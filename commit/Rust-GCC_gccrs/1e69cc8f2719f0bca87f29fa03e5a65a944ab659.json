{"sha": "1e69cc8f2719f0bca87f29fa03e5a65a944ab659", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU2OWNjOGYyNzE5ZjBiY2E4N2YyOWZhMDNlNWE2NWE5NDRhYjY1OQ==", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.vnet.ibm.com", "date": "2017-05-30T10:57:53Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-05-30T10:57:53Z"}, "message": "Vector peeling cost model 3/6\n\ngcc/ChangeLog:\n\n2017-05-30  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n\n\t* tree-vect-data-refs.c (vect_peeling_hash_choose_best_peeling):\n\tReturn peeling info and set costs to zero for unlimited cost\n\tmodel.\n\t(vect_enhance_data_refs_alignment): Also inspect all datarefs\n\twith unknown misalignment. Compute and costs for unknown\n\tmisalignment, compare them to the costs for known misalignment\n\tand choose the cheapest for peeling.\n\nFrom-SVN: r248677", "tree": {"sha": "dced5815ebf536faed331c80e48745dc30020c6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dced5815ebf536faed331c80e48745dc30020c6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e69cc8f2719f0bca87f29fa03e5a65a944ab659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e69cc8f2719f0bca87f29fa03e5a65a944ab659", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e69cc8f2719f0bca87f29fa03e5a65a944ab659", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e69cc8f2719f0bca87f29fa03e5a65a944ab659/comments", "author": {"login": "rdapp1", "id": 22046046, "node_id": "MDQ6VXNlcjIyMDQ2MDQ2", "avatar_url": "https://avatars.githubusercontent.com/u/22046046?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp1", "html_url": "https://github.com/rdapp1", "followers_url": "https://api.github.com/users/rdapp1/followers", "following_url": "https://api.github.com/users/rdapp1/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp1/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp1/subscriptions", "organizations_url": "https://api.github.com/users/rdapp1/orgs", "repos_url": "https://api.github.com/users/rdapp1/repos", "events_url": "https://api.github.com/users/rdapp1/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "71595748a3b193518a6bfb3578e9ff1aa813620f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71595748a3b193518a6bfb3578e9ff1aa813620f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71595748a3b193518a6bfb3578e9ff1aa813620f"}], "stats": {"total": 208, "additions": 111, "deletions": 97}, "files": [{"sha": "a5af5a442032e12e647f1bf38d50a19e629739fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e69cc8f2719f0bca87f29fa03e5a65a944ab659/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e69cc8f2719f0bca87f29fa03e5a65a944ab659/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e69cc8f2719f0bca87f29fa03e5a65a944ab659", "patch": "@@ -1,3 +1,13 @@\n+2017-05-30  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n+\n+\t* tree-vect-data-refs.c (vect_peeling_hash_choose_best_peeling):\n+\tReturn peeling info and set costs to zero for unlimited cost\n+\tmodel.\n+\t(vect_enhance_data_refs_alignment): Also inspect all datarefs\n+\twith unknown misalignment. Compute and costs for unknown\n+\tmisalignment, compare them to the costs for known misalignment\n+\tand choose the cheapest for peeling.\n+\n 2017-05-30  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n \n \t* tree-vect-data-refs.c (vect_update_misalignment_for_peel): Rename."}, {"sha": "1ae71cc6c04517df945bf8badc9e149a6a07791f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 101, "deletions": 97, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e69cc8f2719f0bca87f29fa03e5a65a944ab659/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e69cc8f2719f0bca87f29fa03e5a65a944ab659/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=1e69cc8f2719f0bca87f29fa03e5a65a944ab659", "patch": "@@ -1342,7 +1342,7 @@ vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,\n    choosing an option with the lowest cost (if cost model is enabled) or the\n    option that aligns as many accesses as possible.  */\n \n-static struct data_reference *\n+static struct _vect_peel_extended_info\n vect_peeling_hash_choose_best_peeling (hash_table<peel_info_hasher> *peeling_htab,\n \t\t\t\t       loop_vec_info loop_vinfo,\n                                        unsigned int *npeel,\n@@ -1365,11 +1365,13 @@ vect_peeling_hash_choose_best_peeling (hash_table<peel_info_hasher> *peeling_hta\n        res.peel_info.count = 0;\n        peeling_htab->traverse <_vect_peel_extended_info *,\n \t   \t\t       vect_peeling_hash_get_most_frequent> (&res);\n+       res.inside_cost = 0;\n+       res.outside_cost = 0;\n      }\n \n    *npeel = res.peel_info.npeel;\n    *body_cost_vec = res.body_cost_vec;\n-   return res.peel_info.dr;\n+   return res;\n }\n \n /* Return true if the new peeling NPEEL is supported.  */\n@@ -1518,14 +1520,16 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   enum dr_alignment_support supportable_dr_alignment;\n   struct data_reference *dr0 = NULL, *first_store = NULL;\n   struct data_reference *dr;\n+  struct data_reference *dr0_known_align = NULL;\n   unsigned int i, j;\n   bool do_peeling = false;\n   bool do_versioning = false;\n   bool stat;\n   gimple *stmt;\n   stmt_vec_info stmt_info;\n   unsigned int npeel = 0;\n-  bool all_misalignments_unknown = true;\n+  bool one_misalignment_known = false;\n+  bool one_misalignment_unknown = false;\n   unsigned int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   unsigned possible_npeel_number = 1;\n   tree vectype;\n@@ -1651,47 +1655,40 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                   npeel_tmp += nelements;\n                 }\n \n-              all_misalignments_unknown = false;\n-              /* Data-ref that was chosen for the case that all the\n-                 misalignments are unknown is not relevant anymore, since we\n-                 have a data-ref with known alignment.  */\n-              dr0 = NULL;\n+\t      one_misalignment_known = true;\n             }\n           else\n             {\n               /* If we don't know any misalignment values, we prefer\n                  peeling for data-ref that has the maximum number of data-refs\n                  with the same alignment, unless the target prefers to align\n                  stores over load.  */\n-              if (all_misalignments_unknown)\n-                {\n-\t\t  unsigned same_align_drs\n-\t\t    = STMT_VINFO_SAME_ALIGN_REFS (stmt_info).length ();\n-                  if (!dr0\n-\t\t      || same_align_drs_max < same_align_drs)\n-                    {\n-                      same_align_drs_max = same_align_drs;\n-                      dr0 = dr;\n-                    }\n-\t\t  /* For data-refs with the same number of related\n-\t\t     accesses prefer the one where the misalign\n-\t\t     computation will be invariant in the outermost loop.  */\n-\t\t  else if (same_align_drs_max == same_align_drs)\n-\t\t    {\n-\t\t      struct loop *ivloop0, *ivloop;\n-\t\t      ivloop0 = outermost_invariant_loop_for_expr\n-\t\t\t  (loop, DR_BASE_ADDRESS (dr0));\n-\t\t      ivloop = outermost_invariant_loop_for_expr\n-\t\t\t  (loop, DR_BASE_ADDRESS (dr));\n-\t\t      if ((ivloop && !ivloop0)\n-\t\t\t  || (ivloop && ivloop0\n-\t\t\t      && flow_loop_nested_p (ivloop, ivloop0)))\n-\t\t\tdr0 = dr;\n-\t\t    }\n+\t      unsigned same_align_drs\n+\t\t= STMT_VINFO_SAME_ALIGN_REFS (stmt_info).length ();\n+\t      if (!dr0\n+\t\t  || same_align_drs_max < same_align_drs)\n+\t\t{\n+\t\t  same_align_drs_max = same_align_drs;\n+\t\t  dr0 = dr;\n+\t\t}\n+\t      /* For data-refs with the same number of related\n+\t\t accesses prefer the one where the misalign\n+\t\t computation will be invariant in the outermost loop.  */\n+\t      else if (same_align_drs_max == same_align_drs)\n+\t\t{\n+\t\t  struct loop *ivloop0, *ivloop;\n+\t\t  ivloop0 = outermost_invariant_loop_for_expr\n+\t\t    (loop, DR_BASE_ADDRESS (dr0));\n+\t\t  ivloop = outermost_invariant_loop_for_expr\n+\t\t    (loop, DR_BASE_ADDRESS (dr));\n+\t\t  if ((ivloop && !ivloop0)\n+\t\t      || (ivloop && ivloop0\n+\t\t\t  && flow_loop_nested_p (ivloop, ivloop0)))\n+\t\t    dr0 = dr;\n+\t\t}\n \n-                  if (!first_store && DR_IS_WRITE (dr))\n-                    first_store = dr;\n-                }\n+\t      if (!first_store && DR_IS_WRITE (dr))\n+\t\tfirst_store = dr;\n \n               /* If there are both known and unknown misaligned accesses in the\n                  loop, we choose peeling amount according to the known\n@@ -1702,6 +1699,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                   if (!first_store && DR_IS_WRITE (dr))\n                     first_store = dr;\n                 }\n+\n+\t      one_misalignment_unknown = true;\n             }\n         }\n       else\n@@ -1722,71 +1721,63 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       || loop->inner)\n     do_peeling = false;\n \n+  unsigned int unknown_align_inside_cost = INT_MAX;\n+  unsigned int unknown_align_outside_cost = INT_MAX;\n+\n   if (do_peeling\n-      && all_misalignments_unknown\n+      && one_misalignment_unknown\n       && vect_supportable_dr_alignment (dr0, false))\n     {\n       /* Check if the target requires to prefer stores over loads, i.e., if\n          misaligned stores are more expensive than misaligned loads (taking\n          drs with same alignment into account).  */\n       if (first_store && DR_IS_READ (dr0))\n         {\n-          unsigned int load_inside_cost = 0, load_outside_cost = 0;\n-          unsigned int store_inside_cost = 0, store_outside_cost = 0;\n-          unsigned int load_inside_penalty = 0, load_outside_penalty = 0;\n-          unsigned int store_inside_penalty = 0, store_outside_penalty = 0;\n+\t  unsigned int load_inside_cost = 0;\n+\t  unsigned int load_outside_cost = 0;\n+\t  unsigned int store_inside_cost = 0;\n+\t  unsigned int store_outside_cost = 0;\n \t  stmt_vector_for_cost dummy;\n \t  dummy.create (2);\n+\t  vect_get_peeling_costs_all_drs (dr0,\n+\t\t\t\t\t  &load_inside_cost,\n+\t\t\t\t\t  &load_outside_cost,\n+\t\t\t\t\t  &dummy, vf / 2, vf);\n+\t  dummy.release ();\n \n-          vect_get_data_access_cost (dr0, &load_inside_cost, &load_outside_cost,\n-\t\t\t\t     &dummy);\n-          vect_get_data_access_cost (first_store, &store_inside_cost,\n-\t\t\t\t     &store_outside_cost, &dummy);\n-\n+\t  dummy.create (2);\n+\t  vect_get_peeling_costs_all_drs (first_store,\n+\t\t\t\t\t  &store_inside_cost,\n+\t\t\t\t\t  &store_outside_cost,\n+\t\t\t\t\t  &dummy, vf / 2, vf);\n \t  dummy.release ();\n \n-          /* Calculate the penalty for leaving FIRST_STORE unaligned (by\n-             aligning the load DR0).  */\n-          load_inside_penalty = store_inside_cost;\n-          load_outside_penalty = store_outside_cost;\n-          for (i = 0;\n-\t       STMT_VINFO_SAME_ALIGN_REFS (vinfo_for_stmt (\n-\t\t\t  DR_STMT (first_store))).iterate (i, &dr);\n-               i++)\n-            if (DR_IS_READ (dr))\n-              {\n-                load_inside_penalty += load_inside_cost;\n-                load_outside_penalty += load_outside_cost;\n-              }\n-            else\n-              {\n-                load_inside_penalty += store_inside_cost;\n-                load_outside_penalty += store_outside_cost;\n-              }\n-\n-          /* Calculate the penalty for leaving DR0 unaligned (by\n-             aligning the FIRST_STORE).  */\n-          store_inside_penalty = load_inside_cost;\n-          store_outside_penalty = load_outside_cost;\n-          for (i = 0;\n-\t       STMT_VINFO_SAME_ALIGN_REFS (vinfo_for_stmt (\n-\t\t      DR_STMT (dr0))).iterate (i, &dr);\n-               i++)\n-            if (DR_IS_READ (dr))\n-              {\n-                store_inside_penalty += load_inside_cost;\n-                store_outside_penalty += load_outside_cost;\n-              }\n-            else\n-              {\n-                store_inside_penalty += store_inside_cost;\n-                store_outside_penalty += store_outside_cost;\n-              }\n-\n-          if (load_inside_penalty > store_inside_penalty\n-              || (load_inside_penalty == store_inside_penalty\n-                  && load_outside_penalty > store_outside_penalty))\n-            dr0 = first_store;\n+          if (load_inside_cost > store_inside_cost\n+              || (load_inside_cost == store_inside_cost\n+\t\t  && load_outside_cost > store_outside_cost))\n+\t    {\n+\t      dr0 = first_store;\n+\t      unknown_align_inside_cost = store_inside_cost;\n+\t      unknown_align_outside_cost = store_outside_cost;\n+\t    }\n+\t  else\n+\t    {\n+\t      unknown_align_inside_cost = load_inside_cost;\n+\t      unknown_align_outside_cost = load_outside_cost;\n+\t    }\n+\n+\t  stmt_vector_for_cost prologue_cost_vec, epilogue_cost_vec;\n+\t  prologue_cost_vec.create (2);\n+\t  epilogue_cost_vec.create (2);\n+\n+\t  int dummy2;\n+\t  unknown_align_outside_cost += vect_get_known_peeling_cost\n+\t    (loop_vinfo, vf / 2, &dummy2,\n+\t     &LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n+\t     &prologue_cost_vec, &epilogue_cost_vec);\n+\n+\t  prologue_cost_vec.release ();\n+\t  epilogue_cost_vec.release ();\n         }\n \n       /* Use peeling only if it may help to align other accesses in the loop or\n@@ -1804,22 +1795,35 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n         do_peeling = false;\n     }\n \n-  if (do_peeling && !dr0)\n+  struct _vect_peel_extended_info peel_for_known_alignment;\n+  peel_for_known_alignment.inside_cost = INT_MAX;\n+  peel_for_known_alignment.outside_cost = INT_MAX;\n+  peel_for_known_alignment.peel_info.count = 0;\n+  peel_for_known_alignment.peel_info.dr = NULL;\n+\n+  if (do_peeling && one_misalignment_known)\n     {\n       /* Peeling is possible, but there is no data access that is not supported\n          unless aligned. So we try to choose the best possible peeling.  */\n \n-      /* We should get here only if there are drs with known misalignment.  */\n-      gcc_assert (!all_misalignments_unknown);\n-\n       /* Choose the best peeling from the hash table.  */\n-      dr0 = vect_peeling_hash_choose_best_peeling (&peeling_htab,\n-\t\t\t\t\t\t   loop_vinfo, &npeel,\n-\t\t\t\t\t\t   &body_cost_vec);\n-      if (!dr0 || !npeel)\n-        do_peeling = false;\n+      peel_for_known_alignment = vect_peeling_hash_choose_best_peeling\n+\t(&peeling_htab, loop_vinfo, &npeel, &body_cost_vec);\n+      dr0_known_align = peel_for_known_alignment.peel_info.dr;\n+    }\n+\n+  /* Compare costs of peeling for known and unknown alignment. */\n+  if (dr0_known_align != NULL\n+      && unknown_align_inside_cost >= peel_for_known_alignment.inside_cost)\n+    {\n+      dr0 = dr0_known_align;\n+      if (!npeel)\n+\tdo_peeling = false;\n     }\n \n+  if (dr0 == NULL)\n+    do_peeling = false;\n+\n   if (do_peeling)\n     {\n       stmt = DR_STMT (dr0);"}]}