{"sha": "8b198102220210ef6a61477d9a45564c206ee6b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIxOTgxMDIyMjAyMTBlZjZhNjE0NzdkOWE0NTU2NGMyMDZlZTZiNQ==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2014-06-28T14:17:41Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2014-06-28T14:17:41Z"}, "message": "re PR fortran/29383 (Fortran 2003/F95[TR15580:1999]: Floating point exception (IEEE) support)\n\n\tPR fortran/29383\n\ngcc/fortran/\n\t* gfortran.h (gfc_simplify_ieee_selected_real_kind): New prototype.\n\t* libgfortran.h (GFC_FPE_*): Use simple integer values, valid in\n\tboth C and Fortran.\n\t* expr.c (gfc_check_init_expr): Simplify IEEE_SELECTED_REAL_KIND.\n\t* simplify.c (gfc_simplify_ieee_selected_real_kind): New function.\n\t* module.c (mio_symbol): Keep track of symbols which came from\n\tintrinsic modules.\n\t(gfc_use_module): Keep track of the IEEE modules.\n\t* trans-decl.c (gfc_get_symbol_decl): Adjust code since\n\twe have new intrinsic modules.\n\t(gfc_build_builtin_function_decls): Build decls for\n\tieee_procedure_entry and ieee_procedure_exit.\n\t(is_from_ieee_module, is_ieee_module_used, save_fp_state,\n\trestore_fp_state): New functions.\n\t(gfc_generate_function_code): Save and restore floating-point\n\tstate on procedure entry/exit, when IEEE modules are used.\n\t* intrinsic.texi: Document the IEEE modules.\n\nlibgfortran/\n\t* configure.host: Add checks for IEEE support, rework priorities.\n\t* configure.ac: Define IEEE_SUPPORT, check for fpsetsticky and\n\tfpresetsticky.\n\t* configure: Regenerate.\n\t* Makefile.am: Build new ieee files, install IEEE_* modules.\n\t* Makefile.in: Regenerate.\n\t* gfortran.map (GFORTRAN_1.6): Add new symbols.\n\t* libgfortran.h (get_fpu_trap_exceptions, set_fpu_trap_exceptions,\n\tsupport_fpu_trap, set_fpu_except_flags, support_fpu_flag,\n\tsupport_fpu_rounding_mode, get_fpu_state, set_fpu_state): New\n\tprototypes.\n\t* config/fpu-*.h (get_fpu_trap_exceptions,\n\tset_fpu_trap_exceptions, support_fpu_trap, set_fpu_except_flags,\n\tsupport_fpu_flag, support_fpu_rounding_mode, get_fpu_state,\n\tset_fpu_state): New functions.\n\t* ieee/ieee_features.F90: New file.\n\t* ieee/ieee_exceptions.F90: New file.\n\t* ieee/ieee_arithmetic.F90: New file.\n\t* ieee/ieee_helper.c: New file.\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_fortran_ieee): \n\tNew function.\n\t* gfortran.dg/ieee/ieee.exp: New file.\n\t* gfortran.dg/ieee/ieee_1.F90: New file.\n\t* gfortran.dg/ieee/ieee_2.f90: New file.\n\t* gfortran.dg/ieee/ieee_3.f90: New file.\n\t* gfortran.dg/ieee/ieee_4.f90: New file.\n\t* gfortran.dg/ieee/ieee_5.f90: New file.\n\t* gfortran.dg/ieee/ieee_6.f90: New file.\n\t* gfortran.dg/ieee/ieee_7.f90: New file.\n\t* gfortran.dg/ieee/ieee_rounding_1.f90: New file.\n\nFrom-SVN: r212102", "tree": {"sha": "e7bff5fef45c93b6d9ac36021ec9edaa569bf861", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7bff5fef45c93b6d9ac36021ec9edaa569bf861"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b198102220210ef6a61477d9a45564c206ee6b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b198102220210ef6a61477d9a45564c206ee6b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b198102220210ef6a61477d9a45564c206ee6b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b198102220210ef6a61477d9a45564c206ee6b5/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a86471635f38376128e6cea8d6856f025a57b4c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a86471635f38376128e6cea8d6856f025a57b4c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a86471635f38376128e6cea8d6856f025a57b4c2"}], "stats": {"total": 4730, "additions": 4524, "deletions": 206}, "files": [{"sha": "a5f6f9d529dee15d2da25ef964449a4a56948835", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -1,3 +1,24 @@\n+2014-06-28  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/29383\n+\t* gfortran.h (gfc_simplify_ieee_selected_real_kind): New prototype.\n+\t* libgfortran.h (GFC_FPE_*): Use simple integer values, valid in\n+\tboth C and Fortran.\n+\t* expr.c (gfc_check_init_expr): Simplify IEEE_SELECTED_REAL_KIND.\n+\t* simplify.c (gfc_simplify_ieee_selected_real_kind): New function.\n+\t* module.c (mio_symbol): Keep track of symbols which came from\n+\tintrinsic modules.\n+\t(gfc_use_module): Keep track of the IEEE modules.\n+\t* trans-decl.c (gfc_get_symbol_decl): Adjust code since\n+\twe have new intrinsic modules.\n+\t(gfc_build_builtin_function_decls): Build decls for\n+\tieee_procedure_entry and ieee_procedure_exit.\n+\t(is_from_ieee_module, is_ieee_module_used, save_fp_state,\n+\trestore_fp_state): New functions.\n+\t(gfc_generate_function_code): Save and restore floating-point\n+\tstate on procedure entry/exit, when IEEE modules are used.\n+\t* intrinsic.texi: Document the IEEE modules.\n+\n 2014-06-25  Tobias Burnus  <burnus@net-b.de>\n \n \t* interface.c (check_intents): Fix diagnostic with"}, {"sha": "3e3a664b108c17669567d2dd85bab3a729319cb9", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -2460,9 +2460,23 @@ gfc_check_init_expr (gfc_expr *e)\n \n       {\n \tgfc_intrinsic_sym* isym;\n-\tgfc_symbol* sym;\n+\tgfc_symbol* sym = e->symtree->n.sym;\n+\n+\t/* Special case for IEEE_SELECTED_REAL_KIND from the intrinsic\n+\t   module IEEE_ARITHMETIC, which is allowed in initialization\n+\t   expressions.  */\n+\tif (!strcmp(sym->name, \"ieee_selected_real_kind\")\n+\t    && sym->from_intmod == INTMOD_IEEE_ARITHMETIC)\n+\t  {\n+\t    gfc_expr *new_expr = gfc_simplify_ieee_selected_real_kind (e);\n+\t    if (new_expr)\n+\t      {\n+\t\tgfc_replace_expr (e, new_expr);\n+\t\tt = true;\n+\t\tbreak;\n+\t      }\n+\t  }\n \n-\tsym = e->symtree->n.sym;\n \tif (!gfc_is_intrinsic (sym, 0, e->where)\n \t    || (m = gfc_intrinsic_func_interface (e, 0)) != MATCH_YES)\n \t  {"}, {"sha": "3481319230ef2026af405711eb8f836d2a999a0c", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -678,7 +678,8 @@ iso_c_binding_symbol;\n \n typedef enum\n {\n-  INTMOD_NONE = 0, INTMOD_ISO_FORTRAN_ENV, INTMOD_ISO_C_BINDING\n+  INTMOD_NONE = 0, INTMOD_ISO_FORTRAN_ENV, INTMOD_ISO_C_BINDING,\n+  INTMOD_IEEE_FEATURES, INTMOD_IEEE_EXCEPTIONS, INTMOD_IEEE_ARITHMETIC\n }\n intmod_id;\n \n@@ -2870,6 +2871,8 @@ gfc_formal_arglist *gfc_sym_get_dummy_args (gfc_symbol *);\n /* intrinsic.c -- true if working in an init-expr, false otherwise.  */\n extern bool gfc_init_expr_flag;\n \n+gfc_expr *gfc_simplify_ieee_selected_real_kind (gfc_expr *);\n+\n /* Given a symbol that we have decided is intrinsic, mark it as such\n    by placing it into a special module that is otherwise impossible to\n    read or write.  */"}, {"sha": "87f6478f5328f73d954da636855072f0a13d7ad7", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -13155,6 +13155,7 @@ Fortran 95 elemental function: @ref{IEOR}\n @menu\n * ISO_FORTRAN_ENV::\n * ISO_C_BINDING::\n+* IEEE modules::\n * OpenMP Modules OMP_LIB and OMP_LIB_KINDS::\n @end menu\n \n@@ -13366,6 +13367,35 @@ Moreover, the following two named constants are defined:\n \n Both are equivalent to the value @code{NULL} in C.\n \n+\n+\n+@node IEEE modules\n+@section IEEE modules: @code{IEEE_EXCEPTIONS}, @code{IEEE_ARITHMETIC}, and @code{IEEE_FEATURES}\n+@table @asis\n+@item @emph{Standard}:\n+Fortran 2003 and later\n+@end table\n+\n+The @code{IEEE_EXCEPTIONS}, @code{IEEE_ARITHMETIC}, and @code{IEEE_FEATURES}\n+intrinsic modules provide support for exceptions and IEEE arithmetic, as\n+defined in Fortran 2003 and later standards, and the IEC 60559:1989 standard\n+(@emph{Binary floating-point arithmetic for microprocessor systems}). These\n+modules are only provided on the following supported platforms:\n+\n+@itemize @bullet\n+@item i386 and x86_64 processors\n+@item platforms which use the GNU C Library (glibc)\n+@item platforms with support for SysV/386 routines for floating point\n+interface (including Solaris and BSDs)\n+@item platforms with the AIX OS\n+@end itemize\n+\n+For full compliance with the Fortran standards, code using the\n+@code{IEEE_EXCEPTIONS} or @code{IEEE_ARITHMETIC} modules should be compiled\n+with the following options: @code{-fno-unsafe-math-optimizations\n+-frounding-math -fsignaling-nans}.\n+\n+\n @node OpenMP Modules OMP_LIB and OMP_LIB_KINDS\n @section OpenMP Modules @code{OMP_LIB} and @code{OMP_LIB_KINDS}\n @table @asis"}, {"sha": "1f8616f0ab983505c0d0732274a85bf8b9c955d9", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -35,20 +35,25 @@ along with GCC; see the file COPYING3.  If not see\n \t\t\t\t\t   obsolescent in later standards.  */\n \n \n-/* Bitmasks for the various FPE that can be enabled.  */\n-#define GFC_FPE_INVALID    (1<<0)\n-#define GFC_FPE_DENORMAL   (1<<1)\n-#define GFC_FPE_ZERO       (1<<2)\n-#define GFC_FPE_OVERFLOW   (1<<3)\n-#define GFC_FPE_UNDERFLOW  (1<<4)\n-#define GFC_FPE_INEXACT    (1<<5)\n+/* Bitmasks for the various FPE that can be enabled.  These need to be straight integers\n+   e.g., 8 instead of (1<<3), because they will be included in Fortran source.  */\n+#define GFC_FPE_INVALID      1\n+#define GFC_FPE_DENORMAL     2\n+#define GFC_FPE_ZERO         4\n+#define GFC_FPE_OVERFLOW     8\n+#define GFC_FPE_UNDERFLOW   16\n+#define GFC_FPE_INEXACT     32\n \n /* Defines for floating-point rounding modes.  */\n #define GFC_FPE_DOWNWARD   1\n #define GFC_FPE_TONEAREST  2\n #define GFC_FPE_TOWARDZERO 3\n #define GFC_FPE_UPWARD     4\n \n+/* Size of the buffer required to store FPU state for any target.\n+   In particular, this has to be larger than fenv_t on all glibc targets.\n+   Currently, the winner is x86_64 with 32 bytes.  */\n+#define GFC_FPE_STATE_BUFFER_SIZE 32\n \n /* Bitmasks for the various runtime checks that can be enabled.  */\n #define GFC_RTCHECK_BOUNDS      (1<<0)"}, {"sha": "bd7da1c37df5c961ab1a00d2f1d9fa7b7ef4b6c5", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -190,6 +190,9 @@ static gzFile module_fp;\n static const char *module_name;\n static gfc_use_list *module_list;\n \n+/* If we're reading an intrinsic module, this is its ID.  */\n+static intmod_id current_intmod;\n+\n /* Content of module.  */\n static char* module_content;\n \n@@ -4096,7 +4099,10 @@ mio_symbol (gfc_symbol *sym)\n   else\n     {\n       mio_integer (&intmod);\n-      sym->from_intmod = (intmod_id) intmod;\n+      if (current_intmod)\n+\tsym->from_intmod = current_intmod;\n+      else\n+\tsym->from_intmod = (intmod_id) intmod;\n     }\n   \n   mio_integer (&(sym->intmod_sym_id));\n@@ -6733,6 +6739,7 @@ gfc_use_module (gfc_use_list *module)\n   module_name = module->module_name;\n   gfc_rename_list = module->rename;\n   only_flag = module->only_flag;\n+  current_intmod = INTMOD_NONE;\n \n   filename = XALLOCAVEC (char, strlen (module_name) + strlen (MODULE_EXTENSION)\n \t\t\t       + 1);\n@@ -6777,6 +6784,26 @@ gfc_use_module (gfc_use_list *module)\n       if (module_fp == NULL && module->intrinsic)\n \tgfc_fatal_error (\"Can't find an intrinsic module named '%s' at %C\",\n \t\t\t module_name);\n+\n+      /* Check for the IEEE modules, so we can mark their symbols\n+\t accordingly when we read them.  */\n+      if (strcmp (module_name, \"ieee_features\") == 0\n+\t  && gfc_notify_std (GFC_STD_F2003, \"IEEE_FEATURES module at %C\"))\n+\t{\n+\t  current_intmod = INTMOD_IEEE_FEATURES;\n+\t}\n+      else if (strcmp (module_name, \"ieee_exceptions\") == 0\n+\t       && gfc_notify_std (GFC_STD_F2003,\n+\t\t\t\t  \"IEEE_EXCEPTIONS module at %C\"))\n+\t{\n+\t  current_intmod = INTMOD_IEEE_EXCEPTIONS;\n+\t}\n+      else if (strcmp (module_name, \"ieee_arithmetic\") == 0\n+\t       && gfc_notify_std (GFC_STD_F2003,\n+\t\t\t\t  \"IEEE_ARITHMETIC module at %C\"))\n+\t{\n+\t  current_intmod = INTMOD_IEEE_ARITHMETIC;\n+\t}\n     }\n \n   if (module_fp == NULL)"}, {"sha": "60d85934b72d62366710db047d9dcfbb71d7171b", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -5460,12 +5460,13 @@ gfc_simplify_selected_real_kind (gfc_expr *p, gfc_expr *q, gfc_expr *rdx)\n       if (gfc_real_kinds[i].range >= range)\n \tfound_range = 1;\n \n-      if (gfc_real_kinds[i].radix >= radix)\n+      if (radix == 0 || gfc_real_kinds[i].radix == radix)\n \tfound_radix = 1;\n \n       if (gfc_real_kinds[i].precision >= precision\n \t  && gfc_real_kinds[i].range >= range\n-\t  && gfc_real_kinds[i].radix >= radix && gfc_real_kinds[i].kind < kind)\n+\t  && (radix == 0 || gfc_real_kinds[i].radix == radix)\n+\t  && gfc_real_kinds[i].kind < kind)\n \tkind = gfc_real_kinds[i].kind;\n     }\n \n@@ -5487,6 +5488,87 @@ gfc_simplify_selected_real_kind (gfc_expr *p, gfc_expr *q, gfc_expr *rdx)\n }\n \n \n+gfc_expr *\n+gfc_simplify_ieee_selected_real_kind (gfc_expr *expr)\n+{\n+  gfc_actual_arglist *arg = expr->value.function.actual;\n+  gfc_expr *p = arg->expr, *r = arg->next->expr,\n+\t   *rad = arg->next->next->expr;\n+  int precision, range, radix, res;\n+  int found_precision, found_range, found_radix, i;\n+\n+  if (p)\n+  {\n+    if (p->expr_type != EXPR_CONSTANT\n+\t|| gfc_extract_int (p, &precision) != NULL)\n+      return NULL;\n+  }\n+  else\n+    precision = 0;\n+\n+  if (r)\n+  {\n+    if (r->expr_type != EXPR_CONSTANT\n+\t|| gfc_extract_int (r, &range) != NULL)\n+      return NULL;\n+  }\n+  else\n+    range = 0;\n+\n+  if (rad)\n+  {\n+    if (rad->expr_type != EXPR_CONSTANT\n+\t|| gfc_extract_int (rad, &radix) != NULL)\n+      return NULL;\n+  }\n+  else\n+    radix = 0;\n+\n+  res = INT_MAX;\n+  found_precision = 0;\n+  found_range = 0;\n+  found_radix = 0;\n+\n+  for (i = 0; gfc_real_kinds[i].kind != 0; i++)\n+    {\n+      /* We only support the target's float and double types.  */\n+      if (!gfc_real_kinds[i].c_float && !gfc_real_kinds[i].c_double)\n+\tcontinue;\n+\n+      if (gfc_real_kinds[i].precision >= precision)\n+\tfound_precision = 1;\n+\n+      if (gfc_real_kinds[i].range >= range)\n+\tfound_range = 1;\n+\n+      if (radix == 0 || gfc_real_kinds[i].radix == radix)\n+\tfound_radix = 1;\n+\n+      if (gfc_real_kinds[i].precision >= precision\n+\t  && gfc_real_kinds[i].range >= range\n+\t  && (radix == 0 || gfc_real_kinds[i].radix == radix)\n+\t  && gfc_real_kinds[i].kind < res)\n+\tres = gfc_real_kinds[i].kind;\n+    }\n+\n+  if (res == INT_MAX)\n+    {\n+      if (found_radix && found_range && !found_precision)\n+\tres = -1;\n+      else if (found_radix && found_precision && !found_range)\n+\tres = -2;\n+      else if (found_radix && !found_precision && !found_range)\n+\tres = -3;\n+      else if (found_radix)\n+\tres = -4;\n+      else\n+\tres = -5;\n+    }\n+\n+  return gfc_get_int_expr (gfc_default_integer_kind, &expr->where, res);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_set_exponent (gfc_expr *x, gfc_expr *i)\n {"}, {"sha": "cbcd52dc87f9334695dee13dd76d7fae2feb7f7b", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 77, "deletions": 3, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -90,6 +90,9 @@ static stmtblock_t caf_init_block;\n tree gfc_static_ctors;\n \n \n+/* Whether we've seen a symbol from an IEEE module in the namespace.  */\n+static int seen_ieee_symbol;\n+\n /* Function declarations for builtin library functions.  */\n \n tree gfor_fndecl_pause_numeric;\n@@ -118,6 +121,8 @@ tree gfor_fndecl_in_unpack;\n tree gfor_fndecl_associated;\n tree gfor_fndecl_system_clock4;\n tree gfor_fndecl_system_clock8;\n+tree gfor_fndecl_ieee_procedure_entry;\n+tree gfor_fndecl_ieee_procedure_exit;\n \n \n /* Coarray run-time library function decls.  */\n@@ -1376,8 +1381,9 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \n   /* Special case for array-valued named constants from intrinsic\n      procedures; those are inlined.  */\n-  if (sym->attr.use_assoc && sym->from_intmod\n-      && sym->attr.flavor == FL_PARAMETER)\n+  if (sym->attr.use_assoc && sym->attr.flavor == FL_PARAMETER\n+      && (sym->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t  || sym->from_intmod == INTMOD_ISO_C_BINDING))\n     intrinsic_array_parameter = true;\n \n   /* If use associated compilation, use the module\n@@ -3269,6 +3275,14 @@ gfc_build_builtin_function_decls (void)\n \tget_identifier (PREFIX(\"set_fpe\")),\n \tvoid_type_node, 1, integer_type_node);\n \n+  gfor_fndecl_ieee_procedure_entry = gfc_build_library_function_decl (\n+\tget_identifier (PREFIX(\"ieee_procedure_entry\")),\n+\tvoid_type_node, 1, pvoid_type_node);\n+\n+  gfor_fndecl_ieee_procedure_exit = gfc_build_library_function_decl (\n+\tget_identifier (PREFIX(\"ieee_procedure_exit\")),\n+\tvoid_type_node, 1, pvoid_type_node);\n+\n   /* Keep the array dimension in sync with the call, later in this file.  */\n   gfor_fndecl_set_options = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"set_options\")), \"..R\",\n@@ -5530,6 +5544,55 @@ gfc_generate_return (void)\n }\n \n \n+static void\n+is_from_ieee_module (gfc_symbol *sym)\n+{\n+  if (sym->from_intmod == INTMOD_IEEE_FEATURES\n+      || sym->from_intmod == INTMOD_IEEE_EXCEPTIONS\n+      || sym->from_intmod == INTMOD_IEEE_ARITHMETIC)\n+    seen_ieee_symbol = 1;\n+}\n+\n+\n+static int\n+is_ieee_module_used (gfc_namespace *ns)\n+{\n+  seen_ieee_symbol = 0;\n+  gfc_traverse_ns (ns, is_from_ieee_module);\n+  return seen_ieee_symbol;\n+}\n+\n+\n+static tree\n+save_fp_state (stmtblock_t *block)\n+{\n+  tree type, fpstate, tmp;\n+\n+  type = build_array_type (char_type_node,\n+\t                   build_range_type (size_type_node, size_zero_node,\n+\t\t\t\t\t     size_int (32)));\n+  fpstate = gfc_create_var (type, \"fpstate\");\n+  fpstate = gfc_build_addr_expr (pvoid_type_node, fpstate);\n+\n+  tmp = build_call_expr_loc (input_location, gfor_fndecl_ieee_procedure_entry,\n+\t\t\t     1, fpstate);\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  return fpstate;\n+}\n+\n+\n+static void\n+restore_fp_state (stmtblock_t *block, tree fpstate)\n+{\n+  tree tmp;\n+\n+  tmp = build_call_expr_loc (input_location, gfor_fndecl_ieee_procedure_exit,\n+\t\t\t     1, fpstate);\n+  gfc_add_expr_to_block (block, tmp);\n+}\n+\n+\n /* Generate code for a function.  */\n \n void\n@@ -5539,13 +5602,14 @@ gfc_generate_function_code (gfc_namespace * ns)\n   tree old_context;\n   tree decl;\n   tree tmp;\n+  tree fpstate = NULL_TREE;\n   stmtblock_t init, cleanup;\n   stmtblock_t body;\n   gfc_wrapped_block try_block;\n   tree recurcheckvar = NULL_TREE;\n   gfc_symbol *sym;\n   gfc_symbol *previous_procedure_symbol;\n-  int rank;\n+  int rank, ieee;\n   bool is_recursive;\n \n   sym = ns->proc_name;\n@@ -5636,6 +5700,12 @@ gfc_generate_function_code (gfc_namespace * ns)\n       free (msg);\n     }\n \n+  /* Check if an IEEE module is used in the procedure.  If so, save\n+     the floating point state.  */\n+  ieee = is_ieee_module_used (ns);\n+  if (ieee)\n+    fpstate = save_fp_state (&init);\n+\n   /* Now generate the code for the body of this function.  */\n   gfc_init_block (&body);\n \n@@ -5719,6 +5789,10 @@ gfc_generate_function_code (gfc_namespace * ns)\n       recurcheckvar = NULL;\n     }\n \n+  /* If IEEE modules are loaded, restore the floating-point state.  */\n+  if (ieee)\n+    restore_fp_state (&cleanup, fpstate);\n+\n   /* Finish the function body and add init and cleanup code.  */\n   tmp = gfc_finish_block (&body);\n   gfc_start_wrapped_block (&try_block, tmp);"}, {"sha": "739e0aa0178f3e9fdf3673e225128ed169570eb1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -1,3 +1,18 @@\n+2014-06-28  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/29383\n+\t* lib/target-supports.exp (check_effective_target_fortran_ieee): \n+\tNew function.\n+\t* gfortran.dg/ieee/ieee.exp: New file.\n+\t* gfortran.dg/ieee/ieee_1.F90: New file.\n+\t* gfortran.dg/ieee/ieee_2.f90: New file.\n+\t* gfortran.dg/ieee/ieee_3.f90: New file.\n+\t* gfortran.dg/ieee/ieee_4.f90: New file.\n+\t* gfortran.dg/ieee/ieee_5.f90: New file.\n+\t* gfortran.dg/ieee/ieee_6.f90: New file.\n+\t* gfortran.dg/ieee/ieee_7.f90: New file.\n+\t* gfortran.dg/ieee/ieee_rounding_1.f90: New file.\n+\n 2014-06-28  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* g++.dg/cpp0x/elision_conv.C: New."}, {"sha": "77e63b71e518948ab5f7144e787eedf41e312533", "filename": "gcc/testsuite/gfortran.dg/ieee/ieee.exp", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee.exp?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,59 @@\n+# Copyright (C) 2013 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gfortran-dg.exp\n+load_lib target-supports.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Flags specified in each test\n+global DEFAULT_FFLAGS\n+if ![info exists DEFAULT_FFLAGS] then {\n+    set DEFAULT_FFLAGS \"\"\n+}\n+\n+# Flags for finding the IEEE modules\n+if [info exists TOOL_OPTIONS] {\n+   set specpath [get_multilibs ${TOOL_OPTIONS}]\n+} else {\n+   set specpath [get_multilibs]\n+}\n+set options \"-fintrinsic-modules-path $specpath/libgfortran/\"\n+\n+# Bail out if IEEE tests are not supported at all\n+if ![check_effective_target_fortran_ieee $options ] {\n+ return\n+}\n+\n+# Add target-independent options to require IEEE compatibility\n+set options \"$DEFAULT_FFLAGS $options -fno-unsafe-math-optimizations -frounding-math -fsignaling-nans\"\n+\n+# Add target-specific options to require IEEE compatibility\n+set target_options [add_options_for_ieee \"\"]\n+set options \"$options $target_options\"\n+\n+# Main loop.\n+gfortran-dg-runtest [lsort \\\n+      [find $srcdir/$subdir *.\\[fF\\]{,90,95,03,08} ] ] $options\n+\n+# All done.\n+dg-finish"}, {"sha": "9c1c4e374d4b4ff09720ce733f2dcc3636ba0b51", "filename": "gcc/testsuite/gfortran.dg/ieee/ieee_1.F90", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_1.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_1.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_1.F90?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,174 @@\n+! { dg-do run }\n+! { dg-additional-options \"-ffree-line-length-none -O0\" }\n+!\n+! Use dg-additional-options rather than dg-options to avoid overwriting the\n+! default IEEE options which are passed by ieee.exp and necessary.\n+\n+  use ieee_features, only : ieee_datatype, ieee_denormal, ieee_divide, &\n+      ieee_halting, ieee_inexact_flag, ieee_inf, ieee_invalid_flag, &\n+      ieee_nan, ieee_rounding, ieee_sqrt, ieee_underflow_flag\n+  use ieee_exceptions\n+\n+  implicit none\n+\n+  interface use_real\n+    procedure use_real_4, use_real_8\n+  end interface use_real\n+\n+  type(ieee_flag_type), parameter :: x(5) = &\n+    [ IEEE_INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, &\n+      IEEE_UNDERFLOW, IEEE_INEXACT ]\n+  logical :: l(5) = .false.\n+  character(len=5) :: s\n+\n+#define FLAGS_STRING(S) \\\n+  call ieee_get_flag(x, l) ; \\\n+  write(S,\"(5(A1))\") merge([\"I\",\"O\",\"Z\",\"U\",\"P\"],[\" \",\" \",\" \",\" \",\" \"],l)\n+\n+#define CHECK_FLAGS(expected) \\\n+  FLAGS_STRING(s) ; \\\n+  if (s /= expected) then ; \\\n+    write (*,\"(A,I0,A,A)\") \"Flags at line \", __LINE__, \": \", s ; \\\n+    call abort ; \\\n+  end if ; \\\n+  call check_flag_sub\n+\n+  real :: sx\n+  double precision :: dx\n+\n+  ! This file tests IEEE_SET_FLAG and IEEE_GET_FLAG\n+\n+  !!!! IEEE float\n+\n+  ! Initial flags are all off\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Check we can clear them\n+  call ieee_set_flag(ieee_all, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Raise invalid, then clear\n+  sx = -1\n+  call use_real(sx)\n+  sx = sqrt(sx)\n+  call use_real(sx)\n+  CHECK_FLAGS(\"I    \")\n+  call ieee_set_flag(ieee_all, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Raise overflow and precision\n+  sx = huge(sx)\n+  CHECK_FLAGS(\"     \")\n+  sx = sx*sx\n+  CHECK_FLAGS(\" O  P\")\n+  call use_real(sx)\n+\n+  ! Also raise divide-by-zero\n+  sx = 0\n+  sx = 1 / sx\n+  CHECK_FLAGS(\" OZ P\")\n+  call use_real(sx)\n+\n+  ! Clear them\n+  call ieee_set_flag([ieee_overflow,ieee_inexact,&\n+                      ieee_divide_by_zero],[.false.,.false.,.true.])\n+  CHECK_FLAGS(\"  Z  \")\n+  call ieee_set_flag(ieee_divide_by_zero, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Raise underflow\n+  sx = tiny(sx)\n+  CHECK_FLAGS(\"     \")\n+  sx = sx / 10\n+  call use_real(sx)\n+  CHECK_FLAGS(\"   UP\")\n+\n+  ! Raise everything\n+  call ieee_set_flag(ieee_all, .true.)\n+  CHECK_FLAGS(\"IOZUP\")\n+\n+  ! And clear\n+  call ieee_set_flag(ieee_all, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  !!!! IEEE double\n+\n+  ! Initial flags are all off\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Check we can clear them\n+  call ieee_set_flag(ieee_all, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Raise invalid, then clear\n+  dx = -1\n+  call use_real(dx)\n+  dx = sqrt(dx)\n+  call use_real(dx)\n+  CHECK_FLAGS(\"I    \")\n+  call ieee_set_flag(ieee_all, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Raise overflow and precision\n+  dx = huge(dx)\n+  CHECK_FLAGS(\"     \")\n+  dx = dx*dx\n+  CHECK_FLAGS(\" O  P\")\n+  call use_real(dx)\n+\n+  ! Also raise divide-by-zero\n+  dx = 0\n+  dx = 1 / dx\n+  CHECK_FLAGS(\" OZ P\")\n+  call use_real(dx)\n+\n+  ! Clear them\n+  call ieee_set_flag([ieee_overflow,ieee_inexact,&\n+                      ieee_divide_by_zero],[.false.,.false.,.true.])\n+  CHECK_FLAGS(\"  Z  \")\n+  call ieee_set_flag(ieee_divide_by_zero, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Raise underflow\n+  dx = tiny(dx)\n+  CHECK_FLAGS(\"     \")\n+  dx = dx / 10\n+  CHECK_FLAGS(\"   UP\")\n+  call use_real(dx)\n+\n+  ! Raise everything\n+  call ieee_set_flag(ieee_all, .true.)\n+  CHECK_FLAGS(\"IOZUP\")\n+\n+  ! And clear\n+  call ieee_set_flag(ieee_all, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+contains\n+\n+  subroutine check_flag_sub\n+    use ieee_exceptions\n+    logical :: l(5) = .false.\n+    type(ieee_flag_type), parameter :: x(5) = &\n+      [ IEEE_INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, &\n+        IEEE_UNDERFLOW, IEEE_INEXACT ]\n+    call ieee_get_flag(x, l)\n+\n+    if (any(l)) then\n+      print *, \"Flags not cleared in subroutine\"\n+      call abort\n+    end if\n+  end subroutine\n+\n+  ! Interface to a routine that avoids calculations to be optimized out,\n+  ! making it appear that we use the result\n+  subroutine use_real_4(x)\n+    real :: x\n+    if (x == 123456.789) print *, \"toto\"\n+  end subroutine\n+  subroutine use_real_8(x)\n+    double precision :: x\n+    if (x == 123456.789) print *, \"toto\"\n+  end subroutine\n+\n+end"}, {"sha": "b138061254f26fe7683e184ed7341cb609fa09b9", "filename": "gcc/testsuite/gfortran.dg/ieee/ieee_2.f90", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_2.f90?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,413 @@\n+! { dg-do run }\n+\n+  use, intrinsic :: ieee_features\n+  use, intrinsic :: ieee_exceptions\n+  use, intrinsic :: ieee_arithmetic\n+  implicit none\n+\n+  interface check_equal\n+    procedure check_equal_float, check_equal_double\n+  end interface\n+\n+  interface check_not_equal\n+    procedure check_not_equal_float, check_not_equal_double\n+  end interface\n+\n+  real :: sx1, sx2, sx3\n+  double precision :: dx1, dx2, dx3\n+  type(ieee_round_type) :: mode\n+\n+  ! Test IEEE_COPY_SIGN\n+  sx1 = 1.3\n+  if (ieee_copy_sign(sx1, sx1) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -sx1) /= -sx1) call abort\n+  if (ieee_copy_sign(sx1, 1.) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -1.) /= -sx1) call abort\n+  sx1 = huge(sx1)\n+  if (ieee_copy_sign(sx1, sx1) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -sx1) /= -sx1) call abort\n+  if (ieee_copy_sign(sx1, 1.) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -1.) /= -sx1) call abort\n+  sx1 = ieee_value(sx1, ieee_positive_inf)\n+  if (ieee_copy_sign(sx1, sx1) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -sx1) /= -sx1) call abort\n+  if (ieee_copy_sign(sx1, 1.) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -1.) /= -sx1) call abort\n+  sx1 = tiny(sx1)\n+  if (ieee_copy_sign(sx1, sx1) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -sx1) /= -sx1) call abort\n+  if (ieee_copy_sign(sx1, 1.) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -1.) /= -sx1) call abort\n+  sx1 = tiny(sx1)\n+  sx1 = sx1 / 101\n+  if (ieee_copy_sign(sx1, sx1) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -sx1) /= -sx1) call abort\n+  if (ieee_copy_sign(sx1, 1.) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -1.) /= -sx1) call abort\n+\n+  sx1 = -1.3\n+  if (ieee_copy_sign(sx1, sx1) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -sx1) /= -sx1) call abort\n+  if (ieee_copy_sign(sx1, 1.) /= abs(sx1)) call abort\n+  if (ieee_copy_sign(sx1, -1.) /= -abs(sx1)) call abort\n+  sx1 = -huge(sx1)\n+  if (ieee_copy_sign(sx1, sx1) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -sx1) /= -sx1) call abort\n+  if (ieee_copy_sign(sx1, 1.) /= abs(sx1)) call abort\n+  if (ieee_copy_sign(sx1, -1.) /= -abs(sx1)) call abort\n+  sx1 = ieee_value(sx1, ieee_negative_inf)\n+  if (ieee_copy_sign(sx1, sx1) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -sx1) /= -sx1) call abort\n+  if (ieee_copy_sign(sx1, 1.) /= abs(sx1)) call abort\n+  if (ieee_copy_sign(sx1, -1.) /= -abs(sx1)) call abort\n+  sx1 = -tiny(sx1)\n+  if (ieee_copy_sign(sx1, sx1) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -sx1) /= -sx1) call abort\n+  if (ieee_copy_sign(sx1, 1.) /= abs(sx1)) call abort\n+  if (ieee_copy_sign(sx1, -1.) /= -abs(sx1)) call abort\n+  sx1 = -tiny(sx1)\n+  sx1 = sx1 / 101\n+  if (ieee_copy_sign(sx1, sx1) /= sx1) call abort\n+  if (ieee_copy_sign(sx1, -sx1) /= -sx1) call abort\n+  if (ieee_copy_sign(sx1, 1.) /= abs(sx1)) call abort\n+  if (ieee_copy_sign(sx1, -1.) /= -abs(sx1)) call abort\n+\n+  if (ieee_class(ieee_copy_sign(0., -1.)) /= ieee_negative_zero) call abort\n+  if (ieee_class(ieee_copy_sign(-0., -1.)) /= ieee_negative_zero) call abort\n+  if (ieee_class(ieee_copy_sign(0., 1.)) /= ieee_positive_zero) call abort\n+  if (ieee_class(ieee_copy_sign(-0., 1.)) /= ieee_positive_zero) call abort\n+\n+  sx1 = ieee_value(0., ieee_quiet_nan)\n+  if (ieee_class(ieee_copy_sign(sx1, 1.)) /= ieee_quiet_nan) call abort\n+  if (ieee_class(ieee_copy_sign(sx1, -1.)) /= ieee_quiet_nan) call abort\n+\n+  dx1 = 1.3\n+  if (ieee_copy_sign(dx1, dx1) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -dx1) /= -dx1) call abort\n+  if (ieee_copy_sign(dx1, 1.) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -1.d0) /= -dx1) call abort\n+  dx1 = huge(dx1)\n+  if (ieee_copy_sign(dx1, dx1) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -dx1) /= -dx1) call abort\n+  if (ieee_copy_sign(dx1, 1.d0) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -1.) /= -dx1) call abort\n+  dx1 = ieee_value(dx1, ieee_positive_inf)\n+  if (ieee_copy_sign(dx1, dx1) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -dx1) /= -dx1) call abort\n+  if (ieee_copy_sign(dx1, 1.) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -1.d0) /= -dx1) call abort\n+  dx1 = tiny(dx1)\n+  if (ieee_copy_sign(dx1, dx1) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -dx1) /= -dx1) call abort\n+  if (ieee_copy_sign(dx1, 1.d0) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -1.) /= -dx1) call abort\n+  dx1 = tiny(dx1)\n+  dx1 = dx1 / 101\n+  if (ieee_copy_sign(dx1, dx1) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -dx1) /= -dx1) call abort\n+  if (ieee_copy_sign(dx1, 1.) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -1.d0) /= -dx1) call abort\n+\n+  dx1 = -1.3d0\n+  if (ieee_copy_sign(dx1, dx1) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -dx1) /= -dx1) call abort\n+  if (ieee_copy_sign(dx1, 1.d0) /= abs(dx1)) call abort\n+  if (ieee_copy_sign(dx1, -1.) /= -abs(dx1)) call abort\n+  dx1 = -huge(dx1)\n+  if (ieee_copy_sign(dx1, dx1) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -dx1) /= -dx1) call abort\n+  if (ieee_copy_sign(dx1, 1.) /= abs(dx1)) call abort\n+  if (ieee_copy_sign(dx1, -1.d0) /= -abs(dx1)) call abort\n+  dx1 = ieee_value(dx1, ieee_negative_inf)\n+  if (ieee_copy_sign(dx1, dx1) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -dx1) /= -dx1) call abort\n+  if (ieee_copy_sign(dx1, 1.d0) /= abs(dx1)) call abort\n+  if (ieee_copy_sign(dx1, -1.) /= -abs(dx1)) call abort\n+  dx1 = -tiny(dx1)\n+  if (ieee_copy_sign(dx1, dx1) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -dx1) /= -dx1) call abort\n+  if (ieee_copy_sign(dx1, 1.) /= abs(dx1)) call abort\n+  if (ieee_copy_sign(dx1, -1.d0) /= -abs(dx1)) call abort\n+  dx1 = -tiny(dx1)\n+  dx1 = dx1 / 101\n+  if (ieee_copy_sign(dx1, dx1) /= dx1) call abort\n+  if (ieee_copy_sign(dx1, -dx1) /= -dx1) call abort\n+  if (ieee_copy_sign(dx1, 1.d0) /= abs(dx1)) call abort\n+  if (ieee_copy_sign(dx1, -1.) /= -abs(dx1)) call abort\n+\n+  if (ieee_class(ieee_copy_sign(0.d0, -1.)) /= ieee_negative_zero) call abort\n+  if (ieee_class(ieee_copy_sign(-0.d0, -1.)) /= ieee_negative_zero) call abort\n+  if (ieee_class(ieee_copy_sign(0.d0, 1.)) /= ieee_positive_zero) call abort\n+  if (ieee_class(ieee_copy_sign(-0.d0, 1.)) /= ieee_positive_zero) call abort\n+\n+  dx1 = ieee_value(0.d0, ieee_quiet_nan)\n+  if (ieee_class(ieee_copy_sign(dx1, 1.d0)) /= ieee_quiet_nan) call abort\n+  if (ieee_class(ieee_copy_sign(dx1, -1.)) /= ieee_quiet_nan) call abort\n+\n+  ! Test IEEE_LOGB\n+\n+  if (ieee_logb(1.17) /= exponent(1.17) - 1) call abort\n+  if (ieee_logb(-1.17) /= exponent(-1.17) - 1) call abort\n+  if (ieee_logb(huge(sx1)) /= exponent(huge(sx1)) - 1) call abort\n+  if (ieee_logb(-huge(sx1)) /= exponent(-huge(sx1)) - 1) call abort\n+  if (ieee_logb(tiny(sx1)) /= exponent(tiny(sx1)) - 1) call abort\n+  if (ieee_logb(-tiny(sx1)) /= exponent(-tiny(sx1)) - 1) call abort\n+\n+  if (ieee_class(ieee_logb(0.)) /= ieee_negative_inf) call abort\n+  if (ieee_class(ieee_logb(-0.)) /= ieee_negative_inf) call abort\n+\n+  sx1 = ieee_value(sx1, ieee_positive_inf)\n+  if (ieee_class(ieee_logb(sx1)) /= ieee_positive_inf) call abort\n+  if (ieee_class(ieee_logb(-sx1)) /= ieee_positive_inf) call abort\n+\n+  sx1 = ieee_value(sx1, ieee_quiet_nan)\n+  if (ieee_class(ieee_logb(sx1)) /= ieee_quiet_nan) call abort\n+\n+  if (ieee_logb(1.17d0) /= exponent(1.17d0) - 1) call abort\n+  if (ieee_logb(-1.17d0) /= exponent(-1.17d0) - 1) call abort\n+  if (ieee_logb(huge(dx1)) /= exponent(huge(dx1)) - 1) call abort\n+  if (ieee_logb(-huge(dx1)) /= exponent(-huge(dx1)) - 1) call abort\n+  if (ieee_logb(tiny(dx1)) /= exponent(tiny(dx1)) - 1) call abort\n+  if (ieee_logb(-tiny(dx1)) /= exponent(-tiny(dx1)) - 1) call abort\n+\n+  if (ieee_class(ieee_logb(0.d0)) /= ieee_negative_inf) call abort\n+  if (ieee_class(ieee_logb(-0.d0)) /= ieee_negative_inf) call abort\n+\n+  dx1 = ieee_value(dx1, ieee_positive_inf)\n+  if (ieee_class(ieee_logb(dx1)) /= ieee_positive_inf) call abort\n+  if (ieee_class(ieee_logb(-dx1)) /= ieee_positive_inf) call abort\n+\n+  dx1 = ieee_value(dx1, ieee_quiet_nan)\n+  if (ieee_class(ieee_logb(dx1)) /= ieee_quiet_nan) call abort\n+\n+  ! Test IEEE_NEXT_AFTER\n+\n+  if (ieee_next_after(0.12, 1.0) /= nearest(0.12, 1.0)) call abort\n+  if (ieee_next_after(0.12, -1.0) /= nearest(0.12, -1.0)) call abort\n+\n+  sx1 = 0.12\n+  if (ieee_next_after(sx1, sx1) /= sx1) call abort\n+  sx1 = -0.12\n+  if (ieee_next_after(sx1, sx1) /= sx1) call abort\n+  sx1 = huge(sx1)\n+  if (ieee_next_after(sx1, sx1) /= sx1) call abort\n+  sx1 = tiny(sx1)\n+  if (ieee_next_after(sx1, sx1) /= sx1) call abort\n+  sx1 = 0\n+  if (ieee_next_after(sx1, sx1) /= sx1) call abort\n+  sx1 = ieee_value(sx1, ieee_negative_inf)\n+  if (ieee_next_after(sx1, sx1) /= sx1) call abort\n+  sx1 = ieee_value(sx1, ieee_quiet_nan)\n+  if (ieee_class(ieee_next_after(sx1, sx1)) /= ieee_quiet_nan) call abort\n+\n+  if (ieee_next_after(0., 1.0) <= 0) call abort\n+  if (ieee_next_after(0., -1.0) >= 0) call abort\n+  sx1 = ieee_next_after(huge(sx1), ieee_value(sx1, ieee_negative_inf))\n+  if (.not. sx1 < huge(sx1)) call abort\n+  sx1 = ieee_next_after(huge(sx1), ieee_value(sx1, ieee_positive_inf))\n+  if (ieee_class(sx1) /= ieee_positive_inf) call abort\n+  sx1 = ieee_next_after(-tiny(sx1), 1.0)\n+  if (ieee_class(sx1) /= ieee_negative_denormal) call abort\n+\n+  if (ieee_next_after(0.12d0, 1.0d0) /= nearest(0.12d0, 1.0)) call abort\n+  if (ieee_next_after(0.12d0, -1.0) /= nearest(0.12d0, -1.0)) call abort\n+\n+  dx1 = 0.12\n+  if (ieee_next_after(dx1, dx1) /= dx1) call abort\n+  dx1 = -0.12\n+  if (ieee_next_after(dx1, dx1) /= dx1) call abort\n+  dx1 = huge(dx1)\n+  if (ieee_next_after(dx1, dx1) /= dx1) call abort\n+  dx1 = tiny(dx1)\n+  if (ieee_next_after(dx1, dx1) /= dx1) call abort\n+  dx1 = 0\n+  if (ieee_next_after(dx1, dx1) /= dx1) call abort\n+  dx1 = ieee_value(dx1, ieee_negative_inf)\n+  if (ieee_next_after(dx1, dx1) /= dx1) call abort\n+  dx1 = ieee_value(dx1, ieee_quiet_nan)\n+  if (ieee_class(ieee_next_after(dx1, dx1)) /= ieee_quiet_nan) call abort\n+\n+  if (ieee_next_after(0.d0, 1.0) <= 0) call abort\n+  if (ieee_next_after(0.d0, -1.0d0) >= 0) call abort\n+  dx1 = ieee_next_after(huge(dx1), ieee_value(dx1, ieee_negative_inf))\n+  if (.not. dx1 < huge(dx1)) call abort\n+  dx1 = ieee_next_after(huge(dx1), ieee_value(dx1, ieee_positive_inf))\n+  if (ieee_class(dx1) /= ieee_positive_inf) call abort\n+  dx1 = ieee_next_after(-tiny(dx1), 1.0d0)\n+  if (ieee_class(dx1) /= ieee_negative_denormal) call abort\n+\n+  ! Test IEEE_REM\n+\n+  if (ieee_rem(4.0, 3.0) /= 1.0) call abort\n+  if (ieee_rem(-4.0, 3.0) /= -1.0) call abort\n+  if (ieee_rem(2.0, 3.0d0) /= -1.0d0) call abort\n+  if (ieee_rem(-2.0, 3.0d0) /= 1.0d0) call abort\n+  if (ieee_rem(2.0d0, 3.0d0) /= -1.0d0) call abort\n+  if (ieee_rem(-2.0d0, 3.0d0) /= 1.0d0) call abort\n+\n+  if (ieee_class(ieee_rem(ieee_value(0., ieee_quiet_nan), 1.0)) &\n+      /= ieee_quiet_nan) call abort\n+  if (ieee_class(ieee_rem(1.0, ieee_value(0.d0, ieee_quiet_nan))) &\n+      /= ieee_quiet_nan) call abort\n+\n+  if (ieee_class(ieee_rem(ieee_value(0., ieee_positive_inf), 1.0)) &\n+      /= ieee_quiet_nan) call abort\n+  if (ieee_class(ieee_rem(ieee_value(0.d0, ieee_negative_inf), 1.0)) &\n+      /= ieee_quiet_nan) call abort\n+  if (ieee_rem(-1.0, ieee_value(0., ieee_positive_inf)) &\n+      /= -1.0) call abort\n+  if (ieee_rem(1.0, ieee_value(0.d0, ieee_negative_inf)) &\n+      /= 1.0) call abort\n+\n+\n+  ! Test IEEE_RINT\n+\n+  if (ieee_support_rounding (ieee_nearest, sx1)) then\n+    call ieee_get_rounding_mode (mode)\n+    call ieee_set_rounding_mode (ieee_nearest)\n+    sx1 = 7 / 3.\n+    sx1 = ieee_rint (sx1)\n+    call ieee_set_rounding_mode (mode)\n+    if (sx1 /= 2) call abort\n+  end if\n+\n+  if (ieee_support_rounding (ieee_up, sx1)) then\n+    call ieee_get_rounding_mode (mode)\n+    call ieee_set_rounding_mode (ieee_up)\n+    sx1 = 7 / 3.\n+    sx1 = ieee_rint (sx1)\n+    call ieee_set_rounding_mode (mode)\n+    if (sx1 /= 3) call abort\n+  end if\n+\n+  if (ieee_support_rounding (ieee_down, sx1)) then\n+    call ieee_get_rounding_mode (mode)\n+    call ieee_set_rounding_mode (ieee_down)\n+    sx1 = 7 / 3.\n+    sx1 = ieee_rint (sx1)\n+    call ieee_set_rounding_mode (mode)\n+    if (sx1 /= 2) call abort\n+  end if\n+\n+  if (ieee_support_rounding (ieee_to_zero, sx1)) then\n+    call ieee_get_rounding_mode (mode)\n+    call ieee_set_rounding_mode (ieee_to_zero)\n+    sx1 = 7 / 3.\n+    sx1 = ieee_rint (sx1)\n+    call ieee_set_rounding_mode (mode)\n+    if (sx1 /= 2) call abort\n+  end if\n+\n+  if (ieee_class(ieee_rint(0.)) /= ieee_positive_zero) call abort\n+  if (ieee_class(ieee_rint(-0.)) /= ieee_negative_zero) call abort\n+\n+  if (ieee_support_rounding (ieee_nearest, dx1)) then\n+    call ieee_get_rounding_mode (mode)\n+    call ieee_set_rounding_mode (ieee_nearest)\n+    dx1 = 7 / 3.d0\n+    dx1 = ieee_rint (dx1)\n+    call ieee_set_rounding_mode (mode)\n+    if (dx1 /= 2) call abort\n+  end if\n+\n+  if (ieee_support_rounding (ieee_up, dx1)) then\n+    call ieee_get_rounding_mode (mode)\n+    call ieee_set_rounding_mode (ieee_up)\n+    dx1 = 7 / 3.d0\n+    dx1 = ieee_rint (dx1)\n+    call ieee_set_rounding_mode (mode)\n+    if (dx1 /= 3) call abort\n+  end if\n+\n+  if (ieee_support_rounding (ieee_down, dx1)) then\n+    call ieee_get_rounding_mode (mode)\n+    call ieee_set_rounding_mode (ieee_down)\n+    dx1 = 7 / 3.d0\n+    dx1 = ieee_rint (dx1)\n+    call ieee_set_rounding_mode (mode)\n+    if (dx1 /= 2) call abort\n+  end if\n+\n+  if (ieee_support_rounding (ieee_to_zero, dx1)) then\n+    call ieee_get_rounding_mode (mode)\n+    call ieee_set_rounding_mode (ieee_to_zero)\n+    dx1 = 7 / 3.d0\n+    dx1 = ieee_rint (dx1)\n+    call ieee_set_rounding_mode (mode)\n+    if (dx1 /= 2) call abort\n+  end if\n+\n+  if (ieee_class(ieee_rint(0.d0)) /= ieee_positive_zero) call abort\n+  if (ieee_class(ieee_rint(-0.d0)) /= ieee_negative_zero) call abort\n+\n+  ! Test IEEE_SCALB\n+\n+  sx1 = 1\n+  if (ieee_scalb(sx1, 2) /= 4.) call abort\n+  if (ieee_scalb(-sx1, 2) /= -4.) call abort\n+  if (ieee_scalb(sx1, -2) /= 1/4.) call abort\n+  if (ieee_scalb(-sx1, -2) /= -1/4.) call abort\n+  if (ieee_class(ieee_scalb(sx1, huge(0))) /= ieee_positive_inf) call abort\n+  if (ieee_class(ieee_scalb(-sx1, huge(0))) /= ieee_negative_inf) call abort\n+  if (ieee_class(ieee_scalb(sx1, -huge(0))) /= ieee_positive_zero) call abort\n+  if (ieee_class(ieee_scalb(-sx1, -huge(0))) /= ieee_negative_zero) call abort\n+\n+  sx1 = ieee_value(sx1, ieee_quiet_nan)\n+  if (ieee_class(ieee_scalb(sx1, 1)) /= ieee_quiet_nan) call abort\n+  sx1 = ieee_value(sx1, ieee_positive_inf)\n+  if (ieee_class(ieee_scalb(sx1, -42)) /= ieee_positive_inf) call abort\n+  sx1 = ieee_value(sx1, ieee_negative_inf)\n+  if (ieee_class(ieee_scalb(sx1, -42)) /= ieee_negative_inf) call abort\n+\n+  dx1 = 1\n+  if (ieee_scalb(dx1, 2) /= 4.d0) call abort\n+  if (ieee_scalb(-dx1, 2) /= -4.d0) call abort\n+  if (ieee_scalb(dx1, -2) /= 1/4.d0) call abort\n+  if (ieee_scalb(-dx1, -2) /= -1/4.d0) call abort\n+  if (ieee_class(ieee_scalb(dx1, huge(0))) /= ieee_positive_inf) call abort\n+  if (ieee_class(ieee_scalb(-dx1, huge(0))) /= ieee_negative_inf) call abort\n+  if (ieee_class(ieee_scalb(dx1, -huge(0))) /= ieee_positive_zero) call abort\n+  if (ieee_class(ieee_scalb(-dx1, -huge(0))) /= ieee_negative_zero) call abort\n+\n+  dx1 = ieee_value(dx1, ieee_quiet_nan)\n+  if (ieee_class(ieee_scalb(dx1, 1)) /= ieee_quiet_nan) call abort\n+  dx1 = ieee_value(dx1, ieee_positive_inf)\n+  if (ieee_class(ieee_scalb(dx1, -42)) /= ieee_positive_inf) call abort\n+  dx1 = ieee_value(dx1, ieee_negative_inf)\n+  if (ieee_class(ieee_scalb(dx1, -42)) /= ieee_negative_inf) call abort\n+\n+contains\n+\n+  subroutine check_equal_float (x, y)\n+    real, intent(in) :: x, y\n+    if (x /= y) then\n+      print *, x, y\n+      call abort\n+    end if\n+  end subroutine\n+\n+  subroutine check_equal_double (x, y)\n+    double precision, intent(in) :: x, y\n+    if (x /= y) then\n+      print *, x, y\n+      call abort\n+    end if\n+  end subroutine\n+\n+  subroutine check_not_equal_float (x, y)\n+    real, intent(in) :: x, y\n+    if (x == y) then\n+      print *, x, y\n+      call abort\n+    end if\n+  end subroutine\n+\n+  subroutine check_not_equal_double (x, y)\n+    double precision, intent(in) :: x, y\n+    if (x == y) then\n+      print *, x, y\n+      call abort\n+    end if\n+  end subroutine\n+\n+end"}, {"sha": "b2c718641a3d4732c2f11ab9f909fdbafde60476", "filename": "gcc/testsuite/gfortran.dg/ieee/ieee_3.f90", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_3.f90?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,167 @@\n+! { dg-do run }\n+\n+  use :: ieee_arithmetic\n+  implicit none\n+\n+  real :: sx1, sx2, sx3\n+  double precision :: dx1, dx2, dx3\n+  integer, parameter :: s = kind(sx1), d = kind(dx1)\n+  type(ieee_round_type) :: mode\n+\n+  ! Test IEEE_IS_FINITE\n+\n+  if (ieee_support_datatype(0._s)) then\n+    if (.not. ieee_is_finite(0.2_s)) call abort\n+    if (.not. ieee_is_finite(-0.2_s)) call abort\n+    if (.not. ieee_is_finite(0._s)) call abort\n+    if (.not. ieee_is_finite(-0._s)) call abort\n+    if (.not. ieee_is_finite(tiny(0._s))) call abort\n+    if (.not. ieee_is_finite(tiny(0._s)/100)) call abort\n+    if (.not. ieee_is_finite(huge(0._s))) call abort\n+    if (.not. ieee_is_finite(-huge(0._s))) call abort\n+    sx1 = huge(sx1)\n+    if (ieee_is_finite(2*sx1)) call abort\n+    if (ieee_is_finite(2*(-sx1))) call abort\n+    sx1 = ieee_value(sx1, ieee_quiet_nan)\n+    if (ieee_is_finite(sx1)) call abort\n+  end if\n+\n+  if (ieee_support_datatype(0._d)) then\n+    if (.not. ieee_is_finite(0.2_d)) call abort\n+    if (.not. ieee_is_finite(-0.2_d)) call abort\n+    if (.not. ieee_is_finite(0._d)) call abort\n+    if (.not. ieee_is_finite(-0._d)) call abort\n+    if (.not. ieee_is_finite(tiny(0._d))) call abort\n+    if (.not. ieee_is_finite(tiny(0._d)/100)) call abort\n+    if (.not. ieee_is_finite(huge(0._d))) call abort\n+    if (.not. ieee_is_finite(-huge(0._d))) call abort\n+    dx1 = huge(dx1)\n+    if (ieee_is_finite(2*dx1)) call abort\n+    if (ieee_is_finite(2*(-dx1))) call abort\n+    dx1 = ieee_value(dx1, ieee_quiet_nan)\n+    if (ieee_is_finite(dx1)) call abort\n+  end if\n+\n+  ! Test IEEE_IS_NAN\n+\n+  if (ieee_support_datatype(0._s)) then\n+    if (ieee_is_nan(0.2_s)) call abort\n+    if (ieee_is_nan(-0.2_s)) call abort\n+    if (ieee_is_nan(0._s)) call abort\n+    if (ieee_is_nan(-0._s)) call abort\n+    if (ieee_is_nan(tiny(0._s))) call abort\n+    if (ieee_is_nan(tiny(0._s)/100)) call abort\n+    if (ieee_is_nan(huge(0._s))) call abort\n+    if (ieee_is_nan(-huge(0._s))) call abort\n+    sx1 = huge(sx1)\n+    if (ieee_is_nan(2*sx1)) call abort\n+    if (ieee_is_nan(2*(-sx1))) call abort\n+    sx1 = ieee_value(sx1, ieee_quiet_nan)\n+    if (.not. ieee_is_nan(sx1)) call abort\n+    sx1 = -1\n+    if (.not. ieee_is_nan(sqrt(sx1))) call abort\n+  end if\n+\n+  if (ieee_support_datatype(0._d)) then\n+    if (ieee_is_nan(0.2_d)) call abort\n+    if (ieee_is_nan(-0.2_d)) call abort\n+    if (ieee_is_nan(0._d)) call abort\n+    if (ieee_is_nan(-0._d)) call abort\n+    if (ieee_is_nan(tiny(0._d))) call abort\n+    if (ieee_is_nan(tiny(0._d)/100)) call abort\n+    if (ieee_is_nan(huge(0._d))) call abort\n+    if (ieee_is_nan(-huge(0._d))) call abort\n+    dx1 = huge(dx1)\n+    if (ieee_is_nan(2*dx1)) call abort\n+    if (ieee_is_nan(2*(-dx1))) call abort\n+    dx1 = ieee_value(dx1, ieee_quiet_nan)\n+    if (.not. ieee_is_nan(dx1)) call abort\n+    dx1 = -1\n+    if (.not. ieee_is_nan(sqrt(dx1))) call abort\n+  end if\n+\n+  ! IEEE_IS_NEGATIVE\n+\n+  if (ieee_support_datatype(0._s)) then\n+    if (ieee_is_negative(0.2_s)) call abort\n+    if (.not. ieee_is_negative(-0.2_s)) call abort\n+    if (ieee_is_negative(0._s)) call abort\n+    if (.not. ieee_is_negative(-0._s)) call abort\n+    if (ieee_is_negative(tiny(0._s))) call abort\n+    if (ieee_is_negative(tiny(0._s)/100)) call abort\n+    if (.not. ieee_is_negative(-tiny(0._s))) call abort\n+    if (.not. ieee_is_negative(-tiny(0._s)/100)) call abort\n+    if (ieee_is_negative(huge(0._s))) call abort\n+    if (.not. ieee_is_negative(-huge(0._s))) call abort\n+    sx1 = huge(sx1)\n+    if (ieee_is_negative(2*sx1)) call abort\n+    if (.not. ieee_is_negative(2*(-sx1))) call abort\n+    sx1 = ieee_value(sx1, ieee_quiet_nan)\n+    if (ieee_is_negative(sx1)) call abort\n+    sx1 = -1\n+    if (ieee_is_negative(sqrt(sx1))) call abort\n+  end if\n+\n+  if (ieee_support_datatype(0._d)) then\n+    if (ieee_is_negative(0.2_d)) call abort\n+    if (.not. ieee_is_negative(-0.2_d)) call abort\n+    if (ieee_is_negative(0._d)) call abort\n+    if (.not. ieee_is_negative(-0._d)) call abort\n+    if (ieee_is_negative(tiny(0._d))) call abort\n+    if (ieee_is_negative(tiny(0._d)/100)) call abort\n+    if (.not. ieee_is_negative(-tiny(0._d))) call abort\n+    if (.not. ieee_is_negative(-tiny(0._d)/100)) call abort\n+    if (ieee_is_negative(huge(0._d))) call abort\n+    if (.not. ieee_is_negative(-huge(0._d))) call abort\n+    dx1 = huge(dx1)\n+    if (ieee_is_negative(2*dx1)) call abort\n+    if (.not. ieee_is_negative(2*(-dx1))) call abort\n+    dx1 = ieee_value(dx1, ieee_quiet_nan)\n+    if (ieee_is_negative(dx1)) call abort\n+    dx1 = -1\n+    if (ieee_is_negative(sqrt(dx1))) call abort\n+  end if\n+\n+  ! Test IEEE_IS_NORMAL\n+\n+  if (ieee_support_datatype(0._s)) then\n+    if (.not. ieee_is_normal(0.2_s)) call abort\n+    if (.not. ieee_is_normal(-0.2_s)) call abort\n+    if (.not. ieee_is_normal(0._s)) call abort\n+    if (.not. ieee_is_normal(-0._s)) call abort\n+    if (.not. ieee_is_normal(tiny(0._s))) call abort\n+    if (ieee_is_normal(tiny(0._s)/100)) call abort\n+    if (.not. ieee_is_normal(-tiny(0._s))) call abort\n+    if (ieee_is_normal(-tiny(0._s)/100)) call abort\n+    if (.not. ieee_is_normal(huge(0._s))) call abort\n+    if (.not. ieee_is_normal(-huge(0._s))) call abort\n+    sx1 = huge(sx1)\n+    if (ieee_is_normal(2*sx1)) call abort\n+    if (ieee_is_normal(2*(-sx1))) call abort\n+    sx1 = ieee_value(sx1, ieee_quiet_nan)\n+    if (ieee_is_normal(sx1)) call abort\n+    sx1 = -1\n+    if (ieee_is_normal(sqrt(sx1))) call abort\n+  end if\n+\n+  if (ieee_support_datatype(0._d)) then\n+    if (.not. ieee_is_normal(0.2_d)) call abort\n+    if (.not. ieee_is_normal(-0.2_d)) call abort\n+    if (.not. ieee_is_normal(0._d)) call abort\n+    if (.not. ieee_is_normal(-0._d)) call abort\n+    if (.not. ieee_is_normal(tiny(0._d))) call abort\n+    if (ieee_is_normal(tiny(0._d)/100)) call abort\n+    if (.not. ieee_is_normal(-tiny(0._d))) call abort\n+    if (ieee_is_normal(-tiny(0._d)/100)) call abort\n+    if (.not. ieee_is_normal(huge(0._d))) call abort\n+    if (.not. ieee_is_normal(-huge(0._d))) call abort\n+    dx1 = huge(dx1)\n+    if (ieee_is_normal(2*dx1)) call abort\n+    if (ieee_is_normal(2*(-dx1))) call abort\n+    dx1 = ieee_value(dx1, ieee_quiet_nan)\n+    if (ieee_is_normal(dx1)) call abort\n+    dx1 = -1\n+    if (ieee_is_normal(sqrt(dx1))) call abort\n+  end if\n+\n+end"}, {"sha": "e5f1ceebe4ee685d5311cf2b76088734abd7bea5", "filename": "gcc/testsuite/gfortran.dg/ieee/ieee_4.f90", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_4.f90?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,189 @@\n+! { dg-do run }\n+\n+  use :: ieee_arithmetic\n+  implicit none\n+\n+  real :: sx1, sx2, sx3\n+  double precision :: dx1, dx2, dx3\n+  integer, parameter :: s = kind(sx1), d = kind(dx1)\n+  type(ieee_round_type) :: mode\n+\n+  ! Test IEEE_CLASS\n+\n+  if (ieee_support_datatype(0._s)) then\n+    sx1 = 0.1_s\n+    if (ieee_class(sx1) /= ieee_positive_normal) call abort\n+    if (ieee_class(-sx1) /= ieee_negative_normal) call abort\n+    sx1 = huge(sx1)\n+    if (ieee_class(sx1) /= ieee_positive_normal) call abort\n+    if (ieee_class(-sx1) /= ieee_negative_normal) call abort\n+    if (ieee_class(2*sx1) /= ieee_positive_inf) call abort\n+    if (ieee_class(2*(-sx1)) /= ieee_negative_inf) call abort\n+    sx1 = tiny(sx1)\n+    if (ieee_class(sx1) /= ieee_positive_normal) call abort\n+    if (ieee_class(-sx1) /= ieee_negative_normal) call abort\n+    if (ieee_class(sx1 / 2) /= ieee_positive_denormal) call abort\n+    if (ieee_class((-sx1) / 2) /= ieee_negative_denormal) call abort\n+    sx1 = -1\n+    if (ieee_class(sqrt(sx1)) /= ieee_quiet_nan) call abort\n+    sx1 = 0\n+    if (ieee_class(sx1) /= ieee_positive_zero) call abort\n+    if (ieee_class(-sx1) /= ieee_negative_zero) call abort\n+  end if\n+\n+  if (ieee_support_datatype(0._d)) then\n+    dx1 = 0.1_d\n+    if (ieee_class(dx1) /= ieee_positive_normal) call abort\n+    if (ieee_class(-dx1) /= ieee_negative_normal) call abort\n+    dx1 = huge(dx1)\n+    if (ieee_class(dx1) /= ieee_positive_normal) call abort\n+    if (ieee_class(-dx1) /= ieee_negative_normal) call abort\n+    if (ieee_class(2*dx1) /= ieee_positive_inf) call abort\n+    if (ieee_class(2*(-dx1)) /= ieee_negative_inf) call abort\n+    dx1 = tiny(dx1)\n+    if (ieee_class(dx1) /= ieee_positive_normal) call abort\n+    if (ieee_class(-dx1) /= ieee_negative_normal) call abort\n+    if (ieee_class(dx1 / 2) /= ieee_positive_denormal) call abort\n+    if (ieee_class((-dx1) / 2) /= ieee_negative_denormal) call abort\n+    dx1 = -1\n+    if (ieee_class(sqrt(dx1)) /= ieee_quiet_nan) call abort\n+    dx1 = 0\n+    if (ieee_class(dx1) /= ieee_positive_zero) call abort\n+    if (ieee_class(-dx1) /= ieee_negative_zero) call abort\n+  end if\n+\n+  ! Test IEEE_VALUE and IEEE_UNORDERED\n+\n+  if (ieee_support_datatype(0._s)) then\n+    sx1 = ieee_value(sx1, ieee_quiet_nan)\n+    if (.not. ieee_is_nan(sx1)) call abort\n+    if (.not. ieee_unordered(sx1, sx1)) call abort\n+    if (.not. ieee_unordered(sx1, 0._s)) call abort\n+    if (.not. ieee_unordered(sx1, 0._d)) call abort\n+    if (.not. ieee_unordered(0._s, sx1)) call abort\n+    if (.not. ieee_unordered(0._d, sx1)) call abort\n+    if (ieee_unordered(0._s, 0._s)) call abort\n+\n+    sx1 = ieee_value(sx1, ieee_positive_inf)\n+    if (ieee_is_finite(sx1)) call abort\n+    if (ieee_is_nan(sx1)) call abort\n+    if (ieee_is_negative(sx1)) call abort\n+    if (ieee_is_normal(sx1)) call abort\n+\n+    sx1 = ieee_value(sx1, ieee_negative_inf)\n+    if (ieee_is_finite(sx1)) call abort\n+    if (ieee_is_nan(sx1)) call abort\n+    if (.not. ieee_is_negative(sx1)) call abort\n+    if (ieee_is_normal(sx1)) call abort\n+\n+    sx1 = ieee_value(sx1, ieee_positive_normal)\n+    if (.not. ieee_is_finite(sx1)) call abort\n+    if (ieee_is_nan(sx1)) call abort\n+    if (ieee_is_negative(sx1)) call abort\n+    if (.not. ieee_is_normal(sx1)) call abort\n+\n+    sx1 = ieee_value(sx1, ieee_negative_normal)\n+    if (.not. ieee_is_finite(sx1)) call abort\n+    if (ieee_is_nan(sx1)) call abort\n+    if (.not. ieee_is_negative(sx1)) call abort\n+    if (.not. ieee_is_normal(sx1)) call abort\n+\n+    sx1 = ieee_value(sx1, ieee_positive_denormal)\n+    if (.not. ieee_is_finite(sx1)) call abort\n+    if (ieee_is_nan(sx1)) call abort\n+    if (ieee_is_negative(sx1)) call abort\n+    if (ieee_is_normal(sx1)) call abort\n+    if (sx1 <= 0) call abort\n+    if (sx1 >= tiny(sx1)) call abort\n+\n+    sx1 = ieee_value(sx1, ieee_negative_denormal)\n+    if (.not. ieee_is_finite(sx1)) call abort\n+    if (ieee_is_nan(sx1)) call abort\n+    if (.not. ieee_is_negative(sx1)) call abort\n+    if (ieee_is_normal(sx1)) call abort\n+    if (sx1 >= 0) call abort\n+    if (sx1 <= -tiny(sx1)) call abort\n+\n+    sx1 = ieee_value(sx1, ieee_positive_zero)\n+    if (.not. ieee_is_finite(sx1)) call abort\n+    if (ieee_is_nan(sx1)) call abort\n+    if (ieee_is_negative(sx1)) call abort\n+    if (.not. ieee_is_normal(sx1)) call abort\n+    if (sx1 /= 0) call abort\n+\n+    sx1 = ieee_value(sx1, ieee_negative_zero)\n+    if (.not. ieee_is_finite(sx1)) call abort\n+    if (ieee_is_nan(sx1)) call abort\n+    if (.not. ieee_is_negative(sx1)) call abort\n+    if (.not. ieee_is_normal(sx1)) call abort\n+    if (sx1 /= 0) call abort\n+\n+  end if\n+\n+  if (ieee_support_datatype(0._d)) then\n+    dx1 = ieee_value(dx1, ieee_quiet_nan)\n+    if (.not. ieee_is_nan(dx1)) call abort\n+    if (.not. ieee_unordered(dx1, dx1)) call abort\n+    if (.not. ieee_unordered(dx1, 0._s)) call abort\n+    if (.not. ieee_unordered(dx1, 0._d)) call abort\n+    if (.not. ieee_unordered(0._s, dx1)) call abort\n+    if (.not. ieee_unordered(0._d, dx1)) call abort\n+    if (ieee_unordered(0._d, 0._d)) call abort\n+\n+    dx1 = ieee_value(dx1, ieee_positive_inf)\n+    if (ieee_is_finite(dx1)) call abort\n+    if (ieee_is_nan(dx1)) call abort\n+    if (ieee_is_negative(dx1)) call abort\n+    if (ieee_is_normal(dx1)) call abort\n+\n+    dx1 = ieee_value(dx1, ieee_negative_inf)\n+    if (ieee_is_finite(dx1)) call abort\n+    if (ieee_is_nan(dx1)) call abort\n+    if (.not. ieee_is_negative(dx1)) call abort\n+    if (ieee_is_normal(dx1)) call abort\n+\n+    dx1 = ieee_value(dx1, ieee_positive_normal)\n+    if (.not. ieee_is_finite(dx1)) call abort\n+    if (ieee_is_nan(dx1)) call abort\n+    if (ieee_is_negative(dx1)) call abort\n+    if (.not. ieee_is_normal(dx1)) call abort\n+\n+    dx1 = ieee_value(dx1, ieee_negative_normal)\n+    if (.not. ieee_is_finite(dx1)) call abort\n+    if (ieee_is_nan(dx1)) call abort\n+    if (.not. ieee_is_negative(dx1)) call abort\n+    if (.not. ieee_is_normal(dx1)) call abort\n+\n+    dx1 = ieee_value(dx1, ieee_positive_denormal)\n+    if (.not. ieee_is_finite(dx1)) call abort\n+    if (ieee_is_nan(dx1)) call abort\n+    if (ieee_is_negative(dx1)) call abort\n+    if (ieee_is_normal(dx1)) call abort\n+    if (dx1 <= 0) call abort\n+    if (dx1 >= tiny(dx1)) call abort\n+\n+    dx1 = ieee_value(dx1, ieee_negative_denormal)\n+    if (.not. ieee_is_finite(dx1)) call abort\n+    if (ieee_is_nan(dx1)) call abort\n+    if (.not. ieee_is_negative(dx1)) call abort\n+    if (ieee_is_normal(dx1)) call abort\n+    if (dx1 >= 0) call abort\n+    if (dx1 <= -tiny(dx1)) call abort\n+\n+    dx1 = ieee_value(dx1, ieee_positive_zero)\n+    if (.not. ieee_is_finite(dx1)) call abort\n+    if (ieee_is_nan(dx1)) call abort\n+    if (ieee_is_negative(dx1)) call abort\n+    if (.not. ieee_is_normal(dx1)) call abort\n+    if (dx1 /= 0) call abort\n+\n+    dx1 = ieee_value(dx1, ieee_negative_zero)\n+    if (.not. ieee_is_finite(dx1)) call abort\n+    if (ieee_is_nan(dx1)) call abort\n+    if (.not. ieee_is_negative(dx1)) call abort\n+    if (.not. ieee_is_normal(dx1)) call abort\n+    if (dx1 /= 0) call abort\n+\n+  end if\n+\n+end"}, {"sha": "4ef15252e03065c1d85f63fdf45aadf2aa3a3d35", "filename": "gcc/testsuite/gfortran.dg/ieee/ieee_5.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_5.f90?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+\n+  use :: ieee_arithmetic\n+  implicit none\n+\n+  logical mode\n+\n+  ! Test IEEE_SET_UNDERFLOW_MODE, IEEE_GET_UNDERFLOW_MODE,\n+  ! and IEEE_SUPPORT_UNDERFLOW_CONTROL\n+  !\n+  ! We don't have any targets where this is supported yet, so\n+  ! we just check these subroutines are present.\n+\n+  if (ieee_support_underflow_control() &\n+      .or. ieee_support_underflow_control(0.)) then\n+\n+    call ieee_get_underflow_mode(mode)\n+    call ieee_set_underflow_mode(.false.)\n+    call ieee_set_underflow_mode(.true.)\n+    call ieee_set_underflow_mode(mode)\n+\n+  end if\n+\n+  if (ieee_support_underflow_control() &\n+      .or. ieee_support_underflow_control(0.d0)) then\n+\n+    call ieee_get_underflow_mode(mode)\n+    call ieee_set_underflow_mode(.false.)\n+    call ieee_set_underflow_mode(.true.)\n+    call ieee_set_underflow_mode(mode)\n+\n+  end if\n+\n+end"}, {"sha": "a9a9517ee7cd6c67537fada0eb87b2e28ce9c1c1", "filename": "gcc/testsuite/gfortran.dg/ieee/ieee_6.f90", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_6.f90?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,78 @@\n+! { dg-do run }\n+!\n+! This test will fail on older x86_64 glibc (< 2.20), due to this bug:\n+! https://sourceware.org/bugzilla/show_bug.cgi?id=16198\n+! We usually won't see it anyway, because on such systems x86_64 assembly\n+! (libgfortran/config/fpu-387.h) is used.\n+!\n+  use :: ieee_arithmetic\n+  implicit none\n+\n+  type(ieee_status_type) :: s1, s2\n+  logical :: flags(5), halt(5)\n+  type(ieee_round_type) :: mode\n+  real :: x\n+\n+  ! Test IEEE_GET_STATUS and IEEE_SET_STATUS\n+\n+  call ieee_set_flag(ieee_all, .false.)\n+  call ieee_set_rounding_mode(ieee_down)\n+  call ieee_set_halting_mode(ieee_all, .false.)\n+\n+  call ieee_get_status(s1)\n+  call ieee_set_status(s1)\n+\n+  call ieee_get_flag(ieee_all, flags)\n+  if (any(flags)) call abort\n+  call ieee_get_rounding_mode(mode)\n+  if (mode /= ieee_down) call abort\n+  call ieee_get_halting_mode(ieee_all, halt)\n+  if (any(halt)) call abort\n+\n+  call ieee_set_rounding_mode(ieee_to_zero)\n+  call ieee_set_flag(ieee_underflow, .true.)\n+  call ieee_set_halting_mode(ieee_overflow, .true.)\n+  x = -1\n+  x = sqrt(x)\n+  if (.not. ieee_is_nan(x)) call abort\n+\n+  call ieee_get_status(s2)\n+\n+  call ieee_get_flag(ieee_all, flags)\n+  if (.not. (all(flags .eqv. [.false.,.false.,.true.,.true.,.false.]) &\n+             .or. all(flags .eqv. [.false.,.false.,.true.,.false.,.false.]))) call abort\n+  call ieee_get_rounding_mode(mode)\n+  if (mode /= ieee_to_zero) call abort\n+  call ieee_get_halting_mode(ieee_all, halt)\n+  if ((.not. halt(1)) .or. any(halt(2:))) call abort\n+\n+  call ieee_set_status(s2)\n+\n+  call ieee_get_flag(ieee_all, flags)\n+  if (.not. (all(flags .eqv. [.false.,.false.,.true.,.true.,.false.]) &\n+             .or. all(flags .eqv. [.false.,.false.,.true.,.false.,.false.]))) call abort\n+  call ieee_get_rounding_mode(mode)\n+  if (mode /= ieee_to_zero) call abort\n+  call ieee_get_halting_mode(ieee_all, halt)\n+  if ((.not. halt(1)) .or. any(halt(2:))) call abort\n+\n+  call ieee_set_status(s1)\n+\n+  call ieee_get_flag(ieee_all, flags)\n+  if (any(flags)) call abort\n+  call ieee_get_rounding_mode(mode)\n+  if (mode /= ieee_down) call abort\n+  call ieee_get_halting_mode(ieee_all, halt)\n+  if (any(halt)) call abort\n+\n+  call ieee_set_status(s2)\n+\n+  call ieee_get_flag(ieee_all, flags)\n+  if (.not. (all(flags .eqv. [.false.,.false.,.true.,.true.,.false.]) &\n+             .or. all(flags .eqv. [.false.,.false.,.true.,.false.,.false.]))) call abort\n+  call ieee_get_rounding_mode(mode)\n+  if (mode /= ieee_to_zero) call abort\n+  call ieee_get_halting_mode(ieee_all, halt)\n+  if ((.not. halt(1)) .or. any(halt(2:))) call abort\n+\n+end"}, {"sha": "a66e9057bec7635796578351f92ab4a54c95c3d8", "filename": "gcc/testsuite/gfortran.dg/ieee/ieee_7.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_7.f90?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+\n+  use :: ieee_arithmetic\n+  implicit none\n+\n+  ! Test IEEE_SELECTED_REAL_KIND in specification expressions\n+\n+  integer(kind=ieee_selected_real_kind()) :: i1\n+  integer(kind=ieee_selected_real_kind(10)) :: i2\n+  integer(kind=ieee_selected_real_kind(10,10)) :: i3\n+  integer(kind=ieee_selected_real_kind(10,10,2)) :: i4\n+\n+  ! Test IEEE_SELECTED_REAL_KIND\n+\n+  if (ieee_support_datatype(0.)) then\n+    if (ieee_selected_real_kind() /= kind(0.)) call abort\n+    if (ieee_selected_real_kind(0) /= kind(0.)) call abort\n+    if (ieee_selected_real_kind(0,0) /= kind(0.)) call abort\n+    if (ieee_selected_real_kind(0,0,2) /= kind(0.)) call abort\n+  end if\n+\n+  if (ieee_support_datatype(0.d0)) then\n+    if (ieee_selected_real_kind(precision(0.)+1) /= kind(0.d0)) call abort\n+    if (ieee_selected_real_kind(precision(0.),range(0.)+1) /= kind(0.d0)) call abort\n+    if (ieee_selected_real_kind(precision(0.)+1,range(0.)+1) /= kind(0.d0)) call abort\n+    if (ieee_selected_real_kind(precision(0.)+1,range(0.)+1,2) /= kind(0.d0)) call abort\n+  end if\n+\n+  if (ieee_selected_real_kind(0,0,3) /= -5) call abort\n+  if (ieee_selected_real_kind(precision(0.d0)+1) /= -1) call abort\n+  if (ieee_selected_real_kind(0,range(0.d0)+1) /= -2) call abort\n+  if (ieee_selected_real_kind(precision(0.d0)+1,range(0.d0)+1) /= -3) call abort\n+\n+end"}, {"sha": "e6bf6125ecd5bd0d67aedc342ad2909922041c0e", "filename": "gcc/testsuite/gfortran.dg/ieee/ieee_rounding_1.f90", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_rounding_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_rounding_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_rounding_1.f90?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,151 @@\n+! { dg-do run }\n+\n+  use, intrinsic :: ieee_features, only : ieee_rounding\n+  use, intrinsic :: ieee_arithmetic\n+  implicit none\n+\n+  interface check_equal\n+    procedure check_equal_float, check_equal_double\n+  end interface\n+\n+  interface check_not_equal\n+    procedure check_not_equal_float, check_not_equal_double\n+  end interface\n+\n+  interface divide\n+    procedure divide_float, divide_double\n+  end interface\n+\n+  real :: sx1, sx2, sx3\n+  double precision :: dx1, dx2, dx3\n+  type(ieee_round_type) :: mode\n+\n+  ! We should support at least C float and C double types\n+  if (ieee_support_rounding(ieee_nearest)) then\n+    if (.not. ieee_support_rounding(ieee_nearest, 0.)) call abort\n+    if (.not. ieee_support_rounding(ieee_nearest, 0.d0)) call abort\n+  end if\n+\n+  ! The initial rounding mode should probably be NEAREST\n+  ! (at least on the platforms we currently support)\n+  if (ieee_support_rounding(ieee_nearest, 0.)) then\n+    call ieee_get_rounding_mode (mode)\n+    if (mode /= ieee_nearest) call abort\n+  end if\n+\n+\n+  if (ieee_support_rounding(ieee_up, sx1) .and. &\n+      ieee_support_rounding(ieee_down, sx1) .and. &\n+      ieee_support_rounding(ieee_nearest, sx1) .and. &\n+      ieee_support_rounding(ieee_to_zero, sx1)) then\n+\n+    sx1 = 1\n+    sx2 = 3\n+    sx1 = divide(sx1, sx2, ieee_up)\n+\n+    sx3 = 1\n+    sx2 = 3\n+    sx3 = divide(sx3, sx2, ieee_down)\n+    call check_not_equal(sx1, sx3)\n+    call check_equal(sx3, nearest(sx1, -1.))\n+    call check_equal(sx1, nearest(sx3,  1.))\n+\n+    call check_equal(1./3., divide(1., 3., ieee_nearest))\n+    call check_equal(-1./3., divide(-1., 3., ieee_nearest))\n+\n+    call check_equal(divide(3., 7., ieee_to_zero), &\n+                    divide(3., 7., ieee_down))\n+    call check_equal(divide(-3., 7., ieee_to_zero), &\n+                    divide(-3., 7., ieee_up))\n+\n+  end if\n+\n+  if (ieee_support_rounding(ieee_up, dx1) .and. &\n+      ieee_support_rounding(ieee_down, dx1) .and. &\n+      ieee_support_rounding(ieee_nearest, dx1) .and. &\n+      ieee_support_rounding(ieee_to_zero, dx1)) then\n+\n+    dx1 = 1\n+    dx2 = 3\n+    dx1 = divide(dx1, dx2, ieee_up)\n+\n+    dx3 = 1\n+    dx2 = 3\n+    dx3 = divide(dx3, dx2, ieee_down)\n+    call check_not_equal(dx1, dx3)\n+    call check_equal(dx3, nearest(dx1, -1.d0))\n+    call check_equal(dx1, nearest(dx3,  1.d0))\n+\n+    call check_equal(1.d0/3.d0, divide(1.d0, 3.d0, ieee_nearest))\n+    call check_equal(-1.d0/3.d0, divide(-1.d0, 3.d0, ieee_nearest))\n+\n+    call check_equal(divide(3.d0, 7.d0, ieee_to_zero), &\n+                    divide(3.d0, 7.d0, ieee_down))\n+    call check_equal(divide(-3.d0, 7.d0, ieee_to_zero), &\n+                    divide(-3.d0, 7.d0, ieee_up))\n+\n+  end if\n+\n+contains\n+\n+  real function divide_float (x, y, rounding) result(res)\n+    use, intrinsic :: ieee_arithmetic\n+    real, intent(in) :: x, y\n+    type(ieee_round_type), intent(in) :: rounding\n+    type(ieee_round_type) :: old\n+\n+    call ieee_get_rounding_mode (old)\n+    call ieee_set_rounding_mode (rounding)\n+\n+    res = x / y\n+\n+    call ieee_set_rounding_mode (old)\n+  end function\n+\n+  double precision function divide_double (x, y, rounding) result(res)\n+    use, intrinsic :: ieee_arithmetic\n+    double precision, intent(in) :: x, y\n+    type(ieee_round_type), intent(in) :: rounding\n+    type(ieee_round_type) :: old\n+\n+    call ieee_get_rounding_mode (old)\n+    call ieee_set_rounding_mode (rounding)\n+\n+    res = x / y\n+\n+    call ieee_set_rounding_mode (old)\n+  end function\n+\n+  subroutine check_equal_float (x, y)\n+    real, intent(in) :: x, y\n+    if (x /= y) then\n+      print *, x, y\n+      call abort\n+    end if\n+  end subroutine\n+\n+  subroutine check_equal_double (x, y)\n+    double precision, intent(in) :: x, y\n+    if (x /= y) then\n+      print *, x, y\n+      call abort\n+    end if\n+  end subroutine\n+\n+  subroutine check_not_equal_float (x, y)\n+    real, intent(in) :: x, y\n+    if (x == y) then\n+      print *, x, y\n+      call abort\n+    end if\n+  end subroutine\n+\n+  subroutine check_not_equal_double (x, y)\n+    double precision, intent(in) :: x, y\n+    if (x == y) then\n+      print *, x, y\n+      call abort\n+    end if\n+  end subroutine\n+\n+end"}, {"sha": "9b31a6581dd37b49093d66c3f87fe009244144d4", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -1110,6 +1110,20 @@ proc check_effective_target_fortran_real_16 { } {\n }\n \n \n+# Return 1 if the target supports Fortran's IEEE modules,\n+# 0 otherwise.\n+#\n+# When the target name changes, replace the cached result.\n+\n+proc check_effective_target_fortran_ieee { flags } {\n+    return [check_no_compiler_messages fortran_ieee executable {\n+\t! Fortran\n+\tuse, intrinsic :: ieee_features\n+\tend\n+    } $flags ]\n+}\n+\n+\n # Return 1 if the target supports SQRT for the largest floating-point\n # type. (Some targets lack the libm support for this FP type.)\n # On most targets, this check effectively checks either whether sqrtl is"}, {"sha": "c4e9949c9d7b773f00af23fe74b946ac3e1e713a", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -1,3 +1,26 @@\n+2014-06-28  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/29383\n+\t* configure.host: Add checks for IEEE support, rework priorities.\n+\t* configure.ac: Define IEEE_SUPPORT, check for fpsetsticky and\n+\tfpresetsticky.\n+\t* configure: Regenerate.\n+\t* Makefile.am: Build new ieee files, install IEEE_* modules.\n+\t* Makefile.in: Regenerate.\n+\t* gfortran.map (GFORTRAN_1.6): Add new symbols.\n+\t* libgfortran.h (get_fpu_trap_exceptions, set_fpu_trap_exceptions,\n+\tsupport_fpu_trap, set_fpu_except_flags, support_fpu_flag,\n+\tsupport_fpu_rounding_mode, get_fpu_state, set_fpu_state): New\n+\tprototypes.\n+\t* config/fpu-*.h (get_fpu_trap_exceptions,\n+\tset_fpu_trap_exceptions, support_fpu_trap, set_fpu_except_flags,\n+\tsupport_fpu_flag, support_fpu_rounding_mode, get_fpu_state,\n+\tset_fpu_state): New functions.\n+\t* ieee/ieee_features.F90: New file.\n+\t* ieee/ieee_exceptions.F90: New file.\n+\t* ieee/ieee_arithmetic.F90: New file.\n+\t* ieee/ieee_helper.c: New file.\n+\n 2014-06-26  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/61499"}, {"sha": "a058a0160391113328143afa717659991ce688cd", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -54,6 +54,11 @@ libcaf_single_la_LDFLAGS = -static\n libcaf_single_la_DEPENDENCIES = caf/libcaf.h\n libcaf_single_la_LINK = $(LINK) $(libcaf_single_la_LDFLAGS)\n \n+if IEEE_SUPPORT\n+fincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)/finclude\n+nodist_finclude_HEADERS = ieee_arithmetic.mod ieee_exceptions.mod ieee_features.mod\n+endif\n+\n ## io.h conflicts with a system header on some platforms, so\n ## use -iquote\n AM_CPPFLAGS = -iquote$(srcdir)/io -I$(srcdir)/$(MULTISRCTOP)../gcc \\\n@@ -70,6 +75,7 @@ AM_CFLAGS += $(SECTION_FLAGS)\n \n # Some targets require additional compiler options for IEEE compatibility.\n AM_CFLAGS += $(IEEE_FLAGS)\n+AM_FCFLAGS += $(IEEE_FLAGS)\n \n gfor_io_src= \\\n io/close.c \\\n@@ -160,6 +166,21 @@ intrinsics/unpack_generic.c \\\n runtime/in_pack_generic.c \\\n runtime/in_unpack_generic.c\n \n+if IEEE_SUPPORT\n+\n+gfor_helper_src+=ieee/ieee_helper.c\n+\n+gfor_ieee_src= \\\n+ieee/ieee_arithmetic.F90 \\\n+ieee/ieee_exceptions.F90 \\\n+ieee/ieee_features.F90\n+\n+else\n+\n+gfor_ieee_src=\n+\n+endif\n+\n gfor_src= \\\n runtime/backtrace.c \\\n runtime/bounds.c \\\n@@ -650,7 +671,7 @@ gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n     $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) $(i_pack_c) $(i_unpack_c) \\\n     $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n-    $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h\n+    $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc\n \n # Machine generated specifics\n gfor_built_specific_src= \\\n@@ -811,11 +832,27 @@ $(patsubst %.c,%.lo,$(notdir $(i_matmull_c))): AM_CFLAGS += -funroll-loops\n $(patsubst %.F90,%.lo,$(patsubst %.f90,%.lo,$(notdir $(gfor_specific_src)))): AM_FCFLAGS += -fallow-leading-underscore\n selected_real_kind.lo selected_int_kind.lo: AM_FCFLAGS += -fallow-leading-underscore\n \n+if IEEE_SUPPORT\n+# Add flags for IEEE modules\n+$(patsubst %.F90,%.lo,$(notdir $(gfor_ieee_src))): AM_FCFLAGS += -Wno-unused-dummy-argument -Wno-c-binding-type -ffree-line-length-0 -fallow-leading-underscore\n+endif\n+\n+# Dependencies between IEEE_ARITHMETIC and IEEE_EXCEPTIONS\n+ieee_arithmetic.lo: ieee/ieee_arithmetic.F90 ieee_exceptions.lo\n+\t$(LTPPFCCOMPILE) -c -o $@ $<\n+\n+ieee_features.mod: ieee_features.lo\n+\t:\n+ieee_exceptions.mod: ieee_exceptions.lo\n+\t:\n+ieee_arithmetic.mod: ieee_arithmetic.lo\n+\t:\n+\n BUILT_SOURCES=$(gfor_built_src) $(gfor_built_specific_src) \\\n     $(gfor_built_specific2_src) $(gfor_misc_specifics)\n \n prereq_SRC = $(gfor_src) $(gfor_built_src) $(gfor_io_src) \\\n-    $(gfor_helper_src) $(gfor_io_headers) $(gfor_specific_src)\n+    $(gfor_helper_src) $(gfor_ieee_src) $(gfor_io_headers) $(gfor_specific_src)\n \n if onestep\n # dummy sources for libtool\n@@ -871,6 +908,10 @@ selected_real_kind.inc: $(srcdir)/mk-srk-inc.sh\n fpu-target.h: $(srcdir)/$(FPU_HOST_HEADER)\n \tcp $(srcdir)/$(FPU_HOST_HEADER) $@\n \n+fpu-target.inc: fpu-target.h $(srcdir)/libgfortran.h\n+\tgrep '^#define GFC_FPE_' < $(top_srcdir)/../gcc/fortran/libgfortran.h > $@ || true\n+\tgrep '^#define GFC_FPE_' < $(srcdir)/libgfortran.h >> $@ || true\n+\n ## A 'normal' build shouldn't need to regenerate these\n ## so we only include them in maintainer mode\n "}, {"sha": "5a3c24a55ec17d1b9955f6e9e82c71d6b6be153d", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 119, "deletions": 87, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -16,6 +16,7 @@\n @SET_MAKE@\n \n \n+\n VPATH = @srcdir@\n pkgdatadir = $(datadir)/@PACKAGE@\n pkgincludedir = $(includedir)/@PACKAGE@\n@@ -36,9 +37,10 @@ POST_UNINSTALL = :\n build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n+@IEEE_SUPPORT_TRUE@am__append_1 = ieee/ieee_helper.c\n \n # dummy sources for libtool\n-@onestep_TRUE@am__append_1 = libgfortran_c.c libgfortran_f.f90\n+@onestep_TRUE@am__append_2 = libgfortran_c.c libgfortran_f.f90\n subdir = .\n DIST_COMMON = ChangeLog $(srcdir)/Makefile.in $(srcdir)/Makefile.am \\\n \t$(top_srcdir)/configure $(am__configure_deps) \\\n@@ -95,7 +97,7 @@ am__uninstall_files_from_dir = { \\\n   }\n am__installdirs = \"$(DESTDIR)$(cafexeclibdir)\" \\\n \t\"$(DESTDIR)$(myexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \\\n-\t\"$(DESTDIR)$(toolexeclibdir)\"\n+\t\"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(fincludedir)\"\n LTLIBRARIES = $(cafexeclib_LTLIBRARIES) $(myexeclib_LTLIBRARIES) \\\n \t$(toolexeclib_LTLIBRARIES)\n libcaf_single_la_LIBADD =\n@@ -245,7 +247,8 @@ am__objects_41 = close.lo file_pos.lo format.lo inquire.lo \\\n \tintrinsics.lo list_read.lo lock.lo open.lo read.lo \\\n \tsize_from_kind.lo transfer.lo transfer128.lo unit.lo unix.lo \\\n \twrite.lo fbuf.lo\n-am__objects_42 = associated.lo abort.lo access.lo args.lo \\\n+@IEEE_SUPPORT_TRUE@am__objects_42 = ieee_helper.lo\n+am__objects_43 = associated.lo abort.lo access.lo args.lo \\\n \tbit_intrinsics.lo c99_functions.lo chdir.lo chmod.lo clock.lo \\\n \tcpu_time.lo cshift0.lo ctime.lo date_and_time.lo dtime.lo \\\n \tenv.lo eoshift0.lo eoshift2.lo erfc_scaled.lo etime.lo \\\n@@ -259,9 +262,11 @@ am__objects_42 = associated.lo abort.lo access.lo args.lo \\\n \tselected_int_kind.lo selected_real_kind.lo stat.lo symlnk.lo \\\n \tsystem_clock.lo time.lo transpose_generic.lo umask.lo \\\n \tunlink.lo unpack_generic.lo in_pack_generic.lo \\\n-\tin_unpack_generic.lo\n-am__objects_43 =\n-am__objects_44 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+\tin_unpack_generic.lo $(am__objects_42)\n+@IEEE_SUPPORT_TRUE@am__objects_44 = ieee_arithmetic.lo \\\n+@IEEE_SUPPORT_TRUE@\tieee_exceptions.lo ieee_features.lo\n+am__objects_45 =\n+am__objects_46 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -285,18 +290,19 @@ am__objects_44 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_45 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_47 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_46 = misc_specifics.lo\n-am__objects_47 = $(am__objects_44) $(am__objects_45) $(am__objects_46) \\\n+am__objects_48 = misc_specifics.lo\n+am__objects_49 = $(am__objects_46) $(am__objects_47) $(am__objects_48) \\\n \tdprod_r8.lo f2c_specifics.lo\n-am__objects_48 = $(am__objects_1) $(am__objects_40) $(am__objects_41) \\\n-\t$(am__objects_42) $(am__objects_43) $(am__objects_47)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_48)\n+am__objects_50 = $(am__objects_1) $(am__objects_40) $(am__objects_41) \\\n+\t$(am__objects_43) $(am__objects_44) $(am__objects_45) \\\n+\t$(am__objects_49)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_50)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n libgfortranbegin_la_LIBADD =\n@@ -336,6 +342,7 @@ MULTISUBDIR =\n MULTIDO = true\n MULTICLEAN = true\n DATA = $(toolexeclib_DATA)\n+HEADERS = $(nodist_finclude_HEADERS)\n ETAGS = etags\n CTAGS = ctags\n ACLOCAL = @ACLOCAL@\n@@ -348,7 +355,7 @@ AMTAR = @AMTAR@\n # Some targets require additional compiler options for IEEE compatibility.\n AM_CFLAGS = @AM_CFLAGS@ -fcx-fortran-rules $(SECTION_FLAGS) \\\n \t$(IEEE_FLAGS)\n-AM_FCFLAGS = @AM_FCFLAGS@\n+AM_FCFLAGS = @AM_FCFLAGS@ $(IEEE_FLAGS)\n AR = @AR@\n AS = @AS@\n AUTOCONF = @AUTOCONF@\n@@ -376,6 +383,7 @@ FGREP = @FGREP@\n FPU_HOST_HEADER = @FPU_HOST_HEADER@\n GREP = @GREP@\n IEEE_FLAGS = @IEEE_FLAGS@\n+IEEE_SUPPORT = @IEEE_SUPPORT@\n INSTALL = @INSTALL@\n INSTALL_DATA = @INSTALL_DATA@\n INSTALL_PROGRAM = @INSTALL_PROGRAM@\n@@ -516,6 +524,8 @@ libcaf_single_la_SOURCES = caf/single.c\n libcaf_single_la_LDFLAGS = -static\n libcaf_single_la_DEPENDENCIES = caf/libcaf.h\n libcaf_single_la_LINK = $(LINK) $(libcaf_single_la_LDFLAGS)\n+@IEEE_SUPPORT_TRUE@fincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)/finclude\n+@IEEE_SUPPORT_TRUE@nodist_finclude_HEADERS = ieee_arithmetic.mod ieee_exceptions.mod ieee_features.mod\n AM_CPPFLAGS = -iquote$(srcdir)/io -I$(srcdir)/$(MULTISRCTOP)../gcc \\\n \t      -I$(srcdir)/$(MULTISRCTOP)../gcc/config $(LIBQUADINCLUDE) \\\n \t      -I$(MULTIBUILDTOP)../../$(host_subdir)/gcc \\\n@@ -546,70 +556,39 @@ io/fbuf.h \\\n io/format.h \\\n io/unix.h\n \n-gfor_helper_src = \\\n-intrinsics/associated.c \\\n-intrinsics/abort.c \\\n-intrinsics/access.c \\\n-intrinsics/args.c \\\n-intrinsics/bit_intrinsics.c \\\n-intrinsics/c99_functions.c \\\n-intrinsics/chdir.c \\\n-intrinsics/chmod.c \\\n-intrinsics/clock.c \\\n-intrinsics/cpu_time.c \\\n-intrinsics/cshift0.c \\\n-intrinsics/ctime.c \\\n-intrinsics/date_and_time.c \\\n-intrinsics/dtime.c \\\n-intrinsics/env.c \\\n-intrinsics/eoshift0.c \\\n-intrinsics/eoshift2.c \\\n-intrinsics/erfc_scaled.c \\\n-intrinsics/etime.c \\\n-intrinsics/execute_command_line.c \\\n-intrinsics/exit.c \\\n-intrinsics/extends_type_of.c \\\n-intrinsics/fnum.c \\\n-intrinsics/gerror.c \\\n-intrinsics/getcwd.c \\\n-intrinsics/getlog.c \\\n-intrinsics/getXid.c \\\n-intrinsics/hostnm.c \\\n-intrinsics/ierrno.c \\\n-intrinsics/ishftc.c \\\n-intrinsics/iso_c_generated_procs.c \\\n-intrinsics/iso_c_binding.c \\\n-intrinsics/kill.c \\\n-intrinsics/link.c \\\n-intrinsics/malloc.c \\\n-intrinsics/mvbits.c \\\n-intrinsics/move_alloc.c \\\n-intrinsics/pack_generic.c \\\n-intrinsics/perror.c \\\n-intrinsics/selected_char_kind.c \\\n-intrinsics/signal.c \\\n-intrinsics/size.c \\\n-intrinsics/sleep.c \\\n-intrinsics/spread_generic.c \\\n-intrinsics/string_intrinsics.c \\\n-intrinsics/system.c \\\n-intrinsics/rand.c \\\n-intrinsics/random.c \\\n-intrinsics/rename.c \\\n-intrinsics/reshape_generic.c \\\n-intrinsics/reshape_packed.c \\\n-intrinsics/selected_int_kind.f90 \\\n-intrinsics/selected_real_kind.f90 \\\n-intrinsics/stat.c \\\n-intrinsics/symlnk.c \\\n-intrinsics/system_clock.c \\\n-intrinsics/time.c \\\n-intrinsics/transpose_generic.c \\\n-intrinsics/umask.c \\\n-intrinsics/unlink.c \\\n-intrinsics/unpack_generic.c \\\n-runtime/in_pack_generic.c \\\n-runtime/in_unpack_generic.c\n+gfor_helper_src = intrinsics/associated.c intrinsics/abort.c \\\n+\tintrinsics/access.c intrinsics/args.c \\\n+\tintrinsics/bit_intrinsics.c intrinsics/c99_functions.c \\\n+\tintrinsics/chdir.c intrinsics/chmod.c intrinsics/clock.c \\\n+\tintrinsics/cpu_time.c intrinsics/cshift0.c intrinsics/ctime.c \\\n+\tintrinsics/date_and_time.c intrinsics/dtime.c intrinsics/env.c \\\n+\tintrinsics/eoshift0.c intrinsics/eoshift2.c \\\n+\tintrinsics/erfc_scaled.c intrinsics/etime.c \\\n+\tintrinsics/execute_command_line.c intrinsics/exit.c \\\n+\tintrinsics/extends_type_of.c intrinsics/fnum.c \\\n+\tintrinsics/gerror.c intrinsics/getcwd.c intrinsics/getlog.c \\\n+\tintrinsics/getXid.c intrinsics/hostnm.c intrinsics/ierrno.c \\\n+\tintrinsics/ishftc.c intrinsics/iso_c_generated_procs.c \\\n+\tintrinsics/iso_c_binding.c intrinsics/kill.c intrinsics/link.c \\\n+\tintrinsics/malloc.c intrinsics/mvbits.c \\\n+\tintrinsics/move_alloc.c intrinsics/pack_generic.c \\\n+\tintrinsics/perror.c intrinsics/selected_char_kind.c \\\n+\tintrinsics/signal.c intrinsics/size.c intrinsics/sleep.c \\\n+\tintrinsics/spread_generic.c intrinsics/string_intrinsics.c \\\n+\tintrinsics/system.c intrinsics/rand.c intrinsics/random.c \\\n+\tintrinsics/rename.c intrinsics/reshape_generic.c \\\n+\tintrinsics/reshape_packed.c intrinsics/selected_int_kind.f90 \\\n+\tintrinsics/selected_real_kind.f90 intrinsics/stat.c \\\n+\tintrinsics/symlnk.c intrinsics/system_clock.c \\\n+\tintrinsics/time.c intrinsics/transpose_generic.c \\\n+\tintrinsics/umask.c intrinsics/unlink.c \\\n+\tintrinsics/unpack_generic.c runtime/in_pack_generic.c \\\n+\truntime/in_unpack_generic.c $(am__append_1)\n+@IEEE_SUPPORT_FALSE@gfor_ieee_src = \n+@IEEE_SUPPORT_TRUE@gfor_ieee_src = \\\n+@IEEE_SUPPORT_TRUE@ieee/ieee_arithmetic.F90 \\\n+@IEEE_SUPPORT_TRUE@ieee/ieee_exceptions.F90 \\\n+@IEEE_SUPPORT_TRUE@ieee/ieee_features.F90\n \n gfor_src = \\\n runtime/backtrace.c \\\n@@ -1100,7 +1079,7 @@ gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n     $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) $(i_pack_c) $(i_unpack_c) \\\n     $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n-    $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h\n+    $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc\n \n \n # Machine generated specifics\n@@ -1254,9 +1233,9 @@ intrinsics/f2c_specifics.F90\n \n BUILT_SOURCES = $(gfor_built_src) $(gfor_built_specific_src) \\\n \t$(gfor_built_specific2_src) $(gfor_misc_specifics) \\\n-\t$(am__append_1)\n+\t$(am__append_2)\n prereq_SRC = $(gfor_src) $(gfor_built_src) $(gfor_io_src) \\\n-    $(gfor_helper_src) $(gfor_io_headers) $(gfor_specific_src)\n+    $(gfor_helper_src) $(gfor_ieee_src) $(gfor_io_headers) $(gfor_specific_src)\n \n @onestep_FALSE@libgfortran_la_SOURCES = $(prereq_SRC)\n \n@@ -1538,6 +1517,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iany_i2.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iany_i4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iany_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ieee_helper.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ierrno.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_c10.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_c16.Plo@am__quote@\n@@ -1919,6 +1899,12 @@ distclean-compile:\n .F90.lo:\n \t$(LTPPFCCOMPILE) -c -o $@ $<\n \n+ieee_exceptions.lo: ieee/ieee_exceptions.F90\n+\t$(LIBTOOL)  --tag=FC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(FC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_FCFLAGS) $(FCFLAGS) -c -o ieee_exceptions.lo `test -f 'ieee/ieee_exceptions.F90' || echo '$(srcdir)/'`ieee/ieee_exceptions.F90\n+\n+ieee_features.lo: ieee/ieee_features.F90\n+\t$(LIBTOOL)  --tag=FC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(FC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_FCFLAGS) $(FCFLAGS) -c -o ieee_features.lo `test -f 'ieee/ieee_features.F90' || echo '$(srcdir)/'`ieee/ieee_features.F90\n+\n _abs_c4.lo: $(srcdir)/generated/_abs_c4.F90\n \t$(LIBTOOL)  --tag=FC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(FC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_FCFLAGS) $(FCFLAGS) -c -o _abs_c4.lo `test -f '$(srcdir)/generated/_abs_c4.F90' || echo '$(srcdir)/'`$(srcdir)/generated/_abs_c4.F90\n \n@@ -5630,6 +5616,13 @@ in_unpack_generic.lo: runtime/in_unpack_generic.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_unpack_generic.lo `test -f 'runtime/in_unpack_generic.c' || echo '$(srcdir)/'`runtime/in_unpack_generic.c\n \n+ieee_helper.lo: ieee/ieee_helper.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ieee_helper.lo -MD -MP -MF $(DEPDIR)/ieee_helper.Tpo -c -o ieee_helper.lo `test -f 'ieee/ieee_helper.c' || echo '$(srcdir)/'`ieee/ieee_helper.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/ieee_helper.Tpo $(DEPDIR)/ieee_helper.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='ieee/ieee_helper.c' object='ieee_helper.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ieee_helper.lo `test -f 'ieee/ieee_helper.c' || echo '$(srcdir)/'`ieee/ieee_helper.c\n+\n .f90.o:\n \t$(FCCOMPILE) -c -o $@ $<\n \n@@ -5691,6 +5684,24 @@ uninstall-toolexeclibDATA:\n \t@list='$(toolexeclib_DATA)'; test -n \"$(toolexeclibdir)\" || list=; \\\n \tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n \tdir='$(DESTDIR)$(toolexeclibdir)'; $(am__uninstall_files_from_dir)\n+install-nodist_fincludeHEADERS: $(nodist_finclude_HEADERS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(fincludedir)\" || $(MKDIR_P) \"$(DESTDIR)$(fincludedir)\"\n+\t@list='$(nodist_finclude_HEADERS)'; test -n \"$(fincludedir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(fincludedir)'\"; \\\n+\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(fincludedir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-nodist_fincludeHEADERS:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(nodist_finclude_HEADERS)'; test -n \"$(fincludedir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\tdir='$(DESTDIR)$(fincludedir)'; $(am__uninstall_files_from_dir)\n \n ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n \tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n@@ -5746,9 +5757,9 @@ distclean-tags:\n check-am: all-am\n check: $(BUILT_SOURCES)\n \t$(MAKE) $(AM_MAKEFLAGS) check-am\n-all-am: Makefile $(LTLIBRARIES) all-multi $(DATA) config.h\n+all-am: Makefile $(LTLIBRARIES) all-multi $(DATA) $(HEADERS) config.h\n installdirs:\n-\tfor dir in \"$(DESTDIR)$(cafexeclibdir)\" \"$(DESTDIR)$(myexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(cafexeclibdir)\" \"$(DESTDIR)$(myexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(fincludedir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: $(BUILT_SOURCES)\n@@ -5808,7 +5819,7 @@ info: info-am\n \n info-am:\n \n-install-data-am:\n+install-data-am: install-nodist_fincludeHEADERS\n \n install-dvi: install-dvi-am\n \n@@ -5859,7 +5870,8 @@ ps: ps-am\n ps-am:\n \n uninstall-am: uninstall-cafexeclibLTLIBRARIES \\\n-\tuninstall-myexeclibLTLIBRARIES uninstall-toolexeclibDATA \\\n+\tuninstall-myexeclibLTLIBRARIES \\\n+\tuninstall-nodist_fincludeHEADERS uninstall-toolexeclibDATA \\\n \tuninstall-toolexeclibLTLIBRARIES\n \n .MAKE: all all-multi check clean-multi distclean-multi install \\\n@@ -5876,15 +5888,17 @@ uninstall-am: uninstall-cafexeclibLTLIBRARIES \\\n \tinstall-data install-data-am install-dvi install-dvi-am \\\n \tinstall-exec install-exec-am install-html install-html-am \\\n \tinstall-info install-info-am install-man install-multi \\\n-\tinstall-myexeclibLTLIBRARIES install-pdf install-pdf-am \\\n-\tinstall-ps install-ps-am install-strip install-toolexeclibDATA \\\n+\tinstall-myexeclibLTLIBRARIES install-nodist_fincludeHEADERS \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip install-toolexeclibDATA \\\n \tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n \tinstalldirs maintainer-clean maintainer-clean-generic \\\n \tmaintainer-clean-multi mostlyclean mostlyclean-compile \\\n \tmostlyclean-generic mostlyclean-libtool mostlyclean-multi pdf \\\n \tpdf-am ps ps-am tags uninstall uninstall-am \\\n \tuninstall-cafexeclibLTLIBRARIES uninstall-myexeclibLTLIBRARIES \\\n-\tuninstall-toolexeclibDATA uninstall-toolexeclibLTLIBRARIES\n+\tuninstall-nodist_fincludeHEADERS uninstall-toolexeclibDATA \\\n+\tuninstall-toolexeclibLTLIBRARIES\n \n @LIBGFOR_USE_SYMVER_SUN_TRUE@@LIBGFOR_USE_SYMVER_TRUE@gfortran.map-sun : $(srcdir)/gfortran.map \\\n @LIBGFOR_USE_SYMVER_SUN_TRUE@@LIBGFOR_USE_SYMVER_TRUE@\t\t$(top_srcdir)/../contrib/make_sunver.pl \\\n@@ -5904,6 +5918,20 @@ $(patsubst %.c,%.lo,$(notdir $(i_matmull_c))): AM_CFLAGS += -funroll-loops\n # Add the -fallow-leading-underscore option when needed\n $(patsubst %.F90,%.lo,$(patsubst %.f90,%.lo,$(notdir $(gfor_specific_src)))): AM_FCFLAGS += -fallow-leading-underscore\n selected_real_kind.lo selected_int_kind.lo: AM_FCFLAGS += -fallow-leading-underscore\n+\n+# Add flags for IEEE modules\n+@IEEE_SUPPORT_TRUE@$(patsubst %.F90,%.lo,$(notdir $(gfor_ieee_src))): AM_FCFLAGS += -Wno-unused-dummy-argument -Wno-c-binding-type -ffree-line-length-0 -fallow-leading-underscore\n+\n+# Dependencies between IEEE_ARITHMETIC and IEEE_EXCEPTIONS\n+ieee_arithmetic.lo: ieee/ieee_arithmetic.F90 ieee_exceptions.lo\n+\t$(LTPPFCCOMPILE) -c -o $@ $<\n+\n+ieee_features.mod: ieee_features.lo\n+\t:\n+ieee_exceptions.mod: ieee_exceptions.lo\n+\t:\n+ieee_arithmetic.mod: ieee_arithmetic.lo\n+\t:\n @onestep_TRUE@libgfortran_c.c libgfortran_f.f90 libgfortran_F.F90:\n @onestep_TRUE@\techo > $@\n # overrides for libtool perusing the dummy sources\n@@ -5931,6 +5959,10 @@ selected_real_kind.inc: $(srcdir)/mk-srk-inc.sh\n fpu-target.h: $(srcdir)/$(FPU_HOST_HEADER)\n \tcp $(srcdir)/$(FPU_HOST_HEADER) $@\n \n+fpu-target.inc: fpu-target.h $(srcdir)/libgfortran.h\n+\tgrep '^#define GFC_FPE_' < $(top_srcdir)/../gcc/fortran/libgfortran.h > $@ || true\n+\tgrep '^#define GFC_FPE_' < $(srcdir)/libgfortran.h >> $@ || true\n+\n @MAINTAINER_MODE_TRUE@$(i_all_c): m4/all.m4 $(I_M4_DEPS2)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 all.m4 > $@\n "}, {"sha": "46720b20e8dc2ae52935235d8742e048727adc76", "filename": "libgfortran/config/fpu-387.h", "status": "modified", "additions": 260, "deletions": 14, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfig%2Ffpu-387.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfig%2Ffpu-387.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig%2Ffpu-387.h?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -23,6 +23,8 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n+#include <assert.h>\n+\n #ifndef __SSE_MATH__\n #include \"cpuid.h\"\n #endif\n@@ -62,24 +64,122 @@ has_sse (void)\n \n #define _FPU_RC_MASK    0x3\n \n+/* This structure corresponds to the layout of the block\n+   written by FSTENV.  */\n+typedef struct\n+{\n+  unsigned short int __control_word;\n+  unsigned short int __unused1;\n+  unsigned short int __status_word;\n+  unsigned short int __unused2;\n+  unsigned short int __tags;\n+  unsigned short int __unused3;\n+  unsigned int __eip;\n+  unsigned short int __cs_selector;\n+  unsigned int __opcode:11;\n+  unsigned int __unused4:5;\n+  unsigned int __data_offset;\n+  unsigned short int __data_selector;\n+  unsigned short int __unused5;\n+  unsigned int __mxcsr;\n+}\n+my_fenv_t;\n+\n+\n+/* Raise the supported floating-point exceptions from EXCEPTS.  Other\n+   bits in EXCEPTS are ignored.  Code originally borrowed from\n+   libatomic/config/x86/fenv.c.  */\n+\n+static void\n+local_feraiseexcept (int excepts)\n+{\n+  if (excepts & _FPU_MASK_IM)\n+    {\n+      float f = 0.0f;\n+#ifdef __SSE_MATH__\n+      volatile float r __attribute__ ((unused));\n+      __asm__ __volatile__ (\"%vdivss\\t{%0, %d0|%d0, %0}\" : \"+x\" (f));\n+      r = f; /* Needed to trigger exception.   */\n+#else\n+      __asm__ __volatile__ (\"fdiv\\t{%y0, %0|%0, %y0}\" : \"+t\" (f));\n+      /* No need for fwait, exception is triggered by emitted fstp.  */\n+#endif\n+    }\n+  if (excepts & _FPU_MASK_DM)\n+    {\n+      my_fenv_t temp;\n+      __asm__ __volatile__ (\"fnstenv\\t%0\" : \"=m\" (temp));\n+      temp.__status_word |= _FPU_MASK_DM;\n+      __asm__ __volatile__ (\"fldenv\\t%0\" : : \"m\" (temp));\n+      __asm__ __volatile__ (\"fwait\");\n+    }\n+  if (excepts & _FPU_MASK_ZM)\n+    {\n+      float f = 1.0f, g = 0.0f;\n+#ifdef __SSE_MATH__\n+      volatile float r __attribute__ ((unused));\n+      __asm__ __volatile__ (\"%vdivss\\t{%1, %d0|%d0, %1}\" : \"+x\" (f) : \"xm\" (g));\n+      r = f; /* Needed to trigger exception.   */\n+#else\n+      __asm__ __volatile__ (\"fdivs\\t%1\" : \"+t\" (f) : \"m\" (g));\n+      /* No need for fwait, exception is triggered by emitted fstp.  */\n+#endif\n+    }\n+  if (excepts & _FPU_MASK_OM)\n+    {\n+      my_fenv_t temp;\n+      __asm__ __volatile__ (\"fnstenv\\t%0\" : \"=m\" (temp));\n+      temp.__status_word |= _FPU_MASK_OM;\n+      __asm__ __volatile__ (\"fldenv\\t%0\" : : \"m\" (temp));\n+      __asm__ __volatile__ (\"fwait\");\n+    }\n+  if (excepts & _FPU_MASK_UM)\n+    {\n+      my_fenv_t temp;\n+      __asm__ __volatile__ (\"fnstenv\\t%0\" : \"=m\" (temp));\n+      temp.__status_word |= _FPU_MASK_UM;\n+      __asm__ __volatile__ (\"fldenv\\t%0\" : : \"m\" (temp));\n+      __asm__ __volatile__ (\"fwait\");\n+    }\n+  if (excepts & _FPU_MASK_PM)\n+    {\n+      float f = 1.0f, g = 3.0f;\n+#ifdef __SSE_MATH__\n+      volatile float r __attribute__ ((unused));\n+      __asm__ __volatile__ (\"%vdivss\\t{%1, %d0|%d0, %1}\" : \"+x\" (f) : \"xm\" (g));\n+      r = f; /* Needed to trigger exception.   */\n+#else\n+      __asm__ __volatile__ (\"fdivs\\t%1\" : \"+t\" (f) : \"m\" (g));\n+      /* No need for fwait, exception is triggered by emitted fstp.  */\n+#endif\n+    }\n+}\n+\n \n void\n-set_fpu (void)\n+set_fpu_trap_exceptions (int trap, int notrap)\n {\n-  int excepts = 0;\n+  int exc_set = 0, exc_clr = 0;\n   unsigned short cw;\n \n-  __asm__ __volatile__ (\"fstcw\\t%0\" : \"=m\" (cw));\n+  if (trap & GFC_FPE_INVALID) exc_set |= _FPU_MASK_IM;\n+  if (trap & GFC_FPE_DENORMAL) exc_set |= _FPU_MASK_DM;\n+  if (trap & GFC_FPE_ZERO) exc_set |= _FPU_MASK_ZM;\n+  if (trap & GFC_FPE_OVERFLOW) exc_set |= _FPU_MASK_OM;\n+  if (trap & GFC_FPE_UNDERFLOW) exc_set |= _FPU_MASK_UM;\n+  if (trap & GFC_FPE_INEXACT) exc_set |= _FPU_MASK_PM;\n+\n+  if (notrap & GFC_FPE_INVALID) exc_clr |= _FPU_MASK_IM;\n+  if (notrap & GFC_FPE_DENORMAL) exc_clr |= _FPU_MASK_DM;\n+  if (notrap & GFC_FPE_ZERO) exc_clr |= _FPU_MASK_ZM;\n+  if (notrap & GFC_FPE_OVERFLOW) exc_clr |= _FPU_MASK_OM;\n+  if (notrap & GFC_FPE_UNDERFLOW) exc_clr |= _FPU_MASK_UM;\n+  if (notrap & GFC_FPE_INEXACT) exc_clr |= _FPU_MASK_PM;\n \n-  if (options.fpe & GFC_FPE_INVALID) excepts |= _FPU_MASK_IM;\n-  if (options.fpe & GFC_FPE_DENORMAL) excepts |= _FPU_MASK_DM;\n-  if (options.fpe & GFC_FPE_ZERO) excepts |= _FPU_MASK_ZM;\n-  if (options.fpe & GFC_FPE_OVERFLOW) excepts |= _FPU_MASK_OM;\n-  if (options.fpe & GFC_FPE_UNDERFLOW) excepts |= _FPU_MASK_UM;\n-  if (options.fpe & GFC_FPE_INEXACT) excepts |= _FPU_MASK_PM;\n+  __asm__ __volatile__ (\"fstcw\\t%0\" : \"=m\" (cw));\n \n-  cw |= _FPU_MASK_ALL;\n-  cw &= ~excepts;\n+  cw |= exc_clr;\n+  cw &= ~exc_set;\n \n   __asm__ __volatile__ (\"fnclex\\n\\tfldcw\\t%0\" : : \"m\" (cw));\n \n@@ -90,8 +190,8 @@ set_fpu (void)\n       __asm__ __volatile__ (\"%vstmxcsr\\t%0\" : \"=m\" (cw_sse));\n \n       /* The SSE exception masks are shifted by 7 bits.  */\n-      cw_sse |= _FPU_MASK_ALL << 7;\n-      cw_sse &= ~(excepts << 7);\n+      cw_sse |= (exc_clr << 7);\n+      cw_sse &= ~(exc_set << 7);\n \n       /* Clear stalled exception flags.  */\n       cw_sse &= ~_FPU_EX_ALL;\n@@ -100,14 +200,55 @@ set_fpu (void)\n     }\n }\n \n+void\n+set_fpu (void)\n+{\n+  set_fpu_trap_exceptions (options.fpe, 0);\n+}\n+\n+int\n+get_fpu_trap_exceptions (void)\n+{\n+  int res = 0;\n+  unsigned short cw;\n+\n+  __asm__ __volatile__ (\"fstcw\\t%0\" : \"=m\" (cw));\n+  cw &= _FPU_MASK_ALL;\n+\n+  if (has_sse())\n+    {\n+      unsigned int cw_sse;\n+\n+      __asm__ __volatile__ (\"%vstmxcsr\\t%0\" : \"=m\" (cw_sse));\n+\n+      /* The SSE exception masks are shifted by 7 bits.  */\n+      cw = cw | ((cw_sse >> 7) & _FPU_MASK_ALL);\n+    }\n+\n+  if (~cw & _FPU_MASK_IM) res |= GFC_FPE_INVALID;\n+  if (~cw & _FPU_MASK_DM) res |= GFC_FPE_DENORMAL;\n+  if (~cw & _FPU_MASK_ZM) res |= GFC_FPE_ZERO;\n+  if (~cw & _FPU_MASK_OM) res |= GFC_FPE_OVERFLOW;\n+  if (~cw & _FPU_MASK_UM) res |= GFC_FPE_UNDERFLOW;\n+  if (~cw & _FPU_MASK_PM) res |= GFC_FPE_INEXACT;\n+\n+  return res;\n+}\n+\n+int\n+support_fpu_trap (int flag __attribute__((unused)))\n+{\n+  return 1;\n+}\n+\n int\n get_fpu_except_flags (void)\n {\n   unsigned short cw;\n   int excepts;\n   int result = 0;\n \n-  __asm__ __volatile__ (\"fnstsw\\t%0\" : \"=a\" (cw));\n+  __asm__ __volatile__ (\"fnstsw\\t%0\" : \"=am\" (cw));\n   excepts = cw;\n \n   if (has_sse())\n@@ -130,6 +271,70 @@ get_fpu_except_flags (void)\n   return result;\n }\n \n+void\n+set_fpu_except_flags (int set, int clear)\n+{\n+  my_fenv_t temp;\n+  int exc_set = 0, exc_clr = 0;\n+\n+  /* Translate from GFC_PE_* values to _FPU_MASK_* values.  */\n+  if (set & GFC_FPE_INVALID)\n+    exc_set |= _FPU_MASK_IM;\n+  if (clear & GFC_FPE_INVALID)\n+    exc_clr |= _FPU_MASK_IM;\n+\n+  if (set & GFC_FPE_DENORMAL)\n+    exc_set |= _FPU_MASK_DM;\n+  if (clear & GFC_FPE_DENORMAL)\n+    exc_clr |= _FPU_MASK_DM;\n+\n+  if (set & GFC_FPE_ZERO)\n+    exc_set |= _FPU_MASK_ZM;\n+  if (clear & GFC_FPE_ZERO)\n+    exc_clr |= _FPU_MASK_ZM;\n+\n+  if (set & GFC_FPE_OVERFLOW)\n+    exc_set |= _FPU_MASK_OM;\n+  if (clear & GFC_FPE_OVERFLOW)\n+    exc_clr |= _FPU_MASK_OM;\n+\n+  if (set & GFC_FPE_UNDERFLOW)\n+    exc_set |= _FPU_MASK_UM;\n+  if (clear & GFC_FPE_UNDERFLOW)\n+    exc_clr |= _FPU_MASK_UM;\n+\n+  if (set & GFC_FPE_INEXACT)\n+    exc_set |= _FPU_MASK_PM;\n+  if (clear & GFC_FPE_INEXACT)\n+    exc_clr |= _FPU_MASK_PM;\n+\n+\n+  /* Change the flags. This is tricky on 387 (unlike SSE), because we have\n+     FNSTSW but no FLDSW instruction.  */\n+  __asm__ __volatile__ (\"fnstenv\\t%0\" : \"=m\" (temp));\n+  temp.__status_word &= ~exc_clr;\n+  __asm__ __volatile__ (\"fldenv\\t%0\" : : \"m\" (temp));\n+\n+  /* Change the flags on SSE.  */\n+\n+  if (has_sse())\n+  {\n+    unsigned int cw_sse;\n+\n+    __asm__ __volatile__ (\"%vstmxcsr\\t%0\" : \"=m\" (cw_sse));\n+    cw_sse &= ~exc_clr;\n+    __asm__ __volatile__ (\"%vldmxcsr\\t%0\" : : \"m\" (cw_sse));\n+  }\n+\n+  local_feraiseexcept (exc_set);\n+}\n+\n+int\n+support_fpu_flag (int flag __attribute__((unused)))\n+{\n+  return 1;\n+}\n+\n void\n set_fpu_rounding_mode (int round)\n {\n@@ -213,3 +418,44 @@ get_fpu_rounding_mode (void)\n       return GFC_FPE_INVALID; /* Should be unreachable.  */\n     }\n }\n+\n+int\n+support_fpu_rounding_mode (int mode __attribute__((unused)))\n+{\n+  return 1;\n+}\n+\n+void\n+get_fpu_state (void *state)\n+{\n+  my_fenv_t *envp = state;\n+\n+  /* Check we can actually store the FPU state in the allocated size.  */\n+  assert (sizeof(my_fenv_t) <= (size_t) GFC_FPE_STATE_BUFFER_SIZE);\n+\n+  __asm__ __volatile__ (\"fnstenv\\t%0\" : \"=m\" (*envp));\n+\n+  /* fnstenv has the side effect of masking all exceptions, so we need\n+     to restore the control word after that.  */\n+  __asm__ __volatile__ (\"fldcw\\t%0\" : : \"m\" (envp->__control_word));\n+\n+  if (has_sse())\n+    __asm__ __volatile__ (\"%vstmxcsr\\t%0\" : \"=m\" (envp->__mxcsr));\n+}\n+\n+void\n+set_fpu_state (void *state)\n+{\n+  my_fenv_t *envp = state;\n+\n+  /* Check we can actually store the FPU state in the allocated size.  */\n+  assert (sizeof(my_fenv_t) <= (size_t) GFC_FPE_STATE_BUFFER_SIZE);\n+\n+  /* glibc sources (sysdeps/x86_64/fpu/fesetenv.c) do something more\n+     complex than this, but I think it suffices in our case.  */\n+  __asm__ __volatile__ (\"fldenv\\t%0\" : : \"m\" (*envp));\n+\n+  if (has_sse())\n+    __asm__ __volatile__ (\"%vldmxcsr\\t%0\" : : \"m\" (envp->__mxcsr));\n+}\n+"}, {"sha": "6b44ab7c850ec7e86587193a090c0355afce3e28", "filename": "libgfortran/config/fpu-aix.h", "status": "modified", "additions": 247, "deletions": 20, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfig%2Ffpu-aix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfig%2Ffpu-aix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig%2Ffpu-aix.h?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -33,15 +33,103 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <fpxcp.h>\n #endif\n \n+#ifdef HAVE_FENV_H\n+#include <fenv.h>\n+#endif\n+\n+\n void\n-set_fpu (void)\n+set_fpu_trap_exceptions (int trap, int notrap)\n {\n-  fptrap_t mode = 0;\n+  fptrap_t mode_set = 0, mode_clr = 0;\n \n-  if (options.fpe & GFC_FPE_INVALID)\n #ifdef TRP_INVALID\n-    mode |= TRP_INVALID;\n-#else\n+  if (trap & GFC_FPE_INVALID)\n+    mode_set |= TRP_INVALID;\n+  if (notrap & GFC_FPE_INVALID)\n+    mode_clr |= TRP_INVALID;\n+#endif\n+\n+#ifdef TRP_DIV_BY_ZERO\n+  if (trap & GFC_FPE_ZERO)\n+    mode_set |= TRP_DIV_BY_ZERO;\n+  if (notrap & GFC_FPE_ZERO)\n+    mode_clr |= TRP_DIV_BY_ZERO;\n+#endif\n+\n+#ifdef TRP_OVERFLOW\n+  if (trap & GFC_FPE_OVERFLOW)\n+    mode_set |= TRP_OVERFLOW;\n+  if (notrap & GFC_FPE_OVERFLOW)\n+    mode_clr |= TRP_OVERFLOW;\n+#endif\n+\n+#ifdef TRP_UNDERFLOW\n+  if (trap & GFC_FPE_UNDERFLOW)\n+    mode_set |= TRP_UNDERFLOW;\n+  if (notrap & GFC_FPE_UNDERFLOW)\n+    mode_clr |= TRP_UNDERFLOW;\n+#endif\n+\n+#ifdef TRP_INEXACT\n+  if (trap & GFC_FPE_INEXACT)\n+    mode_set |= TRP_INEXACT;\n+  if (notrap & GFC_FPE_INEXACT)\n+    mode_clr |= TRP_INEXACT;\n+#endif\n+\n+  fp_trap (FP_TRAP_SYNC);\n+  fp_enable (mode_set);\n+  fp_disable (mode_clr);\n+}\n+\n+\n+int\n+get_fpu_trap_exceptions (void)\n+{\n+  int res = 0;\n+\n+#ifdef TRP_INVALID\n+  if (fp_is_enabled (TRP_INVALID))\n+    res |= GFC_FPE_INVALID;\n+#endif\n+\n+#ifdef TRP_DIV_BY_ZERO\n+  if (fp_is_enabled (TRP_DIV_BY_ZERO))\n+    res |= GFC_FPE_ZERO;\n+#endif\n+\n+#ifdef TRP_OVERFLOW\n+  if (fp_is_enabled (TRP_OVERFLOW))\n+    res |= GFC_FPE_OVERFLOW;\n+#endif\n+\n+#ifdef TRP_UNDERFLOW\n+  if (fp_is_enabled (TRP_UNDERFLOW))\n+    res |= GFC_FPE_UNDERFLOW;\n+#endif\n+\n+#ifdef TRP_INEXACT\n+  if (fp_is_enabled (TRP_INEXACT))\n+    res |= GFC_FPE_INEXACT;\n+#endif\n+\n+  return res;\n+}\n+\n+\n+int\n+support_fpu_trap (int flag)\n+{\n+  return support_fpu_flag (flag);\n+}\n+\n+\n+void\n+set_fpu (void)\n+{\n+#ifndef TRP_INVALID\n+  if (options.fpe & GFC_FPE_INVALID)\n     estr_write (\"Fortran runtime warning: IEEE 'invalid operation' \"\n \t        \"exception not supported.\\n\");\n #endif\n@@ -50,43 +138,33 @@ set_fpu (void)\n     estr_write (\"Fortran runtime warning: Floating point 'denormal operand' \"\n \t        \"exception not supported.\\n\");\n \n+#ifndef TRP_DIV_BY_ZERO\n   if (options.fpe & GFC_FPE_ZERO)\n-#ifdef TRP_DIV_BY_ZERO\n-    mode |= TRP_DIV_BY_ZERO;\n-#else\n     estr_write (\"Fortran runtime warning: IEEE 'division by zero' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n+#ifndef TRP_OVERFLOW\n   if (options.fpe & GFC_FPE_OVERFLOW)\n-#ifdef TRP_OVERFLOW\n-    mode |= TRP_OVERFLOW;\n-#else\n     estr_write (\"Fortran runtime warning: IEEE 'overflow' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n+#ifndef TRP_UNDERFLOW\n   if (options.fpe & GFC_FPE_UNDERFLOW)\n-#ifdef TRP_UNDERFLOW\n-    mode |= TRP_UNDERFLOW;\n-#else\n     estr_write (\"Fortran runtime warning: IEEE 'underflow' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n+#ifndef TRP_INEXACT\n   if (options.fpe & GFC_FPE_INEXACT)\n-#ifdef TRP_INEXACT\n-    mode |= TRP_INEXACT;\n-#else\n     estr_write (\"Fortran runtime warning: IEEE 'inexact' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n-  fp_trap(FP_TRAP_SYNC);\n-  fp_enable(mode);\n+  set_fpu_trap_exceptions (options.fpe, 0);\n }\n \n-\n int\n get_fpu_except_flags (void)\n {\n@@ -118,6 +196,98 @@ get_fpu_except_flags (void)\n }\n \n \n+void\n+set_fpu_except_flags (int set, int clear)\n+{\n+  int exc_set = 0, exc_clr = 0;\n+\n+#ifdef FP_INVALID\n+  if (set & GFC_FPE_INVALID)\n+    exc_set |= FP_INVALID;\n+  else if (clear & GFC_FPE_INVALID)\n+    exc_clr |= FP_INVALID;\n+#endif\n+\n+#ifdef FP_DIV_BY_ZERO\n+  if (set & GFC_FPE_ZERO)\n+    exc_set |= FP_DIV_BY_ZERO;\n+  else if (clear & GFC_FPE_ZERO)\n+    exc_clr |= FP_DIV_BY_ZERO;\n+#endif\n+\n+#ifdef FP_OVERFLOW\n+  if (set & GFC_FPE_OVERFLOW)\n+    exc_set |= FP_OVERFLOW;\n+  else if (clear & GFC_FPE_OVERFLOW)\n+    exc_clr |= FP_OVERFLOW;\n+#endif\n+\n+#ifdef FP_UNDERFLOW\n+  if (set & GFC_FPE_UNDERFLOW)\n+    exc_set |= FP_UNDERFLOW;\n+  else if (clear & GFC_FPE_UNDERFLOW)\n+    exc_clr |= FP_UNDERFLOW;\n+#endif\n+\n+/* AIX does not have FP_DENORMAL.  */\n+\n+#ifdef FP_INEXACT\n+  if (set & GFC_FPE_INEXACT)\n+    exc_set |= FP_INEXACT;\n+  else if (clear & GFC_FPE_INEXACT)\n+    exc_clr |= FP_INEXACT;\n+#endif\n+\n+  fp_clr_flag (exc_clr);\n+  fp_set_flag (exc_set);\n+}\n+\n+\n+int\n+support_fpu_flag (int flag)\n+{\n+  if (flag & GFC_FPE_INVALID)\n+  {\n+#ifndef FP_INVALID\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_ZERO)\n+  {\n+#ifndef FP_DIV_BY_ZERO\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_OVERFLOW)\n+  {\n+#ifndef FP_OVERFLOW\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_UNDERFLOW)\n+  {\n+#ifndef FP_UNDERFLOW\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_DENORMAL)\n+  {\n+    /* AIX does not support denormal flag.  */\n+    return 0;\n+  }\n+  else if (flag & GFC_FPE_INEXACT)\n+  {\n+#ifndef FP_INEXACT\n+    return 0;\n+#endif\n+  }\n+\n+  return 1;\n+}\n+\n+\n+\n+\n int\n get_fpu_rounding_mode (void)\n {\n@@ -188,3 +358,60 @@ set_fpu_rounding_mode (int mode)\n \n   fesetround (rnd_mode);\n }\n+\n+\n+int\n+support_fpu_rounding_mode (int mode)\n+{\n+  switch (mode)\n+    {\n+      case GFC_FPE_TONEAREST:\n+#ifdef FE_TONEAREST\n+\treturn 1;\n+#else\n+\treturn 0;\n+#endif\n+\n+#ifdef FE_UPWARD\n+\treturn 1;\n+#else\n+\treturn 0;\n+#endif\n+\n+#ifdef FE_DOWNWARD\n+\treturn 1;\n+#else\n+\treturn 0;\n+#endif\n+\n+#ifdef FE_TOWARDZERO\n+\treturn 1;\n+#else\n+\treturn 0;\n+#endif\n+\n+      default:\n+\treturn 0;\n+    }\n+}\n+\n+\n+\n+void\n+get_fpu_state (void *state)\n+{\n+  /* Check we can actually store the FPU state in the allocated size.  */\n+  assert (sizeof(fenv_t) <= GFC_FPE_STATE_BUFFER_SIZE);\n+\n+  fegetenv (state);\n+}\n+\n+void\n+set_fpu_state (void *state)\n+{\n+  /* Check we can actually store the FPU state in the allocated size.  */\n+  assert (sizeof(fenv_t) <= GFC_FPE_STATE_BUFFER_SIZE);\n+\n+  fesetenv (state);\n+}\n+"}, {"sha": "bbad875f40ef670206b59e53c55d2d744cd3a8e6", "filename": "libgfortran/config/fpu-generic.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfig%2Ffpu-generic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfig%2Ffpu-generic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig%2Ffpu-generic.h?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -51,6 +51,12 @@ set_fpu (void)\n \t        \"exception not supported.\\n\");\n }\n \n+void\n+set_fpu_trap_exceptions (int trap __attribute__((unused)),\n+\t\t\t int notrap __attribute__((unused)))\n+{\n+}\n+\n int\n get_fpu_except_flags (void)\n {"}, {"sha": "695b9d3fbb0e1c55de5a386dfcf0724ff5848052", "filename": "libgfortran/config/fpu-glibc.h", "status": "modified", "additions": 252, "deletions": 21, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfig%2Ffpu-glibc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfig%2Ffpu-glibc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig%2Ffpu-glibc.h?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -27,63 +27,141 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    feenableexcept function in fenv.h to set individual exceptions\n    (there's nothing to do that in C99).  */\n \n+#include <assert.h>\n+\n #ifdef HAVE_FENV_H\n #include <fenv.h>\n #endif\n \n-void set_fpu (void)\n-{\n-  if (FE_ALL_EXCEPT != 0)\n-    fedisableexcept (FE_ALL_EXCEPT);\n \n-  if (options.fpe & GFC_FPE_INVALID)\n+void set_fpu_trap_exceptions (int trap, int notrap)\n+{\n #ifdef FE_INVALID\n+  if (trap & GFC_FPE_INVALID)\n     feenableexcept (FE_INVALID);\n-#else\n+  if (notrap & GFC_FPE_INVALID)\n+    fedisableexcept (FE_INVALID);\n+#endif\n+\n+/* glibc does never have a FE_DENORMAL.  */\n+#ifdef FE_DENORMAL\n+  if (trap & GFC_FPE_DENORMAL)\n+    feenableexcept (FE_DENORMAL);\n+  if (notrap & GFC_FPE_DENORMAL)\n+    fedisableexcept (FE_DENORMAL);\n+#endif\n+\n+#ifdef FE_DIVBYZERO\n+  if (trap & GFC_FPE_ZERO)\n+    feenableexcept (FE_DIVBYZERO);\n+  if (notrap & GFC_FPE_ZERO)\n+    fedisableexcept (FE_DIVBYZERO);\n+#endif\n+\n+#ifdef FE_OVERFLOW\n+  if (trap & GFC_FPE_OVERFLOW)\n+    feenableexcept (FE_OVERFLOW);\n+  if (notrap & GFC_FPE_OVERFLOW)\n+    fedisableexcept (FE_OVERFLOW);\n+#endif\n+\n+#ifdef FE_UNDERFLOW\n+  if (trap & GFC_FPE_UNDERFLOW)\n+    feenableexcept (FE_UNDERFLOW);\n+  if (notrap & GFC_FPE_UNDERFLOW)\n+    fedisableexcept (FE_UNDERFLOW);\n+#endif\n+\n+#ifdef FE_INEXACT\n+  if (trap & GFC_FPE_INEXACT)\n+    feenableexcept (FE_INEXACT);\n+  if (notrap & GFC_FPE_INEXACT)\n+    fedisableexcept (FE_INEXACT);\n+#endif\n+}\n+\n+\n+int\n+get_fpu_trap_exceptions (void)\n+{\n+  int exceptions = fegetexcept ();\n+  int res = 0;\n+\n+#ifdef FE_INVALID\n+  if (exceptions & FE_INVALID) res |= GFC_FPE_INVALID;\n+#endif\n+\n+#ifdef FE_DENORMAL\n+  if (exceptions & FE_DENORMAL) res |= GFC_FPE_DENORMAL;\n+#endif\n+\n+#ifdef FE_DIVBYZERO\n+  if (exceptions & FE_DIVBYZERO) res |= GFC_FPE_ZERO;\n+#endif\n+\n+#ifdef FE_OVERFLOW\n+  if (exceptions & FE_OVERFLOW) res |= GFC_FPE_OVERFLOW;\n+#endif\n+\n+#ifdef FE_UNDERFLOW\n+  if (exceptions & FE_UNDERFLOW) res |= GFC_FPE_UNDERFLOW;\n+#endif\n+\n+#ifdef FE_INEXACT\n+  if (exceptions & FE_INEXACT) res |= GFC_FPE_INEXACT;\n+#endif\n+\n+  return res;\n+}\n+\n+\n+int\n+support_fpu_trap (int flag)\n+{\n+  return support_fpu_flag (flag);\n+}\n+\n+\n+void set_fpu (void)\n+{\n+#ifndef FE_INVALID\n+  if (options.fpe & GFC_FPE_INVALID)\n     estr_write (\"Fortran runtime warning: IEEE 'invalid operation' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n /* glibc does never have a FE_DENORMAL.  */\n+#ifndef FE_DENORMAL\n   if (options.fpe & GFC_FPE_DENORMAL)\n-#ifdef FE_DENORMAL\n-    feenableexcept (FE_DENORMAL);\n-#else\n     estr_write (\"Fortran runtime warning: Floating point 'denormal operand' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n+#ifndef FE_DIVBYZERO\n   if (options.fpe & GFC_FPE_ZERO)\n-#ifdef FE_DIVBYZERO\n-    feenableexcept (FE_DIVBYZERO);\n-#else\n     estr_write (\"Fortran runtime warning: IEEE 'division by zero' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n+#ifndef FE_OVERFLOW\n   if (options.fpe & GFC_FPE_OVERFLOW)\n-#ifdef FE_OVERFLOW\n-    feenableexcept (FE_OVERFLOW);\n-#else\n     estr_write (\"Fortran runtime warning: IEEE 'overflow' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n+#ifndef FE_UNDERFLOW\n   if (options.fpe & GFC_FPE_UNDERFLOW)\n-#ifdef FE_UNDERFLOW\n-    feenableexcept (FE_UNDERFLOW);\n-#else\n     estr_write (\"Fortran runtime warning: IEEE 'underflow' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n+#ifndef FE_INEXACT\n   if (options.fpe & GFC_FPE_INEXACT)\n-#ifdef FE_INEXACT\n-    feenableexcept (FE_INEXACT);\n-#else\n     estr_write (\"Fortran runtime warning: IEEE 'inexact' \"\n \t        \"exception not supported.\\n\");\n #endif\n+\n+  set_fpu_trap_exceptions (options.fpe, 0);\n }\n \n \n@@ -129,6 +207,102 @@ get_fpu_except_flags (void)\n }\n \n \n+void\n+set_fpu_except_flags (int set, int clear)\n+{\n+  int exc_set = 0, exc_clr = 0;\n+\n+#ifdef FE_INVALID\n+  if (set & GFC_FPE_INVALID)\n+    exc_set |= FE_INVALID;\n+  else if (clear & GFC_FPE_INVALID)\n+    exc_clr |= FE_INVALID;\n+#endif\n+\n+#ifdef FE_DIVBYZERO\n+  if (set & GFC_FPE_ZERO)\n+    exc_set |= FE_DIVBYZERO;\n+  else if (clear & GFC_FPE_ZERO)\n+    exc_clr |= FE_DIVBYZERO;\n+#endif\n+\n+#ifdef FE_OVERFLOW\n+  if (set & GFC_FPE_OVERFLOW)\n+    exc_set |= FE_OVERFLOW;\n+  else if (clear & GFC_FPE_OVERFLOW)\n+    exc_clr |= FE_OVERFLOW;\n+#endif\n+\n+#ifdef FE_UNDERFLOW\n+  if (set & GFC_FPE_UNDERFLOW)\n+    exc_set |= FE_UNDERFLOW;\n+  else if (clear & GFC_FPE_UNDERFLOW)\n+    exc_clr |= FE_UNDERFLOW;\n+#endif\n+\n+#ifdef FE_DENORMAL\n+  if (set & GFC_FPE_DENORMAL)\n+    exc_set |= FE_DENORMAL;\n+  else if (clear & GFC_FPE_DENORMAL)\n+    exc_clr |= FE_DENORMAL;\n+#endif\n+\n+#ifdef FE_INEXACT\n+  if (set & GFC_FPE_INEXACT)\n+    exc_set |= FE_INEXACT;\n+  else if (clear & GFC_FPE_INEXACT)\n+    exc_clr |= FE_INEXACT;\n+#endif\n+\n+  feclearexcept (exc_clr);\n+  feraiseexcept (exc_set);\n+}\n+\n+\n+int\n+support_fpu_flag (int flag)\n+{\n+  if (flag & GFC_FPE_INVALID)\n+  {\n+#ifndef FE_INVALID\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_ZERO)\n+  {\n+#ifndef FE_DIVBYZERO\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_OVERFLOW)\n+  {\n+#ifndef FE_OVERFLOW\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_UNDERFLOW)\n+  {\n+#ifndef FE_UNDERFLOW\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_DENORMAL)\n+  {\n+#ifndef FE_DENORMAL\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_INEXACT)\n+  {\n+#ifndef FE_INEXACT\n+    return 0;\n+#endif\n+  }\n+\n+  return 1;\n+}\n+\n+\n int\n get_fpu_rounding_mode (void)\n {\n@@ -199,3 +373,60 @@ set_fpu_rounding_mode (int mode)\n \n   fesetround (rnd_mode);\n }\n+\n+\n+int\n+support_fpu_rounding_mode (int mode)\n+{\n+  switch (mode)\n+    {\n+      case GFC_FPE_TONEAREST:\n+#ifdef FE_TONEAREST\n+\treturn 1;\n+#else\n+\treturn 0;\n+#endif\n+\n+#ifdef FE_UPWARD\n+\treturn 1;\n+#else\n+\treturn 0;\n+#endif\n+\n+#ifdef FE_DOWNWARD\n+\treturn 1;\n+#else\n+\treturn 0;\n+#endif\n+\n+#ifdef FE_TOWARDZERO\n+\treturn 1;\n+#else\n+\treturn 0;\n+#endif\n+\n+      default:\n+\treturn 0;\n+    }\n+}\n+\n+\n+void\n+get_fpu_state (void *state)\n+{\n+  /* Check we can actually store the FPU state in the allocated size.  */\n+  assert (sizeof(fenv_t) <= GFC_FPE_STATE_BUFFER_SIZE);\n+\n+  fegetenv (state);\n+}\n+\n+\n+void\n+set_fpu_state (void *state)\n+{\n+  /* Check we can actually store the FPU state in the allocated size.  */\n+  assert (sizeof(fenv_t) <= GFC_FPE_STATE_BUFFER_SIZE);\n+\n+  fesetenv (state);\n+}\n+"}, {"sha": "0105cf74b8b9dc6ef8ca67e1ad00b9406346683d", "filename": "libgfortran/config/fpu-sysv.h", "status": "modified", "additions": 301, "deletions": 34, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfig%2Ffpu-sysv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfig%2Ffpu-sysv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig%2Ffpu-sysv.h?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -25,73 +25,174 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n /* FPU-related code for SysV platforms with fpsetmask().  */\n \n+/* BSD and Solaris systems have slightly different types and functions\n+   naming.  We deal with these here, to simplify the code below.  */\n+\n+#if HAVE_FP_EXCEPT\n+# define FP_EXCEPT_TYPE fp_except\n+#elif HAVE_FP_EXCEPT_T\n+# define FP_EXCEPT_TYPE fp_except_t\n+#else\n+  choke me\n+#endif\n+\n+#if HAVE_FP_RND\n+# define FP_RND_TYPE fp_rnd\n+#elif HAVE_FP_RND_T\n+# define FP_RND_TYPE fp_rnd_t\n+#else\n+  choke me\n+#endif\n+\n+#if HAVE_FPSETSTICKY\n+# define FPSETSTICKY fpsetsticky\n+#elif HAVE_FPRESETSTICKY\n+# define FPSETSTICKY fpresetsticky\n+#else\n+  choke me\n+#endif\n+\n+\n void\n-set_fpu (void)\n+set_fpu_trap_exceptions (int trap, int notrap)\n {\n-  int cw = 0;\n+  FP_EXCEPT_TYPE cw = fpgetmask();\n \n-  if (options.fpe & GFC_FPE_INVALID)\n #ifdef FP_X_INV\n+  if (trap & GFC_FPE_INVALID)\n     cw |= FP_X_INV;\n-#else\n+  if (notrap & GFC_FPE_INVALID)\n+    cw &= ~FP_X_INV;\n+#endif\n+\n+#ifdef FP_X_DNML\n+  if (trap & GFC_FPE_DENORMAL)\n+    cw |= FP_X_DNML;\n+  if (notrap & GFC_FPE_DENORMAL)\n+    cw &= ~FP_X_DNML;\n+#endif\n+\n+#ifdef FP_X_DZ\n+  if (trap & GFC_FPE_ZERO)\n+    cw |= FP_X_DZ;\n+  if (notrap & GFC_FPE_ZERO)\n+    cw &= ~FP_X_DZ;\n+#endif\n+\n+#ifdef FP_X_OFL\n+  if (trap & GFC_FPE_OVERFLOW)\n+    cw |= FP_X_OFL;\n+  if (notrap & GFC_FPE_OVERFLOW)\n+    cw &= ~FP_X_OFL;\n+#endif\n+\n+#ifdef FP_X_UFL\n+  if (trap & GFC_FPE_UNDERFLOW)\n+    cw |= FP_X_UFL;\n+  if (notrap & GFC_FPE_UNDERFLOW)\n+    cw &= ~FP_X_UFL;\n+#endif\n+\n+#ifdef FP_X_IMP\n+  if (trap & GFC_FPE_INEXACT)\n+    cw |= FP_X_IMP;\n+  if (notrap & GFC_FPE_INEXACT)\n+    cw &= ~FP_X_IMP;\n+#endif\n+\n+  fpsetmask(cw);\n+}\n+\n+\n+int\n+get_fpu_trap_exceptions (void)\n+{\n+  int res = 0;\n+  FP_EXCEPT_TYPE cw = fpgetmask();\n+\n+#ifdef FP_X_INV\n+  if (cw & FP_X_INV) res |= GFC_FPE_INVALID;\n+#endif\n+\n+#ifdef FP_X_DNML\n+  if (cw & FP_X_DNML) res |= GFC_FPE_DENORMAL;\n+#endif\n+\n+#ifdef FP_X_DZ\n+  if (cw & FP_X_DZ) res |= GFC_FPE_ZERO;\n+#endif\n+\n+#ifdef FP_X_OFL\n+  if (cw & FP_X_OFL) res |= GFC_FPE_OVERFLOW;\n+#endif\n+\n+#ifdef FP_X_UFL\n+  if (cw & FP_X_UFL) res |= GFC_FPE_UNDERFLOW;\n+#endif\n+\n+#ifdef FP_X_IMP\n+  if (cw & FP_X_IMP) res |= GFC_FPE_INEXACT;\n+#endif\n+\n+  return res;\n+}\n+\n+\n+int\n+support_fpu_trap (int flag)\n+{\n+  return support_fpu_flag (flag);\n+}\n+\n+\n+void\n+set_fpu (void)\n+{\n+#ifndef FP_X_INV\n+  if (options.fpe & GFC_FPE_INVALID)\n     estr_write (\"Fortran runtime warning: IEEE 'invalid operation' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n+#ifndef FP_X_DNML\n   if (options.fpe & GFC_FPE_DENORMAL)\n-#ifdef FP_X_DNML\n-    cw |= FP_X_DNML;\n-#else\n     estr_write (\"Fortran runtime warning: Floating point 'denormal operand' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n+#ifndef FP_X_DZ\n   if (options.fpe & GFC_FPE_ZERO)\n-#ifdef FP_X_DZ\n-    cw |= FP_X_DZ;\n-#else\n     estr_write (\"Fortran runtime warning: IEEE 'division by zero' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n+#ifndef FP_X_OFL\n   if (options.fpe & GFC_FPE_OVERFLOW)\n-#ifdef FP_X_OFL\n-    cw |= FP_X_OFL;\n-#else\n     estr_write (\"Fortran runtime warning: IEEE 'overflow' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n+#ifndef FP_X_UFL\n   if (options.fpe & GFC_FPE_UNDERFLOW)\n-#ifdef FP_X_UFL\n-    cw |= FP_X_UFL;\n-#else\n     estr_write (\"Fortran runtime warning: IEEE 'underflow' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n+#ifndef FP_X_IMP\n   if (options.fpe & GFC_FPE_INEXACT)\n-#ifdef FP_X_IMP\n-    cw |= FP_X_IMP;\n-#else\n     estr_write (\"Fortran runtime warning: IEEE 'inexact' \"\n \t        \"exception not supported.\\n\");\n #endif\n \n-  fpsetmask(cw);\n+  set_fpu_trap_exceptions (options.fpe, 0);\n }\n \n+\n int\n get_fpu_except_flags (void)\n {\n   int result;\n-#if HAVE_FP_EXCEPT\n-  fp_except set_excepts;\n-#elif HAVE_FP_EXCEPT_T\n-  fp_except_t set_excepts;\n-#else\n-  choke me\n-#endif\n+  FP_EXCEPT_TYPE set_excepts;\n \n   result = 0;\n   set_excepts = fpgetsticky ();\n@@ -130,6 +231,103 @@ get_fpu_except_flags (void)\n }\n \n \n+void\n+set_fpu_except_flags (int set, int clear)\n+{\n+  FP_EXCEPT_TYPE flags;\n+\n+  flags = fpgetsticky ();\n+\n+#ifdef FP_X_INV\n+  if (set & GFC_FPE_INVALID)\n+    flags |= FP_X_INV;\n+  if (clear & GFC_FPE_INVALID)\n+    flags &= ~FP_X_INV;\n+#endif\n+\n+#ifdef FP_X_DZ\n+  if (set & GFC_FPE_ZERO)\n+    flags |= FP_X_DZ;\n+  if (clear & GFC_FPE_ZERO)\n+    flags &= ~FP_X_DZ;\n+#endif\n+\n+#ifdef FP_X_OFL\n+  if (set & GFC_FPE_OVERFLOW)\n+    flags |= FP_X_OFL;\n+  if (clear & GFC_FPE_OVERFLOW)\n+    flags &= ~FP_X_OFL;\n+#endif\n+\n+#ifdef FP_X_UFL\n+  if (set & GFC_FPE_UNDERFLOW)\n+    flags |= FP_X_UFL;\n+  if (clear & GFC_FPE_UNDERFLOW)\n+    flags &= ~FP_X_UFL;\n+#endif\n+\n+#ifdef FP_X_DNML\n+  if (set & GFC_FPE_DENORMAL)\n+    flags |= FP_X_DNML;\n+  if (clear & GFC_FPE_DENORMAL)\n+    flags &= ~FP_X_DNML;\n+#endif\n+\n+#ifdef FP_X_IMP\n+  if (set & GFC_FPE_INEXACT)\n+    flags |= FP_X_IMP;\n+  if (clear & GFC_FPE_INEXACT)\n+    flags &= ~FP_X_IMP;\n+#endif\n+\n+  FPSETSTICKY (flags);\n+}\n+\n+\n+int\n+support_fpu_flag (int flag)\n+{\n+  if (flag & GFC_FPE_INVALID)\n+  {\n+#ifndef FP_X_INV\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_ZERO)\n+  {\n+#ifndef FP_X_DZ\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_OVERFLOW)\n+  {\n+#ifndef FP_X_OFL\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_UNDERFLOW)\n+  {\n+#ifndef FP_X_UFL\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_DENORMAL)\n+  {\n+#ifndef FP_X_DNML\n+    return 0;\n+#endif\n+  }\n+  else if (flag & GFC_FPE_INEXACT)\n+  {\n+#ifndef FP_X_IMP\n+    return 0;\n+#endif\n+  }\n+\n+  return 1;\n+}\n+\n+\n int\n get_fpu_rounding_mode (void)\n {\n@@ -163,13 +361,7 @@ get_fpu_rounding_mode (void)\n void\n set_fpu_rounding_mode (int mode)\n {\n-#if HAVE_FP_RND\n-  fp_rnd rnd_mode;\n-#elif HAVE_FP_RND_T\n-  fp_rnd_t rnd_mode;\n-#else\n-  choke me\n-#endif\n+  FP_RND_TYPE rnd_mode;\n \n   switch (mode)\n     {\n@@ -201,3 +393,78 @@ set_fpu_rounding_mode (int mode)\n     }\n   fpsetround (rnd_mode);\n }\n+\n+\n+int\n+support_fpu_rounding_mode (int mode)\n+{\n+  switch (mode)\n+    {\n+      case GFC_FPE_TONEAREST:\n+#ifdef FP_RN\n+\treturn 1;\n+#else\n+\treturn 0;\n+#endif\n+\n+      case GFC_FPE_UPWARD:\n+#ifdef FP_RP\n+\treturn 1;\n+#else\n+\treturn 0;\n+#endif\n+\n+      case GFC_FPE_DOWNWARD:\n+#ifdef FP_RM\n+\treturn 1;\n+#else\n+\treturn 0;\n+#endif\n+\n+      case GFC_FPE_TOWARDZERO:\n+#ifdef FP_RZ\n+\treturn 1;\n+#else\n+\treturn 0;\n+#endif\n+\n+      default:\n+\treturn 0;\n+    }\n+}\n+\n+\n+typedef struct\n+{\n+  FP_EXCEPT_TYPE mask;\n+  FP_EXCEPT_TYPE sticky;\n+  FP_RND_TYPE round;\n+} fpu_state_t;\n+\n+\n+void\n+get_fpu_state (void *s)\n+{\n+  fpu_state_t *state = s;\n+\n+  /* Check we can actually store the FPU state in the allocated size.  */\n+  assert (sizeof(fpu_state_t) <= GFC_FPE_STATE_BUFFER_SIZE);\n+\n+  state->mask = fpgetmask ();\n+  state->sticky = fpgetsticky ();\n+  state->round = fpgetround ();\n+}\n+\n+void\n+set_fpu_state (void *s)\n+{\n+  fpu_state_t *state = s;\n+\n+  /* Check we can actually store the FPU state in the allocated size.  */\n+  assert (sizeof(fpu_state_t) <= GFC_FPE_STATE_BUFFER_SIZE);\n+\n+  fpsetmask (state->mask);\n+  FPSETSTICKY (state->sticky);\n+  fpsetround (state->round);\n+}\n+"}, {"sha": "f123c48dba225aebd893ff46217299e2a75068ed", "filename": "libgfortran/configure", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -606,6 +606,9 @@ am__EXEEXT_TRUE\n LTLIBOBJS\n LIBOBJS\n IEEE_FLAGS\n+IEEE_SUPPORT\n+IEEE_SUPPORT_FALSE\n+IEEE_SUPPORT_TRUE\n FPU_HOST_HEADER\n LIBGFOR_BUILD_QUAD_FALSE\n LIBGFOR_BUILD_QUAD_TRUE\n@@ -12346,7 +12349,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12349 \"configure\"\n+#line 12352 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12452,7 +12455,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12455 \"configure\"\n+#line 12458 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -26119,9 +26122,22 @@ fi\n . ${srcdir}/configure.host\n { $as_echo \"$as_me:${as_lineno-$LINENO}: FPU dependent file will be ${fpu_host}.h\" >&5\n $as_echo \"$as_me: FPU dependent file will be ${fpu_host}.h\" >&6;}\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: Support for IEEE modules: ${ieee_support}\" >&5\n+$as_echo \"$as_me: Support for IEEE modules: ${ieee_support}\" >&6;}\n FPU_HOST_HEADER=config/${fpu_host}.h\n \n \n+# Whether we will build the IEEE modules\n+ if test x${ieee_support} = xyes; then\n+  IEEE_SUPPORT_TRUE=\n+  IEEE_SUPPORT_FALSE='#'\n+else\n+  IEEE_SUPPORT_TRUE='#'\n+  IEEE_SUPPORT_FALSE=\n+fi\n+\n+\n+\n # Some targets require additional compiler options for IEEE compatibility.\n IEEE_FLAGS=\"${ieee_flags}\"\n \n@@ -26765,6 +26781,10 @@ if test -z \"${LIBGFOR_BUILD_QUAD_TRUE}\" && test -z \"${LIBGFOR_BUILD_QUAD_FALSE}\"\n   as_fn_error \"conditional \\\"LIBGFOR_BUILD_QUAD\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${IEEE_SUPPORT_TRUE}\" && test -z \"${IEEE_SUPPORT_FALSE}\"; then\n+  as_fn_error \"conditional \\\"IEEE_SUPPORT\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n \n : ${CONFIG_STATUS=./config.status}\n ac_write_fail=0"}, {"sha": "be4b7beba04acb3e1a0c5cd884f60ebe7b492be3", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -530,6 +530,10 @@ AC_CHECK_TYPES([fp_rnd,fp_rnd_t], [], [], [[\n #include <math.h>\n ]])\n \n+# Check whether we have fpsetsticky or fpresetsticky\n+AC_CHECK_FUNC([fpsetsticky],[have_fpsetsticky=yes AC_DEFINE([HAVE_FPSETSTICKY],[1],[fpsetsticky is present])])\n+AC_CHECK_FUNC([fpresetsticky],[have_fpresetsticky=yes AC_DEFINE([HAVE_FPRESETSTICKY],[1],[fpresetsticky is present])])\n+\n # Check for AIX fp_trap and fp_enable\n AC_CHECK_FUNC([fp_trap],[have_fp_trap=yes AC_DEFINE([HAVE_FP_TRAP],[1],[fp_trap is present])])\n AC_CHECK_FUNC([fp_enable],[have_fp_enable=yes AC_DEFINE([HAVE_FP_ENABLE],[1],[fp_enable is present])])\n@@ -539,9 +543,14 @@ AC_CHECK_FUNC([fp_enable],[have_fp_enable=yes AC_DEFINE([HAVE_FP_ENABLE],[1],[fp\n # build chain.\n . ${srcdir}/configure.host\n AC_MSG_NOTICE([FPU dependent file will be ${fpu_host}.h])\n+AC_MSG_NOTICE([Support for IEEE modules: ${ieee_support}])\n FPU_HOST_HEADER=config/${fpu_host}.h\n AC_SUBST(FPU_HOST_HEADER)\n \n+# Whether we will build the IEEE modules\n+AM_CONDITIONAL(IEEE_SUPPORT,[test x${ieee_support} = xyes])\n+AC_SUBST(IEEE_SUPPORT)\n+\n # Some targets require additional compiler options for IEEE compatibility.\n IEEE_FLAGS=\"${ieee_flags}\"\n AC_SUBST(IEEE_FLAGS)"}, {"sha": "72da478ac5e7ce51d9e0d24206a20d5e5b6cc165", "filename": "libgfortran/configure.host", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.host?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -19,26 +19,32 @@\n \n # DEFAULTS\n fpu_host='fpu-generic'\n+ieee_support='no'\n+\n+if test \"x${have_fp_enable}\" = \"xyes\" && test \"x${have_fp_trap}\" = \"xyes\"; then\n+  fpu_host='fpu-aix'\n+  ieee_support='yes'\n+fi\n+\n+if test \"x${have_fpsetmask}\" = \"xyes\"; then\n+  fpu_host='fpu-sysv'\n+  ieee_support='yes'\n+fi\n \n if test \"x${have_feenableexcept}\" = \"xyes\"; then\n   fpu_host='fpu-glibc'\n+  ieee_support='yes'\n fi\n \n # x86 asm should be used instead of glibc, since glibc doesn't support\n # the x86 denormal exception.\n case \"${host_cpu}\" in\n   i?86 | x86_64)\n-    fpu_host='fpu-387' ;;\n+    fpu_host='fpu-387'\n+    ieee_support='yes'\n+    ;;\n esac\n \n-if test \"x${have_fpsetmask}\" = \"xyes\"; then\n-  fpu_host='fpu-sysv'\n-fi\n-\n-if test \"x${have_fp_enable}\" = \"xyes\" && test \"x${have_fp_trap}\" = \"xyes\"; then\n-  fpu_host='fpu-aix'\n-fi\n-\n # Some targets require additional compiler options for NaN/Inf.\n ieee_flags=\n case \"${host_cpu}\" in"}, {"sha": "20f7f289b595603d2b46ba2e831d3ff55e0b7c3c", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -1195,6 +1195,117 @@ GFORTRAN_1.5 {\n     _gfortran_backtrace;\n } GFORTRAN_1.4; \n \n+GFORTRAN_1.6 {\n+  global:\n+    _gfortran_ieee_copy_sign_4_4_;\n+    _gfortran_ieee_copy_sign_4_8_;\n+    _gfortran_ieee_copy_sign_8_4_;\n+    _gfortran_ieee_copy_sign_8_8_;\n+    _gfortran_ieee_is_finite_4_;\n+    _gfortran_ieee_is_finite_8_;\n+    _gfortran_ieee_is_nan_4_;\n+    _gfortran_ieee_is_nan_8_;\n+    _gfortran_ieee_is_negative_4_;\n+    _gfortran_ieee_is_negative_8_;\n+    _gfortran_ieee_is_normal_4_;\n+    _gfortran_ieee_is_normal_8_;\n+    _gfortran_ieee_logb_4_;\n+    _gfortran_ieee_logb_8_;\n+    _gfortran_ieee_next_after_4_4_;\n+    _gfortran_ieee_next_after_4_8_;\n+    _gfortran_ieee_next_after_8_4_;\n+    _gfortran_ieee_next_after_8_8_;\n+    _gfortran_ieee_procedure_entry;\n+    _gfortran_ieee_procedure_exit;\n+    _gfortran_ieee_rem_4_4_;\n+    _gfortran_ieee_rem_4_8_;\n+    _gfortran_ieee_rem_8_4_;\n+    _gfortran_ieee_rem_8_8_;\n+    _gfortran_ieee_rint_4_;\n+    _gfortran_ieee_rint_8_;\n+    _gfortran_ieee_scalb_4_;\n+    _gfortran_ieee_scalb_8_;\n+    _gfortran_ieee_unordered_4_4_;\n+    _gfortran_ieee_unordered_4_8_;\n+    _gfortran_ieee_unordered_8_4_;\n+    _gfortran_ieee_unordered_8_8_;\n+    __ieee_arithmetic_MOD_ieee_class_4;\n+    __ieee_arithmetic_MOD_ieee_class_8;\n+    __ieee_arithmetic_MOD_ieee_class_type_eq;\n+    __ieee_arithmetic_MOD_ieee_class_type_ne;\n+    __ieee_arithmetic_MOD_ieee_get_rounding_mode;\n+    __ieee_arithmetic_MOD_ieee_get_underflow_mode;\n+    __ieee_arithmetic_MOD_ieee_round_type_eq;\n+    __ieee_arithmetic_MOD_ieee_round_type_ne;\n+    __ieee_arithmetic_MOD_ieee_selected_real_kind;\n+    __ieee_arithmetic_MOD_ieee_set_rounding_mode;\n+    __ieee_arithmetic_MOD_ieee_set_underflow_mode;\n+    __ieee_arithmetic_MOD_ieee_support_datatype_4;\n+    __ieee_arithmetic_MOD_ieee_support_datatype_8;\n+    __ieee_arithmetic_MOD_ieee_support_datatype_10;\n+    __ieee_arithmetic_MOD_ieee_support_datatype_16;\n+    __ieee_arithmetic_MOD_ieee_support_datatype_noarg;\n+    __ieee_arithmetic_MOD_ieee_support_denormal_4;\n+    __ieee_arithmetic_MOD_ieee_support_denormal_8;\n+    __ieee_arithmetic_MOD_ieee_support_denormal_10;\n+    __ieee_arithmetic_MOD_ieee_support_denormal_16;\n+    __ieee_arithmetic_MOD_ieee_support_denormal_noarg;\n+    __ieee_arithmetic_MOD_ieee_support_divide_4;\n+    __ieee_arithmetic_MOD_ieee_support_divide_8;\n+    __ieee_arithmetic_MOD_ieee_support_divide_10;\n+    __ieee_arithmetic_MOD_ieee_support_divide_16;\n+    __ieee_arithmetic_MOD_ieee_support_divide_noarg;\n+    __ieee_arithmetic_MOD_ieee_support_inf_4;\n+    __ieee_arithmetic_MOD_ieee_support_inf_8;\n+    __ieee_arithmetic_MOD_ieee_support_inf_10;\n+    __ieee_arithmetic_MOD_ieee_support_inf_16;\n+    __ieee_arithmetic_MOD_ieee_support_inf_noarg;\n+    __ieee_arithmetic_MOD_ieee_support_io_4;\n+    __ieee_arithmetic_MOD_ieee_support_io_8;\n+    __ieee_arithmetic_MOD_ieee_support_io_10;\n+    __ieee_arithmetic_MOD_ieee_support_io_16;\n+    __ieee_arithmetic_MOD_ieee_support_io_noarg;\n+    __ieee_arithmetic_MOD_ieee_support_nan_4;\n+    __ieee_arithmetic_MOD_ieee_support_nan_8;\n+    __ieee_arithmetic_MOD_ieee_support_nan_10;\n+    __ieee_arithmetic_MOD_ieee_support_nan_16;\n+    __ieee_arithmetic_MOD_ieee_support_nan_noarg;\n+    __ieee_arithmetic_MOD_ieee_support_rounding_4;\n+    __ieee_arithmetic_MOD_ieee_support_rounding_8;\n+    __ieee_arithmetic_MOD_ieee_support_rounding_10;\n+    __ieee_arithmetic_MOD_ieee_support_rounding_16;\n+    __ieee_arithmetic_MOD_ieee_support_rounding_noarg;\n+    __ieee_arithmetic_MOD_ieee_support_sqrt_4;\n+    __ieee_arithmetic_MOD_ieee_support_sqrt_8;\n+    __ieee_arithmetic_MOD_ieee_support_sqrt_10;\n+    __ieee_arithmetic_MOD_ieee_support_sqrt_16;\n+    __ieee_arithmetic_MOD_ieee_support_sqrt_noarg;\n+    __ieee_arithmetic_MOD_ieee_support_standard_4;\n+    __ieee_arithmetic_MOD_ieee_support_standard_8;\n+    __ieee_arithmetic_MOD_ieee_support_standard_10;\n+    __ieee_arithmetic_MOD_ieee_support_standard_16;\n+    __ieee_arithmetic_MOD_ieee_support_standard_noarg;\n+    __ieee_arithmetic_MOD_ieee_support_underflow_control_4;\n+    __ieee_arithmetic_MOD_ieee_support_underflow_control_8;\n+    __ieee_arithmetic_MOD_ieee_support_underflow_control_10;\n+    __ieee_arithmetic_MOD_ieee_support_underflow_control_16;\n+    __ieee_arithmetic_MOD_ieee_support_underflow_control_noarg;\n+    __ieee_arithmetic_MOD_ieee_value_4;\n+    __ieee_arithmetic_MOD_ieee_value_8;\n+    __ieee_exceptions_MOD_ieee_all;\n+    __ieee_exceptions_MOD_ieee_get_flag;\n+    __ieee_exceptions_MOD_ieee_get_halting_mode;\n+    __ieee_exceptions_MOD_ieee_get_status;\n+    __ieee_exceptions_MOD_ieee_set_flag;\n+    __ieee_exceptions_MOD_ieee_set_halting_mode;\n+    __ieee_exceptions_MOD_ieee_set_status;\n+    __ieee_exceptions_MOD_ieee_support_flag_4;\n+    __ieee_exceptions_MOD_ieee_support_flag_8;\n+    __ieee_exceptions_MOD_ieee_support_flag_noarg;\n+    __ieee_exceptions_MOD_ieee_support_halting;\n+    __ieee_exceptions_MOD_ieee_usual;\n+} GFORTRAN_1.5; \n+\n F2C_1.0 {\n   global:\n     _gfortran_f2c_specific__abs_c4;"}, {"sha": "1dce4f79ee4e3dcb34863242ded2e6d7c1021fab", "filename": "libgfortran/ieee/ieee_arithmetic.F90", "status": "added", "additions": 817, "deletions": 0, "changes": 817, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fieee%2Fieee_arithmetic.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fieee%2Fieee_arithmetic.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_arithmetic.F90?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,817 @@\n+!    Implementation of the IEEE_ARITHMETIC standard intrinsic module\n+!    Copyright (C) 2013 Free Software Foundation, Inc.\n+!    Contributed by Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+! \n+! This file is part of the GNU Fortran runtime library (libgfortran).\n+! \n+! Libgfortran is free software; you can redistribute it and/or\n+! modify it under the terms of the GNU General Public\n+! License as published by the Free Software Foundation; either\n+! version 3 of the License, or (at your option) any later version.\n+! \n+! Libgfortran is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+! \n+! Under Section 7 of GPL version 3, you are granted additional\n+! permissions described in the GCC Runtime Library Exception, version\n+! 3.1, as published by the Free Software Foundation.\n+! \n+! You should have received a copy of the GNU General Public License and\n+! a copy of the GCC Runtime Library Exception along with this program;\n+! see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+! <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+#include \"fpu-target.inc\"\n+\n+module IEEE_ARITHMETIC\n+\n+  use IEEE_EXCEPTIONS\n+  implicit none\n+  private\n+\n+  ! Every public symbol from IEEE_EXCEPTIONS must be made public here\n+  public :: IEEE_FLAG_TYPE, IEEE_INVALID, IEEE_OVERFLOW, &\n+    IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, IEEE_INEXACT, IEEE_USUAL, &\n+    IEEE_ALL, IEEE_STATUS_TYPE, IEEE_GET_FLAG, IEEE_GET_HALTING_MODE, &\n+    IEEE_GET_STATUS, IEEE_SET_FLAG, IEEE_SET_HALTING_MODE, &\n+    IEEE_SET_STATUS, IEEE_SUPPORT_FLAG, IEEE_SUPPORT_HALTING\n+\n+  ! Derived types and named constants\n+\n+  type, public :: IEEE_CLASS_TYPE\n+    private\n+    integer :: hidden\n+  end type\n+\n+  type(IEEE_CLASS_TYPE), parameter, public :: &\n+    IEEE_OTHER_VALUE       = IEEE_CLASS_TYPE(0), &\n+    IEEE_SIGNALING_NAN     = IEEE_CLASS_TYPE(1), &\n+    IEEE_QUIET_NAN         = IEEE_CLASS_TYPE(2), &\n+    IEEE_NEGATIVE_INF      = IEEE_CLASS_TYPE(3), &\n+    IEEE_NEGATIVE_NORMAL   = IEEE_CLASS_TYPE(4), &\n+    IEEE_NEGATIVE_DENORMAL = IEEE_CLASS_TYPE(5), &\n+    IEEE_NEGATIVE_ZERO     = IEEE_CLASS_TYPE(6), &\n+    IEEE_POSITIVE_ZERO     = IEEE_CLASS_TYPE(7), &\n+    IEEE_POSITIVE_DENORMAL = IEEE_CLASS_TYPE(8), &\n+    IEEE_POSITIVE_NORMAL   = IEEE_CLASS_TYPE(9), &\n+    IEEE_POSITIVE_INF      = IEEE_CLASS_TYPE(10)\n+\n+  type, public :: IEEE_ROUND_TYPE\n+    private\n+    integer :: hidden\n+  end type\n+\n+  type(IEEE_ROUND_TYPE), parameter, public :: &\n+    IEEE_NEAREST           = IEEE_ROUND_TYPE(GFC_FPE_TONEAREST), &\n+    IEEE_TO_ZERO           = IEEE_ROUND_TYPE(GFC_FPE_TOWARDZERO), &\n+    IEEE_UP                = IEEE_ROUND_TYPE(GFC_FPE_UPWARD), &\n+    IEEE_DOWN              = IEEE_ROUND_TYPE(GFC_FPE_DOWNWARD), &\n+    IEEE_OTHER             = IEEE_ROUND_TYPE(0)\n+\n+\n+  ! Equality operators on the derived types\n+  interface operator (==)\n+    module procedure IEEE_CLASS_TYPE_EQ, IEEE_ROUND_TYPE_EQ\n+  end interface\n+  public :: operator(==)\n+\n+  interface operator (/=)\n+    module procedure IEEE_CLASS_TYPE_NE, IEEE_ROUND_TYPE_NE\n+  end interface\n+  public :: operator (/=)\n+\n+\n+  ! IEEE_IS_FINITE\n+\n+  interface\n+    elemental logical function _gfortran_ieee_is_finite_4(X)\n+      real(kind=4), intent(in) :: X\n+    end function\n+    elemental logical function _gfortran_ieee_is_finite_8(X)\n+      real(kind=8), intent(in) :: X\n+    end function\n+  end interface\n+\n+  interface IEEE_IS_FINITE\n+    procedure _gfortran_ieee_is_finite_4, _gfortran_ieee_is_finite_8\n+  end interface\n+  public :: IEEE_IS_FINITE\n+\n+  ! IEEE_IS_NAN\n+\n+  interface\n+    elemental logical function _gfortran_ieee_is_nan_4(X)\n+      real(kind=4), intent(in) :: X\n+    end function\n+    elemental logical function _gfortran_ieee_is_nan_8(X)\n+      real(kind=8), intent(in) :: X\n+    end function\n+  end interface\n+\n+  interface IEEE_IS_NAN\n+    procedure _gfortran_ieee_is_nan_4, _gfortran_ieee_is_nan_8\n+  end interface\n+  public :: IEEE_IS_NAN\n+\n+  ! IEEE_IS_NEGATIVE\n+\n+  interface\n+    elemental logical function _gfortran_ieee_is_negative_4(X)\n+      real(kind=4), intent(in) :: X\n+    end function\n+    elemental logical function _gfortran_ieee_is_negative_8(X)\n+      real(kind=8), intent(in) :: X\n+    end function\n+  end interface\n+\n+  interface IEEE_IS_NEGATIVE\n+    procedure _gfortran_ieee_is_negative_4, _gfortran_ieee_is_negative_8\n+  end interface\n+  public :: IEEE_IS_NEGATIVE\n+\n+  ! IEEE_IS_NORMAL\n+\n+  interface\n+    elemental logical function _gfortran_ieee_is_normal_4(X)\n+      real(kind=4), intent(in) :: X\n+    end function\n+    elemental logical function _gfortran_ieee_is_normal_8(X)\n+      real(kind=8), intent(in) :: X\n+    end function\n+  end interface\n+\n+  interface IEEE_IS_NORMAL\n+    procedure _gfortran_ieee_is_normal_4, _gfortran_ieee_is_normal_8\n+  end interface\n+  public :: IEEE_IS_NORMAL\n+\n+  ! IEEE_COPY_SIGN\n+\n+  interface\n+    elemental real(kind=4) function _gfortran_ieee_copy_sign_4_4 (X,Y)\n+      real(kind=4), intent(in) :: X\n+      real(kind=4), intent(in) :: Y\n+    end function\n+    elemental real(kind=4) function _gfortran_ieee_copy_sign_4_8 (X,Y)\n+      real(kind=4), intent(in) :: X\n+      real(kind=8), intent(in) :: Y\n+    end function\n+    elemental real(kind=8) function _gfortran_ieee_copy_sign_8_4 (X,Y)\n+      real(kind=8), intent(in) :: X\n+      real(kind=4), intent(in) :: Y\n+    end function\n+    elemental real(kind=8) function _gfortran_ieee_copy_sign_8_8 (X,Y)\n+      real(kind=8), intent(in) :: X\n+      real(kind=8), intent(in) :: Y\n+    end function\n+  end interface\n+\n+  interface IEEE_COPY_SIGN\n+    procedure _gfortran_ieee_copy_sign_4_4, _gfortran_ieee_copy_sign_4_8, &\n+              _gfortran_ieee_copy_sign_8_4, _gfortran_ieee_copy_sign_8_8\n+  end interface\n+  public :: IEEE_COPY_SIGN\n+\n+  ! IEEE_UNORDERED\n+\n+  interface\n+    elemental logical function _gfortran_ieee_unordered_4_4 (X,Y)\n+      real(kind=4), intent(in) :: X\n+      real(kind=4), intent(in) :: Y\n+    end function\n+    elemental logical function _gfortran_ieee_unordered_4_8 (X,Y)\n+      real(kind=4), intent(in) :: X\n+      real(kind=8), intent(in) :: Y\n+    end function\n+    elemental logical function _gfortran_ieee_unordered_8_4 (X,Y)\n+      real(kind=8), intent(in) :: X\n+      real(kind=4), intent(in) :: Y\n+    end function\n+    elemental logical function _gfortran_ieee_unordered_8_8 (X,Y)\n+      real(kind=8), intent(in) :: X\n+      real(kind=8), intent(in) :: Y\n+    end function\n+  end interface\n+\n+  interface IEEE_UNORDERED\n+    procedure _gfortran_ieee_unordered_4_4, _gfortran_ieee_unordered_4_8, &\n+              _gfortran_ieee_unordered_8_4, _gfortran_ieee_unordered_8_8\n+  end interface\n+  public :: IEEE_UNORDERED\n+\n+  ! IEEE_LOGB\n+\n+  interface\n+    elemental real(kind=4) function _gfortran_ieee_logb_4 (X)\n+      real(kind=4), intent(in) :: X\n+    end function\n+    elemental real(kind=8) function _gfortran_ieee_logb_8 (X)\n+      real(kind=8), intent(in) :: X\n+    end function\n+  end interface\n+\n+  interface IEEE_LOGB\n+    procedure _gfortran_ieee_logb_4, _gfortran_ieee_logb_8\n+  end interface\n+  public :: IEEE_LOGB\n+\n+  ! IEEE_NEXT_AFTER\n+\n+  interface\n+    elemental real(kind=4) function _gfortran_ieee_next_after_4_4 (X, Y)\n+      real(kind=4), intent(in) :: X\n+      real(kind=4), intent(in) :: Y\n+    end function\n+    elemental real(kind=4) function _gfortran_ieee_next_after_4_8 (X, Y)\n+      real(kind=4), intent(in) :: X\n+      real(kind=8), intent(in) :: Y\n+    end function\n+    elemental real(kind=8) function _gfortran_ieee_next_after_8_4 (X, Y)\n+      real(kind=8), intent(in) :: X\n+      real(kind=4), intent(in) :: Y\n+    end function\n+    elemental real(kind=8) function _gfortran_ieee_next_after_8_8 (X, Y)\n+      real(kind=8), intent(in) :: X\n+      real(kind=8), intent(in) :: Y\n+    end function\n+  end interface\n+\n+  interface IEEE_NEXT_AFTER\n+    procedure _gfortran_ieee_next_after_4_4, _gfortran_ieee_next_after_4_8, &\n+              _gfortran_ieee_next_after_8_4, _gfortran_ieee_next_after_8_8\n+  end interface\n+  public :: IEEE_NEXT_AFTER\n+\n+  ! IEEE_REM\n+\n+  interface\n+    elemental real(kind=4) function _gfortran_ieee_rem_4_4 (X, Y)\n+      real(kind=4), intent(in) :: X\n+      real(kind=4), intent(in) :: Y\n+    end function\n+    elemental real(kind=8) function _gfortran_ieee_rem_4_8 (X, Y)\n+      real(kind=4), intent(in) :: X\n+      real(kind=8), intent(in) :: Y\n+    end function\n+    elemental real(kind=8) function _gfortran_ieee_rem_8_4 (X, Y)\n+      real(kind=8), intent(in) :: X\n+      real(kind=4), intent(in) :: Y\n+    end function\n+    elemental real(kind=8) function _gfortran_ieee_rem_8_8 (X, Y)\n+      real(kind=8), intent(in) :: X\n+      real(kind=8), intent(in) :: Y\n+    end function\n+  end interface\n+\n+  interface IEEE_REM\n+    procedure _gfortran_ieee_rem_4_4, _gfortran_ieee_rem_4_8, &\n+              _gfortran_ieee_rem_8_4, _gfortran_ieee_rem_8_8\n+  end interface\n+  public :: IEEE_REM\n+\n+  ! IEEE_RINT\n+\n+  interface\n+    elemental real(kind=4) function _gfortran_ieee_rint_4 (X)\n+      real(kind=4), intent(in) :: X\n+    end function\n+    elemental real(kind=8) function _gfortran_ieee_rint_8 (X)\n+      real(kind=8), intent(in) :: X\n+    end function\n+  end interface\n+\n+  interface IEEE_RINT\n+    procedure _gfortran_ieee_rint_4, _gfortran_ieee_rint_8\n+  end interface\n+  public :: IEEE_RINT\n+\n+  ! IEEE_SCALB\n+\n+  interface\n+    elemental real(kind=4) function _gfortran_ieee_scalb_4 (X, I)\n+      real(kind=4), intent(in) :: X\n+      integer, intent(in) :: I\n+    end function\n+    elemental real(kind=8) function _gfortran_ieee_scalb_8 (X, I)\n+      real(kind=8), intent(in) :: X\n+      integer, intent(in) :: I\n+    end function\n+  end interface\n+\n+  interface IEEE_SCALB\n+    procedure _gfortran_ieee_scalb_4, _gfortran_ieee_scalb_8\n+  end interface\n+  public :: IEEE_SCALB\n+\n+  ! IEEE_VALUE\n+\n+  interface IEEE_VALUE\n+    module procedure IEEE_VALUE_4, IEEE_VALUE_8\n+  end interface\n+  public :: IEEE_VALUE\n+\n+  ! IEEE_CLASS\n+\n+  interface IEEE_CLASS\n+    module procedure IEEE_CLASS_4, IEEE_CLASS_8\n+  end interface\n+  public :: IEEE_CLASS\n+\n+  ! Public declarations for contained procedures\n+  public :: IEEE_GET_ROUNDING_MODE, IEEE_SET_ROUNDING_MODE\n+  public :: IEEE_GET_UNDERFLOW_MODE, IEEE_SET_UNDERFLOW_MODE\n+  public :: IEEE_SELECTED_REAL_KIND\n+\n+  ! IEEE_SUPPORT_ROUNDING\n+\n+  interface IEEE_SUPPORT_ROUNDING\n+    module procedure IEEE_SUPPORT_ROUNDING_4, IEEE_SUPPORT_ROUNDING_8, &\n+#ifdef HAVE_GFC_REAL_10\n+                     IEEE_SUPPORT_ROUNDING_10, &\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+                     IEEE_SUPPORT_ROUNDING_16, &\n+#endif\n+                     IEEE_SUPPORT_ROUNDING_NOARG\n+  end interface\n+  public :: IEEE_SUPPORT_ROUNDING\n+  \n+  ! Interface to the FPU-specific function\n+  interface\n+    pure integer function support_rounding_helper(flag) &\n+        bind(c, name=\"_gfortrani_support_fpu_rounding_mode\")\n+      integer, intent(in), value :: flag\n+    end function\n+  end interface\n+\n+! IEEE_SUPPORT_* generic functions\n+\n+#if defined(HAVE_GFC_REAL_10) && defined(HAVE_GFC_REAL_16)\n+# define MACRO1(NAME) NAME/**/_4, NAME/**/_8, NAME/**/_10, NAME/**/_16, NAME/**/_NOARG\n+#elif defined(HAVE_GFC_REAL_10)\n+# define MACRO1(NAME) NAME/**/_4, NAME/**/_8, NAME/**/_10, NAME/**/_NOARG\n+#elif defined(HAVE_GFC_REAL_16)\n+# define MACRO1(NAME) NAME/**/_4, NAME/**/_8, NAME/**/_16, NAME/**/_NOARG\n+#else\n+# define MACRO1(NAME) NAME/**/_4, NAME/**/_8, NAME/**/_NOARG\n+#endif\n+\n+#define SUPPORTGENERIC(NAME) \\\n+  interface NAME ; module procedure MACRO1(NAME) ; end interface ; \\\n+  public :: NAME\n+\n+SUPPORTGENERIC(IEEE_SUPPORT_DATATYPE)\n+SUPPORTGENERIC(IEEE_SUPPORT_DENORMAL)\n+SUPPORTGENERIC(IEEE_SUPPORT_DIVIDE)\n+SUPPORTGENERIC(IEEE_SUPPORT_INF)\n+SUPPORTGENERIC(IEEE_SUPPORT_IO)\n+SUPPORTGENERIC(IEEE_SUPPORT_NAN)\n+SUPPORTGENERIC(IEEE_SUPPORT_SQRT)\n+SUPPORTGENERIC(IEEE_SUPPORT_STANDARD)\n+SUPPORTGENERIC(IEEE_SUPPORT_UNDERFLOW_CONTROL)\n+\n+contains\n+\n+  ! Equality operators for IEEE_CLASS_TYPE and IEEE_ROUNDING_MODE\n+  elemental logical function IEEE_CLASS_TYPE_EQ (X, Y) result(res)\n+    implicit none\n+    type(IEEE_CLASS_TYPE), intent(in) :: X, Y\n+    res = (X%hidden == Y%hidden)\n+  end function\n+\n+  elemental logical function IEEE_CLASS_TYPE_NE (X, Y) result(res)\n+    implicit none\n+    type(IEEE_CLASS_TYPE), intent(in) :: X, Y\n+    res = (X%hidden /= Y%hidden)\n+  end function\n+\n+  elemental logical function IEEE_ROUND_TYPE_EQ (X, Y) result(res)\n+    implicit none\n+    type(IEEE_ROUND_TYPE), intent(in) :: X, Y\n+    res = (X%hidden == Y%hidden)\n+  end function\n+\n+  elemental logical function IEEE_ROUND_TYPE_NE (X, Y) result(res)\n+    implicit none\n+    type(IEEE_ROUND_TYPE), intent(in) :: X, Y\n+    res = (X%hidden /= Y%hidden)\n+  end function\n+\n+  ! IEEE_SELECTED_REAL_KIND\n+  integer function IEEE_SELECTED_REAL_KIND (P, R, RADIX) result(res)\n+    implicit none\n+    integer, intent(in), optional :: P, R, RADIX\n+    integer :: p2, r2\n+\n+    p2 = 0 ; r2 = 0\n+    if (present(p)) p2 = p\n+    if (present(r)) r2 = r\n+\n+    ! The only IEEE types we support right now are binary\n+    if (present(radix)) then\n+      if (radix /= 2) then\n+        res = -5\n+        return\n+      endif\n+    endif\n+\n+    ! Does IEEE float fit?\n+    if (precision(0.) >= p2 .and. range(0.) >= r2) then\n+      res = kind(0.)\n+      return\n+    endif\n+\n+    ! Does IEEE double fit?\n+    if (precision(0.d0) >= p2 .and. range(0.d0) >= r2) then\n+      res = kind(0.d0)\n+      return\n+    endif\n+\n+    if (precision(0.d0) < p2 .and. range(0.d0) < r2) then\n+      res = -3\n+      return\n+    endif\n+\n+    if (precision(0.d0) < p2) then\n+      res = -1\n+      return\n+    endif\n+\n+   res = -2\n+  end function\n+\n+\n+  ! IEEE_CLASS\n+\n+  elemental function IEEE_CLASS_4 (X) result(res)\n+    implicit none\n+    real(kind=4), intent(in) :: X\n+    type(IEEE_CLASS_TYPE) :: res\n+\n+    interface\n+      pure integer function _gfortrani_ieee_class_helper_4(val)\n+        real(kind=4), intent(in) :: val\n+      end function\n+    end interface\n+\n+    res = IEEE_CLASS_TYPE(_gfortrani_ieee_class_helper_4(X))\n+  end function\n+\n+  elemental function IEEE_CLASS_8 (X) result(res)\n+    implicit none\n+    real(kind=8), intent(in) :: X\n+    type(IEEE_CLASS_TYPE) :: res\n+\n+    interface\n+      pure integer function _gfortrani_ieee_class_helper_8(val)\n+        real(kind=8), intent(in) :: val\n+      end function\n+    end interface\n+\n+    res = IEEE_CLASS_TYPE(_gfortrani_ieee_class_helper_8(X))\n+  end function\n+\n+  ! IEEE_VALUE\n+\n+  elemental real(kind=4) function IEEE_VALUE_4(X, C) result(res)\n+    implicit none\n+    real(kind=4), intent(in) :: X\n+    type(IEEE_CLASS_TYPE), intent(in) :: C\n+\n+    select case (C%hidden)\n+      case (1)     ! IEEE_SIGNALING_NAN\n+        res = -1\n+        res = sqrt(res)\n+      case (2)     ! IEEE_QUIET_NAN\n+        res = -1\n+        res = sqrt(res)\n+      case (3)     ! IEEE_NEGATIVE_INF\n+        res = huge(res)\n+        res = (-res) * res\n+      case (4)     ! IEEE_NEGATIVE_NORMAL\n+        res = -42\n+      case (5)     ! IEEE_NEGATIVE_DENORMAL\n+        res = -tiny(res)\n+        res = res / 2\n+      case (6)     ! IEEE_NEGATIVE_ZERO\n+        res = 0\n+        res = -res\n+      case (7)     ! IEEE_POSITIVE_ZERO\n+        res = 0\n+      case (8)     ! IEEE_POSITIVE_DENORMAL\n+        res = tiny(res)\n+        res = res / 2\n+      case (9)     ! IEEE_POSITIVE_NORMAL\n+        res = 42\n+      case (10)    ! IEEE_POSITIVE_INF\n+        res = huge(res)\n+        res = res * res\n+      case default ! IEEE_OTHER_VALUE, should not happen\n+        res = 0\n+     end select\n+  end function\n+\n+  elemental real(kind=8) function IEEE_VALUE_8(X, C) result(res)\n+    implicit none\n+    real(kind=8), intent(in) :: X\n+    type(IEEE_CLASS_TYPE), intent(in) :: C\n+\n+    select case (C%hidden)\n+      case (1)     ! IEEE_SIGNALING_NAN\n+        res = -1\n+        res = sqrt(res)\n+      case (2)     ! IEEE_QUIET_NAN\n+        res = -1\n+        res = sqrt(res)\n+      case (3)     ! IEEE_NEGATIVE_INF\n+        res = huge(res)\n+        res = (-res) * res\n+      case (4)     ! IEEE_NEGATIVE_NORMAL\n+        res = -42\n+      case (5)     ! IEEE_NEGATIVE_DENORMAL\n+        res = -tiny(res)\n+        res = res / 2\n+      case (6)     ! IEEE_NEGATIVE_ZERO\n+        res = 0\n+        res = -res\n+      case (7)     ! IEEE_POSITIVE_ZERO\n+        res = 0\n+      case (8)     ! IEEE_POSITIVE_DENORMAL\n+        res = tiny(res)\n+        res = res / 2\n+      case (9)     ! IEEE_POSITIVE_NORMAL\n+        res = 42\n+      case (10)    ! IEEE_POSITIVE_INF\n+        res = huge(res)\n+        res = res * res\n+      case default ! IEEE_OTHER_VALUE, should not happen\n+        res = 0\n+     end select\n+  end function\n+\n+\n+  ! IEEE_GET_ROUNDING_MODE\n+\n+  subroutine IEEE_GET_ROUNDING_MODE (ROUND_VALUE)\n+    implicit none\n+    type(IEEE_ROUND_TYPE), intent(out) :: ROUND_VALUE\n+    integer :: i\n+\n+    interface\n+      integer function helper() &\n+        bind(c, name=\"_gfortrani_get_fpu_rounding_mode\")\n+      end function\n+    end interface\n+\n+    ! FIXME: Use intermediate variable i to avoid triggering PR59023\n+    i = helper()\n+    ROUND_VALUE = IEEE_ROUND_TYPE(i)\n+  end subroutine\n+\n+\n+  ! IEEE_SET_ROUNDING_MODE\n+\n+  subroutine IEEE_SET_ROUNDING_MODE (ROUND_VALUE)\n+    implicit none\n+    type(IEEE_ROUND_TYPE), intent(in) :: ROUND_VALUE\n+\n+    interface\n+      subroutine helper(val) &\n+          bind(c, name=\"_gfortrani_set_fpu_rounding_mode\")\n+        integer, value :: val\n+      end subroutine\n+    end interface\n+    \n+    call helper(ROUND_VALUE%hidden)\n+  end subroutine\n+\n+\n+  ! IEEE_GET_UNDERFLOW_MODE\n+\n+  subroutine IEEE_GET_UNDERFLOW_MODE (GRADUAL)\n+    implicit none\n+    logical, intent(out) :: GRADUAL\n+    ! We do not support getting/setting underflow mode yet. We still\n+    ! provide the procedures to avoid link-time error if a user program\n+    ! uses it protected by a call to IEEE_SUPPORT_UNDERFLOW_CONTROL\n+    call abort\n+  end subroutine\n+\n+\n+  ! IEEE_SET_UNDERFLOW_MODE\n+\n+  subroutine IEEE_SET_UNDERFLOW_MODE (GRADUAL)\n+    implicit none\n+    logical, intent(in) :: GRADUAL\n+    ! We do not support getting/setting underflow mode yet. We still\n+    ! provide the procedures to avoid link-time error if a user program\n+    ! uses it protected by a call to IEEE_SUPPORT_UNDERFLOW_CONTROL\n+    call abort\n+  end subroutine\n+\n+! IEEE_SUPPORT_ROUNDING\n+\n+  pure logical function IEEE_SUPPORT_ROUNDING_4 (ROUND_VALUE, X) result(res)\n+    implicit none\n+    real(kind=4), intent(in) :: X\n+    type(IEEE_ROUND_TYPE), intent(in) :: ROUND_VALUE\n+    res = (support_rounding_helper(ROUND_VALUE%hidden) /= 0)\n+  end function\n+\n+  pure logical function IEEE_SUPPORT_ROUNDING_8 (ROUND_VALUE, X) result(res)\n+    implicit none\n+    real(kind=8), intent(in) :: X\n+    type(IEEE_ROUND_TYPE), intent(in) :: ROUND_VALUE\n+    res = (support_rounding_helper(ROUND_VALUE%hidden) /= 0)\n+  end function\n+\n+#ifdef HAVE_GFC_REAL_10\n+  pure logical function IEEE_SUPPORT_ROUNDING_10 (ROUND_VALUE, X) result(res)\n+    implicit none\n+    real(kind=10), intent(in) :: X\n+    type(IEEE_ROUND_TYPE), intent(in) :: ROUND_VALUE\n+    res = .false.\n+  end function\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+  pure logical function IEEE_SUPPORT_ROUNDING_16 (ROUND_VALUE, X) result(res)\n+    implicit none\n+    real(kind=16), intent(in) :: X\n+    type(IEEE_ROUND_TYPE), intent(in) :: ROUND_VALUE\n+    res = .false.\n+  end function\n+#endif\n+\n+  pure logical function IEEE_SUPPORT_ROUNDING_NOARG (ROUND_VALUE) result(res)\n+    implicit none\n+    type(IEEE_ROUND_TYPE), intent(in) :: ROUND_VALUE\n+#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n+    res = .false.\n+#else\n+    res = (support_rounding_helper(ROUND_VALUE%hidden) /= 0)\n+#endif\n+  end function\n+\n+! IEEE_SUPPORT_* functions\n+\n+#define SUPPORTMACRO(NAME, INTKIND, VALUE) \\\n+  pure logical function NAME/**/_/**/INTKIND (X) result(res) ; \\\n+    implicit none                                            ; \\\n+    real(INTKIND), intent(in) :: X(..)                       ; \\\n+    res = VALUE                                              ; \\\n+  end function\n+\n+#define SUPPORTMACRO_NOARG(NAME, VALUE) \\\n+  pure logical function NAME/**/_NOARG () result(res) ; \\\n+    implicit none                                     ; \\\n+    res = VALUE                                       ; \\\n+  end function\n+\n+! IEEE_SUPPORT_DATATYPE\n+\n+SUPPORTMACRO(IEEE_SUPPORT_DATATYPE,4,.true.)\n+SUPPORTMACRO(IEEE_SUPPORT_DATATYPE,8,.true.)\n+#ifdef HAVE_GFC_REAL_10\n+SUPPORTMACRO(IEEE_SUPPORT_DATATYPE,10,.false.)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+SUPPORTMACRO(IEEE_SUPPORT_DATATYPE,16,.false.)\n+#endif\n+#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_DATATYPE,.false.)\n+#else\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_DATATYPE,.true.)\n+#endif\n+\n+! IEEE_SUPPORT_DENORMAL\n+\n+SUPPORTMACRO(IEEE_SUPPORT_DENORMAL,4,.true.)\n+SUPPORTMACRO(IEEE_SUPPORT_DENORMAL,8,.true.)\n+#ifdef HAVE_GFC_REAL_10\n+SUPPORTMACRO(IEEE_SUPPORT_DENORMAL,10,.false.)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+SUPPORTMACRO(IEEE_SUPPORT_DENORMAL,16,.false.)\n+#endif\n+#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_DENORMAL,.false.)\n+#else\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_DENORMAL,.true.)\n+#endif\n+\n+! IEEE_SUPPORT_DIVIDE\n+\n+SUPPORTMACRO(IEEE_SUPPORT_DIVIDE,4,.true.)\n+SUPPORTMACRO(IEEE_SUPPORT_DIVIDE,8,.true.)\n+#ifdef HAVE_GFC_REAL_10\n+SUPPORTMACRO(IEEE_SUPPORT_DIVIDE,10,.false.)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+SUPPORTMACRO(IEEE_SUPPORT_DIVIDE,16,.false.)\n+#endif\n+#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_DIVIDE,.false.)\n+#else\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_DIVIDE,.true.)\n+#endif\n+\n+! IEEE_SUPPORT_INF\n+\n+SUPPORTMACRO(IEEE_SUPPORT_INF,4,.true.)\n+SUPPORTMACRO(IEEE_SUPPORT_INF,8,.true.)\n+#ifdef HAVE_GFC_REAL_10\n+SUPPORTMACRO(IEEE_SUPPORT_INF,10,.false.)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+SUPPORTMACRO(IEEE_SUPPORT_INF,16,.false.)\n+#endif\n+#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_INF,.false.)\n+#else\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_INF,.true.)\n+#endif\n+\n+! IEEE_SUPPORT_IO\n+\n+SUPPORTMACRO(IEEE_SUPPORT_IO,4,.true.)\n+SUPPORTMACRO(IEEE_SUPPORT_IO,8,.true.)\n+#ifdef HAVE_GFC_REAL_10\n+SUPPORTMACRO(IEEE_SUPPORT_IO,10,.false.)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+SUPPORTMACRO(IEEE_SUPPORT_IO,16,.false.)\n+#endif\n+#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_IO,.false.)\n+#else\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_IO,.true.)\n+#endif\n+\n+! IEEE_SUPPORT_NAN\n+\n+SUPPORTMACRO(IEEE_SUPPORT_NAN,4,.true.)\n+SUPPORTMACRO(IEEE_SUPPORT_NAN,8,.true.)\n+#ifdef HAVE_GFC_REAL_10\n+SUPPORTMACRO(IEEE_SUPPORT_NAN,10,.false.)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+SUPPORTMACRO(IEEE_SUPPORT_NAN,16,.false.)\n+#endif\n+#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_NAN,.false.)\n+#else\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_NAN,.true.)\n+#endif\n+\n+! IEEE_SUPPORT_SQRT\n+\n+SUPPORTMACRO(IEEE_SUPPORT_SQRT,4,.true.)\n+SUPPORTMACRO(IEEE_SUPPORT_SQRT,8,.true.)\n+#ifdef HAVE_GFC_REAL_10\n+SUPPORTMACRO(IEEE_SUPPORT_SQRT,10,.false.)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+SUPPORTMACRO(IEEE_SUPPORT_SQRT,16,.false.)\n+#endif\n+#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_SQRT,.false.)\n+#else\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_SQRT,.true.)\n+#endif\n+\n+! IEEE_SUPPORT_STANDARD\n+\n+SUPPORTMACRO(IEEE_SUPPORT_STANDARD,4,.true.)\n+SUPPORTMACRO(IEEE_SUPPORT_STANDARD,8,.true.)\n+#ifdef HAVE_GFC_REAL_10\n+SUPPORTMACRO(IEEE_SUPPORT_STANDARD,10,.false.)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+SUPPORTMACRO(IEEE_SUPPORT_STANDARD,16,.false.)\n+#endif\n+#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_STANDARD,.false.)\n+#else\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_STANDARD,.true.)\n+#endif\n+\n+! IEEE_SUPPORT_UNDERFLOW_CONTROL\n+\n+SUPPORTMACRO(IEEE_SUPPORT_UNDERFLOW_CONTROL,4,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_UNDERFLOW_CONTROL,8,.false.)\n+#ifdef HAVE_GFC_REAL_10\n+SUPPORTMACRO(IEEE_SUPPORT_UNDERFLOW_CONTROL,10,.false.)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+SUPPORTMACRO(IEEE_SUPPORT_UNDERFLOW_CONTROL,16,.false.)\n+#endif\n+SUPPORTMACRO_NOARG(IEEE_SUPPORT_UNDERFLOW_CONTROL,.false.)\n+\n+\n+end module IEEE_ARITHMETIC"}, {"sha": "e77bcf0f8dd9a27200336e7bd3468d60ff7c4eee", "filename": "libgfortran/ieee/ieee_exceptions.F90", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fieee%2Fieee_exceptions.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fieee%2Fieee_exceptions.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_exceptions.F90?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,218 @@\n+!    Implementation of the IEEE_EXCEPTIONS standard intrinsic module\n+!    Copyright (C) 2013 Free Software Foundation, Inc.\n+!    Contributed by Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+! \n+! This file is part of the GNU Fortran runtime library (libgfortran).\n+! \n+! Libgfortran is free software; you can redistribute it and/or\n+! modify it under the terms of the GNU General Public\n+! License as published by the Free Software Foundation; either\n+! version 3 of the License, or (at your option) any later version.\n+! \n+! Libgfortran is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+! \n+! Under Section 7 of GPL version 3, you are granted additional\n+! permissions described in the GCC Runtime Library Exception, version\n+! 3.1, as published by the Free Software Foundation.\n+! \n+! You should have received a copy of the GNU General Public License and\n+! a copy of the GCC Runtime Library Exception along with this program;\n+! see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+! <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+#include \"fpu-target.inc\"\n+\n+module IEEE_EXCEPTIONS\n+\n+  implicit none\n+  private\n+\n+! Derived types and named constants\n+\n+  type, public :: IEEE_FLAG_TYPE\n+    private\n+    integer :: hidden\n+  end type\n+\n+  type(IEEE_FLAG_TYPE), parameter, public :: &\n+    IEEE_INVALID        = IEEE_FLAG_TYPE(GFC_FPE_INVALID), &\n+    IEEE_OVERFLOW       = IEEE_FLAG_TYPE(GFC_FPE_OVERFLOW), &\n+    IEEE_DIVIDE_BY_ZERO = IEEE_FLAG_TYPE(GFC_FPE_ZERO), &\n+    IEEE_UNDERFLOW      = IEEE_FLAG_TYPE(GFC_FPE_UNDERFLOW), &\n+    IEEE_INEXACT        = IEEE_FLAG_TYPE(GFC_FPE_INEXACT)\n+\n+  type(IEEE_FLAG_TYPE), parameter, public :: &\n+    IEEE_USUAL(3) = [ IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_INVALID ], &\n+    IEEE_ALL(5)   = [ IEEE_USUAL, IEEE_UNDERFLOW, IEEE_INEXACT ]\n+\n+  type, public :: IEEE_STATUS_TYPE\n+    private\n+    character(len=GFC_FPE_STATE_BUFFER_SIZE) :: hidden\n+  end type\n+\n+  interface IEEE_SUPPORT_FLAG\n+    module procedure IEEE_SUPPORT_FLAG_NOARG, &\n+                     IEEE_SUPPORT_FLAG_4, &\n+                     IEEE_SUPPORT_FLAG_8\n+  end interface IEEE_SUPPORT_FLAG\n+\n+  public :: IEEE_SUPPORT_FLAG, IEEE_SUPPORT_HALTING\n+  public :: IEEE_SET_HALTING_MODE, IEEE_GET_HALTING_MODE\n+  public :: IEEE_SET_FLAG, IEEE_GET_FLAG\n+  public :: IEEE_SET_STATUS, IEEE_GET_STATUS\n+\n+contains\n+\n+! Saving and restoring floating-point status\n+\n+  subroutine IEEE_GET_STATUS (STATUS_VALUE)\n+    implicit none\n+    type(IEEE_STATUS_TYPE), intent(out) :: STATUS_VALUE\n+\n+    interface\n+      subroutine helper(ptr) &\n+          bind(c, name=\"_gfortrani_get_fpu_state\")\n+        use, intrinsic :: iso_c_binding, only : c_char\n+        character(kind=c_char) :: ptr(*)\n+      end subroutine\n+    end interface\n+\n+    call helper(STATUS_VALUE%hidden)\n+  end subroutine\n+\n+  subroutine IEEE_SET_STATUS (STATUS_VALUE)\n+    implicit none\n+    type(IEEE_STATUS_TYPE), intent(in) :: STATUS_VALUE\n+\n+    interface\n+      subroutine helper(ptr) &\n+          bind(c, name=\"_gfortrani_set_fpu_state\")\n+        use, intrinsic :: iso_c_binding, only : c_char\n+        character(kind=c_char) :: ptr(*)\n+      end subroutine\n+    end interface\n+\n+    call helper(STATUS_VALUE%hidden)\n+  end subroutine\n+\n+! Getting and setting flags\n+\n+  elemental subroutine IEEE_GET_FLAG (FLAG, FLAG_VALUE)\n+    implicit none\n+    type(IEEE_FLAG_TYPE), intent(in) :: FLAG\n+    logical, intent(out) :: FLAG_VALUE\n+\n+    interface\n+      pure integer function helper() &\n+        bind(c, name=\"_gfortrani_get_fpu_except_flags\")\n+      end function\n+    end interface\n+\n+    FLAG_VALUE = (IAND(helper(), FLAG%hidden) /= 0)\n+  end subroutine\n+\n+  elemental subroutine IEEE_SET_FLAG (FLAG, FLAG_VALUE)\n+    implicit none\n+    type(IEEE_FLAG_TYPE), intent(in) :: FLAG\n+    logical, intent(in) :: FLAG_VALUE\n+\n+    interface\n+      pure subroutine helper(set, clear) &\n+          bind(c, name=\"_gfortrani_set_fpu_except_flags\")\n+        integer, intent(in), value :: set, clear\n+      end subroutine\n+    end interface\n+\n+    if (FLAG_VALUE) then\n+      call helper(FLAG%hidden, 0)\n+    else\n+      call helper(0, FLAG%hidden)\n+    end if\n+  end subroutine\n+\n+! Querying and changing the halting mode\n+\n+  elemental subroutine IEEE_GET_HALTING_MODE (FLAG, HALTING)\n+    implicit none\n+    type(IEEE_FLAG_TYPE), intent(in) :: FLAG\n+    logical, intent(out) :: HALTING\n+\n+    interface\n+      pure integer function helper() &\n+          bind(c, name=\"_gfortrani_get_fpu_trap_exceptions\")\n+      end function\n+    end interface\n+\n+    HALTING = (IAND(helper(), FLAG%hidden) /= 0)\n+  end subroutine\n+\n+  elemental subroutine IEEE_SET_HALTING_MODE (FLAG, HALTING)\n+    implicit none\n+    type(IEEE_FLAG_TYPE), intent(in) :: FLAG\n+    logical, intent(in) :: HALTING\n+\n+    interface\n+      pure subroutine helper(trap, notrap) &\n+          bind(c, name=\"_gfortrani_set_fpu_trap_exceptions\")\n+        integer, intent(in), value :: trap, notrap\n+      end subroutine\n+    end interface\n+\n+    if (HALTING) then\n+      call helper(FLAG%hidden, 0)\n+    else\n+      call helper(0, FLAG%hidden)\n+    end if\n+  end subroutine\n+\n+! Querying support\n+\n+  pure logical function IEEE_SUPPORT_HALTING (FLAG)\n+    implicit none\n+    type(IEEE_FLAG_TYPE), intent(in) :: FLAG\n+\n+    interface\n+      pure integer function helper(flag) &\n+          bind(c, name=\"_gfortrani_support_fpu_trap\")\n+        integer, intent(in), value :: flag\n+      end function\n+    end interface\n+\n+    IEEE_SUPPORT_HALTING = (helper(FLAG%hidden) /= 0)\n+  end function\n+\n+  pure logical function IEEE_SUPPORT_FLAG_NOARG (FLAG)\n+    implicit none\n+    type(IEEE_FLAG_TYPE), intent(in) :: FLAG\n+\n+    interface\n+      pure integer function helper(flag) &\n+          bind(c, name=\"_gfortrani_support_fpu_flag\")\n+        integer, intent(in), value :: flag\n+      end function\n+    end interface\n+\n+    IEEE_SUPPORT_FLAG_NOARG = (helper(FLAG%hidden) /= 0)\n+  end function\n+\n+  pure logical function IEEE_SUPPORT_FLAG_4 (FLAG, X) result(res)\n+    implicit none\n+    type(IEEE_FLAG_TYPE), intent(in) :: FLAG\n+    real(kind=4), intent(in) :: X\n+    res = IEEE_SUPPORT_FLAG_NOARG(FLAG)\n+  end function\n+\n+  pure logical function IEEE_SUPPORT_FLAG_8 (FLAG, X) result(res)\n+    implicit none\n+    type(IEEE_FLAG_TYPE), intent(in) :: FLAG\n+    real(kind=8), intent(in) :: X\n+    res = IEEE_SUPPORT_FLAG_NOARG(FLAG)\n+  end function\n+\n+end module IEEE_EXCEPTIONS"}, {"sha": "b3a5c5404f6f9ba8d6e2a680dd1abceb2e6cde2f", "filename": "libgfortran/ieee/ieee_features.F90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fieee%2Fieee_features.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fieee%2Fieee_features.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_features.F90?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,49 @@\n+!    Implementation of the IEEE_FEATURES standard intrinsic module\n+!    Copyright (C) 2013 Free Software Foundation, Inc.\n+!    Contributed by Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+! \n+! This file is part of the GNU Fortran runtime library (libgfortran).\n+! \n+! Libgfortran is free software; you can redistribute it and/or\n+! modify it under the terms of the GNU General Public\n+! License as published by the Free Software Foundation; either\n+! version 3 of the License, or (at your option) any later version.\n+! \n+! Libgfortran is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+! \n+! Under Section 7 of GPL version 3, you are granted additional\n+! permissions described in the GCC Runtime Library Exception, version\n+! 3.1, as published by the Free Software Foundation.\n+! \n+! You should have received a copy of the GNU General Public License and\n+! a copy of the GCC Runtime Library Exception along with this program;\n+! see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+! <http://www.gnu.org/licenses/>.  */\n+\n+module IEEE_FEATURES\n+\n+  implicit none\n+  private\n+\n+  type, public :: IEEE_FEATURES_TYPE\n+    private\n+    integer :: hidden\n+  end type\n+\n+  type(IEEE_FEATURES_TYPE), parameter, public :: &\n+    IEEE_DATATYPE       = IEEE_FEATURES_TYPE(0), &\n+    IEEE_DENORMAL       = IEEE_FEATURES_TYPE(1), &\n+    IEEE_DIVIDE         = IEEE_FEATURES_TYPE(2), &\n+    IEEE_HALTING        = IEEE_FEATURES_TYPE(3), &\n+    IEEE_INEXACT_FLAG   = IEEE_FEATURES_TYPE(4), &\n+    IEEE_INF            = IEEE_FEATURES_TYPE(5), &\n+    IEEE_INVALID_FLAG   = IEEE_FEATURES_TYPE(6), &\n+    IEEE_NAN            = IEEE_FEATURES_TYPE(7), &\n+    IEEE_ROUNDING       = IEEE_FEATURES_TYPE(8), &\n+    IEEE_SQRT           = IEEE_FEATURES_TYPE(9), &\n+    IEEE_UNDERFLOW_FLAG = IEEE_FEATURES_TYPE(10)\n+\n+end module IEEE_FEATURES"}, {"sha": "f628add6b2e57a50bd206e97b7047388bb27d003", "filename": "libgfortran/ieee/ieee_helper.c", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fieee%2Fieee_helper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Fieee%2Fieee_helper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_helper.c?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -0,0 +1,407 @@\n+/* Helper functions in C for IEEE modules\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+/* Prototypes.  */\n+\n+extern int ieee_class_helper_4 (GFC_REAL_4 *);\n+internal_proto(ieee_class_helper_4);\n+\n+extern int ieee_class_helper_8 (GFC_REAL_8 *);\n+internal_proto(ieee_class_helper_8);\n+\n+extern int ieee_is_finite_4_ (GFC_REAL_4 *);\n+export_proto(ieee_is_finite_4_);\n+\n+extern int ieee_is_finite_8_ (GFC_REAL_8 *);\n+export_proto(ieee_is_finite_8_);\n+\n+extern int ieee_is_nan_4_ (GFC_REAL_4 *);\n+export_proto(ieee_is_nan_4_);\n+\n+extern int ieee_is_nan_8_ (GFC_REAL_8 *);\n+export_proto(ieee_is_nan_8_);\n+\n+extern int ieee_is_negative_4_ (GFC_REAL_4 *);\n+export_proto(ieee_is_negative_4_);\n+\n+extern int ieee_is_negative_8_ (GFC_REAL_8 *);\n+export_proto(ieee_is_negative_8_);\n+\n+extern int ieee_is_normal_4_ (GFC_REAL_4 *);\n+export_proto(ieee_is_normal_4_);\n+\n+extern int ieee_is_normal_8_ (GFC_REAL_8 *);\n+export_proto(ieee_is_normal_8_);\n+\n+\n+/* Enumeration of the possible floating-point types. These values\n+   correspond to the hidden arguments of the IEEE_CLASS_TYPE\n+   derived-type of IEEE_ARITHMETIC.  */\n+\n+enum { IEEE_OTHER_VALUE = 0, IEEE_SIGNALING_NAN, IEEE_QUIET_NAN,\n+  IEEE_NEGATIVE_INF, IEEE_NEGATIVE_NORMAL, IEEE_NEGATIVE_DENORMAL,\n+  IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_ZERO, IEEE_POSITIVE_DENORMAL,\n+  IEEE_POSITIVE_NORMAL, IEEE_POSITIVE_INF };\n+\n+#define CLASSMACRO(TYPE) \\\n+  int ieee_class_helper_ ## TYPE (GFC_REAL_ ## TYPE *value) \\\n+  { \\\n+    int res = __builtin_fpclassify (IEEE_QUIET_NAN, IEEE_POSITIVE_INF, \\\n+\t\t\t\t    IEEE_POSITIVE_NORMAL, \\\n+\t\t\t\t    IEEE_POSITIVE_DENORMAL, \\\n+\t\t\t\t    IEEE_POSITIVE_ZERO, *value); \\\n+ \\\n+    if (__builtin_signbit (*value)) \\\n+    { \\\n+      if (res == IEEE_POSITIVE_NORMAL) \\\n+\treturn IEEE_NEGATIVE_NORMAL; \\\n+      else if (res == IEEE_POSITIVE_DENORMAL) \\\n+\treturn IEEE_NEGATIVE_DENORMAL; \\\n+      else if (res == IEEE_POSITIVE_ZERO) \\\n+\treturn IEEE_NEGATIVE_ZERO; \\\n+      else if (res == IEEE_POSITIVE_INF) \\\n+\treturn IEEE_NEGATIVE_INF; \\\n+    } \\\n+ \\\n+    if (res == IEEE_QUIET_NAN) \\\n+    { \\\n+      /* TODO: Handle signaling NaNs  */ \\\n+      return res; \\\n+    } \\\n+ \\\n+    return res; \\\n+  }\n+\n+CLASSMACRO(4)\n+CLASSMACRO(8)\n+\n+\n+/* Testing functions.  */\n+\n+int ieee_is_finite_4_ (GFC_REAL_4 *val)\n+{\n+  return __builtin_isfinite(*val) ? 1 : 0;\n+}\n+\n+int ieee_is_finite_8_ (GFC_REAL_8 *val)\n+{\n+  return __builtin_isfinite(*val) ? 1 : 0;\n+}\n+\n+int ieee_is_nan_4_ (GFC_REAL_4 *val)\n+{\n+  return __builtin_isnan(*val) ? 1 : 0;\n+}\n+\n+int ieee_is_nan_8_ (GFC_REAL_8 *val)\n+{\n+  return __builtin_isnan(*val) ? 1 : 0;\n+}\n+\n+int ieee_is_negative_4_ (GFC_REAL_4 *val)\n+{\n+  return (__builtin_signbit(*val) && !__builtin_isnan(*val)) ? 1 : 0;\n+}\n+\n+int ieee_is_negative_8_ (GFC_REAL_8 *val)\n+{\n+  return (__builtin_signbit(*val) && !__builtin_isnan(*val)) ? 1 : 0;\n+}\n+\n+int ieee_is_normal_4_ (GFC_REAL_4 *val)\n+{\n+  return (__builtin_isnormal(*val) || *val == 0) ? 1 : 0;\n+}\n+\n+int ieee_is_normal_8_ (GFC_REAL_8 *val)\n+{\n+  return (__builtin_isnormal(*val) || *val == 0) ? 1 : 0;\n+}\n+\n+GFC_REAL_4 ieee_copy_sign_4_4_ (GFC_REAL_4 *, GFC_REAL_4 *);\n+export_proto(ieee_copy_sign_4_4_);\n+GFC_REAL_4 ieee_copy_sign_4_4_ (GFC_REAL_4 *x, GFC_REAL_4 *y)\n+{\n+  GFC_REAL_4 s = __builtin_signbit(*y) ? -1 : 1;\n+  return __builtin_copysign(*x, s);\n+}\n+\n+GFC_REAL_4 ieee_copy_sign_4_8_ (GFC_REAL_4 *, GFC_REAL_8 *);\n+export_proto(ieee_copy_sign_4_8_);\n+GFC_REAL_4 ieee_copy_sign_4_8_ (GFC_REAL_4 *x, GFC_REAL_8 *y)\n+{\n+  GFC_REAL_4 s = __builtin_signbit(*y) ? -1 : 1;\n+  return __builtin_copysign(*x, s);\n+}\n+\n+GFC_REAL_8 ieee_copy_sign_8_4_ (GFC_REAL_8 *, GFC_REAL_4 *);\n+export_proto(ieee_copy_sign_8_4_);\n+GFC_REAL_8 ieee_copy_sign_8_4_ (GFC_REAL_8 *x, GFC_REAL_4 *y)\n+{\n+  GFC_REAL_8 s = __builtin_signbit(*y) ? -1 : 1;\n+  return __builtin_copysign(*x, s);\n+}\n+\n+GFC_REAL_8 ieee_copy_sign_8_8_ (GFC_REAL_8 *, GFC_REAL_8 *);\n+export_proto(ieee_copy_sign_8_8_);\n+GFC_REAL_8 ieee_copy_sign_8_8_ (GFC_REAL_8 *x, GFC_REAL_8 *y)\n+{\n+  GFC_REAL_8 s = __builtin_signbit(*y) ? -1 : 1;\n+  return __builtin_copysign(*x, s);\n+}\n+\n+int ieee_unordered_4_4_ (GFC_REAL_4 *, GFC_REAL_4 *);\n+export_proto(ieee_unordered_4_4_);\n+int ieee_unordered_4_4_ (GFC_REAL_4 *x, GFC_REAL_4 *y)\n+{\n+  return __builtin_isunordered(*x, *y);\n+}\n+\n+int ieee_unordered_4_8_ (GFC_REAL_4 *, GFC_REAL_8 *);\n+export_proto(ieee_unordered_4_8_);\n+int ieee_unordered_4_8_ (GFC_REAL_4 *x, GFC_REAL_8 *y)\n+{\n+  return __builtin_isunordered(*x, *y);\n+}\n+\n+int ieee_unordered_8_4_ (GFC_REAL_8 *, GFC_REAL_4 *);\n+export_proto(ieee_unordered_8_4_);\n+int ieee_unordered_8_4_ (GFC_REAL_8 *x, GFC_REAL_4 *y)\n+{\n+  return __builtin_isunordered(*x, *y);\n+}\n+\n+int ieee_unordered_8_8_ (GFC_REAL_8 *, GFC_REAL_8 *);\n+export_proto(ieee_unordered_8_8_);\n+int ieee_unordered_8_8_ (GFC_REAL_8 *x, GFC_REAL_8 *y)\n+{\n+  return __builtin_isunordered(*x, *y);\n+}\n+\n+\n+/* Arithmetic functions (LOGB, NEXT_AFTER, REM, RINT, SCALB).  */\n+\n+GFC_REAL_4 ieee_logb_4_ (GFC_REAL_4 *);\n+export_proto(ieee_logb_4_);\n+\n+GFC_REAL_4 ieee_logb_4_ (GFC_REAL_4 *x)\n+{\n+  GFC_REAL_4 res;\n+  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n+\n+  get_fpu_state (buffer);\n+  res = __builtin_logb (*x);\n+  set_fpu_state (buffer);\n+  return res;\n+}\n+\n+GFC_REAL_8 ieee_logb_8_ (GFC_REAL_8 *);\n+export_proto(ieee_logb_8_);\n+\n+GFC_REAL_8 ieee_logb_8_ (GFC_REAL_8 *x)\n+{\n+  GFC_REAL_8 res;\n+  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n+\n+  get_fpu_state (buffer);\n+  res = __builtin_logb (*x);\n+  set_fpu_state (buffer);\n+  return res;\n+}\n+\n+GFC_REAL_4 ieee_next_after_4_4_ (GFC_REAL_4 *, GFC_REAL_4 *);\n+export_proto(ieee_next_after_4_4_);\n+\n+GFC_REAL_4 ieee_next_after_4_4_ (GFC_REAL_4 *x, GFC_REAL_4 *y)\n+{\n+  return __builtin_nextafterf (*x, *y);\n+}\n+\n+GFC_REAL_4 ieee_next_after_4_8_ (GFC_REAL_4 *, GFC_REAL_8 *);\n+export_proto(ieee_next_after_4_8_);\n+\n+GFC_REAL_4 ieee_next_after_4_8_ (GFC_REAL_4 *x, GFC_REAL_8 *y)\n+{\n+  return __builtin_nextafterf (*x, *y);\n+}\n+\n+GFC_REAL_8 ieee_next_after_8_4_ (GFC_REAL_8 *, GFC_REAL_4 *);\n+export_proto(ieee_next_after_8_4_);\n+\n+GFC_REAL_8 ieee_next_after_8_4_ (GFC_REAL_8 *x, GFC_REAL_4 *y)\n+{\n+  return __builtin_nextafter (*x, *y);\n+}\n+\n+GFC_REAL_8 ieee_next_after_8_8_ (GFC_REAL_8 *, GFC_REAL_8 *);\n+export_proto(ieee_next_after_8_8_);\n+\n+GFC_REAL_8 ieee_next_after_8_8_ (GFC_REAL_8 *x, GFC_REAL_8 *y)\n+{\n+  return __builtin_nextafter (*x, *y);\n+}\n+\n+GFC_REAL_4 ieee_rem_4_4_ (GFC_REAL_4 *, GFC_REAL_4 *);\n+export_proto(ieee_rem_4_4_);\n+\n+GFC_REAL_4 ieee_rem_4_4_ (GFC_REAL_4 *x, GFC_REAL_4 *y)\n+{\n+  GFC_REAL_4 res;\n+  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n+\n+  get_fpu_state (buffer);\n+  res = __builtin_remainderf (*x, *y);\n+  set_fpu_state (buffer);\n+  return res;\n+}\n+\n+GFC_REAL_8 ieee_rem_4_8_ (GFC_REAL_4 *, GFC_REAL_8 *);\n+export_proto(ieee_rem_4_8_);\n+\n+GFC_REAL_8 ieee_rem_4_8_ (GFC_REAL_4 *x, GFC_REAL_8 *y)\n+{\n+  GFC_REAL_8 res;\n+  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n+\n+  get_fpu_state (buffer);\n+  res = __builtin_remainder (*x, *y);\n+  set_fpu_state (buffer);\n+  return res;\n+}\n+\n+GFC_REAL_8 ieee_rem_8_4_ (GFC_REAL_8 *, GFC_REAL_4 *);\n+export_proto(ieee_rem_8_4_);\n+\n+GFC_REAL_8 ieee_rem_8_4_ (GFC_REAL_8 *x, GFC_REAL_4 *y)\n+{\n+  GFC_REAL_8 res;\n+  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n+\n+  get_fpu_state (buffer);\n+  res = __builtin_remainder (*x, *y);\n+  set_fpu_state (buffer);\n+  return res;\n+}\n+\n+GFC_REAL_8 ieee_rem_8_8_ (GFC_REAL_8 *, GFC_REAL_8 *);\n+export_proto(ieee_rem_8_8_);\n+\n+GFC_REAL_8 ieee_rem_8_8_ (GFC_REAL_8 *x, GFC_REAL_8 *y)\n+{\n+  GFC_REAL_8 res;\n+  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n+\n+  get_fpu_state (buffer);\n+  res = __builtin_remainder (*x, *y);\n+  set_fpu_state (buffer);\n+  return res;\n+}\n+\n+GFC_REAL_4 ieee_rint_4_ (GFC_REAL_4 *);\n+export_proto(ieee_rint_4_);\n+\n+GFC_REAL_4 ieee_rint_4_ (GFC_REAL_4 *x)\n+{\n+  GFC_REAL_4 res;\n+  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n+\n+  get_fpu_state (buffer);\n+  res = __builtin_rint (*x);\n+  set_fpu_state (buffer);\n+  return res;\n+}\n+\n+GFC_REAL_8 ieee_rint_8_ (GFC_REAL_8 *);\n+export_proto(ieee_rint_8_);\n+\n+GFC_REAL_8 ieee_rint_8_ (GFC_REAL_8 *x)\n+{\n+  GFC_REAL_8 res;\n+  char buffer[GFC_FPE_STATE_BUFFER_SIZE];\n+\n+  get_fpu_state (buffer);\n+  res = __builtin_rint (*x);\n+  set_fpu_state (buffer);\n+  return res;\n+}\n+\n+GFC_REAL_4 ieee_scalb_4_ (GFC_REAL_4 *, int *);\n+export_proto(ieee_scalb_4_);\n+\n+GFC_REAL_4 ieee_scalb_4_ (GFC_REAL_4 *x, int *i)\n+{\n+  return __builtin_scalbnf (*x, *i);\n+}\n+\n+GFC_REAL_8 ieee_scalb_8_ (GFC_REAL_8 *, int *);\n+export_proto(ieee_scalb_8_);\n+\n+GFC_REAL_8 ieee_scalb_8_ (GFC_REAL_8 *x, int *i)\n+{\n+  return __builtin_scalbn (*x, *i);\n+}\n+\n+\n+#define GFC_FPE_ALL (GFC_FPE_INVALID | GFC_FPE_DENORMAL | \\\n+\t\t     GFC_FPE_ZERO | GFC_FPE_OVERFLOW | \\\n+\t\t     GFC_FPE_UNDERFLOW | GFC_FPE_INEXACT)\n+\n+/* Functions to save and restore floating-point state, clear and restore\n+   exceptions on procedure entry/exit.  The rules we follow are set\n+   in Fortran 2008's 14.3 paragraph 3, note 14.4, 14.4 paragraph 4,\n+   14.5 paragraph 2, and 14.6 paragraph 1.  */\n+\n+void ieee_procedure_entry (void *);\n+export_proto(ieee_procedure_entry);\n+\n+void\n+ieee_procedure_entry (void *state)\n+{\n+  /* Save the floating-point state in the space provided by the caller.  */\n+  get_fpu_state (state);\n+\n+  /* Clear the floating-point exceptions.  */\n+  set_fpu_except_flags (0, GFC_FPE_ALL);\n+}\n+\n+\n+void ieee_procedure_exit (void *);\n+export_proto(ieee_procedure_exit);\n+\n+void\n+ieee_procedure_exit (void *state)\n+{\n+  /* Get the flags currently signaling.  */\n+  int flags = get_fpu_except_flags ();\n+\n+  /* Restore the floating-point state we had on entry.  */\n+  set_fpu_state (state);\n+\n+  /* And re-raised the flags that were raised since entry.  */\n+  set_fpu_except_flags (flags, 0);\n+}\n+"}, {"sha": "8179ceab739d34c7dffdb2955c7c210634dbeaaf", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b198102220210ef6a61477d9a45564c206ee6b5/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=8b198102220210ef6a61477d9a45564c206ee6b5", "patch": "@@ -754,15 +754,39 @@ internal_proto(gf_strerror);\n extern void set_fpu (void);\n internal_proto(set_fpu);\n \n+extern int get_fpu_trap_exceptions (void);\n+internal_proto(get_fpu_trap_exceptions);\n+\n+extern void set_fpu_trap_exceptions (int, int);\n+internal_proto(set_fpu_trap_exceptions);\n+\n+extern int support_fpu_trap (int);\n+internal_proto(support_fpu_trap);\n+\n extern int get_fpu_except_flags (void);\n internal_proto(get_fpu_except_flags);\n \n-extern void set_fpu_rounding_mode (int round);\n+extern void set_fpu_except_flags (int, int);\n+internal_proto(set_fpu_except_flags);\n+\n+extern int support_fpu_flag (int);\n+internal_proto(support_fpu_flag);\n+\n+extern void set_fpu_rounding_mode (int);\n internal_proto(set_fpu_rounding_mode);\n \n extern int get_fpu_rounding_mode (void);\n internal_proto(get_fpu_rounding_mode);\n \n+extern int support_fpu_rounding_mode (int);\n+internal_proto(support_fpu_rounding_mode);\n+\n+extern void get_fpu_state (void *);\n+internal_proto(get_fpu_state);\n+\n+extern void set_fpu_state (void *);\n+internal_proto(set_fpu_state);\n+\n /* memory.c */\n \n extern void *xmalloc (size_t) __attribute__ ((malloc));"}]}