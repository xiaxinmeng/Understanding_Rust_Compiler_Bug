{"sha": "3d3bf932b985baee7ac3973208c0d775dcb93b5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QzYmY5MzJiOTg1YmFlZTdhYzM5NzMyMDhjMGQ3NzVkY2I5M2I1ZA==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2007-04-06T09:15:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:15:09Z"}, "message": "g-stsifd-sockets.adb: New file.\n\n2007-04-06  Thomas Quinot  <quinot@adacore.com>\n\t    Pat Rogers  <rogers@adacore.com>\n\t    Pascal Obry  <obry@adacore.com>\n\n\t* g-stsifd-sockets.adb: New file.\n\n\t* g-socthi.ads, g-socket.adb, g-socthi-vxworks.adb,\n\tg-socthi-vxworks.ads, g-socthi-mingw.ads, g-socthi-vms.ads,\n\tg-socthi-vms.adb: Move signalling\n\tfd management to a nested package, so that they can conveniently be\n\tmoved to a subunit that is shared across Windows, VMS, and VxWorks\n\t(Ada implementation) or completed with imported bodies from socket.c\n\t(UNIX case).\n\t(Read_Signalling_Fd, Write_Signalling_Fd, Create_Signalling_Fds): New\n\tsubprograms.\n\t(Check_Selector): Use Read_Signalling_Fd to read and discard data from\n\tthe signalling file descriptor.\n\t(Abort_Selector): Use Write_Signalling_Fd to write dummy data to the\n\tsignalling file descriptor.\n\t(Create_Selector): Use new C-imported subprogram Create_Signalling_Fds\n\tinstead of creating a pair of sockets for signalling here.\n\n\t* g-socthi.adb: Ditto.\n\tSet the runtime process to ignore SIGPIPEs on platforms that support\n\tneither SO_NOSIGPIPE nor MSG_NOSIGNAL functionality.\n\n\t* g-socthi-mingw.adb: Ditto.\n\t(WS_Version): Use Windows 2.2.\n\tUse Winsock 2.2 (instead of 1.1) for the GNAT.Socket API.\n\n\t* g-soliop-mingw.ads: Link with ws2_32 for Windows 2.x support.\n\tUse Winsock 2.2 (instead of 1.1) for the GNAT.Socket API.\n\n\t* Makefile.in: New libgnat pair g-stsifd.adb<g-stsifd-sockets.adb.\n\tadded GNAT byte swapping facility\n\tUpdate FreeBSD THREADSLIB from -lc_r to -lpthread, for FreeBSD 6.\n\n\t* g-bytswa.adb, g-bytswa-x86.adb, g-bytswa.ads: New files.\n\n\t* socket.c (__gnat_read_signalling_fd, __gnat_write_controlling_fd):\n\tNew subprograms.\n\t(__gnat_create_signalling_fds): New subprogram.\n\tSet the runtime process to ignore SIGPIPEs on platforms that support\n\tneither SO_NOSIGPIPE nor MSG_NOSIGNAL functionality.\n\nFrom-SVN: r123542", "tree": {"sha": "d2a9f2de1b4f8ce5a655a929362077213fa220da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2a9f2de1b4f8ce5a655a929362077213fa220da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d3bf932b985baee7ac3973208c0d775dcb93b5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d3bf932b985baee7ac3973208c0d775dcb93b5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d3bf932b985baee7ac3973208c0d775dcb93b5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d3bf932b985baee7ac3973208c0d775dcb93b5d/comments", "author": null, "committer": null, "parents": [{"sha": "baa3441ddf0daabf8b0127a577121348906aa8b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baa3441ddf0daabf8b0127a577121348906aa8b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baa3441ddf0daabf8b0127a577121348906aa8b6"}], "stats": {"total": 1404, "additions": 1156, "deletions": 248}, "files": [{"sha": "ff27a4e070ad79a42f117ce8bcabc028a2d69471", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -1,5 +1,5 @@\n # Makefile for GNU Ada Compiler (GNAT).\n-#   Copyright (C) 1994-2005 Free Software Foundation, Inc.\n+#   Copyright (C) 1994-2006 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -409,6 +409,7 @@ ifeq ($(strip $(filter-out m68k% wrs vx%,$(targ))),)\n   g-soccon.ads<g-soccon-vxworks.ads \\\n   g-socthi.ads<g-socthi-vxworks.ads \\\n   g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n   system.ads<system-vxworks-m68k.ads\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-vxworks.adb\n@@ -444,7 +445,8 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n   s-vxwork.ads<s-vxwork-ppc.ads \\\n   g-soccon.ads<g-soccon-vxworks.ads \\\n   g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb\n+  g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-vxworks.adb\n \n@@ -501,6 +503,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(targ))),)\n   g-soccon.ads<g-soccon-vxworks.ads \\\n   g-socthi.ads<g-socthi-vxworks.ads \\\n   g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n   system.ads<system-vxworks-ppc-vthread.ads\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-vxworks.adb\n@@ -546,6 +549,7 @@ ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n   g-soccon.ads<g-soccon-vxworks.ads \\\n   g-socthi.ads<g-socthi-vxworks.ads \\\n   g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n   system.ads<system-vxworks-sparcv9.ads   \\\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-vxworks.adb\n@@ -572,9 +576,11 @@ ifeq ($(strip $(filter-out %86 wrs vxworks,$(targ))),)\n   s-taprop.adb<s-taprop-vxworks.adb \\\n   s-taspri.ads<s-taspri-vxworks.ads \\\n   s-vxwork.ads<s-vxwork-x86.ads \\\n+  g-bytswa.adb<g-bytswa-x86.adb \\\n   g-soccon.ads<g-soccon-vxworks.ads \\\n   g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb\n+  g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-vxworks.adb\n \n@@ -627,6 +633,7 @@ ifeq ($(strip $(filter-out arm% coff wrs vx%,$(targ))),)\n   g-soccon.ads<g-soccon-vxworks.ads \\\n   g-socthi.ads<g-socthi-vxworks.ads \\\n   g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n   system.ads<system-vxworks-arm.ads\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-vxworks.adb\n@@ -656,6 +663,7 @@ ifeq ($(strip $(filter-out mips% wrs vx%,$(targ))),)\n   g-soccon.ads<g-soccon-vxworks.ads \\\n   g-socthi.ads<g-socthi-vxworks.ads \\\n   g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n   system.ads<system-vxworks-mips.ads\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-vxworks.adb\n@@ -752,6 +760,7 @@ ifeq ($(strip $(filter-out %86 solaris2%,$(arch) $(osys))),)\n   s-tasinf.ads<s-tasinf-solaris.ads \\\n   s-taspri.ads<s-taspri-solaris.ads \\\n   s-tpopsp.adb<s-tpopsp-solaris.adb \\\n+  g-bytswa.adb<g-bytswa-x86.adb \\\n   g-soccon.ads<g-soccon-solaris.ads \\\n   g-soliop.ads<g-soliop-solaris.ads \\\n   system.ads<system-solaris-x86.ads\n@@ -772,6 +781,7 @@ ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n   a-intnam.ads<a-intnam-linux.ads \\\n   a-numaux.adb<a-numaux-x86.adb \\\n   a-numaux.ads<a-numaux-x86.ads \\\n+  g-bytswa.adb<g-bytswa-x86.adb \\\n   g-soccon.ads<g-soccon-linux-x86.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n   s-intman.adb<s-intman-posix.adb \\\n@@ -828,6 +838,7 @@ ifeq ($(strip $(filter-out %86 freebsd%,$(arch) $(osys))),)\n   a-intnam.ads<a-intnam-freebsd.ads \\\n   a-numaux.adb<a-numaux-x86.adb \\\n   a-numaux.ads<a-numaux-x86.ads \\\n+  g-bytswa.adb<g-bytswa-x86.adb \\\n   g-soccon.ads<g-soccon-freebsd.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n   s-intman.adb<s-intman-posix.adb \\\n@@ -844,7 +855,7 @@ ifeq ($(strip $(filter-out %86 freebsd%,$(arch) $(osys))),)\n   GNATLIB_SHARED = gnatlib-shared-dual\n \n   EH_MECHANISM=-gcc\n-  THREADSLIB= -lc_r\n+  THREADSLIB= -lpthread\n   GMEM_LIB = gmemlib\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n   LIBRARY_VERSION := $(LIB_VERSION)\n@@ -1010,6 +1021,7 @@ ifeq ($(strip $(filter-out lynxos,$(osys))),)\n     a-numaux.adb<a-numaux-x86.adb \\\n     a-numaux.ads<a-numaux-x86.ads \\\n     a-intnam.ads<a-intnam-lynxos.ads \\\n+    g-bytswa.adb<g-bytswa-x86.adb \\\n     s-inmaop.adb<s-inmaop-posix.adb \\\n     s-intman.adb<s-intman-posix.adb \\\n     s-osinte.adb<s-osinte-lynxos.adb \\\n@@ -1142,6 +1154,7 @@ endif\n   g-soccon.ads<g-soccon-vms.ads \\\n   g-socthi.ads<g-socthi-vms.ads \\\n   g-socthi.adb<g-socthi-vms.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n   i-c.ads<i-c-vms_64.ads \\\n   i-cstrin.ads<i-cstrin-vms_64.ads \\\n   i-cstrin.adb<i-cstrin-vms_64.adb \\\n@@ -1212,8 +1225,10 @@ ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)\n   s-osprim.adb<s-osprim-mingw.adb \\\n   s-taprop.adb<s-taprop-mingw.adb \\\n   s-taspri.ads<s-taspri-mingw.ads \\\n+  g-bytswa.adb<g-bytswa-x86.adb \\\n   g-socthi.ads<g-socthi-mingw.ads \\\n   g-socthi.adb<g-socthi-mingw.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n   g-soccon.ads<g-soccon-mingw.ads \\\n   g-soliop.ads<g-soliop-mingw.ads \\\n   system.ads<system-mingw.ads"}, {"sha": "1ec8a0f1be78c05befab63311cdd01c92db40074", "filename": "gcc/ada/g-bytswa-x86.adb", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-bytswa-x86.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-bytswa-x86.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-bytswa-x86.adb?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -0,0 +1,194 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . B Y T E _ S W A P P I N G                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                      Copyright (C) 2006, AdaCore                         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a machine-specific version of this package.\n+--  It uses instructions available on Intel 486 processors (or later).\n+\n+with Interfaces;          use Interfaces;\n+with System.Machine_Code; use System.Machine_Code;\n+with Ada.Unchecked_Conversion;\n+\n+package body GNAT.Byte_Swapping is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Swapped32 (Value : Unsigned_32) return Unsigned_32;\n+   pragma Inline_Always (Swapped32);\n+\n+   --------------\n+   -- Swapped2 --\n+   --------------\n+\n+   function Swapped2 (Input : Item) return Item is\n+\n+      function As_U16 is new Ada.Unchecked_Conversion\n+         (Source => Item, Target => Unsigned_16);\n+\n+      function As_Item is new Ada.Unchecked_Conversion\n+         (Source => Unsigned_16, Target => Item);\n+\n+      X : Unsigned_16 := As_U16 (Input);\n+\n+   begin\n+      Asm (\"xchgb %b0,%h0\",\n+           Unsigned_16'Asm_Output (\"=q\", X),\n+           Unsigned_16'Asm_Input (\"0\", X));\n+      return As_Item (X);\n+   end Swapped2;\n+\n+   --------------\n+   -- Swapped4 --\n+   --------------\n+\n+   function Swapped4 (Input : Item) return Item is\n+\n+      function As_U32 is new Ada.Unchecked_Conversion\n+         (Source => Item, Target => Unsigned_32);\n+\n+      function As_Item is new Ada.Unchecked_Conversion\n+         (Source => Unsigned_32, Target => Item);\n+\n+      X : Unsigned_32 := As_U32 (Input);\n+\n+   begin\n+      Asm (\"bswap %0\",\n+           Unsigned_32'Asm_Output (\"=r\", X),\n+           Unsigned_32'Asm_Input (\"0\", X));\n+      return As_Item (X);\n+   end Swapped4;\n+\n+   --------------\n+   -- Swapped8 --\n+   --------------\n+\n+   function Swapped8 (Input : Item) return Item is\n+\n+      function As_U64 is new Ada.Unchecked_Conversion\n+         (Source => Item, Target => Unsigned_64);\n+\n+      X : Unsigned_64 renames As_U64 (Input);\n+\n+      type Two_Words is array (0 .. 1) of Unsigned_32;\n+      for Two_Words'Component_Size use Unsigned_32'Size;\n+\n+      function As_Item is new Ada.Unchecked_Conversion\n+        (Source => Two_Words, Target => Item);\n+\n+      Result : Two_Words;\n+\n+   begin\n+      Asm (\"xchgl %0,%1\",\n+         Outputs =>\n+            (Unsigned_32'Asm_Output (\"=r\", Result (0)),\n+             Unsigned_32'Asm_Output (\"=r\", Result (1))),\n+         Inputs =>\n+            (Unsigned_32'Asm_Input (\"0\",\n+                Swapped32 (Unsigned_32 (X and 16#0000_0000_FFFF_FFFF#))),\n+             Unsigned_32'Asm_Input (\"1\",\n+                Swapped32 (Unsigned_32 (Shift_Right (X, 32))))));\n+      return As_Item (Result);\n+   end Swapped8;\n+\n+   -----------\n+   -- Swap2 --\n+   -----------\n+\n+   procedure Swap2 (Location : in System.Address) is\n+\n+      X : Unsigned_16;\n+      for X'Address use Location;\n+\n+   begin\n+      Asm (\"xchgb %b0,%h0\",\n+           Unsigned_16'Asm_Output (\"=q\", X),\n+           Unsigned_16'Asm_Input (\"0\", X));\n+   end Swap2;\n+\n+   -----------\n+   -- Swap4 --\n+   -----------\n+\n+   procedure Swap4 (Location : in System.Address) is\n+\n+      X : Unsigned_32;\n+      for X'Address use Location;\n+\n+   begin\n+      Asm (\"bswap %0\",\n+           Unsigned_32'Asm_Output (\"=r\", X),\n+           Unsigned_32'Asm_Input (\"0\", X));\n+   end Swap4;\n+\n+   ---------------\n+   -- Swapped32 --\n+   ---------------\n+\n+   function Swapped32 (Value : Unsigned_32) return Unsigned_32 is\n+      X : Unsigned_32 := Value;\n+   begin\n+      Asm (\"bswap %0\",\n+           Unsigned_32'Asm_Output (\"=r\", X),\n+           Unsigned_32'Asm_Input (\"0\", X));\n+      return X;\n+   end Swapped32;\n+\n+   -----------\n+   -- Swap8 --\n+   -----------\n+\n+   procedure Swap8 (Location : in System.Address) is\n+\n+      X : Unsigned_64;\n+      for X'Address use Location;\n+\n+      type Two_Words is array (0 .. 1) of Unsigned_32;\n+      for Two_Words'Component_Size use Unsigned_32'Size;\n+\n+      Words : Two_Words;\n+      for Words'Address use Location;\n+\n+   begin\n+      Asm (\"xchgl %0,%1\",\n+         Outputs =>\n+            (Unsigned_32'Asm_Output (\"=r\", Words (0)),\n+             Unsigned_32'Asm_Output (\"=r\", Words (1))),\n+         Inputs =>\n+            (Unsigned_32'Asm_Input (\"0\",\n+                Swapped32 (Unsigned_32 (X and 16#0000_0000_FFFF_FFFF#))),\n+             Unsigned_32'Asm_Input (\"1\",\n+                Swapped32 (Unsigned_32 (Shift_Right (X, 32))))));\n+   end Swap8;\n+\n+end GNAT.Byte_Swapping;"}, {"sha": "254e638bed57e94ca3fa13a9b97094b5117408dc", "filename": "gcc/ada/g-bytswa.adb", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-bytswa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-bytswa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-bytswa.adb?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -0,0 +1,156 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . B Y T E _ S W A P P I N G                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                      Copyright (C) 2006, AdaCore                         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a general implementation that does not take advantage of\n+--  any machine-specific instructions.\n+\n+with Interfaces; use Interfaces;\n+with Ada.Unchecked_Conversion;\n+\n+package body GNAT.Byte_Swapping is\n+\n+   --------------\n+   -- Swapped2 --\n+   --------------\n+\n+   function Swapped2 (Input : Item) return Item is\n+\n+      function As_U16 is new Ada.Unchecked_Conversion\n+         (Source => Item, Target => Unsigned_16);\n+\n+      function As_Item is new Ada.Unchecked_Conversion\n+         (Source => Unsigned_16, Target => Item);\n+\n+      X : Unsigned_16 renames As_U16 (Input);\n+\n+   begin\n+      return As_Item ((Shift_Left (X, 8)  and 16#FF00#) or\n+                      (Shift_Right (X, 8) and 16#00FF#));\n+   end Swapped2;\n+\n+   --------------\n+   -- Swapped4 --\n+   --------------\n+\n+   function Swapped4 (Input : Item) return Item is\n+\n+      function As_U32 is new Ada.Unchecked_Conversion\n+         (Source => Item, Target => Unsigned_32);\n+\n+      function As_Item is new Ada.Unchecked_Conversion\n+         (Source => Unsigned_32, Target => Item);\n+\n+      X : Unsigned_32 renames As_U32 (Input);\n+\n+   begin\n+      return As_Item ((Shift_Right (X, 24) and 16#0000_00FF#) or\n+                      (Shift_Right (X, 8)  and 16#0000_FF00#) or\n+                      (Shift_Left (X, 8)   and 16#00FF_0000#) or\n+                      (Shift_Left (X, 24)  and 16#FF00_0000#));\n+   end Swapped4;\n+\n+   --------------\n+   -- Swapped8 --\n+   --------------\n+\n+   function Swapped8 (Input : Item) return Item is\n+\n+      function As_U64 is new Ada.Unchecked_Conversion\n+         (Source => Item, Target => Unsigned_64);\n+\n+      function As_Item is new Ada.Unchecked_Conversion\n+         (Source => Unsigned_64, Target => Item);\n+\n+      X : Unsigned_64 renames As_U64 (Input);\n+\n+      Low, High : aliased Unsigned_32;\n+\n+   begin\n+      Low := Unsigned_32 (X and 16#0000_0000_FFFF_FFFF#);\n+      Swap4 (Low'Address);\n+      High := Unsigned_32 (Shift_Right (X, 32));\n+      Swap4 (High'Address);\n+      return As_Item\n+         (Shift_Left (Unsigned_64 (Low), 32) or Unsigned_64 (High));\n+   end Swapped8;\n+\n+   -----------\n+   -- Swap2 --\n+   -----------\n+\n+   procedure Swap2 (Location : System.Address) is\n+\n+      X : Unsigned_16;\n+      for X'Address use Location;\n+\n+   begin\n+      X := (Shift_Left (X, 8)  and 16#FF00#) or\n+           (Shift_Right (X, 8) and 16#00FF#);\n+   end Swap2;\n+\n+   -----------\n+   -- Swap4 --\n+   -----------\n+\n+   procedure Swap4 (Location : System.Address) is\n+\n+      X : Unsigned_32;\n+      for X'Address use Location;\n+\n+   begin\n+      X := (Shift_Right (X, 24) and 16#0000_00FF#) or\n+           (Shift_Right (X, 8)  and 16#0000_FF00#) or\n+           (Shift_Left (X, 8)   and 16#00FF_0000#) or\n+           (Shift_Left (X, 24)  and 16#FF00_0000#);\n+   end Swap4;\n+\n+   -----------\n+   -- Swap8 --\n+   -----------\n+\n+   procedure Swap8 (Location : System.Address) is\n+\n+      X : Unsigned_64;\n+      for X'Address use Location;\n+\n+      Low, High : aliased Unsigned_32;\n+\n+   begin\n+      Low := Unsigned_32 (X and 16#0000_0000_FFFF_FFFF#);\n+      Swap4 (Low'Address);\n+      High := Unsigned_32 (Shift_Right (X, 32));\n+      Swap4 (High'Address);\n+      X := Shift_Left (Unsigned_64 (Low), 32) or Unsigned_64 (High);\n+   end Swap8;\n+\n+end GNAT.Byte_Swapping;"}, {"sha": "5c9741482ea3a6e85d1b38ec944684d202fae45b", "filename": "gcc/ada/g-bytswa.ads", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-bytswa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-bytswa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-bytswa.ads?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -0,0 +1,206 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . B Y T E _ S W A P P I N G                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                      Copyright (C) 2006, AdaCore                         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Simple routines for swapping the bytes of 16-, 32-, and 64-bit objects.\n+\n+--  The generic functions should be instantiated with types that\n+--  are of a size in bytes corresponding to the name of the generic. For\n+--  example, a 2-byte integer type would be compatible with Swapped2, 4-byte\n+--  integer with Swapped4, and so on. Failure to do so will result in a\n+--  warning when compiling the instantiation; this warning should be heeded.\n+--  Ignoring this warning can result in unexpected results.\n+\n+--  An example of proper usage follows:\n+\n+--     declare\n+--        type Short_Integer is range -32768 .. 32767;\n+--        for Short_Integer'Size use 16; -- for confirmation\n+\n+--        X : Short_Integer := 16#7FFF#;\n+\n+--        function Swapped is new Byte_Swapping.Swapped2 (Short_Integer);\n+\n+--     begin\n+--        Put_Line (X'Img);\n+--        X := Swapped (X);\n+--        Put_Line (X'Img);\n+--     end;\n+\n+--  Note that the generic actual types need not be scalars, but must be\n+--  'definite' types. They can, for example, be constrained subtypes of\n+--  unconstrained array types as long as the size is correct. For instance,\n+--  a subtype of String with length of 4 would be compatible with the\n+--  Swapped4 generic:\n+\n+--     declare\n+--        subtype String4 is String (1 .. 4);\n+--        function Swapped is new Byte_Swapping.Swapped4 (String4);\n+--        S : String4 := \"ABCD\";\n+--     begin\n+--        Put_Line (S);\n+--        S := Swapped (S);\n+--        Put_Line (S);\n+--     end;\n+\n+--  Similarly, a constrained array type is also acceptable:\n+\n+--     declare\n+--        type Mask is array (0 .. 15) of Boolean;\n+--        for Mask'Component_Size use Boolean'Size;\n+--        X : Mask := (0 .. 7 => True, others => False);\n+--        function Swapped is new Byte_Swapping.Swapped2 (Mask);\n+--     begin\n+--        ...\n+--        X := Swapped (X);\n+--        ...\n+--     end;\n+\n+--  A properly-sized record type will also be acceptable, and so forth.\n+\n+--  However, as described, a size mismatch must be avoided. In the following\n+--  we instantiate one of the generics with a type that is too large. The\n+--  result of the function call is undefined, such that assignment to an\n+--  object can result in garbage values.\n+\n+--     Wrong: declare\n+--        subtype String16 is String (1 .. 16);\n+\n+--        function Swapped is new Byte_Swapping.Swapped8 (String16);\n+--        --  Instantiation generates a compiler warning about\n+--        --  mismatched sizes\n+\n+--        S : String16;\n+\n+--     begin\n+--        S := \"ABCDEFGHDEADBEEF\";\n+--\n+--        Put_Line (S);\n+--\n+--        --  the following assignment results in garbage in S after the\n+--        --  first 8 bytes\n+--\n+--        S := Swapped (S);\n+--\n+--        Put_Line (S);\n+--     end Wrong;\n+\n+--  When the size of the type is larger than 8 bytes, the use of the\n+--  non-generic procedures is an alternative because no function result is\n+--  involved; manipulation of the object is direct.\n+\n+--  The procedures are passed the address of an object to manipulate. They will\n+--  swap the first N bytes of that object corresponding to the name of the\n+--  procedure.  For example:\n+\n+--     declare\n+--        S2 : String := \"AB\";\n+--        for S2'Alignment use 2;\n+--        S4 : String := \"ABCD\";\n+--        for S4'Alignment use 4;\n+--        S8 : String := \"ABCDEFGH\";\n+--        for S8'Alignment use 8;\n+\n+--     begin\n+--        Swap2 (S2'Address);\n+--        Put_Line (S2);\n+\n+--        Swap4 (S4'Address);\n+--        Put_Line (S4);\n+\n+--        Swap8 (S8'Address);\n+--        Put_Line (S8);\n+--     end;\n+\n+--  If an object of a type larger than N is passed, the remaining\n+--  bytes of the object are undisturbed.  For example:\n+\n+--     declare\n+--        subtype String16 is String (1 .. 16);\n+\n+--        S : String16;\n+--        for S'Alignment use 8;\n+\n+--     begin\n+--        S  := \"ABCDEFGHDEADBEEF\";\n+--        Put_Line (S);\n+--        Swap8 (S'Address);\n+--        Put_Line (S);\n+--     end;\n+\n+with System;\n+\n+package GNAT.Byte_Swapping is\n+   pragma Pure;\n+\n+   --  NB: all the routines in this package treat the application objects as\n+   --  unsigned (modular) types of a size in bytes corresponding to the routine\n+   --  name. For example, the generic function Swapped2 manipulates the object\n+   --  passed to the formal parameter Input as a value of an unsigned type that\n+   --  is 2 bytes long. Therefore clients are responsible for the compatibility\n+   --  of application types manipulated by these routines and these modular\n+   --  types, in terms of both size and alignment. This requirement applies to\n+   --  the generic actual type passed to the generic formal type Item in the\n+   --  generic functions, as well as to the type of the object implicitly\n+   --  designated by the address passed to the non-generic procedures. Use of\n+   --  incompatible types can result in implementation- defined effects.\n+\n+   generic\n+      type Item is limited private;\n+   function Swapped2 (Input : Item) return Item;\n+   --  Return the 2-byte value of Input with the bytes swapped\n+\n+   generic\n+      type Item is limited private;\n+   function Swapped4 (Input : Item) return Item;\n+   --  Return the 4-byte value of Input with the bytes swapped\n+\n+   generic\n+      type Item is limited private;\n+   function Swapped8 (Input : Item) return Item;\n+   --  Return the 8-byte value of Input with the bytes swapped\n+\n+   procedure Swap2 (Location : System.Address);\n+   --  Swap the first 2 bytes of the object starting at the address specified\n+   --  by Location.\n+\n+   procedure Swap4 (Location : System.Address);\n+   --  Swap the first 4 bytes of the object starting at the address specified\n+   --  by Location.\n+\n+   procedure Swap8 (Location : System.Address);\n+   --  Swap the first 8 bytes of the object starting at the address specified\n+   --  by Location.\n+\n+   pragma Inline (Swap2, Swap4, Swap8, Swapped2, Swapped4, Swapped8);\n+\n+end GNAT.Byte_Swapping;"}, {"sha": "2773b7ab036b54883617718c13a03e4d809fe71b", "filename": "gcc/ada/g-socket.adb", "status": "modified", "additions": 17, "deletions": 105, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -236,14 +236,13 @@ package body GNAT.Sockets is\n    --------------------\n \n    procedure Abort_Selector (Selector : Selector_Type) is\n-      Buf : aliased Character := ASCII.NUL;\n       Res : C.int;\n \n    begin\n-      --  Send an empty array to unblock C select system call\n+      --  Send one byte to unblock select system call\n+\n+      Res := Signalling_Fds.Write (C.int (Selector.W_Sig_Socket));\n \n-      Res := C_Send (C.int (Selector.W_Sig_Socket), Buf'Address, 1,\n-                     Constants.MSG_Forced_Flags);\n       if Res = Failure then\n          Raise_Socket_Error (Socket_Errno);\n       end if;\n@@ -454,16 +453,11 @@ package body GNAT.Sockets is\n          if Is_Set (RSet, RSig) then\n             Clear (RSet, RSig);\n \n-            declare\n-               Buf : Character;\n-\n-            begin\n-               Res := C_Recv (C.int (RSig), Buf'Address, 1, 0);\n+            Res := Signalling_Fds.Read (C.int (RSig));\n \n-               if Res = Failure then\n-                  Raise_Socket_Error (Socket_Errno);\n-               end if;\n-            end;\n+            if Res = Failure then\n+               Raise_Socket_Error (Socket_Errno);\n+            end if;\n \n             Status := Aborted;\n \n@@ -674,105 +668,23 @@ package body GNAT.Sockets is\n    ---------------------\n \n    procedure Create_Selector (Selector : out Selector_Type) is\n-      S0  : C.int;\n-      S1  : C.int;\n-      S2  : C.int;\n-      Res : C.int;\n-      Sin : aliased Sockaddr_In;\n-      Len : aliased C.int := Sin'Size / 8;\n-      Err : Integer;\n+      Two_Fds : aliased Fd_Pair;\n+      Res     : C.int;\n \n    begin\n-      --  We open two signalling sockets. One of them is used to send data to\n-      --  the other, which is included in a C_Select socket set. The\n-      --  communication is used to force the call to C_Select to complete, and\n+      --  We open two signalling file descriptors. One of them is used to send\n+      --  data to the other, which is included in a C_Select socket set. The\n+      --  communication is used to force a call to C_Select to complete, and\n       --  the waiting task to resume its execution.\n \n-      --  Create a listening socket\n-\n-      S0 := C_Socket (Constants.AF_INET, Constants.SOCK_STREAM, 0);\n-\n-      if S0 = Failure then\n-         Raise_Socket_Error (Socket_Errno);\n-      end if;\n-\n-      --  Bind the socket to any unused port on localhost\n-\n-      Sin.Sin_Addr.S_B1 := 127;\n-      Sin.Sin_Addr.S_B2 := 0;\n-      Sin.Sin_Addr.S_B3 := 0;\n-      Sin.Sin_Addr.S_B4 := 1;\n-      Sin.Sin_Port := 0;\n-\n-      Res := C_Bind (S0, Sin'Address, Len);\n-\n-      if Res = Failure then\n-         Err := Socket_Errno;\n-         Res := C_Close (S0);\n-         Raise_Socket_Error (Err);\n-      end if;\n-\n-      --  Get the port used by the socket\n-\n-      Res := C_Getsockname (S0, Sin'Address, Len'Access);\n-\n-      if Res = Failure then\n-         Err := Socket_Errno;\n-         Res := C_Close (S0);\n-         Raise_Socket_Error (Err);\n-      end if;\n-\n-      --  Set backlog to 1 to guarantee that exactly one call to connect(2)\n-      --  can succeed.\n-\n-      Res := C_Listen (S0, 1);\n-\n-      if Res = Failure then\n-         Err := Socket_Errno;\n-         Res := C_Close (S0);\n-         Raise_Socket_Error (Err);\n-      end if;\n-\n-      S1 := C_Socket (Constants.AF_INET, Constants.SOCK_STREAM, 0);\n-\n-      if S1 = Failure then\n-         Err := Socket_Errno;\n-         Res := C_Close (S0);\n-         Raise_Socket_Error (Err);\n-      end if;\n-\n-      --  Do a connect and accept the connection\n-\n-      Res := C_Connect (S1, Sin'Address, Len);\n-\n-      if Res = Failure then\n-         Err := Socket_Errno;\n-         Res := C_Close (S0);\n-         Res := C_Close (S1);\n-         Raise_Socket_Error (Err);\n-      end if;\n-\n-      --  Since the call to connect(2) has suceeded and the backlog limit on\n-      --  the listening socket is 1, we know that there is now exactly one\n-      --  pending connection on S0, which is the one from S1.\n-\n-      S2 := C_Accept (S0, Sin'Address, Len'Access);\n-\n-      if S2 = Failure then\n-         Err := Socket_Errno;\n-         Res := C_Close (S0);\n-         Res := C_Close (S1);\n-         Raise_Socket_Error (Err);\n-      end if;\n-\n-      Res := C_Close (S0);\n+      Res := Signalling_Fds.Create (Two_Fds'Access);\n \n       if Res = Failure then\n          Raise_Socket_Error (Socket_Errno);\n       end if;\n \n-      Selector.R_Sig_Socket := Socket_Type (S1);\n-      Selector.W_Sig_Socket := Socket_Type (S2);\n+      Selector.R_Sig_Socket := Socket_Type (Two_Fds (Read_End));\n+      Selector.W_Sig_Socket := Socket_Type (Two_Fds (Write_End));\n    end Create_Selector;\n \n    -------------------\n@@ -1073,7 +985,7 @@ package body GNAT.Sockets is\n    is\n       use type C.unsigned_char;\n \n-      V8  : aliased Two_Int;\n+      V8  : aliased Two_Ints;\n       V4  : aliased C.int;\n       V1  : aliased C.unsigned_char;\n       VT  : aliased Timeval;\n@@ -1899,7 +1811,7 @@ package body GNAT.Sockets is\n       Level  : Level_Type := Socket_Level;\n       Option : Option_Type)\n    is\n-      V8  : aliased Two_Int;\n+      V8  : aliased Two_Ints;\n       V4  : aliased C.int;\n       V1  : aliased C.unsigned_char;\n       VT  : aliased Timeval;"}, {"sha": "1b74d907670c7eb633ac095dc6fa74c696aaad8d", "filename": "gcc/ada/g-socthi-mingw.adb", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-mingw.adb?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2005, AdaCore                     --\n+--                     Copyright (C) 2001-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,13 +48,13 @@ package body GNAT.Sockets.Thin is\n \n    WSAData_Dummy : array (1 .. 512) of C.int;\n \n-   WS_Version  : constant := 16#0101#;\n+   WS_Version  : constant := 16#0202#;\n    Initialized : Boolean := False;\n \n-   SYSNOTREADY          : constant := 10091;\n-   VERNOTSUPPORTED      : constant := 10092;\n-   NOTINITIALISED       : constant := 10093;\n-   EDISCON              : constant := 10101;\n+   SYSNOTREADY     : constant := 10091;\n+   VERNOTSUPPORTED : constant := 10092;\n+   NOTINITIALISED  : constant := 10093;\n+   EDISCON         : constant := 10101;\n \n    function Standard_Connect\n      (S       : C.int;\n@@ -258,11 +258,11 @@ package body GNAT.Sockets.Thin is\n    -------------\n \n    function C_Readv\n-     (Socket : C.int;\n+     (Fd     : C.int;\n       Iov    : System.Address;\n       Iovcnt : C.int) return C.int\n    is\n-      Res : C.int;\n+      Res   : C.int;\n       Count : C.int := 0;\n \n       Iovec : array (0 .. Iovcnt - 1) of Vector_Element;\n@@ -272,7 +272,7 @@ package body GNAT.Sockets.Thin is\n    begin\n       for J in Iovec'Range loop\n          Res := C_Recv\n-           (Socket,\n+           (Fd,\n             Iovec (J).Base.all'Address,\n             C.int (Iovec (J).Length),\n             0);\n@@ -434,11 +434,11 @@ package body GNAT.Sockets.Thin is\n    --------------\n \n    function C_Writev\n-     (Socket : C.int;\n+     (Fd     : C.int;\n       Iov    : System.Address;\n       Iovcnt : C.int) return C.int\n    is\n-      Res : C.int;\n+      Res   : C.int;\n       Count : C.int := 0;\n \n       Iovec : array (0 .. Iovcnt - 1) of Vector_Element;\n@@ -448,7 +448,7 @@ package body GNAT.Sockets.Thin is\n    begin\n       for J in Iovec'Range loop\n          Res := C_Send\n-           (Socket,\n+           (Fd,\n             Iovec (J).Base.all'Address,\n             C.int (Iovec (J).Length),\n             0);\n@@ -478,7 +478,7 @@ package body GNAT.Sockets.Thin is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Process_Blocking_IO : Boolean := False) is\n+   procedure Initialize (Process_Blocking_IO : Boolean) is\n       pragma Unreferenced (Process_Blocking_IO);\n \n       Return_Value : Interfaces.C.int;\n@@ -542,6 +542,12 @@ package body GNAT.Sockets.Thin is\n       Sin.Sin_Port := Port;\n    end Set_Port;\n \n+   --------------------\n+   -- Signalling_Fds --\n+   --------------------\n+\n+   package body Signalling_Fds is separate;\n+\n    --------------------------\n    -- Socket_Error_Message --\n    --------------------------"}, {"sha": "9db2866f5cf38117029b576159cdc1640b7eb679", "filename": "gcc/ada/g-socthi-mingw.ads", "status": "modified", "additions": 69, "deletions": 39, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi-mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi-mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-mingw.ads?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2005, AdaCore                     --\n+--                     Copyright (C) 2001-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -60,10 +60,9 @@ package GNAT.Sockets.Thin is\n    procedure Set_Socket_Errno (Errno : Integer);\n    --  Set last socket error number\n \n-   function Socket_Error_Message\n-     (Errno : Integer) return C.Strings.chars_ptr;\n-   --  Returns the error message string for the error number Errno. If\n-   --  Errno is not known it returns \"Unknown system error\".\n+   function Socket_Error_Message (Errno : Integer) return C.Strings.chars_ptr;\n+   --  Returns the error message string for the error number Errno. If Errno is\n+   --  not known it returns \"Unknown system error\".\n \n    function Host_Errno return Integer;\n    pragma Import (C, Host_Errno, \"__gnat_get_h_errno\");\n@@ -73,14 +72,14 @@ package GNAT.Sockets.Thin is\n    No_Fd_Set : constant Fd_Set_Access := System.Null_Address;\n \n    type time_t is\n-     range -(2 ** (8 * Constants.SIZEOF_tv_sec - 1))\n-          .. 2 ** (8 * Constants.SIZEOF_tv_sec - 1) - 1;\n+     range -2 ** (8 * Constants.SIZEOF_tv_sec - 1)\n+         .. 2 ** (8 * Constants.SIZEOF_tv_sec - 1) - 1;\n    for time_t'Size use 8 * Constants.SIZEOF_tv_sec;\n    pragma Convention (C, time_t);\n \n    type suseconds_t is\n-     range -(2 ** (8 * Constants.SIZEOF_tv_usec - 1))\n-          .. 2 ** (8 * Constants.SIZEOF_tv_usec - 1) - 1;\n+     range -2 ** (8 * Constants.SIZEOF_tv_usec - 1)\n+         .. 2 ** (8 * Constants.SIZEOF_tv_usec - 1) - 1;\n    for suseconds_t'Size use 8 * Constants.SIZEOF_tv_usec;\n    pragma Convention (C, suseconds_t);\n \n@@ -104,7 +103,7 @@ package GNAT.Sockets.Thin is\n \n    package Chars_Ptr_Pointers is\n       new C.Pointers (C.size_t, C.Strings.chars_ptr, Chars_Ptr_Array,\n-                    C.Strings.Null_Ptr);\n+                      C.Strings.Null_Ptr);\n    --  Arrays of C (char *)\n \n    type In_Addr is record\n@@ -123,6 +122,7 @@ package GNAT.Sockets.Thin is\n    type In_Addr_Access_Array is array (C.size_t range <>)\n      of aliased In_Addr_Access;\n    pragma Convention (C, In_Addr_Access_Array);\n+\n    package In_Addr_Access_Pointers is\n      new C.Pointers (C.size_t, In_Addr_Access, In_Addr_Access_Array, null);\n    --  Array of internet addresses\n@@ -203,14 +203,24 @@ package GNAT.Sockets.Thin is\n    pragma Convention (C, Servent_Access);\n    --  Access to service entry\n \n-   type Two_Int is array (0 .. 1) of C.int;\n-   pragma Convention (C, Two_Int);\n-   --  Used with pipe()\n+   type Two_Ints is array (0 .. 1) of C.int;\n+   pragma Convention (C, Two_Ints);\n+   --  Container for two int values\n+\n+   subtype Fd_Pair is Two_Ints;\n+   --  Two_Ints as used for Create_Signalling_Fds: a pair of connected file\n+   --  descriptors, one of which (the \"read end\" of the connection) being used\n+   --  for reading, the other one (the \"write end\") being used for writing.\n+\n+   Read_End  : constant := 0;\n+   Write_End : constant := 1;\n+   --  Indices into an Fd_Pair value providing access to each of the connected\n+   --  file descriptors.\n \n    function C_Accept\n      (S       : C.int;\n       Addr    : System.Address;\n-      Addrlen : access C.int) return C.int;\n+      Addrlen : not null access C.int) return C.int;\n \n    function C_Bind\n      (S       : C.int;\n@@ -226,9 +236,9 @@ package GNAT.Sockets.Thin is\n       Namelen : C.int) return C.int;\n \n    function C_Gethostbyaddr\n-     (Addr     : System.Address;\n-      Length   : C.int;\n-      Typ      : C.int) return Hostent_Access;\n+     (Addr : System.Address;\n+      Len  : C.int;\n+      Typ  : C.int) return Hostent_Access;\n \n    function C_Gethostbyname\n      (Name : C.char_array) return Hostent_Access;\n@@ -240,7 +250,7 @@ package GNAT.Sockets.Thin is\n    function C_Getpeername\n      (S       : C.int;\n       Name    : System.Address;\n-      Namelen : access C.int) return C.int;\n+      Namelen : not null access C.int) return C.int;\n \n    function C_Getservbyname\n      (Name  : C.char_array;\n@@ -253,14 +263,14 @@ package GNAT.Sockets.Thin is\n    function C_Getsockname\n      (S       : C.int;\n       Name    : System.Address;\n-      Namelen : access C.int) return C.int;\n+      Namelen : not null access C.int) return C.int;\n \n    function C_Getsockopt\n      (S       : C.int;\n       Level   : C.int;\n       Optname : C.int;\n       Optval  : System.Address;\n-      Optlen  : access C.int) return C.int;\n+      Optlen  : not null access C.int) return C.int;\n \n    function C_Inet_Addr\n      (Cp : C.Strings.chars_ptr) return C.int;\n@@ -275,23 +285,23 @@ package GNAT.Sockets.Thin is\n       Backlog : C.int) return C.int;\n \n    function C_Readv\n-     (Socket : C.int;\n+     (Fd     : C.int;\n       Iov    : System.Address;\n       Iovcnt : C.int) return C.int;\n \n    function C_Recv\n      (S     : C.int;\n-      Buf   : System.Address;\n+      Msg   : System.Address;\n       Len   : C.int;\n       Flags : C.int) return C.int;\n \n    function C_Recvfrom\n      (S       : C.int;\n-      Buf     : System.Address;\n+      Msg     : System.Address;\n       Len     : C.int;\n       Flags   : C.int;\n       From    : Sockaddr_In_Access;\n-      Fromlen : access C.int) return C.int;\n+      Fromlen : not null access C.int) return C.int;\n \n    function C_Select\n      (Nfds      : C.int;\n@@ -302,7 +312,7 @@ package GNAT.Sockets.Thin is\n \n    function C_Send\n      (S     : C.int;\n-      Buf   : System.Address;\n+      Msg   : System.Address;\n       Len   : C.int;\n       Flags : C.int) return C.int;\n \n@@ -322,8 +332,8 @@ package GNAT.Sockets.Thin is\n       Optlen  : C.int) return C.int;\n \n    function C_Shutdown\n-     (S    : C.int;\n-      How  : C.int) return C.int;\n+     (S   : C.int;\n+      How : C.int) return C.int;\n \n    function C_Socket\n      (Domain   : C.int;\n@@ -337,14 +347,33 @@ package GNAT.Sockets.Thin is\n      (Command : System.Address) return C.int;\n \n    function C_Writev\n-     (Socket : C.int;\n+     (Fd     : C.int;\n       Iov    : System.Address;\n       Iovcnt : C.int) return C.int;\n \n    function WSAStartup\n      (WS_Version     : Interfaces.C.int;\n       WSADataAddress : System.Address) return Interfaces.C.int;\n \n+   package Signalling_Fds is\n+\n+      function Create (Fds : not null access Fd_Pair) return C.int;\n+      pragma Convention (C, Create);\n+      --  Create a pair of connected descriptors suitable for use with C_Select\n+      --  (used for signalling in Selector objects).\n+\n+      function Read (Rsig : C.int) return C.int;\n+      pragma Convention (C, Read);\n+      --  Read one byte of data from rsig, the read end of a pair of signalling\n+      --  fds created by Create_Signalling_Fds.\n+\n+      function Write (Wsig : C.int) return C.int;\n+      pragma Convention (C, Write);\n+      --  Write one byte of data to wsig, the write end of a pair of signalling\n+      --  fds created by Create_Signalling_Fds.\n+\n+   end Signalling_Fds;\n+\n    procedure Free_Socket_Set\n      (Set : Fd_Set_Access);\n    --  Free system-dependent socket set\n@@ -371,19 +400,19 @@ package GNAT.Sockets.Thin is\n    --  value if it is, zero if it is not.\n \n    procedure Last_Socket_In_Set\n-     (Set  : Fd_Set_Access;\n-      Last : Int_Access);\n-   --  Find the largest socket in the socket set. This is needed for\n-   --  select(). When Last_Socket_In_Set is called, parameter Last is\n-   --  a maximum value of the largest socket. This hint is used to\n-   --  avoid scanning very large socket sets. After the call, Last is\n-   --  set back to the real largest socket in the socket set.\n+     (Set    : Fd_Set_Access;\n+      Last   : Int_Access);\n+   --  Find the largest socket in the socket set. This is needed for select().\n+   --  When Last_Socket_In_Set is called, parameter Last is a maximum value of\n+   --  the largest socket. This hint is used to avoid scanning very large\n+   --  socket sets. After the call, Last is set back to the real largest socket\n+   --  in the socket set.\n \n    function  New_Socket_Set\n      (Set : Fd_Set_Access) return Fd_Set_Access;\n-   --  Allocate a new socket set which is a system-dependent structure\n-   --  and initialize by copying Set if it is non-null, by making it\n-   --  empty otherwise.\n+   --  Allocate a new socket set which is a system-dependent structure and\n+   --  initialize by copying Set if it is non-null, by making it empty\n+   --  otherwise.\n \n    procedure Remove_Socket_From_Set\n      (Set    : Fd_Set_Access;\n@@ -393,7 +422,7 @@ package GNAT.Sockets.Thin is\n    procedure WSACleanup;\n \n    procedure Finalize;\n-   procedure Initialize (Process_Blocking_IO : Boolean := False);\n+   procedure Initialize (Process_Blocking_IO : Boolean);\n \n private\n    pragma Import (Stdcall, C_Accept, \"accept\");\n@@ -430,4 +459,5 @@ private\n    pragma Import (C, New_Socket_Set, \"__gnat_new_socket_set\");\n    pragma Import (C, Insert_Socket_In_Set, \"__gnat_insert_socket_in_set\");\n    pragma Import (C, Remove_Socket_From_Set, \"__gnat_remove_socket_from_set\");\n+\n end GNAT.Sockets.Thin;"}, {"sha": "0ede7e7973d7ec41c31f0451a6d94b676f8808ea", "filename": "gcc/ada/g-socthi-vms.adb", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-vms.adb?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2005, AdaCore                     --\n+--                     Copyright (C) 2001-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -64,7 +64,7 @@ package body GNAT.Sockets.Thin is\n    function Syscall_Accept\n      (S       : C.int;\n       Addr    : System.Address;\n-      Addrlen : access C.int) return C.int;\n+      Addrlen : not null access C.int) return C.int;\n    pragma Import (C, Syscall_Accept, \"accept\");\n \n    function Syscall_Connect\n@@ -92,7 +92,7 @@ package body GNAT.Sockets.Thin is\n       Len     : C.int;\n       Flags   : C.int;\n       From    : Sockaddr_In_Access;\n-      Fromlen : access C.int) return C.int;\n+      Fromlen : not null access C.int) return C.int;\n    pragma Import (C, Syscall_Recvfrom, \"recvfrom\");\n \n    function Syscall_Send\n@@ -125,7 +125,7 @@ package body GNAT.Sockets.Thin is\n    function C_Accept\n      (S       : C.int;\n       Addr    : System.Address;\n-      Addrlen : access C.int) return C.int\n+      Addrlen : not null access C.int) return C.int\n    is\n       R   : C.int;\n       Val : aliased C.int := 1;\n@@ -275,7 +275,7 @@ package body GNAT.Sockets.Thin is\n       Len     : C.int;\n       Flags   : C.int;\n       From    : Sockaddr_In_Access;\n-      Fromlen : access C.int) return C.int\n+      Fromlen : not null access C.int) return C.int\n    is\n       Res : C.int;\n \n@@ -461,6 +461,12 @@ package body GNAT.Sockets.Thin is\n       Sin.Sin_Port   := Port;\n    end Set_Port;\n \n+   --------------------\n+   -- Signalling_Fds --\n+   --------------------\n+\n+   package body Signalling_Fds is separate;\n+\n    --------------------------\n    -- Socket_Error_Message --\n    --------------------------"}, {"sha": "c1bd11643710b8cb49cc8d23208c3652852ac216", "filename": "gcc/ada/g-socthi-vms.ads", "status": "modified", "additions": 61, "deletions": 26, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-vms.ads?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2002-2005, AdaCore                     --\n+--                     Copyright (C) 2002-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,8 +38,8 @@\n --  This is the Alpha/VMS version\n \n with Interfaces.C.Pointers;\n-\n with Interfaces.C.Strings;\n+\n with GNAT.Sockets.Constants;\n with GNAT.OS_Lib;\n \n@@ -60,9 +60,12 @@ package GNAT.Sockets.Thin is\n    function Socket_Errno return Integer renames GNAT.OS_Lib.Errno;\n    --  Returns last socket error number\n \n+   procedure Set_Socket_Errno (Errno : Integer) renames GNAT.OS_Lib.Set_Errno;\n+   --  Set last socket error number\n+\n    function Socket_Error_Message (Errno : Integer) return C.Strings.chars_ptr;\n-   --  Returns the error message string for the error number Errno. If\n-   --  Errno is not known it returns \"Unknown system error\".\n+   --  Returns the error message string for the error number Errno. If Errno is\n+   --  not known it returns \"Unknown system error\".\n \n    function Host_Errno return Integer;\n    pragma Import (C, Host_Errno, \"__gnat_get_h_errno\");\n@@ -165,8 +168,8 @@ package GNAT.Sockets.Thin is\n    --  Set Sin.Sin_Family to Family\n \n    procedure Set_Port\n-     (Sin     : Sockaddr_In_Access;\n-      Port    : C.unsigned_short);\n+     (Sin  : Sockaddr_In_Access;\n+      Port : C.unsigned_short);\n    pragma Inline (Set_Port);\n    --  Set Sin.Sin_Port to Port\n \n@@ -203,14 +206,24 @@ package GNAT.Sockets.Thin is\n    pragma Convention (C, Servent_Access);\n    --  Access to service entry\n \n-   type Two_Int is array (0 .. 1) of C.int;\n-   pragma Convention (C, Two_Int);\n-   --  Used with pipe()\n+   type Two_Ints is array (0 .. 1) of C.int;\n+   pragma Convention (C, Two_Ints);\n+   --  Container for two int values\n+\n+   subtype Fd_Pair is Two_Ints;\n+   --  Two_Ints as used for Create_Signalling_Fds: a pair of connected file\n+   --  descriptors, one of which (the \"read end\" of the connection) being used\n+   --  for reading, the other one (the \"write end\") being used for writing.\n+\n+   Read_End  : constant := 0;\n+   Write_End : constant := 1;\n+   --  Indices into an Fd_Pair value providing access to each of the connected\n+   --  file descriptors.\n \n    function C_Accept\n      (S       : C.int;\n       Addr    : System.Address;\n-      Addrlen : access C.int) return C.int;\n+      Addrlen : not null access C.int) return C.int;\n \n    function C_Bind\n      (S       : C.int;\n@@ -240,7 +253,7 @@ package GNAT.Sockets.Thin is\n    function C_Getpeername\n      (S       : C.int;\n       Name    : System.Address;\n-      Namelen : access C.int) return C.int;\n+      Namelen : not null access C.int) return C.int;\n \n    function C_Getservbyname\n      (Name  : C.char_array;\n@@ -253,24 +266,26 @@ package GNAT.Sockets.Thin is\n    function C_Getsockname\n      (S       : C.int;\n       Name    : System.Address;\n-      Namelen : access C.int) return C.int;\n+      Namelen : not null access C.int) return C.int;\n \n    function C_Getsockopt\n      (S       : C.int;\n       Level   : C.int;\n       Optname : C.int;\n       Optval  : System.Address;\n-      Optlen  : access C.int) return C.int;\n+      Optlen  : not null access C.int) return C.int;\n \n    function C_Inet_Addr\n-     (Cp   : C.Strings.chars_ptr) return C.int;\n+     (Cp : C.Strings.chars_ptr) return C.int;\n \n    function C_Ioctl\n      (S    : C.int;\n       Req  : C.int;\n       Arg  : Int_Access) return C.int;\n \n-   function C_Listen (S, Backlog : C.int) return C.int;\n+   function C_Listen\n+     (S       : C.int;\n+      Backlog : C.int) return C.int;\n \n    function C_Readv\n      (Fd     : C.int;\n@@ -289,7 +304,7 @@ package GNAT.Sockets.Thin is\n       Len     : C.int;\n       Flags   : C.int;\n       From    : Sockaddr_In_Access;\n-      Fromlen : access C.int) return C.int;\n+      Fromlen : not null access C.int) return C.int;\n \n    function C_Select\n      (Nfds      : C.int;\n@@ -320,8 +335,8 @@ package GNAT.Sockets.Thin is\n       Optlen  : C.int) return C.int;\n \n    function C_Shutdown\n-     (S    : C.int;\n-      How  : C.int) return C.int;\n+     (S   : C.int;\n+      How : C.int) return C.int;\n \n    function C_Socket\n      (Domain   : C.int;\n@@ -339,6 +354,25 @@ package GNAT.Sockets.Thin is\n       Iov    : System.Address;\n       Iovcnt : C.int) return C.int;\n \n+   package Signalling_Fds is\n+\n+      function Create (Fds : not null access Fd_Pair) return C.int;\n+      pragma Convention (C, Create);\n+      --  Create a pair of connected descriptors suitable for use with C_Select\n+      --  (used for signalling in Selector objects).\n+\n+      function Read (Rsig : C.int) return C.int;\n+      pragma Convention (C, Read);\n+      --  Read one byte of data from rsig, the read end of a pair of signalling\n+      --  fds created by Create_Signalling_Fds.\n+\n+      function Write (Wsig : C.int) return C.int;\n+      pragma Convention (C, Write);\n+      --  Write one byte of data to wsig, the write end of a pair of signalling\n+      --  fds created by Create_Signalling_Fds.\n+\n+   end Signalling_Fds;\n+\n    procedure Free_Socket_Set\n      (Set : Fd_Set_Access);\n    --  Free system-dependent socket set\n@@ -367,17 +401,17 @@ package GNAT.Sockets.Thin is\n    procedure Last_Socket_In_Set\n      (Set    : Fd_Set_Access;\n       Last   : Int_Access);\n-   --  Find the largest socket in the socket set. This is needed for\n-   --  select(). When Last_Socket_In_Set is called, parameter Last is\n-   --  a maximum value of the largest socket. This hint is used to\n-   --  avoid scanning very large socket sets. After the call, Last is\n-   --  set back to the real largest socket in the socket set.\n+   --  Find the largest socket in the socket set. This is needed for select().\n+   --  When Last_Socket_In_Set is called, parameter Last is a maximum value of\n+   --  the largest socket. This hint is used to avoid scanning very large\n+   --  socket sets. After the call, Last is set back to the real largest socket\n+   --  in the socket set.\n \n    function  New_Socket_Set\n      (Set : Fd_Set_Access) return Fd_Set_Access;\n-   --  Allocate a new socket set which is a system-dependent structure\n-   --  and initialize by copying Set if it is non-null, by making it\n-   --  empty otherwise.\n+   --  Allocate a new socket set which is a system-dependent structure and\n+   --  initialize by copying Set if it is non-null, by making it empty\n+   --  otherwise.\n \n    procedure Remove_Socket_From_Set\n      (Set    : Fd_Set_Access;\n@@ -414,4 +448,5 @@ private\n    pragma Import (C, New_Socket_Set, \"__gnat_new_socket_set\");\n    pragma Import (C, Insert_Socket_In_Set, \"__gnat_insert_socket_in_set\");\n    pragma Import (C, Remove_Socket_From_Set, \"__gnat_remove_socket_from_set\");\n+\n end GNAT.Sockets.Thin;"}, {"sha": "e0539a9d12bbb4779e9996672322298c182d067e", "filename": "gcc/ada/g-socthi-vxworks.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-vxworks.adb?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -92,7 +92,7 @@ package body GNAT.Sockets.Thin is\n    function Syscall_Accept\n      (S       : C.int;\n       Addr    : System.Address;\n-      Addrlen : access C.int) return C.int;\n+      Addrlen : not null access C.int) return C.int;\n    pragma Import (C, Syscall_Accept, \"accept\");\n \n    function Syscall_Connect\n@@ -120,7 +120,7 @@ package body GNAT.Sockets.Thin is\n       Len     : C.int;\n       Flags   : C.int;\n       From    : Sockaddr_In_Access;\n-      Fromlen : access C.int) return C.int;\n+      Fromlen : not null access C.int) return C.int;\n    pragma Import (C, Syscall_Recvfrom, \"recvfrom\");\n \n    function Syscall_Send\n@@ -155,7 +155,7 @@ package body GNAT.Sockets.Thin is\n    function C_Accept\n      (S       : C.int;\n       Addr    : System.Address;\n-      Addrlen : access C.int) return C.int\n+      Addrlen : not null access C.int) return C.int\n    is\n       R   : C.int;\n       Val : aliased C.int := 1;\n@@ -398,7 +398,7 @@ package body GNAT.Sockets.Thin is\n       Len     : C.int;\n       Flags   : C.int;\n       From    : Sockaddr_In_Access;\n-      Fromlen : access C.int) return C.int\n+      Fromlen : not null access C.int) return C.int\n    is\n       Res : C.int;\n \n@@ -594,6 +594,12 @@ package body GNAT.Sockets.Thin is\n       Sin.Sin_Port   := Port;\n    end Set_Port;\n \n+   --------------------\n+   -- Signalling_Fds --\n+   --------------------\n+\n+   package body Signalling_Fds is separate;\n+\n    --------------------------\n    -- Socket_Error_Message --\n    --------------------------"}, {"sha": "6e598b7dbc632c206ec95b5aa0c0604d37ae0e07", "filename": "gcc/ada/g-socthi-vxworks.ads", "status": "modified", "additions": 67, "deletions": 33, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-vxworks.ads?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2002-2005, AdaCore                     --\n+--                     Copyright (C) 2002-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,9 +38,10 @@\n --  This is the version for VxWorks\n \n with Interfaces.C.Pointers;\n+with Interfaces.C.Strings;\n \n with Ada.Unchecked_Conversion;\n-with Interfaces.C.Strings;\n+\n with GNAT.Sockets.Constants;\n with GNAT.OS_Lib;\n \n@@ -59,6 +60,9 @@ package GNAT.Sockets.Thin is\n    function Socket_Errno return Integer renames GNAT.OS_Lib.Errno;\n    --  Returns last socket error number\n \n+   procedure Set_Socket_Errno (Errno : Integer) renames GNAT.OS_Lib.Set_Errno;\n+   --  Set last socket error number\n+\n    function Socket_Error_Message (Errno : Integer) return C.Strings.chars_ptr;\n    --  Returns the error message string for the error number Errno. If Errno is\n    --  not known it returns \"Unknown system error\".\n@@ -161,20 +165,20 @@ package GNAT.Sockets.Thin is\n    --  Set Sin.Sin_Length to Len\n \n    procedure Set_Family\n-     (Sin     : Sockaddr_In_Access;\n-      Family  : C.int);\n+     (Sin    : Sockaddr_In_Access;\n+      Family : C.int);\n    pragma Inline (Set_Family);\n    --  Set Sin.Sin_Family to Family\n \n    procedure Set_Port\n-     (Sin     : Sockaddr_In_Access;\n-      Port    : C.unsigned_short);\n+     (Sin  : Sockaddr_In_Access;\n+      Port : C.unsigned_short);\n    pragma Inline (Set_Port);\n    --  Set Sin.Sin_Port to Port\n \n    procedure Set_Address\n-     (Sin        : Sockaddr_In_Access;\n-      Address    : In_Addr);\n+     (Sin     : Sockaddr_In_Access;\n+      Address : In_Addr);\n    pragma Inline (Set_Address);\n    --  Set Sin.Sin_Addr to Address\n \n@@ -193,10 +197,10 @@ package GNAT.Sockets.Thin is\n    --  Access to host entry\n \n    type Servent is record\n-      S_Name      : C.Strings.chars_ptr;\n-      S_Aliases   : Chars_Ptr_Pointers.Pointer;\n-      S_Port      : C.int;\n-      S_Proto     : C.Strings.chars_ptr;\n+      S_Name    : C.Strings.chars_ptr;\n+      S_Aliases : Chars_Ptr_Pointers.Pointer;\n+      S_Port    : C.int;\n+      S_Proto   : C.Strings.chars_ptr;\n    end record;\n    pragma Convention (C, Servent);\n    --  Service entry\n@@ -205,14 +209,24 @@ package GNAT.Sockets.Thin is\n    pragma Convention (C, Servent_Access);\n    --  Access to service entry\n \n-   type Two_Int is array (0 .. 1) of C.int;\n-   pragma Convention (C, Two_Int);\n-   --  Used with pipe()\n+   type Two_Ints is array (0 .. 1) of C.int;\n+   pragma Convention (C, Two_Ints);\n+   --  Container for two int values\n+\n+   subtype Fd_Pair is Two_Ints;\n+   --  Two_Ints as used for Create_Signalling_Fds: a pair of connected file\n+   --  descriptors, one of which (the \"read end\" of the connection) being used\n+   --  for reading, the other one (the \"write end\") being used for writing.\n+\n+   Read_End  : constant := 0;\n+   Write_End : constant := 1;\n+   --  Indices into an Fd_Pair value providing access to each of the connected\n+   --  file descriptors.\n \n    function C_Accept\n      (S       : C.int;\n       Addr    : System.Address;\n-      Addrlen : access C.int) return C.int;\n+      Addrlen : not null access C.int) return C.int;\n \n    function C_Bind\n      (S       : C.int;\n@@ -242,7 +256,7 @@ package GNAT.Sockets.Thin is\n    function C_Getpeername\n      (S       : C.int;\n       Name    : System.Address;\n-      Namelen : access C.int) return C.int;\n+      Namelen : not null access C.int) return C.int;\n \n    function C_Getservbyname\n      (Name  : C.char_array;\n@@ -255,24 +269,26 @@ package GNAT.Sockets.Thin is\n    function C_Getsockname\n      (S       : C.int;\n       Name    : System.Address;\n-      Namelen : access C.int) return C.int;\n+      Namelen : not null access C.int) return C.int;\n \n    function C_Getsockopt\n      (S       : C.int;\n       Level   : C.int;\n       Optname : C.int;\n       Optval  : System.Address;\n-      Optlen  : access C.int) return C.int;\n+      Optlen  : not null access C.int) return C.int;\n \n    function C_Inet_Addr\n      (Cp : C.Strings.chars_ptr) return C.int;\n \n    function C_Ioctl\n-     (S   : C.int;\n-      Req : C.int;\n-      Arg : Int_Access) return C.int;\n+     (S    : C.int;\n+      Req  : C.int;\n+      Arg  : Int_Access) return C.int;\n \n-   function C_Listen (S, Backlog : C.int) return C.int;\n+   function C_Listen\n+     (S       : C.int;\n+      Backlog : C.int) return C.int;\n \n    function C_Readv\n      (Fd     : C.int;\n@@ -291,7 +307,7 @@ package GNAT.Sockets.Thin is\n       Len     : C.int;\n       Flags   : C.int;\n       From    : Sockaddr_In_Access;\n-      Fromlen : access C.int) return C.int;\n+      Fromlen : not null access C.int) return C.int;\n \n    function C_Select\n      (Nfds      : C.int;\n@@ -341,6 +357,25 @@ package GNAT.Sockets.Thin is\n       Iov    : System.Address;\n       Iovcnt : C.int) return C.int;\n \n+   package Signalling_Fds is\n+\n+      function Create (Fds : not null access Fd_Pair) return C.int;\n+      pragma Convention (C, Create);\n+      --  Create a pair of connected descriptors suitable for use with C_Select\n+      --  (used for signalling in Selector objects).\n+\n+      function Read (Rsig : C.int) return C.int;\n+      pragma Convention (C, Read);\n+      --  Read one byte of data from rsig, the read end of a pair of signalling\n+      --  fds created by Create_Signalling_Fds.\n+\n+      function Write (Wsig : C.int) return C.int;\n+      pragma Convention (C, Write);\n+      --  Write one byte of data to wsig, the write end of a pair of signalling\n+      --  fds created by Create_Signalling_Fds.\n+\n+   end Signalling_Fds;\n+\n    procedure Free_Socket_Set\n      (Set : Fd_Set_Access);\n    --  Free system-dependent socket set\n@@ -369,17 +404,17 @@ package GNAT.Sockets.Thin is\n    procedure Last_Socket_In_Set\n      (Set    : Fd_Set_Access;\n       Last   : Int_Access);\n-   --  Find the largest socket in the socket set. This is needed for\n-   --  select(). When Last_Socket_In_Set is called, parameter Last is\n-   --  a maximum value of the largest socket. This hint is used to\n-   --  avoid scanning very large socket sets. After the call, Last is\n-   --  set back to the real largest socket in the socket set.\n+   --  Find the largest socket in the socket set. This is needed for select().\n+   --  When Last_Socket_In_Set is called, parameter Last is a maximum value of\n+   --  the largest socket. This hint is used to avoid scanning very large\n+   --  socket sets. After the call, Last is set back to the real largest socket\n+   --  in the socket set.\n \n    function  New_Socket_Set\n      (Set : Fd_Set_Access) return Fd_Set_Access;\n-   --  Allocate a new socket set which is a system-dependent structure\n-   --  and initialize by copying Set if it is non-null, by making it\n-   --  empty otherwise.\n+   --  Allocate a new socket set which is a system-dependent structure and\n+   --  initialize by copying Set if it is non-null, by making it empty\n+   --  otherwise.\n \n    procedure Remove_Socket_From_Set\n      (Set    : Fd_Set_Access;\n@@ -390,7 +425,6 @@ package GNAT.Sockets.Thin is\n    procedure Initialize (Process_Blocking_IO : Boolean);\n \n private\n-\n    pragma Import (C, C_Bind, \"bind\");\n    pragma Import (C, C_Close, \"close\");\n    pragma Import (C, C_Gethostname, \"gethostname\");"}, {"sha": "7ca1c1cdfdf23158f9e003fb792b0adb9f16d5f0", "filename": "gcc/ada/g-socthi.adb", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi.adb?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2005, AdaCore                     --\n+--                     Copyright (C) 2001-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -71,7 +71,7 @@ package body GNAT.Sockets.Thin is\n    function Syscall_Accept\n      (S       : C.int;\n       Addr    : System.Address;\n-      Addrlen : access C.int) return C.int;\n+      Addrlen : not null access C.int) return C.int;\n    pragma Import (C, Syscall_Accept, \"accept\");\n \n    function Syscall_Connect\n@@ -99,7 +99,7 @@ package body GNAT.Sockets.Thin is\n       Len     : C.int;\n       Flags   : C.int;\n       From    : Sockaddr_In_Access;\n-      Fromlen : access C.int) return C.int;\n+      Fromlen : not null access C.int) return C.int;\n    pragma Import (C, Syscall_Recvfrom, \"recvfrom\");\n \n    function Syscall_Send\n@@ -127,6 +127,11 @@ package body GNAT.Sockets.Thin is\n    procedure Disable_SIGPIPE (S : C.int);\n    pragma Import (C, Disable_SIGPIPE, \"__gnat_disable_sigpipe\");\n \n+   procedure Disable_All_SIGPIPEs;\n+   pragma Import (C, Disable_All_SIGPIPEs, \"__gnat_disable_all_sigpipes\");\n+   --  Sets the process to ignore all SIGPIPE signals on platforms that\n+   --  don't support Disable_SIGPIPE for particular streams.\n+\n    function Non_Blocking_Socket (S : C.int) return Boolean;\n    procedure Set_Non_Blocking_Socket (S : C.int; V : Boolean);\n \n@@ -137,7 +142,7 @@ package body GNAT.Sockets.Thin is\n    function C_Accept\n      (S       : C.int;\n       Addr    : System.Address;\n-      Addrlen : access C.int) return C.int\n+      Addrlen : not null access C.int) return C.int\n    is\n       R   : C.int;\n       Val : aliased C.int := 1;\n@@ -288,7 +293,7 @@ package body GNAT.Sockets.Thin is\n       Len     : C.int;\n       Flags   : C.int;\n       From    : Sockaddr_In_Access;\n-      Fromlen : access C.int) return C.int\n+      Fromlen : not null access C.int) return C.int\n    is\n       Res : C.int;\n \n@@ -404,6 +409,7 @@ package body GNAT.Sockets.Thin is\n    procedure Initialize (Process_Blocking_IO : Boolean) is\n    begin\n       Thread_Blocking_IO := not Process_Blocking_IO;\n+      Disable_All_SIGPIPEs;\n    end Initialize;\n \n    -------------------------\n@@ -487,6 +493,32 @@ package body GNAT.Sockets.Thin is\n       Sin.Sin_Port   := Port;\n    end Set_Port;\n \n+   --------------------\n+   -- Signalling_Fds --\n+   --------------------\n+\n+   package body Signalling_Fds is\n+\n+      --  In this default implementation, we use a C version of these\n+      --  subprograms provided by socket.c.\n+\n+      function C_Create (Fds : not null access Fd_Pair) return C.int;\n+      function C_Read (Rsig : C.int) return C.int;\n+      function C_Write (Wsig : C.int) return C.int;\n+\n+      pragma Import (C, C_Create, \"__gnat_create_signalling_fds\");\n+      pragma Import (C, C_Read,   \"__gnat_read_signalling_fd\");\n+      pragma Import (C, C_Write,  \"__gnat_write_signalling_fd\");\n+\n+      function Create (Fds : not null access Fd_Pair) return C.int\n+        renames C_Create;\n+\n+      function Read (Rsig : C.int) return C.int renames C_Read;\n+\n+      function Write (Wsig : C.int) return C.int renames C_Write;\n+\n+   end Signalling_Fds;\n+\n    --------------------------\n    -- Socket_Error_Message --\n    --------------------------"}, {"sha": "ce3f7586f1bf3101ce4c17407f5f38d4abe85c60", "filename": "gcc/ada/g-socthi.ads", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-socthi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi.ads?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2005, AdaCore                     --\n+--                     Copyright (C) 2001-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,6 +39,7 @@\n \n with Interfaces.C.Pointers;\n with Interfaces.C.Strings;\n+\n with GNAT.Sockets.Constants;\n with GNAT.OS_Lib;\n \n@@ -204,14 +205,24 @@ package GNAT.Sockets.Thin is\n    pragma Convention (C, Servent_Access);\n    --  Access to service entry\n \n-   type Two_Int is array (0 .. 1) of C.int;\n-   pragma Convention (C, Two_Int);\n-   --  Used with pipe()\n+   type Two_Ints is array (0 .. 1) of C.int;\n+   pragma Convention (C, Two_Ints);\n+   --  Container for two int values\n+\n+   subtype Fd_Pair is Two_Ints;\n+   --  Two_Ints as used for Create_Signalling_Fds: a pair of connected file\n+   --  descriptors, one of which (the \"read end\" of the connection) being used\n+   --  for reading, the other one (the \"write end\") being used for writing.\n+\n+   Read_End  : constant := 0;\n+   Write_End : constant := 1;\n+   --  Indices into an Fd_Pair value providing access to each of the connected\n+   --  file descriptors.\n \n    function C_Accept\n      (S       : C.int;\n       Addr    : System.Address;\n-      Addrlen : access C.int) return C.int;\n+      Addrlen : not null access C.int) return C.int;\n \n    function C_Bind\n      (S       : C.int;\n@@ -241,7 +252,7 @@ package GNAT.Sockets.Thin is\n    function C_Getpeername\n      (S       : C.int;\n       Name    : System.Address;\n-      Namelen : access C.int) return C.int;\n+      Namelen : not null access C.int) return C.int;\n \n    function C_Getservbyname\n      (Name  : C.char_array;\n@@ -254,14 +265,14 @@ package GNAT.Sockets.Thin is\n    function C_Getsockname\n      (S       : C.int;\n       Name    : System.Address;\n-      Namelen : access C.int) return C.int;\n+      Namelen : not null access C.int) return C.int;\n \n    function C_Getsockopt\n      (S       : C.int;\n       Level   : C.int;\n       Optname : C.int;\n       Optval  : System.Address;\n-      Optlen  : access C.int) return C.int;\n+      Optlen  : not null access C.int) return C.int;\n \n    function C_Inet_Addr\n      (Cp : C.Strings.chars_ptr) return C.int;\n@@ -292,7 +303,7 @@ package GNAT.Sockets.Thin is\n       Len     : C.int;\n       Flags   : C.int;\n       From    : Sockaddr_In_Access;\n-      Fromlen : access C.int) return C.int;\n+      Fromlen : not null access C.int) return C.int;\n \n    function C_Select\n      (Nfds      : C.int;\n@@ -342,6 +353,25 @@ package GNAT.Sockets.Thin is\n       Iov    : System.Address;\n       Iovcnt : C.int) return C.int;\n \n+   package Signalling_Fds is\n+\n+      function Create (Fds : not null access Fd_Pair) return C.int;\n+      pragma Convention (C, Create);\n+      --  Create a pair of connected descriptors suitable for use with C_Select\n+      --  (used for signalling in Selector objects).\n+\n+      function Read (Rsig : C.int) return C.int;\n+      pragma Convention (C, Read);\n+      --  Read one byte of data from rsig, the read end of a pair of signalling\n+      --  fds created by Create_Signalling_Fds.\n+\n+      function Write (Wsig : C.int) return C.int;\n+      pragma Convention (C, Write);\n+      --  Write one byte of data to wsig, the write end of a pair of signalling\n+      --  fds created by Create_Signalling_Fds.\n+\n+   end Signalling_Fds;\n+\n    procedure Free_Socket_Set\n      (Set : Fd_Set_Access);\n    --  Free system-dependent socket set\n@@ -418,4 +448,5 @@ private\n    pragma Import (C, New_Socket_Set, \"__gnat_new_socket_set\");\n    pragma Import (C, Insert_Socket_In_Set, \"__gnat_insert_socket_in_set\");\n    pragma Import (C, Remove_Socket_From_Set, \"__gnat_remove_socket_from_set\");\n+\n end GNAT.Sockets.Thin;"}, {"sha": "039d3754c04bfbd930d230cc2ce6956172bbabfb", "filename": "gcc/ada/g-soliop-mingw.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-soliop-mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-soliop-mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-soliop-mingw.ads?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2005, AdaCore                     --\n+--                     Copyright (C) 2001-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,5 +38,5 @@\n \n package GNAT.Sockets.Linker_Options is\n private\n-   pragma Linker_Options (\"-lwsock32\");\n+   pragma Linker_Options (\"-lws2_32\");\n end GNAT.Sockets.Linker_Options;"}, {"sha": "eb480b9032839636692cc52a59030f2972cd94a9", "filename": "gcc/ada/g-stsifd-sockets.adb", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-stsifd-sockets.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fg-stsifd-sockets.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-stsifd-sockets.adb?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -0,0 +1,191 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--     G N A T . S O C K E T S . T H I N . S I G N A L L I N G _ F D S      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2001-2006, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Portable sockets-based implementation of GNAT.Sockets.Thin.Signalling_Fds\n+--  used for platforms that do not support UNIX pipes.\n+\n+--  Note: this code used to be in GNAT.Sockets, but has been moved to a\n+--  platform-specific file. It is now used only for non-UNIX platforms.\n+\n+separate\n+  (GNAT.Sockets.Thin)\n+package body Signalling_Fds is\n+\n+   ------------\n+   -- Create --\n+   ------------\n+\n+   function Create (Fds : not null access Fd_Pair) return C.int is\n+      L_Sock, R_Sock, W_Sock : C.int := Failure;\n+      --  Listening socket, read socket and write socket\n+\n+      Sin : aliased Sockaddr_In;\n+      Len : aliased C.int := Sin'Size / 8;\n+      --  Address of listening socket\n+\n+      Res : C.int;\n+      --  Return status of system calls\n+\n+      Err : Integer;\n+      --  Saved errno value\n+\n+   begin\n+      Fds (Read_End)  := Failure;\n+      Fds (Write_End) := Failure;\n+\n+      --  We open two signalling sockets. One of them is used to send data\n+      --  to the other, which is included in a C_Select socket set. The\n+      --  communication is used to force the call to C_Select to complete,\n+      --  and the waiting task to resume its execution.\n+\n+      --  Create a listening socket\n+\n+      L_Sock := C_Socket (Constants.AF_INET, Constants.SOCK_STREAM, 0);\n+\n+      if L_Sock = Failure then\n+         goto Fail;\n+      end if;\n+\n+      --  Bind the socket to an available port on localhost\n+\n+      Sin.Sin_Addr.S_B1 := 127;\n+      Sin.Sin_Addr.S_B2 := 0;\n+      Sin.Sin_Addr.S_B3 := 0;\n+      Sin.Sin_Addr.S_B4 := 1;\n+      Sin.Sin_Port := 0;\n+\n+      Res := C_Bind (L_Sock, Sin'Address, Len);\n+\n+      if Res = Failure then\n+         goto Fail;\n+      end if;\n+\n+      --  Get assigned port\n+\n+      Res := C_Getsockname (L_Sock, Sin'Address, Len'Access);\n+      if Res = Failure then\n+         goto Fail;\n+      end if;\n+\n+      --  Set socket to listen mode, with a backlog of 1 to guarantee that\n+      --  exactly one call to connect(2) succeeds.\n+\n+      Res := C_Listen (L_Sock, 1);\n+\n+      if Res = Failure then\n+         goto Fail;\n+      end if;\n+\n+      --  Create read end (client) socket\n+\n+      R_Sock := C_Socket (Constants.AF_INET, Constants.SOCK_STREAM, 0);\n+\n+      if R_Sock = Failure then\n+         goto Fail;\n+      end if;\n+\n+      --  Connect listening socket\n+\n+      Res := C_Connect (R_Sock, Sin'Address, Len);\n+\n+      if Res = Failure then\n+         goto Fail;\n+      end if;\n+\n+      --  Since the call to connect(2) has suceeded and the backlog limit on\n+      --  the listening socket is 1, we know that there is now exactly one\n+      --  pending connection on L_Sock, which is the one from R_Sock.\n+\n+      W_Sock := C_Accept (L_Sock, Sin'Address, Len'Access);\n+      if W_Sock = Failure then\n+         goto Fail;\n+      end if;\n+\n+      --  Set TCP_NODELAY on W_Sock, since we always want to send the data out\n+      --  immediately.\n+\n+      Set_Socket_Option\n+        (Socket => Socket_Type (W_Sock),\n+         Level  => IP_Protocol_For_TCP_Level,\n+         Option => (Name => No_Delay, Enabled => True));\n+\n+      --  Close listening socket (ignore exit status)\n+\n+      Res := C_Close (L_Sock);\n+\n+      Fds (Read_End)  := R_Sock;\n+      Fds (Write_End) := W_Sock;\n+\n+      return Success;\n+\n+   <<Fail>>\n+      Err := Socket_Errno;\n+\n+      if W_Sock /= Failure then\n+         Res := C_Close (W_Sock);\n+      end if;\n+\n+      if R_Sock /= Failure then\n+         Res := C_Close (R_Sock);\n+      end if;\n+\n+      if L_Sock /= Failure then\n+         Res := C_Close (L_Sock);\n+      end if;\n+\n+      Set_Socket_Errno (Err);\n+\n+      return Failure;\n+   end Create;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   function Read (Rsig : C.int) return C.int is\n+      Buf : aliased Character;\n+   begin\n+      return C_Recv (Rsig, Buf'Address, 1, Constants.MSG_Forced_Flags);\n+   end Read;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   function Write (Wsig : C.int) return C.int is\n+      Buf : aliased Character := ASCII.NUL;\n+   begin\n+      return C_Send (Wsig, Buf'Address, 1, Constants.MSG_Forced_Flags);\n+   end Write;\n+\n+end Signalling_Fds;"}, {"sha": "ef8e26581a7f3f1679af210081a075a0aa739e1a", "filename": "gcc/ada/socket.c", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fsocket.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3bf932b985baee7ac3973208c0d775dcb93b5d/gcc%2Fada%2Fsocket.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsocket.c?ref=3d3bf932b985baee7ac3973208c0d775dcb93b5d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 2003-2005 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 2003-2006, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -36,21 +36,30 @@\n /* Include all the necessary system-specific headers and define the\n    necessary macros (shared with gen-soccon). */\n \n+#if !defined(SO_NOSIGPIPE) && !defined (MSG_NOSIGNAL)\n+#include <signal.h>\n+#endif\n+/* Required if we will be calling signal() in __gnat_disable_all_sigpipes() */\n+\n #include \"raise.h\"\n /* Required for __gnat_malloc() */\n \n #include <string.h>\n /* Required for memcpy() */\n \n extern void __gnat_disable_sigpipe (int fd);\n+extern void __gnat_disable_all_sigpipes (void);\n+extern int  __gnat_create_signalling_fds (int *fds);\n+extern int  __gnat_read_signalling_fd (int rsig);\n+extern int  __gnat_write_signalling_fd (int wsig);\n extern void __gnat_free_socket_set (fd_set *);\n extern void __gnat_last_socket_in_set (fd_set *, int *);\n extern void __gnat_get_socket_from_set (fd_set *, int *, int *);\n extern void __gnat_insert_socket_in_set (fd_set *, int);\n extern int __gnat_is_socket_in_set (fd_set *, int);\n extern fd_set *__gnat_new_socket_set (fd_set *);\n extern void __gnat_remove_socket_from_set (fd_set *, int);\n-extern int __gnat_get_h_errno (void);\n+extern int  __gnat_get_h_errno (void);\n \f\n /* Disable the sending of SIGPIPE for writes on a broken stream */\n \n@@ -63,6 +72,51 @@ __gnat_disable_sigpipe (int fd)\n #endif\n }\n \n+void\n+__gnat_disable_all_sigpipes (void)\n+{\n+#if !defined(SO_NOSIGPIPE) && !defined(MSG_NOSIGNAL) && defined(SIGPIPE)\n+  (void) signal (SIGPIPE, SIG_IGN);\n+#endif\n+}\n+\f\n+#if defined (_WIN32) || defined (__vxworks) || defined (VMS)\n+/*\n+ * Signalling FDs operations are implemented in Ada for these platforms\n+ * (see subunit GNAT.Sockets.Thin.Signalling_Fds).\n+ */\n+#else\n+/*\n+ * Create a pair of connected file descriptors fds[0] and fds[1] used for\n+ * signalling by a Selector object. fds[0] is the read end, and fds[1] the\n+ * write end.\n+ */\n+int\n+__gnat_create_signalling_fds (int *fds) {\n+  return pipe (fds);\n+}\n+\f\n+/*\n+ * Read one byte of data from rsig, the read end of a pair of signalling fds\n+ * created by __gnat_create_signalling_fds.\n+ */\n+int\n+__gnat_read_signalling_fd (int rsig) {\n+  char c;\n+  return read (rsig, &c, 1);\n+}\n+\f\n+/*\n+ * Write one byte of data to wsig, the write end of a pair of signalling fds\n+ * created by __gnat_create_signalling_fds.\n+ */\n+int\n+__gnat_write_signalling_fd (int wsig) {\n+  char c = 0;\n+  return write (wsig, &c, 1);\n+}\n+#endif\n+\f\n /* Free socket set. */\n \n void\n@@ -83,7 +137,7 @@ __gnat_last_socket_in_set (fd_set *set, int *last)\n   int l;\n   l = -1;\n \n-#ifdef WINNT\n+#ifdef _WIN32\n   /* More efficient method for NT. */\n   for (s = 0; s < set->fd_count; s++)\n     if ((int) set->fd_array[s] > l)"}]}