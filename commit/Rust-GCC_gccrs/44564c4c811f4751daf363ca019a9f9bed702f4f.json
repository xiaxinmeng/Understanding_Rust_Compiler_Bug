{"sha": "44564c4c811f4751daf363ca019a9f9bed702f4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ1NjRjNGM4MTFmNDc1MWRhZjM2M2NhMDE5YTlmOWJlZDcwMmY0Zg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-05-31T17:28:41Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-06-02T22:24:47Z"}, "message": "jit: fix __builtin_unreachable [PR 95426]\n\nPR jit/95426 reports a crash deep inside \"expand\" when using\n__builtin_unreachable via gcc_jit_context_get_builtin_function,\ndue to BLOCK_FOR_INSN being erroneously used on a barrier within\nrtl_verify_bb_pointers.\n\nThe root cause turns out to be that I didn't implement\nLANG_HOOKS_COMMON_ATTRIBUTE_TABLE and LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE\nfor the jit \"frontend\".  When building a decl for the builtin, the\nlibgccjit frontend generates a chain of attributes names, but when\nthis is passed to decl_attributes and the attributes are looked up by\nnamespace and name within lookup_scoped_attribute_spec, attributes_table\nis empty.  Hence no attributes were being associated with the fndecl,\nand so ECF_NORETURN was not set on the gimple_call (along with various\nother flags missing on the decl, etc), and so the call is treated as\nnot terminating its BB, and so the CFG rapidly diverges from the\nequivalent created by the C frontend.\n\nThis patch fixes things by implementing these langhooks, copying the\nminimal attribute-handling code from LTO.  I stepped through the\ncreation of the fndecl and verified that with this fix it has the same\nattributes as the equivalent created by the C frontend.\n\ngcc/jit/ChangeLog:\n\tPR jit/95426\n\t* dummy-frontend.c: Include \"options.h\", \"stringpool.h\", and\n\t\"attribs.h\".\n\t(ATTR_EXCL): New, copied from lto/lto-lang.c.\n\t(attr_noreturn_exclusions): Likewise.\n\t(attr_returns_twice_exclusions): Likewise.\n\t(attr_const_pure_exclusions): Likewise.\n\t(jit_attribute_table): Likewise, copied from lto_attribute_table.\n\t(jit_format_attribute_table): Likewise, copied from\n\tlto_format_attribute_table.\n\t(handle_noreturn_attribute): New, copied from lto/lto-lang.c.\n\t(handle_leaf_attribute): Likewise.\n\t(handle_const_attribute): Likewise.\n\t(handle_malloc_attribute): Likewise.\n\t(handle_pure_attribute): Likewise.\n\t(handle_novops_attribute): Likewise.\n\t(get_nonnull_operand): Likewise.\n\t(handle_nonnull_attribute): Likewise.\n\t(handle_nothrow_attribute): Likewise.\n\t(handle_sentinel_attribute): Likewise.\n\t(handle_type_generic_attribute): Likewise.\n\t(handle_transaction_pure_attribute): Likewise.\n\t(handle_returns_twice_attribute): Likewise.\n\t(handle_patchable_function_entry_attribute): Likewise.\n\t(ignore_attribute): Likewise.\n\t(handle_format_attribute): Likewise.\n\t(handle_format_arg_attribute): Likewise.\n\t(handle_fnspec_attribute): Likewise.\n\t(LANG_HOOKS_COMMON_ATTRIBUTE_TABLE): Define.\n\t(LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE): Define.\n\ngcc/testsuite/ChangeLog:\n\tPR jit/95426\n\t* jit.dg/all-non-failing-tests.h: Add note about...\n\t* jit.dg/test-builtin-unreachable.c: New test.", "tree": {"sha": "eb9631e477cf5657f5944924a54e56c4838c34e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb9631e477cf5657f5944924a54e56c4838c34e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44564c4c811f4751daf363ca019a9f9bed702f4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44564c4c811f4751daf363ca019a9f9bed702f4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44564c4c811f4751daf363ca019a9f9bed702f4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44564c4c811f4751daf363ca019a9f9bed702f4f/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b68cb38ddca37a14a6f2f43de3a6d396ee1bc79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b68cb38ddca37a14a6f2f43de3a6d396ee1bc79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b68cb38ddca37a14a6f2f43de3a6d396ee1bc79"}], "stats": {"total": 512, "additions": 511, "deletions": 1}, "files": [{"sha": "aa64a6eb7a035029b778786264a9e4567cf0ea1d", "filename": "gcc/jit/dummy-frontend.c", "status": "modified", "additions": 459, "deletions": 1, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44564c4c811f4751daf363ca019a9f9bed702f4f/gcc%2Fjit%2Fdummy-frontend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44564c4c811f4751daf363ca019a9f9bed702f4f/gcc%2Fjit%2Fdummy-frontend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdummy-frontend.c?ref=44564c4c811f4751daf363ca019a9f9bed702f4f", "patch": "@@ -26,10 +26,462 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n #include \"diagnostic.h\"\n-\n+#include \"options.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n \n #include <mpfr.h>\n \n+/* Attribute handling.  */\n+\n+static tree handle_noreturn_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_leaf_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_const_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_malloc_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_pure_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_novops_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_nonnull_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_nothrow_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_sentinel_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_transaction_pure_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_returns_twice_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_patchable_function_entry_attribute (tree *, tree, tree,\n+\t\t\t\t\t\t       int, bool *);\n+static tree ignore_attribute (tree *, tree, tree, int, bool *);\n+\n+static tree handle_format_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_format_arg_attribute (tree *, tree, tree, int, bool *);\n+\n+/* Helper to define attribute exclusions.  */\n+#define ATTR_EXCL(name, function, type, variable)\t\\\n+  { name, function, type, variable }\n+\n+/* Define attributes that are mutually exclusive with one another.  */\n+static const struct attribute_spec::exclusions attr_noreturn_exclusions[] =\n+{\n+  ATTR_EXCL (\"noreturn\", true, true, true),\n+  ATTR_EXCL (\"alloc_align\", true, true, true),\n+  ATTR_EXCL (\"alloc_size\", true, true, true),\n+  ATTR_EXCL (\"const\", true, true, true),\n+  ATTR_EXCL (\"malloc\", true, true, true),\n+  ATTR_EXCL (\"pure\", true, true, true),\n+  ATTR_EXCL (\"returns_twice\", true, true, true),\n+  ATTR_EXCL (\"warn_unused_result\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+static const struct attribute_spec::exclusions attr_returns_twice_exclusions[] =\n+{\n+  ATTR_EXCL (\"noreturn\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+static const struct attribute_spec::exclusions attr_const_pure_exclusions[] =\n+{\n+  ATTR_EXCL (\"const\", true, true, true),\n+  ATTR_EXCL (\"noreturn\", true, true, true),\n+  ATTR_EXCL (\"pure\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n+\n+/* Table of machine-independent attributes supported in libgccjit.  */\n+const struct attribute_spec jit_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req,\n+       affects_type_identity, handler, exclude } */\n+  { \"noreturn\",               0, 0, true,  false, false, false,\n+\t\t\t      handle_noreturn_attribute,\n+\t\t\t      attr_noreturn_exclusions },\n+  { \"leaf\",\t\t      0, 0, true,  false, false, false,\n+\t\t\t      handle_leaf_attribute, NULL },\n+  /* The same comments as for noreturn attributes apply to const ones.  */\n+  { \"const\",                  0, 0, true,  false, false, false,\n+\t\t\t      handle_const_attribute,\n+\t\t\t      attr_const_pure_exclusions },\n+  { \"malloc\",                 0, 0, true,  false, false, false,\n+\t\t\t      handle_malloc_attribute, NULL },\n+  { \"pure\",                   0, 0, true,  false, false, false,\n+\t\t\t      handle_pure_attribute,\n+\t\t\t      attr_const_pure_exclusions },\n+  { \"no vops\",                0, 0, true,  false, false, false,\n+\t\t\t      handle_novops_attribute, NULL },\n+  { \"nonnull\",                0, -1, false, true, true, false,\n+\t\t\t      handle_nonnull_attribute, NULL },\n+  { \"nothrow\",                0, 0, true,  false, false, false,\n+\t\t\t      handle_nothrow_attribute, NULL },\n+  { \"patchable_function_entry\", 1, 2, true, false, false, false,\n+\t\t\t      handle_patchable_function_entry_attribute,\n+\t\t\t      NULL },\n+  { \"returns_twice\",          0, 0, true,  false, false, false,\n+\t\t\t      handle_returns_twice_attribute,\n+\t\t\t      attr_returns_twice_exclusions },\n+  { \"sentinel\",               0, 1, false, true, true, false,\n+\t\t\t      handle_sentinel_attribute, NULL },\n+  { \"type generic\",           0, 0, false, true, true, false,\n+\t\t\t      handle_type_generic_attribute, NULL },\n+  { \"fn spec\",\t \t      1, 1, false, true, true, false,\n+\t\t\t      handle_fnspec_attribute, NULL },\n+  { \"transaction_pure\",\t      0, 0, false, true, true, false,\n+\t\t\t      handle_transaction_pure_attribute, NULL },\n+  /* For internal use only.  The leading '*' both prevents its usage in\n+     source code and signals that it may be overridden by machine tables.  */\n+  { \"*tm regparm\",            0, 0, false, true, true, false,\n+\t\t\t      ignore_attribute, NULL },\n+  { NULL,                     0, 0, false, false, false, false, NULL, NULL }\n+};\n+\n+/* Give the specifications for the format attributes, used by C and all\n+   descendants.  */\n+\n+const struct attribute_spec jit_format_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req,\n+       affects_type_identity, handler, exclude } */\n+  { \"format\",                 3, 3, false, true,  true, false,\n+\t\t\t      handle_format_attribute, NULL },\n+  { \"format_arg\",             1, 1, false, true,  true, false,\n+\t\t\t      handle_format_arg_attribute, NULL },\n+  { NULL,                     0, 0, false, false, false, false, NULL, NULL }\n+};\n+\n+/* Attribute handlers.  */\n+\n+/* Handle a \"noreturn\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_noreturn_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\t   tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\t   bool * ARG_UNUSED (no_add_attrs))\n+{\n+  tree type = TREE_TYPE (*node);\n+\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_THIS_VOLATILE (*node) = 1;\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+    TREE_TYPE (*node)\n+      = build_pointer_type\n+\t(build_type_variant (TREE_TYPE (type),\n+\t\t\t     TYPE_READONLY (TREE_TYPE (type)), 1));\n+  else\n+    gcc_unreachable ();\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"leaf\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_leaf_attribute (tree *node, tree name,\n+\t\t       tree ARG_UNUSED (args),\n+\t\t       int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+  if (!TREE_PUBLIC (*node))\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute has no effect on unit local functions\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"const\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_const_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\ttree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\tbool * ARG_UNUSED (no_add_attrs))\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL\n+      || !fndecl_built_in_p (*node))\n+    inform (UNKNOWN_LOCATION, \"%s:%s: %E: %E\", __FILE__, __func__, *node, name);\n+\n+  tree type = TREE_TYPE (*node);\n+\n+  /* See FIXME comment on noreturn in c_common_attribute_table.  */\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_READONLY (*node) = 1;\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+    TREE_TYPE (*node)\n+      = build_pointer_type\n+\t(build_type_variant (TREE_TYPE (type), 1,\n+\t\t\t     TREE_THIS_VOLATILE (TREE_TYPE (type))));\n+  else\n+    gcc_unreachable ();\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Handle a \"malloc\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_malloc_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\t tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\t bool * ARG_UNUSED (no_add_attrs))\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL\n+      && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (*node))))\n+    DECL_IS_MALLOC (*node) = 1;\n+  else\n+    gcc_unreachable ();\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Handle a \"pure\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_pure_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t       tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t       bool * ARG_UNUSED (no_add_attrs))\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    DECL_PURE_P (*node) = 1;\n+  else\n+    gcc_unreachable ();\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Handle a \"no vops\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_novops_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\t tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\t bool *ARG_UNUSED (no_add_attrs))\n+{\n+  gcc_assert (TREE_CODE (*node) == FUNCTION_DECL);\n+  DECL_IS_NOVOPS (*node) = 1;\n+  return NULL_TREE;\n+}\n+\n+\n+/* Helper for nonnull attribute handling; fetch the operand number\n+   from the attribute argument list.  */\n+\n+static bool\n+get_nonnull_operand (tree arg_num_expr, unsigned HOST_WIDE_INT *valp)\n+{\n+  /* Verify the arg number is a constant.  */\n+  if (!tree_fits_uhwi_p (arg_num_expr))\n+    return false;\n+\n+  *valp = TREE_INT_CST_LOW (arg_num_expr);\n+  return true;\n+}\n+\n+/* Handle the \"nonnull\" attribute.  */\n+\n+static tree\n+handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\t  tree args, int ARG_UNUSED (flags),\n+\t\t\t  bool * ARG_UNUSED (no_add_attrs))\n+{\n+  tree type = *node;\n+\n+  /* If no arguments are specified, all pointer arguments should be\n+     non-null.  Verify a full prototype is given so that the arguments\n+     will have the correct types when we actually check them later.\n+     Avoid diagnosing type-generic built-ins since those have no\n+     prototype.  */\n+  if (!args)\n+    {\n+      gcc_assert (prototype_p (type)\n+\t\t  || !TYPE_ATTRIBUTES (type)\n+\t\t  || lookup_attribute (\"type generic\", TYPE_ATTRIBUTES (type)));\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* Argument list specified.  Verify that each argument number references\n+     a pointer argument.  */\n+  for (; args; args = TREE_CHAIN (args))\n+    {\n+      tree argument;\n+      unsigned HOST_WIDE_INT arg_num = 0, ck_num;\n+\n+      if (!get_nonnull_operand (TREE_VALUE (args), &arg_num))\n+\tgcc_unreachable ();\n+\n+      argument = TYPE_ARG_TYPES (type);\n+      if (argument)\n+\t{\n+\t  for (ck_num = 1; ; ck_num++)\n+\t    {\n+\t      if (!argument || ck_num == arg_num)\n+\t\tbreak;\n+\t      argument = TREE_CHAIN (argument);\n+\t    }\n+\n+\t  gcc_assert (argument\n+\t\t      && TREE_CODE (TREE_VALUE (argument)) == POINTER_TYPE);\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Handle a \"nothrow\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_nothrow_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\t  tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\t  bool * ARG_UNUSED (no_add_attrs))\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_NOTHROW (*node) = 1;\n+  else\n+    gcc_unreachable ();\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Handle a \"sentinel\" attribute.  */\n+\n+static tree\n+handle_sentinel_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n+\t\t\t   int ARG_UNUSED (flags),\n+\t\t\t   bool * ARG_UNUSED (no_add_attrs))\n+{\n+  gcc_assert (stdarg_p (*node));\n+\n+  if (args)\n+    {\n+      tree position = TREE_VALUE (args);\n+      gcc_assert (TREE_CODE (position) == INTEGER_CST);\n+      if (tree_int_cst_lt (position, integer_zero_node))\n+\tgcc_unreachable ();\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"type_generic\" attribute.  */\n+\n+static tree\n+handle_type_generic_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\t       tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\t       bool * ARG_UNUSED (no_add_attrs))\n+{\n+  /* Ensure we have a function type.  */\n+  gcc_assert (TREE_CODE (*node) == FUNCTION_TYPE);\n+\n+  /* Ensure we have a variadic function.  */\n+  gcc_assert (!prototype_p (*node) || stdarg_p (*node));\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"transaction_pure\" attribute.  */\n+\n+static tree\n+handle_transaction_pure_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\t\t   tree ARG_UNUSED (args),\n+\t\t\t\t   int ARG_UNUSED (flags),\n+\t\t\t\t   bool * ARG_UNUSED (no_add_attrs))\n+{\n+  /* Ensure we have a function type.  */\n+  gcc_assert (TREE_CODE (*node) == FUNCTION_TYPE);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"returns_twice\" attribute.  */\n+\n+static tree\n+handle_returns_twice_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\t\ttree ARG_UNUSED (args),\n+\t\t\t\tint ARG_UNUSED (flags),\n+\t\t\t\tbool * ARG_UNUSED (no_add_attrs))\n+{\n+  gcc_assert (TREE_CODE (*node) == FUNCTION_DECL);\n+\n+  DECL_IS_RETURNS_TWICE (*node) = 1;\n+\n+  return NULL_TREE;\n+}\n+\n+static tree\n+handle_patchable_function_entry_attribute (tree *, tree, tree, int, bool *)\n+{\n+  /* Nothing to be done here.  */\n+  return NULL_TREE;\n+}\n+\n+/* Ignore the given attribute.  Used when this attribute may be usefully\n+   overridden by the target, but is not used generically.  */\n+\n+static tree\n+ignore_attribute (tree * ARG_UNUSED (node), tree ARG_UNUSED (name),\n+\t\t  tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t  bool *no_add_attrs)\n+{\n+  *no_add_attrs = true;\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"format\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_format_attribute (tree * ARG_UNUSED (node), tree ARG_UNUSED (name),\n+\t\t\t tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\t bool *no_add_attrs)\n+{\n+  *no_add_attrs = true;\n+  return NULL_TREE;\n+}\n+\n+\n+/* Handle a \"format_arg\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+tree\n+handle_format_arg_attribute (tree * ARG_UNUSED (node), tree ARG_UNUSED (name),\n+\t\t\t     tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\t     bool *no_add_attrs)\n+{\n+  *no_add_attrs = true;\n+  return NULL_TREE;\n+}\n+\n+\n+/* Handle a \"fn spec\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_fnspec_attribute (tree *node ATTRIBUTE_UNUSED, tree ARG_UNUSED (name),\n+\t\t\t tree args, int ARG_UNUSED (flags),\n+\t\t\t bool *no_add_attrs ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (args\n+\t      && TREE_CODE (TREE_VALUE (args)) == STRING_CST\n+\t      && !TREE_CHAIN (args));\n+  return NULL_TREE;\n+}\n+\n+/* (end of attribute-handling).  */\n+\n /* Language-dependent contents of a type.  */\n \n struct GTY(()) lang_type\n@@ -269,6 +721,12 @@ jit_langhook_getdecls (void)\n #undef LANG_HOOKS_GETDECLS\n #define LANG_HOOKS_GETDECLS\t\tjit_langhook_getdecls\n \n+/* Attribute hooks.  */\n+#undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\n+#define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE jit_attribute_table\n+#undef LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE\n+#define LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE jit_format_attribute_table\n+\n #undef  LANG_HOOKS_DEEP_UNSHARING\n #define LANG_HOOKS_DEEP_UNSHARING\ttrue\n "}, {"sha": "632ab8cfb2e435c32e262f50e43ffb1ccce6df87", "filename": "gcc/testsuite/jit.dg/all-non-failing-tests.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44564c4c811f4751daf363ca019a9f9bed702f4f/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44564c4c811f4751daf363ca019a9f9bed702f4f/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h?ref=44564c4c811f4751daf363ca019a9f9bed702f4f", "patch": "@@ -74,6 +74,9 @@\n #undef create_code\n #undef verify_code\n \n+/* test-builtin-unreachable.c: We don't add this one, since it touches\n+   the optimization level of the context as a whole.  */\n+\n /* test-calling-external-function.c */\n #define create_code create_code_calling_external_function\n #define verify_code verify_code_calling_external_function"}, {"sha": "09e55e608da013393764d2d0966b6b55eebfe2ce", "filename": "gcc/testsuite/jit.dg/test-builtin-unreachable.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44564c4c811f4751daf363ca019a9f9bed702f4f/gcc%2Ftestsuite%2Fjit.dg%2Ftest-builtin-unreachable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44564c4c811f4751daf363ca019a9f9bed702f4f/gcc%2Ftestsuite%2Fjit.dg%2Ftest-builtin-unreachable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-builtin-unreachable.c?ref=44564c4c811f4751daf363ca019a9f9bed702f4f", "patch": "@@ -0,0 +1,49 @@\n+#include <libgccjit.h>\n+\n+#include \"harness.h\"\n+\n+/* Verify that we can compile a function that uses __builtin_unreachable\n+   (PR jit/95426).\n+   \n+   Compile the equivalent of this C:\n+\n+     int test_pr95426_unreachable (int i)\n+     {\n+       __builtin_unreachable ();\n+       return i;\n+     }\n+*/\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_context_set_int_option (ctxt,\n+\t\t\t\t  GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n+\t\t\t\t  0);\n+\n+  gcc_jit_type *int_type = gcc_jit_context_get_type(ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_param *param_i\n+    = gcc_jit_context_new_param (ctxt, NULL, int_type, \"i\");\n+  gcc_jit_function *test_fn\n+    = gcc_jit_context_new_function (ctxt, NULL, GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    int_type,\n+\t\t\t\t    \"test_pr95426_unreachable\",\n+\t\t\t\t    1, &param_i, 0);\n+\n+  gcc_jit_block *bb = gcc_jit_function_new_block(test_fn, \"start\");\n+  gcc_jit_function *func___builtin_unreachable\n+    = gcc_jit_context_get_builtin_function(ctxt, \"__builtin_unreachable\");\n+  gcc_jit_rvalue *call___builtin_unreachable\n+    = gcc_jit_context_new_call(ctxt, NULL, func___builtin_unreachable,\n+\t\t\t       0, NULL);\n+  gcc_jit_block_add_eval(bb, NULL, call___builtin_unreachable);\n+  gcc_jit_block_end_with_return (bb, NULL, gcc_jit_param_as_rvalue(param_i));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_NON_NULL (result);\n+  CHECK_NON_NULL (gcc_jit_result_get_code (result, \"test_pr95426_unreachable\"));\n+  /* Don't actually run the code.  */\n+}"}]}