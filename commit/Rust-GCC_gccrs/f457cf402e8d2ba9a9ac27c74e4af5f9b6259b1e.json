{"sha": "f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ1N2NmNDAyZThkMmJhOWE5YWMyN2M3NGU0YWY1ZjliNjI1OWIxZQ==", "commit": {"author": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-08-17T03:56:20Z"}, "committer": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-08-17T03:56:20Z"}, "message": "fold-const.c (optimize_bit_field_compare): Remove extra fold call.\n\n2005-08-16  James A. Morrison  <phython@gcc.gnu.org>\n\n        * fold-const.c (optimize_bit_field_compare): Remove extra fold call.\n        (try_move_mult_to_index): Call fold_build2 instead of build2.\n        (fold_binary): Don't call fold after calls to try_move_mult_to_index.\n        * tree-ssa-loop-niter.c (inverse): Call int_const_binop instead of\n        fold_binary_to_constant.\n        (infer_loop_bounds_from_undefined): Call fold_build2 instead of\n        fold (build.\n        * tree-data-ref.c (tree_fold_divides_p): Use tree_int_cst_equal to\n        check if A == gcd (A, B).  Remove TYPE argument.\n        (analyze_offset) Use fold_build2 instead of fold (build.\n        (create_data_ref): Likewise.\n        (analyze_siv_subscript_cst_affine): Update calls to tree_fold_divides_p.        * tree-ssa-ccp.c (widen_bitfield): Call fold_build2 instead of build2\n        then fold.\n\nFrom-SVN: r103200", "tree": {"sha": "bf56b200973247a5d5406c02f3422ef6f6a55621", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf56b200973247a5d5406c02f3422ef6f6a55621"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e/comments", "author": null, "committer": null, "parents": [{"sha": "0cbe2a6862df066e1ba207bbba418b1a5e6bd429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cbe2a6862df066e1ba207bbba418b1a5e6bd429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cbe2a6862df066e1ba207bbba418b1a5e6bd429"}], "stats": {"total": 91, "additions": 52, "deletions": 39}, "files": [{"sha": "ebd71a1f53d789d010bfb6657e50c63ab516cc09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e", "patch": "@@ -1,3 +1,20 @@\n+2005-08-16  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\t* fold-const.c (optimize_bit_field_compare): Remove extra fold call.\n+\t(try_move_mult_to_index): Call fold_build2 instead of build2.\n+\t(fold_binary): Don't call fold after calls to try_move_mult_to_index.\n+\t* tree-ssa-loop-niter.c (inverse): Call int_const_binop instead of\n+\tfold_binary_to_constant.\n+\t(infer_loop_bounds_from_undefined): Call fold_build2 instead of\n+\tfold (build.\n+\t* tree-data-ref.c (tree_fold_divides_p): Use tree_int_cst_equal to\n+\tcheck if A == gcd (A, B).  Remove TYPE argument.\n+\t(analyze_offset) Use fold_build2 instead of fold (build.\n+\t(create_data_ref): Likewise.\n+\t(analyze_siv_subscript_cst_affine): Update calls to tree_fold_divides_p.\n+\t* tree-ssa-ccp.c (widen_bitfield): Call fold_build2 instead of build2\n+\tthen fold.\n+\n 2005-08-17  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* config/arm/unaligned-funcs.c,config/i386/crtfastmath.c,"}, {"sha": "6853b413f09c1566d7bba69bb70d9dfbdee0df51", "filename": "gcc/fold-const.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e", "patch": "@@ -3340,11 +3340,11 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type,\n       TREE_THIS_VOLATILE (lhs) = 1;\n     }\n \n-  rhs = fold (const_binop (BIT_AND_EXPR,\n-\t\t\t   const_binop (LSHIFT_EXPR,\n-\t\t\t\t\tfold_convert (unsigned_type, rhs),\n-\t\t\t\t\tsize_int (lbitpos), 0),\n-\t\t\t   mask, 0));\n+  rhs = const_binop (BIT_AND_EXPR,\n+\t\t     const_binop (LSHIFT_EXPR,\n+\t\t\t\t  fold_convert (unsigned_type, rhs),\n+\t\t\t\t  size_int (lbitpos), 0),\n+\t\t     mask, 0);\n \n   return build2 (code, compare_type,\n \t\t build2 (BIT_AND_EXPR, unsigned_type, lhs, mask),\n@@ -6468,7 +6468,7 @@ try_move_mult_to_index (enum tree_code code, tree addr, tree op1)\n \t\t\t\t\t\t     TREE_OPERAND (pos, 1)),\n \t\t\t\t       fold_convert (itype, delta));\n \n-  return build1 (ADDR_EXPR, TREE_TYPE (addr), ret);\n+  return fold_build1 (ADDR_EXPR, TREE_TYPE (addr), ret);\n }\n \n \n@@ -7305,13 +7305,13 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    {\n \t      tem = try_move_mult_to_index (PLUS_EXPR, arg0, arg1);\n \t      if (tem)\n-\t\treturn fold_convert (type, fold (tem));\n+\t\treturn fold_convert (type, tem);\n \t    }\n \t  else if (TREE_CODE (arg1) == ADDR_EXPR)\n \t    {\n \t      tem = try_move_mult_to_index (PLUS_EXPR, arg1, arg0);\n \t      if (tem)\n-\t\treturn fold_convert (type, fold (tem));\n+\t\treturn fold_convert (type, tem);\n \t    }\n \t}\n       else\n@@ -7730,7 +7730,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t{\n \t  tem = try_move_mult_to_index (MINUS_EXPR, arg0, arg1);\n \t  if (tem)\n-\t    return fold_convert (type, fold (tem));\n+\t    return fold_convert (type, tem);\n \t}\n \n       if (flag_unsafe_math_optimizations"}, {"sha": "568de38deb453c15359c06eb555d9ddbe96826ba", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e", "patch": "@@ -479,13 +479,11 @@ base_addr_differ_p (struct data_reference *dra,\n /* Returns true iff A divides B.  */\n \n static inline bool \n-tree_fold_divides_p (tree type, \n-\t\t     tree a, \n+tree_fold_divides_p (tree a, \n \t\t     tree b)\n {\n   /* Determines whether (A == gcd (A, B)).  */\n-  return integer_zerop \n-    (fold_build2 (MINUS_EXPR, type, a, tree_fold_gcd (a, b)));\n+  return tree_int_cst_equal (a, tree_fold_gcd (a, b));\n }\n \n /* Compute the greatest common denominator of two numbers using\n@@ -1723,7 +1721,7 @@ analyze_offset (tree offset, tree *invariant, tree *constant)\n   *constant = constant_0 ? constant_0 : constant_1;\n   if (invariant_0 && invariant_1)\n     *invariant = \n-      fold (build (code, TREE_TYPE (invariant_0), invariant_0, invariant_1));\n+      fold_build2 (code, TREE_TYPE (invariant_0), invariant_0, invariant_1);\n   else\n     *invariant = invariant_0 ? invariant_0 : invariant_1;\n }\n@@ -1805,8 +1803,8 @@ create_data_ref (tree memref, tree stmt, bool is_read)\n       if (constant)\n \t{\n \t  DR_INIT (dr) = fold_convert (ssizetype, constant);\n-\t  init_cond = fold (build (TRUNC_DIV_EXPR, TREE_TYPE (constant), \n-\t\t\t\t   constant, type_size));\n+\t  init_cond = fold_build2 (TRUNC_DIV_EXPR, TREE_TYPE (constant), \n+\t\t\t\t   constant, type_size);\n \t}\n       else\n \tDR_INIT (dr) = init_cond = ssize_int (0);;\n@@ -2186,8 +2184,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t     chrec_b = {10, +, 1}\n \t\t  */\n \t\t  \n-\t\t  if (tree_fold_divides_p \n-\t\t      (integer_type_node, CHREC_RIGHT (chrec_b), difference))\n+\t\t  if (tree_fold_divides_p (CHREC_RIGHT (chrec_b), difference))\n \t\t    {\n \t\t      *overlaps_a = integer_zero_node;\n \t\t      *overlaps_b = fold_build2 (EXACT_DIV_EXPR, integer_type_node,\n@@ -2199,7 +2196,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t      return;\n \t\t    }\n \t\t  \n-\t\t  /* When the step does not divides the difference, there are\n+\t\t  /* When the step does not divide the difference, there are\n \t\t     no overlaps.  */\n \t\t  else\n \t\t    {\n@@ -2241,13 +2238,12 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t     chrec_a = 3\n \t\t     chrec_b = {10, +, -1}\n \t\t  */\n-\t\t  if (tree_fold_divides_p \n-\t\t      (integer_type_node, CHREC_RIGHT (chrec_b), difference))\n+\t\t  if (tree_fold_divides_p (CHREC_RIGHT (chrec_b), difference))\n \t\t    {\n \t\t      *overlaps_a = integer_zero_node;\n-\t\t      *overlaps_b = fold \n-\t\t\t(build (EXACT_DIV_EXPR, integer_type_node, difference, \n-\t\t\t\tCHREC_RIGHT (chrec_b)));\n+\t\t      *overlaps_b = fold_build2 (EXACT_DIV_EXPR,\n+\t\t\t\t      \t\t integer_type_node, difference, \n+\t\t\t\t\t\t CHREC_RIGHT (chrec_b));\n \t\t      *last_conflicts = integer_one_node;\n \t\t      return;\n \t\t    }\n@@ -2816,7 +2812,7 @@ chrec_steps_divide_constant_p (tree chrec,\n   switch (TREE_CODE (chrec))\n     {\n     case POLYNOMIAL_CHREC:\n-      return (tree_fold_divides_p (integer_type_node, CHREC_RIGHT (chrec), cst)\n+      return (tree_fold_divides_p (CHREC_RIGHT (chrec), cst)\n \t      && chrec_steps_divide_constant_p (CHREC_LEFT (chrec), cst));\n       \n     default:"}, {"sha": "6ec112acb1bacb4ebcea05f53de0597aeaac3bed", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e", "patch": "@@ -1432,8 +1432,8 @@ widen_bitfield (tree val, tree field, tree var)\n       for (i = 0, mask = 0; i < field_size; i++)\n \tmask |= ((HOST_WIDE_INT) 1) << i;\n \n-      wide_val = build2 (BIT_AND_EXPR, TREE_TYPE (var), val, \n-\t\t\t build_int_cst (TREE_TYPE (var), mask));\n+      wide_val = fold_build2 (BIT_AND_EXPR, TREE_TYPE (var), val, \n+\t\t\t      build_int_cst (TREE_TYPE (var), mask));\n     }\n   else\n     {\n@@ -1443,11 +1443,11 @@ widen_bitfield (tree val, tree field, tree var)\n       for (i = 0, mask = 0; i < (var_size - field_size); i++)\n \tmask |= ((HOST_WIDE_INT) 1) << (var_size - i - 1);\n \n-      wide_val = build2 (BIT_IOR_EXPR, TREE_TYPE (var), val,\n-\t\t\t build_int_cst (TREE_TYPE (var), mask));\n+      wide_val = fold_build2 (BIT_IOR_EXPR, TREE_TYPE (var), val,\n+\t\t\t      build_int_cst (TREE_TYPE (var), mask));\n     }\n \n-  return fold (wide_val);\n+  return wide_val;\n }\n \n "}, {"sha": "fc5491b857e46c94dd05d3271c4a004b436dfbd2", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=f457cf402e8d2ba9a9ac27c74e4af5f9b6259b1e", "patch": "@@ -117,10 +117,10 @@ inverse (tree x, tree mask)\n       rslt = build_int_cst_type (type, 1);\n       for (; ctr; ctr--)\n \t{\n-\t  rslt = fold_binary_to_constant (MULT_EXPR, type, rslt, x);\n-\t  x = fold_binary_to_constant (MULT_EXPR, type, x, x);\n+\t  rslt = int_const_binop (MULT_EXPR, rslt, x, 0);\n+\t  x = int_const_binop (MULT_EXPR, x, x, 0);\n \t}\n-      rslt = fold_binary_to_constant (BIT_AND_EXPR, type, rslt, mask);\n+      rslt = int_const_binop (BIT_AND_EXPR, rslt, mask, 0);\n     }\n \n   return rslt;\n@@ -1465,14 +1465,14 @@ infer_loop_bounds_from_undefined (struct loop *loop)\n \n \t\t    utype = unsigned_type_for (type);\n \t\t    if (tree_int_cst_lt (step, integer_zero_node))\n-\t\t      diff = fold (build2 (MINUS_EXPR, utype, init,\n-\t\t\t\t\t   TYPE_MIN_VALUE (type)));\n+\t\t      diff = fold_build2 (MINUS_EXPR, utype, init,\n+\t\t\t\t\t  TYPE_MIN_VALUE (type));\n \t\t    else\n-\t\t      diff = fold (build2 (MINUS_EXPR, utype,\n-\t\t\t\t\t   TYPE_MAX_VALUE (type), init));\n+\t\t      diff = fold_build2 (MINUS_EXPR, utype,\n+\t\t\t\t\t  TYPE_MAX_VALUE (type), init);\n \n-\t\t    estimation = fold (build2 (CEIL_DIV_EXPR, utype, diff,\n-\t\t\t\t\t       step));\n+\t\t    estimation = fold_build2 (CEIL_DIV_EXPR, utype, diff,\n+\t\t\t\t\t      step);\n \t\t    record_estimate (loop, estimation, boolean_true_node, stmt);\n \t\t  }\n "}]}