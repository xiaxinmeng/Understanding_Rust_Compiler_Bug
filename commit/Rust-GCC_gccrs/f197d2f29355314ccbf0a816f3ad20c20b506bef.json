{"sha": "f197d2f29355314ccbf0a816f3ad20c20b506bef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE5N2QyZjI5MzU1MzE0Y2NiZjBhODE2ZjNhZDIwYzIwYjUwNmJlZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:51:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:51:19Z"}, "message": "[multiple changes]\n\n2013-04-25  Arnaud Charlet  <charlet@adacore.com>\n\n\t* par-prag.adb: Fix typo.\n\n2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Apply_Predicate_Check): If the type has a static\n\tpredicate and the expression is also static, check whether the\n\texpression satisfies the predicate.\n\t* sem_ch3.adb (Analyze_Object_Declaration): If the type has a\n\tstatic predicate and the expression is also static, see if the\n\texpression satisfies the predicate.\n\t* sem_util.adb: Alphabetize several routines.\n\t(Check_Expression_Against_Static_Predicate): New routine.\n\t* sem_util.ads (Check_Expression_Against_Static_Predicate): New routine.\n\nFrom-SVN: r198296", "tree": {"sha": "6f7c96cd6779934fc8294e71c105f19678321d2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f7c96cd6779934fc8294e71c105f19678321d2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f197d2f29355314ccbf0a816f3ad20c20b506bef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f197d2f29355314ccbf0a816f3ad20c20b506bef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f197d2f29355314ccbf0a816f3ad20c20b506bef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f197d2f29355314ccbf0a816f3ad20c20b506bef/comments", "author": null, "committer": null, "parents": [{"sha": "bbee5cc4b054ad87d3200f6d17e425040fbc50f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbee5cc4b054ad87d3200f6d17e425040fbc50f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbee5cc4b054ad87d3200f6d17e425040fbc50f6"}], "stats": {"total": 251, "additions": 149, "deletions": 102}, "files": [{"sha": "69141c3f243d60a5f16b1cd00d39cdfe58c62d2d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f197d2f29355314ccbf0a816f3ad20c20b506bef/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f197d2f29355314ccbf0a816f3ad20c20b506bef/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f197d2f29355314ccbf0a816f3ad20c20b506bef", "patch": "@@ -1,3 +1,19 @@\n+2013-04-25  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* par-prag.adb: Fix typo.\n+\n+2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Apply_Predicate_Check): If the type has a static\n+\tpredicate and the expression is also static, check whether the\n+\texpression satisfies the predicate.\n+\t* sem_ch3.adb (Analyze_Object_Declaration): If the type has a\n+\tstatic predicate and the expression is also static, see if the\n+\texpression satisfies the predicate.\n+\t* sem_util.adb: Alphabetize several routines.\n+\t(Check_Expression_Against_Static_Predicate): New routine.\n+\t* sem_util.ads (Check_Expression_Against_Static_Predicate): New routine.\n+\n 2013-04-25  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_rm.texi: Document Reason argument for pragma Warnings."}, {"sha": "5a5b7d1fc7b7915e6205a47fb72aec392129817d", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f197d2f29355314ccbf0a816f3ad20c20b506bef/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f197d2f29355314ccbf0a816f3ad20c20b506bef/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=f197d2f29355314ccbf0a816f3ad20c20b506bef", "patch": "@@ -2502,29 +2502,10 @@ package body Checks is\n          --  Here for normal case of predicate active\n \n          else\n-            --  If the predicate is a static predicate and the operand is\n-            --  static, the predicate must be evaluated statically. If the\n-            --  evaluation fails this is a static constraint error. This check\n-            --  is disabled in -gnatc mode, because the compiler is incapable\n-            --  of evaluating static expressions in that case. Note that when\n-            --  inherited predicates are involved, a type may have both static\n-            --  and dynamic forms. Check the presence of a dynamic predicate\n-            --  aspect.\n-\n-            if Is_OK_Static_Expression (N)\n-              and then Present (Static_Predicate (Typ))\n-              and then not Has_Dynamic_Predicate_Aspect (Typ)\n-            then\n-               if Operating_Mode < Generate_Code\n-                 or else Eval_Static_Predicate_Check (N, Typ)\n-               then\n-                  return;\n-               else\n-                  Error_Msg_NE\n-                    (\"static expression fails static predicate check on&\",\n-                     N, Typ);\n-               end if;\n-            end if;\n+            --  If the type has a static predicate and the expression is also\n+            --  static, see if the expression satisfies the predicate.\n+\n+            Check_Expression_Against_Static_Predicate (N, Typ);\n \n             Insert_Action (N,\n               Make_Predicate_Check (Typ, Duplicate_Subexpr (N)));"}, {"sha": "3587dff4d12c11ed85d931c10860d77a6eb57f1f", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f197d2f29355314ccbf0a816f3ad20c20b506bef/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f197d2f29355314ccbf0a816f3ad20c20b506bef/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=f197d2f29355314ccbf0a816f3ad20c20b506bef", "patch": "@@ -17,7 +17,7 @@\n -- for  more details.  You should have  received  a copy of the GNU General --\n -- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n -- http://www.gnu.org/licenses for a complete copy of the license.          --\n---          War                                                                --\n+--                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --\n --                                                                          --"}, {"sha": "08177737587b65c8d23379f0724a28926bae3a29", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f197d2f29355314ccbf0a816f3ad20c20b506bef/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f197d2f29355314ccbf0a816f3ad20c20b506bef/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f197d2f29355314ccbf0a816f3ad20c20b506bef", "patch": "@@ -3260,11 +3260,11 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n-      --  Deal with predicate check before we start to do major rewriting.\n-      --  it is OK to initialize and then check the initialized value, since\n-      --  the object goes out of scope if we get a predicate failure. Note\n-      --  that we do this in the analyzer and not the expander because the\n-      --  analyzer does some substantial rewriting in some cases.\n+      --  Deal with predicate check before we start to do major rewriting. It\n+      --  is OK to initialize and then check the initialized value, since the\n+      --  object goes out of scope if we get a predicate failure. Note that we\n+      --  do this in the analyzer and not the expander because the analyzer\n+      --  does some substantial rewriting in some cases.\n \n       --  We need a predicate check if the type has predicates, and if either\n       --  there is an initializing expression, or for default initialization\n@@ -3277,6 +3277,13 @@ package body Sem_Ch3 is\n             or else\n               Is_Partially_Initialized_Type (T, Include_Implicit => False))\n       then\n+         --  If the type has a static predicate and the expression is also\n+         --  static, see if the expression satisfies the predicate.\n+\n+         if Present (E) then\n+            Check_Expression_Against_Static_Predicate (E, T);\n+         end if;\n+\n          Insert_After (N,\n            Make_Predicate_Check (T, New_Occurrence_Of (Id, Loc)));\n       end if;"}, {"sha": "bc1f3fb8fd76839644ca1b95348cdb563ed1e99c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 108, "deletions": 73, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f197d2f29355314ccbf0a816f3ad20c20b506bef/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f197d2f29355314ccbf0a816f3ad20c20b506bef/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f197d2f29355314ccbf0a816f3ad20c20b506bef", "patch": "@@ -1265,6 +1265,114 @@ package body Sem_Util is\n       end if;\n    end Cannot_Raise_Constraint_Error;\n \n+   -----------------------------------------\n+   -- Check_Dynamically_Tagged_Expression --\n+   -----------------------------------------\n+\n+   procedure Check_Dynamically_Tagged_Expression\n+     (Expr        : Node_Id;\n+      Typ         : Entity_Id;\n+      Related_Nod : Node_Id)\n+   is\n+   begin\n+      pragma Assert (Is_Tagged_Type (Typ));\n+\n+      --  In order to avoid spurious errors when analyzing the expanded code,\n+      --  this check is done only for nodes that come from source and for\n+      --  actuals of generic instantiations.\n+\n+      if (Comes_From_Source (Related_Nod)\n+           or else In_Generic_Actual (Expr))\n+        and then (Is_Class_Wide_Type (Etype (Expr))\n+                   or else Is_Dynamically_Tagged (Expr))\n+        and then Is_Tagged_Type (Typ)\n+        and then not Is_Class_Wide_Type (Typ)\n+      then\n+         Error_Msg_N (\"dynamically tagged expression not allowed!\", Expr);\n+      end if;\n+   end Check_Dynamically_Tagged_Expression;\n+\n+   -----------------------------------------------\n+   -- Check_Expression_Against_Static_Predicate --\n+   -----------------------------------------------\n+\n+   procedure Check_Expression_Against_Static_Predicate\n+     (Expr : Node_Id;\n+      Typ  : Entity_Id)\n+   is\n+   begin\n+      --  When both the predicate and the expression are static, evaluate the\n+      --  check at compile time. A type becomes non-static when it has aspect\n+      --  Dynamic_Predicate.\n+\n+      if Is_OK_Static_Expression (Expr)\n+        and then Has_Predicates (Typ)\n+        and then Present (Static_Predicate (Typ))\n+        and then not Has_Dynamic_Predicate_Aspect (Typ)\n+      then\n+         --  Either -gnatc is enabled or the expression is ok\n+\n+         if Operating_Mode < Generate_Code\n+           or else Eval_Static_Predicate_Check (Expr, Typ)\n+         then\n+            null;\n+\n+         --  The expression is prohibited by the static predicate\n+\n+         else\n+            Error_Msg_NE\n+              (\"?static expression fails static predicate check on &\",\n+               Expr, Typ);\n+         end if;\n+      end if;\n+   end Check_Expression_Against_Static_Predicate;\n+\n+   --------------------------\n+   -- Check_Fully_Declared --\n+   --------------------------\n+\n+   procedure Check_Fully_Declared (T : Entity_Id; N : Node_Id) is\n+   begin\n+      if Ekind (T) = E_Incomplete_Type then\n+\n+         --  Ada 2005 (AI-50217): If the type is available through a limited\n+         --  with_clause, verify that its full view has been analyzed.\n+\n+         if From_With_Type (T)\n+           and then Present (Non_Limited_View (T))\n+           and then Ekind (Non_Limited_View (T)) /= E_Incomplete_Type\n+         then\n+            --  The non-limited view is fully declared\n+            null;\n+\n+         else\n+            Error_Msg_NE\n+              (\"premature usage of incomplete}\", N, First_Subtype (T));\n+         end if;\n+\n+      --  Need comments for these tests ???\n+\n+      elsif Has_Private_Component (T)\n+        and then not Is_Generic_Type (Root_Type (T))\n+        and then not In_Spec_Expression\n+      then\n+         --  Special case: if T is the anonymous type created for a single\n+         --  task or protected object, use the name of the source object.\n+\n+         if Is_Concurrent_Type (T)\n+           and then not Comes_From_Source (T)\n+           and then Nkind (N) = N_Object_Declaration\n+         then\n+            Error_Msg_NE (\"type of& has incomplete component\", N,\n+              Defining_Identifier (N));\n+\n+         else\n+            Error_Msg_NE\n+              (\"premature usage of incomplete}\", N, First_Subtype (T));\n+         end if;\n+      end if;\n+   end Check_Fully_Declared;\n+\n    -------------------------------------\n    -- Check_Function_Writable_Actuals --\n    -------------------------------------\n@@ -2016,79 +2124,6 @@ package body Sem_Util is\n       end loop Outer;\n    end Check_Later_Vs_Basic_Declarations;\n \n-   -----------------------------------------\n-   -- Check_Dynamically_Tagged_Expression --\n-   -----------------------------------------\n-\n-   procedure Check_Dynamically_Tagged_Expression\n-     (Expr        : Node_Id;\n-      Typ         : Entity_Id;\n-      Related_Nod : Node_Id)\n-   is\n-   begin\n-      pragma Assert (Is_Tagged_Type (Typ));\n-\n-      --  In order to avoid spurious errors when analyzing the expanded code,\n-      --  this check is done only for nodes that come from source and for\n-      --  actuals of generic instantiations.\n-\n-      if (Comes_From_Source (Related_Nod)\n-           or else In_Generic_Actual (Expr))\n-        and then (Is_Class_Wide_Type (Etype (Expr))\n-                   or else Is_Dynamically_Tagged (Expr))\n-        and then Is_Tagged_Type (Typ)\n-        and then not Is_Class_Wide_Type (Typ)\n-      then\n-         Error_Msg_N (\"dynamically tagged expression not allowed!\", Expr);\n-      end if;\n-   end Check_Dynamically_Tagged_Expression;\n-\n-   --------------------------\n-   -- Check_Fully_Declared --\n-   --------------------------\n-\n-   procedure Check_Fully_Declared (T : Entity_Id; N : Node_Id) is\n-   begin\n-      if Ekind (T) = E_Incomplete_Type then\n-\n-         --  Ada 2005 (AI-50217): If the type is available through a limited\n-         --  with_clause, verify that its full view has been analyzed.\n-\n-         if From_With_Type (T)\n-           and then Present (Non_Limited_View (T))\n-           and then Ekind (Non_Limited_View (T)) /= E_Incomplete_Type\n-         then\n-            --  The non-limited view is fully declared\n-            null;\n-\n-         else\n-            Error_Msg_NE\n-              (\"premature usage of incomplete}\", N, First_Subtype (T));\n-         end if;\n-\n-      --  Need comments for these tests ???\n-\n-      elsif Has_Private_Component (T)\n-        and then not Is_Generic_Type (Root_Type (T))\n-        and then not In_Spec_Expression\n-      then\n-         --  Special case: if T is the anonymous type created for a single\n-         --  task or protected object, use the name of the source object.\n-\n-         if Is_Concurrent_Type (T)\n-           and then not Comes_From_Source (T)\n-           and then Nkind (N) = N_Object_Declaration\n-         then\n-            Error_Msg_NE (\"type of& has incomplete component\", N,\n-              Defining_Identifier (N));\n-\n-         else\n-            Error_Msg_NE\n-              (\"premature usage of incomplete}\", N, First_Subtype (T));\n-         end if;\n-      end if;\n-   end Check_Fully_Declared;\n-\n    -------------------------\n    -- Check_Nested_Access --\n    -------------------------"}, {"sha": "b5d1ed355c432f1b79c038957752d7908e64b95a", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f197d2f29355314ccbf0a816f3ad20c20b506bef/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f197d2f29355314ccbf0a816f3ad20c20b506bef/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f197d2f29355314ccbf0a816f3ad20c20b506bef", "patch": "@@ -191,6 +191,14 @@ package Sem_Util is\n       Related_Nod : Node_Id);\n    --  Check wrong use of dynamically tagged expression\n \n+   procedure Check_Expression_Against_Static_Predicate\n+     (Expr : Node_Id;\n+      Typ  : Entity_Id);\n+   --  Determine whether an arbitrary expression satisfies the static predicate\n+   --  of a type. The routine does nothing if Expr is non-static or Typ lacks a\n+   --  static predicate, otherwise it may emit a warning if the expression is\n+   --  prohibited by the predicate.\n+\n    procedure Check_Fully_Declared (T : Entity_Id; N : Node_Id);\n    --  Verify that the full declaration of type T has been seen. If not, place\n    --  error message on node N. Used in object declarations, type conversions"}]}