{"sha": "02b47899e14982d742b91de30d3129b2719c59d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJiNDc4OTllMTQ5ODJkNzQyYjkxZGUzMGQzMTI5YjI3MTljNTlkMA==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2008-12-18T13:38:39Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-12-18T13:38:39Z"}, "message": "re PR rtl-optimization/37922 (code generation error)\n\n2008-12-18  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\tPR rtl-optimization/37922\n\t* dse.c (bb_info): Added regs_live field.\n\t(look_for_hardregs): New function.\n\t(replace_read): Added regs_live parameter and code to check that\n\tshift sequence does not clobber live hardregs.\n\t(check_mem_read_rtx): Added parameter to replace_read.\n\t(dse_step1): Added regs_live bitmap and initialize it.\n\t(rest_of_handle_dse): Added DF_NOTES problem and earlier call to\n\tdf_analyze.\n\t* df-problems.c Renamed to \n\tdf_simulate_initialize_backwards.\n\t(df_simulate_one_insn): Renamed to\n\tdf_simulate_one_insn_backwards.\n\t(df_simulate_artificial_refs_at_top): Renamed to \n\tdf_simulate_finalize_backwards.\n\t(df_simulate_initialized_forwards,\n\tdf_simulate_one_insn_forwards,\n\tdf_simulate_finalize_backwards): New functions.\n\t* df.h (df_simulate_artificial_refs_at_end): Renamed to \n\tdf_simulate_initialize_backwards.\n\t(df_simulate_one_insn): Renamed to\n\tdf_simulate_one_insn_backwards.\n\t(df_simulate_artificial_refs_at_top): Renamed to \n\tdf_simulate_finalize_backwards.\n\t(df_simulate_initialized_forwards,\n\tdf_simulate_one_insn_forwards,\n\tdf_simulate_finalize_backwards): New functions.\n\t* ra-conflict.c (global_conflicts): Renamed\n\tdf_simulate_artificial_refs_at_end to\n\tdf_simulate_initialize_backwards.\n\t* sel-sched.c (propagate_lv_set): Renamed df_simulate_one_insn to\n\tdf_simulate_one_insn_backwards.\n\t* ifcvt.c (dead_or_predicable): Renamed\n\tdf_simulate_artificial_refs_at_end to\n\tdf_simulate_initialize_backwards. Renamed df_simulate_one_insn to\n\tdf_simulate_one_insn_backwards.\n\t* recog.c (peephole2_optimize): Ditto.\n\t* rtl-factoring (collect_pattern_seqs, clear_regs_live_in_seq): Ditto.\n\n2008-12-18  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\tPR rtl-optimization/37922\n\t* g++.dg/torture/pr37922.C: New test.\n\nFrom-SVN: r142809", "tree": {"sha": "c64daed76d865d25eb4ef4c4e020e357ce13e831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c64daed76d865d25eb4ef4c4e020e357ce13e831"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02b47899e14982d742b91de30d3129b2719c59d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02b47899e14982d742b91de30d3129b2719c59d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02b47899e14982d742b91de30d3129b2719c59d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02b47899e14982d742b91de30d3129b2719c59d0/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fb5bc08bb353a574a011eaf5b7ae874672e4b289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb5bc08bb353a574a011eaf5b7ae874672e4b289", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb5bc08bb353a574a011eaf5b7ae874672e4b289"}], "stats": {"total": 778, "additions": 743, "deletions": 35}, "files": [{"sha": "7862b105683d80becac789114b61676ef9780fa1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02b47899e14982d742b91de30d3129b2719c59d0", "patch": "@@ -1,3 +1,44 @@\n+2008-12-18  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\tPR rtl-optimization/37922\n+\t* dse.c (bb_info): Added regs_live field.\n+\t(look_for_hardregs): New function.\n+\t(replace_read): Added regs_live parameter and code to check that\n+\tshift sequence does not clobber live hardregs.\n+\t(check_mem_read_rtx): Added parameter to replace_read.\n+\t(dse_step1): Added regs_live bitmap and initialize it.\n+\t(rest_of_handle_dse): Added DF_NOTES problem and earlier call to\n+\tdf_analyze.\n+\t* df-problems.c Renamed to \n+\tdf_simulate_initialize_backwards.\n+\t(df_simulate_one_insn): Renamed to\n+\tdf_simulate_one_insn_backwards.\n+\t(df_simulate_artificial_refs_at_top): Renamed to \n+\tdf_simulate_finalize_backwards.\n+\t(df_simulate_initialized_forwards,\n+\tdf_simulate_one_insn_forwards,\n+\tdf_simulate_finalize_backwards): New functions.\n+\t* df.h (df_simulate_artificial_refs_at_end): Renamed to \n+\tdf_simulate_initialize_backwards.\n+\t(df_simulate_one_insn): Renamed to\n+\tdf_simulate_one_insn_backwards.\n+\t(df_simulate_artificial_refs_at_top): Renamed to \n+\tdf_simulate_finalize_backwards.\n+\t(df_simulate_initialized_forwards,\n+\tdf_simulate_one_insn_forwards,\n+\tdf_simulate_finalize_backwards): New functions.\n+\t* ra-conflict.c (global_conflicts): Renamed\n+\tdf_simulate_artificial_refs_at_end to\n+\tdf_simulate_initialize_backwards.\n+\t* sel-sched.c (propagate_lv_set): Renamed df_simulate_one_insn to\n+\tdf_simulate_one_insn_backwards.\n+\t* ifcvt.c (dead_or_predicable): Renamed\n+\tdf_simulate_artificial_refs_at_end to\n+\tdf_simulate_initialize_backwards. Renamed df_simulate_one_insn to\n+\tdf_simulate_one_insn_backwards.\n+\t* recog.c (peephole2_optimize): Ditto.\n+\t* rtl-factoring (collect_pattern_seqs, clear_regs_live_in_seq): Ditto.\n+\n 2008-12-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/38533"}, {"sha": "1adea75570df9b1cd17972be68a0f9887cb80366", "filename": "gcc/dce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=02b47899e14982d742b91de30d3129b2719c59d0", "patch": "@@ -607,7 +607,7 @@ dce_process_block (basic_block bb, bool redo_out, bitmap au)\n \n   bitmap_copy (local_live, DF_LR_OUT (bb));\n \n-  df_simulate_artificial_refs_at_end (bb, local_live);\n+  df_simulate_initialize_backwards (bb, local_live);\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n     if (INSN_P (insn))\n@@ -636,7 +636,7 @@ dce_process_block (basic_block bb, bool redo_out, bitmap au)\n \t  df_simulate_uses (insn, local_live);\n       }\n   \n-  df_simulate_artificial_refs_at_top (bb, local_live);\n+  df_simulate_finalize_backwards (bb, local_live);\n \n   block_changed = !bitmap_equal_p (local_live, DF_LR_IN (bb));\n   if (block_changed)"}, {"sha": "829698ba1b3760a910e53a65333439c7b2b448f4", "filename": "gcc/df-problems.c", "status": "modified", "additions": 97, "deletions": 13, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=02b47899e14982d742b91de30d3129b2719c59d0", "patch": "@@ -3759,24 +3759,19 @@ df_simulate_fixup_sets (basic_block bb, bitmap live)\n    The following three functions are used only for BACKWARDS scanning:\n    i.e. they process the defs before the uses.\n \n-   df_simulate_artificial_refs_at_end should be called first with a\n+   df_simulate_initialize_backwards should be called first with a\n    bitvector copyied from the DF_LIVE_OUT or DF_LR_OUT.  Then\n-   df_simulate_one_insn should be called for each insn in the block,\n-   starting with the last on.  Finally,\n-   df_simulate_artificial_refs_at_top can be called to get a new value\n+   df_simulate_one_insn_backwards should be called for each insn in\n+   the block, starting with the last on.  Finally,\n+   df_simulate_finalize_backwards can be called to get a new value\n    of the sets at the top of the block (this is rarely used).\n-\n-   It would be not be difficult to define a similar set of functions\n-   that work in the forwards direction.  In that case the functions\n-   would ignore the use sets and look for the REG_DEAD and REG_UNUSED\n-   notes.\n-----------------------------------------------------------------------------*/\n+   ----------------------------------------------------------------------------*/\n \n /* Apply the artificial uses and defs at the end of BB in a backwards\n    direction.  */\n \n void \n-df_simulate_artificial_refs_at_end (basic_block bb, bitmap live)\n+df_simulate_initialize_backwards (basic_block bb, bitmap live)\n {\n   df_ref *def_rec;\n   df_ref *use_rec;\n@@ -3801,7 +3796,7 @@ df_simulate_artificial_refs_at_end (basic_block bb, bitmap live)\n /* Simulate the backwards effects of INSN on the bitmap LIVE.  */\n \n void \n-df_simulate_one_insn (basic_block bb, rtx insn, bitmap live)\n+df_simulate_one_insn_backwards (basic_block bb, rtx insn, bitmap live)\n {\n   if (! INSN_P (insn))\n     return;\t\n@@ -3816,7 +3811,7 @@ df_simulate_one_insn (basic_block bb, rtx insn, bitmap live)\n    direction.  */\n \n void \n-df_simulate_artificial_refs_at_top (basic_block bb, bitmap live)\n+df_simulate_finalize_backwards (basic_block bb, bitmap live)\n {\n   df_ref *def_rec;\n #ifdef EH_USES\n@@ -3840,3 +3835,92 @@ df_simulate_artificial_refs_at_top (basic_block bb, bitmap live)\n     }\n #endif\n }\n+/*----------------------------------------------------------------------------\n+   The following three functions are used only for FORWARDS scanning:\n+   i.e. they process the defs and the REG_DEAD and REG_UNUSED notes.\n+   Thus it is important to add the DF_NOTES problem to the stack of \n+   problems computed before using these functions.\n+\n+   df_simulate_initialize_forwards should be called first with a\n+   bitvector copyied from the DF_LIVE_IN or DF_LR_IN.  Then\n+   df_simulate_one_insn_forwards should be called for each insn in\n+   the block, starting with the last on.  Finally,\n+   df_simulate_finalize_forwards can be called to get a new value\n+   of the sets at the bottom of the block (this is rarely used).\n+   ----------------------------------------------------------------------------*/\n+\n+/* Apply the artificial uses and defs at the top of BB in a backwards\n+   direction.  */\n+\n+void \n+df_simulate_initialize_forwards (basic_block bb, bitmap live)\n+{\n+  df_ref *def_rec;\n+  int bb_index = bb->index;\n+  \n+  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n+    {\n+      df_ref def = *def_rec;\n+      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+\tbitmap_clear_bit (live, DF_REF_REGNO (def));\n+    }\n+}\n+\n+/* Simulate the backwards effects of INSN on the bitmap LIVE.  */\n+\n+void \n+df_simulate_one_insn_forwards (basic_block bb, rtx insn, bitmap live)\n+{\n+  rtx link;\n+  if (! INSN_P (insn))\n+    return;\t\n+\n+  /* Make sure that the DF_NOTES really is an active df problem.  */ \n+  gcc_assert (df_note);\n+\n+  df_simulate_defs (insn, live);\n+\n+  /* Clear all of the registers that go dead.  */\n+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+    {\n+      switch (REG_NOTE_KIND (link))\n+\tcase REG_DEAD:\n+\tcase REG_UNUSED:\n+\t{\n+\t  rtx reg = XEXP (link, 0);\n+\t  int regno = REGNO (reg);\n+\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t    {\n+\t      int n = hard_regno_nregs[regno][GET_MODE (reg)];\n+\t      while (--n >= 0)\n+\t\tbitmap_clear_bit (live, regno + n);\n+\t    }\n+\t  else \n+\t    bitmap_clear_bit (live, regno);\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  df_simulate_fixup_sets (bb, live);\n+}\n+\n+\n+/* Apply the artificial uses and defs at the end of BB in a backwards\n+   direction.  */\n+\n+void \n+df_simulate_finalize_forwards (basic_block bb, bitmap live)\n+{\n+  df_ref *def_rec;\n+  int bb_index = bb->index;\n+  \n+  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n+    {\n+      df_ref def = *def_rec;\n+      if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n+\tbitmap_clear_bit (live, DF_REF_REGNO (def));\n+    }\n+}\n+\n+"}, {"sha": "5cd5dfccb25e2c6d9cfa3b5a0c92e590387b93ff", "filename": "gcc/df.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=02b47899e14982d742b91de30d3129b2719c59d0", "patch": "@@ -959,9 +959,12 @@ extern void df_note_add_problem (void);\n extern void df_simulate_find_defs (rtx, bitmap);\n extern void df_simulate_defs (rtx, bitmap);\n extern void df_simulate_uses (rtx, bitmap);\n-extern void df_simulate_artificial_refs_at_end (basic_block, bitmap);\n-extern void df_simulate_one_insn (basic_block, rtx, bitmap);\n-extern void df_simulate_artificial_refs_at_top (basic_block, bitmap);\n+extern void df_simulate_initialize_backwards (basic_block, bitmap);\n+extern void df_simulate_one_insn_backwards (basic_block, rtx, bitmap);\n+extern void df_simulate_finalize_backwards (basic_block, bitmap);\n+extern void df_simulate_initialize_forwards (basic_block, bitmap);\n+extern void df_simulate_one_insn_forwards (basic_block, rtx, bitmap);\n+extern void df_simulate_finalize_forwards (basic_block, bitmap);\n \n /* Functions defined in df-scan.c.  */\n "}, {"sha": "3269c7adaff6afc871884c32199e9344eaf8bbd7", "filename": "gcc/dse.c", "status": "modified", "additions": 78, "deletions": 5, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=02b47899e14982d742b91de30d3129b2719c59d0", "patch": "@@ -374,6 +374,10 @@ struct bb_info\n      operations.  */\n   bool apply_wild_read;\n \n+  /* The following 4 bitvectors hold information about which positions\n+     of which stores are live or dead.  They are indexed by\n+     get_bitmap_index.  */\n+\n   /* The set of store positions that exist in this block before a wild read.  */\n   bitmap gen;\n   \n@@ -401,6 +405,14 @@ struct bb_info\n      just initializes the vector from one of the out sets of the\n      successors of the block.  */\n   bitmap out;\n+\n+  /* The following bitvector is indexed by the reg number.  It\n+     contains the set of regs that are live at the current instruction\n+     being processed.  While it contains info for all of the\n+     registers, only the pseudos are actually examined.  It is used to\n+     assure that shift sequences that are inserted do not accidently\n+     clobber live hard regs.  */\n+  bitmap regs_live;\n };\n \n typedef struct bb_info *bb_info_t;\n@@ -1533,6 +1545,25 @@ find_shift_sequence (int access_size,\n }\n \n \n+/* Call back for note_stores to find the hard regs set or clobbered by\n+   insn.  Data is a bitmap of the hardregs set so far.  */\n+\n+static void\n+look_for_hardregs (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n+{\n+  bitmap regs_set = (bitmap) data;\n+\n+  if (REG_P (x)\n+      && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+    {\n+      int regno = REGNO (x);\n+      int n = hard_regno_nregs[regno][GET_MODE (x)];\n+      while (--n >= 0)\n+\tbitmap_set_bit (regs_set, regno + n);\n+    }\n+}\n+\n+\n /* Take a sequence of:\n      A <- r1\n      ...\n@@ -1566,13 +1597,13 @@ find_shift_sequence (int access_size,\n \n static bool\n replace_read (store_info_t store_info, insn_info_t store_insn, \n-\t      read_info_t read_info, insn_info_t read_insn, rtx *loc)\n+\t      read_info_t read_info, insn_info_t read_insn, rtx *loc, bitmap regs_live)\n {\n   enum machine_mode store_mode = GET_MODE (store_info->mem);\n   enum machine_mode read_mode = GET_MODE (read_info->mem);\n   int shift;\n   int access_size; /* In bytes.  */\n-  rtx insns, read_reg;\n+  rtx insns, this_insn, read_reg;\n \n   if (!dbg_cnt (dse))\n     return false;\n@@ -1624,6 +1655,34 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n   insns = get_insns ();\n   end_sequence ();\n \n+  if (insns != NULL_RTX)\n+    {\n+      /* Now we have to scan the set of new instructions to see if the\n+\t sequence contains and sets of hardregs that happened to be\n+\t live at this point.  For instance, this can happen if one of\n+\t the insns sets the CC and the CC happened to be live at that\n+\t point.  This does occasionally happen, see PR 37922.  */\n+      bitmap regs_set = BITMAP_ALLOC (NULL);\n+\n+      for (this_insn = insns; this_insn != NULL_RTX; this_insn = NEXT_INSN (this_insn))\n+\tnote_stores (PATTERN (this_insn), look_for_hardregs, regs_set);\n+      \n+      bitmap_and_into (regs_set, regs_live);\n+      if (!bitmap_empty_p (regs_set))\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \n+\t\t       \"abandoning replacement because sequence clobbers live hardregs:\");\n+\t      df_print_regset (dump_file, regs_set);\n+\t    }\n+\t  \n+\t  BITMAP_FREE (regs_set);\n+\t  return false;\n+\t}\n+      BITMAP_FREE (regs_set);\n+    }\n+\n   if (validate_change (read_insn->insn, loc, read_reg, 0))\n     {\n       deferred_change_t deferred_change =\n@@ -1842,7 +1901,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \n \t\t      if ((store_info->positions_needed & mask) == mask\n \t\t\t  && replace_read (store_info, i_ptr, \n-\t\t\t\t\t   read_info, insn_info, loc))\n+\t\t\t\t\t   read_info, insn_info, loc, bb_info->regs_live))\n \t\t\treturn 0;\n \t\t    }\n \t\t  /* The bases are the same, just see if the offsets\n@@ -1911,7 +1970,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \n \t      if ((store_info->positions_needed & mask) == mask\n \t\t  && replace_read (store_info, i_ptr, \n-\t\t\t\t   read_info, insn_info, loc))\n+\t\t\t\t   read_info, insn_info, loc, bb_info->regs_live))\n \t\treturn 0;\n \t    }\n \n@@ -2139,7 +2198,8 @@ static void\n dse_step1 (void)\n {\n   basic_block bb;\n-\n+  bitmap regs_live = BITMAP_ALLOC (NULL);\n+  \n   cselib_init (false);\n   all_blocks = BITMAP_ALLOC (NULL);\n   bitmap_set_bit (all_blocks, ENTRY_BLOCK);\n@@ -2152,6 +2212,10 @@ dse_step1 (void)\n \n       memset (bb_info, 0, sizeof (struct bb_info));\n       bitmap_set_bit (all_blocks, bb->index);\n+      bb_info->regs_live = regs_live;\n+\n+      bitmap_copy (regs_live, DF_LR_IN (bb));\n+      df_simulate_initialize_forwards (bb, regs_live);\n \n       bb_table[bb->index] = bb_info;\n       cselib_discard_hook = remove_useless_values;\n@@ -2172,6 +2236,8 @@ dse_step1 (void)\n \t      if (INSN_P (insn))\n \t\tscan_insn (bb_info, insn);\n \t      cselib_process_insn (insn);\n+\t      if (INSN_P (insn))\n+\t\tdf_simulate_one_insn_forwards (bb, insn, regs_live);\n \t    }\n \t  \n \t  /* This is something of a hack, because the global algorithm\n@@ -2238,8 +2304,10 @@ dse_step1 (void)\n \n \t  free_alloc_pool (cse_store_info_pool);\n \t}\n+      bb_info->regs_live = NULL;\n     }\n \n+  BITMAP_FREE (regs_live);\n   cselib_finish ();\n   htab_empty (rtx_group_table);\n }\n@@ -3239,6 +3307,11 @@ rest_of_handle_dse (void)\n \n   df_set_flags (DF_DEFER_INSN_RESCAN);\n \n+  /* Need the notes since we must track live hardregs in the forwards\n+     direction.  */\n+  df_note_add_problem ();\n+  df_analyze ();\n+\n   dse_step0 ();\n   dse_step1 ();\n   dse_step2_init ();"}, {"sha": "dc5788d5440bb1817dc8bb2dd82261855a443857", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=02b47899e14982d742b91de30d3129b2719c59d0", "patch": "@@ -3950,13 +3950,13 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       /* The loop below takes the set of live registers \n          after JUMP, and calculates the live set before EARLIEST. */\n       bitmap_copy (test_live, df_get_live_in (other_bb));\n-      df_simulate_artificial_refs_at_end (test_bb, test_live);\n+      df_simulate_initialize_backwards (test_bb, test_live);\n       for (insn = jump; ; insn = prev)\n \t{\n \t  if (INSN_P (insn))\n \t    {\n \t      df_simulate_find_defs (insn, test_set);\n-\t      df_simulate_one_insn (test_bb, insn, test_live);\n+\t      df_simulate_one_insn_backwards (test_bb, insn, test_live);\n \t    }\n \t  prev = PREV_INSN (insn);\n \t  if (insn == earliest)"}, {"sha": "eb732861442452c4c9c18b916c2339da47e88b5f", "filename": "gcc/ra-conflict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fra-conflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fra-conflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-conflict.c?ref=02b47899e14982d742b91de30d3129b2719c59d0", "patch": "@@ -774,7 +774,7 @@ global_conflicts (void)\n       bitmap_iterator bi;\n \n       bitmap_copy (live, DF_LIVE_OUT (bb));\n-      df_simulate_artificial_refs_at_end (bb, live);\n+      df_simulate_initialize_backwards (bb, live);\n \n       sparseset_clear (allocnos_live);\n       memset (live_subregs_used, 0, max_allocno * sizeof (int));"}, {"sha": "0e2dd1bd60d7fdc5bf8b2d1193176fdc1be2681c", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=02b47899e14982d742b91de30d3129b2719c59d0", "patch": "@@ -3039,7 +3039,7 @@ peephole2_optimize (void)\n \n       /* Start up propagation.  */\n       bitmap_copy (live, DF_LR_OUT (bb));\n-      df_simulate_artificial_refs_at_end (bb, live);\n+      df_simulate_initialize_backwards (bb, live);\n       bitmap_copy (peep2_insn_data[MAX_INSNS_PER_PEEP2].live_before, live);\n \n       for (insn = BB_END (bb); ; insn = prev)\n@@ -3059,7 +3059,7 @@ peephole2_optimize (void)\n \t\t  && peep2_insn_data[peep2_current].insn == NULL_RTX)\n \t\tpeep2_current_count++;\n \t      peep2_insn_data[peep2_current].insn = insn;\n-\t      df_simulate_one_insn (bb, insn, live);\n+\t      df_simulate_one_insn_backwards (bb, insn, live);\n \t      COPY_REG_SET (peep2_insn_data[peep2_current].live_before, live);\n \n \t      if (RTX_FRAME_RELATED_P (insn))\n@@ -3218,7 +3218,7 @@ peephole2_optimize (void)\n \t\t\t    peep2_current_count++;\n \t\t\t  peep2_insn_data[i].insn = x;\n \t\t\t  df_insn_rescan (x);\n-\t\t\t  df_simulate_one_insn (bb, x, live);\n+\t\t\t  df_simulate_one_insn_backwards (bb, x, live);\n \t\t\t  bitmap_copy (peep2_insn_data[i].live_before, live);\n \t\t\t}\n \t\t      x = PREV_INSN (x);"}, {"sha": "4c879691e9f32f2d89340e8ef16599e7034ade5a", "filename": "gcc/rtl-factoring.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Frtl-factoring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Frtl-factoring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-factoring.c?ref=02b47899e14982d742b91de30d3129b2719c59d0", "patch": "@@ -464,7 +464,7 @@ collect_pattern_seqs (void)\n     /* Initialize liveness propagation.  */\n     INIT_REG_SET (&live);\n     bitmap_copy (&live, DF_LR_OUT (bb));\n-    df_simulate_artificial_refs_at_end (bb, &live);\n+    df_simulate_initialize_backwards (bb, &live);\n \n     /* Propagate liveness info and mark insns where a stack reg is live.  */\n     insn = BB_END (bb);\n@@ -486,7 +486,7 @@ collect_pattern_seqs (void)\n \t  }\n \tif (insn == BB_HEAD (bb))\n \t  break;\n-\tdf_simulate_one_insn (bb, insn, &live);\n+\tdf_simulate_one_insn_backwards (bb, insn, &live);\n \tinsn = prev;\n       }\n \n@@ -572,11 +572,11 @@ clear_regs_live_in_seq (HARD_REG_SET * regs, rtx insn, int length)\n   bb = BLOCK_FOR_INSN (insn);\n   INIT_REG_SET (&live);\n   bitmap_copy (&live, DF_LR_OUT (bb));\n-  df_simulate_artificial_refs_at_end (bb, &live);\n+  df_simulate_initialize_backwards (bb, &live);\n \n   /* Propagate until INSN if found.  */\n   for (x = BB_END (bb); x != insn; x = PREV_INSN (x))\n-    df_simulate_one_insn (bb, x, &live);\n+    df_simulate_one_insn_backwards (bb, x, &live);\n \n   /* Clear registers live after INSN.  */\n   renumbered_reg_set_to_hard_reg_set (&hlive, &live);\n@@ -586,7 +586,7 @@ clear_regs_live_in_seq (HARD_REG_SET * regs, rtx insn, int length)\n   for (i = 0; i < length;)\n     {\n       rtx prev = PREV_INSN (x);\n-      df_simulate_one_insn (bb, x, &live);\n+      df_simulate_one_insn_backwards (bb, x, &live);\n \n       if (INSN_P (x))\n         {"}, {"sha": "c98a52162dce2d54591a6ac20f5a1de12fdc783c", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=02b47899e14982d742b91de30d3129b2719c59d0", "patch": "@@ -2947,7 +2947,7 @@ propagate_lv_set (regset lv, insn_t insn)\n   if (INSN_NOP_P (insn))\n     return;\n \n-  df_simulate_one_insn (BLOCK_FOR_INSN (insn), insn, lv);\n+  df_simulate_one_insn_backwards (BLOCK_FOR_INSN (insn), insn, lv);\n }\n \n /* Return livness set at the end of BB.  */"}, {"sha": "83063037de9dadc699e9088fed5797511b0c607f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=02b47899e14982d742b91de30d3129b2719c59d0", "patch": "@@ -1,3 +1,8 @@\n+2008-12-18  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\tPR rtl-optimization/37922\n+\t* g++.dg/torture/pr37922.C: New test.\n+\n 2008-12-18  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/31822"}, {"sha": "a7d05ab0fe87d59b5c037c1fb5be9b22edb43af4", "filename": "gcc/testsuite/g++.dg/torture/pr37922.C", "status": "added", "additions": 502, "deletions": 0, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr37922.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b47899e14982d742b91de30d3129b2719c59d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr37922.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr37922.C?ref=02b47899e14982d742b91de30d3129b2719c59d0", "patch": "@@ -0,0 +1,502 @@\n+// { dg-do run }\n+// { dg-options \"-fpic\" { target fpic } }\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+template <typename NumType>\n+inline\n+NumType\n+absolute(NumType const& x)\n+{\n+  if (x < NumType(0)) return -x;\n+  return x;\n+}\n+\n+class trivial_accessor\n+{\n+  public:\n+    typedef size_t index_type;\n+    struct index_value_type {};\n+\n+    trivial_accessor() : size_(0) {}\n+\n+    trivial_accessor(size_t const& n) : size_(n) {}\n+\n+    size_t size_1d() const { return size_; }\n+\n+  protected:\n+    size_t size_;\n+};\n+\n+namespace N0\n+{\n+  template <typename ElementType,\n+            typename AccessorType = trivial_accessor>\n+  class const_ref\n+  {\n+    public:\n+      typedef ElementType value_type;\n+      typedef size_t size_type;\n+\n+      typedef AccessorType accessor_type;\n+      typedef typename accessor_type::index_type index_type;\n+      typedef typename accessor_type::index_value_type index_value_type;\n+\n+      const_ref() {}\n+\n+      const_ref(const ElementType* begin, accessor_type const& accessor)\n+      : begin_(begin), accessor_(accessor)\n+      {\n+        init();\n+      }\n+\n+      const_ref(const ElementType* begin, index_value_type const& n0)\n+      : begin_(begin), accessor_(n0)\n+      {\n+        init();\n+      }\n+\n+      const_ref(const ElementType* begin, index_value_type const& n0,\n+                                          index_value_type const& n1)\n+      : begin_(begin), accessor_(n0, n1)\n+      {\n+        init();\n+      }\n+\n+      const_ref(const ElementType* begin, index_value_type const& n0,\n+                                          index_value_type const& n1,\n+                                          index_value_type const& n2)\n+      : begin_(begin), accessor_(n0, n1, n2)\n+      {\n+        init();\n+      }\n+\n+      accessor_type const& accessor() const { return accessor_; }\n+      size_type size() const { return size_; }\n+\n+      const ElementType* begin() const { return begin_; }\n+      const ElementType* end() const { return end_; }\n+\n+      ElementType const&\n+      operator[](size_type i) const { return begin_[i]; }\n+\n+      const_ref<ElementType>\n+      as_1d() const\n+      {\n+        return const_ref<ElementType>(begin_, size_);\n+      }\n+\n+    protected:\n+      void\n+      init()\n+      {\n+        size_ = accessor_.size_1d();\n+        end_ = begin_ + size_;\n+      }\n+\n+      const ElementType* begin_;\n+      accessor_type accessor_;\n+      size_type size_;\n+      const ElementType* end_;\n+  };\n+}\n+\n+template <typename ElementType,\n+          typename AccessorType = trivial_accessor>\n+class ref : public N0::const_ref<ElementType, AccessorType>\n+{\n+  public:\n+    typedef ElementType value_type;\n+    typedef size_t size_type;\n+\n+    typedef N0::const_ref<ElementType, AccessorType> base_class;\n+    typedef AccessorType accessor_type;\n+    typedef typename accessor_type::index_type index_type;\n+\n+    ref() {}\n+\n+    ElementType*\n+    begin() const { return const_cast<ElementType*>(this->begin_); }\n+\n+    ElementType*\n+    end() const { return const_cast<ElementType*>(this->end_); }\n+\n+    ElementType&\n+    operator[](size_type i) const { return begin()[i]; }\n+};\n+\n+namespace N1 {\n+  template <typename ElementType, size_t N>\n+  class tiny_plain\n+  {\n+    public:\n+      typedef ElementType value_type;\n+      typedef size_t size_type;\n+\n+      static const size_t fixed_size=N;\n+\n+      ElementType elems[N];\n+\n+      tiny_plain() {}\n+\n+      static size_type size() { return N; }\n+\n+      ElementType* begin() { return elems; }\n+      const ElementType* begin() const { return elems; }\n+      ElementType* end() { return elems+N; }\n+      const ElementType* end() const { return elems+N; }\n+      ElementType& operator[](size_type i) { return elems[i]; }\n+      ElementType const& operator[](size_type i) const { return elems[i]; }\n+  };\n+\n+  template <typename ElementType, size_t N>\n+  class tiny : public tiny_plain<ElementType, N>\n+  {\n+    public:\n+      typedef ElementType value_type;\n+      typedef size_t size_type;\n+\n+      typedef tiny_plain<ElementType, N> base_class;\n+\n+      tiny() {}\n+  };\n+}\n+\n+template <typename NumType>\n+class mat3 : public N1::tiny_plain<NumType, 9>\n+{\n+  public:\n+    typedef typename N1::tiny_plain<NumType, 9> base_type;\n+\n+    mat3() {}\n+    mat3(NumType const& e00, NumType const& e01, NumType const& e02,\n+         NumType const& e10, NumType const& e11, NumType const& e12,\n+         NumType const& e20, NumType const& e21, NumType const& e22)\n+      : base_type(e00, e01, e02, e10, e11, e12, e20, e21, e22)\n+    {}\n+    mat3(base_type const& a)\n+      : base_type(a)\n+    {}\n+\n+    NumType const&\n+    operator()(size_t r, size_t c) const\n+    {\n+      return this->elems[r * 3 + c];\n+    }\n+    NumType&\n+    operator()(size_t r, size_t c)\n+    {\n+      return this->elems[r * 3 + c];\n+    }\n+\n+    NumType\n+    trace() const\n+    {\n+      mat3 const& m = *this;\n+      return m[0] + m[4] + m[8];\n+    }\n+\n+    NumType\n+    determinant() const\n+    {\n+      mat3 const& m = *this;\n+      return   m[0] * (m[4] * m[8] - m[5] * m[7])\n+             - m[1] * (m[3] * m[8] - m[5] * m[6])\n+             + m[2] * (m[3] * m[7] - m[4] * m[6]);\n+    }\n+};\n+\n+template <typename NumType>\n+inline\n+mat3<NumType>\n+operator-(mat3<NumType> const& v)\n+{\n+  mat3<NumType> result;\n+  for(size_t i=0;i<9;i++) {\n+    result[i] = -v[i];\n+  }\n+  return result;\n+}\n+\n+class mat_grid : public N1::tiny<size_t, 2>\n+{\n+  public:\n+    typedef N1::tiny<size_t, 2> index_type;\n+    typedef index_type::value_type index_value_type;\n+\n+    mat_grid() { this->elems[0]=0; this->elems[1]=0; }\n+\n+    mat_grid(index_type const& n) : index_type(n) {}\n+\n+    mat_grid(index_value_type const& n0, index_value_type const& n1)\n+    { this->elems[0]=n0; this->elems[1]=n1; }\n+\n+    size_t size_1d() const { return elems[0] * elems[1]; }\n+\n+    size_t\n+    operator()(index_value_type const& r, index_value_type const& c) const\n+    {\n+      return r * elems[1] + c;\n+    }\n+};\n+\n+template <typename NumType, typename AccessorType = mat_grid>\n+class mat_const_ref : public N0::const_ref<NumType, AccessorType>\n+{\n+  public:\n+    typedef AccessorType accessor_type;\n+    typedef typename N0::const_ref<NumType, AccessorType> base_type;\n+    typedef typename accessor_type::index_value_type index_value_type;\n+\n+    mat_const_ref() {}\n+\n+    mat_const_ref(const NumType* begin, accessor_type const& grid)\n+    : base_type(begin, grid)\n+    {}\n+\n+    mat_const_ref(const NumType* begin, index_value_type const& n_rows,\n+                                        index_value_type const& n_columns)\n+    : base_type(begin, accessor_type(n_rows, n_columns))\n+    {}\n+\n+    accessor_type\n+    grid() const { return this->accessor(); }\n+\n+    index_value_type const&\n+    n_rows() const { return this->accessor()[0]; }\n+\n+    index_value_type const&\n+    n_columns() const { return this->accessor()[1]; }\n+\n+    NumType const&\n+    operator()(index_value_type const& r, index_value_type const& c) const\n+    {\n+      return this->begin()[this->accessor()(r, c)];\n+    }\n+};\n+\n+template <typename NumType, typename AccessorType = mat_grid>\n+class mat_ref : public mat_const_ref<NumType, AccessorType>\n+{\n+  public:\n+    typedef AccessorType accessor_type;\n+    typedef mat_const_ref<NumType, AccessorType> base_type;\n+    typedef typename accessor_type::index_value_type index_value_type;\n+\n+    mat_ref() {}\n+\n+    mat_ref(NumType* begin, accessor_type const& grid)\n+    : base_type(begin, grid)\n+    {}\n+\n+    mat_ref(NumType* begin, index_value_type n_rows,\n+                            index_value_type n_columns)\n+    : base_type(begin, accessor_type(n_rows, n_columns))\n+    {}\n+\n+    NumType*\n+    begin() const { return const_cast<NumType*>(this->begin_); }\n+\n+    NumType*\n+    end() const { return const_cast<NumType*>(this->end_); }\n+\n+    NumType&\n+    operator[](index_value_type const& i) const { return begin()[i]; }\n+\n+    NumType&\n+    operator()(index_value_type const& r, index_value_type const& c) const\n+    {\n+      return this->begin()[this->accessor()(r, c)];\n+    }\n+};\n+\n+  template <typename AnyType>\n+  inline void\n+  swap(AnyType* a, AnyType* b, size_t n)\n+  {\n+    for(size_t i=0;i<n;i++) {\n+      AnyType t = a[i]; a[i] = b[i]; b[i] = t;\n+    }\n+  }\n+\n+template <typename IntType>\n+size_t\n+form_t(mat_ref<IntType>& m,\n+       mat_ref<IntType> const& t)\n+{\n+  typedef size_t size_t;\n+  size_t mr = m.n_rows();\n+  size_t mc = m.n_columns();\n+  size_t tc = t.n_columns();\n+  if (tc) {\n+  }\n+  size_t i, j;\n+  for (i = j = 0; i < mr && j < mc;) {\n+    size_t k = i; while (k < mr && m(k,j) == 0) k++;\n+    if (k == mr)\n+      j++;\n+    else {\n+      if (i != k) {\n+                swap(&m(i,0), &m(k,0), mc);\n+        if (tc) swap(&t(i,0), &t(k,0), tc);\n+      }\n+      for (k++; k < mr; k++) {\n+        IntType a = absolute(m(k, j));\n+        if (a != 0 && a < absolute(m(i,j))) {\n+                  swap(&m(i,0), &m(k,0), mc);\n+          if (tc) swap(&t(i,0), &t(k,0), tc);\n+        }\n+      }\n+      if (m(i,j) < 0) {\n+                for(size_t ic=0;ic<mc;ic++) m(i,ic) *= -1;\n+        if (tc) for(size_t ic=0;ic<tc;ic++) t(i,ic) *= -1;\n+      }\n+      bool cleared = true;\n+      for (k = i+1; k < mr; k++) {\n+        IntType a = m(k,j) / m(i,j);\n+        if (a != 0) {\n+                  for(size_t ic=0;ic<mc;ic++) m(k,ic) -= a * m(i,ic);\n+          if (tc) for(size_t ic=0;ic<tc;ic++) t(k,ic) -= a * t(i,ic);\n+        }\n+        if (m(k,j) != 0) cleared = false;\n+      }\n+      if (cleared) { i++; j++; }\n+    }\n+  }\n+  m = mat_ref<IntType>(m.begin(), i, mc);\n+  return i;\n+}\n+\n+template <typename IntType>\n+size_t\n+form(mat_ref<IntType>& m)\n+{\n+  mat_ref<IntType> t(0,0,0);\n+  return form_t(m, t);\n+}\n+\n+typedef mat3<int> sg_mat3;\n+\n+class rot_mx\n+{\n+  public:\n+    explicit\n+    rot_mx(sg_mat3 const& m, int denominator=1)\n+    : num_(m), den_(denominator)\n+    {}\n+\n+    sg_mat3 const&\n+    num() const { return num_; }\n+    sg_mat3&\n+    num()       { return num_; }\n+\n+    int const&\n+    operator[](size_t i) const { return num_[i]; }\n+    int&\n+    operator[](size_t i)       { return num_[i]; }\n+\n+    int\n+    const& operator()(int r, int c) const { return num_(r, c); }\n+    int&\n+    operator()(int r, int c)       { return num_(r, c); }\n+\n+    int const&\n+    den() const { return den_; }\n+    int&\n+    den()       { return den_; }\n+\n+    rot_mx\n+    minus_unit_mx() const\n+    {\n+      rot_mx result(*this);\n+      for (size_t i=0;i<9;i+=4) result[i] -= den_;\n+      return result;\n+    }\n+\n+    rot_mx\n+    operator-() const { return rot_mx(-num_, den_); }\n+\n+    int\n+    type() const;\n+\n+    int\n+    order(int type=0) const;\n+\n+  private:\n+    sg_mat3 num_;\n+    int den_;\n+};\n+\n+class rot_mx_info\n+{\n+  public:\n+    rot_mx_info(rot_mx const& r);\n+\n+    int type() const { return type_; }\n+\n+  private:\n+    int type_;\n+};\n+\n+int rot_mx::type() const\n+{\n+  int det = num_.determinant();\n+  if (det == -1 || det == 1) {\n+    switch (num_.trace()) {\n+      case -3:                return -1;\n+      case -2:                return -6;\n+      case -1: if (det == -1) return -4;\n+               else           return  2;\n+      case  0: if (det == -1) return -3;\n+               else           return  3;\n+      case  1: if (det == -1) return -2;\n+               else           return  4;\n+      case  2:                return  6;\n+      case  3:                return  1;\n+    }\n+  }\n+  return 0;\n+}\n+\n+int rot_mx::order(int type) const\n+{\n+  if (type == 0) type = rot_mx::type();\n+  if (type > 0) return  type;\n+  if (type % 2) return -type * 2;\n+                return -type;\n+}\n+\n+rot_mx_info::rot_mx_info(rot_mx const& r)\n+: type_(r.type())\n+{\n+  if (type_ == 0) {\n+    return;\n+  }\n+  rot_mx proper_r = r;\n+  int proper_order = type_;\n+  // THE PROBLEM IS AROUND HERE\n+  if (proper_order < 0) {\n+    proper_order *= -1;\n+    proper_r = -proper_r; // THIS FAILS ...\n+  }\n+  if (proper_order > 1) {\n+    rot_mx rmi = proper_r.minus_unit_mx(); // ... THEREFORE WRONG HERE\n+    mat_ref<int> re_mx(rmi.num().begin(), 3, 3);\n+    if (form(re_mx) != 2) {\n+      type_ = 0;\n+    }\n+  }\n+}\n+\n+int main()\n+{\n+  N1::tiny<int, 9> e;\n+  e[0] = 1; e[1] =  0; e[2] = 0;\n+  e[3] = 0; e[4] = -1; e[5] = 0;\n+  e[6] = 0; e[7] =  0; e[8] = 1;\n+  rot_mx r(e);\n+  rot_mx_info ri(r);\n+  if (ri.type() != -2)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}