{"sha": "38811401ad565179e1a82028ed4eedf4baa0cdca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg4MTE0MDFhZDU2NTE3OWUxYTgyMDI4ZWQ0ZWVkZjRiYWEwY2RjYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2013-01-31T17:50:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-01-31T17:50:47Z"}, "message": "dwarf.c (read_function_info): Permit fvec parameter to be NULL.\n\n\t* dwarf.c (read_function_info): Permit fvec parameter to be NULL.\n\t(dwarf_lookup_pc): Don't use ddata->fvec if threaded.\n\nFrom-SVN: r195620", "tree": {"sha": "c730595a0fbaf514a1320e15b86b4c83f57cf332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c730595a0fbaf514a1320e15b86b4c83f57cf332"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38811401ad565179e1a82028ed4eedf4baa0cdca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38811401ad565179e1a82028ed4eedf4baa0cdca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38811401ad565179e1a82028ed4eedf4baa0cdca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38811401ad565179e1a82028ed4eedf4baa0cdca/comments", "author": null, "committer": null, "parents": [{"sha": "e259a3f2ca40d51e7d7c1ccb2a09ec06ca52d320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e259a3f2ca40d51e7d7c1ccb2a09ec06ca52d320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e259a3f2ca40d51e7d7c1ccb2a09ec06ca52d320"}], "stats": {"total": 50, "additions": 41, "deletions": 9}, "files": [{"sha": "07e83864dabdf0ea12f0d5b960e72fe058a6434f", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38811401ad565179e1a82028ed4eedf4baa0cdca/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38811401ad565179e1a82028ed4eedf4baa0cdca/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=38811401ad565179e1a82028ed4eedf4baa0cdca", "patch": "@@ -1,3 +1,8 @@\n+2013-01-31  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (read_function_info): Permit fvec parameter to be NULL.\n+\t(dwarf_lookup_pc): Don't use ddata->fvec if threaded.\n+\n 2013-01-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR other/56076"}, {"sha": "501afe553d203486735a4645dc80689f03e86b8d", "filename": "libbacktrace/dwarf.c", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38811401ad565179e1a82028ed4eedf4baa0cdca/libbacktrace%2Fdwarf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38811401ad565179e1a82028ed4eedf4baa0cdca/libbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fdwarf.c?ref=38811401ad565179e1a82028ed4eedf4baa0cdca", "patch": "@@ -2473,10 +2473,21 @@ read_function_info (struct backtrace_state *state, struct dwarf_data *ddata,\n \t\t    struct function_addrs **ret_addrs,\n \t\t    size_t *ret_addrs_count)\n {\n+  struct function_vector lvec;\n+  struct function_vector *pfvec;\n   struct dwarf_buf unit_buf;\n   struct function_addrs *addrs;\n   size_t addrs_count;\n \n+  /* Use FVEC if it is not NULL.  Otherwise use our own vector.  */\n+  if (fvec != NULL)\n+    pfvec = fvec;\n+  else\n+    {\n+      memset (&lvec, 0, sizeof lvec);\n+      pfvec = &lvec;\n+    }\n+\n   unit_buf.name = \".debug_info\";\n   unit_buf.start = ddata->dwarf_info;\n   unit_buf.buf = u->unit_data;\n@@ -2489,20 +2500,28 @@ read_function_info (struct backtrace_state *state, struct dwarf_data *ddata,\n   while (unit_buf.left > 0)\n     {\n       if (!read_function_entry (state, ddata, u, 0, &unit_buf, lhdr,\n-\t\t\t\terror_callback, data, fvec))\n+\t\t\t\terror_callback, data, pfvec))\n \treturn;\n     }\n \n-  if (fvec->count == 0)\n+  if (pfvec->count == 0)\n     return;\n \n-  addrs = (struct function_addrs *) fvec->vec.base;\n-  addrs_count = fvec->count;\n+  addrs = (struct function_addrs *) pfvec->vec.base;\n+  addrs_count = pfvec->count;\n \n-  /* Finish this list of addresses, but leave the remaining space in\n-     the vector available for the next function unit.  */\n-  backtrace_vector_finish (state, &fvec->vec);\n-  fvec->count = 0;\n+  if (fvec == NULL)\n+    {\n+      if (!backtrace_vector_release (state, &lvec.vec, error_callback, data))\n+\treturn;\n+    }\n+  else\n+    {\n+      /* Finish this list of addresses, but leave the remaining space in\n+\t the vector available for the next function unit.  */\n+      backtrace_vector_finish (state, &fvec->vec);\n+      fvec->count = 0;\n+    }\n \n   qsort (addrs, addrs_count, sizeof (struct function_addrs),\n \t function_addrs_compare);\n@@ -2663,8 +2682,16 @@ dwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n       if (read_line_info (state, ddata, error_callback, data, entry->u, &lhdr,\n \t\t\t  &lines, &count))\n \t{\n+\t  struct function_vector *pfvec;\n+\n+\t  /* If not threaded, reuse DDATA->FVEC for better memory\n+\t     consumption.  */\n+\t  if (state->threaded)\n+\t    pfvec = NULL;\n+\t  else\n+\t    pfvec = &ddata->fvec;\n \t  read_function_info (state, ddata, &lhdr, error_callback, data,\n-\t\t\t      entry->u, &ddata->fvec, &function_addrs,\n+\t\t\t      entry->u, pfvec, &function_addrs,\n \t\t\t      &function_addrs_count);\n \t  free_line_header (state, &lhdr, error_callback, data);\n \t  new_data = 1;"}]}