{"sha": "182b8b695625d5efc820a67e0b97da20bb2697ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgyYjhiNjk1NjI1ZDVlZmM4MjBhNjdlMGI5N2RhMjBiYjI2OTdjZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-05-11T19:54:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-05-11T19:54:42Z"}, "message": "genrecog.c (match_pattern_1): Expect the pattern to be a SEQUENCE for define_peephole2s.\n\ngcc/\n\t* genrecog.c (match_pattern_1): Expect the pattern to be a SEQUENCE\n\tfor define_peephole2s.\n\t(get_peephole2_pattern): New function.\n\t(main): Use it.  Call validate_pattern.\n\nFrom-SVN: r223015", "tree": {"sha": "10677b74440cfc112f5207e53600dbc0cb51e65e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10677b74440cfc112f5207e53600dbc0cb51e65e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/182b8b695625d5efc820a67e0b97da20bb2697ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/182b8b695625d5efc820a67e0b97da20bb2697ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/182b8b695625d5efc820a67e0b97da20bb2697ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/182b8b695625d5efc820a67e0b97da20bb2697ce/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "91c6b410ad26a37a6436064dc37e69f3af43b1bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c6b410ad26a37a6436064dc37e69f3af43b1bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91c6b410ad26a37a6436064dc37e69f3af43b1bf"}], "stats": {"total": 68, "additions": 49, "deletions": 19}, "files": [{"sha": "610389faebd25019702f79b68d2c250bffff9191", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/182b8b695625d5efc820a67e0b97da20bb2697ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/182b8b695625d5efc820a67e0b97da20bb2697ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=182b8b695625d5efc820a67e0b97da20bb2697ce", "patch": "@@ -1,3 +1,10 @@\n+2015-05-11  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* genrecog.c (match_pattern_1): Expect the pattern to be a SEQUENCE\n+\tfor define_peephole2s.\n+\t(get_peephole2_pattern): New function.\n+\t(main): Use it.  Call validate_pattern.\n+\n 2015-05-11  Pitchumani Sivanupandi  <pitchumani.s@atmel.com>\n \n \t* config/avr/avr.c (avr_hard_regno_call_part_clobbered): Use"}, {"sha": "31ad7c07b99530b2f2c87cb7c764a5a3976d97da", "filename": "gcc/genrecog.c", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/182b8b695625d5efc820a67e0b97da20bb2697ce/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/182b8b695625d5efc820a67e0b97da20bb2697ce/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=182b8b695625d5efc820a67e0b97da20bb2697ce", "patch": "@@ -4080,33 +4080,29 @@ match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n    (2) the rtx matches TOP_PATTERN and\n    (3) C_TEST is true.\n \n-   For peephole2, TOP_PATTERN is the DEFINE_PEEPHOLE2 itself, otherwise\n-   it is the rtx pattern to match (PARALLEL, SET, etc.).  */\n+   For peephole2, TOP_PATTERN is a SEQUENCE of the instruction patterns\n+   to match, otherwise it is a single instruction pattern.  */\n \n static void\n match_pattern_1 (state *s, rtx top_pattern, const char *c_test,\n \t\t acceptance_type acceptance)\n {\n-  if (GET_CODE (top_pattern) == DEFINE_PEEPHOLE2)\n+  if (acceptance.type == PEEPHOLE2)\n     {\n       /* Match each individual instruction.  */\n       position **subpos_ptr = &peep2_insn_pos_list;\n       int count = 0;\n       for (int i = 0; i < XVECLEN (top_pattern, 0); ++i)\n \t{\n \t  rtx x = XVECEXP (top_pattern, 0, i);\n-\t  /* Ignore scratch register requirements.  */\n-\t  if (GET_CODE (x) != MATCH_SCRATCH && GET_CODE (x) != MATCH_DUP)\n-\t    {\n-\t      position *subpos = next_position (subpos_ptr, &root_pos,\n-\t\t\t\t\t\tPOS_PEEP2_INSN, count);\n-\t      if (count > 0)\n-\t\ts = add_decision (s, rtx_test::peep2_count (count + 1),\n-\t\t\t\t  true, false);\n-\t      s = match_pattern_2 (s, top_pattern, subpos, x);\n-\t      subpos_ptr = &subpos->next;\n-\t      count += 1;\n-\t    }\n+\t  position *subpos = next_position (subpos_ptr, &root_pos,\n+\t\t\t\t\t    POS_PEEP2_INSN, count);\n+\t  if (count > 0)\n+\t    s = add_decision (s, rtx_test::peep2_count (count + 1),\n+\t\t\t      true, false);\n+\t  s = match_pattern_2 (s, top_pattern, subpos, x);\n+\t  subpos_ptr = &subpos->next;\n+\t  count += 1;\n \t}\n       acceptance.u.full.u.match_len = count - 1;\n     }\n@@ -5165,6 +5161,30 @@ add_implicit_parallel (rtvec vec)\n     }\n }\n \n+/* Return the rtx pattern for the list of rtxes in a define_peephole2.  */\n+\n+static rtx\n+get_peephole2_pattern (rtvec vec)\n+{\n+  int i, j;\n+  rtx pattern = rtx_alloc (SEQUENCE);\n+  XVEC (pattern, 0) = rtvec_alloc (GET_NUM_ELEM (vec));\n+  for (i = j = 0; i < GET_NUM_ELEM (vec); i++)\n+    {\n+      rtx x = RTVEC_ELT (vec, i);\n+      /* Ignore scratch register requirements.  */\n+      if (GET_CODE (x) != MATCH_SCRATCH && GET_CODE (x) != MATCH_DUP)\n+\t{\n+\t  XVECEXP (pattern, 0, j) = x;\n+\t  j++;\n+\t}\n+    }\n+  XVECLEN (pattern, 0) = j;\n+  if (j == 0)\n+    error_with_line (pattern_lineno, \"empty define_peephole2\");\n+  return pattern;\n+}\n+\n /* Return true if *PATTERN_PTR is a PARALLEL in which at least one trailing\n    rtx can be added automatically by add_clobbers.  If so, update\n    *ACCEPTANCE_PTR so that its num_clobbers field contains the number\n@@ -5231,20 +5251,20 @@ main (int argc, char **argv)\n       if (desc == NULL)\n \tbreak;\n \n-      rtx pattern;\n-\n       acceptance_type acceptance;\n       acceptance.partial_p = false;\n       acceptance.u.full.code = next_insn_code;\n \n+      rtx pattern;\n       switch (GET_CODE (desc))\n \t{\n \tcase DEFINE_INSN:\n \t  {\n \t    /* Match the instruction in the original .md form.  */\n-\t    pattern = add_implicit_parallel (XVEC (desc, 1));\n \t    acceptance.type = RECOG;\n \t    acceptance.u.full.u.num_clobbers = 0;\n+\t    pattern = add_implicit_parallel (XVEC (desc, 1));\n+\t    validate_pattern (pattern, desc, NULL_RTX, 0);\n \t    match_pattern (&insn_root, pattern, XSTR (desc, 2), acceptance);\n \n \t    /* If the pattern is a PARALLEL with trailing CLOBBERs,\n@@ -5258,6 +5278,7 @@ main (int argc, char **argv)\n \tcase DEFINE_SPLIT:\n \t  acceptance.type = SPLIT;\n \t  pattern = add_implicit_parallel (XVEC (desc, 0));\n+\t  validate_pattern (pattern, desc, NULL_RTX, 0);\n \t  match_pattern (&split_root, pattern, XSTR (desc, 1), acceptance);\n \n \t  /* Declare the gen_split routine that we'll call if the\n@@ -5268,7 +5289,9 @@ main (int argc, char **argv)\n \n \tcase DEFINE_PEEPHOLE2:\n \t  acceptance.type = PEEPHOLE2;\n-\t  match_pattern (&peephole2_root, desc, XSTR (desc, 1), acceptance);\n+\t  pattern = get_peephole2_pattern (XVEC (desc, 0));\n+\t  validate_pattern (pattern, desc, NULL_RTX, 0);\n+\t  match_pattern (&peephole2_root, pattern, XSTR (desc, 1), acceptance);\n \n \t  /* Declare the gen_peephole2 routine that we'll call if the\n \t     pattern matches.  The definition comes from insn-emit.c.  */"}]}