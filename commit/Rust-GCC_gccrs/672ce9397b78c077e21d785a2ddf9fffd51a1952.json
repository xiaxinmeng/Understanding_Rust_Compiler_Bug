{"sha": "672ce9397b78c077e21d785a2ddf9fffd51a1952", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcyY2U5Mzk3Yjc4YzA3N2UyMWQ3ODVhMmRkZjlmZmZkNTFhMTk1Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2014-02-20T17:43:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2014-02-20T17:43:53Z"}, "message": "re PR c++/60272 (atomic<>::compare_exchange_weak has spurious store and can cause race conditions)\n\nPR c++/60272\n\ngcc/\n\t* builtins.c (expand_builtin_atomic_compare_exchange): Conditionalize\n\ton failure the store back into EXPECT.\nlibatomic/\n\t* cas_n.c (libat_compare_exchange): Conditionalize on failure\n\tthe store back to EPTR.\n\nFrom-SVN: r207966", "tree": {"sha": "8ec4b08823b9b5486cecde9c93f376b7f59cf42e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ec4b08823b9b5486cecde9c93f376b7f59cf42e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/672ce9397b78c077e21d785a2ddf9fffd51a1952", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/672ce9397b78c077e21d785a2ddf9fffd51a1952", "html_url": "https://github.com/Rust-GCC/gccrs/commit/672ce9397b78c077e21d785a2ddf9fffd51a1952", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/672ce9397b78c077e21d785a2ddf9fffd51a1952/comments", "author": null, "committer": null, "parents": [{"sha": "95ce7613d537f5a3e9e36da0ca6aa752f60da8e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ce7613d537f5a3e9e36da0ca6aa752f60da8e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95ce7613d537f5a3e9e36da0ca6aa752f60da8e0"}], "stats": {"total": 56, "additions": 38, "deletions": 18}, "files": [{"sha": "7161754b2b3dfd3c35a04b368c8c207bccfd48a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672ce9397b78c077e21d785a2ddf9fffd51a1952/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672ce9397b78c077e21d785a2ddf9fffd51a1952/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=672ce9397b78c077e21d785a2ddf9fffd51a1952", "patch": "@@ -1,3 +1,9 @@\n+2014-02-20  Richard Henderson <rth@redhat.com>\n+\n+\tPR c++/60272\n+\t* builtins.c (expand_builtin_atomic_compare_exchange): Conditionalize\n+\ton failure the store back into EXPECT.\n+\n 2014-02-20  Chung-Lin Tang  <cltang@codesourcery.com>\n \t    Sandra Loosemore  <sandra@codesourcery.com>\n "}, {"sha": "09fefe50a8d91d0b444877b511e4b8e990badf43", "filename": "gcc/builtins.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672ce9397b78c077e21d785a2ddf9fffd51a1952/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672ce9397b78c077e21d785a2ddf9fffd51a1952/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=672ce9397b78c077e21d785a2ddf9fffd51a1952", "patch": "@@ -5292,7 +5292,7 @@ static rtx\n expand_builtin_atomic_compare_exchange (enum machine_mode mode, tree exp, \n \t\t\t\t\trtx target)\n {\n-  rtx expect, desired, mem, oldval;\n+  rtx expect, desired, mem, oldval, label;\n   enum memmodel success, failure;\n   tree weak;\n   bool is_weak;\n@@ -5330,14 +5330,23 @@ expand_builtin_atomic_compare_exchange (enum machine_mode mode, tree exp,\n   if (tree_fits_shwi_p (weak) && tree_to_shwi (weak) != 0)\n     is_weak = true;\n \n+  if (target == const0_rtx)\n+    target = NULL;\n   oldval = expect;\n-  if (!expand_atomic_compare_and_swap ((target == const0_rtx ? NULL : &target),\n-\t\t\t\t       &oldval, mem, oldval, desired,\n+\n+  if (!expand_atomic_compare_and_swap (&target, &oldval, mem, oldval, desired,\n \t\t\t\t       is_weak, success, failure))\n     return NULL_RTX;\n \n-  if (oldval != expect)\n-    emit_move_insn (expect, oldval);\n+  /* Conditionally store back to EXPECT, lest we create a race condition\n+     with an improper store to memory.  */\n+  /* ??? With a rearrangement of atomics at the gimple level, we can handle\n+     the normal case where EXPECT is totally private, i.e. a register.  At\n+     which point the store can be unconditional.  */\n+  label = gen_label_rtx ();\n+  emit_cmp_and_jump_insns (target, const0_rtx, NE, NULL, VOIDmode, 1, label);\n+  emit_move_insn (expect, oldval);\n+  emit_label (label);\n \n   return target;\n }"}, {"sha": "1bd3c2178aa5ca94f2dd0d0d6eb93e75dae9f004", "filename": "libatomic/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672ce9397b78c077e21d785a2ddf9fffd51a1952/libatomic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672ce9397b78c077e21d785a2ddf9fffd51a1952/libatomic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2FChangeLog?ref=672ce9397b78c077e21d785a2ddf9fffd51a1952", "patch": "@@ -1,3 +1,9 @@\n+2014-02-20  Richard Henderson <rth@redhat.com>\n+\n+\tPR c++/60272\n+\t* cas_n.c (libat_compare_exchange): Conditionalize on failure\n+\tthe store back to EPTR.\n+\n 2014-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tUpdate copyright years"}, {"sha": "801262d551c4bbf5079a8b3a58977f230a03d653", "filename": "libatomic/cas_n.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672ce9397b78c077e21d785a2ddf9fffd51a1952/libatomic%2Fcas_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672ce9397b78c077e21d785a2ddf9fffd51a1952/libatomic%2Fcas_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fcas_n.c?ref=672ce9397b78c077e21d785a2ddf9fffd51a1952", "patch": "@@ -51,10 +51,9 @@ SIZE(libat_compare_exchange) (UTYPE *mptr, UTYPE *eptr, UTYPE newval,\n #if !DONE && N <= WORDSIZE && defined(atomic_compare_exchange_w)\n bool\n SIZE(libat_compare_exchange) (UTYPE *mptr, UTYPE *eptr, UTYPE newval,\n-\t\t\t      int smodel, int fmodel UNUSED)\n+\t\t\t      int smodel, int fmodel)\n {\n   UWORD mask, shift, weval, woldval, wnewval, t, *wptr;\n-  bool ret = false;\n \n   pre_barrier (smodel);\n \n@@ -82,12 +81,13 @@ SIZE(libat_compare_exchange) (UTYPE *mptr, UTYPE *eptr, UTYPE newval,\n     }\n   while (!atomic_compare_exchange_w (wptr, &woldval, t, true,\n \t\t\t\t     __ATOMIC_RELAXED, __ATOMIC_RELAXED));\n-  ret = true;\n+  post_barrier (smodel);\n+  return true;\n+\n  failure:\n   *eptr = woldval >> shift;\n-\n-  post_barrier (smodel);\n-  return ret;\n+  post_barrier (fmodel);\n+  return false;\n }\n \n #define DONE 1\n@@ -102,18 +102,17 @@ SIZE(libat_compare_exchange) (UTYPE *mptr, UTYPE *eptr, UTYPE newval,\n {\n   UTYPE oldval;\n   UWORD magic;\n-  bool ret = false;\n+  bool ret;\n \n   pre_seq_barrier (smodel);\n   magic = protect_start (mptr);\n \n   oldval = *mptr;\n-  if (oldval == *eptr)\n-    {\n-      *mptr = newval;\n-      ret = true;\n-    }\n-  *eptr = oldval;\n+  ret = (oldval == *eptr);\n+  if (ret)\n+    *mptr = newval;\n+  else\n+    *eptr = oldval;\n \n   protect_end (mptr, magic);\n   post_seq_barrier (smodel);"}]}