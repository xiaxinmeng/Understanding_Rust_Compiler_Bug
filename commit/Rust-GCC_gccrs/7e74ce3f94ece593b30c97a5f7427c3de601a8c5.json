{"sha": "7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U3NGNlM2Y5NGVjZTU5M2IzMGM5N2E1Zjc0MjdjM2RlNjAxYThjNQ==", "commit": {"author": {"name": "Ed Smith-Rowland", "email": "3dw4rd@verizon.net", "date": "2011-11-21T19:27:30Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-11-21T19:27:30Z"}, "message": "re PR c++/50958 ([C++0x] raw literal operator provides incorrect string for integer literal '0')\n\n\tPR c++/50958\ngcc/cp/\n\t* parser.c (lookup_literal_operator): New.\n\t(cp_parser_userdef_char_literal): Use it.\n\t(cp_parser_userdef_numeric_literal): Use it.\n\t(cp_parser_userdef_string_literal): Use lookup_name.\nlibcpp/\n\t* expr.c (cpp_userdef_char_remove_type): Fix typo.\n\nFrom-SVN: r181595", "tree": {"sha": "c5bf0a4816e7907735b0ce901cff5513fb6278af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5bf0a4816e7907735b0ce901cff5513fb6278af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/comments", "author": {"login": "emsr", "id": 1936479, "node_id": "MDQ6VXNlcjE5MzY0Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1936479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emsr", "html_url": "https://github.com/emsr", "followers_url": "https://api.github.com/users/emsr/followers", "following_url": "https://api.github.com/users/emsr/following{/other_user}", "gists_url": "https://api.github.com/users/emsr/gists{/gist_id}", "starred_url": "https://api.github.com/users/emsr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emsr/subscriptions", "organizations_url": "https://api.github.com/users/emsr/orgs", "repos_url": "https://api.github.com/users/emsr/repos", "events_url": "https://api.github.com/users/emsr/events{/privacy}", "received_events_url": "https://api.github.com/users/emsr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f3fae478f43753041564b94a9b002f399c6576fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3fae478f43753041564b94a9b002f399c6576fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3fae478f43753041564b94a9b002f399c6576fb"}], "stats": {"total": 341, "additions": 261, "deletions": 80}, "files": [{"sha": "7b995f1f095836e4e50cc07dab0e2bf3c357b26a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "patch": "@@ -1,3 +1,11 @@\n+2011-11-21  Ed Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tPR c++/50958\n+\t* parser.c (lookup_literal_operator): New.\n+\t(cp_parser_userdef_char_literal): Use it.\n+\t(cp_parser_userdef_numeric_literal): Use it.\n+\t(cp_parser_userdef_string_literal): Use lookup_name.\n+\n 2011-11-20  Jason Merrill  <jason@redhat.com>\n \n \t* pt.c (tsubst_pack_expansion): Fix SFINAE."}, {"sha": "4a2b2a9a471ce610ea5def6655e27033deb55f5d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 93, "deletions": 66, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "patch": "@@ -3547,40 +3547,79 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n   return value;\n }\n \n+/* Look up a literal operator with the name and the exact arguments.  */\n+\n+static tree\n+lookup_literal_operator (tree name, VEC(tree,gc) *args)\n+{\n+  tree decl, fns;\n+  decl = lookup_name (name);\n+  if (!decl || decl == error_mark_node)\n+    return error_mark_node;\n+\n+  for (fns = decl; fns; fns = OVL_NEXT (fns))\n+    {\n+      unsigned int ix;\n+      bool found = true;\n+      tree fn = OVL_CURRENT (fns);\n+      tree argtypes = NULL_TREE;\n+      argtypes = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+      if (argtypes != NULL_TREE)\n+\t{\n+\t  for (ix = 0; ix < VEC_length (tree, args) && argtypes != NULL_TREE;\n+\t       ++ix, argtypes = TREE_CHAIN (argtypes))\n+\t    {\n+\t      tree targ = TREE_VALUE (argtypes);\n+\t      tree tparm = TREE_TYPE (VEC_index (tree, args, ix));\n+\t      bool ptr = TREE_CODE (targ) == POINTER_TYPE;\n+\t      bool arr = TREE_CODE (tparm) == ARRAY_TYPE;\n+\t      if ((ptr || arr || !same_type_p (targ, tparm))\n+\t\t  && (!ptr || !arr\n+\t\t      || !same_type_p (TREE_TYPE (targ),\n+\t\t\t\t       TREE_TYPE (tparm))))\n+\t\tfound = false;\n+\t    }\n+\t  if (found)\n+\t    return fn;\n+\t}\n+    }\n+\n+  return error_mark_node;\n+}\n+\n /* Parse a user-defined char constant.  Returns a call to a user-defined\n    literal operator taking the character as an argument.  */\n \n static tree\n cp_parser_userdef_char_literal (cp_parser *parser)\n {\n-  cp_token *token = NULL;\n-  tree literal, suffix_id, value;\n-  tree name, decl;\n-  tree result;\n-  VEC(tree,gc) *vec;\n-\n-  token = cp_lexer_consume_token (parser->lexer);\n-  literal = token->u.value;\n-  suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);\n-  value = USERDEF_LITERAL_VALUE (literal);\n-  name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));\n+  cp_token *token = cp_lexer_consume_token (parser->lexer);\n+  tree literal = token->u.value;\n+  tree suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);\n+  tree value = USERDEF_LITERAL_VALUE (literal);\n+  tree name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));\n+  tree decl, result;\n \n   /* Build up a call to the user-defined operator  */\n   /* Lookup the name we got back from the id-expression.  */\n-  vec = make_tree_vector ();\n-  VEC_safe_push (tree, gc, vec, value);\n-  decl = lookup_function_nonclass (name, vec, /*block_p=*/false);\n+  VEC(tree,gc) *args = make_tree_vector ();\n+  VEC_safe_push (tree, gc, args, value);\n+  decl = lookup_literal_operator (name, args);\n   if (!decl || decl == error_mark_node)\n     {\n-      error (\"unable to find user-defined character literal operator %qD\",\n-\t     name);\n-      release_tree_vector (vec);\n+      error (\"unable to find character literal operator %qD with %qT argument\",\n+\t     name, TREE_TYPE (value));\n+      release_tree_vector (args);\n       return error_mark_node;\n     }\n-  result = finish_call_expr (decl, &vec, false, true, tf_warning_or_error);\n-  release_tree_vector (vec);\n+  result = finish_call_expr (decl, &args, false, true, tf_warning_or_error);\n+  release_tree_vector (args);\n+  if (result != error_mark_node)\n+    return result;\n \n-  return result;\n+  error (\"unable to find character literal operator %qD with %qT argument\",\n+\t name, TREE_TYPE (value));\n+  return error_mark_node;\n }\n \n /* A subroutine of cp_parser_userdef_numeric_literal to\n@@ -3615,26 +3654,20 @@ make_char_string_pack (tree value)\n static tree\n cp_parser_userdef_numeric_literal (cp_parser *parser)\n {\n-  cp_token *token = NULL;\n-  tree literal, suffix_id, value, num_string;\n-  tree name, decl;\n-  tree result = error_mark_node;\n+  cp_token *token = cp_lexer_consume_token (parser->lexer);\n+  tree literal = token->u.value;\n+  tree suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);\n+  tree value = USERDEF_LITERAL_VALUE (literal);\n+  tree num_string = USERDEF_LITERAL_NUM_STRING (literal);\n+  tree name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));\n+  tree decl, result;\n   VEC(tree,gc) *args;\n \n-  token = cp_lexer_consume_token (parser->lexer);\n-  literal = token->u.value;\n-  suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);\n-  value = USERDEF_LITERAL_VALUE (literal);\n-  num_string = USERDEF_LITERAL_NUM_STRING (literal);\n-  name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));\n-\n-  /* Build up a call to the user-defined operator  */\n-  /* Lookup the name we got back from the id-expression.  */\n-  /* Try to find the literal operator by finishing the call expression\n-     with the numeric argument.  */\n+  /* Look for a literal operator taking the exact type of numeric argument\n+     as the literal value.  */\n   args = make_tree_vector ();\n   VEC_safe_push (tree, gc, args, value);\n-  decl = lookup_function_nonclass (name, args, /*block_p=*/false);\n+  decl = lookup_literal_operator (name, args);\n   if (decl && decl != error_mark_node)\n     {\n       result = finish_call_expr (decl, &args, false, true, tf_none);\n@@ -3651,7 +3684,7 @@ cp_parser_userdef_numeric_literal (cp_parser *parser)\n      in string format.  */\n   args = make_tree_vector ();\n   VEC_safe_push (tree, gc, args, num_string);\n-  decl = lookup_function_nonclass (name, args, /*block_p=*/false);\n+  decl = lookup_literal_operator (name, args);\n   if (decl && decl != error_mark_node)\n     {\n       result = finish_call_expr (decl, &args, false, true, tf_none);\n@@ -3667,7 +3700,7 @@ cp_parser_userdef_numeric_literal (cp_parser *parser)\n      function with parameter pack char....  Call the function with\n      template parameter characters representing the number.  */\n   args = make_tree_vector ();\n-  decl = lookup_function_nonclass (name, args, /*block_p=*/false);\n+  decl = lookup_literal_operator (name, args);\n   if (decl && decl != error_mark_node)\n     {\n       tree tmpl_args = make_char_string_pack (num_string);\n@@ -3681,10 +3714,8 @@ cp_parser_userdef_numeric_literal (cp_parser *parser)\n     }\n   release_tree_vector (args);\n \n-  if (result == error_mark_node)\n-    error (\"unable to find user-defined numeric literal operator %qD\", name);\n-\n-  return result;\n+  error (\"unable to find numeric literal operator %qD\", name);\n+  return error_mark_node;\n }\n \n /* Parse a user-defined string constant.  Returns a call to a user-defined\n@@ -3694,38 +3725,34 @@ cp_parser_userdef_numeric_literal (cp_parser *parser)\n static tree\n cp_parser_userdef_string_literal (cp_token *token)\n {\n-  tree literal, suffix_id, value;\n-  tree name, decl;\n-  tree result;\n-  VEC(tree,gc) *vec;\n-  int len;\n-\n-  literal = token->u.value;\n-  suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);\n-  name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));\n-  value = USERDEF_LITERAL_VALUE (literal);\n-  len = TREE_STRING_LENGTH (value)\n+  tree literal = token->u.value;\n+  tree suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);\n+  tree name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));\n+  tree value = USERDEF_LITERAL_VALUE (literal);\n+  int len = TREE_STRING_LENGTH (value)\n \t/ TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (value)))) - 1;\n+  tree decl, result;\n+\n   /* Build up a call to the user-defined operator  */\n   /* Lookup the name we got back from the id-expression.  */\n-  vec = make_tree_vector ();\n-  VEC_safe_push (tree, gc, vec, value);\n-  VEC_safe_push (tree, gc, vec, build_int_cst (size_type_node, len));\n-  decl = lookup_function_nonclass (name, vec, /*block_p=*/false);\n+  VEC(tree,gc) *args = make_tree_vector ();\n+  VEC_safe_push (tree, gc, args, value);\n+  VEC_safe_push (tree, gc, args, build_int_cst (size_type_node, len));\n+  decl = lookup_name (name);\n   if (!decl || decl == error_mark_node)\n     {\n-      error (\"unable to find user-defined string literal operator %qD\", name);\n-      release_tree_vector (vec);\n+      error (\"unable to find string literal operator %qD\", name);\n+      release_tree_vector (args);\n       return error_mark_node;\n     }\n-  result = finish_call_expr (decl, &vec, false, true, tf_none);\n-  if (result == error_mark_node)\n-    error (\"unable to find valid user-defined string literal operator %qD.\"\n-\t   \"  Possible missing length argument in string literal operator.\",\n-\t   name);\n-  release_tree_vector (vec);\n+  result = finish_call_expr (decl, &args, false, true, tf_none);\n+  release_tree_vector (args);\n+  if (result != error_mark_node)\n+    return result;\n \n-  return result;\n+  error (\"unable to find string literal operator %qD with %qT, %qT arguments\",\n+\t name, TREE_TYPE (value), size_type_node);\n+  return error_mark_node;\n }\n \n "}, {"sha": "b9ab57903866c87dcca33a3bd82c8755178d0efe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "patch": "@@ -1,3 +1,14 @@\n+2011-11-21  Ed Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tPR c++/50958\n+\t* g++.dg/cpp0x/udlit-declare-neg.C: Adjust.\n+\t* g++.dg/cpp0x/udlit-implicit-conv-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-member.C: Adjust.\n+\t* g++.dg/cpp0x/udlit-raw-length.C: New.\n+\t* g++.dg/cpp0x/udlit-raw-op-string-neg.C: Adjust.\n+\t* g++.dg/cpp0x/udlit-resolve.C: New.\n+\t* c-c++-common/dfp/pr33466.c: Adjust.\n+\n 2011-11-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* lib/target-supports.exp"}, {"sha": "9b10a092b91e591e1c60428884c342f0253fae78", "filename": "gcc/testsuite/c-c++-common/dfp/pr33466.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdfp%2Fpr33466.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdfp%2Fpr33466.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdfp%2Fpr33466.c?ref=7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "patch": "@@ -5,9 +5,9 @@\n    These are invalid for all targets, not just those that support\n     decimal float.  */\n \n-long double dF = 4.5dF;\t   /* { dg-error \"invalid suffix|user-defined\" } */\n-long double Df = 4.5Df;\t   /* { dg-error \"invalid suffix|user-defined\" } */\n-long double dD = 4.5dD;\t   /* { dg-error \"invalid suffix|user-defined\" } */\n-long double Dd = 4.5Dd;\t   /* { dg-error \"invalid suffix|user-defined\" } */\n-long double dL = 4.5dL;\t   /* { dg-error \"invalid suffix|user-defined\" } */\n-long double Dl = 4.5Dl;\t   /* { dg-error \"invalid suffix|user-defined\" } */\n+long double dF = 4.5dF;\t   /* { dg-error \"invalid suffix|literal operator\" } */\n+long double Df = 4.5Df;\t   /* { dg-error \"invalid suffix|literal operator\" } */\n+long double dD = 4.5dD;\t   /* { dg-error \"invalid suffix|literal operator\" } */\n+long double Dd = 4.5Dd;\t   /* { dg-error \"invalid suffix|literal operator\" } */\n+long double dL = 4.5dL;\t   /* { dg-error \"invalid suffix|literal operator\" } */\n+long double Dl = 4.5Dl;\t   /* { dg-error \"invalid suffix|literal operator\" } */"}, {"sha": "9060abba4940a6f6aadef5d3ed796ea9cab73e7f", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-declare-neg.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-declare-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-declare-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-declare-neg.C?ref=7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "patch": "@@ -3,13 +3,13 @@\n //  Check that undeclared literal operator calls and literals give appropriate errors.\n \n int i = operator\"\" _Bar('x');  // { dg-error \"was not declared in this scope\" }\n-int j = 'x'_Bar;  // { dg-error \"unable to find user-defined character literal operator\" }\n+int j = 'x'_Bar;  // { dg-error \"unable to find character literal operator|with|argument\" }\n \n int ii = operator\"\" _BarCharStr(\"Howdy, Pardner!\");  // { dg-error \"was not declared in this scope\" }\n-int jj = \"Howdy, Pardner!\"_BarCharStr;  // { dg-error \"unable to find user-defined string literal operator\" }\n+int jj = \"Howdy, Pardner!\"_BarCharStr;  // { dg-error \"unable to find string literal operator|Possible missing length argument\" }\n \n unsigned long long iULL = operator\"\" _BarULL(666ULL);  // { dg-error \"was not declared in this scope\" }\n-unsigned long long jULL = 666_BarULL;  // { dg-error \"unable to find user-defined numeric literal operator\" }\n+unsigned long long jULL = 666_BarULL;  // { dg-error \"unable to find numeric literal operator\" }\n \n long double iLD = operator\"\" _BarLD(666.0L);  // { dg-error \"was not declared in this scope\" }\n-long double jLD = 666.0_BarLD;  // { dg-error \"unable to find user-defined numeric literal operator\" }\n+long double jLD = 666.0_BarLD;  // { dg-error \"unable to find numeric literal operator\" }"}, {"sha": "998ad155bf771e769467e46c5705de4d0cb4828a", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-implicit-conv-neg.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-implicit-conv-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-implicit-conv-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-implicit-conv-neg.C?ref=7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "patch": "@@ -0,0 +1,63 @@\n+// { dg-options -std=c++0x }\n+\n+#include <cstdint>\n+\n+int operator\"\" _bar (long double);\n+\n+double operator\"\" _foo (long long unsigned);\n+\n+int i = 12_bar; // { dg-error \"unable to find numeric literal operator|with|argument\" }\n+\n+double d = 1.2_foo; // { dg-error \"unable to find numeric literal operator|with|argument\" }\n+\n+int operator\"\" _char(char);\n+\n+int operator\"\" _wchar_t(wchar_t);\n+\n+int operator\"\" _char16_t(char16_t);\n+\n+int operator\"\" _char32_t(char32_t);\n+\n+int cwcx = 'c'_wchar_t; // { dg-error \"unable to find character literal operator|with|argument\" }\n+int cc16 = 'c'_char16_t; // { dg-error \"unable to find character literal operator|with|argument\" }\n+int cc32 = 'c'_char32_t; // { dg-error \"unable to find character literal operator|with|argument\" }\n+\n+int wccx = L'c'_char; // { dg-error \"unable to find character literal operator|with|argument\" }\n+int wcc16 = L'c'_char16_t; // { dg-error \"unable to find character literal operator|with|argument\" }\n+int wcc32 = L'c'_char32_t; // { dg-error \"unable to find character literal operator|with|argument\" }\n+\n+int c16c = u'c'_char; // { dg-error \"unable to find character literal operator|with|argument\" }\n+int c16wc = u'c'_wchar_t; // { dg-error \"unable to find character literal operator|with|argument\" }\n+int c16c32 = u'c'_char32_t; // { dg-error \"unable to find character literal operator|with|argument\" }\n+\n+int c32c = U'c'_char; // { dg-error \"unable to find character literal operator|with|argument\" }\n+int c32wc = U'c'_wchar_t; // { dg-error \"unable to find character literal operator|with|argument\" }\n+int c32c16 = U'c'_char16_t; // { dg-error \"unable to find character literal operator|with|argument\" }\n+\n+int operator\"\" _char_str(const char*, std::size_t);\n+\n+int operator\"\" _wchar_t_str(const wchar_t*, std::size_t);\n+\n+int operator\"\" _char16_t_str(const char16_t*, std::size_t);\n+\n+int operator\"\" _char32_t_str(const char32_t*, std::size_t);\n+\n+int strwstr = \"str\"_wchar_t_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+int strstr16 = \"str\"_char16_t_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+int strstr32 = \"str\"_char32_t_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+\n+int str8wstr = u8\"str\"_wchar_t_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+int str8str16 = u8\"str\"_char16_t_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+int str8str32 = u8\"str\"_char32_t_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+\n+int wstrstr = L\"str\"_char_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+int wstrstr16 = L\"str\"_char16_t_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+int wstrstr32 = L\"str\"_char32_t_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+\n+int str16str = u\"str\"_char_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+int str16wstr = u\"str\"_wchar_t_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+int str16str32 = u\"str\"_char32_t_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+\n+int str32str = U\"str\"_char_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+int str32wstr = U\"str\"_wchar_t_str; // { dg-error \"unable to find string literal operator|with|arguments\" }\n+int str32str16 = U\"str\"_char16_t_str; // { dg-error \"unable to find string literal operator string operator|with|arguments\" }"}, {"sha": "a6220c4c0fc5691ca5e98cda694ef9337ae0c5d7", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-member-neg.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-member-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-member-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-member-neg.C?ref=7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "patch": "@@ -8,7 +8,7 @@ public:\n };\n \n int i = operator\"\" _Bar(U'x');  // { dg-error \"was not declared in this scope\" }\n-int j = U'x'_Bar;  // { dg-error \"unable to find user-defined character literal operator\" }\n+int j = U'x'_Bar;  // { dg-error \"unable to find character literal operator\" }\n \n int\n Foo::operator\"\" _Bar(char32_t)  // { dg-error \"must be a non-member function\" }"}, {"sha": "2d910624a7cbca2cd49509ee74eb284aa56d541c", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-raw-length.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-length.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-length.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-length.C?ref=7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "patch": "@@ -0,0 +1,27 @@\n+// { dg-options \"-std=c++0x\" }\n+// PR c++/50958\n+\n+typedef decltype(sizeof(0)) size_type;\n+\n+constexpr size_type\n+cstrlen_impl(const char* s, size_type i)\n+{\n+  return s[i] ? cstrlen_impl(s, i + 1) : i;\n+}\n+\n+constexpr size_type\n+cstrlen(const char* s)\n+{\n+  return s ? cstrlen_impl(s, 0) : throw 0;\n+}\n+\n+constexpr size_type\n+operator \"\" _lenraw(const char* digits)\n+{\n+  return cstrlen(digits);\n+}\n+\n+static_assert(123_lenraw == 3, \"Ouch\");\n+static_assert(1_lenraw == 1, \"Ouch\");\n+static_assert(012_lenraw == 3, \"Ouch\");\n+static_assert(0_lenraw == 1, \"Ouch\");"}, {"sha": "58ad0e609d02767ea6bc2c0e4b8768e0c440b83c", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-raw-op-string-neg.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-op-string-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-op-string-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-op-string-neg.C?ref=7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "patch": "@@ -5,4 +5,4 @@\n int operator\"\" _embedraw(const char*)\n { return 41; };\n \n-int k = \"Boo!\"_embedraw;  //  { dg-error \"unable to find valid user-defined string literal operator\" }\n+int k = \"Boo!\"_embedraw;  //  { dg-error \"unable to find string literal operator\" }"}, {"sha": "a25516220c29620e8ee65fe873a776ec51e30b83", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-resolve.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-resolve.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-resolve.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-resolve.C?ref=7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <cstdint>\n+#include <cassert>\n+\n+int operator\"\" _foo(const char*)                  { return 0; }\n+int operator\"\" _foo(unsigned long long int)       { return 1; }\n+int operator\"\" _foo(long double)                  { return 2; }\n+int operator\"\" _foo(char)                         { return 3; }\n+int operator\"\" _foo(wchar_t)                      { return 4; }\n+int operator\"\" _foo(char16_t)                     { return 5; }\n+int operator\"\" _foo(char32_t)                     { return 6; }\n+int operator\"\" _foo(const char*, std::size_t)     { return 7; }\n+int operator\"\" _foo(const wchar_t*, std::size_t)  { return 8; }\n+int operator\"\" _foo(const char16_t*, std::size_t) { return 9; }\n+int operator\"\" _foo(const char32_t*, std::size_t) { return 10; }\n+template<char...> int operator\"\" _foo2()          { return 20; }\n+int operator\"\" _foo2(unsigned long long int)      { return 21; }\n+\n+namespace bar {\n+int operator\"\" _foo(unsigned long long int)       { return 101; }\n+}\n+using namespace bar;\n+\n+int\n+main()\n+{\n+  assert(123_foo == 101);\n+  assert(0.123_foo == 2);\n+  assert('c'_foo == 3);\n+  assert(L'c'_foo == 4);\n+  assert(u'c'_foo == 5);\n+  assert(U'c'_foo == 6);\n+  assert(\"abc\"_foo == 7);\n+  assert(L\"abc\"_foo == 8);\n+  assert(u\"abc\"_foo == 9);\n+  assert(U\"abc\"_foo == 10);\n+  assert(123_foo2 == 21);\n+}"}, {"sha": "5929842a4ada14dac2ac6f1f9c2285de8bb7f2b1", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "patch": "@@ -1,3 +1,8 @@\n+2011-11-21  Ed Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tPR c++/50958\n+\t* expr.c (cpp_userdef_char_remove_type): Fix typo.\n+\n 2011-11-03  Michael Matz  <matz@suse.de>\n \n \tPR bootstrap/50857"}, {"sha": "d56e56a631114b98ee8f0e49ae7acadce8fca8d3", "filename": "libcpp/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e74ce3f94ece593b30c97a5f7427c3de601a8c5/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=7e74ce3f94ece593b30c97a5f7427c3de601a8c5", "patch": "@@ -284,9 +284,9 @@ cpp_userdef_char_remove_type (enum cpp_ttype type)\n   else if (type == CPP_WCHAR_USERDEF)\n     return CPP_WCHAR;\n   else if (type == CPP_CHAR16_USERDEF)\n-    return CPP_STRING16;\n+    return CPP_CHAR16;\n   else if (type == CPP_CHAR32_USERDEF)\n-    return CPP_STRING32;\n+    return CPP_CHAR32;\n   else\n     return type;\n }"}]}