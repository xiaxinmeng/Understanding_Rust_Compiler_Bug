{"sha": "b1b6774f67ee3760778596db91bbe5a6ce73a172", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFiNjc3NGY2N2VlMzc2MDc3ODU5NmRiOTFiYmU1YTZjZTczYTE3Mg==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2016-10-24T11:02:51Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2016-10-24T11:02:51Z"}, "message": "re PR target/78093 ([avr] New variable attribute \"absdata\" and option \"-mabsdata\" to enable LDS / STS on Reduced Tiny)\n\ngcc/\n\tPR target/78093\n\t* doc/extend.texi (AVR Variable Attributes) [absdata]: Document it.\n\t* config/avr/avr.c (AVR_SYMBOL_FLAG_TINY_ABSDATA): New macro.\n\t(avr_address_tiny_absdata_p): New static function.\n\t(avr_legitimate_address_p, avr_legitimize_address) [AVR_TINY]: Use\n\tit to determine validity of constant addresses.\n\t(avr_attribute_table) [absdata]: New variable attribute...\n\t(avr_handle_absdata_attribute): ...and handler.\n\t(avr_decl_absdata_p): New static function.\n\t(avr_encode_section_info) [AVR_TINY]: Use it to add flag\n\tAVR_SYMBOL_FLAG_TINY_ABSDATA to respective symbols_refs.\n\t(avr_address_cost) [AVR_TINY]: absdata addresses cost 2.\ngcc/testsuite/\n\tPR target/78093\n\t* lib/target-supports.exp (check_effective_target_avr_tiny): New proc.\n\t* gcc.target/avr/torture/tiny-absdata-1.c: New test.\n\nFrom-SVN: r241468", "tree": {"sha": "b7c4975fab294b75e604f23f0d4cc6a39addca46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7c4975fab294b75e604f23f0d4cc6a39addca46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1b6774f67ee3760778596db91bbe5a6ce73a172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b6774f67ee3760778596db91bbe5a6ce73a172", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1b6774f67ee3760778596db91bbe5a6ce73a172", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b6774f67ee3760778596db91bbe5a6ce73a172/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06d1ff9050a32a7dda55e1905de3d4fd6eb76452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d1ff9050a32a7dda55e1905de3d4fd6eb76452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06d1ff9050a32a7dda55e1905de3d4fd6eb76452"}], "stats": {"total": 245, "additions": 234, "deletions": 11}, "files": [{"sha": "291ef4507de8dc21990ef0aabb8bf5a55244b1ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b6774f67ee3760778596db91bbe5a6ce73a172/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b6774f67ee3760778596db91bbe5a6ce73a172/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1b6774f67ee3760778596db91bbe5a6ce73a172", "patch": "@@ -1,3 +1,18 @@\n+2016-10-24  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/78093\n+\t* doc/extend.texi (AVR Variable Attributes) [absdata]: Document it.\n+\t* config/avr/avr.c (AVR_SYMBOL_FLAG_TINY_ABSDATA): New macro.\n+\t(avr_address_tiny_absdata_p): New static function.\n+\t(avr_legitimate_address_p, avr_legitimize_address) [AVR_TINY]: Use\n+\tit to determine validity of constant addresses.\n+\t(avr_attribute_table) [absdata]: New variable attribute...\n+\t(avr_handle_absdata_attribute): ...and handler.\n+\t(avr_decl_absdata_p): New static function.\n+\t(avr_encode_section_info) [AVR_TINY]: Use it to add flag\n+\tAVR_SYMBOL_FLAG_TINY_ABSDATA to respective symbols_refs.\n+\t(avr_address_cost) [AVR_TINY]: absdata addresses cost 2.\n+\n 2016-10-24  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/78076"}, {"sha": "1a49fdc0d9651252ce5b033f3c4745f296764a57", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 98, "deletions": 11, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b6774f67ee3760778596db91bbe5a6ce73a172/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b6774f67ee3760778596db91bbe5a6ce73a172/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=b1b6774f67ee3760778596db91bbe5a6ce73a172", "patch": "@@ -85,6 +85,10 @@\n #define AVR_SYMBOL_FLAG_TINY_PM \\\n   (SYMBOL_FLAG_MACH_DEP << 7)\n \n+/* (AVR_TINY only): Symbol has attribute absdata */\n+#define AVR_SYMBOL_FLAG_TINY_ABSDATA \\\n+  (SYMBOL_FLAG_MACH_DEP << 8)\n+\n #define TINY_ADIW(REG1, REG2, I)                                \\\n     \"subi \" #REG1 \",lo8(-(\" #I \"))\" CR_TAB                      \\\n     \"sbci \" #REG2 \",hi8(-(\" #I \"))\"\n@@ -1791,6 +1795,28 @@ avr_mode_dependent_address_p (const_rtx addr ATTRIBUTE_UNUSED, addr_space_t as)\n }\n \n \n+/* Return true if rtx X is a CONST_INT, CONST or SYMBOL_REF\n+   address with the `absdata' variable attribute, i.e. respective\n+   data can be read / written by LDS / STS instruction.\n+   This is used only for AVR_TINY.  */\n+\n+static bool\n+avr_address_tiny_absdata_p (rtx x, machine_mode mode)\n+{\n+  if (CONST == GET_CODE (x))\n+    x = XEXP (XEXP (x, 0), 0);\n+\n+  if (SYMBOL_REF_P (x))\n+    return SYMBOL_REF_FLAGS (x) & AVR_SYMBOL_FLAG_TINY_ABSDATA;\n+\n+  if (CONST_INT_P (x)\n+      && IN_RANGE (INTVAL (x), 0, 0xc0 - GET_MODE_SIZE (mode)))\n+    return true;\n+\n+  return false;\n+}\n+\n+\n /* Helper function for `avr_legitimate_address_p'.  */\n \n static inline bool\n@@ -1875,8 +1901,7 @@ avr_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n       /* avrtiny's load / store instructions only cover addresses 0..0xbf:\n          IN / OUT range is 0..0x3f and LDS / STS can access 0x40..0xbf.  */\n \n-      ok = (CONST_INT_P (x)\n-            && IN_RANGE (INTVAL (x), 0, 0xc0 - GET_MODE_SIZE (mode)));\n+      ok = avr_address_tiny_absdata_p (x, mode);\n     }\n \n   if (avr_log.legitimate_address_p)\n@@ -1918,8 +1943,7 @@ avr_legitimize_address (rtx x, rtx oldx, machine_mode mode)\n   if (AVR_TINY)\n     {\n       if (CONSTANT_ADDRESS_P (x)\n-          && !(CONST_INT_P (x)\n-               && IN_RANGE (INTVAL (x), 0, 0xc0 - GET_MODE_SIZE (mode))))\n+          && ! avr_address_tiny_absdata_p (x, mode))\n         {\n           x = force_reg (Pmode, x);\n         }\n@@ -9148,6 +9172,32 @@ avr_handle_fntype_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+static tree\n+avr_handle_absdata_attribute (tree *node, tree name, tree /* args */,\n+                              int /* flags */, bool *no_add)\n+{\n+  location_t loc = DECL_SOURCE_LOCATION (*node);\n+\n+  if (AVR_TINY)\n+    {\n+      if (TREE_CODE (*node) != VAR_DECL\n+          || (!TREE_STATIC (*node) && !DECL_EXTERNAL (*node)))\n+        {\n+          warning_at (loc, OPT_Wattributes, \"%qE attribute only applies to\"\n+                      \" variables in static storage\", name);\n+          *no_add = true;\n+        }\n+    }\n+  else\n+    {\n+      warning_at (loc, OPT_Wattributes, \"%qE attribute only supported\"\n+                  \" for reduced Tiny cores\", name);\n+      *no_add = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n static tree\n avr_handle_addr_attribute (tree *node, tree name, tree args,\n \t\t\t   int flags ATTRIBUTE_UNUSED, bool *no_add)\n@@ -9218,8 +9268,8 @@ avr_eval_addr_attrib (rtx x)\n       if (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_IO)\n \t{\n \t  attr = lookup_attribute (\"io\", DECL_ATTRIBUTES (decl));\n-         if (!attr || !TREE_VALUE (attr))\n-           attr = lookup_attribute (\"io_low\", DECL_ATTRIBUTES (decl));\n+          if (!attr || !TREE_VALUE (attr))\n+            attr = lookup_attribute (\"io_low\", DECL_ATTRIBUTES (decl));\n \t  gcc_assert (attr);\n \t}\n       if (!attr || !TREE_VALUE (attr))\n@@ -9255,6 +9305,8 @@ avr_attribute_table[] =\n     false },\n   { \"address\",   1, 1, false, false, false,  avr_handle_addr_attribute,\n     false },\n+  { \"absdata\",   0, 0, true, false, false,  avr_handle_absdata_attribute,\n+    false },\n   { NULL,        0, 0, false, false, false, NULL, false }\n };\n \n@@ -9339,6 +9391,17 @@ avr_progmem_p (tree decl, tree attributes)\n }\n \n \n+/* Return true if DECL has attribute `absdata' set.  This function should\n+   only be used for AVR_TINY.  */\n+\n+static bool\n+avr_decl_absdata_p (tree decl, tree attributes)\n+{\n+  return (TREE_CODE (decl) == VAR_DECL\n+          && NULL_TREE != lookup_attribute (\"absdata\", attributes));\n+}\n+\n+\n /* Scan type TYP for pointer references to address space ASn.\n    Return ADDR_SPACE_GENERIC (i.e. 0) if all pointers targeting\n    the AS are also declared to be CONST.\n@@ -9694,6 +9757,8 @@ avr_section_type_flags (tree decl, const char *name, int reloc)\n static void\n avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n {\n+  tree addr_attr = NULL_TREE;\n+\n   /* In avr_handle_progmem_attribute, DECL_INITIAL is not yet\n      readily available, see PR34734.  So we postpone the warning\n      about uninitialized data in program memory section until here.  */\n@@ -9735,7 +9800,7 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n \n       tree io_low_attr = lookup_attribute (\"io_low\", attr);\n       tree io_attr = lookup_attribute (\"io\", attr);\n-      tree addr_attr;\n+\n       if (io_low_attr\n \t  && TREE_VALUE (io_low_attr) && TREE_VALUE (TREE_VALUE (io_low_attr)))\n \taddr_attr = io_attr;\n@@ -9763,14 +9828,32 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n   if (AVR_TINY\n       && decl\n       && VAR_DECL == TREE_CODE (decl)\n-      && -1 == avr_progmem_p (decl, DECL_ATTRIBUTES (decl))\n       && MEM_P (rtl)\n       && SYMBOL_REF_P (XEXP (rtl, 0)))\n     {\n-      /* Tag symbols for later addition of 0x4000 (AVR_TINY_PM_OFFSET).  */\n-\n       rtx sym = XEXP (rtl, 0);\n-      SYMBOL_REF_FLAGS (sym) |= AVR_SYMBOL_FLAG_TINY_PM;\n+\n+      if (-1 == avr_progmem_p (decl, DECL_ATTRIBUTES (decl)))\n+        {\n+          // Tag symbols for later addition of 0x4000 (AVR_TINY_PM_OFFSET).\n+          SYMBOL_REF_FLAGS (sym) |= AVR_SYMBOL_FLAG_TINY_PM;\n+        }\n+\n+      if (avr_decl_absdata_p (decl, DECL_ATTRIBUTES (decl))\n+          || (addr_attr\n+              // If addr_attr is non-null, it has an argument.  Peek into it.\n+              && TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (addr_attr))) < 0xc0))\n+        {\n+          // May be accessed by LDS / STS.\n+          SYMBOL_REF_FLAGS (sym) |= AVR_SYMBOL_FLAG_TINY_ABSDATA;\n+        }\n+\n+      if (-1 == avr_progmem_p (decl, DECL_ATTRIBUTES (decl))\n+          && avr_decl_absdata_p (decl, DECL_ATTRIBUTES (decl)))\n+        {\n+          error (\"%q+D has incompatible attributes %qs and %qs\",\n+                 decl, \"progmem\", \"absdata\");\n+        }\n     }\n }\n \n@@ -10900,6 +10983,10 @@ avr_address_cost (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n       if (optimize > 0\n           && io_address_operand (x, QImode))\n         cost = 2;\n+\n+      if (AVR_TINY\n+          && avr_address_tiny_absdata_p (x, QImode))\n+        cost = 2;\n     }\n \n   if (avr_log.address_cost)"}, {"sha": "0669f7999beb078822e471352036d8f13517812d", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b6774f67ee3760778596db91bbe5a6ce73a172/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b6774f67ee3760778596db91bbe5a6ce73a172/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=b1b6774f67ee3760778596db91bbe5a6ce73a172", "patch": "@@ -5973,6 +5973,33 @@ memory-mapped peripherals that may lie outside the io address range.\n volatile int porta __attribute__((address (0x600)));\n @end smallexample\n \n+@item absdata\n+@cindex @code{absdata} variable attribute, AVR\n+Variables in static storage and with the @code{absdata} attribute can\n+be accessed by the @code{LDS} and @code{STS} instructions which take\n+absolute addresses.\n+\n+@itemize @bullet\n+@item\n+This attribute is only supported for the reduced AVR Tiny core\n+like ATtiny40.\n+\n+@item\n+You must make sure that respective data is located in the\n+address range @code{0x40}@dots{}@code{0xbf} accessible by\n+@code{LDS} and @code{STS}.  One way to achieve this as an\n+appropriate linker description file.\n+\n+@item\n+If the location does not fit the address range of @code{LDS}\n+and @code{STS}, there is currently (Binutils 2.26) just an unspecific\n+warning like\n+@quotation\n+@code{module.c:(.text+0x1c): warning: internal error: out of range error}\n+@end quotation\n+\n+@end itemize\n+\n @end table\n \n @node Blackfin Variable Attributes"}, {"sha": "bc9bf6760327c0681cdd20432f18ffc60b7382a5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b6774f67ee3760778596db91bbe5a6ce73a172/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b6774f67ee3760778596db91bbe5a6ce73a172/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1b6774f67ee3760778596db91bbe5a6ce73a172", "patch": "@@ -1,3 +1,9 @@\n+2016-10-24  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/78093\n+\t* lib/target-supports.exp (check_effective_target_avr_tiny): New proc.\n+\t* gcc.target/avr/torture/tiny-absdata-1.c: New test.\n+\n 2016-10-24  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \n \t* gcc.target/arm/pure-code/pure-code.exp: Restore saved globals."}, {"sha": "c1c645fc7a683052e40aee9813833907f904a805", "filename": "gcc/testsuite/gcc.target/avr/torture/tiny-absdata-1.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b6774f67ee3760778596db91bbe5a6ce73a172/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Ftiny-absdata-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b6774f67ee3760778596db91bbe5a6ce73a172/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Ftiny-absdata-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Ftiny-absdata-1.c?ref=b1b6774f67ee3760778596db91bbe5a6ce73a172", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target avr_tiny } */\n+\n+typedef struct\n+{\n+  char a, b, c;\n+} abc_t;\n+\n+extern char varA __attribute__((absdata));\n+extern char varB __attribute__((absdata));\n+\n+extern int arrayA[] __attribute__((absdata));\n+extern int arrayB[] __attribute__((absdata));\n+extern char arrayC[] __attribute__((address(0x80)));\n+\n+extern abc_t abc __attribute__((absdata));\n+\n+char get_1 (void)\n+{\n+  return varA;\n+}\n+\n+int get_2 (void)\n+{\n+  return arrayA[3];\n+}\n+\n+char get_3 (void)\n+{\n+  return abc.a + abc.b + abc.c;\n+}\n+\n+\n+void put_1 (char b)\n+{\n+  varB = b;\n+}\n+\n+void put_2 (int b)\n+{\n+  arrayB[3] = b;\n+}\n+\n+void put_3 (void)\n+{\n+  abc.a = abc.b = abc.c = 0;\n+}\n+\n+void put_4 (void)\n+{\n+  arrayC[0] = arrayC[1] = arrayC[2] = 0;\n+}\n+\n+/* { dg-final { scan-assembler \"lds r\\[0-9\\]+,varA\" } } */\n+/* { dg-final { scan-assembler \"lds r\\[0-9\\]+,arrayA\\\\+6\" } } */\n+/* { dg-final { scan-assembler \"lds r\\[0-9\\]+,arrayA\\\\+6\\\\+1\" } } */\n+/* { dg-final { scan-assembler \"lds r\\[0-9\\]+,abc\" } } */\n+/* { dg-final { scan-assembler \"lds r\\[0-9\\]+,abc\\\\+1\" } } */\n+/* { dg-final { scan-assembler \"lds r\\[0-9\\]+,abc\\\\+2\" } } */\n+\n+/* { dg-final { scan-assembler \"sts varB,\" } } */\n+/* { dg-final { scan-assembler \"sts arrayB\\\\+6,\" } } */\n+/* { dg-final { scan-assembler \"sts arrayB\\\\+6\\\\+1,\" } } */\n+/* { dg-final { scan-assembler \"sts arrayC,\" } } */\n+/* { dg-final { scan-assembler \"sts arrayC\\\\+1,\" } } */\n+/* { dg-final { scan-assembler \"sts arrayC\\\\+2,\" } } */\n+\n+/* { dg-final { scan-assembler \"sts abc,\" } } */\n+/* { dg-final { scan-assembler \"sts abc\\\\+1,\" } } */\n+/* { dg-final { scan-assembler \"sts abc\\\\+2,\" } } */"}, {"sha": "b5a9faab5a47d01371c6402a5b07d34071dbc34b", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b6774f67ee3760778596db91bbe5a6ce73a172/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b6774f67ee3760778596db91bbe5a6ce73a172/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=b1b6774f67ee3760778596db91bbe5a6ce73a172", "patch": "@@ -7784,6 +7784,24 @@ proc check_effective_target_aarch64_large { } {\n     }\n }\n \n+\n+# Return 1 if this is a reduced AVR Tiny core.  Such cores have different\n+# register set, instruction set, addressing capabilities and ABI.\n+\n+proc check_effective_target_avr_tiny { } {\n+    if { [istarget avr*-*-*] } {\n+        return [check_no_compiler_messages avr_tiny object {\n+            #ifdef __AVR_TINY__\n+            int dummy;\n+            #else\n+            #error target not a reduced AVR Tiny core\n+            #endif\n+        }]\n+    } else {\n+        return 0\n+    }\n+}\n+\n # Return 1 if <fenv.h> is available with all the standard IEEE\n # exceptions and floating-point exceptions are raised by arithmetic\n # operations.  (If the target requires special options for \"inexact\""}]}