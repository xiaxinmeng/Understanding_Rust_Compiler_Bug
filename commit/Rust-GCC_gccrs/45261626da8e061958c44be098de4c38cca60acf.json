{"sha": "45261626da8e061958c44be098de4c38cca60acf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUyNjE2MjZkYThlMDYxOTU4YzQ0YmUwOThkZTRjMzhjY2E2MGFjZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-11-06T17:06:05Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-11-06T17:06:05Z"}, "message": "sparc.c (scan_record_type): Handle vector types.\n\n\t* config/sparc/sparc.c (scan_record_type): Handle vector types.\n\t(function_arg_slotno): Handle vector types specially.\n\t(function_arg_record_value_1): Split fields with vector type and\n\tBLKmode into their subparts.\n\t(function_arg_record_value_2): Likewise.  Be prepared to handle\n\tmore than 2 registers per field.\n\t(function_arg_union_value): Increment regno inside the loop.\n\t(function_arg_vector_value): New function.\n\t(function_arg): Use it to split fields with vector type and\n\tBLKmode into their subparts and build a PARALLEL.  Treat\n\tother vector types like floats.\n\t(function_value): Likewise.\n\t(sparc_pass_by_reference): Handle vector types.\n\t(sparc_return_in_memory): Likewise.\n\nFrom-SVN: r90179", "tree": {"sha": "e467f18493f5713b5223d86ab110b758c6dc221e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e467f18493f5713b5223d86ab110b758c6dc221e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45261626da8e061958c44be098de4c38cca60acf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45261626da8e061958c44be098de4c38cca60acf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45261626da8e061958c44be098de4c38cca60acf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45261626da8e061958c44be098de4c38cca60acf/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d43449beeca514721c7bc676fe7b5879810ca42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d43449beeca514721c7bc676fe7b5879810ca42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d43449beeca514721c7bc676fe7b5879810ca42"}], "stats": {"total": 304, "additions": 232, "deletions": 72}, "files": [{"sha": "138c1406c60c9f45c2d2cfd6694f6ee26696186e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45261626da8e061958c44be098de4c38cca60acf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45261626da8e061958c44be098de4c38cca60acf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45261626da8e061958c44be098de4c38cca60acf", "patch": "@@ -1,3 +1,20 @@\n+2004-11-06  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* config/sparc/sparc.c (scan_record_type): Handle vector types.\n+\t(function_arg_slotno): Handle vector types specially.\n+\t(function_arg_record_value_1): Split fields with vector type and\n+\tBLKmode into their subparts.\n+\t(function_arg_record_value_2): Likewise.  Be prepared to handle\n+\tmore than 2 registers per field.\n+\t(function_arg_union_value): Increment regno inside the loop.\n+\t(function_arg_vector_value): New function.\n+\t(function_arg): Use it to split fields with vector type and\n+\tBLKmode into their subparts and build a PARALLEL.  Treat\n+\tother vector types like floats.\n+\t(function_value): Likewise.\n+\t(sparc_pass_by_reference): Handle vector types.\n+\t(sparc_return_in_memory): Likewise.\n+\n 2004-11-06  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-cfg.c (find_taken_edge_cond_expr): Remove an \"if\""}, {"sha": "d44ab95877c823ca0922333359653b2067ecb408", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 215, "deletions": 72, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45261626da8e061958c44be098de4c38cca60acf/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45261626da8e061958c44be098de4c38cca60acf/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=45261626da8e061958c44be098de4c38cca60acf", "patch": "@@ -4928,8 +4928,7 @@ output_sibcall (rtx insn, rtx call_operand)\n       _Complex double            16        memory         FP reg.\n       _Complex long double       32        memory         FP reg.\n \n-      vector float             <=32        memory         FP reg.\n-      vector float              >32        memory         memory\n+      vector float              any        memory         memory\n \n       aggregate                 any        memory         memory\n \n@@ -4974,8 +4973,8 @@ implemented by the Sun compiler.\n Note #2: integral vector types follow the scalar floating-point types\n conventions to match what is implemented by the Sun VIS SDK.\n \n-Note #3: floating-point vector types follow the complex floating-point\n-types conventions.  */\n+Note #3: floating-point vector types follow the aggregate types \n+conventions.  */\n \n \n /* Maximum number of int regs for args.  */\n@@ -5037,7 +5036,9 @@ scan_record_type (tree type, int *intregs_p, int *fpregs_p, int *packed_p)\n \t{\n \t  if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n \t    scan_record_type (TREE_TYPE (field), intregs_p, fpregs_p, 0);\n-\t  else if (FLOAT_TYPE_P (TREE_TYPE (field)) && TARGET_FPU)\n+\t  else if ((FLOAT_TYPE_P (TREE_TYPE (field))\n+\t\t   || TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE)\n+\t\t  && TARGET_FPU)\n \t    *fpregs_p = 1;\n \t  else\n \t    *intregs_p = 1;\n@@ -5072,6 +5073,7 @@ function_arg_slotno (const struct sparc_args *cum, enum machine_mode mode,\n \t\t ? SPARC_INCOMING_INT_ARG_FIRST\n \t\t : SPARC_OUTGOING_INT_ARG_FIRST);\n   int slotno = cum->words;\n+  enum mode_class mclass;\n   int regno;\n \n   *ppadding = 0;\n@@ -5091,12 +5093,37 @@ function_arg_slotno (const struct sparc_args *cum, enum machine_mode mode,\n       && (slotno & 1) != 0)\n     slotno++, *ppadding = 1;\n \n-  switch (GET_MODE_CLASS (mode))\n+  mclass = GET_MODE_CLASS (mode);\n+  if (type && TREE_CODE (type) == VECTOR_TYPE)\n+    {\n+      /* Vector types deserve special treatment because they are\n+\t polymorphic wrt their mode, depending upon whether VIS\n+\t instructions are enabled.  */\n+      if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)\n+\t{\n+\t  /* The SPARC port defines no floating-point vector modes.  */\n+\t  if (mode != BLKmode)\n+\t    abort ();\n+\t}\n+      else\n+\t{\n+\t  /* Integral vector types should either have a vector\n+\t     mode or an integral mode, because we are guaranteed\n+\t     by pass_by_reference that their size is not greater\n+\t     than 16 bytes and TImode is 16-byte wide.  */\n+\t  if (mode == BLKmode)\n+\t    abort ();\n+\n+\t  /* Vector integers are handled like floats according to\n+\t     the Sun VIS SDK.  */\n+\t  mclass = MODE_FLOAT;\n+\t}\n+    }\n+\n+  switch (mclass)\n     {\n     case MODE_FLOAT:\n     case MODE_COMPLEX_FLOAT:\n-    case MODE_VECTOR_INT:\n-    case MODE_VECTOR_FLOAT:\n       if (TARGET_ARCH64 && TARGET_FPU && named)\n \t{\n \t  if (slotno >= SPARC_FP_ARG_MAX)\n@@ -5132,18 +5159,21 @@ function_arg_slotno (const struct sparc_args *cum, enum machine_mode mode,\n \t  && (slotno & 1) != 0)\n \tslotno++, *ppadding = 1;\n \n-      if (TARGET_ARCH32 || (type && TREE_CODE (type) == UNION_TYPE))\n+      if (TARGET_ARCH32 || !type || (TREE_CODE (type) == UNION_TYPE))\n \t{\n \t  if (slotno >= SPARC_INT_ARG_MAX)\n \t    return -1;\n \t  regno = regbase + slotno;\n \t}\n-      else  /* TARGET_ARCH64 && type && TREE_CODE (type) == RECORD_TYPE */\n+      else  /* TARGET_ARCH64 && type */\n \t{\n \t  int intregs_p = 0, fpregs_p = 0, packed_p = 0;\n \n \t  /* First see what kinds of registers we would need.  */\n-\t  scan_record_type (type, &intregs_p, &fpregs_p, &packed_p);\n+\t  if (TREE_CODE (type) == VECTOR_TYPE)\n+\t    fpregs_p = 1;\n+\t  else\n+\t    scan_record_type (type, &intregs_p, &fpregs_p, &packed_p);\n \n \t  /* The ABI obviously doesn't specify how packed structures\n \t     are passed.  These are defined to be passed in int regs\n@@ -5274,8 +5304,12 @@ function_arg_record_value_1 (tree type, HOST_WIDE_INT startbitpos,\n \n \t      /* There's no need to check this_slotno < SPARC_FP_ARG MAX.\n \t\t If it wasn't true we wouldn't be here.  */\n-\t      parms->nregs += 1;\n-\t      if (TREE_CODE (TREE_TYPE (field)) == COMPLEX_TYPE)\n+\t      if (TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE\n+\t\t  && DECL_MODE (field) == BLKmode)\n+\t\tparms->nregs += TYPE_VECTOR_SUBPARTS (TREE_TYPE (field));\n+\t      else if (TREE_CODE (TREE_TYPE (field)) == COMPLEX_TYPE)\n+\t\tparms->nregs += 2;\n+\t      else\n \t\tparms->nregs += 1;\n \t    }\n \t  else\n@@ -5389,34 +5423,41 @@ function_arg_record_value_2 (tree type, HOST_WIDE_INT startbitpos,\n \t\t   && ! packed_p)\n \t    {\n \t      int this_slotno = parms->slotno + bitpos / BITS_PER_WORD;\n-\t      int regno;\n+\t      int regno, nregs, pos;\n \t      enum machine_mode mode = DECL_MODE (field);\n \t      rtx reg;\n \n \t      function_arg_record_value_3 (bitpos, parms);\n-\t      switch (mode)\n-\t\t{\n-\t\tcase SCmode: mode = SFmode; break;\n-\t\tcase DCmode: mode = DFmode; break;\n-\t\tcase TCmode: mode = TFmode; break;\n-\t\tdefault: break;\n+\n+\t      if (TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE\n+\t\t  && mode == BLKmode)\n+\t        {\n+\t\t  mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (field)));\n+\t\t  nregs = TYPE_VECTOR_SUBPARTS (TREE_TYPE (field));\n \t\t}\n+\t      else if (TREE_CODE (TREE_TYPE (field)) == COMPLEX_TYPE)\n+\t        {\n+\t\t  mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (field)));\n+\t\t  nregs = 2;\n+\t\t}\n+\t      else\n+\t        nregs = 1;\n+\n \t      regno = SPARC_FP_ARG_FIRST + this_slotno * 2;\n \t      if (GET_MODE_SIZE (mode) <= 4 && (bitpos & 32) != 0)\n \t\tregno++;\n \t      reg = gen_rtx_REG (mode, regno);\n+\t      pos = bitpos / BITS_PER_UNIT;\n \t      XVECEXP (parms->ret, 0, parms->stack + parms->nregs)\n-\t\t= gen_rtx_EXPR_LIST (VOIDmode, reg,\n-\t\t\t   GEN_INT (bitpos / BITS_PER_UNIT));\n+\t\t= gen_rtx_EXPR_LIST (VOIDmode, reg, GEN_INT (pos));\n \t      parms->nregs += 1;\n-\t      if (TREE_CODE (TREE_TYPE (field)) == COMPLEX_TYPE)\n+\t      while (--nregs > 0)\n \t\t{\n \t\t  regno += GET_MODE_SIZE (mode) / 4;\n \t  \t  reg = gen_rtx_REG (mode, regno);\n+\t\t  pos += GET_MODE_SIZE (mode);\n \t\t  XVECEXP (parms->ret, 0, parms->stack + parms->nregs)\n-\t\t    = gen_rtx_EXPR_LIST (VOIDmode, reg,\n-\t\t\tGEN_INT ((bitpos + GET_MODE_BITSIZE (mode))\n-\t\t\t\t / BITS_PER_UNIT));\n+\t\t    = gen_rtx_EXPR_LIST (VOIDmode, reg, GEN_INT (pos));\n \t\t  parms->nregs += 1;\n \t\t}\n \t    }\n@@ -5547,14 +5588,47 @@ function_arg_union_value (int size, enum machine_mode mode, int regno)\n   int nwords = ROUND_ADVANCE (size), i;\n   rtx regs;\n \n-  /* Unions are passed left-justified.  */\n   regs = gen_rtx_PARALLEL (mode, rtvec_alloc (nwords));\n \n   for (i = 0; i < nwords; i++)\n-    XVECEXP (regs, 0, i)\n-      = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t   gen_rtx_REG (word_mode, regno + i),\n-\t\t\t   GEN_INT (UNITS_PER_WORD * i));\n+    {\n+      /* Unions are passed left-justified.  */\n+      XVECEXP (regs, 0, i)\n+\t= gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t     gen_rtx_REG (word_mode, regno),\n+\t\t\t     GEN_INT (UNITS_PER_WORD * i));\n+      regno++;\n+    }\n+\n+  return regs;\n+}\n+\n+/* Used by function_arg and function_value to implement the conventions\n+   for passing and returning large (BLKmode) vectors.\n+   Return an expression valid as a return value for the two macros\n+   FUNCTION_ARG and FUNCTION_VALUE.\n+\n+   SIZE is the size in bytes of the vector.\n+   BASE_MODE is the argument's base machine mode.\n+   REGNO is the FP hard register the vector will be passed in.  */\n+\n+static rtx\n+function_arg_vector_value (int size, enum machine_mode base_mode, int regno)\n+{\n+  unsigned short base_mode_size = GET_MODE_SIZE (base_mode);\n+  int nregs = size / base_mode_size, i;\n+  rtx regs;\n+\n+  regs = gen_rtx_PARALLEL (BLKmode, rtvec_alloc (nregs));\n+\n+  for (i = 0; i < nregs; i++)\n+    {\n+      XVECEXP (regs, 0, i)\n+\t= gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t     gen_rtx_REG (base_mode, regno),\n+\t\t\t     GEN_INT (base_mode_size * i));\n+      regno += base_mode_size / 4;\n+    }\n \n   return regs;\n }\n@@ -5582,6 +5656,7 @@ function_arg (const struct sparc_args *cum, enum machine_mode mode,\n \t\t ? SPARC_INCOMING_INT_ARG_FIRST\n \t\t : SPARC_OUTGOING_INT_ARG_FIRST);\n   int slotno, regno, padding;\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n   rtx reg;\n \n   slotno = function_arg_slotno (cum, mode, type, named, incoming_p,\n@@ -5615,14 +5690,29 @@ function_arg (const struct sparc_args *cum, enum machine_mode mode,\n \n       return function_arg_union_value (size, mode, regno);\n     }\n+  else if (type && TREE_CODE (type) == VECTOR_TYPE)\n+    {\n+      /* Vector types deserve special treatment because they are\n+\t polymorphic wrt their mode, depending upon whether VIS\n+\t instructions are enabled.  */\n+      HOST_WIDE_INT size = int_size_in_bytes (type);\n+\n+      if (size > 16)\n+\tabort (); /* shouldn't get here */\n+\n+      if (mode == BLKmode)\n+\treturn function_arg_vector_value (size,\n+\t\t\t\t\t  TYPE_MODE (TREE_TYPE (type)),\n+\t\t\t\t\t  SPARC_FP_ARG_FIRST + 2*slotno);\n+      else\n+\tmclass = MODE_FLOAT;\n+    }\n+\n   /* v9 fp args in reg slots beyond the int reg slots get passed in regs\n      but also have the slot allocated for them.\n      If no prototype is in scope fp values in register slots get passed\n      in two places, either fp regs and int regs or fp regs and memory.  */\n-  else if ((GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t    || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n-\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+  if ((mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)\n       && SPARC_FP_REG_P (regno))\n     {\n       reg = gen_rtx_REG (mode, regno);\n@@ -5760,11 +5850,8 @@ function_arg_partial_nregs (const struct sparc_args *cum,\n   return 0;\n }\n \n-/* Return true if the argument should be passed by reference.\n-   !v9: The SPARC ABI stipulates passing struct arguments (of any size) and\n-   quad-precision floats by invisible reference.\n-   v9: Aggregates greater than 16 bytes are passed by reference.\n-   For Pascal, also pass arrays by reference.  */\n+/* Handle the TARGET_PASS_BY_REFERENCE target hook.\n+   Specify whether to pass the argument by reference.  */\n \n static bool\n sparc_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n@@ -5773,23 +5860,48 @@ sparc_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n {\n   if (TARGET_ARCH32)\n     {\n-      return ((type && AGGREGATE_TYPE_P (type))\n-\t      /* Extended ABI (as implemented by the Sun compiler) says\n-\t\t that all complex floats are passed in memory.  */\n+    /* Original SPARC 32-bit ABI says that structures and unions,\n+       and quad-precision floats are passed by reference.  For Pascal,\n+       also pass arrays by reference.  All other base types are passed\n+       in registers.\n+\n+       Extended ABI (as implemented by the Sun compiler) says that all\n+       complex floats are passed by reference.  Pass complex integers\n+       in registers up to 8 bytes.  More generally, enforce the 2-word\n+       cap for passing arguments in registers.\n+\n+       Vector ABI (as implemented by the Sun VIS SDK) says that vector\n+       integers are passed like floats of the same size, that is in\n+       registers up to 8 bytes.  Pass all vector floats by reference\n+       like structure and unions.  */\n+      return ((type && (AGGREGATE_TYPE_P (type) || VECTOR_FLOAT_TYPE_P (type)))\n \t      || mode == SCmode\n-\t      /* Enforce the 2-word cap for passing arguments in registers.\n-\t\t This affects CDImode, TFmode, DCmode, TCmode and large\n-\t\t vector modes.  */\n-\t      || GET_MODE_SIZE (mode) > 8);\n+\t      /* Catch CDImode, TFmode, DCmode and TCmode.  */\n+\t      || GET_MODE_SIZE (mode) > 8\n+\t      || (type\n+\t\t  && TREE_CODE (type) == VECTOR_TYPE\n+\t\t  && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 8));\n     }\n   else\n     {\n+    /* Original SPARC 64-bit ABI says that structures and unions\n+       smaller than 16 bytes are passed in registers, as well as\n+       all other base types.  For Pascal, pass arrays by reference.\n+       \n+       Extended ABI (as implemented by the Sun compiler) says that\n+       complex floats are passed in registers up to 16 bytes.  Pass\n+       all complex integers in registers up to 16 bytes.  More generally,\n+       enforce the 2-word cap for passing arguments in registers.\n+\n+       Vector ABI (as implemented by the Sun VIS SDK) says that vector\n+       integers are passed like floats of the same size, that is in\n+       registers (up to 16 bytes).  Pass all vector floats like structure\n+       and unions.  */\n       return ((type && TREE_CODE (type) == ARRAY_TYPE)\n \t      || (type\n-\t\t  && AGGREGATE_TYPE_P (type)\n+\t\t  && (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == VECTOR_TYPE)\n \t\t  && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 16)\n-\t      /* Enforce the 2-word cap for passing arguments in registers.\n-\t\t This affects CTImode, TCmode and large vector modes.  */\n+\t      /* Catch CTImode and TCmode.  */\n \t      || GET_MODE_SIZE (mode) > 16);\n     }\n }\n@@ -5861,30 +5973,40 @@ static bool\n sparc_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n {\n   if (TARGET_ARCH32)\n-    /* Original SPARC 32-bit ABI says that quad-precision floats\n-       and all structures are returned in memory.  Extended ABI\n-       (as implemented by the Sun compiler) says that all complex\n-       floats are returned in registers (8 FP registers at most\n-       for '_Complex long double').  Return all complex integers\n-       in registers (4 at most for '_Complex long long').  */\n+    /* Original SPARC 32-bit ABI says that structures and unions,\n+       and quad-precision floats are returned in memory.  All other\n+       base types are returned in registers.\n+\n+       Extended ABI (as implemented by the Sun compiler) says that\n+       all complex floats are returned in registers (8 FP registers\n+       at most for '_Complex long double').  Return all complex integers\n+       in registers (4 at most for '_Complex long long').\n+\n+       Vector ABI (as implemented by the Sun VIS SDK) says that vector\n+       integers are returned like floats of the same size, that is in\n+       registers up to 8 bytes and in memory otherwise.  Return all\n+       vector floats in memory like structure and unions; note that\n+       they always have BLKmode like the latter.  */\n     return (TYPE_MODE (type) == BLKmode\n \t    || TYPE_MODE (type) == TFmode\n-\t    /* Integral vector types follow the scalar FP types conventions.  */\n-\t    || (GET_MODE_CLASS (TYPE_MODE (type)) == MODE_VECTOR_INT\n-\t\t&& GET_MODE_SIZE (TYPE_MODE (type)) > 8)\n-\t    /* FP vector types follow the complex FP types conventions.  */\n-\t    || (GET_MODE_CLASS (TYPE_MODE (type)) == MODE_VECTOR_FLOAT\n-\t\t&& GET_MODE_SIZE (TYPE_MODE (type)) > 32));\n+\t    || (TREE_CODE (type) == VECTOR_TYPE\n+\t\t&& (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 8));\n   else\n     /* Original SPARC 64-bit ABI says that structures and unions\n-       smaller than 32 bytes are returned in registers.  Extended\n-       ABI (as implemented by the Sun compiler) says that all complex\n-       floats are returned in registers (8 FP registers at most\n-       for '_Complex long double').  Return all complex integers\n-       in registers (4 at most for '_Complex TItype').  */\n+       smaller than 32 bytes are returned in registers, as well as\n+       all other base types.\n+       \n+       Extended ABI (as implemented by the Sun compiler) says that all\n+       complex floats are returned in registers (8 FP registers at most\n+       for '_Complex long double').  Return all complex integers in\n+       registers (4 at most for '_Complex TItype').\n+\n+       Vector ABI (as implemented by the Sun VIS SDK) says that vector\n+       integers are returned like floats of the same size, that is in\n+       registers.  Return all vector floats like structure and unions;\n+       note that they always have BLKmode like the latter.  */\n     return ((TYPE_MODE (type) == BLKmode\n-\t     && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 32)\n-\t    || GET_MODE_SIZE (TYPE_MODE (type)) > 32);\n+\t     && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 32));\n }\n \n /* Handle the TARGET_STRUCT_VALUE target hook.\n@@ -5917,9 +6039,27 @@ function_value (tree type, enum machine_mode mode, int incoming_p)\n   int regbase = (incoming_p\n \t\t ? SPARC_OUTGOING_INT_ARG_FIRST\n \t\t : SPARC_INCOMING_INT_ARG_FIRST);\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n   int regno;\n \n-  if (TARGET_ARCH64 && type)\n+  if (type && TREE_CODE (type) == VECTOR_TYPE)\n+    {\n+      /* Vector types deserve special treatment because they are\n+\t polymorphic wrt their mode, depending upon whether VIS\n+\t instructions are enabled.  */\n+      HOST_WIDE_INT size = int_size_in_bytes (type);\n+\n+      if ((TARGET_ARCH32 && size > 8) || (TARGET_ARCH64 && size > 32))\n+\tabort (); /* shouldn't get here */\n+\n+      if (mode == BLKmode)\n+\treturn function_arg_vector_value (size,\n+\t\t\t\t\t  TYPE_MODE (TREE_TYPE (type)),\n+\t\t\t\t\t  SPARC_FP_ARG_FIRST);\n+      else\n+\tmclass = MODE_FLOAT;\n+    }\n+  else if (type && TARGET_ARCH64)\n     {\n       if (TREE_CODE (type) == RECORD_TYPE)\n \t{\n@@ -5962,13 +6102,16 @@ function_value (tree type, enum machine_mode mode, int incoming_p)\n \t     for unions in that case.  */\n \t  if (mode == BLKmode)\n \t    return function_arg_union_value (bytes, mode, regbase);\n+\t  else\n+\t    mclass = MODE_INT;\n \t}\n-      else if (GET_MODE_CLASS (mode) == MODE_INT\n+      else if (mclass == MODE_INT\n \t       && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \tmode = word_mode;\n     }\n \n-  if (TARGET_FPU && (FLOAT_MODE_P (mode) || VECTOR_MODE_P (mode)))\n+  if ((mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)\n+      && TARGET_FPU)\n     regno = SPARC_FP_ARG_FIRST;\n   else\n     regno = regbase;"}]}