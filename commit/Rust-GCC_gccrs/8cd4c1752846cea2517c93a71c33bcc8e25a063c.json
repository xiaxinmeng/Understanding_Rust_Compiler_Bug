{"sha": "8cd4c1752846cea2517c93a71c33bcc8e25a063c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNkNGMxNzUyODQ2Y2VhMjUxN2M5M2E3MWMzM2JjYzhlMjVhMDYzYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-08-17T17:13:42Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-08-17T17:13:42Z"}, "message": "gxxint.texi: Remove obsolete documentation of overloading code.\n\n\t* gxxint.texi: Remove obsolete documentation of overloading code.\n\t* decl.c (finish_enum): Also set TYPE_SIZE_UNIT.\n\t* tree.c (lvalue_type): Fix for arrays.\n\t* typeck.c (build_unary_op): Use lvalue_type.\n\t* call.c (add_function_candidate): Likewise.\n\t* cvt.c (convert_to_reference): Likewise.\n\t* decl2.c (lang_decode_option): Ignore -traditional.\n\nFrom-SVN: r21795", "tree": {"sha": "f93bdf9315c8122980ce7c7ba46bf398ebde9158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f93bdf9315c8122980ce7c7ba46bf398ebde9158"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cd4c1752846cea2517c93a71c33bcc8e25a063c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd4c1752846cea2517c93a71c33bcc8e25a063c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd4c1752846cea2517c93a71c33bcc8e25a063c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd4c1752846cea2517c93a71c33bcc8e25a063c/comments", "author": null, "committer": null, "parents": [{"sha": "2e245dac404f9921584d2baf3b9b98a3b88eacce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e245dac404f9921584d2baf3b9b98a3b88eacce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e245dac404f9921584d2baf3b9b98a3b88eacce"}], "stats": {"total": 124, "additions": 21, "deletions": 103}, "files": [{"sha": "58ee77c90423201ff9075149804dac8f4e26ddf3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8cd4c1752846cea2517c93a71c33bcc8e25a063c", "patch": "@@ -1,5 +1,16 @@\n 1998-08-17  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* gxxint.texi: Remove obsolete documentation of overloading code.\n+\n+\t* decl.c (finish_enum): Also set TYPE_SIZE_UNIT.\n+\n+\t* tree.c (lvalue_type): Fix for arrays.\n+\t* typeck.c (build_unary_op): Use lvalue_type.\n+\t* call.c (add_function_candidate): Likewise.\n+\t* cvt.c (convert_to_reference): Likewise.\n+\n+\t* decl2.c (lang_decode_option): Ignore -traditional.\n+\n \t* init.c (build_offset_ref): Don't mess with error_mark_node.\n \t* lex.c (do_scoped_id): Use cp_error.\n "}, {"sha": "5234a4b1762fba1a80c0abed93245ab32debcceb", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8cd4c1752846cea2517c93a71c33bcc8e25a063c", "patch": "@@ -1144,15 +1144,9 @@ add_function_candidate (candidates, fn, arglist, flags)\n   for (i = 0; i < len; ++i)\n     {\n       tree arg = TREE_VALUE (argnode);\n-      tree argtype = TREE_TYPE (arg);\n+      tree argtype = lvalue_type (arg);\n       tree t;\n \n-      /* An overloaded function does not have an argument type */\n-      if (TREE_CODE (arg) == OVERLOAD)\n-\targtype = unknown_type_node;\n-      argtype = cp_build_type_variant\n-\t(argtype, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n-\n       if (parmnode == void_list_node)\n \tbreak;\n       else if (parmnode)"}, {"sha": "1c6447a61b78eb0b43f3816179d8236331d9503f", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=8cd4c1752846cea2517c93a71c33bcc8e25a063c", "patch": "@@ -448,13 +448,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n       if (flags & LOOKUP_COMPLAIN)\n \t{\n \t  tree ttl = TREE_TYPE (reftype);\n-\t  tree ttr;\n-\t  \n-\t  {\n-\t    int r = TREE_READONLY (expr);\n-\t    int v = TREE_THIS_VOLATILE (expr);\n-\t    ttr = cp_build_type_variant (TREE_TYPE (expr), r, v);\n-\t  }\n+\t  tree ttr = lvalue_type (expr);\n \n \t  if (! real_lvalue_p (expr) && ! TYPE_READONLY (ttl))\n \t    {"}, {"sha": "932fb694ad975c77697122e64f44fb410fcd8acd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8cd4c1752846cea2517c93a71c33bcc8e25a063c", "patch": "@@ -11891,6 +11891,7 @@ finish_enum (enumtype, values)\n \tTYPE_MIN_VALUE (tem) = TYPE_MIN_VALUE (enumtype);\n \tTYPE_MAX_VALUE (tem) = TYPE_MAX_VALUE (enumtype);\n \tTYPE_SIZE (tem) = TYPE_SIZE (enumtype);\n+\tTYPE_SIZE_UNIT (tem) = TYPE_SIZE_UNIT (enumtype);\n \tTYPE_MODE (tem) = TYPE_MODE (enumtype);\n \tTYPE_PRECISION (tem) = TYPE_PRECISION (enumtype);\n \tTYPE_ALIGN (tem) = TYPE_ALIGN (enumtype);"}, {"sha": "6ac0beeb1844b2c46f33ecd0356c35484ad9b84c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8cd4c1752846cea2517c93a71c33bcc8e25a063c", "patch": "@@ -541,8 +541,7 @@ lang_decode_option (argc, argv)\n #endif /* ! USE_CPPLIB */\n \n   if (!strcmp (p, \"-ftraditional\") || !strcmp (p, \"-traditional\"))\n-    flag_writable_strings = 1,\n-    flag_this_is_variable = 1, flag_new_for_scope = 0;\n+    /* ignore */;\n   /* The +e options are for cfront compatibility.  They come in as\n      `-+eN', to kludge around gcc.c's argument handling.  */\n   else if (p[0] == '-' && p[1] == '+' && p[2] == 'e')"}, {"sha": "c8f312ebfca25608723a01ee3dbc51d4db751081", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=8cd4c1752846cea2517c93a71c33bcc8e25a063c", "patch": "@@ -167,77 +167,6 @@ class foo @{ public: int b; int a; foo (); @};\n Thus, @samp{b} will be initialized with 2 first, then @samp{a} will be\n initialized with 1, regardless of how they're listed in the mem-initializer.\n \n-@item Argument Matching\n-\n-In early 1993, the argument matching scheme in @sc{gnu} C++ changed\n-significantly.  The original code was completely replaced with a new\n-method that will, hopefully, be easier to understand and make fixing\n-specific cases much easier.\n-\n-The @samp{-fansi-overloading} option is used to enable the new code; at\n-some point in the future, it will become the default behavior of the\n-compiler.\n-\n-The file @file{cp-call.c} contains all of the new work, in the functions\n-@code{rank_for_overload}, @code{compute_harshness},\n-@code{compute_conversion_costs}, and @code{ideal_candidate}.\n-\n-Instead of using obscure numerical values, the quality of an argument\n-match is now represented by clear, individual codes.  The new data\n-structure @code{struct harshness} (it used to be an @code{unsigned}\n-number) contains:\n-\n-@enumerate a\n-@item the @samp{code} field, to signify what was involved in matching two\n-arguments;\n-@item the @samp{distance} field, used in situations where inheritance\n-decides which function should be called (one is ``closer'' than\n-another);\n-@item and the @samp{int_penalty} field, used by some codes as a tie-breaker.\n-@end enumerate\n-\n-The @samp{code} field is a number with a given bit set for each type of\n-code, OR'd together.  The new codes are:\n-\n-@itemize @bullet\n-@item @code{EVIL_CODE}\n-The argument was not a permissible match.\n-\n-@item @code{CONST_CODE}\n-Currently, this is only used by @code{compute_conversion_costs}, to\n-distinguish when a non-@code{const} member function is called from a\n-@code{const} member function.\n-\n-@item @code{ELLIPSIS_CODE}\n-A match against an ellipsis @samp{...} is considered worse than all others.\n-\n-@item @code{USER_CODE}\n-Used for a match involving a user-defined conversion.\n-\n-@item @code{STD_CODE}\n-A match involving a standard conversion.\n-\n-@item @code{PROMO_CODE}\n-A match involving an integral promotion.  For these, the\n-@code{int_penalty} field is used to handle the ARM's rule (XXX cite)\n-that a smaller @code{unsigned} type should promote to a @code{int}, not\n-to an @code{unsigned int}.\n-\n-@item @code{QUAL_CODE}\n-Used to mark use of qualifiers like @code{const} and @code{volatile}.\n-\n-@item @code{TRIVIAL_CODE}\n-Used for trivial conversions.  The @samp{int_penalty} field is used by\n-@code{convert_harshness} to communicate further penalty information back\n-to @code{build_overload_call_real} when deciding which function should\n-be call.\n-@end itemize\n-\n-The functions @code{convert_to_aggr} and @code{build_method_call} use\n-@code{compute_conversion_costs} to rate each argument's suitability for\n-a given candidate function (that's how we get the list of candidates for\n-@code{ideal_candidate}).\n-\n @item The Explicit Keyword\n \n The use of @code{explicit} on a constructor is used by @code{grokdeclarator}"}, {"sha": "685810ae5045eb0b7ab057b6d805ec8fceb7c7e9", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=8cd4c1752846cea2517c93a71c33bcc8e25a063c", "patch": "@@ -2368,8 +2368,10 @@ lvalue_type (arg)\n   tree type = TREE_TYPE (arg);\n   if (TREE_CODE (arg) == OVERLOAD)\n     type = unknown_type_node;\n-  return cp_build_type_variant\n-    (type, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n+  if (TREE_CODE (type) != ARRAY_TYPE)\n+    type = cp_build_type_variant\n+      (type, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n+  return type;\n }\n \n /* The type of ARG for printing error messages; denote lvalues with"}, {"sha": "1fa589c54b037e8867a6a21904f8cca94836ea0c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd4c1752846cea2517c93a71c33bcc8e25a063c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8cd4c1752846cea2517c93a71c33bcc8e25a063c", "patch": "@@ -4506,12 +4506,12 @@ build_unary_op (code, xarg, noconvert)\n       /* Note that this operation never does default_conversion\n \t regardless of NOCONVERT.  */\n \n-      argtype = TREE_TYPE (arg);\n+      argtype = lvalue_type (arg);\n       if (TREE_CODE (argtype) == REFERENCE_TYPE)\n \t{\n \t  arg = build1\n \t    (CONVERT_EXPR,\n-\t     build_pointer_type (TREE_TYPE (TREE_TYPE (arg))), arg);\n+\t     build_pointer_type (TREE_TYPE (argtype)), arg);\n \t  TREE_CONSTANT (arg) = TREE_CONSTANT (TREE_OPERAND (arg, 0));\n \t  return arg;\n \t}\n@@ -4639,18 +4639,6 @@ build_unary_op (code, xarg, noconvert)\n \t       && !lvalue_or_else (arg, \"unary `&'\"))\n \treturn error_mark_node;\n \n-      /* Ordinary case; arg is a COMPONENT_REF or a decl.  */\n-      /* If the lvalue is const or volatile,\n-\t merge that into the type that the address will point to.  */\n-      if (TREE_CODE_CLASS (TREE_CODE (arg)) == 'd'\n-\t  || TREE_CODE_CLASS (TREE_CODE (arg)) == 'r')\n-\t{\n-\t  if (TREE_READONLY (arg) || TREE_THIS_VOLATILE (arg))\n-\t    argtype = cp_build_type_variant (argtype,\n-\t\t\t\t\t    TREE_READONLY (arg),\n-\t\t\t\t\t    TREE_THIS_VOLATILE (arg));\n-\t}\n-\n       argtype = build_pointer_type (argtype);\n \n       if (mark_addressable (arg) == 0)"}]}