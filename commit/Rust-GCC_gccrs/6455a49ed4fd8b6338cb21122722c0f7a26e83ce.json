{"sha": "6455a49ed4fd8b6338cb21122722c0f7a26e83ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ1NWE0OWVkNGZkOGI2MzM4Y2IyMTEyMjcyMmMwZjdhMjZlODNjZQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2013-10-09T07:22:52Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2013-10-09T07:22:52Z"}, "message": "s390.c (struct s390_frame_layout): New field gpr_save_slots.\n\n2013-10-09  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* config/s390/s390.c (struct s390_frame_layout): New field\n\tgpr_save_slots.\n\t(cfun_save_arg_fprs_p, cfun_gpr_save_slot): New macros.\n\t(s390_reg_clobbered_rtx, s390_regs_ever_clobbered): Change type of\n\tregs_ever_clobbered to char*.\n\t(s390_regs_ever_clobbered): Check crtl->saves_all_registers\n\tinstead of cfun->has_nonlocal_label.  Ignore frame related restore\n\tINSNs.\n\t(s390_register_info): Enable FPR save slots.  Move/Copy some\n\tfunctionality into ...\n\t(s390_register_info_gprtofpr, s390_register_info_stdarg_fpr)\n\t(s390_register_info_stdarg_gpr, s390_optimize_register_info): New\n\tfunction.\n\t(s390_frame_info): Do gpr slot allocation here now.  stdarg does\n\tnot imply a stack frame.\n\t(s390_init_frame_layout): Remove variable clobbered_regs.\n\t(s390_update_register_info): Remove function.\n\t(s390_hard_regno_rename_ok): Call-saved regs without a save slot\n\tcannot be used for register renaming.\n\t(s390_hard_regno_scratch_ok): New function.\n\t(TARGET_HARD_REGNO_SCRATCH_OK): Define target hook.\n\t(s390_initial_elimination_offset): Change offset calculation of\n\tthe return address pointer.\n\t(save_gprs): Deal with only r6 being saved from the call-saved\n\tregs.\n\t(restore_gprs): Set frame related flag.\n\t(s390_save_gprs_to_fprs, s390_restore_gprs_from_fprs): New\n\tfunctions.\n\t(s390_emit_prologue): Call s390_register_info instead of\n\ts390_update_frame_layout.  Call s390_save_gprs_to_fprs.\n\t(s390_emit_epilogue): Call s390_restore_gprs_from_fprs.\n\t(s390_optimize_prologue): Call s390_optimize_register_info.\n\tTry to remove also FPR slot save/restore INSNs.  Remove frame\n\trelated flags from restore INSNs.\n\nFrom-SVN: r203303", "tree": {"sha": "0ffb33f09dccd72890f06033cbd6298a7608b5a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ffb33f09dccd72890f06033cbd6298a7608b5a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6455a49ed4fd8b6338cb21122722c0f7a26e83ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6455a49ed4fd8b6338cb21122722c0f7a26e83ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6455a49ed4fd8b6338cb21122722c0f7a26e83ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6455a49ed4fd8b6338cb21122722c0f7a26e83ce/comments", "author": null, "committer": null, "parents": [{"sha": "0dc7adad7e35a1627e03bb63074ff17a3900de9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc7adad7e35a1627e03bb63074ff17a3900de9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dc7adad7e35a1627e03bb63074ff17a3900de9f"}], "stats": {"total": 700, "additions": 503, "deletions": 197}, "files": [{"sha": "9d3cad9784e5d3fecb7899f90fdd104f651e771c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6455a49ed4fd8b6338cb21122722c0f7a26e83ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6455a49ed4fd8b6338cb21122722c0f7a26e83ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6455a49ed4fd8b6338cb21122722c0f7a26e83ce", "patch": "@@ -1,3 +1,40 @@\n+2013-10-09  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* config/s390/s390.c (struct s390_frame_layout): New field\n+\tgpr_save_slots.\n+\t(cfun_save_arg_fprs_p, cfun_gpr_save_slot): New macros.\n+\t(s390_reg_clobbered_rtx, s390_regs_ever_clobbered): Change type of\n+\tregs_ever_clobbered to char*.\n+\t(s390_regs_ever_clobbered): Check crtl->saves_all_registers\n+\tinstead of cfun->has_nonlocal_label.  Ignore frame related restore\n+\tINSNs.\n+\t(s390_register_info): Enable FPR save slots.  Move/Copy some\n+\tfunctionality into ...\n+\t(s390_register_info_gprtofpr, s390_register_info_stdarg_fpr)\n+\t(s390_register_info_stdarg_gpr, s390_optimize_register_info): New\n+\tfunction.\n+\t(s390_frame_info): Do gpr slot allocation here now.  stdarg does\n+\tnot imply a stack frame.\n+\t(s390_init_frame_layout): Remove variable clobbered_regs.\n+\t(s390_update_register_info): Remove function.\n+\t(s390_hard_regno_rename_ok): Call-saved regs without a save slot\n+\tcannot be used for register renaming.\n+\t(s390_hard_regno_scratch_ok): New function.\n+\t(TARGET_HARD_REGNO_SCRATCH_OK): Define target hook.\n+\t(s390_initial_elimination_offset): Change offset calculation of\n+\tthe return address pointer.\n+\t(save_gprs): Deal with only r6 being saved from the call-saved\n+\tregs.\n+\t(restore_gprs): Set frame related flag.\n+\t(s390_save_gprs_to_fprs, s390_restore_gprs_from_fprs): New\n+\tfunctions.\n+\t(s390_emit_prologue): Call s390_register_info instead of\n+\ts390_update_frame_layout.  Call s390_save_gprs_to_fprs.\n+\t(s390_emit_epilogue): Call s390_restore_gprs_from_fprs.\n+\t(s390_optimize_prologue): Call s390_optimize_register_info.\n+\tTry to remove also FPR slot save/restore INSNs.  Remove frame\n+\trelated flags from restore INSNs.\n+\n 2013-10-08  DJ Delorie  <dj@redhat.com>\n \n \t* config/rl78/rl78-expand.md (movqi): use operands[] not operandN."}, {"sha": "a833fd64ea0a948c12797b6f39bee0ff6a18cb2e", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 466, "deletions": 197, "changes": 663, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6455a49ed4fd8b6338cb21122722c0f7a26e83ce/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6455a49ed4fd8b6338cb21122722c0f7a26e83ce/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6455a49ed4fd8b6338cb21122722c0f7a26e83ce", "patch": "@@ -324,6 +324,12 @@ struct GTY (()) s390_frame_layout\n   int first_save_gpr_slot;\n   int last_save_gpr_slot;\n \n+  /* Location (FP register number) where GPRs (r0-r15) should\n+     be saved to.\n+      0 - does not need to be saved at all\n+     -1 - stack slot  */\n+  signed char gpr_save_slots[16];\n+\n   /* Number of first and last gpr to be saved, restored.  */\n   int first_save_gpr;\n   int first_restore_gpr;\n@@ -377,12 +383,17 @@ struct GTY(()) machine_function\n \n #define cfun_frame_layout (cfun->machine->frame_layout)\n #define cfun_save_high_fprs_p (!!cfun_frame_layout.high_fprs)\n-#define cfun_gprs_save_area_size ((cfun_frame_layout.last_save_gpr_slot -           \\\n+#define cfun_save_arg_fprs_p (!!(TARGET_64BIT\t\t\t\t\\\n+\t\t\t\t ? cfun_frame_layout.fpr_bitmap & 0x0f\t\\\n+\t\t\t\t : cfun_frame_layout.fpr_bitmap & 0x03))\n+#define cfun_gprs_save_area_size ((cfun_frame_layout.last_save_gpr_slot - \\\n   cfun_frame_layout.first_save_gpr_slot + 1) * UNITS_PER_LONG)\n #define cfun_set_fpr_save(REGNO) (cfun->machine->frame_layout.fpr_bitmap |=    \\\n   (1 << (REGNO - FPR0_REGNUM)))\n #define cfun_fpr_save_p(REGNO) (!!(cfun->machine->frame_layout.fpr_bitmap &    \\\n   (1 << (REGNO - FPR0_REGNUM))))\n+#define cfun_gpr_save_slot(REGNO) \\\n+  cfun->machine->frame_layout.gpr_save_slots[REGNO]\n \n /* Number of GPRs and FPRs used for argument passing.  */\n #define GP_ARG_NUM_REG 5\n@@ -7364,7 +7375,7 @@ find_unused_clobbered_reg (void)\n static void\n s390_reg_clobbered_rtx (rtx setreg, const_rtx set_insn ATTRIBUTE_UNUSED, void *data)\n {\n-  int *regs_ever_clobbered = (int *)data;\n+  char *regs_ever_clobbered = (char *)data;\n   unsigned int i, regno;\n   enum machine_mode mode = GET_MODE (setreg);\n \n@@ -7392,13 +7403,13 @@ s390_reg_clobbered_rtx (rtx setreg, const_rtx set_insn ATTRIBUTE_UNUSED, void *d\n    each of those regs.  */\n \n static void\n-s390_regs_ever_clobbered (int *regs_ever_clobbered)\n+s390_regs_ever_clobbered (char regs_ever_clobbered[])\n {\n   basic_block cur_bb;\n   rtx cur_insn;\n   unsigned int i;\n \n-  memset (regs_ever_clobbered, 0, 32 * sizeof (int));\n+  memset (regs_ever_clobbered, 0, 32);\n \n   /* For non-leaf functions we have to consider all call clobbered regs to be\n      clobbered.  */\n@@ -7425,7 +7436,7 @@ s390_regs_ever_clobbered (int *regs_ever_clobbered)\n      This flag is also set for the unwinding code in libgcc.\n      See expand_builtin_unwind_init.  For regs_ever_live this is done by\n      reload.  */\n-  if (cfun->has_nonlocal_label)\n+  if (crtl->saves_all_registers)\n     for (i = 0; i < 32; i++)\n       if (!call_really_used_regs[i])\n \tregs_ever_clobbered[i] = 1;\n@@ -7434,10 +7445,38 @@ s390_regs_ever_clobbered (int *regs_ever_clobbered)\n     {\n       FOR_BB_INSNS (cur_bb, cur_insn)\n \t{\n-\t  if (INSN_P (cur_insn))\n-\t    note_stores (PATTERN (cur_insn),\n-\t\t\t s390_reg_clobbered_rtx,\n-\t\t\t regs_ever_clobbered);\n+\t  rtx pat;\n+\n+\t  if (!INSN_P (cur_insn))\n+\t    continue;\n+\n+\t  pat = PATTERN (cur_insn);\n+\n+\t  /* Ignore GPR restore insns.  */\n+\t  if (epilogue_completed && RTX_FRAME_RELATED_P (cur_insn))\n+\t    {\n+\t      if (GET_CODE (pat) == SET\n+\t\t  && GENERAL_REG_P (SET_DEST (pat)))\n+\t\t{\n+\t\t  /* lgdr  */\n+\t\t  if (GET_MODE (SET_SRC (pat)) == DImode\n+\t\t      && FP_REG_P (SET_SRC (pat)))\n+\t\t    continue;\n+\n+\t\t  /* l / lg  */\n+\t\t  if (GET_CODE (SET_SRC (pat)) == MEM)\n+\t\t    continue;\n+\t\t}\n+\n+\t      /* lm / lmg */\n+\t      if (GET_CODE (pat) == PARALLEL\n+\t\t  && load_multiple_operation (pat, VOIDmode))\n+\t\tcontinue;\n+\t    }\n+\n+\t  note_stores (pat,\n+\t\t       s390_reg_clobbered_rtx,\n+\t\t       regs_ever_clobbered);\n \t}\n     }\n }\n@@ -7487,178 +7526,254 @@ s390_frame_area (int *area_bottom, int *area_top)\n   *area_bottom = b;\n   *area_top = t;\n }\n-\n-/* Fill cfun->machine with info about register usage of current function.\n-   Return in CLOBBERED_REGS which GPRs are currently considered set.  */\n+/* Update gpr_save_slots in the frame layout trying to make use of\n+   FPRs as GPR save slots.\n+   This is a helper routine of s390_register_info.  */\n \n static void\n-s390_register_info (int clobbered_regs[])\n+s390_register_info_gprtofpr ()\n {\n+  int save_reg_slot = FPR0_REGNUM;\n   int i, j;\n \n-  /* Find first and last gpr to be saved.  We trust regs_ever_live\n-     data, except that we don't save and restore global registers.\n-\n-     Also, all registers with special meaning to the compiler need\n-     to be handled extra.  */\n-\n-  s390_regs_ever_clobbered (clobbered_regs);\n+  if (!TARGET_Z10 || !TARGET_HARD_FLOAT || !crtl->is_leaf)\n+    return;\n \n-  /* fprs 8 - 15 are call saved for 64 Bit ABI.  */\n-  if (!epilogue_completed)\n+  for (i = 15; i >= 6; i--)\n     {\n-      cfun_frame_layout.fpr_bitmap = 0;\n-      cfun_frame_layout.high_fprs = 0;\n-\n-      for (i = FPR0_REGNUM; i <= FPR15_REGNUM; i++)\n-\t{\n-\t  if (call_really_used_regs[i])\n-\t    continue;\n-\t  /* During reload we have to use the df_regs_ever_live infos\n-\t     since reload is marking FPRs used as spill slots there as\n-\t     live before actually making the code changes.  Without\n-\t     this we fail during elimination offset verification.  */\n-\t  if ((clobbered_regs[i]\n-\t       || (df_regs_ever_live_p (i)\n-\t\t   && (lra_in_progress\n-\t\t       || reload_in_progress\n-\t\t       || crtl->saves_all_registers)))\n-\t      && !global_regs[i])\n-\t    {\n-\t      cfun_set_fpr_save (i);\n+      if (cfun_gpr_save_slot (i) == 0)\n+\tcontinue;\n \n-\t      if (i >= FPR8_REGNUM)\n-\t\tcfun_frame_layout.high_fprs++;\n-\t    }\n+      /* Advance to the next FP register which can be used as a\n+\t GPR save slot.  */\n+      while ((!call_really_used_regs[save_reg_slot]\n+\t      || df_regs_ever_live_p (save_reg_slot)\n+\t      || cfun_fpr_save_p (save_reg_slot))\n+\t     && FP_REGNO_P (save_reg_slot))\n+\tsave_reg_slot++;\n+      if (!FP_REGNO_P (save_reg_slot))\n+\t{\n+\t  /* We only want to use ldgr/lgdr if we can get rid of\n+\t     stm/lm entirely.  So undo the gpr slot allocation in\n+\t     case we ran out of FPR save slots.  */\n+\t  for (j = 6; j <= 15; j++)\n+\t    if (FP_REGNO_P (cfun_gpr_save_slot (j)))\n+\t      cfun_gpr_save_slot (j) = -1;\n+\t  break;\n \t}\n+      cfun_gpr_save_slot (i) = save_reg_slot++;\n     }\n+}\n \n-  for (i = 0; i < 16; i++)\n-    clobbered_regs[i] = clobbered_regs[i] && !global_regs[i] && !fixed_regs[i];\n+/* Set the bits in fpr_bitmap for FPRs which need to be saved due to\n+   stdarg.\n+   This is a helper routine for s390_register_info.  */\n \n-  if (frame_pointer_needed)\n-    clobbered_regs[HARD_FRAME_POINTER_REGNUM] = 1;\n+static void\n+s390_register_info_stdarg_fpr ()\n+{\n+  int i;\n+  int min_fpr;\n+  int max_fpr;\n+\n+  /* Save the FP argument regs for stdarg. f0, f2 for 31 bit and\n+     f0-f4 for 64 bit.  */\n+  if (!cfun->stdarg\n+      || !TARGET_HARD_FLOAT\n+      || !cfun->va_list_fpr_size\n+      || crtl->args.info.fprs >= FP_ARG_NUM_REG)\n+    return;\n+\n+  min_fpr = crtl->args.info.fprs;\n+  max_fpr = min_fpr + cfun->va_list_fpr_size;\n+  if (max_fpr > FP_ARG_NUM_REG)\n+    max_fpr = FP_ARG_NUM_REG;\n+\n+  /* The va_arg algorithm accesses the FPRs in the reg save area using\n+     a constant offset from r0.  With the packed stack layout omitting\n+     FPRs from the beginning would change the offset for the\n+     subsequent FPRs.  */\n+  if (TARGET_PACKED_STACK)\n+    min_fpr = 0;\n+\n+  for (i = min_fpr; i < max_fpr; i++)\n+    cfun_set_fpr_save (i + FPR0_REGNUM);\n+}\n+\n+/* Reserve the GPR save slots for GPRs which need to be saved due to\n+   stdarg.\n+   This is a helper routine for s390_register_info.  */\n+\n+static void\n+s390_register_info_stdarg_gpr ()\n+{\n+  int i;\n+  int min_gpr;\n+  int max_gpr;\n+\n+  if (!cfun->stdarg\n+      || !cfun->va_list_gpr_size\n+      || crtl->args.info.gprs >= GP_ARG_NUM_REG)\n+    return;\n+\n+  min_gpr = crtl->args.info.gprs;\n+  max_gpr = min_gpr + cfun->va_list_gpr_size;\n+  if (max_gpr > GP_ARG_NUM_REG)\n+    max_gpr = GP_ARG_NUM_REG;\n+\n+  for (i = min_gpr; i < max_gpr; i++)\n+    cfun_gpr_save_slot (2 + i) = -1;\n+}\n+\n+/* The GPR and FPR save slots in cfun->machine->frame_layout are set\n+   for registers which need to be saved in function prologue.\n+   This function can be used until the insns emitted for save/restore\n+   of the regs are visible in the RTL stream.  */\n+\n+static void\n+s390_register_info ()\n+{\n+  int i, j;\n+  char clobbered_regs[32];\n+\n+  gcc_assert (!epilogue_completed);\n+\n+  if (reload_completed)\n+    /* After reload we rely on our own routine to determine which\n+       registers need saving.  */\n+    s390_regs_ever_clobbered (clobbered_regs);\n+  else\n+    /* During reload we use regs_ever_live as a base since reload\n+       does changes in there which we otherwise would not be aware\n+       of.  */\n+    for (i = 0; i < 32; i++)\n+      clobbered_regs[i] = df_regs_ever_live_p (i);\n+\n+  for (i = 0; i < 32; i++)\n+    clobbered_regs[i] = clobbered_regs[i] && !global_regs[i];\n+\n+  /* Mark the call-saved FPRs which need to be saved.\n+     This needs to be done before checking the special GPRs since the\n+     stack pointer usage depends on whether high FPRs have to be saved\n+     or not.  */\n+  cfun_frame_layout.fpr_bitmap = 0;\n+  cfun_frame_layout.high_fprs = 0;\n+  for (i = FPR0_REGNUM; i <= FPR15_REGNUM; i++)\n+    if (clobbered_regs[i] && !call_really_used_regs[i])\n+      {\n+\tcfun_set_fpr_save (i);\n+\tif (i >= FPR8_REGNUM)\n+\t  cfun_frame_layout.high_fprs++;\n+      }\n \n   if (flag_pic)\n     clobbered_regs[PIC_OFFSET_TABLE_REGNUM]\n-      |= df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM);\n+      |= !!df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM);\n \n   clobbered_regs[BASE_REGNUM]\n     |= (cfun->machine->base_reg\n-        && REGNO (cfun->machine->base_reg) == BASE_REGNUM);\n+\t&& REGNO (cfun->machine->base_reg) == BASE_REGNUM);\n \n+  clobbered_regs[HARD_FRAME_POINTER_REGNUM]\n+    |= !!frame_pointer_needed;\n+\n+  /* On pre z900 machines this might take until machine dependent\n+     reorg to decide.\n+     save_return_addr_p will only be set on non-zarch machines so\n+     there is no risk that r14 goes into an FPR instead of a stack\n+     slot.  */\n   clobbered_regs[RETURN_REGNUM]\n     |= (!crtl->is_leaf\n \t|| TARGET_TPF_PROFILING\n \t|| cfun->machine->split_branches_pending_p\n \t|| cfun_frame_layout.save_return_addr_p\n-\t|| crtl->calls_eh_return\n-\t|| cfun->stdarg);\n+\t|| crtl->calls_eh_return);\n \n   clobbered_regs[STACK_POINTER_REGNUM]\n     |= (!crtl->is_leaf\n \t|| TARGET_TPF_PROFILING\n \t|| cfun_save_high_fprs_p\n \t|| get_frame_size () > 0\n \t|| (reload_completed && cfun_frame_layout.frame_size > 0)\n-\t|| cfun->calls_alloca\n-\t|| cfun->stdarg);\n+\t|| cfun->calls_alloca);\n+\n+  memset (cfun_frame_layout.gpr_save_slots, 0, 16);\n \n   for (i = 6; i < 16; i++)\n-    if (df_regs_ever_live_p (i) || clobbered_regs[i])\n-      break;\n-  for (j = 15; j > i; j--)\n-    if (df_regs_ever_live_p (j) || clobbered_regs[j])\n-      break;\n+    if (clobbered_regs[i])\n+      cfun_gpr_save_slot (i) = -1;\n \n-  if (i == 16)\n-    {\n-      /* Nothing to save/restore.  */\n-      cfun_frame_layout.first_save_gpr_slot = -1;\n-      cfun_frame_layout.last_save_gpr_slot = -1;\n-      cfun_frame_layout.first_save_gpr = -1;\n-      cfun_frame_layout.first_restore_gpr = -1;\n-      cfun_frame_layout.last_save_gpr = -1;\n-      cfun_frame_layout.last_restore_gpr = -1;\n-    }\n-  else\n-    {\n-      /* Save slots for gprs from i to j.  */\n-      cfun_frame_layout.first_save_gpr_slot = i;\n-      cfun_frame_layout.last_save_gpr_slot = j;\n+  s390_register_info_stdarg_fpr ();\n+  s390_register_info_gprtofpr ();\n \n-      for (i = cfun_frame_layout.first_save_gpr_slot;\n-\t   i < cfun_frame_layout.last_save_gpr_slot + 1;\n-\t   i++)\n-\tif (clobbered_regs[i])\n-\t  break;\n+  /* First find the range of GPRs to be restored.  Vararg regs don't\n+     need to be restored so we do it before assigning slots to the\n+     vararg GPRs.  */\n+  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != -1; i++);\n+  for (j = 15; j > i && cfun_gpr_save_slot (j) != -1; j--);\n+  cfun_frame_layout.first_restore_gpr = (i == 16) ? -1 : i;\n+  cfun_frame_layout.last_restore_gpr = (i == 16) ? -1 : j;\n \n-      for (j = cfun_frame_layout.last_save_gpr_slot; j > i; j--)\n-\tif (clobbered_regs[j])\n-\t  break;\n+  /* stdarg functions might need to save GPRs 2 to 6.  This might\n+     override the GPR->FPR save decision made above for r6 since\n+     vararg regs must go to the stack.  */\n+  s390_register_info_stdarg_gpr ();\n \n-      if (i == cfun_frame_layout.last_save_gpr_slot + 1)\n-\t{\n-\t  /* Nothing to save/restore.  */\n-\t  cfun_frame_layout.first_save_gpr = -1;\n-\t  cfun_frame_layout.first_restore_gpr = -1;\n-\t  cfun_frame_layout.last_save_gpr = -1;\n-\t  cfun_frame_layout.last_restore_gpr = -1;\n-\t}\n-      else\n-\t{\n-\t  /* Save / Restore from gpr i to j.  */\n-\t  cfun_frame_layout.first_save_gpr = i;\n-\t  cfun_frame_layout.first_restore_gpr = i;\n-\t  cfun_frame_layout.last_save_gpr = j;\n-\t  cfun_frame_layout.last_restore_gpr = j;\n-\t}\n-    }\n+  /* Now the range of GPRs which need saving.  */\n+  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != -1; i++);\n+  for (j = 15; j > i && cfun_gpr_save_slot (j) != -1; j--);\n+  cfun_frame_layout.first_save_gpr = (i == 16) ? -1 : i;\n+  cfun_frame_layout.last_save_gpr = (i == 16) ? -1 : j;\n+}\n \n-  if (cfun->stdarg)\n-    {\n-      /* Varargs functions need to save gprs 2 to 6.  */\n-      if (cfun->va_list_gpr_size\n-\t  && crtl->args.info.gprs < GP_ARG_NUM_REG)\n-\t{\n-\t  int min_gpr = crtl->args.info.gprs;\n-\t  int max_gpr = min_gpr + cfun->va_list_gpr_size;\n-\t  if (max_gpr > GP_ARG_NUM_REG)\n-\t    max_gpr = GP_ARG_NUM_REG;\n+/* This function is called by s390_optimize_prologue in order to get\n+   rid of unnecessary GPR save/restore instructions.  The register info\n+   for the GPRs is re-computed and the ranges are re-calculated.  */\n \n-\t  if (cfun_frame_layout.first_save_gpr == -1\n-\t      || cfun_frame_layout.first_save_gpr > 2 + min_gpr)\n-\t    {\n-\t      cfun_frame_layout.first_save_gpr = 2 + min_gpr;\n-\t      cfun_frame_layout.first_save_gpr_slot = 2 + min_gpr;\n-\t    }\n+static void\n+s390_optimize_register_info ()\n+{\n+  char clobbered_regs[32];\n+  int i, j;\n \n-\t  if (cfun_frame_layout.last_save_gpr == -1\n-\t      || cfun_frame_layout.last_save_gpr < 2 + max_gpr - 1)\n-\t    {\n-\t      cfun_frame_layout.last_save_gpr = 2 + max_gpr - 1;\n-\t      cfun_frame_layout.last_save_gpr_slot = 2 + max_gpr - 1;\n-\t    }\n-\t}\n+  gcc_assert (epilogue_completed);\n+  gcc_assert (!cfun->machine->split_branches_pending_p);\n \n-      /* Mark f0, f2 for 31 bit and f0-f4 for 64 bit to be saved.  */\n-      if (TARGET_HARD_FLOAT && cfun->va_list_fpr_size\n-\t  && crtl->args.info.fprs < FP_ARG_NUM_REG)\n-\t{\n-\t  int min_fpr = crtl->args.info.fprs;\n-\t  int max_fpr = min_fpr + cfun->va_list_fpr_size;\n-\t  if (max_fpr > FP_ARG_NUM_REG)\n-\t    max_fpr = FP_ARG_NUM_REG;\n+  s390_regs_ever_clobbered (clobbered_regs);\n \n-\t  /* ??? This is currently required to ensure proper location\n-\t     of the fpr save slots within the va_list save area.  */\n-\t  if (TARGET_PACKED_STACK)\n-\t    min_fpr = 0;\n+  for (i = 0; i < 32; i++)\n+    clobbered_regs[i] = clobbered_regs[i] && !global_regs[i];\n \n-\t  for (i = min_fpr; i < max_fpr; i++)\n-\t    cfun_set_fpr_save (i + FPR0_REGNUM);\n-\t}\n-    }\n+  /* There is still special treatment needed for cases invisible to\n+     s390_regs_ever_clobbered.  */\n+  clobbered_regs[RETURN_REGNUM]\n+    |= (TARGET_TPF_PROFILING\n+\t/* When expanding builtin_return_addr in ESA mode we do not\n+\t   know whether r14 will later be needed as scratch reg when\n+\t   doing branch splitting.  So the builtin always accesses the\n+\t   r14 save slot and we need to stick to the save/restore\n+\t   decision for r14 even if it turns out that it didn't get\n+\t   clobbered.  */\n+\t|| cfun_frame_layout.save_return_addr_p\n+\t|| crtl->calls_eh_return);\n+\n+  memset (cfun_frame_layout.gpr_save_slots, 0, 6);\n+\n+  for (i = 6; i < 16; i++)\n+    if (!clobbered_regs[i])\n+      cfun_gpr_save_slot (i) = 0;\n+\n+  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != -1; i++);\n+  for (j = 15; j > i && cfun_gpr_save_slot (j) != -1; j--);\n+  cfun_frame_layout.first_restore_gpr = (i == 16) ? -1 : i;\n+  cfun_frame_layout.last_restore_gpr = (i == 16) ? -1 : j;\n+\n+  s390_register_info_stdarg_gpr ();\n+\n+  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != -1; i++);\n+  for (j = 15; j > i && cfun_gpr_save_slot (j) != -1; j--);\n+  cfun_frame_layout.first_save_gpr = (i == 16) ? -1 : i;\n+  cfun_frame_layout.last_save_gpr = (i == 16) ? -1 : j;\n }\n \n /* Fill cfun->machine with info about frame of current function.  */\n@@ -7668,6 +7783,22 @@ s390_frame_info (void)\n {\n   int i;\n \n+  cfun_frame_layout.first_save_gpr_slot = cfun_frame_layout.first_save_gpr;\n+  cfun_frame_layout.last_save_gpr_slot = cfun_frame_layout.last_save_gpr;\n+\n+  /* The va_arg builtin uses a constant distance of 16 *\n+     UNITS_PER_LONG (r0-r15) to reach the FPRs from the reg_save_area\n+     pointer.  So even if we are going to save the stack pointer in an\n+     FPR we need the stack space in order to keep the offsets\n+     correct.  */\n+  if (cfun->stdarg && cfun_save_arg_fprs_p)\n+    {\n+      cfun_frame_layout.last_save_gpr_slot = STACK_POINTER_REGNUM;\n+\n+      if (cfun_frame_layout.first_save_gpr_slot == -1)\n+\tcfun_frame_layout.first_save_gpr_slot = STACK_POINTER_REGNUM;\n+    }\n+\n   cfun_frame_layout.frame_size = get_frame_size ();\n   if (!TARGET_64BIT && cfun_frame_layout.frame_size > 0x7fff0000)\n     fatal_error (\"total size of local variables exceeds architecture limit\");\n@@ -7738,8 +7869,7 @@ s390_frame_info (void)\n       && !TARGET_TPF_PROFILING\n       && cfun_frame_layout.frame_size == 0\n       && !cfun_save_high_fprs_p\n-      && !cfun->calls_alloca\n-      && !cfun->stdarg)\n+      && !cfun->calls_alloca)\n     return;\n \n   if (!TARGET_PACKED_STACK)\n@@ -7785,7 +7915,8 @@ s390_init_frame_layout (void)\n {\n   HOST_WIDE_INT frame_size;\n   int base_used;\n-  int clobbered_regs[32];\n+\n+  gcc_assert (!reload_completed);\n \n   /* On S/390 machines, we may need to perform branch splitting, which\n      will require both base and return address register.  We have no\n@@ -7814,7 +7945,7 @@ s390_init_frame_layout (void)\n       else\n \tcfun->machine->base_reg = gen_rtx_REG (Pmode, BASE_REGNUM);\n \n-      s390_register_info (clobbered_regs);\n+      s390_register_info ();\n       s390_frame_info ();\n     }\n   while (frame_size != cfun_frame_layout.frame_size);\n@@ -7971,29 +8102,6 @@ s390_optimize_nonescaping_tx (void)\n   return;\n }\n \n-/* Update frame layout.  Recompute actual register save data based on\n-   current info and update regs_ever_live for the special registers.\n-   May be called multiple times, but may never cause *more* registers\n-   to be saved than s390_init_frame_layout allocated room for.  */\n-\n-static void\n-s390_update_frame_layout (void)\n-{\n-  int clobbered_regs[32];\n-\n-  s390_register_info (clobbered_regs);\n-\n-  df_set_regs_ever_live (BASE_REGNUM,\n-\t\t\t clobbered_regs[BASE_REGNUM] ? true : false);\n-  df_set_regs_ever_live (RETURN_REGNUM,\n-\t\t\t clobbered_regs[RETURN_REGNUM] ? true : false);\n-  df_set_regs_ever_live (STACK_POINTER_REGNUM,\n-\t\t\t clobbered_regs[STACK_POINTER_REGNUM] ? true : false);\n-\n-  if (cfun->machine->base_reg)\n-    df_set_regs_ever_live (REGNO (cfun->machine->base_reg), true);\n-}\n-\n /* Return true if it is legal to put a value with MODE into REGNO.  */\n \n bool\n@@ -8054,6 +8162,31 @@ s390_hard_regno_rename_ok (unsigned int old_reg, unsigned int new_reg)\n \t|| REGNO (cfun->machine->base_reg) == new_reg)\n       return false;\n \n+  /* Prevent regrename from using call-saved regs which haven't\n+     actually been saved.  This is necessary since regrename assumes\n+     the backend save/restore decisions are based on\n+     df_regs_ever_live.  Since we have our own routine we have to tell\n+     regrename manually about it.  */\n+  if (GENERAL_REGNO_P (new_reg)\n+      && !call_really_used_regs[new_reg]\n+      && cfun_gpr_save_slot (new_reg) == 0)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return nonzero if register REGNO can be used as a scratch register\n+   in peephole2.  */\n+\n+static bool\n+s390_hard_regno_scratch_ok (unsigned int regno)\n+{\n+  /* See s390_hard_regno_rename_ok.  */\n+  if (GENERAL_REGNO_P (regno)\n+      && !call_really_used_regs[regno]\n+      && cfun_gpr_save_slot (regno) == 0)\n+    return false;\n+\n   return true;\n }\n \n@@ -8133,7 +8266,6 @@ HOST_WIDE_INT\n s390_initial_elimination_offset (int from, int to)\n {\n   HOST_WIDE_INT offset;\n-  int index;\n \n   /* ??? Why are we called for non-eliminable pairs?  */\n   if (!s390_can_eliminate (from, to))\n@@ -8154,10 +8286,26 @@ s390_initial_elimination_offset (int from, int to)\n \n     case RETURN_ADDRESS_POINTER_REGNUM:\n       s390_init_frame_layout ();\n-      index = RETURN_REGNUM - cfun_frame_layout.first_save_gpr_slot;\n-      gcc_assert (index >= 0);\n-      offset = cfun_frame_layout.frame_size + cfun_frame_layout.gprs_offset;\n-      offset += index * UNITS_PER_LONG;\n+\n+      if (cfun_frame_layout.first_save_gpr_slot == -1)\n+\t{\n+\t  /* If it turns out that for stdarg nothing went into the reg\n+\t     save area we also do not need the return address\n+\t     pointer.  */\n+\t  if (cfun->stdarg && !cfun_save_arg_fprs_p)\n+\t    return 0;\n+\n+\t  gcc_unreachable ();\n+\t}\n+\n+      /* In order to make the following work it is not necessary for\n+\t r14 to have a save slot.  It is sufficient if one other GPR\n+\t got one.  Since the GPRs are always stored without gaps we\n+\t are able to calculate where the r14 save slot would\n+\t reside.  */\n+      offset = (cfun_frame_layout.frame_size + cfun_frame_layout.gprs_offset +\n+\t\t(RETURN_REGNUM - cfun_frame_layout.first_save_gpr_slot) *\n+\t\tUNITS_PER_LONG);\n       break;\n \n     case BASE_REGNUM:\n@@ -8295,6 +8443,23 @@ save_gprs (rtx base, int offset, int first, int last)\n \n       addr = plus_constant (Pmode, base,\n \t\t\t    offset + (start - first) * UNITS_PER_LONG);\n+\n+      if (start == last)\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    note = gen_movdi (gen_rtx_MEM (Pmode, addr),\n+\t\t\t      gen_rtx_REG (Pmode, start));\n+\t  else\n+\t    note = gen_movsi (gen_rtx_MEM (Pmode, addr),\n+\t\t\t      gen_rtx_REG (Pmode, start));\n+\t  note = PATTERN (note);\n+\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, note);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t  return insn;\n+\t}\n+\n       note = gen_store_multiple (gen_rtx_MEM (Pmode, addr),\n \t\t\t\t gen_rtx_REG (Pmode, start),\n \t\t\t\t GEN_INT (last - start + 1));\n@@ -8335,12 +8500,14 @@ restore_gprs (rtx base, int offset, int first, int last)\n       else\n         insn = gen_movsi (gen_rtx_REG (Pmode, first), addr);\n \n+      RTX_FRAME_RELATED_P (insn) = 1;\n       return insn;\n     }\n \n   insn = gen_load_multiple (gen_rtx_REG (Pmode, first),\n \t\t\t    addr,\n \t\t\t    GEN_INT (last - first + 1));\n+  RTX_FRAME_RELATED_P (insn) = 1;\n   return insn;\n }\n \n@@ -8405,6 +8572,56 @@ s390_emit_stack_tie (void)\n   emit_insn (gen_stack_tie (mem));\n }\n \n+/* Copy GPRS into FPR save slots.  */\n+\n+static void\n+s390_save_gprs_to_fprs (void)\n+{\n+  int i;\n+\n+  if (!TARGET_Z10 || !TARGET_HARD_FLOAT || !crtl->is_leaf)\n+    return;\n+\n+  for (i = 6; i < 16; i++)\n+    {\n+      if (FP_REGNO_P (cfun_gpr_save_slot (i)))\n+\t{\n+\t  rtx insn =\n+\t    emit_move_insn (gen_rtx_REG (DImode, cfun_gpr_save_slot (i)),\n+\t\t\t    gen_rtx_REG (DImode, i));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+    }\n+}\n+\n+/* Restore GPRs from FPR save slots.  */\n+\n+static void\n+s390_restore_gprs_from_fprs (void)\n+{\n+  int i;\n+\n+  if (!TARGET_Z10 || !TARGET_HARD_FLOAT || !crtl->is_leaf)\n+    return;\n+\n+  for (i = 6; i < 16; i++)\n+    {\n+      if (FP_REGNO_P (cfun_gpr_save_slot (i)))\n+\t{\n+\t  rtx insn =\n+\t    emit_move_insn (gen_rtx_REG (DImode, i),\n+\t\t\t    gen_rtx_REG (DImode, cfun_gpr_save_slot (i)));\n+\t  df_set_regs_ever_live (i, true);\n+\t  /* The frame related flag is only required on the save\n+\t     operations.  We nevertheless set it also for the restore\n+\t     in order to recognize these instructions in\n+\t     s390_optimize_prologue.  The flag will then be\n+\t     deleted.  */\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+    }\n+}\n+\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n@@ -8419,8 +8636,8 @@ s390_emit_prologue (void)\n   /* Try to get rid of the FPR clobbers.  */\n   s390_optimize_nonescaping_tx ();\n \n-  /* Complete frame layout.  */\n-  s390_update_frame_layout ();\n+  /* Re-compute register info.  */\n+  s390_register_info ();\n \n   /* Annotate all constant pool references to let the scheduler know\n      they implicitly use the base register.  */\n@@ -8446,6 +8663,8 @@ s390_emit_prologue (void)\n   else\n     temp_reg = gen_rtx_REG (Pmode, 1);\n \n+  s390_save_gprs_to_fprs ();\n+\n   /* Save call saved gprs.  */\n   if (cfun_frame_layout.first_save_gpr != -1)\n     {\n@@ -8900,6 +9119,8 @@ s390_emit_epilogue (bool sibcall)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n+  s390_restore_gprs_from_fprs ();\n+\n   if (! sibcall)\n     {\n \n@@ -10561,8 +10782,7 @@ s390_optimize_prologue (void)\n   rtx insn, new_insn, next_insn;\n \n   /* Do a final recompute of the frame-related data.  */\n-\n-  s390_update_frame_layout ();\n+  s390_optimize_register_info ();\n \n   /* If all special registers are in fact used, there's nothing we\n      can do, so no point in walking the insn list.  */\n@@ -10580,18 +10800,63 @@ s390_optimize_prologue (void)\n     {\n       int first, last, off;\n       rtx set, base, offset;\n+      rtx pat;\n \n       next_insn = NEXT_INSN (insn);\n \n-      if (! NONJUMP_INSN_P (insn))\n+      if (! NONJUMP_INSN_P (insn) || ! RTX_FRAME_RELATED_P (insn))\n \tcontinue;\n \n-      if (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t  && store_multiple_operation (PATTERN (insn), VOIDmode))\n+      pat = PATTERN (insn);\n+\n+      /* Remove ldgr/lgdr instructions used for saving and restore\n+\t GPRs if possible.  */\n+      if (TARGET_Z10\n+\t  && GET_CODE (pat) == SET\n+\t  && GET_MODE (SET_SRC (pat)) == DImode\n+\t  && REG_P (SET_SRC (pat))\n+\t  && REG_P (SET_DEST (pat)))\n+\t{\n+\t  int src_regno = REGNO (SET_SRC (pat));\n+\t  int dest_regno = REGNO (SET_DEST (pat));\n+\t  int gpr_regno;\n+\t  int fpr_regno;\n+\n+\t  if (!((GENERAL_REGNO_P (src_regno) && FP_REGNO_P (dest_regno))\n+\t\t|| (FP_REGNO_P (src_regno) && GENERAL_REGNO_P (dest_regno))))\n+\t    continue;\n+\n+\t  gpr_regno = GENERAL_REGNO_P (src_regno) ? src_regno : dest_regno;\n+\t  fpr_regno = FP_REGNO_P (src_regno) ? src_regno : dest_regno;\n+\n+\t  /* GPR must be call-saved, FPR must be call-clobbered.  */\n+\t  if (!call_really_used_regs[fpr_regno]\n+\t      || call_really_used_regs[gpr_regno])\n+\t    continue;\n+\n+\t  /* For restores we have to revert the frame related flag\n+\t     since no debug info is supposed to be generated for\n+\t     these.  */\n+\t  if (dest_regno == gpr_regno)\n+\t    RTX_FRAME_RELATED_P (insn) = 0;\n+\n+\t  /* It must not happen that what we once saved in an FPR now\n+\t     needs a stack slot.  */\n+\t  gcc_assert (cfun_gpr_save_slot (gpr_regno) != -1);\n+\n+\t  if (cfun_gpr_save_slot (gpr_regno) == 0)\n+\t    {\n+\t      remove_insn (insn);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (GET_CODE (pat) == PARALLEL\n+\t  && store_multiple_operation (pat, VOIDmode))\n \t{\n-\t  set = XVECEXP (PATTERN (insn), 0, 0);\n+\t  set = XVECEXP (pat, 0, 0);\n \t  first = REGNO (SET_SRC (set));\n-\t  last = first + XVECLEN (PATTERN (insn), 0) - 1;\n+\t  last = first + XVECLEN (pat, 0) - 1;\n \t  offset = const0_rtx;\n \t  base = eliminate_constant_term (XEXP (SET_DEST (set), 0), &offset);\n \t  off = INTVAL (offset);\n@@ -10624,14 +10889,11 @@ s390_optimize_prologue (void)\n \t}\n \n       if (cfun_frame_layout.first_save_gpr == -1\n-\t  && GET_CODE (PATTERN (insn)) == SET\n-\t  && GET_CODE (SET_SRC (PATTERN (insn))) == REG\n-\t  && (REGNO (SET_SRC (PATTERN (insn))) == BASE_REGNUM\n-\t      || (!TARGET_CPU_ZARCH\n-\t\t  && REGNO (SET_SRC (PATTERN (insn))) == RETURN_REGNUM))\n-\t  && GET_CODE (SET_DEST (PATTERN (insn))) == MEM)\n+\t  && GET_CODE (pat) == SET\n+\t  && GENERAL_REG_P (SET_SRC (pat))\n+\t  && GET_CODE (SET_DEST (pat)) == MEM)\n \t{\n-\t  set = PATTERN (insn);\n+\t  set = pat;\n \t  first = REGNO (SET_SRC (set));\n \t  offset = const0_rtx;\n \t  base = eliminate_constant_term (XEXP (SET_DEST (set), 0), &offset);\n@@ -10647,18 +10909,21 @@ s390_optimize_prologue (void)\n \t  continue;\n \t}\n \n-      if (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t  && load_multiple_operation (PATTERN (insn), VOIDmode))\n+      if (GET_CODE (pat) == PARALLEL\n+\t  && load_multiple_operation (pat, VOIDmode))\n \t{\n-\t  set = XVECEXP (PATTERN (insn), 0, 0);\n+\t  set = XVECEXP (pat, 0, 0);\n \t  first = REGNO (SET_DEST (set));\n-\t  last = first + XVECLEN (PATTERN (insn), 0) - 1;\n+\t  last = first + XVECLEN (pat, 0) - 1;\n \t  offset = const0_rtx;\n \t  base = eliminate_constant_term (XEXP (SET_SRC (set), 0), &offset);\n \t  off = INTVAL (offset);\n \n \t  if (GET_CODE (base) != REG || off < 0)\n \t    continue;\n+\n+\t  RTX_FRAME_RELATED_P (insn) = 0;\n+\n \t  if (cfun_frame_layout.first_restore_gpr != -1\n \t      && (cfun_frame_layout.first_restore_gpr < first\n \t\t  || cfun_frame_layout.last_restore_gpr > last))\n@@ -10676,6 +10941,7 @@ s390_optimize_prologue (void)\n \t\t\t\t\t      - first) * UNITS_PER_LONG,\n \t\t\t\t       cfun_frame_layout.first_restore_gpr,\n \t\t\t\t       cfun_frame_layout.last_restore_gpr);\n+\t      RTX_FRAME_RELATED_P (new_insn) = 0;\n \t      new_insn = emit_insn_before (new_insn, insn);\n \t      INSN_ADDRESSES_NEW (new_insn, -1);\n \t    }\n@@ -10685,21 +10951,21 @@ s390_optimize_prologue (void)\n \t}\n \n       if (cfun_frame_layout.first_restore_gpr == -1\n-\t  && GET_CODE (PATTERN (insn)) == SET\n-\t  && GET_CODE (SET_DEST (PATTERN (insn))) == REG\n-\t  && (REGNO (SET_DEST (PATTERN (insn))) == BASE_REGNUM\n-\t      || (!TARGET_CPU_ZARCH\n-\t\t  && REGNO (SET_DEST (PATTERN (insn))) == RETURN_REGNUM))\n-\t  && GET_CODE (SET_SRC (PATTERN (insn))) == MEM)\n+\t  && GET_CODE (pat) == SET\n+\t  && GENERAL_REG_P (SET_DEST (pat))\n+\t  && GET_CODE (SET_SRC (pat)) == MEM)\n \t{\n-\t  set = PATTERN (insn);\n+\t  set = pat;\n \t  first = REGNO (SET_DEST (set));\n \t  offset = const0_rtx;\n \t  base = eliminate_constant_term (XEXP (SET_SRC (set), 0), &offset);\n \t  off = INTVAL (offset);\n \n \t  if (GET_CODE (base) != REG || off < 0)\n \t    continue;\n+\n+\t  RTX_FRAME_RELATED_P (insn) = 0;\n+\n \t  if (REGNO (base) != STACK_POINTER_REGNUM\n \t      && REGNO (base) != HARD_FRAME_POINTER_REGNUM)\n \t    continue;\n@@ -11638,6 +11904,9 @@ s390_loop_unroll_adjust (unsigned nunroll, struct loop *loop)\n #undef TARGET_CANONICALIZE_COMPARISON\n #define TARGET_CANONICALIZE_COMPARISON s390_canonicalize_comparison\n \n+#undef TARGET_HARD_REGNO_SCRATCH_OK\n+#define TARGET_HARD_REGNO_SCRATCH_OK s390_hard_regno_scratch_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-s390.h\""}]}