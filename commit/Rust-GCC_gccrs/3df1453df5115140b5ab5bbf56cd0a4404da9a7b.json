{"sha": "3df1453df5115140b5ab5bbf56cd0a4404da9a7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RmMTQ1M2RmNTExNTE0MGI1YWI1YmJmNTZjZDBhNDQwNGRhOWE3Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-02-05T11:01:36Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-02-05T11:01:36Z"}, "message": "Remove libio\n\nFrom-SVN: r39453", "tree": {"sha": "7d2c2f4379041aeae8b380308e1294d0a49ff67a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d2c2f4379041aeae8b380308e1294d0a49ff67a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3df1453df5115140b5ab5bbf56cd0a4404da9a7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3df1453df5115140b5ab5bbf56cd0a4404da9a7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3df1453df5115140b5ab5bbf56cd0a4404da9a7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3df1453df5115140b5ab5bbf56cd0a4404da9a7b/comments", "author": null, "committer": null, "parents": [{"sha": "39d6f2e8a535c22254682e99e59d63481aab8dfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d6f2e8a535c22254682e99e59d63481aab8dfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39d6f2e8a535c22254682e99e59d63481aab8dfe"}], "stats": {"total": 41642, "additions": 0, "deletions": 41642}, "files": [{"sha": "ec2fd437739a5e31b71156777b855b7c66e7551c", "filename": "libio/ChangeLog", "status": "removed", "additions": 0, "deletions": 2899, "changes": 2899, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FChangeLog?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "1d4123b523c38f8cbc6de53fac4bf5870aa39775", "filename": "libio/Makefile.in", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FMakefile.in?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,137 +0,0 @@\n-# Copyright (C) 1993, 1995, 1996, 1997, 1998 Free Software Foundation\n-# \n-# This file is part of the GNU IO Library.  This library is free\n-# software; you can redistribute it and/or modify it under the\n-# terms of the GNU General Public License as published by the\n-# Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-# \n-# This library is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with this library; see the file COPYING.  If not, write to the Free\n-# Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-srcdir = .\n-\n-VERSION = 2.8.0\n-# The config file (overriden by Linux).\n-_G_CONFIG_H=_G_config.h\n-tooldir = $(exec_prefix)/$(target)\n-INSTALLDIR = $(libdir)\n-gxx_include_dir=${includedir}/g++\n-\n-IO_OBJECTS = filedoalloc.o floatconv.o genops.o fileops.o \\\n-  iovfprintf.o \\\n-  iovfscanf.o ioignore.o iopadn.o \\\n-  iofgetpos.o iofread.o iofscanf.o \\\n-  iofsetpos.o iogetdelim.o iogetline.o \\\n-  ioprintf.o ioseekoff.o ioseekpos.o \\\n-  outfloat.o strops.o iofclose.o iopopen.o ioungetc.o peekc.o iogetc.o \\\n-  ioputc.o iofeof.o ioferror.o\n-\n-STDIO_OBJECTS = stdfiles.o\n-\n-# These emulate stdio functionality, but with a different name (_IO_ungetc\n-# instead of ungetc), and using _IO_FILE instead of FILE.\n-# They are not needed for C++ iostream, nor stdio, though some stdio\n-# files are build using the same source files (see stdio/configure.in).\n-# They are needed for iostdio.h.  They are needed under Linux to avoid\n-# version incompatibility problems with the C library.\n-# iofclose.o is not here, because it is needed for stdio (by pclose).\n-STDIO_WRAP_OBJECTS =  iofdopen.o iofflush.o iofgets.o iofopen.o iofprintf.o iofputs.o iofwrite.o \\\n-  iogets.o ioperror.o ioputs.o ioscanf.o iosetbuffer.o iosetvbuf.o \\\n-  iosprintf.o iosscanf.o ioftell.o iovsscanf.o iovsprintf.o\n-\n-IOSTREAM_OBJECTS = builtinbuf.o filebuf.o fstream.o \\\n-  indstream.o ioassign.o ioextend.o iomanip.o iostream.o \\\n-  isgetline.o isgetsb.o isscan.o \\\n-  osform.o procbuf.o sbform.o sbgetline.o sbscan.o \\\n-  stdiostream.o stdstrbufs.o stdstreams.o stream.o streambuf.o strstream.o \\\n-  PlotFile.o SFile.o parsestream.o pfstream.o editbuf.o\n-\n-# These files define _IO_read etc, which are just wrappers for read(2) etc.\n-# They need to be changed to use name-space-clean (e.g. __read) versions\n-# for each specific libc.\n-OSPRIM_OBJECTS = ioprims.o iostrerror.o cleanup.o\n-\n-LIBIOSTREAM_OBJECTS = $(IO_OBJECTS) $(IOSTREAM_OBJECTS) $(OSPRIM_OBJECTS)\n-LIBIO_OBJECTS = $(IO_OBJECTS) $(STDIO_WRAP_OBJECTS) $(OSPRIM_OBJECTS) \\\n-\t\t$(STDIO_OBJECTS)\n-\n-LIBIOSTREAM_DEP = $(LIBIOSTREAM_OBJECTS)\n-LIBIOSTREAM_USE = $(LIBIOSTREAM_OBJECTS)\n-\n-USER_INCLUDES = *.h\n-\n-PICFLAG =\n-\n-#### package, host, target, and site dependent Makefile fragments come in here.\n-##\n-\n-$(LIBIO_OBJECTS): $(_G_CONFIG_H)\n-\n-libio.a: $(_G_CONFIG_H) $(LIBIO_OBJECTS)\n-\t-rm -rf libio.a\n-\t$(AR) $(AR_FLAGS) libio.a $(LIBIO_OBJECTS)\n-\t$(RANLIB) libio.a\n-\n-libiostream.a: $(_G_CONFIG_H) $(LIBIOSTREAM_DEP)\n-\t-rm -rf libiostream.a\n-\t$(AR) $(AR_FLAGS) libiostream.a $(LIBIOSTREAM_USE)\n-\t$(RANLIB) libiostream.a\n-\n-test: test.o libio.a\n-\t$(CC) $(CFLAGS) -o test test.o libio.a\n-tpipe: tpipe.o libio.a\n-\t$(CC) $(CFLAGS) -o tpipe tpipe.o libio.a\n-\n-iostream.list: $(_G_CONFIG_H) $(LIBIOSTREAM_DEP)\n-\t@echo \"$(LIBIOSTREAM_USE)\"> iostream.list\n-\n-# The \"pic\" subdir must be created before we can put any object\n-# files into it.\n-$(LIBIOSTREAM_DEP) $(LIBIO_OBJECTS): stamp-picdir\n-\n-stmp-stdio:\n-\t@rootme=`pwd`/ ; export rootme; cd stdio ; \\\n-\t  $(MAKE) $(FLAGS_TO_PASS) stdio.list\n-\n-_G_config.h: ${srcdir}/gen-params\n-\trootme=`pwd`/ ; export rootme; \\\n-\tCC=\"$(CC) $(CINCLUDES)\"; export CC; \\\n-\tCXX=\"$(CXX) $(CXXINCLUDES) $(NOSTDINC) $(CXXFLAGS)\"; export CXX; \\\n-\tCONFIG_NM=\"$(NM)\"; export CONFIG_NM; \\\n-\t$(SHELL) ${srcdir}/gen-params LIB_VERSION=$(VERSION) $(G_CONFIG_ARGS) >tmp-params.h\n-\tmv tmp-params.h _G_config.h\n-\n-install:\n-\trootme=`pwd`/ ; export rootme ; \\\n-\tif [ -z \"$(MULTISUBDIR)\" ]; then \\\n-\t  if [ \"$(_G_CONFIG_H)\" != \"\" ]; then \\\n-\t    if [ x$(enable_version_specific_runtime_libs) = xyes ]; then \\\n-\t      rm -f $(gxx_include_dir)/_G_config.h ; \\\n-\t      $(INSTALL_DATA) _G_config.h $(gxx_include_dir)/_G_config.h || exit 1; \\\n-\t    else \\\n-\t      rm -f $(tooldir)/include/_G_config.h ; \\\n-\t      $(INSTALL_DATA) _G_config.h $(tooldir)/include/_G_config.h || exit 1; \\\n-\t    fi; \\\n-\t  else true; \\\n-\t  fi ; \\\n-\t  cd $(srcdir); \\\n-\t  for FILE in $(USER_INCLUDES); do if [ $$FILE != _G_config.h ]; then \\\n-\t    rm -f $(gxx_include_dir)/$$FILE ; \\\n-\t    $(INSTALL_DATA) $$FILE $(gxx_include_dir)/$$FILE ; \\\n-\t    chmod a-x $(gxx_include_dir)/$$FILE ; \\\n-\t  else true; fi; done ; \\\n-\telse true; \\\n-\tfi\n-\t@rootme=`pwd`/ ; export rootme ; \\\n-\t$(MULTIDO) $(FLAGS_TO_PASS) multi-do DO=install\n-\n-c++clean:\n-\trm -rf $(IOSTREAM_OBJECTS)\n-\t@$(MAKE) $(FLAGS_TO_PASS) \"DODIRS=tests\" DO=clean subdir_do"}, {"sha": "1f3b7781e226799d6e853e17ceb9785bded22c6d", "filename": "libio/NEWS", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FNEWS?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,57 +0,0 @@\n-*** Major changes in libio for egcs:\n-\n-* Better support for Linux.\n-\n-* Dejagnu testsuite.\n-\n-*** Major changes in libio version 2.7.0:\n-\n-* The data representations of _IO_FILE and streambufs have been modified.\n-  The layout of the jump-table table _IO_jumps_t has been re-arranged\n-  to match that of a virtual function table of a streambuf.  Therefore,\n-  we no longer need a separate _IO_FILE::_jumps pointer;  instead it can\n-  be shared with the virtual function table pointer.  In addition to\n-  saving space, this also removes the overhead when double indirection\n-  was needed, and there are many simplificatons (e.g. we no longer need\n-  the builtinbuf class.\n-\n-* The streambuf::uflow virtual has been added, to match the standard.\n-\n-* The ifstream, ofstream, and fstream classes now include the filebuf\n-  as a member, rather than being pointed to it.  Various related changes.\n-\n-* Version number changed to generally follow libg++ (and gcc).\n-\n-*** Major changes in libio version 0.66 (released with libg++ 2.6.1):\n-\n-* Some documentation and an example in iostream.texi on how to derive\n- your own class from streambuf.\n-\n-* New functions added to stdio:  getline, detdelim, snprintf, vsnprintf.\n-  This is for compatibility with the GNU C library.\n-\n-*** Major changes in libio version 0.65 (released with libg++ 2.6):\n-\n-* _IO_getline and streambuf::sgetline no longer write a '\\0' at the end.\n-\n-* A number of improvements to get closer to the ANSI/ISO C++ working\n-paper, such as:\n-- Added (preliminary support for) new ANSI streambuf::uflow virtual.\n-- Added istdiostream and ostdiostream classes.\n-- Added ostream::operator<<(bool) and istream::operator>>(bool&).\n-\n-* More robust (and faster) initialization and cleanup of standard streambufs.\n-\n-* Many small bug fixes, portability improvements, and random enhancements.\n-\n-*** Major changes in libio version 0.63 (released with libg++ 2.5.3):\n-\n-* There is a g++ bug that causes inconsistent name mangling for the\n-assembler name of the virtual function table for the istream class.\n-A work-around has been put into streambuf.h, which will make g++\n-always do the right thing.  Note that this may require you to\n-recompile programs that were incorrectly compiled by g++.\n-\n-* Functions that do printf-style formatting to the unbuffered\n-streams have been optimized to write to a temporary buffer.\n-"}, {"sha": "98b2d839555dd4715dd843d8875c737a8fb11dc3", "filename": "libio/PlotFile.cc", "status": "removed", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FPlotFile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FPlotFile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FPlotFile.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,157 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-// This may look like C code, but it is really -*- C++ -*-\n-/* \n-Copyright (C) 1988, 1992, 1993 Free Software Foundation\n-    written by Doug Lea (dl@rocky.oswego.edu)\n-    converted to use iostream library by Per Bothner (bothner@cygnus.com)\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with GCC to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License.  */\n-\n-#ifdef __GNUG__\n-#pragma implementation\n-#endif\n-#include <PlotFile.h>\n-\n-/*\n- PlotFile implementation module\n-*/\n-\n-\n-PlotFile& PlotFile:: cmd(char c)\n-{ \n-  ofstream::put(c); \n-  return *this; \n-}\n-\n-PlotFile& PlotFile:: operator<<(const int x)\n-{ \n-#if defined(convex)\n-  ofstream::put((char)(x>>8)); \n-  ofstream::put((char)(x&0377)); \n-#else\n-  ofstream::put((char)(x&0377)); \n-  ofstream::put((char)(x>>8)); \n-#endif\n-  return *this; \n-}\n-\n-PlotFile& PlotFile:: operator<<(const char *s)\n-{ \n-  *(ofstream*)this << s;\n-  return *this;\n-}\n-\n-\n-PlotFile& PlotFile:: arc(const int xi, const int yi,\n-\t\t\t const int x0, const int y0,\n-\t\t\t const int x1, const int y1)\n-{ \n-  return cmd('a') << xi << yi << x0 << y0 << x1 << y1; \n-}\n-\n-\n-PlotFile& PlotFile:: box(const int x0, const int y0,\n-\t\t\t const int x1, const int y1)\n-{ \n-  line(x0, y0, x0, y1);\n-  line(x0, y1, x1, y1);\n-  line(x1, y1, x1, y0);\n-  return line(x1, y0, x0, y0);\n-}\n-\n-PlotFile& PlotFile:: circle(const int x, const int y, const int r)\n-{ \n-  return cmd('c') << x << y << r; \n-}\n-\n-PlotFile& PlotFile:: cont(const int xi, const int yi)\n-{ \n-  return cmd('n') << xi << yi;\n-}\n-\n-PlotFile& PlotFile:: dot(const int xi, const int yi, const int dx,\n-\t\t\t int n, const int* pat)\n-{ \n-  cmd('d') << xi << yi << dx << n;\n-  while (n-- > 0) *this << *pat++;\n-  return *this; \n-}\n-\n-PlotFile& PlotFile:: erase()\n-{ \n-  return cmd('e'); \n-}\n-\n-PlotFile& PlotFile:: label(const char* s)\n-{ \n-  return cmd('t') << s << \"\\n\"; \n-}\n-\n-PlotFile& PlotFile:: line(const int x0, const int y0,\n-\t\t\t  const int x1, const int y1)\n-{ \n-  return cmd('l') << x0 << y0 << x1 << y1; \n-}\n-\n-PlotFile& PlotFile:: linemod(const char* s)\n-{ \n-  return cmd('f') << s << \"\\n\"; \n-}\n-\n-PlotFile& PlotFile:: move(const int xi, const int yi)\n-{ \n-  return cmd('m') << xi << yi;\n-}\n-\n-PlotFile& PlotFile:: point(const int xi, const int yi)\n-{ \n-  return cmd('p') << xi << yi; \n-}\n-\n-PlotFile& PlotFile:: space(const int x0, const int y0,\n-\t\t\t   const int x1, const int y1)\n-{ \n-  return cmd('s') << x0 << y0 << x1 << y1; \n-}"}, {"sha": "82b08bc4681cae9fa53722eb49765e09c6eb90f6", "filename": "libio/PlotFile.h", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FPlotFile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FPlotFile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FPlotFile.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,89 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-/* \n-  a very simple implementation of a class to output unix \"plot\"\n-  format plotter files. See corresponding unix man pages for\n-  more details. \n-\n-  written by Doug Lea (dl@rocky.oswego.edu)\n-  converted to use iostream library by Per Bothner (bothner@cygnus.com)\n-*/\n-\n-#ifndef _PlotFile_h\n-#ifdef __GNUG__\n-#pragma interface\n-#endif\n-#define _PlotFile_h\n-\n-#include <fstream.h>\n-\n-/*   \n-   Some plot libraries have the `box' command to draw boxes. Some don't.\n-   `box' is included here via moves & lines to allow both possiblilties.\n-*/\n-\n-extern \"C++\" {\n-class PlotFile : public ofstream\n-{\n-protected:\n-  PlotFile& cmd(char c);\n-  PlotFile& operator << (const int x);\n-  PlotFile& operator << (const char *s);\n-  \n-public:\n-  \n-  PlotFile() : ofstream() { }\n-  PlotFile(int fd) : ofstream(fd) { }\n-  PlotFile(const char *name, int mode=ios::out, int prot=0664)\n-      : ofstream(name, mode, prot) { }\n-  \n-//  PlotFile& remove() { ofstream::remove(); return *this; }\n-  \n-//  int           filedesc() { return ofstream::filedesc(); }\n-//  const char*   name() { return File::name(); }\n-//  void          setname(const char* newname) { File::setname(newname); }\n-//  int           iocount() { return File::iocount(); }\n-  \n-  PlotFile& arc(const int xi, const int yi,\n-                const int x0, const int y0,\n-                const int x1, const int y1);\n-  PlotFile& box(const int x0, const int y0,\n-                const int x1, const int y1);\n-  PlotFile& circle(const int x, const int y, const int r);\n-  PlotFile& cont(const int xi, const int yi);\n-  PlotFile& dot(const int xi, const int yi, const int dx,\n-                int n, const int* pat);\n-  PlotFile& erase(); \n-  PlotFile& label(const char* s);\n-  PlotFile& line(const int x0, const int y0,\n-                 const int x1, const int y1);\n-  PlotFile& linemod(const char* s);\n-  PlotFile& move(const int xi, const int yi);\n-  PlotFile& point(const int xi, const int yi);\n-  PlotFile& space(const int x0, const int y0,\n-                  const int x1, const int y1);\n-};\n-} // extern \"C++\"\n-#endif"}, {"sha": "c2d564965ca41cfb227ab4bfef9f577f12eb0e38", "filename": "libio/README", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FREADME?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,30 +0,0 @@\n-This is libio, the GNU C/C++ input/output library.\n-\n-By default, the library is configured to build the C++ iostream\n-facility (in $libdir/libiostream.a).\n-\n-The library can be configured to build the C stdio facility\n-that is part of a C run-time library.\n-\n-This library is distributed with libg++; see ../libg++/README\n-for installation instructions, and where to send bug reports\n-and questions.\n-\n-* Copyright restrictions\n-\n-The files in this directory are generally covered by the GNU Public\n-License (which is in the file ../COPYING), but modified with the\n-following:\n-\n-    As a special exception, if you link this library with files\n-    compiled with a GNU compiler to produce an executable, this does not cause\n-    the resulting executable to be covered by the GNU General Public License.\n-    This exception does not however invalidate any other reasons why\n-    the executable file might be covered by the GNU General Public License.\n-\n-A few source files and subroutines are covered by other (but\n-less restrictive) copyright conditions.  E.g. some code (such\n-as iovfprintf.c) is based on software that was developed by the\n-University of California, Berkeley, for the Berkeley Software\n-Distribution (BSD-4.4), and bears their copyright;  and one\n-file (floatconv.c) is derived from (\"free\") code copyrighted AT&T."}, {"sha": "e5daa645695e335120ebe04f593194e8be3d0bca", "filename": "libio/SFile.cc", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FSFile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FSFile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FSFile.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,82 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-/* \n-Copyright (C) 1988 Free Software Foundation\n-    written by Doug Lea (dl@rocky.oswego.edu)\n-\n-This file is part of the GNU C++ Library.  This library is free\n-software; you can redistribute it and/or modify it under the terms of\n-the GNU Library General Public License as published by the Free\n-Software Foundation; either version 2 of the License, or (at your\n-option) any later version.  This library is distributed in the hope\n-that it will be useful, but WITHOUT ANY WARRANTY; without even the\n-implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n-PURPOSE.  See the GNU Library General Public License for more details.\n-You should have received a copy of the GNU Library General Public\n-License along with this library; if not, write to the Free Software\n-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n-*/\n-\n-#ifdef __GNUG__\n-#pragma implementation\n-#endif\n-#include <SFile.h>\n-\n-SFile::SFile(const char *filename, int size, int mode, int prot)\n-: fstream(filename, mode, prot)\n-{ \n-  sz = size; \n-}\n-\n-SFile::SFile(int fd, int size)\n-: fstream(fd)\n-{ \n-  sz = size; \n-}\n-\n-void SFile::open(const char *name, int size, int mode, int prot)\n-{\n-    fstream::open(name, mode, prot);\n-    sz = size;\n-}\n-\n-SFile& SFile::get(void* x)\n-{\n-    read(x, sz);\n-    return *this;\n-}\n-\n-SFile& SFile::put(void* x)\n-{\n-    write(x, sz);\n-    return *this;\n-}\n-\n-SFile& SFile::operator[](long i)\n-{\n-    if (rdbuf()->pubseekoff(i * sz, ios::beg) == EOF)\n-\tset(ios::badbit);\n-    return *this;\n-}"}, {"sha": "f07277cee49f6e44ace5582ec01cb0af3d83ecc4", "filename": "libio/SFile.h", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FSFile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FSFile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FSFile.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,55 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1988, 1992, 1993 Free Software Foundation\n-    written by Doug Lea (dl@rocky.oswego.edu)\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#ifndef _SFile_h\n-#ifdef __GNUG__\n-#pragma interface\n-#endif\n-#define _SFile_h 1\n-\n-#include <fstream.h>\n-\n-extern \"C++\" {\n-class SFile: public fstream\n-{\n-  protected:\n-    int       sz;                   // unit size for structured binary IO\n-\n-public:\n-    SFile() : fstream() { }\n-    SFile(int fd, int size);\n-    SFile(const char *name, int size, int mode, int prot=0664);\n-    void open(const char *name, int size, int mode, int prot=0664);\n-    \n-    int       size() { return sz; }\n-    int       setsize(int s) { int old = sz; sz = s; return old; }\n-    \n-    SFile&    get(void* x);\n-    SFile&    put(void* x);\n-    SFile&    operator[](long i);\n-};\n-} // extern \"C++\"\n-\n-#endif"}, {"sha": "05e65a5c371b47ca473455fce8965fa788d5dfd5", "filename": "libio/builtinbuf.cc", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fbuiltinbuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fbuiltinbuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fbuiltinbuf.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,78 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#ifdef __GNUC__\n-#pragma implementation\n-#endif\n-#define _STREAM_COMPAT\n-#include \"builtinbuf.h\"\n-#include \"iostreamP.h\"\n-#if !_IO_UNIFIED_JUMPTABLES\n-int builtinbuf::overflow(int ch) { return _IO_OVERFLOW (this, ch); }\n-\n-int builtinbuf::underflow() { return _IO_UNDERFLOW (this); }\n-\n-streamsize builtinbuf::xsgetn(char* buf, streamsize n)\n-{ return _IO_XSGETN (this, buf, n); }\n-\n-streamsize builtinbuf::xsputn(const char* buf, streamsize n)\n-{ return _IO_XSPUTN (this, buf, n); }\n-\n-int builtinbuf::doallocate() { return _IO_DOALLOCATE (this); }\n-\n-builtinbuf::~builtinbuf() { _IO_FINISH (this); }\n-\n-int builtinbuf::sync() { return _IO_SYNC (this); }\n-\n-streambuf* builtinbuf::setbuf(char *buf, int n)\n-{ return (streambuf*)_IO_SETBUF (this, buf, n); }\n-\n-streampos builtinbuf::seekoff(streamoff off, _seek_dir dir, int mode)\n-{\n-  return _IO_SEEKOFF (this, off, dir, mode);\n-}\n-\n-streampos builtinbuf::seekpos(streampos pos, int mode)\n-{\n-  return _IO_SEEKPOS (this, pos, mode);\n-}\n-\n-int builtinbuf::pbackfail(int c)\n-{ return _IO_PBACKFAIL (this, c); }\n-\n-streamsize builtinbuf::sys_read(char* buf, streamsize size)\n-{ return _IO_SYSREAD (this, buf, size); }\n-\n-streampos builtinbuf::sys_seek(streamoff off, _seek_dir dir)\n-{ return _IO_SYSSEEK (this, off, dir); }\n-\n-streamsize builtinbuf::sys_write(const char* buf, streamsize size)\n-{ return _IO_SYSWRITE (this, buf, size); }\n-\n-int builtinbuf::sys_stat(void* buf) // Actually, a (struct stat*)\n-{ return _IO_SYSSTAT (this, buf); }\n-\n-int builtinbuf::sys_close()\n-{ return _IO_SYSCLOSE (this); }\n-#endif"}, {"sha": "3aa4c37a654f9dd1e5dff9540bb5ffc908dc25b1", "filename": "libio/builtinbuf.h", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fbuiltinbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fbuiltinbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fbuiltinbuf.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,68 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#ifndef _BUILTINBUF_H\n-#define _BUILTINBUF_H\n-\n-#ifdef __GNUC__\n-#pragma interface\n-#endif\n-\n-#include <streambuf.h>\n-\n-#if !_IO_UNIFIED_JUMPTABLES\n-// A builtinbuf is a streambuf where all the virtual operations\n-// call the _IO_jump_t table.\n-\n-extern \"C++\" {\n-class builtinbuf : public streambuf {\n-  friend ios;\n-  virtual int overflow(int);\n-  virtual int underflow();\n-  virtual streamsize xsgetn(char *, streamsize);\n-  virtual streamsize xsputn(const char *, streamsize);\n-  virtual streambuf* setbuf(char*, int);\n-  virtual int doallocate();\n-  virtual ~builtinbuf();\n-  virtual int sync();\n-\n-  virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);\n-  virtual streampos seekpos(streampos pos, int mode = ios::in|ios::out);\n-  virtual int pbackfail(int c);\n-  virtual streamsize sys_read(char* buf, streamsize size);\n-  virtual streampos sys_seek(streamoff, _seek_dir);\n-  virtual streamsize sys_write(const char*, streamsize);\n-  virtual int sys_stat(void*); // Actually, a (struct stat*)\n-  virtual int sys_close();\n-#if 0\n-  virtual int get_column();\n-  virtual int set_column(int);\n-#endif\n- private:\n-  builtinbuf() { }\n-};\n-} // extern \"C++\"\n-#endif\n-\n-#endif /* _BUILTINBUF_H */"}, {"sha": "691fa838b26ab9cb7553f29a8e3965bf7782bb45", "filename": "libio/cleanup.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fcleanup.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,17 +0,0 @@\n-#include \"libioP.h\"\n-#if _G_HAVE_ATEXIT\n-#include <stdlib.h>\n-\n-typedef void (*voidfunc) __P((void));\n-\n-static void\n-_IO_register_cleanup ()\n-{\n-  atexit ((voidfunc)_IO_cleanup);\n-  _IO_cleanup_registration_needed = 0;\n-}\n-\n-void (*_IO_cleanup_registration_needed)() = _IO_register_cleanup;\n-#else\n-void (*_IO_cleanup_registration_needed)() = NULL;\n-#endif /* _G_HAVE_ATEXIT */"}, {"sha": "0c319c118a041c735132e3aa95e1f1433ddba972", "filename": "libio/config.shared", "status": "removed", "additions": 0, "deletions": 502, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig.shared", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig.shared", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig.shared?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,502 +0,0 @@\n-# Copyright (C) 1993, 1995, 1997, 1998 Free Software Foundation\n-# \n-# This file is part of the GNU IO Library.  This library is free\n-# software; you can redistribute it and/or modify it under the\n-# terms of the GNU General Public License as published by the\n-# Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-# \n-# This library is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with GNU CC; see the file COPYING.  If not, write to\n-# the Free Software Foundation, 59 Temple Place - Suite 330,\n-# Boston, MA 02111-1307, USA.  */\n-\n-# File descriptor usage:\n-# 1: All macros which need to be re-definable by any target fragments\n-# 2: All generic rules; especially those which use re-defined macros, e.g. _G_CONFIG_H!\n-\n-# Significant variables:\n-\n-# Note that TO_TOPDIR does *not* include multilib.\n-test -z \"${TO_TOPDIR}\" && TO_TOPDIR=${TOLIBGXX}../\n-# Native configurations build target libraries in directories at the same\n-# level as the rest of the tree.  Cross configurations build target libraries\n-# one level deeper.  TO_REAL_TOPDIR accounts for this.\n-# Obviously, TO_REAL_TOPDIR can only be used in the build tree.\n-if [ \"${with_target_subdir}\" != \".\" ] ; then\n-  TO_REAL_TOPDIR=\"${TO_TOPDIR}../\"\n-else\n-  TO_REAL_TOPDIR=\"${TO_TOPDIR}\"\n-fi\n-DOING_LIBGXX=${DOING_LIBGXX-false}\n-THIS_FILE=\"${srcdir}/${TOLIBIO}config.shared\"\n-\n-echo \"# Start of package fragment generated by ${THIS_FILE}.\"\n-echo \"\"\n-echo >&2 \"# Start of package rules fragment generated by ${THIS_FILE}.\"\n-echo >&2 \"\"\n-\n-# Multilib support.\n-echo 'MULTISRCTOP ='\n-echo 'MULTIBUILDTOP ='\n-echo 'MULTIDIRS ='\n-echo 'MULTISUBDIR ='\n-echo 'MULTIDO = true'\n-echo 'MULTICLEAN = true'\n-echo ''\n-\n-# TOLIBGXX\n-# MOSTLYCLEAN\n-# CLEAN\n-# DISTCLEAN\n-# REALCLEAN\n-# SUBDIRS [defaults to (configdirs)]\n-# INFO_FILES   List of (basenames of) texinfo files\n-# INFO_SUBDIRS [default: empty]  sub-directories containing documentation\n-\n-# ??? This doesn't appear to be used by us or any of our callers.\n-# Note that all uses in this file are single-quoted.\n-rootme=${rootme-`pwd`}\n-\n-# libg++ uses the convention that $rootme includes a trailing '/'.\n-# We use that in the definition of TOPDIR.  $rootme is either empty\n-# or an absolute pathname to the current directory (with trailing '/').\n-TOPDIR=${TOPDIR-'$${rootme}$(MULTIBUILDTOP)'${TO_REAL_TOPDIR}}\n-echo '#' TOPDIR=\"${TOPDIR} invsubdir=${invsubdir} subdir=${subdir}\"\n-SUBDIRS=${SUBDIRS-${configdirs}}\n-CHECK_SUBDIRS=${CHECK_SUBDIRS-${SUBDIRS}}\n-\n-echo \"srcdir = ${srcdir}\"\n-echo \"SUBDIRS = ${SUBDIRS}\"\n-echo \"CHECK_SUBDIRS = ${CHECK_SUBDIRS}\"\n-\n-echo \"prefix = ${prefix-/usr/local}\"\n-echo \"exec_prefix = ${exec_prefix-'${prefix}'}\"\n-\n-echo 'bindir = $(exec_prefix)/bin'\n-echo 'libdir = $(exec_prefix)/lib'\n-echo 'libsubdir = $(libdir)/gcc-lib/$(target_alias)/$(gcc_version)'\n-\n-echo 'datadir = $(prefix)/lib'\n-echo 'mandir = $(prefix)/man'\n-echo 'man1dir = $(mandir)/man1'\n-echo 'man2dir = $(mandir)/man2'\n-echo 'man3dir = $(mandir)/man3'\n-echo 'man4dir = $(mandir)/man4'\n-echo 'man5dir = $(mandir)/man5'\n-echo 'man6dir = $(mandir)/man6'\n-echo 'man7dir = $(mandir)/man7'\n-echo 'man8dir = $(mandir)/man8'\n-echo 'man9dir = $(mandir)/man9'\n-\n-echo 'infodir = $(prefix)/info'\n-echo 'includedir = $(prefix)/include'\n-echo 'docdir = $(datadir)/doc'\n-echo ''\n-echo 'SHELL = /bin/sh'\n-echo ''\n-case \"$srcdir\" in\n-  /*) echo 'INSTALL = $(srcdir)'/\"${TO_TOPDIR}install-sh -c\" ;;\n-  .)  echo 'INSTALL = $${rootme}'\"${with_multisrctop}${TO_REAL_TOPDIR}install-sh -c\" ;;\n-  *)  echo 'INSTALL = $${rootme}$(srcdir)'/\"${TO_TOPDIR}install-sh -c\" ;;\n-esac\n-echo 'INSTALL_PROGRAM = $(INSTALL)'\n-echo 'INSTALL_DATA = $(INSTALL)'\n-echo ''\n-echo 'AR = `if [ -f' ${TOPDIR}'binutils/ar ] ; \\'\n-echo \"\tthen echo ${TOPDIR}binutils/ar ; \"'\\'\n-echo '\telse echo ar ; fi`'\n-echo 'AR_FLAGS = rc'\n-echo 'RANLIB = `if [ -f' ${TOPDIR}'binutils/ranlib ] ; \\'\n-echo '\tthen echo '${TOPDIR}'binutils/ranlib ; \\'\n-echo '\telse echo ranlib ; fi`'\n-echo 'NM = `if [ -f' ${TOPDIR}'binutils/nm.new ] ; \\'\n-echo '\tthen echo '${TOPDIR}'binutils/nm.new ; \\'\n-echo '\telse echo nm ; fi`'\n-echo 'NLMCONV = `if [ -f' ${TOPDIR}'binutils/nlmconv ] ; \\'\n-echo '\tthen echo '${TOPDIR}'binutils/nlmconv ; \\'\n-echo '\telse echo nlmconv ; fi`'\n-echo 'LD = `if [ -f' ${TOPDIR}'ld/ld.new ] ; \\'\n-echo '\tthen echo '${TOPDIR}'ld/ld.new ; \\'\n-echo '\telse echo ld ; fi`'\n-echo ''\n-echo 'MAKEINFO = `if [ -f '${TOPDIR}'texinfo/C/makeinfo ] ; \\'\n-echo '\tthen echo '${TOPDIR}'texinfo/C/makeinfo ; \\'\n-echo '\telse echo makeinfo ; fi`'\n-case \"$srcdir\" in\n-  .) echo 'TEXIDIR = '\"${with_multisrctop}${TO_REAL_TOPDIR}texinfo\" ;;\n-  *) echo 'TEXIDIR = $(srcdir)'/\"${TO_TOPDIR}texinfo\" ;;\n-esac\n-echo 'TEXI2DVI = TEXINPUTS=${TEXIDIR}:$$TEXINPUTS texi2dvi'\n-echo ''\n-echo 'CC = cc'\n-echo 'CXX = gcc'\n-echo ''\n-# FIXME!!!\n-if true ; then\n-  echo 'WRAP_C_INCLUDES ='\n-else\n-  echo 'WRAP_C_INCLUDES = -I$(srcdir)'/${TOLIBGXX}g++-include\n-fi\n-echo 'CFLAGS = -g'\n-echo 'CXXFLAGS = -g -O'\n-echo 'LIBCFLAGS = $(CFLAGS)'\n-echo 'LIBCXXFLAGS = $(CXXFLAGS) -fno-implicit-templates'\n-if [ \"${LIBDIR}\" = \"yes\" ]; then\n-  echo 'PICDIR = stamp-picdir'\n-else\n-  echo 'PICDIR = '\n-fi\n-\n-if test \"${DOING_LIBGXX}\" = \"true\" ; then\n-  echo \"TOLIBGXX = ${TOLIBGXX}\"\n-  echo 'PROTODIR = $(srcdir)'/${TOLIBGXX}src/gen\n-  echo \"LIBS = -L./${TOLIBGXX} -L./${TOLIBGXX}../libstdc++ -lg++ -lstdc++\"\n-\n-  # You can override iostream (e.g. in a site- or host-Makefile fragment) to:\n-  # iostream (Normal iostream library)\n-  # old-stream (Old stream library; no longer supported)\n-  # no-stream (If you don't want iostream to be part of libg++)\n-  echo 'IO_DIR = ../libio'\n-  echo '# IO_DIR = no-stream'\n-elif test \"${DOING_GPERF}\" = \"true\" ; then\n-  echo \"IO_DIR = libio\"\n-  echo \"LIBS = -L${TO_TOPDIR}libstdc++ -lstdc++\"\n-fi\n-\n-if [ -z \"${ALL}\" ] ; then\n-  if [ -n \"${TARGETLIB}\" ] ; then\n-    ALL='$(TARGETLIB)'\n-    echo \"TARGETLIB = ${TARGETLIB}\"\n-  elif [ -n \"${TARGETPROG}\" ] ; then\n-    ALL='${TARGETPROG}'\n-    echo \"TARGETPROG = ${TARGETPROG}\"\n-  else\n-    echo \"config error: neither ALL, TARGETLIB or TARGETPROG is defined\" 1>&2\n-  fi\n-fi\n-\n-echo >&2 \"all: ${ALL} multi-all\"\n-if [ \"${SUBDIRS}\" != \"\" ] ; then\n-  echo >&2 '\t@rootme=`pwd`/; export rootme; \\'\n-  echo >&2 '\t$(MAKE) \"DODIRS=$(SUBDIRS)\" DO=all $(FLAGS_TO_PASS) subdir_do'\n-fi\n-if [ \"${LIBDIR}\" = \"yes\" ]; then\n-  echo >&2 \"${ALL} \"'multi-all: $(PICDIR)'\n-fi\n-echo >&2 '.PHONY: all'\n-echo >&2 ''\n-\n-echo >&2 '.PHONY: multi-all'\n-echo >&2 'multi-all:'\n-echo >&2 '\t@$(MULTIDO) $(FLAGS_TO_PASS) multi-do DO=all'\n-echo >&2 ''\n-\n-echo >&2\n-if [ \"${SUBDIRS}\" != \"\" ] ; then\n-  echo >&2 '.PHONY: subdir_do'\n-  echo >&2 'subdir_do: force'\n-  echo >&2 '\t@rootme=`pwd`/; export rootme; \\'\n-  echo >&2 '\tfor i in $(DODIRS); do \\'\n-  echo >&2 '\t\tif [ -f  ./$$i/Makefile ] ; then \\'\n-  echo >&2 '\t\t\techo \"cd $$i; make $(DO) ...\" ; \\'\n-  echo >&2 '\t\t\t(cd $$i ; $(MAKE) $(FLAGS_TO_PASS) $(DO)) || exit 1 ; \\'\n-  echo >&2 '\t\telse true ; fi ; \\'\n-  echo >&2 '\tdone'\n-  echo >&2 ''\n-  echo >&2 '# List of variables to pass to sub-makes.  This should not be needed'\n-  echo >&2 '# by GNU make or Sun make (both of which pass command-line variable'\n-  echo >&2 '# overrides thouh $(MAKE)) but may be needed by older versions.'\n-  echo >&2 ''\n-  echo >&2 'FLAGS_TO_PASS= \\'\n-  echo >&2 '\t\"SHELL=$(SHELL)\" \\'\n-  echo >&2 '\t\"INSTALL=$(INSTALL)\" \\'\n-  echo >&2 '\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\'\n-  echo >&2 '\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\'\n-  echo >&2 '\t\"prefix=$(prefix)\" \\'\n-  echo >&2 '\t\"exec_prefix=$(exec_prefix)\" \\'\n-  echo >&2 '\t\"tooldir=$(tooldir)\" \\'\n-  echo >&2 '\t\"gxx_include_dir=$(gxx_include_dir)\" \\'\n-  echo >&2 '\t\"libsubdir=$(libsubdir)\" \\'\n-  echo >&2 '\t\"gcc_version=$(gcc_version)\" \\'\n-  echo >&2 '\t\"gcc_version_trigger=$(gcc_version_trigger)\" \\'\n-  echo >&2 '\t\"AR=$(AR)\" \\'\n-  echo >&2 '\t\"AR_FLAGS=$(AR_FLAGS)\" \\'\n-  echo >&2 '\t\"CC=$(CC)\" \\'\n-  echo >&2 '\t\"CXX=$(CXX)\" \\'\n-  echo >&2 '\t\"CFLAGS=$(CFLAGS)\" \\'\n-  echo >&2 '\t\"CXXFLAGS=$(CXXFLAGS)\" \\'\n-  echo >&2 '\t\"NM=$(NM)\" \\'\n-  echo >&2 '\t\"RANLIB=$(RANLIB)\" \\'\n-  echo >&2 '\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\'\n-  echo >&2 '\t\"LIBCXXFLAGS=$(LIBCXXFLAGS)\" \\'\n-  echo >&2 '\t\"LOADLIBES=$(LOADLIBES)\" \\'\n-  echo >&2 '\t\"LDFLAGS=$(LDFLAGS)\" \\'\n-  echo >&2 '\t\"MAKEINFO=$(MAKEINFO)\" \\'\n-  echo >&2 '\t\"SHLIB=$(SHLIB)\" \\'\n-  echo >&2 '\t\"SHCURSES=$(SHCURSES)\" \\'\n-  echo >&2 '\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\"'\n-fi\n-\n-echo >&2 'NOSTDINC = -nostdinc++'\n-if test -n \"${XCXXINCLUDES}\" ; then\n-  echo >&2 \"CXXINCLUDES = ${XCXXINCLUDES} \"'$(NOSTDINC)'\n-elif test \"${DOING_LIBGXX}\" = \"true\" ; then\n-  echo >&2 'CXXINCLUDES = $(NOSTDINC) -I. -I'\"${TO_TOPDIR}libio\"' -I$(srcdir) -I$(srcdir)/'\"${TOLIBGXX}\"'$(IO_DIR) -I$(srcdir)/'\"${TOLIBGXX}\"'../libstdc++ -I$(srcdir)/'\"${TOLIBGXX}src\"' '\"${host_includes}\"' $(WRAP_C_INCLUDES)'\n-fi\n-if test -n \"${XCINCLUDES}\" ; then\n-  echo >&2 \"CINCLUDES = ${XCINCLUDES}\"\n-elif test \"${DOING_LIBGXX}\" = \"true\" ; then\n-  echo >&2 'CINCLUDES ='\n-fi\n-\n-if [ \"${LIBDIR}\" = \"yes\" ]; then\n-  echo >&2 'XCFLAGS = $(LIBCFLAGS)'\n-  echo >&2 'XCXXFLAGS = $(LIBCXXFLAGS)'\n-else\n-  echo >&2 'XCFLAGS = $(CFLAGS)'\n-  echo >&2 'XCXXFLAGS = $(CXXFLAGS)'\n-fi\n-\n-echo >&2 '.SUFFIXES: .o .C .cc .c'\n-echo >&2 'COMPILE.c = $(CC) -c $(XCFLAGS) $(CINCLUDES) $(MT_CFLAGS)'\n-echo >&2 '.c.o:'\n-if [ \"${LIBDIR}\" = \"yes\" ]; then\n-echo >&2 '\tif [ x\"$(PICFLAG)\" != x ]; then \\'\n-echo >&2 '\t  $(COMPILE.c) $(PICFLAG) $< -o pic/$@; \\'\n-echo >&2 '\telse true; fi'\n-fi\n-echo >&2 '\t$(COMPILE.c) $<'\n-[ \"${TOUCH_ON_COMPILE}\" = \"yes\" ] && echo >&2 '\t@touch stamp'\n-echo >&2 'COMPILE.cc = $(CXX) -c $(XCXXFLAGS) $(CXXINCLUDES) $(MT_CFLAGS)'\n-echo >&2 '.C.o:'\n-if [ \"${LIBDIR}\" = \"yes\" ]; then\n-echo >&2 '\tif [ x\"$(PICFLAG)\" != x ]; then \\'\n-echo >&2 '\t  $(COMPILE.cc) $(PICFLAG) $< -o pic/$@; \\'\n-echo >&2 '\telse true; fi'\n-fi\n-echo >&2 '\t$(COMPILE.cc) $<'\n-[ \"${TOUCH_ON_COMPILE}\" = \"yes\" ] && echo >&2 '\t@touch stamp'\n-echo >&2 '.cc.o:'\n-if [ \"${LIBDIR}\" = \"yes\" ]; then\n-echo >&2 '\tif [ x\"$(PICFLAG)\" != x ]; then \\'\n-echo >&2 '\t  $(COMPILE.cc) $(PICFLAG) $< -o pic/$@; \\'\n-echo >&2 '\telse true; fi'\n-fi\n-echo >&2 '\t$(COMPILE.cc) $<'\n-[ \"${TOUCH_ON_COMPILE}\" = \"yes\" ] && echo >&2 '\t@touch stamp'\n-echo >&2 ''\n-\n-if [ -n \"${TARGETLIB}\" ] ; then\n-  echo TARGETLIB = ${TARGETLIB}\n-fi\n-if [ -n \"${TARGETPROG}\" ] ; then\n-  echo TARGETPROG = ${TARGETPROG}\n-fi\n-\n-if [ \"${LIBDIR}\" = \"yes\" ]; then\n-  echo >&2 ''\n-  echo >&2 'stamp-picdir:'\n-  echo >&2 '\tif [ x\"$(PICFLAG)\" != x ] && [ ! -d pic ]; then \\'\n-  echo >&2 '\t  mkdir pic; \\'\n-  echo >&2 '\telse true; fi'\n-  echo >&2 '\ttouch stamp-picdir'\n-fi\n-\n-echo >&2 ''\n-echo >&2 '.PHONY: install'\n-echo >&2 'install:'\n-echo >&2 '.PHONY: check'\n-if [ \"${CHECK}\" != \"check\" ] ; then\n-  echo >&2 \"check: ${ALL} ${CHECK}\"\n-  if [ \"${CHECK_SUBDIRS}\" != \"\" ] ; then\n-    echo >&2 '\trootme=`pwd`/; export rootme; \\'\n-    echo >&2 '\tSAVE_LLPATH=\"$${SAVE_LLPATH-$$LD_LIBRARY_PATH}\"; export SAVE_LLPATH; \\'\n-    echo >&2 '\tLD_LIBRARY_PATH=\"$${rootme}${TOLIBGXX}../libstdc++:$${rootme}${TOLIBGXX}../libg++:$$SAVE_LLPATH\"; \\'\n-    echo >&2 '\texport LD_LIBRARY_PATH; \\'\n-    echo >&2 '\t$(MAKE) \"DODIRS=$(CHECK_SUBDIRS)\" DO=check $(FLAGS_TO_PASS) subdir_do'\n-  fi\n-fi\n-\n-# Generate rules for documentation (depending on INFO_FILES and INFO_SUBDIRS).\n-\n-echo >&2 '.PHONY: info dvi install-info clean-info'\n-\n-# emit the rule for 'info'\n-# (Note that the top-level ../Makefile.in greps for '^info:' when making\n-# a release (in \"make taz\"), so don't break that!)\n-if [ -z \"${INFO_FILES}\" ] ; then\n-  echo >&2 'info:'\n-else\n-  echo >&2 info: `for file in ${INFO_FILES} ; do echo $file.info ; done`\n-fi\n-if [ \"${INFO_SUBDIRS}\" != \"\" ] ; then\n-  echo >&2 '\t@rootme=`pwd`/; export rootme; \\\n-\t$(MAKE) \"DODIRS='${INFO_SUBDIRS}'\" DO=info $(FLAGS_TO_PASS) subdir_do'\n-fi\n-\n-# emit the rule for 'dvi'\n-if [ -z \"${INFO_FILES}\" ] ; then\n-  echo >&2 'dvi:'\n-else\n-  echo >&2 dvi: `for file in ${INFO_FILES} ; do echo $file.dvi ; done`\n-fi\n-if [ \"${INFO_SUBDIRS}\" != \"\" ] ; then\n-  echo >&2 '\t@rootme=`pwd`/; export rootme; \\\n-\t$(MAKE) \"DODIRS='${INFO_SUBDIRS}'\" DO=dvi $(FLAGS_TO_PASS) subdir_do'\n-fi\n-\n-# Emit rules for each *.info and *.dvi file\n-for file in ${INFO_FILES} ; do\n-  echo >&2 ${file}.info: '$(srcdir)'/${file}.texi\n-  echo >&2 '\t$(MAKEINFO) -I$(srcdir) -I$(TEXIDIR) $(srcdir)/'${file}.texi -o ${file}.info\n-  echo >&2 ${file}.dvi: '$(srcdir)'/${file}.texi\n-  echo >&2 '\t$(TEXI2DVI) $(srcdir)'/${file}.texi\n-  echo >&2 \"${file}.ps: ${file}.dvi\"\n-  echo >&2 \"\tdvips ${file} -o\"\n-done\n-\n-# emit the rule for install-info\n-echo >&2 'install-info:'\n-if [ -n \"${INFO_FILES}\" ] ; then\n-  echo >&2 '\t-parent=`echo $(infodir)|sed -e' \"'\"'s@/[^/]*$$@@'\"'\"'`; \\'\n-  echo >&2 '\tif [ -d $$parent ] ; then true ; else mkdir $$parent ; fi'\n-  echo >&2 '\t-if [ -d $(infodir) ] ; then true ; else mkdir $(infodir) ; fi'\n-  echo >&2 '\tfor i in *.info* ; do \\'\n-  echo >&2 '\t  $(INSTALL_DATA) $$i $(infodir)/$$i ; \\'\n-  echo >&2 '\tdone'\n-fi\n-if [ \"${INFO_SUBDIRS}\" != \"\" ] ; then\n-  echo >&2 '\t@rootme=`pwd`/; export rootme; \\\n-\t$(MAKE) \"DODIRS='${INFO_SUBDIRS}'\" DO=install-info $(FLAGS_TO_PASS) subdir_do'\n-fi\n-\n-# emit clean-info and clean-dvi rules\n-echo >&2 '.PHONY: do-clean-info clean-info do-clean-dvi clean-dvi'\n-echo >&2 do-clean-info:\n-if [ -n \"${INFO_FILES}\" ] ; then\n-  echo >&2 '\trm -f *.info*'\n-fi\n-echo >&2 'do-clean-dvi:'\n-if [ -n \"${INFO_FILES}\" ] ; then\n-  echo >&2 '\trm -f *.dvi *.aux *.cp *.cps *.fn* *.ky *.log *.pg *.toc *.tp *.vr'\n-fi\n-for type in info dvi ; do\n-  echo >&2 clean-${type}: do-clean-${type}\n-  if [ \"${INFO_SUBDIRS}\" != \"\" ] ; then\n-    echo >&2 '\t@rootme=`pwd`/; export rootme; \\\n-\t$(MAKE) \"DODIRS='${NFO_SUBDIRS}'\" DO=clean-'${type} '$(FLAGS_TO_PASS) subdir_do'\n-  fi\n-done\n-\n-echo >&2 ''\n-\n-echo >&2 '.PHONY: boltcc'\n-echo >&2 'boltcc:'\n-echo >&2 '\trootme=`pwd`/ ; export rootme ; $(MAKE) $(FLAGS_TO_PASS)'\n-echo >&2 ''\n-\n-# Emit clean rules\n-\n-echo >&2 ''\n-echo >&2 '# clean rules'\n-\n-MOSTLYCLEAN=\"${MOSTLYCLEAN-*.o pic stamp-picdir core ${EXTRA_MOSTLYCLEAN}} `if test -n \"${TOUCH_ON_COMPILE}\"; then echo stamp; else true; fi`\"\n-CLEAN=\"${CLEAN-${TARGETPROG} ${TARGETLIB}}\"\n-DISTCLEAN=\"${DISTCLEAN-config.status Makefile *~ Make.pack target-mkfrag multilib.out ${EXTRA_DISTCLEAN-}}\"\n-REALCLEAN=\"${REALCLEAN-depend *.info*}\"\n-\n-\n-echo >&2 '.PHONY: mostlyclean clean distclean maintainer-clean realclean'\n-if test -z \"${SUBDIRS}\" ; then\n-  echo >&2 \"mostlyclean: clean-dvi\"\n-  echo >&2 \"\trm -rf ${MOSTLYCLEAN}\"\n-  echo >&2 '\t@$(MULTICLEAN) multi-clean DO=mostlyclean'\n-  echo >&2 \"clean: clean-dvi\"\n-  echo >&2 \"\trm -rf ${MOSTLYCLEAN} ${CLEAN}\"\n-  echo >&2 '\t@$(MULTICLEAN) multi-clean DO=clean'\n-  echo >&2 \"distclean: clean\"\n-  echo >&2 '\t@$(MULTICLEAN) multi-clean DO=distclean'\n-  echo >&2 \"\trm -rf ${DISTCLEAN}\"\n-  echo >&2 \"maintainer-clean realclean: clean clean-info\"\n-  echo >&2 '\t@$(MULTICLEAN) multi-clean DO=maintainer-clean'\n-  echo >&2 \"\trm -rf ${DISTCLEAN} ${REALCLEAN}\"\n-else\n-  echo >&2 '.PHONY: do-clean subdir_distclean subdir_maintainer_clean'\n-  echo >&2 \"mostlyclean: do-clean-dvi\"\n-  echo >&2 \"\trm -rf ${MOSTLYCLEAN}\"\n-  echo >&2 '\t@$(MAKE) $(FLAGS_TO_PASS) \"DODIRS=$(SUBDIRS)\" DO=mostlyclean subdir_do'\n-  echo >&2 '\t@$(MULTICLEAN) multi-clean DO=mostlyclean'\n-  echo >&2 \"do-clean: do-clean-dvi\"\n-  echo >&2 \"\trm -rf ${MOSTLYCLEAN} ${CLEAN}\"\n-  echo >&2 \"clean: do-clean\"\n-  echo >&2 '\t@$(MAKE) $(FLAGS_TO_PASS) \"DODIRS=$(SUBDIRS)\" DO=clean subdir_do'\n-  echo >&2 '\t@$(MULTICLEAN) multi-clean DO=clean'\n-  # distclean and maintainer-clean are tricky because they remove the Makefile.\n-  echo >&2 \"subdir_distclean:\"\n-  echo >&2 '\t@$(MAKE) $(FLAGS_TO_PASS) \"DODIRS=$(SUBDIRS)\" DO=distclean subdir_do'\n-  echo >&2 \"distclean: do-clean subdir_distclean\"\n-  echo >&2 '\t@$(MULTICLEAN) multi-clean DO=distclean'\n-  echo >&2 \"\trm -rf ${DISTCLEAN}\"\n-  echo >&2 \"subdir_maintainer_clean:\"\n-  echo >&2 '\t@$(MAKE) $(FLAGS_TO_PASS) \"DODIRS=$(SUBDIRS)\" DO=maintainer-clean subdir_do'\n-  echo >&2 \"maintainer-clean realclean: do-clean subdir_maintainer_clean do-clean-info\"\n-  echo >&2 '\t@$(MULTICLEAN) multi-clean DO=maintainer-clean'\n-  echo >&2 \"\trm -rf ${DISTCLEAN} ${REALCLEAN}\"\n-fi\n-\n-echo >&2 ''\n-echo >&2 '.PHONY: force'\n-echo >&2 'force:'\n-echo >&2 ''\n-echo >&2 '# with the gnu make, this is done automatically.'\n-echo >&2 ''\n-echo >&2 'Makefile: $(srcdir)/Makefile.in $(host_makefile_frag) $(target_makefile_frag) $(gcc_version_trigger)'\n-echo >&2 '\t$(SHELL) ./config.status'\n-echo >&2 ''\n-echo >&2 '.NOEXPORT:'\n-echo >&2 'MAKEOVERRIDES='\n-\n-cat >&2 <<\"EOF\"\n-DEPEND_SOURCES = ${srcdir}/*.cc ${srcdir}/*.c\n-depend.new:\n-# The sed script below attempts to make the depend output portable.\n-# It cleans up the depenency information generated by cpp.\n-# It replaces instances of $(srcdir)/ by the string '$(srcdir)/'.\n-# It removes remaining absolute files names (such as /usr/include/stdio.h).\n-# It removes lines containing only \"\\\\\".\n-# It inserts '$(MULTISRCTOP)' in '$(srcdir)/..'.\n-# In order to support SunOS VPATH, $(srcdir)/[a-z]*.{c,cc} is replaced with\n-# [a-z]*.{c,cc} (the directory part is removed).\n-# The awk script removes a continuation marker that is followed by\n-# a blank line, since that may confuse make.\n-\techo \"# AUTOMATICALLY GENERATED BY 'make depend' - DO NOT EDIT\" \\\n-\t  >depend.new\n-\t$(CXX) -M $(CXXINCLUDES) $(DEPEND_SOURCES) \\\n-\t| sed -e 's|$(srcdir)/|$$(srcdir)/|g' \\\n-\t      -e 's| [^ ]*_G_config.h| $$(_G_CONFIG_H)|g' \\\n-\t      -e 's| /[^ ]*||g' -e 's| libc-lock\\.h||' \\\n-\t      -e '/^[ \t]*\\\\$$/d' -e 's/^[ \t]*$$//' \\\n-\t| sed -e 's|$$(srcdir)/[.][.]|$$(srcdir)/$$(MULTISRCTOP)..|g' \\\n-\t      -e 's|$$(srcdir)/\\([^/]*[.]c\\)|\\1|' \\\n-\t| awk 'BEGIN   { prev = \"\" } \\\n-\t      /^( )*$$/ { if (prev ~ /\\\\$$/) \\\n-\t                    { prev = substr(prev,1,length(prev)-1); next } } \\\n-\t                { print prev; prev = $$0 } \\\n-\t      END { if (prev !~ /^( )*$$/) print prev }' \\\n-\t>> depend.new\n-$(srcdir)/depend:  depend.new\n-\tmv depend.new $(srcdir)/depend\n-EOF\n-\n-if [ -f ${srcdir}/${subdir}/depend ] ; then\n-  cat ${srcdir}/${subdir}/depend >&2\n-fi\n-\n-echo \"# End of package fragment generated by ${THIS_FILE}.\"\n-echo >&2 \"# End of package rules fragment generated by ${THIS_FILE}.\""}, {"sha": "9e3c519ed13b51ae2dc04e9a57f7a238b6e4da86", "filename": "libio/config/linux.mt", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Flinux.mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Flinux.mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Flinux.mt?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,25 +0,0 @@\n-# Use the libio which comes with the local libc.\n-\n-# Comment this out to avoid including the stdio functions in libiostream.a:\n-# LIBIOSTREAM_OBJECTS = $(IO_OBJECTS) $(IOSTREAM_OBJECTS) $(STDIO_WRAP_OBJECTS) $(OSPRIM_OBJECTS)\n-# LIBIOSTREAM_DEP = $(LIBIOSTREAM_OBJECTS) stdio.list\n-# LIBIOSTREAM_USE = $(LIBIOSTREAM_OBJECTS) `cat stdio.list`\n-\n-# Comment the above and uncomment the below to use the code in the Linux libc:\n-# We have _G_config.h in /usr/include.\n-_G_CONFIG_H=\n-\n-# We must not see the libio.h file from this library.\n-LIBIO_INCLUDE=\n-\n-# We have those in libc.a.\n-IO_OBJECTS= iogetline.o\n-STDIO_WRAP_OBJECTS=\n-OSPRIM_OBJECTS=\n-STDIO_OBJECTS=\n-\n-# We have the rest in /usr/include.\n-USER_INCLUDES=PlotFile.h SFile.h builtinbuf.h editbuf.h fstream.h \\\n-\tindstream.h iomanip.h iostream.h istream.h ostream.h \\\n-\tparsestream.h pfstream.h procbuf.h stdiostream.h stream.h \\\n-\tstreambuf.h strfile.h strstream.h"}, {"sha": "2523a0d5157b272898470b42c8888be1b290242d", "filename": "libio/config/linuxaxp1-libc-lock.h", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Flinuxaxp1-libc-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Flinuxaxp1-libc-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Flinuxaxp1-libc-lock.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,112 +0,0 @@\n-/* libc-internal interface for mutex locks.  LinuxThreads version.\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Library General Public License as\n-   published by the Free Software Foundation; either version 2 of the\n-   License, or (at your option) any later version.\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Library General Public License for more details.\n-\n-   You should have received a copy of the GNU Library General Public\n-   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n-   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n-\n-#ifndef _LIBC_LOCK_H\n-#define _LIBC_LOCK_H 1\n-\n-#include <pthread.h>\n-#define __libc_lock_t pthread_mutex_t\n-\n-/* Define a lock variable NAME with storage class CLASS.  The lock must be\n-   initialized with __libc_lock_init before it can be used (or define it\n-   with __libc_lock_define_initialized, below).  Use `extern' for CLASS to\n-   declare a lock defined in another module.  In public structure\n-   definitions you must use a pointer to the lock structure (i.e., NAME\n-   begins with a `*'), because its storage size will not be known outside\n-   of libc.  */\n-#define __libc_lock_define(CLASS,NAME) \\\n-  CLASS __libc_lock_t NAME;\n-\n-/* Define an initialized lock variable NAME with storage class CLASS.  */\n-#define __libc_lock_define_initialized(CLASS,NAME) \\\n-  CLASS __libc_lock_t NAME = PTHREAD_MUTEX_INITIALIZER;\n-\n-/* Initialize the named lock variable, leaving it in a consistent, unlocked\n-   state.  */\n-#define __libc_lock_init(NAME) \\\n-  (__pthread_mutex_init != NULL ? __pthread_mutex_init (&(NAME), NULL) : 0);\n-\n-/* Same as last but this time we initialize a recursive mutex.  */\n-#define __libc_lock_init_recursive(NAME) \\\n-  do {                                                                      \\\n-    if (__pthread_mutex_init != NULL)                                       \\\n-      {                                                                     \\\n-      pthread_mutexattr_t __attr;                                           \\\n-      __pthread_mutexattr_init (&__attr);                                   \\\n-      __pthread_mutexattr_setkind_np (&__attr, PTHREAD_MUTEX_RECURSIVE_NP); \\\n-      __pthread_mutex_init (&(NAME), &__attr);                              \\\n-      __pthread_mutexattr_destroy (&__attr);                                \\\n-      }                                                                             \\\n-  } while (0);\n-\n-/* Finalize the named lock variable, which must be locked.  It cannot be\n-   used again until __libc_lock_init is called again on it.  This must be\n-   called on a lock variable before the containing storage is reused.  */\n-#define __libc_lock_fini(NAME) \\\n-  (__pthread_mutex_destroy != NULL ? __pthread_mutex_destroy (&(NAME)) : 0);\n-\n-/* Lock the named lock variable.  */\n-#define __libc_lock_lock(NAME) \\\n-  (__pthread_mutex_lock != NULL ? __pthread_mutex_lock (&(NAME)) : 0);\n-\n-/* Try to lock the named lock variable.  */\n-#define __libc_lock_trylock(NAME) \\\n-  (__pthread_mutex_trylock != NULL ? __pthread_mutex_trylock (&(NAME)) : 0);\n-\n-/* Unlock the named lock variable.  */\n-#define __libc_lock_unlock(NAME) \\\n-  (__pthread_mutex_unlock != NULL ? __pthread_mutex_unlock (&(NAME)) : 0);\n-\n-/* Start critical region with cleanup.  */\n-#define __libc_cleanup_region_start(FCT, ARG) \\\n-  { struct _pthread_cleanup_buffer _buffer;                                 \\\n-    if (_pthread_cleanup_push_defer != NULL) {                              \\\n-      _pthread_cleanup_push_defer (&_buffer, (FCT), (ARG));                 \\\n-    }\n-\n-/* End critical region with cleanup.  */\n-#define __libc_cleanup_region_end(DOIT) \\\n-    if (_pthread_cleanup_push_defer != NULL) {                              \\\n-      _pthread_cleanup_pop_restore (&_buffer, (DOIT));                      \\\n-    }                                                                       \\\n-  }\n-\n-/* Make the pthread functions weak so that we can elide them from\n-   single-threaded processes.  */\n-#pragma weak __pthread_mutex_init\n-#pragma weak __pthread_mutex_destroy\n-#pragma weak __pthread_mutex_lock\n-#pragma weak __pthread_mutex_trylock\n-#pragma weak __pthread_mutex_unlock\n-#pragma weak __pthread_mutexattr_init\n-#pragma weak __pthread_mutexattr_destroy\n-#pragma weak __pthread_mutexattr_setkind_np\n-#pragma weak __pthread_key_create\n-#pragma weak __pthread_setspecific\n-#pragma weak __pthread_getspecific\n-#pragma weak __pthread_initialize\n-#pragma weak _pthread_cleanup_push_defer\n-#pragma weak _pthread_cleanup_pop_restore\n-\n-/* We need portable names for some functions.  E.g., when they are\n-   used as argument to __libc_cleanup_region_start.  */\n-#define __libc_mutex_unlock __pthread_mutex_unlock\n-\n-#endif        /* libc-lock.h */\n-"}, {"sha": "cbee76867d12053c57a68a34db5066ff844e408a", "filename": "libio/config/linuxaxp1-stdio-lock.h", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Flinuxaxp1-stdio-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Flinuxaxp1-stdio-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Flinuxaxp1-stdio-lock.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,36 +0,0 @@\n-/* Thread package specific definitions of stream lock type.\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Library General Public License as\n-   published by the Free Software Foundation; either version 2 of the\n-   License, or (at your option) any later version.\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Library General Public License for more details.\n-\n-   You should have received a copy of the GNU Library General Public\n-   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n-   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n-\n-#include <pthread.h>\n-\n-typedef pthread_mutex_t _IO_lock_t;\n-\n-/* We need recursive (counting) mutexes.  */\n-#define _IO_lock_initializer PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\n-\n-\n-#define _IO_cleanup_region_start(_fct, _fp) \\\n-     __libc_cleanup_region_start (_fct, _fp)\n-#define _IO_cleanup_region_end(_doit) \\\n-     __libc_cleanup_region_end (_doit)\n-#define _IO_lock_init(_name) \\\n-     __libc_lock_init_recursive (_name)\n-#define _IO_lock_fini(_name) \\\n-     __libc_lock_fini_recursive (_name)\n-"}, {"sha": "d9b7e8c7e95628b864ec86fc114302f25c20fb0d", "filename": "libio/config/linuxaxp1.mt", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Flinuxaxp1.mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Flinuxaxp1.mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Flinuxaxp1.mt?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,10 +0,0 @@\n-# We _do_ need a new _G_config.h\n-_G_CONFIG_H=_G_config.h\n-\n-# And the two bits files.\n-all:\n-install: install-axp-mt-headers\n-\n-install-axp-mt-headers:\n-\t$(INSTALL_DATA) libc-lock.h $(gxx_include_dir)/libc-lock.h\n-\t$(INSTALL_DATA) stdio-lock.h $(gxx_include_dir)/stdio-lock.h"}, {"sha": "742cbf18534290b751b57b37fc70d249fd220841", "filename": "libio/config/linuxlibc1.mt", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Flinuxlibc1.mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Flinuxlibc1.mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Flinuxlibc1.mt?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,26 +0,0 @@\n-# Use the libio which comes with the local libc.\n-\n-# Comment this out to avoid including the stdio functions in libiostream.a:\n-# LIBIOSTREAM_OBJECTS = $(IO_OBJECTS) $(IOSTREAM_OBJECTS) $(STDIO_WRAP_OBJECTS) $(OSPRIM_OBJECTS)\n-# LIBIOSTREAM_DEP = $(LIBIOSTREAM_OBJECTS) stdio.list\n-# LIBIOSTREAM_USE = $(LIBIOSTREAM_OBJECTS) `cat stdio.list`\n-\n-# We must not see the libio.h file from this library.\n-LIBIO_INCLUDE=\n-\n-# We have those in libc.a.\n-IO_OBJECTS=iogetc.o ioputc.o iofeof.o ioferror.o \\\n-\tfiledoalloc.o fileops.o genops.o iofclose.o \\\n-\tiovsprintf.o iovsscanf.o strops.o iogetline.o\n-STDIO_WRAP_OBJECTS=\n-OSPRIM_OBJECTS=\n-STDIO_OBJECTS=\n-\n-# We have the rest in /usr/include.\n-USER_INCLUDES=PlotFile.h SFile.h builtinbuf.h editbuf.h fstream.h \\\n-\tindstream.h iomanip.h iostream.h istream.h ostream.h \\\n-\tparsestream.h pfstream.h procbuf.h stdiostream.h stream.h \\\n-\tstreambuf.h strfile.h strstream.h libio.h\n-\n-# A bad kludge\n-MT_CFLAGS=-D_G_HAVE_MMAP -D_G_STDIO_USES_LIBIO -D_G_HAVE_WEAK_SYMBOL"}, {"sha": "71e79167658b5f2935949944aba2352fbd8d3307", "filename": "libio/config/mn10200.mt", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Fmn10200.mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Fmn10200.mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Fmn10200.mt?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,3 +0,0 @@\n-# Flags to pass to gen-params when building _G_config.h.\n-# For example: G_CONFIG_ARGS = size_t=\"unsigned long\"\n-G_CONFIG_ARGS = NO_USE_DTOA=1 USE_INT32_FLAGS=1"}, {"sha": "93199398f35baaf00ca4269b47bdbd616de6a7e4", "filename": "libio/config/mpeix.mt", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Fmpeix.mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Fmpeix.mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Fmpeix.mt?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,20 +0,0 @@\n-# Flags to pass to gen-params when building _G_config.h. \n-# For example: G_CONFIG_ARGS = size_t=\"unsigned long\" \n-G_CONFIG_ARGS = DOLLAR_IN_LABEL=1 \n-\n-# \n-# gen-params tries to determine whether or not printf_fp exists by\n-# simply compiling a test program. Since MPE is by definition a\n-# shared runtime environment, this won't work unless the resulting\n-# program is run. Simply run _G_config.h through a sed script to\n-# update the values accordingly. \n-# \n-_G_CONFIG_H = stmp-Gconfig\n-\n-stmp-Gconfig: _G_config.h \n-      sed -e \"s/_G_HAVE_PRINTF_FP 1/_G_HAVE_PRINTF_FP 0/\" \\ \n-          -e \"s/_G_HAVE_LONG_DOUBLE_IO 1/_G_HAVE_LONG_DOUBLE_IO 0/\" \\\n-          <_G_config.h > tmp-config.h \n-      mv -f tmp-config.h _G_config.h \n-      touch stmp-Gconfig \n-      $(MAKE) $(FLAGS_TO_PASS) _G_CONFIG_H=_G_config.h all "}, {"sha": "5848851be8ac4da2e148290e9995237f79e9d0af", "filename": "libio/config/mtsafe.mt", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Fmtsafe.mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Fmtsafe.mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Fmtsafe.mt?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,2 +0,0 @@\n-# tell we want the mt-safe version\n-MT_CFLAGS = -D_IO_MTSAFE_IO"}, {"sha": "339a865717c032aaa4f018ccd1d1ad18b7d189b6", "filename": "libio/config/netware.mt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Fnetware.mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Fnetware.mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Fnetware.mt?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,16 +0,0 @@\n-IMPDIR=\t$(srcdir)/config/netware\n-\n-PRELUDE=\tprelude.o\n-\n-iostream.def:\tMakefile\n-\t-rm -f iostream.def\n-\techo \"description \\\"libiostream\\\"\" >> iostream.def\n-\techo \"screenname \\\"NONE\\\"\" >> iostream.def\n-\techo \"version `echo $(VERSION) | sed 's|\\.|,|g'`\" >> iostream.def\n-\techo \"export @$(IMPDIR)/iostream.imp\" >> iostream.def\n-\n-iostream.O:\t$(PRELUDE) $(LIBIOSTREAM_OBJECTS)\n-\t$(CC) -Xlinker -Ur -o $@ $(PRELUDE) $(LIBIOSTREAM_OBJECTS)\n-\n-iostream.nlm:\tiostream.def iostream.O $(IMPDIR)/iostream.imp\n-\t$(NLMCONV) -l $(LD) -T iostream.def iostream.O iostream.nlm"}, {"sha": "087e309d66d32b4187a734b179fc3941afec8c22", "filename": "libio/config/vxworks.mt", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Fvxworks.mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfig%2Fvxworks.mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Fvxworks.mt?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1 +0,0 @@\n-G_CONFIG_ARGS = HAVE_PRINTF_FP=0 HAVE_LONG_DOUBLE_IO=0"}, {"sha": "2a14a926d39d3ad96cec211d7a7633a58c2fbfa9", "filename": "libio/configure.in", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfigure.in?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,208 +0,0 @@\n-# This file is a shell script fragment that supplies the information\n-# necessary for a configure script to process the program in\n-# this directory.  For more information, look at ../configure.\n-\n-# If the language specific compiler does not exist, but the \"gcc\" directory \n-# does, we do not build anything. Note, $r is set by the top-level Makefile.\n-# Note that when we look for the compiler, we search both with and without\n-# extension to handle cross and canadian cross builds. \n-# Note that if $norecursion is set we're being called from config.status,\n-# so don't check for the compiler; we might be doing a make clean.\n-compiler_name=cc1plus\n-rm -f skip-this-dir\n-if test -n \"$r\" && [ -z \"$norecursion\" ] ; then\n-  if test -d \"$r\"/gcc; then\n-    if test -f \"$r\"/gcc/$compiler_name \\\n-       || test -f \"$r\"/gcc/$compiler_name.exe; then\n-      true\n-    else\n-      echo \"rm -f multilib.out\" > skip-this-dir\n-    fi\n-  fi\n-fi\n-\n-if [ \"${srcdir}\" = \".\" ] ; then\n-  if [ \"${with_target_subdir}\" != \".\" ] ; then\n-    topsrcdir=${with_multisrctop}../..\n-  else\n-    topsrcdir=${with_multisrctop}..\n-  fi\n-else\n-  topsrcdir=${srcdir}/..\n-fi\n-\n-if [ -d ${topsrcdir}/gcc ] ; then\n-  configdirs=\"tests dbz stdio testsuite\"\n-else\n-  configdirs=\"tests dbz stdio\"\n-fi\n-srctrigger=libioP.h\n-srcname=\"input/output library\"\n-package_makefile_frag=Make.pack\n-package_makefile_rules_frag=Make.pack.r\n-\n-# per-host:\n-\n-# per-target:\n-\n-echo \"# Warning: this fragment is automatically generated\" > temp.mt\n-frags=\n-case x$enable_threads in\n-\txno) ;;\n-\t*)   mtsafe=mtsafe.mt ;;\n-esac\n-\n-case \"${target}\" in\n-  *-mpeix*)      frags=\"mpeix.mt\" ;;\n-  *-hpux*)       frags=hpux.mt ;;\n-  alpha*-*-linux*libc1)\n-\t\t frags=\"linux.mt linuxaxp1.mt $mtsafe\" ;;\n-  powerpc*-*-linux*libc1)\n-\t\t frags=\"linux.mt linuxaxp1.mt $mtsafe\" ;;\n-  *-linux*libc1)\n-\t\t frags=linuxlibc1.mt ;;\n-  *-linux*)\n-\t\t frags=\"linux.mt $mtsafe\" ;;\n-  *-isc*)        frags=isc.mt ;;\n-  *-netware*)    frags=netware.mt ;;\n-  *-dgux*)\t frags=dgux.mt ;;\n-  *vxworks*)     frags=\"vxworks.mt\" ;;\n-  *-beos*)\t frags=\"beos.mt $mtsafe\" ;;\n-  *)             frags=${target_cpu}.mt ;;\n-esac\n-\n-case \"${enable_shared}\" in\n-  yes) shared=yes ;;\n-  no) shared=no ;;\n-  *libio*) shared=yes ;;\n-  *) shared=no ;;\n-esac\n-\n-if [ \"${shared}\" = \"yes\" ]; then\n-  case \"${target}\" in\n-    alpha*-*-linux*)\tfrags=\"${frags} ../../config/mh-elfalphapic\" ;;\n-    arm*-*-*)\t\tfrags=\"${frags} ../../config/mh-armpic\" ;;\n-    hppa*-*-*)\t\tfrags=\"${frags} ../../config/mh-papic\" ;;\n-    i[3456]86-*-*)\tfrags=\"${frags} ../../config/mh-x86pic\" ;;\n-    powerpc*-*-aix*)\t;;\n-    powerpc*-*-*)\tfrags=\"${frags} ../../config/mh-ppcpic\" ;;\n-    sparc*-*-*)\t\tfrags=\"${frags} ../../config/mh-sparcpic\" ;;\n-    *-*-*)\t\tfrags=\"${frags} ../../config/mh-${target_cpu}pic\" ;;\n-  esac\n-fi\n-\n-# Take care of header file lossage.\n-case \"${target}\" in\n-  alpha*-*-linux*libc1)\n-    # For some reason stdio-lock.h is not installed on Red Hat systems.\n-    # Further, libc-lock.h needs to define the pthreads stuff weak, and\n-    # fails to do this for other than _LIBC.  Install our own versions\n-    # of these files.\n-    cp ${srcdir}/config/linuxaxp1-libc-lock.h libc-lock.h\n-    cp ${srcdir}/config/linuxaxp1-stdio-lock.h stdio-lock.h\n-    ;;\n-  powerpc*-*-linux*libc1)\n-    # For some reason stdio-lock.h is not installed on Red Hat systems.\n-    # Further, libc-lock.h needs to define the pthreads stuff weak, and\n-    # fails to do this for other than _LIBC.  Install our own versions\n-    # of these files.\n-    cp ${srcdir}/config/linuxaxp1-libc-lock.h libc-lock.h\n-    cp ${srcdir}/config/linuxaxp1-stdio-lock.h stdio-lock.h\n-    ;;\n-  *-linux*)\n-    # We have a correct libc-lock.h in glibc 2.1 but not all glibc 2.0.\n-    # Create a wrapper if necessary.\n-    (echo \"#include <bits/libc-lock.h>\" | ${CC-cc} -E -) >/dev/null 2>&1 ||\n-      {\n-\techo \" #include_next <libc-lock.h>\" > libc-lock.h\n-\techo 'asm (\".weak _pthread_cleanup_pop_restore\");' >> libc-lock.h\n-\techo 'asm (\".weak _pthread_cleanup_push_defer\");' >> libc-lock.h\n-\n-      }\n-    ;;\n-esac\n-\n-for frag in ${frags}; do\n-  case ${frag} in\n-    ../* )\n-      if [ ${srcdir} = . ]; then\n-\t[ -n \"${with_target_subdir}\" ] && frag=../${frag}\n-\t[ -n \"${with_multisrctop}\" ] && frag=${with_multisrctop}${frag}\n-      fi\n-      ;;\n-  esac\n-  frag=${srcdir}/config/$frag\n-  if [ -f ${frag} ]; then\n-    echo \"Appending ${frag} to target-mkfrag\"\n-    echo \"# Following fragment copied from ${frag}\" >> temp.mt\n-    cat ${frag} >> temp.mt\n-  fi\n-done\n-\n-target_makefile_frag=target-mkfrag\n-${moveifchange} temp.mt target-mkfrag\n-\n-LIBDIR=yes\n-TO_TOPDIR=../\n-ALL='$(_G_CONFIG_H) libio.a libiostream.a iostream.list'\n-case \"${target}\" in\n-  *-*-cygwin*)\n-    XCINCLUDES='-I. -I$(srcdir) -I$(srcdir)/../winsup/include'\n-    XCXXINCLUDES='-I. -I$(srcdir) -I$(srcdir)/../winsup/include'\n-    ;;\n-  *)\n-    XCINCLUDES='-I. -I$(srcdir)'\n-    XCXXINCLUDES='-I. -I$(srcdir)'\n-    ;;\n-esac\n-MOSTLYCLEAN='*.o pic stamp-picdir core iostream.list'\n-DISTCLEAN='config.status Makefile *~ Make.pack target-mkfrag multilib.out'\n-CLEAN='_G_config.h *.a'\n-INFO_FILES=iostream\n-if [ -n \"${with_cross_host}\" -a -d ${topsrcdir}/gcc ]; then\n-    CHECK_SUBDIRS=testsuite\n-fi\n-(. ${srcdir}/config.shared) >${package_makefile_frag} 2>${package_makefile_rules_frag}\n-\n-# post-target:\n-\n-# If cross-compiling, we install in $(tooldir)/lib or in $(libsubdir)\n-# depending on --enable-version-specific-runtime-libs.\n-if [ -n \"${with_cross_host}\" ] ; then\n-    rm -f Makefile.tem\n-    sed \\\n-        -e 's|\\(^[ \t]*INSTALLDIR[ \t]*=[ \t]*\\)\\$(libdir)|\\1$(tooldir)/lib|' \\\n-\tMakefile >Makefile.tem\n-    mv -f Makefile.tem Makefile\n-fi\n-\n-. ${topsrcdir}/config-ml.in\n-\n-gxx_include_dir=\n-# Specify the g++ header file directory\n-# Check whether --with-gxx-include-dir or --without-gxx-include-dir was given.\n-if test \"${with_gxx_include_dir+set}\" = set; then\n-  withval=\"$with_gxx_include_dir\"\n-  case \"${withval}\" in\n-    yes)\n-      echo \"configure.in: error: bad value ${withval} given for g++ include directory\" 1>&2\n-      exit 1\n-      ;;\n-    no)\t;;\n-    *)\tgxx_include_dir=$with_gxx_include_dir ;;\n-  esac\n-fi\n-\n-if test x${gxx_include_dir} = x; then\n-  if test x${enable_version_specific_runtime_libs} = xyes; then\n-    gxx_include_dir='${libsubdir}/include/g++'\n-  else\n-    . ${topsrcdir}/config.if\n-    gxx_include_dir='${prefix}/include/g++'-${libstdcxx_interface}\n-  fi\n-fi\n-\n-rm -f Makefile.tem\n-sed -e \"s%^gxx_include_dir[ \t]*=.*$%gxx_include_dir=${gxx_include_dir}%\" \\\n-       Makefile >Makefile.tem\n-mv -f Makefile.tem Makefile"}, {"sha": "0fd956414148225d61ce7d99732ee4ddb794a7f8", "filename": "libio/dbz/Makefile.in", "status": "removed", "additions": 0, "deletions": 218, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2FMakefile.in?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,218 +0,0 @@\n-srcdir = .\n-CFLAGS = -g\n-C_FLAGS = $(CFLAGS) -I$(srcdir) -I.. -I$(srcdir)/.. -DDBZ_FINISH='_IO_flush_all()'\n-CC = `if [ -f ../../../gcc/gcc ] ; \\\n-\tthen echo ../../../gcc/gcc -B../../../gcc/ ; \\\n-\telse echo gcc ; fi`\n-LIBIO = ../libio.a ../../libiberty/libiberty.a\n-LIBS = $(LIBIO)\n-# LIBS = ../libcnews.a\n-DBM =\n-RFC = -DHAVERFCIZE\n-CASE = case.o\n-DEBUG = -DDBZDEBUG\n-LINTFLAGS = -h $(DEBUG) $(RFC) -I$(srcdir)\n-LDFLAGS =\n-# =()<NEWSBIN = @<NEWSBIN>@>()=\n-NEWSBIN = /usr/lib/newsbin\n-# workaround for System V make bug\n-SHELL = /bin/sh\n-\n-# database sizes for performance tests, regression, and regression prime-find\n-TSIZE=12007\n-RSIZE=4019\n-RPSIZE=2679\n-\n-#### host and target dependent Makefile fragments come in here.\n-##\n-\n-# history files for regression and performance tests\n-RHIST=hist3.3\n-R2HIST=hist10\n-THIST=hist13\n-\n-#all:\tdbz\n-all:\n-install:\n-install-info:\n-info:\n-\n-check: r\n-\t$(MAKE) rclean\n-\n-bininstall:\tdbz\n-\tcp dbz $(NEWSBIN)\n-\n-cmp:\tdbz\n-\tcmp dbz $(NEWSBIN)/dbz\n-\n-newsinstall:\n-\t: nothing\n-\n-u:\tdbz.o\n-\tar ruv ../libcnews.a dbz.o\n-\tcmp dbz.h ../h/dbz.h\n-\n-t:\ttdbz fake\n-\n-lint:\n-\tlint $(LINTFLAGS) dbzmain.c dbz.c\n-\n-.c.o:\n-\t$(CC) $(C_FLAGS) -c $<\n-\n-rdbz.o:\trdbz.c\n-\t$(CC) $(C_FLAGS) $(DEBUG) -DDEFSIZE=$(RSIZE) -c rdbz.c\n-\n-rdbzmain.o: rdbzmain.c\n-\t$(CC) $(C_FLAGS) $(RFC) -c rdbzmain.c\n-\n-tdbz.o:\t$(srcdir)/dbz.c\n-\tcp $(srcdir)/dbz.c tdbz.c\n-\t$(CC) $(C_FLAGS) -DDEFSIZE=$(TSIZE) -c tdbz.c\n-\trm tdbz.c\n-\n-dbz:\tdbzmain.o $(CASE)\n-\t$(CC) $(LDFLAGS) dbzmain.o $(CASE) $(PRE) $(DBM) $(LIBS) $(POST) -o $@\n-\n-tdbz:\tdbzmain.o tdbz.o $(CASE)\n-\t$(CC) $(LDFLAGS) dbzmain.o tdbz.o $(CASE) $(PRE) $(LIBS) $(POST) -o $@\n-\n-rdbz:\trdbzmain.o rdbz.o $(CASE)\n-\t$(CC) $(LDFLAGS) rdbzmain.o rdbz.o $(CASE) $(PRE) $(LIBS) $(POST) -o $@\n-\n-fake:\tfake.o random.o\n-\t$(CC) $(LDFLAGS) fake.o random.o $(PRE) $(LIBS) $(POST) -o $@\n-\n-byteflip:\tbyteflip.o\n-\t$(CC) $(LDFLAGS) byteflip.o $(PRE) $(LIBS) $(POST) -o $@\n-\n-hist10:\tfake\n-\t./fake -t -e 75 10000 >$@\n-\n-hist3.3:\tfake\n-\t./fake -t -e 75 3300 >$@\n-\n-hist13:\tfake\n-\t./fake -t -e 75 13000 >$@\n-\n-r:\t$(srcdir)/getmap $(srcdir)/revbytes $(srcdir)/altbytes stamp-r8\n-\t: success!\n-\n-stamp-r0:\n-\t: 'WARNING:  creates about 2MB of debris; do \"make rclean\" afterward'\n-\trm -f dbase dbase[23] dbase.* dbase[23].*\n-\ttest ! -d xx || rmdir xx\n-\t@touch stamp-r0\n-\n-stamp-r1: $(RHIST) $(R2HIST) stamp-r0\n-\t: crude check of synthetic history file\n-\t( sed 25q $(RHIST) ; tail -25 $(RHIST) ) >histjunk\n-\tcmp histjunk $(srcdir)/firstlast25\n-\trm histjunk\n-\t@touch stamp-r1\n-\n-r2a: rdbz stamp-r1\n-\t: basic tests, exercising as many options as possible\n-\tcp $(RHIST) dbase\n-\tmkdir xx\n-\tchmod -w xx\n-\t./rdbz -E 1000 -0 -M -i -S -u -U -C xx dbase\n-\trmdir xx\n-\tsed '/>\t0/d' $(RHIST) >dbase.used\n-\ttest \"`cat dbase.used | wc -l`\" -eq \"`sed -n '2s/ .*//p' dbase.dir`\" ;\n-\n-stamp-r2: r2a\n-\tcp $(RHIST) dbase2\n-\t./rdbz -E 1000 -0 -p $(RPSIZE) -t '\t' dbase2\n-\tcmp $(RHIST) dbase\n-\tcmp dbase dbase2\n-\tcmp dbase.dir dbase2.dir\n-\tcmp dbase.pag dbase2.pag\n-\t./rdbz -E 1000 -0 -c dbase\n-\t./rdbz -E 1000 -0 -c -i -q -M -U dbase\n-\t@touch stamp-r2\n-\n-stamp-r3: stamp-r2\n-\t: build a database and then add to it\n-\tsed 1000q $(RHIST) >dbase2\n-\tsed 1,1000d $(RHIST) >dbase2.add\n-\t./rdbz -E 1000 -0 dbase2\n-\t./rdbz -E 1000 -0 -a dbase2 dbase2.add\n-\tcmp dbase dbase2\n-\tcmp dbase.dir dbase2.dir\n-\tcmp dbase.pag dbase2.pag\n-\t@touch stamp-r3\n-\n-stamp-r4: stamp-r3\n-\t: build based on existing one, test extraction and readonly files\n-\t./rdbz -E 1000 -0 -f dbase dbase2\n-\ttest \"`cat dbase.used | wc -l`\" -eq \"`awk 'NR==2{print $$1}' dbase2.dir`\" ;\n-\ttest \"`cat dbase.used | wc -l`\" -eq \"`awk 'NR==2{print $$2}' dbase2.dir`\" ;\n-\tchmod -w dbase2.dir dbase2.pag\n-\t./rdbz -E 1000 -x dbase2 dbase >dbase.temp\n-\tcmp dbase.used dbase.temp\n-\t@touch stamp-r4\n-\n-stamp-r5: stamp-r4\n-\t: try some small case perversions\n-\tsed 's/\\(@[^ \t]*\\)A/\\1a/' dbase >dbase.ick\n-\t./rdbz -E 1000 -x dbase2 dbase.ick >dbase.temp\n-\tcmp dbase.used dbase.temp\n-\tsed -n 's/A\\([^ \t]*@\\)/a\\1/p' dbase >dbase.ick\n-\t./rdbz -x dbase2 dbase.ick >dbase.temp\n-\ttest ! -s dbase.temp ;\n-\trm -f dbase2.dir dbase2.pag\n-\t@touch stamp-r5\n-\n-stamp-r6: stamp-r5\n-\t: try it without tags, case-insensitive, with case perversions\n-\t./rdbz -E 1000 -0 -p '0 b 1' dbase2\n-\ttr 'ABCDEFGHIJKLMnopqrstuvwxyz' 'abcdefghijklmNOPQRSTUVWXYZ' <dbase2 >dbase.ick\n-\t./rdbz -E 1000 -x dbase2 dbase.ick >dbase.temp\n-\tcmp dbase.used dbase.temp\n-\trm -f dbase.temp dbase.ick\n-\t@touch stamp-r6\n-\n-stamp-r7: byteflip stamp-r6\n-\t: test various perversions of byte ordering\n-\tawk -f $(srcdir)/revbytes dbase.dir >dbase2.dir\n-\t./byteflip `$(srcdir)/getmap dbase.dir` `$(srcdir)/getmap dbase2.dir` <dbase.pag >dbase2.pag\n-\tcp dbase dbase2\n-\t./rdbz -E 1000 -0 -c dbase2\n-\tawk -f $(srcdir)/altbytes dbase.dir >dbase2.dir\n-\tdd conv=swab <dbase.pag >dbase2.pag\n-\t./rdbz -E 1000 -0 -c dbase2\n-\tcp dbase2 dbase3\n-\t./rdbz -E 1000 -0 -f dbase2 dbase3\n-\t./rdbz -E 1000 -0 -c dbase3\n-\ttest \" `$(srcdir)/getmap dbase2.dir`\" = \" `$(srcdir)/getmap dbase3.dir`\" ;\n-\t@touch stamp-r7\n-\n-stamp-r8: stamp-r7\n-\t: test massive overflow, throw in case sensitivity and tag mask\n-\tcp $(R2HIST) dbase\n-\t./rdbz -E 1000 -0 -p '0 0 7ffc0000' dbase\n-\t./rdbz -E 1000 -0 -cq dbase\n-\tsed 100q dbase | egrep '[aA].*\t' | tr aA Aa >dbase.ick\n-\t./rdbz -x dbase dbase.ick >dbase.temp\n-\ttest ! -s dbase.temp ;\n-\t@touch stamp-r8\n-\n-rclean:\n-\trm -f dbase dbase[23] dbase.* dbase[23].* fake fake.o random.o\n-\trm -f rdbz rdbz.o rdbzmain.o $(RHIST) $(R2HIST) byteflip byteflip.o\n-\trm -f histjunk core stamp-r? *~\n-\ttest ! -d xx || rmdir xx\n-\n-mostlyclean: rclean\n-\trm -f *.o [a-z]dbz [a-z][a-z]dbz junk* PostScript.out\n-\trm -f hist* dbase* *.bak mon.out gmon.out core dbm.h\n-\n-clean:\tmostlyclean\n-\trm -f dbz\n-\n-distclean: clean\n-\trm -rf Makefile config.status rdbz.c rdbzmain.c\n-\n-maintainer-clean realclean: distclean"}, {"sha": "e7fa8765ad5c2838374537183cd26149b1dbf83a", "filename": "libio/dbz/README", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2FREADME?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,25 +0,0 @@\n-The dbz package was \"liberated\" from C News.\n-It is included with the GNU libio because it provides\n-a fairly good work-out for a stdio implementation.\n-The Makefile.in, configure.in, and stdio.h have been\n-set up to test libio.\n-\n-------\n-\n-This is the new, improved, lemon-freshened :-) dbz.\n-\n-Just \"make\" will get you dbz.o and the dbz program.  \"make r\" runs an\n-extensive set of regression tests; most of the mysterious oddments lying\n-around here are to do with that.  \"make rclean\" cleans up after \"make r\".\n-\n-You probably want to inspect the #ifdef list early in dbz.c before\n-compiling, although the defaults should work all right on most systems.\n-\n-If you are not building this as part of C News, you will need to change\n-the -I option in FLAGS in the Makefile to \"-I.\", and delete the DBMLIBS\n-and RFC lines entirely.  That will break some of the regression tests;\n-at some point I'll fix this.\n-\n-If you are using this independently from C News, you probably still want\n-to look through ../notebook/problems, as some of the portability problems\n-described in there can affect dbz."}, {"sha": "26cc9fb9e023e3876ae8ac036f90bbf7059c9b3a", "filename": "libio/dbz/altbytes", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Faltbytes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Faltbytes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Faltbytes?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,7 +0,0 @@\n-NR == 1 {\n-\tprintf \"%s %s %s %s %s %s %s %s %s\", $1, $2, $3, $4, $5, $6, $7, $8, $9\n-\tfor (i = 10; i <= NF; i += 2)\n-\t\tprintf \" %s %s\", $(i+1), $i\n-\tprintf \"\\n\"\n-}\n-NR > 1 { print }"}, {"sha": "d54c6591fa18afb75e3114bf5bd275e9aae69298", "filename": "libio/dbz/byteflip.c", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fbyteflip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fbyteflip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Fbyteflip.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,38 +0,0 @@\n-#include <stdio.h>\n-\n-#define\tMAXWORD\t32\n-\n-int\n-main(argc, argv)\n-int argc;\n-char *argv[];\n-{\n-\tregister int len;\n-\tint inmap[MAXWORD];\n-\tint outmap[MAXWORD];\n-\tchar in[MAXWORD];\n-\tchar out[MAXWORD];\n-\tregister int i;\n-\tregister int a;\n-\n-\ta = 1;\n-\tlen = atoi(argv[a++]);\n-\tif (len > MAXWORD)\n-\t\tabort();\t/* kind of drastic... */\n-\tfor (i = 0; i < len; i++)\n-\t\tinmap[i] = atoi(argv[a++]);\n-\tif (atoi(argv[a++]) != len)\n-\t\tabort();\n-\tfor (i = 0; i < len; i++)\n-\t\toutmap[i] = atoi(argv[a++]);\n-\n-\twhile (fread(in, 1, len, stdin) == len) {\n-\t\tfor (i = 0; i < len; i++)\n-\t\t\tout[outmap[i]] = in[inmap[i]];\n-\t\tfwrite(out, 1, len, stdout);\n-\t}\n-#ifdef DBZ_FINISH\n-\tDBZ_FINISH;\n-#endif\n-\texit(0);\n-}"}, {"sha": "87b741ff54a7f61424246af06608b2078e48b477", "filename": "libio/dbz/case.c", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fcase.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fcase.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Fcase.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,129 +0,0 @@\n-/*\n- * case-mapping stuff\n- *\n- * We exploit the fact that we are dealing only with headers here, and\n- * headers are limited to the ASCII characters by RFC822.  It is barely\n- * possible that we might be dealing with a translation into another\n- * character set, but in particular it's very unlikely for a header\n- * character to be outside -128..255.\n- *\n- * Life would be a whole lot simpler if tolower() could safely and portably\n- * be applied to any char.\n- */\n-#include <stdio.h>\n-#include \"string.h\"\n-#include \"case.h\"\n-\n-/* note that case.h knows the value of OFFSET */\n-#define\tOFFSET\t128\t\t/* avoid trouble with negative chars */\n-#define\tMAPSIZE\t(256+OFFSET)\n-char casemap[MAPSIZE];\t\t/* relies on init to '\\0' */\n-static int primed = 0;\t\t/* has casemap been set up? */\n-\n-/*\n- - prime - set up case-mapping stuff\n- */\n-static void\n-prime()\n-{\n-\tregister char *lp;\n-\tregister char *up;\n-\tregister int c;\n-\tregister int i;\n-\tstatic char lower[] = \"abcdefghijklmnopqrstuvwxyz\";\n-\tstatic char upper[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n-\n-\tfor (lp = lower, up = upper; *lp != '\\0'; lp++, up++) {\n-\t\tc = *lp;\n-\t\tcasemap[c+OFFSET] = c;\n-\t\tcasemap[*up+OFFSET] = c;\n-\t}\n-\tfor (i = 0; i < MAPSIZE; i++)\n-\t\tif (casemap[i] == '\\0')\n-\t\t\tcasemap[i] = (char)(i-OFFSET);\n-\tprimed = 1;\n-}\n-\n-/*\n- - cistrncmp - case-independent strncmp\n- */\n-int\t\t\t\t/* < == > 0 */\n-cistrncmp(s1, s2, len)\n-char *s1;\n-char *s2;\n-int len;\n-{\n-\tregister char *p1;\n-\tregister char *p2;\n-\tregister int n;\n-\n-\tif (!primed)\n-\t\tprime();\n-\n-\tp1 = s1;\n-\tp2 = s2;\n-\tn = len;\n-\twhile (--n >= 0 && *p1 != '\\0' && TOLOW(*p1) == TOLOW(*p2)) {\n-\t\tp1++;\n-\t\tp2++;\n-\t}\n-\tif (n < 0)\n-\t\treturn(0);\n-\n-\t/*\n-\t * The following case analysis is necessary so that characters\n-\t * which look negative collate low against normal characters but\n-\t * high against the end-of-string NUL.\n-\t */\n-\tif (*p1 == '\\0' && *p2 == '\\0')\n-\t\treturn(0);\n-\telse if (*p1 == '\\0')\n-\t\treturn(-1);\n-\telse if (*p2 == '\\0')\n-\t\treturn(1);\n-\telse\n-\t\treturn(TOLOW(*p1) - TOLOW(*p2));\n-}\n-\n-/*\n- - rfc822ize - do the bizarre case conversion needed for rfc822 message-ids\n- *\n- * Actually, this is not quite complete.  Absolute, total, full RFC822\n- * compliance requires a horrible parsing job, because of the arcane\n- * quoting conventions -- abc\"def\"ghi is not equivalent to abc\"DEF\"ghi,\n- * for example.  There are three or four things that might occur in the\n- * domain part of a message-id that are case-sensitive.  They don't seem\n- * to ever occur in real news, thank Cthulhu.  (What?  You were expecting\n- * a merciful and forgiving deity to be invoked in connection with RFC822?\n- * Forget it; none of them would come near it.)\n- */\n-char *\t\t\t\t/* returns the argument */\n-rfc822ize(s)\n-char *s;\n-{\n-\tregister char *p;\n-\tstatic char post[] = \"postmaster\";\n-\tstatic int postlen = sizeof(post)-1;\n-\n-\tif (!primed)\n-\t\tprime();\n-\n-\tp = strrchr(s, '@');\n-\tif (p == NULL)\t\t\t/* no local/domain split */\n-\t\tp = \"\";\t\t\t/* assume all local */\n-\telse if\t(p - (s+1) == postlen && CISTREQN(s+1, post, postlen)) {\n-\t\t/* crazy special case -- \"postmaster\" is case-insensitive */\n-\t\tp = s;\n-\t}\n-#ifdef NONSTANDARD\n-#ifdef RFCVIOLATION\n-#ifdef B_2_11_MISTAKE\n-\tp = s;\t\t\t\t/* all case-insensitive */\n-#endif\n-#endif\n-#endif\n-\tfor (; *p != '\\0'; p++)\n-\t\t*p = TOLOW(*p);\n-\n-\treturn(s);\n-}"}, {"sha": "d5ef69615506fddb135822481fdc68a117e39de4", "filename": "libio/dbz/case.h", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fcase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fcase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Fcase.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,12 +0,0 @@\n-extern int cistrncmp();\n-extern char *rfc822ize();\n-\n-extern char casemap[];\n-\n-/* must call cistrncmp before invoking TOLOW... */\n-#define\tTOLOW(c)\t(casemap[(c)+128])\t/* see case.c for why 128 */\n-\n-/* ...but the use of it in CISTREQN is safe without the preliminary call (!) */\n-/* CISTREQN is an optimised case-insensitive strncmp(a,b,n)==0; n > 0 */\n-#define CISTREQN(a, b, n) \\\n-\t(TOLOW((a)[0]) == TOLOW((b)[0]) && cistrncmp(a, b, n) == 0)"}, {"sha": "4cb9b57ce0fa88d9c51bc9a3c1b491efcd29068c", "filename": "libio/dbz/configure.in", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Fconfigure.in?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,17 +0,0 @@\n-# This file is a shell script fragment that supplies the information\n-# necessary for a configure script to process the program in\n-# this directory.  For more information, look at ../configure.\n-\n-configdirs=\n-srctrigger=dbzmain.c\n-srcname=\"libio dbz test\"\n-\n-# per-host:\n-\n-# per-target:\n-\n-files=\"dbz.c dbzmain.c\"\n-links=\"rdbz.c rdbzmain.c\"\n-\n-# post-target:\n-"}, {"sha": "d2fff17af9852628355ad167052cff23abd9c191", "filename": "libio/dbz/dbz.1", "status": "removed", "additions": 0, "deletions": 221, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fdbz.1", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fdbz.1", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Fdbz.1?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,221 +0,0 @@\n-.TH DBZ 1 \"11 Feb 1992\"\n-.BY \"C News\"\n-.SH NAME\n-dbz \\- operate on dbz databases of text\n-.SH SYNOPSIS\n-.B dbz\n-[\n-.BR \\- { axmc }\n-] [\n-.B \\-t\n-c\n-] [\n-.B \\-l\n-length\n-] [\n-.BR \\- { qiue }\n-] [\n-.B \\-f\n-old\n-] [\n-.B \\-p\n-parms\n-] database file ...\n-.SH DESCRIPTION\n-.I Dbz\n-is a shell-level interface to the\n-.IR dbz (3z)\n-database routines for indexed access to a text file.\n-.PP\n-The\n-.I database\n-file must be a text file,\n-one line per database record,\n-with the key the first field on the line.\n-The\n-.B \\-t\n-option sets the field-separator character; the default is tab.\n-Setting the separator character to NUL (with\n-.BR \"\\-t\\ ''\" )\n-makes the whole line the key.\n-Lines must not exceed 1023 bytes in length including the newline;\n-this limit can be increased with the\n-.B \\-l\n-option.\n-The limitations and restrictions of\n-.IR dbz (3z)\n-must also be observed;\n-in particular, it remains the user's responsibility to ensure that\n-no attempt is made to store two entries (whether identical or not)\n-with the same key.\n-.PP\n-In the absence of options,\n-.I dbz\n-creates a\n-.IR dbz (3z)\n-index for the database;\n-the index comprises files\n-.IB database .pag\n-and\n-.IB database .dir\n-in the same directory.\n-Any previous index is silently overwritten.\n-The\n-.BR \\-a ,\n-.BR \\-x ,\n-.BR \\-m ,\n-and\n-.B \\-c\n-options specify other operations.\n-.PP\n-With\n-.BR \\-a ,\n-.I dbz\n-appends lines from the\n-.IR file (s)\n-(standard input if none)\n-to the database, updating both the\n-text file and the indexes.\n-.PP\n-With\n-.BR \\-x ,\n-.I dbz\n-reads keys from the\n-.IR file (s)\n-(standard input if none)\n-and prints (on standard output) the corresponding lines, if any,\n-from the database.\n-The input is in the form of database lines, although only the keys are\n-significant.\n-The\n-.B \\-q\n-option makes\n-.B \\-x\n-print the input lines whose keys are found instead of the database\n-lines; this is somewhat faster.\n-.PP\n-With\n-.BR \\-m ,\n-operation is the same as for\n-.B \\-x\n-except that the keys which are \\fInot\\fR present in the database are printed.\n-.PP\n-With\n-.BR \\-c ,\n-.I dbz\n-checks the database for internal consistency.\n-The\n-.B \\-q\n-option causes this check to be done more quickly but less thoroughly\n-(each key is looked up in the index, but no check is made to be sure\n-that the index entry points to the right place).\n-.PP\n-The\n-.B \\-i\n-option suppresses the use of\n-.IR dbz (3z)'s\n-.I incore\n-facility.\n-This makes accesses slower, but keeps the files current\n-during updating\n-and reduces\n-startup/shutdown overhead.\n-.PP\n-Normally,\n-.I dbz\n-checks whether a key is already in the database before adding it.\n-The\n-.B \\-u\n-option suppresses this check, speeding things up at the expense of safety.\n-.PP\n-A new index is normally created with default size,\n-case mapping, and tagging.\n-The default size is right for 90-100,000 records.\n-The default case mapping is right for RFC822 message-ids.\n-See\n-.IR dbz (3z)\n-for what tagging is about.\n-(Note, these defaults can be changed when\n-.IR dbz (3z)\n-is installed.)\n-.PP\n-If the\n-.B \\-f\n-option is given,\n-size, case mapping, and tagging\n-are instead initialized based on the\n-database\n-.IR old .\n-This is mostly useful when\n-creating a new generation of an existing database.\n-(See the description of\n-.I dbzagain\n-in\n-.IR dbz (3z)\n-for details.)\n-.PP\n-If the\n-.B \\-p\n-option is given, the\n-.I parms\n-string specifies the size, case mapping, and tagging.\n-If\n-.I parms\n-is a single decimal number,\n-that is taken as the expected number of records\n-in the index, with case mapping and tagging defaulted.\n-Alternatively,\n-.I parms\n-can be three fields\\(ema decimal number, a case-mapping code character, and a\n-hexadecimal tag mask\\(emseparated by white space.\n-The decimal number is, again, the expected number of records;\n-0 means ``use the default''.\n-See\n-.IR dbz (3z)\n-for possible choices of case-mapping code,\n-but in particular,\n-.B 0\n-means ``no case mapping''.\n-See\n-.IR dbz (3z)\n-for details on tag masks;\n-0 means ``use the default''.\n-.PP\n-If the\n-.B \\-e\n-option is given, the decimal number in\n-.B \\-p\n-is taken to be the exact table size, not the expected number of records,\n-and invocation of\n-.I dbzsize\n-(see\n-.IR dbz (3z))\n-to predict a good size for that number of records is suppressed.\n-.PP\n-The\n-.B \\&.pag\n-file is normally about 6 bytes per record (based on the estimate given to\n-.B \\-p\n-or the previous history of the\n-.B \\-f\n-database).\n-The\n-.B \\&.dir\n-file is tiny.\n-.SH SEE ALSO\n-dbz(3z)\n-.SH HISTORY\n-Written at U of Toronto by Henry Spencer, for the C News project.\n-See\n-.IR dbz (3z)\n-for the history of the underlying database routines.\n-.SH BUGS\n-There are a number of undocumented options with obscure effects,\n-meant for debugging and regression testing of\n-.IR dbz (3z).\n-.PP\n-Permissions for the index files probably ought to be taken from those\n-of the base file.\n-.PP\n-The line-length limit is a blemish, alleviated only slightly by\n-.BR \\-l ."}, {"sha": "6df25311c7014b1235585b4cede83aa7b1adb653", "filename": "libio/dbz/dbz.3z", "status": "removed", "additions": 0, "deletions": 547, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fdbz.3z", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fdbz.3z", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Fdbz.3z?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,547 +0,0 @@\n-.TH DBZ 3Z \"3 Feb 1991\"\n-.BY \"C News\"\n-.SH NAME\n-dbminit, fetch, store, dbmclose \\- somewhat dbm-compatible database routines\n-.br\n-dbzfresh, dbzagain, dbzfetch, dbzstore \\- database routines\n-.br\n-dbzsync, dbzsize, dbzincore, dbzcancel, dbzdebug \\- database routines\n-.SH SYNOPSIS\n-.nf\n-.B #include <dbz.h>\n-.PP\n-.B dbminit(base)\n-.B char *base;\n-.PP\n-.B datum\n-.B fetch(key)\n-.B datum key;\n-.PP\n-.B store(key, value)\n-.B datum key;\n-.B datum value;\n-.PP\n-.B dbmclose()\n-.PP\n-.B dbzfresh(base, size, fieldsep, cmap, tagmask)\n-.B char *base;\n-.B long size;\n-.B int fieldsep;\n-.B int cmap;\n-.B long tagmask;\n-.PP\n-.B dbzagain(base, oldbase)\n-.B char *base;\n-.B char *oldbase;\n-.PP\n-.B datum\n-.B dbzfetch(key)\n-.B datum key;\n-.PP\n-.B dbzstore(key, value)\n-.B datum key;\n-.B datum value;\n-.PP\n-.B dbzsync()\n-.PP\n-.B long\n-.B dbzsize(nentries)\n-.B long nentries;\n-.PP\n-.B dbzincore(newvalue)\n-.PP\n-.B dbzcancel()\n-.PP\n-.B dbzdebug(newvalue)\n-.SH DESCRIPTION\n-These functions provide an indexing system for rapid random access to a\n-text file (the\n-.I base \n-.IR file ).\n-Subject to certain constraints, they are call-compatible with\n-.IR dbm (3),\n-although they also provide some extensions.\n-(Note that they are\n-.I not\n-file-compatible with\n-.I dbm\n-or any variant thereof.)\n-.PP\n-In principle,\n-.I dbz\n-stores key-value pairs, where both key and value are arbitrary sequences\n-of bytes, specified to the functions by\n-values of type\n-.IR datum ,\n-typedefed in the header file to be a structure with members\n-.I dptr\n-(a value of type\n-.I char *\n-pointing to the bytes)\n-and\n-.I dsize\n-(a value of type\n-.I int\n-indicating how long the byte sequence is).\n-.PP\n-In practice,\n-.I dbz\n-is more restricted than\n-.IR dbm .\n-A\n-.I dbz\n-database\n-must be an index into a base file,\n-with the database\n-.IR value s\n-being\n-.IR fseek (3)\n-offsets into the base file.\n-Each such\n-.I value\n-must ``point to'' a place in the base file where the corresponding\n-.I key\n-sequence is found.\n-A key can be no longer than\n-.SM DBZMAXKEY\n-(a constant defined in the header file) bytes.\n-No key can be an initial subsequence of another,\n-which in most applications requires that keys be\n-either bracketed or terminated in some way (see the\n-discussion of the\n-.I fieldsep\n-parameter of\n-.IR dbzfresh ,\n-below,\n-for a fine point on terminators).\n-.PP\n-.I Dbminit\n-opens a database,\n-an index into the base file\n-.IR base ,\n-consisting of files\n-.IB base .dir\n-and\n-.IB base .pag\n-which must already exist.\n-(If the database is new, they should be zero-length files.)\n-Subsequent accesses go to that database until\n-.I dbmclose\n-is called to close the database.\n-The base file need not exist at the time of the\n-.IR dbminit ,\n-but it must exist before accesses are attempted.\n-.PP\n-.I Fetch\n-searches the database for the specified\n-.IR key ,\n-returning the corresponding\n-.IR value\n-if any.\n-.I Store\n-stores the\n-.IR key - value\n-pair in the database.\n-.I Store\n-will fail unless the database files are writeable.\n-See below for a complication arising from case mapping.\n-.PP\n-.I Dbzfresh\n-is a variant of\n-.I dbminit\n-for creating a new database with more control over details.\n-Unlike for\n-.IR dbminit ,\n-the database files need not exist:\n-they will be created if necessary,\n-and truncated in any case.\n-.PP\n-.IR Dbzfresh 's\n-.I size\n-parameter specifies the size of the first hash table within the database,\n-in key-value pairs.\n-Performance will be best if\n-.I size\n-is a prime number and\n-the number of key-value pairs stored in the database does not exceed\n-about 2/3 of\n-.IR size .\n-(The\n-.I dbzsize\n-function, given the expected number of key-value pairs,\n-will suggest a database size that meets these criteria.)\n-Assuming that an\n-.I fseek\n-offset is 4 bytes,\n-the\n-.B .pag\n-file will be\n-.RI 4* size\n-bytes\n-(the\n-.B .dir\n-file is tiny and roughly constant in size)\n-until\n-the number of key-value pairs exceeds about 80% of\n-.IR size .\n-(Nothing awful will happen if the database grows beyond 100% of\n-.IR size ,\n-but accesses will slow down somewhat and the\n-.B .pag\n-file will grow somewhat.)\n-.PP\n-.IR Dbzfresh 's\n-.I fieldsep\n-parameter specifies the field separator in the base file.\n-If this is not\n-NUL (0), and the last character of a\n-.I key\n-argument is NUL, that NUL compares equal to either a NUL or a\n-.I fieldsep\n-in the base file.\n-This permits use of NUL to terminate key strings without requiring that\n-NULs appear in the base file.\n-The\n-.I fieldsep\n-of a database created with\n-.I dbminit\n-is the horizontal-tab character.\n-.PP\n-For use in news systems, various forms of case mapping (e.g. uppercase to\n-lowercase) in keys are available.\n-The\n-.I cmap\n-parameter to\n-.I dbzfresh\n-is a single character specifying which of several mapping algorithms to use.\n-Available algorithms are:\n-.RS\n-.TP\n-.B 0\n-case-sensitive:  no case mapping\n-.TP\n-.B B\n-same as\n-.B 0\n-.TP\n-.B NUL\n-same as\n-.B 0\n-.TP\n-.B =\n-case-insensitive:  uppercase and lowercase equivalent\n-.TP\n-.B b\n-same as\n-.B =\n-.TP\n-.B C\n-RFC822 message-ID rules, case-sensitive before `@' (with certain exceptions)\n-and case-insensitive after\n-.TP\n-.B ?\n-whatever the local default is, normally\n-.B C\n-.RE\n-.PP\n-Mapping algorithm\n-.B 0\n-(no mapping) is faster than the others and is overwhelmingly the correct\n-choice for most applications.\n-Unless compatibility constraints interfere, it is more efficient to pre-map\n-the keys, storing mapped keys in the base file, than to have\n-.I dbz\n-do the mapping on every search.\n-.PP\n-For historical reasons,\n-.I fetch\n-and\n-.I store\n-expect their\n-.I key\n-arguments to be pre-mapped, but expect unmapped keys in the base file.\n-.I Dbzfetch\n-and\n-.I dbzstore\n-do the same jobs but handle all case mapping internally,\n-so the customer need not worry about it.\n-.PP\n-.I Dbz\n-stores only the database\n-.IR value s\n-in its files, relying on reference to the base file to confirm a hit on a key.\n-References to the base file can be minimized, greatly speeding up searches,\n-if a little bit of information about the keys can be stored in the\n-.I dbz\n-files.\n-This is ``free'' if there are some unused bits in an\n-.I fseek\n-offset,\n-so that the offset can be\n-.I tagged\n-with some information about the key.\n-The\n-.I tagmask\n-parameter of\n-.I dbzfresh\n-allows specifying the location of unused bits.\n-.I Tagmask\n-should be a mask with\n-one group of\n-contiguous\n-.B 1\n-bits.\n-The bits in the mask should\n-be unused (0) in\n-.I most\n-offsets.\n-The bit immediately above the mask (the\n-.I flag\n-bit) should be unused (0) in\n-.I all\n-offsets;\n-.I (dbz)store\n-will reject attempts to store a key-value pair in which the\n-.I value\n-has the flag bit on.\n-Apart from this restriction, tagging is invisible to the user.\n-As a special case, a\n-.I tagmask\n-of 1 means ``no tagging'', for use with enormous base files or\n-on systems with unusual offset representations.\n-.PP\n-A\n-.I size\n-of 0\n-given to\n-.I dbzfresh\n-is synonymous with the local default;\n-the normal default is suitable for tables of 90-100,000\n-key-value pairs.\n-A\n-.I cmap\n-of 0 (NUL) is synonymous with the character\n-.BR 0 ,\n-signifying no case mapping\n-(note that the character\n-.B ?\n-specifies the local default mapping,\n-normally\n-.BR C ).\n-A\n-.I tagmask\n-of 0 is synonymous with the local default tag mask,\n-normally 0x7f000000 (specifying the top bit in a 32-bit offset\n-as the flag bit, and the next 7 bits as the mask,\n-which is suitable for base files up to circa 24MB).\n-Calling\n-.I dbminit(name)\n-with the database files empty is equivalent to calling\n-.IR dbzfresh(name,0,'\\et','?',0) .\n-.PP\n-When databases are regenerated periodically, as in news,\n-it is simplest to pick the parameters for a new database based on the old one.\n-This also permits some memory of past sizes of the old database, so that\n-a new database size can be chosen to cover expected fluctuations.\n-.I Dbzagain\n-is a variant of\n-.I dbminit\n-for creating a new database as a new generation of an old database.\n-The database files for\n-.I oldbase\n-must exist.\n-.I Dbzagain\n-is equivalent to calling\n-.I dbzfresh\n-with the same field separator, case mapping, and tag mask as the old database,\n-and a\n-.I size\n-equal to the result of applying\n-.I dbzsize\n-to the largest number of entries in the\n-.I oldbase\n-database and its previous 10 generations.\n-.PP\n-When many accesses are being done by the same program,\n-.I dbz\n-is massively faster if its first hash table is in memory.\n-If an internal flag is 1,\n-an attempt is made to read the table in when\n-the database is opened, and\n-.I dbmclose\n-writes it out to disk again (if it was read successfully and\n-has been modified).\n-.I Dbzincore\n-sets the flag to\n-.I newvalue\n-(which should be 0 or 1)\n-and returns the previous value;\n-this does not affect the status of a database that has already been opened.\n-The default is 0.\n-The attempt to read the table in may fail due to memory shortage;\n-in this case\n-.I dbz\n-quietly falls back on its default behavior.\n-.IR Store s\n-to an in-memory database are not (in general) written out to the file\n-until\n-.IR dbmclose\n-or\n-.IR dbzsync ,\n-so if robustness in the presence of crashes\n-or concurrent accesses\n-is crucial, in-memory databases\n-should probably be avoided.\n-.PP\n-.I Dbzsync\n-causes all buffers etc. to be flushed out to the files.\n-It is typically used as a precaution against crashes or concurrent accesses\n-when a\n-.IR dbz -using\n-process will be running for a long time.\n-It is a somewhat expensive operation,\n-especially\n-for an in-memory database.\n-.PP\n-.I Dbzcancel\n-cancels any pending writes from buffers.\n-This is typically useful only for in-core databases, since writes are\n-otherwise done immediately.\n-Its main purpose is to let a child process, in the wake of a\n-.IR fork ,\n-do a\n-.I dbmclose\n-without writing its parent's data to disk.\n-.PP\n-If\n-.I dbz\n-has been compiled with debugging facilities available (which makes it\n-bigger and a bit slower),\n-.I dbzdebug\n-alters the value (and returns the previous value) of an internal flag\n-which (when 1; default is 0) causes\n-verbose and cryptic debugging output on standard output.\n-.PP\n-Concurrent reading of databases is fairly safe,\n-but there is no (inter)locking,\n-so concurrent updating is not.\n-.PP\n-The database files include a record of the byte order of the processor\n-creating the database, and accesses by processors with different byte\n-order will work, although they will be slightly slower.\n-Byte order is preserved by\n-.IR dbzagain .\n-However,\n-agreement on the size and internal structure of an\n-.I fseek\n-offset is necessary, as is consensus on\n-the character set.\n-.PP\n-An open database occupies three\n-.I stdio\n-streams and their corresponding file descriptors;\n-a fourth is needed for an in-memory database.\n-Memory consumption is negligible (except for\n-.I stdio\n-buffers) except for in-memory databases.\n-.SH SEE ALSO\n-dbz(1), dbm(3)\n-.SH DIAGNOSTICS\n-Functions returning\n-.I int\n-values return 0 for success, \\-1 for failure.\n-Functions returning\n-.I datum\n-values return a value with\n-.I dptr\n-set to NULL for failure.\n-.I Dbminit\n-attempts to have\n-.I errno\n-set plausibly on return, but otherwise this is not guaranteed.\n-An\n-.I errno\n-of\n-.B EDOM\n-from\n-.I dbminit\n-indicates that the database did not appear to be in\n-.I dbz\n-format.\n-.SH HISTORY\n-The original\n-.I dbz\n-was written by\n-Jon Zeeff (zeeff@b-tech.ann-arbor.mi.us).\n-Later contributions by David Butler and Mark Moraes.\n-Extensive reworking,\n-including this documentation,\n-by Henry Spencer (henry@zoo.toronto.edu) as\n-part of the C News project.\n-Hashing function by Peter Honeyman.\n-.SH BUGS\n-The\n-.I dptr\n-members of returned\n-.I datum\n-values point to static storage which is overwritten by later calls.\n-.PP\n-Unlike\n-.IR dbm ,\n-.I dbz\n-will misbehave if an existing key-value pair is `overwritten' by\n-a new\n-.I (dbz)store\n-with the same key.\n-The user is responsible for avoiding this by using\n-.I (dbz)fetch\n-first to check for duplicates;\n-an internal optimization remembers the result of the\n-first search so there is minimal overhead in this.\n-.PP\n-Waiting until after\n-.I dbminit\n-to bring the base file into existence\n-will fail if\n-.IR chdir (2)\n-has been used meanwhile.\n-.PP\n-The RFC822 case mapper implements only a first approximation to the\n-hideously-complex RFC822 case rules.\n-.PP\n-The prime finder in\n-.I dbzsize\n-is not particularly quick.\n-.PP\n-Should implement the\n-.I dbm\n-functions\n-.IR delete ,\n-.IR firstkey ,\n-and\n-.IR nextkey .\n-.PP\n-On C implementations which trap integer overflow,\n-.I dbz\n-will refuse to\n-.I (dbz)store\n-an\n-.I fseek\n-offset equal to the greatest\n-representable\n-positive number,\n-as this would cause overflow in the biased representation used.\n-.PP\n-.I Dbzagain\n-perhaps ought to notice when many offsets\n-in the old database were\n-too big for\n-tagging, and shrink the tag mask to match.\n-.PP\n-Marking\n-.IR dbz 's\n-file descriptors\n-.RI close-on- exec\n-would be a better approach to the problem\n-.I dbzcancel\n-tries to address, but that's harder to do portably."}, {"sha": "417ecde6685b277f79d06b5461a0b7d0114a4e94", "filename": "libio/dbz/dbz.c", "status": "removed", "additions": 0, "deletions": 1759, "changes": 1759, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fdbz.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fdbz.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Fdbz.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,1759 +0,0 @@\n-/*\n-\n-dbz.c  V3.2\n-\n-Copyright 1988 Jon Zeeff (zeeff@b-tech.ann-arbor.mi.us)\n-You can use this code in any manner, as long as you leave my name on it\n-and don't hold me responsible for any problems with it.\n-\n-Hacked on by gdb@ninja.UUCP (David Butler); Sun Jun  5 00:27:08 CDT 1988\n-\n-Various improvments + INCORE by moraes@ai.toronto.edu (Mark Moraes)\n-\n-Major reworking by Henry Spencer as part of the C News project.\n-\n-These routines replace dbm as used by the usenet news software\n-(it's not a full dbm replacement by any means).  It's fast and\n-simple.  It contains no AT&T code.\n-\n-In general, dbz's files are 1/20 the size of dbm's.  Lookup performance\n-is somewhat better, while file creation is spectacularly faster, especially\n-if the incore facility is used.\n-\n-*/\n-\n-#include <stdio.h>\n-#include <sys/types.h>\n-#include <string.h>\n-#include <ctype.h>\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <dbz.h>\n-\n-/*\n- * #ifdef index.  \"LIA\" = \"leave it alone unless you know what you're doing\".\n- *\n- * FUNNYSEEKS\tSEEK_SET is not 0, get it from <unistd.h>\n- * INDEX_SIZE\tbackward compatibility with old dbz; avoid using this\n- * NMEMORY\tnumber of days of memory for use in sizing new table (LIA)\n- * INCORE\tbackward compatibility with old dbz; use dbzincore() instead\n- * DBZDEBUG\tenable debugging\n- * DEFSIZE\tdefault table size (not as critical as in old dbz)\n- * OLDBNEWS\tdefault case mapping as in old B News; set NOBUFFER\n- * BNEWS\tdefault case mapping as in current B News; set NOBUFFER\n- * DEFCASE\tdefault case-map algorithm selector\n- * NOTAGS\tfseek offsets are strange, do not do tagging (see below)\n- * NPAGBUF\tsize of .pag buffer, in longs (LIA)\n- * SHISTBUF\tsize of ASCII-file buffer, in bytes (LIA)\n- * MAXRUN\tlength of run which shifts to next table (see below) (LIA)\n- * OVERFLOW\tlong-int arithmetic overflow must be avoided, will trap\n- * NOBUFFER\tdo not buffer hash-table i/o, B News locking is defective\n- */\n-\n-#ifdef FUNNYSEEKS\n-#include <unistd.h>\n-#else\n-#define\tSEEK_SET\t0\n-#endif\n-#ifdef OVERFLOW\n-#include <limits.h>\n-#endif\n-\n-static int dbzversion = 3;\t/* for validating .dir file format */\n-\n-/*\n- * The dbz database exploits the fact that when news stores a <key,value>\n- * tuple, the `value' part is a seek offset into a text file, pointing to\n- * a copy of the `key' part.  This avoids the need to store a copy of\n- * the key in the dbz files.  However, the text file *must* exist and be\n- * consistent with the dbz files, or things will fail.\n- *\n- * The basic format of the database is a simple hash table containing the\n- * values.  A value is stored by indexing into the table using a hash value\n- * computed from the key; collisions are resolved by linear probing (just\n- * search forward for an empty slot, wrapping around to the beginning of\n- * the table if necessary).  Linear probing is a performance disaster when\n- * the table starts to get full, so a complication is introduced.  The\n- * database is actually one *or more* tables, stored sequentially in the\n- * .pag file, and the length of linear-probe sequences is limited.  The\n- * search (for an existing item or an empty slot) always starts in the\n- * first table, and whenever MAXRUN probes have been done in table N,\n- * probing continues in table N+1.  This behaves reasonably well even in\n- * cases of massive overflow.  There are some other small complications\n- * added, see comments below.\n- *\n- * The table size is fixed for any particular database, but is determined\n- * dynamically when a database is rebuilt.  The strategy is to try to pick\n- * the size so the first table will be no more than 2/3 full, that being\n- * slightly before the point where performance starts to degrade.  (It is\n- * desirable to be a bit conservative because the overflow strategy tends\n- * to produce files with holes in them, which is a nuisance.)\n- */\n-\n-/*\n- * The following is for backward compatibility.\n- */\n-#ifdef INDEX_SIZE\n-#define\tDEFSIZE\tINDEX_SIZE\n-#endif\n-\n-/*\n- * ANSI C says the offset argument to fseek is a long, not an off_t, for some\n- * reason.  Let's use off_t anyway.\n- */\n-#define\tSOF\t(sizeof(off_t))\n-\n-/*\n- * We assume that unused areas of a binary file are zeros, and that the\n- * bit pattern of `(off_t)0' is all zeros.  The alternative is rather\n- * painful file initialization.  Note that okayvalue(), if OVERFLOW is\n- * defined, knows what value of an offset would cause overflow.\n- */\n-#define\tVACANT\t\t((off_t)0)\n-#define\tBIAS(o)\t\t((o)+1)\t\t/* make any valid off_t non-VACANT */\n-#define\tUNBIAS(o)\t((o)-1)\t\t/* reverse BIAS() effect */\n-\n-/*\n- * In a Unix implementation, or indeed any in which an off_t is a byte\n- * count, there are a bunch of high bits free in an off_t.  There is a\n- * use for them.  Checking a possible hit by looking it up in the base\n- * file is relatively expensive, and the cost can be dramatically reduced\n- * by using some of those high bits to tag the value with a few more bits\n- * of the key's hash.  This detects most false hits without the overhead of\n- * seek+read+strcmp.  We use the top bit to indicate whether the value is\n- * tagged or not, and don't tag a value which is using the tag bits itself.\n- * We're in trouble if the off_t representation wants to use the top bit.\n- * The actual bitmasks and offset come from the configuration stuff,\n- * which permits fiddling with them as necessary, and also suppressing\n- * them completely (by defining the masks to 0).  We build pre-shifted\n- * versions of the masks for efficiency.\n- */\n-static off_t tagbits;\t\t/* pre-shifted tag mask */\n-static off_t taghere;\t\t/* pre-shifted tag-enable bit */\n-static off_t tagboth;\t\t/* tagbits|taghere */\n-#define\tHASTAG(o)\t((o)&taghere)\n-#define\tTAG(o)\t\t((o)&tagbits)\n-#define\tNOTAG(o)\t((o)&~tagboth)\n-#define\tCANTAG(o)\t(((o)&tagboth) == 0)\n-#define\tMKTAG(v)\t(((v)<<conf.tagshift)&tagbits)\n-\n-/*\n- * A new, from-scratch database, not built as a rebuild of an old one,\n- * needs to know table size, casemap algorithm, and tagging.  Normally\n- * the user supplies this info, but there have to be defaults.\n- */\n-#ifndef DEFSIZE\n-#define\tDEFSIZE\t120011\t\t/* 300007 might be better */\n-#endif\n-#ifdef OLDBNEWS\n-#define\tDEFCASE\t'0'\t\t/* B2.10 -- no mapping */\n-#define\tNOBUFFER\t\t/* B News locking is defective */\n-#endif\n-#ifdef BNEWS\n-#define\tDEFCASE\t'='\t\t/* B2.11 -- all mapped */\n-#define\tNOBUFFER\t\t/* B News locking is defective */\n-#endif\n-#ifndef DEFCASE\t\t\t/* C News compatibility is the default */\n-#define\tDEFCASE\t'C'\t\t/* C News -- RFC822 mapping */\n-#endif\n-#ifndef NOTAGS\n-#define\tTAGENB\t0x80\t\t/* tag enable is top bit, tag is next 7 */\n-#define\tTAGMASK\t0x7f\n-#define\tTAGSHIFT\t24\n-#else\n-#define\tTAGENB\t0\t\t/* no tags */\n-#define\tTAGMASK\t0\n-#define\tTAGSHIFT\t0\n-#endif\n-\n-/*\n- * We read configuration info from the .dir file into this structure,\n- * so we can avoid wired-in assumptions for an existing database.\n- *\n- * Among the info is a record of recent peak usages, so that a new table\n- * size can be chosen intelligently when rebuilding.  10 is a good\n- * number of usages to keep, since news displays marked fluctuations\n- * in volume on a 7-day cycle.\n- */\n-struct dbzconfig {\n-\tint olddbz;\t\t/* .dir file empty but .pag not? */\n-\toff_t tsize;\t\t/* table size */\n-#\tifndef NMEMORY\n-#\tdefine\tNMEMORY\t10\t/* # days of use info to remember */\n-#\tendif\n-#\tdefine\tNUSEDS\t(1+NMEMORY)\n-\toff_t used[NUSEDS];\t/* entries used today, yesterday, ... */\n-\tint valuesize;\t\t/* size of table values, == SOF */\n-\tint bytemap[SOF];\t/* byte-order map */\n-\tchar casemap;\t\t/* case-mapping algorithm (see cipoint()) */\n-\tchar fieldsep;\t\t/* field separator in base file, if any */\n-\toff_t tagenb;\t\t/* unshifted tag-enable bit */\n-\toff_t tagmask;\t\t/* unshifted tag mask */\n-\tint tagshift;\t\t/* shift count for tagmask and tagenb */\n-};\n-static struct dbzconfig conf;\n-static int getconf();\n-static long getno();\n-static int putconf();\n-static void mybytemap();\n-static off_t bytemap();\n-\n-/* \n- * For a program that makes many, many references to the database, it\n- * is a large performance win to keep the table in core, if it will fit.\n- * Note that this does hurt robustness in the event of crashes, and\n- * dbmclose() *must* be called to flush the in-core database to disk.\n- * The code is prepared to deal with the possibility that there isn't\n- * enough memory.  There *is* an assumption that a size_t is big enough\n- * to hold the size (in bytes) of one table, so dbminit() tries to figure\n- * out whether this is possible first.\n- *\n- * The preferred way to ask for an in-core table is to do dbzincore(1)\n- * before dbminit().  The default is not to do it, although -DINCORE\n- * overrides this for backward compatibility with old dbz.\n- *\n- * We keep only the first table in core.  This greatly simplifies the\n- * code, and bounds memory demand.  Furthermore, doing this is a large\n- * performance win even in the event of massive overflow.\n- */\n-#ifdef INCORE\n-static int incore = 1;\n-#else\n-static int incore = 0;\n-#endif\n-\n-/*\n- * Stdio buffer for .pag reads.  Buffering more than about 16 does not help\n- * significantly at the densities we try to maintain, and the much larger\n- * buffers that most stdios default to are much more expensive to fill.\n- * With small buffers, stdio is performance-competitive with raw read(),\n- * and it's much more portable.\n- */\n-#ifndef NPAGBUF\n-#define\tNPAGBUF\t16\n-#endif\n-#ifndef NOBUFFER\n-#ifdef _IOFBF\n-static off_t pagbuf[NPAGBUF];\t/* only needed if !NOBUFFER && _IOFBF */\n-#endif\n-#endif\n-\n-/*\n- * Stdio buffer for base-file reads.  Message-IDs (all news ever needs to\n- * read) are essentially never longer than 64 bytes, and the typical stdio\n- * buffer is so much larger that it is much more expensive to fill.\n- */\n-#ifndef SHISTBUF\n-#define\tSHISTBUF\t64\n-#endif\n-#ifdef _IOFBF\n-static char basebuf[SHISTBUF];\t\t/* only needed if _IOFBF exists */\n-#endif\n-\n-/*\n- * Data structure for recording info about searches.\n- */\n-struct searcher {\n-\toff_t place;\t\t/* current location in file */\n-\tint tabno;\t\t/* which table we're in */\n-\tint run;\t\t/* how long we'll stay in this table */\n-#\t\tifndef MAXRUN\n-#\t\tdefine\tMAXRUN\t100\n-#\t\tendif\n-\tlong hash;\t\t/* the key's hash code (for optimization) */\n-\toff_t tag;\t\t/* tag we are looking for */\n-\tint seen;\t\t/* have we examined current location? */\n-\tint aborted;\t\t/* has i/o error aborted search? */\n-};\n-static void start();\n-#define\tFRESH\t((struct searcher *)NULL)\n-static off_t search();\n-#define\tNOTFOUND\t((off_t)-1)\n-static int okayvalue();\n-static int set();\n-\n-/*\n- * Arguably the searcher struct for a given routine ought to be local to\n- * it, but a fetch() is very often immediately followed by a store(), and\n- * in some circumstances it is a useful performance win to remember where\n- * the fetch() completed.  So we use a global struct and remember whether\n- * it is current.\n- */\n-static struct searcher srch;\n-static struct searcher *prevp;\t/* &srch or FRESH */\n-\n-/* byte-ordering stuff */\n-static int mybmap[SOF];\t\t\t/* my byte order (see mybytemap()) */\n-static int bytesame;\t\t\t/* is database order same as mine? */\n-#define\tMAPIN(o)\t((bytesame) ? (o) : bytemap((o), conf.bytemap, mybmap))\n-#define\tMAPOUT(o)\t((bytesame) ? (o) : bytemap((o), mybmap, conf.bytemap))\n-\n-/*\n- * The double parentheses needed to make this work are ugly, but the\n- * alternative (under most compilers) is to pack around 2K of unused\n- * strings -- there's just no way to get rid of them.\n- */\n-static int debug;\t\t\t/* controlled by dbzdebug() */\n-#ifdef DBZDEBUG\n-#define DEBUG(args) if (debug) { (void) printf args ; }\n-#else\n-#define\tDEBUG(args)\t;\n-#endif\n-\n-/* misc. forwards */\n-static long hash();\n-static void crcinit();\n-static char *cipoint();\n-static char *mapcase();\n-static int isprime();\n-static FILE *latebase();\n-\n-/* file-naming stuff */\n-static char dir[] = \".dir\";\n-static char pag[] = \".pag\";\n-static char *enstring();\n-\n-/* central data structures */\n-static FILE *basef;\t\t/* descriptor for base file */\n-static char *basefname;\t\t/* name for not-yet-opened base file */\n-static FILE *dirf;\t\t/* descriptor for .dir file */\n-static int dirronly;\t\t/* dirf open read-only? */\n-static FILE *pagf = NULL;\t/* descriptor for .pag file */\n-static off_t pagpos;\t\t/* posn in pagf; only search may set != -1 */\n-static int pagronly;\t\t/* pagf open read-only? */\n-static off_t *corepag;\t\t/* incore version of .pag file, if any */\n-static FILE *bufpagf;\t\t/* well-buffered pagf, for incore rewrite */\n-static off_t *getcore();\n-static int putcore();\n-static int written;\t\t/* has a store() been done? */\n-\n-/*\n- - dbzfresh - set up a new database, no historical info\n- */\n-int\t\t\t\t/* 0 success, -1 failure */\n-dbzfresh(name, size, fs, cmap, tagmask)\n-char *name;\t\t\t/* base name; .dir and .pag must exist */\n-long size;\t\t\t/* table size (0 means default) */\n-int fs;\t\t\t\t/* field-separator character in base file */\n-int cmap;\t\t\t/* case-map algorithm (0 means default) */\n-off_t tagmask;\t\t\t/* 0 default, 1 no tags */\n-{\n-\tregister char *fn;\n-\tstruct dbzconfig c;\n-\tregister off_t m;\n-\tregister FILE *f;\n-\n-\tif (pagf != NULL) {\n-\t\tDEBUG((\"dbzfresh: database already open\\n\"));\n-\t\treturn(-1);\n-\t}\n-\tif (size != 0 && size < 2) {\n-\t\tDEBUG((\"dbzfresh: preposterous size (%ld)\\n\", size));\n-\t\treturn(-1);\n-\t}\n-\n-\t/* get default configuration */\n-\tif (getconf((FILE *)NULL, (FILE *)NULL, &c) < 0)\n-\t\treturn(-1);\t/* \"can't happen\" */\n-\n-\t/* and mess with it as specified */\n-\tif (size != 0)\n-\t\tc.tsize = size;\n-\tc.fieldsep = fs;\n-\tswitch (cmap) {\n-\tcase 0:\n-\tcase '0':\n-\tcase 'B':\t\t/* 2.10 compat */\n-\t\tc.casemap = '0';\t/* '\\0' nicer, but '0' printable! */\n-\t\tbreak;\n-\tcase '=':\n-\tcase 'b':\t\t/* 2.11 compat */\n-\t\tc.casemap = '=';\n-\t\tbreak;\n-\tcase 'C':\n-\t\tc.casemap = 'C';\n-\t\tbreak;\n-\tcase '?':\n-\t\tc.casemap = DEFCASE;\n-\t\tbreak;\n-\tdefault:\n-\t\tDEBUG((\"dbzfresh case map `%c' unknown\\n\", cmap));\n-\t\treturn(-1);\n-\t\tbreak;\n-\t}\n-\tswitch (tagmask) {\n-\tcase 0:\t\t\t/* default */\n-\t\tbreak;\n-\tcase 1:\t\t\t/* no tags */\n-\t\tc.tagshift = 0;\n-\t\tc.tagmask = 0;\n-\t\tc.tagenb = 0;\n-\t\tbreak;\n-\tdefault:\n-\t\tm = tagmask;\n-\t\tc.tagshift = 0;\n-\t\twhile (!(m&01)) {\n-\t\t\tm >>= 1;\n-\t\t\tc.tagshift++;\n-\t\t}\n-\t\tc.tagmask = m;\n-\t\tc.tagenb = (m << 1) & ~m;\n-\t\tbreak;\n-\t}\n-\n-\t/* write it out */\n-\tfn = enstring(name, dir);\n-\tif (fn == NULL)\n-\t\treturn(-1);\n-\tf = fopen(fn, \"w\");\n-\tfree(fn);\n-\tif (f == NULL) {\n-\t\tDEBUG((\"dbzfresh: unable to write config\\n\"));\n-\t\treturn(-1);\n-\t}\n-\tif (putconf(f, &c) < 0) {\n-\t\t(void) fclose(f);\n-\t\treturn(-1);\n-\t}\n-\tif (fclose(f) == EOF) {\n-\t\tDEBUG((\"dbzfresh: fclose failure\\n\"));\n-\t\treturn(-1);\n-\t}\n-\n-\t/* create/truncate .pag */\n-\tfn = enstring(name, pag);\n-\tif (fn == NULL)\n-\t\treturn(-1);\n-\tf = fopen(fn, \"w\");\n-\tfree(fn);\n-\tif (f == NULL) {\n-\t\tDEBUG((\"dbzfresh: unable to create/truncate .pag file\\n\"));\n-\t\treturn(-1);\n-\t} else\n-\t\t(void) fclose(f);\n-\n-\t/* and punt to dbminit for the hard work */\n-\treturn(dbminit(name));\n-}\n-\n-/*\n- - dbzsize - what's a good table size to hold this many entries?\n- */\n-long\n-dbzsize(contents)\n-long contents;\t\t\t/* 0 means what's the default */\n-{\n-\tregister long n;\n-\n-\tif (contents <= 0) {\t/* foulup or default inquiry */\n-\t\tDEBUG((\"dbzsize: preposterous input (%ld)\\n\", contents));\n-\t\treturn(DEFSIZE);\n-\t}\n-\tn = (contents/2)*3;\t/* try to keep table at most 2/3 full */\n-\tif (!(n&01))\t\t/* make it odd */\n-\t\tn++;\n-\tDEBUG((\"dbzsize: tentative size %ld\\n\", n));\n-\twhile (!isprime(n))\t/* and look for a prime */\n-\t\tn += 2;\n-\tDEBUG((\"dbzsize: final size %ld\\n\", n));\n-\n-\treturn(n);\n-}\n-\n-/*\n- - isprime - is a number prime?\n- *\n- * This is not a terribly efficient approach.\n- */\n-static int\t\t\t/* predicate */\n-isprime(x)\n-register long x;\n-{\n-\tstatic int quick[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 0 };\n-\tregister int *ip;\n-\tregister long div;\n-\tregister long stop;\n-\n-\t/* hit the first few primes quickly to eliminate easy ones */\n-\t/* this incidentally prevents ridiculously small tables */\n-\tfor (ip = quick; (div = *ip) != 0; ip++)\n-\t\tif (x%div == 0) {\n-\t\t\tDEBUG((\"isprime: quick result on %ld\\n\", (long)x));\n-\t\t\treturn(0);\n-\t\t}\n-\n-\t/* approximate square root of x */\n-\tfor (stop = x; x/stop < stop; stop >>= 1)\n-\t\tcontinue;\n-\tstop <<= 1;\n-\n-\t/* try odd numbers up to stop */\n-\tfor (div = *--ip; div < stop; div += 2)\n-\t\tif (x%div == 0)\n-\t\t\treturn(0);\n-\n-\treturn(1);\n-}\n-\n-/*\n- - dbzagain - set up a new database to be a rebuild of an old one\n- */\n-int\t\t\t\t/* 0 success, -1 failure */\n-dbzagain(name, oldname)\n-char *name;\t\t\t/* base name; .dir and .pag must exist */\n-char *oldname;\t\t\t/* base name; all must exist */\n-{\n-\tregister char *fn;\n-\tstruct dbzconfig c;\n-\tregister int i;\n-\tregister long top;\n-\tregister FILE *f;\n-\tregister int newtable;\n-\tregister off_t newsize;\n-\n-\tif (pagf != NULL) {\n-\t\tDEBUG((\"dbzagain: database already open\\n\"));\n-\t\treturn(-1);\n-\t}\n-\n-\t/* pick up the old configuration */\n-\tfn = enstring(oldname, dir);\n-\tif (fn == NULL)\n-\t\treturn(-1);\n-\tf = fopen(fn, \"r\");\n-\tfree(fn);\n-\tif (f == NULL) {\n-\t\tDEBUG((\"dbzagain: cannot open old .dir file\\n\"));\n-\t\treturn(-1);\n-\t}\n-\ti = getconf(f, (FILE *)NULL, &c);\n-\t(void) fclose(f);\n-\tif (i < 0) {\n-\t\tDEBUG((\"dbzagain: getconf failed\\n\"));\n-\t\treturn(-1);\n-\t}\n-\n-\t/* tinker with it */\n-\ttop = 0;\n-\tnewtable = 0;\n-\tfor (i = 0; i < NUSEDS; i++) {\n-\t\tif (top < c.used[i])\n-\t\t\ttop = c.used[i];\n-\t\tif (c.used[i] == 0)\n-\t\t\tnewtable = 1;\t/* hasn't got full usage history yet */\n-\t}\n-\tif (top == 0) {\n-\t\tDEBUG((\"dbzagain: old table has no contents!\\n\"));\n-\t\tnewtable = 1;\n-\t}\n-\tfor (i = NUSEDS-1; i > 0; i--)\n-\t\tc.used[i] = c.used[i-1];\n-\tc.used[0] = 0;\n-\tnewsize = dbzsize(top);\n-\tif (!newtable || newsize > c.tsize)\t/* don't shrink new table */\n-\t\tc.tsize = newsize;\n-\n-\t/* write it out */\n-\tfn = enstring(name, dir);\n-\tif (fn == NULL)\n-\t\treturn(-1);\n-\tf = fopen(fn, \"w\");\n-\tfree(fn);\n-\tif (f == NULL) {\n-\t\tDEBUG((\"dbzagain: unable to write new .dir\\n\"));\n-\t\treturn(-1);\n-\t}\n-\ti = putconf(f, &c);\n-\t(void) fclose(f);\n-\tif (i < 0) {\n-\t\tDEBUG((\"dbzagain: putconf failed\\n\"));\n-\t\treturn(-1);\n-\t}\n-\n-\t/* create/truncate .pag */\n-\tfn = enstring(name, pag);\n-\tif (fn == NULL)\n-\t\treturn(-1);\n-\tf = fopen(fn, \"w\");\n-\tfree(fn);\n-\tif (f == NULL) {\n-\t\tDEBUG((\"dbzagain: unable to create/truncate .pag file\\n\"));\n-\t\treturn(-1);\n-\t} else\n-\t\t(void) fclose(f);\n-\n-\t/* and let dbminit do the work */\n-\treturn(dbminit(name));\n-}\n-\n-/*\n- - dbminit - open a database, creating it (using defaults) if necessary\n- *\n- * We try to leave errno set plausibly, to the extent that underlying\n- * functions permit this, since many people consult it if dbminit() fails.\n- */\n-int \t\t\t\t/* 0 success, -1 failure */\n-dbminit(name)\n-char *name;\n-{\n-\tregister int i;\n-\tregister size_t s;\n-\tregister char *dirfname;\n-\tregister char *pagfname;\n-\n-\tif (pagf != NULL) {\n-\t\tDEBUG((\"dbminit: dbminit already called once\\n\"));\n-\t\terrno = 0;\n-\t\treturn(-1);\n-\t}\n-\n-\t/* open the .dir file */\n-\tdirfname = enstring(name, dir);\n-\tif (dirfname == NULL)\n-\t\treturn(-1);\n-\tdirf = fopen(dirfname, \"r+\");\n-\tif (dirf == NULL) {\n-\t\tdirf = fopen(dirfname, \"r\");\n-\t\tdirronly = 1;\n-\t} else\n-\t\tdirronly = 0;\n-\tfree(dirfname);\n-\tif (dirf == NULL) {\n-\t\tDEBUG((\"dbminit: can't open .dir file\\n\"));\n-\t\treturn(-1);\n-\t}\n-\n-\t/* open the .pag file */\n-\tpagfname = enstring(name, pag);\n-\tif (pagfname == NULL) {\n-\t\t(void) fclose(dirf);\n-\t\treturn(-1);\n-\t}\n-\tpagf = fopen(pagfname, \"r+b\");\n-\tif (pagf == NULL) {\n-\t\tpagf = fopen(pagfname, \"rb\");\n-\t\tif (pagf == NULL) {\n-\t\t\tDEBUG((\"dbminit: .pag open failed\\n\"));\n-\t\t\t(void) fclose(dirf);\n-\t\t\tfree(pagfname);\n-\t\t\treturn(-1);\n-\t\t}\n-\t\tpagronly = 1;\n-\t} else if (dirronly)\n-\t\tpagronly = 1;\n-\telse\n-\t\tpagronly = 0;\n-#ifdef NOBUFFER\n-\t/*\n-\t * B News does not do adequate locking on its database accesses.\n-\t * Why it doesn't get into trouble using dbm is a mystery.  In any\n-\t * case, doing unbuffered i/o does not cure the problem, but does\n-\t * enormously reduce its incidence.\n-\t */\n-\t(void) setbuf(pagf, (char *)NULL);\n-#else\n-#ifdef _IOFBF\n-\t(void) setvbuf(pagf, (char *)pagbuf, _IOFBF, sizeof(pagbuf));\n-#endif\n-#endif\n-\tpagpos = -1;\n-\t/* don't free pagfname, need it below */\n-\n-\t/* open the base file */\n-\tbasef = fopen(name, \"r\");\n-\tif (basef == NULL) {\n-\t\tDEBUG((\"dbminit: basefile open failed\\n\"));\n-\t\tbasefname = enstring(name, \"\");\n-\t\tif (basefname == NULL) {\n-\t\t\t(void) fclose(pagf);\n-\t\t\t(void) fclose(dirf);\n-\t\t\tfree(pagfname);\n-\t\t\tpagf = NULL;\n-\t\t\treturn(-1);\n-\t\t}\n-\t} else\n-\t\tbasefname = NULL;\n-#ifdef _IOFBF\n-\tif (basef != NULL)\n-\t\t(void) setvbuf(basef, basebuf, _IOFBF, sizeof(basebuf));\n-#endif\n-\n-\t/* pick up configuration */\n-\tif (getconf(dirf, pagf, &conf) < 0) {\n-\t\tDEBUG((\"dbminit: getconf failure\\n\"));\n-\t\t(void) fclose(basef);\n-\t\t(void) fclose(pagf);\n-\t\t(void) fclose(dirf);\n-\t\tfree(pagfname);\n-\t\tpagf = NULL;\n-\t\terrno = EDOM;\t/* kind of a kludge, but very portable */\n-\t\treturn(-1);\n-\t}\n-\ttagbits = conf.tagmask << conf.tagshift;\n-\ttaghere = conf.tagenb << conf.tagshift;\n-\ttagboth = tagbits | taghere;\n-\tmybytemap(mybmap);\n-\tbytesame = 1;\n-\tfor (i = 0; i < SOF; i++)\n-\t\tif (mybmap[i] != conf.bytemap[i])\n-\t\t\tbytesame = 0;\n-\n-\t/* get first table into core, if it looks desirable and feasible */\n-\ts = (size_t)conf.tsize * SOF;\n-\tif (incore && (off_t)(s/SOF) == conf.tsize) {\n-\t\tbufpagf = fopen(pagfname, (pagronly) ? \"rb\" : \"r+b\");\n-\t\tif (bufpagf != NULL)\n-\t\t\tcorepag = getcore(bufpagf);\n-\t} else {\n-\t\tbufpagf = NULL;\n-\t\tcorepag = NULL;\n-\t}\n-\tfree(pagfname);\n-\n-\t/* misc. setup */\n-\tcrcinit();\n-\twritten = 0;\n-\tprevp = FRESH;\n-\tDEBUG((\"dbminit: succeeded\\n\"));\n-\treturn(0);\n-}\n-\n-/*\n- - enstring - concatenate two strings into a malloced area\n- */\n-static char *\t\t\t/* NULL if malloc fails */\n-enstring(s1, s2)\n-char *s1;\n-char *s2;\n-{\n-\tregister char *p;\n-\n-\tp = malloc((size_t)strlen(s1) + (size_t)strlen(s2) + 1);\n-\tif (p != NULL) {\n-\t\t(void) strcpy(p, s1);\n-\t\t(void) strcat(p, s2);\n-\t} else {\n-\t\tDEBUG((\"enstring(%s, %s) out of memory\\n\", s1, s2));\n-\t}\n-\treturn(p);\n-}\n-\n-/*\n- - dbmclose - close a database\n- */\n-int\n-dbmclose()\n-{\n-\tregister int ret = 0;\n-\n-\tif (pagf == NULL) {\n-\t\tDEBUG((\"dbmclose: not opened!\\n\"));\n-\t\treturn(-1);\n-\t}\n-\n-\tif (fclose(pagf) == EOF) {\n-\t\tDEBUG((\"dbmclose: fclose(pagf) failed\\n\"));\n-\t\tret = -1;\n-\t}\n-\tpagf = basef;\t\t/* ensure valid pointer; dbzsync checks it */\n-\tif (dbzsync() < 0)\n-\t\tret = -1;\n-\tif (bufpagf != NULL && fclose(bufpagf) == EOF) {\n-\t\tDEBUG((\"dbmclose: fclose(bufpagf) failed\\n\"));\n-\t\tret = -1;\n-\t}\n-\tif (corepag != NULL)\n-\t\tfree((char *)corepag);\n-\tcorepag = NULL;\n-\tif (fclose(basef) == EOF) {\n-\t\tDEBUG((\"dbmclose: fclose(basef) failed\\n\"));\n-\t\tret = -1;\n-\t}\n-\tif (basefname != NULL)\n-\t\tfree(basefname);\n-\tbasef = NULL;\n-\tpagf = NULL;\n-\tif (fclose(dirf) == EOF) {\n-\t\tDEBUG((\"dbmclose: fclose(dirf) failed\\n\"));\n-\t\tret = -1;\n-\t}\n-\n-\tDEBUG((\"dbmclose: %s\\n\", (ret == 0) ? \"succeeded\" : \"failed\"));\n-\treturn(ret);\n-}\n-\n-/*\n- - dbzsync - push all in-core data out to disk\n- */\n-int\n-dbzsync()\n-{\n-\tregister int ret = 0;\n-\n-\tif (pagf == NULL) {\n-\t\tDEBUG((\"dbzsync: not opened!\\n\"));\n-\t\treturn(-1);\n-\t}\n-\tif (!written)\n-\t\treturn(0);\n-\n-\tif (corepag != NULL) {\n-\t\tif (putcore(corepag, bufpagf) < 0) {\n-\t\t\tDEBUG((\"dbzsync: putcore failed\\n\"));\n-\t\t\tret = -1;\n-\t\t}\n-\t}\n-\tif (!conf.olddbz)\n-\t\tif (putconf(dirf, &conf) < 0)\n-\t\t\tret = -1;\n-\n-\tDEBUG((\"dbzsync: %s\\n\", (ret == 0) ? \"succeeded\" : \"failed\"));\n-\treturn(ret);\n-}\n-\n-/*\n- - dbzcancel - cancel writing of in-core data\n- * Mostly for use from child processes.\n- * Note that we don't need to futz around with stdio buffers, because we\n- * always fflush them immediately anyway and so they never have stale data.\n- */\n-int\n-dbzcancel()\n-{\n-\tif (pagf == NULL) {\n-\t\tDEBUG((\"dbzcancel: not opened!\\n\"));\n-\t\treturn(-1);\n-\t}\n-\n-\twritten = 0;\n-\treturn(0);\n-}\n-\n-/*\n- - dbzfetch - fetch() with case mapping built in\n- */\n-datum\n-dbzfetch(key)\n-datum key;\n-{\n-\tchar buffer[DBZMAXKEY + 1];\n-\tdatum mappedkey;\n-\tregister size_t keysize;\n-\n-\tDEBUG((\"dbzfetch: (%s)\\n\", key.dptr));\n-\n-\t/* Key is supposed to be less than DBZMAXKEY */\n-\tkeysize = key.dsize;\n-\tif (keysize >= DBZMAXKEY) {\n-\t\tkeysize = DBZMAXKEY;\n-\t\tDEBUG((\"keysize is %d - truncated to %d\\n\", key.dsize, DBZMAXKEY));\n-\t}\n-\n-\tmappedkey.dptr = mapcase(buffer, key.dptr, keysize);\n-\tbuffer[keysize] = '\\0';\t/* just a debug aid */\n-\tmappedkey.dsize = keysize;\n-\n-\treturn(fetch(mappedkey));\n-}\n-\n-/*\n- - fetch - get an entry from the database\n- *\n- * Disgusting fine point, in the name of backward compatibility:  if the\n- * last character of \"key\" is a NUL, that character is (effectively) not\n- * part of the comparison against the stored keys.\n- */\n-datum\t\t\t\t/* dptr NULL, dsize 0 means failure */\n-fetch(key)\n-datum key;\n-{\n-\tchar buffer[DBZMAXKEY + 1];\n-\tstatic off_t key_ptr;\t\t/* return value points here */\n-\tdatum output;\n-\tregister size_t keysize;\n-\tregister size_t cmplen;\n-\tregister char *sepp;\n-\n-\tDEBUG((\"fetch: (%s)\\n\", key.dptr));\n-\toutput.dptr = NULL;\n-\toutput.dsize = 0;\n-\tprevp = FRESH;\n-\n-\t/* Key is supposed to be less than DBZMAXKEY */\n-\tkeysize = key.dsize;\n-\tif (keysize >= DBZMAXKEY) {\n-\t\tkeysize = DBZMAXKEY;\n-\t\tDEBUG((\"keysize is %d - truncated to %d\\n\", key.dsize, DBZMAXKEY));\n-\t}\n-\n-\tif (pagf == NULL) {\n-\t\tDEBUG((\"fetch: database not open!\\n\"));\n-\t\treturn(output);\n-\t} else if (basef == NULL) {\t/* basef didn't exist yet */\n-\t\tbasef = latebase();\n-\t\tif (basef == NULL)\n-\t\t\treturn(output);\n-\t}\n-\n-\tcmplen = keysize;\n-\tsepp = &conf.fieldsep;\n-\tif (key.dptr[keysize-1] == '\\0') {\n-\t\tcmplen--;\n-\t\tsepp = &buffer[keysize-1];\n-\t}\n-\tstart(&srch, &key, FRESH);\n-\twhile ((key_ptr = search(&srch)) != NOTFOUND) {\n-\t\tDEBUG((\"got 0x%lx\\n\", key_ptr));\n-\n-\t\t/* fetch the key */\n-\t\tif (fseek(basef, key_ptr, SEEK_SET) != 0) {\n-\t\t\tDEBUG((\"fetch: seek failed\\n\"));\n-\t\t\treturn(output);\n-\t\t}\n-\t\tif (fread(buffer, 1, keysize, basef) != keysize) {\n-\t\t\tDEBUG((\"fetch: read failed\\n\"));\n-\t\t\treturn(output);\n-\t\t}\n-\n-\t\t/* try it */\n-\t\tbuffer[keysize] = '\\0';\t\t/* terminated for DEBUG */\n-\t\t(void) mapcase(buffer, buffer, keysize);\n-\t\tDEBUG((\"fetch: buffer (%s) looking for (%s) size = %d\\n\", \n-\t\t\t\t\t\tbuffer, key.dptr, keysize));\n-\t\tif (memcmp(key.dptr, buffer, cmplen) == 0 &&\n-\t\t\t\t(*sepp == conf.fieldsep || *sepp == '\\0')) {\n-\t\t\t/* we found it */\n-\t\t\toutput.dptr = (char *)&key_ptr;\n-\t\t\toutput.dsize = SOF;\n-\t\t\tDEBUG((\"fetch: successful\\n\"));\n-\t\t\treturn(output);\n-\t\t}\n-\t}\n-\n-\t/* we didn't find it */\n-\tDEBUG((\"fetch: failed\\n\"));\n-\tprevp = &srch;\t\t\t/* remember where we stopped */\n-\treturn(output);\n-}\n-\n-/*\n- - latebase - try to open a base file that wasn't there at the start\n- */\n-static FILE *\n-latebase()\n-{\n-\tregister FILE *it;\n-\n-\tif (basefname == NULL) {\n-\t\tDEBUG((\"latebase: name foulup\\n\"));\n-\t\treturn(NULL);\n-\t}\n-\tit = fopen(basefname, \"r\");\n-\tif (it == NULL) {\n-\t\tDEBUG((\"latebase: still can't open base\\n\"));\n-\t} else {\n-\t\tDEBUG((\"latebase: late open succeeded\\n\"));\n-\t\tfree(basefname);\n-\t\tbasefname = NULL;\n-#ifdef _IOFBF\n-\t\t(void) setvbuf(it, basebuf, _IOFBF, sizeof(basebuf));\n-#endif\n-\t}\n-\treturn(it);\n-}\n-\n-/*\n- - dbzstore - store() with case mapping built in\n- */\n-int\n-dbzstore(key, data)\n-datum key;\n-datum data;\n-{\n-\tchar buffer[DBZMAXKEY + 1];\n-\tdatum mappedkey;\n-\tregister size_t keysize;\n-\n-\tDEBUG((\"dbzstore: (%s)\\n\", key.dptr));\n-\n-\t/* Key is supposed to be less than DBZMAXKEY */\n-\tkeysize = key.dsize;\n-\tif (keysize >= DBZMAXKEY) {\n-\t\tDEBUG((\"dbzstore: key size too big (%d)\\n\", key.dsize));\n-\t\treturn(-1);\n-\t}\n-\n-\tmappedkey.dptr = mapcase(buffer, key.dptr, keysize);\n-\tbuffer[keysize] = '\\0';\t/* just a debug aid */\n-\tmappedkey.dsize = keysize;\n-\n-\treturn(store(mappedkey, data));\n-}\n-\n-/*\n- - store - add an entry to the database\n- */\n-int\t\t\t\t/* 0 success, -1 failure */\n-store(key, data)\n-datum key;\n-datum data;\n-{\n-\toff_t value;\n-\n-\tif (pagf == NULL) {\n-\t\tDEBUG((\"store: database not open!\\n\"));\n-\t\treturn(-1);\n-\t} else if (basef == NULL) {\t/* basef didn't exist yet */\n-\t\tbasef = latebase();\n-\t\tif (basef == NULL)\n-\t\t\treturn(-1);\n-\t}\n-\tif (pagronly) {\n-\t\tDEBUG((\"store: database open read-only\\n\"));\n-\t\treturn(-1);\n-\t}\n-\tif (data.dsize != SOF) {\n-\t\tDEBUG((\"store: value size wrong (%d)\\n\", data.dsize));\n-\t\treturn(-1);\n-\t}\n-\tif (key.dsize >= DBZMAXKEY) {\n-\t\tDEBUG((\"store: key size too big (%d)\\n\", key.dsize));\n-\t\treturn(-1);\n-\t}\n-\n-\t/* copy the value in to ensure alignment */\n-\t(void) memcpy((char *)&value, data.dptr, SOF);\n-\tDEBUG((\"store: (%s, %ld)\\n\", key.dptr, (long)value));\n-\tif (!okayvalue(value)) {\n-\t\tDEBUG((\"store: reserved bit or overflow in 0x%lx\\n\", value));\n-\t\treturn(-1);\n-\t}\n-\n-\t/* find the place, exploiting previous search if possible */\n-\tstart(&srch, &key, prevp);\n-\twhile (search(&srch) != NOTFOUND)\n-\t\tcontinue;\n-\n-\tprevp = FRESH;\n-\tconf.used[0]++;\n-\tDEBUG((\"store: used count %ld\\n\", conf.used[0]));\n-\twritten = 1;\n-\treturn(set(&srch, value));\n-}\n-\n-/*\n- - dbzincore - control attempts to keep .pag file in core\n- */\n-int\t\t\t\t/* old setting */\n-dbzincore(value)\n-int value;\n-{\n-\tregister int old = incore;\n-\n-\tincore = value;\n-\treturn(old);\n-}\n-\n-/*\n- - getconf - get configuration from .dir file\n- */\n-static int\t\t\t/* 0 success, -1 failure */\n-getconf(df, pf, cp)\n-register FILE *df;\t\t/* NULL means just give me the default */\n-register FILE *pf;\t\t/* NULL means don't care about .pag */\n-register struct dbzconfig *cp;\n-{\n-\tregister int c;\n-\tregister int i;\n-\tint err = 0;\n-\n-\tc = (df != NULL) ? getc(df) : EOF;\n-\tif (c == EOF) {\t\t/* empty file, no configuration known */\n-\t\tcp->olddbz = 0;\n-\t\tif (df != NULL && pf != NULL && getc(pf) != EOF)\n-\t\t\tcp->olddbz = 1;\n-\t\tcp->tsize = DEFSIZE;\n-\t\tcp->fieldsep = '\\t';\n-\t\tfor (i = 0; i < NUSEDS; i++)\n-\t\t\tcp->used[i] = 0;\n-\t\tcp->valuesize = SOF;\n-\t\tmybytemap(cp->bytemap);\n-\t\tcp->casemap = DEFCASE;\n-\t\tcp->tagenb = TAGENB;\n-\t\tcp->tagmask = TAGMASK;\n-\t\tcp->tagshift = TAGSHIFT;\n-\t\tDEBUG((\"getconf: defaults (%ld, %c, (0x%lx/0x%lx<<%d))\\n\",\n-\t\t\tcp->tsize, cp->casemap, cp->tagenb, \n-\t\t\tcp->tagmask, cp->tagshift));\n-\t\treturn(0);\n-\t}\n-\t(void) ungetc(c, df);\n-\n-\t/* first line, the vital stuff */\n-\tif (getc(df) != 'd' || getc(df) != 'b' || getc(df) != 'z')\n-\t\terr = -1;\n-\tif (getno(df, &err) != dbzversion)\n-\t\terr = -1;\n-\tcp->tsize = getno(df, &err);\n-\tcp->fieldsep = getno(df, &err);\n-\twhile ((c = getc(df)) == ' ')\n-\t\tcontinue;\n-\tcp->casemap = c;\n-\tcp->tagenb = getno(df, &err);\n-\tcp->tagmask = getno(df, &err);\n-\tcp->tagshift = getno(df, &err);\n-\tcp->valuesize = getno(df, &err);\n-\tif (cp->valuesize != SOF) {\n-\t\tDEBUG((\"getconf: wrong off_t size (%d)\\n\", cp->valuesize));\n-\t\terr = -1;\n-\t\tcp->valuesize = SOF;\t/* to protect the loops below */\n-\t}\n-\tfor (i = 0; i < cp->valuesize; i++)\n-\t\tcp->bytemap[i] = getno(df, &err);\n-\tif (getc(df) != '\\n')\n-\t\terr = -1;\n-\tDEBUG((\"size %ld, sep %d, cmap %c, tags 0x%lx/0x%lx<<%d, \", cp->tsize,\n-\t\t\tcp->fieldsep, cp->casemap, cp->tagenb, cp->tagmask,\n-\t\t\tcp->tagshift));\n-\tDEBUG((\"bytemap (%d)\", cp->valuesize));\n-\tfor (i = 0; i < cp->valuesize; i++) {\n-\t\tDEBUG((\" %d\", cp->bytemap[i]));\n-\t}\n-\tDEBUG((\"\\n\"));\n-\n-\t/* second line, the usages */\n-\tfor (i = 0; i < NUSEDS; i++)\n-\t\tcp->used[i] = getno(df, &err);\n-\tif (getc(df) != '\\n')\n-\t\terr = -1;\n-\tDEBUG((\"used %ld %ld %ld...\\n\", cp->used[0], cp->used[1], cp->used[2]));\n-\n-\tif (err < 0) {\n-\t\tDEBUG((\"getconf error\\n\"));\n-\t\treturn(-1);\n-\t}\n-\treturn(0);\n-}\n-\n-/*\n- - getno - get a long\n- */\n-static long\n-getno(f, ep)\n-FILE *f;\n-int *ep;\n-{\n-\tregister char *p;\n-#\tdefine\tMAXN\t50\n-\tchar getbuf[MAXN];\n-\tregister int c;\n-\n-\twhile ((c = getc(f)) == ' ')\n-\t\tcontinue;\n-\tif (c == EOF || c == '\\n') {\n-\t\tDEBUG((\"getno: missing number\\n\"));\n-\t\t*ep = -1;\n-\t\treturn(0);\n-\t}\n-\tp = getbuf;\n-\t*p++ = c;\n-\twhile ((c = getc(f)) != EOF && c != '\\n' && c != ' ')\n-\t\tif (p < &getbuf[MAXN-1])\n-\t\t\t*p++ = c;\n-\tif (c == EOF) {\n-\t\tDEBUG((\"getno: EOF\\n\"));\n-\t\t*ep = -1;\n-\t} else\n-\t\t(void) ungetc(c, f);\n-\t*p = '\\0';\n-\n-\tif (strspn(getbuf, \"-1234567890\") != strlen(getbuf)) {\n-\t\tDEBUG((\"getno: `%s' non-numeric\\n\", getbuf));\n-\t\t*ep = -1;\n-\t}\n-\treturn(atol(getbuf));\n-}\n-\n-/*\n- - putconf - write configuration to .dir file\n- */\n-static int\t\t\t/* 0 success, -1 failure */\n-putconf(f, cp)\n-register FILE *f;\n-register struct dbzconfig *cp;\n-{\n-\tregister int i;\n-\tregister int ret = 0;\n-\n-\tif (fseek(f, 0, SEEK_SET) != 0) {\n-\t\tDEBUG((\"fseek failure in putconf\\n\"));\n-\t\tret = -1;\n-\t}\n-\tfprintf(f, \"dbz %d %ld %d %c %ld %ld %d %d\", dbzversion,\n-\t\t(long)cp->tsize,\n-\t\tcp->fieldsep, cp->casemap, (long)cp->tagenb,\n-\t\t(long)cp->tagmask, cp->tagshift,\n-\t\tcp->valuesize);\n-\n-\tfor (i = 0; i < cp->valuesize; i++)\n-\t\tfprintf(f, \" %d\", cp->bytemap[i]);\n-\tfprintf(f, \"\\n\");\n-\tfor (i = 0; i < NUSEDS; i++)\n-\t\tfprintf(f, \"%ld%c\",\n-\t\t\t(long)cp->used[i], (i < NUSEDS-1) ? ' ' : '\\n');\n-\n-\n-\t(void) fflush(f);\n-\tif (ferror(f))\n-\t\tret = -1;\n-\n-\tDEBUG((\"putconf status %d\\n\", ret));\n-\treturn(ret);\n-}\n-\n-/*\n- - getcore - try to set up an in-core copy of .pag file\n- */\n-static off_t *\t\t\t/* pointer to copy, or NULL */\n-getcore(f)\n-FILE *f;\n-{\n-\tregister off_t *p;\n-\tregister size_t i;\n-\tregister size_t nread;\n-\tregister char *it;\n-\n-\tit = malloc((size_t)conf.tsize * SOF);\n-\tif (it == NULL) {\n-\t\tDEBUG((\"getcore: malloc failed\\n\"));\n-\t\treturn(NULL);\n-\t}\n-\n-\tnread = fread(it, SOF, (size_t)conf.tsize, f);\n-\tif (ferror(f)) {\n-\t\tDEBUG((\"getcore: read failed\\n\"));\n-\t\tfree(it);\n-\t\treturn(NULL);\n-\t}\n-\n-\tp = (off_t *)it + nread;\n-\ti = (size_t)conf.tsize - nread;\n-\twhile (i-- > 0)\n-\t\t*p++ = VACANT;\n-\treturn((off_t *)it);\n-}\n-\n-/*\n- - putcore - try to rewrite an in-core table\n- */\n-static int\t\t\t/* 0 okay, -1 fail */\n-putcore(tab, f)\n-off_t *tab;\n-FILE *f;\n-{\n-\tif (fseek(f, 0, SEEK_SET) != 0) {\n-\t\tDEBUG((\"fseek failure in putcore\\n\"));\n-\t\treturn(-1);\n-\t}\n-\t(void) fwrite((char *)tab, SOF, (size_t)conf.tsize, f);\n-\t(void) fflush(f);\n-\treturn((ferror(f)) ? -1 : 0);\n-}\n-\n-/*\n- - start - set up to start or restart a search\n- */\n-static void\n-start(sp, kp, osp)\n-register struct searcher *sp;\n-register datum *kp;\n-register struct searcher *osp;\t\t/* may be FRESH, i.e. NULL */\n-{\n-\tregister long h;\n-\n-\th = hash(kp->dptr, kp->dsize);\n-\tif (osp != FRESH && osp->hash == h) {\n-\t\tif (sp != osp)\n-\t\t\t*sp = *osp;\n-\t\tDEBUG((\"search restarted\\n\"));\n-\t} else {\n-\t\tsp->hash = h;\n-\t\tsp->tag = MKTAG(h / conf.tsize);\n-\t\tDEBUG((\"tag 0x%lx\\n\", sp->tag));\n-\t\tsp->place = h % conf.tsize;\n-\t\tsp->tabno = 0;\n-\t\tsp->run = (conf.olddbz) ? conf.tsize : MAXRUN;\n-\t\tsp->aborted = 0;\n-\t}\n-\tsp->seen = 0;\n-}\n-\n-/*\n- - search - conduct part of a search\n- */\n-static off_t\t\t\t/* NOTFOUND if we hit VACANT or error */\n-search(sp)\n-register struct searcher *sp;\n-{\n-\tregister off_t dest;\n-\tregister off_t value;\n-\toff_t val;\t\t/* buffer for value (can't fread register) */\n-\tregister off_t place;\n-\n-\tif (sp->aborted)\n-\t\treturn(NOTFOUND);\n-\n-\tfor (;;) {\n-\t\t/* determine location to be examined */\n-\t\tplace = sp->place;\n-\t\tif (sp->seen) {\n-\t\t\t/* go to next location */\n-\t\t\tif (--sp->run <= 0) {\n-\t\t\t\tsp->tabno++;\n-\t\t\t\tsp->run = MAXRUN;\n-\t\t\t}\n-\t\t\tplace = (place+1)%conf.tsize + sp->tabno*conf.tsize;\n-\t\t\tsp->place = place;\n-\t\t} else\n-\t\t\tsp->seen = 1;\t/* now looking at current location */\n-\t\tDEBUG((\"search @ %ld\\n\", place));\n-\n-\t\t/* get the tagged value */\n-\t\tif (corepag != NULL && place < conf.tsize) {\n-\t\t\tDEBUG((\"search: in core\\n\"));\n-\t\t\tvalue = MAPIN(corepag[place]);\n-\t\t} else {\n-\t\t\t/* seek, if necessary */\n-\t\t\tdest = place * SOF;\n-\t\t\tif (pagpos != dest) {\n-\t\t\t\tif (fseek(pagf, dest, SEEK_SET) != 0) {\n-\t\t\t\t\tDEBUG((\"search: seek failed\\n\"));\n-\t\t\t\t\tpagpos = -1;\n-\t\t\t\t\tsp->aborted = 1;\n-\t\t\t\t\treturn(NOTFOUND);\n-\t\t\t\t}\n-\t\t\t\tpagpos = dest;\n-\t\t\t}\n-\n-\t\t\t/* read it */\n-\t\t\tif (fread((char *)&val, sizeof(val), 1, pagf) == 1)\n-\t\t\t\tvalue = MAPIN(val);\n-\t\t\telse if (ferror(pagf)) {\n-\t\t\t\tDEBUG((\"search: read failed\\n\"));\n-\t\t\t\tpagpos = -1;\n-\t\t\t\tsp->aborted = 1;\n-\t\t\t\treturn(NOTFOUND);\n-\t\t\t} else\n-\t\t\t\tvalue = VACANT;\n-\n-\t\t\t/* and finish up */\n-\t\t\tpagpos += sizeof(val);\n-\t\t}\n-\n-\t\t/* vacant slot is always cause to return */\n-\t\tif (value == VACANT) {\n-\t\t\tDEBUG((\"search: empty slot\\n\"));\n-\t\t\treturn(NOTFOUND);\n-\t\t};\n-\n-\t\t/* check the tag */\n-\t\tvalue = UNBIAS(value);\n-\t\tDEBUG((\"got 0x%lx\\n\", value));\n-\t\tif (!HASTAG(value)) {\n-\t\t\tDEBUG((\"tagless\\n\"));\n-\t\t\treturn(value);\n-\t\t} else if (TAG(value) == sp->tag) {\n-\t\t\tDEBUG((\"match\\n\"));\n-\t\t\treturn(NOTAG(value));\n-\t\t} else {\n-\t\t\tDEBUG((\"mismatch 0x%lx\\n\", TAG(value)));\n-\t\t}\n-\t}\n-\t/* NOTREACHED */\n-}\n-\n-/*\n- - okayvalue - check that a value can be stored\n- */\n-static int\t\t\t/* predicate */\n-okayvalue(value)\n-off_t value;\n-{\n-\tif (HASTAG(value))\n-\t\treturn(0);\n-#ifdef OVERFLOW\n-\tif (value == LONG_MAX)\t/* BIAS() and UNBIAS() will overflow */\n-\t\treturn(0);\n-#endif\n-\treturn(1);\n-}\n-\n-/*\n- - set - store a value into a location previously found by search\n- */\n-static int\t\t\t/* 0 success, -1 failure */\n-set(sp, value)\n-register struct searcher *sp;\n-off_t value;\n-{\n-\tregister off_t place = sp->place;\n-\tregister off_t v = value;\n-\n-\tif (sp->aborted)\n-\t\treturn(-1);\n-\n-\tif (CANTAG(v) && !conf.olddbz) {\n-\t\tv |= sp->tag | taghere;\n-\t\tif (v != UNBIAS(VACANT))\t/* BIAS(v) won't look VACANT */\n-#ifdef OVERFLOW\n-\t\t\tif (v != LONG_MAX)\t/* and it won't overflow */\n-#endif\n-\t\t\tvalue = v;\n-\t}\n-\tDEBUG((\"tagged value is 0x%lx\\n\", value));\n-\tvalue = BIAS(value);\n-\tvalue = MAPOUT(value);\n-\n-\t/* If we have the index file in memory, use it */\n-\tif (corepag != NULL && place < conf.tsize) {\n-\t\tcorepag[place] = value;\n-\t\tDEBUG((\"set: incore\\n\"));\n-\t\treturn(0);\n-\t}\n-\n-\t/* seek to spot */\n-\tpagpos = -1;\t\t/* invalidate position memory */\n-\tif (fseek(pagf, place * SOF, SEEK_SET) != 0) {\n-\t\tDEBUG((\"set: seek failed\\n\"));\n-\t\tsp->aborted = 1;\n-\t\treturn(-1);\n-\t}\n-\n-\t/* write in data */\n-\tif (fwrite((char *)&value, SOF, 1, pagf) != 1) {\n-\t\tDEBUG((\"set: write failed\\n\"));\n-\t\tsp->aborted = 1;\n-\t\treturn(-1);\n-\t}\n-\t/* fflush improves robustness, and buffer re-use is rare anyway */\n-\tif (fflush(pagf) == EOF) {\n-\t\tDEBUG((\"set: fflush failed\\n\"));\n-\t\tsp->aborted = 1;\n-\t\treturn(-1);\n-\t}\n-\n-\tDEBUG((\"set: succeeded\\n\"));\n-\treturn(0);\n-}\n-\n-/*\n- - mybytemap - determine this machine's byte map\n- *\n- * A byte map is an array of ints, sizeof(off_t) of them.  The 0th int\n- * is the byte number of the high-order byte in my off_t, and so forth.\n- */\n-static void\n-mybytemap(map)\n-int map[];\t\t\t/* -> int[SOF] */\n-{\n-\tunion {\n-\t\toff_t o;\n-\t\tchar c[SOF];\n-\t} u;\n-\tregister int *mp = &map[SOF];\n-\tregister int ntodo;\n-\tregister int i;\n-\n-\tu.o = 1;\n-\tfor (ntodo = (int)SOF; ntodo > 0; ntodo--) {\n-\t\tfor (i = 0; i < SOF; i++)\n-\t\t\tif (u.c[i] != 0)\n-\t\t\t\tbreak;\n-\t\tif (i == SOF) {\n-\t\t\t/* trouble -- set it to *something* consistent */\n-\t\t\tDEBUG((\"mybytemap: nonexistent byte %d!!!\\n\", ntodo));\n-\t\t\tfor (i = 0; i < SOF; i++)\n-\t\t\t\tmap[i] = i;\n-\t\t\treturn;\n-\t\t}\n-\t\tDEBUG((\"mybytemap: byte %d\\n\", i));\n-\t\t*--mp = i;\n-\t\twhile (u.c[i] != 0)\n-\t\t\tu.o <<= 1;\n-\t}\n-}\n-\n-/*\n- - bytemap - transform an off_t from byte ordering map1 to map2\n- */\n-static off_t\t\t\t/* transformed result */\n-bytemap(ino, map1, map2)\n-off_t ino;\n-int *map1;\n-int *map2;\n-{\n-\tunion oc {\n-\t\toff_t o;\n-\t\tchar c[SOF];\n-\t};\n-\tunion oc in;\n-\tunion oc out;\n-\tregister int i;\n-\n-\tin.o = ino;\n-\tfor (i = 0; i < SOF; i++)\n-\t\tout.c[map2[i]] = in.c[map1[i]];\n-\treturn(out.o);\n-}\n-\n-/*\n- * This is a simplified version of the pathalias hashing function.\n- * Thanks to Steve Belovin and Peter Honeyman\n- *\n- * hash a string into a long int.  31 bit crc (from andrew appel).\n- * the crc table is computed at run time by crcinit() -- we could\n- * precompute, but it takes 1 clock tick on a 750.\n- *\n- * This fast table calculation works only if POLY is a prime polynomial\n- * in the field of integers modulo 2.  Since the coefficients of a\n- * 32-bit polynomial won't fit in a 32-bit word, the high-order bit is\n- * implicit.  IT MUST ALSO BE THE CASE that the coefficients of orders\n- * 31 down to 25 are zero.  Happily, we have candidates, from\n- * E. J.  Watson, \"Primitive Polynomials (Mod 2)\", Math. Comp. 16 (1962):\n- *\tx^32 + x^7 + x^5 + x^3 + x^2 + x^1 + x^0\n- *\tx^31 + x^3 + x^0\n- *\n- * We reverse the bits to get:\n- *\t111101010000000000000000000000001 but drop the last 1\n- *         f   5   0   0   0   0   0   0\n- *\t010010000000000000000000000000001 ditto, for 31-bit crc\n- *\t   4   8   0   0   0   0   0   0\n- */\n-\n-#define POLY 0x48000000L\t/* 31-bit polynomial (avoids sign problems) */\n-\n-static long CrcTable[128];\n-\n-/*\n- - crcinit - initialize tables for hash function\n- */\n-static void\n-crcinit()\n-{\n-\tregister int i, j;\n-\tregister long sum;\n-\n-\tfor (i = 0; i < 128; ++i) {\n-\t\tsum = 0L;\n-\t\tfor (j = 7 - 1; j >= 0; --j)\n-\t\t\tif (i & (1 << j))\n-\t\t\t\tsum ^= POLY >> j;\n-\t\tCrcTable[i] = sum;\n-\t}\n-\tDEBUG((\"crcinit: done\\n\"));\n-}\n-\n-/*\n- - hash - Honeyman's nice hashing function\n- */\n-static long\n-hash(name, size)\n-register char *name;\n-register int size;\n-{\n-\tregister long sum = 0L;\n-\n-\twhile (size--) {\n-\t\tsum = (sum >> 7) ^ CrcTable[(sum ^ (*name++)) & 0x7f];\n-\t}\n-\tDEBUG((\"hash: returns (%ld)\\n\", sum));\n-\treturn(sum);\n-}\n-\n-/*\n- * case-mapping stuff\n- *\n- * Borrowed from C News, by permission of the authors.  Somewhat modified.\n- *\n- * We exploit the fact that we are dealing only with headers here, and\n- * headers are limited to the ASCII characters by RFC822.  It is barely\n- * possible that we might be dealing with a translation into another\n- * character set, but in particular it's very unlikely for a header\n- * character to be outside -128..255.\n- *\n- * Life would be a whole lot simpler if tolower() could safely and portably\n- * be applied to any char.\n- */\n-\n-#define\tOFFSET\t128\t\t/* avoid trouble with negative chars */\n-\n-/* must call casencmp before invoking TOLOW... */\n-#define\tTOLOW(c)\t(cmap[(c)+OFFSET])\n-\n-/* ...but the use of it in CISTREQN is safe without the preliminary call (!) */\n-/* CISTREQN is an optimised case-insensitive strncmp(a,b,n)==0; n > 0 */\n-#define CISTREQN(a, b, n) \\\n-\t(TOLOW((a)[0]) == TOLOW((b)[0]) && casencmp(a, b, n) == 0)\n-\n-#define\tMAPSIZE\t(256+OFFSET)\n-static char cmap[MAPSIZE];\t/* relies on init to '\\0' */\n-static int mprimed = 0;\t\t/* has cmap been set up? */\n-\n-/*\n- - mapprime - set up case-mapping stuff\n- */\n-static void\n-mapprime()\n-{\n-\tregister char *lp;\n-\tregister char *up;\n-\tregister int c;\n-\tregister int i;\n-\tstatic char lower[] = \"abcdefghijklmnopqrstuvwxyz\";\n-\tstatic char upper[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n-\n-\tfor (lp = lower, up = upper; *lp != '\\0'; lp++, up++) {\n-\t\tc = *lp;\n-\t\tcmap[c+OFFSET] = c;\n-\t\tcmap[*up+OFFSET] = c;\n-\t}\n-\tfor (i = 0; i < MAPSIZE; i++)\n-\t\tif (cmap[i] == '\\0')\n-\t\t\tcmap[i] = (char)(i-OFFSET);\n-\tmprimed = 1;\n-}\n-\n-/*\n- - casencmp - case-independent strncmp\n- */\n-static int\t\t\t/* < == > 0 */\n-casencmp(s1, s2, len)\n-char *s1;\n-char *s2;\n-int len;\n-{\n-\tregister char *p1;\n-\tregister char *p2;\n-\tregister int n;\n-\n-\tif (!mprimed)\n-\t\tmapprime();\n-\n-\tp1 = s1;\n-\tp2 = s2;\n-\tn = len;\n-\twhile (--n >= 0 && *p1 != '\\0' && TOLOW(*p1) == TOLOW(*p2)) {\n-\t\tp1++;\n-\t\tp2++;\n-\t}\n-\tif (n < 0)\n-\t\treturn(0);\n-\n-\t/*\n-\t * The following case analysis is necessary so that characters\n-\t * which look negative collate low against normal characters but\n-\t * high against the end-of-string NUL.\n-\t */\n-\tif (*p1 == '\\0' && *p2 == '\\0')\n-\t\treturn(0);\n-\telse if (*p1 == '\\0')\n-\t\treturn(-1);\n-\telse if (*p2 == '\\0')\n-\t\treturn(1);\n-\telse\n-\t\treturn(TOLOW(*p1) - TOLOW(*p2));\n-}\n-\n-/*\n- - mapcase - do case-mapped copy\n- */\n-static char *\t\t\t/* returns src or dst */\n-mapcase(dst, src, siz)\n-char *dst;\t\t\t/* destination, used only if mapping needed */\n-char *src;\t\t\t/* source; src == dst is legal */\n-size_t siz;\n-{\n-\tregister char *s;\n-\tregister char *d;\n-\tregister char *c;\t/* case break */\n-\tregister char *e;\t/* end of source */\n-\n-\n-\tc = cipoint(src, siz);\n-\tif (c == NULL)\n-\t\treturn(src);\n-\n-\tif (!mprimed)\n-\t\tmapprime();\n-\ts = src;\n-\te = s + siz;\n-\td = dst;\n-\n-\twhile (s < c)\n-\t\t*d++ = *s++;\n-\twhile (s < e)\n-\t\t*d++ = TOLOW(*s++);\n-\n-\treturn(dst);\n-}\n-\n-/*\n- - cipoint - where in this message-ID does it become case-insensitive?\n- *\n- * The RFC822 code is not quite complete.  Absolute, total, full RFC822\n- * compliance requires a horrible parsing job, because of the arcane\n- * quoting conventions -- abc\"def\"ghi is not equivalent to abc\"DEF\"ghi,\n- * for example.  There are three or four things that might occur in the\n- * domain part of a message-id that are case-sensitive.  They don't seem\n- * to ever occur in real news, thank Cthulhu.  (What?  You were expecting\n- * a merciful and forgiving deity to be invoked in connection with RFC822?\n- * Forget it; none of them would come near it.)\n- */\n-static char *\t\t\t/* pointer into s, or NULL for \"nowhere\" */\n-cipoint(s, siz)\n-char *s;\n-size_t siz;\n-{\n-\tregister char *p;\n-\tstatic char post[] = \"postmaster\";\n-\tstatic int plen = sizeof(post)-1;\n-\n-\tswitch (conf.casemap) {\n-\tcase '0':\t\t/* unmapped, sensible */\n-\t\treturn(NULL);\n-\t\tbreak;\n-\tcase 'C':\t\t/* C News, RFC 822 conformant (approx.) */\n-\t\tp = memchr(s, '@', siz);\n-\t\tif (p == NULL)\t\t\t/* no local/domain split */\n-\t\t\treturn(NULL);\t\t/* assume all local */\n-\t\telse if\t(p - (s+1) == plen && CISTREQN(s+1, post, plen)) {\n-\t\t\t/* crazy -- \"postmaster\" is case-insensitive */\n-\t\t\treturn(s);\n-\t\t} else\n-\t\t\treturn(p);\n-\t\tbreak;\n-\tcase '=':\t\t/* 2.11, neither sensible nor conformant */\n-\t\treturn(s);\t/* all case-insensitive */\n-\t\tbreak;\n-\t}\n-\n-\tDEBUG((\"cipoint: unknown case mapping `%c'\\n\", conf.casemap));\n-\treturn(NULL);\t\t/* just leave it alone */\n-}\n-\n-/*\n- - dbzdebug - control dbz debugging at run time\n- */\n-int\t\t\t\t/* old value */\n-dbzdebug(value)\n-int value;\n-{\n-#ifdef DBZDEBUG\n-\tregister int old = debug;\n-\n-\tdebug = value;\n-\treturn(old);\n-#else\n-\treturn(-1);\n-#endif\n-}"}, {"sha": "3d7e8ed702cb06c59cf6606fdc0015a5c46df723", "filename": "libio/dbz/dbz.h", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fdbz.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fdbz.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Fdbz.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,32 +0,0 @@\n-/* for dbm and dbz */\n-typedef struct {\n-\tchar *dptr;\n-\tint dsize;\n-} datum;\n-\n-/* standard dbm functions */\n-extern int dbminit();\n-extern datum fetch();\n-extern int store();\n-extern int delete();\t\t/* not in dbz */\n-extern datum firstkey();\t/* not in dbz */\n-extern datum nextkey();\t\t/* not in dbz */\n-extern int dbmclose();\t\t/* in dbz, but not in old dbm */\n-\n-/* new stuff for dbz */\n-extern int dbzfresh();\n-extern int dbzagain();\n-extern datum dbzfetch();\n-extern int dbzstore();\n-extern int dbzsync();\n-extern long dbzsize();\n-extern int dbzincore();\n-extern int dbzcancel();\n-extern int dbzdebug();\n-\n-/*\n- * In principle we could handle unlimited-length keys by operating a chunk\n- * at a time, but it's not worth it in practice.  Setting a nice large\n- * bound on them simplifies the code and doesn't hurt anything.\n- */\n-#define DBZMAXKEY\t255"}, {"sha": "f03ed59f5f47afdbbffa246e267e2703a09f6401", "filename": "libio/dbz/dbzmain.c", "status": "removed", "additions": 0, "deletions": 514, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fdbzmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fdbzmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Fdbzmain.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,514 +0,0 @@\n-/*\n- * dbz - use and test dbz in various ways\n- *\n- * -Log-\n- */\n-\n-#include <stdio.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <string.h>\n-#include <stdlib.h>\n-#include <dbz.h>\n-\n-#ifdef FUNNYSEEKS\n-#include <unistd.h>\n-#else\n-#define\tSEEK_SET\t0\n-#endif\n-\n-#define\tSTREQ(a, b)\t(*(a) == *(b) && strcmp((a), (b)) == 0)\n-\n-char *progname;\n-\n-char *inname = \"(no file)\";\t\t/* filename for messages etc. */\n-long lineno;\t\t\t\t/* line number for messages etc. */\n-\n-char *my_basename;\n-char *pagname;\n-char *dir_name;\n-char *str2dup();\n-FILE *base;\n-\n-int op = 'b';\t\t\t/* what to do, default build a new table */\n-int baseinput = 1;\t\t/* is the base file also the input? */\n-\n-char *from = NULL;\t\t/* old table to use for dbzagain() */\n-int omitzero = 0;\t\t/* omit lines tagged with 0 */\n-long every = 0;\t\t\t/* report every n lines */\n-int syncs = 0;\t\t\t/* dbzsync() on each report */\n-int quick = 0;\t\t\t/* quick checking, not too thorough */\n-int sweep = 0;\t\t\t/* sweep file checking all offsets */\n-int useincore = 1;\t\t/* should we use incore facility? */\n-long xxx = 0;\t\t\t/* debugging variable */\n-int printx = 0;\t\t\t/* print xxx after all is done */\n-int unique = 1;\t\t\t/* before store(), check with fetch() */\n-int usefresh = 0;\t\t/* use dbzfresh? */\n-long siz = 0;\t\t\t/* -p size */\n-char map = 'C';\t\t\t/* -p map */\n-long tag = 0;\t\t\t/* -p tag mask */\n-int exact = 0;\t\t\t/* do not run dbzsize(siz) */\n-int dbzint = 1;\t\t\t/* use new interface? */\n-char fs = '\\t';\t\t\t/* field separator, default tab */\n-int unopen = 0;\t\t\t/* make base unopenable during dbminit? */\n-char *change = NULL;\t\t/* chdir here before dbmclose */\n-\n-#define\tDEFBUF\t1024\t\t/* default line-buffer size */\n-int buflen = DEFBUF;\t\t/* line length limit */\n-char lbuf[DEFBUF];\n-char *line = lbuf;\n-char cbuf[DEFBUF];\n-char *cmp = cbuf;\n-\n-void fail();\n-void dofile();\n-void runs();\n-void dosweep();\n-void mkfiles();\n-void crfile();\n-void doline();\n-void process();\n-\n-#ifdef HAVERFCIZE\n-extern char *rfc822ize();\n-#else\n-#define\trfc822ize(n)\t(n)\n-#endif\n-\n-/*\n- - main - parse arguments and handle options\n- */\n-int\n-main(argc, argv)\n-int argc;\n-char *argv[];\n-{\n-\tint c;\n-\tint errflg = 0;\n-\textern int optind;\n-\textern char *optarg;\n-\tint doruns = 0;\n-\textern long atol();\n-\n-\tprogname = argv[0];\n-\n-\twhile ((c = getopt(argc, argv, \"axcmt:l:R0E:SqOiX:Yuf:p:eMUC:d\")) != EOF)\n-\t\tswitch (c) {\n-\t\tcase 'a':\t/* append to existing table */\n-\t\t\tif (op != 'b')\n-\t\t\t\tfail(\"only one of -a -x -c -m can be given\", \"\");\n-\t\t\top = 'a';\n-\t\t\tbaseinput = 0;\n-\t\t\tbreak;\n-\t\tcase 'x':\t/* extract from existing table */\n-\t\t\tif (op != 'b')\n-\t\t\t\tfail(\"only one of -a -x -c -m can be given\", \"\");\n-\t\t\top = 'x';\n-\t\t\tbaseinput = 0;\n-\t\t\tbreak;\n-\t\tcase 'c':\t/* check existing table */\n-\t\t\tif (op != 'b')\n-\t\t\t\tfail(\"only one of -a -x -c -m can be given\", \"\");\n-\t\t\top = 'c';\n-\t\t\tbreak;\n-\t\tcase 'm':\t/* extract missing (complement of -x) */\n-\t\t\tif (op != 'b')\n-\t\t\t\tfail(\"only one of -a -x -c -m can be given\", \"\");\n-\t\t\top = 'm';\n-\t\t\tbaseinput = 0;\n-\t\t\tbreak;\n-\t\tcase 't':\t/* set field separator */\n-\t\t\tif (strlen(optarg) > 1)\n-\t\t\t\tfail(\"only one field separator allowed\", \"\");\n-\t\t\tfs = *optarg;\n-\t\t\tbreak;\n-\t\tcase 'l':\t/* override line-length limit */\n-\t\t\tbuflen = atoi(optarg) + 1;\n-\t\t\tif (buflen <= 2)\n-\t\t\t\tfail(\"bad -l value `%s'\", optarg);\n-\t\t\tline = malloc(buflen);\n-\t\t\tcmp = malloc(buflen);\n-\t\t\tif (line == NULL || cmp == NULL)\n-\t\t\t\tfail(\"cannot allocate %s-byte buffers\", optarg);\n-\t\t\tbreak;\n-\t\tcase 'R':\t/* print run statistics */\n-\t\t\tdoruns = 1;\n-\t\t\tbreak;\n-\t\tcase '0':\t/* omit lines tagged (by fake -t) with 0 */\n-\t\t\tomitzero = 1;\n-\t\t\tbreak;\n-\t\tcase 'E':\t/* report every n items */\n-\t\t\tevery = atol(optarg);\n-\t\t\tbreak;\n-\t\tcase 'S':\t/* dbzsync() on each -E report */\n-\t\t\tsyncs = 1;\n-\t\t\tbreak;\n-\t\tcase 'q':\t/* quick check or extract */\n-\t\t\tquick = 1;\n-\t\t\tbreak;\n-\t\tcase 'O':\t/* sweep file checking all offsets */\n-\t\t\tsweep = 1;\n-\t\t\tbreak;\n-\t\tcase 'i':\t/* don't use incore */\n-\t\t\tuseincore = 0;\n-\t\t\tbreak;\n-\t\tcase 'X':\t/* set xxx */\n-\t\t\txxx = atoi(optarg);\n-\t\t\tbreak;\n-\t\tcase 'Y':\t/* print xxx afterward */\n-\t\t\tprintx = 1;\n-\t\t\tbreak;\n-\t\tcase 'u':\t/* don't check uniqueness */\n-\t\t\tunique = 0;\n-\t\t\tbreak;\n-\t\tcase 'f':\t/* init from existing table's parameters */\n-\t\t\tfrom = optarg;\n-\t\t\tbreak;\n-\t\tcase 'p':\t/* parameters for dbzfresh */\n-\t\t\tif (sscanf(optarg, \"%ld %1s %lx\", &siz, &map, &tag) != 3) {\n-\t\t\t\tmap = '?';\n-\t\t\t\ttag = 0;\n-\t\t\t\tif (sscanf(optarg, \"%ld\", &siz) != 1)\n-\t\t\t\t\tfail(\"bad -n value `%s'\", optarg);\n-\t\t\t}\n-\t\t\tusefresh = 1;\n-\t\t\tbreak;\n-\t\tcase 'e':\t/* -p size is exact, don't dbzsize() it */\n-\t\t\texact = 1;\n-\t\t\tbreak;\n-\t\tcase 'M':\t/* use old dbm interface + rfc822ize */\n-\t\t\tdbzint = 0;\n-\t\t\tbreak;\n-\t\tcase 'U':\t/* make base unopenable during init */\n-\t\t\tunopen = 1;\n-\t\t\tbreak;\n-\t\tcase 'C':\t/* change directories before dbmclose */\n-\t\t\tchange = optarg;\n-\t\t\tbreak;\n-\t\tcase 'd':\t/* Debugging. */\n-\t\t\tif (dbzdebug(1) < 0)\n-\t\t\t\tfail(\"dbz debugging not available\", \"\");\n-\t\t\tbreak;\n-\t\tcase '?':\n-\t\tdefault:\n-\t\t\terrflg++;\n-\t\t\tbreak;\n-\t\t}\n-\tif (errflg || optind >= argc || (optind+1 < argc && baseinput)) {\n-\t\tfprintf(stderr, \"usage: %s \", progname);\n-\t\tfprintf(stderr, \"[-a] [-x] [-c] database [file] ...\\n\");\n-\t\texit(2);\n-\t}\n-\n-\t(void) dbzincore(useincore);\n-\tmy_basename = argv[optind];\n-\tpagname = str2dup(my_basename, \".pag\");\n-\tdir_name = str2dup(my_basename, \".dir\");\n-\tmkfiles();\n-\toptind++;\n-\n-\tif (baseinput)\t\t/* implies no further arguments */\n-\t\tprocess(base, my_basename);\n-\telse if (optind >= argc)\n-\t\tprocess(stdin, \"stdin\");\n-\telse\n-\t\tfor (; optind < argc; optind++)\n-\t\t\tdofile(argv[optind]);\n-\n-\tif (change != NULL)\n-\t\t(void) chdir(change);\n-\tif (dbmclose() < 0)\n-\t\tfail(\"dbmclose failed\", \"\");\n-\tif (doruns)\n-\t\truns(pagname);\n-\tif (sweep)\n-\t\tdosweep(my_basename, pagname);\n-\tif (printx)\n-\t\tprintf(\"%ld\\n\", xxx);\n-#ifdef DBZ_FINISH\n-\tDBZ_FINISH;\n-#endif\n-\texit(0);\n-}\n-\n-/*\n- - dofile - open a file and invoke process()\n- */\n-void\n-dofile(name)\n-char *name;\n-{\n-\tregister FILE *in;\n-\n-\tif (STREQ(name, \"-\"))\n-\t\tprocess(stdin, \"-\");\n-\telse {\n-\t\tin = fopen(name, \"r\");\n-\t\tif (in == NULL)\n-\t\t\tfail(\"cannot open `%s'\", name);\n-\t\tprocess(in, name);\n-\t\t(void) fclose(in);\n-\t}\n-}\n-\n-/*\n- - mkfiles - create empty files and open them up\n- */\n-void\n-mkfiles()\n-{\n-\tif (op == 'b' && !dbzint) {\n-\t\tcrfile(dir_name);\n-\t\tcrfile(pagname);\n-\t}\n-\n-\tbase = fopen(my_basename, (op == 'a') ? \"a\" : \"r\");\n-\tif (base == NULL)\n-\t\tfail(\"cannot open `%s'\", my_basename);\n-\tif (unopen)\n-\t\t(void) chmod(my_basename, 0);\n-\tif (from != NULL) {\n-\t\tif (dbzagain(my_basename, from) < 0)\n-\t\t\tfail(\"dbzagain(`%s'...) failed\", my_basename);\n-\t} else if (op == 'b' && dbzint) {\n-\t\tif (!exact)\n-\t\t\tsiz = dbzsize(siz);\n-\t\tif (dbzfresh(my_basename, siz, (int)fs, map, (off_t)tag) < 0)\n-\t\t\tfail(\"dbzfresh(`%s'...) failed\", my_basename);\n-\t} else if (dbminit(my_basename) < 0)\n-\t\tfail(\"dbminit(`%s') failed\", my_basename);\n-\tif (unopen)\n-\t\t(void) chmod(my_basename, 0600);\t/* hard to restore original */\n-}\n-\n-/*\n- - crfile - create a file\n- */\n-void\n-crfile(name)\n-char *name;\n-{\n-\tregister int f;\n-\n-\tf = creat(name, 0666);\n-\tif (f < 0)\n-\t\tfail(\"cannot create `%s'\", name);\n-\t(void) close(f);\n-}\n-\n-/*\n- - process - process input file\n- */\n-void\n-process(in, name)\n-FILE *in;\n-char *name;\n-{\n-\tregister off_t place;\n-\n-\tinname = name;\n-\tlineno = 0;\n-\n-\tfor (;;) {\n-\t\tplace = ftell(in);\n-\t\tif (fgets(line, buflen, in) == NULL)\n-\t\t\treturn;\n-\t\tlineno++;\n-\t\tif (every > 0 && lineno%every == 0) {\n-\t\t\tfprintf(stderr, \"%ld\\n\", lineno);\n-\t\t\tif (dbzsync() < 0)\n-\t\t\t\tfail(\"dbzsync failed\", \"\");\n-\t\t}\n-\t\tdoline(line, place);\n-\t}\n-\t/* NOTREACHED */\n-}\n-\n-/*\n- - doline - process input line\n- */\n-void\n-doline(lp, inoffset)\n-char *lp;\n-off_t inoffset;\n-{\n-\tregister char *p;\n-\tregister char pc;\n-\tdatum key, value;\n-\toff_t place = inoffset;\n-\tregister int shouldfind;\n-\tregister int llen;\n-\tchar keytext[DBZMAXKEY+1];\n-\n-\tp = NULL;\n-\tif (fs != '\\0')\n-\t\tp = strchr(lp, fs);\n-\tif (p == NULL)\n-\t\tp = lp + strlen(lp);\n-\tif (p > lp && *(p-1) == '\\n')\n-\t\tp--;\n-\tif (p - lp > DBZMAXKEY)\n-\t\tfail(\"key of `%.40s...' too long\", lp);\n-\tpc = *p;\n-\t*p = '\\0';\n-\t(void) strcpy(keytext, lp);\n-\t*p = pc;\n-\tkey.dptr = (dbzint) ? keytext : rfc822ize(keytext);\n-\tkey.dsize = strlen(keytext)+1;\n-\n-\tswitch (op) {\n-\tcase 'a':\n-\t\tplace = ftell(base);\n-\t\tllen = strlen(lp);\n-\t\tif (fwrite(lp, 1, llen, base) != llen)\n-\t\t\tfail(\"write error in `%s'\", my_basename);\n-\t\t/* FALLTHROUGH */\n-\tcase 'b':\n-\t\tif (omitzero && p != NULL && *(p+1) == '0')\n-\t\t\treturn;\n-\t\tif (unique) {\n-\t\t\tvalue = (dbzint) ? dbzfetch(key) : fetch(key);\n-\t\t\tif (value.dptr != NULL)\n-\t\t\t\tfail(\"`%.40s...' already present\", lp);\n-\t\t}\n-\t\tvalue.dptr = (char *)&place;\n-\t\tvalue.dsize = (int)sizeof(off_t);\n-\t\tif (((dbzint) ? dbzstore(key, value) : store(key, value)) < 0)\n-\t\t\tfail(\"store failed on `%.40s...'\", lp);\n-\t\tbreak;\n-\tcase 'c':\n-\t\tvalue = (dbzint) ? dbzfetch(key) : fetch(key);\n-\t\tshouldfind = (omitzero && p != NULL && *(p+1) == '0') ? 0 : 1;\n-\t\tif (!shouldfind && (value.dptr != NULL || value.dsize != 0))\n-\t\t\tfail(\"`%.40s...' found, shouldn't be\", lp);\n-\t\tif (shouldfind && (value.dptr == NULL ||\n-\t\t\t\t\tvalue.dsize != sizeof(off_t)))\n-\t\t\tfail(\"can't find `%.40s...'\", lp);\n-\t\tif (shouldfind && !quick) {\n-\t\t\t(void) memcpy((char *)&place, value.dptr, sizeof(off_t));\n-\t\t\tif (place != inoffset)\n-\t\t\t\tfail(\"offset mismatch on `%.40s...'\", lp);\n-\t\t\tif (fseek(base, place, SEEK_SET) == -1)\n-\t\t\t\tfail(\"fseek failed on `%.40s...'\", lp);\n-\t\t\tif (fgets(cmp, buflen, base) == NULL)\n-\t\t\t\tfail(\"can't read line for `%.40s...'\", lp);\n-\t\t\tif (!STREQ(lp, cmp))\n-\t\t\t\tfail(\"compare failed on `%.40s...'\", lp);\n-\t\t}\n-\t\tbreak;\n-\tcase 'x':\n-\t\tvalue = (dbzint) ? dbzfetch(key) : fetch(key);\n-\t\tif (value.dptr != NULL && !quick) {\n-\t\t\t(void) memcpy((char *)&place, value.dptr, sizeof(off_t));\n-\t\t\tif (fseek(base, place, SEEK_SET) == -1)\n-\t\t\t\tfail(\"fseek failed on `%.40s...'\", lp);\n-\t\t\tif (fgets(cmp, buflen, base) == NULL)\n-\t\t\t\tfail(\"can't read line for `%.40s...'\", lp);\n-\t\t\tfputs(cmp, stdout);\n-\t\t} else if (value.dptr != NULL)\n-\t\t\tfputs(lp, stdout);\n-\t\tbreak;\n-\tcase 'm':\n-\t\tvalue = (dbzint) ? dbzfetch(key) : fetch(key);\n-\t\tif (value.dptr == NULL) {\n-\t\t\tfputs(keytext, stdout);\n-\t\t\tputchar('\\n');\n-\t\t}\n-\t\tbreak;\n-\tdefault:\n-\t\tfail(\"unknown operator -- can't happen\", \"\");\n-\t\tbreak;\n-\t}\n-}\n-\n-/*\n- - runs - print run statistics\n- */\n-void\n-runs(file)\n-char *file;\n-{\n-\tregister FILE *fd;\n-\toff_t it;\n-\tregister long run;\n-\n-\tfd = fopen(file, \"r\");\n-\tif (fd == NULL)\n-\t\tfail(\"cannot reopen `%s'\", file);\n-\trun = 0;\n-\twhile (fread((char *)&it, sizeof(off_t), 1, fd) == 1) {\n-\t\tif (it != 0)\n-\t\t\trun++;\n-\t\telse if (run > 0) {\n-\t\t\tprintf(\"%ld\\n\", run);\n-\t\t\trun = 0;\n-\t\t}\n-\t}\n-\t(void) fclose(fd);\n-}\n-\n-/*\n- - dosweep - sweep pag file checking for valid offsets\n- */\n-void\n-dosweep(fn, pn)\n-char *fn;\n-char *pn;\n-{\n-\tregister FILE *pf;\n-\toff_t it;\n-\tchar nl;\n-\tregister FILE *hf;\n-\n-\thf = fopen(fn, \"r\");\n-\tif (hf == NULL)\n-\t\tfail(\"cannot reopen `%s'\", fn);\n-\tpf = fopen(pn, \"r\");\n-\tif (pf == NULL)\n-\t\tfail(\"cannot reopen `%s'\", pn);\n-\twhile (fread((char *)&it, sizeof(off_t), 1, pf) == 1) {\n-\t\tit = (it & ((off_t)0x80000000)) ? (it&~((off_t)0xff000000)) : it;\n-\t\tif (it != 0 && it != 1) {\t/* 0 empty, 1 known okay */\n-\t\t\tit--;\t\t/* get rid of bias */\n-\t\t\t(void) fseek(hf, it-1, SEEK_SET);\n-\t\t\tnl = getc(hf);\n-\t\t\tif (nl != '\\n')\n-\t\t\t\tfprintf(stderr, \"offset 0%lo does not point to line\\n\",\n-\t\t\t\t\t\t\t\t(long)it);\n-\t\t}\n-\t}\n-\t(void) fclose(hf);\n-\t(void) fclose(pf);\n-}\n-\n-/*\n- - fail - complain and die\n- */\n-void\n-fail(s1, s2)\n-char *s1;\n-char *s2;\n-{\n-\tfprintf(stderr, \"%s: (file `%s', line %ld) \", progname, inname, lineno);\n-\tfprintf(stderr, s1, s2);\n-\tfprintf(stderr, \"\\n\");\n-\texit(1);\n-}\n-\n-/*\n- - str2dup - concatenate strings and malloc result\n- */\n-char *\n-str2dup(s1, s2)\n-char *s1;\n-char *s2;\n-{\n-\tregister char *p;\n-\n-\tp = malloc((size_t)strlen(s1) + strlen(s2) + 1);\n-\tif (p == NULL)\n-\t\tfail(\"can't allocate space for strings\", \"\");\n-\t(void) strcpy(p, s1);\n-\t(void) strcat(p, s2);\n-\treturn(p);\n-}"}, {"sha": "74f2ae682533ac0717a5e35367bfb5ea320840a7", "filename": "libio/dbz/fake.c", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Ffake.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Ffake.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Ffake.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,140 +0,0 @@\n-/*\n- * fake - make up random lines resembling history-file entries, reproducibly\n- *\n- * -Log-\n- */\n-\n-#include <stdio.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <string.h>\n-\n-#define\tMAXSTR\t500\t\t/* For sizing strings -- DON'T use BUFSIZ! */\n-#define\tSTREQ(a, b)\t(*(a) == *(b) && strcmp((a), (b)) == 0)\n-\n-int midonly = 0;\t\t/* just message ids, rest not realistic */\n-int tag = 0;\t\t\t/* tag lines with random digit for later use */\n-int expired = -1;\t\t/* percentage of lines to be expired */\n-\n-int debug = 0;\n-char *progname;\n-\n-char *inname;\t\t\t\t/* filename for messages etc. */\n-long lineno;\t\t\t\t/* line number for messages etc. */\n-\n-void doline();\n-void addchars();\n-void seed();\n-\n-/*\n- - main - parse arguments and handle options\n- */\n-int\n-main(argc, argv)\n-int argc;\n-char *argv[];\n-{\n-\tint c;\n-\tint errflg = 0;\n-\tFILE *in;\n-\tstruct stat statbuf;\n-\textern int optind;\n-\textern char *optarg;\n-\tvoid process();\n-\tregister long no;\n-\textern long atol();\n-\tchar line[MAXSTR];\n-\n-\tprogname = argv[0];\n-\n-\twhile ((c = getopt(argc, argv, \"ms:te:d\")) != EOF)\n-\t\tswitch (c) {\n-\t\tcase 'm':\t/* message-ids only */\n-\t\t\tmidonly = 1;\n-\t\t\tbreak;\n-\t\tcase 's':\t/* seed */\n-\t\t\tseed(atol(optarg));\n-\t\t\tbreak;\n-\t\tcase 't':\t/* tag lines with a random digit */\n-\t\t\ttag = 1;\n-\t\t\tbreak;\n-\t\tcase 'e':\t/* percentage to be expired */\n-\t\t\texpired = atoi(optarg);\n-\t\t\tbreak;\n-\t\tcase 'd':\t/* Debugging. */\n-\t\t\tdebug++;\n-\t\t\tbreak;\n-\t\tcase '?':\n-\t\tdefault:\n-\t\t\terrflg++;\n-\t\t\tbreak;\n-\t\t}\n-\tif (errflg || optind != argc - 1) {\n-\t\tfprintf(stderr, \"usage: %s \", progname);\n-\t\tfprintf(stderr, \"[-m] [-s seed] length\\n\");\n-\t\texit(2);\n-\t}\n-\n-\tfor (no = atol(argv[optind]); no > 0; no--) {\n-\t\tdoline(line);\n-\t\tputs(line);\n-\t}\n-#ifdef DBZ_FINISH\n-\tDBZ_FINISH;\n-#endif\n-\texit(0);\n-}\n-\n-/*\n- - doline - generate random history pseudo-line\n- */\n-void\n-doline(buf)\n-char *buf;\n-{\n-\tchar tagch[2];\n-\n-\t(void) strcpy(buf, \"<\");\n-\taddchars(buf, range(4, 20));\n-\t(void) strcat(buf, \"@\");\n-\taddchars(buf, range(8, 20));\n-\tif (midonly)\n-\t\t(void) strcat(buf, \">\\tx\");\n-\telse {\n-\t\tif (tag) {\n-\t\t\ttagch[0] = \"1234567890\"[range(0,9)];\n-\t\t\ttagch[1] = '\\0';\n-\t\t\t(void) strcat(buf, \">\\t\");\n-\t\t\t(void) strcat(buf, tagch);\n-\t\t\t(void) strcat(buf, \"00000000~-\");\n-\t\t} else\n-\t\t\t(void) strcat(buf, \">\\t1234567890~-\");\n-\t}\n-\tif (range(1, 100) > expired) {\n-\t\tif (midonly)\n-\t\t\t(void) strcat(buf, \"\\tx\");\n-\t\telse {\n-\t\t\t(void) strcat(buf, \"\\t\");\n-\t\t\taddchars(buf, range(10, 30));\n-\t\t}\n-\t}\n-}\n-\n-/*\n- - addchars - generate n random characters suitable for history file\n- */\n-void\n-addchars(buf, len)\n-char *buf;\n-int len;\n-{\n-\tregister int i;\n-\tregister char *p = buf + strlen(buf);\n-\tstatic char vocab[] = \"1234567890.abcde.fghij.klmno.pqrst.uvwxyz.\\\n-1234567890.ABCDE.FGHIJ.KLMNO.PQRST.UVWXYZ.1234567890.\\\n-1234567890.abcde.fghij.klmno.pqrst.uvwxyz.1234567890\";\n-\n-\tfor (i = len; i > 0; i--)\n-\t\t*p++ = vocab[range(0, sizeof(vocab)-2)];\n-\t*p++ = '\\0';\n-}"}, {"sha": "4850468c0c2a9e24015358aca1edcc0f4828e91e", "filename": "libio/dbz/firstlast25", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Ffirstlast25", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Ffirstlast25", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Ffirstlast25?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,50 +0,0 @@\n-<m....VO1.9q.@s95e1zKsIj7LrIwa1>\t600000000~-\t90fz0706yo.1Env21x8b\n-<H5.i.R6ZQ2@Vg6.5mqj8..z>\t200000000~-\n-<1Hy.ufmjqe371x5.o@HEEl0tAp4>\t700000000~-\n-<T6.c9.xM4i@943..7z.c..3h>\t600000000~-\n-<Exus7LsME4fPL9v8@2.ouu97O25z9cdft>\t700000000~-\n-<6kUzkf.v74@iC1iGj882RQ0zli>\t400000000~-\n-<J.7YT7dV.Kkul8Bh0fc@Rar.EnMx2lm0.6Yeob>\t600000000~-\n-<.wVJi1DX42@5.4i6.jaZ6qw9Ln1.>\t500000000~-\n-<uUd9e18vxzevae7uY@33a480208l0.4p2q>\t300000000~-\n-<43hQ.5shbE7@912400.ajES6x0sXl.M>\t400000000~-\n-<g25r..2r.0WOZ6k3@tb3.U9xrR.uw61a2y0>\t600000000~-\n-<923s5e67d5Oq085Y.1@6Pik68584>\t900000000~-\n-<.5.n5cx5aD62i9q8@Ai60Sc.4x>\t200000000~-\n-<9N9n@3.1ql87.yj2xFs.zLqI>\t700000000~-\tQ2.kni8kZps7kF5uiEv32B38y4z.p\n-<.X.fw.6LtoT.0@pp6bp.5s6yh74.>\t400000000~-\n-<54c1w@7..u1.99m9T4j.BNGBiK>\t600000000~-\t.F3hb.OFh06V..p\n-<j12Mtn6q9@m2.m1X1s>\t500000000~-\n-<o1WJV9G4H.zf0BX44w@W7.76xn33>\t000000000~-\n-<0C605s6plaAgfM.ap40@e6d66n.uv01W.j.8ph.>\t100000000~-\tm.x7TY8.8DQ5\n-<.2.14xdn.@D0g.W.uZ.75gyyg.q1G>\t100000000~-\n-<.A..03.@5v..64.5v3.3tbjUo.>\t500000000~-\n-<72..c19ms65.WCf0G3.@83seEG9nnhM.O.j22>\t900000000~-\n-<D..xX.kti9@u739li.xvy2>\t000000000~-\tNPLL42XVfM\n-<6HO.nFal1ufl3.8b@3.n0k7a.IDgNy>\t700000000~-\tWv4j3Itccnh0Zp3\n-<x5RjUnIpd03xBBnuN@z0puc82Q26Ou.0T6>\t400000000~-\tk67.hvXwv6X745R4rh2ybuFN3n.\n-<62dIeg.fW92.ov375@x76mf5c6.37.v>\t000000000~-\n-<chdpqs.0mgZOp.@Dxl9v..94e7ar2>\t900000000~-\n-<.9Xr.7V91..oe5CG.hX@p5x3jos3s27R6O3yj1>\t400000000~-\n-<Mm6dr.231dH35ua@SE1u0za3V1M43lRn9>\t100000000~-\n-<JIhw2@.Qdf.8v28Tnf1M>\t200000000~-\n-<z4FCa.q4MF..EE0.2@W9U63e33h9w3lcFFl>\t400000000~-\n-<87.W3r6is4.@svVqQCBiNqz400A.qwj>\t200000000~-\n-<0liI7Lu0Mx435m7M99@87Xw.8j63.9.>\t500000000~-\n-<tRtht5M.6d0@06gj.qm3.s9>\t200000000~-\te27S.BKVD70P.o\n-<Jpga8@m68yvw.b4b>\t200000000~-\n-<.2.69hy3JT1@Aq3.r83o.9>\t700000000~-\n-<.W7EurYppo4fhzs.I@8651m2W7v>\t700000000~-\n-<3m02.@22074.a5ct2j3>\t900000000~-\n-<.fy9Epa@.1.kNGCNokFwB8ezo1WM>\t800000000~-\n-<c758d64.FS4yY7L5@43sw.kI6>\t900000000~-\n-<vLd0.t@.kq70oHl96ixdnXd.GVv>\t100000000~-\t9A6Ejq5t55I4VJ6.q1\n-<d3.4@n17p4N.77N7W..7.8>\t300000000~-\n-<f2lv064.8@4jokk3e07>\t400000000~-\n-<rr7hoxA.U7.JXxnpvd@1rbMO437vHnakx>\t000000000~-\n-<.0p3G7novlrYz9kjI@Sx.2w.yqzerZl12781.k>\t700000000~-\n-<51ny.pQ7ay4@nfU2l1f0ixG09584.m>\t000000000~-\t38K5bhK7cr6.bg.5MlC2Fxq06Ziuw.\n-<2.cau.9s@.n4Pk0Jd9g>\t300000000~-\n-<bEH1Bwa.662i@zm.3g.gx4.lp3>\t300000000~-\tc8.t4Q0.8t0.m50\n-<.t13789u5AqM4m3.z0T@P17e.ypf>\t200000000~-\tq17z.fZ3.FyD533WthqZs8q7\n-<M4r1I@Ovaev.dp>\t100000000~-"}, {"sha": "fd746cad7d95420543045908520645a22cc5c2ba", "filename": "libio/dbz/getmap", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fgetmap", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fgetmap", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Fgetmap?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,6 +0,0 @@\n-#!/bin/sh\n-awk 'NR == 1 {\n-\tfor (i = 9; i <= NF; i++)\n-\t\tprintf \"%s \", $i\n-\tprintf \"\\n\"\n-}' $*"}, {"sha": "1d8de3a2b44d965ba0c09879f609b2cfde0f5ead", "filename": "libio/dbz/random.c", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Frandom.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,31 +0,0 @@\n-/*\n- * random-number generator for testing\n- */\n-static unsigned long next = 1;\n-\n-/*\n- - range - generate a random number within an inclusive range\n- *\n- * Algorithm from ANSI C standard.  Limitation:  max-min <= 32767.\n- */\n-int\n-range(min, max)\n-int min;\n-int max;\n-{\n-\tregister int temp;\n-\n-\tnext = next * 1103515245 + 12345;\n-\ttemp = (int)((next/65536)%32768);\n-\treturn(temp%(max - min + 1) + min);\n-}\n-\n-/*\n- - seed - seed random number generator\n- */\n-void\n-seed(n)\n-long n;\n-{\n-\tnext = (unsigned long)n;\n-}"}, {"sha": "b3d80c2685fbef6118725d583a7888c585f4eb4e", "filename": "libio/dbz/revbytes", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Frevbytes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Frevbytes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Frevbytes?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,7 +0,0 @@\n-NR == 1 {\n-\tprintf \"%s %s %s %s %s %s %s %s %s\", $1, $2, $3, $4, $5, $6, $7, $8, $9\n-\tfor (i = NF; i > 9; i--)\n-\t\tprintf \" %s\", $i\n-\tprintf \"\\n\"\n-}\n-NR > 1 { print }"}, {"sha": "80faee30ad9609f0bf6dc0b8af4ef1b0ae0ea9ec", "filename": "libio/dbz/stdio.h", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fstdio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdbz%2Fstdio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdbz%2Fstdio.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1 +0,0 @@\n-#include \"../iostdio.h\""}, {"sha": "15888c4574a744c1c60036a54bbc23f7c77733f0", "filename": "libio/depend", "status": "removed", "additions": 0, "deletions": 379, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdepend", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fdepend", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdepend?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,379 +0,0 @@\n-# AUTOMATICALLY GENERATED BY 'make depend' - DO NOT EDIT\n-\n-PlotFile.o: PlotFile.cc \\\n- $(srcdir)/PlotFile.h \\\n- $(srcdir)/fstream.h \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-SFile.o: SFile.cc \\\n- $(srcdir)/SFile.h \\\n- $(srcdir)/fstream.h \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-builtinbuf.o: builtinbuf.cc \\\n- $(srcdir)/builtinbuf.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/iostreamP.h \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h\n-editbuf.o: editbuf.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/editbuf.h \\\n- $(srcdir)/fstream.h \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h\n-filebuf.o: filebuf.cc \\\n- $(srcdir)/iostreamP.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/builtinbuf.h\n-fstream.o: fstream.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/fstream.h \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h\n-indstream.o: indstream.cc \\\n- $(srcdir)/indstream.h \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioassign.o: ioassign.cc \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h\n-ioextend.o: ioextend.cc \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iomanip.o: iomanip.cc \\\n- $(srcdir)/iomanip.h \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iostream.o: iostream.cc \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/floatio.h\n-isgetline.o: isgetline.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \n-isgetsb.o: isgetsb.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \n-isscan.o: isscan.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \n-osform.o: osform.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \n-parsestream.o: parsestream.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/parsestream.h \\\n- $(srcdir)/streambuf.h \n-pfstream.o: pfstream.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/pfstream.h \\\n- $(srcdir)/fstream.h \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/procbuf.h\n-procbuf.o: procbuf.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/procbuf.h \\\n- $(srcdir)/streambuf.h\n-sbform.o: sbform.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/streambuf.h \n-sbgetline.o: sbgetline.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/streambuf.h\n-sbscan.o: sbscan.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/streambuf.h \n-stdiostream.o: stdiostream.cc \\\n- $(srcdir)/stdiostream.h \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h\n-stdstrbufs.o: stdstrbufs.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/stdiostream.h \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h\n-stdstreams.o: stdstreams.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/iostream.h\n-stream.o: stream.cc \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/stream.h \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/strstream.h \\\n- $(srcdir)/strfile.h\n-streambuf.o: streambuf.cc \\\n- $(srcdir)/iostreamP.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \n-strstream.o: strstream.cc \\\n- $(srcdir)/iostreamP.h \\\n- $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/strstream.h \\\n- $(srcdir)/iostream.h \\\n- $(srcdir)/strfile.h \n-cleanup.o: cleanup.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-filedoalloc.o: filedoalloc.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-fileops.o: fileops.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-floatconv.o: floatconv.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-genops.o: genops.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofclose.o: iofclose.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofdopen.o: iofdopen.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofeof.o: iofeof.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioferror.o: ioferror.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofflush.o: iofflush.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofflush_u.o: iofflush_u.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofgetpos.o: iofgetpos.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofgets.o: iofgets.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofopen.o: iofopen.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofprintf.o: iofprintf.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofputs.o: iofputs.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofread.o: iofread.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofscanf.o: iofscanf.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofsetpos.o: iofsetpos.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioftell.o: ioftell.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iofwrite.o: iofwrite.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iogetc.o: iogetc.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iogetdelim.o: iogetdelim.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iogetline.o: iogetline.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iogets.o: iogets.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioignore.o: ioignore.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iopadn.o: iopadn.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioperror.o: ioperror.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iopopen.o: iopopen.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioprims.o: ioprims.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioprintf.o: ioprintf.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioputc.o: ioputc.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioputs.o: ioputs.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioscanf.o: ioscanf.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioseekoff.o: ioseekoff.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioseekpos.o: ioseekpos.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iosetbuffer.o: iosetbuffer.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iosetvbuf.o: iosetvbuf.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iosprintf.o: iosprintf.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iosscanf.o: iosscanf.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iostrerror.o: iostrerror.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-ioungetc.o: ioungetc.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-iovfprintf.o: iovfprintf.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/floatio.h\n-iovfscanf.o: iovfscanf.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/floatio.h\n-iovsprintf.o: iovsprintf.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/strfile.h\n-iovsscanf.o: iovsscanf.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/strfile.h\n-outfloat.o: outfloat.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-peekc.o: peekc.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-stdfiles.o: stdfiles.c \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \n-strops.o: strops.c \\\n- $(srcdir)/strfile.h \\\n- $(srcdir)/libio.h $(_G_CONFIG_H) \\\n- $(srcdir)/libioP.h \\\n- $(srcdir)/iolibio.h "}, {"sha": "e2df8c4641cd8e883e8398299b11b270c3565d34", "filename": "libio/editbuf.cc", "status": "removed", "additions": 0, "deletions": 718, "changes": 718, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Feditbuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Feditbuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Feditbuf.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,718 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License.\n-\n-Written by Per Bothner (bothner@cygnus.com). */\n-\n-#ifdef __GNUG__\n-#pragma implementation\n-#endif\n-#include \"libioP.h\"\n-#include \"editbuf.h\"\n-#include <stddef.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-/* NOTE: Some of the code here is taken from GNU emacs */\n-/* Hence this file falls under the GNU License! */\n-\n-// Invariants for edit_streambuf:\n-// An edit_streambuf is associated with a specific edit_string,\n-// which again is a sub-string of a specific edit_buffer.\n-// An edit_streambuf is always in either get mode or put mode, never both.\n-// In get mode, gptr() is the current position,\n-// and pbase(), pptr(), and epptr() are all NULL.\n-// In put mode, pptr() is the current position,\n-// and eback(), gptr(), and egptr() are all NULL.\n-// Any edit_streambuf that is actively doing insertion (as opposed to\n-// replacing) // must have its pptr() pointing to the start of the gap.\n-// Only one edit_streambuf can be actively inserting into a specific\n-// edit_buffer; the edit_buffer's _writer field points to that edit_streambuf.\n-// That edit_streambuf \"owns\" the gap, and the actual start of the\n-// gap is the pptr() of the edit_streambuf; the edit_buffer::_gap_start pointer\n-// will only be updated on an edit_streambuf::overflow().\n-\n-int edit_streambuf::truncate()\n-{\n-    str->buffer->delete_range(str->buffer->tell((buf_char*)pptr()),\n-\t\t\t      str->buffer->tell(str->end));\n-    return 0;\n-}\n-\n-#ifdef OLD_STDIO\n-inline void  disconnect_gap_from_file(edit_buffer* buffer, FILE* fp)\n-{\n-    if (buffer->gap_start_ptr != &fp->__bufp)\n-\treturn;\n-    buffer->gap_start_normal = fp->__bufp;\n-    buffer->gap_start_ptr = &buffer->gap_start_normal;\n-}\n-#endif\n-\n-void edit_streambuf::flush_to_buffer(edit_buffer* buffer)\n-{\n-    if (pptr() > buffer->_gap_start && pptr() < buffer->gap_end())\n-\tbuffer->_gap_start = pptr();\n-}\n-\n-void edit_streambuf::disconnect_gap_from_file(edit_buffer* buffer)\n-{\n-    if (buffer->_writer != this) return;\n-    flush_to_buffer(buffer);\n-    setp(pptr(),pptr());\n-    buffer->_writer = NULL;    \n-}\n-\n-buf_index edit_buffer::tell(buf_char *ptr)\n-{\n-    if (ptr <= gap_start())\n-\treturn ptr - data;\n-    else\n-\treturn ptr - gap_end() + size1();\n-}\n-\n-#if 0\n-buf_index buf_cookie::tell()\n-{\n-    return str->buffer->tell(file->__bufp);\n-}\n-#endif\n-\n-buf_index edit_buffer::tell(edit_mark*mark)\n-{\n-    return tell(data + mark->index_in_buffer(this));\n-}\n-\n-// adjust the position of the gap\n-\n-void edit_buffer::move_gap(buf_offset pos)\n-{\n-  if (pos < size1())\n-    gap_left (pos);\n-  else if (pos > size1())\n-    gap_right (pos);\n-}\n-\n-void edit_buffer::gap_left (int pos)\n-{\n-  register buf_char *to, *from;\n-  register int i;\n-  int new_s1;\n-\n-  i = size1();\n-  from = gap_start();\n-  to = from + gap_size();\n-  new_s1 = size1();\n-\n-  /* Now copy the characters.  To move the gap down,\n-     copy characters up.  */\n-\n-  for (;;)\n-    {\n-      /* I gets number of characters left to copy.  */\n-      i = new_s1 - pos;\n-      if (i == 0)\n-\tbreak;\n-#if 0\n-      /* If a quit is requested, stop copying now.\n-\t Change POS to be where we have actually moved the gap to.  */\n-      if (QUITP)\n-\t{\n-\t  pos = new_s1;\n-\t  break;\n-\t}\n-#endif\n-      /* Move at most 32000 chars before checking again for a quit.  */\n-      if (i > 32000)\n-\ti = 32000;\n-      new_s1 -= i;\n-      while (--i >= 0)\n-\t*--to = *--from;\n-    }\n-\n-  /* Adjust markers, and buffer data structure, to put the gap at POS.\n-     POS is where the loop above stopped, which may be what was specified\n-     or may be where a quit was detected.  */\n-  adjust_markers (pos << 1, size1() << 1, gap_size(), data);\n-#ifndef OLD_STDIO\n-  _gap_start = data + pos;\n-#else\n-  if (gap_start_ptr == &gap_start_normal)\n-\tgap_start_normal = data + pos;\n-#endif\n-  __gap_end_pos = to - data;\n-/*  QUIT;*/\n-}\n-\n-void edit_buffer::gap_right (int pos)\n-{\n-  register buf_char *to, *from;\n-  register int i;\n-  int new_s1;\n-\n-  i = size1();\n-  to = gap_start();\n-  from = i + gap_end();\n-  new_s1 = i;\n-\n-  /* Now copy the characters.  To move the gap up,\n-     copy characters down.  */\n-\n-  while (1)\n-    {\n-      /* I gets number of characters left to copy.  */\n-      i = pos - new_s1;\n-      if (i == 0)\n-\tbreak;\n-#if 0\n-      /* If a quit is requested, stop copying now.\n-\t Change POS to be where we have actually moved the gap to.  */\n-      if (QUITP)\n-\t{\n-\t  pos = new_s1;\n-\t  break;\n-\t}\n-#endif\n-      /* Move at most 32000 chars before checking again for a quit.  */\n-      if (i > 32000)\n-\ti = 32000;\n-      new_s1 += i;\n-      while (--i >= 0)\n-\t*to++ = *from++;\n-    }\n-\n-  adjust_markers ((size1() + gap_size()) << 1, (pos + gap_size()) << 1,\n-\t- gap_size(), data);\n-#ifndef OLD_STDIO\n-  _gap_start = data+pos;\n-#else\n-  if (gap_start_ptr == &gap_start_normal)\n-\tgap_start_normal = data + pos;\n-#endif\n-  __gap_end_pos = from - data;\n-/*  QUIT;*/\n-}\n-\n-/* make sure that the gap in the current buffer is at least k\n-   characters wide */\n-\n-void edit_buffer::make_gap(buf_offset k)\n-{\n-  register buf_char *p1, *p2, *lim;\n-  buf_char *old_data = data;\n-  int s1 = size1();\n-\n-  if (gap_size() >= k)\n-    return;\n-\n-  /* Get more than just enough */\n-  if (buf_size > 1000) k += 2000;\n-  else k += /*200;*/ 20; // for testing!\n-\n-  p1 = (buf_char *) realloc (data, s1 + size2() + k);\n-  if (p1 == 0)\n-    abort(); /*memory_full ();*/\n-\n-  k -= gap_size();\t\t\t/* Amount of increase.  */\n-\n-  /* Record new location of text */\n-  data = p1;\n-\n-  /* Transfer the new free space from the end to the gap\n-     by shifting the second segment upward */\n-  p2 = data + buf_size;\n-  p1 = p2 + k;\n-  lim = p2 - size2();\n-  while (lim < p2)\n-    *--p1 = *--p2;\n-\n-  /* Finish updating text location data */\n-  __gap_end_pos += k;\n-\n-#ifndef OLD_STDIO\n-  _gap_start = data + s1;\n-#else\n-  if (gap_start_ptr == &gap_start_normal)\n-\tgap_start_normal = data + s1;\n-#endif\n-\n-  /* adjust markers */\n-  adjust_markers (s1 << 1, (buf_size << 1) + 1, k, old_data);\n-  buf_size += k;\n-}\n-\n-/* Add `amount' to the position of every marker in the current buffer\n-   whose current position is between `from' (exclusive) and `to' (inclusive).\n-   Also, any markers past the outside of that interval, in the direction\n-   of adjustment, are first moved back to the near end of the interval\n-   and then adjusted by `amount'.  */\n-\n-void edit_buffer::adjust_markers(register mark_pointer low,\n-\t\t\t\t register mark_pointer high,\n-\t\t\t\t int amount, buf_char *old_data)\n-{\n-  register struct edit_mark *m;\n-  register mark_pointer mpos;\n-  /* convert to mark_pointer */\n-  amount <<= 1;\n-\n-  if (_writer)\n-      _writer->disconnect_gap_from_file(this);\n-\n-  for (m = mark_list(); m != NULL; m = m->chain)\n-    {\n-      mpos = m->_pos;\n-      if (amount > 0)\n-\t{\n-\t  if (mpos > high && mpos < high + amount)\n-\t    mpos = high + amount;\n-\t}\n-      else\n-\t{\n-\t  if (mpos > low + amount && mpos <= low)\n-\t    mpos = low + amount;\n-\t}\n-      if (mpos > low && mpos <= high)\n-\tmpos += amount;\n-      m->_pos = mpos;\n-    }\n-\n-    // Now adjust files\n-    edit_streambuf *file;\n-\n-    for (file = files; file != NULL; file = file->next) {\n-\tmpos = file->current() - old_data;\n-\tif (amount > 0)\n-\t{\n-\t  if (mpos > high && mpos < high + amount)\n-\t    mpos = high + amount;\n-\t}\n-\telse\n-\t{\n-\t  if (mpos > low + amount && mpos <= low)\n-\t    mpos = low + amount;\n-\t}\n-\tif (mpos > low && mpos <= high)\n-\t    mpos += amount;\n-\tchar* new_pos = data + mpos;\n-\tfile->set_current(new_pos, file->is_reading());\n-    }\n-}\n-\n-#if 0\n-stdio_\n-   __off == index at start of buffer (need only be valid after seek ? )\n-   __buf ==\n-\n-if read/read_delete/overwrite mode:\n-     __endp <= min(*gap_start_ptr, edit_string->end->ptr(buffer))\n-\n-if inserting:\n-     must have *gap_start_ptr == __bufp && *gap_start_ptr+gap == __endp\n-     file->edit_string->end->ptr(buffer) == *gap_start_ptr+end\n-if write_mode:\n-     if before gap\n-#endif\n-\n-int edit_streambuf::underflow()\n-{\n-    if (!(_mode & ios::in))\n-\treturn EOF;\n-    struct edit_buffer *buffer = str->buffer;\n-    if (!is_reading()) { // Must switch from put to get mode.\n-\tdisconnect_gap_from_file(buffer);\n-\tset_current(pptr(), 1);\n-    }\n-    buf_char *str_end = str->end->ptr(buffer);\n-  retry:\n-    if (gptr() < egptr()) {\n-\treturn *gptr();\n-    }\n-    if ((buf_char*)gptr() == str_end)\n-\treturn EOF;\n-    if (str_end <= buffer->gap_start()) {\n-\tsetg(eback(), gptr(), str_end);\n-\tgoto retry;\n-    }\n-    if (gptr() < buffer->gap_start()) {\n-\tsetg(eback(), gptr(), buffer->gap_start());\n-\tgoto retry;\n-    }\n-    if (gptr() == buffer->gap_start()) {\n-\tdisconnect_gap_from_file(buffer);\n-//\tfp->__offset += fp->__bufp - fp->__buffer;\n-\tsetg(buffer->gap_end(), buffer->gap_end(), str_end);\n-    }\n-    else\n-\tsetg(eback(), gptr(), str_end);\n-    goto retry;\n-}\n-\n-int edit_streambuf::overflow(int ch)\n-{\n-    if (_mode == ios::in)\n-\treturn EOF;\n-    struct edit_buffer *buffer = str->buffer;\n-    flush_to_buffer(buffer);\n-    if (ch == EOF)\n-\treturn 0;\n-    if (is_reading()) { // Must switch from get to put mode.\n-\tset_current(gptr(), 0);\n-    }\n-    buf_char *str_end = str->end->ptr(buffer);\n-  retry:\n-    if (pptr() < epptr()) {\n-\t*pptr() = ch;\n-\tpbump(1);\n-\treturn (unsigned char)ch;\n-    }\n-    if ((buf_char*)pptr() == str_end || inserting()) {\n-\t/* insert instead */\n-\tif (buffer->_writer)\n-\t    buffer->_writer->flush_to_buffer(); // Redundant?\n-\tbuffer->_writer = NULL;\n-\tif  (pptr() >= buffer->gap_end())\n-\t    buffer->move_gap(pptr() - buffer->gap_size());\n-\telse\n-\t    buffer->move_gap(pptr());\n-\tbuffer->make_gap(1);\n-\tsetp(buffer->gap_start(), buffer->gap_end());\n-\tbuffer->_writer = this;\n-\t*pptr() = ch;\n-\tpbump(1);\n-\treturn (unsigned char)ch;\n-    }\n-    if (str_end <= buffer->gap_start()) {\n-\t// Entire string is left of gap.\n-\tsetp(pptr(), str_end);\n-    }\n-    else if (pptr() < buffer->gap_start()) {\n-\t// Current pos is left of gap.\n-\tsetp(pptr(), buffer->gap_start());\n-\tgoto retry;\n-    }\n-    else if (pptr() == buffer->gap_start()) {\n-\t// Current pos is at start of gap; move to end of gap.\n-//\tdisconnect_gap_from_file(buffer);\n-\tsetp(buffer->gap_end(), str_end);\n-//\t__offset += __bufp - __buffer;\n-    }\n-    else {\n-\t// Otherwise, current pos is right of gap.\n-\tsetp(pptr(), str_end);\n-    }\n-    goto retry;\n-}\n-\n-void edit_streambuf::set_current(char *new_pos, int reading)\n-{\n-    if (reading) {\n-\tsetg(new_pos, new_pos, new_pos);\n-\tsetp(NULL, NULL);\n-    }\n-    else {\n-\tsetg(NULL, NULL, NULL);\n-\tsetp(new_pos, new_pos);\n-    }\n-}\n-\n-// Called by fseek(fp, pos, whence) if fp is bound to a edit_buffer.\n-\n-streampos edit_streambuf::seekoff(streamoff offset, _seek_dir dir,\n-\t\t\t\t  int /* =ios::in|ios::out*/)\n-{\n-    struct edit_buffer *buffer = str->buffer;\n-    disconnect_gap_from_file(buffer);\n-    buf_index cur_pos = buffer->tell((buf_char*)current());;\n-    buf_index start_pos = buffer->tell(str->start);\n-    buf_index end_pos = buffer->tell(str->end);\n-    switch (dir) {\n-      case ios::beg:\n-\toffset += start_pos;\n-\tbreak;\n-      case ios::cur:\n-\toffset += cur_pos;\n-\tbreak;\n-      case ios::end:\n-\toffset += end_pos;\n-\tbreak;\n-    }\n-    if (offset < start_pos || offset > end_pos)\n-\treturn EOF;\n-    buf_char *new_pos = buffer->data + offset;\n-    buf_char* gap_start = buffer->gap_start();\n-    if (new_pos > gap_start) {\n-\tbuf_char* gap_end = buffer->gap_end();\n-\tnew_pos += gap_end - gap_start;\n-\tif (new_pos >= buffer->data + buffer->buf_size) abort(); // Paranoia.\n-    }\n-    set_current(new_pos, is_reading());\n-    return EOF;\n-}\n-\n-#if 0\n-int buf_seek(void *arg_cookie, fpos_t * pos, int whence)\n-{\n-    struct buf_cookie *cookie = arg_cookie;\n-    FILE *file = cookie->file;\n-    struct edit_buffer *buffer = cookie->str->buffer;\n-    buf_char *str_start = cookie->str->start->ptr(buffer);\n-    disconnect_gap_from_file(buffer, cookie->file);\n-    fpos_t cur_pos, new_pos;\n-    if (file->__bufp <= *buffer->gap_start_ptr\n-\t|| str_start >= buffer->__gap_end)\n-\tcur_pos = str_start - file->__bufp;\n-    else\n-\tcur_pos =\n-\t    (*buffer->gap_start_ptr - str_start) + (file->__bufp - __gap_end);\n-    end_pos = ...;\n-    switch (whence) {\n-      case SEEK_SET:\n-\tnew_pos = *pos;\n-\tbreak;\n-      case SEEK_CUR:\n-\tnew_pos = cur_pos + *pos;\n-\tbreak;\n-      case SEEK_END:\n-\tnew_pos = end_pos + *pos;\n-\tbreak;\n-    }\n-    if (new_pos > end_pos) {\n-\tseek to end_pos;\n-\tinsert_nulls(new_pos - end_pos);\n-\treturn;\n-    }\n-    if (str_start + new_pos <= *gap_start_ptr &* *gap_start_ptr < end) {\n-\t__buffer = str_start;\n-        __off = 0;\n-\t__bufp = str_start + new_pos;\n-\tfile->__get_limit =\n-\t    *buffer->gap_start_ptr; /* what if gap_start_ptr == &bufp ??? */\n-    } else if () {\n-\t\n-    }\n-    *pos = new_pos;\n-}\n-#endif\n-\n-/* Delete characters from `from' up to (but not incl) `to' */\n-\n-void edit_buffer::delete_range (buf_index from, buf_index to)\n-{\n-  register int numdel;\n-\n-  if ((numdel = to - from) <= 0)\n-    return;\n-\n-  /* Make sure the gap is somewhere in or next to what we are deleting */\n-  if (from > size1())\n-    gap_right (from);\n-  if (to < size1())\n-    gap_left (to);\n-\n-  /* Relocate all markers pointing into the new, larger gap\n-     to point at the end of the text before the gap.  */\n-  adjust_markers ((to + gap_size()) << 1, (to + gap_size()) << 1,\n-\t- numdel - gap_size(), data);\n-\n-   __gap_end_pos = to + gap_size();\n-  _gap_start = data + from;\n-}\n-\n-void edit_buffer::delete_range(struct edit_mark *start, struct edit_mark *end)\n-{\n-    delete_range(tell(start), tell(end));\n-}\n-\n-void buf_delete_chars(struct edit_buffer *, struct edit_mark *, size_t)\n-{\n- abort();\n-}\n-\n-edit_streambuf::edit_streambuf(edit_string* bstr, int mode)\n-{\n-    _mode = mode;\n-    str = bstr;\n-    edit_buffer* buffer = bstr->buffer;\n-    next = buffer->files;\n-    buffer->files = this;\n-    char* buf_ptr = bstr->start->ptr(buffer);\n-    _inserting = 0;\n-//    setb(buf_ptr, buf_ptr, 0);\n-    set_current(buf_ptr, !(mode & ios::out+ios::trunc+ios::app));\n-    if (_mode & ios::trunc)\n-\ttruncate();\n-    if (_mode & ios::ate)\n-\tseekoff(0, ios::end);\n-}\n-\n-// Called by fclose(fp) if fp is bound to a edit_buffer.\n-\n-#if 0\n-static int buf_close(void *arg)\n-{\n-    register struct buf_cookie *cookie = arg;\n-    struct edit_buffer *buffer = cookie->str->buffer;\n-    struct buf_cookie **ptr;\n-    for (ptr = &buffer->files; *ptr != cookie; ptr = &(*ptr)->next) ;\n-    *ptr = cookie->next;\n-    disconnect_gap_from_file(buffer, cookie->file);\n-    free (cookie);\n-    return 0;\n-}\n-#endif\n-\n-edit_streambuf::~edit_streambuf()\n-{\n-    if (_mode == ios::out)\n-\ttruncate();\n-    // Unlink this from list of files associated with bstr->buffer.\n-    edit_streambuf **ptr = &str->buffer->files;\n-    for (; *ptr != this; ptr = &(*ptr)->next) { }\n-    *ptr = next;\n-\n-    disconnect_gap_from_file(str->buffer);\n-}\n-\n-edit_buffer::edit_buffer()\n-{\n-    buf_size = /*200;*/ 15; /* for testing! */\n-    data = (buf_char*)malloc(buf_size);\n-    files = NULL;\n-#ifndef OLD_STDIO\n-    _gap_start = data;\n-    _writer = NULL;\n-#else\n-    gap_start_normal = data;\n-    gap_start_ptr = &gap_start_normal;\n-#endif\n-    __gap_end_pos = buf_size;\n-    start_mark.chain = &end_mark;\n-    start_mark._pos = 0;\n-    end_mark.chain = NULL;\n-    end_mark._pos = 2 * buf_size + 1;\n-}\n-\n-// Allocate a new mark, which is adjusted by 'delta' bytes from 'this'.\n-// Restrict new mark to lie within 'str'.\n-\n-edit_mark::edit_mark(struct edit_string *str, long delta)\n-{\n-    struct edit_buffer *buf = str->buffer;\n-    chain = buf->start_mark.chain;\n-    buf->start_mark.chain = this;\n-    mark_pointer size1 = buf->size1() << 1;\n-    int gap_size = buf->gap_size() << 1;\n-    delta <<= 1;\n-\n-    // check if new and old marks are opposite sides of gap\n-    if (_pos <= size1 && _pos + delta > size1)\n-\tdelta += gap_size;\n-    else if (_pos >= size1 + gap_size && _pos + delta < size1 + gap_size)\n-\tdelta -= gap_size;\n-\n-    _pos = _pos + delta;\n-    if (_pos < str->start->_pos & ~1)\n-\t_pos = (str->start->_pos & ~ 1) + (_pos & 1);\n-    else if (_pos >= str->end->_pos)\n-\t_pos = (str->end->_pos & ~ 1) + (_pos & 1);\n-}\n-\n-// A (slow) way to find the buffer a mark belongs to.\n-\n-edit_buffer * edit_mark::buffer()\n-{\n-    struct edit_mark *mark;\n-    for (mark = this; mark->chain != NULL; mark = mark->chain) ;\n-    // Assume that the last mark on the chain is the end_mark.\n-    return (edit_buffer *)((char*)mark - offsetof(edit_buffer, end_mark));\n-}\n-\n-edit_mark::~edit_mark()\n-{\n-    // Must unlink mark from chain of owning buffer\n-    struct edit_buffer *buf = buffer();\n-    if (this == &buf->start_mark || this == &buf->end_mark) abort();\n-    edit_mark **ptr;\n-    for (ptr = &buf->start_mark.chain; *ptr != this; ptr = &(*ptr)->chain) ;\n-    *ptr = this->chain;\n-}\n-\n-int edit_string::length() const\n-{\n-    ptrdiff_t delta = end->ptr(buffer) - start->ptr(buffer);\n-    if (end->ptr(buffer) <= buffer->gap_start() ||\n-\tstart->ptr(buffer) >= buffer->gap_end())\n-\treturn delta;\n-    return delta - buffer->gap_size();\n-}\n-\n-buf_char * edit_string::copy_bytes(int *lenp) const\n-{\n-    char *new_str;\n-    int len1, len2;\n-    buf_char *start1, *start2;\n-    start1 = start->ptr(buffer);\n-    if (end->ptr(buffer) <= buffer->gap_start()\n-\t|| start->ptr(buffer) >= buffer->gap_end()) {\n-\tlen1 = end->ptr(buffer) - start1;\n-\tlen2 = 0;\n-\tstart2 = NULL; // To avoid a warning from g++.\n-    }\n-    else {\n-\tlen1 = buffer->gap_start() - start1;\n-\tstart2 = buffer->gap_end();\n-\tlen2 = end->ptr(buffer) - start2;\n-    }\n-    new_str = (char*)malloc(len1 + len2 + 1);\n-    memcpy(new_str, start1, len1);\n-    if (len2 > 0) memcpy(new_str + len1, start2, len2);\n-    new_str[len1+len2] = '\\0';\n-    *lenp = len1+len2;\n-    return new_str;\n-}\n-\n-// Replace the buf_chars in 'this' with ones from 'src'.\n-// Equivalent to deleting this, then inserting src, except tries\n-// to leave marks in place: Marks whose offset from the start\n-// of 'this' is less than 'src->length()' will still have the\n-// same offset in 'this' when done.\n-\n-void edit_string::assign(struct edit_string *src)\n-{\n-    edit_streambuf dst_file(this, ios::out);\n-    if (buffer == src->buffer /*&& ???*/) { /* overly conservative */\n-\tint src_len;\n-\tbuf_char *new_str;\n-\tnew_str = src->copy_bytes(&src_len);\n-\tdst_file.sputn(new_str, src_len);\n-\tfree (new_str);\n-    } else {\n-\tedit_streambuf src_file(src, ios::in);\n-\tfor ( ; ; ) {\n-\t    int ch = src_file.sbumpc();\n-\t    if (ch == EOF) break;\n-\t    dst_file.sputc(ch);\n-\t}\n-    }\n-}"}, {"sha": "21574a96285b9d599b459feb528ddd63ce235ec7", "filename": "libio/editbuf.h", "status": "removed", "additions": 0, "deletions": 185, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Feditbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Feditbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Feditbuf.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,185 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993, 2000 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License.\n-\n-Written by Per Bothner (bothner@cygnus.com). */\n-\n-#ifndef _EDITBUF_H\n-#define _EDITBUF_H\n-#ifdef __GNUG__\n-#pragma interface\n-#endif\n-#include <stdio.h>\n-#include <fstream.h>\n-\n-extern \"C++\" {\n-typedef unsigned long mark_pointer;\n-// At some point, it might be nice to parameterize this code\n-// in terms of buf_char.\n-typedef /*unsigned*/ char buf_char;\n-\n-// Logical pos from start of buffer (does not count gap).\n-typedef long buf_index;\n-\t\t\t\n-// Pos from start of buffer, possibly including gap_size.\n-typedef long buf_offset; \n-\n-#if 0\n-struct buf_cookie {\n-    FILE *file;\n-    struct edit_string *str;\n-    struct buf_cookie *next;\n-    buf_index tell();\n-};\n-#endif\n-\n-struct edit_buffer;\n-struct edit_mark;\n-\n-// A edit_string is defined as the region between the 'start' and 'end' marks.\n-// Normally (always?) 'start->insert_before()' should be false,\n-// and 'end->insert_before()' should be true.\n-\n-struct edit_string {\n-    struct edit_buffer *buffer; // buffer that 'start' and 'end' belong to\n-    struct edit_mark *start, *end;\n-    int length() const; // count of buf_chars currently in string\n-    edit_string(struct edit_buffer *b,\n-\t\t      struct edit_mark *ms, struct edit_mark *me)\n-\t{ buffer = b; start = ms; end = me; }\n-/* Make a fresh, contiguous copy of the data in STR.\n-   Assign length of STR to *LENP.\n-   (Output has extra NUL at out[*LENP].) */\n-    buf_char *copy_bytes(int *lenp) const;\n-//    FILE *open_file(char *mode);\n-    void assign(struct edit_string *src); // copy bytes from src to this\n-};\n-\n-struct edit_streambuf : public streambuf {\n-    friend class edit_buffer;\n-    edit_string *str;\n-    edit_streambuf* next; // Chain of edit_streambuf's for a edit_buffer.\n-    short _mode;\n-    edit_streambuf(edit_string* bstr, int mode);\n-    ~edit_streambuf();\n-    virtual int underflow();\n-    virtual int overflow(int c = EOF);\n-    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);\n-    void flush_to_buffer();\n-    void flush_to_buffer(edit_buffer* buffer);\n-    int _inserting;\n-    int inserting() { return _inserting; }\n-    void inserting(int i) { _inserting = i; }\n-//    int delete_chars(int count, char* cut_buf); Not implemented.\n-    int truncate();\n-    int is_reading() { return gptr() != NULL; }\n-    buf_char* current() { return is_reading() ? gptr() : pptr(); }\n-    void set_current(char *p, int is_reading);\n-  protected:\n-    void disconnect_gap_from_file(edit_buffer* buffer);\n-};\n-\n-// A 'edit_mark' indicates a position in a buffer.\n-// It is \"attached\" the text (rather than the offset).\n-// There are two kinds of mark, which have different behavior\n-// when text is inserted at the mark:\n-// If 'insert_before()' is true the mark will be adjusted to be\n-// *after* the new text.\n-\n-struct edit_mark {\n-    struct edit_mark *chain;\n-    mark_pointer _pos;\n-    inline int insert_before() { return _pos & 1; }\n-    inline unsigned long index_in_buffer(struct edit_buffer *)\n-\t{ return _pos >> 1; }\n-    inline buf_char *ptr(struct edit_buffer *buf);\n-    buf_index tell();\n-    edit_mark() { }\n-    edit_mark(struct edit_string *str, long delta);\n-    edit_buffer *buffer();\n-    ~edit_mark();\n-};\n-\n-// A 'edit_buffer' consists of a sequence of buf_chars (the data),\n-// a list of edit_marks pointing into the data, and a list of FILEs\n-// also pointing into the data.\n-// A 'edit_buffer' coerced to a edit_string is the string of\n-// all the buf_chars in the buffer.\n-\n-// This implementation uses a conventional buffer gap (as in Emacs).\n-// The gap start is defined by de-referencing a (buf_char**).\n-// This is because sometimes a FILE is inserting into the buffer,\n-// so rather than having each putc adjust the gap, we use indirection\n-// to have the gap be defined as the write pointer of the FILE.\n-// (This assumes that putc adjusts a pointer (as in GNU's libc), not an index.)\n-\n-struct edit_buffer {\n-    buf_char *data; /* == emacs buffer_text.p1+1 */\n-    buf_char *_gap_start;\n-    edit_streambuf* _writer; // If non-NULL, currently writing stream\n-    inline buf_char *gap_start()\n-\t{ return _writer ? _writer->pptr() : _gap_start; }\n-    buf_offset __gap_end_pos; // size of part 1 + size of gap\n-    /* int gap; implicit: buf_size - size1 - size2 */\n-    int buf_size;\n-    struct edit_streambuf *files;\n-    struct edit_mark start_mark;\n-    struct edit_mark end_mark;\n-    edit_buffer();\n-    inline buf_offset gap_end_pos() { return __gap_end_pos; }\n-    inline struct edit_mark *start_marker() { return &start_mark; }\n-    inline struct edit_mark *end_marker() { return &end_mark; }\n-/* these should be protected, ultimately */\n-    buf_index tell(edit_mark*);\n-    buf_index tell(buf_char*);\n-    inline buf_char *gap_end() { return data + gap_end_pos(); }\n-    inline int gap_size() { return gap_end() - gap_start(); }\n-    inline int size1() { return gap_start() - data; }\n-    inline int size2() { return buf_size - gap_end_pos(); }\n-    inline struct edit_mark * mark_list() { return &start_mark; }\n-    void make_gap (buf_offset);\n-    void move_gap (buf_offset pos);\n-    void move_gap (buf_char *pos) { move_gap(pos - data); }\n-    void gap_left (int pos);\n-    void gap_right (int pos);\n-    void adjust_markers(mark_pointer low, mark_pointer high,\n-\t\t\tint amount, buf_char *old_data);\n-    void delete_range(buf_index from, buf_index to);\n-    void delete_range(struct edit_mark *start, struct edit_mark *end);\n-};\n-\n-extern buf_char * bstr_copy(struct edit_string *str, int *lenp);\n-\n-// Convert a edit_mark to a (buf_char*)\n-\n-inline buf_char *edit_mark::ptr(struct edit_buffer *buf)\n-\t{ return buf->data + index_in_buffer(buf); }\n-\n-inline void edit_streambuf::flush_to_buffer()\n-{\n-    edit_buffer* buffer = str->buffer;\n-    if (buffer->_writer == this) flush_to_buffer(buffer);\n-}\n-} // extern \"C++\"\n-#endif /* !_EDITBUF_H*/\n-"}, {"sha": "0b0fd6d88d3acba7d68031c8eee58c530ae690da", "filename": "libio/filebuf.cc", "status": "removed", "additions": 0, "deletions": 223, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffilebuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffilebuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ffilebuf.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,223 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993, 1995, 1999 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License.\n-\n-Written by Per Bothner (bothner@cygnus.com). */\n-\n-#include \"iostreamP.h\"\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <fcntl.h>\n-#include <errno.h>\n-#include \"builtinbuf.h\"\n-\n-void filebuf::init()\n-{\n-  _IO_file_init(this);\n-}\n-\n-filebuf::filebuf()\n-{\n-  _IO_file_init(this);\n-}\n-\n-#if !_IO_UNIFIED_JUMPTABLES\n-/* This is like \"new filebuf()\", but it uses the _IO_file_jump jumptable,\n-   for eficiency. */\n-\n-filebuf* filebuf::__new()\n-{\n-  filebuf *fb = new filebuf;\n-  _IO_JUMPS(fb) = &_IO_file_jumps;\n-  fb->_vtable() = builtinbuf_vtable;\n-  return fb;\n-}\n-#endif\n-\n-filebuf::filebuf(int fd)\n-{\n-  _IO_file_init(this);\n-  _IO_file_attach(this, fd);\n-}\n-\n-filebuf::filebuf(int fd, char* p, int len)\n-{\n-  _IO_file_init(this);\n-  _IO_file_attach(this, fd);\n-  setbuf(p, len);\n-}\n-\n-filebuf::~filebuf()\n-{\n-  if (_IO_file_is_open(this))\n-    {\n-      _IO_do_flush (this);\n-      if (!(xflags() & _IO_DELETE_DONT_CLOSE))\n-\t_IO_SYSCLOSE (this);\n-    }\n-}\n-\n-filebuf* filebuf::open(const char *filename, ios::openmode mode, int prot)\n-{\n-  if (_IO_file_is_open (this))\n-    return NULL;\n-  int posix_mode;\n-  int read_write;\n-  if (mode & ios::app)\n-    mode |= ios::out;\n-  if ((mode & (ios::in|ios::out)) == (ios::in|ios::out)) {\n-    posix_mode = O_RDWR;\n-    read_write = 0;\n-  }\n-  else if (mode & ios::out)\n-    posix_mode = O_WRONLY, read_write = _IO_NO_READS;\n-  else if (mode & (int)ios::in)\n-    posix_mode = O_RDONLY, read_write = _IO_NO_WRITES;\n-  else\n-    posix_mode = 0, read_write = _IO_NO_READS+_IO_NO_WRITES;\n-  if (mode & ios::binary)\n-    {\n-      mode &= ~ios::binary;\n-#ifdef O_BINARY\n-      /* This is a (mis-)feature of DOS/Windows C libraries. */\n-      posix_mode |= O_BINARY;\n-#endif\n-    }\n-  if ((mode & (int)ios::trunc) || mode == (int)ios::out)\n-    posix_mode |= O_TRUNC;\n-  if (mode & ios::app)\n-    posix_mode |= O_APPEND, read_write |= _IO_IS_APPENDING;\n-  if (!(mode & (int)ios::nocreate) && mode != ios::in)\n-    posix_mode |= O_CREAT;\n-  if (mode & (int)ios::noreplace)\n-    posix_mode |= O_EXCL;\n-#if _G_HAVE_IO_FILE_OPEN\n-  if (!_IO_file_open (this, filename, posix_mode, prot, \n-\t\t      read_write, 0))\n-    return NULL;\n-  if (mode & ios::ate) {\n-    if (pubseekoff(0, ios::end) == EOF) {\n-      _IO_un_link (this);\n-      return NULL;\n-    }\n-  }\n-  return this;\n-#else\n-  int fd = ::open(filename, posix_mode, prot);\n-  if (fd < 0)\n-    return NULL;\n-  _fileno = fd;\n-  xsetflags(read_write, _IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);\n-  if (mode & ios::ate) {\n-    if (pubseekoff(0, ios::end) == EOF)\n-      return NULL;\n-  }\n-  _IO_link_in(this);\n-  return this;\n-#endif\n-}\n-\n-filebuf* filebuf::open(const char *filename, const char *mode)\n-{\n-#if _G_IO_IO_FILE_VERSION == 0x20001\n-  return (filebuf*)_IO_file_fopen(this, filename, mode, 0);\n-#else\n-  return (filebuf*)_IO_file_fopen(this, filename, mode);\n-#endif\n-}\n-\n-filebuf* filebuf::attach(int fd)\n-{\n-  return (filebuf*)_IO_file_attach(this, fd);\n-}\n-\n-streambuf* filebuf::setbuf(char* p, int len)\n-{\n-  return (streambuf*)_IO_file_setbuf (this, p, len);\n-}\n-\n-int filebuf::doallocate() { return _IO_file_doallocate(this); }\n-\n-int filebuf::overflow(int c)\n-{\n-  return _IO_file_overflow(this, c);\n-}\n-\n-int filebuf::underflow()\n-{\n-  return _IO_file_underflow(this);\n-}\n-\n-int filebuf::sync()\n-{\n-  return _IO_file_sync(this);\n-}\n-\n-streampos filebuf::seekoff(streamoff offset, _seek_dir dir, int mode)\n-{\n-  return _IO_file_seekoff (this, offset, dir, mode);\n-}\n-\n-filebuf* filebuf::close()\n-{\n-  return (_IO_file_close_it(this) ? (filebuf*)NULL : this);\n-}\n-\n-streamsize filebuf::sys_read(char* buf, streamsize size)\n-{\n-  return _IO_file_read(this, buf, size);\n-}\n-\n-streampos filebuf::sys_seek(streamoff offset, _seek_dir dir)\n-{\n-  return _IO_file_seek(this, offset, dir);\n-}\n-\n-streamsize filebuf::sys_write(const char *buf, streamsize n)\n-{\n-  return _IO_file_write (this, buf, n);\n-}\n-\n-int filebuf::sys_stat(void* st)\n-{\n-  return _IO_file_stat (this, st);\n-}\n-\n-int filebuf::sys_close()\n-{\n-  return _IO_file_close (this);\n-}\n-\n-streamsize filebuf::xsputn(const char *s, streamsize n)\n-{\n-  return _IO_file_xsputn(this, s, n);\n-}\n-\n-streamsize filebuf::xsgetn(char *s, streamsize n)\n-{\n-    // FIXME: OPTIMIZE THIS (specifically, when unbuffered()).\n-    return streambuf::xsgetn(s, n);\n-}\n-\n-// Non-ANSI AT&T-ism:  Default open protection.\n-const int filebuf::openprot = 0644;"}, {"sha": "a27455c4a5cb3e20558c3a80f7692b4dc6500e75", "filename": "libio/filedoalloc.c", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffiledoalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffiledoalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ffiledoalloc.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,120 +0,0 @@\n-/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-/*\n- * Copyright (c) 1990 The Regents of the University of California.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. [rescinded 22 July 1999]\n- * 4. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- */\n-\n-/* Modified for GNU iostream by Per Bothner 1991, 1992. */\n-\n-#include \"libioP.h\"\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#include <unistd.h>\n-#endif\n-\n-#ifdef _LIBC\n-# undef isatty\n-# define isatty(Fd) __isatty (Fd)\n-#endif\n-\n-/*\n- * Allocate a file buffer, or switch to unbuffered I/O.\n- * Per the ANSI C standard, ALL tty devices default to line buffered.\n- *\n- * As a side effect, we set __SOPT or __SNPT (en/dis-able fseek\n- * optimisation) right after the _fstat() that finds the buffer size.\n- */\n-\n-int\n-_IO_file_doallocate (fp)\n-     _IO_FILE *fp;\n-{\n-  _IO_size_t size;\n-  int couldbetty;\n-  char *p;\n-  struct stat st;\n-\n-#if !defined(_LIBC) && !defined(__linux__)\n-  /* If _IO_cleanup_registration_needed is non-zero, we should call the\n-     function it points to.  This is to make sure _IO_cleanup gets called\n-     on exit.  We call it from _IO_file_doallocate, since that is likely\n-     to get called by any program that does buffered I/O. */\n-  if (_IO_cleanup_registration_needed)\n-    (*_IO_cleanup_registration_needed) ();\n-#endif\n-\n-  if (fp->_fileno < 0 || _IO_SYSSTAT (fp, &st) < 0)\n-    {\n-      couldbetty = 0;\n-      size = _IO_BUFSIZ;\n-#if 0\n-      /* do not try to optimise fseek() */\n-      fp->_flags |= __SNPT;\n-#endif\n-    }\n-  else\n-    {\n-      couldbetty = S_ISCHR (st.st_mode);\n-#if _IO_HAVE_ST_BLKSIZE\n-      size = st.st_blksize <= 0 ? _IO_BUFSIZ : st.st_blksize;\n-#else\n-      size = _IO_BUFSIZ;\n-#endif\n-    }\n-  ALLOC_BUF (p, size, EOF);\n-  _IO_setb (fp, p, p + size, 1);\n-  if (couldbetty && isatty (fp->_fileno))\n-    fp->_flags |= _IO_LINE_BUF;\n-  return 1;\n-}"}, {"sha": "54e13d3f18feaab37a847ebe80ef3cfe03b80cc2", "filename": "libio/fileops.c", "status": "removed", "additions": 0, "deletions": 811, "changes": 811, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffileops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffileops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ffileops.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,811 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-   Written by Per Bothner <bothner@cygnus.com>.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-\n-#include \"libioP.h\"\n-#include <fcntl.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <string.h>\n-#include <unistd.h>\n-#include <errno.h>\n-#ifndef errno\n-extern int errno;\n-#endif\n-\n-\n-#ifdef _LIBC\n-# define open(Name, Flags, Prot) __open (Name, Flags, Prot)\n-# define close(FD) __close (FD)\n-# define fstat(FD, Statbuf) __fstat (FD, Statbuf)\n-# define lseek(FD, Offset, Whence) __lseek (FD, Offset, Whence)\n-# define read(FD, Buf, NBytes) __read (FD, Buf, NBytes)\n-# define write(FD, Buf, NBytes) __write (FD, Buf, NBytes)\n-#endif\n-\n-/* An fstream can be in at most one of put mode, get mode, or putback mode.\n-   Putback mode is a variant of get mode.\n-\n-   In a filebuf, there is only one current position, instead of two\n-   separate get and put pointers.  In get mode, the current position\n-   is that of gptr(); in put mode that of pptr().\n-\n-   The position in the buffer that corresponds to the position\n-   in external file system is normally _IO_read_end, except in putback\n-   mode, when it is _IO_save_end.\n-   If the field _fb._offset is >= 0, it gives the offset in\n-   the file as a whole corresponding to eGptr(). (?)\n-\n-   PUT MODE:\n-   If a filebuf is in put mode, then all of _IO_read_ptr, _IO_read_end,\n-   and _IO_read_base are equal to each other.  These are usually equal\n-   to _IO_buf_base, though not necessarily if we have switched from\n-   get mode to put mode.  (The reason is to maintain the invariant\n-   that _IO_read_end corresponds to the external file position.)\n-   _IO_write_base is non-NULL and usually equal to _IO_base_base.\n-   We also have _IO_write_end == _IO_buf_end, but only in fully buffered mode.\n-   The un-flushed character are those between _IO_write_base and _IO_write_ptr.\n-\n-   GET MODE:\n-   If a filebuf is in get or putback mode, eback() != egptr().\n-   In get mode, the unread characters are between gptr() and egptr().\n-   The OS file position corresponds to that of egptr().\n-\n-   PUTBACK MODE:\n-   Putback mode is used to remember \"excess\" characters that have\n-   been sputbackc'd in a separate putback buffer.\n-   In putback mode, the get buffer points to the special putback buffer.\n-   The unread characters are the characters between gptr() and egptr()\n-   in the putback buffer, as well as the area between save_gptr()\n-   and save_egptr(), which point into the original reserve buffer.\n-   (The pointers save_gptr() and save_egptr() are the values\n-   of gptr() and egptr() at the time putback mode was entered.)\n-   The OS position corresponds to that of save_egptr().\n-\n-   LINE BUFFERED OUTPUT:\n-   During line buffered output, _IO_write_base==base() && epptr()==base().\n-   However, ptr() may be anywhere between base() and ebuf().\n-   This forces a call to filebuf::overflow(int C) on every put.\n-   If there is more space in the buffer, and C is not a '\\n',\n-   then C is inserted, and pptr() incremented.\n-\n-   UNBUFFERED STREAMS:\n-   If a filebuf is unbuffered(), the _shortbuf[1] is used as the buffer.\n-*/\n-\n-#define CLOSED_FILEBUF_FLAGS \\\n-  (_IO_IS_FILEBUF+_IO_NO_READS+_IO_NO_WRITES+_IO_TIED_PUT_GET)\n-\n-\n-void\n-_IO_file_init (fp)\n-     _IO_FILE *fp;\n-{\n-  /* POSIX.1 allows another file handle to be used to change the position\n-     of our file descriptor.  Hence we actually don't know the actual\n-     position before we do the first fseek (and until a following fflush). */\n-  fp->_offset = _IO_pos_BAD;\n-  fp->_IO_file_flags |= CLOSED_FILEBUF_FLAGS;\n-\n-  _IO_link_in(fp);\n-  fp->_fileno = -1;\n-}\n-\n-int\n-_IO_file_close_it (fp)\n-     _IO_FILE *fp;\n-{\n-  int write_status, close_status;\n-  if (!_IO_file_is_open (fp))\n-    return EOF;\n-\n-  write_status = _IO_do_flush (fp);\n-\n-  _IO_unsave_markers(fp);\n-\n-  close_status = _IO_SYSCLOSE (fp);\n-\n-  /* Free buffer. */\n-  _IO_setb (fp, NULL, NULL, 0);\n-  _IO_setg (fp, NULL, NULL, NULL);\n-  _IO_setp (fp, NULL, NULL);\n-\n-  _IO_un_link (fp);\n-  fp->_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;\n-  fp->_fileno = EOF;\n-  fp->_offset = _IO_pos_BAD;\n-\n-  return close_status ? close_status : write_status;\n-}\n-\n-void\n-_IO_file_finish (fp, dummy)\n-     _IO_FILE *fp;\n-     int dummy;\n-{\n-  if (_IO_file_is_open (fp))\n-    {\n-      _IO_do_flush (fp);\n-      if (!(fp->_flags & _IO_DELETE_DONT_CLOSE))\n-\t_IO_SYSCLOSE (fp);\n-    }\n-  _IO_default_finish (fp, 0);\n-}\n-\n-_IO_FILE *\n-_IO_file_fopen (fp, filename, mode)\n-     _IO_FILE *fp;\n-     const char *filename;\n-     const char *mode;\n-{\n-  int oflags = 0, omode;\n-  int read_write, fdesc;\n-  int oprot = 0666;\n-  if (_IO_file_is_open (fp))\n-    return 0;\n-  switch (*mode++)\n-    {\n-    case 'r':\n-      omode = O_RDONLY;\n-      read_write = _IO_NO_WRITES;\n-      break;\n-    case 'w':\n-      omode = O_WRONLY;\n-      oflags = O_CREAT|O_TRUNC;\n-      read_write = _IO_NO_READS;\n-      break;\n-    case 'a':\n-      omode = O_WRONLY;\n-      oflags = O_CREAT|O_APPEND;\n-      read_write = _IO_NO_READS|_IO_IS_APPENDING;\n-      break;\n-    default:\n-      __set_errno (EINVAL);\n-      return NULL;\n-    }\n-  if (mode[0] == '+' || (mode[0] == 'b' && mode[1] == '+'))\n-    {\n-      omode = O_RDWR;\n-      read_write &= _IO_IS_APPENDING;\n-    }\n-  fdesc = open (filename, omode|oflags, oprot);\n-  if (fdesc < 0)\n-    return NULL;\n-  fp->_fileno = fdesc;\n-  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);\n-  if (read_write & _IO_IS_APPENDING)\n-    if (_IO_SEEKOFF (fp, (_IO_off_t)0, _IO_seek_end, _IOS_INPUT|_IOS_OUTPUT)\n-\t== _IO_pos_BAD && errno != ESPIPE)\n-      return NULL;\n-  _IO_link_in (fp);\n-  return fp;\n-}\n-\n-_IO_FILE *\n-_IO_file_attach (fp, fd)\n-     _IO_FILE *fp;\n-     int fd;\n-{\n-  if (_IO_file_is_open (fp))\n-    return NULL;\n-  fp->_fileno = fd;\n-  fp->_flags &= ~(_IO_NO_READS+_IO_NO_WRITES);\n-  fp->_flags |= _IO_DELETE_DONT_CLOSE;\n-  /* Get the current position of the file. */\n-  /* We have to do that since that may be junk. */\n-  fp->_offset = _IO_pos_BAD;\n-  if (_IO_SEEKOFF (fp, (_IO_off_t)0, _IO_seek_cur, _IOS_INPUT|_IOS_OUTPUT)\n-      == _IO_pos_BAD && errno != ESPIPE)\n-    return NULL;\n-  return fp;\n-}\n-\n-_IO_FILE *\n-_IO_file_setbuf (fp, p, len)\n-     _IO_FILE *fp;\n-     char *p;\n-     _IO_ssize_t len;\n-{\n-    if (_IO_default_setbuf (fp, p, len) == NULL)\n-      return NULL;\n-\n-    fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end\n-      = fp->_IO_buf_base;\n-    _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-\n-    return fp;\n-}\n-\n-/* Write TO_DO bytes from DATA to FP.\n-   Then mark FP as having empty buffers. */\n-\n-int\n-_IO_do_write (fp, data, to_do)\n-     _IO_FILE *fp;\n-     const char *data;\n-     _IO_size_t to_do;\n-{\n-  _IO_size_t count;\n-  if (to_do == 0)\n-    return 0;\n-  if (fp->_flags & _IO_IS_APPENDING)\n-    /* On a system without a proper O_APPEND implementation,\n-       you would need to sys_seek(0, SEEK_END) here, but it\n-       is not needed nor desirable for Unix- or Posix-like systems.\n-       Instead, just indicate that offset (before and after) is\n-       unpredictable. */\n-    fp->_offset = _IO_pos_BAD;\n-  else if (fp->_IO_read_end != fp->_IO_write_base)\n-    {\n-      _IO_pos_t new_pos\n-\t= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);\n-      if (new_pos == _IO_pos_BAD)\n-\treturn EOF;\n-      fp->_offset = new_pos;\n-    }\n-  count = _IO_SYSWRITE (fp, data, to_do);\n-  if (fp->_cur_column)\n-    fp->_cur_column = _IO_adjust_column (fp->_cur_column - 1, data, to_do) + 1;\n-  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_buf_base;\n-  fp->_IO_write_end = ((fp->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n-\t\t       ? fp->_IO_buf_base : fp->_IO_buf_end);\n-  return count != to_do ? EOF : 0;\n-}\n-\n-int\n-_IO_file_underflow (fp)\n-     _IO_FILE *fp;\n-{\n-  _IO_ssize_t count;\n-#if 0\n-  /* SysV does not make this test; take it out for compatibility */\n-  if (fp->_flags & _IO_EOF_SEEN)\n-    return (EOF);\n-#endif\n-\n-  if (fp->_flags & _IO_NO_READS)\n-    {\n-      __set_errno (EBADF);\n-      return EOF;\n-    }\n-  if (fp->_IO_read_ptr < fp->_IO_read_end)\n-    return *(unsigned char *) fp->_IO_read_ptr;\n-\n-  if (fp->_IO_buf_base == NULL)\n-    _IO_doallocbuf (fp);\n-\n-  /* Flush all line buffered files before reading. */\n-  /* FIXME This can/should be moved to genops ?? */\n-  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))\n-    _IO_flush_all_linebuffered ();\n-\n-  _IO_switch_to_get_mode (fp);\n-\n-  /* This is very tricky. We have to adjust those\n-     pointers before we call _IO_SYSREAD () since\n-     we may longjump () out while waiting for\n-     input. Those pointers may be screwed up. H.J. */\n-  fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;\n-  fp->_IO_read_end = fp->_IO_buf_base;\n-  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end\n-    = fp->_IO_buf_base;\n-\n-  count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n-\t\t       fp->_IO_buf_end - fp->_IO_buf_base);\n-  if (count <= 0)\n-    {\n-      if (count == 0)\n-\tfp->_flags |= _IO_EOF_SEEN;\n-      else\n-\tfp->_flags |= _IO_ERR_SEEN, count = 0;\n-  }\n-  fp->_IO_read_end += count;\n-  if (count == 0)\n-    return EOF;\n-  if (fp->_offset != _IO_pos_BAD)\n-    _IO_pos_adjust (fp->_offset, count);\n-  return *(unsigned char *) fp->_IO_read_ptr;\n-}\n-\n-int\n-_IO_file_overflow (f, ch)\n-      _IO_FILE *f;\n-      int ch;\n-{\n-  if (f->_flags & _IO_NO_WRITES) /* SET ERROR */\n-    {\n-      f->_flags |= _IO_ERR_SEEN;\n-      __set_errno (EBADF);\n-      return EOF;\n-    }\n-  /* If currently reading or no buffer allocated. */\n-  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0)\n-    {\n-      /* Allocate a buffer if needed. */\n-      if (f->_IO_write_base == 0)\n-\t{\n-\t  _IO_doallocbuf (f);\n-\t  _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);\n-\t}\n-      /* Otherwise must be currently reading.\n-\t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\n-\t logically slide the buffer forwards one block (by setting the\n-\t read pointers to all point at the beginning of the block).  This\n-\t makes room for subsequent output.\n-\t Otherwise, set the read pointers to _IO_read_end (leaving that\n-\t alone, so it can continue to correspond to the external position). */\n-      if (f->_IO_read_ptr == f->_IO_buf_end)\n-\tf->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;\n-      f->_IO_write_ptr = f->_IO_read_ptr;\n-      f->_IO_write_base = f->_IO_write_ptr;\n-      f->_IO_write_end = f->_IO_buf_end;\n-      f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;\n-\n-      if (f->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n-\tf->_IO_write_end = f->_IO_write_ptr;\n-      f->_flags |= _IO_CURRENTLY_PUTTING;\n-    }\n-  if (ch == EOF)\n-    return _IO_do_flush (f);\n-  if (f->_IO_write_ptr == f->_IO_buf_end ) /* Buffer is really full */\n-    if (_IO_do_flush (f) == EOF)\n-      return EOF;\n-  *f->_IO_write_ptr++ = ch;\n-  if ((f->_flags & _IO_UNBUFFERED)\n-      || ((f->_flags & _IO_LINE_BUF) && ch == '\\n'))\n-    if (_IO_do_flush (f) == EOF)\n-      return EOF;\n-  return (unsigned char) ch;\n-}\n-\n-int\n-_IO_file_sync (fp)\n-     _IO_FILE *fp;\n-{\n-  _IO_size_t delta;\n-  int retval = 0;\n-\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  /*    char* ptr = cur_ptr(); */\n-  if (fp->_IO_write_ptr > fp->_IO_write_base)\n-    if (_IO_do_flush(fp)) return EOF;\n-  delta = fp->_IO_read_ptr - fp->_IO_read_end;\n-  if (delta != 0)\n-    {\n-#ifdef TODO\n-      if (_IO_in_backup (fp))\n-\tdelta -= eGptr () - Gbase ();\n-#endif\n-      _IO_off_t new_pos = _IO_SYSSEEK (fp, delta, 1);\n-      if (new_pos != (_IO_off_t) EOF)\n-\tfp->_IO_read_end = fp->_IO_read_ptr;\n-#ifdef ESPIPE\n-      else if (errno == ESPIPE)\n-\t; /* Ignore error from unseekable devices. */\n-#endif\n-      else\n-\tretval = EOF;\n-    }\n-  if (retval != EOF)\n-    fp->_offset = _IO_pos_BAD;\n-  /* FIXME: Cleanup - can this be shared? */\n-  /*    setg(base(), ptr, ptr); */\n-  _IO_cleanup_region_end (1);\n-  return retval;\n-}\n-\n-_IO_pos_t\n-_IO_file_seekoff (fp, offset, dir, mode)\n-     _IO_FILE *fp;\n-     _IO_off_t offset;\n-     int dir;\n-     int mode;\n-{\n-  _IO_pos_t result;\n-  _IO_off_t delta, new_offset;\n-  long count;\n-  /* POSIX.1 8.2.3.7 says that after a call the fflush() the file\n-     offset of the underlying file must be exact.  */\n-  int must_be_exact = (fp->_IO_read_base == fp->_IO_read_end\n-\t\t       && fp->_IO_write_base == fp->_IO_write_ptr);\n-\n-  if (mode == 0)\n-    dir = _IO_seek_cur, offset = 0; /* Don't move any pointers. */\n-\n-  /* Flush unwritten characters.\n-     (This may do an unneeded write if we seek within the buffer.\n-     But to be able to switch to reading, we would need to set\n-     egptr to ptr.  That can't be done in the current design,\n-     which assumes file_ptr() is eGptr.  Anyway, since we probably\n-     end up flushing when we close(), it doesn't make much difference.)\n-     FIXME: simulate mem-papped files. */\n-\n-  if (fp->_IO_write_ptr > fp->_IO_write_base || _IO_in_put_mode (fp))\n-    if (_IO_switch_to_get_mode (fp))\n-      return EOF;\n-\n-  if (fp->_IO_buf_base == NULL)\n-    {\n-      _IO_doallocbuf (fp);\n-      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-    }\n-\n-  switch (dir)\n-    {\n-    case _IO_seek_cur:\n-      /* Adjust for read-ahead (bytes is buffer). */\n-      offset -= fp->_IO_read_end - fp->_IO_read_ptr;\n-      if (fp->_offset == _IO_pos_BAD)\n-\tgoto dumb;\n-      /* Make offset absolute, assuming current pointer is file_ptr(). */\n-      offset += _IO_pos_as_off (fp->_offset);\n-\n-      dir = _IO_seek_set;\n-      break;\n-    case _IO_seek_set:\n-      break;\n-    case _IO_seek_end:\n-      {\n-\tstruct stat st;\n-\tif (_IO_SYSSTAT (fp, &st) == 0 && S_ISREG (st.st_mode))\n-\t  {\n-\t    offset += st.st_size;\n-\t    dir = _IO_seek_set;\n-\t  }\n-\telse\n-\t  goto dumb;\n-      }\n-    }\n-  /* At this point, dir==_IO_seek_set. */\n-\n-  /* If destination is within current buffer, optimize: */\n-  if (fp->_offset != _IO_pos_BAD && fp->_IO_read_base != NULL\n-      && !_IO_in_backup (fp))\n-    {\n-      /* Offset relative to start of main get area. */\n-      _IO_pos_t rel_offset = (offset - fp->_offset\n-\t\t\t      + (fp->_IO_read_end - fp->_IO_read_base));\n-      if (rel_offset >= 0)\n-\t{\n-#if 0\n-\t  if (_IO_in_backup (fp))\n-\t    _IO_switch_to_main_get_area (fp);\n-#endif\n-\t  if (rel_offset <= fp->_IO_read_end - fp->_IO_read_base)\n-\t    {\n-\t      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base + rel_offset,\n-\t\t\tfp->_IO_read_end);\n-\t      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-\t      return offset;\n-\t    }\n-#ifdef TODO\n-\t    /* If we have streammarkers, seek forward by reading ahead. */\n-\t    if (_IO_have_markers (fp))\n-\t      {\n-\t\tint to_skip = rel_offset\n-\t\t  - (fp->_IO_read_ptr - fp->_IO_read_base);\n-\t\tif (ignore (to_skip) != to_skip)\n-\t\t  goto dumb;\n-\t\treturn offset;\n-\t      }\n-#endif\n-\t}\n-#ifdef TODO\n-      if (rel_offset < 0 && rel_offset >= Bbase () - Bptr ())\n-\t{\n-\t  if (!_IO_in_backup (fp))\n-\t    _IO_switch_to_backup_area (fp);\n-\t  gbump (fp->_IO_read_end + rel_offset - fp->_IO_read_ptr);\n-\t  return offset;\n-\t}\n-#endif\n-    }\n-\n-#ifdef TODO\n-  _IO_unsave_markers (fp);\n-#endif\n-\n-  if (fp->_flags & _IO_NO_READS)\n-    goto dumb;\n-\n-  /* Try to seek to a block boundary, to improve kernel page management. */\n-  new_offset = offset & ~(fp->_IO_buf_end - fp->_IO_buf_base - 1);\n-  delta = offset - new_offset;\n-  if (delta > fp->_IO_buf_end - fp->_IO_buf_base)\n-    {\n-      new_offset = offset;\n-      delta = 0;\n-    }\n-  result = _IO_SYSSEEK (fp, new_offset, 0);\n-  if (result < 0)\n-    return EOF;\n-  if (delta == 0)\n-    count = 0;\n-  else\n-    {\n-      count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n-\t\t\t   (must_be_exact\n-\t\t\t    ? delta : fp->_IO_buf_end - fp->_IO_buf_base));\n-      if (count < delta)\n-\t{\n-\t  /* We weren't allowed to read, but try to seek the remainder. */\n-\t  offset = count == EOF ? delta : delta-count;\n-\t  dir = _IO_seek_cur;\n-\t  goto dumb;\n-\t}\n-    }\n-  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base + delta,\n-\t    fp->_IO_buf_base + count);\n-  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-  fp->_offset = result + count;\n-  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-  return offset;\n- dumb:\n-\n-  _IO_unsave_markers (fp);\n-  result = _IO_SYSSEEK (fp, offset, dir);\n-  if (result != EOF)\n-    _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-  fp->_offset = result;\n-  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-  return result;\n-}\n-\n-_IO_ssize_t\n-_IO_file_read (fp, buf, size)\n-     _IO_FILE *fp;\n-     void *buf;\n-     _IO_ssize_t size;\n-{\n-  return read (fp->_fileno, buf, size);\n-}\n-\n-_IO_pos_t\n-_IO_file_seek (fp, offset, dir)\n-     _IO_FILE *fp;\n-     _IO_off_t offset;\n-     int dir;\n-{\n-  return lseek (fp->_fileno, offset, dir);\n-}\n-\n-int\n-_IO_file_stat (fp, st)\n-     _IO_FILE *fp;\n-     void *st;\n-{\n-  return fstat (fp->_fileno, (struct stat *) st);\n-}\n-\n-int\n-_IO_file_close (fp)\n-     _IO_FILE *fp;\n-{\n-  return close (fp->_fileno);\n-}\n-\n-_IO_ssize_t\n-_IO_file_write (f, data, n)\n-     _IO_FILE *f;\n-     const void *data;\n-     _IO_ssize_t n;\n-{\n-  _IO_ssize_t to_do = n;\n-  while (to_do > 0)\n-    {\n-      _IO_ssize_t count = write (f->_fileno, data, to_do);\n-      if (count == EOF)\n-\t{\n-\t  f->_flags |= _IO_ERR_SEEN;\n-\t  break;\n-        }\n-      to_do -= count;\n-      data = (void *) ((char *) data + count);\n-    }\n-  n -= to_do;\n-  if (f->_offset >= 0)\n-    f->_offset += n;\n-  return n;\n-}\n-\n-_IO_size_t\n-_IO_file_xsputn (f, data, n)\n-     _IO_FILE *f;\n-     const void *data;\n-     _IO_size_t n;\n-{\n-  register const char *s = (char *) data;\n-  _IO_size_t to_do = n;\n-  int must_flush = 0;\n-  _IO_size_t count;\n-\n-  if (n <= 0)\n-    return 0;\n-  /* This is an optimized implementation.\n-     If the amount to be written straddles a block boundary\n-     (or the filebuf is unbuffered), use sys_write directly. */\n-\n-  /* First figure out how much space is available in the buffer. */\n-  count = f->_IO_write_end - f->_IO_write_ptr; /* Space available. */\n-  if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))\n-    {\n-      count = f->_IO_buf_end - f->_IO_write_ptr;\n-      if (count >= n)\n-\t{\n-\t  register const char *p;\n-\t  for (p = s + n; p > s; )\n-\t    {\n-\t      if (*--p == '\\n')\n-\t\t{\n-\t\t  count = p - s + 1;\n-\t\t  must_flush = 1;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  /* Then fill the buffer. */\n-  if (count > 0)\n-    {\n-      if (count > to_do)\n-\tcount = to_do;\n-      if (count > 20)\n-\t{\n-\t  memcpy (f->_IO_write_ptr, s, count);\n-\t  s += count;\n-\t}\n-      else\n-\t{\n-\t  register char *p = f->_IO_write_ptr;\n-\t  register int i = (int) count;\n-\t  while (--i >= 0)\n-\t    *p++ = *s++;\n-\t}\n-      f->_IO_write_ptr += count;\n-      to_do -= count;\n-    }\n-  if (to_do + must_flush > 0)\n-    {\n-      _IO_size_t block_size, dont_write;\n-      /* Next flush the (full) buffer. */\n-      if (__overflow (f, EOF) == EOF)\n-\treturn n - to_do;\n-\n-      /* Try to maintain alignment: write a whole number of blocks.\n-\t dont_write is what gets left over. */\n-      block_size = f->_IO_buf_end - f->_IO_buf_base;\n-      dont_write = block_size >= 128 ? to_do % block_size : 0;\n-\n-      count = to_do - dont_write;\n-      if (_IO_do_write (f, s, count) == EOF)\n-\treturn n - to_do;\n-      to_do = dont_write;\n-\n-      /* Now write out the remainder.  Normally, this will fit in the\n-\t buffer, but it's somewhat messier for line-buffered files,\n-\t so we let _IO_default_xsputn handle the general case. */\n-      if (dont_write)\n-\tto_do -= _IO_default_xsputn (f, s+count, dont_write);\n-    }\n-  return n - to_do;\n-}\n-\n-#if 0\n-/* Work in progress */\n-_IO_size_t\n-_IO_file_xsgetn (fp, data, n)\n-     _IO_FILE *fp;\n-     void *data;\n-     _IO_size_t n;\n-{\n-  register _IO_size_t more = n;\n-  register char *s = data;\n-  for (;;)\n-    {\n-      /* Data available. */\n-      _IO_ssize_t count = fp->_IO_read_end - fp->_IO_read_ptr;\n-      if (count > 0)\n-\t{\n-\t  if (count > more)\n-\t    count = more;\n-\t  if (count > 20)\n-\t    {\n-\t      memcpy (s, fp->_IO_read_ptr, count);\n-\t      s += count;\n-\t      fp->_IO_read_ptr += count;\n-\t    }\n-\t  else if (count <= 0)\n-\t    count = 0;\n-\t  else\n-\t    {\n-\t      register char *p = fp->_IO_read_ptr;\n-\t      register int i = (int) count;\n-\t      while (--i >= 0)\n-\t\t*s++ = *p++;\n-\t      fp->_IO_read_ptr = p;\n-            }\n-            more -= count;\n-        }\n-#if 0\n-      if (! _IO_in put_mode (fp)\n-\t  && ! _IO_have_markers (fp) && ! IO_have_backup (fp))\n-\t{\n-\t  /* This is an optimization of _IO_file_underflow */\n-\t  if (fp->_flags & _IO_NO_READS)\n-\t    break;\n-\t  /* If we're reading a lot of data, don't bother allocating\n-\t     a buffer.  But if we're only reading a bit, perhaps we should ??*/\n-\t  if (count <= 512 && fp->_IO_buf_base == NULL)\n-\t    _IO_doallocbuf (fp);\n-\t  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))\n-\t    _IO_flush_all_linebuffered ();\n-\n-\t  _IO_switch_to_get_mode (fp); ???;\n-\t  count = _IO_SYSREAD (fp, s, more);\n-\t  if (count <= 0)\n-\t     {\n-\t       if (count == 0)\n-\t\t fp->_flags |= _IO_EOF_SEEN;\n-\t       else\n-\t\t fp->_flags |= _IO_ERR_SEEN, count = 0;\n-\t     }\n-\n-\t  s += count;\n-\t  more -= count;\n-\t}\n-#endif\n-      if (more == 0 || __underflow (fp) == EOF)\n-\tbreak;\n-    }\n-  return n - more;\n-}\n-#endif\n-\n-struct _IO_jump_t _IO_file_jumps =\n-{\n-  JUMP_INIT_DUMMY,\n-  JUMP_INIT(finish, _IO_file_finish),\n-  JUMP_INIT(overflow, _IO_file_overflow),\n-  JUMP_INIT(underflow, _IO_file_underflow),\n-  JUMP_INIT(uflow, _IO_default_uflow),\n-  JUMP_INIT(pbackfail, _IO_default_pbackfail),\n-  JUMP_INIT(xsputn, _IO_file_xsputn),\n-  JUMP_INIT(xsgetn, _IO_default_xsgetn),\n-  JUMP_INIT(seekoff, _IO_file_seekoff),\n-  JUMP_INIT(seekpos, _IO_default_seekpos),\n-  JUMP_INIT(setbuf, _IO_file_setbuf),\n-  JUMP_INIT(sync, _IO_file_sync),\n-  JUMP_INIT(doallocate, _IO_file_doallocate),\n-  JUMP_INIT(read, _IO_file_read),\n-  JUMP_INIT(write, _IO_file_write),\n-  JUMP_INIT(seek, _IO_file_seek),\n-  JUMP_INIT(close, _IO_file_close),\n-  JUMP_INIT(stat, _IO_file_stat)\n-};"}, {"sha": "9503187b5d574e1d5a4dfe8e76729c661de1bb88", "filename": "libio/floatconv.c", "status": "removed", "additions": 0, "deletions": 2375, "changes": 2375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffloatconv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffloatconv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ffloatconv.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,2375 +0,0 @@\n-/* \n-Copyright (C) 1993, 1994 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#include <libioP.h>\n-#ifdef _IO_USE_DTOA\n-/****************************************************************\n- *\n- * The author of this software is David M. Gay.\n- *\n- * Copyright (c) 1991 by AT&T.\n- *\n- * Permission to use, copy, modify, and distribute this software for any\n- * purpose without fee is hereby granted, provided that this entire notice\n- * is included in all copies of any software which is or includes a copy\n- * or modification of this software and in all copies of the supporting\n- * documentation for such software.\n- *\n- * THIS SOFTWARE IS BEING PROVIDED \"AS IS\", WITHOUT ANY EXPRESS OR IMPLIED\n- * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR AT&T MAKES ANY\n- * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY\n- * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.\n- *\n- ***************************************************************/\n-\n-/* Some cleaning up by Per Bothner, bothner@cygnus.com, 1992, 1993.\n-   Re-written to not need static variables\n-   (except result, result_k, HIWORD, LOWORD). */\n-\n-/* Note that the checking of _DOUBLE_IS_32BITS is for use with the\n-   cross targets that employ the newlib ieeefp.h header.  -- brendan */\n-\n-/* Please send bug reports to\n-        David M. Gay\n-        AT&T Bell Laboratories, Room 2C-463\n-        600 Mountain Avenue\n-        Murray Hill, NJ 07974-2070\n-        U.S.A.\n-        dmg@research.att.com or research!dmg\n- */\n-\n-/* strtod for IEEE-, VAX-, and IBM-arithmetic machines.\n- *\n- * This strtod returns a nearest machine number to the input decimal\n- * string (or sets errno to ERANGE).  With IEEE arithmetic, ties are\n- * broken by the IEEE round-even rule.  Otherwise ties are broken by\n- * biased rounding (add half and chop).\n- *\n- * Inspired loosely by William D. Clinger's paper \"How to Read Floating\n- * Point Numbers Accurately\" [Proc. ACM SIGPLAN '90, pp. 92-101].\n- *\n- * Modifications:\n- *\n- *      1. We only require IEEE, IBM, or VAX double-precision\n- *              arithmetic (not IEEE double-extended).\n- *      2. We get by with floating-point arithmetic in a case that\n- *              Clinger missed -- when we're computing d * 10^n\n- *              for a small integer d and the integer n is not too\n- *              much larger than 22 (the maximum integer k for which\n- *              we can represent 10^k exactly), we may be able to\n- *              compute (d*10^k) * 10^(e-k) with just one roundoff.\n- *      3. Rather than a bit-at-a-time adjustment of the binary\n- *              result in the hard case, we use floating-point\n- *              arithmetic to determine the adjustment to within\n- *              one bit; only in really hard cases do we need to\n- *              compute a second residual.\n- *      4. Because of 3., we don't need a large table of powers of 10\n- *              for ten-to-e (just some small tables, e.g. of 10^k\n- *              for 0 <= k <= 22).\n- */\n-\n-/*\n- * #define IEEE_8087 for IEEE-arithmetic machines where the least\n- *      significant byte has the lowest address.\n- * #define IEEE_MC68k for IEEE-arithmetic machines where the most\n- *      significant byte has the lowest address.\n- * #define Sudden_Underflow for IEEE-format machines without gradual\n- *      underflow (i.e., that flush to zero on underflow).\n- * #define IBM for IBM mainframe-style floating-point arithmetic.\n- * #define VAX for VAX-style floating-point arithmetic.\n- * #define Unsigned_Shifts if >> does treats its left operand as unsigned.\n- * #define No_leftright to omit left-right logic in fast floating-point\n- *      computation of dtoa.\n- * #define Check_FLT_ROUNDS if FLT_ROUNDS can assume the values 2 or 3.\n- * #define RND_PRODQUOT to use rnd_prod and rnd_quot (assembly routines\n- *      that use extended-precision instructions to compute rounded\n- *      products and quotients) with IBM.\n- * #define ROUND_BIASED for IEEE-format with biased rounding.\n- * #define Inaccurate_Divide for IEEE-format with correctly rounded\n- *      products but inaccurate quotients, e.g., for Intel i860.\n- * #define KR_headers for old-style C function headers.\n- */\n-\n-#ifdef DEBUG\n-#include <stdio.h>\n-#define Bug(x) {fprintf(stderr, \"%s\\n\", x); exit(1);}\n-#endif\n-\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#include <string.h>\n-#include <float.h>\n-#define CONST const\n-#else\n-#define CONST\n-#define KR_headers\n-\n-/* In this case, we assume IEEE floats. */\n-#define FLT_ROUNDS 1\n-#define FLT_RADIX 2\n-#define DBL_MANT_DIG 53\n-#define DBL_DIG 15\n-#define DBL_MAX_10_EXP 308\n-#define DBL_MAX_EXP 1024\n-#endif\n-\n-#include <errno.h>\n-#ifndef __MATH_H__\n-#include <math.h>\n-#endif\n-\n-#ifdef Unsigned_Shifts\n-#define Sign_Extend(a,b) if (b < 0) a |= 0xffff0000;\n-#else\n-#define Sign_Extend(a,b) /*no-op*/\n-#endif\n-\n-#if defined(__i386__) || defined(__i860__) || defined(clipper)\n-#define IEEE_8087\n-#endif\n-#if defined(MIPSEL) || defined(__alpha__)\n-#define IEEE_8087\n-#endif\n-#if defined(__sparc__) || defined(sparc) || defined(MIPSEB)\n-#define IEEE_MC68k\n-#endif\n-\n-#if defined(IEEE_8087) + defined(IEEE_MC68k) + defined(VAX) + defined(IBM) != 1\n-\n-#ifndef _DOUBLE_IS_32BITS\n-#if FLT_RADIX==16\n-#define IBM\n-#else\n-#if DBL_MANT_DIG==56\n-#define VAX\n-#else\n-#if DBL_MANT_DIG==53 && DBL_MAX_10_EXP==308\n-#define IEEE_Unknown\n-#else\n-Exactly one of IEEE_8087, IEEE_MC68k, VAX, or IBM should be defined.\n-#endif\n-#endif\n-#endif\n-#endif /* !_DOUBLE_IS_32BITS */\n-#endif\n-\n-typedef _G_uint32_t unsigned32;\n-\n-union doubleword {\n-  double d;\n-  unsigned32 u[2];\n-};\n-\n-#ifdef IEEE_8087\n-#define HIWORD 1\n-#define LOWORD 0\n-#define TEST_ENDIANNESS  /* nothing */\n-#else\n-#if defined(IEEE_MC68k)\n-#define HIWORD 0\n-#define LOWORD 1\n-#define TEST_ENDIANNESS  /* nothing */\n-#else\n-static int HIWORD = -1, LOWORD;\n-static void test_endianness()\n-{\n-    union doubleword dw;\n-    dw.d = 10;\n-    if (dw.u[0] != 0) /* big-endian */\n-\tHIWORD=0, LOWORD=1;\n-    else\n-\tHIWORD=1, LOWORD=0;\n-}\n-#define TEST_ENDIANNESS  if (HIWORD<0) test_endianness();\n-#endif\n-#endif\n-\n-#if 0\n-union doubleword _temp;\n-#endif\n-#if defined(__GNUC__) && !defined(_DOUBLE_IS_32BITS)\n-#define word0(x) ({ union doubleword _du; _du.d = (x); _du.u[HIWORD]; })\n-#define word1(x) ({ union doubleword _du; _du.d = (x); _du.u[LOWORD]; })\n-#define setword0(D,W) \\\n-  ({ union doubleword _du; _du.d = (D); _du.u[HIWORD]=(W); (D)=_du.d; })\n-#define setword1(D,W) \\\n-  ({ union doubleword _du; _du.d = (D); _du.u[LOWORD]=(W); (D)=_du.d; })\n-#define setwords(D,W0,W1) ({ union doubleword _du; \\\n-  _du.u[HIWORD]=(W0); _du.u[LOWORD]=(W1); (D)=_du.d; })\n-#define addword0(D,W) \\\n-  ({ union doubleword _du; _du.d = (D); _du.u[HIWORD]+=(W); (D)=_du.d; })\n-#else\n-#define word0(x) ((unsigned32 *)&x)[HIWORD]\n-#ifndef _DOUBLE_IS_32BITS\n-#define word1(x) ((unsigned32 *)&x)[LOWORD]\n-#else\n-#define word1(x) 0\n-#endif\n-#define setword0(D,W) word0(D) = (W)\n-#ifndef _DOUBLE_IS_32BITS\n-#define setword1(D,W) word1(D) = (W)\n-#define setwords(D,W0,W1) (setword0(D,W0),setword1(D,W1))\n-#else\n-#define setword1(D,W)\n-#define setwords(D,W0,W1) (setword0(D,W0))\n-#endif\n-#define addword0(D,X) (word0(D) += (X))\n-#endif\n-\n-/* The following definition of Storeinc is appropriate for MIPS processors. */\n-#if defined(IEEE_8087) + defined(VAX)\n-#define Storeinc(a,b,c) (((unsigned short *)a)[1] = (unsigned short)b, \\\n-((unsigned short *)a)[0] = (unsigned short)c, a++)\n-#else\n-#if defined(IEEE_MC68k)\n-#define Storeinc(a,b,c) (((unsigned short *)a)[0] = (unsigned short)b, \\\n-((unsigned short *)a)[1] = (unsigned short)c, a++)\n-#else\n-#define Storeinc(a,b,c) (*a++ = b << 16 | c & 0xffff)\n-#endif\n-#endif\n-\n-/* #define P DBL_MANT_DIG */\n-/* Ten_pmax = floor(P*log(2)/log(5)) */\n-/* Bletch = (highest power of 2 < DBL_MAX_10_EXP) / 16 */\n-/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */\n-/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */\n-\n-#if defined(IEEE_8087) + defined(IEEE_MC68k) + defined(IEEE_Unknown)\n-#define Exp_shift  20\n-#define Exp_shift1 20\n-#define Exp_msk1    0x100000\n-#define Exp_msk11   0x100000\n-#define Exp_mask  0x7ff00000\n-#define P 53\n-#define Bias 1023\n-#define IEEE_Arith\n-#define Emin (-1022)\n-#define Exp_1  0x3ff00000\n-#define Exp_11 0x3ff00000\n-#define Ebits 11\n-#define Frac_mask  0xfffff\n-#define Frac_mask1 0xfffff\n-#define Ten_pmax 22\n-#define Bletch 0x10\n-#define Bndry_mask  0xfffff\n-#define Bndry_mask1 0xfffff\n-#define LSB 1\n-#define Sign_bit 0x80000000\n-#define Log2P 1\n-#define Tiny0 0\n-#define Tiny1 1\n-#define Quick_max 14\n-#define Int_max 14\n-#define Infinite(x) (word0(x) == 0x7ff00000) /* sufficient test for here */\n-#else\n-#undef  Sudden_Underflow\n-#define Sudden_Underflow\n-#ifdef IBM\n-#define Exp_shift  24\n-#define Exp_shift1 24\n-#define Exp_msk1   0x1000000\n-#define Exp_msk11  0x1000000\n-#define Exp_mask  0x7f000000\n-#define P 14\n-#define Bias 65\n-#define Exp_1  0x41000000\n-#define Exp_11 0x41000000\n-#define Ebits 8 /* exponent has 7 bits, but 8 is the right value in b2d */\n-#define Frac_mask  0xffffff\n-#define Frac_mask1 0xffffff\n-#define Bletch 4\n-#define Ten_pmax 22\n-#define Bndry_mask  0xefffff\n-#define Bndry_mask1 0xffffff\n-#define LSB 1\n-#define Sign_bit 0x80000000\n-#define Log2P 4\n-#define Tiny0 0x100000\n-#define Tiny1 0\n-#define Quick_max 14\n-#define Int_max 15\n-#else /* VAX */\n-#define Exp_shift  23\n-#define Exp_shift1 7\n-#define Exp_msk1    0x80\n-#define Exp_msk11   0x800000\n-#define Exp_mask  0x7f80\n-#define P 56\n-#define Bias 129\n-#define Exp_1  0x40800000\n-#define Exp_11 0x4080\n-#define Ebits 8\n-#define Frac_mask  0x7fffff\n-#define Frac_mask1 0xffff007f\n-#define Ten_pmax 24\n-#define Bletch 2\n-#define Bndry_mask  0xffff007f\n-#define Bndry_mask1 0xffff007f\n-#define LSB 0x10000\n-#define Sign_bit 0x8000\n-#define Log2P 1\n-#define Tiny0 0x80\n-#define Tiny1 0\n-#define Quick_max 15\n-#define Int_max 15\n-#endif\n-#endif\n-\n-#ifndef IEEE_Arith\n-#define ROUND_BIASED\n-#endif\n-\n-#ifdef RND_PRODQUOT\n-#define rounded_product(a,b) a = rnd_prod(a, b)\n-#define rounded_quotient(a,b) a = rnd_quot(a, b)\n-extern double rnd_prod(double, double), rnd_quot(double, double);\n-#else\n-#define rounded_product(a,b) a *= b\n-#define rounded_quotient(a,b) a /= b\n-#endif\n-\n-#define Big0 (Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+Bias-1))\n-#define Big1 0xffffffff\n-\n-#define Kmax 15\n-\n-/* (1<<BIGINT_MINIMUM_K) is the minimum number of words to allocate\n-   in a Bigint.  dtoa usually manages with 1<<2, and has not been\n-   known to need more than 1<<3.  */\n-\n-#define BIGINT_MINIMUM_K 3\n-\n-struct Bigint {\n-  struct Bigint *next;\n-  int k;\t\t/* Parameter given to Balloc(k) */\n-  int maxwds;\t\t/* Allocated space: equals 1<<k. */\n-  short on_stack;\t/* 1 if stack-allocated. */\n-  short sign;\t\t/* 0 if value is positive or zero; 1 if negative. */\n-  int wds;\t\t/* Current length. */\n-  unsigned32 x[1<<BIGINT_MINIMUM_K]; /* Actually: x[maxwds] */\n-};\n-\n-#define BIGINT_HEADER_SIZE \\\n-  (sizeof(Bigint) - (1<<BIGINT_MINIMUM_K) * sizeof(unsigned32))\n-\n-typedef struct Bigint Bigint;\n-\n-/* Initialize a stack-allocated Bigint. */\n-\n-static Bigint *\n-Binit\n-#ifdef KR_headers\n-        (v) Bigint *v;\n-#else\n-        (Bigint *v)\n-#endif\n-{\n-  v->on_stack = 1;\n-  v->k = BIGINT_MINIMUM_K;\n-  v->maxwds = 1 << BIGINT_MINIMUM_K;\n-  v->sign = v->wds = 0;\n-  return v;\n-}\n-\n-/* Allocate a Bigint with '1<<k' big digits. */\n-\n-static Bigint *\n-Balloc\n-#ifdef KR_headers\n-        (k) int k;\n-#else\n-        (int k)\n-#endif\n-{\n-  int x;\n-  Bigint *rv;\n-\n-  if (k < BIGINT_MINIMUM_K)\n-    k = BIGINT_MINIMUM_K;\n-\n-  x = 1 << k;\n-  rv = (Bigint *)\n-    malloc(BIGINT_HEADER_SIZE + x * sizeof(unsigned32));\n-  rv->k = k;\n-  rv->maxwds = x;\n-  rv->sign = rv->wds = 0;\n-  rv->on_stack = 0;\n-  return rv;\n-}\n-\n-static void\n-Bfree\n-#ifdef KR_headers\n-        (v) Bigint *v;\n-#else\n-        (Bigint *v)\n-#endif\n-{\n-  if (v && !v->on_stack)\n-    free (v);\n-}\n-\n-static void\n-Bcopy\n-#ifdef KR_headers\n-        (x, y) Bigint *x, *y;\n-#else\n-        (Bigint *x, Bigint *y)\n-#endif\n-{\n-  register unsigned32 *xp, *yp;\n-  register int i = y->wds;\n-  x->sign = y->sign;\n-  x->wds = i;\n-  for (xp = x->x, yp = y->x; --i >= 0; )\n-    *xp++ = *yp++;\n-}\n-\n-/* Make sure b has room for at least 1<<k big digits. */\n-\n-static Bigint *\n-Brealloc\n-#ifdef KR_headers\n-        (b, k) Bigint *b; int k;\n-#else\n-        (Bigint * b, int k)\n-#endif\n-{\n-  if (b == NULL)\n-    return Balloc(k);\n-  if (b->k >= k)\n-    return b;\n-  else\n-    {\n-      Bigint *rv = Balloc (k);\n-      Bcopy(rv, b);\n-      Bfree(b);\n-      return rv;\n-    }\n-}\n-\n-/* Return b*m+a.  b is modified.\n-   Assumption:  0xFFFF*m+a fits in 32 bits. */\n-\n-static Bigint *\n-multadd\n-#ifdef KR_headers\n-        (b, m, a) Bigint *b; int m, a;\n-#else\n-        (Bigint *b, int m, int a)\n-#endif\n-{\n-        int i, wds;\n-        unsigned32 *x, y;\n-        unsigned32 xi, z;\n-\n-        wds = b->wds;\n-        x = b->x;\n-        i = 0;\n-        do {\n-                xi = *x;\n-                y = (xi & 0xffff) * m + a;\n-                z = (xi >> 16) * m + (y >> 16);\n-                a = (int)(z >> 16);\n-                *x++ = (z << 16) + (y & 0xffff);\n-                }\n-                while(++i < wds);\n-        if (a) {\n-                if (wds >= b->maxwds)\n-                        b = Brealloc(b, b->k+1);\n-                b->x[wds++] = a;\n-                b->wds = wds;\n-                }\n-        return b;\n-        }\n-\n-static Bigint *\n-s2b\n-#ifdef KR_headers\n-        (result, s, nd0, nd, y9)\n-\tBigint *result; CONST char *s; int nd0, nd; unsigned32 y9;\n-#else\n-        (Bigint *result, CONST char *s, int nd0, int nd, unsigned32 y9)\n-#endif\n-{\n-  int i, k;\n-  _G_int32_t x, y;\n-\n-  x = (nd + 8) / 9;\n-  for(k = 0, y = 1; x > y; y <<= 1, k++) ;\n-  result = Brealloc(result, k);\n-  result->x[0] = y9;\n-  result->wds = 1;\n-\n-  i = 9;\n-  if (9 < nd0)\n-    {\n-      s += 9;\n-      do\n-\tresult = multadd(result, 10, *s++ - '0');\n-      while (++i < nd0);\n-      s++;\n-    }\n-  else\n-    s += 10;\n-  for(; i < nd; i++)\n-    result = multadd(result, 10, *s++ - '0');\n-  return result;\n-}\n-\n-static int\n-hi0bits\n-#ifdef KR_headers\n-        (x) register unsigned32 x;\n-#else\n-        (register unsigned32 x)\n-#endif\n-{\n-        register int k = 0;\n-\n-        if (!(x & 0xffff0000)) {\n-                k = 16;\n-                x <<= 16;\n-                }\n-        if (!(x & 0xff000000)) {\n-                k += 8;\n-                x <<= 8;\n-                }\n-        if (!(x & 0xf0000000)) {\n-                k += 4;\n-                x <<= 4;\n-                }\n-        if (!(x & 0xc0000000)) {\n-                k += 2;\n-                x <<= 2;\n-                }\n-        if (!(x & 0x80000000)) {\n-                k++;\n-                if (!(x & 0x40000000))\n-                        return 32;\n-                }\n-        return k;\n-        }\n-\n-static int\n-lo0bits\n-#ifdef KR_headers\n-        (y) unsigned32 *y;\n-#else\n-        (unsigned32 *y)\n-#endif\n-{\n-        register int k;\n-        register unsigned32 x = *y;\n-\n-        if (x & 7) {\n-                if (x & 1)\n-                        return 0;\n-                if (x & 2) {\n-                        *y = x >> 1;\n-                        return 1;\n-                        }\n-                *y = x >> 2;\n-                return 2;\n-                }\n-        k = 0;\n-        if (!(x & 0xffff)) {\n-                k = 16;\n-                x >>= 16;\n-                }\n-        if (!(x & 0xff)) {\n-                k += 8;\n-                x >>= 8;\n-                }\n-        if (!(x & 0xf)) {\n-                k += 4;\n-                x >>= 4;\n-                }\n-        if (!(x & 0x3)) {\n-                k += 2;\n-                x >>= 2;\n-                }\n-        if (!(x & 1)) {\n-                k++;\n-                x >>= 1;\n-                if (!x & 1)\n-                        return 32;\n-                }\n-        *y = x;\n-        return k;\n-        }\n-\n-static Bigint *\n-i2b\n-#ifdef KR_headers\n-        (result, i) Bigint *result; int i;\n-#else\n-        (Bigint* result, int i)\n-#endif\n-{\n-  result = Brealloc(result, 1);\n-  result->x[0] = i;\n-  result->wds = 1;\n-  return result;\n-}\n-\n-/* Do: c = a * b. */\n-\n-static Bigint *\n-mult\n-#ifdef KR_headers\n-        (c, a, b) Bigint *a, *b, *c;\n-#else\n-        (Bigint *c, Bigint *a, Bigint *b)\n-#endif\n-{\n-        int k, wa, wb, wc;\n-        unsigned32 carry, y, z;\n-        unsigned32 *x, *xa, *xae, *xb, *xbe, *xc, *xc0;\n-        unsigned32 z2;\n-        if (a->wds < b->wds) {\n-                Bigint *tmp = a;\n-                a = b;\n-                b = tmp;\n-                }\n-        k = a->k;\n-        wa = a->wds;\n-        wb = b->wds;\n-        wc = wa + wb;\n-        if (wc > a->maxwds)\n-                k++;\n-\tc = Brealloc(c, k);\n-        for(x = c->x, xa = x + wc; x < xa; x++)\n-                *x = 0;\n-        xa = a->x;\n-        xae = xa + wa;\n-        xb = b->x;\n-        xbe = xb + wb;\n-        xc0 = c->x;\n-        for(; xb < xbe; xb++, xc0++) {\n-                if ((y = *xb & 0xffff)) {\n-                        x = xa;\n-                        xc = xc0;\n-                        carry = 0;\n-                        do {\n-                                z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;\n-                                carry = z >> 16;\n-                                z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;\n-                                carry = z2 >> 16;\n-                                Storeinc(xc, z2, z);\n-                                }\n-                                while(x < xae);\n-                        *xc = carry;\n-                        }\n-                if ((y = *xb >> 16)) {\n-                        x = xa;\n-                        xc = xc0;\n-                        carry = 0;\n-                        z2 = *xc;\n-                        do {\n-                                z = (*x & 0xffff) * y + (*xc >> 16) + carry;\n-                                carry = z >> 16;\n-                                Storeinc(xc, z, z2);\n-                                z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;\n-                                carry = z2 >> 16;\n-                                }\n-                                while(x < xae);\n-                        *xc = z2;\n-                        }\n-                }\n-        for(xc0 = c->x, xc = xc0 + wc; wc > 0 && !*--xc; --wc) ;\n-        c->wds = wc;\n-        return c;\n-        }\n-\n-/* Returns b*(5**k).  b is modified. */\n-/* Re-written by Per Bothner to not need a static list. */\n-\n-static Bigint *\n-pow5mult\n-#ifdef KR_headers\n-        (b, k) Bigint *b; int k;\n-#else\n-        (Bigint *b, int k)\n-#endif\n-{\n-  static int p05[6] = { 5, 25, 125, 625, 3125, 15625 };\n-\n-  for (; k > 6; k -= 6)\n-    b = multadd(b, 15625, 0); /* b *= 5**6 */\n-  if (k == 0)\n-    return b;\n-  else\n-    return multadd(b, p05[k-1], 0);\n-}\n-\n-/* Re-written by Per Bothner so shift can be in place. */\n-\n-static Bigint *\n-lshift\n-#ifdef KR_headers\n-\t(b, k) Bigint *b; int k;\n-#else\n-        (Bigint *b, int k)\n-#endif\n-{\n-  int i;\n-  unsigned32 *x, *x1, *xe;\n-  int old_wds = b->wds;\n-  int n = k >> 5;\n-  int k1 = b->k;\n-  int n1 = n + old_wds + 1;\n-\n-  if (k == 0)\n-    return b;\n-\n-  for(i = b->maxwds; n1 > i; i <<= 1)\n-    k1++;\n-  b = Brealloc(b, k1);\n-\n-  xe = b->x; /* Source limit */\n-  x = xe + old_wds; /* Source pointer */\n-  x1 = x + n; /* Destination pointer */\n-  if (k &= 0x1f) {\n-    int k1 = 32 - k;\n-    unsigned32 z = *--x;\n-    if ((*x1 = (z >> k1)) != 0) {\n-      ++n1;\n-    }\n-    while (x > xe) {\n-      unsigned32 w = *--x;\n-      *--x1 = (z << k) | (w >> k1);\n-      z = w;\n-    }\n-    *--x1 = z << k;\n-  }\n-  else\n-    do {\n-      *--x1 = *--x;\n-    } while(x > xe);\n-  while (x1 > xe)\n-    *--x1 = 0;\n-  b->wds = n1 - 1;\n-  return b;\n-}\n-\n-static int\n-cmp\n-#ifdef KR_headers\n-        (a, b) Bigint *a, *b;\n-#else\n-        (Bigint *a, Bigint *b)\n-#endif\n-{\n-        unsigned32 *xa, *xa0, *xb, *xb0;\n-        int i, j;\n-\n-        i = a->wds;\n-        j = b->wds;\n-#ifdef DEBUG\n-        if (i > 1 && !a->x[i-1])\n-                Bug(\"cmp called with a->x[a->wds-1] == 0\");\n-        if (j > 1 && !b->x[j-1])\n-                Bug(\"cmp called with b->x[b->wds-1] == 0\");\n-#endif\n-        if (i -= j)\n-                return i;\n-        xa0 = a->x;\n-        xa = xa0 + j;\n-        xb0 = b->x;\n-        xb = xb0 + j;\n-        for(;;) {\n-                if (*--xa != *--xb)\n-                        return *xa < *xb ? -1 : 1;\n-                if (xa <= xa0)\n-                        break;\n-                }\n-        return 0;\n-        }\n-\n-/* Do: c = a-b. */\n-\n-static Bigint *\n-diff\n-#ifdef KR_headers\n-        (c, a, b) Bigint *c, *a, *b;\n-#else\n-        (Bigint *c, Bigint *a, Bigint *b)\n-#endif\n-{\n-        int i, wa, wb;\n-        _G_int32_t borrow, y; /* We need signed shifts here. */\n-        unsigned32 *xa, *xae, *xb, *xbe, *xc;\n-        _G_int32_t z;\n-\n-        i = cmp(a,b);\n-        if (!i) {\n-                c = Brealloc(c, 0);\n-                c->wds = 1;\n-                c->x[0] = 0;\n-                return c;\n-                }\n-        if (i < 0) {\n-                Bigint *tmp = a;\n-                a = b;\n-                b = tmp;\n-                i = 1;\n-                }\n-        else\n-                i = 0;\n-        c = Brealloc(c, a->k);\n-        c->sign = i;\n-        wa = a->wds;\n-        xa = a->x;\n-        xae = xa + wa;\n-        wb = b->wds;\n-        xb = b->x;\n-        xbe = xb + wb;\n-        xc = c->x;\n-        borrow = 0;\n-        do {\n-                y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;\n-                borrow = y >> 16;\n-                Sign_Extend(borrow, y);\n-                z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;\n-                borrow = z >> 16;\n-                Sign_Extend(borrow, z);\n-                Storeinc(xc, z, y);\n-                }\n-                while(xb < xbe);\n-        while(xa < xae) {\n-                y = (*xa & 0xffff) + borrow;\n-                borrow = y >> 16;\n-                Sign_Extend(borrow, y);\n-                z = (*xa++ >> 16) + borrow;\n-                borrow = z >> 16;\n-                Sign_Extend(borrow, z);\n-                Storeinc(xc, z, y);\n-                }\n-        while(!*--xc)\n-                wa--;\n-        c->wds = wa;\n-        return c;\n-        }\n-\n-static double\n-ulp\n-#ifdef KR_headers\n-        (x) double x;\n-#else\n-        (double x)\n-#endif\n-{\n-        register _G_int32_t L;\n-        double a;\n-\n-        L = (word0(x) & Exp_mask) - (P-1)*Exp_msk1;\n-#ifndef Sudden_Underflow\n-        if (L > 0) {\n-#endif\n-#ifdef IBM\n-                L |= Exp_msk1 >> 4;\n-#endif\n-                setwords(a, L, 0);\n-#ifndef Sudden_Underflow\n-                }\n-        else {\n-                L = -L >> Exp_shift;\n-                if (L < Exp_shift)\n-                        setwords(a, 0x80000 >> L, 0);\n-                else {\n-                        L -= Exp_shift;\n-                        setwords(a, 0, L >= 31 ? 1 : 1 << (31 - L));\n-                        }\n-                }\n-#endif\n-        return a;\n-        }\n-\n-static double\n-b2d\n-#ifdef KR_headers\n-        (a, e) Bigint *a; int *e;\n-#else\n-        (Bigint *a, int *e)\n-#endif\n-{\n-        unsigned32 *xa, *xa0, w, y, z;\n-        int k;\n-        double d;\n-        unsigned32 d0, d1;\n-\n-        xa0 = a->x;\n-        xa = xa0 + a->wds;\n-        y = *--xa;\n-#ifdef DEBUG\n-        if (!y) Bug(\"zero y in b2d\");\n-#endif\n-        k = hi0bits(y);\n-        *e = 32 - k;\n-        if (k < Ebits) {\n-                d0 = Exp_1 | y >> (Ebits - k);\n-                w = xa > xa0 ? *--xa : 0;\n-#ifndef _DOUBLE_IS_32BITS\n-                d1 = y << ((32-Ebits) + k) | w >> (Ebits - k);\n-#endif\n-                goto ret_d;\n-                }\n-        z = xa > xa0 ? *--xa : 0;\n-        if (k -= Ebits) {\n-                d0 = Exp_1 | y << k | z >> (32 - k);\n-                y = xa > xa0 ? *--xa : 0;\n-#ifndef _DOUBLE_IS_32BITS\n-                d1 = z << k | y >> (32 - k);\n-#endif\n-                }\n-        else {\n-                d0 = Exp_1 | y;\n-#ifndef _DOUBLE_IS_32BITS\n-                d1 = z;\n-#endif\n-                }\n- ret_d:\n-#ifdef VAX\n-        setwords(d, d0 >> 16 | d0 << 16, d1 >> 16 | d1 << 16);\n-#else\n-\tsetwords (d, d0, d1);\n-#endif\n-        return d;\n-        }\n-\n-static Bigint *\n-d2b\n-#ifdef KR_headers\n-        (result, d, e, bits) Bigint *result; double d; _G_int32_t *e, *bits;\n-#else\n-        (Bigint *result, double d, _G_int32_t *e, _G_int32_t *bits)\n-#endif\n-{\n-        int de, i, k;\n-        unsigned32 *x, y, z;\n-        unsigned32 d0, d1;\n-#ifdef VAX\n-        d0 = word0(d) >> 16 | word0(d) << 16;\n-        d1 = word1(d) >> 16 | word1(d) << 16;\n-#else\n-\td0 = word0(d);\n-\td1 = word1(d);\n-#endif\n-\n-        result = Brealloc(result, 1);\n-        x = result->x;\n-\n-        z = d0 & Frac_mask;\n-        d0 &= 0x7fffffff;       /* clear sign bit, which we ignore */\n-\n-        de = (int)(d0 >> Exp_shift);  /* The exponent part of d. */\n-\n-\t/* Put back the suppressed high-order bit, if normalized. */\n-#ifndef IBM\n-#ifndef Sudden_Underflow\n-        if (de)\n-#endif\n-\t  z |= Exp_msk11;\n-#endif\n-\n-#ifndef _DOUBLE_IS_32BITS\n-        if ((y = d1)) {\n-                if ((k = lo0bits(&y))) {\n-                        x[0] = y | z << (32 - k);\n-                        z >>= k;\n-                        }\n-                else\n-                        x[0] = y;\n-                i = result->wds = (x[1] = z) ? 2 : 1;\n-                }\n-        else {\n-#endif /* !_DOUBLE_IS_32BITS */\n-#ifdef DEBUG\n-                if (!z)\n-                        Bug(\"Zero passed to d2b\");\n-#endif\n-                k = lo0bits(&z);\n-                x[0] = z;\n-                i = result->wds = 1;\n-#ifndef _DOUBLE_IS_32BITS\n-                k += 32;\n-                }\n-#endif\n-#ifndef Sudden_Underflow\n-        if (de) {\n-#endif\n-#ifdef IBM\n-                *e = (de - Bias - (P-1) << 2) + k;\n-                *bits = 4*P + 8 - k - hi0bits(word0(d) & Frac_mask);\n-#else\n-                *e = de - Bias - (P-1) + k;\n-                *bits = P - k;\n-#endif\n-#ifndef Sudden_Underflow\n-                }\n-        else {\n-                *e = de - Bias - (P-1) + 1 + k;\n-                *bits = 32*i - hi0bits(x[i-1]);\n-                }\n-#endif\n-        return result;\n-        }\n-\n-static double\n-ratio\n-#ifdef KR_headers\n-        (a, b) Bigint *a, *b;\n-#else\n-        (Bigint *a, Bigint *b)\n-#endif\n-{\n-        double da, db;\n-        int k, ka, kb;\n-\n-        da = b2d(a, &ka);\n-        db = b2d(b, &kb);\n-        k = ka - kb + 32*(a->wds - b->wds);\n-#ifdef IBM\n-        if (k > 0) {\n-                addword0(da, (k >> 2)*Exp_msk1);\n-                if (k &= 3)\n-                        da *= 1 << k;\n-                }\n-        else {\n-                k = -k;\n-                addword0(db,(k >> 2)*Exp_msk1);\n-                if (k &= 3)\n-                        db *= 1 << k;\n-                }\n-#else\n-        if (k > 0)\n-                addword0(da, k*Exp_msk1);\n-        else {\n-                k = -k;\n-                addword0(db, k*Exp_msk1);\n-                }\n-#endif\n-        return da / db;\n-        }\n-\n-static CONST double\n-tens[] = {\n-                1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,\n-                1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n-                1e20, 1e21, 1e22\n-#ifdef VAX\n-                , 1e23, 1e24\n-#endif\n-                };\n-\n-#ifdef IEEE_Arith\n-static CONST double bigtens[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };\n-static CONST double tinytens[] = { 1e-16, 1e-32, 1e-64, 1e-128, 1e-256 };\n-#define n_bigtens 5\n-#else\n-#ifdef IBM\n-static CONST double bigtens[] = { 1e16, 1e32, 1e64 };\n-static CONST double tinytens[] = { 1e-16, 1e-32, 1e-64 };\n-#define n_bigtens 3\n-#else\n-/* Also used for the case when !_DOUBLE_IS_32BITS.  */\n-static CONST double bigtens[] = { 1e16, 1e32 };\n-static CONST double tinytens[] = { 1e-16, 1e-32 };\n-#define n_bigtens 2\n-#endif\n-#endif\n-\n- double\n-_IO_strtod\n-#ifdef KR_headers\n-        (s00, se) CONST char *s00; char **se;\n-#else\n-        (CONST char *s00, char **se)\n-#endif\n-{\n-        _G_int32_t bb2, bb5, bbe, bd2, bd5, bbbits, bs2, c, dsign,\n-                 e, e1, esign, i, j, k, nd, nd0, nf, nz, nz0, sign;\n-        CONST char *s, *s0, *s1;\n-        double aadj, aadj1, adj, rv, rv0;\n-        _G_int32_t L;\n-        unsigned32 y, z;\n-\tBigint _bb, _b_avail, _bd, _bd0, _bs, _delta;\n-\tBigint *bb = Binit(&_bb);\n-\tBigint *bd = Binit(&_bd);\n-\tBigint *bd0 = Binit(&_bd0);\n-\tBigint *bs = Binit(&_bs);\n-\tBigint *b_avail = Binit(&_b_avail);\n-\tBigint *delta = Binit(&_delta);\n-\n-\tTEST_ENDIANNESS;\n-        sign = nz0 = nz = 0;\n-        rv = 0.;\n-\t(void)&rv;\t\t/* Force rv into the stack */\n-        for(s = s00;;s++) switch(*s) {\n-                case '-':\n-                        sign = 1;\n-                        /* no break */\n-                case '+':\n-                        if (*++s)\n-                                goto break2;\n-                        /* no break */\n-                case 0:\n-\t\t\t/* \"+\" and \"-\" should be reported as an error? */\n-\t\t\tsign = 0;\n-\t\t\ts = s00;\n-                        goto ret;\n-                case '\\t':\n-                case '\\n':\n-                case '\\v':\n-                case '\\f':\n-                case '\\r':\n-                case ' ':\n-                        continue;\n-                default:\n-                        goto break2;\n-                }\n- break2:\n-        if (*s == '0') {\n-                nz0 = 1;\n-                while(*++s == '0') ;\n-                if (!*s)\n-                        goto ret;\n-                }\n-        s0 = s;\n-        y = z = 0;\n-        for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)\n-                if (nd < 9)\n-                        y = 10*y + c - '0';\n-                else if (nd < 16)\n-                        z = 10*z + c - '0';\n-        nd0 = nd;\n-        if (c == '.') {\n-                c = *++s;\n-                if (!nd) {\n-                        for(; c == '0'; c = *++s)\n-                                nz++;\n-                        if (c > '0' && c <= '9') {\n-                                s0 = s;\n-                                nf += nz;\n-                                nz = 0;\n-                                goto have_dig;\n-                                }\n-                        goto dig_done;\n-                        }\n-                for(; c >= '0' && c <= '9'; c = *++s) {\n- have_dig:\n-                        nz++;\n-                        if (c -= '0') {\n-                                nf += nz;\n-                                for(i = 1; i < nz; i++)\n-                                        if (nd++ < 9)\n-                                                y *= 10;\n-                                        else if (nd <= DBL_DIG + 1)\n-                                                z *= 10;\n-                                if (nd++ < 9)\n-                                        y = 10*y + c;\n-                                else if (nd <= DBL_DIG + 1)\n-                                        z = 10*z + c;\n-                                nz = 0;\n-                                }\n-                        }\n-                }\n- dig_done:\n-        e = 0;\n-        if (c == 'e' || c == 'E') {\n-                if (!nd && !nz && !nz0) {\n-                        s = s00;\n-                        goto ret;\n-                        }\n-                s00 = s;\n-                esign = 0;\n-                switch(c = *++s) {\n-                        case '-':\n-                                esign = 1;\n-                        case '+':\n-                                c = *++s;\n-                        }\n-                if (c >= '0' && c <= '9') {\n-                        while(c == '0')\n-                                c = *++s;\n-                        if (c > '0' && c <= '9') {\n-                                e = c - '0';\n-                                s1 = s;\n-                                while((c = *++s) >= '0' && c <= '9')\n-                                        e = 10*e + c - '0';\n-                                if (s - s1 > 8)\n-                                        /* Avoid confusion from exponents\n-                                         * so large that e might overflow.\n-                                         */\n-                                        e = 9999999;\n-                                if (esign)\n-                                        e = -e;\n-                                }\n-                        else\n-                                e = 0;\n-                        }\n-                else\n-                        s = s00;\n-                }\n-        if (!nd) {\n-                if (!nz && !nz0)\n-                        s = s00;\n-                goto ret;\n-                }\n-        e1 = e -= nf;\n-\n-        /* Now we have nd0 digits, starting at s0, followed by a\n-         * decimal point, followed by nd-nd0 digits.  The number we're\n-         * after is the integer represented by those digits times\n-         * 10**e */\n-\n-        if (!nd0)\n-                nd0 = nd;\n-        k = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;\n-        rv = y;\n-        if (k > 9)\n-                rv = tens[k - 9] * rv + z;\n-        if (nd <= DBL_DIG\n-#ifndef RND_PRODQUOT\n-                && FLT_ROUNDS == 1\n-#endif\n-                        ) {\n-                if (!e)\n-                        goto ret;\n-                if (e > 0) {\n-                        if (e <= Ten_pmax) {\n-#ifdef VAX\n-                                goto vax_ovfl_check;\n-#else\n-                                /* rv = */ rounded_product(rv, tens[e]);\n-                                goto ret;\n-#endif\n-                                }\n-                        i = DBL_DIG - nd;\n-                        if (e <= Ten_pmax + i) {\n-                                /* A fancier test would sometimes let us do\n-                                 * this for larger i values.\n-                                 */\n-                                e -= i;\n-                                rv *= tens[i];\n-#ifdef VAX\n-                                /* VAX exponent range is so narrow we must\n-                                 * worry about overflow here...\n-                                 */\n- vax_ovfl_check:\n-                                addword0(rv, - P*Exp_msk1);\n-                                /* rv = */ rounded_product(rv, tens[e]);\n-                                if ((word0(rv) & Exp_mask)\n-                                 > Exp_msk1*(DBL_MAX_EXP+Bias-1-P))\n-                                        goto ovfl;\n-                                addword0(rv, P*Exp_msk1);\n-#else\n-                                /* rv = */ rounded_product(rv, tens[e]);\n-#endif\n-                                goto ret;\n-                                }\n-                        }\n-#ifndef Inaccurate_Divide\n-                else if (e >= -Ten_pmax) {\n-                        /* rv = */ rounded_quotient(rv, tens[-e]);\n-                        goto ret;\n-                        }\n-#endif\n-                }\n-        e1 += nd - k;\n-\n-        /* Get starting approximation = rv * 10**e1 */\n-\n-        if (e1 > 0) {\n-                if ((i = e1 & 15))\n-                        rv *= tens[i];\n-                if (e1 &= ~15) {\n-                        if (e1 > DBL_MAX_10_EXP) {\n- ovfl:\n-                                errno = ERANGE;\n-#if defined(sun) && !defined(__svr4__)\n-/* SunOS defines HUGE_VAL as __infinity(), which is in libm. */\n-#undef HUGE_VAL\n-#endif\n-#ifndef HUGE_VAL\n-#define HUGE_VAL        1.7976931348623157E+308\n-#endif\n-                                rv = HUGE_VAL;\n-                                goto ret;\n-                                }\n-                        if (e1 >>= 4) {\n-                                for(j = 0; e1 > 1; j++, e1 >>= 1)\n-                                        if (e1 & 1)\n-                                                rv *= bigtens[j];\n-                        /* The last multiplication could overflow. */\n-                                addword0(rv, -P*Exp_msk1);\n-                                rv *= bigtens[j];\n-                                if ((z = word0(rv) & Exp_mask)\n-                                 > Exp_msk1*(DBL_MAX_EXP+Bias-P))\n-                                        goto ovfl;\n-                                if (z > Exp_msk1*(DBL_MAX_EXP+Bias-1-P)) {\n-                                        /* set to largest number */\n-                                        /* (Can't trust DBL_MAX) */\n-                                        setwords(rv, Big0, Big1);\n-                                        }\n-                                else\n-                                        addword0(rv, P*Exp_msk1);\n-                                }\n-\n-                        }\n-                }\n-        else if (e1 < 0) {\n-                e1 = -e1;\n-                if ((i = e1 & 15))\n-                        rv /= tens[i];\n-                if (e1 &= ~15) {\n-                        e1 >>= 4;\n-                        for(j = 0; e1 > 1; j++, e1 >>= 1)\n-                                if (e1 & 1)\n-                                        rv *= tinytens[j];\n-                        /* The last multiplication could underflow. */\n-                        rv0 = rv;\n-                        rv *= tinytens[j];\n-                        if (!rv) {\n-                                rv = 2.*rv0;\n-                                rv *= tinytens[j];\n-                                if (!rv) {\n- undfl:\n-                                        rv = 0.;\n-                                        errno = ERANGE;\n-                                        goto ret;\n-                                        }\n-                                setwords(rv, Tiny0, Tiny1);\n-                                /* The refinement below will clean\n-                                 * this approximation up.\n-                                 */\n-                                }\n-                        }\n-                }\n-\n-        /* Now the hard part -- adjusting rv to the correct value.*/\n-\n-        /* Put digits into bd: true value = bd * 10^e */\n-\n-        bd0 = s2b(bd0, s0, nd0, nd, y);\n-\tbd = Brealloc(bd, bd0->k);\n-\n-        for(;;) {\n-                Bcopy(bd, bd0);\n-                bb = d2b(bb, rv, &bbe, &bbbits);    /* rv = bb * 2^bbe */\n-                bs = i2b(bs, 1);\n-\n-                if (e >= 0) {\n-                        bb2 = bb5 = 0;\n-                        bd2 = bd5 = e;\n-                        }\n-                else {\n-                        bb2 = bb5 = -e;\n-                        bd2 = bd5 = 0;\n-                        }\n-                if (bbe >= 0)\n-                        bb2 += bbe;\n-                else\n-                        bd2 -= bbe;\n-                bs2 = bb2;\n-#ifdef Sudden_Underflow\n-#ifdef IBM\n-                j = 1 + 4*P - 3 - bbbits + ((bbe + bbbits - 1) & 3);\n-#else\n-                j = P + 1 - bbbits;\n-#endif\n-#else\n-                i = bbe + bbbits - 1;   /* logb(rv) */\n-                if (i < Emin)   /* denormal */\n-                        j = bbe + (P-Emin);\n-                else\n-                        j = P + 1 - bbbits;\n-#endif\n-                bb2 += j;\n-                bd2 += j;\n-                i = bb2 < bd2 ? bb2 : bd2;\n-                if (i > bs2)\n-                        i = bs2;\n-                if (i > 0) {\n-                        bb2 -= i;\n-                        bd2 -= i;\n-                        bs2 -= i;\n-                        }\n-                if (bb5 > 0) {\n-\t\t\tBigint *b_tmp;\n-                        bs = pow5mult(bs, bb5);\n-                        b_tmp = mult(b_avail, bs, bb);\n-                        b_avail = bb;\n-                        bb = b_tmp;\n-                        }\n-                if (bb2 > 0)\n-                        bb = lshift(bb, bb2);\n-                if (bd5 > 0)\n-                        bd = pow5mult(bd, bd5);\n-                if (bd2 > 0)\n-                        bd = lshift(bd, bd2);\n-                if (bs2 > 0)\n-                        bs = lshift(bs, bs2);\n-                delta = diff(delta, bb, bd);\n-                dsign = delta->sign;\n-                delta->sign = 0;\n-                i = cmp(delta, bs);\n-                if (i < 0) {\n-                        /* Error is less than half an ulp -- check for\n-                         * special case of mantissa a power of two.\n-                         */\n-                        if (dsign || word1(rv) || word0(rv) & Bndry_mask)\n-                                break;\n-                        delta = lshift(delta,Log2P);\n-                        if (cmp(delta, bs) > 0)\n-                                goto drop_down;\n-                        break;\n-                        }\n-                if (i == 0) {\n-                        /* exactly half-way between */\n-                        if (dsign) {\n-                                if ((word0(rv) & Bndry_mask1) == Bndry_mask1\n-                                 &&  word1(rv) == 0xffffffff) {\n-                                        /*boundary case -- increment exponent*/\n-                                        setword0(rv, (word0(rv) & Exp_mask)\n-\t\t\t\t\t\t + Exp_msk1);\n-#ifdef IBM\n-                                        setword0 (rv,\n-\t\t\t\t\t\t  word0(rv) | (Exp_msk1 >> 4));\n-#endif\n-                                        setword1(rv, 0);\n-                                        break;\n-                                        }\n-                                }\n-                        else if (!(word0(rv) & Bndry_mask) && !word1(rv)) {\n- drop_down:\n-                                /* boundary case -- decrement exponent */\n-#ifdef Sudden_Underflow\n-                                L = word0(rv) & Exp_mask;\n-#ifdef IBM\n-                                if (L <  Exp_msk1)\n-#else\n-                                if (L <= Exp_msk1)\n-#endif\n-                                        goto undfl;\n-                                L -= Exp_msk1;\n-#else\n-                                L = (word0(rv) & Exp_mask) - Exp_msk1;\n-#endif\n-                                setwords(rv, L | Bndry_mask1, 0xffffffff);\n-#ifdef IBM\n-                                continue;\n-#else\n-                                break;\n-#endif\n-                                }\n-#ifndef ROUND_BIASED\n-                        if (!(word1(rv) & LSB))\n-                                break;\n-#endif\n-                        if (dsign)\n-                                rv += ulp(rv);\n-#ifndef ROUND_BIASED\n-                        else {\n-                                rv -= ulp(rv);\n-#ifndef Sudden_Underflow\n-                                if (!rv)\n-                                        goto undfl;\n-#endif\n-                                }\n-#endif\n-                        break;\n-                        }\n-                if ((aadj = ratio(delta, bs)) <= 2.) {\n-                        if (dsign)\n-                                aadj = aadj1 = 1.;\n-                        else if (word1(rv) || word0(rv) & Bndry_mask) {\n-#ifndef Sudden_Underflow\n-                                if (word1(rv) == Tiny1 && !word0(rv))\n-                                        goto undfl;\n-#endif\n-                                aadj = 1.;\n-                                aadj1 = -1.;\n-                                }\n-                        else {\n-                                /* special case -- power of FLT_RADIX to be */\n-                                /* rounded down... */\n-\n-                                if (aadj < 2./FLT_RADIX)\n-                                        aadj = 1./FLT_RADIX;\n-                                else\n-                                        aadj *= 0.5;\n-                                aadj1 = -aadj;\n-                                }\n-                        }\n-                else {\n-                        aadj *= 0.5;\n-                        aadj1 = dsign ? aadj : -aadj;\n-#ifdef Check_FLT_ROUNDS\n-                        switch(FLT_ROUNDS) {\n-                                case 2: /* towards +infinity */\n-                                        aadj1 -= 0.5;\n-                                        break;\n-                                case 0: /* towards 0 */\n-                                case 3: /* towards -infinity */\n-                                        aadj1 += 0.5;\n-                                }\n-#else\n-                        if (FLT_ROUNDS == 0)\n-                                aadj1 += 0.5;\n-#endif\n-                        }\n-                y = word0(rv) & Exp_mask;\n-\n-                /* Check for overflow */\n-\n-                if (y == Exp_msk1*(DBL_MAX_EXP+Bias-1)) {\n-                        rv0 = rv;\n-                        addword0(rv, - P*Exp_msk1);\n-                        adj = aadj1 * ulp(rv);\n-                        rv += adj;\n-                        if ((word0(rv) & Exp_mask) >=\n-                                        Exp_msk1*(DBL_MAX_EXP+Bias-P)) {\n-                                if (word0(rv0) == Big0 && word1(rv0) == Big1)\n-                                        goto ovfl;\n-                                setwords(rv, Big0, Big1);\n-                                continue;\n-                                }\n-                        else\n-                                addword0(rv, P*Exp_msk1);\n-                        }\n-                else {\n-#ifdef Sudden_Underflow\n-                        if ((word0(rv) & Exp_mask) <= P*Exp_msk1) {\n-                                rv0 = rv;\n-                                addword0(rv, P*Exp_msk1);\n-                                adj = aadj1 * ulp(rv);\n-                                rv += adj;\n-#ifdef IBM\n-                                if ((word0(rv) & Exp_mask) <  P*Exp_msk1)\n-#else\n-                                if ((word0(rv) & Exp_mask) <= P*Exp_msk1)\n-#endif\n-                                        {\n-                                        if (word0(rv0) == Tiny0\n-                                         && word1(rv0) == Tiny1)\n-                                                goto undfl;\n-                                        setwords(rv, Tiny0, Tiny1);\n-                                        continue;\n-                                        }\n-                                else\n-                                        addword0(rv, -P*Exp_msk1);\n-                                }\n-                        else {\n-                                adj = aadj1 * ulp(rv);\n-                                rv += adj;\n-                                }\n-#else\n-                        /* Compute adj so that the IEEE rounding rules will\n-                         * correctly round rv + adj in some half-way cases.\n-                         * If rv * ulp(rv) is denormalized (i.e.,\n-                         * y <= (P-1)*Exp_msk1), we must adjust aadj to avoid\n-                         * trouble from bits lost to denormalization;\n-                         * example: 1.2e-307 .\n-                         */\n-                        if (y <= (P-1)*Exp_msk1 && aadj >= 1.) {\n-                                aadj1 = (double)(int)(aadj + 0.5);\n-                                if (!dsign)\n-                                        aadj1 = -aadj1;\n-                                }\n-                        adj = aadj1 * ulp(rv);\n-                        rv += adj;\n-#endif\n-                        }\n-                z = word0(rv) & Exp_mask;\n-                if (y == z) {\n-                        /* Can we stop now? */\n-                        L = (_G_int32_t)aadj;\n-                        aadj -= L;\n-                        /* The tolerances below are conservative. */\n-                        if (dsign || word1(rv) || word0(rv) & Bndry_mask) {\n-                                if (aadj < .4999999 || aadj > .5000001)\n-                                        break;\n-                                }\n-                        else if (aadj < .4999999/FLT_RADIX)\n-                                break;\n-                        }\n-                }\n-        Bfree(bb);\n-        Bfree(bd);\n-        Bfree(bs);\n-        Bfree(bd0);\n-        Bfree(delta);\n-\tBfree(b_avail);\n- ret:\n-        if (se)\n-                *se = (char *)s;\n-        return sign ? -rv : rv;\n-        }\n-\n-static int\n-quorem\n-#ifdef KR_headers\n-        (b, S) Bigint *b, *S;\n-#else\n-        (Bigint *b, Bigint *S)\n-#endif\n-{\n-        int n;\n-        _G_int32_t borrow, y;\n-        unsigned32 carry, q, ys;\n-        unsigned32 *bx, *bxe, *sx, *sxe;\n-        _G_int32_t z;\n-        unsigned32 si, zs;\n-\n-        n = S->wds;\n-#ifdef DEBUG\n-        /*debug*/ if (b->wds > n)\n-        /*debug*/       Bug(\"oversize b in quorem\");\n-#endif\n-        if (b->wds < n)\n-                return 0;\n-        sx = S->x;\n-        sxe = sx + --n;\n-        bx = b->x;\n-        bxe = bx + n;\n-        q = *bxe / (*sxe + 1);  /* ensure q <= true quotient */\n-#ifdef DEBUG\n-        /*debug*/ if (q > 9)\n-        /*debug*/       Bug(\"oversized quotient in quorem\");\n-#endif\n-        if (q) {\n-                borrow = 0;\n-                carry = 0;\n-                do {\n-                        si = *sx++;\n-                        ys = (si & 0xffff) * q + carry;\n-                        zs = (si >> 16) * q + (ys >> 16);\n-                        carry = zs >> 16;\n-                        y = (*bx & 0xffff) - (ys & 0xffff) + borrow;\n-                        borrow = y >> 16;\n-                        Sign_Extend(borrow, y);\n-                        z = (*bx >> 16) - (zs & 0xffff) + borrow;\n-                        borrow = z >> 16;\n-                        Sign_Extend(borrow, z);\n-                        Storeinc(bx, z, y);\n-                        }\n-                        while(sx <= sxe);\n-                if (!*bxe) {\n-                        bx = b->x;\n-                        while(--bxe > bx && !*bxe)\n-                                --n;\n-                        b->wds = n;\n-                        }\n-                }\n-        if (cmp(b, S) >= 0) {\n-                q++;\n-                borrow = 0;\n-                carry = 0;\n-                bx = b->x;\n-                sx = S->x;\n-                do {\n-                        si = *sx++;\n-                        ys = (si & 0xffff) + carry;\n-                        zs = (si >> 16) + (ys >> 16);\n-                        carry = zs >> 16;\n-                        y = (*bx & 0xffff) - (ys & 0xffff) + borrow;\n-                        borrow = y >> 16;\n-                        Sign_Extend(borrow, y);\n-                        z = (*bx >> 16) - (zs & 0xffff) + borrow;\n-                        borrow = z >> 16;\n-                        Sign_Extend(borrow, z);\n-                        Storeinc(bx, z, y);\n-                        }\n-                        while(sx <= sxe);\n-                bx = b->x;\n-                bxe = bx + n;\n-                if (!*bxe) {\n-                        while(--bxe > bx && !*bxe)\n-                                --n;\n-                        b->wds = n;\n-                        }\n-                }\n-        return q;\n-        }\n-\n-/* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.\n- *\n- * Inspired by \"How to Print Floating-Point Numbers Accurately\" by\n- * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 92-101].\n- *\n- * Modifications:\n- *      1. Rather than iterating, we use a simple numeric overestimate\n- *         to determine k = floor(log10(d)).  We scale relevant\n- *         quantities using O(log2(k)) rather than O(k) multiplications.\n- *      2. For some modes > 2 (corresponding to ecvt and fcvt), we don't\n- *         try to generate digits strictly left to right.  Instead, we\n- *         compute with fewer bits and propagate the carry if necessary\n- *         when rounding the final digit up.  This is often faster.\n- *      3. Under the assumption that input will be rounded nearest,\n- *         mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.\n- *         That is, we allow equality in stopping tests when the\n- *         round-nearest rule will give the same floating-point value\n- *         as would satisfaction of the stopping test with strict\n- *         inequality.\n- *      4. We remove common factors of powers of 2 from relevant\n- *         quantities.\n- *      5. When converting floating-point integers less than 1e16,\n- *         we use floating-point arithmetic rather than resorting\n- *         to multiple-precision integers.\n- *      6. When asked to produce fewer than 15 digits, we first try\n- *         to get by with floating-point arithmetic; we resort to\n- *         multiple-precision integer arithmetic only if we cannot\n- *         guarantee that the floating-point calculation has given\n- *         the correctly rounded result.  For k requested digits and\n- *         \"uniformly\" distributed input, the probability is\n- *         something like 10^(k-15) that we must resort to the long\n- *         calculation.\n- */\n-\n- char *\n-_IO_dtoa\n-#ifdef KR_headers\n-        (d, mode, ndigits, decpt, sign, rve)\n-        double d; int mode, ndigits, *decpt, *sign; char **rve;\n-#else\n-        (double d, int mode, int ndigits, int *decpt, int *sign, char **rve)\n-#endif\n-{\n- /*     Arguments ndigits, decpt, sign are similar to those\n-        of ecvt and fcvt; trailing zeros are suppressed from\n-        the returned string.  If not null, *rve is set to point\n-        to the end of the return value.  If d is +-Infinity or NaN,\n-        then *decpt is set to 9999.\n-\n-        mode:\n-                0 ==> shortest string that yields d when read in\n-                        and rounded to nearest.\n-                1 ==> like 0, but with Steele & White stopping rule;\n-                        e.g. with IEEE P754 arithmetic , mode 0 gives\n-                        1e23 whereas mode 1 gives 9.999999999999999e22.\n-                2 ==> max(1,ndigits) significant digits.  This gives a\n-                        return value similar to that of ecvt, except\n-                        that trailing zeros are suppressed.\n-                3 ==> through ndigits past the decimal point.  This\n-                        gives a return value similar to that from fcvt,\n-                        except that trailing zeros are suppressed, and\n-                        ndigits can be negative.\n-                4-9 should give the same return values as 2-3, i.e.,\n-                        4 <= mode <= 9 ==> same return as mode\n-                        2 + (mode & 1).  These modes are mainly for\n-                        debugging; often they run slower but sometimes\n-                        faster than modes 2-3.\n-                4,5,8,9 ==> left-to-right digit generation.\n-                6-9 ==> don't try fast floating-point estimate\n-                        (if applicable).\n-\n-                Values of mode other than 0-9 are treated as mode 0.\n-\n-                Sufficient space is allocated to the return value\n-                to hold the suppressed trailing zeros.\n-        */\n-\n-        _G_int32_t bbits, b2, b5, be, dig, i, ieps, ilim, ilim0, ilim1,\n-                j, j1, k, k0, k_check, leftright, m2, m5, s2, s5,\n-                spec_case, try_quick;\n-        _G_int32_t L;\n-#ifndef Sudden_Underflow\n-        int denorm;\n-#endif\n-\tBigint _b_avail, _b, _mhi, _mlo, _S;\n-\tBigint *b_avail = Binit(&_b_avail);\n-\tBigint *b = Binit(&_b);\n-\tBigint *S = Binit(&_S);\n-\t/* mhi and mlo are only set and used if leftright. */\n-        Bigint *mhi = NULL, *mlo = NULL;\n-        double d2, ds, eps;\n-        char *s, *s0;\n-        static Bigint *result = NULL;\n-        static int result_k;\n-\n-\tTEST_ENDIANNESS;\n-        if (result) {\n-\t\t/* result is contains a string, so its fields (interpreted\n-\t\t   as a Bigint have been trashed.  Restore them.\n-\t\t   This is a really ugly interface - result should\n-\t\t   not be static, since that is not thread-safe.  FIXME. */\n-                result->k = result_k;\n-                result->maxwds = 1 << result_k;\n-                result->on_stack = 0;\n-                }\n-\n-        if (word0(d) & Sign_bit) {\n-                /* set sign for everything, including 0's and NaNs */\n-                *sign = 1;\n-                setword0(d, word0(d) & ~Sign_bit);  /* clear sign bit */\n-                }\n-        else\n-                *sign = 0;\n-\n-#if defined(IEEE_Arith) + defined(VAX)\n-#ifdef IEEE_Arith\n-        if ((word0(d) & Exp_mask) == Exp_mask)\n-#else\n-        if (word0(d)  == 0x8000)\n-#endif\n-                {\n-                /* Infinity or NaN */\n-                *decpt = 9999;\n-#ifdef IEEE_Arith\n-\t\tif (!word1(d) && !(word0(d) & 0xfffff))\n-\t\t  {\n-\t\t    s = \"Infinity\";\n-\t\t    if (rve)\n-\t\t      *rve = s + 8;\n-\t\t  }\n-\t\telse\n-#endif\n-\t\t  {\n-\t\t    s = \"NaN\";\n-\t\t    if (rve)\n-\t\t      *rve = s +3;\n-\t\t  }\n-                return s;\n-                }\n-#endif\n-#ifdef IBM\n-        d += 0; /* normalize */\n-#endif\n-        if (!d) {\n-                *decpt = 1;\n-                s = \"0\";\n-                if (rve)\n-                        *rve = s + 1;\n-                return s;\n-                }\n-\n-        b = d2b(b, d, &be, &bbits);\n-        i = (int)(word0(d) >> Exp_shift1 & (Exp_mask>>Exp_shift1));\n-#ifndef Sudden_Underflow\n-        if (i) {\n-#endif\n-                d2 = d;\n-                setword0(d2, (word0(d2) & Frac_mask1) | Exp_11);\n-#ifdef IBM\n-                if (j = 11 - hi0bits(word0(d2) & Frac_mask))\n-                        d2 /= 1 << j;\n-#endif\n-\n-                i -= Bias;\n-#ifdef IBM\n-                i <<= 2;\n-                i += j;\n-#endif\n-#ifndef Sudden_Underflow\n-                denorm = 0;\n-                }\n-        else {\n-                /* d is denormalized */\n-\t\tunsigned32 x;\n-\n-                i = bbits + be + (Bias + (P-1) - 1);\n-                x = i > 32  ? word0(d) << (64 - i) | word1(d) >> (i - 32)\n-                            : word1(d) << (32 - i);\n-                d2 = x;\n-                addword0(d2, - 31*Exp_msk1); /* adjust exponent */\n-                i -= (Bias + (P-1) - 1) + 1;\n-                denorm = 1;\n-                }\n-#endif\n-\n-\t/* Now i is the unbiased base-2 exponent. */\n-\n-        /* log(x)       ~=~ log(1.5) + (x-1.5)/1.5\n-         * log10(x)      =  log(x) / log(10)\n-         *              ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))\n-         * log10(d) = i*log(2)/log(10) + log10(d2)\n-         *\n-         * This suggests computing an approximation k to log10(d) by\n-         *\n-         * k = i*0.301029995663981\n-         *      + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );\n-         *\n-         * We want k to be too large rather than too small.\n-         * The error in the first-order Taylor series approximation\n-         * is in our favor, so we just round up the constant enough\n-         * to compensate for any error in the multiplication of\n-         * (i) by 0.301029995663981; since |i| <= 1077,\n-         * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,\n-         * adding 1e-13 to the constant term more than suffices.\n-         * Hence we adjust the constant term to 0.1760912590558.\n-         * (We could get a more accurate k by invoking log10,\n-         *  but this is probably not worthwhile.)\n-         */\n-\n-        ds = (d2-1.5)*0.289529654602168 + 0.1760912590558 + i*0.301029995663981;\n-        k = (int)ds;\n-        if (ds < 0. && ds != k)\n-                k--;    /* want k = floor(ds) */\n-        k_check = 1;\n-        if (k >= 0 && k <= Ten_pmax) {\n-                if (d < tens[k])\n-                        k--;\n-                k_check = 0;\n-                }\n-        j = bbits - i - 1;\n-        if (j >= 0) {\n-                b2 = 0;\n-                s2 = j;\n-                }\n-        else {\n-                b2 = -j;\n-                s2 = 0;\n-                }\n-        if (k >= 0) {\n-                b5 = 0;\n-                s5 = k;\n-                s2 += k;\n-                }\n-        else {\n-                b2 -= k;\n-                b5 = -k;\n-                s5 = 0;\n-                }\n-        if (mode < 0 || mode > 9)\n-                mode = 0;\n-        try_quick = 1;\n-        if (mode > 5) {\n-                mode -= 4;\n-                try_quick = 0;\n-                }\n-        leftright = 1;\n-        switch(mode) {\n-                case 0:\n-                case 1:\n-                        ilim = ilim1 = -1;\n-                        i = 18;\n-                        ndigits = 0;\n-                        break;\n-                case 2:\n-                        leftright = 0;\n-                        /* no break */\n-                case 4:\n-                        if (ndigits <= 0)\n-                                ndigits = 1;\n-                        ilim = ilim1 = i = ndigits;\n-                        break;\n-                case 3:\n-                        leftright = 0;\n-                        /* no break */\n-                case 5:\n-                        i = ndigits + k + 1;\n-                        ilim = i;\n-                        ilim1 = i - 1;\n-                        if (i <= 0)\n-                                i = 1;\n-                }\n-\t/* i is now an upper bound of the number of digits to generate. */\n-        j = sizeof(unsigned32) * (1<<BIGINT_MINIMUM_K);\n-\t/* The test is <= so as to allow room for the final '\\0'. */\n-        for(result_k = BIGINT_MINIMUM_K; BIGINT_HEADER_SIZE + j <= i;\n-                j <<= 1) result_k++;\n-        if (!result || result_k > result->k)\n-        {\n-          Bfree (result);\n-          result = Balloc(result_k);\n-        }\n-        s = s0 = (char *)result;\n-\n-        if (ilim >= 0 && ilim <= Quick_max && try_quick) {\n-\n-                /* Try to get by with floating-point arithmetic. */\n-\n-                i = 0;\n-                d2 = d;\n-                k0 = k;\n-                ilim0 = ilim;\n-                ieps = 2; /* conservative */\n-                if (k > 0) {\n-                        ds = tens[k&0xf];\n-                        j = k >> 4;\n-                        if (j & Bletch) {\n-                                /* prevent overflows */\n-                                j &= Bletch - 1;\n-                                d /= bigtens[n_bigtens-1];\n-                                ieps++;\n-                                }\n-                        for(; j; j >>= 1, i++)\n-                                if (j & 1) {\n-                                        ieps++;\n-                                        ds *= bigtens[i];\n-                                        }\n-                        d /= ds;\n-                        }\n-                else if ((j1 = -k)) {\n-                        d *= tens[j1 & 0xf];\n-                        for(j = j1 >> 4; j; j >>= 1, i++)\n-                                if (j & 1) {\n-                                        ieps++;\n-                                        d *= bigtens[i];\n-                                        }\n-                        }\n-                if (k_check && d < 1. && ilim > 0) {\n-                        if (ilim1 <= 0)\n-                                goto fast_failed;\n-                        ilim = ilim1;\n-                        k--;\n-                        d *= 10.;\n-                        ieps++;\n-                        }\n-                eps = ieps*d + 7.;\n-                addword0(eps, - (P-1)*Exp_msk1);\n-                if (ilim == 0) {\n-                        d -= 5.;\n-                        if (d > eps)\n-                                goto one_digit;\n-                        if (d < -eps)\n-                                goto no_digits;\n-                        goto fast_failed;\n-                        }\n-#ifndef No_leftright\n-                if (leftright) {\n-                        /* Use Steele & White method of only\n-                         * generating digits needed.\n-                         */\n-                        eps = 0.5/tens[ilim-1] - eps;\n-                        for(i = 0;;) {\n-                                L = (_G_int32_t)d;\n-                                d -= L;\n-                                *s++ = '0' + (int)L;\n-                                if (d < eps)\n-                                        goto ret1;\n-                                if (1. - d < eps)\n-                                        goto bump_up;\n-                                if (++i >= ilim)\n-                                        break;\n-                                eps *= 10.;\n-                                d *= 10.;\n-                                }\n-                        }\n-                else {\n-#endif\n-                        /* Generate ilim digits, then fix them up. */\n-                        eps *= tens[ilim-1];\n-                        for(i = 1;; i++, d *= 10.) {\n-                                L = (_G_int32_t)d;\n-                                d -= L;\n-                                *s++ = '0' + (int)L;\n-                                if (i == ilim) {\n-                                        if (d > 0.5 + eps)\n-                                                goto bump_up;\n-                                        else if (d < 0.5 - eps) {\n-                                                while(*--s == '0');\n-                                                s++;\n-                                                goto ret1;\n-                                                }\n-                                        break;\n-                                        }\n-                                }\n-#ifndef No_leftright\n-                        }\n-#endif\n- fast_failed:\n-                s = s0;\n-                d = d2;\n-                k = k0;\n-                ilim = ilim0;\n-                }\n-\n-        /* Do we have a \"small\" integer? */\n-\n-        if (be >= 0 && k <= Int_max) {\n-                /* Yes. */\n-                ds = tens[k];\n-                if (ndigits < 0 && ilim <= 0) {\n-                        if (ilim < 0 || d <= 5*ds)\n-                                goto no_digits;\n-                        goto one_digit;\n-                        }\n-                for(i = 1;; i++) {\n-                        L = (_G_int32_t)(d / ds);\n-                        d -= L*ds;\n-#ifdef Check_FLT_ROUNDS\n-                        /* If FLT_ROUNDS == 2, L will usually be high by 1 */\n-                        if (d < 0) {\n-                                L--;\n-                                d += ds;\n-                                }\n-#endif\n-                        *s++ = '0' + (int)L;\n-                        if (i == ilim) {\n-                                d += d;\n-                                if (d > ds || (d == ds && L & 1)) {\n- bump_up:\n-                                        while(*--s == '9')\n-                                                if (s == s0) {\n-                                                        k++;\n-                                                        *s = '0';\n-                                                        break;\n-                                                        }\n-                                        ++*s++;\n-                                        }\n-                                break;\n-                                }\n-                        if (!(d *= 10.))\n-                                break;\n-                        }\n-                goto ret1;\n-                }\n-\n-        m2 = b2;\n-        m5 = b5;\n-        if (leftright) {\n-                if (mode < 2) {\n-                        i =\n-#ifndef Sudden_Underflow\n-                                denorm ? be + (Bias + (P-1) - 1 + 1) :\n-#endif\n-#ifdef IBM\n-                                1 + 4*P - 3 - bbits + ((bbits + be - 1) & 3);\n-#else\n-                                1 + P - bbits;\n-#endif\n-                        }\n-                else {\n-                        j = ilim - 1;\n-                        if (m5 >= j)\n-                                m5 -= j;\n-                        else {\n-                                s5 += j -= m5;\n-                                b5 += j;\n-                                m5 = 0;\n-                                }\n-                        if ((i = ilim) < 0) {\n-                                m2 -= i;\n-                                i = 0;\n-                                }\n-                        }\n-                b2 += i;\n-                s2 += i;\n-                mhi = i2b(Binit(&_mhi), 1);\n-                }\n-        if (m2 > 0 && s2 > 0) {\n-                i = m2 < s2 ? m2 : s2;\n-                b2 -= i;\n-                m2 -= i;\n-                s2 -= i;\n-                }\n-        if (b5 > 0) {\n-                if (leftright) {\n-                        if (m5 > 0) {\n-\t\t\t\tBigint *b_tmp;\n-                                mhi = pow5mult(mhi, m5);\n-                                b_tmp = mult(b_avail, mhi, b);\n-                                b_avail = b;\n-                                b = b_tmp;\n-                                }\n-                        if ((j = b5 - m5))\n-                                b = pow5mult(b, j);\n-                        }\n-                else\n-                        b = pow5mult(b, b5);\n-                }\n-        S = i2b(S, 1);\n-        if (s5 > 0)\n-                S = pow5mult(S, s5);\n-\n-        /* Check for special case that d is a normalized power of 2. */\n-\n-        if (mode < 2) {\n-                if (!word1(d) && !(word0(d) & Bndry_mask)\n-#ifndef Sudden_Underflow\n-                 && word0(d) & Exp_mask\n-#endif\n-                                ) {\n-                        /* The special case */\n-                        b2 += Log2P;\n-                        s2 += Log2P;\n-                        spec_case = 1;\n-                        }\n-                else\n-                        spec_case = 0;\n-                }\n-\n-        /* Arrange for convenient computation of quotients:\n-         * shift left if necessary so divisor has 4 leading 0 bits.\n-         *\n-         * Perhaps we should just compute leading 28 bits of S once\n-         * and for all and pass them and a shift to quorem, so it\n-         * can do shifts and ors to compute the numerator for q.\n-         */\n-        if ((i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0x1f))\n-                i = 32 - i;\n-        if (i > 4) {\n-                i -= 4;\n-                b2 += i;\n-                m2 += i;\n-                s2 += i;\n-                }\n-        else if (i < 4) {\n-                i += 28;\n-                b2 += i;\n-                m2 += i;\n-                s2 += i;\n-                }\n-        if (b2 > 0)\n-                b = lshift(b, b2);\n-        if (s2 > 0)\n-                S = lshift(S, s2);\n-        if (k_check) {\n-                if (cmp(b,S) < 0) {\n-                        k--;\n-                        b = multadd(b, 10, 0);  /* we botched the k estimate */\n-                        if (leftright)\n-                                mhi = multadd(mhi, 10, 0);\n-                        ilim = ilim1;\n-                        }\n-                }\n-        if (ilim <= 0 && mode > 2) {\n-                if (ilim < 0 || cmp(b,S = multadd(S,5,0)) <= 0) {\n-                        /* no digits, fcvt style */\n- no_digits:\n-                        k = -1 - ndigits;\n-                        goto ret;\n-                        }\n- one_digit:\n-                *s++ = '1';\n-                k++;\n-                goto ret;\n-                }\n-        if (leftright) {\n-                if (m2 > 0)\n-                        mhi = lshift(mhi, m2);\n-\n-                /* Compute mlo -- check for special case\n-                 * that d is a normalized power of 2.\n-                 */\n-\n-                if (spec_case) {\n-\t\t\tmlo = Brealloc(Binit(&_mlo), mhi->k);\n-                        Bcopy(mlo, mhi);\n-                        mhi = lshift(mhi, Log2P);\n-                        }\n-\t\telse\n-\t\t\tmlo = mhi;\n-\n-                for(i = 1;;i++) {\n-                        dig = quorem(b,S) + '0';\n-                        /* Do we yet have the shortest decimal string\n-                         * that will round to d?\n-                         */\n-                        j = cmp(b, mlo);\n-                        b_avail = diff(b_avail, S, mhi); /* b_avail = S - mi */\n-                        j1 = b_avail->sign ? 1 : cmp(b, b_avail);\n-#ifndef ROUND_BIASED\n-                        if (j1 == 0 && !mode && !(word1(d) & 1)) {\n-                                if (dig == '9')\n-                                        goto round_9_up;\n-                                if (j > 0)\n-                                        dig++;\n-                                *s++ = dig;\n-                                goto ret;\n-                                }\n-#endif\n-                        if (j < 0 || (j == 0 && !mode\n-#ifndef ROUND_BIASED\n-                                                        && !(word1(d) & 1)\n-#endif\n-                                        )) {\n-                                if (j1 > 0) {\n-                                        b = lshift(b, 1);\n-                                        j1 = cmp(b, S);\n-                                        if ((j1 > 0 || (j1 == 0 && dig & 1))\n-                                        && dig++ == '9')\n-                                                goto round_9_up;\n-                                        }\n-                                *s++ = dig;\n-                                goto ret;\n-                                }\n-                        if (j1 > 0) {\n-                                if (dig == '9') { /* possible if i == 1 */\n- round_9_up:\n-                                        *s++ = '9';\n-                                        goto roundoff;\n-                                        }\n-                                *s++ = dig + 1;\n-                                goto ret;\n-                                }\n-                        *s++ = dig;\n-                        if (i == ilim)\n-                                break;\n-                        b = multadd(b, 10, 0);\n-                        if (mlo == mhi)\n-                                mlo = mhi = multadd(mhi, 10, 0);\n-                        else {\n-                                mlo = multadd(mlo, 10, 0);\n-                                mhi = multadd(mhi, 10, 0);\n-                                }\n-                        }\n-                }\n-        else\n-                for(i = 1;; i++) {\n-                        *s++ = dig = quorem(b,S) + '0';\n-                        if (i >= ilim)\n-                                break;\n-                        b = multadd(b, 10, 0);\n-                        }\n-\n-        /* Round off last digit */\n-\n-        b = lshift(b, 1);\n-        j = cmp(b, S);\n-        if (j > 0 || (j == 0 && dig & 1)) {\n- roundoff:\n-                while(*--s == '9')\n-                        if (s == s0) {\n-                                k++;\n-                                *s++ = '1';\n-                                goto ret;\n-                                }\n-                ++*s++;\n-                }\n-        else {\n-                while(*--s == '0');\n-                s++;\n-                }\n- ret:\n-\tBfree(b_avail);\n-        Bfree(S);\n-        if (mhi) {\n-                if (mlo && mlo != mhi)\n-                        Bfree(mlo);\n-                Bfree(mhi);\n-                }\n- ret1:\n-        Bfree(b);\n-        *s = 0;\n-        *decpt = k + 1;\n-        if (rve)\n-                *rve = s;\n-        return s0;\n-        }\n-#endif /* _IO_USE_DTOA */"}, {"sha": "79c0f630dfc9c50db28f33beeb203cf9775d7df7", "filename": "libio/floatio.h", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffloatio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffloatio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ffloatio.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,64 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-/*\n- * Copyright (c) 1990 The Regents of the University of California.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. [rescinded 22 July 1999]\n- * 4. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- *\n- *\t%W% (Berkeley) %G%\n- */\n-\n-/*\n- * Floating point scanf/printf (input/output) definitions.\n- */\n-\n-/* 11-bit exponent (VAX G floating point) is 308 decimal digits */\n-#define\tMAXEXP\t\t308\n-/* 128 bit fraction takes up 39 decimal digits; max reasonable precision */\n-#define\tMAXFRACT\t39"}, {"sha": "8930e0b9271f97ac81abd6ec5bc7586ca247345f", "filename": "libio/fstream.cc", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ffstream.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,110 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License.\n-\n-Written by Per Bothner (bothner@cygnus.com). */\n-\n-#ifdef __GNUG__\n-#pragma implementation\n-#endif\n-#define _STREAM_COMPAT\n-extern \"C\" {\n-#include \"libioP.h\"\n-}\n-#include <fstream.h>\n-\n-inline void\n-fstreambase::__fb_init()\n-{\n-#ifdef _IO_NEW_STREAMS\n-#if !_IO_UNIFIED_JUMPTABLES\n-  /* Uses the _IO_file_jump jumptable, for eficiency. */\n-  __my_fb._jumps = &_IO_file_jumps;\n-  __my_fb._vtable() = builtinbuf_vtable;\n-#endif\n-  init (&__my_fb);\n-#else\n-  init(filebuf::__new());\n-  _flags &= ~ios::dont_close;\n-#endif\n-}\n-\n-fstreambase::fstreambase()\n-{\n-  __fb_init ();\n-}\n-\n-fstreambase::fstreambase(int fd)\n-{\n-  __fb_init ();\n-  _IO_file_attach(rdbuf(), fd);\n-}\n-\n-fstreambase::fstreambase(const char *name, int mode, int prot)\n-{\n-  __fb_init ();\n-  if (!rdbuf()->open(name, mode, prot))\n-    set(ios::badbit);\n-}\n-\n-fstreambase::fstreambase(int fd, char *p, int l)\n-{\n-#ifdef _IO_NEW_STREAMS\n-  __fb_init ();\n-#else\n-  init(filebuf::__new());\n-#endif\n-  _IO_file_attach(rdbuf(), fd);\n-  _IO_file_setbuf(rdbuf(), p, l);\n-}\n-\n-void fstreambase::open(const char *name, int mode, int prot)\n-{\n-    clear();\n-    if (!rdbuf()->open(name, mode, prot))\n-\tset(ios::badbit);\n-}\n-\n-void fstreambase::close()\n-{\n-    if (!rdbuf()->close())\n-\tset(ios::failbit);\n-}\n-\n-void fstreambase::attach(int fd)\n-{\n-  if (!rdbuf()->attach(fd))\n-    set(ios::failbit);\n-}\n-\n-#if 0\n-static int mode_to_sys(enum open_mode mode)\n-{\n-    return O_WRONLY;\n-}\n-\n-static char* fopen_cmd_arg(io_mode i)\n-{\n-    return \"w\";\n-}\n-#endif"}, {"sha": "b5f6598538f211471c4c6864a2f541e26767ce96", "filename": "libio/fstream.h", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ffstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ffstream.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,92 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993, 2000 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#ifndef _FSTREAM_H\n-#define _FSTREAM_H\n-#ifdef __GNUG__\n-#pragma interface\n-#endif\n-#include <iostream.h>\n-\n-extern \"C++\" {\n-class fstreambase : virtual public ios {\n-#ifdef _IO_NEW_STREAMS\n-    mutable filebuf __my_fb; // mutable so rdbuf() can be const\n-#endif\n-    void __fb_init ();\n-  public:\n-    fstreambase();\n-    fstreambase(int fd);\n-    fstreambase(int fd, char *p, int l); /* Deprecated */\n-    fstreambase(const char *name, int mode, int prot=0664);\n-    void close();\n-#ifdef _IO_NEW_STREAMS\n-    filebuf* rdbuf() const { return &__my_fb; }\n-#else\n-    filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }\n-#endif\n-    void open(const char *name, int mode, int prot=0664);\n-    int is_open() const { return rdbuf()->is_open(); }\n-    void setbuf(char *ptr, int len) { rdbuf()->setbuf(ptr, len); }\n-    void attach(int fd);\n-#ifdef _STREAM_COMPAT\n-    int filedesc() { return rdbuf()->fd(); }\n-    fstreambase& raw() { rdbuf()->setbuf(NULL, 0); return *this; }\n-#endif\n-};\n-\n-class ifstream : public fstreambase, public istream {\n-  public:\n-    ifstream() : fstreambase() { }\n-    ifstream(int fd) : fstreambase(fd) { }\n-    ifstream(int fd, char *p, int l) : fstreambase(fd, p, l) { } /*Deprecated*/\n-    ifstream(const char *name, int mode=ios::in, int prot=0664)\n-\t: fstreambase(name, mode | ios::in, prot) { }\n-    void open(const char *name, int mode=ios::in, int prot=0664)\n-\t{ fstreambase::open(name, mode | ios::in, prot); }\n-};\n-\n-class ofstream : public fstreambase, public ostream {\n-  public:\n-    ofstream() : fstreambase() { }\n-    ofstream(int fd) : fstreambase(fd) { }\n-    ofstream(int fd, char *p, int l) : fstreambase(fd, p, l) { } /*Deprecated*/\n-    ofstream(const char *name, int mode=ios::out, int prot=0664)\n-\t: fstreambase(name, mode | ios::out, prot) { }\n-    void open(const char *name, int mode=ios::out, int prot=0664)\n-\t{ fstreambase::open(name, mode | ios::out, prot); }\n-};\n-\n-class fstream : public fstreambase, public iostream {\n-  public:\n-    fstream() : fstreambase() { }\n-    fstream(int fd) : fstreambase(fd) { }\n-    fstream(const char *name, int mode, int prot=0664)\n-\t: fstreambase(name, mode, prot) { }\n-    fstream(int fd, char *p, int l) : fstreambase(fd, p, l) { } /*Deprecated*/\n-    void open(const char *name, int mode, int prot=0664)\n-\t{ fstreambase::open(name, mode, prot); }\n-};\n-} // extern \"C++\"\n-#endif /*!_FSTREAM_H*/"}, {"sha": "d83c31b609923e0c4b2cf87c75473a3f4e54d78f", "filename": "libio/gen-params", "status": "removed", "additions": 0, "deletions": 778, "changes": 778, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fgen-params", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fgen-params", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fgen-params?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,778 +0,0 @@\n-#!/bin/sh\n-# Copyright (C) 1992, 1993, 1994, 1997, 1998, 1999, 2000 Free Software Foundation\n-# \n-# This file is part of the GNU IO Library.  This library is free\n-# software; you can redistribute it and/or modify it under the\n-# terms of the GNU General Public License as published by the\n-# Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-# \n-# This library is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with this library; see the file COPYING.  If not, write to the Free\n-# Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-#    Written by Per Bothner (bothner@cygnus.com)\n-\n-# This is a shell-script that figures out various things about a\n-# system, and writes (to stdout) a C-style include files with\n-# suitable definitions, including all the standard Posix types.\n-# It works by compiling various test programs -- some are run through\n-# the C pre-processor, and the output examined.\n-# The test programs are only compiled, not executed, so the script\n-# should even if you're cross-compiling.\n-# It uses $CC (which defaults to cc) to compile C programs (extension .c),\n-# and $CXX (which defaults to gcc) to compile C++ programs (extension .C).\n-# The shell-script is written for libg++.a.\n-\n-# Usage: gen-params [NAME1=name1 ...]\n-# - where an assignment (such as size_t=\"unsigned int\" means to\n-# use that value, instead of trying to figure it out.\n-\n-# Uncomment following line for debugging\n-# set -x\n-\n-SED=sed\n-\n-# Evaluate the arguments (which should be assignments):\n-for arg in \"$@\"; do\n-  # Quote arg (i.e. FOO=bar => FOO='bar'), then eval it.\n-  eval `echo \"$arg\" | ${SED} -e \"s|^\\(.*\\)=\\(.*\\)|\\1='\\2'|\"`\n-done\n-\n-macro_prefix=${macro_prefix-\"_G_\"}\n-rootdir=`pwd`/..\n-gccdir=${gccdir-${rootdir}/gcc}\n-binutilsdir=${binutilsdir-${rootdir}/binutils}\n-CC=${CC-`if [ -f ${gccdir}/xgcc ] ; \\\n-\tthen echo ${gccdir}/xgcc -B${gccdir}/ ; \\\n-\telse echo cc ; fi`}\n-CXX=${CXX-`if [ -f ${gccdir}/xgcc ] ; \\\n-\tthen echo ${gccdir}/xgcc -B${gccdir}/ ; \\\n-\telse echo gcc ; fi`}\n-CPP=${CPP-`echo ${CC} -E`}\n-CONFIG_NM=${CONFIG_NM-`if [ -f ${binutilsdir}/nm.new ] ; \\\n-\tthen echo ${binutilsdir}/nm.new ; \\\n-\telse echo nm ; fi`}\n-\n-cat <<!EOF!\n-/* AUTOMATICALLY GENERATED; DO NOT EDIT! */ \n-#ifndef ${macro_prefix}config_h\n-#define ${macro_prefix}config_h\n-!EOF!\n-\n-if [ x\"${LIB_VERSION}\" != \"x\" ] ; then\n-  echo \"#define ${macro_prefix}LIB_VERSION\" '\"'${LIB_VERSION}'\"'\n-fi\n-\n-# This program is used to test if the compiler prepends '_' before identifiers.\n-# It is also used to check the g++ uses '$' or '.' various places.\n-\n-if test -z \"${NAMES_HAVE_UNDERSCORE}\" \\\n-   || test -z \"${DOLLAR_IN_LABEL}\" \\\n-   || test -z \"${VTABLE_LABEL_PREFIX}\"; then\n-  cat >dummy.h <<!EOF!\n-#ifdef __GNUG__\n-#pragma interface\n-#endif\n-  struct filebuf {\n-      virtual int foo();\n-  };\n-!EOF!\n-  cat >dummy.C <<!EOF!\n-#ifdef __GNUG__\n-#pragma implementation\n-#endif\n-#include \"dummy.h\"\n-  int filebuf::foo() { return 0; }\n-  extern \"C\" int FUNC(int);\n-  int FUNC(int i) { return i+10; }\n-!EOF!\n-\n-  if ${CXX} -O -c dummy.C ; then\n-    if test -z \"${NAMES_HAVE_UNDERSCORE}\" ; then\n-      if test \"`${CONFIG_NM} dummy.o | grep _FUNC`\" != \"\"; then\n-        NAMES_HAVE_UNDERSCORE=1\n-      elif test \"`${CONFIG_NM} dummy.o | grep FUNC`\" != \"\"; then\n-        NAMES_HAVE_UNDERSCORE=0\n-      else\n-        echo \"${CONFIG_NM} failed to find FUNC in dummy.o!\" 1>&2; exit -1;\n-      fi\n-    fi\n-    echo \"#define ${macro_prefix}NAMES_HAVE_UNDERSCORE ${NAMES_HAVE_UNDERSCORE}\"\n-\n-    if test -z \"${VTABLE_LABEL_PREFIX}\" ; then\n-      # Determine how virtual function tables are named.  This is fragile,\n-      # because different nm's produce output in different formats.\n-      ${CONFIG_NM} dummy.o >TMP\n-      if [ -n \"`${SED} -n -e 's/ virtual table/nope/p' <TMP`\" ] ; then\n-\t${CONFIG_NM} --no-cplus dummy.o >TMP 2>/dev/null ||\n-\t  ${CONFIG_NM} --no-demangle dummy.o >TMP 2>/dev/null ||\n-\t  ${CONFIG_NM} dummy.o >TMP 2>/dev/null\n-      fi\n-      # First we look for a pattern that matches historical output from g++.\n-      # We surround the actual label name by <> to separate it from\n-      # other nm junk. \n-      ${SED} -n -e 's/_*vt[$_.]7*filebuf/<&>/p' <TMP >dummy.out\n-      # For paranoia's sake (e.g. if we're using some other C++ compiler)\n-      # we try a more general pattern, and append the result.\n-      grep -v foo <TMP \\\n-\t| ${SED} -n -e 's/[a-zA-Z0-9_.$]*filebuf[a-zA-Z0-9_.$]*/<&>/p' \\\n-\t>>dummy.out\n-      # Now we get rid of the <>, and any other junk on the nm output line.\n-      # (We get rid of <filebuf> in case nm included debugging output for\n-      # class filebuf itself.)  On windows32, we also need to delete the \n-      # unique sections (.data$_vt$*), otherwise we get the wrong result.\n-      # Finally, we select the first line of the result, and hope that's \n-      # what we wanted!\n-      vtab_name=`${SED} -n -e '/<filebuf>/d' \\\n-        -e '/\\.data[$_.]<_vt\\$7filebuf>/d' \\\n-        -e 's/^.*<\\(.*\\)>.*$/\\1/p' \\\n-        <dummy.out | ${SED} -n -e '1p'`\n-      case \"${vtab_name}\" in\n-        *7filebuf) echo \"#define ${macro_prefix}VTABLE_LABEL_HAS_LENGTH 1\" ;;\n-        *) echo \"#define ${macro_prefix}VTABLE_LABEL_HAS_LENGTH 0\" ;;\n-      esac\n-      VTABLE_LABEL_PREFIX=`echo $vtab_name | ${SED} -e 's/7*filebuf//'`\n-    fi\n-    echo \"#define ${macro_prefix}VTABLE_LABEL_PREFIX\" '\"'\"${VTABLE_LABEL_PREFIX}\"'\"'\n-    if [ \"${VTABLE_LABEL_PREFIX}\" = \"__vt_\" -o \\\n-        \"${VTABLE_LABEL_PREFIX}\" = \"___vt_\" ] ; then\n-      echo \"#define ${macro_prefix}USING_THUNKS\"\n-    fi\n-\n-    # VTABLE_LABEL_PREFIX_ID is the same as VTABLE_LABEL_PREFIX,\n-    # but the former is a C identifier, while the latter is a quoted\n-    # st\n-    if [ -z \"\"`echo ${VTABLE_LABEL_PREFIX} | ${SED} -e 's/[a-zA-Z0-9_]//g'` ] ; then\n-      if [ \"${NAMES_HAVE_UNDERSCORE}\" = \"1\" ] ; then\n-\tVTABLE_LABEL_PREFIX=`echo ${VTABLE_LABEL_PREFIX} | ${SED} -e 's/^_//'`\n-      fi\n-      echo \"#define ${macro_prefix}VTABLE_LABEL_PREFIX_ID ${VTABLE_LABEL_PREFIX}\"\n-    fi\n-\n-#    if test -n \"${DOLLAR_IN_LABEL}\" ; then\n-#      echo \"#define ${macro_prefix}DOLLAR_IN_LABEL ${DOLLAR_IN_LABEL}\"\n-#    elif test \"`${CONFIG_NM} dummy.o | grep 'vt[$$]7filebuf'`\" != \"\"; then\n-#      echo \"#define ${macro_prefix}DOLLAR_IN_LABEL 1\"\n-#    elif test \"`${CONFIG_NM} dummy.o | grep 'vt[.]7filebuf'`\" != \"\"; then\n-#      echo \"#define ${macro_prefix}DOLLAR_IN_LABEL 0\"\n-#    elif test \"`${CONFIG_NM} dummy.o | grep 'vtbl__7filebuf'`\" != \"\"; then\n-#      echo \"#define ${macro_prefix}DOLLAR_IN_LABEL 0\"\n-#    else\n-#      echo \"gen-params: ${CONFIG_NM} failed to find vt[.\\$]filebuf in dummy.o!\" 1>&2; exit 1\n-#    fi\n-  else\n-    # The compile failed for some reason (no C++?)\n-    echo \"gen-params: could not compile dummy.C with ${CXX}\" 1>&2; exit 1;\n-  fi\n-fi\n-\n-# A little test program to check if struct stat has st_blksize.\n-cat >dummy.c <<!EOF!\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-int BLKSIZE(struct stat *st)\n-{\n-    return st->st_blksize;\n-}\n-!EOF!\n-\n-if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-  echo \"#define ${macro_prefix}HAVE_ST_BLKSIZE 1\"\n-else\n-  echo \"#define ${macro_prefix}HAVE_ST_BLKSIZE 0\"\n-fi\n-\n-# A little test program to check if there is an O_APPEND.\n-cat >dummy.c <<!EOF!\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <fcntl.h>\n-int foo()\n-{\n-    return O_APPEND;\n-}\n-!EOF!\n-\n-if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-  :\n-else\n-  echo \"#define O_APPEND 0\"\n-fi\n-\n-# A little test program to check if there is an O_EXCL.\n-cat >dummy.c <<!EOF!\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <fcntl.h>\n-int foo()\n-{\n-    return O_EXCL;\n-}\n-!EOF!\n-\n-if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-  :\n-else\n-  echo \"#define O_EXCL 0\"\n-fi\n-\n-# A little test program to check if the name 'clog' is defined in libm,\n-# as it is under DEC UNIX.\n-cat >dummy.c <<!EOF!\n-int clog;\n-main () {}\n-!EOF!\n-\n-if ${CC} dummy.c -lm 2>&1 >/dev/null | grep clog >/dev/null; then\n-  echo \"#define ${macro_prefix}CLOG_CONFLICT 1\"\n-fi\n-\n-echo \"\"\n-\n-# Next, generate definitions for the standard types (such as mode_t)\n-# compatible with those in the standard C header files.\n-# It works by a dummy program through the C pre-processor, and then\n-# using sed to search for typedefs in the output.\n-\n-for hdr in wchar wctype; do\n-  eval $hdr=0\n-  cat >dummy.c <<EOF\n-#include <${hdr}.h>\n-EOF\n-  if ${CPP} dummy.c >/dev/null 2>&1 ; then eval $hdr=1; fi\n-done\n-\n-cat >dummy.c <<!EOF!\n-#include <sys/types.h>\n-#include <stddef.h>\n-#ifdef __STDC__\n-#include <stdarg.h>\n-#else /* !__STDC__ */\n-#include <varargs.h>\n-#endif /* __STDC__ */\n-#include <stdio.h>\n-#include <time.h>\n-#include <signal.h>\n-#ifdef __STDC__\n-#include <limits.h>\n-#endif\n-#if WCHAR == 1\n-#include <wchar.h>\n-#endif\n-#if WCTYPE == 1\n-#include <wctype.h>\n-#endif\n-#ifdef size_t\n-typedef size_t Xsize_t;\n-#elif defined(__SIZE_TYPE__)\n-typedef __SIZE_TYPE__ Xsize_t;\n-#endif\n-#ifdef ptrdiff_t\n-typedef ptrdiff_t Xptrdiff_t;\n-#elif defined(__PTRDIFF_TYPE__)\n-typedef __PTRDIFF_TYPE__ Xptrdiff_t;\n-#endif\n-#ifdef wchar_t\n-typedef wchar_t Xwchar_t;\n-#elif defined(__WCHAR_TYPE__)\n-typedef __WCHAR_TYPE__ Xwchar_t;\n-#endif\n-#ifdef va_list\n-typedef va_list XXXva_list;\n-#endif\n-#ifdef BUFSIZ\n-long XBUFSIZ=BUFSIZ;\n-#endif\n-#ifdef FOPEN_MAX\n-long XFOPEN_MAX=FOPEN_MAX;\n-#endif\n-#ifdef FILENAME_MAX\n-long XFILENAME_MAX=FILENAME_MAX;\n-#endif\n-#ifdef SHRT_MAX\n-long XSHRT_MAX=SHRT_MAX;\n-#endif\n-#ifdef INT_MAX\n-long XINT_MAX=INT_MAX;\n-#endif\n-#ifdef LONG_MAX\n-long XLONG_MAX=LONG_MAX;\n-#endif\n-#ifdef LONG_LONG_MAX\n-long XLONG_LONG_MAX=LONG_LONG_MAX;\n-#endif\n-!EOF!\n-\n-if ${CPP} dummy.c -DWCHAR=$wchar -DWCTYPE=$wctype >TMP ; then true\n-else\n-  echo \"gen-params: could not invoke ${CPP} on dummy.c\" 1>&2 ; exit 1\n-fi\n-tr '\t' ' ' <TMP >dummy.out\n-\n-for TYPE in dev_t clock_t fpos_t gid_t ino_t mode_t nlink_t off_t pid_t ptrdiff_t sigset_t size_t ssize_t time_t uid_t va_list wchar_t wint_t int16_t uint16_t int32_t uint_32_t u_int16_t u_int32_t; do\n-    eval IMPORTED=\\$$TYPE\n-    if [ -n \"${IMPORTED}\" ] ; then\n-\teval \"$TYPE='$IMPORTED'\"\n-    else\n-\tt=$TYPE\n-\tVALUE=''\n-\n-\t# Follow `typedef VALUE TYPE' chains, but don't loop indefinitely.\n-\tfor iteration in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20; do\n-\t    # Search dummy.out for a typedef for X*$t.\n-\t    sed_script=\"\n-\t\ts/unsigned long long int/_G_ullong/g\n-\t\ts/long long int /_G_llong /g\n-\t\ts/unsigned long long/_G_ullong/g\n-\t\ts/long long/_G_llong/g\n-\t\t/.*typedef  *\\\\(.*[^ ]\\\\)  *X*$t *;.*/{s||\\1|;p;q;}\n-\t\t/.*typedef  *\\\\(.*[^ a-zA-Z0-9_]\\\\)X*$t *;.*/{s||\\1|;p;q;}\n-\t    \"\n-\t    t=`${SED} -n \"$sed_script\" <dummy.out`\n-\t    case \"$t\" in\n-\t      '')\n-\t\tbreak;;\n-\t      *)\n-\t\t# Found a type $t; save it in VALUE.\n-\t\tVALUE=$t\n-\t\t# If it won't cause problems in matching,\n-\t\t# look for a typedef for it in turn.\n-\t\tcase \"$VALUE\" in\n-\t\t  *.* | */* | *\\ * | *\\** | *\\[* | *\\\\*) break;;\n-\t\tesac;;\n-\t    esac\n-\tdone\n-\n-\tcase \"$VALUE\" in\n-\t  ?*) eval \"$TYPE=\\\"$VALUE\\\"\"\n-\tesac\n-    fi\n-done\n-\n-# Look for some standard macros.\n-for NAME in BUFSIZ FOPEN_MAX FILENAME_MAX NULL; do\n-    eval IMPORTED=\\$$NAME\n-    if [ -n \"${IMPORTED}\" ] ; then\n-\teval \"$NAME='$IMPORTED /* specified */'\"\n-    else\n-\trm -f TMP\n-\t${SED} -n -e 's| *;|;|g' -e \"s|long X${NAME}= *\\(.*\\);|\\1|w TMP\" \\\n-\t  <dummy.out>/dev/null\n-\t# Now select the first definition.\n-\tif [ -s TMP ]; then\n-\t    eval \"$NAME='\"`${SED} -e '2,$d' <TMP`\"'\"\n-\tfi\n-    fi\n-done\n-\n-# These macros must be numerical constants; strip any trailing 'L's.\n-for NAME in SHRT_MAX INT_MAX LONG_MAX LONG_LONG_MAX; do\n-    eval IMPORTED=\\$$NAME\n-    if [ -n \"${IMPORTED}\" ] ; then\n-\teval \"$NAME='$IMPORTED /* specified */'\"\n-    else\n-\trm -f TMP\n-\t${SED} -n -e 's| *;|;|g' -e \"s|long X${NAME}= *\\([0-9]*\\)L* *;|\\1|w TMP\" \\\n-\t  <dummy.out>/dev/null\n-\t# Now select the first definition.\n-\tif [ -s TMP ]; then\n-\t    eval \"$NAME='\"`${SED} -e '2,$d' <TMP`\"'\"\n-\tfi\n-    fi\n-done\n-\n-# Figure out integral type sizes.\n-\n-default_int16='short /* deduction failed */'\n-default_int32='long /* deduction failed */'\n-INT16=32767\n-INT32=2147483647\n-\n-if [ \"${SHRT_MAX}\" = $INT16 ] ; then\n-  default_int16='short /* deduced */'\n-  if [ \"${LONG_MAX}\" = $INT32 ] ; then\n-    default_int32='long /* deduced */'\n-  elif [ \"${INT_MAX}\" = $INT32 ] ; then\n-    default_int32='int /* deduced */'\n-  fi\n-fi\n-\n-[ -n \"$u_int16_t\" ] && uint16_t=\"$u_int16_t\"\n-[ -n \"$u_int32_t\" ] && uint32_t=\"$u_int32_t\"\n-\n-[ -z  \"$int16_t\" ] &&  int16_t=\"$default_int16\"\n-[ -z \"$uint16_t\" ] && uint16_t=\"unsigned $int16_t\"\n-[ -z  \"$int32_t\" ] &&  int32_t=\"$default_int32\"\n-[ -z \"$uint32_t\" ] && uint32_t=\"unsigned $int32_t\"\n-\n-cat <<!EOF!\n-#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)\n-typedef          int   ${macro_prefix}int8_t __attribute__((__mode__(__QI__)));\n-typedef unsigned int  ${macro_prefix}uint8_t __attribute__((__mode__(__QI__)));\n-typedef          int  ${macro_prefix}int16_t __attribute__((__mode__(__HI__)));\n-typedef unsigned int ${macro_prefix}uint16_t __attribute__((__mode__(__HI__)));\n-typedef          int  ${macro_prefix}int32_t __attribute__((__mode__(__SI__)));\n-typedef unsigned int ${macro_prefix}uint32_t __attribute__((__mode__(__SI__)));\n-typedef          int  ${macro_prefix}int64_t __attribute__((__mode__(__DI__)));\n-typedef unsigned int ${macro_prefix}uint64_t __attribute__((__mode__(__DI__)));\n-#if __GNUC__ > 2 || __GNUC_MINOR__ >= 8\n-__extension__ typedef long long ${macro_prefix}llong;\n-__extension__ typedef unsigned long long ${macro_prefix}ullong;\n-#endif\n-#else\n-typedef  $int16_t  ${macro_prefix}int16_t;\n-typedef $uint16_t ${macro_prefix}uint16_t;\n-typedef  $int32_t  ${macro_prefix}int32_t;\n-typedef $uint32_t ${macro_prefix}uint32_t;\n-#endif\n-\n-typedef ${clock_t-int /* default */} ${macro_prefix}clock_t;\n-typedef ${dev_t-int /* default */} ${macro_prefix}dev_t;\n-typedef ${fpos_t-long /* default */} ${macro_prefix}fpos_t;\n-typedef ${gid_t-int /* default */} ${macro_prefix}gid_t;\n-typedef ${ino_t-int /* default */} ${macro_prefix}ino_t;\n-typedef ${mode_t-int /* default */} ${macro_prefix}mode_t;\n-typedef ${nlink_t-int /* default */} ${macro_prefix}nlink_t;\n-typedef ${off_t-long /* default */} ${macro_prefix}off_t;\n-typedef ${pid_t-int /* default */} ${macro_prefix}pid_t;\n-#ifndef __PTRDIFF_TYPE__\n-#define __PTRDIFF_TYPE__ ${ptrdiff_t-long int /* default */}\n-#endif\n-typedef __PTRDIFF_TYPE__ ${macro_prefix}ptrdiff_t;\n-typedef ${sigset_t-int /* default */} ${macro_prefix}sigset_t;\n-#ifndef __SIZE_TYPE__\n-#define __SIZE_TYPE__ ${size_t-unsigned long /* default */}\n-#endif\n-typedef __SIZE_TYPE__ ${macro_prefix}size_t;\n-typedef ${time_t-int /* default */} ${macro_prefix}time_t;\n-typedef ${uid_t-int /* default */} ${macro_prefix}uid_t;\n-typedef ${wchar_t-int /* default */} ${macro_prefix}wchar_t;\n-\n-#define ${macro_prefix}BUFSIZ ${BUFSIZ-1024 /* default */}\n-#define ${macro_prefix}FOPEN_MAX ${FOPEN_MAX-32 /* default */}\n-#define ${macro_prefix}FILENAME_MAX ${FILENAME_MAX-1024 /* default */}\n-#if defined (__cplusplus) || defined (__STDC__)\n-#define ${macro_prefix}ARGS(ARGLIST) ARGLIST\n-#else\n-#define ${macro_prefix}ARGS(ARGLIST) ()\n-#endif\n-#if !defined (__GNUG__) || defined (__STRICT_ANSI__)\n-#define ${macro_prefix}NO_NRV\n-#endif\n-#if !defined (__GNUG__)\n-#define _G_NO_EXTERN_TEMPLATES\n-#endif\n-!EOF!\n-\n-# ssize_t is the signed version of size_t\n-if [ -n \"${ssize_t}\" ] ; then\n-    echo \"typedef ${ssize_t} ${macro_prefix}ssize_t;\"\n-elif [ -z \"${size_t}\" ] ; then\n-    echo \"typedef long ${macro_prefix}ssize_t;\"\n-else\n-    # Remove \"unsigned\" from ${size_t} to get ${ssize_t}.\n-    tmp=\"`echo ${size_t} | ${SED} -e 's|unsigned||g' -e 's|  | |g'`\"\n-    if [ -z \"$tmp\" ] ; then\n-\ttmp=int\n-    else\n-\t# check $tmp doesn't conflict with <unistd.h>\n-\techo \"#include <unistd.h>\n-\textern $tmp read();\" >dummy.c\n-\t${CC} -c dummy.c >/dev/null 2>&1 || tmp=int\n-    fi\n-    echo \"typedef $tmp /* default */ ${macro_prefix}ssize_t;\"\n-fi\n-\n-# wint_t is often the integral type to which wchar_t promotes.\n-if [ -z \"${wint_t}\" ] ; then\n-  for TYPE in int 'unsigned int' 'long int' 'long unsigned int'; do\n-    cat >dummy.C <<!EOF!\n-#ifndef __WCHAR_TYPE__\n-#define __WCHAR_TYPE__ ${wchar_t-int /* default */}\n-#endif\n-typedef __WCHAR_TYPE__ ${macro_prefix}wchar_t;\n-void foo ($TYPE);\n-void foo (double);\n-void bar (${macro_prefix}wchar_t w)\n-{\n-  foo (w);\n-}\n-!EOF!\n-    if ${CXX} -c dummy.C >/dev/null 2>&1 ; then  \n-      wint_t=\"$TYPE /* default */\"\n-      break\n-    fi\n-  done\n-fi\n-echo \"typedef ${wint_t-int /* wchar_t is broken */} ${macro_prefix}wint_t;\"\n-\n-# va_list can cause problems (e.g. some systems have va_list as a struct).\n-# Check to see if ${va_list-char*} really is compatible with stdarg.h.\n-cat >dummy.C <<!EOF!\n-#define X_va_list ${va_list-char* /* default */}\n-extern long foo(X_va_list ap); /* Check that X_va_list compiles on its own */\n-extern \"C\" {\n-#include <stdarg.h>\n-}\n-long foo(X_va_list ap) { return va_arg(ap, long); }\n-long bar(int i, ...)\n-{ va_list ap; long j; va_start(ap, i); j = foo(ap); va_end(ap); return j; }\n-!EOF!\n-if ${CXX} -c dummy.C >/dev/null 2>&1 ; then\n-  # Ok: We have something that works.\n-  echo \"typedef ${va_list-char* /* default */} ${macro_prefix}va_list;\"\n-else\n-  echo \"#define ${macro_prefix}NEED_STDARG_H\"\n-  # Check and see if we have __gnuc_va_list, as we might set up define\n-  # loops if we use va_list.\n-  cat >dummy.C <<!EOF!\n-#include <stdarg.h>\n-long foo(__gnuc_va_list ap) { return va_arg(ap, long); }\n-!EOF!\n-  if ${CXX} -c dummy.C >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}va_list __gnuc_va_list\"\n-  else\n-    echo \"#define ${macro_prefix}va_list va_list\"\n-  fi\n-fi\n-\n-cat >dummy.c <<!EOF!\n-#include <signal.h>\n-extern int (*signal())();\n-extern int dummy (int);\n-main()\n-{\n-    int (*oldsig)(int) = signal (1, dummy);\n-    (void) signal (2, oldsig);\n-    return 0;\n-}\n-!EOF!\n-if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-  echo \"#define ${macro_prefix}signal_return_type int\"\n-else\n-  echo \"#define ${macro_prefix}signal_return_type void\"\n-fi\n-\n-# check sprintf return type\n-\n-cat >dummy.c <<!EOF!\n-#include <stdio.h>\n-extern int sprintf(); char buf[100];\n-int main() { return sprintf(buf, \"%d\", 34); }\n-!EOF!\n-if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-  echo \"#define ${macro_prefix}sprintf_return_type int\"\n-else\n-  echo \"#define ${macro_prefix}sprintf_return_type char*\"\n-fi\n-\n-if test -n \"${HAVE_ATEXIT}\" ; then\n- echo \"#define ${macro_prefix}HAVE_ATEXIT ${HAVE_ATEXIT}\"\n-else\n-  cat >dummy.c <<!EOF!\n-#include <stdlib.h>\n-int main()\n-{\n-  atexit (0);\n-}\n-!EOF!\n-  if ${CC} dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_ATEXIT 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_ATEXIT 0\"\n-  fi\n-fi\n-\n-\n-# *** Check for presence of certain include files ***\n-\n-# check for sys/resource.h\n-\n-if test -n \"${HAVE_SYS_RESOURCE}\" ; then\n- echo \"#define ${macro_prefix}HAVE_SYS_RESOURCE ${HAVE_SYS_RESOURCE}\"\n-else\n-  cat >dummy.c <<!EOF!\n-#include <sys/types.h>\n-#include <sys/time.h>\n-#include <sys/resource.h>\n-  int main()\n-  {\n-    struct rusage res;\n-    getrusage(RUSAGE_SELF, &res);\n-    return (int)(res.ru_utime.tv_sec + (res.ru_utime.tv_usec / 1000000.0));\n-  }\n-!EOF!\n-  # Note: We link because some systems have sys/resource, but not getrusage().\n-  if ${CC} dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_SYS_RESOURCE 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_SYS_RESOURCE 0\"\n-  fi\n-fi\n-\n-# check for struct tms in sys/times.h\n-\n-if test -n \"${HAVE_SYS_TIMES}\" ; then\n- echo \"#define ${macro_prefix}HAVE_SYS_TIMES ${HAVE_SYS_TIMES}\"\n-else\n- cat >dummy.c <<!EOF!\n-#include <sys/types.h>\n-#include <sys/times.h>\n-  int main()\n-  {\n-    struct tms s;\n-    return s.tms_utime;\n-  }\n-!EOF!\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_SYS_TIMES 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_SYS_TIMES 0\"\n-  fi\n-fi\n-\n-# check for sys/socket.h\n-\n-if test -n \"${HAVE_SYS_SOCKET}\" ; then\n- echo \"#define ${macro_prefix}HAVE_SYS_SOCKET ${HAVE_SYS_SOCKET}\"\n-else\n-  echo '#include <sys/types.h>' >dummy.c\n-  echo '#include <sys/socket.h>' >>dummy.c\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_SYS_SOCKET 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_SYS_SOCKET 0\"\n-  fi\n-fi\n-\n-# check for sys/cdefs.h\n-\n-if test -n \"${HAVE_SYS_CDEFS}\" ; then\n- echo \"#define ${macro_prefix}HAVE_SYS_CDEFS ${HAVE_SYS_CDEFS}\"\n-else\n-  echo '#include <sys/cdefs.h>' >dummy.c\n-  echo 'extern int myfunc __P((int, int));' >>dummy.c\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_SYS_CDEFS 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_SYS_CDEFS 0\"\n-  fi\n-fi\n-\n-# Check for a (Posix-compatible) sys/wait.h */\n-\n-if test -n \"${HAVE_SYS_WAIT}\" ; then\n- echo \"#define ${macro_prefix}HAVE_SYS_WAIT ${HAVE_SYS_WAIT}\"\n-else\n-  cat >dummy.c <<!EOF!\n-#include <sys/types.h>\n-#include <sys/wait.h>\n-  int f() { int i; wait(&i); return i; }\n-!EOF!\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_SYS_WAIT 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_SYS_WAIT 0\"\n-  fi\n-fi\n-\n-if test -n \"${HAVE_UNISTD}\" ; then\n- echo \"#define ${macro_prefix}HAVE_UNISTD ${HAVE_UNISTD}\"\n-else\n-  echo '#include <unistd.h>' >dummy.c\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_UNISTD 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_UNISTD 0\"\n-  fi\n-fi\n-\n-if test -n \"${HAVE_DIRENT}\" ; then\n- echo \"#define ${macro_prefix}HAVE_DIRENT ${HAVE_DIRENT}\"\n-else\n-  echo '#include <sys/types.h>\n-#include <dirent.h>' >dummy.c\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_DIRENT 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_DIRENT 0\"\n-  fi\n-fi\n-\n-if test -n \"${HAVE_CURSES}\" ; then\n- echo \"#define ${macro_prefix}HAVE_CURSES ${HAVE_CURSES}\"\n-else\n-  echo '#include <curses.h>' >dummy.c\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_CURSES 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_CURSES 0\"\n-  fi\n-fi\n-\n-# There is no test for this at the moment; it is just set by the\n-# configuration files.\n-if test -n \"${MATH_H_INLINES}\" ; then\n-  echo \"#define ${macro_prefix}MATH_H_INLINES ${MATH_H_INLINES}\"\n-else\n-  echo \"#define ${macro_prefix}MATH_H_INLINES 0\"\n-fi\n-\n-if test -n \"${HAVE_BOOL}\" ; then\n- echo \"#define ${macro_prefix}HAVE_BOOL ${HAVE_BOOL}\"\n-else\n-  echo 'bool i=true,j=false;' >dummy.C\n-  if ${CXX} -c dummy.C >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_BOOL 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_BOOL 0\"\n-  fi\n-fi\n-\n-if test -n \"${NO_USE_DTOA}\" ; then\n-    echo \"#define ${macro_prefix}NO_USE_DTOA 1\"\n-fi\n-if test -n \"${USE_INT32_FLAGS}\" ; then\n-    echo \"#define ${macro_prefix}USE_INT32_FLAGS 1\"\n-fi\n-\n-if test -n \"$HAVE_PRINTF_FP\"; then\n-  echo \"#define ${macro_prefix}HAVE_PRINTF_FP $HAVE_PRINTF_FP\"\n-  echo \"#define ${macro_prefix}HAVE_LONG_DOUBLE_IO $HAVE_LONG_DOUBLE_IO\"\n-else\n-  # A little test program to check if __printf_fp is available.\n-  cat >dummy.c <<EOF\n-int main()\n-{\n-    return __printf_fp ();\n-}\n-EOF\n-\n-  if ${CC} dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_PRINTF_FP 1\"\n-    echo \"#define ${macro_prefix}HAVE_LONG_DOUBLE_IO 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_PRINTF_FP 0\"\n-    echo \"#define ${macro_prefix}HAVE_LONG_DOUBLE_IO 0\"\n-  fi\n-fi\n-\n-# Uncomment the following line if you don't have working templates.\n-# echo \"#define ${macro_prefix}NO_TEMPLATES\"\n-\n-# Override bogus definitions of NULL in system headers.\n-cat <<EOF\n-#undef NULL\n-#define __need_NULL\n-#include <stddef.h>\n-EOF\n-\n-rm -f dummy.C dummy.o dummy.c dummy.out TMP core a.out\n-\n-echo \"#endif /* !${macro_prefix}config_h */\""}, {"sha": "b899e150afabf483e32ebd24b8dc4d033e62fcde", "filename": "libio/genops.c", "status": "removed", "additions": 0, "deletions": 946, "changes": 946, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fgenops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fgenops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fgenops.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,946 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1997, 1998 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-/* Generic or default I/O operations. */\n-\n-#include \"libioP.h\"\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#endif\n-#include <string.h>\n-\n-void\n-_IO_un_link (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp->_flags & _IO_LINKED)\n-    {\n-      _IO_FILE **f;\n-      for (f = &_IO_list_all; *f != NULL; f = &(*f)->_chain)\n-\t{\n-\t  if (*f == fp)\n-\t    {\n-\t      *f = fp->_chain;\n-\t      break;\n-\t    }\n-\t}\n-      fp->_flags &= ~_IO_LINKED;\n-    }\n-}\n-\n-void\n-_IO_link_in (fp)\n-     _IO_FILE *fp;\n-{\n-    if ((fp->_flags & _IO_LINKED) == 0)\n-      {\n-\tfp->_flags |= _IO_LINKED;\n-\tfp->_chain = _IO_list_all;\n-\t_IO_list_all = fp;\n-      }\n-}\n-\n-/* Return minimum _pos markers\n-   Assumes the current get area is the main get area. */\n-static _IO_size_t _IO_least_marker __P ((_IO_FILE *fp));\n-\n-static _IO_size_t\n-_IO_least_marker (fp)\n-     _IO_FILE *fp;\n-{\n-  _IO_ssize_t least_so_far = fp->_IO_read_end - fp->_IO_read_base;\n-  struct _IO_marker *mark;\n-  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n-    if (mark->_pos < least_so_far)\n-      least_so_far = mark->_pos;\n-  return least_so_far;\n-}\n-\n-/* Switch current get area from backup buffer to (start of) main get area. */\n-\n-void\n-_IO_switch_to_main_get_area (fp)\n-     _IO_FILE *fp;\n-{\n-  char *tmp;\n-  fp->_flags &= ~_IO_IN_BACKUP;\n-  /* Swap _IO_read_end and _IO_save_end. */\n-  tmp = fp->_IO_read_end;\n-  fp->_IO_read_end = fp->_IO_save_end;\n-  fp->_IO_save_end= tmp;\n-  /* Swap _IO_read_base and _IO_save_base. */\n-  tmp = fp->_IO_read_base;\n-  fp->_IO_read_base = fp->_IO_save_base;\n-  fp->_IO_save_base = tmp;\n-\n-  fp->_IO_read_ptr = fp->_IO_read_base;\n-}\n-\n-/* Switch current get area from main get area to (end of) backup area. */\n-\n-void\n-_IO_switch_to_backup_area (fp)\n-     _IO_FILE *fp;\n-{\n-  char *tmp;\n-  fp->_flags |= _IO_IN_BACKUP;\n-  /* Swap _IO_read_end and _IO_save_end. */\n-  tmp = fp->_IO_read_end;\n-  fp->_IO_read_end = fp->_IO_save_end;\n-  fp->_IO_save_end = tmp;\n-  /* Swap _gbase and _IO_save_base. */\n-  tmp = fp->_IO_read_base;\n-  fp->_IO_read_base = fp->_IO_save_base;\n-  fp->_IO_save_base = tmp;\n-\n-  fp->_IO_read_ptr = fp->_IO_read_end;\n-}\n-\n-int\n-_IO_switch_to_get_mode (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp->_IO_write_ptr > fp->_IO_write_base)\n-    if (_IO_OVERFLOW (fp, EOF) == EOF)\n-      return EOF;\n-  if (_IO_in_backup (fp))\n-    fp->_IO_read_base = fp->_IO_backup_base;\n-  else\n-    {\n-      fp->_IO_read_base = fp->_IO_buf_base;\n-      if (fp->_IO_write_ptr > fp->_IO_read_end)\n-\tfp->_IO_read_end = fp->_IO_write_ptr;\n-    }\n-  fp->_IO_read_ptr = fp->_IO_write_ptr;\n-\n-  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end = fp->_IO_read_ptr;\n-\n-  fp->_flags &= ~_IO_CURRENTLY_PUTTING;\n-  return 0;\n-}\n-\n-void\n-_IO_free_backup_area (fp)\n-     _IO_FILE *fp;\n-{\n-  if (_IO_in_backup (fp))\n-    _IO_switch_to_main_get_area (fp);  /* Just in case. */\n-  free (fp->_IO_save_base);\n-  fp->_IO_save_base = NULL;\n-  fp->_IO_save_end = NULL;\n-  fp->_IO_backup_base = NULL;\n-}\n-\n-#if 0\n-int\n-_IO_switch_to_put_mode (fp)\n-     _IO_FILE *fp;\n-{\n-  fp->_IO_write_base = fp->_IO_read_ptr;\n-  fp->_IO_write_ptr = fp->_IO_read_ptr;\n-  /* Following is wrong if line- or un-buffered? */\n-  fp->_IO_write_end = (fp->_flags & _IO_IN_BACKUP\n-\t\t       ? fp->_IO_read_end : fp->_IO_buf_end);\n-\n-  fp->_IO_read_ptr = fp->_IO_read_end;\n-  fp->_IO_read_base = fp->_IO_read_end;\n-\n-  fp->_flags |= _IO_CURRENTLY_PUTTING;\n-  return 0;\n-}\n-#endif\n-\n-int\n-__overflow (f, ch)\n-     _IO_FILE *f;\n-     int ch;\n-{\n-  return _IO_OVERFLOW (f, ch);\n-}\n-\n-static int save_for_backup __P ((_IO_FILE *fp));\n-\n-     static int\n-save_for_backup (fp)\n-     _IO_FILE *fp;\n-{\n-  /* Append [_IO_read_base.._IO_read_end] to backup area. */\n-  int least_mark = _IO_least_marker (fp);\n-  /* needed_size is how much space we need in the backup area. */\n-  int needed_size = (fp->_IO_read_end - fp->_IO_read_base) - least_mark;\n-  int current_Bsize = fp->_IO_save_end - fp->_IO_save_base;\n-  int avail; /* Extra space available for future expansion. */\n-  int delta;\n-  struct _IO_marker *mark;\n-  if (needed_size > current_Bsize)\n-    {\n-      char *new_buffer;\n-      avail = 100;\n-      new_buffer = (char *) malloc (avail + needed_size);\n-      if (new_buffer == NULL)\n-\treturn EOF;\t\t/* FIXME */\n-      if (least_mark < 0)\n-\t{\n-\t  memcpy (new_buffer + avail,\n-\t\t  fp->_IO_save_end + least_mark,\n-\t\t  -least_mark);\n-\t  memcpy (new_buffer + avail - least_mark,\n-\t\t  fp->_IO_read_base,\n-\t\t  fp->_IO_read_end - fp->_IO_read_base);\n-\t}\n-      else\n-\tmemcpy (new_buffer + avail,\n-\t\tfp->_IO_read_base + least_mark,\n-\t\tneeded_size);\n-      if (fp->_IO_save_base)\n-\tfree (fp->_IO_save_base);\n-      fp->_IO_save_base = new_buffer;\n-      fp->_IO_save_end = new_buffer + avail + needed_size;\n-    }\n-  else\n-    {\n-      avail = current_Bsize - needed_size;\n-      if (least_mark < 0)\n-\t{\n-\t  memmove (fp->_IO_save_base + avail,\n-\t\t   fp->_IO_save_end + least_mark,\n-\t\t   -least_mark);\n-\t  memcpy (fp->_IO_save_base + avail - least_mark,\n-\t\t  fp->_IO_read_base,\n-\t\t  fp->_IO_read_end - fp->_IO_read_base);\n-\t}\n-      else if (needed_size > 0)\n-\tmemcpy (fp->_IO_save_base + avail,\n-\t\tfp->_IO_read_base + least_mark,\n-\t\tneeded_size);\n-    }\n-  /* FIXME: Dubious arithmetic if pointers are NULL */\n-  fp->_IO_backup_base = fp->_IO_save_base + avail;\n-  /* Adjust all the streammarkers. */\n-  delta = fp->_IO_read_end - fp->_IO_read_base;\n-  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n-    mark->_pos -= delta;\n-  return 0;\n-}\n-\n-int\n-__underflow (fp)\n-     _IO_FILE *fp;\n-{\n-  if (_IO_in_put_mode (fp))\n-    if (_IO_switch_to_get_mode (fp) == EOF)\n-      return EOF;\n-  if (fp->_IO_read_ptr < fp->_IO_read_end)\n-    return *(unsigned char *) fp->_IO_read_ptr;\n-  if (_IO_in_backup (fp))\n-    {\n-      _IO_switch_to_main_get_area (fp);\n-      if (fp->_IO_read_ptr < fp->_IO_read_end)\n-\treturn *(unsigned char *) fp->_IO_read_ptr;\n-    }\n-  if (_IO_have_markers (fp))\n-    {\n-      if (save_for_backup (fp))\n-\treturn EOF;\n-    }\n-  else if (_IO_have_backup (fp))\n-    _IO_free_backup_area (fp);\n-  return _IO_UNDERFLOW (fp);\n-}\n-\n-int\n-__uflow (fp)\n-     _IO_FILE *fp;\n-{\n-  if (_IO_in_put_mode (fp))\n-    if (_IO_switch_to_get_mode (fp) == EOF)\n-      return EOF;\n-  if (fp->_IO_read_ptr < fp->_IO_read_end)\n-    return *(unsigned char *) fp->_IO_read_ptr++;\n-  if (_IO_in_backup (fp))\n-    {\n-      _IO_switch_to_main_get_area (fp);\n-      if (fp->_IO_read_ptr < fp->_IO_read_end)\n-\treturn *(unsigned char *) fp->_IO_read_ptr++;\n-    }\n-  if (_IO_have_markers (fp))\n-    {\n-      if (save_for_backup (fp))\n-\treturn EOF;\n-    }\n-  else if (_IO_have_backup (fp))\n-    _IO_free_backup_area (fp);\n-  return _IO_UFLOW (fp);\n-}\n-\n-void\n-_IO_setb (f, b, eb, a)\n-     _IO_FILE *f;\n-      char *b;\n-     char *eb;\n-     int a;\n-{\n-  if (f->_IO_buf_base && !(f->_flags & _IO_USER_BUF))\n-    FREE_BUF (f->_IO_buf_base, _IO_blen (f));\n-  f->_IO_buf_base = b;\n-  f->_IO_buf_end = eb;\n-  if (a)\n-    f->_flags &= ~_IO_USER_BUF;\n-  else\n-    f->_flags |= _IO_USER_BUF;\n-}\n-\n-void\n-_IO_doallocbuf (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp->_IO_buf_base)\n-    return;\n-  if (!(fp->_flags & _IO_UNBUFFERED))\n-    if (_IO_DOALLOCATE (fp) != EOF)\n-      return;\n-  _IO_setb (fp, fp->_shortbuf, fp->_shortbuf+1, 0);\n-}\n-\n-int\n-_IO_default_underflow (fp)\n-     _IO_FILE *fp;\n-{\n-  return EOF;\n-}\n-\n-int\n-_IO_default_uflow (fp)\n-     _IO_FILE *fp;\n-{\n-  int ch = _IO_UNDERFLOW (fp);\n-  if (ch == EOF)\n-    return EOF;\n-  return *(unsigned char *) fp->_IO_read_ptr++;\n-}\n-\n-_IO_size_t\n-_IO_default_xsputn (f, data, n)\n-     _IO_FILE *f;\n-     const void *data;\n-     _IO_size_t n;\n-{\n-  const char *s = (char *) data;\n-  _IO_size_t more = n;\n-  if (more <= 0)\n-    return 0;\n-  for (;;)\n-    {\n-      /* Space available. */\n-      _IO_ssize_t count = f->_IO_write_end - f->_IO_write_ptr;\n-      if (count > 0)\n-\t{\n-\t  if ((_IO_size_t) count > more)\n-\t    count = more;\n-\t  if (count > 20)\n-\t    {\n-\t      memcpy (f->_IO_write_ptr, s, count);\n-\t      s += count;\n-\t      f->_IO_write_ptr += count;\n-            }\n-\t  else if (count <= 0)\n-\t    count = 0;\n-\t  else\n-\t    {\n-\t      char *p = f->_IO_write_ptr;\n-\t      _IO_ssize_t i;\n-\t      for (i = count; --i >= 0; )\n-\t\t*p++ = *s++;\n-\t      f->_IO_write_ptr = p;\n-            }\n-\t  more -= count;\n-        }\n-      if (more == 0 || __overflow (f, (unsigned char) *s++) == EOF)\n-\tbreak;\n-      more--;\n-    }\n-  return n - more;\n-}\n-\n-_IO_size_t\n-_IO_sgetn (fp, data, n)\n-     _IO_FILE *fp;\n-     void *data;\n-     _IO_size_t n;\n-{\n-  /* FIXME handle putback buffer here! */\n-  return _IO_XSGETN (fp, data, n);\n-}\n-\n-_IO_size_t\n-_IO_default_xsgetn (fp, data, n)\n-     _IO_FILE *fp;\n-     void *data;\n-     _IO_size_t n;\n-{\n-  _IO_size_t more = n;\n-  char *s = (char*) data;\n-  for (;;)\n-    {\n-      /* Data available. */\n-      _IO_ssize_t count = fp->_IO_read_end - fp->_IO_read_ptr;\n-      if (count > 0)\n-\t{\n-\t  if ((_IO_size_t) count > more)\n-\t    count = more;\n-\t  if (count > 20)\n-\t    {\n-\t      memcpy (s, fp->_IO_read_ptr, count);\n-\t      s += count;\n-\t      fp->_IO_read_ptr += count;\n-\t    }\n-\t  else if (count <= 0)\n-\t    count = 0;\n-\t  else\n-\t    {\n-\t      char *p = fp->_IO_read_ptr;\n-\t      int i = (int) count;\n-\t      while (--i >= 0)\n-\t\t*s++ = *p++;\n-\t      fp->_IO_read_ptr = p;\n-            }\n-            more -= count;\n-        }\n-      if (more == 0 || __underflow (fp) == EOF)\n-\tbreak;\n-    }\n-  return n - more;\n-}\n-\n-#if 0\n-/* Seems not to be needed. --drepper */\n-int\n-_IO_sync (fp)\n-     _IO_FILE *fp;\n-{\n-  return 0;\n-}\n-#endif\n-\n-_IO_FILE *\n-_IO_default_setbuf (fp, p, len)\n-     _IO_FILE *fp;\n-     char *p;\n-     _IO_ssize_t len;\n-{\n-    if (_IO_SYNC (fp) == EOF)\n-\treturn NULL;\n-    if (p == NULL || len == 0)\n-      {\n-\tfp->_flags |= _IO_UNBUFFERED;\n-\t_IO_setb (fp, fp->_shortbuf, fp->_shortbuf+1, 0);\n-      }\n-    else\n-      {\n-\tfp->_flags &= ~_IO_UNBUFFERED;\n-\t_IO_setb (fp, p, p+len, 0);\n-      }\n-    fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end = 0;\n-    fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_read_end = 0;\n-    return fp;\n-}\n-\n-_IO_pos_t\n-_IO_default_seekpos (fp, pos, mode)\n-     _IO_FILE *fp;\n-     _IO_pos_t pos;\n-     int mode;\n-{\n-  return _IO_SEEKOFF (fp, _IO_pos_as_off (pos), 0, mode);\n-}\n-\n-int\n-_IO_default_doallocate (fp)\n-     _IO_FILE *fp;\n-{\n-  char *buf;\n-\n-  ALLOC_BUF (buf, _IO_BUFSIZ, EOF);\n-  _IO_setb (fp, buf, buf+_IO_BUFSIZ, 1);\n-  return 1;\n-}\n-\n-void\n-_IO_init (fp, flags)\n-     _IO_FILE *fp;\n-     int flags;\n-{\n-  fp->_flags = _IO_MAGIC|flags;\n-  fp->_IO_buf_base = NULL;\n-  fp->_IO_buf_end = NULL;\n-  fp->_IO_read_base = NULL;\n-  fp->_IO_read_ptr = NULL;\n-  fp->_IO_read_end = NULL;\n-  fp->_IO_write_base = NULL;\n-  fp->_IO_write_ptr = NULL;\n-  fp->_IO_write_end = NULL;\n-  fp->_chain = NULL; /* Not necessary. */\n-\n-  fp->_IO_save_base = NULL;\n-  fp->_IO_backup_base = NULL;\n-  fp->_IO_save_end = NULL;\n-  fp->_markers = NULL;\n-  fp->_cur_column = 0;\n-#ifdef _IO_MTSAFE_IO\n-  _IO_lock_init (*fp->_lock);\n-#endif\n-}\n-\n-int\n-_IO_default_sync (fp)\n-     _IO_FILE *fp;\n-{\n-  return 0;\n-}\n-\n-/* The way the C++ classes are mapped into the C functions in the\n-   current implementation, this function can get called twice! */\n-\n-void\n-_IO_default_finish (fp, dummy)\n-     _IO_FILE *fp;\n-     int dummy;\n-{\n-  struct _IO_marker *mark;\n-  if (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))\n-    {\n-      FREE_BUF (fp->_IO_buf_base, _IO_blen (fp));\n-      fp->_IO_buf_base = fp->_IO_buf_end = NULL;\n-    }\n-\n-  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n-    mark->_sbuf = NULL;\n-\n-  if (fp->_IO_save_base)\n-    {\n-      free (fp->_IO_save_base);\n-      fp->_IO_save_base = NULL;\n-    }\n-\n-#ifdef _IO_MTSAFE_IO\n-  _IO_lock_fini (*fp->_lock);\n-#endif\n-\n-  _IO_un_link (fp);\n-}\n-\n-_IO_pos_t\n-_IO_default_seekoff (fp, offset, dir, mode)\n-     _IO_FILE *fp;\n-     _IO_off_t offset;\n-     int dir;\n-     int mode;\n-{\n-    return _IO_pos_BAD;\n-}\n-\n-int\n-_IO_sputbackc (fp, c)\n-     _IO_FILE *fp;\n-     int c;\n-{\n-  int result;\n-\n-  if (fp->_IO_read_ptr > fp->_IO_read_base\n-      && (unsigned char)fp->_IO_read_ptr[-1] == (unsigned char)c)\n-    {\n-      fp->_IO_read_ptr--;\n-      result = (unsigned char) c;\n-    }\n-  else\n-    result = _IO_PBACKFAIL (fp, c);\n-\n-  if (result != EOF)\n-    fp->_flags &= ~_IO_EOF_SEEN;\n-\n-  return result;\n-}\n-\n-int\n-_IO_sungetc (fp)\n-     _IO_FILE *fp;\n-{\n-  int result;\n-\n-  if (fp->_IO_read_ptr > fp->_IO_read_base)\n-    {\n-      fp->_IO_read_ptr--;\n-      result = (unsigned char) *fp->_IO_read_ptr;\n-    }\n-  else\n-    result = _IO_PBACKFAIL (fp, EOF);\n-\n-  if (result != EOF)\n-    fp->_flags &= ~_IO_EOF_SEEN;\n-\n-  return result;\n-}\n-\n-#if 0 /* Work in progress */\n-/* Seems not to be needed.  */\n-#if 0\n-void\n-_IO_set_column (fp, c)\n-     _IO_FILE *fp;\n-     int c;\n-{\n-  if (c == -1)\n-    fp->_column = -1;\n-  else\n-    fp->_column = c - (fp->_IO_write_ptr - fp->_IO_write_base);\n-}\n-#else\n-int\n-_IO_set_column (fp, i)\n-     _IO_FILE *fp;\n-     int i;\n-{\n-  fp->_cur_column = i + 1;\n-  return 0;\n-}\n-#endif\n-#endif\n-\n-\n-unsigned\n-_IO_adjust_column (start, line, count)\n-     unsigned start;\n-     const char *line;\n-     int count;\n-{\n-  const char *ptr = line + count;\n-  while (ptr > line)\n-    if (*--ptr == '\\n')\n-      return line + count - ptr - 1;\n-  return start + count;\n-}\n-\n-#if 0\n-/* Seems not to be needed. --drepper */\n-int\n-_IO_get_column (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp->_cur_column)\n-    return _IO_adjust_column (fp->_cur_column - 1,\n-\t\t\t      fp->_IO_write_base,\n-\t\t\t      fp->_IO_write_ptr - fp->_IO_write_base);\n-  return -1;\n-}\n-#endif\n-\n-int\n-_IO_flush_all ()\n-{\n-  int result = 0;\n-  _IO_FILE *fp;\n-  for (fp = _IO_list_all; fp != NULL; fp = fp->_chain)\n-    if (fp->_IO_write_ptr > fp->_IO_write_base\n-\t&& _IO_OVERFLOW (fp, EOF) == EOF)\n-      result = EOF;\n-  return result;\n-}\n-\n-void\n-_IO_flush_all_linebuffered ()\n-{\n-  _IO_FILE *fp;\n-  for (fp = _IO_list_all; fp != NULL; fp = fp->_chain)\n-    if ((fp->_flags & _IO_NO_WRITES) == 0 && fp->_flags & _IO_LINE_BUF)\n-      _IO_OVERFLOW (fp, EOF);\n-}\n-\n-static void _IO_unbuffer_all __P ((void));\n-\n-static void\n-_IO_unbuffer_all ()\n-{\n-  _IO_FILE *fp;\n-  for (fp = _IO_list_all; fp != NULL; fp = fp->_chain)\n-    if (! (fp->_flags & _IO_UNBUFFERED))\n-      _IO_SETBUF (fp, NULL, 0);\n-}\n-\n-void\n-_IO_cleanup ()\n-{\n-  _IO_flush_all ();\n-\n-  /* We currently don't have a reliable mechanism for making sure that\n-     C++ static destructors are executed in the correct order.\n-     So it is possible that other static destructors might want to\n-     write to cout - and they're supposed to be able to do so.\n-\n-     The following will make the standard streambufs be unbuffered,\n-     which forces any output from late destructors to be written out. */\n-  _IO_unbuffer_all ();\n-}\n-\n-void\n-_IO_init_marker (marker, fp)\n-     struct _IO_marker *marker;\n-     _IO_FILE *fp;\n-{\n-  marker->_sbuf = fp;\n-  if (_IO_in_put_mode (fp))\n-    _IO_switch_to_get_mode (fp);\n-  if (_IO_in_backup (fp))\n-    marker->_pos = fp->_IO_read_ptr - fp->_IO_read_end;\n-  else\n-    marker->_pos = fp->_IO_read_ptr - fp->_IO_read_base;\n-\n-  /* Should perhaps sort the chain? */\n-  marker->_next = fp->_markers;\n-  fp->_markers = marker;\n-}\n-\n-void\n-_IO_remove_marker (marker)\n-     struct _IO_marker *marker;\n-{\n-  /* Unlink from sb's chain. */\n-  struct _IO_marker **ptr = &marker->_sbuf->_markers;\n-  for (; ; ptr = &(*ptr)->_next)\n-    {\n-      if (*ptr == NULL)\n-\tbreak;\n-      else if (*ptr == marker)\n-\t{\n-\t  *ptr = marker->_next;\n-\t  return;\n-\t}\n-    }\n-#if 0\n-    if _sbuf has a backup area that is no longer needed, should we delete\n-    it now, or wait until the next underflow?\n-#endif\n-}\n-\n-#define BAD_DELTA EOF\n-\n-int\n-_IO_marker_difference (mark1, mark2)\n-     struct _IO_marker *mark1;\n-     struct _IO_marker *mark2;\n-{\n-  return mark1->_pos - mark2->_pos;\n-}\n-\n-/* Return difference between MARK and current position of MARK's stream. */\n-int\n-_IO_marker_delta (mark)\n-     struct _IO_marker *mark;\n-{\n-  int cur_pos;\n-  if (mark->_sbuf == NULL)\n-    return BAD_DELTA;\n-  if (_IO_in_backup (mark->_sbuf))\n-    cur_pos = mark->_sbuf->_IO_read_ptr - mark->_sbuf->_IO_read_end;\n-  else\n-    cur_pos = mark->_sbuf->_IO_read_ptr - mark->_sbuf->_IO_read_base;\n-  return mark->_pos - cur_pos;\n-}\n-\n-int\n-_IO_seekmark (fp, mark, delta)\n-     _IO_FILE *fp;\n-     struct _IO_marker *mark;\n-     int delta;\n-{\n-  if (mark->_sbuf != fp)\n-    return EOF;\n- if (mark->_pos >= 0)\n-    {\n-      if (_IO_in_backup (fp))\n-\t_IO_switch_to_main_get_area (fp);\n-      fp->_IO_read_ptr = fp->_IO_read_base + mark->_pos;\n-    }\n-  else\n-    {\n-      if (!_IO_in_backup (fp))\n-\t_IO_switch_to_backup_area (fp);\n-      fp->_IO_read_ptr = fp->_IO_read_end + mark->_pos;\n-    }\n-  return 0;\n-}\n-\n-void\n-_IO_unsave_markers (fp)\n-     _IO_FILE *fp;\n-{\n-  struct _IO_marker *mark = fp->_markers;\n-  if (mark)\n-    {\n-#ifdef TODO\n-      streampos offset = seekoff (0, ios::cur, ios::in);\n-      if (offset != EOF)\n-\t{\n-\t  offset += eGptr () - Gbase ();\n-\t  for ( ; mark != NULL; mark = mark->_next)\n-\t    mark->set_streampos (mark->_pos + offset);\n-\t}\n-    else\n-      {\n-\tfor ( ; mark != NULL; mark = mark->_next)\n-\t  mark->set_streampos (EOF);\n-      }\n-#endif\n-      fp->_markers = 0;\n-    }\n-\n-  if (_IO_have_backup (fp))\n-    _IO_free_backup_area (fp);\n-}\n-\n-#if 0\n-/* Seems not to be needed. --drepper */\n-int\n-_IO_nobackup_pbackfail (fp, c)\n-     _IO_FILE *fp;\n-     int c;\n-{\n-  if (fp->_IO_read_ptr > fp->_IO_read_base)\n-\tfp->_IO_read_ptr--;\n-  if (c != EOF && *fp->_IO_read_ptr != c)\n-      *fp->_IO_read_ptr = c;\n-  return (unsigned char) c;\n-}\n-#endif\n-\n-int\n-_IO_default_pbackfail (fp, c)\n-     _IO_FILE *fp;\n-     int c;\n-{\n-  if (fp->_IO_read_ptr <= fp->_IO_read_base)\n-    {\n-      /* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/\n-      if (_IO_have_backup (fp) && !_IO_in_backup (fp))\n-\t_IO_switch_to_backup_area (fp);\n-\n-      if (!_IO_have_backup (fp))\n-\t{\n-\t  /* No backup buffer: allocate one. */\n-\t  /* Use nshort buffer, if unused? (probably not)  FIXME */\n-\t  int backup_size = 128;\n-\t  char *bbuf = (char *) malloc (backup_size);\n-\t  if (bbuf == NULL)\n-\t    return EOF;\n-\t  fp->_IO_save_base = bbuf;\n-\t  fp->_IO_save_end = fp->_IO_save_base + backup_size;\n-\t  fp->_IO_backup_base = fp->_IO_save_end;\n-\t  _IO_switch_to_backup_area (fp);\n-\t}\n-      else if (fp->_IO_read_ptr <= fp->_IO_read_base)\n-\t{\n-\t  /* Increase size of existing backup buffer. */\n-\t  _IO_size_t new_size;\n-\t  _IO_size_t old_size = fp->_IO_read_end - fp->_IO_read_base;\n-\t  char *new_buf;\n-\t  new_size = 2 * old_size;\n-\t  new_buf = (char *) malloc (new_size);\n-\t  if (new_buf == NULL)\n-\t    return EOF;\n-\t  memcpy (new_buf + (new_size - old_size), fp->_IO_read_base,\n-\t\t  old_size);\n-\t  free (fp->_IO_read_base);\n-\t  _IO_setg (fp, new_buf, new_buf + (new_size - old_size),\n-\t\t    new_buf + new_size);\n-\t  fp->_IO_backup_base = fp->_IO_read_ptr;\n-\t}\n-    }\n-  --fp->_IO_read_ptr;\n-  if (c != EOF && *fp->_IO_read_ptr != c)\n-    *fp->_IO_read_ptr = c;\n-  return (unsigned char) *fp->_IO_read_ptr;\n-}\n-\n-_IO_pos_t\n-_IO_default_seek (fp, offset, dir)\n-     _IO_FILE *fp;\n-     _IO_off_t offset;\n-     int dir;\n-{\n-  return _IO_pos_BAD;\n-}\n-\n-int\n-_IO_default_stat (fp, st)\n-     _IO_FILE *fp;\n-     void* st;\n-{\n-  return EOF;\n-}\n-\n-_IO_ssize_t\n-_IO_default_read (fp, data, n)\n-     _IO_FILE* fp;\n-     void *data;\n-     _IO_ssize_t n;\n-{\n-  return -1;\n-}\n-\n-_IO_ssize_t\n-_IO_default_write (fp, data, n)\n-     _IO_FILE *fp;\n-     const void *data;\n-     _IO_ssize_t n;\n-{\n-  return 0;\n-}\n-\n-\n-#ifdef TODO\n-#if defined(linux)\n-#define IO_CLEANUP ;\n-#endif\n-\n-#ifdef IO_CLEANUP\n-  IO_CLEANUP\n-#else\n-struct __io_defs {\n-    __io_defs() { }\n-    ~__io_defs() { _IO_cleanup (); }\n-};\n-__io_defs io_defs__;\n-#endif\n-\n-#endif /* TODO */\n-\n-#ifdef weak_alias\n-weak_alias (_IO_cleanup, _cleanup)\n-#elif defined(_G_STDIO_USES_LIBIO) && defined(_G_HAVE_WEAK_SYMBOL)\n-void _cleanup () __attribute__ ((weak, alias (\"_IO_cleanup\")));\n-#endif\n-\n-#ifdef text_set_element\n-text_set_element(__libc_atexit, _cleanup);\n-#endif"}, {"sha": "dcbf758df9c7ce83753c29bd251fbffb66af5272", "filename": "libio/include/empty.h", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Finclude%2Fempty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Finclude%2Fempty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Finclude%2Fempty.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,37 +0,0 @@\n-/* Thread package specific definitions of stream lock type.\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Library General Public License as\n-   published by the Free Software Foundation; either version 2 of the\n-   License, or (at your option) any later version.\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Library General Public License for more details.\n-\n-   You should have received a copy of the GNU Library General Public\n-   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n-   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n-\n-#ifndef _LIBIO_LOCK_H\n-#define _LIBIO_LOCK_H\t1\n-\n-typedef void *_IO_lock_t;\n-\n-/* We need recursive (counting) mutexes.  */\n-#define _IO_lock_initializer NULL\n-\n-\n-#define _IO_cleanup_region_start(_fct, _fp)\n-#define _IO_cleanup_region_end(_doit)\n-#define _IO_lock_init(_name)\n-#define _IO_lock_fini(_name)\n-#define _IO_lock_lock(_name)\n-#define _IO_lock_unlock(_name)\n-\n-#endif /* libio-lock.h */\n-/* this will be used later*/"}, {"sha": "15a1bb2778d34c32a5af65958aee88e812f73d7f", "filename": "libio/indstream.cc", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Findstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Findstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Findstream.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,121 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License.\n-\n-Written by Per Bothner (bothner@cygnus.com). */\n-\n-#ifdef __GNUG__\n-#pragma implementation\n-#endif\n-\n-#include <indstream.h>\n-\n-indirectbuf::indirectbuf(streambuf *get, streambuf *put, int delete_mode)\n-: streambuf()\n-{\n-    _get_stream = get;\n-    _put_stream = put == NULL ? get : put;\n-    _delete_flags = delete_mode;\n-}\n-\n-indirectbuf::~indirectbuf()\n-{\n-    if (_delete_flags & ios::in)  delete get_stream();\n-    if (_delete_flags & ios::out)  delete put_stream();\n-}\n-\n-streamsize indirectbuf::xsputn(const char* s, streamsize n)\n-{\n-    return put_stream()->sputn(s, n);\n-}\n-\n-streamsize indirectbuf::xsgetn(char* s, streamsize n)\n-{\n-    return get_stream()->sgetn(s, n);\n-}\n-\n-int indirectbuf::overflow(int c /* = EOF */)\n-{\n-    if (c == EOF)\n-\treturn put_stream()->overflow(c);\n-    else\n-\treturn put_stream()->sputc(c);\n-}\n-\n-int indirectbuf::underflow()\n-{\n-    return get_stream()->sgetc();\n-}\n-\n-int indirectbuf::uflow()\n-{\n-    return get_stream()->sbumpc();\n-}\n-\n-streampos indirectbuf::seekoff(streamoff off, _seek_dir dir, int mode)\n-{\n-    int ret_val = 0;\n-    int select = mode == 0 ? (ios::in|ios::out) : mode;\n-    streambuf *gbuf = (select & ios::in) ? get_stream() : (streambuf*)NULL;\n-    streambuf *pbuf = (select & ios::out) ? put_stream() : (streambuf*)NULL;\n-    if (gbuf == pbuf)\n-\tret_val = gbuf->seekoff(off, dir, mode);\n-    else {\n-\tif (gbuf)\n-\t    ret_val = gbuf->seekoff(off, dir, ios::in);\n-\tif (pbuf && ret_val != EOF)\n-\t    ret_val = pbuf->seekoff(off, dir, ios::out);\n-    }\n-    return ret_val;\n-}\n-\n-streampos indirectbuf::seekpos(streampos pos, int mode)\n-{\n-    int ret_val = EOF;\n-    int select = mode == 0 ? (ios::in|ios::out) : mode;\n-    streambuf *gbuf = (select & ios::in) ? get_stream() : (streambuf*)NULL;\n-    streambuf *pbuf = (select & ios::out) ? put_stream() : (streambuf*)NULL;\n-    if (gbuf == pbuf && gbuf != NULL)\n-\tret_val = gbuf->seekpos(pos, mode);\n-    else {\n-\tif (gbuf)\n-\t    ret_val = gbuf->seekpos(pos, ios::in);\n-\tif (pbuf && ret_val != EOF)\n-\t    ret_val = pbuf->seekpos(pos, ios::out);\n-    }\n-    return ret_val;\n-}\n-\n-int indirectbuf::sync()\n-{\n-  streambuf *gbuf = get_stream();\n-  int get_ret_val = gbuf ? gbuf->sync() : 0;\n-  streambuf *pbuf = put_stream();\n-  int put_ret_val = (pbuf && pbuf != gbuf) ?  pbuf->sync() : 0;\n-  return get_ret_val || put_ret_val;\n-}\n-\n-int indirectbuf::pbackfail(int c)\n-{\n-    return get_stream()->sputbackc(c);\n-}"}, {"sha": "c4558623d079e237d27d0bf85cbd680174d19330", "filename": "libio/indstream.h", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Findstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Findstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Findstream.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,77 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License.\n-\n-Written by Per Bothner (bothner@cygnus.com). */\n-\n-#ifndef _INDSTREAM_H\n-#define _INDSTREAM_H\n-\n-#ifdef __GNUG__\n-#pragma interface\n-#endif\n-\n-#include <iostream.h>\n-\n-extern \"C++\" {\n-// An indirectbuf is one that forwards all of its I/O requests\n-// to another streambuf.\n-// All get-related requests are sent to get_stream().\n-// All put-related requests are sent to put_stream().\n-\n-// An indirectbuf can be used to implement Common Lisp\n-// synonym-streams and two-way-streams.\n-//\n-// class synonymbuf : public indirectbuf {\n-//    Symbol *sym;\n-//    synonymbuf(Symbol *s) { sym = s; }\n-//    virtual streambuf *lookup_stream(int mode) {\n-//        return coerce_to_streambuf(lookup_value(sym)); }\n-// };\n-\n-class indirectbuf : public streambuf {\n-  protected:\n-    streambuf *_get_stream;  // Optional cache for get_stream().\n-    streambuf *_put_stream;  // Optional cache for put_stream().\n-    int _delete_flags;\n-  public:\n-    streambuf *get_stream()\n-\t{ return _get_stream ? _get_stream : lookup_stream(ios::in); }\n-    streambuf *put_stream()\n-\t{ return _put_stream ? _put_stream : lookup_stream(ios::out); }\n-    virtual streambuf *lookup_stream(int/*mode*/) { return NULL; } // ERROR!\n-    indirectbuf(streambuf *get=NULL, streambuf *put=NULL, int delete_mode=0);\n-    virtual ~indirectbuf();\n-    virtual streamsize xsputn(const char* s, streamsize n);\n-    virtual streamsize xsgetn(char* s, streamsize n);\n-    virtual int underflow();\n-    virtual int uflow();\n-    virtual int overflow(int c = EOF);\n-    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);\n-    virtual streampos seekpos(streampos pos, int mode = ios::in|ios::out);\n-    virtual int sync();\n-    virtual int pbackfail(int c);\n-};\n-} // extern \"C++\"\n-\n-#endif /* !_INDSTREAM_H */"}, {"sha": "5b8e68bbf539c2e2d1c252bcf835dfef8655380f", "filename": "libio/ioassign.cc", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioassign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioassign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioassign.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,49 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1994 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-/* Written by Per Bothner (bothner@cygnus.com). */\n-\n-#include <iostream.h>\n-#include \"libioP.h\"\n-\n-// These method are provided for backward compatibility reasons.\n-// It's generally poor style to use them.\n-// They are not supported by the ANSI/ISO working paper.\n-\n-_IO_istream_withassign&  _IO_istream_withassign::operator=(istream& rhs)\n-{\n-  if (&rhs != (istream*)this)\n-    {\n-      init (rhs.rdbuf ());\n-      _gcount = 0;\n-    }\n-  return *this;\n-}\n-\n-_IO_ostream_withassign&  _IO_ostream_withassign::operator=(ostream& rhs)\n-{\n-  if (&rhs != (ostream*)this)\n-    init (rhs.rdbuf ());\n-  return *this;\n-}"}, {"sha": "a31ff36e6e5802a83db7fb5007265cb24c5938d6", "filename": "libio/ioextend.cc", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioextend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioextend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioextend.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,132 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#include <iostream.h>\n-\n-static int __xalloc = 0;\n-\n-int ios::xalloc()\n-{\n-  return __xalloc++;\n-}\n-\n-static ios::fmtflags __used_fmt_flags\n-= ios::skipws | ios::left | ios::right | ios::internal\n-| ios::dec | ios::oct | ios::hex | ios::showbase | ios::showpoint\n-| ios::uppercase | ios::showpos | ios::scientific | ios::fixed\n-#ifndef _IO_NEW_STREAMS\n-| ios::dont_close\n-#endif\n-| ios::unitbuf | ios::stdio;\n-\n-ios::fmtflags ios::bitalloc()\n-{\n-  fmtflags bit_to_try = (fmtflags)1;\n-  for (; bit_to_try; bit_to_try <<= 1)\n-    {\n-      if ((__used_fmt_flags & bit_to_try) == 0)\n-\t{\n-\t  __used_fmt_flags |= bit_to_try;\n-\t  return bit_to_try;\n-\t}\n-    }\n-  return 0;\n-}\n-\n-// NOTE:  This implementation of ios::iword and ios::pword assumes\n-// that these methods are seldom used, so we want to minimize\n-// the space and time overhead when NOT using these methods.\n-//\n-// ANSI specifies two conceptually-infinite arrays, one whose\n-// elements are longs, and one whose elements are (void*)s.\n-// We implement this as a single array, each of whose element is\n-// a (struct ptr_and_long), which has space for both a long and a void*.\n-// We also specify that (the i field of) the 0'th element of the array\n-// contains the allocated length of the array (not counting that\n-// initial element).\n-\n-struct ptr_and_long {\n-  void *p;\n-  long i;\n-};\n-\n-static struct ptr_and_long&\n-get_array_element(ios& io, int index)\n-{\n-  if (index < 0)\n-    io._throw_failure();\n-  register struct ptr_and_long *array = (ptr_and_long*)io._arrays;\n-  int old_length = array == NULL ? 0 : array[0].i;\n-  if (index >= old_length)\n-    {\n-      register int i;\n-      int new_length = index + 10;\n-      register struct ptr_and_long *new_array\n-\t= new ptr_and_long[1 + new_length];\n-      if (array != NULL)\n-\t{\n-\t  for (i = 1; i <= old_length; i++)\n-\t    new_array[i] = array[i];\n-\t  delete [] array;\n-\t}\n-      for (i = old_length + 1; i <= new_length; i++)\n-\t{\n-\t  new_array[i].i = 0;\n-\t  new_array[i].p = NULL;\n-\t}\n-      new_array[0].i = new_length;\n-      new_array[0].p = NULL;\n-      io._arrays = (void*)new_array;\n-      array = new_array;\n-    }\n-  return array[index+1];\n-}\n-\n-long& ios::iword(int index)\n-{\n-  return get_array_element(*this, index).i;\n-}\n-\n-void*& ios::pword(int index)\n-{\n-  return get_array_element(*this, index).p;\n-}\n-\n-long ios::iword(int index) const\n-{\n-  if (index < 0)\n-    _throw_failure();\n-  register struct ptr_and_long *pl_array = (ptr_and_long*)_arrays;\n-  int len = pl_array == NULL ? 0 : pl_array[0].i;\n-  return index >= len ? 0 : pl_array[index+1].i;\n-}\n-\n-void* ios::pword(int index) const\n-{\n-  if (index < 0)\n-    _throw_failure();\n-  register struct ptr_and_long *pl_array = (ptr_and_long*)_arrays;\n-  int len = pl_array == NULL ? 0 : pl_array[0].i;\n-  return index >= len ? 0 : pl_array[index+1].p;\n-}"}, {"sha": "7db336c5d539a8ca071401b1502051af827bdfb2", "filename": "libio/iofclose.c", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofclose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofclose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofclose.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,60 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#endif\n-\n-int\n-_IO_fclose (fp)\n-     _IO_FILE *fp;\n-{\n-  int status;\n-\n-  CHECK_FILE(fp, EOF);\n-\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  if (fp->_IO_file_flags & _IO_IS_FILEBUF)\n-    status = _IO_file_close_it (fp);\n-  else\n-    status = fp->_flags & _IO_ERR_SEEN ? -1 : 0;\n-  _IO_FINISH (fp);\n-  _IO_cleanup_region_end (1);\n-  if (fp != _IO_stdin && fp != _IO_stdout && fp != _IO_stderr)\n-    {\n-      fp->_IO_file_flags = 0;\n-      free(fp);\n-    }\n-\n-  return status;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_fclose, fclose)\n-#elif defined(_G_STDIO_USES_LIBIO) && defined(_G_HAVE_WEAK_SYMBOL)\n-int fclose (_IO_FILE *) __attribute__ ((weak, alias(\"_IO_fclose\")));\n-#endif"}, {"sha": "841e7032b803218d1ed94896755146dea4eb8628", "filename": "libio/iofdopen.c", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofdopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofdopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofdopen.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,134 +0,0 @@\n-/* Copyright (C) 1993, 1994, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#endif\n-#include \"libioP.h\"\n-#include <fcntl.h>\n-\n-#ifndef _IO_fcntl\n-#define _IO_fcntl fcntl\n-#endif\n-\n-_IO_FILE *\n-_IO_fdopen (fd, mode)\n-     int fd;\n-     const char *mode;\n-{\n-  int read_write;\n-  int posix_mode = 0;\n-  struct locked_FILE\n-  {\n-    struct _IO_FILE_plus fp;\n-#ifdef _IO_MTSAFE_IO\n-    _IO_lock_t lock;\n-#endif\n-  } *new_f;\n-  int fd_flags;\n-\n-  switch (*mode++)\n-    {\n-    case 'r':\n-      read_write = _IO_NO_WRITES;\n-      break;\n-    case 'w':\n-      read_write = _IO_NO_READS;\n-      break;\n-    case 'a':\n-      posix_mode = O_APPEND;\n-      read_write = _IO_NO_READS|_IO_IS_APPENDING;\n-      break;\n-    default:\n-      MAYBE_SET_EINVAL;\n-      return NULL;\n-  }\n-  if (mode[0] == '+' || (mode[0] == 'b' && mode[1] == '+'))\n-    read_write &= _IO_IS_APPENDING;\n-#ifdef F_GETFL\n-  fd_flags = _IO_fcntl (fd, F_GETFL);\n-#ifndef O_ACCMODE\n-#define O_ACCMODE (O_RDONLY|O_WRONLY|O_RDWR)\n-#endif\n-  if (fd_flags == -1\n-      || ((fd_flags & O_ACCMODE) == O_RDONLY && !(read_write & _IO_NO_WRITES))\n-      || ((fd_flags & O_ACCMODE) == O_WRONLY && !(read_write & _IO_NO_READS)))\n-    return NULL;\n-\n-  /* The May 93 draft of P1003.4/D14.1 (redesignated as 1003.1b)\n-     [System Application Program Interface (API) Amendment 1:\n-     Realtime Extensions], Rationale B.8.3.3\n-     Open a Stream on a File Descriptor says:\n-\n-         Although not explicitly required by POSIX.1, a good\n-         implementation of append (\"a\") mode would cause the\n-         O_APPEND flag to be set.\n-\n-     (Historical implementations [such as Solaris2] do a one-time\n-     seek in fdopen.)\n-\n-     However, we do not turn O_APPEND off if the mode is \"w\" (even\n-     though that would seem consistent) because that would be more\n-     likely to break historical programs.\n-     */\n-  if ((posix_mode & O_APPEND) && !(fd_flags & O_APPEND))\n-    {\n-#ifdef F_SETFL\n-      if (_IO_fcntl (fd, F_SETFL, fd_flags | O_APPEND) == -1)\n-#endif\n-\treturn NULL;\n-    }\n-#endif\n-\n-  new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));\n-  if (new_f == NULL)\n-    return NULL;\n-#ifdef _IO_MTSAFE_IO\n-  new_f->fp.file._lock = &new_f->lock;\n-#endif\n-  _IO_init (&new_f->fp.file, 0);\n-  _IO_JUMPS (&new_f->fp.file) = &_IO_file_jumps;\n-  _IO_file_init (&new_f->fp.file);\n-#if  !_IO_UNIFIED_JUMPTABLES\n-  new_f->fp.vtable = NULL;\n-#endif\n-  if (_IO_file_attach (&new_f->fp.file, fd) == NULL)\n-    {\n-      _IO_un_link (&new_f->fp.file);\n-      free (new_f);\n-      return NULL;\n-    }\n-  new_f->fp.file._flags &= ~_IO_DELETE_DONT_CLOSE;\n-\n-  new_f->fp.file._IO_file_flags =\n-    _IO_mask_flags (&new_f->fp.file, read_write,\n-\t\t    _IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);\n-\n-  return (_IO_FILE *) &new_f->fp;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_fdopen, fdopen)\n-#endif"}, {"sha": "7bf8cba285be5a8d6979eacbcd02feafe966d18a", "filename": "libio/iofeof.c", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofeof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofeof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofeof.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,45 +0,0 @@\n-/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include \"stdio.h\"\n-\n-int\n-_IO_feof (fp)\n-     _IO_FILE* fp;\n-{\n-  int result;\n-  CHECK_FILE (fp, EOF);\n-  _IO_flockfile (fp);\n-  result = _IO_feof_unlocked (fp);\n-  _IO_funlockfile (fp);\n-  return result;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_feof, feof)\n-#elif defined(_G_STDIO_USES_LIBIO) && defined(_G_HAVE_WEAK_SYMBOL)\n-int feof (_IO_FILE *) __attribute__ ((weak, alias(\"_IO_feof\")));\n-#endif"}, {"sha": "3019e796a1f6a31ba1d7f188bde4c1de29a2f70c", "filename": "libio/ioferror.c", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioferror.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,45 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include \"stdio.h\"\n-\n-int\n-_IO_ferror (fp)\n-     _IO_FILE* fp;\n-{\n-  int result;\n-  CHECK_FILE (fp, EOF);\n-  _IO_flockfile (fp);\n-  result = _IO_ferror_unlocked (fp);\n-  _IO_funlockfile (fp);\n-  return result;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_ferror, ferror)\n-#elif defined(_G_STDIO_USES_LIBIO) && defined(_G_HAVE_WEAK_SYMBOL)\n-int ferror (_IO_FILE *) __attribute__ ((weak, alias(\"_IO_ferror\")));\n-#endif"}, {"sha": "540c99d535ee8c72551240133121a2f88828a7ef", "filename": "libio/iofflush.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofflush.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofflush.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofflush.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,49 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include <stdio.h>\n-\n-int\n-_IO_fflush (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp == NULL)\n-    return _IO_flush_all ();\n-  else\n-    {\n-      int result;\n-      CHECK_FILE (fp, EOF);\n-      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-      _IO_flockfile (fp);\n-      result = _IO_SYNC (fp) ? EOF : 0;\n-      _IO_cleanup_region_end (1);\n-      return result;\n-    }\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_fflush, fflush)\n-#endif"}, {"sha": "b46ae4a3f94948cdaa5a940fc0d2b9c54a197ed9", "filename": "libio/iofflush_u.c", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofflush_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofflush_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofflush_u.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,40 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include <stdio.h>\n-\n-int\n-fflush_unlocked (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp == NULL)\n-    return _IO_flush_all ();\n-  else\n-    {\n-      CHECK_FILE (fp, EOF);\n-      return _IO_SYNC (fp) ? EOF : 0;\n-    }\n-}"}, {"sha": "716be4bca107b19e151f2c802dbc2b7d8322350a", "filename": "libio/iofgetpos.c", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofgetpos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofgetpos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofgetpos.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,55 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include <errno.h>\n-/* ANSI explicitly requires setting errno to a positive value on failure. */\n-\n-int\n-_IO_fgetpos (fp, posp)\n-     _IO_FILE* fp;\n-     _IO_fpos_t *posp;\n-{\n-  _IO_fpos_t pos;\n-  CHECK_FILE (fp, EOF);\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  pos = _IO_seekoff (fp, 0, _IO_seek_cur, 0);\n-  _IO_cleanup_region_end (1);\n-  if (pos == _IO_pos_BAD)\n-    {\n-#ifdef EIO\n-      if (errno == 0)\n-\t__set_errno (EIO);\n-#endif\n-      return EOF;\n-    }\n-  *posp = pos;\n-  return 0;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_fgetpos, fgetpos)\n-#endif"}, {"sha": "74754d5d1ea811e84b2a4794e385114e3f2f556d", "filename": "libio/iofgets.c", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofgets.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofgets.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofgets.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,56 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include <stdio.h>\n-\n-char *\n-_IO_fgets (buf, n, fp)\n-     char *buf;\n-     int n;\n-     _IO_FILE *fp;\n-{\n-  _IO_size_t count;\n-  char *result;\n-  CHECK_FILE (fp, NULL);\n-  if (n <= 0)\n-    return NULL;\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  count = _IO_getline (fp, buf, n - 1, '\\n', 1);\n-  if (count == 0 || (fp->_IO_file_flags & _IO_ERR_SEEN))\n-    result = NULL;\n-  else\n-    {\n-      buf[count] = '\\0';\n-      result = buf;\n-    }\n-  _IO_cleanup_region_end (1);\n-  return result;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_fgets, fgets)\n-#endif"}, {"sha": "1dbeccb81a8fcf5c9f9c278dc691b1e7b4dac8e1", "filename": "libio/iofopen.c", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofopen.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,64 +0,0 @@\n-/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#endif\n-\n-_IO_FILE *\n-_IO_fopen (filename, mode)\n-     const char *filename;\n-     const char *mode;\n-{\n-  struct locked_FILE\n-  {\n-    struct _IO_FILE_plus fp;\n-#ifdef _IO_MTSAFE_IO\n-    _IO_lock_t lock;\n-#endif\n-  } *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));\n-\n-  if (new_f == NULL)\n-    return NULL;\n-#ifdef _IO_MTSAFE_IO\n-  new_f->fp.file._lock = &new_f->lock;\n-#endif\n-  _IO_init (&new_f->fp.file, 0);\n-  _IO_JUMPS (&new_f->fp.file) = &_IO_file_jumps;\n-  _IO_file_init (&new_f->fp.file);\n-#if  !_IO_UNIFIED_JUMPTABLES\n-  new_f->fp.vtable = NULL;\n-#endif\n-  if (_IO_file_fopen (&new_f->fp.file, filename, mode) != NULL)\n-        return (_IO_FILE *) &new_f->fp;\n-  _IO_un_link (&new_f->fp.file);\n-  free (new_f);\n-  return NULL;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_fopen, fopen)\n-#endif"}, {"sha": "4dc9d3f6617e9b0be62ff531208eab664e03b591", "filename": "libio/iofprintf.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofprintf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,51 +0,0 @@\n-/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-\n-#ifdef __STDC__\n-#include <stdarg.h>\n-#else\n-#include <varargs.h>\n-#endif\n-\n-int\n-#ifdef __STDC__\n-_IO_fprintf (_IO_FILE *fp, const char* format, ...)\n-#else\n-_IO_fprintf (fp, format, va_alist)\n-     _IO_FILE *fp;\n-     char *format;\n-     va_dcl\n-#endif\n-{\n-  int ret;\n-  va_list args;\n-  CHECK_FILE (fp, -1);\n-  _IO_va_start (args, format);\n-  ret = _IO_vfprintf (fp, format, args);\n-  va_end (args);\n-  return ret;\n-}"}, {"sha": "1a329bbe26fc20b5c7f3a872c1af2381437880ee", "filename": "libio/iofputs.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofputs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofputs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofputs.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,49 +0,0 @@\n-/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include <string.h>\n-\n-int\n-_IO_fputs (str, fp)\n-      const char *str;\n-      _IO_FILE *fp;\n-{\n-  _IO_size_t len = strlen (str);\n-  int result;\n-  CHECK_FILE (fp, EOF);\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  if (_IO_sputn (fp, str, len) != len)\n-    result = EOF;\n-  else\n-    result = 1;\n-  _IO_cleanup_region_end (1);\n-  return result;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_fputs, fputs)\n-#endif"}, {"sha": "c83d2b638c97d99fee08538d368521c897e5aac5", "filename": "libio/iofread.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofread.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,49 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-\n-_IO_size_t\n-_IO_fread (buf, size, count, fp)\n-     void *buf;\n-     _IO_size_t size;\n-     _IO_size_t count;\n-     _IO_FILE *fp;\n-{\n-  _IO_size_t bytes_requested = size*count;\n-  _IO_size_t bytes_read;\n-  CHECK_FILE (fp, 0);\n-  if (bytes_requested == 0)\n-    return 0;\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);\n-  _IO_cleanup_region_end (1);\n-  return bytes_requested == bytes_read ? count : bytes_read / size;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_fread, fread)\n-#endif"}, {"sha": "3e12d9b5315c0dc2f4c4761c69cb2af0b91fa96f", "filename": "libio/iofscanf.c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofscanf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofscanf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofscanf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,48 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#include \"libioP.h\"\n-\n-#ifdef __STDC__\n-#include <stdarg.h>\n-#else\n-#include <varargs.h>\n-#endif\n-\n-int\n-_IO_fscanf\n-#ifdef __STDC__\n-  (_IO_FILE *fp, const char* format, ...)\n-#else\n-(fp, format, va_alist) _IO_FILE *fp; char *format; va_dcl\n-#endif\n-{\n-  int ret;\n-  va_list args;\n-  CHECK_FILE(fp, EOF);\n-  _IO_va_start(args, format);\n-  ret = _IO_vfscanf(fp, format, args, NULL);\n-  va_end(args);\n-  return ret;\n-}"}, {"sha": "a8d816f5a393a549393c62b267ec729f9685e99b", "filename": "libio/iofsetpos.c", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofsetpos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofsetpos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofsetpos.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,56 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include <libioP.h>\n-#include <errno.h>\n-\n-int\n-_IO_fsetpos (fp, posp)\n-     _IO_FILE *fp;\n-     const _IO_fpos_t *posp;\n-{\n-  int result;\n-  CHECK_FILE (fp, EOF);\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  if (_IO_seekpos (fp, *posp, _IOS_INPUT|_IOS_OUTPUT) == _IO_pos_BAD)\n-    {\n-      /* ANSI explicitly requires setting errno to a positive value on\n-\t failure.  */\n-#ifdef EIO\n-      if (errno == 0)\n-\t__set_errno (EIO);\n-#endif\n-      result = EOF;\n-    }\n-  else\n-    result = 0;\n-  _IO_cleanup_region_end (1);\n-  return result;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_fsetpos, fsetpos)\n-#endif"}, {"sha": "d8a1ce1d24239a66e5e2937beb10cca59456f1d9", "filename": "libio/ioftell.c", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioftell.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioftell.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioftell.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,53 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include <errno.h>\n-/* ANSI explicily requires setting errno to a positive value on failure. */\n-\n-long int\n-_IO_ftell (fp)\n-     _IO_FILE *fp;\n-{\n-  _IO_pos_t pos;\n-  CHECK_FILE (fp, -1L);\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  pos = _IO_seekoff (fp, 0, _IO_seek_cur, 0);\n-  _IO_cleanup_region_end (1);\n-  if (pos == _IO_pos_BAD)\n-    {\n-#ifdef EIO\n-      if (errno == 0)\n-\t__set_errno (EIO);\n-#endif\n-      return -1L;\n-    }\n-  return _IO_pos_as_off (pos);\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_ftell, ftell)\n-#endif"}, {"sha": "5bc525ffc704d6c4d5cd3cd4074f2f3edbf1b676", "filename": "libio/iofwrite.c", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiofwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofwrite.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,54 +0,0 @@\n-/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-\n-_IO_size_t\n-_IO_fwrite (buf, size, count, fp)\n-     const void *buf;\n-     _IO_size_t size;\n-     _IO_size_t count;\n-     _IO_FILE *fp;\n-{\n-  _IO_size_t request = size * count;\n-  _IO_size_t written;\n-  CHECK_FILE (fp, 0);\n-  if (request == 0)\n-    return 0;\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  written = _IO_sputn (fp, (const char *) buf, request);\n-  _IO_cleanup_region_end (1);\n-  /* Many traditional implementations return 0 if size==0 && count > 0,\n-     but ANSI requires us to return count in this case. */\n-  if (written == request)\n-    return count;\n-  else\n-    return written / size;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_fwrite, fwrite)\n-#endif"}, {"sha": "6a11e47334dc5ad5612e209c2f001b5a92c54ad6", "filename": "libio/iogetc.c", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiogetc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiogetc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiogetc.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,50 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include \"stdio.h\"\n-\n-#undef _IO_getc\n-\n-int\n-_IO_getc (fp)\n-     _IO_FILE *fp;\n-{\n-  int result;\n-  CHECK_FILE (fp, EOF);\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  result = _IO_getc_unlocked (fp);\n-  _IO_cleanup_region_end (1);\n-  return result;\n-}\n-\n-#undef getc\n-\n-#ifdef weak_alias\n-weak_alias (_IO_getc, getc)\n-#elif defined(_G_STDIO_USES_LIBIO) && defined(_G_HAVE_WEAK_SYMBOL)\n-int getc (_IO_FILE *) __attribute__ ((weak, alias(\"_IO_getc\")));\n-#endif"}, {"sha": "50918b3e8dcc1e3ebc95d49acad6b80c11d9f69c", "filename": "libio/iogetdelim.c", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiogetdelim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiogetdelim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiogetdelim.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,125 +0,0 @@\n-/* Copyright (C) 1994, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#endif\n-#include \"libioP.h\"\n-#include <string.h>\n-#include <errno.h>\n-\n-/* Read up to (and including) a TERMINATOR from FP into *LINEPTR\n-   (and null-terminate it).  *LINEPTR is a pointer returned from malloc (or\n-   NULL), pointing to *N characters of space.  It is realloc'ed as\n-   necessary.  Returns the number of characters read (not including the\n-   null terminator), or -1 on error or EOF.  */\n-\n-_IO_ssize_t\n-_IO_getdelim (lineptr, n, delimiter, fp)\n-     char **lineptr;\n-     _IO_size_t *n;\n-     int delimiter;\n-     _IO_FILE *fp;\n-{\n-  int result;\n-  _IO_ssize_t cur_len = 0;\n-  _IO_ssize_t len;\n-\n-  if (lineptr == NULL || n == NULL)\n-    {\n-      MAYBE_SET_EINVAL;\n-      return -1;\n-    }\n-  CHECK_FILE (fp, -1);\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  if (_IO_ferror_unlocked (fp))\n-    {\n-      result = -1;\n-      goto unlock_return;\n-    }\n-\n-  if (*lineptr == NULL || *n == 0)\n-    {\n-      *n = 120;\n-      *lineptr = (char *) malloc (*n);\n-      if (*lineptr == NULL)\n-\t{\n-\t  result = -1;\n-\t  goto unlock_return;\n-\t}\n-    }\n-\n-  len = fp->_IO_read_end - fp->_IO_read_ptr;\n-  if (len <= 0)\n-    {\n-      if (__underflow (fp) == EOF)\n-\t{\n-\t  result = -1;\n-\t  goto unlock_return;\n-\t}\n-      len = fp->_IO_read_end - fp->_IO_read_ptr;\n-    }\n-\n-  for (;;)\n-    {\n-      _IO_size_t needed;\n-      char *t;\n-      t = (char *) memchr ((void *) fp->_IO_read_ptr, delimiter, len);\n-      if (t != NULL)\n-\tlen = (t - fp->_IO_read_ptr) + 1;\n-      /* Make enough space for len+1 (for final NUL) bytes.  */\n-      needed = cur_len + len + 1;\n-      if (needed > *n)\n-\t{\n-\t  if (needed < 2 * *n)\n-\t    needed = 2 * *n;  /* Be generous. */\n-\t  *n = needed;\n-\t  *lineptr = (char *) realloc (*lineptr, needed);\n-\t  if (*lineptr == NULL)\n-\t    {\n-\t      result = -1;\n-\t      goto unlock_return;\n-\t    }\n-\t}\n-      memcpy (*lineptr + cur_len, (void *) fp->_IO_read_ptr, len);\n-      fp->_IO_read_ptr += len;\n-      cur_len += len;\n-      if (t != NULL || __underflow (fp) == EOF)\n-\tbreak;\n-      len = fp->_IO_read_end - fp->_IO_read_ptr;\n-    }\n-  (*lineptr)[cur_len] = '\\0';\n-  result = cur_len;\n-\n-unlock_return:\n-  _IO_cleanup_region_end (1);\n-  return result;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_getdelim, __getdelim)\n-weak_alias (_IO_getdelim, getdelim)\n-#endif"}, {"sha": "5aac9b56387e9aa9aedab20f06baf9ea6b1b3639", "filename": "libio/iogetline.c", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiogetline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiogetline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiogetline.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,112 +0,0 @@\n-/* Copyright (C) 1993, 1997, 1998 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include <string.h>\n-\n-#if defined(_LIBC) || !_G_HAVE_IO_GETLINE_INFO\n-\n-_IO_size_t\n-_IO_getline (fp, buf, n, delim, extract_delim)\n-     _IO_FILE *fp;\n-     char *buf;\n-     _IO_size_t n;\n-     int delim;\n-     int extract_delim;\n-{\n-  return _IO_getline_info (fp, buf, n, delim, extract_delim, (int *) 0);\n-}\n-\n-/* Algorithm based on that used by Berkeley pre-4.4 fgets implementation.\n-\n-   Read chars into buf (of size n), until delim is seen.\n-   Return number of chars read (at most n).\n-   Does not put a terminating '\\0' in buf.\n-   If extract_delim < 0, leave delimiter unread.\n-   If extract_delim > 0, insert delim in output. */\n-\n-_IO_size_t\n-_IO_getline_info (fp, buf, n, delim, extract_delim, eof)\n-     _IO_FILE *fp;\n-     char *buf;\n-     _IO_size_t n;\n-     int delim;\n-     int extract_delim;\n-     int *eof;\n-{\n-  char *ptr = buf;\n-  if (eof) *eof = 0;\n-  while (n != 0)\n-    {\n-      _IO_ssize_t len = fp->_IO_read_end - fp->_IO_read_ptr;\n-      if (len <= 0)\n-\t{\n-\t  int c = __uflow (fp);\n-\t  if (c == EOF)\n-\t    {\n-\t      if (eof) *eof = c;\n-\t      break;\n-\t    }\n-\t  if (c == delim)\n-\t    {\n-\t      if (extract_delim > 0)\n-\t\t*ptr++ = c;\n-\t      else if (extract_delim < 0)\n-\t\t_IO_sputbackc (fp, c);\n-\t      return ptr - buf;\n-\t    }\n-\t  *ptr++ = c;\n-\t  n--;\n-\t}\n-\telse\n-\t  {\n-\t    char *t;\n-\t    if ((_IO_size_t) len >= n)\n-\t      len = n;\n-\t    t = (char *) memchr ((void *) fp->_IO_read_ptr, delim, len);\n-\t    if (t != NULL)\n-\t      {\n-\t\t_IO_size_t old_len = ptr-buf;\n-\t\tlen = t - fp->_IO_read_ptr;\n-\t\tif (extract_delim >= 0)\n-\t\t  {\n-\t\t    ++t;\n-\t\t    if (extract_delim > 0)\n-\t\t      ++len;\n-\t\t  }\n-\t\tmemcpy ((void *) ptr, (void *) fp->_IO_read_ptr, len);\n-\t\tfp->_IO_read_ptr = t;\n-\t\treturn old_len + len;\n-\t      }\n-\t    memcpy ((void *) ptr, (void *) fp->_IO_read_ptr, len);\n-\t    fp->_IO_read_ptr += len;\n-\t    ptr += len;\n-\t    n -= len;\n-\t  }\n-    }\n-  return ptr - buf;\n-}\n-\n-#endif /* Defined(_LIBC) || !_G_HAVE_IO_GETLINE_INFO */"}, {"sha": "9e88ca1037ae55c70fd7b08fa748a1f43396356e", "filename": "libio/iogets.c", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiogets.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiogets.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiogets.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,71 +0,0 @@\n-/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include <limits.h>\n-\n-char*\n-_IO_gets (buf)\n-     char *buf;\n-{\n-  _IO_size_t count;\n-  int ch;\n-  char *retval;\n-\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t    _IO_stdin);\n-  _IO_flockfile (_IO_stdin);\n-  ch = _IO_getc_unlocked (_IO_stdin);\n-  if (ch == EOF)\n-    {\n-      retval = NULL;\n-      goto unlock_return;\n-    }\n-  if (ch == '\\n')\n-    count = 0;\n-  else\n-    {\n-      buf[0] = (char) ch;\n-      count = _IO_getline (_IO_stdin, buf + 1, INT_MAX, '\\n', 0) + 1;\n-      if (_IO_stdin->_IO_file_flags & _IO_ERR_SEEN)\n-\t{\n-\t  retval = NULL;\n-\t  goto unlock_return;\n-\t}\n-    }\n-  buf[count] = 0;\n-  retval = buf;\n-unlock_return:\n-  _IO_cleanup_region_end (1);\n-  return retval;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_gets, gets)\n-#endif\n-\n-#ifdef _LIBC\n-link_warning (gets, \"the `gets' function is dangerous and should not be used.\")\n-#endif"}, {"sha": "ac0678ed7b9948ac78b698e1e4983d786dc3cd07", "filename": "libio/ioignore.c", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioignore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioignore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioignore.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,47 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#include \"libioP.h\"\n-\n-int\n-_IO_ignore (fp, n)\n-     _IO_FILE *fp;\n-     _IO_size_t n;\n-{\n-  register _IO_size_t more = n;\n-  for (;;)\n-    {\n-      _IO_ssize_t count = fp->_IO_read_end - fp->_IO_read_ptr;\n-      if (count > 0)\n-\t{\n-\t  if (count > more)\n-\t    count = more;\n-\t  fp->_IO_read_ptr += count;\n-\t  more -= count;\n-\t}\n-      if (more == 0 || __underflow(fp) == EOF)\n-\tbreak;\n-    }\n-  return n - more;\n-}"}, {"sha": "0ebc14f7ac2b66069434b8bd907624cc3f13c134", "filename": "libio/iolibio.h", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiolibio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiolibio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiolibio.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,67 +0,0 @@\n-#include <libio.h>\n-\n-/* These emulate stdio functionality, but with a different name\n-   (_IO_ungetc instead of ungetc), and using _IO_FILE instead of FILE. */\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-extern int _IO_fclose __P((_IO_FILE*));\n-extern _IO_FILE *_IO_fdopen __P((int, const char*));\n-extern int _IO_fflush __P((_IO_FILE*));\n-extern int _IO_fgetpos __P((_IO_FILE*, _IO_fpos_t*));\n-extern char* _IO_fgets __P((char*, int, _IO_FILE*));\n-extern _IO_FILE *_IO_fopen __P((const char*, const char*));\n-extern int _IO_fprintf __P((_IO_FILE*, const char*, ...));\n-extern int _IO_fputs __P((const char*, _IO_FILE*));\n-extern int _IO_fsetpos __P((_IO_FILE*, const _IO_fpos_t *));\n-extern long int _IO_ftell __P((_IO_FILE*));\n-extern _IO_size_t _IO_fread __P((void*, _IO_size_t, _IO_size_t, _IO_FILE*));\n-extern _IO_size_t _IO_fwrite __P((const void*,\n-\t\t\t\t      _IO_size_t, _IO_size_t, _IO_FILE*));\n-extern char* _IO_gets __P((char*));\n-extern void _IO_perror __P((const char*));\n-extern int _IO_printf __P((const char*, ...));\n-extern int _IO_puts __P((const char*));\n-extern int _IO_scanf __P((const char*, ...));\n-extern void _IO_setbuffer __P((_IO_FILE *, char*, _IO_size_t));\n-extern int _IO_setvbuf __P((_IO_FILE*, char*, int, _IO_size_t));\n-extern int _IO_sscanf __P((const char*, const char*, ...));\n-extern int _IO_sprintf __P((char *, const char*, ...));\n-extern int _IO_ungetc __P((int, _IO_FILE*));\n-extern int _IO_vsscanf __P((const char *, const char *, _IO_va_list));\n-extern int _IO_vsprintf __P((char*, const char*, _IO_va_list));\n-\n-struct obstack;\n-extern int _IO_obstack_vprintf __P ((struct obstack *, const char *,\n-                                    _IO_va_list));\n-extern int _IO_obstack_printf __P ((struct obstack *, const char *, ...));\n-#ifndef _IO_pos_BAD\n-# if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n-#  define _IO_pos_BAD ((_IO_off64_t) -1)\n-# else\n-#  define _IO_pos_BAD ((_IO_off_t) -1)\n-# endif\n-#endif\n-#define _IO_clearerr(FP) ((FP)->_flags &= ~(_IO_ERR_SEEN|_IO_EOF_SEEN))\n-#define _IO_fseek(__fp, __offset, __whence) \\\n-  (_IO_seekoff(__fp, __offset, __whence, _IOS_INPUT|_IOS_OUTPUT) == _IO_pos_BAD ? EOF : 0)\n-#define _IO_rewind(FILE) (void)_IO_seekoff(FILE, 0, 0, _IOS_INPUT|_IOS_OUTPUT)\n-#define _IO_vprintf(FORMAT, ARGS) _IO_vfprintf(_IO_stdout, FORMAT, ARGS)\n-#if _G_IO_IO_FILE_VERSION == 0x20001\n-#define _IO_freopen(FILENAME, MODE, FP) \\\n-  (_IO_file_close_it(FP), _IO_file_fopen(FP, FILENAME, MODE, 0))\n-#else\n-#define _IO_freopen(FILENAME, MODE, FP) \\\n-  (_IO_file_close_it(FP), _IO_file_fopen(FP, FILENAME, MODE))\n-#endif\n-#define _IO_fileno(FP) ((FP)->_fileno)\n-extern _IO_FILE* _IO_popen __P((const char*, const char*));\n-#define _IO_pclose _IO_fclose\n-#define _IO_setbuf(_FP, _BUF) _IO_setbuffer(_FP, _BUF, _IO_BUFSIZ)\n-#define _IO_setlinebuf(_FP) _IO_setvbuf(_FP, NULL, 1, 0)\n-\n-#ifdef __cplusplus\n-}\n-#endif"}, {"sha": "fddba55a2b989b7ddf462a604474e6652b10ddc2", "filename": "libio/iomanip.cc", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiomanip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiomanip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiomanip.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,90 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#ifdef __GNUG__\n-#pragma implementation\n-#endif\n-\n-#include \"iomanip.h\"\n-\n-\n-// Those functions are called through a pointer, \n-// thus it does not make sense, to inline them.\n-\n-ios & __iomanip_setbase (ios& i, int n)\n-{\n-    ios::fmtflags b;\n-    switch (n)\n-      {\n-\tcase  8: \n-\t  b = ios::oct; break;\n-\tcase 10: \n-\t  b = ios::dec; break;\n-\tcase 16: \n-\t  b = ios::hex; break;\n-\tdefault:\n-\t  b = 0;\n-      }\n-    i.setf(b, ios::basefield);\n-    return i;\n-}\n-\n-ios & __iomanip_setfill (ios& i, int n)\n-{\n-    //FIXME if ( i.flags() & ios::widechar )\n-      i.fill( (char) n);\n-    //FIXME else\n-    //FIXME   i.fill( (wchar) n);\n-    return i;\n-}   \n-\n-ios &  __iomanip_setprecision (ios& i, int n)\n-{\n-    i.precision(n);\n-    return i;\n-}\n-ios &  __iomanip_setw (ios& i, int n)\n-{\n-    i.width(n);\n-    return i;\n-}\n-\n-ios & __iomanip_setiosflags (ios& i, ios::fmtflags n)\n-{\n-    i.setf(n,n);\n-    return i;\n-}\n-\n-ios & __iomanip_resetiosflags (ios& i, ios::fmtflags n)\n-{\n-    i.setf(0,n);\n-    return i;\n-}\n-\n-template class smanip<int>;\n-template class smanip<ios::fmtflags>;\n-template istream& operator>>(istream&, const smanip<int>&);\n-template istream& operator>>(istream&, const smanip<ios::fmtflags>&);\n-template ostream& operator<<(ostream&, const smanip<int>&);\n-template ostream& operator<<(ostream&, const smanip<ios::fmtflags>&);"}, {"sha": "7c0232ed1e166727b2d51d574e92dc84680db207", "filename": "libio/iomanip.h", "status": "removed", "additions": 0, "deletions": 180, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiomanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiomanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiomanip.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,180 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#ifndef _IOMANIP_H\n-#ifdef __GNUG__\n-#pragma interface\n-#endif\n-#define _IOMANIP_H\n-\n-#include <iostream.h>\n-\n-extern \"C++\" {\n-//-----------------------------------------------------------------------------\n-//\tParametrized Manipulators as specified by ANSI draft\n-//-----------------------------------------------------------------------------\n-\n-//-----------------------------------------------------------------------------\n-//\tStream Manipulators\n-//-----------------------------------------------------------------------------\n-//\n-template<class TP> class smanip; // TP = Type Param\n-\n-template<class TP> class sapp {\n-    ios& (*_f)(ios&, TP);\n-public: \n-    sapp(ios& (*f)(ios&, TP)) : _f(f) {}\n-    //\n-    smanip<TP> operator()(TP a) \n-      { return smanip<TP>(_f, a); }\n-};\n-\n-template<class TP>\n-inline istream& operator>>(istream& i, const smanip<TP>& m);\n-template<class TP>\n-inline ostream& operator<<(ostream& o, const smanip<TP>& m);\n-\n-template <class TP> class smanip {\n-    ios& (*_f)(ios&, TP);\n-    TP _a;\n-public:\n-    smanip(ios& (*f)(ios&, TP), TP a) : _f(f), _a(a) {}\n-    //\n-    friend \n-      istream& operator>> <>(istream& i, const smanip<TP>& m);\n-    friend\n-      ostream& operator<< <>(ostream& o, const smanip<TP>& m);\n-};\n-\n-#ifdef __GNUG__\n-__extension__ extern template class smanip<int>;\n-__extension__ extern template class smanip<ios::fmtflags>;\n-#endif\n-\n-template<class TP>\n-inline istream& operator>>(istream& i, const smanip<TP>& m)\n-{ (*m._f)(i, m._a); return i; }\n-\n-template<class TP>\n-inline ostream& operator<<(ostream& o, const smanip<TP>& m)\n-{ (*m._f)(o, m._a); return o;}\n-\n-#ifdef __GNUG__\n-__extension__ extern \n-template istream& operator>>(istream&, const smanip<int>&);\n-__extension__ extern \n-template istream& operator>>(istream&, const smanip<ios::fmtflags>&);\n-__extension__ extern \n-template ostream& operator<<(ostream&, const smanip<int>&);\n-__extension__ extern \n-template ostream& operator<<(ostream&, const smanip<ios::fmtflags>&);\n-#endif\n-\n-//-----------------------------------------------------------------------------\n-//\tInput-Stream Manipulators\n-//-----------------------------------------------------------------------------\n-//\n-template<class TP> class imanip; \n-\n-template<class TP> class iapp {\n-    istream& (*_f)(istream&, TP);\n-public: \n-    iapp(istream& (*f)(istream&,TP)) : _f(f) {}\n-    //\n-    imanip<TP> operator()(TP a)\n-       { return imanip<TP>(_f, a); }\n-};\n-\n-template <class TP>\n-inline istream& operator>>(istream&, const imanip<TP>&);\n-\n-template <class TP> class imanip {\n-    istream& (*_f)(istream&, TP);\n-    TP _a;\n-public:\n-    imanip(istream& (*f)(istream&, TP), TP a) : _f(f), _a(a) {}\n-    //\n-    friend\n-      istream& operator>> <>(istream& i, const imanip<TP>& m);\n-};\n-\n-template <class TP>\n-inline istream& operator>>(istream& i, const imanip<TP>& m)\n-{ return (*m._f)( i, m._a); }\n-\n-//-----------------------------------------------------------------------------\n-//\tOutput-Stream Manipulators\n-//-----------------------------------------------------------------------------\n-//\n-template<class TP> class omanip; \n-\n-template<class TP> class oapp {\n-    ostream& (*_f)(ostream&, TP);\n-public: \n-    oapp(ostream& (*f)(ostream&,TP)) : _f(f) {}\n-    //\n-    omanip<TP> operator()(TP a)\n-      { return omanip<TP>(_f, a); }\n-};\n-\n-template <class TP>\n-inline ostream& operator<<(ostream&, const omanip<TP>&);\n-\n-template <class TP> class omanip {\n-    ostream& (*_f)(ostream&, TP);\n-    TP _a;\n-public:\n-    omanip(ostream& (*f)(ostream&, TP), TP a) : _f(f), _a(a) {}\n-    //\n-    friend\n-      ostream& operator<< <>(ostream& o, const omanip<TP>& m);\n-};\n-\n-template <class TP>\n-inline ostream& operator<<(ostream& o, const omanip<TP>& m)\n-{ return (*m._f)(o, m._a); }\n-\n-//-----------------------------------------------------------------------------\n-//\tAvailable Manipulators\n-//-----------------------------------------------------------------------------\n-\n-//\n-// Macro to define an iomanip function, with one argument\n-// The underlying function is `__iomanip_<name>' \n-//\n-#define __DEFINE_IOMANIP_FN1(type,param,function)         \\\n-\textern ios& __iomanip_##function (ios&, param); \\\n-\tinline type<param> function (param n)           \\\n-\t\t        { return type<param> (__iomanip_##function, n); }\n-\n-__DEFINE_IOMANIP_FN1( smanip, int, setbase)\n-__DEFINE_IOMANIP_FN1( smanip, int, setfill)\n-__DEFINE_IOMANIP_FN1( smanip, int, setprecision)\n-__DEFINE_IOMANIP_FN1( smanip, int, setw)\n-\n-__DEFINE_IOMANIP_FN1( smanip, ios::fmtflags, resetiosflags)\n-__DEFINE_IOMANIP_FN1( smanip, ios::fmtflags, setiosflags)\n-} // extern \"C++\"\n-\n-#endif /*!_IOMANIP_H*/"}, {"sha": "087715b349b8a4aed5850749f8395ff43eb6a538", "filename": "libio/iopadn.c", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiopadn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiopadn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiopadn.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,70 +0,0 @@\n-/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-\n-#define PADSIZE 16\n-static char const blanks[PADSIZE] =\n-{' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '};\n-static char const zeroes[PADSIZE] =\n-{'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'};\n-\n-_IO_ssize_t\n-_IO_padn (fp, pad, count)\n-      _IO_FILE *fp;\n-      int pad;\n-      _IO_ssize_t count;\n-{\n-  char padbuf[PADSIZE];\n-  const char *padptr;\n-  int i;\n-  _IO_size_t written = 0;\n-  _IO_size_t w;\n-\n-  if (pad == ' ')\n-    padptr = blanks;\n-  else if (pad == '0')\n-    padptr = zeroes;\n-  else\n-    {\n-      for (i = PADSIZE; --i >= 0; )\n-\tpadbuf[i] = pad;\n-      padptr = padbuf;\n-    }\n-  for (i = count; i >= PADSIZE; i -= PADSIZE)\n-    {\n-      w = _IO_sputn (fp, padptr, PADSIZE);\n-      written += w;\n-      if (w != PADSIZE)\n-\treturn written;\n-    }\n-\n-  if (i > 0)\n-    {\n-      w = _IO_sputn (fp, padptr, i);\n-      written += w;\n-    }\n-  return written;\n-}"}, {"sha": "7ca72b0bb60b18fd053583d49f63806ba63cd532", "filename": "libio/ioperror.c", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioperror.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,22 +0,0 @@\n-#include \"libioP.h\"\n-#include <errno.h>\n-#include <string.h>\n-#ifndef errno\n-extern int errno;\n-#endif\n-\n-#ifndef _IO_strerror\n-extern char* _IO_strerror __P((int));\n-#endif\n-\n-void\n-_IO_perror (s)\n-     const char *s;\n-{\n-  char *error = _IO_strerror (errno);\n-\n-  if (s != NULL && *s != '\\0')\n-    _IO_fprintf (_IO_stderr, \"%s:\", s);\n-\n-  _IO_fprintf (_IO_stderr, \"%s\\n\", error ? error : \"\");\n-}"}, {"sha": "58f97495c11b806ce7fa9d125468867100dc0b7d", "filename": "libio/iopopen.c", "status": "removed", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiopopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiopopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiopopen.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,248 +0,0 @@\n-/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-   Written by Per Bothner <bothner@cygnus.com>.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#if _IO_HAVE_SYS_WAIT\n-#include <signal.h>\n-#include <unistd.h>\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#endif\n-#ifdef _LIBC\n-# include <unistd.h>\n-#endif\n-#include <sys/types.h>\n-#include <sys/wait.h>\n-\n-#ifndef _IO_fork\n-#define _IO_fork vfork /* defined in libiberty, if needed */\n-extern _IO_pid_t _IO_fork __P ((void));\n-#endif\n-\n-#endif /* _IO_HAVE_SYS_WAIT */\n-\n-#ifndef _IO_pipe\n-#define _IO_pipe pipe\n-extern int _IO_pipe __P ((int des[2]));\n-#endif\n-\n-#ifndef _IO_dup2\n-#define _IO_dup2 dup2\n-extern int _IO_dup2 __P ((int fd, int fd2));\n-#endif\n-\n-#ifndef _IO_waitpid\n-#define _IO_waitpid waitpid\n-#endif\n-\n-#ifndef _IO_execl\n-#define _IO_execl execl\n-#endif\n-#ifndef _IO__exit\n-#define _IO__exit _exit\n-#endif\n-\n-#ifndef _IO_close\n-#define _IO_close close\n-#endif\n-\n-struct _IO_proc_file\n-{\n-  struct _IO_FILE_plus file;\n-  /* Following fields must match those in class procbuf (procbuf.h) */\n-  _IO_pid_t pid;\n-  struct _IO_proc_file *next;\n-};\n-typedef struct _IO_proc_file _IO_proc_file;\n-\n-static struct _IO_proc_file *proc_file_chain = NULL;\n-\n-_IO_FILE *\n-_IO_proc_open (fp, command, mode)\n-     _IO_FILE *fp;\n-     const char *command;\n-     const char *mode;\n-{\n-#if _IO_HAVE_SYS_WAIT\n-  volatile int read_or_write;\n-  volatile int parent_end, child_end;\n-  int pipe_fds[2];\n-  _IO_pid_t child_pid;\n-  if (_IO_file_is_open (fp))\n-    return NULL;\n-  if (_IO_pipe (pipe_fds) < 0)\n-    return NULL;\n-  if (mode[0] == 'r')\n-    {\n-      parent_end = pipe_fds[0];\n-      child_end = pipe_fds[1];\n-      read_or_write = _IO_NO_WRITES;\n-    }\n-  else\n-    {\n-      parent_end = pipe_fds[1];\n-      child_end = pipe_fds[0];\n-      read_or_write = _IO_NO_READS;\n-    }\n-  ((_IO_proc_file *) fp)->pid = child_pid = _IO_fork ();\n-  if (child_pid == 0)\n-    {\n-      int child_std_end = mode[0] == 'r' ? 1 : 0;\n-      _IO_close (parent_end);\n-      if (child_end != child_std_end)\n-\t{\n-\t  _IO_dup2 (child_end, child_std_end);\n-\t  _IO_close (child_end);\n-\t}\n-      /* POSIX.2:  \"popen() shall ensure that any streams from previous\n-         popen() calls that remain open in the parent process are closed\n-\t in the new child process.\" */\n-      while (proc_file_chain)\n-\t{\n-\t  _IO_close (_IO_fileno ((_IO_FILE *) proc_file_chain));\n-\t  proc_file_chain = proc_file_chain->next;\n-\t}\n-\n-      _IO_execl (\"/bin/sh\", \"sh\", \"-c\", command, (char *) 0);\n-      _IO__exit (127);\n-    }\n-  _IO_close (child_end);\n-  if (child_pid < 0)\n-    {\n-      _IO_close (parent_end);\n-      return NULL;\n-    }\n-  _IO_fileno (fp) = parent_end;\n-\n-  /* Link into proc_file_chain. */\n-  ((_IO_proc_file *) fp)->next = proc_file_chain;\n-  proc_file_chain = (_IO_proc_file *) fp;\n-\n-  _IO_mask_flags (fp, read_or_write, _IO_NO_READS|_IO_NO_WRITES);\n-  return fp;\n-#else /* !_IO_HAVE_SYS_WAIT */\n-  return NULL;\n-#endif\n-}\n-\n-_IO_FILE *\n-_IO_popen (command, mode)\n-     const char *command;\n-     const char *mode;\n-{\n-  struct locked_FILE\n-  {\n-    struct _IO_proc_file fpx;\n-#ifdef _IO_MTSAFE_IO\n-    _IO_lock_t lock;\n-#endif\n-  } *new_f;\n-  _IO_FILE *fp;\n-\n-  new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));\n-  if (new_f == NULL)\n-    return NULL;\n-#ifdef _IO_MTSAFE_IO\n-  new_f->fpx.file.file._lock = &new_f->lock;\n-#endif\n-  fp = (_IO_FILE*)&new_f->fpx;\n-  _IO_init (fp, 0);\n-  _IO_JUMPS (fp) = &_IO_proc_jumps;\n-  _IO_file_init (fp);\n-#if  !_IO_UNIFIED_JUMPTABLES\n-  ((struct _IO_FILE_plus *) fp)->vtable = NULL;\n-#endif\n-  if (_IO_proc_open (fp, command, mode) != NULL)\n-    return fp;\n-  free (new_f);\n-  return NULL;\n-}\n-\n-#ifdef strong_alias\n-strong_alias (_IO_popen, popen);\n-#endif\n-\n-int\n-_IO_proc_close (fp)\n-     _IO_FILE *fp;\n-{\n-  /* This is not name-space clean. FIXME! */\n-#if _IO_HAVE_SYS_WAIT\n-  int wstatus;\n-  _IO_proc_file **ptr = &proc_file_chain;\n-  _IO_pid_t wait_pid;\n-  int status = -1;\n-\n-  /* Unlink from proc_file_chain. */\n-  for ( ; *ptr != NULL; ptr = &(*ptr)->next)\n-    {\n-      if (*ptr == (_IO_proc_file *) fp)\n-\t{\n-\t  *ptr = (*ptr)->next;\n-\t  status = 0;\n-\t  break;\n-\t}\n-    }\n-\n-  if (status < 0 || _IO_close (_IO_fileno(fp)) < 0)\n-    return -1;\n-  /* POSIX.2 Rationale:  \"Some historical implementations either block\n-     or ignore the signals SIGINT, SIGQUIT, and SIGHUP while waiting\n-     for the child process to terminate.  Since this behavior is not\n-     described in POSIX.2, such implementations are not conforming.\" */\n-  do\n-    {\n-      wait_pid = _IO_waitpid (((_IO_proc_file *) fp)->pid, &wstatus, 0);\n-    }\n-  while (wait_pid == -1 && errno == EINTR);\n-  if (wait_pid == -1)\n-    return -1;\n-  return wstatus;\n-#else /* !_IO_HAVE_SYS_WAIT */\n-  return -1;\n-#endif\n-}\n-\n-struct _IO_jump_t _IO_proc_jumps = {\n-  JUMP_INIT_DUMMY,\n-  JUMP_INIT(finish, _IO_file_finish),\n-  JUMP_INIT(overflow, _IO_file_overflow),\n-  JUMP_INIT(underflow, _IO_file_underflow),\n-  JUMP_INIT(uflow, _IO_default_uflow),\n-  JUMP_INIT(pbackfail, _IO_default_pbackfail),\n-  JUMP_INIT(xsputn, _IO_file_xsputn),\n-  JUMP_INIT(xsgetn, _IO_default_xsgetn),\n-  JUMP_INIT(seekoff, _IO_file_seekoff),\n-  JUMP_INIT(seekpos, _IO_default_seekpos),\n-  JUMP_INIT(setbuf, _IO_file_setbuf),\n-  JUMP_INIT(sync, _IO_file_sync),\n-  JUMP_INIT(doallocate, _IO_file_doallocate),\n-  JUMP_INIT(read, _IO_file_read),\n-  JUMP_INIT(write, _IO_file_write),\n-  JUMP_INIT(seek, _IO_file_seek),\n-  JUMP_INIT(close, _IO_proc_close),\n-  JUMP_INIT(stat, _IO_file_stat)\n-};"}, {"sha": "e3e0d7e75cdcd91272bddb2c5a87444fc0055a3b", "filename": "libio/ioprims.c", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioprims.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioprims.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioprims.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,80 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-/* I/O OS-level primitives.\n-   Needs to be replaced if not using Unix.\n-   Also needs to be replaced if avoiding name-space pollution\n-   (in which case read would be defined in terms of _IO_read,\n-   rather than vice versa). */\n-\n-#include \"libioP.h\"\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <unistd.h>\n-\n-#ifdef TODO\n-/* Add open, isatty */\n-#endif\n-\n-_IO_ssize_t\n-_IO_read (fildes, buf, nbyte)\n-     int fildes;\n-     void *buf;\n-     _IO_size_t nbyte;\n-{\n-  return read (fildes, buf, nbyte);\n-}\n-\n-_IO_ssize_t\n-_IO_write (fildes, buf, nbyte)\n-     int fildes;\n-     const void *buf;\n-     _IO_size_t nbyte;\n-{\n-  return write (fildes, buf, nbyte);\n-}\n-\n-_IO_off_t\n-_IO_lseek (fildes, offset, whence)\n-     int fildes;\n-     _IO_off_t offset;\n-     int whence;\n-{\n-  return lseek (fildes, offset, whence);\n-}\n-\n-int\n-_IO_close (fildes)\n-     int fildes;\n-{\n-  return close (fildes);\n-}\n-\n-int\n-_IO_fstat (fildes, buf)\n-     int fildes;\n-     struct stat *buf;\n-{\n-  return fstat (fildes, buf);\n-}"}, {"sha": "0b99c2a6637f1c64a7f83b38647b8446ef2d1754", "filename": "libio/ioprintf.c", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioprintf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,47 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#include \"libioP.h\"\n-\n-#ifdef __STDC__\n-#include <stdarg.h>\n-#else\n-#include <varargs.h>\n-#endif\n-\n-int\n-_IO_printf\n-#ifdef __STDC__\n-  (const char* format, ...)\n-#else\n-(format, va_alist) char *format; va_dcl\n-#endif\n-{\n-  int ret;\n-  va_list args;\n-  _IO_va_start(args, format);\n-  ret = _IO_vfprintf(_IO_stdout, format, args);\n-  va_end(args);\n-  return ret;\n-}"}, {"sha": "38a3ec9a00b77554443473592c3d0009108a38a2", "filename": "libio/ioputc.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioputc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioputc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioputc.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,44 +0,0 @@\n-/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Library General Public License as\n-   published by the Free Software Foundation; either version 2 of the\n-   License, or (at your option) any later version.\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Library General Public License for more details.\n-\n-   You should have received a copy of the GNU Library General Public\n-   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n-   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n-\n-#include \"libioP.h\"\n-#include \"stdio.h\"\n-\n-#undef _IO_putc\n-\n-int\n-_IO_putc (c, fp)\n-     int c;\n-     _IO_FILE *fp;\n-{\n-  int result;\n-  CHECK_FILE (fp, EOF);\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  result = _IO_putc_unlocked (c, fp);\n-  _IO_cleanup_region_end (1);\n-  return result;\n-}\n-\n-#undef putc\n-\n-#ifdef weak_alias\n-weak_alias (_IO_putc, putc)\n-#elif defined(_G_STDIO_USES_LIBIO) && defined(_G_HAVE_WEAK_SYMBOL)\n-int putc (int, _IO_FILE *) __attribute__ ((weak, alias(\"_IO_putc\")));\n-#endif"}, {"sha": "ab5e6aaa4cc95aa490a93828b6a40df6d4d51918", "filename": "libio/ioputs.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioputs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioputs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioputs.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,49 +0,0 @@\n-/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include <string.h>\n-\n-int\n-_IO_puts (str)\n-     const char *str;\n-{\n-  int result;\n-  _IO_size_t len = strlen (str);\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t    _IO_stdout);\n-  _IO_flockfile (_IO_stdout);\n-  if (_IO_sputn (_IO_stdout, str, len) == len\n-      && _IO_putc_unlocked ('\\n', _IO_stdout) != EOF)\n-    result = len + 1;\n-  else\n-    result = EOF;\n-  _IO_cleanup_region_end (1);\n-  return result;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_puts, puts)\n-#endif"}, {"sha": "405d1e2eb0f72da206f0007441a4cee07ac0659b", "filename": "libio/ioscanf.c", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioscanf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioscanf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioscanf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,47 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#include \"libioP.h\"\n-\n-#ifdef __STDC__\n-#include <stdarg.h>\n-#else\n-#include <varargs.h>\n-#endif\n-\n-int\n-_IO_scanf\n-#ifdef __STDC__\n-  (const char* format, ...)\n-#else\n-(format, va_alist) char *format; va_dcl\n-#endif\n-{\n-  int ret;\n-  va_list args;\n-  _IO_va_start(args, format);\n-  ret = _IO_vfscanf(_IO_stdin, format, args, NULL);\n-  va_end(args);\n-  return ret;\n-}"}, {"sha": "b1c4729b3d1df3532f33c1617f26022a1b09b64f", "filename": "libio/ioseekoff.c", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioseekoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioseekoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioseekoff.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,54 +0,0 @@\n-/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include <libioP.h>\n-\n-_IO_pos_t\n-_IO_seekoff (fp, offset, dir, mode)\n-     _IO_FILE *fp;\n-     _IO_off_t offset;\n-     int dir;\n-     int mode;\n-{\n-  _IO_pos_t retval;\n-\n-  /* If we have a backup buffer, get rid of it, since the __seekoff\n-     callback may not know to do the right thing about it.\n-     This may be over-kill, but it'll do for now. TODO */\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-\n-\n-  if (_IO_have_backup (fp))\n-    {\n-      if (dir == _IO_seek_cur && _IO_in_backup (fp))\n-\toffset -= fp->_IO_read_end - fp->_IO_read_ptr;\n-      _IO_free_backup_area (fp);\n-    }\n-  retval = _IO_SEEKOFF (fp, offset, dir, mode);\n-\n-  _IO_cleanup_region_end (1);\n-  return retval;\n-}"}, {"sha": "2ce0c2224ec77f0468892715d093f31036418e14", "filename": "libio/ioseekpos.c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioseekpos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioseekpos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioseekpos.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,48 +0,0 @@\n-/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include <libioP.h>\n-\n-_IO_pos_t\n-_IO_seekpos (fp, pos, mode)\n-     _IO_FILE *fp;\n-     _IO_pos_t pos;\n-     int mode;\n-{\n-  _IO_pos_t retval;\n-\n-  /* If we have a backup buffer, get rid of it, since the __seekoff\n-     callback may not know to do the right thing about it.\n-     This may be over-kill, but it'll do for now. TODO */\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-\n-  if (_IO_have_backup (fp))\n-    _IO_free_backup_area (fp);\n-  retval = _IO_SEEKPOS (fp, pos, mode);\n-\n-  _IO_cleanup_region_end (1);\n-  return retval;\n-}"}, {"sha": "f140a9ad046eb68daabb015bdcd9754d1113bb94", "filename": "libio/iosetbuffer.c", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiosetbuffer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiosetbuffer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiosetbuffer.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,46 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-\n-void\n-_IO_setbuffer (fp, buf, size)\n-     _IO_FILE *fp;\n-     char *buf;\n-     _IO_size_t size;\n-{\n-  CHECK_FILE (fp, );\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  fp->_flags &= ~_IO_LINE_BUF;\n-  if (!buf)\n-    size = 0;\n-  (void) _IO_SETBUF (fp, buf, size);\n-  _IO_cleanup_region_end (1);\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_setbuffer, setbuffer)\n-#endif"}, {"sha": "65eeea51a6faa6fce20eeafc4ff64b8dc069f6ab", "filename": "libio/iosetvbuf.c", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiosetvbuf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiosetvbuf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiosetvbuf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,100 +0,0 @@\n-/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-\n-#define _IOFBF 0 /* Fully buffered. */\n-#define _IOLBF 1 /* Line buffered. */\n-#define _IONBF 2 /* No buffering. */\n-\n-int\n-_IO_setvbuf (fp, buf, mode, size)\n-     _IO_FILE *fp;\n-     char *buf;\n-     int mode;\n-     _IO_size_t size;\n-{\n-  int result;\n-  CHECK_FILE (fp, EOF);\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  switch (mode)\n-    {\n-    case _IOFBF:\n-      fp->_IO_file_flags &= ~_IO_LINE_BUF|_IO_UNBUFFERED;\n-      if (buf == NULL)\n-\t{\n-\t  if (fp->_IO_buf_base == NULL)\n-\t    {\n-\t      /* There is no flag to distinguish between \"fully buffered\n-\t\t mode has been explicitly set\" as opposed to \"line\n-\t\t buffering has not been explicitly set\".  In both\n-\t\t cases, _IO_LINE_BUF is off.  If this is a tty, and\n-\t\t _IO_filedoalloc later gets called, it cannot know if\n-\t\t it should set the _IO_LINE_BUF flag (because that is\n-\t\t the default), or not (because we have explicitly asked\n-\t\t for fully buffered mode).  So we make sure a buffer\n-\t\t gets allocated now, and explicitly turn off line\n-\t\t buffering.\n-\n-\t\t A possibly cleaner alternative would be to add an\n-\t\t extra flag, but then flags are a finite resource.  */\n-\t      if (_IO_DOALLOCATE (fp) < 0)\n-\t\t{\n-\t\t  result = EOF;\n-\t\t  goto unlock_return;\n-\t\t}\n-\t      fp->_IO_file_flags &= ~_IO_LINE_BUF;\n-\t    }\n-\t  result = 0;\n-\t  goto unlock_return;\n-\t}\n-      break;\n-    case _IOLBF:\n-      fp->_IO_file_flags &= ~_IO_UNBUFFERED;\n-      fp->_IO_file_flags |= _IO_LINE_BUF;\n-      if (buf == NULL)\n-\t{\n-\t  result = 0;\n-\t  goto unlock_return;\n-\t}\n-      break;\n-    case _IONBF:\n-      buf = NULL;\n-      size = 0;\n-      break;\n-    default:\n-      result = EOF;\n-      goto unlock_return;\n-    }\n-  result = _IO_SETBUF (fp, buf, size) == NULL ? EOF : 0;\n-unlock_return:\n-  _IO_cleanup_region_end (1);\n-  return result;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_setvbuf, setvbuf)\n-#endif"}, {"sha": "704a6dbd72d949efcaa8c73f9df849bbb9f6b7c8", "filename": "libio/iosprintf.c", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiosprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiosprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiosprintf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,50 +0,0 @@\n-/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-\n-#ifdef __STDC__\n-#include <stdarg.h>\n-#else\n-#include <varargs.h>\n-#endif\n-\n-int\n-#ifdef __STDC__\n-_IO_sprintf (char *string, const char* format, ...)\n-#else\n-_IO_sprintf (string, format, va_alist)\n-     char *string;\n-     char *format;\n-     va_dcl\n-#endif\n-{\n-  int ret;\n-  va_list args;\n-  _IO_va_start (args, format);\n-  ret = _IO_vsprintf (string, format, args);\n-  va_end (args);\n-  return ret;\n-}"}, {"sha": "58868778c48ebfd8d3033a28442768d3deed79e0", "filename": "libio/iosscanf.c", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiosscanf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiosscanf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiosscanf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,47 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#include \"libioP.h\"\n-\n-#ifdef __STDC__\n-#include <stdarg.h>\n-#else\n-#include <varargs.h>\n-#endif\n-\n-int\n-_IO_sscanf\n-#ifdef __STDC__\n-  (const char * string, const char* format, ...)\n-#else\n-(string, format, va_alist) char *string; char *format; va_dcl\n-#endif\n-{\n-  int ret;\n-  va_list args;\n-  _IO_va_start(args, format);\n-  ret = _IO_vsscanf(string, format, args);\n-  va_end(args);\n-  return ret;\n-}"}, {"sha": "9ed47a4654a44c9fd015f038a152971b13ecb562", "filename": "libio/iostdio.h", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiostdio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiostdio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiostdio.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,114 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-/* This file defines a stdio-like environment, except that it avoid\n-   link-time name clashes with an existing stdio.\n-   It allows for testing the libio using stdio-using programs\n-   with an incompatible libc.a.\n-   It is not predantically correct - e.g. some macros are used\n-   that may evaluate a stream argument more than once.  */\n-\n-#ifndef _IOSTDIO_H\n-#define _IOSTDIO_H\n-\n-#include \"iolibio.h\"\n-\n-typedef _IO_FILE FILE;\n-#ifndef EOF\n-#define EOF (-1)\n-#endif\n-#ifndef BUFSIZ\n-#define BUFSIZ 1024\n-#endif\n-\n-/* #define size_t, fpos_t L_tmpname TMP_MAX */\n-\n-#define _IOFBF 0 /* Fully buffered. */\n-#define _IOLBF 1 /* Line buffered. */\n-#define _IONBF 2 /* No buffering. */\n-\n-#define SEEK_SET 0\n-#define SEEK_CUR 1\n-#define SEEK_END 2\n-\n-#define stdin _IO_stdin\n-#define stdout _IO_stdout\n-#define stderr _IO_stderr\n-\n-#define getc(_fp) _IO_getc(_fp)\n-#define putc(_ch, _fp) _IO_putc(_ch, _fp)\n-\n-#define clearerr _IO_clearerr\n-#define fclose _IO_fclose\n-#define feof _IO_feof\n-#define ferror _IO_ferror\n-#define fflush _IO_fflush\n-#define fgetc(__fp) _IO_getc(_fp)\n-#define fgetpos _IO_fgetpos\n-#define fgets _IO_fgets\n-#define fopen _IO_fopen\n-#define fprintf _IO_fprintf\n-#define fputc(_ch, _fp) _IO_putc(_ch, _fp)\n-#define fputs _IO_fputs\n-#define fread _IO_fread\n-#define freopen _IO_freopen\n-#define fscanf _IO_fscanf\n-#define fseek _IO_fseek\n-#define fsetpos _IO_fsetpos\n-#define ftell _IO_ftell\n-#define fwrite _IO_fwrite\n-#define gets _IO_gets\n-#define perror _IO_perror\n-#define printf _IO_printf\n-#define puts _IO_puts\n-#define rewind _IO_rewind\n-#define scanf _IO_scanf\n-#define setbuf _IO_setbuf\n-#define setbuffer _IO_setbuffer\n-#define setvbuf _IO_setvbuf\n-#define sprintf _IO_sprintf\n-#define sscanf _IO_sscanf\n-#define ungetc _IO_ungetc\n-#define vfprintf _IO_vfprintf\n-#define vprintf(__fmt, __args) vfprintf(stdout, __fmt, __args)\n-#define vsprintf _IO_vsprintf\n-\n-#if 0\n-/* We can use the libc versions of these, since they don't pass FILE*s. */\n-#define remove ??? __P((const char*))\n-#define rename ??? __P((const char* _old, const char* _new))\n-#define tmpfile ??? __P((void))\n-#define tmpnam ??? __P((char*))\n-#endif\n-\n-#if !defined(__STRICT_ANSI__) || defined(_POSIX_SOURCE)\n-#define fdopen _IO_fdopen\n-#define fileno _IO_fileno\n-#define popen _IO_popen\n-#define pclose _IO_pclose\n-#define setbuf _IO_setbuf\n-#define setlinebuf _IO_setlinebuf\n-#endif\n-\n-#endif /* _IOSTDIO_H */"}, {"sha": "ae1db1afd9c9f8583f63d8cf9e440c95eef19b2d", "filename": "libio/iostream.cc", "status": "removed", "additions": 0, "deletions": 1062, "changes": 1062, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiostream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiostream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiostream.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,1062 +0,0 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-   Copyright (C) 1993, 1997, 2000 Free Software Foundation, Inc.\n-\n-   This file is part of the GNU IO Library.  This library is free\n-   software; you can redistribute it and/or modify it under the\n-   terms of the GNU General Public License as published by the\n-   Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n-\n-   This library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to the Free\n-   Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n-   USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does not cause\n-   the resulting executable to be covered by the GNU General Public License.\n-   This exception does not however invalidate any other reasons why\n-   the executable file might be covered by the GNU General Public License. */\n-\n-/* Written by Per Bothner (bothner@cygnus.com). */\n-\n-#ifdef __GNUC__\n-#pragma implementation\n-#endif\n-#define _STREAM_COMPAT\n-#include <iostream.h>\n-#include \"libioP.h\"\n-#include <stdio.h>  /* Needed for sprintf */\n-#include <ctype.h>\n-#include <string.h>\n-#include <limits.h>\n-\n-#if _G_HAVE_PRINTF_FP\n-#include <printf.h>\n-extern \"C\" int __printf_fp (_IO_FILE *, const struct printf_info *,\n-\t\t\t    const void *const *);\n-#else\n-#include \"floatio.h\"\n-# ifndef _IO_USE_DTOA\n-int __cvt_double(double number, register int prec, int flags, int *signp,\n-                 int fmtch, char *startp, char *endp);\n-# endif\n-#endif\n-\n-#define\tBUF\t\t(MAXEXP+MAXFRACT+1)\t/* + decimal point */\n-\n-//#define isspace(ch) ((ch)==' ' || (ch)=='\\t' || (ch)=='\\n')\n-\n-istream::istream(streambuf *sb, ostream* tied)\n-{\n-  init (sb, tied);\n-  _gcount = 0;\n-}\n-\n-int skip_ws(streambuf* sb)\n-{\n-    int ch;\n-    for (;;) {\n-\tch = sb->sbumpc();\n-\tif (ch == EOF || !isspace(ch))\n-\t    return ch;\n-    }\n-}\n-\n-istream& istream::get(char& c)\n-{\n-    if (ipfx1()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\tint ch = _strbuf->sbumpc();\n-\tif (ch == EOF) {\n-\t  set(ios::eofbit|ios::failbit);\n-\t  _gcount = 0;\n-\t}\n-\telse {\n-\t  c = (char)ch;\n-\t  _gcount = 1;\n-\t}\n-\tisfx();\n-\t_IO_cleanup_region_end (0);\n-    }\n-    else\n-      _gcount = 0;\n-    return *this;\n-}\n-\n-int istream::peek()\n-{\n-  if (!good())\n-    return EOF;\n-  if (_tie && rdbuf()->in_avail() == 0)\n-    _tie->flush();\n-  int ch = _strbuf->sgetc();\n-  if (ch == EOF)\n-    set(ios::eofbit);\n-  return ch;\n-}\n-\n-istream& istream::ignore(int n /* = 1 */, int delim /* = EOF */)\n-{\n-    _gcount = 0;\n-    if (ipfx1()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\tregister streambuf* sb = _strbuf;\n-\tif (delim == EOF) {\n-\t    _gcount = sb->ignore(n);\n-\t    goto unlock;\n-\t}\n-\tfor (;;) {\n-#if 0\n-\t    if (n != MAXINT) // FIXME\n-#endif\n-\t    if (--n < 0)\n-\t\tbreak;\n-\t    int ch = sb->sbumpc();\n-\t    if (ch == EOF) {\n-\t\tset(ios::eofbit|ios::failbit);\n-\t\tbreak;\n-\t    }\n-\t    _gcount++;\n-\t    if (ch == delim)\n-\t\tbreak;\n-\t}\n-    unlock:\n-\tisfx();\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return *this;\n-}\n-\n-istream& istream::read(char *s, streamsize n)\n-{\n-    if (ipfx1()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\t_gcount = _strbuf->sgetn(s, n);\n-\tif (_gcount != n)\n-\t    set(ios::failbit|ios::eofbit);\n-\tisfx();\n-\t_IO_cleanup_region_end (0);\n-    }\n-    else\n-      _gcount = 0;\n-    return *this;\n-}\n-\n-int\n-istream::sync ()\n-{\n-  streambuf *sb = rdbuf ();\n-  if (sb == NULL)\n-    return EOF;\n-  if (sb->sync ()) // Later: pubsync\n-    {\n-      setstate (ios::badbit);\n-      return EOF;\n-    }\n-  else\n-    return 0;\n-}\n-\n-istream& istream::seekg(streampos pos)\n-{\n-    pos = _strbuf->pubseekpos(pos, ios::in);\n-    if (pos == streampos(EOF))\n-\tset(ios::badbit);\n-    return *this;\n-}\n-\n-istream& istream::seekg(streamoff off, _seek_dir dir)\n-{\n-  streampos pos = _IO_seekoff (_strbuf, off, (int) dir, _IOS_INPUT);\n-  if (pos == streampos(EOF))\n-    set(ios::badbit);\n-  return *this;\n-}\n-\n-streampos istream::tellg()\n-{\n-#if 0\n-    streampos pos = _strbuf->pubseekoff(0, ios::cur, ios::in);\n-#else\n-    streampos pos = _IO_seekoff (_strbuf, 0, _IO_seek_cur, _IOS_INPUT);\n-#endif\n-    if (pos == streampos(EOF))\n-\tset(ios::badbit);\n-    return pos;\n-}\n-\n-istream& istream::operator>>(char& c)\n-{\n-    if (ipfx0()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\tint ch = _strbuf->sbumpc();\n-\tif (ch == EOF)\n-\t    set(ios::eofbit|ios::failbit);\n-\telse\n-\t    c = (char)ch;\n-\tisfx();\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return *this;\n-}\n-\n-istream&\n-istream::operator>> (char* ptr)\n-{\n-  register char *p = ptr;\n-  int w = width(0);\n-  if (ipfx0())\n-    {\n-      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t_strbuf);\n-      register streambuf* sb = _strbuf;\n-      for (;;)\n-\t{\n-\t  int ch = sb->sbumpc();\n-\t  if (ch == EOF)\n-\t    {\n-\t      set(ios::eofbit);\n-\t      break;\n-\t    }\n-\t  else if (isspace(ch) || w == 1)\n-\t    {\n-\t      sb->sputbackc(ch);\n-\t      break;\n-\t    }\n-\t  else *p++ = ch;\n-\t  w--;\n-\t}\n-      if (p == ptr)\n-\tset(ios::failbit);\n-      isfx();\n-      _IO_cleanup_region_end (0);\n-    }\n-  *p = '\\0';\n-  return *this;\n-}\n-\n-#if defined(__GNUC__) && !defined(__STRICT_ANSI__)\n-#define LONGEST long long\n-#else\n-#define LONGEST long\n-#endif\n-\n-static int read_int(istream& stream, unsigned LONGEST& val, int& neg)\n-{\n-    if (!stream.ipfx0())\n-      return 0;\n-    int retval;\n-    _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t      stream._strbuf);\n-    register streambuf* sb = stream.rdbuf();\n-    int base = 10;\n-    int ndigits = 0;\n-    register int ch = skip_ws(sb);\n-    if (ch == EOF)\n-\tgoto eof_fail;\n-    neg = 0;\n-    if (ch == '+') {\n-\tch = skip_ws(sb);\n-    }\n-    else if (ch == '-') {\n-\tneg = 1;\n-\tch = skip_ws(sb);\n-    }\n-    if (ch == EOF) goto eof_fail;\n-    if (!(stream.flags() & ios::basefield)) {\n-\tif (ch == '0') {\n-\t    ch = sb->sbumpc();\n-\t    if (ch == EOF) {\n-\t\tval = 0;\n-\t\tgoto unlock;\n-\t    }\n-\t    if (ch == 'x' || ch == 'X') {\n-\t\tbase = 16;\n-\t\tch = sb->sbumpc();\n-\t\tif (ch == EOF) goto eof_fail;\n-\t    }\n-\t    else {\n-\t\tsb->sputbackc(ch);\n-\t\tbase = 8;\n-\t\tch = '0';\n-\t    }\n-\t}\n-    }\n-    else if ((stream.flags() & ios::basefield) == ios::hex)\n-\tbase = 16;\n-    else if ((stream.flags() & ios::basefield) == ios::oct)\n-\tbase = 8;\n-    val = 0;\n-    for (;;) {\n-\tif (ch == EOF)\n-\t    break;\n-\tint digit;\n-\tif (ch >= '0' && ch <= '9')\n-\t    digit = ch - '0';\n-\telse if (ch >= 'A' && ch <= 'F')\n-\t    digit = ch - 'A' + 10;\n-\telse if (ch >= 'a' && ch <= 'f')\n-\t    digit = ch - 'a' + 10;\n-\telse\n-\t    digit = 999;\n-\tif (digit >= base) {\n-\t    sb->sputbackc(ch);\n-\t    if (ndigits == 0)\n-\t\tgoto fail;\n-\t    else\n-\t\tgoto unlock;\n-\t}\n-\tndigits++;\n-\tval = base * val + digit;\n-\tch = sb->sbumpc();\n-    }\n-  unlock:\n-    retval = 1;\n-    goto out;\n-  fail:\n-    stream.set(ios::failbit);\n-    retval = 0;\n-    goto out;\n-  eof_fail:\n-    stream.set(ios::failbit|ios::eofbit);\n-    retval = 0;\n-  out:\n-    stream.isfx();\n-    _IO_cleanup_region_end (0);\n-    return retval;\n-}\n-\n-#define READ_INT(TYPE) \\\n-istream& istream::operator>>(TYPE& i)\\\n-{\\\n-    unsigned LONGEST val; int neg;\\\n-    if (read_int(*this, val, neg)) {\\\n-\tif (neg) val = -val;\\\n-\ti = (TYPE)val;\\\n-    }\\\n-    return *this;\\\n-}\n-\n-READ_INT(short)\n-READ_INT(unsigned short)\n-READ_INT(int)\n-READ_INT(unsigned int)\n-READ_INT(long)\n-READ_INT(unsigned long)\n-#if defined(__GNUC__) && !defined(__STRICT_ANSI__)\n-READ_INT(long long)\n-READ_INT(unsigned long long)\n-#endif\n-#if _G_HAVE_BOOL\n-READ_INT(bool)\n-#endif\n-\n-istream& istream::operator>>(long double& x)\n-{\n-    if (ipfx0())\n-      {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-#if _G_HAVE_LONG_DOUBLE_IO\n-\tscan(\"%Lg\", &x);\n-#else\n-\tdouble y;\n-\tscan(\"%lg\", &y);\n-\tx = y;\n-#endif\n-\tisfx();\n-\t_IO_cleanup_region_end (0);\n-      }\n-    return *this;\n-}\n-\n-istream& istream::operator>>(double& x)\n-{\n-    if (ipfx0())\n-      {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\tscan(\"%lg\", &x);\n-\tisfx();\n-\t_IO_cleanup_region_end (0);\n-      }\n-    return *this;\n-}\n-\n-istream& istream::operator>>(float& x)\n-{\n-    if (ipfx0())\n-      {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\tscan(\"%g\", &x);\n-\tisfx();\n-\t_IO_cleanup_region_end (0);\n-      }\n-    return *this;\n-}\n-\n-istream& istream::operator>>(register streambuf* sbuf)\n-{\n-    if (ipfx0()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\tregister streambuf* inbuf = rdbuf();\n-\t// FIXME: Should optimize!\n-\tfor (;;) {\n-\t    register int ch = inbuf->sbumpc();\n-\t    if (ch == EOF) {\n-\t\tset(ios::eofbit);\n-\t\tbreak;\n-\t    }\n-\t    if (sbuf->sputc(ch) == EOF) {\n-\t\tset(ios::failbit);\n-\t\tbreak;\n-\t    }\n-\t}\n-\tisfx();\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return *this;\n-}\n-\n-ostream& ostream::operator<<(char c)\n-{\n-    if (opfx()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-#if 1\n-\t// This is what the cfront implementation does.\n-\tif (_strbuf->sputc(c) == EOF) {\n-\t    set(ios::badbit);\n-\t    goto failed;\n-\t}\n-#else\n-\t// This is what cfront documentation and current ANSI drafts say.\n-\tint w = width(0);\n-\tchar fill_char = fill();\n-\tregister int padding = w > 0 ? w - 1 : 0;\n-\tregister streambuf *sb = _strbuf;\n-\tif (!(flags() & ios::left) && padding) // Default adjustment.\n-\t    if (_IO_padn(sb, fill_char, padding) < padding) {\n-\t      set(ios::badbit);\n-\t      goto failed;\n-\t    }\n-\tif (sb->sputc(c) == EOF) {\n-\t  set(ios::badbit);\n-\t  goto failed;\n-        }\n-\tif (flags() & ios::left && padding) // Left adjustment.\n-\t    if (_IO_padn(sb, fill_char, padding) < padding)\n-\t      set(ios::badbit);\n-#endif\n-       failed:\n-\tosfx();\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return *this;\n-}\n-\n-/* Write VAL on STREAM.\n-   If SIGN<0, val is the absolute value of a negative number.\n-   If SIGN>0, val is a signed non-negative number.\n-   If SIGN==0, val is unsigned. */\n-\n-static void write_int(ostream& stream, unsigned LONGEST val, int sign)\n-{\n-#define WRITE_BUF_SIZE (10 + sizeof(unsigned LONGEST) * 3)\n-    char buf[WRITE_BUF_SIZE];\n-    register char *buf_ptr = buf+WRITE_BUF_SIZE; // End of buf.\n-    const char *show_base = \"\";\n-    int show_base_len = 0;\n-    int show_pos = 0; // If 1, print a '+'.\n-\n-    // Now do the actual conversion, placing the result at the *end* of buf.\n-    // Note that we use separate code for decimal, octal, and hex,\n-    // so we can divide by optimizable constants.\n-    if ((stream.flags() & ios::basefield) == ios::oct) { // Octal\n-\tdo {\n-\t    *--buf_ptr = (val & 7) + '0';\n-\t    val = val >> 3;\n-\t} while (val != 0);\n-\tif ((stream.flags() & ios::showbase) && (*buf_ptr != '0'))\n-\t    *--buf_ptr = '0';\n-    }\n-    else if ((stream.flags() & ios::basefield) == ios::hex) { // Hex\n-\tconst char *xdigs = (stream.flags() & ios::uppercase) ? \"0123456789ABCDEF0X\"\n-\t    : \"0123456789abcdef0x\";\n-\tdo {\n-\t    *--buf_ptr = xdigs[val & 15];\n-\t    val = val >> 4;\n-\t} while (val != 0);\n-\tif ((stream.flags() & ios::showbase)) {\n-\t    show_base = xdigs + 16; // Either \"0X\" or \"0x\".\n-\t    show_base_len = 2;\n-\t}\n-    }\n-    else { // Decimal\n-#if defined(__GNUC__) && !defined(__STRICT_ANSI__)\n-\t// Optimization:  Only use long long when we need to.\n-\twhile (val > UINT_MAX) {\n-\t    *--buf_ptr = (val % 10) + '0';\n-\t    val /= 10;\n-\t}\n-\t// Use more efficient (int) arithmetic for the rest.\n-\tregister unsigned int ival = (unsigned int)val;\n-#else\n-\tregister unsigned LONGEST ival = val;\n-#endif\n-\tdo {\n-\t    *--buf_ptr = (ival % 10) + '0';\n-\t    ival /= 10;\n-\t} while (ival != 0);\n-\tif (sign > 0 && (stream.flags() & ios::showpos))\n-\t    show_pos=1;\n-    }\n-\n-    int buf_len = buf+WRITE_BUF_SIZE - buf_ptr;\n-    int w = stream.width(0);\n-\n-    // Calculate padding.\n-    int len = buf_len+show_pos;\n-    if (sign < 0) len++;\n-    len += show_base_len;\n-    int padding = len > w ? 0 : w - len;\n-\n-    // Do actual output.\n-    register streambuf* sbuf = stream.rdbuf();\n-    ios::fmtflags pad_kind =\n-\tstream.flags() & (ios::left|ios::right|ios::internal);\n-    char fill_char = stream.fill();\n-    if (padding > 0\n-\t&& pad_kind != (ios::fmtflags)ios::left\n-\t&& pad_kind != (ios::fmtflags)ios::internal) // Default (right) adjust.\n-\tif (_IO_padn(sbuf, fill_char, padding) < padding)\n-\t  goto failed;\n-    if (sign < 0 || show_pos)\n-      {\n-\tchar ch = sign < 0 ? '-' : '+';\n-\tif (sbuf->sputc(ch) < 0)\n-\t  goto failed;\n-      }\n-    if (show_base_len)\n-\tif (_IO_sputn(sbuf, show_base, show_base_len) <= 0)\n-\t  goto failed;\n-    if (pad_kind == (ios::fmtflags)ios::internal && padding > 0)\n-      if (_IO_padn(sbuf, fill_char, padding) < padding)\n-\tgoto failed;\n-    if (_IO_sputn (sbuf, buf_ptr, buf_len) != buf_len)\n-      goto failed;\n-    if (pad_kind == (ios::fmtflags)ios::left && padding > 0) // Left adjustment\n-      if (_IO_padn(sbuf, fill_char, padding) < padding)\n-\tgoto failed;\n-    stream.osfx();\n-    return;\n-  failed:\n-    stream.set(ios::badbit);\n-    stream.osfx();\n-}\n-\n-ostream& ostream::operator<<(int n)\n-{\n-    if (opfx()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\tint sign = 1;\n-\tunsigned int abs_n = (unsigned)n;\n-\tif (n < 0 && (flags() & (ios::oct|ios::hex)) == 0)\n-\t    abs_n = -((unsigned)n), sign = -1;\n-\twrite_int(*this, abs_n, sign);\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return *this;\n-}\n-\n-ostream& ostream::operator<<(unsigned int n)\n-{\n-    if (opfx()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\twrite_int(*this, n, 0);\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return *this;\n-}\n-\n-\n-ostream& ostream::operator<<(long n)\n-{\n-    if (opfx()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\tint sign = 1;\n-\tunsigned long abs_n = (unsigned long)n;\n-\tif (n < 0 && (flags() & (ios::oct|ios::hex)) == 0)\n-\t    abs_n = -((unsigned long)n), sign = -1;\n-\twrite_int(*this, abs_n, sign);\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return *this;\n-}\n-\n-ostream& ostream::operator<<(unsigned long n)\n-{\n-    if (opfx()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\twrite_int(*this, n, 0);\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return *this;\n-}\n-\n-#if defined(__GNUC__) && !defined(__STRICT_ANSI__)\n-ostream& ostream::operator<<(long long n)\n-{\n-    if (opfx()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\tint sign = 1;\n-\tunsigned long long abs_n = (unsigned long long)n;\n-\tif (n < 0 && (flags() & (ios::oct|ios::hex)) == 0)\n-\t    abs_n = -((unsigned long long)n), sign = -1;\n-\twrite_int(*this, abs_n, sign);\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return *this;\n-}\n-\n-\n-ostream& ostream::operator<<(unsigned long long n)\n-{\n-    if (opfx()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\twrite_int(*this, n, 0);\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return *this;\n-}\n-#endif /*__GNUC__*/\n-\n-ostream& ostream::operator<<(double n)\n-{\n-    if (opfx()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\t// Uses __cvt_double (renamed from static cvt), in Chris Torek's\n-\t// stdio implementation.  The setup code uses the same logic\n-\t// as in __vsbprintf.C (also based on Torek's code).\n-\tint format_char;\n-\tif ((flags() & ios::floatfield) == ios::fixed)\n-\t    format_char = 'f';\n-\telse if ((flags() & ios::floatfield) == ios::scientific)\n-\t    format_char = flags() & ios::uppercase ? 'E' : 'e';\n-\telse\n-\t    format_char = flags() & ios::uppercase ? 'G' : 'g';\n-\n-\tint prec = precision();\n-\tif (prec <= 0 && !(flags() & ios::fixed))\n-\t  prec = 6; /* default */\n-\n-\t// Do actual conversion.\n-#if _G_HAVE_PRINTF_FP\n-\t{\n-\t  struct printf_info info = { /* prec: */ prec,\n-\t\t\t\t      /* width: */ width(0),\n-\t\t\t\t      /* spec: */ format_char,\n-\t\t\t\t      /* is_long_double: */ 0,\n-\t\t\t\t      /* is_short: */ 0,\n-\t\t\t\t      /* is_long: */ 0,\n-\t\t\t\t      /* alt: */ (flags() & ios::showpoint) != 0,\n-\t\t\t\t      /* space: */ 0,\n-\t\t\t\t      /* left: */ (flags() & ios::left) != 0,\n-\t\t\t\t      /* showsign: */ (flags() & ios::showpos) != 0,\n-\t\t\t\t      /* group: */ 0,\n-#if defined __GLIBC__ && __GLIBC__ >= 2\n-\t\t\t\t      /* extra: */ 0,\n-#if __GLIBC_MINOR__ >= 1\n-\t\t\t\t      /* is_char: */ 0,\n-#if __GLIBC_MINOR__ >= 2\n-\t\t\t\t      /* wide: */ 0,\n-\t\t\t\t      /* i18n: */ 0,\n-#endif\n-#endif\n-#endif\n-\t\t\t\t      /* pad: */ fill()\n-\t  };\n-\t  const void *ptr = (const void *) &n;\n-\t  if (__printf_fp (rdbuf(), &info, &ptr) < 0)\n-\t    set(ios::badbit|ios::failbit);\n-\t}\n-#elif defined  _IO_USE_DTOA\n-\tif (_IO_outfloat(n, rdbuf(), format_char, width(0),\n-\t\t\t prec, flags(),\n-\t\t\t flags() & ios::showpos ? '+' : 0,\n-\t\t\t fill()) < 0)\n-\t    set(ios::badbit|ios::failbit); // ??\n-#else\n-\tint fpprec = 0; // 'Extra' (suppressed) floating precision.\n-\tif (prec > MAXFRACT) {\n-\t    if (flags() & (ios::fixed|ios::scientific) & ios::showpos)\n-\t\tfpprec = prec - MAXFRACT;\n-\t    prec = MAXFRACT;\n-\t}\n-\tint negative;\n-\tchar buf[BUF];\n-\tint sign = '\\0';\n-\tchar *cp = buf;\n-\t*cp = 0;\n-\tint size = __cvt_double(n, prec,\n-\t\t\t\tflags() & ios::showpoint ? 0x80 : 0,\n-\t\t\t\t&negative,\n-\t\t\t\tformat_char, cp, buf + sizeof(buf));\n-\tif (negative) sign = '-';\n-\telse if (flags() & ios::showpos) sign = '+';\n-\tif (*cp == 0)\n-\t    cp++;\n-\n-\t// Calculate padding.\n-\tint fieldsize = size + fpprec;\n-\tif (sign) fieldsize++;\n-\tint padding = 0;\n-\tint w = width(0);\n-\tif (fieldsize < w)\n-\t    padding = w - fieldsize;\n-\n-\t// Do actual output.\n-\tregister streambuf* sbuf = rdbuf();\n-\tregister i;\n-\tchar fill_char = fill();\n-\tios::fmtflags pad_kind =\n-\t    flags() & (ios::left|ios::right|ios::internal);\n-\tif (pad_kind != (ios::fmtflags)ios::left // Default (right) adjust.\n-\t    && pad_kind != (ios::fmtflags)ios::internal)\n-\t    for (i = padding; --i >= 0; ) sbuf->sputc(fill_char);\n-\tif (sign)\n-\t    sbuf->sputc(sign);\n-\tif (pad_kind == (ios::fmtflags)ios::internal)\n-\t    for (i = padding; --i >= 0; ) sbuf->sputc(fill_char);\n-\n-\t// Emit the actual concented field, followed by extra zeros.\n-\t_IO_sputn (sbuf, cp, size);\n-\tfor (i = fpprec; --i >= 0; ) sbuf->sputc('0');\n-\n-\tif (pad_kind == (ios::fmtflags)ios::left) // Left adjustment\n-\t    for (i = padding; --i >= 0; ) sbuf->sputc(fill_char);\n-#endif\n-\tosfx();\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return *this;\n-}\n-\n-#if _G_HAVE_LONG_DOUBLE_IO\n-ostream& ostream::operator<<(long double n)\n-{\n-  if (opfx())\n-    {\n-      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t_strbuf);\n-      int format_char;\n-      if ((flags() & ios::floatfield) == ios::fixed)\n-\tformat_char = 'f';\n-      else if ((flags() & ios::floatfield) == ios::scientific)\n-\tformat_char = flags() & ios::uppercase ? 'E' : 'e';\n-      else\n-\tformat_char = flags() & ios::uppercase ? 'G' : 'g';\n-\n-      int prec = precision();\n-      if (prec <= 0 && !(flags() & ios::fixed))\n-\tprec = 6; /* default */\n-\n-#if _G_HAVE_PRINTF_FP\n-      // Do actual conversion.\n-      struct printf_info info = { /* prec: */ prec,\n-\t\t\t\t  /* width: */ width(0),\n-\t\t\t\t  /* spec: */ format_char,\n-\t\t\t          /* is_long_double: */ 1,\n-\t\t\t\t  /* is_short: */ 0,\n-\t\t\t\t  /* is_long: */ 0,\n-\t\t\t\t  /* alt: */ (flags() & ios::showpoint) != 0,\n-\t\t\t\t  /* space: */ 0,\n-\t\t\t\t  /* left: */ (flags() & ios::left) != 0,\n-\t\t\t\t  /* showsign: */ (flags() & ios::showpos) != 0,\n-\t\t\t\t  /* group: */ 0,\n-#if defined __GLIBC__ && __GLIBC__ >= 2\n-\t\t\t\t  /* extra: */ 0,\n-#if __GLIBC_MINOR__ >= 1\n-\t\t\t\t  /* is_char: */ 0,\n-#if __GLIBC_MINOR__ >= 2\n-\t\t\t\t  /* wide: */ 0,\n-\t\t\t\t  /* i18n: */ 0,\n-#endif\n-#endif\n-#endif\n-\t\t\t\t  /* pad: */ fill()\n-      };\n-\n-      const void *ptr = (const void *) &n;\n-\n-      if (__printf_fp (rdbuf(), &info, &ptr) < 0)\n-\tset (ios::badbit|ios::failbit);\n-#else\n-# error \"long double I/O using dtoa or cvt_double is not implemented\"\n-#endif\n-      osfx();\n-      _IO_cleanup_region_end (0);\n-    }\n-  return *this;\n-}\n-#endif\n-\n-ostream& ostream::operator<<(const char *s)\n-{\n-  if (opfx())\n-    {\n-      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t_strbuf);\n-      if (s == NULL)\n-\ts = \"(null)\";\n-      int len = strlen(s);\n-      int w = width(0);\n-// FIXME: Should we: if (w && len>w) len = w;\n-      char fill_char = fill();\n-      register streambuf *sbuf = rdbuf();\n-      register int padding = w > len ? w - len : 0;\n-      if (!(flags() & ios::left) && padding > 0) // Default adjustment.\n-\tif (_IO_padn(sbuf, fill_char, padding) != padding)\n-\t  {\n-\t    set(ios::badbit);\n-\t    goto failed;\n-\t  }\n-      if (_IO_sputn (sbuf, s, len) != len)\n-\t{\n-\t  set(ios::badbit);\n-\t  goto failed;\n-\t}\n-      if (flags() & ios::left && padding > 0) // Left adjustment.\n-\tif (_IO_padn(sbuf, fill_char, padding) != padding)\n-\t  set(ios::badbit);\n-     failed:\n-      osfx();\n-      _IO_cleanup_region_end (0);\n-    }\n-  return *this;\n-}\n-\n-#if 0\n-ostream& ostream::operator<<(const void *p)\n-{ Is in osform.cc, to avoid pulling in all of _IO_vfprintf by this file. */ }\n-#endif\n-\n-ostream& ostream::operator<<(register streambuf* sbuf)\n-{\n-  if (opfx())\n-    {\n-      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t_strbuf);\n-      char buffer[_IO_BUFSIZ];\n-      register streambuf* outbuf = _strbuf;\n-      for (;;)\n-\t{\n-\t  _IO_size_t count = _IO_sgetn(sbuf, buffer, _IO_BUFSIZ);\n-\t  if (count <= 0)\n-\t    break;\n-\t  if (_IO_sputn(outbuf, buffer, count) != count)\n-\t    {\n-\t      set(ios::badbit);\n-\t      break;\n-\t    }\n-\t}\n-      osfx();\n-      _IO_cleanup_region_end (0);\n-    }\n-  return *this;\n-}\n-\n-ostream::ostream(streambuf* sb, ostream* tied)\n-{\n-  init (sb, tied);\n-}\n-\n-ostream& ostream::seekp(streampos pos)\n-{\n-    pos = _strbuf->pubseekpos(pos, ios::out);\n-    if (pos == streampos(EOF))\n-\tset(ios::badbit);\n-    return *this;\n-}\n-\n-ostream& ostream::seekp(streamoff off, _seek_dir dir)\n-{\n-  streampos pos = _IO_seekoff (_strbuf, off, (int) dir, _IOS_OUTPUT);\n-  if (pos == streampos(EOF))\n-    set(ios::badbit);\n-  return *this;\n-}\n-\n-streampos ostream::tellp()\n-{\n-#if 1\n-    streampos pos = _IO_seekoff (_strbuf, 0, _IO_seek_cur, _IOS_OUTPUT);\n-#else\n-    streampos pos = _strbuf->pubseekoff(0, ios::cur, ios::out);\n-#endif\n-    if (pos == streampos(EOF))\n-\tset(ios::badbit);\n-    return pos;\n-}\n-\n-ostream& ostream::flush()\n-{\n-    if (_strbuf->sync())\n-\tset(ios::badbit);\n-    return *this;\n-}\n-\n-ostream& flush(ostream& outs)\n-{\n-  return outs.flush();\n-}\n-\n-istream& ws(istream& ins)\n-{\n-    if (ins.ipfx1()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  ins._strbuf);\n-\tint ch = skip_ws(ins._strbuf);\n-\tif (ch == EOF)\n-\t    ins.set(ios::eofbit);\n-\telse\n-\t    ins._strbuf->sputbackc(ch);\n-\tins.isfx();\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return ins;\n-}\n-\n-// Skip white-space.  Return 0 on failure (EOF), or 1 on success.\n-// Differs from ws() manipulator in that failbit is set on EOF.\n-// Called by ipfx() and ipfx0() if needed.\n-\n-int istream::_skip_ws()\n-{\n-    int ch = skip_ws(_strbuf);\n-    if (ch == EOF) {\n-\tset(ios::eofbit|ios::failbit);\n-\treturn 0;\n-    }\n-    else {\n-\t_strbuf->sputbackc(ch);\n-\treturn 1;\n-    }\n-}\n-\n-ostream& ends(ostream& outs)\n-{\n-    if (outs.opfx()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  outs._strbuf);\n-\touts.put('\\0');\n-\touts.osfx();\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return outs;\n-}\n-\n-ostream& endl(ostream& outs)\n-{\n-    if (outs.opfx()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  outs._strbuf);\n-        flush(outs.put('\\n'));\n-\touts.osfx();\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return outs;\n-}\n-\n-istream& lock(istream& ins)\n-{\n-  _IO_flockfile (ins._strbuf);\n-  return ins;\n-}\n-istream& unlock(istream& ins)\n-{\n-  _IO_funlockfile (ins._strbuf);\n-  return ins;\n-}\n-ostream& lock(ostream& outs)\n-{\n-  _IO_flockfile (outs._strbuf);\n-  return outs;\n-}\n-ostream& unlock(ostream& outs)\n-{\n-  _IO_funlockfile (outs._strbuf);\n-  return outs;\n-}\n-\n-\n-ostream& ostream::write(const char *s, streamsize n)\n-{\n-    if (opfx()) {\n-\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t\t  _strbuf);\n-\tif (_IO_sputn(_strbuf, s, n) != n)\n-\t    set(ios::failbit);\n-\tosfx();\n-\t_IO_cleanup_region_end (0);\n-    }\n-    return *this;\n-}\n-\n-void ostream::do_osfx()\n-{\n-    if (flags() & ios::unitbuf)\n-\tflush();\n-    if (flags() & ios::stdio) {\n-\tfflush(stdout);\n-\tfflush(stderr);\n-    }\n-}\n-\n-iostream::iostream(streambuf* sb, ostream* tied)\n-{\n-  init (sb, tied);\n-}\n-\n-// NOTE: extension for compatibility with old libg++.\n-// Not really compatible with fistream::close().\n-#ifdef _STREAM_COMPAT\n-void ios::close()\n-{\n-  if (_strbuf->_flags & _IO_IS_FILEBUF)\n-    ((struct filebuf*)rdbuf())->close();\n-  else if (_strbuf != NULL)\n-    rdbuf()->sync();\n-  _strbuf = NULL;\n-  _state = badbit;\n-}\n-\n-int istream::skip(int i)\n-{\n-    int old = (_flags & ios::skipws) != 0;\n-    if (i)\n-\t_flags |= ios::skipws;\n-    else\n-\t_flags &= ~ios::skipws;\n-    return old;\n-}\n-#endif"}, {"sha": "19fbf8a4d95ca2bdd74c2543dd9e704108c3a3e3", "filename": "libio/iostream.h", "status": "removed", "additions": 0, "deletions": 273, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiostream.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,273 +0,0 @@\n-/*  This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#ifndef _IOSTREAM_H\n-#ifdef __GNUG__\n-#pragma interface\n-#endif\n-#define _IOSTREAM_H\n-\n-#include <streambuf.h>\n-\n-extern \"C++\" {\n-class istream; class ostream;\n-typedef ios& (*__manip)(ios&);\n-typedef istream& (*__imanip)(istream&);\n-typedef ostream& (*__omanip)(ostream&);\n-\n-extern istream& ws(istream& ins);\n-extern ostream& flush(ostream& outs);\n-extern ostream& endl(ostream& outs);\n-extern ostream& ends(ostream& outs);\n-\n-class ostream : virtual public ios\n-{\n-    // NOTE: If fields are changed, you must fix _fake_ostream in stdstreams.C!\n-    void do_osfx();\n-  public:\n-    ostream() { }\n-    ostream(streambuf* sb, ostream* tied=NULL);\n-    int opfx() {\n-\tif (!good()) return 0;\n-\telse { if (_tie) _tie->flush(); _IO_flockfile(_strbuf); return 1;} }\n-    void osfx() { _IO_funlockfile(_strbuf);\n-\t\t  if (flags() & (ios::unitbuf|ios::stdio))\n-\t\t      do_osfx(); }\n-    ostream& flush();\n-    ostream& put(char c) { _strbuf->sputc(c); return *this; }\n-#ifdef _STREAM_COMPAT\n-    /* Temporary binary compatibility.  REMOVE IN NEXT RELEASE. */\n-    ostream& put(unsigned char c) { return put((char)c); }\n-    ostream& put(signed char c) { return put((char)c); }\n-#endif\n-    ostream& write(const char *s, streamsize n);\n-    ostream& write(const unsigned char *s, streamsize n)\n-      { return write((const char*)s, n);}\n-    ostream& write(const signed char *s, streamsize n)\n-      { return write((const char*)s, n);}\n-    ostream& write(const void *s, streamsize n)\n-      { return write((const char*)s, n);}\n-    ostream& seekp(streampos);\n-    ostream& seekp(streamoff, _seek_dir);\n-    streampos tellp();\n-    ostream& form(const char *format ...);\n-    ostream& vform(const char *format, _IO_va_list args);\n-\n-    ostream& operator<<(char c);\n-    ostream& operator<<(unsigned char c) { return (*this) << (char)c; }\n-    ostream& operator<<(signed char c) { return (*this) << (char)c; }\n-    ostream& operator<<(const char *s);\n-    ostream& operator<<(const unsigned char *s)\n-\t{ return (*this) << (const char*)s; }\n-    ostream& operator<<(const signed char *s)\n-\t{ return (*this) << (const char*)s; }\n-    ostream& operator<<(const void *p);\n-    ostream& operator<<(int n);\n-    ostream& operator<<(unsigned int n);\n-    ostream& operator<<(long n);\n-    ostream& operator<<(unsigned long n);\n-#if defined(__GNUC__)\n-    __extension__ ostream& operator<<(long long n);\n-    __extension__ ostream& operator<<(unsigned long long n);\n-#endif\n-    ostream& operator<<(short n) {return operator<<((int)n);}\n-    ostream& operator<<(unsigned short n) {return operator<<((unsigned int)n);}\n-#if _G_HAVE_BOOL\n-    ostream& operator<<(bool b) { return operator<<((int)b); }\n-#endif\n-    ostream& operator<<(double n);\n-    ostream& operator<<(float n) { return operator<<((double)n); }\n-#if _G_HAVE_LONG_DOUBLE_IO\n-    ostream& operator<<(long double n);\n-#else\n-    ostream& operator<<(long double n) { return operator<<((double)n); }\n-#endif\n-    ostream& operator<<(__omanip func) { return (*func)(*this); }\n-    ostream& operator<<(__manip func) {(*func)(*this); return *this;}\n-    ostream& operator<<(streambuf*);\n-#ifdef _STREAM_COMPAT\n-    streambuf* ostreambuf() const { return _strbuf; }\n-#endif\n-};\n-\n-class istream : virtual public ios\n-{\n-    // NOTE: If fields are changed, you must fix _fake_istream in stdstreams.C!\n-protected:\n-    _IO_size_t _gcount;\n-\n-    int _skip_ws();\n-  public:\n-    istream(): _gcount (0) { }\n-    istream(streambuf* sb, ostream*tied=NULL);\n-    istream& get(char* ptr, int len, char delim = '\\n');\n-    istream& get(unsigned char* ptr, int len, char delim = '\\n')\n-\t{ return get((char*)ptr, len, delim); }\n-    istream& get(char& c);\n-    istream& get(unsigned char& c) { return get((char&)c); }\n-    istream& getline(char* ptr, int len, char delim = '\\n');\n-    istream& getline(unsigned char* ptr, int len, char delim = '\\n')\n-\t{ return getline((char*)ptr, len, delim); }\n-    istream& get(signed char& c)  { return get((char&)c); }\n-    istream& get(signed char* ptr, int len, char delim = '\\n')\n-\t{ return get((char*)ptr, len, delim); }\n-    istream& getline(signed char* ptr, int len, char delim = '\\n')\n-\t{ return getline((char*)ptr, len, delim); }\n-    istream& read(char *ptr, streamsize n);\n-    istream& read(unsigned char *ptr, streamsize n)\n-      { return read((char*)ptr, n); }\n-    istream& read(signed char *ptr, streamsize n)\n-      { return read((char*)ptr, n); }\n-    istream& read(void *ptr, streamsize n)\n-      { return read((char*)ptr, n); }\n-    istream& get(streambuf& sb, char delim = '\\n');\n-    istream& gets(char **s, char delim = '\\n');\n-    int ipfx(int need = 0) {\n-\tif (!good()) { set(ios::failbit); return 0; }\n-\telse {\n-\t  _IO_flockfile(_strbuf);\n-\t  if (_tie && (need == 0 || rdbuf()->in_avail() < need)) _tie->flush();\n-\t  if (!need && (flags() & ios::skipws)) return _skip_ws();\n-\t  else return 1;\n-\t}\n-    }\n-    int ipfx0() { // Optimized version of ipfx(0).\n-\tif (!good()) { set(ios::failbit); return 0; }\n-\telse {\n-\t  _IO_flockfile(_strbuf);\n-\t  if (_tie) _tie->flush();\n-\t  if (flags() & ios::skipws) return _skip_ws();\n-\t  else return 1;\n-\t}\n-    }\n-    int ipfx1() { // Optimized version of ipfx(1).\n-\tif (!good()) { set(ios::failbit); return 0; }\n-\telse {\n-\t  _IO_flockfile(_strbuf);\n-\t  if (_tie && rdbuf()->in_avail() == 0) _tie->flush();\n-\t  return 1;\n-\t}\n-    }\n-    void isfx() { _IO_funlockfile(_strbuf); }\n-    int get() { if (!ipfx1()) return EOF;\n-\t\telse { int ch = _strbuf->sbumpc();\n-\t\t       if (ch == EOF) set(ios::eofbit);\n-\t\t       isfx();\n-\t\t       return ch;\n-\t\t     } }\n-    int peek();\n-    _IO_size_t gcount() { return _gcount; }\n-    istream& ignore(int n=1, int delim = EOF);\n-    int sync ();\n-    istream& seekg(streampos);\n-    istream& seekg(streamoff, _seek_dir);\n-    streampos tellg();\n-    istream& putback(char ch) {\n-\tif (good() && _strbuf->sputbackc(ch) == EOF) clear(ios::badbit);\n-\treturn *this;}\n-    istream& unget() {\n-\tif (good() && _strbuf->sungetc() == EOF) clear(ios::badbit);\n-\treturn *this;}\n-    istream& scan(const char *format ...);\n-    istream& vscan(const char *format, _IO_va_list args);\n-#ifdef _STREAM_COMPAT\n-    istream& unget(char ch) { return putback(ch); }\n-    int skip(int i);\n-    streambuf* istreambuf() const { return _strbuf; }\n-#endif\n-\n-    istream& operator>>(char*);\n-    istream& operator>>(unsigned char* p) { return operator>>((char*)p); }\n-    istream& operator>>(signed char*p) { return operator>>((char*)p); }\n-    istream& operator>>(char& c);\n-    istream& operator>>(unsigned char& c) {return operator>>((char&)c);}\n-    istream& operator>>(signed char& c) {return operator>>((char&)c);}\n-    istream& operator>>(int&);\n-    istream& operator>>(long&);\n-#if defined(__GNUC__)\n-    __extension__ istream& operator>>(long long&);\n-    __extension__ istream& operator>>(unsigned long long&);\n-#endif\n-    istream& operator>>(short&);\n-    istream& operator>>(unsigned int&);\n-    istream& operator>>(unsigned long&);\n-    istream& operator>>(unsigned short&);\n-#if _G_HAVE_BOOL\n-    istream& operator>>(bool&);\n-#endif\n-    istream& operator>>(float&);\n-    istream& operator>>(double&);\n-    istream& operator>>(long double&);\n-    istream& operator>>( __manip func) {(*func)(*this); return *this;}\n-    istream& operator>>(__imanip func) { return (*func)(*this); }\n-    istream& operator>>(streambuf*);\n-};\n-\n-class iostream : public istream, public ostream\n-{\n-  public:\n-    iostream() { }\n-    iostream(streambuf* sb, ostream*tied=NULL);\n-};\n-\n-class _IO_istream_withassign : public istream {\n-public:\n-  _IO_istream_withassign& operator=(istream&);\n-  _IO_istream_withassign& operator=(_IO_istream_withassign& rhs)\n-    { return operator= (static_cast<istream&> (rhs)); }\n-};\n-\n-class _IO_ostream_withassign : public ostream {\n-public:\n-  _IO_ostream_withassign& operator=(ostream&);\n-  _IO_ostream_withassign& operator=(_IO_ostream_withassign& rhs)\n-    { return operator= (static_cast<ostream&> (rhs)); }\n-};\n-\n-extern _IO_istream_withassign cin;\n-// clog->rdbuf() == cerr->rdbuf()\n-extern _IO_ostream_withassign cout, cerr;\n-\n-extern _IO_ostream_withassign clog\n-#if _G_CLOG_CONFLICT\n-__asm__ (\"__IO_clog\")\n-#endif\n-;\n-\n-extern istream& lock(istream& ins);\n-extern istream& unlock(istream& ins);\n-extern ostream& lock(ostream& outs);\n-extern ostream& unlock(ostream& outs);\n-\n-struct Iostream_init { } ;  // Compatibility hack for AT&T library.\n-\n-inline ios& dec(ios& i)\n-{ i.setf(ios::dec, ios::dec|ios::hex|ios::oct); return i; }\n-inline ios& hex(ios& i)\n-{ i.setf(ios::hex, ios::dec|ios::hex|ios::oct); return i; }\n-inline ios& oct(ios& i)\n-{ i.setf(ios::oct, ios::dec|ios::hex|ios::oct); return i; }\n-} // extern \"C++\"\n-\n-#endif /*!_IOSTREAM_H*/"}, {"sha": "641cd7da22f078aacf8767437fb37e7a63838d9d", "filename": "libio/iostream.texi", "status": "removed", "additions": 0, "deletions": 1971, "changes": 1971, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiostream.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiostream.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiostream.texi?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,1971 +0,0 @@\n-\\input texinfo                                 @c -*-Texinfo-*-\n-@c Copyright (c) 1993 Free Software Foundation, Inc.\n-\n-@c %**start of header \n-@setfilename iostream.info\n-@settitle The GNU C++ Iostream Library\n-@setchapternewpage odd\n-@c %**end of header\n-\n-@ifinfo\n-@format\n-START-INFO-DIR-ENTRY\n-* iostream: (iostream).                    The C++ input/output facility.\n-END-INFO-DIR-ENTRY\n-@end format\n-\n-This file describes libio, the GNU library for C++ iostreams and C stdio.\n-\n-libio includes software developed by the University of California,\n-Berkeley.\n-\n-Copyright (C) 1993 Free Software Foundation, Inc.\n-\n-Permission is granted to make and distribute verbatim copies of\n-this manual provided the copyright notice and this permission notice\n-are preserved on all copies.\n-\n-@ignore\n-Permission is granted to process this file through TeX and print the\n-results, provided the printed document carries copying permission\n-notice identical to this one except for the removal of this paragraph\n-(this paragraph not being relevant to the printed manual).\n-\n-@end ignore\n-Permission is granted to copy and distribute modified versions of this\n-manual under the conditions for verbatim copying, provided also that the\n-entire resulting derived work is distributed under the terms of a\n-permission notice identical to this one.\n-\n-Permission is granted to copy and distribute translations of this manual\n-into another language, under the above conditions for modified versions.\n-@end ifinfo\n-\n-@finalout\n-@syncodeindex fn cp\n-@syncodeindex vr cp\n-\n-@titlepage\n-@title The GNU C++ Iostream Library\n-@subtitle Reference Manual for @code{libio} Version 0.64\n-@sp 3\n-@author Per Bothner @hfill @code{bothner@@cygnus.com}\n-@author Cygnus Support @hfill @code{doc@@cygnus.com}\n-@page\n-\n-@vskip 0pt plus 1filll\n-Copyright @copyright{} 1993 Free Software Foundation, Inc.\n-\n-@code{libio} includes software developed by the University of\n-California, Berkeley.\n-\n-@code{libio} uses floating-point software written by David M. Gay, which\n-includes the following notice:\n-\n-@quotation\n-The author of this software is David M. Gay.\n-\n-Copyright (c) 1991 by AT&T.\n-\n-Permission to use, copy, modify, and distribute this software for any\n-purpose without fee is hereby granted, provided that this entire notice\n-is included in all copies of any software which is or includes a copy\n-or modification of this software and in all copies of the supporting\n-documentation for such software.\n-\n-THIS SOFTWARE IS BEING PROVIDED \"AS IS\", WITHOUT ANY EXPRESS OR IMPLIED\n-WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR AT&T MAKES ANY\n-REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY\n-OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.\n-@end quotation\n-\n-Permission is granted to make and distribute verbatim copies of\n-this manual provided the copyright notice and this permission notice\n-are preserved on all copies.\n-\n-Permission is granted to copy and distribute modified versions of this\n-manual under the conditions for verbatim copying, provided also that the\n-entire resulting derived work is distributed under the terms of a\n-permission notice identical to this one.\n-\n-Permission is granted to copy and distribute translations of this manual\n-into another language, under the above conditions for modified versions.\n-@end titlepage\n-\n-@ifinfo\n-@node Top\n-@top The GNU C++ Iostream Library\n-\n-This file provides reference information on the GNU C++ iostream library\n-(@code{libio}), version 0.64.\n-\n-@menu\n-* Introduction::\n-* Operators::\t\t\tOperators and default streams.\n-* Streams::\t\t\tStream classes.\n-* Files and Strings::\t\tClasses for files and strings.\n-* Streambuf::\t\t\tUsing the streambuf layer.\n-* Stdio::\t\t\tC input and output.\n-* Index::\n-@end menu\n-@end ifinfo\n-\n-@node Introduction\n-@chapter Introduction\n-\n-The iostream classes implement most of the features of AT&T version 2.0\n-iostream library classes, and most of the features of the ANSI X3J16\n-library draft (which is based on the AT&T design).\n-\n-This manual is meant as a reference; for tutorial material on iostreams,\n-see the corresponding section of any recent popular introduction to C++.\n-\n-@menu\n-* Copying::\t\tSpecial GNU licensing terms for libio.\n-* Acknowledgements::\tContributors to GNU iostream.\n-@end menu\n-\n-@node Copying\n-@section Licensing terms for @code{libio}\n-\n-Since the @code{iostream} classes are so fundamental to standard C++,\n-the Free Software Foundation has agreed to a special exception to its\n-standard license, when you link programs with @code{libio.a}:\n-\n-@quotation\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License.\n-@end quotation\n-\n-The code is under the @sc{gnu} General Public License (version 2) for\n-all other purposes than linking with this library; that means that you\n-can modify and redistribute the code as usual, but remember that if you\n-do, your modifications, and anything you link with the modified code,\n-must be available to others on the same terms.\n-\n-These functions are also available as part of the @code{libg++}\n-library; if you link with that library instead of @code{libio}, the\n-@sc{gnu} Library General Public License applies.\n-\n-@node Acknowledgements\n-@section Acknowledgements\n-\n-Per Bothner wrote most of the @code{iostream} library, but some portions\n-have their origins elsewhere in the free software community.  Heinz\n-Seidl wrote the IO manipulators.  The floating-point conversion software\n-is by David M. Gay of AT&T.  Some code was derived from parts of BSD\n-4.4, which was written at the University of California, Berkeley.\n-\n-The iostream classes are found in the @code{libio} library.  An early\n-version was originally distributed in @code{libg++}, and they are still\n-included there as well, for convenience if you need other @code{libg++}\n-classes.  Doug Lea was the original author of @code{libg++}, and some of\n-the file-management code still in @code{libio} is his.\n-\n-Various people found bugs or offered suggestions.  Hongjiu Lu worked\n-hard to use the library as the default stdio implementation for Linux,\n-and has provided much stress-testing of the library.\n-\n-@node Operators\n-@chapter Operators and Default Streams\n-\n-The @sc{gnu} iostream library, @file{libio}, implements the standard\n-input and output facilities for C++.  These facilities are roughly\n-analogous (in their purpose and ubiquity, at least) with those defined\n-by the C @file{stdio} functions.\n-\n-Although these definitions come from a library, rather than being part\n-of the ``core language'', they are sufficiently central to be specified\n-in the latest working papers for C++.\n-\n-You can use two operators defined in this library for basic input and\n-output operations.  They are familiar from any C++ introductory\n-textbook: @code{<<} for output, and @code{>>} for input.  (Think of data\n-flowing in the direction of the ``arrows''.)\n-\n-These operators are often used in conjunction with three streams that\n-are open by default: \n-\n-@deftypevar ostream cout\n-The standard output stream, analogous to the C @code{stdout}.\n-@end deftypevar\n-\n-@deftypevar istream cin\n-The standard input stream, analogous to the C @code{stdin}.\n-@end deftypevar\n-\n-@deftypevar ostream cerr\n-An alternative output stream for errors, analogous to the C\n-@code{stderr}.\n-@end deftypevar\n-\n-@noindent\n-For example, this bare-bones C++ version of the traditional ``hello''\n-program uses @code{<<} and @code{cout}:\n-\n-@example\n-#include <iostream.h>\n-\n-int main(int argc, char **argv)\n-@{\n-  cout << \"Well, hi there.\\n\";\n-  return 0;\n-@}\n-@end example\n-\n-Casual use of these operators may be seductive, but---other than in\n-writing throwaway code for your own use---it is not necessarily simpler\n-than managing input and output in any other language.  For example,\n-robust code should check the state of the input and output streams\n-between operations (for example, using the method @code{good}).\n-@xref{States,,Checking the state of a stream}.  You may also need to\n-adjust maximum input or output field widths, using manipulators like\n-@code{setw} or @code{setprecision}.\n-\n-@defop Operator ostream <<\n-Write output to an open output stream of class @code{ostream}.\n-Defined by this library on any @var{object} of a C++ primitive type, and\n-on other classes of the library.  You can overload the definition for any\n-of your own applications' classes.\n-\n-Returns a reference to the implied argument @code{*this} (the open stream it\n-writes on), permitting statements like\n-@example\n-cout << \"The value of i is \" << i << \"\\n\";\n-@end example\n-@end defop\n-\n-@defop Operator istream >>\n-Read input from an open input stream of class @code{istream}.  Defined\n-by this library on primitive numeric, pointer, and string types; you can\n-extend the definition for any of your own applications' classes.\n-\n-Returns a reference to the implied argument @code{*this} (the open stream\n-it reads), permitting multiple inputs in one statement.\n-@end defop\n-\n-@node Streams\n-@chapter Stream Classes\n-\n-The previous chapter referred in passing to the classes @code{ostream}\n-and @code{istream}, for output and input respectively.  These classes\n-share certain properties, captured in their base class @code{ios}.\n-\n-@menu\n-* Ios::       Shared properties.\n-* Ostream::   Managing output streams.\n-* Istream::   Managing input streams.\n-* Iostream::  Input and output together.\n-@end menu\n-\n-@node Ios\n-@section Shared properties: class @code{ios}\n-\n-The base class @code{ios} provides methods to test and manage the state\n-of input or output streams.\n-\n-@code{ios} delegates the job of actually reading and writing bytes to\n-the abstract class @code{streambuf}, which is designed to provide\n-buffered streams (compatible with C, in the @sc{gnu} implementation).\n-@xref{Streambuf,,Using the @code{streambuf} layer}, for information on\n-the facilities available at the @code{streambuf} level.\n-\n-@deftypefn Constructor {} ios::ios ([streambuf* @var{sb} @w{[, ostream*} @var{tie}])\n-The @code{ios} constructor by default initializes a new @code{ios}, and\n-if you supply a @code{streambuf} @var{sb} to associate with it, sets the\n-state @code{good} in the new @code{ios} object.  It also sets the\n-default properties of the new object.\n-\n-@ignore\n-@c FIXME--future: this (a) doesn't work, (b) is controversial at ANSI\n-An @code{ios} without a @code{streambuf} has the state @code{bad} until\n-you supply a @code{streambuf}; you can do that by assigning a new value\n-to the @code{ios} with @samp{=}.\n-@end ignore\n-\n-You can also supply an optional second argument @var{tie} to the\n-constructor: if present, it is an initial value for @code{ios::tie}, to\n-associate the new @code{ios} object with another stream.\n-@end deftypefn\n-\n-@deftypefn Destructor {} ios::~ios ()\n-The @code{ios} destructor is virtual, permitting application-specific\n-behavior when a stream is closed---typically, the destructor frees any\n-storage associated with the stream and releases any other associated\n-objects.\n-@end deftypefn\n-\n-@c FIXME-future:  Is @deftypefn really the best way of displaying these?\n-\n-@c FIXME-future: Undocumented: ios::_throw_failure, ios::exceptions; things\n-@c controlled by _STREAM_COMPAT; ios::Init; ios::_IO_fix_vtable.\n-\n-@menu\n-* States::\t\tChecking the state of a stream.\n-* Format Control::\tChoices in formatting.\n-* Manipulators::\tConvenient ways of changing stream properties.\n-* Extending::\t\tExtended data fields.\n-* Synchronization::\tSynchronizing related streams.\n-* Streambuf from Ios::\tReaching the underlying streambuf.\n-@end menu\n-\n-@node States\n-@subsection Checking the state of a stream\n-\n-Use this collection of methods to test for (or signal) errors and other\n-exceptional conditions of streams:\n-\n-@deftypefn Method {ios::operator void*} () const\n-You can do a quick check on the state of the most recent operation on a\n-stream by examining a pointer to the stream itself.  The pointer is\n-arbitrary except for its truth value; it is true if no failures have\n-occurred (@code{ios::fail} is not true).  For example, you might ask for\n-input on @code{cin} only if all prior output operations succeeded:\n-\n-@example\n-if (cout)\n-@{\n-  // Everything OK so far\n-  cin >> new_value;\n-  @dots{}\n-@}\n-@end example\n-@end deftypefn\n-\n-@deftypefn Method {ios::operator !} () const\n-In case it is more convenient to check whether something has failed, the\n-operator @code{!} returns true if @code{ios::fail} is true (an operation\n-has failed).  For example,\n-you might issue an error message if input failed:\n-\n-@example\n-if (!cin)\n-@{\n-  // Oops\n-  cerr << \"Eh?\\n\";\n-@}\n-@end example\n-@end deftypefn\n-\n-@deftypefn Method iostate ios::rdstate () const\n-Return the state flags for this stream.  The value is from the\n-enumeration @code{iostate}.  You can test for any combination of\n-\n-@vtable @code\n-@item goodbit\n-There are no indications of exceptional states on this stream.\n-\n-@item eofbit\n-End of file.\n-\n-@item failbit\n-An operation has failed on this stream; this usually indicates bad\n-format of input.\n-\n-@item badbit\n-The stream is unusable.\n-@end vtable\n-@end deftypefn\n-\n-@deftypefn Method void ios::setstate (iostate @var{state})\n-@findex ios::set\n-Set the state flag for this stream to @var{state} @emph{in addition to}\n-any state flags already set.  Synonym (for upward compatibility):\n-@code{ios::set}.\n-\n-See @code{ios::clear} to set the stream state without regard to existing\n-state flags.  See @code{ios::good}, @code{ios::eof}, @code{ios::fail},\n-and @code{ios::bad}, to test the state.\n-@end deftypefn\n-\n-@deftypefn Method int ios::good () const\n-Test the state flags associated with this stream; true if no error\n-indicators are set.\n-@end deftypefn\n-\n-@deftypefn Method int ios::bad () const\n-Test whether a stream is marked as unusable.  (Whether\n-@code{ios::badbit} is set.)\n-@end deftypefn\n-\n-@deftypefn Method int ios::eof () const\n-True if end of file was reached on this stream.  (If @code{ios::eofbit}\n-is set.)\n-@end deftypefn\n-\n-@deftypefn Method int ios::fail () const\n-Test for any kind of failure on this stream: @emph{either} some\n-operation failed, @emph{or} the stream is marked as bad.  (If either\n-@code{ios::failbit} or @code{ios::badbit} is set.)\n-@end deftypefn\n-\n-@deftypefn Method void ios::clear (iostate @var{state})\n-@c FIXME-future: There is some complication to do with buffering and _throw_failure\n-Set the state indication for this stream to the argument @var{state}.\n-You may call @code{ios::clear} with no argument, in which case the state\n-is set to @code{good} (no errors pending).\n-\n-See @code{ios::good}, @code{ios::eof}, @code{ios::fail}, and\n-@code{ios::bad}, to test the state; see @code{ios::set} or\n-@code{ios::setstate} for an alternative way of setting the state.\n-@end deftypefn\n-\n-@node Format Control\n-@subsection Choices in formatting\n-\n-These methods control (or report on) settings for some details of\n-controlling streams, primarily to do with formatting output:\n-\n-@deftypefn Method char ios::fill () const\n-Report on the padding character in use.\n-@end deftypefn\n-\n-@deftypefn Method char ios::fill (char @var{padding})\n-Set the padding character.  You can also use the manipulator\n-@code{setfill}.  @xref{Manipulators,,Changing stream properties in\n-expressions}.\n-\n-Default: blank.\n-@end deftypefn\n-\n-@deftypefn Method int ios::precision () const\n-Report the number of significant digits currently in use for output of\n-floating point numbers.\n-\n-Default: @code{6}.\n-@end deftypefn\n-\n-@deftypefn Method int ios::precision (int @var{signif})\n-Set the number of significant digits (for input and output numeric\n-conversions) to @var{signif}.\n-\n-@findex setprecision\n-@cindex setting @code{ios::precision}\n-You can also use the manipulator @code{setprecision} for this purpose.\n-@xref{Manipulators,,Changing stream properties using manipulators}.\n-@end deftypefn\n-\n-@deftypefn Method int ios::width () const\n-Report the current output field width setting (the number of\n-characters to write on the next @samp{<<} output operation).\n-\n-Default: @code{0}, which means to use as many characters as necessary.\n-@end deftypefn\n-\n-@deftypefn Method int ios::width (int @var{num})\n-Set the input field width setting to @var{num}.  Return the\n-@emph{previous} value for this stream.\n-\n-@findex setw\n-@cindex setting @code{ios::width}\n-This value resets to zero (the default) every time you use @samp{<<}; it is\n-essentially an additional implicit argument to that operator.  You can\n-also use the manipulator @code{setw} for this purpose.\n-@xref{Manipulators,,Changing stream properties using manipulators}.\n-@end deftypefn\n-\n-@need 2000\n-@deftypefn Method fmtflags ios::flags () const\n-Return the current value of the complete collection of flags controlling\n-the format state.  These are the flags and their meanings when set:\n-\n-@vtable @code\n-@item ios::dec\n-@itemx ios::oct\n-@itemx ios::hex\n-What numeric base to use in converting integers from internal to display\n-representation, or vice versa: decimal, octal, or hexadecimal,\n-respectively.  (You can change the base using the manipulator\n-@code{setbase}, or any of the manipulators @code{dec}, @code{oct}, or\n-@code{hex}; @pxref{Manipulators,,Changing stream properties in\n-expressions}.)\n-\n-On input, if none of these flags is set, read numeric constants\n-according to the prefix: decimal if no prefix (or a @samp{.} suffix),\n-octal if a @samp{0} prefix is present, hexadecimal if a @samp{0x} prefix\n-is present.\n-\n-Default: @code{dec}.\n-\n-@item ios::fixed\n-Avoid scientific notation, and always show a fixed number of digits after\n-the decimal point, according to the output precision in effect.\n-Use @code{ios::precision} to set precision.\n-\n-@item ios::left\n-@itemx ios::right\n-@itemx ios::internal\n-Where output is to appear in a fixed-width field; left-justified,\n-right-justified, or with padding in the middle (e.g. between a numeric\n-sign and the associated value), respectively.\n-\n-@item ios::scientific\n-Use scientific (exponential) notation to display numbers.\n-\n-@item ios::showbase\n-Display the conventional prefix as a visual indicator of the conversion\n-base: no prefix for decimal, @samp{0} for octal, @samp{0x} for hexadecimal.\n-\n-@item ios::showpoint\n-Display a decimal point and trailing zeros after it to fill out numeric\n-fields, even when redundant.\n-\n-@item ios::showpos\n-Display a positive sign on display of positive numbers.\n-\n-@item ios::skipws\n-Skip white space.  (On by default).\n-\n-@item ios::stdio\n-Flush the C @code{stdio} streams @code{stdout} and @code{stderr} after\n-each output operation (for programs that mix C and C++ output conventions).\n-\n-@item ios::unitbuf\n-Flush after each output operation.\n-\n-@item ios::uppercase\n-Use upper-case characters for the non-numeral elements in numeric\n-displays; for instance, @samp{0X7A} rather than @samp{0x7a}, or\n-@samp{3.14E+09} rather than @samp{3.14e+09}.\n-@end vtable\n-@end deftypefn\n-\n-@deftypefn Method fmtflags ios::flags (fmtflags @var{value})\n-Set @var{value} as the complete collection of flags controlling the\n-format state.  The flag values are described under @samp{ios::flags ()}.\n-\n-Use @code{ios::setf} or @code{ios::unsetf} to change one property at a\n-time.\n-@end deftypefn\n-\n-@deftypefn Method fmtflags ios::setf (fmtflags @var{flag})\n-Set one particular flag (of those described for @samp{ios::flags ()};\n-return the complete collection of flags @emph{previously} in effect.\n-(Use @code{ios::unsetf} to cancel.)\n-@end deftypefn\n-\n-@deftypefn Method fmtflags ios::setf (fmtflags @var{flag}, fmtflags @var{mask})\n-Clear the flag values indicated by @var{mask}, then set any of them that\n-are also in @var{flag}.  (Flag values are described for @samp{ios::flags\n-()}.)  Return the complete collection of flags @emph{previously} in\n-effect.  (See @code{ios::unsetf} for another way of clearing flags.)\n-@end deftypefn\n-\n-@deftypefn Method fmtflags ios::unsetf (fmtflags @var{flag})\n-Make certain @var{flag} (a combination of flag values described for\n-@samp{ios::flags ()}) is not set for this stream; converse of\n-@code{ios::setf}.  Returns the old values of those flags.\n-@c FIXME-future: should probably be fixed to give same result as setf.\n-@end deftypefn\n-\n-@node Manipulators\n-@subsection Changing stream properties using manipulators\n-\n-For convenience, @var{manipulators} provide a way to change certain\n-properties of streams, or otherwise affect them, in the middle of\n-expressions involving @samp{<<} or @samp{>>}.  For example, you might\n-write\n-\n-@example\n-cout << \"|\" << setfill('*') << setw(5) << 234 << \"|\";\n-@end example\n-\n-@noindent\n-to produce @samp{|**234|} as output.\n-\n-@deftypefn Manipulator {} ws\n-Skip whitespace.\n-@end deftypefn\n-\n-@deftypefn Manipulator {} flush\n-Flush an output stream.  For example, @samp{cout << @dots{} <<flush;}\n-has the same effect as @samp{cout << @dots{}; cout.flush();}.\n-@end deftypefn\n-\n-@deftypefn Manipulator {} endl\n-Write an end of line character @samp{\\n}, then flushes the output stream.\n-@end deftypefn\n-\n-@deftypefn Manipulator {} ends\n-Write @samp{\\0} (the string terminator character).\n-@end deftypefn\n-\n-@deftypefn Manipulator {} setprecision (int @var{signif})\n-You can change the value of @code{ios::precision} in @samp{<<}\n-expressions with the manipulator @samp{setprecision(@var{signif})}; for\n-example,\n-\n-@example\n-cout << setprecision(2) << 4.567;\n-@end example\n-\n-@noindent\n-prints @samp{4.6}.  Requires @file{#include <iomanip.h>}.\n-@end deftypefn\n-\n-@deftypefn Manipulator {} setw (int @var{n})\n-You can change the value of @code{ios::width} in @samp{<<} expressions\n-with the manipulator @samp{setw(@var{n})}; for example,\n-\n-@example\n-cout << setw(5) << 234;\n-@end example\n-\n-@noindent\n-prints @w{@samp{  234}} with two leading blanks.  Requires @file{#include\n-<iomanip.h>}.\n-@end deftypefn\n-\n-@deftypefn Manipulator {} setbase (int @var{base})\n-Where @var{base} is one of @code{10} (decimal), @code{8} (octal), or\n-@code{16} (hexadecimal), change the base value for numeric\n-representations.  Requires @file{#include <iomanip.h>}.\n-@end deftypefn\n-\n-@deftypefn Manipulator {} dec\n-Select decimal base; equivalent to @samp{setbase(10)}.\n-@end deftypefn\n-\n-@deftypefn Manipulator {} hex\n-Select hexadecimal base; equivalent to @samp{setbase(16)}.\n-@end deftypefn\n-\n-@deftypefn Manipulator {} oct\n-Select octal base; equivalent to @samp{setbase(8)}.\n-@end deftypefn\n-\n-@deftypefn Manipulator {} setfill (char @var{padding})\n-Set the padding character, in the same way as @code{ios::fill}.\n-Requires @file{#include <iomanip.h>}.\n-@end deftypefn\n-\n-@node Extending\n-@subsection Extended data fields\n-\n-A related collection of methods allows you to extend this collection of\n-flags and parameters for your own applications, without risk of conflict\n-between them:\n-\n-@deftypefn Method {static fmtflags} ios::bitalloc ()\n-Reserve a bit (the single bit on in the result) to use as a flag.  Using\n-@code{bitalloc} guards against conflict between two packages that use\n-@code{ios} objects for different purposes.\n-\n-This method is available for upward compatibility, but is not in the\n-@sc{ansi} working paper.  The number of bits available is limited; a\n-return value of @code{0} means no bit is available.\n-@end deftypefn\n-\n-@deftypefn Method {static int} ios::xalloc ()\n-Reserve space for a long integer or pointer parameter.  The result is a\n-unique nonnegative integer.  You can use it as an index to\n-@code{ios::iword} or @code{ios::pword}.  Use @code{xalloc} to arrange\n-for arbitrary special-purpose data in your @code{ios} objects, without\n-risk of conflict between packages designed for different purposes.\n-@end deftypefn\n-\n-@deftypefn Method long& ios::iword (int @var{index})\n-Return a reference to arbitrary data, of long integer type, stored in an\n-@code{ios} instance.  @var{index}, conventionally returned from\n-@code{ios::xalloc}, identifies what particular data you need.\n-@end deftypefn\n-\n-@deftypefn Method long ios::iword (int @var{index}) const\n-Return the actual value of a long integer stored in an @code{ios}.\n-@end deftypefn\n-\n-@deftypefn Method void*& ios::pword (int @var{index})\n-Return a reference to an arbitrary pointer, stored in an @code{ios}\n-instance.  @var{index}, originally returned from @code{ios::xalloc},\n-identifies what particular pointer you need.\n-@end deftypefn\n-\n-@deftypefn Method void* ios::pword (int @var{index}) const\n-Return the actual value of a pointer stored in an @code{ios}.\n-@end deftypefn\n-\n-@node Synchronization\n-@subsection Synchronizing related streams\n-\n-You can use these methods to synchronize related streams with\n-one another:\n-\n-@deftypefn Method ostream* ios::tie () const\n-Report on what output stream, if any, is to be flushed before accessing\n-this one.  A pointer value of @code{0} means no stream is tied.\n-@end deftypefn\n-\n-@deftypefn Method ostream* ios::tie (ostream* @var{assoc})\n-Declare that output stream @var{assoc} must be flushed before accessing\n-this stream.\n-@end deftypefn\n-\n-@deftypefn Method int ios::sync_with_stdio ([int @var{switch}])\n-Unless iostreams and C @code{stdio} are designed to work together, you\n-may have to choose between efficient C++ streams output and output\n-compatible with C @code{stdio}.  Use @samp{ios::sync_with_stdio()} to\n-select C compatibility.\n-\n-The argument @var{switch} is a @sc{gnu} extension; use @code{0} as the\n-argument to choose output that is not necessarily compatible with C\n-@code{stdio}.  The default value for @var{switch} is @code{1}.\n-\n-If you install the @code{stdio} implementation that comes with @sc{gnu}\n-@code{libio}, there are compatible input/output facilities for both C\n-and C++.  In that situation, this method is unnecessary---but you may\n-still want to write programs that call it, for portability.\n-@end deftypefn\n-\n-@node Streambuf from Ios\n-@subsection Reaching the underlying @code{streambuf}\n-\n-Finally, you can use this method to access the underlying object:\n-\n-@deftypefn Method streambuf* ios::rdbuf () const\n-Return a pointer to the @code{streambuf} object that underlies this\n-@code{ios}.\n-@end deftypefn\n-\n-@node Ostream\n-@section Managing output streams: class @code{ostream}\n-\n-Objects of class @code{ostream} inherit the generic methods from\n-@code{ios}, and in addition have the following methods available.\n-Declarations for this class come from @file{iostream.h}.\n-\n-@deftypefn Constructor {} ostream::ostream ()\n-The simplest form of the constructor for an @code{ostream} simply\n-allocates a new @code{ios} object.\n-@end deftypefn\n-\n-@deftypefn Constructor {} ostream::ostream (streambuf* @var{sb} @w{[, ostream} @var{tie}])\n-This alternative constructor requires a first argument @var{sb} of type\n-@code{streambuf*}, to use an existing open stream for output.  It also\n-accepts an optional second argument @var{tie}, to specify a related\n-@code{ostream*} as the initial value for @code{ios::tie}.\n-\n-If you give the @code{ostream} a @code{streambuf} explicitly, using\n-this constructor, the @var{sb} is @emph{not} destroyed (or deleted or\n-closed) when the @code{ostream} is destroyed.\n-@end deftypefn\n-\n-@menu\n-* Writing::\t\tWriting on an ostream.\n-* Output Position::\tRepositioning an ostream.\n-* Ostream Housekeeping:: Miscellaneous ostream utilities.\n-@end menu\n-\n-@node Writing\n-@subsection Writing on an @code{ostream}\n-\n-These methods write on an @code{ostream} (you may also use the operator\n-@code{<<}; @pxref{Operators,,Operators and Default Streams}).\n-\n-@deftypefn Method ostream& ostream::put (char @var{c})\n-Write the single character @var{c}.\n-@end deftypefn\n-\n-@deftypefn Method ostream& ostream::write (@var{string}, int @var{length})\n-Write @var{length} characters of a string to this @code{ostream},\n-beginning at the pointer @var{string}.\n-\n-@var{string} may have any of these types: @code{char*}, @code{unsigned\n-char*}, @code{signed char*}.\n-@end deftypefn\n-\n-@deftypefn Method ostream& ostream::form (const char *@var{format}, ...)\n-A @sc{gnu} extension, similar to @code{fprintf(@var{file},\n-@var{format}, ...)}.\n-\n-@var{format} is a @code{printf}-style format control string, which is used\n-to format the (variable number of) arguments, printing the result on\n-this @code{ostream}.  See @code{ostream::vform} for a version that uses\n-an argument list rather than a variable number of arguments.\n-@end deftypefn\n-\n-@deftypefn Method ostream& ostream::vform (const char *@var{format}, va_list @var{args})\n-A @sc{gnu} extension, similar to @code{vfprintf(@var{file},\n-@var{format}, @var{args})}.\n-\n-@var{format} is a @code{printf}-style format control string, which is used\n-to format the argument list @var{args}, printing the result on\n-this @code{ostream}.  See @code{ostream::form} for a version that uses a\n-variable number of arguments rather than an argument list.\n-@end deftypefn\n-\n-@node Output Position\n-@subsection Repositioning an @code{ostream}\n-\n-You can control the output position (on output streams that actually\n-support positions, typically files) with these methods:\n-@c FIXME-future: sort out which classes support this and which\n-@c don't; fstream, filebuf?  And what is failure condition when not supported?\n-\n-@deftypefn Method streampos ostream::tellp ()\n-Return the current write position in the stream.\n-@end deftypefn\n-\n-@deftypefn Method ostream& ostream::seekp (streampos @var{loc})\n-Reset the output position to @var{loc} (which is usually the result of a\n-previous call to @code{ostream::tellp}).  @var{loc} specifies an\n-absolute position in the output stream.\n-@end deftypefn\n-\n-@deftypefn Method ostream& ostream::seekp (streamoff @var{loc}, @var{rel})\n-@findex ios::seekdir\n-Reset the output position to @var{loc}, relative to the beginning, end,\n-or current output position in the stream, as indicated by @var{rel} (a\n-value from the enumeration @code{ios::seekdir}):\n-\n-@vtable @code\n-@item beg\n-Interpret @var{loc} as an absolute offset from the beginning of the\n-file.\n-\n-@item cur\n-Interpret @var{loc} as an offset relative to the current output\n-position.\n-\n-@item end\n-Interpret @var{loc} as an offset from the current end of the output\n-stream.\n-@end vtable\n-@end deftypefn\n-\n-@node Ostream Housekeeping\n-@subsection Miscellaneous @code{ostream} utilities\n-\n-You may need to use these @code{ostream} methods for housekeeping:\n-\n-@deftypefn Method ostream& flush ()\n-Deliver any pending buffered output for this @code{ostream}.\n-@end deftypefn\n-\n-@deftypefn Method int ostream::opfx ()\n-@code{opfx} is a @dfn{prefix} method for operations on @code{ostream}\n-objects; it is designed to be called before any further processing.  See\n-@code{ostream::osfx} for the converse.\n-@c FIXME-future: specify sometime which methods start with opfx.\n-\n-@code{opfx} tests that the stream is in state @code{good}, and if so\n-flushes any stream tied to this one.\n-\n-The result is @code{1} when @code{opfx} succeeds; else (if the stream state is\n-not @code{good}), the result is @code{0}.\n-@end deftypefn\n-\n-@deftypefn Method void ostream::osfx ()\n-@code{osfx} is a @dfn{suffix} method for operations on @code{ostream}\n-objects; it is designed to be called at the conclusion of any processing.  All\n-the @code{ostream} methods end by calling @code{osfx}.  See\n-@code{ostream::opfx} for the converse.\n-\n-If the @code{unitbuf} flag is set for this stream, @code{osfx} flushes\n-any buffered output for it.\n-\n-If the @code{stdio} flag is set for this stream, @code{osfx} flushes any\n-output buffered for the C output streams @file{stdout} and @file{stderr}.\n-@end deftypefn\n-\n-@node Istream\n-@section Managing input streams: class @code{istream}\n-\n-Class @code{istream} objects are specialized for input; as for\n-@code{ostream}, they are derived from @code{ios}, so you can use any of\n-the general-purpose methods from that base class.  Declarations for this\n-class also come from @file{iostream.h}.\n-\n-@deftypefn Constructor {} istream::istream ()\n-When used without arguments, the @code{istream} constructor simply\n-allocates a new @code{ios} object and initializes the input counter (the\n-value reported by @code{istream::gcount}) to @code{0}.\n-@end deftypefn\n-\n-@deftypefn Constructor {} istream::istream (streambuf *@var{sb} @w{[, ostream} @var{tie}])\n-You can also call the constructor with one or two arguments.  The first\n-argument @var{sb} is a @code{streambuf*}; if you supply this pointer,\n-the constructor uses that @code{streambuf} for input.\n-You can use the second optional argument @var{tie} to specify a related\n-output stream as the initial value for @code{ios::tie}.\n-\n-If you give the @code{istream} a @code{streambuf} explicitly, using\n-this constructor, the @var{sb} is @emph{not} destroyed (or deleted or\n-closed) when the @code{ostream} is destroyed.\n-@end deftypefn\n-\n-@menu\n-* Char Input::\t\tReading one character.\n-* String Input::\tReading strings.\n-* Input Position::\tRepositioning an istream.\n-* Istream Housekeeping:: Miscellaneous istream utilities.\n-@end menu\n-\n-@node Char Input\n-@subsection Reading one character\n-\n-Use these methods to read a single character from the input stream:\n-\n-@deftypefn Method int istream::get ()\n-Read a single character (or @code{EOF}) from the input stream, returning\n-it (coerced to an unsigned char) as the result.\n-@end deftypefn\n-\n-@deftypefn Method istream& istream::get (char& @var{c})\n-Read a single character from the input stream, into @code{&@var{c}}.\n-@end deftypefn\n-\n-@deftypefn Method int istream::peek ()\n-Return the next available input character, but @emph{without} changing\n-the current input position.\n-@end deftypefn\n-\n-@node String Input\n-@subsection Reading strings\n-\n-Use these methods to read strings (for example, a line at a time) from\n-the input stream:\n-\n-@deftypefn Method istream& istream::get (char* @var{c}, int @var{len} @w{[, char} @var{delim}])\n-Read a string from the input stream, into the array at @var{c}.\n-\n-The remaining arguments limit how much to read: up to @samp{len-1}\n-characters, or up to (but not including) the first occurrence in the\n-input of a particular delimiter character @var{delim}---newline\n-(@code{\\n}) by default.  (Naturally, if the stream reaches end of file\n-first, that too will terminate reading.)\n-\n-If @var{delim} was present in the input, it remains available as if\n-unread; to discard it instead, see @code{iostream::getline}.\n-\n-@code{get} writes @samp{\\0} at the end of the string, regardless\n-of which condition terminates the read.\n-@end deftypefn\n-\n-@deftypefn Method istream& istream::get (streambuf& @var{sb} @w{[, char} @var{delim}])\n-Read characters from the input stream and copy them on the\n-@code{streambuf} object @var{sb}.  Copying ends either just before the\n-next instance of the delimiter character @var{delim} (newline @code{\\n}\n-by default), or when either stream ends.   If @var{delim} was present in\n-the input, it remains available as if unread.\n-@end deftypefn\n-\n-@deftypefn Method istream& istream::getline (@var{charptr}, int @var{len} @w{[, char} @var{delim}])\n-Read a line from the input stream, into the array at @var{charptr}.\n-@var{charptr} may be any of three kinds of pointer: @code{char*},\n-@code{unsigned char*}, or @code{signed char*}.\n-\n-The remaining arguments limit how much to read: up to (but not\n-including) the first occurrence in the input of a line delimiter\n-character @var{delim}---newline (@code{\\n}) by default, or up to\n-@samp{len-1} characters (or to end of file, if that happens sooner).\n-\n-If @code{getline} succeeds in reading a ``full line'', it also discards\n-the trailing delimiter character from the input stream.  (To preserve it\n-as available input, see the similar form of @code{iostream::get}.)\n-\n-If @var{delim} was @emph{not} found before @var{len} characters or end\n-of file, @code{getline} sets the @code{ios::fail} flag, as well as the\n-@code{ios::eof} flag if appropriate.\n-\n-@code{getline} writes a null character at the end of the string, regardless\n-of which condition terminates the read.\n-@end deftypefn\n-\n-@deftypefn Method istream& istream::read (@var{pointer}, int @var{len})\n-Read @var{len} bytes into the location at @var{pointer}, unless the\n-input ends first.\n-\n-@var{pointer} may be of type @code{char*}, @code{void*}, @code{unsigned\n-char*}, or @code{signed char*}.\n-\n-If the @code{istream} ends before reading @var{len} bytes, @code{read}\n-sets the @code{ios::fail} flag.\n-@end deftypefn\n-\n-@deftypefn Method istream& istream::gets (char **@var{s} @w{[, char} @var{delim}])\n-A @sc{gnu} extension, to read an arbitrarily long string\n-from the current input position to the next instance of the @var{delim}\n-character (newline @code{\\n} by default).\n-\n-To permit reading a string of arbitrary length, @code{gets} allocates\n-whatever memory is required.  Notice that the first argument @var{s} is\n-an address to record a character pointer, rather than the pointer\n-itself.\n-@end deftypefn\n-\n-@deftypefn Method istream& istream::scan (const char *format ...)\n-A @sc{gnu} extension, similar to @code{fscanf(@var{file},\n-@var{format}, ...)}.  The @var{format} is a @code{scanf}-style format\n-control string, which is used to read the variables in the remainder of\n-the argument list from the @code{istream}.\n-@end deftypefn\n-\n-@deftypefn Method istream& istream::vscan (const char *format, va_list args)\n-Like @code{istream::scan}, but takes a single @code{va_list} argument.\n-@end deftypefn\n-\n-@node Input Position\n-@subsection Repositioning an @code{istream}\n-\n-Use these methods to control the current input position:\n-\n-@deftypefn Method streampos istream::tellg ()\n-Return the current read position, so that you can save it and return to\n-it later with @code{istream::seekg}.\n-@end deftypefn\n-\n-@deftypefn Method istream& istream::seekg (streampos @var{p})\n-Reset the input pointer (if the input device permits it) to @var{p},\n-usually the result of an earlier call to @code{istream::tellg}.\n-@end deftypefn\n-\n-@deftypefn Method istream& istream::seekg (streamoff @var{offset}, ios::seek_dir @var{ref})\n-Reset the input pointer (if the input device permits it) to @var{offset}\n-characters from the beginning of the input, the current position, or the\n-end of input.  Specify how to interpret @var{offset} with one of these\n-values for the second argument:\n-\n-@vtable @code\n-@item ios::beg\n-Interpret @var{loc} as an absolute offset from the beginning of the\n-file.\n-\n-@item ios::cur\n-Interpret @var{loc} as an offset relative to the current output\n-position.\n-\n-@item ios::end\n-Interpret @var{loc} as an offset from the current end of the output\n-stream.\n-@end vtable\n-@end deftypefn\n-\n-@node Istream Housekeeping\n-@subsection Miscellaneous @code{istream} utilities\n-\n-Use these methods for housekeeping on @code{istream} objects:\n-\n-@deftypefn Method int istream::gcount ()\n-Report how many characters were read from this @code{istream} in the\n-last unformatted input operation.\n-@c FIXME! Define \"unformatted input\" somewhere...\n-@end deftypefn\n-\n-@deftypefn Method int istream::ipfx (int @var{keepwhite})\n-Ensure that the @code{istream} object is ready for reading; check for\n-errors and end of file and flush any tied stream.  @code{ipfx} skips\n-whitespace if you specify @code{0} as the @var{keepwhite}\n-argument, @emph{and} @code{ios::skipws} is set for this stream.\n-\n-To avoid skipping whitespace (regardless of the @code{skipws} setting on\n-the stream), use @code{1} as the argument.\n-\n-Call @code{istream::ipfx} to simplify writing your own methods for reading\n-@code{istream} objects.\n-@end deftypefn\n-\n-@deftypefn Method void istream::isfx ()\n-A placeholder for compliance with the draft @sc{ansi} standard; this\n-method does nothing whatever.\n-\n-If you wish to write portable standard-conforming code on @code{istream}\n-objects, call @code{isfx} after any operation that reads from an\n-@code{istream}; if @code{istream::ipfx} has any special effects that\n-must be cancelled when done, @code{istream::isfx} will cancel them.\n-@end deftypefn\n-\n-@deftypefn Method istream& istream::ignore ([int @var{n}] @w{[, int} @var{delim}])\n-Discard some number of characters pending input.  The first optional\n-argument @var{n} specifies how many characters to skip.  The second\n-optional argument @var{delim} specifies a ``boundary'' character:\n-@code{ignore} returns immediately if this character appears in the\n-input.\n-\n-By default, @var{delim} is @code{EOF}; that is, if you do not specify a\n-second argument, only the count @var{n} restricts how much to ignore\n-(while input is still available).\n-\n-If you do not specify how many characters to ignore, @code{ignore}\n-returns after discarding only one character.\n-@end deftypefn\n-\n-@deftypefn Method istream& istream::putback (char @var{ch})\n-Attempts to back up one character, replacing the character backed-up\n-over by @var{ch}.  Returns @code{EOF} if this is not allowed.  Putting\n-back the most recently read character is always allowed.  (This method\n-corresponds to the C function @code{ungetc}.)\n-@end deftypefn\n-\n-@deftypefn Method istream& istream::unget ()\n-Attempt to back up one character.\n-@end deftypefn\n-\n-@node Iostream\n-@section Input and output together: class @code{iostream}\n-\n-If you need to use the same stream for input and output, you can use an\n-object of the class @code{iostream}, which is derived from @emph{both}\n-@code{istream} and @code{ostream}.\n-\n-The constructors for @code{iostream} behave just like the constructors\n-for @code{istream}.\n-\n-@deftypefn Constructor {} iostream::iostream ()\n-When used without arguments, the @code{iostream} constructor simply\n-allocates a new @code{ios} object, and initializes the input counter\n-(the value reported by @code{istream::gcount}) to @code{0}.\n-@end deftypefn\n-\n-@deftypefn Constructor {} iostream::iostream (streambuf* @var{sb} @w{[, ostream*} @var{tie}])\n-You can also call a constructor with one or two arguments.  The first\n-argument @var{sb} is a @code{streambuf*}; if you supply this pointer,\n-the constructor uses that @code{streambuf} for input and output.\n-\n-You can use the optional second argument @var{tie} (an @code{ostream*})\n-to specify a related output stream as the initial value for\n-@code{ios::tie}.\n-@end deftypefn\n-\n-@cindex @code{iostream} destructor\n-@cindex destructor for @code{iostream}\n-As for @code{ostream} and @code{istream}, @code{iostream} simply uses\n-the @code{ios} destructor.  However, an @code{iostream} is not deleted by\n-its destructor.\n-\n-You can use all the @code{istream}, @code{ostream}, and @code{ios}\n-methods with an @code{iostream} object.\n-\n-@node Files and Strings\n-@chapter Classes for Files and Strings\n-\n-There are two very common special cases of input and output: using files,\n-and using strings in memory.\n-\n-@code{libio} defines four specialized classes for these cases:\n-\n-@ftable @code\n-@item ifstream\n-Methods for reading files.\n-\n-@item ofstream\n-Methods for writing files.\n-\n-@item istrstream\n-Methods for reading strings from memory.\n-\n-@item ostrstream\n-Methods for writing strings in memory.\n-@end ftable\n-\n-@menu\n-* Files::\tReading and writing files.\n-* Strings::\tReading and writing strings in memory.\n-@end menu\n-\n-@node Files\n-@section Reading and writing files\n-\n-These methods are declared in @file{fstream.h}.\n-\n-@findex ifstream\n-@cindex class @code{ifstream}\n-You can read data from class @code{ifstream} with any operation from class\n-@code{istream}.  There are also a few specialized facilities:\n-\n-@deftypefn Constructor {} ifstream::ifstream ()\n-Make an @code{ifstream} associated with a new file for input.  (If you\n-use this version of the constructor, you need to call\n-@code{ifstream::open} before actually reading anything)\n-@end deftypefn\n-\n-@deftypefn Constructor {} ifstream::ifstream (int @var{fd})\n-Make an @code{ifstream} for reading from a file that was already open,\n-using file descriptor @var{fd}.  (This constructor is compatible with\n-other versions of iostreams for @sc{posix} systems, but is not part of\n-the @sc{ansi} working paper.)\n-@end deftypefn\n-\n-@deftypefn Constructor {} ifstream::ifstream (const char* @var{fname} @w{[, int} @var{mode} @w{[, int} @var{prot}]])\n-Open a file @code{*@var{fname}} for this @code{ifstream} object.\n-\n-By default, the file is opened for input (with @code{ios::in} as\n-@var{mode}).  If you use this constructor, the file will be closed when\n-the @code{ifstream} is destroyed.\n-\n-You can use the optional argument @var{mode} to specify how to open the\n-file, by combining these enumerated values (with @samp{|} bitwise or).\n-(These values are actually defined in class @code{ios}, so that all\n-file-related streams may inherit them.)  Only some of these modes are\n-defined in the latest draft @sc{ansi} specification; if portability is\n-important, you may wish to avoid the others.\n-\n-@vtable @code\n-@item ios::in\n-Open for input.  (Included in @sc{ansi} draft.)\n-\n-@item ios::out\n-Open for output.  (Included in @sc{ansi} draft.)\n-\n-@item ios::ate\n-Set the initial input (or output) position to the end of the file.\n-\n-@item ios::app\n-Seek to end of file before each write.  (Included in @sc{ansi} draft.)\n-\n-@item ios::trunc\n-Guarantee a fresh file; discard any contents that were previously\n-associated with it.\n-\n-@item ios::nocreate\n-Guarantee an existing file; fail if the specified file did not already\n-exist.\n-\n-@item ios::noreplace\n-Guarantee a new file; fail if the specified file already existed.\n-\n-@item ios::bin\n-Open as a binary file (on systems where binary and text files have different\n-properties, typically how @samp{\\n} is mapped; included in @sc{ansi} draft).\n-@end vtable\n-\n-@noindent\n-The last optional argument @var{prot} is specific to Unix-like systems;\n-it specifies the file protection (by default @samp{644}).\n-@end deftypefn\n-\n-@deftypefn Method void ifstream::open (const char* @var{fname} @w{[, int} @var{mode} @w{[, int} @var{prot}]])\n-Open a file explicitly after the associated @code{ifstream} object\n-already exists (for instance, after using the default constructor).  The\n-arguments, options and defaults all have the same meanings as in the\n-fully specified @code{ifstream} constructor.\n-@end deftypefn\n-\n-@findex ostream\n-@cindex class @code{ostream}\n-You can write data to class @code{ofstream} with any operation from class\n-@code{ostream}.  There are also a few specialized facilities:\n-\n-@deftypefn Constructor {} ofstream::ofstream ()\n-Make an @code{ofstream} associated with a new file for output.\n-@end deftypefn\n-\n-@deftypefn Constructor {} ofstream::ofstream (int @var{fd})\n-Make an @code{ofstream} for writing to a file that was already open,\n-using file descriptor @var{fd}.\n-@end deftypefn\n-\n-@deftypefn Constructor {} ofstream::ofstream (const char* @var{fname} @w{[, int} @var{mode} @w{[, int} @var{prot}]])\n-Open a file @code{*@var{fname}} for this @code{ofstream} object.\n-\n-By default, the file is opened for output (with @code{ios::out} as @var{mode}).\n-You can use the optional argument @var{mode} to specify how to open the\n-file, just as described for @code{ifstream::ifstream}.\n-\n-The last optional argument @var{prot} specifies the file protection (by\n-default @samp{644}).\n-@end deftypefn\n-\n-@deftypefn Destructor {} ofstream::~ofstream ()\n-The files associated with @code{ofstream} objects are closed when the\n-corresponding object is destroyed.\n-@end deftypefn\n-\n-@deftypefn Method void ofstream::open (const char* @var{fname} @w{[, int} @var{mode} @w{[, int} @var{prot}]])\n-Open a file explicitly after the associated @code{ofstream} object\n-already exists (for instance, after using the default constructor).  The\n-arguments, options and defaults all have the same meanings as in the\n-fully specified @code{ofstream} constructor.\n-@end deftypefn\n-\n-@findex fstream\n-@cindex class @code{fstream}\n-The class @code{fstream} combines the facilities of @code{ifstream} and\n-@code{ofstream}, just as @code{iostream} combines @code{istream} and\n-@code{ostream}.\n-\n-@c FIXME-future: say something about fstream constructor, maybe.\n-\n-@findex fstreambase\n-@cindex class @code{fstreambase}\n-The class @code{fstreambase} underlies both @code{ifstream} and\n-@code{ofstream}.  They both inherit this additional method:\n-\n-@deftypefn Method void fstreambase::close ()\n-Close the file associated with this object, and set @code{ios::fail} in\n-this object to mark the event.\n-@end deftypefn\n-\n-@node Strings\n-@section Reading and writing in memory\n-\n-@c FIXME!! Per, there's a lot of guesswork here---please check carefully!\n-\n-@findex istrstream\n-@cindex class @code{istrstream}\n-@findex ostrstream\n-@cindex class @code{ostrstream}\n-@findex strstream\n-@cindex class @code{strstream}\n-@findex strstreambase\n-@cindex class @code{strstreambase}\n-@findex strstreambuf\n-@cindex class @code{strstreambuf}\n-The classes @code{istrstream}, @code{ostrstream}, and @code{strstream}\n-provide some additional features for reading and writing strings in\n-memory---both static strings, and dynamically allocated strings.  The\n-underlying class @code{strstreambase} provides some features common to\n-all three; @code{strstreambuf} underlies that in turn.\n-\n-@c FIXME-future:  Document strstreambuf methods one day, when we document\n-@c streambuf more fully.\n-\n-@deftypefn Constructor {} istrstream::istrstream (const char* @var{str} @w{[, int} @var{size}])\n-Associate the new input string class @code{istrstream} with an existing\n-static string starting at @var{str}, of size @var{size}.  If you do not\n-specify @var{size}, the string is treated as a @code{NUL} terminated string.\n-@end deftypefn\n-\n-@deftypefn Constructor {} ostrstream::ostrstream ()\n-Create a new stream for output to a dynamically managed string, which\n-will grow as needed.\n-@end deftypefn\n-\n-@deftypefn Constructor {} ostrstream::ostrstream (char* @var{str}, int @var{size} [,int @var{mode}])\n-A new stream for output to a statically defined string of length\n-@var{size}, starting at @var{str}.  You may optionally specify one of\n-the modes described for @code{ifstream::ifstream}; if you do not specify\n-one, the new stream is simply open for output, with mode @code{ios::out}.\n-@end deftypefn\n-\n-@deftypefn Method int ostrstream::pcount ()\n-Report the current length of the string associated with this @code{ostrstream}.\n-@end deftypefn\n-\n-@deftypefn Method char* ostrstream::str ()\n-A pointer to the string managed by this @code{ostrstream}.  Implies\n-@samp{ostrstream::freeze()}.\n-\n-Note that if you want the string to be nul-terminated,\n-you must do that yourself (perhaps by writing ends to the stream).\n-@end deftypefn\n-\n-@deftypefn Method void ostrstream::freeze ([int @var{n}])\n-If @var{n} is nonzero (the default), declare that the string associated\n-with this @code{ostrstream} is not to change dynamically; while frozen,\n-it will not be reallocated if it needs more space, and it will not be\n-deallocated when the @code{ostrstream} is destroyed.  Use\n-@samp{freeze(1)} if you refer to the string as a pointer after creating\n-it via @code{ostrstream} facilities.\n-\n-@samp{freeze(0)} cancels this declaration, allowing a dynamically\n-allocated string to be freed when its @code{ostrstream} is destroyed.\n-\n-If this @code{ostrstream} is already static---that is, if it was created\n-to manage an existing statically allocated string---@code{freeze} is\n-unnecessary, and has no effect.\n-@end deftypefn\n-\n-@deftypefn Method int ostrstream::frozen ()\n-Test whether @code{freeze(1)} is in effect for this string.\n-@end deftypefn\n-\n-@deftypefn Method strstreambuf* strstreambase::rdbuf ()\n-A pointer to the underlying @code{strstreambuf}.\n-@end deftypefn\n-\n-@node Streambuf\n-@chapter Using the @code{streambuf} Layer\n-\n-The @code{istream} and @code{ostream} classes are meant to handle\n-conversion between objects in your program and their textual representation.\n-\n-By contrast, the underlying @code{streambuf} class is for transferring\n-raw bytes between your program, and input sources or output sinks.\n-Different @code{streambuf} subclasses connect to different kinds of\n-sources and sinks.\n-\n-The @sc{gnu} implementation of @code{streambuf} is still evolving; we\n-describe only some of the highlights.\n-\n-@menu\n-* Areas::\t\tAreas in a streambuf.\n-* Overflow::\t\tSimple output re-direction\n-* Formatting::\t\tC-style formatting for streambuf objects.\n-* Stdiobuf::\t\tWrappers for C stdio.\n-* Procbuf::             Reading/writing from/to a pipe\n-* Backing Up::\t\tMarking and returning to a position.\n-* Indirectbuf::\t\tForwarding I/O activity.\n-@end menu\n-\n-@node Areas\n-@section Areas of a @code{streambuf}\n-\n-Streambuf buffer management is fairly sophisticated (this is a\n-nice way to say ``complicated'').  The standard protocol\n-has the following ``areas'':\n-\n-@itemize @bullet\n-@item\n-@cindex put area\n-The @dfn{put area} contains characters waiting for output.\n-\n-@item\n-@cindex get area\n-The @dfn{get area} contains characters available for reading.\n-@end itemize\n-\n-The @sc{gnu} @code{streambuf} design extends this, but the details are\n-still evolving.\n-\n-The following methods are used to manipulate these areas.\n-These are all protected methods, which are intended to be\n-used by virtual function in classes derived from @code{streambuf}.\n-They are also all ANSI/ISO-standard, and the ugly names\n-are traditional.\n-(Note that if a pointer points to the 'end' of an area,\n-it means that it points to the character after the area.)\n-\n-@deftypefn Method char* streambuf::pbase () const\n-Returns a pointer to the start of the put area.\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::epptr () const\n-Returns a pointer to the end of the put area.\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::pptr () const\n-If @code{pptr() < epptr ()}, the @code{pptr()}\n-returns a pointer to the current put position.\n-(In that case, the next write will\n-overwrite @code{*pptr()}, and increment @code{pptr()}.)\n-Otherwise, there is no put position available\n-(and the next character written will cause @code{streambuf::overflow}\n-to be called).\n-@end deftypefn\n-\n-@deftypefn Method void streambuf::pbump (int @var{N})\n-Add @var{N} to the current put pointer.\n-No error checking is done.\n-@end deftypefn\n-\n-@deftypefn Method void streambuf::setp (char* @var{P}, char* @var{E})\n-Sets the start of the put area to @var{P}, the end of the put area to @var{E},\n-and the current put pointer to @var{P} (also).\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::eback () const\n-Returns a pointer to the start of the get area.\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::egptr () const\n-Returns a pointer to the end of the get area.\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::gptr () const\n-If @code{gptr() < egptr ()}, then @code{gptr()}\n-returns a pointer to the current get position.\n-(In that case the next read will read @code{*gptr()},\n-and possibly increment @code{gptr()}.)\n-Otherwise, there is no read position available\n-(and the next read will cause @code{streambuf::underflow}\n-to be called).\n-@end deftypefn\n-\n-@deftypefn Method void streambuf:gbump (int @var{N})\n-Add @var{N} to the current get pointer.\n-No error checking is done.\n-@end deftypefn\n-\n-@deftypefn Method void streambuf::setg (char* @var{B}, char* @var{P}, char* @var{E})\n-Sets the start of the get area to @var{B}, the end of the get area to @var{E},\n-and the current put pointer to @var{P}.\n-@end deftypefn\n-\n-@node Overflow\n-@section Simple output re-direction by redefining @code{overflow}\n-\n-Suppose you have a function @code{write_to_window} that\n-writes characters to a @code{window} object.  If you want to use the\n-ostream function to write to it, here is one (portable) way to do it.\n-This depends on the default buffering (if any).\n-\n-@cartouche\n-@smallexample\n-#include <iostream.h>\n-/* Returns number of characters successfully written to @var{win}. */\n-extern int write_to_window (window* win, char* text, int length);\n-\n-class windowbuf : public streambuf @{\n-    window* win;\n-  public:\n-    windowbuf (window* w) @{ win = w; @}\n-    int sync ();\n-    int overflow (int ch);\n-    // Defining xsputn is an optional optimization.\n-    // (streamsize was recently added to ANSI C++, not portable yet.)\n-    streamsize xsputn (char* text, streamsize n);\n-@};\n-\n-int windowbuf::sync ()\n-@{ streamsize n = pptr () - pbase ();\n-  return (n && write_to_window (win, pbase (), n) != n) ? EOF : 0;\n-@}\n-\n-int windowbuf::overflow (int ch)\n-@{ streamsize n = pptr () - pbase ();\n-  if (n && sync ())\n-    return EOF;\n-  if (ch != EOF)\n-    @{\n-      char cbuf[1];\n-      cbuf[0] = ch;\n-      if (write_to_window (win, cbuf, 1) != 1)\n-        return EOF;\n-    @}\n-  pbump (-n);  // Reset pptr().\n-  return 0;\n-@}\n-\n-streamsize windowbuf::xsputn (char* text, streamsize n)\n-@{ return sync () == EOF ? 0 : write_to_window (win, text, n); @}\n-\n-int\n-main (int argc, char**argv)\n-@{\n-  window *win = ...;\n-  windowbuf wbuf(win);\n-  ostream wstr(&wbuf);\n-  wstr << \"Hello world!\\n\";\n-@}\n-@end smallexample\n-@end cartouche\n-\n-\n-\n-@node Formatting\n-@section C-style formatting for @code{streambuf} objects\n-\n-The @sc{gnu} @code{streambuf} class supports @code{printf}-like\n-formatting and scanning.\n-\n-@deftypefn Method int streambuf::form (const char *@var{format}, ...)\n-Similar to @code{fprintf(@var{file}, @var{format}, ...)}.\n-The @var{format} is a @code{printf}-style format control string, which is used\n-to format the (variable number of) arguments, printing the result on\n-the @code{this} streambuf.  The result is the number of characters printed.\n-@end deftypefn\n-\n-@deftypefn Method int streambuf::vform (const char *@var{format}, va_list @var{args})\n-Similar to @code{vfprintf(@var{file}, @var{format}, @var{args})}.\n-The @var{format} is a @code{printf}-style format control string, which is used\n-to format the argument list @var{args}, printing the result on\n-the @code{this} streambuf.  The result is the number of characters printed.\n-@end deftypefn\n-\n-@deftypefn Method int streambuf::scan (const char *@var{format}, ...)\n-Similar to @code{fscanf(@var{file}, @var{format}, ...)}.\n-The @var{format} is a @code{scanf}-style format control string, which is used\n-to read the (variable number of) arguments from the @code{this} streambuf.\n-The result is the number of items assigned, or @code{EOF} in case of\n-input failure before any conversion.\n-@end deftypefn\n-\n-@deftypefn Method int streambuf::vscan (const char *@var{format}, va_list @var{args})\n-Like @code{streambuf::scan}, but takes a single @code{va_list} argument.\n-@end deftypefn\n-\n-@node Stdiobuf\n-@section Wrappers for C @code{stdio}\n-\n-A @dfn{stdiobuf} is a @code{streambuf} object that points to\n-a @code{FILE} object (as defined by @code{stdio.h}).\n-All @code{streambuf} operations on the @code{stdiobuf} are forwarded\n-to the @code{FILE}.  Thus the @code{stdiobuf} object provides a\n-wrapper around a @code{FILE}, allowing use of @code{streambuf}\n-operations on a @code{FILE}.  This can be useful when mixing\n-C code with C++ code.\n-\n-The pre-defined streams @code{cin}, @code{cout}, and @code{cerr} are\n-normally implemented as @code{stdiobuf} objects that point to\n-respectively @code{stdin}, @code{stdout}, and @code{stderr}.  This is\n-convenient, but it does cost some extra overhead.\n-\n-If you set things up to use the implementation of @code{stdio} provided\n-with this library, then @code{cin}, @code{cout}, and @code{cerr} will be\n-set up to use @code{stdiobuf} objects, since you get their benefits\n-for free.  @xref{Stdio,,C Input and Output}.\n-\n-@ignore\n-@c FIXME-future: setbuf is not yet documented, hence this para is not useful.\n-Note that if you use @code{setbuf} to give a buffer to a @code{stdiobuf},\n-that buffer will provide intermediate buffering in addition that\n-whatever is done by the @code{FILE}.\n-@end ignore\n-\n-@node Procbuf\n-@section Reading/writing from/to a pipe\n-\n-The @dfn{procbuf} class is a @sc{gnu} extension.  It is derived from\n-@code{streambuf}.  A @code{procbuf} can be @dfn{closed} (in which case\n-it does nothing), or @dfn{open} (in which case it allows communicating\n-through a pipe with some other program).\n-\n-@deftypefn Constructor {} procbuf::procbuf ()\n-Creates a @code{procbuf} in a @dfn{closed} state.\n-@end deftypefn\n-\n-@deftypefn Method procbuf* procbuf::open (const char *@var{command}, int @var{mode})\n-Uses the shell (@file{/bin/sh}) to run a program specified by @var{command}.\n-\n-If @var{mode} is @samp{ios::in}, standard output from the program is sent\n-to a pipe; you can read from the pipe by reading from the\n-@code{procbuf}.  (This is similar to @w{@samp{popen(@var{command}, \"r\")}}.)\n-\n-If @var{mode} is @samp{ios::out}, output written to the\n-@code{procbuf} is written to a pipe; the program is set up to read its\n-standard input from (the other end of) the pipe.  (This is similar to\n-@w{@samp{popen(@var{command}, \"w\")}}.)\n-\n-The @code{procbuf} must start out in the @dfn{closed} state.\n-Returns @samp{*this} on success, and @samp{NULL} on failure.\n-@end deftypefn\n-\n-@deftypefn Constructor {} procbuf::procbuf (const char *@var{command}, int @var{mode})\n-Calls @samp{procbuf::open (@var{command}, @var{mode})}.\n-@end deftypefn\n-\n-@deftypefn Method procbuf* procbuf::close ()\n-Waits for the program to finish executing,\n-and then cleans up the resources used.\n-Returns @samp{*this} on success, and @samp{NULL} on failure.\n-@end deftypefn\n-\n-@deftypefn Destructor {} procbuf::~procbuf ()\n-Calls @samp{procbuf::close}.\n-@end deftypefn\n-\n-@node Backing Up\n-@section Backing up\n-\n-The @sc{gnu} iostream library allows you to ask a @code{streambuf} to\n-remember the current position.  This allows you to go back to this\n-position later, after reading further.  You can back up arbitrary\n-amounts, even on unbuffered files or multiple buffers' worth, as long as\n-you tell the library in advance.  This unbounded backup is very useful\n-for scanning and parsing applications.  This example shows a typical\n-scenario:\n-\n-@cartouche\n-@smallexample\n-// Read either \"dog\", \"hound\", or \"hounddog\".\n-// If \"dog\" is found, return 1.\n-// If \"hound\" is found, return 2.\n-// If \"hounddog\" is found, return 3.\n-// If none of these are found, return -1.\n-int my_scan(streambuf* sb)\n-@{\n-    streammarker fence(sb);\n-    char buffer[20];\n-    // Try reading \"hounddog\":\n-    if (sb->sgetn(buffer, 8) == 8\n-        && strncmp(buffer, \"hounddog\", 8) == 0)\n-      return 3;\n-    // No, no \"hounddog\":  Back up to 'fence'\n-    sb->seekmark(fence); // \n-    // ... and try reading \"dog\":\n-    if (sb->sgetn(buffer, 3) == 3\n-        && strncmp(buffer, \"dog\", 3) == 0)\n-      return 1;\n-    // No, no \"dog\" either:  Back up to 'fence'\n-    sb->seekmark(fence); // \n-    // ... and try reading \"hound\":\n-    if (sb->sgetn(buffer, 5) == 5\n-        && strncmp(buffer, \"hound\", 5) == 0)\n-      return 2;\n-    // No, no \"hound\" either:  Back up and signal failure.\n-    sb->seekmark(fence); // Backup to 'fence'\n-    return -1;\n-@}\n-@end smallexample\n-@end cartouche\n-\n-@deftypefn Constructor {} streammarker::streammarker (streambuf* @var{sbuf})\n-Create a @code{streammarker} associated with @var{sbuf}\n-that remembers the current position of the get pointer.\n-@end deftypefn\n-\n-@deftypefn Method int streammarker::delta (streammarker& @var{mark2})\n-Return the difference between the get positions corresponding\n-to @code{*this} and @var{mark2} (which must point into the same\n-@code{streambuffer} as @code{this}).\n-@end deftypefn\n-\n-@deftypefn Method int streammarker::delta ()\n-Return the position relative to the streambuffer's current get position.\n-@end deftypefn\n-\n-@deftypefn Method int streambuf::seekmark (streammarker& @var{mark})\n-Move the get pointer to where it (logically) was when @var{mark}\n-was constructed.\n-@end deftypefn\n-\n-@node Indirectbuf\n-@section Forwarding I/O activity\n-\n-An @dfn{indirectbuf} is one that forwards all of its I/O requests\n-to another streambuf.\n-\n-@ignore\n-@c FIXME-future: get_stream and put_stream are so far undocumented.\n-All get-related requests are sent to get_stream().\n-All put-related requests are sent to put_stream().\n-@end ignore\n-\n-An @code{indirectbuf} can be used to implement Common Lisp\n-synonym-streams and two-way-streams:\n-\n-@example\n-class synonymbuf : public indirectbuf @{\n-   Symbol *sym;\n-   synonymbuf(Symbol *s) @{ sym = s; @}\n-   virtual streambuf *lookup_stream(int mode) @{\n-       return coerce_to_streambuf(lookup_value(sym)); @}\n-@};\n-@end example\n-\n-@node Stdio\n-@chapter C Input and Output\n-\n-@code{libio} is distributed with a complete implementation of the ANSI C\n-@code{stdio} facility.  It is implemented using @code{streambuf}\n-objects.  @xref{Stdiobuf,,Wrappers for C @code{stdio}}.\n-\n-The @code{stdio} package is intended as a replacement for the whatever\n-@code{stdio} is in your C library.\n-@ignore\n-@c FIXME-future:  This is not useful unless we specify what problems.\n-It can co-exist with C libraries that have alternate implementations of\n-stdio, but there may be some problems.\n-@end ignore\n-Since @code{stdio} works best when you build @code{libc} to contain it, and\n-that may be inconvenient, it is not installed by default.\n-\n-Extensions beyond @sc{ansi}:\n-\n-@itemize @bullet\n-@item\n-A stdio @code{FILE} is identical to a streambuf.\n-Hence there is no need to worry about synchronizing C and C++\n-input/output---they are by definition always synchronized.\n-\n-@item\n-If you create a new streambuf sub-class (in C++), you can use it as a\n-@code{FILE} from C.  Thus the system is extensible using the standard\n-@code{streambuf} protocol.\n-\n-@item\n-You can arbitrarily mix reading and writing, without having to seek\n-in between.\n-\n-@item\n-Unbounded @code{ungetc()} buffer.\n-@end itemize\n-\n-@ignore\n-@c FIXME-future: Per says this is not ready to go public at v0.5\n-@node Libio buffer management\n-@chapter Libio buffer management\n-\n-The libio user functions present an abstract sequence of characters,\n-that they read and write from.  A number of buffers are used to go\n-between the user program and the abstract sequence.  These buffers are\n-concrete arrays of characters that contain some sub-sequence of the\n-abstract sequence.\n-\n-The libio buffer management protocol is fairly complex.  Its design is\n-based on the C++ @code{streambuf} protocol, so that the C++\n-@code{streambuf} classes can be trivially implemented on top of the\n-libio protocol.\n-\n-The @dfn{write area} contains characters waiting for output.\n-\n-The @dfn{read area} contains characters available for reading.\n-\n-The @dfn{reserve area} is available to virtual methods.\n-Usually, the get and/or put areas are part of the reserve area.\n-\n-The @dfn{main get area} contains characters that have\n-been read in from the character source, but not yet\n-read by the application.\n-\n-The @dfn{backup area} contains previously read data that is being saved\n-because of a user request, or that have been \"unread\" (put back).\n-@end ignore\n-\n-@ignore\n-@c Per says this design is not finished\n-@node Streambuf internals\n-@chapter Streambuf internals\n-\n-@menu\n-* Buffer management::\n-* Filebuf internals::\n-@end menu\n-\n-@node Buffer management\n-@section Buffer management\n-\n-@subsection Areas\n-\n-NOTE:  This chapter is due for an update.\n-\n-Streambuf buffer management is fairly sophisticated (this is a\n-nice way to say \"complicated\").  The standard protocol\n-has the following \"areas\":\n-\n-@itemize @bullet\n-@cindex put area\n-@item\n-The @dfn{put area} contains characters waiting for output.\n-@cindex get area\n-@item\n-The @dfn{get area} contains characters available for reading.\n-@cindex reserve area\n-@item\n-The @dfn{reserve area} is available to virtual methods.\n-Usually, the get and/or put areas are part of the reserve area.\n-@end itemize\n-\n-The @sc{gnu} @code{streambuf} design extends this by supporting two\n-get areas:\n-@itemize @bullet\n-@cindex main get area\n-@item\n-The @dfn{main get area} contains characters that have\n-been read in from the character source, but not yet\n-read by the application.\n-@cindex backup area\n-@item\n-The @dfn{backup area} contains previously read data that is being\n-saved because of a user request, or that have been \"unread\" (putback).\n-@end itemize\n-\n-The backup and the main get area are logically contiguous:  That is,\n-the first character of the main get area follows the last character\n-of the backup area.\n-\n-The @dfn{current get area} is whichever one of the backup or\n-main get areas that is currently being read from.\n-The other of the two is the @dfn{non-current get area}.\n-\n-@subsection Pointers\n-\n-The following @code{char*} pointers define the various areas.\n-\n-@deftypefn Method char* streambuf::base ()\n-The start of the reserve area.\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::ebuf ()\n-The end of the reserve area.\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::Gbase ()\n-The start of the main get area.\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::eGptr ()\n-The end of the main get area.\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::Bbase ()\n-The start of the backup area.\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::Bptr ()\n-The start of the used part of the backup area.\n-The area (@code{Bptr()} .. @code{eBptr()}) contains data that has been\n-pushed back, while (@code{Bbase()} .. @code{eBptr()}) contains unused\n-space available for future putbacks.\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::eBptr ()\n-The end of the backup area.\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::Nbase ()\n-The start of the non-current get area (either @code{main_gbase} or @code{backup_gbase}).\n-@end deftypefn\n-\n-@deftypefn Method char* streambuf::eNptr ()\n-The end of the non-current get area.\n-@end deftypefn\n-\n-@node Filebuf internals\n-@section Filebuf internals\n-\n-The @code{filebuf} is used a lot, so it is importamt that it be\n-efficient.  It is also supports rather complex semantics.\n-so let us examine its implementation.\n-\n-@subsection Tied read and write pointers\n-\n-The streambuf model allows completely independent read and write pointers.\n-However, a @code{filebuf} has only a single logical pointer used\n-for both reads and writes.  Since the @code{streambuf} protocol\n-uses @code{gptr()} for reading and @code{pptr()} for writing,\n-we map the logical file pointer into either @code{gptr()} or @code{pptr()}\n-at different times.\n-\n-@itemize @bullet\n-@item\n-Reading is allowed when @code{gptr() < egptr()}, which we call get mode.\n-\n-@item\n-Writing is allowed when @code{pptr() < epptr()}, which we call put mode.\n-@end itemize\n-\n-@noindent\n-A @code{filebuf} cannot be in get mode and put mode at the same time.\n-\n-We have up to two buffers:\n-\n-@itemize @bullet\n-@item\n-The backup area, defined by @code{Bbase()}, @code{Bptr()}, and @code{eBptr()}.\n-This can be empty.\n-\n-@item\n-The reserve area, which also contains the main get area.\n-For an unbuffered file, the (@code{shortbuf()}..@code{shortbuf()+1}) is used,\n-where @code{shortbuf()} points to a 1-byte buffer that is part of\n-the @code{filebuf}.\n-@end itemize\n-\n-@noindent\n-The file system's idea of the current position is @code{eGptr()}.\n-\n-Characters that have been written into a buffer but not yet written\n-out (flushed) to the file systems are those between @code{pbase()}\n-and @code{pptr()}.\n-\n-The end of the valid data bytes is:\n-@code{pptr() > eGptr() && pptr() < ebuf() ? pptr() : eGptr()}.\n-\n-If the @code{filebuf} is unbuffered or line buffered,\n-the @code{eptr()} is @code{pbase()}.  This forces a call\n-to @code{overflow()} on each put of a character.\n-The logical @code{epptr()} is @code{epptr() ? ebuf() : NULL}.\n-(If the buffer is read-only, set @code{pbase()}, @code{pptr()},\n-and @code{epptr()} to @code{NULL}. NOT!)\n-@end ignore\n-\n-@node Index\n-@unnumbered Index\n-@printindex cp\n-\n-@contents\n-@bye"}, {"sha": "c9c40cb6ba9a2c66d2f4dbab067a2397a7025fad", "filename": "libio/iostreamP.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FiostreamP.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FiostreamP.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FiostreamP.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,26 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-#include \"streambuf.h\"\n-#include \"libioP.h\""}, {"sha": "348e0956d70f5c461fcf88e0b3bdc1d15c37f255", "filename": "libio/iostrerror.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiostrerror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiostrerror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiostrerror.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,12 +0,0 @@\n-/* This should be replaced by whatever namespace-clean\n-   version of strerror you have available. */\n-\n-#include \"libioP.h\"\n-extern char *strerror __P ((int));\n-\n-char *\n-_IO_strerror (errnum)\n-     int errnum;\n-{\n-  return strerror(errnum);\n-}"}, {"sha": "07f38e747bf363e42a5183f547cba527b8b2e37b", "filename": "libio/ioungetc.c", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioungetc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fioungetc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioungetc.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,46 +0,0 @@\n-/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-\n-int\n-_IO_ungetc (c, fp)\n-     int c;\n-     _IO_FILE *fp;\n-{\n-  int result;\n-  CHECK_FILE (fp, EOF);\n-  if (c == EOF)\n-    return EOF;\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  result = _IO_sputbackc (fp, (unsigned char) c);\n-  _IO_cleanup_region_end (1);\n-  return result;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_ungetc, ungetc)\n-#endif"}, {"sha": "229215ad0e089c4f04f5c4ee4227302ed394c7f9", "filename": "libio/iovfprintf.c", "status": "removed", "additions": 0, "deletions": 903, "changes": 903, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiovfprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiovfprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiovfprintf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe", "patch": "@@ -1,903 +0,0 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-/*\n- * Copyright (c) 1990 Regents of the University of California.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. [rescinded 22 July 1999]\n- * 4. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- */\n-\n-\n-#if defined(LIBC_SCCS) && !defined(lint)\n-static char sccsid[] = \"%W% (Berkeley) %G%\";\n-#endif /* LIBC_SCCS and not lint */\n-\n-/*\n- * Actual printf innards.\n- *\n- * This code is large and complicated...\n- */\n-\n-#include <sys/types.h>\n-#include \"libioP.h\"\n-#include <string.h>\n-#ifdef __STDC__\n-#include <stdarg.h>\n-#else\n-#include <varargs.h>\n-#endif\n-\n-#ifndef _IO_USE_DTOA\n-int __cvt_double __P((double number, register int prec, int flags, int *signp, int fmtch, char *startp, char *endp));\n-#endif\n-\n-/*\n- * Define FLOATING_POINT to get floating point.\n- */\n-#ifndef\tNO_FLOATING_POINT\n-#define\tFLOATING_POINT\n-#endif\n-\n-/* end of configuration stuff */\n-\n-\n-/*\n- * Helper \"class\" for `fprintf to unbuffered': creates a\n- * temporary buffer. */\n-\n-struct helper_file\n-{\n-  struct _IO_FILE_plus _f;\n-  _IO_FILE *_put_stream;\n-};\n-\n-static int\n-_IO_helper_overflow (fp, c)\n-     _IO_FILE *fp;\n-     int c;\n-{\n-  _IO_FILE *target = ((struct helper_file*)fp)->_put_stream;\n-  int used = fp->_IO_write_ptr - fp->_IO_write_base;\n-  if (used)\n-    {\n-      _IO_sputn(target, fp->_IO_write_base, used);\n-      fp->_IO_write_ptr -= used;\n-    }\n-  return _IO_putc (c, fp);\n-}\n-\n-static struct _IO_jump_t _IO_helper_jumps = {\n-  JUMP_INIT_DUMMY,\n-  JUMP_INIT(finish, _IO_default_finish),\n-  JUMP_INIT(overflow, _IO_helper_overflow),\n-  JUMP_INIT(underflow, _IO_default_underflow),\n-  JUMP_INIT(uflow, _IO_default_uflow),\n-  JUMP_INIT(pbackfail, _IO_default_pbackfail),\n-  JUMP_INIT(xsputn, _IO_default_xsputn),\n-  JUMP_INIT(xsgetn, _IO_default_xsgetn),\n-  JUMP_INIT(seekoff, _IO_default_seekoff),\n-  JUMP_INIT(seekpos, _IO_default_seekpos),\n-  JUMP_INIT(setbuf, _IO_default_setbuf),\n-  JUMP_INIT(sync, _IO_default_sync),\n-  JUMP_INIT(doallocate, _IO_default_doallocate),\n-  JUMP_INIT(read, _IO_default_read),\n-  JUMP_INIT(write, _IO_default_write),\n-  JUMP_INIT(seek, _IO_default_seek),\n-  JUMP_INIT(close, _IO_default_close),\n-  JUMP_INIT(stat, _IO_default_stat)\n-};\n-\n-static int\n-helper_vfprintf (fp, fmt0, ap)\n-     _IO_FILE *fp;\n-     char const *fmt0;\n-     _IO_va_list ap;\n-{\n-  char buf[_IO_BUFSIZ];\n-  struct helper_file helper;\n-  register _IO_FILE *hp = (_IO_FILE*)&helper;\n-  int result, to_flush;\n-\n-  /* initialize helper */\n-  helper._put_stream = fp;\n-  hp->_IO_write_base = buf;\n-  hp->_IO_write_ptr = buf;\n-  hp->_IO_write_end = buf+_IO_BUFSIZ;\n-  hp->_IO_file_flags = _IO_MAGIC|_IO_NO_READS;\n-  _IO_JUMPS(hp) = &_IO_helper_jumps;\n-  \n-  /* Now print to helper instead. */\n-  result = _IO_vfprintf(hp, fmt0, ap);\n-\n-  /* Now flush anything from the helper to the fp. */\n-  if ((to_flush = hp->_IO_write_ptr - hp->_IO_write_base) > 0)\n-    {\n-      if (_IO_sputn(fp, hp->_IO_write_base, to_flush) != to_flush)\n-\treturn EOF;\n-    }\n-  return result;\n-}\n-\n-#ifdef FLOATING_POINT\n-\n-#include \"floatio.h\"\n-#define\tBUF\t\t(MAXEXP+MAXFRACT+1)\t/* + decimal point */\n-#define\tDEFPREC\t\t6\n-extern double modf __P((double, double*));\n-\n-#else /* no FLOATING_POINT */\n-\n-#define\tBUF\t\t40\n-\n-#endif /* FLOATING_POINT */\n-\n-\n-/*\n- * Macros for converting digits to letters and vice versa\n- */\n-#define\tto_digit(c)\t((c) - '0')\n-#define is_digit(c)\t((unsigned)to_digit(c) <= 9)\n-#define\tto_char(n)\t((n) + '0')\n-\n-/*\n- * Flags used during conversion.\n- */\n-#define\tLONGINT\t\t0x01\t\t/* long integer */\n-#define\tLONGDBL\t\t0x02\t\t/* long double; unimplemented */\n-#define\tSHORTINT\t0x04\t\t/* short integer */\n-#define\tALT\t\t0x08\t\t/* alternate form */\n-#define\tLADJUST\t\t0x10\t\t/* left adjustment */\n-#define\tZEROPAD\t\t0x20\t\t/* zero (as opposed to blank) pad */\n-#define\tHEXPREFIX\t0x40\t\t/* add 0x or 0X prefix */\n-\n-int\n-_IO_vfprintf (fp, fmt0, ap)\n-     _IO_FILE *fp;\n-     char const *fmt0;\n-     _IO_va_list ap;\n-{\n-\tregister const char *fmt; /* format string */\n-\tregister int ch;\t/* character from fmt */\n-\tregister int n;\t\t/* handy integer (short term usage) */\n-\tregister char *cp;\t/* handy char pointer (short term usage) */\n-\tconst char *fmark;\t/* for remembering a place in fmt */\n-\tregister int flags;\t/* flags as above */\n-\tint ret;\t\t/* return value accumulator */\n-\tint width;\t\t/* width from format (%8d), or 0 */\n-\tint prec;\t\t/* precision from format (%.3d), or -1 */\n-\tchar sign;\t\t/* sign prefix (' ', '+', '-', or \\0) */\n-#ifdef FLOATING_POINT\n-\tint softsign;\t\t/* temporary negative sign for floats */\n-\tdouble _double;\t\t/* double precision arguments %[eEfgG] */\n-#ifndef _IO_USE_DTOA\n-\tint fpprec;\t\t/* `extra' floating precision in [eEfgG] */\n-#endif\n-#endif\n-\tunsigned long _ulong;\t/* integer arguments %[diouxX] */\n-\tenum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */\n-\tint dprec;\t\t/* a copy of prec if [diouxX], 0 otherwise */\n-\tint dpad;\t\t/* extra 0 padding needed for integers */\n-\tint fieldsz;\t\t/* field size expanded by sign, dpad etc */\n-\t/* The initialization of 'size' is to suppress a warning that\n-\t   'size' might be used unitialized.  It seems gcc can't\n-\t   quite grok this spaghetti code ... */\n-\tint size = 0;\t\t/* size of converted field or string */\n-\tchar buf[BUF];\t\t/* space for %c, %[diouxX], %[eEfgG] */\n-\tchar ox[2];\t\t/* space for 0x hex-prefix */\n-\n-\t/*\n-\t * BEWARE, these `goto error' on error, and PAD uses `n'.\n-\t */\n-#define\tPRINT(ptr, len) \\\n-  do { if (_IO_sputn(fp,ptr, len) != len) goto error; } while (0)\n-#define PAD_SP(howmany) if (_IO_padn(fp, ' ', howmany) < (howmany)) goto error;\n-#define PAD_0(howmany) if (_IO_padn(fp, '0', howmany) < (howmany)) goto error;\n-\n-\t/*\n-\t * To extend shorts properly, we need both signed and unsigned\n-\t * argument extraction methods.\n-\t */\n-#define\tSARG() \\\n-\t(flags&LONGINT ? va_arg(ap, long) : \\\n-\t    flags&SHORTINT ? (long)(short)va_arg(ap, int) : \\\n-\t    (long)va_arg(ap, int))\n-#define\tUARG() \\\n-\t(flags&LONGINT ? va_arg(ap, unsigned long) : \\\n-\t    flags&SHORTINT ? (unsigned long)(unsigned short)va_arg(ap, int) : \\\n-\t    (unsigned long)va_arg(ap, unsigned int))\n-\n-\t/* optimise stderr (and other unbuffered Unix files) */\n-\tif (fp->_IO_file_flags & _IO_UNBUFFERED)\n-\t    return helper_vfprintf(fp, fmt0, ap);\n-\n-\tfmt = fmt0;\n-\tret = 0;\n-\n-\t/*\n-\t * Scan the format for conversions (`%' character).\n-\t */\n-\tfor (;;) {\n-\t\tfor (fmark = fmt; (ch = *fmt) != '\\0' && ch != '%'; fmt++)\n-\t\t\t/* void */;\n-\t\tif ((n = fmt - fmark) != 0) {\n-\t\t\tPRINT(fmark, n);\n-\t\t\tret += n;\n-\t\t}\n-\t\tif (ch == '\\0')\n-\t\t\tgoto done;\n-\t\tfmt++;\t\t/* skip over '%' */\n-\n-\t\tflags = 0;\n-\t\tdprec = 0;\n-#if defined(FLOATING_POINT) && !defined (_IO_USE_DTOA)\n-\t\tfpprec = 0;\n-#endif\n-\t\twidth = 0;\n-\t\tprec = -1;\n-\t\tsign = '\\0';\n-\n-rflag:\t\tch = *fmt++;\n-reswitch:\tswitch (ch) {\n-\t\tcase ' ':\n-\t\t\t/*\n-\t\t\t * ``If the space and + flags both appear, the space\n-\t\t\t * flag will be ignored.''\n-\t\t\t *\t-- ANSI X3J11\n-\t\t\t */\n-\t\t\tif (!sign)\n-\t\t\t\tsign = ' ';\n-\t\t\tgoto rflag;\n-\t\tcase '#':\n-\t\t\tflags |= ALT;\n-\t\t\tgoto rflag;\n-\t\tcase '*':\n-\t\t\t/*\n-\t\t\t * ``A negative field width argument is taken as a\n-\t\t\t * - flag followed by a positive field width.''\n-\t\t\t *\t-- ANSI X3J11\n-\t\t\t * They don't exclude field widths read from args.\n-\t\t\t */\n-\t\t\tif ((width = va_arg(ap, int)) >= 0)\n-\t\t\t\tgoto rflag;\n-\t\t\twidth = -width;\n-\t\t\t/* FALLTHROUGH */\n-\t\tcase '-':\n-\t\t\tflags |= LADJUST;\n-\t\t\tflags &= ~ZEROPAD; /* '-' disables '0' */\n-\t\t\tgoto rflag;\n-\t\tcase '+':\n-\t\t\tsign = '+';\n-\t\t\tgoto rflag;\n-\t\tcase '.':\n-\t\t\tif ((ch = *fmt++) == '*') {\n-\t\t\t\tn = va_arg(ap, int);\n-\t\t\t\tprec = n < 0 ? -1 : n;\n-\t\t\t\tgoto rflag;\n-\t\t\t}\n-\t\t\tn = 0;\n-\t\t\twhile (is_digit(ch)) {\n-\t\t\t\tn = 10 * n + to_digit(ch);\n-\t\t\t\tch = *fmt++;\n-\t\t\t}\n-\t\t\tprec = n < 0 ? -1 : n;\n-\t\t\tgoto reswitch;\n-\t\tcase '0':\n-\t\t\t/*\n-\t\t\t * ``Note that 0 is taken as a flag, not as the\n-\t\t\t * beginning of a field width.''\n-\t\t\t *\t-- ANSI X3J11\n-\t\t\t */\n-\t\t\tif (!(flags & LADJUST))\n-\t\t\t    flags |= ZEROPAD; /* '-' disables '0' */\n-\t\t\tgoto rflag;\n-\t\tcase '1': case '2': case '3': case '4':\n-\t\tcase '5': case '6': case '7': case '8': case '9':\n-\t\t\tn = 0;\n-\t\t\tdo {\n-\t\t\t\tn = 10 * n + to_digit(ch);\n-\t\t\t\tch = *fmt++;\n-\t\t\t} while (is_digit(ch));\n-\t\t\twidth = n;\n-\t\t\tgoto reswitch;\n-#ifdef FLOATING_POINT\n-\t\tcase 'L':\n-\t\t\tflags |= LONGDBL;\n-\t\t\tgoto rflag;\n-#endif\n-\t\tcase 'h':\n-\t\t\tflags |= SHORTINT;\n-\t\t\tgoto rflag;\n-\t\tcase 'l':\n-\t\t\tflags |= LONGINT;\n-\t\t\tgoto rflag;\n-\t\tcase 'c':\n-\t\t\t*(cp = buf) = va_arg(ap, int);\n-\t\t\tsize = 1;\n-\t\t\tsign = '\\0';\n-\t\t\tbreak;\n-\t\tcase 'D':\n-\t\t\tflags |= LONGINT;\n-\t\t\t/*FALLTHROUGH*/\n-\t\tcase 'd':\n-\t\tcase 'i':\n-\t\t\t_ulong = SARG();\n-\t\t\tif ((long)_ulong < 0) {\n-\t\t\t\t_ulong = -_ulong;\n-\t\t\t\tsign = '-';\n-\t\t\t}\n-\t\t\tbase = DEC;\n-\t\t\tgoto number;\n-#ifdef FLOATING_POINT\n-\t\tcase 'e':\n-\t\tcase 'E':\n-\t\tcase 'f':\n-\t\tcase 'F':\n-\t\tcase 'g':\n-\t\tcase 'G':\n-\t\t\t_double = va_arg(ap, double);\n-#ifdef _IO_USE_DTOA\n-\t\t\t{\n-\t\t\t    int fmt_flags = 0;\n-\t\t\t    int fill = ' ';\n-\t\t\t    if (flags & ALT)\n-\t\t\t\tfmt_flags |= _IO_SHOWPOINT;\n-\t\t\t    if (flags & LADJUST)\n-\t\t\t\tfmt_flags |= _IO_LEFT;\n-\t\t\t    else if (flags & ZEROPAD)\n-\t\t\t\tfmt_flags |= _IO_INTERNAL, fill = '0';\n-\t\t\t    n = _IO_outfloat(_double, fp, ch, width,\n-\t\t\t\t\t     prec < 0 ? DEFPREC : prec,\n-\t\t\t\t\t     fmt_flags, sign, fill);\n-\t\t\t    if (n < 0)\n-\t\t\t\tgoto error;\n-\t\t\t    ret += n;\n-\t\t\t}\n-\t\t\t/* CHECK ERROR! */\n-\t\t\tcontinue;\n-#else\n-\t\t\t/*\n-\t\t\t * don't do unrealistic precision; just pad it with\n-\t\t\t * zeroes later, so buffer size stays rational.\n-\t\t\t */\n-\t\t\tif (prec > MAXFRACT) {\n-\t\t\t\tif ((ch != 'g' && ch != 'G') || (flags&ALT))\n-\t\t\t\t\tfpprec = prec - MAXFRACT;\n-\t\t\t\tprec = MAXFRACT;\n-\t\t\t} else if (prec == -1)\n-\t\t\t\tprec = DEFPREC;\n-\t\t\t/* __cvt_double may have to round up before the\n-\t\t\t   \"start\" of its buffer, i.e.\n-\t\t\t   ``intf(\"%.2f\", (double)9.999);'';\n-\t\t\t   if the first character is still NUL, it did.\n-\t\t\t   softsign avoids negative 0 if _double < 0 but\n-\t\t\t   no significant digits will be shown. */\n-\t\t\tcp = buf;\n-\t\t\t*cp = '\\0';\n-\t\t\tsize = __cvt_double(_double, prec, flags, &softsign,\n-\t\t\t\t\t    ch, cp, buf + sizeof(buf));\n-\t\t\tif (softsign)\n-\t\t\t\tsign = '-';\n-\t\t\tif (*cp == '\\0')\n-\t\t\t\tcp++;\n-\t\t\tbreak;\n-#endif\n-#endif /* FLOATING_POINT */\n-\t\tcase 'n':\n-\t\t\tif (flags & LONGINT)\n-\t\t\t\t*va_arg(ap, long *) = ret;\n-\t\t\telse if (flags & SHORTINT)\n-\t\t\t\t*va_arg(ap, short *) = ret;\n-\t\t\telse\n-\t\t\t\t*va_arg(ap, int *) = ret;\n-\t\t\tcontinue;\t/* no output */\n-\t\tcase 'O':\n-\t\t\tflags |= LONGINT;\n-\t\t\t/*FALLTHROUGH*/\n-\t\tcase 'o':\n-\t\t\t_ulong = UARG();\n-\t\t\tbase = OCT;\n-\t\t\tgoto nosign;\n-\t\tcase 'p':\n-\t\t\t/*\n-\t\t\t * ``The argument shall be a pointer to void.  The\n-\t\t\t * value of the pointer is converted to a sequence\n-\t\t\t * of printable characters, in an implementation-\n-\t\t\t * defined manner.''\n-\t\t\t *\t-- ANSI X3J11\n-\t\t\t */\n-\t\t\t/* NOSTRICT */\n-\t\t\t_ulong = (unsigned long)va_arg(ap, void *);\n-\t\t\tbase = HEX;\n-\t\t\tflags |= HEXPREFIX;\n-\t\t\tch = 'x';\n-\t\t\tgoto nosign;\n-\t\tcase 's':\n-\t\t\tif ((cp = va_arg(ap, char *)) == NULL)\n-\t\t\t\tcp = \"(null)\";\n-\t\t\tif (prec >= 0) {\n-\t\t\t\t/*\n-\t\t\t\t * can't use strlen; can only look for the\n-\t\t\t\t * NUL in the first `prec' characters, and\n-\t\t\t\t * strlen() will go further.\n-\t\t\t\t */\n-\t\t\t\tchar *p = (char*)memchr(cp, 0, prec);\n-\n-\t\t\t\tif (p != NULL) {\n-\t\t\t\t\tsize = p - cp;\n-\t\t\t\t\tif (size > prec)\n-\t\t\t\t\t\tsize = prec;\n-\t\t\t\t} else\n-\t\t\t\t\tsize = prec;\n-\t\t\t} else\n-\t\t\t\tsize = strlen(cp);\n-\t\t\tsign = '\\0';\n-\t\t\tbreak;\n-\t\tcase 'U':\n-\t\t\tflags |= LONGINT;\n-\t\t\t/*FALLTHROUGH*/\n-\t\tcase 'u':\n-\t\t\t_ulong = UARG();\n-\t\t\tbase = DEC;\n-\t\t\tgoto nosign;\n-\t\tcase 'X':\n-\t\tcase 'x':\n-\t\t\t_ulong = UARG();\n-\t\t\tbase = HEX;\n-\t\t\t/* leading 0x/X only if non-zero */\n-\t\t\tif (flags & ALT && _ulong != 0)\n-\t\t\t\tflags |= HEXPREFIX;\n-\n-\t\t\t/* unsigned conversions */\n-nosign:\t\t\tsign = '\\0';\n-\t\t\t/*\n-\t\t\t * ``... diouXx conversions ... if a precision is\n-\t\t\t * specified, the 0 flag will be ignored.''\n-\t\t\t *\t-- ANSI X3J11\n-\t\t\t */\n-number:\t\t\tif ((dprec = prec) >= 0)\n-\t\t\t\tflags &= ~ZEROPAD;\n-\n-\t\t\t/*\n-\t\t\t * ``The result of converting a zero value with an\n-\t\t\t * explicit precision of zero is no characters.''\n-\t\t\t *\t-- ANSI X3J11\n-\t\t\t */\n-\t\t\tcp = buf + BUF;\n-\t\t\tif (_ulong != 0 || prec != 0) {\n-\t\t\t        char *xdigs; /* digits for [xX] conversion */\n-\t\t\t\t/*\n-\t\t\t\t * unsigned mod is hard, and unsigned mod\n-\t\t\t\t * by a constant is easier than that by\n-\t\t\t\t * a variable; hence this switch.\n-\t\t\t\t */\n-\t\t\t\tswitch (base) {\n-\t\t\t\tcase OCT:\n-\t\t\t\t\tdo {\n-\t\t\t\t\t\t*--cp = to_char(_ulong & 7);\n-\t\t\t\t\t\t_ulong >>= 3;\n-\t\t\t\t\t} while (_ulong);\n-\t\t\t\t\t/* handle octal leading 0 */\n-\t\t\t\t\tif (flags & ALT && *cp != '0')\n-\t\t\t\t\t\t*--cp = '0';\n-\t\t\t\t\tbreak;\n-\n-\t\t\t\tcase DEC:\n-\t\t\t\t\t/* many numbers are 1 digit */\n-\t\t\t\t\twhile (_ulong >= 10) {\n-\t\t\t\t\t\t*--cp = to_char(_ulong % 10);\n-\t\t\t\t\t\t_ulong /= 10;\n-\t\t\t\t\t}\n-\t\t\t\t\t*--cp = to_char(_ulong);\n-\t\t\t\t\tbreak;\n-\n-\t\t\t\tcase HEX:\n-\t\t\t\t\tif (ch == 'X')\n-\t\t\t\t\t    xdigs = \"0123456789ABCDEF\";\n-\t\t\t\t\telse /* ch == 'x' || ch == 'p' */\n-\t\t\t\t\t    xdigs = \"0123456789abcdef\";\n-\t\t\t\t\tdo {\n-\t\t\t\t\t\t*--cp = xdigs[_ulong & 15];\n-\t\t\t\t\t\t_ulong >>= 4;\n-\t\t\t\t\t} while (_ulong);\n-\t\t\t\t\tbreak;\n-\n-\t\t\t\tdefault:\n-\t\t\t\t\tcp = \"bug in vform: bad base\";\n-\t\t\t\t\tgoto skipsize;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tsize = buf + BUF - cp;\n-\t\tskipsize:\n-\t\t\tbreak;\n-\t\tdefault:\t/* \"%?\" prints ?, unless ? is NUL */\n-\t\t\tif (ch == '\\0')\n-\t\t\t\tgoto done;\n-\t\t\t/* pretend it was %c with argument ch */\n-\t\t\tcp = buf;\n-\t\t\t*cp = ch;\n-\t\t\tsize = 1;\n-\t\t\tsign = '\\0';\n-\t\t\tbreak;\n-\t\t}\n-\n-\t\t/*\n-\t\t * All reasonable formats wind up here.  At this point,\n-\t\t * `cp' points to a string which (if not flags&LADJUST)\n-\t\t * should be padded out to `width' places.  If\n-\t\t * flags&ZEROPAD, it should first be prefixed by any\n-\t\t * sign or other prefix; otherwise, it should be blank\n-\t\t * padded before the prefix is emitted.  After any\n-\t\t * left-hand padding and prefixing, emit zeroes\n-\t\t * required by a decimal [diouxX] precision, then print\n-\t\t * the string proper, then emit zeroes required by any\n-\t\t * leftover floating precision; finally, if LADJUST,\n-\t\t * pad with blanks.\n-\t\t */\n-\n-\t\t/*\n-\t\t * compute actual size, so we know how much to pad.\n-\t\t */\n-#if defined(FLOATING_POINT) && !defined (_IO_USE_DTOA)\n-\t\tfieldsz = size + fpprec;\n-#else\n-\t\tfieldsz = size;\n-#endif\n-\t\tdpad = dprec - size;\n-\t\tif (dpad < 0)\n-\t\t    dpad = 0;\n-\n-\t\tif (sign)\n-\t\t\tfieldsz++;\n-\t\telse if (flags & HEXPREFIX)\n-\t\t\tfieldsz += 2;\n-\t\tfieldsz += dpad;\n-\n-\t\t/* right-adjusting blank padding */\n-\t\tif ((flags & (LADJUST|ZEROPAD)) == 0)\n-\t\t\tPAD_SP(width - fieldsz);\n-\n-\t\t/* prefix */\n-\t\tif (sign) {\n-\t\t\tPRINT(&sign, 1);\n-\t\t} else if (flags & HEXPREFIX) {\n-\t\t\tox[0] = '0';\n-\t\t\tox[1] = ch;\n-\t\t\tPRINT(ox, 2);\n-\t\t}\n-\n-\t\t/* right-adjusting zero padding */\n-\t\tif ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)\n-\t\t\tPAD_0(width - fieldsz);\n-\n-\t\t/* leading zeroes from decimal precision */\n-\t\tPAD_0(dpad);\n-\n-\t\t/* the string or number proper */\n-\t\tPRINT(cp, size);\n-\n-#if defined(FLOATING_POINT) && !defined (_IO_USE_DTOA)\n-\t\t/* trailing f.p. zeroes */\n-\t\tPAD_0(fpprec);\n-#endif\n-\n-\t\t/* left-adjusting padding (always blank) */\n-\t\tif (flags & LADJUST)\n-\t\t\tPAD_SP(width - fieldsz);\n-\n-\t\t/* finally, adjust ret */\n-\t\tret += width > fieldsz ? width : fieldsz;\n-\n-\t}\n-done:\n-\treturn ret;\n-error:\n-\treturn EOF;\n-\t/* NOTREACHED */\n-}\n-\n-#if defined(FLOATING_POINT) && !defined(_IO_USE_DTOA)\n-\n-static char *exponent(register char *p, register int exp, int fmtch)\n-{\n-\tregister char *t;\n-\tchar expbuf[MAXEXP];\n-\n-\t*p++ = fmtch;\n-\tif (exp < 0) {\n-\t\texp = -exp;\n-\t\t*p++ = '-';\n-\t}\n-\telse\n-\t\t*p++ = '+';\n-\tt = expbuf + MAXEXP;\n-\tif (exp > 9) {\n-\t\tdo {\n-\t\t\t*--t = to_char(exp % 10);\n-\t\t} while ((exp /= 10) > 9);\n-\t\t*--t = to_char(exp);\n-\t\tfor (; t < expbuf + MAXEXP; *p++ = *t++);\n-\t}\n-\telse {\n-\t\t*p++ = '0';\n-\t\t*p++ = to_char(exp);\n-\t}\n-\treturn (p);\n-}\n-\n-static char * round(double fract, int *exp,\n-\t\t    register char *start, register char *end,\n-\t\t    char ch, int *signp)\n-{\n-\tdouble tmp;\n-\n-\tif (fract)\n-\t(void)modf(fract * 10, &tmp);\n-\telse\n-\t\ttmp = to_digit(ch);\n-\tif (tmp > 4)\n-\t\tfor (;; --end) {\n-\t\t\tif (*end == '.')\n-\t\t\t\t--end;\n-\t\t\tif (++*end <= '9')\n-\t\t\t\tbreak;\n-\t\t\t*end = '0';\n-\t\t\tif (end == start) {\n-\t\t\t\tif (exp) {\t/* e/E; increment exponent */\n-\t\t\t\t\t*end = '1';\n-\t\t\t\t\t++*exp;\n-\t\t\t\t}\n-\t\t\t\telse {\t\t/* f; add extra digit */\n-\t\t\t\t*--end = '1';\n-\t\t\t\t--start;\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t/* ``\"%.3f\", (double)-0.0004'' gives you a negative 0. */\n-\telse if (*signp == '-')\n-\t\tfor (;; --end) {\n-\t\t\tif (*end == '.')\n-\t\t\t\t--end;\n-\t\t\tif (*end != '0')\n-\t\t\t\tbreak;\n-\t\t\tif (end == start)\n-\t\t\t\t*signp = 0;\n-\t\t}\n-\treturn (start);\n-}\n-\n-int __cvt_double(double number, register int prec, int flags, int *signp,\n-\t\t int fmtch, char *startp, char *endp)\n-{\n-\tregister char *p, *t;\n-\tregister double fract;\n-\tint dotrim = 0, expcnt, gformat = 0;\n-\tdouble integer, tmp;\n-\n-\texpcnt = 0;\n-\tif (number < 0) {\n-\t\tnumber = -number;\n-\t\t*signp = '-';\n-\t} else\n-\t\t*signp = 0;\n-\n-\tfract = modf(number, &integer);\n-\n-\t/* get an extra slot for rounding. */\n-\tt = ++startp;\n-\n-\t/*\n-\t * get integer portion of number; put into the end of the buffer; the\n-\t * .01 is added for modf(356.0 / 10, &integer) returning .59999999...\n-\t */\n-\tfor (p = endp - 1; p >= startp && integer; ++expcnt) {\n-\t\ttmp = modf(integer / 10, &integer);\n-\t\t*p-- = to_char((int)((tmp + .01) * 10));\n-\t}\n-\tswitch (fmtch) {\n-\tcase 'f':\n-\tcase 'F':\n-\t\t/* reverse integer into beginning of buffer */\n-\t\tif (expcnt)\n-\t\t\tfor (; ++p < endp; *t++ = *p);\n-\t\telse\n-\t\t\t*t++ = '0';\n-\t\t/*\n-\t\t * if precision required or alternate flag set, add in a\n-\t\t * decimal point.\n-\t\t */\n-\t\tif (prec || flags&ALT)\n-\t\t\t*t++ = '.';\n-\t\t/* if requires more precision and some fraction left */\n-\t\tif (fract) {\n-\t\t\tif (prec)\n-\t\t\t\tdo {\n-\t\t\t\t\tfract = modf(fract * 10, &tmp);\n-\t\t\t\t\t*t++ = to_char((int)tmp);\n-\t\t\t\t} while (--prec && fract);\n-\t\t\tif (fract)\n-\t\t\t\tstartp = round(fract, (int *)NULL, startp,\n-\t\t\t\t    t - 1, (char)0, signp);\n-\t\t}\n-\t\tfor (; prec--; *t++ = '0');\n-\t\tbreak;\n-\tcase 'e':\n-\tcase 'E':\n-eformat:\tif (expcnt) {\n-\t\t\t*t++ = *++p;\n-\t\t\tif (prec || flags&ALT)\n-\t\t\t\t*t++ = '.';\n-\t\t\t/* if requires more precision and some integer left */\n-\t\t\tfor (; prec && ++p < endp; --prec)\n-\t\t\t\t*t++ = *p;\n-\t\t\t/*\n-\t\t\t * if done precision and more of the integer component,\n-\t\t\t * round using it; adjust fract so we don't re-round\n-\t\t\t * later.\n-\t\t\t */\n-\t\t\tif (!prec && ++p < endp) {\n-\t\t\t\tfract = 0;\n-\t\t\t\tstartp = round((double)0, &expcnt, startp,\n-\t\t\t\t    t - 1, *p, signp);\n-\t\t\t}\n-\t\t\t/* adjust expcnt for digit in front of decimal */\n-\t\t\t--expcnt;\n-\t\t}\n-\t\t/* until first fractional digit, decrement exponent */\n-\t\telse if (fract) {\n-\t\t\t/* adjust expcnt for digit in front of decimal */\n-\t\t\tfor (expcnt = -1;; --expcnt) {\n-\t\t\t\tfract = modf(fract * 10, &tmp);\n-\t\t\t\tif (tmp)\n-\t\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\t*t++ = to_char((int)tmp);\n-\t\t\tif (prec || flags&ALT)\n-\t\t\t\t*t++ = '.';\n-\t\t}\n-\t\telse {\n-\t\t\t*t++ = '0';\n-\t\t\tif (prec || flags&ALT)\n-\t\t\t\t*t++ = '.';\n-\t\t}\n-\t\t/* if requires more precision and some fraction left */\n-\t\tif (fract) {\n-\t\t\tif (prec)\n-\t\t\t\tdo {\n-\t\t\t\t\tfract = modf(fract * 10, &tmp);\n-\t\t\t\t\t*t++ = to_char((int)tmp);\n-\t\t\t\t} while (--prec && fract);\n-\t\t\tif (fract)\n-\t\t\t\tstartp = round(fract, &expcnt, startp,\n-\t\t\t\t    t - 1, (char)0, signp);\n-\t\t}\n-\t\t/* if requires more precision */\n-\t\tfor (; prec--; *t++ = '0');\n-\n-\t\t/* unless alternate flag, trim any g/G format trailing 0's */\n-\t\tif (gformat && !(flags&ALT)) {\n-\t\t\twhile (t > startp && *--t == '0');\n-\t\t\tif (*t == '.')\n-\t\t\t\t--t;\n-\t\t\t++t;\n-\t\t}\n-\t\tt = exponent(t, expcnt, fmtch);\n-\t\tbreak;\n-\tcase 'g':\n-\tcase 'G':\n-\t\t/* a precision of 0 is treated as a precision of 1. */\n-\t\tif (!prec)\n-\t\t\t++prec;\n-\t\t/*\n-\t\t * ``The style used depends on the value converted; style e\n-\t\t * will be used only if the exponent resulting from the\n-\t\t * conversion is less than -4 or greater than the precision.''\n-\t\t *\t-- ANSI X3J11\n-\t\t */\n-\t\tif (expcnt > prec || (!expcnt && fract && fract < .0001)) {\n-\t\t\t/*\n-\t\t\t * g/G format counts \"significant digits, not digits of\n-\t\t\t * precision; for the e/E format, this just causes an\n-\t\t\t * off-by-one problem, i.e. g/G considers the digit\n-\t\t\t * before the decimal point significant and e/E doesn't\n-\t\t\t * count it as precision.\n-\t\t\t */\n-\t\t\t--prec;\n-\t\t\tfmtch -= 2;\t\t/* G->E, g->e */\n-\t\t\tgformat = 1;\n-\t\t\tgoto eformat;\n-\t\t}\n-\t\t/*\n-\t\t * reverse integer into beginning of buffer,\n-\t\t * note, decrement precision\n-\t\t */\n-\t\tif (expcnt)\n-\t\t\tfor (; ++p < endp; *t++ = *p, --prec);\n-\t\telse\n-\t\t\t*t++ = '0';\n-\t\t/*\n-\t\t * if precision required or alternate flag set, add in a\n-\t\t * decimal point.  If no digits yet, add in leading 0.\n-\t\t */\n-\t\tif (prec || flags&ALT) {\n-\t\t\tdotrim = 1;\n-\t\t\t*t++ = '.';\n-\t\t}\n-\t\telse\n-\t\t\tdotrim = 0;\n-\t\t/* if requires more precision and some fraction left */\n-\t\tif (fract) {\n-\t\t\tif (prec) {\n-\t\t\t\t/* If no integer part, don't count initial\n-\t\t\t\t * zeros as significant digits. */\n-\t\t\t\tdo {\n-\t\t\t\t\tfract = modf(fract * 10, &tmp);\n-\t\t\t\t\t*t++ = to_char((int)tmp);\n-\t\t\t\t} while(!tmp && !expcnt);\n-\t\t\t\twhile (--prec && fract) {\n-\t\t\t\t\tfract = modf(fract * 10, &tmp);\n-\t\t\t\t\t*t++ = to_char((int)tmp);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (fract)\n-\t\t\t\tstartp = round(fract, (int *)NULL, startp,\n-\t\t\t\t    t - 1, (char)0, signp);\n-\t\t}\n-\t\t/* alternate format, adds 0's for precision, else trim 0's */\n-\t\tif (flags&ALT)\n-\t\t\tfor (; prec--; *t++ = '0');\n-\t\telse if (dotrim) {\n-\t\t\twhile (t > startp && *--t == '0');\n-\t\t\tif (*t != '.')\n-\t\t\t\t++t;\n-\t\t}\n-\t}\n-\treturn (t - startp);\n-}\n-\n-#endif /* defined(FLOATING_POINT) && !defined(_IO_USE_DTOA) */"}, {"sha": "f1c4d224de563a0adc6b6dd1969324c5b24b9821", "filename": "libio/iovfscanf.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiovfscanf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiovfscanf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiovfscanf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "617a5888405dce55a0a883ec29642793c8292d89", "filename": "libio/iovsprintf.c", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiovsprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiovsprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiovsprintf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "6bdc3ccf01828503d8c48c3cf207e28003883d16", "filename": "libio/iovsscanf.c", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiovsscanf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fiovsscanf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiovsscanf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "5e48a000c09ab9b35a0091bdf1f56a026f523849", "filename": "libio/isgetline.cc", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fisgetline.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fisgetline.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fisgetline.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "655c972589ab0c76e47ee914bb0797a1aac40250", "filename": "libio/isgetsb.cc", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fisgetsb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fisgetsb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fisgetsb.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "977559c2cba55e3def9e0c3485b9b493bd0ed20d", "filename": "libio/isscan.cc", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fisscan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fisscan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fisscan.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "f54ec1de9a1cc7b11dabfff16db53f9acc97e859", "filename": "libio/istream.h", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fistream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fistream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fistream.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "c453b77bf30dd4727e20b7ca217ad5bfa1de43bf", "filename": "libio/libio.h", "status": "removed", "additions": 0, "deletions": 365, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Flibio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Flibio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Flibio.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "0dee72d577edf2b9b3bcc33ea66d5017964bd723", "filename": "libio/libioP.h", "status": "removed", "additions": 0, "deletions": 653, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FlibioP.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2FlibioP.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FlibioP.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "f08f2efaa39e0e0934eeba57c4270673b8292a78", "filename": "libio/osform.cc", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fosform.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fosform.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fosform.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "f54ec1de9a1cc7b11dabfff16db53f9acc97e859", "filename": "libio/ostream.h", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fostream.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "5cbb6c925982a978baa4975c1fcde2146c281d96", "filename": "libio/outfloat.c", "status": "removed", "additions": 0, "deletions": 211, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Foutfloat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Foutfloat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Foutfloat.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "711733221b5e67024d6a8a374a4afe283fbf1f3d", "filename": "libio/parsestream.cc", "status": "removed", "additions": 0, "deletions": 318, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fparsestream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fparsestream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fparsestream.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "97655bcbf6911cced379ccf898972f4221932758", "filename": "libio/parsestream.h", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fparsestream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fparsestream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fparsestream.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "0b3b5140c26f7a4fb32617b9a65b6b55b405eeb3", "filename": "libio/peekc.c", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fpeekc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fpeekc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fpeekc.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "a438718f3882484c3e93c57e73699a3798d1d307", "filename": "libio/pfstream.cc", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fpfstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fpfstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fpfstream.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "3c5458baaa9315bb5ab8fc48779e5c0f1b7b408f", "filename": "libio/pfstream.h", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fpfstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fpfstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fpfstream.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "eb6d50e7797f896817a704e1f479a4424bd91285", "filename": "libio/procbuf.cc", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fprocbuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fprocbuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fprocbuf.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "b361a6a7c8445b0c5dc9f9326115589763a7f6a3", "filename": "libio/procbuf.h", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fprocbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fprocbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fprocbuf.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "c17bd08db15e1764d2c003a6b1a82f7d66d81079", "filename": "libio/sbform.cc", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fsbform.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fsbform.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fsbform.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "0475114c629ee0d976613a46b89d19f64ea4e376", "filename": "libio/sbgetline.cc", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fsbgetline.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fsbgetline.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fsbgetline.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "c0ec35c53db6dcda71869ed7e28dab610df4c454", "filename": "libio/sbscan.cc", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fsbscan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fsbscan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fsbscan.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "8453e33c34cd8a18d89eed06ad2f25f97cb30b5d", "filename": "libio/stdfiles.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdfiles.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "f98baec0955bd87d962faa767558d460c30efe06", "filename": "libio/stdio/ChangeLog", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2FChangeLog?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "9cc5d324bd7246624f89cec369fbe00d94ce3693", "filename": "libio/stdio/ChangeLog.old", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2FChangeLog.old", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2FChangeLog.old", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2FChangeLog.old?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "680c8a497a4116b7339097c75599a71dd99feaab", "filename": "libio/stdio/Makefile.in", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2FMakefile.in?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "4776250ff8d943b2ce7311f81a9214638ae1fde3", "filename": "libio/stdio/clearerr.c", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fclearerr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fclearerr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fclearerr.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "2a1ba7070bb77f995e9b35a8307a373405a74da7", "filename": "libio/stdio/clearerr_u.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fclearerr_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fclearerr_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fclearerr_u.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "83cac17ebc7c22660f039664369b4d428a378682", "filename": "libio/stdio/configure.in", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fconfigure.in?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "83e026ec7f7610b7ac8be15ea0537ef230bbba66", "filename": "libio/stdio/fdopen.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffdopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffdopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffdopen.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "d06de044fba5f8b36e5a0ab17e826dc05de336f2", "filename": "libio/stdio/feof.c", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffeof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffeof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffeof.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "4773599012dda73de9940de63aaa4ebe4644fbdf", "filename": "libio/stdio/feof_u.c", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffeof_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffeof_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffeof_u.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "855627ade66d987e08c3acf905918751bad23b8e", "filename": "libio/stdio/ferror.c", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fferror.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "6e13e53ddc0090eac6bb5ad62a6b0c39c3e74baa", "filename": "libio/stdio/ferror_u.c", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fferror_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fferror_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fferror_u.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "174e60fa3fd27afb4c5e2b5983617742f5cad8ca", "filename": "libio/stdio/fgetc.c", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffgetc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffgetc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffgetc.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "7ff93e6a8138839d825718280f4407b639e88ab6", "filename": "libio/stdio/fileno.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffileno.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffileno.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffileno.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "22cdfab9a8442b3a5cc6810c06b23cfaca3d1e23", "filename": "libio/stdio/fputc.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffputc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffputc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffputc.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "48701e1d6cb50e9fd331ec128eca5425589bbd0c", "filename": "libio/stdio/fputc_u.c", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffputc_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffputc_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffputc_u.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "ff57d6033dc1d8cea749433db69add146d610d9f", "filename": "libio/stdio/freopen.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffreopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffreopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffreopen.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "f2563d33f28f4cdca470293fc8adad583a95f24f", "filename": "libio/stdio/fseek.c", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffseek.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Ffseek.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffseek.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "1dc53b5ed65138806a7f222cd5477b1ce80d8a56", "filename": "libio/stdio/getc.c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fgetc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fgetc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fgetc.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "f07442744661bc555502f05401d5e07bf24be5ef", "filename": "libio/stdio/getc_u.c", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fgetc_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fgetc_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fgetc_u.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "93194b3912d91def27b6096639945f7f671d1349", "filename": "libio/stdio/getchar.c", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fgetchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fgetchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fgetchar.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "bfbe56b30c09d9854aeff81f0bb7ea605d0810c6", "filename": "libio/stdio/getchar_u.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fgetchar_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fgetchar_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fgetchar_u.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "6f4b677086e82d413fe514e3d088086aa39c551f", "filename": "libio/stdio/getline.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fgetline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fgetline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fgetline.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "1dfafbc1d4f44cd1b3eca117405c5240b5d7a554", "filename": "libio/stdio/getw.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fgetw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fgetw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fgetw.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "6b959e455a8d89df3f71d37a64f544611081bd3c", "filename": "libio/stdio/obprintf.c", "status": "removed", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fobprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fobprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fobprintf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "9f9f3f72f58ee88bd694603b20b861fef77f9f6e", "filename": "libio/stdio/popen.c", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fpopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fpopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fpopen.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "3c35c365f07a53417f1473ece3f2d9ecd6d3577d", "filename": "libio/stdio/putc.c", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fputc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fputc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fputc.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "b4d94e8912bc7358300282552c7ae27528e59f6c", "filename": "libio/stdio/putc_u.c", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fputc_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fputc_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fputc_u.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "1e1dd137626713f9d17cc6fa6f4a9d1798199d73", "filename": "libio/stdio/putchar.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fputchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fputchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fputchar.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "f8f387ac4edbaeae98819e539691636971ef45c1", "filename": "libio/stdio/putchar_u.c", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fputchar_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fputchar_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fputchar_u.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "fd73261359cfaeb1bc9a616439ef23c12ceef639", "filename": "libio/stdio/putw.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fputw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fputw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fputw.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "bce27575fd8a677ed397f56ea3e1c1d6fd106dd5", "filename": "libio/stdio/rewind.c", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Frewind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Frewind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Frewind.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "ac323a31b5ba3a05cadd94ee9eb8d0abe01f3051", "filename": "libio/stdio/setbuf.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fsetbuf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fsetbuf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fsetbuf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "f7ccc6fdd666860005f6f0152448ae357092158a", "filename": "libio/stdio/setfileno.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fsetfileno.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fsetfileno.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fsetfileno.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "e4e029faeac2f71833e7ebc93dd752991685904b", "filename": "libio/stdio/setlinebuf.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fsetlinebuf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fsetlinebuf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fsetlinebuf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "5c70a44411278ddd9f678dfbbd86d59c95e71056", "filename": "libio/stdio/snprintf.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fsnprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fsnprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fsnprintf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "30065ac8714913b1b06050002c62a276698b89be", "filename": "libio/stdio/stdio.h", "status": "removed", "additions": 0, "deletions": 219, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fstdio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fstdio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fstdio.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "15513d0fca7dc73592b6fe3dbac419fa01035cf9", "filename": "libio/stdio/vasprintf.c", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fvasprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fvasprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fvasprintf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "fca62094452949cd51bb8121bd167b307f580b2a", "filename": "libio/stdio/vfprintf.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fvfprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fvfprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fvfprintf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "1759ee5ee017d97af19213bab32dea6605e042dc", "filename": "libio/stdio/vfscanf.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fvfscanf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fvfscanf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fvfscanf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "784f0d9b8dfeed3c658cf42c6d141afa9e6e42ab", "filename": "libio/stdio/vprintf.c", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fvprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fvprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fvprintf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "8b92ae270e6d56f34b2a377d732f062b508e33a9", "filename": "libio/stdio/vscanf.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fvscanf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fvscanf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fvscanf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "3f35af299ab7cbd0fa94becb8195b03a32d78626", "filename": "libio/stdio/vsnprintf.c", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fvsnprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdio%2Fvsnprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fvsnprintf.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "ee0907b209f4ba90632a70d5c29613bd26e53e60", "filename": "libio/stdiostream.cc", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdiostream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdiostream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdiostream.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "b973d7a39b62cde0079e890e9ae5bdce200d6822", "filename": "libio/stdiostream.h", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdiostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdiostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdiostream.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "2425a56eec69a5fc954f31f1a7f6d968d3a46f56", "filename": "libio/stdstrbufs.cc", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdstrbufs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdstrbufs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdstrbufs.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "7a74eaaa4433fab558cc60ab9a5704ca93342ef5", "filename": "libio/stdstreams.cc", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdstreams.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstdstreams.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdstreams.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "3440a0c9bdb4f18b4b9846147114ae7343101c9d", "filename": "libio/stream.cc", "status": "removed", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstream.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "90f8c1f278191f2c1c705a8af1851b30b5314de4", "filename": "libio/stream.h", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstream.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "057d1e6e4ce9bca11feeff1dbd69bb33f8b06e6e", "filename": "libio/streambuf.cc", "status": "removed", "additions": 0, "deletions": 364, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstreambuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstreambuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstreambuf.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "193c4993827f39df7743bd809fe765bf6929eaa4", "filename": "libio/streambuf.h", "status": "removed", "additions": 0, "deletions": 490, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstreambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstreambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstreambuf.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "85e83a95d0732c4fbe5681afbb9a0afbf1a6317b", "filename": "libio/strfile.h", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstrfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstrfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstrfile.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "193e39d55cb87311275198c0a14f17a194b37ad7", "filename": "libio/strops.c", "status": "removed", "additions": 0, "deletions": 303, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstrops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstrops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstrops.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "a32e811c9d94b0df17e539db2fb4c14929dc9b9c", "filename": "libio/strstream.cc", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstrstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstrstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstrstream.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "967e5b0b76ac6623bb1f466b99efcd4c6bb5ac90", "filename": "libio/strstream.h", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstrstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Fstrstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstrstream.h?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "5d937238d57a76b55d16cc805977ac1da01b2591", "filename": "libio/tests/ChangeLog", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2FChangeLog?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "b70639a68096ac9f1c39eca3a0a40a6c40de61f6", "filename": "libio/tests/Makefile.in", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2FMakefile.in?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "46deefbc8c95c7cae0a5c8c0a69d34fdfa205828", "filename": "libio/tests/configure.in", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Fconfigure.in?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "29a923836476f5d31fe68026b699df724ff24cb2", "filename": "libio/tests/hounddog.cc", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Fhounddog.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Fhounddog.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Fhounddog.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "2060807b431249af8dedce66e94c9f6ca716a03d", "filename": "libio/tests/hounddog.exp", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Fhounddog.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Fhounddog.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Fhounddog.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "370371bc20323ba6d13d1f8cfb1e9908bee86b39", "filename": "libio/tests/hounddog.inp", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Fhounddog.inp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Fhounddog.inp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Fhounddog.inp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "0e1ed61f55989c5c69e6a63267eb340c2ede2ff7", "filename": "libio/tests/putbackdog.cc", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Fputbackdog.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Fputbackdog.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Fputbackdog.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "42090ff83a30fd15b76449300a89ff5e79eefb5d", "filename": "libio/tests/tFile.cc", "status": "removed", "additions": 0, "deletions": 558, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2FtFile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2FtFile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2FtFile.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "154cd24dc0bbd910e98bc6f70372e60649c71d2b", "filename": "libio/tests/tFile.exp", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2FtFile.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2FtFile.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2FtFile.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "5b821ef072bef254ee172bc623d1e53410d5315a", "filename": "libio/tests/tFile.inp", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2FtFile.inp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2FtFile.inp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2FtFile.inp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "56efa1a9ebafe3f0975e1bf57fe32258f7c91c3e", "filename": "libio/tests/tfformat.c", "status": "removed", "additions": 0, "deletions": 4183, "changes": 4183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftfformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftfformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Ftfformat.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "78d09cedc230e858a8ea1c7017fe4502d9651715", "filename": "libio/tests/tiformat.c", "status": "removed", "additions": 0, "deletions": 5112, "changes": 5112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftiformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftiformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Ftiformat.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "b7dd08a4618e0738222c7607223a4c1221c3c246", "filename": "libio/tests/tiomanip.cc", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftiomanip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftiomanip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Ftiomanip.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "7a0a7ea5cb218ac7b8305f3c685febe8769a2807", "filename": "libio/tests/tiomanip.exp", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftiomanip.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftiomanip.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Ftiomanip.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "207a3f16e2b4e1f6902584037cbc754ba74111f2", "filename": "libio/tests/tiomisc.cc", "status": "removed", "additions": 0, "deletions": 236, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftiomisc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftiomisc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Ftiomisc.cc?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "26a3acd33fb156e9006f77c17a7c840cfffe6b9d", "filename": "libio/tests/tiomisc.exp", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftiomisc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftiomisc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Ftiomisc.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "cd8e88fd6cec33c2dcca3747221df08dcf1936fa", "filename": "libio/tests/tstdiomisc.c", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftstdiomisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftstdiomisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Ftstdiomisc.c?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "b8ee02dcd6a3e0264aea55802d6a26a481dca184", "filename": "libio/tests/tstdiomisc.exp", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftstdiomisc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftests%2Ftstdiomisc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2Ftstdiomisc.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "bffb157505ec2d242550276682b7225b46a60d3b", "filename": "libio/testsuite/ChangeLog", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2FChangeLog?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "d1795d00df60d997f613dc8ce00bbf5670f62ca1", "filename": "libio/testsuite/Makefile.in", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2FMakefile.in?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "90967cccc18afeb470c705244f4cb9e44f15eb0d", "filename": "libio/testsuite/config/default.exp", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Fconfig%2Fdefault.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Fconfig%2Fdefault.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2Fconfig%2Fdefault.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "cd400c84ba2cc9a9ee8d9d9860055feeab8495c3", "filename": "libio/testsuite/configure.in", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2Fconfigure.in?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "fb32541a2c4acc965f6472d082ae8d52ad6f728f", "filename": "libio/testsuite/lib/libio.exp", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flib%2Flibio.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flib%2Flibio.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2Flib%2Flibio.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "b51f9f0a4d39c57fcc17dca2acb7dffdfa7ec075", "filename": "libio/testsuite/libio.tests/hounddog.exp", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Fhounddog.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Fhounddog.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2Flibio.tests%2Fhounddog.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "30d91a8a5b8d8171ce796b7d59058061d3f55f2c", "filename": "libio/testsuite/libio.tests/putbackdog.exp", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Fputbackdog.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Fputbackdog.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2Flibio.tests%2Fputbackdog.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "f190916d8636c38575f217d6a319028eb01900b0", "filename": "libio/testsuite/libio.tests/tFile.exp", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2FtFile.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2FtFile.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2Flibio.tests%2FtFile.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "f0f7113c31993b04e55af714c97935dfab6b088d", "filename": "libio/testsuite/libio.tests/tfformat.exp", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Ftfformat.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Ftfformat.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2Flibio.tests%2Ftfformat.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "f2d14db5236ed87d9999a136db5928b8956b3916", "filename": "libio/testsuite/libio.tests/tiformat.exp", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Ftiformat.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Ftiformat.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2Flibio.tests%2Ftiformat.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "856cefc3cd05e87ac3e47897debb8b7f15a3c23d", "filename": "libio/testsuite/libio.tests/tiomanip.exp", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Ftiomanip.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Ftiomanip.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2Flibio.tests%2Ftiomanip.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "71309951bb07ea6312a187d0856b13bab5fe5a5f", "filename": "libio/testsuite/libio.tests/tiomisc.exp", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Ftiomisc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Ftiomisc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2Flibio.tests%2Ftiomisc.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}, {"sha": "01dae9ffe1a6056259c87c9369b5dc7cbe73ce14", "filename": "libio/testsuite/libio.tests/tstdiomisc.exp", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Ftstdiomisc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d6f2e8a535c22254682e99e59d63481aab8dfe/libio%2Ftestsuite%2Flibio.tests%2Ftstdiomisc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftestsuite%2Flibio.tests%2Ftstdiomisc.exp?ref=39d6f2e8a535c22254682e99e59d63481aab8dfe"}]}