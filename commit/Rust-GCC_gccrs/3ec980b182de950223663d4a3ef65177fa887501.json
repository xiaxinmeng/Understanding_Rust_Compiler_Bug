{"sha": "3ec980b182de950223663d4a3ef65177fa887501", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VjOTgwYjE4MmRlOTUwMjIzNjYzZDRhM2VmNjUxNzdmYTg4NzUwMQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-09-12T17:04:02Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-09-12T17:04:02Z"}, "message": "This commit was generated by cvs2svn to compensate for changes in r104181,\n\nwhich included commits to RCS files with non-trunk default branches.\n\nFrom-SVN: r104182", "tree": {"sha": "253197a1e98aea7fe0dd20a442e82f1f30007b5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/253197a1e98aea7fe0dd20a442e82f1f30007b5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ec980b182de950223663d4a3ef65177fa887501", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec980b182de950223663d4a3ef65177fa887501", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ec980b182de950223663d4a3ef65177fa887501", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec980b182de950223663d4a3ef65177fa887501/comments", "author": null, "committer": null, "parents": [{"sha": "303ae446cf2ab1469d83e83f4cc5168c899c3cee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/303ae446cf2ab1469d83e83f4cc5168c899c3cee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/303ae446cf2ab1469d83e83f4cc5168c899c3cee"}], "stats": {"total": 7254, "additions": 3906, "deletions": 3348}, "files": [{"sha": "85549515006281b6ccc305d7bddccfeb84dcb529", "filename": "zlib/as400/compile.clp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fas400%2Fcompile.clp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fas400%2Fcompile.clp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fas400%2Fcompile.clp?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -118,6 +118,6 @@\n                                  &MODLIB/INFTREES    &MODLIB/TREES       +\n                                  &MODLIB/UNCOMPR     &MODLIB/ZUTIL)      +\n                           SRCFILE(&SRCLIB/&CTLFILE) SRCMBR(BNDSRC) +\n-                          TEXT('ZLIB 1.2.1') TGTRLS(V4R4M0)\n+                          TEXT('ZLIB 1.2.3') TGTRLS(V4R4M0)\n \n              ENDPGM"}, {"sha": "beae13f565bda4eab2966bbd059394dc7a4f23e5", "filename": "zlib/as400/readme.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fas400%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fas400%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fas400%2Freadme.txt?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,4 +1,4 @@\n-        ZLIB version 1.2.1 for AS400 installation instructions\n+        ZLIB version 1.2.3 for AS400 installation instructions\n \n I) From an AS400 *SAVF file:\n "}, {"sha": "7bbfb7e4171fce28c49c627d9407a7945b983dbf", "filename": "zlib/as400/zlib.inc", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fas400%2Fzlib.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fas400%2Fzlib.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fas400%2Fzlib.inc?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,7 +1,7 @@\n       *  ZLIB.INC - Interface to the general purpose compression library\n       *\n       *  ILE RPG400 version by Patrick Monnerat, DATASPHERE.\n-      *  Version 1.2.1\n+      *  Version 1.2.3\n       *\n       *\n       *  WARNING:\n@@ -20,8 +20,12 @@\n       *                               Constants\n       **************************************************************************\n       *\n-     D ZLIB_VERSION    C                   '1.2.1'                            Header's version\n-     D ZLIB_VERNUM     C                   X'1210'\n+      *  Versioning information.\n+      *\n+     D ZLIB_VERSION    C                   '1.2.3'\n+     D ZLIB_VERNUM     C                   X'1230'\n+      *\n+      *  Other equates.\n       *\n      D Z_NO_FLUSH      C                   0\n      D Z_SYNC_FLUSH    C                   2"}, {"sha": "c4dfd080f0c0a4ea5ee3a0204a89ac91e83d859f", "filename": "zlib/contrib/ada/mtest.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fmtest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fmtest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fmtest.adb?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -5,10 +5,10 @@\n --                                                            --\n --  Open source license information is in the zlib.ads file.  --\n ----------------------------------------------------------------\n---  Continuous test for ZLib multithreading. If the test is fail\n---  Wou should provide thread safe allocation routines for the Z_Stream.\n+--  Continuous test for ZLib multithreading. If the test would fail\n+--  we should provide thread safe allocation routines for the Z_Stream.\n --\n---  $Id: mtest.adb,v 1.2 2003/08/12 12:11:05 vagul Exp $\n+--  $Id: mtest.adb,v 1.4 2004/07/23 07:49:54 vagul Exp $\n \n with ZLib;\n with Ada.Streams;\n@@ -148,6 +148,9 @@ procedure MTest is\n \n    pragma Unreferenced (Test);\n \n+   Dummy : Character;\n+\n begin\n-   null;\n+   Ada.Text_IO.Get_Immediate (Dummy);\n+   Stop := True;\n end MTest;"}, {"sha": "1f2efbfeb80287a7d024ca56381760a535a2deaa", "filename": "zlib/contrib/ada/read.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fread.adb?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -6,7 +6,7 @@\n --  Open source license information is in the zlib.ads file.  --\n ----------------------------------------------------------------\n \n---  $Id: read.adb,v 1.7 2003/08/12 12:12:35 vagul Exp $\n+--  $Id: read.adb,v 1.8 2004/05/31 10:53:40 vagul Exp $\n \n --  Test/demo program for the generic read interface.\n \n@@ -68,7 +68,11 @@ procedure Read is\n    --  ZLib.Read\n    --  reading data from the File_In.\n \n-   procedure Read is new ZLib.Read (Read, Read_Buffer, Read_First, Read_Last);\n+   procedure Read is new ZLib.Read\n+                           (Read,\n+                            Read_Buffer,\n+                            Rest_First => Read_First,\n+                            Rest_Last  => Read_Last);\n \n    ----------\n    -- Read --\n@@ -103,6 +107,7 @@ procedure Read is\n       Pack_Size := 0;\n       Offset := 1;\n       Read_First := Read_Buffer'Last + 1;\n+      Read_Last  := Read_Buffer'Last;\n    end Reset;\n \n begin"}, {"sha": "ce4d2cadf0d928f44dcf2bc2193c18941b214ddf", "filename": "zlib/contrib/ada/readme.txt", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Freadme.txt?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,23 +1,34 @@\n-\n-\t\t\tZLib for Ada thick binding (ZLib.Ada)\n-\t\t\tRelease 1.2\n+                        ZLib for Ada thick binding (ZLib.Ada)\n+                        Release 1.3\n \n ZLib.Ada is a thick binding interface to the popular ZLib data\n compression library, available at http://www.gzip.org/zlib/.\n It provides Ada-style access to the ZLib C library.\n \n \n-\tHere are the main changes since ZLib.Ada 1.1:\n+        Here are the main changes since ZLib.Ada 1.2:\n+\n+- Attension: ZLib.Read generic routine have a initialization requirement\n+  for Read_Last parameter now. It is a bit incompartible with previous version,\n+  but extends functionality, we could use new parameters Allow_Read_Some and\n+  Flush now.\n+\n+- Added Is_Open routines to ZLib and ZLib.Streams packages.\n \n-- The default header type has a name \"Default\" now. Auto is used only for\n-  automatic GZip/ZLib header detection.\n+- Add pragma Assert to check Stream_Element is 8 bit.\n \n-- Added test for multitasking mtest.adb.\n+- Fix extraction to buffer with exact known decompressed size. Error reported by\n+  Steve Sangwine.\n \n-- Added GNAT project file zlib.gpr.\n+- Fix definition of ULong (changed to unsigned_long), fix regression on 64 bits\n+  computers. Patch provided by Pascal Obry.\n \n+- Add Status_Error exception definition.\n \n-\tHow to build ZLib.Ada under GNAT\n+- Add pragma Assertion that Ada.Streams.Stream_Element size is 8 bit.\n+\n+\n+        How to build ZLib.Ada under GNAT\n \n You should have the ZLib library already build on your computer, before\n building ZLib.Ada. Make the directory of ZLib.Ada sources current and\n@@ -30,7 +41,7 @@ Or use the GNAT project file build for GNAT 3.15 or later:\n   gnatmake -Pzlib.gpr -L<directory where libz.a is>\n \n \n-\tHow to build ZLib.Ada under Aonix ObjectAda for Win32 7.2.2\n+        How to build ZLib.Ada under Aonix ObjectAda for Win32 7.2.2\n \n 1. Make a project with all *.ads and *.adb files from the distribution.\n 2. Build the libz.a library from the ZLib C sources.\n@@ -40,7 +51,7 @@ Or use the GNAT project file build for GNAT 3.15 or later:\n 6. Build the executable using test.adb as a main procedure.\n \n \n-\tHow to use ZLib.Ada\n+        How to use ZLib.Ada\n \n The source files test.adb and read.adb are small demo programs that show\n the main functionality of ZLib.Ada.\n@@ -50,3 +61,5 @@ The routines from the package specifications are commented.\n \n Homepage: http://zlib-ada.sourceforge.net/\n Author: Dmitriy Anisimkov <anisimkov@yahoo.com>\n+\n+Contributors: Pascal Obry <pascal@obry.org>, Steve Sangwine <sjs@essex.ac.uk>"}, {"sha": "b6497bae286e507898046fc580f4551edcad774a", "filename": "zlib/contrib/ada/zlib-streams.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib-streams.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib-streams.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib-streams.adb?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -6,7 +6,7 @@\n --  Open source license information is in the zlib.ads file.  --\n ----------------------------------------------------------------\n \n---  $Id: zlib-streams.adb,v 1.9 2003/08/12 13:15:31 vagul Exp $\n+--  $Id: zlib-streams.adb,v 1.10 2004/05/31 10:53:40 vagul Exp $\n \n with Ada.Unchecked_Deallocation;\n \n@@ -90,6 +90,7 @@ package body ZLib.Streams is\n \n          Stream.Buffer     := new Buffer_Subtype;\n          Stream.Rest_First := Stream.Buffer'Last + 1;\n+         Stream.Rest_Last  := Stream.Buffer'Last;\n       end if;\n    end Create;\n \n@@ -113,6 +114,15 @@ package body ZLib.Streams is\n       end loop;\n    end Flush;\n \n+   -------------\n+   -- Is_Open --\n+   -------------\n+\n+   function Is_Open (Stream : Stream_Type) return Boolean is\n+   begin\n+      return Is_Open (Stream.Reader) or else Is_Open (Stream.Writer);\n+   end Is_Open;\n+\n    ----------\n    -- Read --\n    ----------"}, {"sha": "f0193c6baeea5e0ca4c6f70129642149403c606a", "filename": "zlib/contrib/ada/zlib-streams.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib-streams.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib-streams.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib-streams.ads?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -6,7 +6,7 @@\n --  Open source license information is in the zlib.ads file.  --\n ----------------------------------------------------------------\n \n---  $Id: zlib-streams.ads,v 1.11 2003/08/12 13:15:31 vagul Exp $\n+--  $Id: zlib-streams.ads,v 1.12 2004/05/31 10:53:40 vagul Exp $\n \n package ZLib.Streams is\n \n@@ -77,6 +77,8 @@ package ZLib.Streams is\n    --  !!! When the Need_Header is False ZLib-Ada is using undocumented\n    --  ZLib 1.1.4 functionality to do not create/wait for ZLib headers.\n \n+   function Is_Open (Stream : Stream_Type) return Boolean;\n+\n    procedure Close (Stream : in out Stream_Type);\n \n private"}, {"sha": "0ca4a712046af856cd2b490c1bfe90029db33d95", "filename": "zlib/contrib/ada/zlib-thin.adb", "status": "modified", "additions": 13, "deletions": 57, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib-thin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib-thin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib-thin.adb?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -6,12 +6,11 @@\n --  Open source license information is in the zlib.ads file.  --\n ----------------------------------------------------------------\n \n---  $Id: zlib-thin.adb,v 1.6 2003/01/21 15:26:37 vagul Exp $\n+--  $Id: zlib-thin.adb,v 1.8 2003/12/14 18:27:31 vagul Exp $\n \n package body ZLib.Thin is\n \n-   ZLIB_VERSION : constant Chars_Ptr :=\n-      Interfaces.C.Strings.New_String (\"1.1.4\");\n+   ZLIB_VERSION  : constant Chars_Ptr := zlibVersion;\n \n    Z_Stream_Size : constant Int := Z_Stream'Size / System.Storage_Unit;\n \n@@ -37,14 +36,6 @@ package body ZLib.Thin is\n    -- Deflate_Init --\n    ------------------\n \n-   function Deflate_Init\n-     (strm  : in Z_Streamp;\n-      level : in Int := Z_DEFAULT_COMPRESSION)\n-      return  Int is\n-   begin\n-      return deflateInit (strm, level, ZLIB_VERSION, Z_Stream_Size);\n-   end Deflate_Init;\n-\n    function Deflate_Init\n      (strm       : Z_Streamp;\n       level      : Int;\n@@ -69,16 +60,15 @@ package body ZLib.Thin is\n    -- Inflate_Init --\n    ------------------\n \n-   function Inflate_Init (strm : Z_Streamp) return Int is\n-   begin\n-      return inflateInit (strm, ZLIB_VERSION, Z_Stream_Size);\n-   end Inflate_Init;\n-\n    function Inflate_Init (strm : Z_Streamp; windowBits : Int) return Int is\n    begin\n       return inflateInit2 (strm, windowBits, ZLIB_VERSION, Z_Stream_Size);\n    end Inflate_Init;\n \n+   ------------------------\n+   -- Last_Error_Message --\n+   ------------------------\n+\n    function Last_Error_Message (Strm : in Z_Stream) return String is\n       use Interfaces.C.Strings;\n    begin\n@@ -89,54 +79,28 @@ package body ZLib.Thin is\n       end if;\n    end Last_Error_Message;\n \n-   -------------\n-   -- Need_In --\n-   -------------\n-\n-   function Need_In (strm : Z_Stream) return Boolean is\n-   begin\n-      return strm.Avail_In = 0;\n-   end Need_In;\n-\n-   --------------\n-   -- Need_Out --\n-   --------------\n-\n-   function Need_Out (strm : Z_Stream) return Boolean is\n-   begin\n-      return strm.Avail_Out = 0;\n-   end Need_Out;\n-\n    ------------\n    -- Set_In --\n    ------------\n \n    procedure Set_In\n      (Strm   : in out Z_Stream;\n-      Buffer : in Byte_Access;\n-      Size   : in UInt) is\n+      Buffer : in     Voidp;\n+      Size   : in     UInt) is\n    begin\n       Strm.Next_In  := Buffer;\n       Strm.Avail_In := Size;\n    end Set_In;\n \n-   procedure Set_In\n-     (Strm   : in out Z_Stream;\n-      Buffer : in Voidp;\n-      Size   : in UInt) is\n-   begin\n-      Set_In (Strm, Bytes.To_Pointer (Buffer), Size);\n-   end Set_In;\n-\n    ------------------\n    -- Set_Mem_Func --\n    ------------------\n \n    procedure Set_Mem_Func\n      (Strm   : in out Z_Stream;\n-      Opaque : in Voidp;\n-      Alloc  : in alloc_func;\n-      Free   : in free_func) is\n+      Opaque : in     Voidp;\n+      Alloc  : in     alloc_func;\n+      Free   : in     free_func) is\n    begin\n       Strm.opaque := Opaque;\n       Strm.zalloc := Alloc;\n@@ -149,21 +113,13 @@ package body ZLib.Thin is\n \n    procedure Set_Out\n      (Strm   : in out Z_Stream;\n-      Buffer : in Byte_Access;\n-      Size   : in UInt) is\n+      Buffer : in     Voidp;\n+      Size   : in     UInt) is\n    begin\n       Strm.Next_Out  := Buffer;\n       Strm.Avail_Out := Size;\n    end Set_Out;\n \n-   procedure Set_Out\n-     (Strm   : in out Z_Stream;\n-      Buffer : in Voidp;\n-      Size   : in UInt) is\n-   begin\n-      Set_Out (Strm, Bytes.To_Pointer (Buffer), Size);\n-   end Set_Out;\n-\n    --------------\n    -- Total_In --\n    --------------"}, {"sha": "d4407eb800db3b3aa1629edc0f3815e33e737ce3", "filename": "zlib/contrib/ada/zlib-thin.ads", "status": "modified", "additions": 11, "deletions": 46, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib-thin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib-thin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib-thin.ads?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -6,10 +6,11 @@\n --  Open source license information is in the zlib.ads file.  --\n ----------------------------------------------------------------\n \n---  $Id: zlib-thin.ads,v 1.8 2003/08/12 13:16:51 vagul Exp $\n+--  $Id: zlib-thin.ads,v 1.11 2004/07/23 06:33:11 vagul Exp $\n \n with Interfaces.C.Strings;\n-with System.Address_To_Access_Conversions;\n+\n+with System;\n \n private package ZLib.Thin is\n \n@@ -36,18 +37,18 @@ private package ZLib.Thin is\n                                                 --  zconf.h:216\n    type Int is new Interfaces.C.int;\n \n-   type ULong is new Interfaces.C.unsigned;     --  32 bits or more\n-                                                --  zconf.h:217\n+   type ULong is new Interfaces.C.unsigned_long;     --  32 bits or more\n+                                                     --  zconf.h:217\n    subtype Chars_Ptr is Interfaces.C.Strings.chars_ptr;\n \n    type ULong_Access is access ULong;\n    type Int_Access is access Int;\n-   subtype Voidp is System.Address;            --  zconf.h:232\n \n-   package Bytes is new System.Address_To_Access_Conversions (Byte);\n+   subtype Voidp is System.Address;            --  zconf.h:232\n \n-   subtype Byte_Access is Bytes.Object_Pointer;\n+   subtype Byte_Access is Voidp;\n \n+   Nul : constant Voidp := System.Null_Address;\n    --  end from zconf\n \n    Z_NO_FLUSH : constant := 8#0000#;   --  zlib.h:125\n@@ -251,12 +252,6 @@ private package ZLib.Thin is\n       stream_size : Int)\n       return        Int;\n \n-   function Deflate_Init\n-     (strm  : in Z_Streamp;\n-      level : in Int := Z_DEFAULT_COMPRESSION)\n-      return  Int;\n-   pragma Inline (Deflate_Init);\n-\n    function deflateInit2\n      (strm        : Z_Streamp;\n       level       : Int;\n@@ -284,9 +279,6 @@ private package ZLib.Thin is\n       stream_size : Int)\n       return        Int;\n \n-   function Inflate_Init (strm : Z_Streamp) return Int;\n-   pragma Inline (Inflate_Init);\n-\n    function inflateInit2\n      (strm        : in Z_Streamp;\n       windowBits  : in Int;\n@@ -318,32 +310,12 @@ private package ZLib.Thin is\n    --  has dropped to zero. The application must initialize zalloc, zfree and\n    --  opaque before calling the init function.\n \n-   function Need_In (strm : in Z_Stream) return Boolean;\n-   --  return true when we do not need to setup Next_In and Avail_In fields.\n-   pragma Inline (Need_In);\n-\n-   function Need_Out (strm : in Z_Stream) return Boolean;\n-   --  return true when we do not need to setup Next_Out and Avail_Out field.\n-   pragma Inline (Need_Out);\n-\n-   procedure Set_In\n-     (Strm   : in out Z_Stream;\n-      Buffer : in Byte_Access;\n-      Size   : in UInt);\n-   pragma Inline (Set_In);\n-\n    procedure Set_In\n      (Strm   : in out Z_Stream;\n       Buffer : in Voidp;\n       Size   : in UInt);\n    pragma Inline (Set_In);\n \n-   procedure Set_Out\n-     (Strm   : in out Z_Stream;\n-      Buffer : in Byte_Access;\n-      Size   : in UInt);\n-   pragma Inline (Set_Out);\n-\n    procedure Set_Out\n      (Strm   : in out Z_Stream;\n       Buffer : in Voidp;\n@@ -388,19 +360,13 @@ private package ZLib.Thin is\n \n    function zlibCompileFlags return ULong;\n \n-   function deflatePrime\n-     (strm     : Z_Streamp;\n-      bits     : Int;\n-      value    : Int)\n-      return     Int;\n-\n private\n \n    type Z_Stream is record            -- zlib.h:68\n-      Next_In   : Byte_Access;        -- next input byte\n+      Next_In   : Voidp      := Nul;  -- next input byte\n       Avail_In  : UInt       := 0;    -- number of bytes available at next_in\n       Total_In  : ULong      := 0;    -- total nb of input bytes read so far\n-      Next_Out  : Byte_Access;        -- next output byte should be put there\n+      Next_Out  : Voidp      := Nul;  -- next output byte should be put there\n       Avail_Out : UInt       := 0;    -- remaining free space at next_out\n       Total_Out : ULong      := 0;    -- total nb of bytes output so far\n       msg       : Chars_Ptr;          -- last error message, NULL if no error\n@@ -460,14 +426,13 @@ private\n    pragma Import (C, inflateSyncPoint, \"inflateSyncPoint\");\n    pragma Import (C, get_crc_table, \"get_crc_table\");\n \n-   --  added in zlib 1.2.1:\n+   --  since zlib 1.2.0:\n \n    pragma Import (C, inflateCopy, \"inflateCopy\");\n    pragma Import (C, compressBound, \"compressBound\");\n    pragma Import (C, deflateBound, \"deflateBound\");\n    pragma Import (C, gzungetc, \"gzungetc\");\n    pragma Import (C, zlibCompileFlags, \"zlibCompileFlags\");\n-   pragma Import (C, deflatePrime, \"deflatePrime\");\n \n    pragma Import (C, inflateBackInit, \"inflateBackInit_\");\n "}, {"sha": "8b6fd686ac77ec02919b60d0039254559b8af7a0", "filename": "zlib/contrib/ada/zlib.adb", "status": "modified", "additions": 85, "deletions": 58, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib.adb?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,12 +1,12 @@\n ----------------------------------------------------------------\n --  ZLib for Ada thick binding.                               --\n --                                                            --\n---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --\n+--  Copyright (C) 2002-2004 Dmitriy Anisimkov                 --\n --                                                            --\n --  Open source license information is in the zlib.ads file.  --\n ----------------------------------------------------------------\n \n---  $Id: zlib.adb,v 1.19 2003/07/13 16:02:19 vagul Exp $\n+--  $Id: zlib.adb,v 1.31 2004/09/06 06:53:19 vagul Exp $\n \n with Ada.Exceptions;\n with Ada.Unchecked_Conversion;\n@@ -34,7 +34,7 @@ package body ZLib is\n        VERSION_ERROR);\n \n    type Flate_Step_Function is access\n-     function (Strm : Thin.Z_Streamp; flush : Thin.Int) return Thin.Int;\n+     function (Strm : in Thin.Z_Streamp; Flush : in Thin.Int) return Thin.Int;\n    pragma Convention (C, Flate_Step_Function);\n \n    type Flate_End_Function is access\n@@ -82,13 +82,13 @@ package body ZLib is\n    Flush_Finish : constant array (Boolean) of Flush_Mode\n      := (True => Finish, False => No_Flush);\n \n-   procedure Raise_Error (Stream : Z_Stream);\n+   procedure Raise_Error (Stream : in Z_Stream);\n    pragma Inline (Raise_Error);\n \n-   procedure Raise_Error (Message : String);\n+   procedure Raise_Error (Message : in String);\n    pragma Inline (Raise_Error);\n \n-   procedure Check_Error (Stream : Z_Stream; Code : Thin.Int);\n+   procedure Check_Error (Stream : in Z_Stream; Code : in Thin.Int);\n \n    procedure Free is new Ada.Unchecked_Deallocation\n       (Z_Stream, Z_Stream_Access);\n@@ -118,7 +118,7 @@ package body ZLib is\n    -- Check_Error --\n    -----------------\n \n-   procedure Check_Error (Stream : Z_Stream; Code : Thin.Int) is\n+   procedure Check_Error (Stream : in Z_Stream; Code : in Thin.Int) is\n       use type Thin.Int;\n    begin\n       if Code /= Thin.Z_OK then\n@@ -138,10 +138,11 @@ package body ZLib is\n    is\n       Code : Thin.Int;\n    begin\n-      Code := Flate (Filter.Compression).Done\n-          (To_Thin_Access (Filter.Strm));\n+      if not Ignore_Error and then not Is_Open (Filter) then\n+         raise Status_Error;\n+      end if;\n \n-      Filter.Opened := False;\n+      Code := Flate (Filter.Compression).Done (To_Thin_Access (Filter.Strm));\n \n       if Ignore_Error or else Code = Thin.Z_OK then\n          Free (Filter.Strm);\n@@ -154,7 +155,7 @@ package body ZLib is\n             Ada.Exceptions.Raise_Exception\n                (ZLib_Error'Identity,\n                 Return_Code_Enum'Image (Return_Code (Code))\n-                & \": \" & Error_Message);\n+                  & \": \" & Error_Message);\n          end;\n       end if;\n    end Close;\n@@ -170,10 +171,9 @@ package body ZLib is\n    is\n       use Thin;\n    begin\n-      return Unsigned_32 (crc32\n-        (ULong (CRC),\n-         Bytes.To_Pointer (Data'Address),\n-         Data'Length));\n+      return Unsigned_32 (crc32 (ULong (CRC),\n+                                 Data'Address,\n+                                 Data'Length));\n    end CRC32;\n \n    procedure CRC32\n@@ -192,13 +192,17 @@ package body ZLib is\n       Level        : in     Compression_Level  := Default_Compression;\n       Strategy     : in     Strategy_Type      := Default_Strategy;\n       Method       : in     Compression_Method := Deflated;\n-      Window_Bits  : in     Window_Bits_Type   := 15;\n-      Memory_Level : in     Memory_Level_Type  := 8;\n+      Window_Bits  : in     Window_Bits_Type   := Default_Window_Bits;\n+      Memory_Level : in     Memory_Level_Type  := Default_Memory_Level;\n       Header       : in     Header_Type        := Default)\n    is\n       use type Thin.Int;\n       Win_Bits : Thin.Int := Thin.Int (Window_Bits);\n    begin\n+      if Is_Open (Filter) then\n+         raise Status_Error;\n+      end if;\n+\n       --  We allow ZLib to make header only in case of default header type.\n       --  Otherwise we would either do header by ourselfs, or do not do\n       --  header at all.\n@@ -216,10 +220,9 @@ package body ZLib is\n          Filter.Offset := Simple_GZip_Header'Last + 1;\n       end if;\n \n-      Filter.Strm := new Z_Stream;\n+      Filter.Strm        := new Z_Stream;\n       Filter.Compression := True;\n       Filter.Stream_End  := False;\n-      Filter.Opened      := True;\n       Filter.Header      := Header;\n \n       if Thin.Deflate_Init\n@@ -255,18 +258,18 @@ package body ZLib is\n    -----------------------\n \n    procedure Generic_Translate\n-     (Filter : in out ZLib.Filter_Type;\n-      In_Buffer_Size  : Integer := Default_Buffer_Size;\n-      Out_Buffer_Size : Integer := Default_Buffer_Size)\n+     (Filter          : in out ZLib.Filter_Type;\n+      In_Buffer_Size  : in     Integer := Default_Buffer_Size;\n+      Out_Buffer_Size : in     Integer := Default_Buffer_Size)\n    is\n-      In_Buffer : Stream_Element_Array\n-         (1 .. Stream_Element_Offset (In_Buffer_Size));\n+      In_Buffer  : Stream_Element_Array\n+                     (1 .. Stream_Element_Offset (In_Buffer_Size));\n       Out_Buffer : Stream_Element_Array\n-        (1 .. Stream_Element_Offset (Out_Buffer_Size));\n-      Last : Stream_Element_Offset;\n-      In_Last : Stream_Element_Offset;\n-      In_First : Stream_Element_Offset;\n-      Out_Last : Stream_Element_Offset;\n+                     (1 .. Stream_Element_Offset (Out_Buffer_Size));\n+      Last       : Stream_Element_Offset;\n+      In_Last    : Stream_Element_Offset;\n+      In_First   : Stream_Element_Offset;\n+      Out_Last   : Stream_Element_Offset;\n    begin\n       Main : loop\n          Data_In (In_Buffer, Last);\n@@ -275,18 +278,21 @@ package body ZLib is\n \n          loop\n             Translate\n-              (Filter,\n-               In_Buffer (In_First .. Last),\n-               In_Last,\n-               Out_Buffer,\n-               Out_Last,\n-               Flush_Finish (Last < In_Buffer'First));\n+              (Filter   => Filter,\n+               In_Data  => In_Buffer (In_First .. Last),\n+               In_Last  => In_Last,\n+               Out_Data => Out_Buffer,\n+               Out_Last => Out_Last,\n+               Flush    => Flush_Finish (Last < In_Buffer'First));\n \n-            Data_Out (Out_Buffer (Out_Buffer'First .. Out_Last));\n+            if Out_Buffer'First <= Out_Last then\n+               Data_Out (Out_Buffer (Out_Buffer'First .. Out_Last));\n+            end if;\n \n             exit Main when Stream_End (Filter);\n \n             --  The end of in buffer.\n+\n             exit when In_Last = Last;\n \n             In_First := In_Last + 1;\n@@ -301,7 +307,7 @@ package body ZLib is\n \n    procedure Inflate_Init\n      (Filter      : in out Filter_Type;\n-      Window_Bits : in     Window_Bits_Type := 15;\n+      Window_Bits : in     Window_Bits_Type := Default_Window_Bits;\n       Header      : in     Header_Type      := Default)\n    is\n       use type Thin.Int;\n@@ -320,6 +326,10 @@ package body ZLib is\n       end Check_Version;\n \n    begin\n+      if Is_Open (Filter) then\n+         raise Status_Error;\n+      end if;\n+\n       case Header is\n          when None =>\n             Check_Version;\n@@ -344,10 +354,9 @@ package body ZLib is\n          when Default => null;\n       end case;\n \n-      Filter.Strm := new Z_Stream;\n+      Filter.Strm        := new Z_Stream;\n       Filter.Compression := False;\n       Filter.Stream_End  := False;\n-      Filter.Opened      := True;\n       Filter.Header      := Header;\n \n       if Thin.Inflate_Init\n@@ -357,16 +366,25 @@ package body ZLib is\n       end if;\n    end Inflate_Init;\n \n+   -------------\n+   -- Is_Open --\n+   -------------\n+\n+   function Is_Open (Filter : in Filter_Type) return Boolean is\n+   begin\n+      return Filter.Strm /= null;\n+   end Is_Open;\n+\n    -----------------\n    -- Raise_Error --\n    -----------------\n \n-   procedure Raise_Error (Message : String) is\n+   procedure Raise_Error (Message : in String) is\n    begin\n       Ada.Exceptions.Raise_Exception (ZLib_Error'Identity, Message);\n    end Raise_Error;\n \n-   procedure Raise_Error (Stream : Z_Stream) is\n+   procedure Raise_Error (Stream : in Z_Stream) is\n    begin\n       Raise_Error (Last_Error_Message (Stream));\n    end Raise_Error;\n@@ -378,33 +396,43 @@ package body ZLib is\n    procedure Read\n      (Filter : in out Filter_Type;\n       Item   :    out Ada.Streams.Stream_Element_Array;\n-      Last   :    out Ada.Streams.Stream_Element_Offset)\n+      Last   :    out Ada.Streams.Stream_Element_Offset;\n+      Flush  : in     Flush_Mode := No_Flush)\n    is\n       In_Last    : Stream_Element_Offset;\n       Item_First : Ada.Streams.Stream_Element_Offset := Item'First;\n+      V_Flush    : Flush_Mode := Flush;\n \n    begin\n       pragma Assert (Rest_First in Buffer'First .. Buffer'Last + 1);\n+      pragma Assert (Rest_Last in Buffer'First - 1 .. Buffer'Last);\n \n       loop\n-         if Rest_First > Buffer'Last then\n+         if Rest_Last = Buffer'First - 1 then\n+            V_Flush := Finish;\n+\n+         elsif Rest_First > Rest_Last then\n             Read (Buffer, Rest_Last);\n             Rest_First := Buffer'First;\n-         end if;\n \n-         pragma Assert (Rest_Last in Buffer'First - 1 .. Buffer'Last);\n+            if Rest_Last < Buffer'First then\n+               V_Flush := Finish;\n+            end if;\n+         end if;\n \n          Translate\n            (Filter   => Filter,\n             In_Data  => Buffer (Rest_First .. Rest_Last),\n             In_Last  => In_Last,\n             Out_Data => Item (Item_First .. Item'Last),\n             Out_Last => Last,\n-            Flush    => Flush_Finish (Rest_Last < Rest_First));\n+            Flush    => V_Flush);\n \n          Rest_First := In_Last + 1;\n \n-         exit when Last = Item'Last or else Stream_End (Filter);\n+         exit when Stream_End (Filter)\n+           or else Last = Item'Last\n+           or else (Last >= Item'First and then Allow_Read_Some);\n \n          Item_First := Last + 1;\n       end loop;\n@@ -489,11 +517,11 @@ package body ZLib is\n       Code : Thin.Int;\n \n    begin\n-      if Filter.Opened = False then\n-         raise ZLib_Error;\n+      if not Is_Open (Filter) then\n+         raise Status_Error;\n       end if;\n \n-      if Out_Data'Length = 0 then\n+      if Out_Data'Length = 0 and then In_Data'Length = 0 then\n          raise Constraint_Error;\n       end if;\n \n@@ -514,7 +542,6 @@ package body ZLib is\n          - Stream_Element_Offset (Avail_In (Filter.Strm.all));\n       Out_Last := Out_Data'Last\n          - Stream_Element_Offset (Avail_Out (Filter.Strm.all));\n-\n    end Translate_Auto;\n \n    --------------------\n@@ -529,7 +556,7 @@ package body ZLib is\n       Out_Last  :    out Ada.Streams.Stream_Element_Offset;\n       Flush     : in     Flush_Mode)\n    is\n-      Out_First  : Stream_Element_Offset;\n+      Out_First : Stream_Element_Offset;\n \n       procedure Add_Data (Data : in Stream_Element_Array);\n       --  Add data to stream from the Filter.Offset till necessary,\n@@ -596,15 +623,14 @@ package body ZLib is\n          Add_Data (Simple_GZip_Header);\n \n          Translate_Auto\n-           (Filter => Filter,\n+           (Filter   => Filter,\n             In_Data  => In_Data,\n             In_Last  => In_Last,\n             Out_Data => Out_Data (Out_First .. Out_Data'Last),\n             Out_Last => Out_Last,\n             Flush    => Flush);\n \n          CRC32 (Filter.CRC, In_Data (In_Data'First .. In_Last));\n-\n       end if;\n \n       if Filter.Stream_End and then Out_Last <= Out_Data'Last then\n@@ -642,10 +668,11 @@ package body ZLib is\n    procedure Write\n      (Filter : in out Filter_Type;\n       Item   : in     Ada.Streams.Stream_Element_Array;\n-      Flush  : in     Flush_Mode)\n+      Flush  : in     Flush_Mode := No_Flush)\n    is\n-      Buffer : Stream_Element_Array (1 .. Buffer_Size);\n-      In_Last, Out_Last : Stream_Element_Offset;\n+      Buffer   : Stream_Element_Array (1 .. Buffer_Size);\n+      In_Last  : Stream_Element_Offset;\n+      Out_Last : Stream_Element_Offset;\n       In_First : Stream_Element_Offset := Item'First;\n    begin\n       if Item'Length = 0 and Flush = No_Flush then\n@@ -654,7 +681,7 @@ package body ZLib is\n \n       loop\n          Translate\n-           (Filter => Filter,\n+           (Filter   => Filter,\n             In_Data  => Item (In_First .. Item'Last),\n             In_Last  => In_Last,\n             Out_Data => Buffer,"}, {"sha": "79ffc4095cf46f90a30334466637b4df61dfaa5b", "filename": "zlib/contrib/ada/zlib.ads", "status": "modified", "additions": 61, "deletions": 44, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib.ads?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,7 +1,7 @@\n ------------------------------------------------------------------------------\n --                      ZLib for Ada thick binding.                         --\n --                                                                          --\n---              Copyright (C) 2002-2003 Dmitriy Anisimkov                   --\n+--              Copyright (C) 2002-2004 Dmitriy Anisimkov                   --\n --                                                                          --\n --  This library is free software; you can redistribute it and/or modify    --\n --  it under the terms of the GNU General Public License as published by    --\n@@ -25,15 +25,16 @@\n --  covered by the  GNU Public License.                                     --\n ------------------------------------------------------------------------------\n \n---  $Id: zlib.ads,v 1.17 2003/08/12 13:19:07 vagul Exp $\n+--  $Id: zlib.ads,v 1.26 2004/09/06 06:53:19 vagul Exp $\n \n with Ada.Streams;\n \n with Interfaces;\n \n package ZLib is\n \n-   ZLib_Error : exception;\n+   ZLib_Error   : exception;\n+   Status_Error : exception;\n \n    type Compression_Level is new Integer range -1 .. 9;\n \n@@ -55,12 +56,15 @@ package ZLib is\n \n    subtype Count is Ada.Streams.Stream_Element_Count;\n \n+   Default_Memory_Level : constant Memory_Level_Type := 8;\n+   Default_Window_Bits  : constant Window_Bits_Type  := 15;\n+\n    ----------------------------------\n    -- Compression method constants --\n    ----------------------------------\n \n    Deflated : constant Compression_Method;\n-   --  Only one method allowed in this ZLib version.\n+   --  Only one method allowed in this ZLib version\n \n    ---------------------------------\n    -- Compression level constants --\n@@ -79,21 +83,29 @@ package ZLib is\n    --  Regular way for compression, no flush\n \n    Partial_Flush : constant Flush_Mode;\n-   --  will be removed, use Z_SYNC_FLUSH instead\n+   --  Will be removed, use Z_SYNC_FLUSH instead\n \n    Sync_Flush    : constant Flush_Mode;\n-   --  all pending output is flushed to the output buffer and the output\n+   --  All pending output is flushed to the output buffer and the output\n    --  is aligned on a byte boundary, so that the decompressor can get all\n    --  input data available so far. (In particular avail_in is zero after the\n    --  call if enough output space has been provided  before the call.)\n    --  Flushing may degrade compression for some compression algorithms and so\n    --  it should be used only when necessary.\n \n+   Block_Flush   : constant Flush_Mode;\n+   --  Z_BLOCK requests that inflate() stop\n+   --  if and when it get to the next deflate block boundary. When decoding the\n+   --  zlib or gzip format, this will cause inflate() to return immediately\n+   --  after the header and before the first block. When doing a raw inflate,\n+   --  inflate() will go ahead and process the first block, and will return\n+   --  when it gets to the end of that block, or when it runs out of data.\n+\n    Full_Flush    : constant Flush_Mode;\n-   --  all output is flushed as with SYNC_FLUSH, and the compression state\n+   --  All output is flushed as with SYNC_FLUSH, and the compression state\n    --  is reset so that decompression can restart from this point if previous\n    --  compressed data has been damaged or if random access is desired. Using\n-   --  FULL_FLUSH too often can seriously degrade the compression.\n+   --  Full_Flush too often can seriously degrade the compression.\n \n    Finish        : constant Flush_Mode;\n    --  Just for tell the compressor that input data is complete.\n@@ -111,7 +123,7 @@ package ZLib is\n \n    Default_Buffer_Size : constant := 4096;\n \n-   type Filter_Type is limited private;\n+   type Filter_Type is tagged limited private;\n    --  The filter is for compression and for decompression.\n    --  The usage of the type is depend of its initialization.\n \n@@ -124,8 +136,8 @@ package ZLib is\n       Level        : in     Compression_Level  := Default_Compression;\n       Strategy     : in     Strategy_Type      := Default_Strategy;\n       Method       : in     Compression_Method := Deflated;\n-      Window_Bits  : in     Window_Bits_Type   := 15;\n-      Memory_Level : in     Memory_Level_Type  := 8;\n+      Window_Bits  : in     Window_Bits_Type   := Default_Window_Bits;\n+      Memory_Level : in     Memory_Level_Type  := Default_Memory_Level;\n       Header       : in     Header_Type        := Default);\n    --  Compressor initialization.\n    --  When Header parameter is Auto or Default, then default zlib header\n@@ -136,7 +148,7 @@ package ZLib is\n \n    procedure Inflate_Init\n      (Filter      : in out Filter_Type;\n-      Window_Bits : in     Window_Bits_Type := 15;\n+      Window_Bits : in     Window_Bits_Type := Default_Window_Bits;\n       Header      : in     Header_Type      := Default);\n    --  Decompressor initialization.\n    --  Default header type mean that ZLib default header is expecting in the\n@@ -146,10 +158,14 @@ package ZLib is\n    --  input compressed stream.\n    --  Auto header type mean that header type (GZip or Native) would be\n    --  detected automatically in the input stream.\n-   --  Note that header types parameter values None, GZip and Auto is\n-   --  supporting for inflate routine only in ZLib versions 1.2.0.2 and later.\n+   --  Note that header types parameter values None, GZip and Auto are\n+   --  supported for inflate routine only in ZLib versions 1.2.0.2 and later.\n    --  Deflate_Init is supporting all header types.\n \n+   function Is_Open (Filter : in Filter_Type) return Boolean;\n+   pragma Inline (Is_Open);\n+   --  Is the filter opened for compression or decompression.\n+\n    procedure Close\n      (Filter       : in out Filter_Type;\n       Ignore_Error : in     Boolean := False);\n@@ -167,31 +183,31 @@ package ZLib is\n      (Filter          : in out Filter_Type;\n       In_Buffer_Size  : in     Integer := Default_Buffer_Size;\n       Out_Buffer_Size : in     Integer := Default_Buffer_Size);\n-   --  Compressing/decompressing data arrived from Data_In routine\n+   --  Compress/decompress data fetch from Data_In routine and pass the result\n    --  to the Data_Out routine. User should provide Data_In and Data_Out\n    --  for compression/decompression data flow.\n-   --  Compression or decompression depend on initialization of Filter.\n+   --  Compression or decompression depend on Filter initialization.\n \n    function Total_In (Filter : in Filter_Type) return Count;\n    pragma Inline (Total_In);\n-   --  Return total number of input bytes read so far.\n+   --  Returns total number of input bytes read so far\n \n    function Total_Out (Filter : in Filter_Type) return Count;\n    pragma Inline (Total_Out);\n-   --  Return total number of bytes output so far.\n+   --  Returns total number of bytes output so far\n \n    function CRC32\n      (CRC    : in Unsigned_32;\n       Data   : in Ada.Streams.Stream_Element_Array)\n       return Unsigned_32;\n    pragma Inline (CRC32);\n-   --  Calculate CRC32, it could be necessary for make gzip format.\n+   --  Compute CRC32, it could be necessary for make gzip format\n \n    procedure CRC32\n      (CRC  : in out Unsigned_32;\n       Data : in     Ada.Streams.Stream_Element_Array);\n    pragma Inline (CRC32);\n-   --  Calculate CRC32, it could be necessary for make gzip format.\n+   --  Compute CRC32, it could be necessary for make gzip format\n \n    -------------------------------------------------\n    --  Below is more complex low level routines.  --\n@@ -204,15 +220,11 @@ package ZLib is\n       Out_Data  :    out Ada.Streams.Stream_Element_Array;\n       Out_Last  :    out Ada.Streams.Stream_Element_Offset;\n       Flush     : in     Flush_Mode);\n-   --  Compressing/decompressing the datas from In_Data buffer to the\n-   --  Out_Data buffer.\n-   --  In_Data is incoming data portion,\n-   --  In_Last is the index of last element from In_Data accepted by the\n-   --  Filter.\n-   --  Out_Data is the buffer for output data from the filter.\n-   --  Out_Last is the last element of the received data from Filter.\n-   --  To tell the filter that incoming data is complete put the\n-   --  Flush parameter to FINISH.\n+   --  Compress/decompress the In_Data buffer and place the result into\n+   --  Out_Data. In_Last is the index of last element from In_Data accepted by\n+   --  the Filter. Out_Last is the last element of the received data from\n+   --  Filter. To tell the filter that incoming data are complete put the\n+   --  Flush parameter to Finish.\n \n    function Stream_End (Filter : in Filter_Type) return Boolean;\n    pragma Inline (Stream_End);\n@@ -239,10 +251,9 @@ package ZLib is\n    procedure Write\n      (Filter  : in out Filter_Type;\n       Item    : in     Ada.Streams.Stream_Element_Array;\n-      Flush   : in     Flush_Mode);\n-   --  Compressing/Decompressing data from Item to the\n-   --  generic parameter procedure Write.\n-   --  Output buffer size could be set in Buffer_Size generic parameter.\n+      Flush   : in     Flush_Mode := No_Flush);\n+   --  Compress/Decompress data from Item to the generic parameter procedure\n+   --  Write. Output buffer size could be set in Buffer_Size generic parameter.\n \n    generic\n       with procedure Read\n@@ -257,33 +268,41 @@ package ZLib is\n \n       Rest_First, Rest_Last : in out Ada.Streams.Stream_Element_Offset;\n       --  Rest_First have to be initialized to Buffer'Last + 1\n+      --  Rest_Last have to be initialized to Buffer'Last\n       --  before usage.\n \n+      Allow_Read_Some : in Boolean := False;\n+      --  Is it allowed to return Last < Item'Last before end of data.\n+\n    procedure Read\n      (Filter : in out Filter_Type;\n       Item   :    out Ada.Streams.Stream_Element_Array;\n-      Last   :    out Ada.Streams.Stream_Element_Offset);\n-   --  Compressing/Decompressing data from generic parameter\n-   --  procedure Read to the Item.\n-   --  User should provide Buffer for the operation\n-   --  and Rest_First variable first time initialized to the Buffer'Last + 1.\n+      Last   :    out Ada.Streams.Stream_Element_Offset;\n+      Flush  : in     Flush_Mode := No_Flush);\n+   --  Compress/Decompress data from generic parameter procedure Read to the\n+   --  Item. User should provide Buffer and initialized Rest_First, Rest_Last\n+   --  indicators. If Allow_Read_Some is True, Read routines could return\n+   --  Last < Item'Last only at end of stream.\n \n private\n \n    use Ada.Streams;\n \n-   type Flush_Mode is new Integer range 0 .. 4;\n+   pragma Assert (Ada.Streams.Stream_Element'Size    =    8);\n+   pragma Assert (Ada.Streams.Stream_Element'Modulus = 2**8);\n+\n+   type Flush_Mode is new Integer range 0 .. 5;\n \n    type Compression_Method is new Integer range 8 .. 8;\n \n    type Strategy_Type is new Integer range 0 .. 3;\n \n    No_Flush      : constant Flush_Mode := 0;\n+   Partial_Flush : constant Flush_Mode := 1;\n    Sync_Flush    : constant Flush_Mode := 2;\n    Full_Flush    : constant Flush_Mode := 3;\n    Finish        : constant Flush_Mode := 4;\n-   Partial_Flush : constant Flush_Mode := 1;\n-   --  will be removed, use Z_SYNC_FLUSH instead\n+   Block_Flush   : constant Flush_Mode := 5;\n \n    Filtered         : constant Strategy_Type := 1;\n    Huffman_Only     : constant Strategy_Type := 2;\n@@ -296,16 +315,14 @@ private\n \n    type Z_Stream_Access is access all Z_Stream;\n \n-   type Filter_Type is record\n+   type Filter_Type is tagged limited record\n       Strm        : Z_Stream_Access;\n       Compression : Boolean;\n       Stream_End  : Boolean;\n       Header      : Header_Type;\n       CRC         : Unsigned_32;\n       Offset      : Stream_Element_Offset;\n       --  Offset for gzip header/footer output.\n-\n-      Opened      : Boolean := False;\n    end record;\n \n end ZLib;"}, {"sha": "296b22aa966706adb8780e12089d7a9072997a78", "filename": "zlib/contrib/ada/zlib.gpr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib.gpr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fada%2Fzlib.gpr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib.gpr?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -3,10 +3,10 @@ project Zlib is\n    for Languages use (\"Ada\");\n    for Source_Dirs use (\".\");\n    for Object_Dir use \".\";\n-   for Main use (\"test.adb\", \"mtest.adb\", \"read.adb\");\n+   for Main use (\"test.adb\", \"mtest.adb\", \"read.adb\", \"buffer_demo\");\n \n    package Compiler is\n-      for Default_Switches (\"ada\") use (\"-gnatwbcfilopru\", \"-gnatVcdfimorst\", \"-gnatyabcefhiklmnoprst\");\n+      for Default_Switches (\"ada\") use (\"-gnatwcfilopru\", \"-gnatVcdfimorst\", \"-gnatyabcefhiklmnoprst\");\n    end Compiler;\n \n    package Linker is\n@@ -18,4 +18,3 @@ project Zlib is\n    end Builder;\n \n end Zlib;\n-"}, {"sha": "3f2b8b4a5cdbc8612ad5fd56f444ca59f5fe840f", "filename": "zlib/contrib/delphi/ZLib.pas", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fdelphi%2FZLib.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fdelphi%2FZLib.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi%2FZLib.pas?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -152,7 +152,7 @@ procedure DecompressToUserBuf(const InBuf: Pointer; InBytes: Integer;\n   const OutBuf: Pointer; BufSize: Integer);\n \n const\n-  zlib_version = '1.2.1';\n+  zlib_version = '1.2.3';\n \n type\n   EZlibError = class(Exception);\n@@ -344,7 +344,7 @@ procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;\n     strm.avail_out := OutBytes;\n     DCheck(inflateInit_(strm, zlib_version, sizeof(strm)));\n     try\n-      while DCheck(inflate(strm, Z_FINISH)) <> Z_STREAM_END do\n+      while DCheck(inflate(strm, Z_NO_FLUSH)) <> Z_STREAM_END do\n       begin\n         P := OutBuf;\n         Inc(OutBytes, BufInc);\n@@ -510,7 +510,7 @@ function TDecompressionStream.Read(var Buffer; Count: Longint): Longint;\n         Result := Count - FZRec.avail_out;\n         Exit;\n       end;\n-          FZRec.next_in := FBuffer;\n+      FZRec.next_in := FBuffer;\n       FStrmPos := FStrm.Position;\n       Progress(Self);\n     end;"}, {"sha": "f5ddde67da66670d612c42f53b0a6587875ed5c5", "filename": "zlib/contrib/infback9/infback9.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Finfback9%2Finfback9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Finfback9%2Finfback9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finfback9%2Finfback9.c?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -430,6 +430,9 @@ void FAR *out_desc;\n                 }\n             }\n \n+            /* handle error breaks in while */\n+            if (mode == BAD) break;\n+\n             /* build code tables */\n             state->next = state->codes;\n             lencode = (code const FAR *)(state->next);"}, {"sha": "1073c0a38e6c2c7f51d7638135a08f1471d7320c", "filename": "zlib/contrib/infback9/infback9.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Finfback9%2Finfback9.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Finfback9%2Finfback9.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finfback9%2Finfback9.h?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -16,6 +16,10 @@\n  * zlib.h must be included before this header file.\n  */\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n ZEXTERN int ZEXPORT inflateBack9 OF((z_stream FAR *strm,\n                                     in_func in, void FAR *in_desc,\n                                     out_func out, void FAR *out_desc));\n@@ -27,3 +31,7 @@ ZEXTERN int ZEXPORT inflateBack9Init_ OF((z_stream FAR *strm,\n #define inflateBack9Init(strm, window) \\\n         inflateBack9Init_((strm), (window), \\\n         ZLIB_VERSION, sizeof(z_stream))\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "0993f75646cd10259fff09bd49165994d59f3378", "filename": "zlib/contrib/infback9/inftree9.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Finfback9%2Finftree9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Finfback9%2Finftree9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finfback9%2Finftree9.c?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,5 +1,5 @@\n /* inftree9.c -- generate Huffman trees for efficient decoding\n- * Copyright (C) 1995-2003 Mark Adler\n+ * Copyright (C) 1995-2005 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -9,7 +9,7 @@\n #define MAXBITS 15\n \n const char inflate9_copyright[] =\n-   \" inflate9 1.2.1 Copyright 1995-2003 Mark Adler \";\n+   \" inflate9 1.2.3 Copyright 1995-2005 Mark Adler \";\n /*\n   If you use the zlib library in a product, an acknowledgment is welcome\n   in the documentation of your product. If for some reason you cannot\n@@ -64,7 +64,7 @@ unsigned short FAR *work;\n     static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n         128, 128, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129,\n         130, 130, 130, 130, 131, 131, 131, 131, 132, 132, 132, 132,\n-        133, 133, 133, 133, 144, 76, 66};\n+        133, 133, 133, 133, 144, 201, 196};\n     static const unsigned short dbase[32] = { /* Distance codes 0..31 base */\n         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49,\n         65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073,\n@@ -128,7 +128,7 @@ unsigned short FAR *work;\n         left -= count[len];\n         if (left < 0) return -1;        /* over-subscribed */\n     }\n-    if (left > 0 && (type == CODES || (codes - count[0] != 1)))\n+    if (left > 0 && (type == CODES || max != 1))\n         return -1;                      /* incomplete set */\n \n     /* generate offsets into symbol table for each length for sorting */"}, {"sha": "a268084eea628261851f640692ceb92ee9538fde", "filename": "zlib/contrib/infback9/inftree9.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Finfback9%2Finftree9.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Finfback9%2Finftree9.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finfback9%2Finftree9.h?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -36,12 +36,12 @@ typedef struct {\n  */\n \n /* Maximum size of dynamic tree.  The maximum found in a long but non-\n-   exhaustive search was 1004 code structures (850 for length/literals\n-   and 154 for distances, the latter actually the result of an\n+   exhaustive search was 1444 code structures (852 for length/literals\n+   and 592 for distances, the latter actually the result of an\n    exhaustive search).  The true maximum is not known, but the value\n    below is more than safe. */\n-#define ENOUGH 1440\n-#define MAXD 154\n+#define ENOUGH 2048\n+#define MAXD 592\n \n /* Type of code to build for inftable() */\n typedef enum {"}, {"sha": "6da76358ccb273181f141dda117612d57ff82949", "filename": "zlib/contrib/inflate86/inffas86.c", "status": "modified", "additions": 586, "deletions": 212, "changes": 798, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Finflate86%2Finffas86.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Finflate86%2Finffas86.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finflate86%2Finffas86.c?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -7,6 +7,15 @@\n  * Copyright (C) 2003 Chris Anderson <christop@charm.net>\n  * Please use the copyright conditions above.\n  *\n+ * Dec-29-2003 -- I added AMD64 inflate asm support.  This version is also\n+ * slightly quicker on x86 systems because, instead of using rep movsb to copy\n+ * data, it uses rep movsw, which moves data in 2-byte chunks instead of single\n+ * bytes.  I've tested the AMD64 code on a Fedora Core 1 + the x86_64 updates\n+ * from http://fedora.linux.duke.edu/fc1_x86_64\n+ * which is running on an Athlon 64 3000+ / Gigabyte GA-K8VT800M system with\n+ * 1GB ram.  The 64-bit version is about 4% faster than the 32-bit version,\n+ * when decompressing mozilla-source-1.3.tar.gz.\n+ *\n  * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from\n  * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at\n  * the moment.  I have successfully compiled and tested this code with gcc2.96,\n@@ -65,33 +74,44 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n {\n     struct inflate_state FAR *state;\n     struct inffast_ar {\n-      void *esp;                  /* esp save */\n-      unsigned char FAR *in;      /* local strm->next_in */\n-      unsigned char FAR *last;    /* while in < last, enough input available */\n-      unsigned char FAR *out;     /* local strm->next_out */\n-      unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */\n-      unsigned char FAR *end;     /* while out < end, enough space available */\n-      unsigned wsize;             /* window size or zero if not using window */\n-      unsigned write;             /* window write index */\n-      unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */\n-      unsigned long hold;         /* local strm->hold */\n-      unsigned bits;              /* local strm->bits */\n-      code const FAR *lcode;      /* local strm->lencode */\n-      code const FAR *dcode;      /* local strm->distcode */\n-      unsigned lmask;             /* mask for first level of length codes */\n-      unsigned dmask;             /* mask for first level of distance codes */\n-      unsigned len;               /* match length, unused bytes */\n-      unsigned dist;              /* match distance */\n-      unsigned status;            /* this is set when state changes */\n+/* 64   32                               x86  x86_64 */\n+/* ar offset                              register */\n+/*  0    0 */ void *esp;                /* esp save */\n+/*  8    4 */ void *ebp;                /* ebp save */\n+/* 16    8 */ unsigned char FAR *in;    /* esi rsi  local strm->next_in */\n+/* 24   12 */ unsigned char FAR *last;  /*     r9   while in < last */\n+/* 32   16 */ unsigned char FAR *out;   /* edi rdi  local strm->next_out */\n+/* 40   20 */ unsigned char FAR *beg;   /*          inflate()'s init next_out */\n+/* 48   24 */ unsigned char FAR *end;   /*     r10  while out < end */\n+/* 56   28 */ unsigned char FAR *window;/*          size of window, wsize!=0 */\n+/* 64   32 */ code const FAR *lcode;    /* ebp rbp  local strm->lencode */\n+/* 72   36 */ code const FAR *dcode;    /*     r11  local strm->distcode */\n+/* 80   40 */ unsigned long hold;       /* edx rdx  local strm->hold */\n+/* 88   44 */ unsigned bits;            /* ebx rbx  local strm->bits */\n+/* 92   48 */ unsigned wsize;           /*          window size */\n+/* 96   52 */ unsigned write;           /*          window write index */\n+/*100   56 */ unsigned lmask;           /*     r12  mask for lcode */\n+/*104   60 */ unsigned dmask;           /*     r13  mask for dcode */\n+/*108   64 */ unsigned len;             /*     r14  match length */\n+/*112   68 */ unsigned dist;            /*     r15  match distance */\n+/*116   72 */ unsigned status;          /*          set when state chng*/\n     } ar;\n \n+#if defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )\n+#define PAD_AVAIL_IN 6\n+#define PAD_AVAIL_OUT 258\n+#else\n+#define PAD_AVAIL_IN 5\n+#define PAD_AVAIL_OUT 257\n+#endif\n+\n     /* copy state to local variables */\n     state = (struct inflate_state FAR *)strm->state;\n     ar.in = strm->next_in;\n-    ar.last = ar.in + (strm->avail_in - 5);\n+    ar.last = ar.in + (strm->avail_in - PAD_AVAIL_IN);\n     ar.out = strm->next_out;\n     ar.beg = ar.out - (start - strm->avail_out);\n-    ar.end = ar.out + (strm->avail_out - 257);\n+    ar.end = ar.out + (strm->avail_out - PAD_AVAIL_OUT);\n     ar.wsize = state->wsize;\n     ar.write = state->write;\n     ar.window = state->window;\n@@ -105,32 +125,368 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n     /* decode literals and length/distances until end-of-block or not enough\n        input data or output space */\n \n-    /* align in on 2 byte boundary */\n-    if (((unsigned long)(void *)ar.in & 0x1) != 0) {\n+    /* align in on 1/2 hold size boundary */\n+    while (((unsigned long)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {\n         ar.hold += (unsigned long)*ar.in++ << ar.bits;\n         ar.bits += 8;\n     }\n \n-#if defined( __GNUC__ ) || defined( __ICC )\n+#if defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )\n+    __asm__ __volatile__ (\n+\"        leaq    %0, %%rax\\n\"\n+\"        movq    %%rbp, 8(%%rax)\\n\"       /* save regs rbp and rsp */\n+\"        movq    %%rsp, (%%rax)\\n\"\n+\"        movq    %%rax, %%rsp\\n\"          /* make rsp point to &ar */\n+\"        movq    16(%%rsp), %%rsi\\n\"      /* rsi  = in */\n+\"        movq    32(%%rsp), %%rdi\\n\"      /* rdi  = out */\n+\"        movq    24(%%rsp), %%r9\\n\"       /* r9   = last */\n+\"        movq    48(%%rsp), %%r10\\n\"      /* r10  = end */\n+\"        movq    64(%%rsp), %%rbp\\n\"      /* rbp  = lcode */\n+\"        movq    72(%%rsp), %%r11\\n\"      /* r11  = dcode */\n+\"        movq    80(%%rsp), %%rdx\\n\"      /* rdx  = hold */\n+\"        movl    88(%%rsp), %%ebx\\n\"      /* ebx  = bits */\n+\"        movl    100(%%rsp), %%r12d\\n\"    /* r12d = lmask */\n+\"        movl    104(%%rsp), %%r13d\\n\"    /* r13d = dmask */\n+                                          /* r14d = len */\n+                                          /* r15d = dist */\n+\"        cld\\n\"\n+\"        cmpq    %%rdi, %%r10\\n\"\n+\"        je      .L_one_time\\n\"           /* if only one decode left */\n+\"        cmpq    %%rsi, %%r9\\n\"\n+\"        je      .L_one_time\\n\"\n+\"        jmp     .L_do_loop\\n\"\n+\n+\".L_one_time:\\n\"\n+\"        movq    %%r12, %%r8\\n\"           /* r8 = lmask */\n+\"        cmpb    $32, %%bl\\n\"\n+\"        ja      .L_get_length_code_one_time\\n\"\n+\n+\"        lodsl\\n\"                         /* eax = *(uint *)in++ */\n+\"        movb    %%bl, %%cl\\n\"            /* cl = bits, needs it for shifting */\n+\"        addb    $32, %%bl\\n\"             /* bits += 32 */\n+\"        shlq    %%cl, %%rax\\n\"\n+\"        orq     %%rax, %%rdx\\n\"          /* hold |= *((uint *)in)++ << bits */\n+\"        jmp     .L_get_length_code_one_time\\n\"\n+\n+\".align 32,0x90\\n\"\n+\".L_while_test:\\n\"\n+\"        cmpq    %%rdi, %%r10\\n\"\n+\"        jbe     .L_break_loop\\n\"\n+\"        cmpq    %%rsi, %%r9\\n\"\n+\"        jbe     .L_break_loop\\n\"\n+\n+\".L_do_loop:\\n\"\n+\"        movq    %%r12, %%r8\\n\"           /* r8 = lmask */\n+\"        cmpb    $32, %%bl\\n\"\n+\"        ja      .L_get_length_code\\n\"    /* if (32 < bits) */\n+\n+\"        lodsl\\n\"                         /* eax = *(uint *)in++ */\n+\"        movb    %%bl, %%cl\\n\"            /* cl = bits, needs it for shifting */\n+\"        addb    $32, %%bl\\n\"             /* bits += 32 */\n+\"        shlq    %%cl, %%rax\\n\"\n+\"        orq     %%rax, %%rdx\\n\"          /* hold |= *((uint *)in)++ << bits */\n+\n+\".L_get_length_code:\\n\"\n+\"        andq    %%rdx, %%r8\\n\"            /* r8 &= hold */\n+\"        movl    (%%rbp,%%r8,4), %%eax\\n\"  /* eax = lcode[hold & lmask] */\n+\n+\"        movb    %%ah, %%cl\\n\"            /* cl = this.bits */\n+\"        subb    %%ah, %%bl\\n\"            /* bits -= this.bits */\n+\"        shrq    %%cl, %%rdx\\n\"           /* hold >>= this.bits */\n+\n+\"        testb   %%al, %%al\\n\"\n+\"        jnz     .L_test_for_length_base\\n\" /* if (op != 0) 45.7% */\n+\n+\"        movq    %%r12, %%r8\\n\"            /* r8 = lmask */\n+\"        shrl    $16, %%eax\\n\"            /* output this.val char */\n+\"        stosb\\n\"\n+\n+\".L_get_length_code_one_time:\\n\"\n+\"        andq    %%rdx, %%r8\\n\"            /* r8 &= hold */\n+\"        movl    (%%rbp,%%r8,4), %%eax\\n\" /* eax = lcode[hold & lmask] */\n+\n+\".L_dolen:\\n\"\n+\"        movb    %%ah, %%cl\\n\"            /* cl = this.bits */\n+\"        subb    %%ah, %%bl\\n\"            /* bits -= this.bits */\n+\"        shrq    %%cl, %%rdx\\n\"           /* hold >>= this.bits */\n+\n+\"        testb   %%al, %%al\\n\"\n+\"        jnz     .L_test_for_length_base\\n\" /* if (op != 0) 45.7% */\n+\n+\"        shrl    $16, %%eax\\n\"            /* output this.val char */\n+\"        stosb\\n\"\n+\"        jmp     .L_while_test\\n\"\n+\n+\".align 32,0x90\\n\"\n+\".L_test_for_length_base:\\n\"\n+\"        movl    %%eax, %%r14d\\n\"         /* len = this */\n+\"        shrl    $16, %%r14d\\n\"           /* len = this.val */\n+\"        movb    %%al, %%cl\\n\"\n+\n+\"        testb   $16, %%al\\n\"\n+\"        jz      .L_test_for_second_level_length\\n\" /* if ((op & 16) == 0) 8% */\n+\"        andb    $15, %%cl\\n\"             /* op &= 15 */\n+\"        jz      .L_decode_distance\\n\"    /* if (!op) */\n+\n+\".L_add_bits_to_len:\\n\"\n+\"        subb    %%cl, %%bl\\n\"\n+\"        xorl    %%eax, %%eax\\n\"\n+\"        incl    %%eax\\n\"\n+\"        shll    %%cl, %%eax\\n\"\n+\"        decl    %%eax\\n\"\n+\"        andl    %%edx, %%eax\\n\"          /* eax &= hold */\n+\"        shrq    %%cl, %%rdx\\n\"\n+\"        addl    %%eax, %%r14d\\n\"         /* len += hold & mask[op] */\n+\n+\".L_decode_distance:\\n\"\n+\"        movq    %%r13, %%r8\\n\"           /* r8 = dmask */\n+\"        cmpb    $32, %%bl\\n\"\n+\"        ja      .L_get_distance_code\\n\"  /* if (32 < bits) */\n+\n+\"        lodsl\\n\"                         /* eax = *(uint *)in++ */\n+\"        movb    %%bl, %%cl\\n\"            /* cl = bits, needs it for shifting */\n+\"        addb    $32, %%bl\\n\"             /* bits += 32 */\n+\"        shlq    %%cl, %%rax\\n\"\n+\"        orq     %%rax, %%rdx\\n\"          /* hold |= *((uint *)in)++ << bits */\n+\n+\".L_get_distance_code:\\n\"\n+\"        andq    %%rdx, %%r8\\n\"           /* r8 &= hold */\n+\"        movl    (%%r11,%%r8,4), %%eax\\n\" /* eax = dcode[hold & dmask] */\n+\n+\".L_dodist:\\n\"\n+\"        movl    %%eax, %%r15d\\n\"         /* dist = this */\n+\"        shrl    $16, %%r15d\\n\"           /* dist = this.val */\n+\"        movb    %%ah, %%cl\\n\"\n+\"        subb    %%ah, %%bl\\n\"            /* bits -= this.bits */\n+\"        shrq    %%cl, %%rdx\\n\"           /* hold >>= this.bits */\n+\"        movb    %%al, %%cl\\n\"            /* cl = this.op */\n+\n+\"        testb   $16, %%al\\n\"             /* if ((op & 16) == 0) */\n+\"        jz      .L_test_for_second_level_dist\\n\"\n+\"        andb    $15, %%cl\\n\"             /* op &= 15 */\n+\"        jz      .L_check_dist_one\\n\"\n+\n+\".L_add_bits_to_dist:\\n\"\n+\"        subb    %%cl, %%bl\\n\"\n+\"        xorl    %%eax, %%eax\\n\"\n+\"        incl    %%eax\\n\"\n+\"        shll    %%cl, %%eax\\n\"\n+\"        decl    %%eax\\n\"                 /* (1 << op) - 1 */\n+\"        andl    %%edx, %%eax\\n\"          /* eax &= hold */\n+\"        shrq    %%cl, %%rdx\\n\"\n+\"        addl    %%eax, %%r15d\\n\"         /* dist += hold & ((1 << op) - 1) */\n+\n+\".L_check_window:\\n\"\n+\"        movq    %%rsi, %%r8\\n\"           /* save in so from can use it's reg */\n+\"        movq    %%rdi, %%rax\\n\"\n+\"        subq    40(%%rsp), %%rax\\n\"      /* nbytes = out - beg */\n+\n+\"        cmpl    %%r15d, %%eax\\n\"\n+\"        jb      .L_clip_window\\n\"        /* if (dist > nbytes) 4.2% */\n+\n+\"        movl    %%r14d, %%ecx\\n\"         /* ecx = len */\n+\"        movq    %%rdi, %%rsi\\n\"\n+\"        subq    %%r15, %%rsi\\n\"          /* from = out - dist */\n+\n+\"        sarl    %%ecx\\n\"\n+\"        jnc     .L_copy_two\\n\"           /* if len % 2 == 0 */\n+\n+\"        rep     movsw\\n\"\n+\"        movb    (%%rsi), %%al\\n\"\n+\"        movb    %%al, (%%rdi)\\n\"\n+\"        incq    %%rdi\\n\"\n+\n+\"        movq    %%r8, %%rsi\\n\"           /* move in back to %rsi, toss from */\n+\"        jmp     .L_while_test\\n\"\n+\n+\".L_copy_two:\\n\"\n+\"        rep     movsw\\n\"\n+\"        movq    %%r8, %%rsi\\n\"           /* move in back to %rsi, toss from */\n+\"        jmp     .L_while_test\\n\"\n+\n+\".align 32,0x90\\n\"\n+\".L_check_dist_one:\\n\"\n+\"        cmpl    $1, %%r15d\\n\"            /* if dist 1, is a memset */\n+\"        jne     .L_check_window\\n\"\n+\"        cmpq    %%rdi, 40(%%rsp)\\n\"      /* if out == beg, outside window */\n+\"        je      .L_check_window\\n\"\n+\n+\"        movl    %%r14d, %%ecx\\n\"         /* ecx = len */\n+\"        movb    -1(%%rdi), %%al\\n\"\n+\"        movb    %%al, %%ah\\n\"\n+\n+\"        sarl    %%ecx\\n\"\n+\"        jnc     .L_set_two\\n\"\n+\"        movb    %%al, (%%rdi)\\n\"\n+\"        incq    %%rdi\\n\"\n+\n+\".L_set_two:\\n\"\n+\"        rep     stosw\\n\"\n+\"        jmp     .L_while_test\\n\"\n+\n+\".align 32,0x90\\n\"\n+\".L_test_for_second_level_length:\\n\"\n+\"        testb   $64, %%al\\n\"\n+\"        jnz     .L_test_for_end_of_block\\n\" /* if ((op & 64) != 0) */\n+\n+\"        xorl    %%eax, %%eax\\n\"\n+\"        incl    %%eax\\n\"\n+\"        shll    %%cl, %%eax\\n\"\n+\"        decl    %%eax\\n\"\n+\"        andl    %%edx, %%eax\\n\"         /* eax &= hold */\n+\"        addl    %%r14d, %%eax\\n\"        /* eax += len */\n+\"        movl    (%%rbp,%%rax,4), %%eax\\n\" /* eax = lcode[val+(hold&mask[op])]*/\n+\"        jmp     .L_dolen\\n\"\n+\n+\".align 32,0x90\\n\"\n+\".L_test_for_second_level_dist:\\n\"\n+\"        testb   $64, %%al\\n\"\n+\"        jnz     .L_invalid_distance_code\\n\" /* if ((op & 64) != 0) */\n+\n+\"        xorl    %%eax, %%eax\\n\"\n+\"        incl    %%eax\\n\"\n+\"        shll    %%cl, %%eax\\n\"\n+\"        decl    %%eax\\n\"\n+\"        andl    %%edx, %%eax\\n\"         /* eax &= hold */\n+\"        addl    %%r15d, %%eax\\n\"        /* eax += dist */\n+\"        movl    (%%r11,%%rax,4), %%eax\\n\" /* eax = dcode[val+(hold&mask[op])]*/\n+\"        jmp     .L_dodist\\n\"\n+\n+\".align 32,0x90\\n\"\n+\".L_clip_window:\\n\"\n+\"        movl    %%eax, %%ecx\\n\"         /* ecx = nbytes */\n+\"        movl    92(%%rsp), %%eax\\n\"     /* eax = wsize, prepare for dist cmp */\n+\"        negl    %%ecx\\n\"                /* nbytes = -nbytes */\n+\n+\"        cmpl    %%r15d, %%eax\\n\"\n+\"        jb      .L_invalid_distance_too_far\\n\" /* if (dist > wsize) */\n+\n+\"        addl    %%r15d, %%ecx\\n\"         /* nbytes = dist - nbytes */\n+\"        cmpl    $0, 96(%%rsp)\\n\"\n+\"        jne     .L_wrap_around_window\\n\" /* if (write != 0) */\n+\n+\"        movq    56(%%rsp), %%rsi\\n\"     /* from  = window */\n+\"        subl    %%ecx, %%eax\\n\"         /* eax  -= nbytes */\n+\"        addq    %%rax, %%rsi\\n\"         /* from += wsize - nbytes */\n+\n+\"        movl    %%r14d, %%eax\\n\"        /* eax = len */\n+\"        cmpl    %%ecx, %%r14d\\n\"\n+\"        jbe     .L_do_copy\\n\"           /* if (nbytes >= len) */\n+\n+\"        subl    %%ecx, %%eax\\n\"         /* eax -= nbytes */\n+\"        rep     movsb\\n\"\n+\"        movq    %%rdi, %%rsi\\n\"\n+\"        subq    %%r15, %%rsi\\n\"         /* from = &out[ -dist ] */\n+\"        jmp     .L_do_copy\\n\"\n+\n+\".align 32,0x90\\n\"\n+\".L_wrap_around_window:\\n\"\n+\"        movl    96(%%rsp), %%eax\\n\"     /* eax = write */\n+\"        cmpl    %%eax, %%ecx\\n\"\n+\"        jbe     .L_contiguous_in_window\\n\" /* if (write >= nbytes) */\n+\n+\"        movl    92(%%rsp), %%esi\\n\"     /* from  = wsize */\n+\"        addq    56(%%rsp), %%rsi\\n\"     /* from += window */\n+\"        addq    %%rax, %%rsi\\n\"         /* from += write */\n+\"        subq    %%rcx, %%rsi\\n\"         /* from -= nbytes */\n+\"        subl    %%eax, %%ecx\\n\"         /* nbytes -= write */\n+\n+\"        movl    %%r14d, %%eax\\n\"        /* eax = len */\n+\"        cmpl    %%ecx, %%eax\\n\"\n+\"        jbe     .L_do_copy\\n\"           /* if (nbytes >= len) */\n+\n+\"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n+\"        rep     movsb\\n\"\n+\"        movq    56(%%rsp), %%rsi\\n\"     /* from = window */\n+\"        movl    96(%%rsp), %%ecx\\n\"     /* nbytes = write */\n+\"        cmpl    %%ecx, %%eax\\n\"\n+\"        jbe     .L_do_copy\\n\"           /* if (nbytes >= len) */\n+\n+\"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n+\"        rep     movsb\\n\"\n+\"        movq    %%rdi, %%rsi\\n\"\n+\"        subq    %%r15, %%rsi\\n\"         /* from = out - dist */\n+\"        jmp     .L_do_copy\\n\"\n+\n+\".align 32,0x90\\n\"\n+\".L_contiguous_in_window:\\n\"\n+\"        movq    56(%%rsp), %%rsi\\n\"     /* rsi = window */\n+\"        addq    %%rax, %%rsi\\n\"\n+\"        subq    %%rcx, %%rsi\\n\"         /* from += write - nbytes */\n+\n+\"        movl    %%r14d, %%eax\\n\"        /* eax = len */\n+\"        cmpl    %%ecx, %%eax\\n\"\n+\"        jbe     .L_do_copy\\n\"           /* if (nbytes >= len) */\n+\n+\"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n+\"        rep     movsb\\n\"\n+\"        movq    %%rdi, %%rsi\\n\"\n+\"        subq    %%r15, %%rsi\\n\"         /* from = out - dist */\n+\"        jmp     .L_do_copy\\n\"           /* if (nbytes >= len) */\n+\n+\".align 32,0x90\\n\"\n+\".L_do_copy:\\n\"\n+\"        movl    %%eax, %%ecx\\n\"         /* ecx = len */\n+\"        rep     movsb\\n\"\n+\n+\"        movq    %%r8, %%rsi\\n\"          /* move in back to %esi, toss from */\n+\"        jmp     .L_while_test\\n\"\n+\n+\".L_test_for_end_of_block:\\n\"\n+\"        testb   $32, %%al\\n\"\n+\"        jz      .L_invalid_literal_length_code\\n\"\n+\"        movl    $1, 116(%%rsp)\\n\"\n+\"        jmp     .L_break_loop_with_status\\n\"\n+\n+\".L_invalid_literal_length_code:\\n\"\n+\"        movl    $2, 116(%%rsp)\\n\"\n+\"        jmp     .L_break_loop_with_status\\n\"\n+\n+\".L_invalid_distance_code:\\n\"\n+\"        movl    $3, 116(%%rsp)\\n\"\n+\"        jmp     .L_break_loop_with_status\\n\"\n+\n+\".L_invalid_distance_too_far:\\n\"\n+\"        movl    $4, 116(%%rsp)\\n\"\n+\"        jmp     .L_break_loop_with_status\\n\"\n+\n+\".L_break_loop:\\n\"\n+\"        movl    $0, 116(%%rsp)\\n\"\n+\n+\".L_break_loop_with_status:\\n\"\n+/* put in, out, bits, and hold back into ar and pop esp */\n+\"        movq    %%rsi, 16(%%rsp)\\n\"     /* in */\n+\"        movq    %%rdi, 32(%%rsp)\\n\"     /* out */\n+\"        movl    %%ebx, 88(%%rsp)\\n\"     /* bits */\n+\"        movq    %%rdx, 80(%%rsp)\\n\"     /* hold */\n+\"        movq    (%%rsp), %%rax\\n\"       /* restore rbp and rsp */\n+\"        movq    8(%%rsp), %%rbp\\n\"\n+\"        movq    %%rax, %%rsp\\n\"\n+          :\n+          : \"m\" (ar)\n+          : \"memory\", \"%rax\", \"%rbx\", \"%rcx\", \"%rdx\", \"%rsi\", \"%rdi\",\n+            \"%r8\", \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\"\n+    );\n+#elif ( defined( __GNUC__ ) || defined( __ICC ) ) && defined( __i386 )\n     __asm__ __volatile__ (\n \"        leal    %0, %%eax\\n\"\n-\"        pushf\\n\"\n-\"        pushl   %%ebp\\n\"\n-\"        movl    %%esp, (%%eax)\\n\"\n+\"        movl    %%esp, (%%eax)\\n\"        /* save esp, ebp */\n+\"        movl    %%ebp, 4(%%eax)\\n\"\n \"        movl    %%eax, %%esp\\n\"\n-\"        movl    4(%%esp), %%esi\\n\"       /* esi = in */\n-\"        movl    12(%%esp), %%edi\\n\"      /* edi = out */\n-\"        movl    36(%%esp), %%edx\\n\"      /* edx = hold */\n-\"        movl    40(%%esp), %%ebx\\n\"      /* ebx = bits */\n-\"        movl    44(%%esp), %%ebp\\n\"      /* ebp = lcode */\n+\"        movl    8(%%esp), %%esi\\n\"       /* esi = in */\n+\"        movl    16(%%esp), %%edi\\n\"      /* edi = out */\n+\"        movl    40(%%esp), %%edx\\n\"      /* edx = hold */\n+\"        movl    44(%%esp), %%ebx\\n\"      /* ebx = bits */\n+\"        movl    32(%%esp), %%ebp\\n\"      /* ebp = lcode */\n \n \"        cld\\n\"\n \"        jmp     .L_do_loop\\n\"\n \n+\".align 32,0x90\\n\"\n \".L_while_test:\\n\"\n-\"        cmpl    %%edi, 20(%%esp)\\n\"\n+\"        cmpl    %%edi, 24(%%esp)\\n\"      /* out < end */\n \"        jbe     .L_break_loop\\n\"\n-\"        cmpl    %%esi, 8(%%esp)\\n\"\n+\"        cmpl    %%esi, 12(%%esp)\\n\"      /* in < last */\n \"        jbe     .L_break_loop\\n\"\n \n \".L_do_loop:\\n\"\n@@ -145,7 +501,7 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n \"        orl     %%eax, %%edx\\n\"        /* hold |= *((ushort *)in)++ << bits */\n \n \".L_get_length_code:\\n\"\n-\"        movl    52(%%esp), %%eax\\n\"      /* eax = lmask */\n+\"        movl    56(%%esp), %%eax\\n\"      /* eax = lmask */\n \"        andl    %%edx, %%eax\\n\"          /* eax &= hold */\n \"        movl    (%%ebp,%%eax,4), %%eax\\n\" /* eax = lcode[hold & lmask] */\n \n@@ -161,10 +517,11 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n \"        stosb\\n\"\n \"        jmp     .L_while_test\\n\"\n \n+\".align 32,0x90\\n\"\n \".L_test_for_length_base:\\n\"\n \"        movl    %%eax, %%ecx\\n\"          /* len = this */\n \"        shrl    $16, %%ecx\\n\"            /* len = this.val */\n-\"        movl    %%ecx, 60(%%esp)\\n\"      /* len = this */\n+\"        movl    %%ecx, 64(%%esp)\\n\"      /* save len */\n \"        movb    %%al, %%cl\\n\"\n \n \"        testb   $16, %%al\\n\"\n@@ -184,13 +541,14 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n \"        movb    %%ch, %%cl\\n\"            /* move op back to ecx */\n \n \".L_add_bits_to_len:\\n\"\n-\"        movl    $1, %%eax\\n\"\n+\"        subb    %%cl, %%bl\\n\"\n+\"        xorl    %%eax, %%eax\\n\"\n+\"        incl    %%eax\\n\"\n \"        shll    %%cl, %%eax\\n\"\n \"        decl    %%eax\\n\"\n-\"        subb    %%cl, %%bl\\n\"\n \"        andl    %%edx, %%eax\\n\"          /* eax &= hold */\n \"        shrl    %%cl, %%edx\\n\"\n-\"        addl    %%eax, 60(%%esp)\\n\"      /* len += hold & mask[op] */\n+\"        addl    %%eax, 64(%%esp)\\n\"      /* len += hold & mask[op] */\n \n \".L_decode_distance:\\n\"\n \"        cmpb    $15, %%bl\\n\"\n@@ -204,8 +562,8 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n \"        orl     %%eax, %%edx\\n\"         /* hold |= *((ushort *)in)++ << bits */\n \n \".L_get_distance_code:\\n\"\n-\"        movl    56(%%esp), %%eax\\n\"      /* eax = dmask */\n-\"        movl    48(%%esp), %%ecx\\n\"      /* ecx = dcode */\n+\"        movl    60(%%esp), %%eax\\n\"      /* eax = dmask */\n+\"        movl    36(%%esp), %%ecx\\n\"      /* ecx = dcode */\n \"        andl    %%edx, %%eax\\n\"          /* eax &= hold */\n \"        movl    (%%ecx,%%eax,4), %%eax\\n\"/* eax = dcode[hold & dmask] */\n \n@@ -234,223 +592,228 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n \"        movb    %%ch, %%cl\\n\"            /* move op back to ecx */\n \n \".L_add_bits_to_dist:\\n\"\n-\"        movl    $1, %%eax\\n\"\n+\"        subb    %%cl, %%bl\\n\"\n+\"        xorl    %%eax, %%eax\\n\"\n+\"        incl    %%eax\\n\"\n \"        shll    %%cl, %%eax\\n\"\n \"        decl    %%eax\\n\"                 /* (1 << op) - 1 */\n-\"        subb    %%cl, %%bl\\n\"\n \"        andl    %%edx, %%eax\\n\"          /* eax &= hold */\n \"        shrl    %%cl, %%edx\\n\"\n \"        addl    %%eax, %%ebp\\n\"          /* dist += hold & ((1 << op) - 1) */\n \n \".L_check_window:\\n\"\n-\"        movl    %%esi, 4(%%esp)\\n\"       /* save in so from can use it's reg */\n+\"        movl    %%esi, 8(%%esp)\\n\"       /* save in so from can use it's reg */\n \"        movl    %%edi, %%eax\\n\"\n-\"        subl    16(%%esp), %%eax\\n\"      /* nbytes = out - beg */\n+\"        subl    20(%%esp), %%eax\\n\"      /* nbytes = out - beg */\n \n \"        cmpl    %%ebp, %%eax\\n\"\n \"        jb      .L_clip_window\\n\"        /* if (dist > nbytes) 4.2% */\n \n-\"        movl    60(%%esp), %%ecx\\n\"\n+\"        movl    64(%%esp), %%ecx\\n\"      /* ecx = len */\n \"        movl    %%edi, %%esi\\n\"\n \"        subl    %%ebp, %%esi\\n\"          /* from = out - dist */\n \n-\"        subl    $3, %%ecx\\n\"             /* copy from to out */\n+\"        sarl    %%ecx\\n\"\n+\"        jnc     .L_copy_two\\n\"           /* if len % 2 == 0 */\n+\n+\"        rep     movsw\\n\"\n \"        movb    (%%esi), %%al\\n\"\n \"        movb    %%al, (%%edi)\\n\"\n-\"        movb    1(%%esi), %%al\\n\"\n-\"        movb    2(%%esi), %%ah\\n\"\n-\"        addl    $3, %%esi\\n\"\n-\"        movb    %%al, 1(%%edi)\\n\"\n-\"        movb    %%ah, 2(%%edi)\\n\"\n-\"        addl    $3, %%edi\\n\"\n-\"        rep     movsb\\n\"\n+\"        incl    %%edi\\n\"\n \n-\"        movl    4(%%esp), %%esi\\n\"      /* move in back to %esi, toss from */\n-\"        movl    44(%%esp), %%ebp\\n\"     /* ebp = lcode */\n+\"        movl    8(%%esp), %%esi\\n\"       /* move in back to %esi, toss from */\n+\"        movl    32(%%esp), %%ebp\\n\"      /* ebp = lcode */\n \"        jmp     .L_while_test\\n\"\n \n+\".L_copy_two:\\n\"\n+\"        rep     movsw\\n\"\n+\"        movl    8(%%esp), %%esi\\n\"       /* move in back to %esi, toss from */\n+\"        movl    32(%%esp), %%ebp\\n\"      /* ebp = lcode */\n+\"        jmp     .L_while_test\\n\"\n+\n+\".align 32,0x90\\n\"\n \".L_check_dist_one:\\n\"\n \"        cmpl    $1, %%ebp\\n\"            /* if dist 1, is a memset */\n \"        jne     .L_check_window\\n\"\n-\"        cmpl    %%edi, 16(%%esp)\\n\"\n-\"        je      .L_check_window\\n\"\n+\"        cmpl    %%edi, 20(%%esp)\\n\"\n+\"        je      .L_check_window\\n\"      /* out == beg, if outside window */\n+\n+\"        movl    64(%%esp), %%ecx\\n\"      /* ecx = len */\n+\"        movb    -1(%%edi), %%al\\n\"\n+\"        movb    %%al, %%ah\\n\"\n+\n+\"        sarl    %%ecx\\n\"\n+\"        jnc     .L_set_two\\n\"\n+\"        movb    %%al, (%%edi)\\n\"\n+\"        incl    %%edi\\n\"\n \n-\"        decl    %%edi\\n\"\n-\"        movl    60(%%esp), %%ecx\\n\"\n-\"        movb    (%%edi), %%al\\n\"\n-\"        subl    $3, %%ecx\\n\"\n-\n-\"        movb    %%al, 1(%%edi)\\n\"       /* memset out with from[-1] */\n-\"        movb    %%al, 2(%%edi)\\n\"\n-\"        movb    %%al, 3(%%edi)\\n\"\n-\"        addl    $4, %%edi\\n\"\n-\"        rep     stosb\\n\"\n-\"        movl    44(%%esp), %%ebp\\n\"      /* ebp = lcode */\n+\".L_set_two:\\n\"\n+\"        rep     stosw\\n\"\n+\"        movl    32(%%esp), %%ebp\\n\"      /* ebp = lcode */\n \"        jmp     .L_while_test\\n\"\n \n+\".align 32,0x90\\n\"\n \".L_test_for_second_level_length:\\n\"\n \"        testb   $64, %%al\\n\"\n \"        jnz     .L_test_for_end_of_block\\n\" /* if ((op & 64) != 0) */\n \n-\"        movl    $1, %%eax\\n\"\n+\"        xorl    %%eax, %%eax\\n\"\n+\"        incl    %%eax\\n\"\n \"        shll    %%cl, %%eax\\n\"\n \"        decl    %%eax\\n\"\n \"        andl    %%edx, %%eax\\n\"         /* eax &= hold */\n-\"        addl    60(%%esp), %%eax\\n\"     /* eax += this.val */\n+\"        addl    64(%%esp), %%eax\\n\"     /* eax += len */\n \"        movl    (%%ebp,%%eax,4), %%eax\\n\" /* eax = lcode[val+(hold&mask[op])]*/\n \"        jmp     .L_dolen\\n\"\n \n+\".align 32,0x90\\n\"\n \".L_test_for_second_level_dist:\\n\"\n \"        testb   $64, %%al\\n\"\n \"        jnz     .L_invalid_distance_code\\n\" /* if ((op & 64) != 0) */\n \n-\"        movl    $1, %%eax\\n\"\n+\"        xorl    %%eax, %%eax\\n\"\n+\"        incl    %%eax\\n\"\n \"        shll    %%cl, %%eax\\n\"\n \"        decl    %%eax\\n\"\n \"        andl    %%edx, %%eax\\n\"         /* eax &= hold */\n-\"        addl    %%ebp, %%eax\\n\"         /* eax += this.val */\n-\"        movl    48(%%esp), %%ecx\\n\"     /* ecx = dcode */\n+\"        addl    %%ebp, %%eax\\n\"         /* eax += dist */\n+\"        movl    36(%%esp), %%ecx\\n\"     /* ecx = dcode */\n \"        movl    (%%ecx,%%eax,4), %%eax\\n\" /* eax = dcode[val+(hold&mask[op])]*/\n \"        jmp     .L_dodist\\n\"\n \n+\".align 32,0x90\\n\"\n \".L_clip_window:\\n\"\n \"        movl    %%eax, %%ecx\\n\"\n-\"        movl    24(%%esp), %%eax\\n\"     /* prepare for dist compare */\n+\"        movl    48(%%esp), %%eax\\n\"     /* eax = wsize */\n \"        negl    %%ecx\\n\"                /* nbytes = -nbytes */\n-\"        movl    32(%%esp), %%esi\\n\"     /* from = window */\n+\"        movl    28(%%esp), %%esi\\n\"     /* from = window */\n \n \"        cmpl    %%ebp, %%eax\\n\"\n \"        jb      .L_invalid_distance_too_far\\n\" /* if (dist > wsize) */\n \n \"        addl    %%ebp, %%ecx\\n\"         /* nbytes = dist - nbytes */\n-\"        cmpl    $0, 28(%%esp)\\n\"\n+\"        cmpl    $0, 52(%%esp)\\n\"\n \"        jne     .L_wrap_around_window\\n\" /* if (write != 0) */\n \n \"        subl    %%ecx, %%eax\\n\"\n \"        addl    %%eax, %%esi\\n\"         /* from += wsize - nbytes */\n \n-\"        movl    60(%%esp), %%eax\\n\"\n-\"        cmpl    %%ecx, %%eax\\n\"\n-\"        jbe     .L_do_copy1\\n\"          /* if (nbytes >= len) */\n-\n-\"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n-\"        rep     movsb\\n\"\n-\"        movl    %%edi, %%esi\\n\"\n-\"        subl    %%ebp, %%esi\\n\"         /* from = out - dist */\n-\"        jmp     .L_do_copy1\\n\"\n-\n+\"        movl    64(%%esp), %%eax\\n\"     /* eax = len */\n \"        cmpl    %%ecx, %%eax\\n\"\n-\"        jbe     .L_do_copy1\\n\"          /* if (nbytes >= len) */\n+\"        jbe     .L_do_copy\\n\"           /* if (nbytes >= len) */\n \n \"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n \"        rep     movsb\\n\"\n \"        movl    %%edi, %%esi\\n\"\n \"        subl    %%ebp, %%esi\\n\"         /* from = out - dist */\n-\"        jmp     .L_do_copy1\\n\"\n+\"        jmp     .L_do_copy\\n\"\n \n+\".align 32,0x90\\n\"\n \".L_wrap_around_window:\\n\"\n-\"        movl    28(%%esp), %%eax\\n\"\n+\"        movl    52(%%esp), %%eax\\n\"     /* eax = write */\n \"        cmpl    %%eax, %%ecx\\n\"\n \"        jbe     .L_contiguous_in_window\\n\" /* if (write >= nbytes) */\n \n-\"        addl    24(%%esp), %%esi\\n\"\n-\"        addl    %%eax, %%esi\\n\"\n-\"        subl    %%ecx, %%esi\\n\"         /* from += wsize + write - nbytes */\n+\"        addl    48(%%esp), %%esi\\n\"     /* from += wsize */\n+\"        addl    %%eax, %%esi\\n\"         /* from += write */\n+\"        subl    %%ecx, %%esi\\n\"         /* from -= nbytes */\n \"        subl    %%eax, %%ecx\\n\"         /* nbytes -= write */\n \n-\"        movl    60(%%esp), %%eax\\n\"\n+\"        movl    64(%%esp), %%eax\\n\"     /* eax = len */\n \"        cmpl    %%ecx, %%eax\\n\"\n-\"        jbe     .L_do_copy1\\n\"          /* if (nbytes >= len) */\n+\"        jbe     .L_do_copy\\n\"           /* if (nbytes >= len) */\n \n \"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n \"        rep     movsb\\n\"\n-\"        movl    32(%%esp), %%esi\\n\"     /* from = window */\n-\"        movl    28(%%esp), %%ecx\\n\"     /* nbytes = write */\n+\"        movl    28(%%esp), %%esi\\n\"     /* from = window */\n+\"        movl    52(%%esp), %%ecx\\n\"     /* nbytes = write */\n \"        cmpl    %%ecx, %%eax\\n\"\n-\"        jbe     .L_do_copy1\\n\"          /* if (nbytes >= len) */\n+\"        jbe     .L_do_copy\\n\"           /* if (nbytes >= len) */\n \n \"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n \"        rep     movsb\\n\"\n \"        movl    %%edi, %%esi\\n\"\n \"        subl    %%ebp, %%esi\\n\"         /* from = out - dist */\n-\"        jmp     .L_do_copy1\\n\"\n+\"        jmp     .L_do_copy\\n\"\n \n+\".align 32,0x90\\n\"\n \".L_contiguous_in_window:\\n\"\n \"        addl    %%eax, %%esi\\n\"\n \"        subl    %%ecx, %%esi\\n\"         /* from += write - nbytes */\n \n-\"        movl    60(%%esp), %%eax\\n\"\n+\"        movl    64(%%esp), %%eax\\n\"     /* eax = len */\n \"        cmpl    %%ecx, %%eax\\n\"\n-\"        jbe     .L_do_copy1\\n\"          /* if (nbytes >= len) */\n+\"        jbe     .L_do_copy\\n\"           /* if (nbytes >= len) */\n \n \"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n \"        rep     movsb\\n\"\n \"        movl    %%edi, %%esi\\n\"\n \"        subl    %%ebp, %%esi\\n\"         /* from = out - dist */\n+\"        jmp     .L_do_copy\\n\"           /* if (nbytes >= len) */\n \n-\".L_do_copy1:\\n\"\n+\".align 32,0x90\\n\"\n+\".L_do_copy:\\n\"\n \"        movl    %%eax, %%ecx\\n\"\n \"        rep     movsb\\n\"\n \n-\"        movl    4(%%esp), %%esi\\n\"      /* move in back to %esi, toss from */\n-\"        movl    44(%%esp), %%ebp\\n\"     /* ebp = lcode */\n+\"        movl    8(%%esp), %%esi\\n\"      /* move in back to %esi, toss from */\n+\"        movl    32(%%esp), %%ebp\\n\"     /* ebp = lcode */\n \"        jmp     .L_while_test\\n\"\n \n \".L_test_for_end_of_block:\\n\"\n \"        testb   $32, %%al\\n\"\n \"        jz      .L_invalid_literal_length_code\\n\"\n-\"        movl    $1, 68(%%esp)\\n\"\n+\"        movl    $1, 72(%%esp)\\n\"\n \"        jmp     .L_break_loop_with_status\\n\"\n \n \".L_invalid_literal_length_code:\\n\"\n-\"        movl    $2, 68(%%esp)\\n\"\n+\"        movl    $2, 72(%%esp)\\n\"\n \"        jmp     .L_break_loop_with_status\\n\"\n \n \".L_invalid_distance_code:\\n\"\n-\"        movl    $3, 68(%%esp)\\n\"\n+\"        movl    $3, 72(%%esp)\\n\"\n \"        jmp     .L_break_loop_with_status\\n\"\n \n \".L_invalid_distance_too_far:\\n\"\n-\"        movl    4(%%esp), %%esi\\n\"\n-\"        movl    $4, 68(%%esp)\\n\"\n+\"        movl    8(%%esp), %%esi\\n\"\n+\"        movl    $4, 72(%%esp)\\n\"\n \"        jmp     .L_break_loop_with_status\\n\"\n \n \".L_break_loop:\\n\"\n-\"        movl    $0, 68(%%esp)\\n\"\n+\"        movl    $0, 72(%%esp)\\n\"\n \n \".L_break_loop_with_status:\\n\"\n /* put in, out, bits, and hold back into ar and pop esp */\n-\"        movl    %%esi, 4(%%esp)\\n\"\n-\"        movl    %%edi, 12(%%esp)\\n\"\n-\"        movl    %%ebx, 40(%%esp)\\n\"\n-\"        movl    %%edx, 36(%%esp)\\n\"\n+\"        movl    %%esi, 8(%%esp)\\n\"      /* save in */\n+\"        movl    %%edi, 16(%%esp)\\n\"     /* save out */\n+\"        movl    %%ebx, 44(%%esp)\\n\"     /* save bits */\n+\"        movl    %%edx, 40(%%esp)\\n\"     /* save hold */\n+\"        movl    4(%%esp), %%ebp\\n\"      /* restore esp, ebp */\n \"        movl    (%%esp), %%esp\\n\"\n-\"        popl    %%ebp\\n\"\n-\"        popf\\n\"\n           :\n           : \"m\" (ar)\n           : \"memory\", \"%eax\", \"%ebx\", \"%ecx\", \"%edx\", \"%esi\", \"%edi\"\n     );\n-#elif defined( _MSC_VER )\n+#elif defined( _MSC_VER ) && ! defined( _M_AMD64 )\n     __asm {\n \tlea\teax, ar\n-\tpushfd\n-\tpush\tebp\n-\tmov\t[eax], esp\n+\tmov\t[eax], esp         /* save esp, ebp */\n+\tmov\t[eax+4], ebp\n \tmov\tesp, eax\n-\tmov\tesi, [esp+4]       /* esi = in */\n-\tmov\tedi, [esp+12]      /* edi = out */\n-\tmov\tedx, [esp+36]      /* edx = hold */\n-\tmov\tebx, [esp+40]      /* ebx = bits */\n-\tmov\tebp, [esp+44]      /* ebp = lcode */\n+\tmov\tesi, [esp+8]       /* esi = in */\n+\tmov\tedi, [esp+16]      /* edi = out */\n+\tmov\tedx, [esp+40]      /* edx = hold */\n+\tmov\tebx, [esp+44]      /* ebx = bits */\n+\tmov\tebp, [esp+32]      /* ebp = lcode */\n \n \tcld\n \tjmp\tL_do_loop\n \n+ALIGN 4\n L_while_test:\n-\tcmp\t[esp+20], edi\n+\tcmp\t[esp+24], edi\n \tjbe\tL_break_loop\n-\tcmp\t[esp+8], esi\n+\tcmp\t[esp+12], esi\n \tjbe\tL_break_loop\n \n L_do_loop:\n@@ -465,7 +828,7 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n \tor\tedx, eax        /* hold |= *((ushort *)in)++ << bits */\n \n L_get_length_code:\n-\tmov\teax, [esp+52]      /* eax = lmask */\n+\tmov\teax, [esp+56]      /* eax = lmask */\n \tand\teax, edx          /* eax &= hold */\n \tmov\teax, [ebp+eax*4] /* eax = lcode[hold & lmask] */\n \n@@ -481,10 +844,11 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n \tstosb\n \tjmp\tL_while_test\n \n+ALIGN 4\n L_test_for_length_base:\n \tmov\tecx, eax          /* len = this */\n \tshr\tecx, 16            /* len = this.val */\n-\tmov\t[esp+60], ecx      /* len = this */\n+\tmov\t[esp+64], ecx      /* save len */\n \tmov\tcl, al\n \n \ttest\tal, 16\n@@ -504,13 +868,14 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n \tmov\tcl, ch            /* move op back to ecx */\n \n L_add_bits_to_len:\n-\tmov\teax, 1\n+\tsub\tbl, cl\n+\txor\teax, eax\n+\tinc\teax\n \tshl\teax, cl\n \tdec\teax\n-\tsub\tbl, cl\n \tand\teax, edx          /* eax &= hold */\n \tshr\tedx, cl\n-\tadd\t[esp+60], eax      /* len += hold & mask[op] */\n+\tadd\t[esp+64], eax      /* len += hold & mask[op] */\n \n L_decode_distance:\n \tcmp\tbl, 15\n@@ -524,8 +889,8 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n \tor\tedx, eax         /* hold |= *((ushort *)in)++ << bits */\n \n L_get_distance_code:\n-\tmov\teax, [esp+56]      /* eax = dmask */\n-\tmov\tecx, [esp+48]      /* ecx = dcode */\n+\tmov\teax, [esp+60]      /* eax = dmask */\n+\tmov\tecx, [esp+36]      /* ecx = dcode */\n \tand\teax, edx          /* eax &= hold */\n \tmov\teax, [ecx+eax*4]/* eax = dcode[hold & dmask] */\n \n@@ -554,200 +919,207 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n \tmov\tcl, ch            /* move op back to ecx */\n \n L_add_bits_to_dist:\n-\tmov\teax, 1\n+\tsub\tbl, cl\n+\txor\teax, eax\n+\tinc\teax\n \tshl\teax, cl\n \tdec\teax                 /* (1 << op) - 1 */\n-\tsub\tbl, cl\n \tand\teax, edx          /* eax &= hold */\n \tshr\tedx, cl\n \tadd\tebp, eax          /* dist += hold & ((1 << op) - 1) */\n \n L_check_window:\n-\tmov\t[esp+4], esi       /* save in so from can use it's reg */\n+\tmov\t[esp+8], esi       /* save in so from can use it's reg */\n \tmov\teax, edi\n-\tsub\teax, [esp+16]      /* nbytes = out - beg */\n+\tsub\teax, [esp+20]      /* nbytes = out - beg */\n \n \tcmp\teax, ebp\n \tjb\tL_clip_window        /* if (dist > nbytes) 4.2% */\n \n-\tmov\tecx, [esp+60]\n+\tmov\tecx, [esp+64]      /* ecx = len */\n \tmov\tesi, edi\n \tsub\tesi, ebp          /* from = out - dist */\n \n-\tsub\tecx, 3             /* copy from to out */\n+\tsar\tecx, 1\n+\tjnc\tL_copy_two\n+\n+\trep     movsw\n \tmov\tal, [esi]\n \tmov\t[edi], al\n-\tmov\tal, [esi+1]\n-\tmov\tah, [esi+2]\n-\tadd\tesi, 3\n-\tmov\t[edi+1], al\n-\tmov\t[edi+2], ah\n-\tadd\tedi, 3\n-\trep     movsb\n+\tinc\tedi\n+\n+\tmov\tesi, [esp+8]      /* move in back to %esi, toss from */\n+\tmov\tebp, [esp+32]     /* ebp = lcode */\n+\tjmp\tL_while_test\n \n-\tmov\tesi, [esp+4]      /* move in back to %esi, toss from */\n-\tmov\tebp, [esp+44]     /* ebp = lcode */\n+L_copy_two:\n+\trep     movsw\n+\tmov\tesi, [esp+8]      /* move in back to %esi, toss from */\n+\tmov\tebp, [esp+32]     /* ebp = lcode */\n \tjmp\tL_while_test\n \n+ALIGN 4\n L_check_dist_one:\n \tcmp\tebp, 1            /* if dist 1, is a memset */\n \tjne\tL_check_window\n-\tcmp\t[esp+16], edi\n-\tje\tL_check_window\n-\n-\tdec\tedi\n-\tmov\tecx, [esp+60]\n-\tmov\tal, [edi]\n-\tsub\tecx, 3\n-\n-\tmov\t[edi+1], al       /* memset out with from[-1] */\n-\tmov\t[edi+2], al\n-\tmov\t[edi+3], al\n-\tadd\tedi, 4\n-\trep     stosb\n-\tmov\tebp, [esp+44]      /* ebp = lcode */\n+\tcmp\t[esp+20], edi\n+\tje\tL_check_window    /* out == beg, if outside window */\n+\n+\tmov\tecx, [esp+64]     /* ecx = len */\n+\tmov\tal, [edi-1]\n+\tmov\tah, al\n+\n+\tsar\tecx, 1\n+\tjnc\tL_set_two\n+\tmov\t[edi], al         /* memset out with from[-1] */\n+\tinc\tedi\n+\n+L_set_two:\n+\trep     stosw\n+\tmov\tebp, [esp+32]     /* ebp = lcode */\n \tjmp\tL_while_test\n \n+ALIGN 4\n L_test_for_second_level_length:\n \ttest\tal, 64\n \tjnz\tL_test_for_end_of_block /* if ((op & 64) != 0) */\n \n-\tmov\teax, 1\n+\txor\teax, eax\n+\tinc\teax\n \tshl\teax, cl\n \tdec\teax\n \tand\teax, edx         /* eax &= hold */\n-\tadd\teax, [esp+60]     /* eax += this.val */\n+\tadd\teax, [esp+64]     /* eax += len */\n \tmov\teax, [ebp+eax*4] /* eax = lcode[val+(hold&mask[op])]*/\n \tjmp\tL_dolen\n \n+ALIGN 4\n L_test_for_second_level_dist:\n \ttest\tal, 64\n \tjnz\tL_invalid_distance_code /* if ((op & 64) != 0) */\n \n-\tmov\teax, 1\n+\txor\teax, eax\n+\tinc\teax\n \tshl\teax, cl\n \tdec\teax\n \tand\teax, edx         /* eax &= hold */\n-\tadd\teax, ebp         /* eax += this.val */\n-\tmov\tecx, [esp+48]     /* ecx = dcode */\n+\tadd\teax, ebp         /* eax += dist */\n+\tmov\tecx, [esp+36]     /* ecx = dcode */\n \tmov\teax, [ecx+eax*4] /* eax = dcode[val+(hold&mask[op])]*/\n \tjmp\tL_dodist\n \n+ALIGN 4\n L_clip_window:\n \tmov\tecx, eax\n-\tmov\teax, [esp+24]     /* prepare for dist compare */\n+\tmov\teax, [esp+48]     /* eax = wsize */\n \tneg\tecx                /* nbytes = -nbytes */\n-\tmov\tesi, [esp+32]     /* from = window */\n+\tmov\tesi, [esp+28]     /* from = window */\n \n \tcmp\teax, ebp\n \tjb\tL_invalid_distance_too_far /* if (dist > wsize) */\n \n \tadd\tecx, ebp         /* nbytes = dist - nbytes */\n-\tcmp\tdword ptr [esp+28], 0\n+\tcmp\tdword ptr [esp+52], 0\n \tjne\tL_wrap_around_window /* if (write != 0) */\n \n \tsub\teax, ecx\n \tadd\tesi, eax         /* from += wsize - nbytes */\n \n-\tmov\teax, [esp+60]\n-\tcmp\teax, ecx\n-\tjbe\tL_do_copy1          /* if (nbytes >= len) */\n-\n-\tsub\teax, ecx         /* len -= nbytes */\n-\trep     movsb\n-\tmov\tesi, edi\n-\tsub\tesi, ebp         /* from = out - dist */\n-\tjmp\tL_do_copy1\n-\n+\tmov\teax, [esp+64]    /* eax = len */\n \tcmp\teax, ecx\n-\tjbe\tL_do_copy1          /* if (nbytes >= len) */\n+\tjbe\tL_do_copy          /* if (nbytes >= len) */\n \n \tsub\teax, ecx         /* len -= nbytes */\n \trep     movsb\n \tmov\tesi, edi\n \tsub\tesi, ebp         /* from = out - dist */\n-\tjmp\tL_do_copy1\n+\tjmp\tL_do_copy\n \n+ALIGN 4\n L_wrap_around_window:\n-\tmov\teax, [esp+28]\n+\tmov\teax, [esp+52]    /* eax = write */\n \tcmp\tecx, eax\n \tjbe\tL_contiguous_in_window /* if (write >= nbytes) */\n \n-\tadd\tesi, [esp+24]\n-\tadd\tesi, eax\n-\tsub\tesi, ecx         /* from += wsize + write - nbytes */\n+\tadd\tesi, [esp+48]    /* from += wsize */\n+\tadd\tesi, eax         /* from += write */\n+\tsub\tesi, ecx         /* from -= nbytes */\n \tsub\tecx, eax         /* nbytes -= write */\n \n-\tmov\teax, [esp+60]\n+\tmov\teax, [esp+64]    /* eax = len */\n \tcmp\teax, ecx\n-\tjbe\tL_do_copy1          /* if (nbytes >= len) */\n+\tjbe\tL_do_copy          /* if (nbytes >= len) */\n \n \tsub\teax, ecx         /* len -= nbytes */\n \trep     movsb\n-\tmov\tesi, [esp+32]     /* from = window */\n-\tmov\tecx, [esp+28]     /* nbytes = write */\n+\tmov\tesi, [esp+28]     /* from = window */\n+\tmov\tecx, [esp+52]     /* nbytes = write */\n \tcmp\teax, ecx\n-\tjbe\tL_do_copy1          /* if (nbytes >= len) */\n+\tjbe\tL_do_copy          /* if (nbytes >= len) */\n \n \tsub\teax, ecx         /* len -= nbytes */\n \trep     movsb\n \tmov\tesi, edi\n \tsub\tesi, ebp         /* from = out - dist */\n-\tjmp\tL_do_copy1\n+\tjmp\tL_do_copy\n \n+ALIGN 4\n L_contiguous_in_window:\n \tadd\tesi, eax\n \tsub\tesi, ecx         /* from += write - nbytes */\n \n-\tmov\teax, [esp+60]\n+\tmov\teax, [esp+64]    /* eax = len */\n \tcmp\teax, ecx\n-\tjbe\tL_do_copy1          /* if (nbytes >= len) */\n+\tjbe\tL_do_copy          /* if (nbytes >= len) */\n \n \tsub\teax, ecx         /* len -= nbytes */\n \trep     movsb\n \tmov\tesi, edi\n \tsub\tesi, ebp         /* from = out - dist */\n+\tjmp\tL_do_copy\n \n-L_do_copy1:\n+ALIGN 4\n+L_do_copy:\n \tmov\tecx, eax\n \trep     movsb\n \n-\tmov\tesi, [esp+4]      /* move in back to %esi, toss from */\n-\tmov\tebp, [esp+44]     /* ebp = lcode */\n+\tmov\tesi, [esp+8]      /* move in back to %esi, toss from */\n+\tmov\tebp, [esp+32]     /* ebp = lcode */\n \tjmp\tL_while_test\n \n L_test_for_end_of_block:\n \ttest\tal, 32\n \tjz\tL_invalid_literal_length_code\n-\tmov\tdword ptr [esp+68], 1\n+\tmov\tdword ptr [esp+72], 1\n \tjmp\tL_break_loop_with_status\n \n L_invalid_literal_length_code:\n-\tmov\tdword ptr [esp+68], 2\n+\tmov\tdword ptr [esp+72], 2\n \tjmp\tL_break_loop_with_status\n \n L_invalid_distance_code:\n-\tmov\tdword ptr [esp+68], 3\n+\tmov\tdword ptr [esp+72], 3\n \tjmp\tL_break_loop_with_status\n \n L_invalid_distance_too_far:\n \tmov\tesi, [esp+4]\n-\tmov\tdword ptr [esp+68], 4\n+\tmov\tdword ptr [esp+72], 4\n \tjmp\tL_break_loop_with_status\n \n L_break_loop:\n-\tmov\tdword ptr [esp+68], 0\n+\tmov\tdword ptr [esp+72], 0\n \n L_break_loop_with_status:\n /* put in, out, bits, and hold back into ar and pop esp */\n-\tmov\t[esp+4], esi\n-\tmov\t[esp+12], edi\n-\tmov\t[esp+40], ebx\n-\tmov\t[esp+36], edx\n+\tmov\t[esp+8], esi     /* save in */\n+\tmov\t[esp+16], edi    /* save out */\n+\tmov\t[esp+44], ebx    /* save bits */\n+\tmov\t[esp+40], edx    /* save hold */\n+\tmov\tebp, [esp+4]     /* restore esp, ebp */\n \tmov\tesp, [esp]\n-\tpop\tebp\n-\tpopfd\n     }\n+#else\n+#error \"x86 architecture not defined\"\n #endif\n \n     if (ar.status > 1) {\n@@ -772,10 +1144,12 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n     /* update state and return */\n     strm->next_in = ar.in;\n     strm->next_out = ar.out;\n-    strm->avail_in = (unsigned)(ar.in < ar.last ? 5 + (ar.last - ar.in) :\n-                                                  5 - (ar.in - ar.last));\n-    strm->avail_out = (unsigned)(ar.out < ar.end ? 257 + (ar.end - ar.out) :\n-                                                   257 - (ar.out - ar.end));\n+    strm->avail_in = (unsigned)(ar.in < ar.last ?\n+                                PAD_AVAIL_IN + (ar.last - ar.in) :\n+                                PAD_AVAIL_IN - (ar.in - ar.last));\n+    strm->avail_out = (unsigned)(ar.out < ar.end ?\n+                                 PAD_AVAIL_OUT + (ar.end - ar.out) :\n+                                 PAD_AVAIL_OUT - (ar.out - ar.end));\n     state->hold = ar.hold;\n     state->bits = ar.bits;\n     return;"}, {"sha": "2245a2905bdf53083544015620345a175c4fdf64", "filename": "zlib/contrib/inflate86/inffast.S", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Finflate86%2Finffast.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Finflate86%2Finffast.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finflate86%2Finffast.S?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -188,17 +188,8 @@\n /*\n  * typedef enum inflate_mode consts, in inflate.h\n  */\n-#ifndef NO_GUNZIP\n-#define GUNZIP\n-#endif\n-\n-#ifdef GUNZIP\n #define INFLATE_MODE_TYPE 11  /* state->mode flags enum-ed in inflate.h */\n #define INFLATE_MODE_BAD  26\n-#else\n-#define INFLATE_MODE_TYPE 3\n-#define INFLATE_MODE_BAD  17\n-#endif\n \n \n #if ! defined( USE_MMX ) && ! defined( NO_MMX )"}, {"sha": "4b03a71abd5998f095e500f6bbf6ddcca9a1eaad", "filename": "zlib/contrib/masm686/match.asm", "status": "modified", "additions": 413, "deletions": 408, "changes": 821, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fmasm686%2Fmatch.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fmasm686%2Fmatch.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasm686%2Fmatch.asm?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,408 +1,413 @@\n-\n-; match.asm -- Pentium-Pro optimized version of longest_match()\n-;\n-; Updated for zlib 1.1.3 and converted to MASM 6.1x\n-; Copyright (C) 2000 Dan Higdon <hdan@kinesoft.com>\n-;                    and Chuck Walbourn <chuckw@kinesoft.com>\n-; Corrections by Cosmin Truta <cosmint@cs.ubbcluj.ro>\n-;\n-; This is free software; you can redistribute it and/or modify it\n-; under the terms of the GNU General Public License.\n-\n-; Based on match.S\n-; Written for zlib 1.1.2\n-; Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>\n-\n-\t.686P\n-\t.MODEL\tFLAT\n-\n-;===========================================================================\n-; EQUATES\n-;===========================================================================\n-\n-MAX_MATCH\tEQU 258\n-MIN_MATCH\tEQU 3\n-MIN_LOOKAHEAD\tEQU (MAX_MATCH + MIN_MATCH + 1)\n-MAX_MATCH_8\tEQU ((MAX_MATCH + 7) AND (NOT 7))\n-\n-;===========================================================================\n-; STRUCTURES\n-;===========================================================================\n-\n-; This STRUCT assumes a 4-byte alignment\n-\n-DEFLATE_STATE\tSTRUCT\n-ds_strm\t\t\tdd ?\n-ds_status\t\tdd ?\n-ds_pending_buf\t\tdd ?\n-ds_pending_buf_size\tdd ?\n-ds_pending_out\t\tdd ?\n-ds_pending\t\tdd ?\n-ds_wrap\t\t\tdd ?\n-ds_data_type\t\tdb ?\n-ds_method\t\tdb ?\n-\t\t\tdb ?\t; padding\n-\t\t\tdb ?\t; padding\n-ds_last_flush\t\tdd ?\n-ds_w_size\t\tdd ?\t; used\n-ds_w_bits\t\tdd ?\n-ds_w_mask\t\tdd ?\t; used\n-ds_window\t\tdd ?\t; used\n-ds_window_size\t\tdd ?\n-ds_prev\t\t\tdd ?\t; used\n-ds_head\t\t\tdd ?\n-ds_ins_h\t\tdd ?\n-ds_hash_size\t\tdd ?\n-ds_hash_bits\t\tdd ?\n-ds_hash_mask\t\tdd ?\n-ds_hash_shift\t\tdd ?\n-ds_block_start\t\tdd ?\n-ds_match_length\t\tdd ?\t; used\n-ds_prev_match\t\tdd ?\t; used\n-ds_match_available\tdd ?\n-ds_strstart\t\tdd ?\t; used\n-ds_match_start\t\tdd ?\t; used\n-ds_lookahead\t\tdd ?\t; used\n-ds_prev_length\t\tdd ?\t; used\n-ds_max_chain_length\tdd ?\t; used\n-ds_max_laxy_match\tdd ?\n-ds_level\t\tdd ?\n-ds_strategy\t\tdd ?\n-ds_good_match\t\tdd ?\t; used\n-ds_nice_match\t\tdd ?\t; used\n-\n-; Don't need anymore of the struct for match\n-DEFLATE_STATE\tENDS\n-\n-;===========================================================================\n-; CODE\n-;===========================================================================\n-_TEXT\tSEGMENT\n-\n-;---------------------------------------------------------------------------\n-; match_init\n-;---------------------------------------------------------------------------\n-\tALIGN\t4\n-PUBLIC\t_match_init\n-_match_init\tPROC\n-\t; no initialization needed\n-\tret\n-_match_init\tENDP\n-\n-;---------------------------------------------------------------------------\n-; uInt longest_match(deflate_state *deflatestate, IPos curmatch)\n-;---------------------------------------------------------------------------\n-\tALIGN\t4\n-\n-PUBLIC\t_longest_match\n-_longest_match\tPROC\n-\n-; Since this code uses EBP for a scratch register, the stack frame must\n-; be manually constructed and referenced relative to the ESP register.\n-\n-; Stack image\n-; Variables\n-chainlenwmask\t=  0\t; high word: current chain len\n-\t\t\t; low word: s->wmask\n-window\t\t=  4\t; local copy of s->window\n-windowbestlen\t=  8\t; s->window + bestlen\n-scanend\t\t= 12\t; last two bytes of string\n-scanstart\t= 16\t; first two bytes of string\n-scanalign\t= 20\t; dword-misalignment of string\n-nicematch\t= 24\t; a good enough match size\n-bestlen\t\t= 28\t; size of best match so far\n-scan\t\t= 32\t; ptr to string wanting match\n-varsize\t\t= 36\t; number of bytes (also offset to last saved register)\n-\n-; Saved Registers (actually pushed into place)\n-ebx_save\t= 36\n-edi_save\t= 40\n-esi_save\t= 44\n-ebp_save\t= 48\n-\n-; Parameters\n-retaddr\t\t= 52\n-deflatestate\t= 56\n-curmatch\t= 60\n-\n-; Save registers that the compiler may be using\n-\tpush\tebp\n-\tpush\tedi\n-\tpush\tesi\n-\tpush\tebx\n-\n-; Allocate local variable space\n-\tsub\tesp,varsize\n-\n-; Retrieve the function arguments. ecx will hold cur_match\n-; throughout the entire function. edx will hold the pointer to the\n-; deflate_state structure during the function's setup (before\n-; entering the main loop).\n-\n-\tmov\tedx, [esp+deflatestate]\n-ASSUME\tedx:PTR DEFLATE_STATE\n-\n-\tmov\tecx, [esp+curmatch]\n-\n-; uInt wmask = s->w_mask;\n-; unsigned chain_length = s->max_chain_length;\n-; if (s->prev_length >= s->good_match) {\n-;     chain_length >>= 2;\n-; }\n-\n-\tmov\teax, [edx].ds_prev_length\n-\tmov\tebx, [edx].ds_good_match\n-\tcmp\teax, ebx\n-\tmov\teax, [edx].ds_w_mask\n-\tmov\tebx, [edx].ds_max_chain_length\n-\tjl\tSHORT LastMatchGood\n-\tshr\tebx, 2\n-LastMatchGood:\n-\n-; chainlen is decremented once beforehand so that the function can\n-; use the sign flag instead of the zero flag for the exit test.\n-; It is then shifted into the high word, to make room for the wmask\n-; value, which it will always accompany.\n-\n-\tdec\tebx\n-\tshl\tebx, 16\n-\tor\tebx, eax\n-\tmov\t[esp+chainlenwmask], ebx\n-\n-; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n-\n-\tmov\teax, [edx].ds_nice_match\n-\tmov\tebx, [edx].ds_lookahead\n-\tcmp\tebx, eax\n-\tjl\tSHORT LookaheadLess\n-\tmov\tebx, eax\n-LookaheadLess:\n-\tmov\t[esp+nicematch], ebx\n-\n-;/* register Bytef *scan = s->window + s->strstart;                     */\n-\n-\tmov\tesi, [edx].ds_window\n-\tmov\t[esp+window], esi\n-\tmov\tebp, [edx].ds_strstart\n-\tlea\tedi, [esi+ebp]\n-\tmov\t[esp+scan],edi\n-\n-;/* Determine how many bytes the scan ptr is off from being             */\n-;/* dword-aligned.                                                      */\n-\n-\tmov\teax, edi\n-\tneg\teax\n-\tand\teax, 3\n-\tmov\t[esp+scanalign], eax\n-\n-;/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?                      */\n-;/*     s->strstart - (IPos)MAX_DIST(s) : NIL;                          */\n-\n-\tmov\teax, [edx].ds_w_size\n-\tsub\teax, MIN_LOOKAHEAD\n-\tsub\tebp, eax\n-\tjg\tSHORT LimitPositive\n-\txor\tebp, ebp\n-LimitPositive:\n-\n-;/* int best_len = s->prev_length;                                      */\n-\n-\tmov\teax, [edx].ds_prev_length\n-\tmov\t[esp+bestlen], eax\n-\n-;/* Store the sum of s->window + best_len in %esi locally, and in %esi. */\n-\n-\tadd\tesi, eax\n-\tmov\t[esp+windowbestlen], esi\n-\n-;/* register ush scan_start = *(ushf*)scan;                             */\n-;/* register ush scan_end   = *(ushf*)(scan+best_len-1);                */\n-;/* Posf *prev = s->prev;                                               */\n-\n-\tmovzx\tebx, WORD PTR[edi]\n-\tmov\t[esp+scanstart], ebx\n-\tmovzx\tebx, WORD PTR[eax+edi-1]\n-\tmov\t[esp+scanend], ebx\n-\tmov\tedi, [edx].ds_prev\n-\n-;/* Jump into the main loop.                                            */\n-\n-\tmov\tedx, [esp+chainlenwmask]\n-\tjmp\tSHORT LoopEntry\n-\n-;/* do {\n-; *     match = s->window + cur_match;\n-; *     if (*(ushf*)(match+best_len-1) != scan_end ||\n-; *         *(ushf*)match != scan_start) continue;\n-; *     [...]\n-; * } while ((cur_match = prev[cur_match & wmask]) > limit\n-; *          && --chain_length != 0);\n-; *\n-; * Here is the inner loop of the function. The function will spend the\n-; * majority of its time in this loop, and majority of that time will\n-; * be spent in the first ten instructions.\n-; *\n-; * Within this loop:\n-; * %ebx = scanend\n-; * %ecx = curmatch\n-; * %edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)\n-; * %esi = windowbestlen - i.e., (window + bestlen)\n-; * %edi = prev\n-; * %ebp = limit\n-; */\n-\n-\tALIGN\t4\n-LookupLoop:\n-\tand\tecx, edx\n-\tmovzx\tecx, WORD PTR[edi+ecx*2]\n-\tcmp\tecx, ebp\n-\tjbe\tLeaveNow\n-\tsub\tedx, 000010000H\n-\tjs\tLeaveNow\n-\n-LoopEntry:\n-\tmovzx\teax, WORD PTR[esi+ecx-1]\n-\tcmp\teax, ebx\n-\tjnz\tSHORT LookupLoop\n-\n-\tmov\teax, [esp+window]\n-\tmovzx\teax, WORD PTR[eax+ecx]\n-\tcmp\teax, [esp+scanstart]\n-\tjnz\tSHORT LookupLoop\n-\n-;/* Store the current value of chainlen.                                */\n-\n-\tmov\t[esp+chainlenwmask], edx\n-\n-;/* Point %edi to the string under scrutiny, and %esi to the string we  */\n-;/* are hoping to match it up with. In actuality, %esi and %edi are     */\n-;/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is     */\n-;/* initialized to -(MAX_MATCH_8 - scanalign).                          */\n-\n-\tmov\tesi, [esp+window]\n-\tmov\tedi, [esp+scan]\n-\tadd\tesi, ecx\n-\tmov\teax, [esp+scanalign]\n-\tmov\tedx, -MAX_MATCH_8\n-\tlea\tedi, [edi+eax+MAX_MATCH_8]\n-\tlea\tesi, [esi+eax+MAX_MATCH_8]\n-\n-;/* Test the strings for equality, 8 bytes at a time. At the end,\n-; * adjust %edx so that it is offset to the exact byte that mismatched.\n-; *\n-; * We already know at this point that the first three bytes of the\n-; * strings match each other, and they can be safely passed over before\n-; * starting the compare loop. So what this code does is skip over 0-3\n-; * bytes, as much as necessary in order to dword-align the %edi\n-; * pointer. (%esi will still be misaligned three times out of four.)\n-; *\n-; * It should be confessed that this loop usually does not represent\n-; * much of the total running time. Replacing it with a more\n-; * straightforward \"rep cmpsb\" would not drastically degrade\n-; * performance.\n-; */\n-\n-LoopCmps:\n-\tmov\teax, DWORD PTR[esi+edx]\n-\txor\teax, DWORD PTR[edi+edx]\n-\tjnz\tSHORT LeaveLoopCmps\n-\n-\tmov\teax, DWORD PTR[esi+edx+4]\n-\txor\teax, DWORD PTR[edi+edx+4]\n-\tjnz\tSHORT LeaveLoopCmps4\n-\n-\tadd\tedx, 8\n-\tjnz\tSHORT LoopCmps\n-\tjmp\tLenMaximum\n-\tALIGN\t4\n-\n-LeaveLoopCmps4:\n-\tadd\tedx, 4\n-\n-LeaveLoopCmps:\n-\ttest\teax, 00000FFFFH\n-\tjnz\tSHORT LenLower\n-\n-\tadd\tedx, 2\n-\tshr\teax, 16\n-\n-LenLower:\n-\tsub\tal, 1\n-\tadc\tedx, 0\n-\n-;/* Calculate the length of the match. If it is longer than MAX_MATCH,  */\n-;/* then automatically accept it as the best possible match and leave.  */\n-\n-\tlea\teax, [edi+edx]\n-\tmov\tedi, [esp+scan]\n-\tsub\teax, edi\n-\tcmp\teax, MAX_MATCH\n-\tjge\tSHORT LenMaximum\n-\n-;/* If the length of the match is not longer than the best match we     */\n-;/* have so far, then forget it and return to the lookup loop.          */\n-\n-\tmov\tedx, [esp+deflatestate]\n-\tmov\tebx, [esp+bestlen]\n-\tcmp\teax, ebx\n-\tjg\tSHORT LongerMatch\n-\tmov\tesi, [esp+windowbestlen]\n-\tmov\tedi, [edx].ds_prev\n-\tmov\tebx, [esp+scanend]\n-\tmov\tedx, [esp+chainlenwmask]\n-\tjmp\tLookupLoop\n-\tALIGN\t4\n-\n-;/*         s->match_start = cur_match;                                 */\n-;/*         best_len = len;                                             */\n-;/*         if (len >= nice_match) break;                               */\n-;/*         scan_end = *(ushf*)(scan+best_len-1);                       */\n-\n-LongerMatch:\n-\tmov\tebx, [esp+nicematch]\n-\tmov\t[esp+bestlen], eax\n-\tmov\t[edx].ds_match_start, ecx\n-\tcmp\teax, ebx\n-\tjge\tSHORT LeaveNow\n-\tmov\tesi, [esp+window]\n-\tadd\tesi, eax\n-\tmov\t[esp+windowbestlen], esi\n-\tmovzx\tebx, WORD PTR[edi+eax-1]\n-\tmov\tedi, [edx].ds_prev\n-\tmov\t[esp+scanend], ebx\n-\tmov\tedx, [esp+chainlenwmask]\n-\tjmp\tLookupLoop\n-\tALIGN\t4\n-\n-;/* Accept the current string, with the maximum possible length.        */\n-\n-LenMaximum:\n-\tmov\tedx, [esp+deflatestate]\n-\tmov\tDWORD PTR[esp+bestlen], MAX_MATCH\n-\tmov\t[edx].ds_match_start, ecx\n-\n-;/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;          */\n-;/* return s->lookahead;                                                */\n-\n-LeaveNow:\n-\tmov\tedx, [esp+deflatestate]\n-\tmov\tebx, [esp+bestlen]\n-\tmov\teax, [edx].ds_lookahead\n-\tcmp\tebx, eax\n-\tjg\tSHORT LookaheadRet\n-\tmov\teax, ebx\n-LookaheadRet:\n-\n-; Restore the stack and return from whence we came.\n-\n-\tadd\tesp, varsize\n-\tpop\tebx\n-\tpop\tesi\n-\tpop\tedi\n-\tpop\tebp\n-\tret\n-\n-_longest_match\tENDP\n-\n-_TEXT\tENDS\n-END\n+\r\n+; match.asm -- Pentium-Pro optimized version of longest_match()\r\n+;\r\n+; Updated for zlib 1.1.3 and converted to MASM 6.1x\r\n+; Copyright (C) 2000 Dan Higdon <hdan@kinesoft.com>\r\n+;                    and Chuck Walbourn <chuckw@kinesoft.com>\r\n+; Corrections by Cosmin Truta <cosmint@cs.ubbcluj.ro>\r\n+;\r\n+; This is free software; you can redistribute it and/or modify it\r\n+; under the terms of the GNU General Public License.\r\n+\r\n+; Based on match.S\r\n+; Written for zlib 1.1.2\r\n+; Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>\r\n+;\r\n+; Modified by Gilles Vollant (2005) for add gzhead and gzindex\r\n+\r\n+\t.686P\r\n+\t.MODEL\tFLAT\r\n+\r\n+;===========================================================================\r\n+; EQUATES\r\n+;===========================================================================\r\n+\r\n+MAX_MATCH\tEQU 258\r\n+MIN_MATCH\tEQU 3\r\n+MIN_LOOKAHEAD\tEQU (MAX_MATCH + MIN_MATCH + 1)\r\n+MAX_MATCH_8\tEQU ((MAX_MATCH + 7) AND (NOT 7))\r\n+\r\n+;===========================================================================\r\n+; STRUCTURES\r\n+;===========================================================================\r\n+\r\n+; This STRUCT assumes a 4-byte alignment\r\n+\r\n+DEFLATE_STATE\tSTRUCT\r\n+ds_strm\t\t\tdd ?\r\n+ds_status\t\tdd ?\r\n+ds_pending_buf\t\tdd ?\r\n+ds_pending_buf_size\tdd ?\r\n+ds_pending_out\t\tdd ?\r\n+ds_pending\t\tdd ?\r\n+ds_wrap\t\t\tdd ?\r\n+; gzhead and gzindex are added in zlib 1.2.2.2 (see deflate.h)\r\n+ds_gzhead               dd ?\r\n+ds_gzindex              dd ?\r\n+ds_data_type\t\tdb ?\r\n+ds_method\t\tdb ?\r\n+\t\t\tdb ?\t; padding\r\n+\t\t\tdb ?\t; padding\r\n+ds_last_flush\t\tdd ?\r\n+ds_w_size\t\tdd ?\t; used\r\n+ds_w_bits\t\tdd ?\r\n+ds_w_mask\t\tdd ?\t; used\r\n+ds_window\t\tdd ?\t; used\r\n+ds_window_size\t\tdd ?\r\n+ds_prev\t\t\tdd ?\t; used\r\n+ds_head\t\t\tdd ?\r\n+ds_ins_h\t\tdd ?\r\n+ds_hash_size\t\tdd ?\r\n+ds_hash_bits\t\tdd ?\r\n+ds_hash_mask\t\tdd ?\r\n+ds_hash_shift\t\tdd ?\r\n+ds_block_start\t\tdd ?\r\n+ds_match_length\t\tdd ?\t; used\r\n+ds_prev_match\t\tdd ?\t; used\r\n+ds_match_available\tdd ?\r\n+ds_strstart\t\tdd ?\t; used\r\n+ds_match_start\t\tdd ?\t; used\r\n+ds_lookahead\t\tdd ?\t; used\r\n+ds_prev_length\t\tdd ?\t; used\r\n+ds_max_chain_length\tdd ?\t; used\r\n+ds_max_laxy_match\tdd ?\r\n+ds_level\t\tdd ?\r\n+ds_strategy\t\tdd ?\r\n+ds_good_match\t\tdd ?\t; used\r\n+ds_nice_match\t\tdd ?\t; used\r\n+\r\n+; Don't need anymore of the struct for match\r\n+DEFLATE_STATE\tENDS\r\n+\r\n+;===========================================================================\r\n+; CODE\r\n+;===========================================================================\r\n+_TEXT\tSEGMENT\r\n+\r\n+;---------------------------------------------------------------------------\r\n+; match_init\r\n+;---------------------------------------------------------------------------\r\n+\tALIGN\t4\r\n+PUBLIC\t_match_init\r\n+_match_init\tPROC\r\n+\t; no initialization needed\r\n+\tret\r\n+_match_init\tENDP\r\n+\r\n+;---------------------------------------------------------------------------\r\n+; uInt longest_match(deflate_state *deflatestate, IPos curmatch)\r\n+;---------------------------------------------------------------------------\r\n+\tALIGN\t4\r\n+\r\n+PUBLIC\t_longest_match\r\n+_longest_match\tPROC\r\n+\r\n+; Since this code uses EBP for a scratch register, the stack frame must\r\n+; be manually constructed and referenced relative to the ESP register.\r\n+\r\n+; Stack image\r\n+; Variables\r\n+chainlenwmask\t=  0\t; high word: current chain len\r\n+\t\t\t; low word: s->wmask\r\n+window\t\t=  4\t; local copy of s->window\r\n+windowbestlen\t=  8\t; s->window + bestlen\r\n+scanend\t\t= 12\t; last two bytes of string\r\n+scanstart\t= 16\t; first two bytes of string\r\n+scanalign\t= 20\t; dword-misalignment of string\r\n+nicematch\t= 24\t; a good enough match size\r\n+bestlen\t\t= 28\t; size of best match so far\r\n+scan\t\t= 32\t; ptr to string wanting match\r\n+varsize\t\t= 36\t; number of bytes (also offset to last saved register)\r\n+\r\n+; Saved Registers (actually pushed into place)\r\n+ebx_save\t= 36\r\n+edi_save\t= 40\r\n+esi_save\t= 44\r\n+ebp_save\t= 48\r\n+\r\n+; Parameters\r\n+retaddr\t\t= 52\r\n+deflatestate\t= 56\r\n+curmatch\t= 60\r\n+\r\n+; Save registers that the compiler may be using\r\n+\tpush\tebp\r\n+\tpush\tedi\r\n+\tpush\tesi\r\n+\tpush\tebx\r\n+\r\n+; Allocate local variable space\r\n+\tsub\tesp,varsize\r\n+\r\n+; Retrieve the function arguments. ecx will hold cur_match\r\n+; throughout the entire function. edx will hold the pointer to the\r\n+; deflate_state structure during the function's setup (before\r\n+; entering the main loop).\r\n+\r\n+\tmov\tedx, [esp+deflatestate]\r\n+ASSUME\tedx:PTR DEFLATE_STATE\r\n+\r\n+\tmov\tecx, [esp+curmatch]\r\n+\r\n+; uInt wmask = s->w_mask;\r\n+; unsigned chain_length = s->max_chain_length;\r\n+; if (s->prev_length >= s->good_match) {\r\n+;     chain_length >>= 2;\r\n+; }\r\n+\r\n+\tmov\teax, [edx].ds_prev_length\r\n+\tmov\tebx, [edx].ds_good_match\r\n+\tcmp\teax, ebx\r\n+\tmov\teax, [edx].ds_w_mask\r\n+\tmov\tebx, [edx].ds_max_chain_length\r\n+\tjl\tSHORT LastMatchGood\r\n+\tshr\tebx, 2\r\n+LastMatchGood:\r\n+\r\n+; chainlen is decremented once beforehand so that the function can\r\n+; use the sign flag instead of the zero flag for the exit test.\r\n+; It is then shifted into the high word, to make room for the wmask\r\n+; value, which it will always accompany.\r\n+\r\n+\tdec\tebx\r\n+\tshl\tebx, 16\r\n+\tor\tebx, eax\r\n+\tmov\t[esp+chainlenwmask], ebx\r\n+\r\n+; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\r\n+\r\n+\tmov\teax, [edx].ds_nice_match\r\n+\tmov\tebx, [edx].ds_lookahead\r\n+\tcmp\tebx, eax\r\n+\tjl\tSHORT LookaheadLess\r\n+\tmov\tebx, eax\r\n+LookaheadLess:\r\n+\tmov\t[esp+nicematch], ebx\r\n+\r\n+;/* register Bytef *scan = s->window + s->strstart;                     */\r\n+\r\n+\tmov\tesi, [edx].ds_window\r\n+\tmov\t[esp+window], esi\r\n+\tmov\tebp, [edx].ds_strstart\r\n+\tlea\tedi, [esi+ebp]\r\n+\tmov\t[esp+scan],edi\r\n+\r\n+;/* Determine how many bytes the scan ptr is off from being             */\r\n+;/* dword-aligned.                                                      */\r\n+\r\n+\tmov\teax, edi\r\n+\tneg\teax\r\n+\tand\teax, 3\r\n+\tmov\t[esp+scanalign], eax\r\n+\r\n+;/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?                      */\r\n+;/*     s->strstart - (IPos)MAX_DIST(s) : NIL;                          */\r\n+\r\n+\tmov\teax, [edx].ds_w_size\r\n+\tsub\teax, MIN_LOOKAHEAD\r\n+\tsub\tebp, eax\r\n+\tjg\tSHORT LimitPositive\r\n+\txor\tebp, ebp\r\n+LimitPositive:\r\n+\r\n+;/* int best_len = s->prev_length;                                      */\r\n+\r\n+\tmov\teax, [edx].ds_prev_length\r\n+\tmov\t[esp+bestlen], eax\r\n+\r\n+;/* Store the sum of s->window + best_len in %esi locally, and in %esi. */\r\n+\r\n+\tadd\tesi, eax\r\n+\tmov\t[esp+windowbestlen], esi\r\n+\r\n+;/* register ush scan_start = *(ushf*)scan;                             */\r\n+;/* register ush scan_end   = *(ushf*)(scan+best_len-1);                */\r\n+;/* Posf *prev = s->prev;                                               */\r\n+\r\n+\tmovzx\tebx, WORD PTR[edi]\r\n+\tmov\t[esp+scanstart], ebx\r\n+\tmovzx\tebx, WORD PTR[eax+edi-1]\r\n+\tmov\t[esp+scanend], ebx\r\n+\tmov\tedi, [edx].ds_prev\r\n+\r\n+;/* Jump into the main loop.                                            */\r\n+\r\n+\tmov\tedx, [esp+chainlenwmask]\r\n+\tjmp\tSHORT LoopEntry\r\n+\r\n+;/* do {\r\n+; *     match = s->window + cur_match;\r\n+; *     if (*(ushf*)(match+best_len-1) != scan_end ||\r\n+; *         *(ushf*)match != scan_start) continue;\r\n+; *     [...]\r\n+; * } while ((cur_match = prev[cur_match & wmask]) > limit\r\n+; *          && --chain_length != 0);\r\n+; *\r\n+; * Here is the inner loop of the function. The function will spend the\r\n+; * majority of its time in this loop, and majority of that time will\r\n+; * be spent in the first ten instructions.\r\n+; *\r\n+; * Within this loop:\r\n+; * %ebx = scanend\r\n+; * %ecx = curmatch\r\n+; * %edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)\r\n+; * %esi = windowbestlen - i.e., (window + bestlen)\r\n+; * %edi = prev\r\n+; * %ebp = limit\r\n+; */\r\n+\r\n+\tALIGN\t4\r\n+LookupLoop:\r\n+\tand\tecx, edx\r\n+\tmovzx\tecx, WORD PTR[edi+ecx*2]\r\n+\tcmp\tecx, ebp\r\n+\tjbe\tLeaveNow\r\n+\tsub\tedx, 000010000H\r\n+\tjs\tLeaveNow\r\n+\r\n+LoopEntry:\r\n+\tmovzx\teax, WORD PTR[esi+ecx-1]\r\n+\tcmp\teax, ebx\r\n+\tjnz\tSHORT LookupLoop\r\n+\r\n+\tmov\teax, [esp+window]\r\n+\tmovzx\teax, WORD PTR[eax+ecx]\r\n+\tcmp\teax, [esp+scanstart]\r\n+\tjnz\tSHORT LookupLoop\r\n+\r\n+;/* Store the current value of chainlen.                                */\r\n+\r\n+\tmov\t[esp+chainlenwmask], edx\r\n+\r\n+;/* Point %edi to the string under scrutiny, and %esi to the string we  */\r\n+;/* are hoping to match it up with. In actuality, %esi and %edi are     */\r\n+;/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is     */\r\n+;/* initialized to -(MAX_MATCH_8 - scanalign).                          */\r\n+\r\n+\tmov\tesi, [esp+window]\r\n+\tmov\tedi, [esp+scan]\r\n+\tadd\tesi, ecx\r\n+\tmov\teax, [esp+scanalign]\r\n+\tmov\tedx, -MAX_MATCH_8\r\n+\tlea\tedi, [edi+eax+MAX_MATCH_8]\r\n+\tlea\tesi, [esi+eax+MAX_MATCH_8]\r\n+\r\n+;/* Test the strings for equality, 8 bytes at a time. At the end,\r\n+; * adjust %edx so that it is offset to the exact byte that mismatched.\r\n+; *\r\n+; * We already know at this point that the first three bytes of the\r\n+; * strings match each other, and they can be safely passed over before\r\n+; * starting the compare loop. So what this code does is skip over 0-3\r\n+; * bytes, as much as necessary in order to dword-align the %edi\r\n+; * pointer. (%esi will still be misaligned three times out of four.)\r\n+; *\r\n+; * It should be confessed that this loop usually does not represent\r\n+; * much of the total running time. Replacing it with a more\r\n+; * straightforward \"rep cmpsb\" would not drastically degrade\r\n+; * performance.\r\n+; */\r\n+\r\n+LoopCmps:\r\n+\tmov\teax, DWORD PTR[esi+edx]\r\n+\txor\teax, DWORD PTR[edi+edx]\r\n+\tjnz\tSHORT LeaveLoopCmps\r\n+\r\n+\tmov\teax, DWORD PTR[esi+edx+4]\r\n+\txor\teax, DWORD PTR[edi+edx+4]\r\n+\tjnz\tSHORT LeaveLoopCmps4\r\n+\r\n+\tadd\tedx, 8\r\n+\tjnz\tSHORT LoopCmps\r\n+\tjmp\tLenMaximum\r\n+\tALIGN\t4\r\n+\r\n+LeaveLoopCmps4:\r\n+\tadd\tedx, 4\r\n+\r\n+LeaveLoopCmps:\r\n+\ttest\teax, 00000FFFFH\r\n+\tjnz\tSHORT LenLower\r\n+\r\n+\tadd\tedx, 2\r\n+\tshr\teax, 16\r\n+\r\n+LenLower:\r\n+\tsub\tal, 1\r\n+\tadc\tedx, 0\r\n+\r\n+;/* Calculate the length of the match. If it is longer than MAX_MATCH,  */\r\n+;/* then automatically accept it as the best possible match and leave.  */\r\n+\r\n+\tlea\teax, [edi+edx]\r\n+\tmov\tedi, [esp+scan]\r\n+\tsub\teax, edi\r\n+\tcmp\teax, MAX_MATCH\r\n+\tjge\tSHORT LenMaximum\r\n+\r\n+;/* If the length of the match is not longer than the best match we     */\r\n+;/* have so far, then forget it and return to the lookup loop.          */\r\n+\r\n+\tmov\tedx, [esp+deflatestate]\r\n+\tmov\tebx, [esp+bestlen]\r\n+\tcmp\teax, ebx\r\n+\tjg\tSHORT LongerMatch\r\n+\tmov\tesi, [esp+windowbestlen]\r\n+\tmov\tedi, [edx].ds_prev\r\n+\tmov\tebx, [esp+scanend]\r\n+\tmov\tedx, [esp+chainlenwmask]\r\n+\tjmp\tLookupLoop\r\n+\tALIGN\t4\r\n+\r\n+;/*         s->match_start = cur_match;                                 */\r\n+;/*         best_len = len;                                             */\r\n+;/*         if (len >= nice_match) break;                               */\r\n+;/*         scan_end = *(ushf*)(scan+best_len-1);                       */\r\n+\r\n+LongerMatch:\r\n+\tmov\tebx, [esp+nicematch]\r\n+\tmov\t[esp+bestlen], eax\r\n+\tmov\t[edx].ds_match_start, ecx\r\n+\tcmp\teax, ebx\r\n+\tjge\tSHORT LeaveNow\r\n+\tmov\tesi, [esp+window]\r\n+\tadd\tesi, eax\r\n+\tmov\t[esp+windowbestlen], esi\r\n+\tmovzx\tebx, WORD PTR[edi+eax-1]\r\n+\tmov\tedi, [edx].ds_prev\r\n+\tmov\t[esp+scanend], ebx\r\n+\tmov\tedx, [esp+chainlenwmask]\r\n+\tjmp\tLookupLoop\r\n+\tALIGN\t4\r\n+\r\n+;/* Accept the current string, with the maximum possible length.        */\r\n+\r\n+LenMaximum:\r\n+\tmov\tedx, [esp+deflatestate]\r\n+\tmov\tDWORD PTR[esp+bestlen], MAX_MATCH\r\n+\tmov\t[edx].ds_match_start, ecx\r\n+\r\n+;/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;          */\r\n+;/* return s->lookahead;                                                */\r\n+\r\n+LeaveNow:\r\n+\tmov\tedx, [esp+deflatestate]\r\n+\tmov\tebx, [esp+bestlen]\r\n+\tmov\teax, [edx].ds_lookahead\r\n+\tcmp\tebx, eax\r\n+\tjg\tSHORT LookaheadRet\r\n+\tmov\teax, ebx\r\n+LookaheadRet:\r\n+\r\n+; Restore the stack and return from whence we came.\r\n+\r\n+\tadd\tesp, varsize\r\n+\tpop\tebx\r\n+\tpop\tesi\r\n+\tpop\tedi\r\n+\tpop\tebp\r\n+\tret\r\n+\r\n+_longest_match\tENDP\r\n+\r\n+_TEXT\tENDS\r\n+END\r"}, {"sha": "874bb2d482beb9794956cb376190be1b7a29bc42", "filename": "zlib/contrib/masmx86/gvmat32.asm", "status": "modified", "additions": 972, "deletions": 905, "changes": 1877, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32.asm?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,905 +1,972 @@\n-;\n-; gvmat32.asm -- Asm portion of the optimized longest_match for 32 bits x86\n-; Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.\n-; File written by Gilles Vollant, by modifiying the longest_match\n-;  from Jean-loup Gailly in deflate.c\n-; It need wmask == 0x7fff\n-;     (assembly code is faster with a fixed wmask)\n-;\n-; For Visual C++ 4.2 and ML 6.11c (version in directory \\MASM611C of Win95 DDK)\n-;   I compile with : \"ml /coff /Zi /c gvmat32.asm\"\n-;\n-\n-;uInt longest_match_7fff(s, cur_match)\n-;    deflate_state *s;\n-;    IPos cur_match;                             /* current match */\n-\n-\tNbStack         equ     76\n-\tcur_match       equ     dword ptr[esp+NbStack-0]\n-\tstr_s           equ     dword ptr[esp+NbStack-4]\n-; 5 dword on top (ret,ebp,esi,edi,ebx)\n-\tadrret          equ     dword ptr[esp+NbStack-8]\n-\tpushebp         equ     dword ptr[esp+NbStack-12]\n-\tpushedi         equ     dword ptr[esp+NbStack-16]\n-\tpushesi         equ     dword ptr[esp+NbStack-20]\n-\tpushebx         equ     dword ptr[esp+NbStack-24]\n-\n-\tchain_length    equ     dword ptr [esp+NbStack-28]\n-\tlimit           equ     dword ptr [esp+NbStack-32]\n-\tbest_len        equ     dword ptr [esp+NbStack-36]\n-\twindow          equ     dword ptr [esp+NbStack-40]\n-\tprev            equ     dword ptr [esp+NbStack-44]\n-\tscan_start      equ      word ptr [esp+NbStack-48]\n-\twmask           equ     dword ptr [esp+NbStack-52]\n-\tmatch_start_ptr equ     dword ptr [esp+NbStack-56]\n-\tnice_match      equ     dword ptr [esp+NbStack-60]\n-\tscan            equ     dword ptr [esp+NbStack-64]\n-\n-\twindowlen       equ     dword ptr [esp+NbStack-68]\n-\tmatch_start     equ     dword ptr [esp+NbStack-72]\n-\tstrend          equ     dword ptr [esp+NbStack-76]\n-\tNbStackAdd      equ     (NbStack-24)\n-\n-    .386p\n-\n-    name    gvmatch\n-    .MODEL  FLAT\n-\n-\n-\n-;  all the +4 offsets are due to the addition of pending_buf_size (in zlib\n-;  in the deflate_state structure since the asm code was first written\n-;  (if you compile with zlib 1.0.4 or older, remove the +4).\n-;  Note : these value are good with a 8 bytes boundary pack structure\n-    dep_chain_length    equ     70h+4\n-    dep_window          equ     2ch+4\n-    dep_strstart        equ     60h+4\n-    dep_prev_length     equ     6ch+4\n-    dep_nice_match      equ     84h+4\n-    dep_w_size          equ     20h+4\n-    dep_prev            equ     34h+4\n-    dep_w_mask          equ     28h+4\n-    dep_good_match      equ     80h+4\n-    dep_match_start     equ     64h+4\n-    dep_lookahead       equ     68h+4\n-\n-\n-_TEXT                   segment\n-\n-IFDEF NOUNDERLINE\n-\t\t\tpublic  longest_match_7fff\n-\t\t\tpublic  longest_match_686\n-;                        public  match_init\n-ELSE\n-\t\t\tpublic  _longest_match_7fff\n-\t\t\tpublic  _longest_match_686\n-;                        public  _match_init\n-ENDIF\n-\n-    MAX_MATCH           equ     258\n-    MIN_MATCH           equ     3\n-    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)\n-\n-\n-\n-IFDEF NOUNDERLINE\n-;match_init      proc near\n-;                ret\n-;match_init      endp\n-ELSE\n-;_match_init     proc near\n-;                ret\n-;_match_init     endp\n-ENDIF\n-\n-\n-IFDEF NOUNDERLINE\n-longest_match_7fff   proc near\n-ELSE\n-_longest_match_7fff  proc near\n-ENDIF\n-\n-\tmov     edx,[esp+4]\n-\n-\n-\n-\tpush    ebp\n-\tpush    edi\n-\tpush    esi\n-\tpush    ebx\n-\n-\tsub     esp,NbStackAdd\n-\n-; initialize or check the variables used in match.asm.\n-\tmov     ebp,edx\n-\n-; chain_length = s->max_chain_length\n-; if (prev_length>=good_match) chain_length >>= 2\n-\tmov     edx,[ebp+dep_chain_length]\n-\tmov     ebx,[ebp+dep_prev_length]\n-\tcmp     [ebp+dep_good_match],ebx\n-\tja      noshr\n-\tshr     edx,2\n-noshr:\n-; we increment chain_length because in the asm, the --chain_lenght is in the beginning of the loop\n-\tinc     edx\n-\tmov     edi,[ebp+dep_nice_match]\n-\tmov     chain_length,edx\n-\tmov     eax,[ebp+dep_lookahead]\n-\tcmp     eax,edi\n-; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n-\tjae     nolookaheadnicematch\n-\tmov     edi,eax\n-nolookaheadnicematch:\n-; best_len = s->prev_length\n-\tmov     best_len,ebx\n-\n-; window = s->window\n-\tmov     esi,[ebp+dep_window]\n-\tmov     ecx,[ebp+dep_strstart]\n-\tmov     window,esi\n-\n-\tmov     nice_match,edi\n-; scan = window + strstart\n-\tadd     esi,ecx\n-\tmov     scan,esi\n-; dx = *window\n-\tmov     dx,word ptr [esi]\n-; bx = *(window+best_len-1)\n-\tmov     bx,word ptr [esi+ebx-1]\n-\tadd     esi,MAX_MATCH-1\n-; scan_start = *scan\n-\tmov     scan_start,dx\n-; strend = scan + MAX_MATCH-1\n-\tmov     strend,esi\n-; bx = scan_end = *(window+best_len-1)\n-\n-;    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n-;        s->strstart - (IPos)MAX_DIST(s) : NIL;\n-\n-\tmov     esi,[ebp+dep_w_size]\n-\tsub     esi,MIN_LOOKAHEAD\n-; here esi = MAX_DIST(s)\n-\tsub     ecx,esi\n-\tja      nodist\n-\txor     ecx,ecx\n-nodist:\n-\tmov     limit,ecx\n-\n-; prev = s->prev\n-\tmov     edx,[ebp+dep_prev]\n-\tmov     prev,edx\n-\n-;\n-\tmov     edx,dword ptr [ebp+dep_match_start]\n-\tmov     bp,scan_start\n-\tmov     eax,cur_match\n-\tmov     match_start,edx\n-\n-\tmov     edx,window\n-\tmov     edi,edx\n-\tadd     edi,best_len\n-\tmov     esi,prev\n-\tdec     edi\n-; windowlen = window + best_len -1\n-\tmov     windowlen,edi\n-\n-\tjmp     beginloop2\n-\talign   4\n-\n-; here, in the loop\n-;       eax = ax = cur_match\n-;       ecx = limit\n-;        bx = scan_end\n-;        bp = scan_start\n-;       edi = windowlen (window + best_len -1)\n-;       esi = prev\n-\n-\n-;// here; chain_length <=16\n-normalbeg0add16:\n-\tadd     chain_length,16\n-\tjz      exitloop\n-normalbeg0:\n-\tcmp     word ptr[edi+eax],bx\n-\tje      normalbeg2noroll\n-rcontlabnoroll:\n-; cur_match = prev[cur_match & wmask]\n-\tand     eax,7fffh\n-\tmov     ax,word ptr[esi+eax*2]\n-; if cur_match > limit, go to exitloop\n-\tcmp     ecx,eax\n-\tjnb     exitloop\n-; if --chain_length != 0, go to exitloop\n-\tdec     chain_length\n-\tjnz     normalbeg0\n-\tjmp     exitloop\n-\n-normalbeg2noroll:\n-; if (scan_start==*(cur_match+window)) goto normalbeg2\n-\tcmp     bp,word ptr[edx+eax]\n-\tjne     rcontlabnoroll\n-\tjmp     normalbeg2\n-\n-contloop3:\n-\tmov     edi,windowlen\n-\n-; cur_match = prev[cur_match & wmask]\n-\tand     eax,7fffh\n-\tmov     ax,word ptr[esi+eax*2]\n-; if cur_match > limit, go to exitloop\n-\tcmp     ecx,eax\n-jnbexitloopshort1:\n-\tjnb     exitloop\n-; if --chain_length != 0, go to exitloop\n-\n-\n-; begin the main loop\n-beginloop2:\n-\tsub     chain_length,16+1\n-; if chain_length <=16, don't use the unrolled loop\n-\tjna     normalbeg0add16\n-\n-do16:\n-\tcmp     word ptr[edi+eax],bx\n-\tje      normalbeg2dc0\n-\n-maccn   MACRO   lab\n-\tand     eax,7fffh\n-\tmov     ax,word ptr[esi+eax*2]\n-\tcmp     ecx,eax\n-\tjnb     exitloop\n-\tcmp     word ptr[edi+eax],bx\n-\tje      lab\n-\tENDM\n-\n-rcontloop0:\n-\tmaccn   normalbeg2dc1\n-\n-rcontloop1:\n-\tmaccn   normalbeg2dc2\n-\n-rcontloop2:\n-\tmaccn   normalbeg2dc3\n-\n-rcontloop3:\n-\tmaccn   normalbeg2dc4\n-\n-rcontloop4:\n-\tmaccn   normalbeg2dc5\n-\n-rcontloop5:\n-\tmaccn   normalbeg2dc6\n-\n-rcontloop6:\n-\tmaccn   normalbeg2dc7\n-\n-rcontloop7:\n-\tmaccn   normalbeg2dc8\n-\n-rcontloop8:\n-\tmaccn   normalbeg2dc9\n-\n-rcontloop9:\n-\tmaccn   normalbeg2dc10\n-\n-rcontloop10:\n-\tmaccn   short normalbeg2dc11\n-\n-rcontloop11:\n-\tmaccn   short normalbeg2dc12\n-\n-rcontloop12:\n-\tmaccn   short normalbeg2dc13\n-\n-rcontloop13:\n-\tmaccn   short normalbeg2dc14\n-\n-rcontloop14:\n-\tmaccn   short normalbeg2dc15\n-\n-rcontloop15:\n-\tand     eax,7fffh\n-\tmov     ax,word ptr[esi+eax*2]\n-\tcmp     ecx,eax\n-\tjnb     exitloop\n-\n-\tsub     chain_length,16\n-\tja      do16\n-\tjmp     normalbeg0add16\n-\n-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n-\n-normbeg MACRO   rcontlab,valsub\n-; if we are here, we know that *(match+best_len-1) == scan_end\n-\tcmp     bp,word ptr[edx+eax]\n-; if (match != scan_start) goto rcontlab\n-\tjne     rcontlab\n-; calculate the good chain_length, and we'll compare scan and match string\n-\tadd     chain_length,16-valsub\n-\tjmp     iseq\n-\tENDM\n-\n-\n-normalbeg2dc11:\n-\tnormbeg rcontloop11,11\n-\n-normalbeg2dc12:\n-\tnormbeg short rcontloop12,12\n-\n-normalbeg2dc13:\n-\tnormbeg short rcontloop13,13\n-\n-normalbeg2dc14:\n-\tnormbeg short rcontloop14,14\n-\n-normalbeg2dc15:\n-\tnormbeg short rcontloop15,15\n-\n-normalbeg2dc10:\n-\tnormbeg rcontloop10,10\n-\n-normalbeg2dc9:\n-\tnormbeg rcontloop9,9\n-\n-normalbeg2dc8:\n-\tnormbeg rcontloop8,8\n-\n-normalbeg2dc7:\n-\tnormbeg rcontloop7,7\n-\n-normalbeg2dc6:\n-\tnormbeg rcontloop6,6\n-\n-normalbeg2dc5:\n-\tnormbeg rcontloop5,5\n-\n-normalbeg2dc4:\n-\tnormbeg rcontloop4,4\n-\n-normalbeg2dc3:\n-\tnormbeg rcontloop3,3\n-\n-normalbeg2dc2:\n-\tnormbeg rcontloop2,2\n-\n-normalbeg2dc1:\n-\tnormbeg rcontloop1,1\n-\n-normalbeg2dc0:\n-\tnormbeg rcontloop0,0\n-\n-\n-; we go in normalbeg2 because *(ushf*)(match+best_len-1) == scan_end\n-\n-normalbeg2:\n-\tmov     edi,window\n-\n-\tcmp     bp,word ptr[edi+eax]\n-\tjne     contloop3                   ; if *(ushf*)match != scan_start, continue\n-\n-iseq:\n-; if we are here, we know that *(match+best_len-1) == scan_end\n-; and (match == scan_start)\n-\n-\tmov     edi,edx\n-\tmov     esi,scan                    ; esi = scan\n-\tadd     edi,eax                     ; edi = window + cur_match = match\n-\n-\tmov     edx,[esi+3]                 ; compare manually dword at match+3\n-\txor     edx,[edi+3]                 ; and scan +3\n-\n-\tjz      begincompare                ; if equal, go to long compare\n-\n-; we will determine the unmatch byte and calculate len (in esi)\n-\tor      dl,dl\n-\tje      eq1rr\n-\tmov     esi,3\n-\tjmp     trfinval\n-eq1rr:\n-\tor      dx,dx\n-\tje      eq1\n-\n-\tmov     esi,4\n-\tjmp     trfinval\n-eq1:\n-\tand     edx,0ffffffh\n-\tjz      eq11\n-\tmov     esi,5\n-\tjmp     trfinval\n-eq11:\n-\tmov     esi,6\n-\tjmp     trfinval\n-\n-begincompare:\n-\t; here we now scan and match begin same\n-\tadd     edi,6\n-\tadd     esi,6\n-\tmov     ecx,(MAX_MATCH-(2+4))/4     ; scan for at most MAX_MATCH bytes\n-\trepe    cmpsd                       ; loop until mismatch\n-\n-\tje      trfin                       ; go to trfin if not unmatch\n-; we determine the unmatch byte\n-\tsub     esi,4\n-\tmov     edx,[edi-4]\n-\txor     edx,[esi]\n-\n-\tor      dl,dl\n-\tjnz     trfin\n-\tinc     esi\n-\n-\tor      dx,dx\n-\tjnz     trfin\n-\tinc     esi\n-\n-\tand     edx,0ffffffh\n-\tjnz     trfin\n-\tinc     esi\n-\n-trfin:\n-\tsub     esi,scan          ; esi = len\n-trfinval:\n-; here we have finised compare, and esi contain len of equal string\n-\tcmp     esi,best_len        ; if len > best_len, go newbestlen\n-\tja      short newbestlen\n-; now we restore edx, ecx and esi, for the big loop\n-\tmov     esi,prev\n-\tmov     ecx,limit\n-\tmov     edx,window\n-\tjmp     contloop3\n-\n-newbestlen:\n-\tmov     best_len,esi        ; len become best_len\n-\n-\tmov     match_start,eax     ; save new position as match_start\n-\tcmp     esi,nice_match      ; if best_len >= nice_match, exit\n-\tjae     exitloop\n-\tmov     ecx,scan\n-\tmov     edx,window          ; restore edx=window\n-\tadd     ecx,esi\n-\tadd     esi,edx\n-\n-\tdec     esi\n-\tmov     windowlen,esi       ; windowlen = window + best_len-1\n-\tmov     bx,[ecx-1]          ; bx = *(scan+best_len-1) = scan_end\n-\n-; now we restore ecx and esi, for the big loop :\n-\tmov     esi,prev\n-\tmov     ecx,limit\n-\tjmp     contloop3\n-\n-exitloop:\n-; exit : s->match_start=match_start\n-\tmov     ebx,match_start\n-\tmov     ebp,str_s\n-\tmov     ecx,best_len\n-\tmov     dword ptr [ebp+dep_match_start],ebx\n-\tmov     eax,dword ptr [ebp+dep_lookahead]\n-\tcmp     ecx,eax\n-\tja      minexlo\n-\tmov     eax,ecx\n-minexlo:\n-; return min(best_len,s->lookahead)\n-\n-; restore stack and register ebx,esi,edi,ebp\n-\tadd     esp,NbStackAdd\n-\n-\tpop     ebx\n-\tpop     esi\n-\tpop     edi\n-\tpop     ebp\n-\tret\n-InfoAuthor:\n-; please don't remove this string !\n-; Your are free use gvmat32 in any fre or commercial apps if you don't remove the string in the binary!\n-\tdb     0dh,0ah,\"GVMat32 optimised assembly code written 1996-98 by Gilles Vollant\",0dh,0ah\n-\n-\n-\n-IFDEF NOUNDERLINE\n-longest_match_7fff   endp\n-ELSE\n-_longest_match_7fff  endp\n-ENDIF\n-\n-\n-IFDEF NOUNDERLINE\n-cpudetect32     proc near\n-ELSE\n-_cpudetect32    proc near\n-ENDIF\n-\n-\tpush\tebx\n-\n-\tpushfd                  ; push original EFLAGS\n-\tpop     eax             ; get original EFLAGS\n-\tmov     ecx, eax        ; save original EFLAGS\n-\txor     eax, 40000h     ; flip AC bit in EFLAGS\n-\tpush    eax             ; save new EFLAGS value on stack\n-\tpopfd                   ; replace current EFLAGS value\n-\tpushfd                  ; get new EFLAGS\n-\tpop     eax             ; store new EFLAGS in EAX\n-\txor     eax, ecx        ; can\ufffdt toggle AC bit, processor=80386\n-\tjz      end_cpu_is_386  ; jump if 80386 processor\n-\tpush    ecx\n-\tpopfd                   ; restore AC bit in EFLAGS first\n-\n-\tpushfd\n-\tpushfd\n-\tpop     ecx\n-\n-\tmov     eax, ecx        ; get original EFLAGS\n-\txor     eax, 200000h    ; flip ID bit in EFLAGS\n-\tpush    eax             ; save new EFLAGS value on stack\n-\tpopfd                   ; replace current EFLAGS value\n-\tpushfd                  ; get new EFLAGS\n-\tpop\t\teax\t            ; store new EFLAGS in EAX\n-\tpopfd                   ; restore original EFLAGS\n-\txor\t\teax, ecx        ; can\ufffdt toggle ID bit,\n-\tje\t\tis_old_486\t\t; processor=old\n-\n-\tmov     eax,1\n-\tdb      0fh,0a2h        ;CPUID\n-\n-exitcpudetect:\n-\tpop\tebx\n-\tret\n-\n-end_cpu_is_386:\n-\tmov     eax,0300h\n-\tjmp     exitcpudetect\n-\n-is_old_486:\n-\tmov     eax,0400h\n-\tjmp     exitcpudetect\n-\n-IFDEF NOUNDERLINE\n-cpudetect32     endp\n-ELSE\n-_cpudetect32    endp\n-ENDIF\n-\n-\n-\n-\n-MAX_MATCH       equ     258\n-MIN_MATCH       equ     3\n-MIN_LOOKAHEAD   equ     (MAX_MATCH + MIN_MATCH + 1)\n-MAX_MATCH_8_     equ     ((MAX_MATCH + 7) AND 0FFF0h)\n-\n-\n-;;; stack frame offsets\n-\n-chainlenwmask\tequ  esp + 0\t; high word: current chain len\n-\t\t\t\t\t; low word: s->wmask\n-window\t\tequ  esp + 4\t; local copy of s->window\n-windowbestlen\tequ  esp + 8\t; s->window + bestlen\n-scanstart\tequ  esp + 16\t; first two bytes of string\n-scanend\t\tequ  esp + 12\t; last two bytes of string\n-scanalign\tequ  esp + 20\t; dword-misalignment of string\n-nicematch\tequ  esp + 24\t; a good enough match size\n-bestlen\t\tequ  esp + 28\t; size of best match so far\n-scan\t\tequ  esp + 32\t; ptr to string wanting match\n-\n-LocalVarsSize\tequ 36\n-;\tsaved ebx\tbyte esp + 36\n-;\tsaved edi\tbyte esp + 40\n-;\tsaved esi\tbyte esp + 44\n-;\tsaved ebp\tbyte esp + 48\n-;\treturn address\tbyte esp + 52\n-deflatestate\tequ  esp + 56\t; the function arguments\n-curmatch\tequ  esp + 60\n-\n-;;; Offsets for fields in the deflate_state structure. These numbers\n-;;; are calculated from the definition of deflate_state, with the\n-;;; assumption that the compiler will dword-align the fields. (Thus,\n-;;; changing the definition of deflate_state could easily cause this\n-;;; program to crash horribly, without so much as a warning at\n-;;; compile time. Sigh.)\n-\n-dsWSize\t\tequ 36\n-dsWMask\t\tequ 44\n-dsWindow\tequ 48\n-dsPrev\t\tequ 56\n-dsMatchLen\tequ 88\n-dsPrevMatch\tequ 92\n-dsStrStart\tequ 100\n-dsMatchStart\tequ 104\n-dsLookahead\tequ 108\n-dsPrevLen\tequ 112\n-dsMaxChainLen\tequ 116\n-dsGoodMatch\tequ 132\n-dsNiceMatch\tequ 136\n-\n-\n-;;; match.asm -- Pentium-Pro-optimized version of longest_match()\n-;;; Written for zlib 1.1.2\n-;;; Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>\n-;;; You can look at http://www.muppetlabs.com/~breadbox/software/assembly.html\n-;;;\n-;;; This is free software; you can redistribute it and/or modify it\n-;;; under the terms of the GNU General Public License.\n-\n-;GLOBAL\t_longest_match, _match_init\n-\n-\n-;SECTION\t.text\n-\n-;;; uInt longest_match(deflate_state *deflatestate, IPos curmatch)\n-\n-;_longest_match:\n-IFDEF NOUNDERLINE\n-longest_match_686   proc near\n-ELSE\n-_longest_match_686  proc near\n-ENDIF\n-\n-\n-;;; Save registers that the compiler may be using, and adjust esp to\n-;;; make room for our stack frame.\n-\n-\t\tpush\tebp\n-\t\tpush\tedi\n-\t\tpush\tesi\n-\t\tpush\tebx\n-\t\tsub\tesp, LocalVarsSize\n-\n-;;; Retrieve the function arguments. ecx will hold cur_match\n-;;; throughout the entire function. edx will hold the pointer to the\n-;;; deflate_state structure during the function's setup (before\n-;;; entering the main loop.\n-\n-\t\tmov\tedx, [deflatestate]\n-\t\tmov\tecx, [curmatch]\n-\n-;;; uInt wmask = s->w_mask;\n-;;; unsigned chain_length = s->max_chain_length;\n-;;; if (s->prev_length >= s->good_match) {\n-;;;     chain_length >>= 2;\n-;;; }\n-\n-\t\tmov\teax, [edx + dsPrevLen]\n-\t\tmov\tebx, [edx + dsGoodMatch]\n-\t\tcmp\teax, ebx\n-\t\tmov\teax, [edx + dsWMask]\n-\t\tmov\tebx, [edx + dsMaxChainLen]\n-\t\tjl\tLastMatchGood\n-\t\tshr\tebx, 2\n-LastMatchGood:\n-\n-;;; chainlen is decremented once beforehand so that the function can\n-;;; use the sign flag instead of the zero flag for the exit test.\n-;;; It is then shifted into the high word, to make room for the wmask\n-;;; value, which it will always accompany.\n-\n-\t\tdec\tebx\n-\t\tshl\tebx, 16\n-\t\tor\tebx, eax\n-\t\tmov\t[chainlenwmask], ebx\n-\n-;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n-\n-\t\tmov\teax, [edx + dsNiceMatch]\n-\t\tmov\tebx, [edx + dsLookahead]\n-\t\tcmp\tebx, eax\n-\t\tjl\tLookaheadLess\n-\t\tmov\tebx, eax\n-LookaheadLess:\tmov\t[nicematch], ebx\n-\n-;;; register Bytef *scan = s->window + s->strstart;\n-\n-\t\tmov\tesi, [edx + dsWindow]\n-\t\tmov\t[window], esi\n-\t\tmov\tebp, [edx + dsStrStart]\n-\t\tlea\tedi, [esi + ebp]\n-\t\tmov\t[scan], edi\n-\n-;;; Determine how many bytes the scan ptr is off from being\n-;;; dword-aligned.\n-\n-\t\tmov\teax, edi\n-\t\tneg\teax\n-\t\tand\teax, 3\n-\t\tmov\t[scanalign], eax\n-\n-;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n-;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;\n-\n-\t\tmov\teax, [edx + dsWSize]\n-\t\tsub\teax, MIN_LOOKAHEAD\n-\t\tsub\tebp, eax\n-\t\tjg\tLimitPositive\n-\t\txor\tebp, ebp\n-LimitPositive:\n-\n-;;; int best_len = s->prev_length;\n-\n-\t\tmov\teax, [edx + dsPrevLen]\n-\t\tmov\t[bestlen], eax\n-\n-;;; Store the sum of s->window + best_len in esi locally, and in esi.\n-\n-\t\tadd\tesi, eax\n-\t\tmov\t[windowbestlen], esi\n-\n-;;; register ush scan_start = *(ushf*)scan;\n-;;; register ush scan_end   = *(ushf*)(scan+best_len-1);\n-;;; Posf *prev = s->prev;\n-\n-\t\tmovzx\tebx, word ptr [edi]\n-\t\tmov\t[scanstart], ebx\n-\t\tmovzx\tebx, word ptr [edi + eax - 1]\n-\t\tmov\t[scanend], ebx\n-\t\tmov\tedi, [edx + dsPrev]\n-\n-;;; Jump into the main loop.\n-\n-\t\tmov\tedx, [chainlenwmask]\n-\t\tjmp\tshort LoopEntry\n-\n-align 4\n-\n-;;; do {\n-;;;     match = s->window + cur_match;\n-;;;     if (*(ushf*)(match+best_len-1) != scan_end ||\n-;;;         *(ushf*)match != scan_start) continue;\n-;;;     [...]\n-;;; } while ((cur_match = prev[cur_match & wmask]) > limit\n-;;;          && --chain_length != 0);\n-;;;\n-;;; Here is the inner loop of the function. The function will spend the\n-;;; majority of its time in this loop, and majority of that time will\n-;;; be spent in the first ten instructions.\n-;;;\n-;;; Within this loop:\n-;;; ebx = scanend\n-;;; ecx = curmatch\n-;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)\n-;;; esi = windowbestlen - i.e., (window + bestlen)\n-;;; edi = prev\n-;;; ebp = limit\n-\n-LookupLoop:\n-\t\tand\tecx, edx\n-\t\tmovzx\tecx, word ptr [edi + ecx*2]\n-\t\tcmp\tecx, ebp\n-\t\tjbe\tLeaveNow\n-\t\tsub\tedx, 00010000h\n-\t\tjs\tLeaveNow\n-LoopEntry:\tmovzx\teax, word ptr [esi + ecx - 1]\n-\t\tcmp\teax, ebx\n-\t\tjnz\tLookupLoop\n-\t\tmov\teax, [window]\n-\t\tmovzx\teax, word ptr [eax + ecx]\n-\t\tcmp\teax, [scanstart]\n-\t\tjnz\tLookupLoop\n-\n-;;; Store the current value of chainlen.\n-\n-\t\tmov\t[chainlenwmask], edx\n-\n-;;; Point edi to the string under scrutiny, and esi to the string we\n-;;; are hoping to match it up with. In actuality, esi and edi are\n-;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is\n-;;; initialized to -(MAX_MATCH_8 - scanalign).\n-\n-\t\tmov\tesi, [window]\n-\t\tmov\tedi, [scan]\n-\t\tadd\tesi, ecx\n-\t\tmov\teax, [scanalign]\n-\t\tmov\tedx, 0fffffef8h; -(MAX_MATCH_8)\n-\t\tlea\tedi, [edi + eax + 0108h] ;MAX_MATCH_8]\n-\t\tlea\tesi, [esi + eax + 0108h] ;MAX_MATCH_8]\n-\n-;;; Test the strings for equality, 8 bytes at a time. At the end,\n-;;; adjust edx so that it is offset to the exact byte that mismatched.\n-;;;\n-;;; We already know at this point that the first three bytes of the\n-;;; strings match each other, and they can be safely passed over before\n-;;; starting the compare loop. So what this code does is skip over 0-3\n-;;; bytes, as much as necessary in order to dword-align the edi\n-;;; pointer. (esi will still be misaligned three times out of four.)\n-;;;\n-;;; It should be confessed that this loop usually does not represent\n-;;; much of the total running time. Replacing it with a more\n-;;; straightforward \"rep cmpsb\" would not drastically degrade\n-;;; performance.\n-\n-LoopCmps:\n-\t\tmov\teax, [esi + edx]\n-\t\txor\teax, [edi + edx]\n-\t\tjnz\tLeaveLoopCmps\n-\t\tmov\teax, [esi + edx + 4]\n-\t\txor\teax, [edi + edx + 4]\n-\t\tjnz\tLeaveLoopCmps4\n-\t\tadd\tedx, 8\n-\t\tjnz\tLoopCmps\n-\t\tjmp\tshort LenMaximum\n-LeaveLoopCmps4:\tadd\tedx, 4\n-LeaveLoopCmps:\ttest\teax, 0000FFFFh\n-\t\tjnz\tLenLower\n-\t\tadd\tedx,  2\n-\t\tshr\teax, 16\n-LenLower:\tsub\tal, 1\n-\t\tadc\tedx, 0\n-\n-;;; Calculate the length of the match. If it is longer than MAX_MATCH,\n-;;; then automatically accept it as the best possible match and leave.\n-\n-\t\tlea\teax, [edi + edx]\n-\t\tmov\tedi, [scan]\n-\t\tsub\teax, edi\n-\t\tcmp\teax, MAX_MATCH\n-\t\tjge\tLenMaximum\n-\n-;;; If the length of the match is not longer than the best match we\n-;;; have so far, then forget it and return to the lookup loop.\n-\n-\t\tmov\tedx, [deflatestate]\n-\t\tmov\tebx, [bestlen]\n-\t\tcmp\teax, ebx\n-\t\tjg\tLongerMatch\n-\t\tmov\tesi, [windowbestlen]\n-\t\tmov\tedi, [edx + dsPrev]\n-\t\tmov\tebx, [scanend]\n-\t\tmov\tedx, [chainlenwmask]\n-\t\tjmp\tLookupLoop\n-\n-;;;         s->match_start = cur_match;\n-;;;         best_len = len;\n-;;;         if (len >= nice_match) break;\n-;;;         scan_end = *(ushf*)(scan+best_len-1);\n-\n-LongerMatch:\tmov\tebx, [nicematch]\n-\t\tmov\t[bestlen], eax\n-\t\tmov\t[edx + dsMatchStart], ecx\n-\t\tcmp\teax, ebx\n-\t\tjge\tLeaveNow\n-\t\tmov\tesi, [window]\n-\t\tadd\tesi, eax\n-\t\tmov\t[windowbestlen], esi\n-\t\tmovzx\tebx, word ptr [edi + eax - 1]\n-\t\tmov\tedi, [edx + dsPrev]\n-\t\tmov\t[scanend], ebx\n-\t\tmov\tedx, [chainlenwmask]\n-\t\tjmp\tLookupLoop\n-\n-;;; Accept the current string, with the maximum possible length.\n-\n-LenMaximum:\tmov\tedx, [deflatestate]\n-\t\tmov\tdword ptr [bestlen], MAX_MATCH\n-\t\tmov\t[edx + dsMatchStart], ecx\n-\n-;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\n-;;; return s->lookahead;\n-\n-LeaveNow:\n-\t\tmov\tedx, [deflatestate]\n-\t\tmov\tebx, [bestlen]\n-\t\tmov\teax, [edx + dsLookahead]\n-\t\tcmp\tebx, eax\n-\t\tjg\tLookaheadRet\n-\t\tmov\teax, ebx\n-LookaheadRet:\n-\n-;;; Restore the stack and return from whence we came.\n-\n-\t\tadd\tesp, LocalVarsSize\n-\t\tpop\tebx\n-\t\tpop\tesi\n-\t\tpop\tedi\n-\t\tpop\tebp\n-\n-\t\tret\n-; please don't remove this string !\n-; Your can freely use gvmat32 in any free or commercial app if you don't remove the string in the binary!\n-\tdb     0dh,0ah,\"asm686 with masm, optimised assembly code from Brian Raiter, written 1998\",0dh,0ah\n-\n-IFDEF NOUNDERLINE\n-longest_match_686   endp\n-ELSE\n-_longest_match_686  endp\n-ENDIF\n-\n-_TEXT   ends\n-end\n+; gvmat32.asm -- Asm portion of the optimized longest_match for 32 bits x86\r\n+; Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.\r\n+; File written by Gilles Vollant, by modifiying the longest_match\r\n+;  from Jean-loup Gailly in deflate.c\r\n+;\r\n+;         http://www.zlib.net\r\n+;         http://www.winimage.com/zLibDll\r\n+;         http://www.muppetlabs.com/~breadbox/software/assembly.html\r\n+;\r\n+; For Visual C++ 4.x and higher and ML 6.x and higher\r\n+;   ml.exe is in directory \\MASM611C of Win95 DDK\r\n+;   ml.exe is also distributed in http://www.masm32.com/masmdl.htm\r\n+;    and in VC++2003 toolkit at http://msdn.microsoft.com/visualc/vctoolkit2003/\r\n+;\r\n+; this file contain two implementation of longest_match\r\n+;\r\n+;  longest_match_7fff : written 1996 by Gilles Vollant optimized for \r\n+;            first Pentium. Assume s->w_mask == 0x7fff\r\n+;  longest_match_686 : written by Brian raiter (1998), optimized for Pentium Pro\r\n+;\r\n+;  for using an seembly version of longest_match, you need define ASMV in project\r\n+;  There is two way in using gvmat32.asm\r\n+;\r\n+;  A) Suggested method\r\n+;    if you want include both longest_match_7fff and longest_match_686\r\n+;    compile the asm file running\r\n+;           ml /coff /Zi /Flgvmat32.lst /c gvmat32.asm\r\n+;    and include gvmat32c.c in your project\r\n+;    if you have an old cpu (386,486 or first Pentium) and s->w_mask==0x7fff,\r\n+;        longest_match_7fff will be used\r\n+;    if you have a more modern CPU (Pentium Pro, II and higher)\r\n+;        longest_match_686 will be used\r\n+;    on old cpu with s->w_mask!=0x7fff, longest_match_686 will be used,\r\n+;        but this is not a sitation you'll find often\r\n+;\r\n+;  B) Alternative\r\n+;    if you are not interresed in old cpu performance and want the smaller\r\n+;       binaries possible\r\n+;\r\n+;    compile the asm file running\r\n+;           ml /coff /Zi /c /Flgvmat32.lst /DNOOLDPENTIUMCODE gvmat32.asm\r\n+;    and do not include gvmat32c.c in your project (ou define also \r\n+;              NOOLDPENTIUMCODE)\r\n+;\r\n+; note : as I known, longest_match_686 is very faster than longest_match_7fff\r\n+;        on pentium Pro/II/III, faster (but less) in P4, but it seem\r\n+;        longest_match_7fff can be faster (very very litte) on AMD Athlon64/K8\r\n+;\r\n+; see below : zlib1222add must be adjuster if you use a zlib version < 1.2.2.2\r\n+\r\n+;uInt longest_match_7fff(s, cur_match)\r\n+;    deflate_state *s;\r\n+;    IPos cur_match;                             /* current match */\r\n+\r\n+    NbStack         equ     76\r\n+    cur_match       equ     dword ptr[esp+NbStack-0]\r\n+    str_s           equ     dword ptr[esp+NbStack-4]\r\n+; 5 dword on top (ret,ebp,esi,edi,ebx)\r\n+    adrret          equ     dword ptr[esp+NbStack-8]\r\n+    pushebp         equ     dword ptr[esp+NbStack-12]\r\n+    pushedi         equ     dword ptr[esp+NbStack-16]\r\n+    pushesi         equ     dword ptr[esp+NbStack-20]\r\n+    pushebx         equ     dword ptr[esp+NbStack-24]\r\n+\r\n+    chain_length    equ     dword ptr [esp+NbStack-28]\r\n+    limit           equ     dword ptr [esp+NbStack-32]\r\n+    best_len        equ     dword ptr [esp+NbStack-36]\r\n+    window          equ     dword ptr [esp+NbStack-40]\r\n+    prev            equ     dword ptr [esp+NbStack-44]\r\n+    scan_start      equ      word ptr [esp+NbStack-48]\r\n+    wmask           equ     dword ptr [esp+NbStack-52]\r\n+    match_start_ptr equ     dword ptr [esp+NbStack-56]\r\n+    nice_match      equ     dword ptr [esp+NbStack-60]\r\n+    scan            equ     dword ptr [esp+NbStack-64]\r\n+\r\n+    windowlen       equ     dword ptr [esp+NbStack-68]\r\n+    match_start     equ     dword ptr [esp+NbStack-72]\r\n+    strend          equ     dword ptr [esp+NbStack-76]\r\n+    NbStackAdd      equ     (NbStack-24)\r\n+\r\n+    .386p\r\n+\r\n+    name    gvmatch\r\n+    .MODEL  FLAT\r\n+\r\n+\r\n+\r\n+;  all the +zlib1222add offsets are due to the addition of fields\r\n+;  in zlib in the deflate_state structure since the asm code was first written\r\n+;  (if you compile with zlib 1.0.4 or older, use \"zlib1222add equ (-4)\").\r\n+;  (if you compile with zlib between 1.0.5 and 1.2.2.1, use \"zlib1222add equ 0\").\r\n+;  if you compile with zlib 1.2.2.2 or later , use \"zlib1222add equ 8\").\r\n+\r\n+    zlib1222add         equ     8\r\n+\r\n+;  Note : these value are good with a 8 bytes boundary pack structure\r\n+    dep_chain_length    equ     74h+zlib1222add\r\n+    dep_window          equ     30h+zlib1222add\r\n+    dep_strstart        equ     64h+zlib1222add\r\n+    dep_prev_length     equ     70h+zlib1222add\r\n+    dep_nice_match      equ     88h+zlib1222add\r\n+    dep_w_size          equ     24h+zlib1222add\r\n+    dep_prev            equ     38h+zlib1222add\r\n+    dep_w_mask          equ     2ch+zlib1222add\r\n+    dep_good_match      equ     84h+zlib1222add\r\n+    dep_match_start     equ     68h+zlib1222add\r\n+    dep_lookahead       equ     6ch+zlib1222add\r\n+\r\n+\r\n+_TEXT                   segment\r\n+\r\n+IFDEF NOUNDERLINE\r\n+   IFDEF NOOLDPENTIUMCODE\r\n+            public  longest_match\r\n+            public  match_init\r\n+   ELSE            \r\n+            public  longest_match_7fff\r\n+            public  cpudetect32\r\n+            public  longest_match_686\r\n+   ENDIF\r\n+ELSE\r\n+   IFDEF NOOLDPENTIUMCODE\r\n+            public  _longest_match\r\n+            public  _match_init\r\n+   ELSE\r\n+            public  _longest_match_7fff\r\n+            public  _cpudetect32\r\n+            public  _longest_match_686\r\n+   ENDIF\r\n+ENDIF\r\n+\r\n+    MAX_MATCH           equ     258\r\n+    MIN_MATCH           equ     3\r\n+    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)\r\n+\r\n+\r\n+\r\n+IFNDEF NOOLDPENTIUMCODE\r\n+IFDEF NOUNDERLINE\r\n+longest_match_7fff   proc near\r\n+ELSE\r\n+_longest_match_7fff  proc near\r\n+ENDIF\r\n+\r\n+    mov     edx,[esp+4]\r\n+\r\n+\r\n+\r\n+    push    ebp\r\n+    push    edi\r\n+    push    esi\r\n+    push    ebx\r\n+\r\n+    sub     esp,NbStackAdd\r\n+\r\n+; initialize or check the variables used in match.asm.\r\n+    mov     ebp,edx\r\n+\r\n+; chain_length = s->max_chain_length\r\n+; if (prev_length>=good_match) chain_length >>= 2\r\n+    mov     edx,[ebp+dep_chain_length]\r\n+    mov     ebx,[ebp+dep_prev_length]\r\n+    cmp     [ebp+dep_good_match],ebx\r\n+    ja      noshr\r\n+    shr     edx,2\r\n+noshr:\r\n+; we increment chain_length because in the asm, the --chain_lenght is in the beginning of the loop\r\n+    inc     edx\r\n+    mov     edi,[ebp+dep_nice_match]\r\n+    mov     chain_length,edx\r\n+    mov     eax,[ebp+dep_lookahead]\r\n+    cmp     eax,edi\r\n+; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\r\n+    jae     nolookaheadnicematch\r\n+    mov     edi,eax\r\n+nolookaheadnicematch:\r\n+; best_len = s->prev_length\r\n+    mov     best_len,ebx\r\n+\r\n+; window = s->window\r\n+    mov     esi,[ebp+dep_window]\r\n+    mov     ecx,[ebp+dep_strstart]\r\n+    mov     window,esi\r\n+\r\n+    mov     nice_match,edi\r\n+; scan = window + strstart\r\n+    add     esi,ecx\r\n+    mov     scan,esi\r\n+; dx = *window\r\n+    mov     dx,word ptr [esi]\r\n+; bx = *(window+best_len-1)\r\n+    mov     bx,word ptr [esi+ebx-1]\r\n+    add     esi,MAX_MATCH-1\r\n+; scan_start = *scan\r\n+    mov     scan_start,dx\r\n+; strend = scan + MAX_MATCH-1\r\n+    mov     strend,esi\r\n+; bx = scan_end = *(window+best_len-1)\r\n+\r\n+;    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\r\n+;        s->strstart - (IPos)MAX_DIST(s) : NIL;\r\n+\r\n+    mov     esi,[ebp+dep_w_size]\r\n+    sub     esi,MIN_LOOKAHEAD\r\n+; here esi = MAX_DIST(s)\r\n+    sub     ecx,esi\r\n+    ja      nodist\r\n+    xor     ecx,ecx\r\n+nodist:\r\n+    mov     limit,ecx\r\n+\r\n+; prev = s->prev\r\n+    mov     edx,[ebp+dep_prev]\r\n+    mov     prev,edx\r\n+\r\n+;\r\n+    mov     edx,dword ptr [ebp+dep_match_start]\r\n+    mov     bp,scan_start\r\n+    mov     eax,cur_match\r\n+    mov     match_start,edx\r\n+\r\n+    mov     edx,window\r\n+    mov     edi,edx\r\n+    add     edi,best_len\r\n+    mov     esi,prev\r\n+    dec     edi\r\n+; windowlen = window + best_len -1\r\n+    mov     windowlen,edi\r\n+\r\n+    jmp     beginloop2\r\n+    align   4\r\n+\r\n+; here, in the loop\r\n+;       eax = ax = cur_match\r\n+;       ecx = limit\r\n+;        bx = scan_end\r\n+;        bp = scan_start\r\n+;       edi = windowlen (window + best_len -1)\r\n+;       esi = prev\r\n+\r\n+\r\n+;// here; chain_length <=16\r\n+normalbeg0add16:\r\n+    add     chain_length,16\r\n+    jz      exitloop\r\n+normalbeg0:\r\n+    cmp     word ptr[edi+eax],bx\r\n+    je      normalbeg2noroll\r\n+rcontlabnoroll:\r\n+; cur_match = prev[cur_match & wmask]\r\n+    and     eax,7fffh\r\n+    mov     ax,word ptr[esi+eax*2]\r\n+; if cur_match > limit, go to exitloop\r\n+    cmp     ecx,eax\r\n+    jnb     exitloop\r\n+; if --chain_length != 0, go to exitloop\r\n+    dec     chain_length\r\n+    jnz     normalbeg0\r\n+    jmp     exitloop\r\n+\r\n+normalbeg2noroll:\r\n+; if (scan_start==*(cur_match+window)) goto normalbeg2\r\n+    cmp     bp,word ptr[edx+eax]\r\n+    jne     rcontlabnoroll\r\n+    jmp     normalbeg2\r\n+\r\n+contloop3:\r\n+    mov     edi,windowlen\r\n+\r\n+; cur_match = prev[cur_match & wmask]\r\n+    and     eax,7fffh\r\n+    mov     ax,word ptr[esi+eax*2]\r\n+; if cur_match > limit, go to exitloop\r\n+    cmp     ecx,eax\r\n+jnbexitloopshort1:\r\n+    jnb     exitloop\r\n+; if --chain_length != 0, go to exitloop\r\n+\r\n+\r\n+; begin the main loop\r\n+beginloop2:\r\n+    sub     chain_length,16+1\r\n+; if chain_length <=16, don't use the unrolled loop\r\n+    jna     normalbeg0add16\r\n+\r\n+do16:\r\n+    cmp     word ptr[edi+eax],bx\r\n+    je      normalbeg2dc0\r\n+\r\n+maccn   MACRO   lab\r\n+    and     eax,7fffh\r\n+    mov     ax,word ptr[esi+eax*2]\r\n+    cmp     ecx,eax\r\n+    jnb     exitloop\r\n+    cmp     word ptr[edi+eax],bx\r\n+    je      lab\r\n+    ENDM\r\n+\r\n+rcontloop0:\r\n+    maccn   normalbeg2dc1\r\n+\r\n+rcontloop1:\r\n+    maccn   normalbeg2dc2\r\n+\r\n+rcontloop2:\r\n+    maccn   normalbeg2dc3\r\n+\r\n+rcontloop3:\r\n+    maccn   normalbeg2dc4\r\n+\r\n+rcontloop4:\r\n+    maccn   normalbeg2dc5\r\n+\r\n+rcontloop5:\r\n+    maccn   normalbeg2dc6\r\n+\r\n+rcontloop6:\r\n+    maccn   normalbeg2dc7\r\n+\r\n+rcontloop7:\r\n+    maccn   normalbeg2dc8\r\n+\r\n+rcontloop8:\r\n+    maccn   normalbeg2dc9\r\n+\r\n+rcontloop9:\r\n+    maccn   normalbeg2dc10\r\n+\r\n+rcontloop10:\r\n+    maccn   short normalbeg2dc11\r\n+\r\n+rcontloop11:\r\n+    maccn   short normalbeg2dc12\r\n+\r\n+rcontloop12:\r\n+    maccn   short normalbeg2dc13\r\n+\r\n+rcontloop13:\r\n+    maccn   short normalbeg2dc14\r\n+\r\n+rcontloop14:\r\n+    maccn   short normalbeg2dc15\r\n+\r\n+rcontloop15:\r\n+    and     eax,7fffh\r\n+    mov     ax,word ptr[esi+eax*2]\r\n+    cmp     ecx,eax\r\n+    jnb     exitloop\r\n+\r\n+    sub     chain_length,16\r\n+    ja      do16\r\n+    jmp     normalbeg0add16\r\n+\r\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n+\r\n+normbeg MACRO   rcontlab,valsub\r\n+; if we are here, we know that *(match+best_len-1) == scan_end\r\n+    cmp     bp,word ptr[edx+eax]\r\n+; if (match != scan_start) goto rcontlab\r\n+    jne     rcontlab\r\n+; calculate the good chain_length, and we'll compare scan and match string\r\n+    add     chain_length,16-valsub\r\n+    jmp     iseq\r\n+    ENDM\r\n+\r\n+\r\n+normalbeg2dc11:\r\n+    normbeg rcontloop11,11\r\n+\r\n+normalbeg2dc12:\r\n+    normbeg short rcontloop12,12\r\n+\r\n+normalbeg2dc13:\r\n+    normbeg short rcontloop13,13\r\n+\r\n+normalbeg2dc14:\r\n+    normbeg short rcontloop14,14\r\n+\r\n+normalbeg2dc15:\r\n+    normbeg short rcontloop15,15\r\n+\r\n+normalbeg2dc10:\r\n+    normbeg rcontloop10,10\r\n+\r\n+normalbeg2dc9:\r\n+    normbeg rcontloop9,9\r\n+\r\n+normalbeg2dc8:\r\n+    normbeg rcontloop8,8\r\n+\r\n+normalbeg2dc7:\r\n+    normbeg rcontloop7,7\r\n+\r\n+normalbeg2dc6:\r\n+    normbeg rcontloop6,6\r\n+\r\n+normalbeg2dc5:\r\n+    normbeg rcontloop5,5\r\n+\r\n+normalbeg2dc4:\r\n+    normbeg rcontloop4,4\r\n+\r\n+normalbeg2dc3:\r\n+    normbeg rcontloop3,3\r\n+\r\n+normalbeg2dc2:\r\n+    normbeg rcontloop2,2\r\n+\r\n+normalbeg2dc1:\r\n+    normbeg rcontloop1,1\r\n+\r\n+normalbeg2dc0:\r\n+    normbeg rcontloop0,0\r\n+\r\n+\r\n+; we go in normalbeg2 because *(ushf*)(match+best_len-1) == scan_end\r\n+\r\n+normalbeg2:\r\n+    mov     edi,window\r\n+\r\n+    cmp     bp,word ptr[edi+eax]\r\n+    jne     contloop3                   ; if *(ushf*)match != scan_start, continue\r\n+\r\n+iseq:\r\n+; if we are here, we know that *(match+best_len-1) == scan_end\r\n+; and (match == scan_start)\r\n+\r\n+    mov     edi,edx\r\n+    mov     esi,scan                    ; esi = scan\r\n+    add     edi,eax                     ; edi = window + cur_match = match\r\n+\r\n+    mov     edx,[esi+3]                 ; compare manually dword at match+3\r\n+    xor     edx,[edi+3]                 ; and scan +3\r\n+\r\n+    jz      begincompare                ; if equal, go to long compare\r\n+\r\n+; we will determine the unmatch byte and calculate len (in esi)\r\n+    or      dl,dl\r\n+    je      eq1rr\r\n+    mov     esi,3\r\n+    jmp     trfinval\r\n+eq1rr:\r\n+    or      dx,dx\r\n+    je      eq1\r\n+\r\n+    mov     esi,4\r\n+    jmp     trfinval\r\n+eq1:\r\n+    and     edx,0ffffffh\r\n+    jz      eq11\r\n+    mov     esi,5\r\n+    jmp     trfinval\r\n+eq11:\r\n+    mov     esi,6\r\n+    jmp     trfinval\r\n+\r\n+begincompare:\r\n+    ; here we now scan and match begin same\r\n+    add     edi,6\r\n+    add     esi,6\r\n+    mov     ecx,(MAX_MATCH-(2+4))/4     ; scan for at most MAX_MATCH bytes\r\n+    repe    cmpsd                       ; loop until mismatch\r\n+\r\n+    je      trfin                       ; go to trfin if not unmatch\r\n+; we determine the unmatch byte\r\n+    sub     esi,4\r\n+    mov     edx,[edi-4]\r\n+    xor     edx,[esi]\r\n+\r\n+    or      dl,dl\r\n+    jnz     trfin\r\n+    inc     esi\r\n+\r\n+    or      dx,dx\r\n+    jnz     trfin\r\n+    inc     esi\r\n+\r\n+    and     edx,0ffffffh\r\n+    jnz     trfin\r\n+    inc     esi\r\n+\r\n+trfin:\r\n+    sub     esi,scan          ; esi = len\r\n+trfinval:\r\n+; here we have finised compare, and esi contain len of equal string\r\n+    cmp     esi,best_len        ; if len > best_len, go newbestlen\r\n+    ja      short newbestlen\r\n+; now we restore edx, ecx and esi, for the big loop\r\n+    mov     esi,prev\r\n+    mov     ecx,limit\r\n+    mov     edx,window\r\n+    jmp     contloop3\r\n+\r\n+newbestlen:\r\n+    mov     best_len,esi        ; len become best_len\r\n+\r\n+    mov     match_start,eax     ; save new position as match_start\r\n+    cmp     esi,nice_match      ; if best_len >= nice_match, exit\r\n+    jae     exitloop\r\n+    mov     ecx,scan\r\n+    mov     edx,window          ; restore edx=window\r\n+    add     ecx,esi\r\n+    add     esi,edx\r\n+\r\n+    dec     esi\r\n+    mov     windowlen,esi       ; windowlen = window + best_len-1\r\n+    mov     bx,[ecx-1]          ; bx = *(scan+best_len-1) = scan_end\r\n+\r\n+; now we restore ecx and esi, for the big loop :\r\n+    mov     esi,prev\r\n+    mov     ecx,limit\r\n+    jmp     contloop3\r\n+\r\n+exitloop:\r\n+; exit : s->match_start=match_start\r\n+    mov     ebx,match_start\r\n+    mov     ebp,str_s\r\n+    mov     ecx,best_len\r\n+    mov     dword ptr [ebp+dep_match_start],ebx\r\n+    mov     eax,dword ptr [ebp+dep_lookahead]\r\n+    cmp     ecx,eax\r\n+    ja      minexlo\r\n+    mov     eax,ecx\r\n+minexlo:\r\n+; return min(best_len,s->lookahead)\r\n+\r\n+; restore stack and register ebx,esi,edi,ebp\r\n+    add     esp,NbStackAdd\r\n+\r\n+    pop     ebx\r\n+    pop     esi\r\n+    pop     edi\r\n+    pop     ebp\r\n+    ret\r\n+InfoAuthor:\r\n+; please don't remove this string !\r\n+; Your are free use gvmat32 in any fre or commercial apps if you don't remove the string in the binary!\r\n+    db     0dh,0ah,\"GVMat32 optimised assembly code written 1996-98 by Gilles Vollant\",0dh,0ah\r\n+\r\n+\r\n+\r\n+IFDEF NOUNDERLINE\r\n+longest_match_7fff   endp\r\n+ELSE\r\n+_longest_match_7fff  endp\r\n+ENDIF\r\n+\r\n+\r\n+IFDEF NOUNDERLINE\r\n+cpudetect32     proc near\r\n+ELSE\r\n+_cpudetect32    proc near\r\n+ENDIF\r\n+\r\n+    push    ebx\r\n+\r\n+    pushfd                  ; push original EFLAGS\r\n+    pop     eax             ; get original EFLAGS\r\n+    mov     ecx, eax        ; save original EFLAGS\r\n+    xor     eax, 40000h     ; flip AC bit in EFLAGS\r\n+    push    eax             ; save new EFLAGS value on stack\r\n+    popfd                   ; replace current EFLAGS value\r\n+    pushfd                  ; get new EFLAGS\r\n+    pop     eax             ; store new EFLAGS in EAX\r\n+    xor     eax, ecx        ; can\ufffdt toggle AC bit, processor=80386\r\n+    jz      end_cpu_is_386  ; jump if 80386 processor\r\n+    push    ecx\r\n+    popfd                   ; restore AC bit in EFLAGS first\r\n+\r\n+    pushfd\r\n+    pushfd\r\n+    pop     ecx\r\n+\r\n+    mov     eax, ecx        ; get original EFLAGS\r\n+    xor     eax, 200000h    ; flip ID bit in EFLAGS\r\n+    push    eax             ; save new EFLAGS value on stack\r\n+    popfd                   ; replace current EFLAGS value\r\n+    pushfd                  ; get new EFLAGS\r\n+    pop     eax             ; store new EFLAGS in EAX\r\n+    popfd                   ; restore original EFLAGS\r\n+    xor     eax, ecx        ; can\ufffdt toggle ID bit,\r\n+    je      is_old_486      ; processor=old\r\n+\r\n+    mov     eax,1\r\n+    db      0fh,0a2h        ;CPUID\r\n+\r\n+exitcpudetect:\r\n+    pop ebx\r\n+    ret\r\n+\r\n+end_cpu_is_386:\r\n+    mov     eax,0300h\r\n+    jmp     exitcpudetect\r\n+\r\n+is_old_486:\r\n+    mov     eax,0400h\r\n+    jmp     exitcpudetect\r\n+\r\n+IFDEF NOUNDERLINE\r\n+cpudetect32     endp\r\n+ELSE\r\n+_cpudetect32    endp\r\n+ENDIF\r\n+ENDIF\r\n+\r\n+MAX_MATCH       equ     258\r\n+MIN_MATCH       equ     3\r\n+MIN_LOOKAHEAD   equ     (MAX_MATCH + MIN_MATCH + 1)\r\n+MAX_MATCH_8_     equ     ((MAX_MATCH + 7) AND 0FFF0h)\r\n+\r\n+\r\n+;;; stack frame offsets\r\n+\r\n+chainlenwmask   equ  esp + 0    ; high word: current chain len\r\n+                    ; low word: s->wmask\r\n+window      equ  esp + 4    ; local copy of s->window\r\n+windowbestlen   equ  esp + 8    ; s->window + bestlen\r\n+scanstart   equ  esp + 16   ; first two bytes of string\r\n+scanend     equ  esp + 12   ; last two bytes of string\r\n+scanalign   equ  esp + 20   ; dword-misalignment of string\r\n+nicematch   equ  esp + 24   ; a good enough match size\r\n+bestlen     equ  esp + 28   ; size of best match so far\r\n+scan        equ  esp + 32   ; ptr to string wanting match\r\n+\r\n+LocalVarsSize   equ 36\r\n+;   saved ebx   byte esp + 36\r\n+;   saved edi   byte esp + 40\r\n+;   saved esi   byte esp + 44\r\n+;   saved ebp   byte esp + 48\r\n+;   return address  byte esp + 52\r\n+deflatestate    equ  esp + 56   ; the function arguments\r\n+curmatch    equ  esp + 60\r\n+\r\n+;;; Offsets for fields in the deflate_state structure. These numbers\r\n+;;; are calculated from the definition of deflate_state, with the\r\n+;;; assumption that the compiler will dword-align the fields. (Thus,\r\n+;;; changing the definition of deflate_state could easily cause this\r\n+;;; program to crash horribly, without so much as a warning at\r\n+;;; compile time. Sigh.)\r\n+\r\n+dsWSize     equ 36+zlib1222add\r\n+dsWMask     equ 44+zlib1222add\r\n+dsWindow    equ 48+zlib1222add\r\n+dsPrev      equ 56+zlib1222add\r\n+dsMatchLen  equ 88+zlib1222add\r\n+dsPrevMatch equ 92+zlib1222add\r\n+dsStrStart  equ 100+zlib1222add\r\n+dsMatchStart    equ 104+zlib1222add\r\n+dsLookahead equ 108+zlib1222add\r\n+dsPrevLen   equ 112+zlib1222add\r\n+dsMaxChainLen   equ 116+zlib1222add\r\n+dsGoodMatch equ 132+zlib1222add\r\n+dsNiceMatch equ 136+zlib1222add\r\n+\r\n+\r\n+;;; match.asm -- Pentium-Pro-optimized version of longest_match()\r\n+;;; Written for zlib 1.1.2\r\n+;;; Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>\r\n+;;; You can look at http://www.muppetlabs.com/~breadbox/software/assembly.html\r\n+;;;\r\n+;;; This is free software; you can redistribute it and/or modify it\r\n+;;; under the terms of the GNU General Public License.\r\n+\r\n+;GLOBAL _longest_match, _match_init\r\n+\r\n+\r\n+;SECTION    .text\r\n+\r\n+;;; uInt longest_match(deflate_state *deflatestate, IPos curmatch)\r\n+\r\n+;_longest_match:\r\n+IFDEF NOOLDPENTIUMCODE\r\n+    IFDEF NOUNDERLINE\r\n+    longest_match       proc near\r\n+    ELSE\r\n+    _longest_match      proc near\r\n+    ENDIF\r\n+ELSE\r\n+    IFDEF NOUNDERLINE\r\n+    longest_match_686   proc near\r\n+    ELSE\r\n+    _longest_match_686  proc near\r\n+    ENDIF\r\n+ENDIF\r\n+\r\n+;;; Save registers that the compiler may be using, and adjust esp to\r\n+;;; make room for our stack frame.\r\n+\r\n+        push    ebp\r\n+        push    edi\r\n+        push    esi\r\n+        push    ebx\r\n+        sub esp, LocalVarsSize\r\n+\r\n+;;; Retrieve the function arguments. ecx will hold cur_match\r\n+;;; throughout the entire function. edx will hold the pointer to the\r\n+;;; deflate_state structure during the function's setup (before\r\n+;;; entering the main loop.\r\n+\r\n+        mov edx, [deflatestate]\r\n+        mov ecx, [curmatch]\r\n+\r\n+;;; uInt wmask = s->w_mask;\r\n+;;; unsigned chain_length = s->max_chain_length;\r\n+;;; if (s->prev_length >= s->good_match) {\r\n+;;;     chain_length >>= 2;\r\n+;;; }\r\n+\r\n+        mov eax, [edx + dsPrevLen]\r\n+        mov ebx, [edx + dsGoodMatch]\r\n+        cmp eax, ebx\r\n+        mov eax, [edx + dsWMask]\r\n+        mov ebx, [edx + dsMaxChainLen]\r\n+        jl  LastMatchGood\r\n+        shr ebx, 2\r\n+LastMatchGood:\r\n+\r\n+;;; chainlen is decremented once beforehand so that the function can\r\n+;;; use the sign flag instead of the zero flag for the exit test.\r\n+;;; It is then shifted into the high word, to make room for the wmask\r\n+;;; value, which it will always accompany.\r\n+\r\n+        dec ebx\r\n+        shl ebx, 16\r\n+        or  ebx, eax\r\n+        mov [chainlenwmask], ebx\r\n+\r\n+;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\r\n+\r\n+        mov eax, [edx + dsNiceMatch]\r\n+        mov ebx, [edx + dsLookahead]\r\n+        cmp ebx, eax\r\n+        jl  LookaheadLess\r\n+        mov ebx, eax\r\n+LookaheadLess:  mov [nicematch], ebx\r\n+\r\n+;;; register Bytef *scan = s->window + s->strstart;\r\n+\r\n+        mov esi, [edx + dsWindow]\r\n+        mov [window], esi\r\n+        mov ebp, [edx + dsStrStart]\r\n+        lea edi, [esi + ebp]\r\n+        mov [scan], edi\r\n+\r\n+;;; Determine how many bytes the scan ptr is off from being\r\n+;;; dword-aligned.\r\n+\r\n+        mov eax, edi\r\n+        neg eax\r\n+        and eax, 3\r\n+        mov [scanalign], eax\r\n+\r\n+;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\r\n+;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;\r\n+\r\n+        mov eax, [edx + dsWSize]\r\n+        sub eax, MIN_LOOKAHEAD\r\n+        sub ebp, eax\r\n+        jg  LimitPositive\r\n+        xor ebp, ebp\r\n+LimitPositive:\r\n+\r\n+;;; int best_len = s->prev_length;\r\n+\r\n+        mov eax, [edx + dsPrevLen]\r\n+        mov [bestlen], eax\r\n+\r\n+;;; Store the sum of s->window + best_len in esi locally, and in esi.\r\n+\r\n+        add esi, eax\r\n+        mov [windowbestlen], esi\r\n+\r\n+;;; register ush scan_start = *(ushf*)scan;\r\n+;;; register ush scan_end   = *(ushf*)(scan+best_len-1);\r\n+;;; Posf *prev = s->prev;\r\n+\r\n+        movzx   ebx, word ptr [edi]\r\n+        mov [scanstart], ebx\r\n+        movzx   ebx, word ptr [edi + eax - 1]\r\n+        mov [scanend], ebx\r\n+        mov edi, [edx + dsPrev]\r\n+\r\n+;;; Jump into the main loop.\r\n+\r\n+        mov edx, [chainlenwmask]\r\n+        jmp short LoopEntry\r\n+\r\n+align 4\r\n+\r\n+;;; do {\r\n+;;;     match = s->window + cur_match;\r\n+;;;     if (*(ushf*)(match+best_len-1) != scan_end ||\r\n+;;;         *(ushf*)match != scan_start) continue;\r\n+;;;     [...]\r\n+;;; } while ((cur_match = prev[cur_match & wmask]) > limit\r\n+;;;          && --chain_length != 0);\r\n+;;;\r\n+;;; Here is the inner loop of the function. The function will spend the\r\n+;;; majority of its time in this loop, and majority of that time will\r\n+;;; be spent in the first ten instructions.\r\n+;;;\r\n+;;; Within this loop:\r\n+;;; ebx = scanend\r\n+;;; ecx = curmatch\r\n+;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)\r\n+;;; esi = windowbestlen - i.e., (window + bestlen)\r\n+;;; edi = prev\r\n+;;; ebp = limit\r\n+\r\n+LookupLoop:\r\n+        and ecx, edx\r\n+        movzx   ecx, word ptr [edi + ecx*2]\r\n+        cmp ecx, ebp\r\n+        jbe LeaveNow\r\n+        sub edx, 00010000h\r\n+        js  LeaveNow\r\n+LoopEntry:  movzx   eax, word ptr [esi + ecx - 1]\r\n+        cmp eax, ebx\r\n+        jnz LookupLoop\r\n+        mov eax, [window]\r\n+        movzx   eax, word ptr [eax + ecx]\r\n+        cmp eax, [scanstart]\r\n+        jnz LookupLoop\r\n+\r\n+;;; Store the current value of chainlen.\r\n+\r\n+        mov [chainlenwmask], edx\r\n+\r\n+;;; Point edi to the string under scrutiny, and esi to the string we\r\n+;;; are hoping to match it up with. In actuality, esi and edi are\r\n+;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is\r\n+;;; initialized to -(MAX_MATCH_8 - scanalign).\r\n+\r\n+        mov esi, [window]\r\n+        mov edi, [scan]\r\n+        add esi, ecx\r\n+        mov eax, [scanalign]\r\n+        mov edx, 0fffffef8h; -(MAX_MATCH_8)\r\n+        lea edi, [edi + eax + 0108h] ;MAX_MATCH_8]\r\n+        lea esi, [esi + eax + 0108h] ;MAX_MATCH_8]\r\n+\r\n+;;; Test the strings for equality, 8 bytes at a time. At the end,\r\n+;;; adjust edx so that it is offset to the exact byte that mismatched.\r\n+;;;\r\n+;;; We already know at this point that the first three bytes of the\r\n+;;; strings match each other, and they can be safely passed over before\r\n+;;; starting the compare loop. So what this code does is skip over 0-3\r\n+;;; bytes, as much as necessary in order to dword-align the edi\r\n+;;; pointer. (esi will still be misaligned three times out of four.)\r\n+;;;\r\n+;;; It should be confessed that this loop usually does not represent\r\n+;;; much of the total running time. Replacing it with a more\r\n+;;; straightforward \"rep cmpsb\" would not drastically degrade\r\n+;;; performance.\r\n+\r\n+LoopCmps:\r\n+        mov eax, [esi + edx]\r\n+        xor eax, [edi + edx]\r\n+        jnz LeaveLoopCmps\r\n+        mov eax, [esi + edx + 4]\r\n+        xor eax, [edi + edx + 4]\r\n+        jnz LeaveLoopCmps4\r\n+        add edx, 8\r\n+        jnz LoopCmps\r\n+        jmp short LenMaximum\r\n+LeaveLoopCmps4: add edx, 4\r\n+LeaveLoopCmps:  test    eax, 0000FFFFh\r\n+        jnz LenLower\r\n+        add edx,  2\r\n+        shr eax, 16\r\n+LenLower:   sub al, 1\r\n+        adc edx, 0\r\n+\r\n+;;; Calculate the length of the match. If it is longer than MAX_MATCH,\r\n+;;; then automatically accept it as the best possible match and leave.\r\n+\r\n+        lea eax, [edi + edx]\r\n+        mov edi, [scan]\r\n+        sub eax, edi\r\n+        cmp eax, MAX_MATCH\r\n+        jge LenMaximum\r\n+\r\n+;;; If the length of the match is not longer than the best match we\r\n+;;; have so far, then forget it and return to the lookup loop.\r\n+\r\n+        mov edx, [deflatestate]\r\n+        mov ebx, [bestlen]\r\n+        cmp eax, ebx\r\n+        jg  LongerMatch\r\n+        mov esi, [windowbestlen]\r\n+        mov edi, [edx + dsPrev]\r\n+        mov ebx, [scanend]\r\n+        mov edx, [chainlenwmask]\r\n+        jmp LookupLoop\r\n+\r\n+;;;         s->match_start = cur_match;\r\n+;;;         best_len = len;\r\n+;;;         if (len >= nice_match) break;\r\n+;;;         scan_end = *(ushf*)(scan+best_len-1);\r\n+\r\n+LongerMatch:    mov ebx, [nicematch]\r\n+        mov [bestlen], eax\r\n+        mov [edx + dsMatchStart], ecx\r\n+        cmp eax, ebx\r\n+        jge LeaveNow\r\n+        mov esi, [window]\r\n+        add esi, eax\r\n+        mov [windowbestlen], esi\r\n+        movzx   ebx, word ptr [edi + eax - 1]\r\n+        mov edi, [edx + dsPrev]\r\n+        mov [scanend], ebx\r\n+        mov edx, [chainlenwmask]\r\n+        jmp LookupLoop\r\n+\r\n+;;; Accept the current string, with the maximum possible length.\r\n+\r\n+LenMaximum: mov edx, [deflatestate]\r\n+        mov dword ptr [bestlen], MAX_MATCH\r\n+        mov [edx + dsMatchStart], ecx\r\n+\r\n+;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\r\n+;;; return s->lookahead;\r\n+\r\n+LeaveNow:\r\n+        mov edx, [deflatestate]\r\n+        mov ebx, [bestlen]\r\n+        mov eax, [edx + dsLookahead]\r\n+        cmp ebx, eax\r\n+        jg  LookaheadRet\r\n+        mov eax, ebx\r\n+LookaheadRet:\r\n+\r\n+;;; Restore the stack and return from whence we came.\r\n+\r\n+        add esp, LocalVarsSize\r\n+        pop ebx\r\n+        pop esi\r\n+        pop edi\r\n+        pop ebp\r\n+\r\n+        ret\r\n+; please don't remove this string !\r\n+; Your can freely use gvmat32 in any free or commercial app if you don't remove the string in the binary!\r\n+    db     0dh,0ah,\"asm686 with masm, optimised assembly code from Brian Raiter, written 1998\",0dh,0ah\r\n+\r\n+\r\n+IFDEF NOOLDPENTIUMCODE\r\n+    IFDEF NOUNDERLINE\r\n+    longest_match       endp\r\n+    ELSE\r\n+    _longest_match      endp\r\n+    ENDIF\r\n+\r\n+    IFDEF NOUNDERLINE\r\n+    match_init      proc near\r\n+                    ret\r\n+    match_init      endp\r\n+    ELSE\r\n+    _match_init     proc near\r\n+                    ret\r\n+    _match_init     endp\r\n+    ENDIF    \r\n+ELSE\r\n+    IFDEF NOUNDERLINE\r\n+    longest_match_686   endp\r\n+    ELSE\r\n+    _longest_match_686  endp\r\n+    ENDIF\r\n+ENDIF\r\n+\r\n+_TEXT   ends\r\n+end\r"}, {"sha": "7ad2b27943bc0bbbdbd06df733548c47e157dc85", "filename": "zlib/contrib/masmx86/gvmat32c.c", "status": "modified", "additions": 62, "deletions": 206, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32c.c?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,206 +1,62 @@\n-/* gvmat32.c -- C portion of the optimized longest_match for 32 bits x86\n- * Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.\n- * File written by Gilles Vollant, by modifiying the longest_match\n- *  from Jean-loup Gailly in deflate.c\n- *  it prepare all parameters and call the assembly longest_match_gvasm\n- *  longest_match execute standard C code is wmask != 0x7fff\n- *     (assembly code is faster with a fixed wmask)\n- *\n- */\n-\n-#include \"deflate.h\"\n-\n-#ifdef ASMV\n-#define NIL 0\n-\n-#define UNALIGNED_OK\n-\n-\n-/* if your C compiler don't add underline before function name,\n-        define ADD_UNDERLINE_ASMFUNC */\n-#ifdef ADD_UNDERLINE_ASMFUNC\n-#define longest_match_7fff _longest_match_7fff\n-#define longest_match_686  _longest_match_686\n-#define cpudetect32        _cpudetect32\n-#endif\n-\n-\n-\n-void match_init()\n-{\n-}\n-\n-unsigned long cpudetect32();\n-\n-uInt longest_match_c(\n-    deflate_state *s,\n-    IPos cur_match);                             /* current match */\n-\n-\n-uInt longest_match_7fff(\n-    deflate_state *s,\n-    IPos cur_match);                             /* current match */\n-\n-uInt longest_match_686(\n-    deflate_state *s,\n-    IPos cur_match);                             /* current match */\n-\n-uInt longest_match(\n-    deflate_state *s,\n-    IPos cur_match)                             /* current match */\n-{\n-    static uInt iIsPPro=2;\n-\n-    if ((s->w_mask == 0x7fff) && (iIsPPro==0))\n-        return longest_match_7fff(s,cur_match);\n-\n-    if (iIsPPro==1)\n-        return longest_match_686(s,cur_match);\n-\n-    if (iIsPPro==2)\n-        iIsPPro = (((cpudetect32()/0x100)&0xf)>=6) ? 1 : 0;\n-\n-    return longest_match_c(s,cur_match);\n-}\n-\n-\n-\n-uInt longest_match_c(s, cur_match)\n-    deflate_state *s;\n-    IPos cur_match;                             /* current match */\n-{\n-    unsigned chain_length = s->max_chain_length;/* max hash chain length */\n-    register Bytef *scan = s->window + s->strstart; /* current string */\n-    register Bytef *match;                       /* matched string */\n-    register int len;                           /* length of current match */\n-    int best_len = s->prev_length;              /* best match length so far */\n-    int nice_match = s->nice_match;             /* stop if match long enough */\n-    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n-        s->strstart - (IPos)MAX_DIST(s) : NIL;\n-    /* Stop when cur_match becomes <= limit. To simplify the code,\n-     * we prevent matches with the string of window index 0.\n-     */\n-    Posf *prev = s->prev;\n-    uInt wmask = s->w_mask;\n-\n-#ifdef UNALIGNED_OK\n-    /* Compare two bytes at a time. Note: this is not always beneficial.\n-     * Try with and without -DUNALIGNED_OK to check.\n-     */\n-    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;\n-    register ush scan_start = *(ushf*)scan;\n-    register ush scan_end   = *(ushf*)(scan+best_len-1);\n-#else\n-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n-    register Byte scan_end1  = scan[best_len-1];\n-    register Byte scan_end   = scan[best_len];\n-#endif\n-\n-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n-     * It is easy to get rid of this optimization if necessary.\n-     */\n-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n-\n-    /* Do not waste too much time if we already have a good match: */\n-    if (s->prev_length >= s->good_match) {\n-        chain_length >>= 2;\n-    }\n-    /* Do not look for matches beyond the end of the input. This is necessary\n-     * to make deflate deterministic.\n-     */\n-    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n-\n-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n-\n-    do {\n-        Assert(cur_match < s->strstart, \"no future\");\n-        match = s->window + cur_match;\n-\n-        /* Skip to next match if the match length cannot increase\n-         * or if the match length is less than 2:\n-         */\n-#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\n-        /* This code assumes sizeof(unsigned short) == 2. Do not use\n-         * UNALIGNED_OK if your compiler uses a different size.\n-         */\n-        if (*(ushf*)(match+best_len-1) != scan_end ||\n-            *(ushf*)match != scan_start) continue;\n-\n-        /* It is not necessary to compare scan[2] and match[2] since they are\n-         * always equal when the other bytes match, given that the hash keys\n-         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at\n-         * strstart+3, +5, ... up to strstart+257. We check for insufficient\n-         * lookahead only every 4th comparison; the 128th check will be made\n-         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is\n-         * necessary to put more guard bytes at the end of the window, or\n-         * to check more often for insufficient lookahead.\n-         */\n-        Assert(scan[2] == match[2], \"scan[2]?\");\n-        scan++, match++;\n-        do {\n-        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n-                 scan < strend);\n-        /* The funny \"do {}\" generates better code on most compilers */\n-\n-        /* Here, scan <= window+strstart+257 */\n-        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n-        if (*scan == *match) scan++;\n-\n-        len = (MAX_MATCH - 1) - (int)(strend-scan);\n-        scan = strend - (MAX_MATCH-1);\n-\n-#else /* UNALIGNED_OK */\n-\n-        if (match[best_len]   != scan_end  ||\n-            match[best_len-1] != scan_end1 ||\n-            *match            != *scan     ||\n-            *++match          != scan[1])      continue;\n-\n-        /* The check at best_len-1 can be removed because it will be made\n-         * again later. (This heuristic is not always a win.)\n-         * It is not necessary to compare scan[2] and match[2] since they\n-         * are always equal when the other bytes match, given that\n-         * the hash keys are equal and that HASH_BITS >= 8.\n-         */\n-        scan += 2, match++;\n-        Assert(*scan == *match, \"match[2]?\");\n-\n-        /* We check for insufficient lookahead only every 8th comparison;\n-         * the 256th check will be made at strstart+258.\n-         */\n-        do {\n-        } while (*++scan == *++match && *++scan == *++match &&\n-                 *++scan == *++match && *++scan == *++match &&\n-                 *++scan == *++match && *++scan == *++match &&\n-                 *++scan == *++match && *++scan == *++match &&\n-                 scan < strend);\n-\n-        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n-\n-        len = MAX_MATCH - (int)(strend - scan);\n-        scan = strend - MAX_MATCH;\n-\n-#endif /* UNALIGNED_OK */\n-\n-        if (len > best_len) {\n-            s->match_start = cur_match;\n-            best_len = len;\n-            if (len >= nice_match) break;\n-#ifdef UNALIGNED_OK\n-            scan_end = *(ushf*)(scan+best_len-1);\n-#else\n-            scan_end1  = scan[best_len-1];\n-            scan_end   = scan[best_len];\n-#endif\n-        }\n-    } while ((cur_match = prev[cur_match & wmask]) > limit\n-             && --chain_length != 0);\n-\n-    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\n-    return s->lookahead;\n-}\n-\n-#endif /* ASMV */\n+/* gvmat32.c -- C portion of the optimized longest_match for 32 bits x86\r\n+ * Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.\r\n+ * File written by Gilles Vollant, by modifiying the longest_match\r\n+ *  from Jean-loup Gailly in deflate.c\r\n+ *  it prepare all parameters and call the assembly longest_match_gvasm\r\n+ *  longest_match execute standard C code is wmask != 0x7fff\r\n+ *     (assembly code is faster with a fixed wmask)\r\n+ *\r\n+ * Read comment at beginning of gvmat32.asm for more information\r\n+ */\r\n+\r\n+#if defined(ASMV) && (!defined(NOOLDPENTIUMCODE))\r\n+#include \"deflate.h\"\r\n+\r\n+/* if your C compiler don't add underline before function name,\r\n+        define ADD_UNDERLINE_ASMFUNC */\r\n+#ifdef ADD_UNDERLINE_ASMFUNC\r\n+#define longest_match_7fff _longest_match_7fff\r\n+#define longest_match_686  _longest_match_686\r\n+#define cpudetect32        _cpudetect32\r\n+#endif\r\n+\r\n+\r\n+unsigned long cpudetect32();\r\n+\r\n+uInt longest_match_c(\r\n+    deflate_state *s,\r\n+    IPos cur_match);                             /* current match */\r\n+\r\n+\r\n+uInt longest_match_7fff(\r\n+    deflate_state *s,\r\n+    IPos cur_match);                             /* current match */\r\n+\r\n+uInt longest_match_686(\r\n+    deflate_state *s,\r\n+    IPos cur_match);                             /* current match */\r\n+\r\n+\r\n+static uInt iIsPPro=2;\r\n+\r\n+void match_init ()\r\n+{\r\n+    iIsPPro = (((cpudetect32()/0x100)&0xf)>=6) ? 1 : 0;\r\n+}\r\n+\r\n+uInt longest_match(\r\n+    deflate_state *s,\r\n+    IPos cur_match)                             /* current match */\r\n+{\r\n+    if (iIsPPro!=0)\r\n+        return longest_match_686(s,cur_match);\r\n+\r\n+    if (s->w_mask != 0x7fff)\r\n+        return longest_match_686(s,cur_match);\r\n+\r\n+    /* now ((s->w_mask == 0x7fff) && (iIsPPro==0)) */\r\n+        return longest_match_7fff(s,cur_match);\r\n+}\r\n+\r\n+\r\n+#endif /* defined(ASMV) && (!defined(NOOLDPENTIUMCODE)) */\r"}, {"sha": "4a205125ec59d1c2c2eb53abc359025509e32de8", "filename": "zlib/contrib/masmx86/inffas32.asm", "status": "modified", "additions": 1083, "deletions": 1033, "changes": 2116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fmasmx86%2Finffas32.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fmasmx86%2Finffas32.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Finffas32.asm?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,1033 +1,1083 @@\n-; 75 \"inffast.S\"\n-;FILE \"inffast.S\"\n-\n-;;;GLOBAL _inflate_fast\n-\n-;;;SECTION .text\n-\n-\n-\n-\t.586p\n-\t.mmx\n-\n-\tname\tinflate_fast_x86\n-\t.MODEL\tFLAT\n-\n-_DATA\t\t\tsegment\n-inflate_fast_use_mmx:\n-\tdd\t1\n-\n-\n-_TEXT\t\t\tsegment\n-PUBLIC _inflate_fast\n-\n-ALIGN 4\n-_inflate_fast:\n-\tjmp inflate_fast_entry\n-\n-\n-\n-ALIGN 4\n-\tdb\t'Fast decoding Code from Chris Anderson'\n-\tdb\t0\n-\n-ALIGN 4\n-invalid_literal_length_code_msg:\n-\tdb\t'invalid literal/length code'\n-\tdb\t0\n-\n-ALIGN 4\n-invalid_distance_code_msg:\n-\tdb\t'invalid distance code'\n-\tdb\t0\n-\n-ALIGN 4\n-invalid_distance_too_far_msg:\n-\tdb\t'invalid distance too far back'\n-\tdb\t0\n-\n-\n-ALIGN 4\n-inflate_fast_mask:\n-dd\t0\n-dd\t1\n-dd\t3\n-dd\t7\n-dd\t15\n-dd\t31\n-dd\t63\n-dd\t127\n-dd\t255\n-dd\t511\n-dd\t1023\n-dd\t2047\n-dd\t4095\n-dd\t8191\n-dd\t16383\n-dd\t32767\n-dd\t65535\n-dd\t131071\n-dd\t262143\n-dd\t524287\n-dd\t1048575\n-dd\t2097151\n-dd\t4194303\n-dd\t8388607\n-dd\t16777215\n-dd\t33554431\n-dd\t67108863\n-dd\t134217727\n-dd\t268435455\n-dd\t536870911\n-dd\t1073741823\n-dd\t2147483647\n-dd\t4294967295\n-\n-\n-\n-mode_state\t equ\t0\t;/* state->mode\t*/\n-wsize_state\t equ\t32\t;/* state->wsize */\n-write_state\t equ\t(36+4)\t;/* state->write */\n-window_state\t equ\t(40+4)\t;/* state->window */\n-hold_state\t equ\t(44+4)\t;/* state->hold\t*/\n-bits_state\t equ\t(48+4)\t;/* state->bits\t*/\n-lencode_state\t equ\t(64+4)\t;/* state->lencode */\n-distcode_state\t equ\t(68+4)\t;/* state->distcode */\n-lenbits_state\t equ\t(72+4)\t;/* state->lenbits */\n-distbits_state\t equ\t(76+4)\t;/* state->distbits */\n-\n-\n-;;SECTION .text\n-; 205 \"inffast.S\"\n-;GLOBAL\tinflate_fast_use_mmx\n-\n-;SECTION .data\n-\n-\n-; GLOBAL inflate_fast_use_mmx:object\n-;.size inflate_fast_use_mmx, 4\n-; 226 \"inffast.S\"\n-;SECTION .text\n-\n-ALIGN 4\n-inflate_fast_entry:\n-\tpush  edi\n-\tpush  esi\n-\tpush  ebp\n-\tpush  ebx\n-\tpushfd\n-\tsub  esp,64\n-\tcld\n-\n-\n-\n-\n-\tmov  esi, [esp+88]\n-\tmov  edi, [esi+28]\n-\n-\n-\n-\n-\n-\n-\n-\tmov  edx, [esi+4]\n-\tmov  eax, [esi+0]\n-\n-\tadd  edx,eax\n-\tsub  edx,11\n-\n-\tmov  [esp+44],eax\n-\tmov  [esp+20],edx\n-\n-\tmov  ebp, [esp+92]\n-\tmov  ecx, [esi+16]\n-\tmov  ebx, [esi+12]\n-\n-\tsub  ebp,ecx\n-\tneg  ebp\n-\tadd  ebp,ebx\n-\n-\tsub  ecx,257\n-\tadd  ecx,ebx\n-\n-\tmov  [esp+60],ebx\n-\tmov  [esp+40],ebp\n-\tmov  [esp+16],ecx\n-; 285 \"inffast.S\"\n-\tmov  eax, [edi+lencode_state]\n-\tmov  ecx, [edi+distcode_state]\n-\n-\tmov  [esp+8],eax\n-\tmov  [esp+12],ecx\n-\n-\tmov  eax,1\n-\tmov  ecx, [edi+lenbits_state]\n-\tshl  eax,cl\n-\tdec  eax\n-\tmov  [esp+0],eax\n-\n-\tmov  eax,1\n-\tmov  ecx, [edi+distbits_state]\n-\tshl  eax,cl\n-\tdec  eax\n-\tmov  [esp+4],eax\n-\n-\tmov  eax, [edi+wsize_state]\n-\tmov  ecx, [edi+write_state]\n-\tmov  edx, [edi+window_state]\n-\n-\tmov  [esp+52],eax\n-\tmov  [esp+48],ecx\n-\tmov  [esp+56],edx\n-\n-\tmov  ebp, [edi+hold_state]\n-\tmov  ebx, [edi+bits_state]\n-; 321 \"inffast.S\"\n-\tmov  esi, [esp+44]\n-\tmov  ecx, [esp+20]\n-\tcmp  ecx,esi\n-\tja   L_align_long\n-\n-\tadd  ecx,11\n-\tsub  ecx,esi\n-\tmov  eax,12\n-\tsub  eax,ecx\n-\tlea  edi, [esp+28]\n-\trep movsb\n-\tmov  ecx,eax\n-\txor  eax,eax\n-\trep stosb\n-\tlea  esi, [esp+28]\n-\tmov  [esp+20],esi\n-\tjmp  L_is_aligned\n-\n-\n-L_align_long:\n-\ttest  esi,3\n-\tjz   L_is_aligned\n-\txor  eax,eax\n-\tmov  al, [esi]\n-\tinc  esi\n-\tmov  ecx,ebx\n-\tadd  ebx,8\n-\tshl  eax,cl\n-\tor  ebp,eax\n-\tjmp L_align_long\n-\n-L_is_aligned:\n-\tmov  edi, [esp+60]\n-; 366 \"inffast.S\"\n-L_check_mmx:\n-\tcmp  dword ptr [inflate_fast_use_mmx],2\n-\tje   L_init_mmx\n-\tja   L_do_loop\n-\n-\tpush  eax\n-\tpush  ebx\n-\tpush  ecx\n-\tpush  edx\n-\tpushfd\n-\tmov  eax, [esp]\n-\txor  dword ptr [esp],0200000h\n-\n-\n-\n-\n-\tpopfd\n-\tpushfd\n-\tpop  edx\n-\txor  edx,eax\n-\tjz   L_dont_use_mmx\n-\txor  eax,eax\n-\tcpuid\n-\tcmp  ebx,0756e6547h\n-\tjne  L_dont_use_mmx\n-\tcmp  ecx,06c65746eh\n-\tjne  L_dont_use_mmx\n-\tcmp  edx,049656e69h\n-\tjne  L_dont_use_mmx\n-\tmov  eax,1\n-\tcpuid\n-\tshr  eax,8\n-\tand  eax,15\n-\tcmp  eax,6\n-\tjne  L_dont_use_mmx\n-\ttest  edx,0800000h\n-\tjnz  L_use_mmx\n-\tjmp  L_dont_use_mmx\n-L_use_mmx:\n-\tmov  dword ptr [inflate_fast_use_mmx],2\n-\tjmp  L_check_mmx_pop\n-L_dont_use_mmx:\n-\tmov  dword ptr [inflate_fast_use_mmx],3\n-L_check_mmx_pop:\n-\tpop  edx\n-\tpop  ecx\n-\tpop  ebx\n-\tpop  eax\n-\tjmp  L_check_mmx\n-; 426 \"inffast.S\"\n-ALIGN 4\n-L_do_loop:\n-; 437 \"inffast.S\"\n-\tcmp  bl,15\n-\tja   L_get_length_code\n-\n-\txor  eax,eax\n-\tlodsw\n-\tmov  cl,bl\n-\tadd  bl,16\n-\tshl  eax,cl\n-\tor  ebp,eax\n-\n-L_get_length_code:\n-\tmov  edx, [esp+0]\n-\tmov  ecx, [esp+8]\n-\tand  edx,ebp\n-\tmov  eax, [ecx+edx*4]\n-\n-L_dolen:\n-\n-\n-\n-\n-\n-\n-\tmov  cl,ah\n-\tsub  bl,ah\n-\tshr  ebp,cl\n-\n-\n-\n-\n-\n-\n-\ttest  al,al\n-\tjnz   L_test_for_length_base\n-\n-\tshr  eax,16\n-\tstosb\n-\n-L_while_test:\n-\n-\n-\tcmp  [esp+16],edi\n-\tjbe  L_break_loop\n-\n-\tcmp  [esp+20],esi\n-\tja   L_do_loop\n-\tjmp  L_break_loop\n-\n-L_test_for_length_base:\n-; 502 \"inffast.S\"\n-\tmov  edx,eax\n-\tshr  edx,16\n-\tmov  cl,al\n-\n-\ttest  al,16\n-\tjz   L_test_for_second_level_length\n-\tand  cl,15\n-\tjz   L_save_len\n-\tcmp  bl,cl\n-\tjae  L_add_bits_to_len\n-\n-\tmov  ch,cl\n-\txor  eax,eax\n-\tlodsw\n-\tmov  cl,bl\n-\tadd  bl,16\n-\tshl  eax,cl\n-\tor  ebp,eax\n-\tmov  cl,ch\n-\n-L_add_bits_to_len:\n-\tmov  eax,1\n-\tshl  eax,cl\n-\tdec  eax\n-\tsub  bl,cl\n-\tand  eax,ebp\n-\tshr  ebp,cl\n-\tadd  edx,eax\n-\n-L_save_len:\n-\tmov  [esp+24],edx\n-\n-\n-L_decode_distance:\n-; 549 \"inffast.S\"\n-\tcmp  bl,15\n-\tja   L_get_distance_code\n-\n-\txor  eax,eax\n-\tlodsw\n-\tmov  cl,bl\n-\tadd  bl,16\n-\tshl  eax,cl\n-\tor  ebp,eax\n-\n-L_get_distance_code:\n-\tmov  edx, [esp+4]\n-\tmov  ecx, [esp+12]\n-\tand  edx,ebp\n-\tmov  eax, [ecx+edx*4]\n-\n-\n-L_dodist:\n-\tmov  edx,eax\n-\tshr  edx,16\n-\tmov  cl,ah\n-\tsub  bl,ah\n-\tshr  ebp,cl\n-; 584 \"inffast.S\"\n-\tmov  cl,al\n-\n-\ttest  al,16\n-\tjz  L_test_for_second_level_dist\n-\tand  cl,15\n-\tjz  L_check_dist_one\n-\tcmp  bl,cl\n-\tjae  L_add_bits_to_dist\n-\n-\tmov  ch,cl\n-\txor  eax,eax\n-\tlodsw\n-\tmov  cl,bl\n-\tadd  bl,16\n-\tshl  eax,cl\n-\tor  ebp,eax\n-\tmov  cl,ch\n-\n-L_add_bits_to_dist:\n-\tmov  eax,1\n-\tshl  eax,cl\n-\tdec  eax\n-\tsub  bl,cl\n-\tand  eax,ebp\n-\tshr  ebp,cl\n-\tadd  edx,eax\n-\tjmp  L_check_window\n-\n-L_check_window:\n-; 625 \"inffast.S\"\n-\tmov  [esp+44],esi\n-\tmov  eax,edi\n-\tsub  eax, [esp+40]\n-\n-\tcmp  eax,edx\n-\tjb   L_clip_window\n-\n-\tmov  ecx, [esp+24]\n-\tmov  esi,edi\n-\tsub  esi,edx\n-\n-\tsub  ecx,3\n-\tmov  al, [esi]\n-\tmov  [edi],al\n-\tmov  al, [esi+1]\n-\tmov  dl, [esi+2]\n-\tadd  esi,3\n-\tmov  [edi+1],al\n-\tmov  [edi+2],dl\n-\tadd  edi,3\n-\trep movsb\n-\n-\tmov  esi, [esp+44]\n-\tjmp  L_while_test\n-\n-ALIGN 4\n-L_check_dist_one:\n-\tcmp  edx,1\n-\tjne  L_check_window\n-\tcmp  [esp+40],edi\n-\tje  L_check_window\n-\n-\tdec  edi\n-\tmov  ecx, [esp+24]\n-\tmov  al, [edi]\n-\tsub  ecx,3\n-\n-\tmov  [edi+1],al\n-\tmov  [edi+2],al\n-\tmov  [edi+3],al\n-\tadd  edi,4\n-\trep stosb\n-\n-\tjmp  L_while_test\n-\n-ALIGN 4\n-L_test_for_second_level_length:\n-\n-\n-\n-\n-\ttest  al,64\n-\tjnz   L_test_for_end_of_block\n-\n-\tmov  eax,1\n-\tshl  eax,cl\n-\tdec  eax\n-\tand  eax,ebp\n-\tadd  eax,edx\n-\tmov  edx, [esp+8]\n-\tmov  eax, [edx+eax*4]\n-\tjmp  L_dolen\n-\n-ALIGN 4\n-L_test_for_second_level_dist:\n-\n-\n-\n-\n-\ttest  al,64\n-\tjnz   L_invalid_distance_code\n-\n-\tmov  eax,1\n-\tshl  eax,cl\n-\tdec  eax\n-\tand  eax,ebp\n-\tadd  eax,edx\n-\tmov  edx, [esp+12]\n-\tmov  eax, [edx+eax*4]\n-\tjmp  L_dodist\n-\n-ALIGN 4\n-L_clip_window:\n-; 721 \"inffast.S\"\n-\tmov  ecx,eax\n-\tmov  eax, [esp+52]\n-\tneg  ecx\n-\tmov  esi, [esp+56]\n-\n-\tcmp  eax,edx\n-\tjb   L_invalid_distance_too_far\n-\n-\tadd  ecx,edx\n-\tcmp  dword ptr [esp+48],0\n-\tjne  L_wrap_around_window\n-\n-\tsub  eax,ecx\n-\tadd  esi,eax\n-; 749 \"inffast.S\"\n-\tmov  eax, [esp+24]\n-\tcmp  eax,ecx\n-\tjbe  L_do_copy1\n-\n-\tsub  eax,ecx\n-\trep movsb\n-\tmov  esi,edi\n-\tsub  esi,edx\n-\tjmp  L_do_copy1\n-\n-\tcmp  eax,ecx\n-\tjbe  L_do_copy1\n-\n-\tsub  eax,ecx\n-\trep movsb\n-\tmov  esi,edi\n-\tsub  esi,edx\n-\tjmp  L_do_copy1\n-\n-L_wrap_around_window:\n-; 793 \"inffast.S\"\n-\tmov  eax, [esp+48]\n-\tcmp  ecx,eax\n-\tjbe  L_contiguous_in_window\n-\n-\tadd  esi, [esp+52]\n-\tadd  esi,eax\n-\tsub  esi,ecx\n-\tsub  ecx,eax\n-\n-\n-\tmov  eax, [esp+24]\n-\tcmp  eax,ecx\n-\tjbe  L_do_copy1\n-\n-\tsub  eax,ecx\n-\trep movsb\n-\tmov  esi, [esp+56]\n-\tmov  ecx, [esp+48]\n-\tcmp  eax,ecx\n-\tjbe  L_do_copy1\n-\n-\tsub  eax,ecx\n-\trep movsb\n-\tmov  esi,edi\n-\tsub  esi,edx\n-\tjmp  L_do_copy1\n-\n-L_contiguous_in_window:\n-; 836 \"inffast.S\"\n-\tadd  esi,eax\n-\tsub  esi,ecx\n-\n-\n-\tmov  eax, [esp+24]\n-\tcmp  eax,ecx\n-\tjbe  L_do_copy1\n-\n-\tsub  eax,ecx\n-\trep movsb\n-\tmov  esi,edi\n-\tsub  esi,edx\n-\n-L_do_copy1:\n-; 862 \"inffast.S\"\n-\tmov  ecx,eax\n-\trep movsb\n-\n-\tmov  esi, [esp+44]\n-\tjmp  L_while_test\n-; 878 \"inffast.S\"\n-ALIGN 4\n-L_init_mmx:\n-\temms\n-\n-\n-\n-\n-\n-\tmovd mm0,ebp\n-\tmov  ebp,ebx\n-; 896 \"inffast.S\"\n-\tmovd mm4,[esp+0]\n-\tmovq mm3,mm4\n-\tmovd mm5,[esp+4]\n-\tmovq mm2,mm5\n-\tpxor mm1,mm1\n-\tmov  ebx, [esp+8]\n-\tjmp  L_do_loop_mmx\n-\n-ALIGN 4\n-L_do_loop_mmx:\n-\tpsrlq mm0,mm1\n-\n-\tcmp  ebp,32\n-\tja  L_get_length_code_mmx\n-\n-\tmovd mm6,ebp\n-\tmovd mm7,[esi]\n-\tadd  esi,4\n-\tpsllq mm7,mm6\n-\tadd  ebp,32\n-\tpor mm0,mm7\n-\n-L_get_length_code_mmx:\n-\tpand mm4,mm0\n-\tmovd eax,mm4\n-\tmovq mm4,mm3\n-\tmov  eax, [ebx+eax*4]\n-\n-L_dolen_mmx:\n-\tmovzx  ecx,ah\n-\tmovd mm1,ecx\n-\tsub  ebp,ecx\n-\n-\ttest  al,al\n-\tjnz L_test_for_length_base_mmx\n-\n-\tshr  eax,16\n-\tstosb\n-\n-L_while_test_mmx:\n-\n-\n-\tcmp  [esp+16],edi\n-\tjbe L_break_loop\n-\n-\tcmp  [esp+20],esi\n-\tja L_do_loop_mmx\n-\tjmp L_break_loop\n-\n-L_test_for_length_base_mmx:\n-\n-\tmov  edx,eax\n-\tshr  edx,16\n-\n-\ttest  al,16\n-\tjz  L_test_for_second_level_length_mmx\n-\tand  eax,15\n-\tjz L_decode_distance_mmx\n-\n-\tpsrlq mm0,mm1\n-\tmovd mm1,eax\n-\tmovd ecx,mm0\n-\tsub  ebp,eax\n-\tand  ecx, [inflate_fast_mask+eax*4]\n-\tadd  edx,ecx\n-\n-L_decode_distance_mmx:\n-\tpsrlq mm0,mm1\n-\n-\tcmp  ebp,32\n-\tja L_get_dist_code_mmx\n-\n-\tmovd mm6,ebp\n-\tmovd mm7,[esi]\n-\tadd  esi,4\n-\tpsllq mm7,mm6\n-\tadd  ebp,32\n-\tpor mm0,mm7\n-\n-L_get_dist_code_mmx:\n-\tmov  ebx, [esp+12]\n-\tpand mm5,mm0\n-\tmovd eax,mm5\n-\tmovq mm5,mm2\n-\tmov  eax, [ebx+eax*4]\n-\n-L_dodist_mmx:\n-\n-\tmovzx  ecx,ah\n-\tmov  ebx,eax\n-\tshr  ebx,16\n-\tsub  ebp,ecx\n-\tmovd mm1,ecx\n-\n-\ttest  al,16\n-\tjz L_test_for_second_level_dist_mmx\n-\tand  eax,15\n-\tjz L_check_dist_one_mmx\n-\n-L_add_bits_to_dist_mmx:\n-\tpsrlq mm0,mm1\n-\tmovd mm1,eax\n-\tmovd ecx,mm0\n-\tsub  ebp,eax\n-\tand  ecx, [inflate_fast_mask+eax*4]\n-\tadd  ebx,ecx\n-\n-L_check_window_mmx:\n-\tmov  [esp+44],esi\n-\tmov  eax,edi\n-\tsub  eax, [esp+40]\n-\n-\tcmp  eax,ebx\n-\tjb L_clip_window_mmx\n-\n-\tmov  ecx,edx\n-\tmov  esi,edi\n-\tsub  esi,ebx\n-\n-\tsub  ecx,3\n-\tmov  al, [esi]\n-\tmov  [edi],al\n-\tmov  al, [esi+1]\n-\tmov  dl, [esi+2]\n-\tadd  esi,3\n-\tmov  [edi+1],al\n-\tmov  [edi+2],dl\n-\tadd  edi,3\n-\trep movsb\n-\n-\tmov  esi, [esp+44]\n-\tmov  ebx, [esp+8]\n-\tjmp  L_while_test_mmx\n-\n-ALIGN 4\n-L_check_dist_one_mmx:\n-\tcmp  ebx,1\n-\tjne  L_check_window_mmx\n-\tcmp  [esp+40],edi\n-\tje   L_check_window_mmx\n-\n-\tdec  edi\n-\tmov  ecx,edx\n-\tmov  al, [edi]\n-\tsub  ecx,3\n-\n-\tmov  [edi+1],al\n-\tmov  [edi+2],al\n-\tmov  [edi+3],al\n-\tadd  edi,4\n-\trep stosb\n-\n-\tmov  ebx, [esp+8]\n-\tjmp  L_while_test_mmx\n-\n-ALIGN 4\n-L_test_for_second_level_length_mmx:\n-\ttest  al,64\n-\tjnz L_test_for_end_of_block\n-\n-\tand  eax,15\n-\tpsrlq mm0,mm1\n-\tmovd ecx,mm0\n-\tand  ecx, [inflate_fast_mask+eax*4]\n-\tadd  ecx,edx\n-\tmov  eax, [ebx+ecx*4]\n-\tjmp L_dolen_mmx\n-\n-ALIGN 4\n-L_test_for_second_level_dist_mmx:\n-\ttest  al,64\n-\tjnz L_invalid_distance_code\n-\n-\tand  eax,15\n-\tpsrlq mm0,mm1\n-\tmovd ecx,mm0\n-\tand  ecx, [inflate_fast_mask+eax*4]\n-\tmov  eax, [esp+12]\n-\tadd  ecx,ebx\n-\tmov  eax, [eax+ecx*4]\n-\tjmp  L_dodist_mmx\n-\n-ALIGN 4\n-L_clip_window_mmx:\n-\n-\tmov  ecx,eax\n-\tmov  eax, [esp+52]\n-\tneg  ecx\n-\tmov  esi, [esp+56]\n-\n-\tcmp  eax,ebx\n-\tjb  L_invalid_distance_too_far\n-\n-\tadd  ecx,ebx\n-\tcmp  dword ptr [esp+48],0\n-\tjne  L_wrap_around_window_mmx\n-\n-\tsub  eax,ecx\n-\tadd  esi,eax\n-\n-\tcmp  edx,ecx\n-\tjbe  L_do_copy1_mmx\n-\n-\tsub  edx,ecx\n-\trep movsb\n-\tmov  esi,edi\n-\tsub  esi,ebx\n-\tjmp  L_do_copy1_mmx\n-\n-\tcmp  edx,ecx\n-\tjbe  L_do_copy1_mmx\n-\n-\tsub  edx,ecx\n-\trep movsb\n-\tmov  esi,edi\n-\tsub  esi,ebx\n-\tjmp  L_do_copy1_mmx\n-\n-L_wrap_around_window_mmx:\n-\n-\tmov  eax, [esp+48]\n-\tcmp  ecx,eax\n-\tjbe  L_contiguous_in_window_mmx\n-\n-\tadd  esi, [esp+52]\n-\tadd  esi,eax\n-\tsub  esi,ecx\n-\tsub  ecx,eax\n-\n-\n-\tcmp  edx,ecx\n-\tjbe  L_do_copy1_mmx\n-\n-\tsub  edx,ecx\n-\trep movsb\n-\tmov  esi, [esp+56]\n-\tmov  ecx, [esp+48]\n-\tcmp  edx,ecx\n-\tjbe  L_do_copy1_mmx\n-\n-\tsub  edx,ecx\n-\trep movsb\n-\tmov  esi,edi\n-\tsub  esi,ebx\n-\tjmp  L_do_copy1_mmx\n-\n-L_contiguous_in_window_mmx:\n-\n-\tadd  esi,eax\n-\tsub  esi,ecx\n-\n-\n-\tcmp  edx,ecx\n-\tjbe  L_do_copy1_mmx\n-\n-\tsub  edx,ecx\n-\trep movsb\n-\tmov  esi,edi\n-\tsub  esi,ebx\n-\n-L_do_copy1_mmx:\n-\n-\n-\tmov  ecx,edx\n-\trep movsb\n-\n-\tmov  esi, [esp+44]\n-\tmov  ebx, [esp+8]\n-\tjmp  L_while_test_mmx\n-; 1174 \"inffast.S\"\n-L_invalid_distance_code:\n-\n-\n-\n-\n-\n-\tmov  ecx, invalid_distance_code_msg\n-\tmov  edx,26\n-\tjmp  L_update_stream_state\n-\n-L_test_for_end_of_block:\n-\n-\n-\n-\n-\n-\ttest  al,32\n-\tjz  L_invalid_literal_length_code\n-\n-\tmov  ecx,0\n-\tmov  edx,11\n-\tjmp  L_update_stream_state\n-\n-L_invalid_literal_length_code:\n-\n-\n-\n-\n-\n-\tmov  ecx, invalid_literal_length_code_msg\n-\tmov  edx,26\n-\tjmp  L_update_stream_state\n-\n-L_invalid_distance_too_far:\n-\n-\n-\n-\tmov  esi, [esp+44]\n-\tmov  ecx, invalid_distance_too_far_msg\n-\tmov  edx,26\n-\tjmp  L_update_stream_state\n-\n-L_update_stream_state:\n-\n-\tmov  eax, [esp+88]\n-\ttest  ecx,ecx\n-\tjz  L_skip_msg\n-\tmov  [eax+24],ecx\n-L_skip_msg:\n-\tmov  eax, [eax+28]\n-\tmov  [eax+mode_state],edx\n-\tjmp  L_break_loop\n-\n-ALIGN 4\n-L_break_loop:\n-; 1243 \"inffast.S\"\n-\tcmp  dword ptr [inflate_fast_use_mmx],2\n-\tjne  L_update_next_in\n-\n-\n-\n-\tmov  ebx,ebp\n-\n-L_update_next_in:\n-; 1266 \"inffast.S\"\n-\tmov  eax, [esp+88]\n-\tmov  ecx,ebx\n-\tmov  edx, [eax+28]\n-\tshr  ecx,3\n-\tsub  esi,ecx\n-\tshl  ecx,3\n-\tsub  ebx,ecx\n-\tmov  [eax+12],edi\n-\tmov  [edx+bits_state],ebx\n-\tmov  ecx,ebx\n-\n-\tlea  ebx, [esp+28]\n-\tcmp  [esp+20],ebx\n-\tjne  L_buf_not_used\n-\n-\tsub  esi,ebx\n-\tmov  ebx, [eax+0]\n-\tmov  [esp+20],ebx\n-\tadd  esi,ebx\n-\tmov  ebx, [eax+4]\n-\tsub  ebx,11\n-\tadd  [esp+20],ebx\n-\n-L_buf_not_used:\n-\tmov  [eax+0],esi\n-\n-\tmov  ebx,1\n-\tshl  ebx,cl\n-\tdec  ebx\n-\n-\n-\n-\n-\n-\tcmp  dword ptr [inflate_fast_use_mmx],2\n-\tjne  L_update_hold\n-\n-\n-\n-\tpsrlq mm0,mm1\n-\tmovd ebp,mm0\n-\n-\temms\n-\n-L_update_hold:\n-\n-\n-\n-\tand  ebp,ebx\n-\tmov  [edx+hold_state],ebp\n-\n-\n-\n-\n-\tmov  ebx, [esp+20]\n-\tcmp  ebx,esi\n-\tjbe  L_last_is_smaller\n-\n-\tsub  ebx,esi\n-\tadd  ebx,11\n-\tmov  [eax+4],ebx\n-\tjmp  L_fixup_out\n-L_last_is_smaller:\n-\tsub  esi,ebx\n-\tneg  esi\n-\tadd  esi,11\n-\tmov  [eax+4],esi\n-\n-\n-\n-\n-L_fixup_out:\n-\n-\tmov  ebx, [esp+16]\n-\tcmp  ebx,edi\n-\tjbe  L_end_is_smaller\n-\n-\tsub  ebx,edi\n-\tadd  ebx,257\n-\tmov  [eax+16],ebx\n-\tjmp  L_done\n-L_end_is_smaller:\n-\tsub  edi,ebx\n-\tneg  edi\n-\tadd  edi,257\n-\tmov  [eax+16],edi\n-\n-\n-\n-\n-\n-L_done:\n-\tadd  esp,64\n-\tpopfd\n-\tpop  ebx\n-\tpop  ebp\n-\tpop  esi\n-\tpop  edi\n-\tret\n-\n-\n-\n-\n-_TEXT\tends\n-end\n+;/* inffas32.asm is a hand tuned assembler version of inffast.c -- fast decoding\r\n+; *\r\n+; * inffas32.asm is derivated from inffas86.c, with translation of assembly code\r\n+; *\r\n+; * Copyright (C) 1995-2003 Mark Adler\r\n+; * For conditions of distribution and use, see copyright notice in zlib.h\r\n+; *\r\n+; * Copyright (C) 2003 Chris Anderson <christop@charm.net>\r\n+; * Please use the copyright conditions above.\r\n+; *\r\n+; * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from\r\n+; * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at\r\n+; * the moment.  I have successfully compiled and tested this code with gcc2.96,\r\n+; * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S\r\n+; * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX\r\n+; * enabled.  I will attempt to merge the MMX code into this version.  Newer\r\n+; * versions of this and inffast.S can be found at\r\n+; * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/\r\n+; * \r\n+; * 2005 : modification by Gilles Vollant\r\n+; */\r\n+; For Visual C++ 4.x and higher and ML 6.x and higher\r\n+;   ml.exe is in directory \\MASM611C of Win95 DDK\r\n+;   ml.exe is also distributed in http://www.masm32.com/masmdl.htm\r\n+;    and in VC++2003 toolkit at http://msdn.microsoft.com/visualc/vctoolkit2003/\r\n+;\r\n+;\r\n+;   compile with command line option\r\n+;   ml  /coff /Zi /c /Flinffas32.lst inffas32.asm\r\n+\r\n+;   if you define NO_GZIP (see inflate.h), compile with\r\n+;   ml  /coff /Zi /c /Flinffas32.lst /DNO_GUNZIP inffas32.asm\r\n+\r\n+\r\n+; zlib122sup is 0 fort zlib 1.2.2.1 and lower\r\n+; zlib122sup is 8 fort zlib 1.2.2.2 and more (with addition of dmax and head \r\n+;        in inflate_state in inflate.h)\r\n+zlib1222sup      equ    8\r\n+\r\n+\r\n+IFDEF GUNZIP\r\n+  INFLATE_MODE_TYPE    equ 11\r\n+  INFLATE_MODE_BAD     equ 26\r\n+ELSE\r\n+  IFNDEF NO_GUNZIP\r\n+    INFLATE_MODE_TYPE    equ 11\r\n+    INFLATE_MODE_BAD     equ 26\r\n+  ELSE\r\n+    INFLATE_MODE_TYPE    equ 3\r\n+    INFLATE_MODE_BAD     equ 17\r\n+  ENDIF\r\n+ENDIF\r\n+\r\n+\r\n+; 75 \"inffast.S\"\r\n+;FILE \"inffast.S\"\r\n+\r\n+;;;GLOBAL _inflate_fast\r\n+\r\n+;;;SECTION .text\r\n+\r\n+\r\n+\r\n+\t.586p\r\n+\t.mmx\r\n+\r\n+\tname\tinflate_fast_x86\r\n+\t.MODEL\tFLAT\r\n+\r\n+_DATA\t\t\tsegment\r\n+inflate_fast_use_mmx:\r\n+\tdd\t1\r\n+\r\n+\r\n+_TEXT\t\t\tsegment\r\n+PUBLIC _inflate_fast\r\n+\r\n+ALIGN 4\r\n+_inflate_fast:\r\n+\tjmp inflate_fast_entry\r\n+\r\n+\r\n+\r\n+ALIGN 4\r\n+\tdb\t'Fast decoding Code from Chris Anderson'\r\n+\tdb\t0\r\n+\r\n+ALIGN 4\r\n+invalid_literal_length_code_msg:\r\n+\tdb\t'invalid literal/length code'\r\n+\tdb\t0\r\n+\r\n+ALIGN 4\r\n+invalid_distance_code_msg:\r\n+\tdb\t'invalid distance code'\r\n+\tdb\t0\r\n+\r\n+ALIGN 4\r\n+invalid_distance_too_far_msg:\r\n+\tdb\t'invalid distance too far back'\r\n+\tdb\t0\r\n+\r\n+\r\n+ALIGN 4\r\n+inflate_fast_mask:\r\n+dd\t0\r\n+dd\t1\r\n+dd\t3\r\n+dd\t7\r\n+dd\t15\r\n+dd\t31\r\n+dd\t63\r\n+dd\t127\r\n+dd\t255\r\n+dd\t511\r\n+dd\t1023\r\n+dd\t2047\r\n+dd\t4095\r\n+dd\t8191\r\n+dd\t16383\r\n+dd\t32767\r\n+dd\t65535\r\n+dd\t131071\r\n+dd\t262143\r\n+dd\t524287\r\n+dd\t1048575\r\n+dd\t2097151\r\n+dd\t4194303\r\n+dd\t8388607\r\n+dd\t16777215\r\n+dd\t33554431\r\n+dd\t67108863\r\n+dd\t134217727\r\n+dd\t268435455\r\n+dd\t536870911\r\n+dd\t1073741823\r\n+dd\t2147483647\r\n+dd\t4294967295\r\n+\r\n+\r\n+mode_state\t equ\t0\t;/* state->mode\t*/\r\n+wsize_state\t equ\t(32+zlib1222sup)\t;/* state->wsize */\r\n+write_state\t equ\t(36+4+zlib1222sup)\t;/* state->write */\r\n+window_state\t equ\t(40+4+zlib1222sup)\t;/* state->window */\r\n+hold_state\t equ\t(44+4+zlib1222sup)\t;/* state->hold\t*/\r\n+bits_state\t equ\t(48+4+zlib1222sup)\t;/* state->bits\t*/\r\n+lencode_state\t equ\t(64+4+zlib1222sup)\t;/* state->lencode */\r\n+distcode_state\t equ\t(68+4+zlib1222sup)\t;/* state->distcode */\r\n+lenbits_state\t equ\t(72+4+zlib1222sup)\t;/* state->lenbits */\r\n+distbits_state\t equ\t(76+4+zlib1222sup)\t;/* state->distbits */\r\n+\r\n+\r\n+;;SECTION .text\r\n+; 205 \"inffast.S\"\r\n+;GLOBAL\tinflate_fast_use_mmx\r\n+\r\n+;SECTION .data\r\n+\r\n+\r\n+; GLOBAL inflate_fast_use_mmx:object\r\n+;.size inflate_fast_use_mmx, 4\r\n+; 226 \"inffast.S\"\r\n+;SECTION .text\r\n+\r\n+ALIGN 4\r\n+inflate_fast_entry:\r\n+\tpush  edi\r\n+\tpush  esi\r\n+\tpush  ebp\r\n+\tpush  ebx\r\n+\tpushfd\r\n+\tsub  esp,64\r\n+\tcld\r\n+\r\n+\r\n+\r\n+\r\n+\tmov  esi, [esp+88]\r\n+\tmov  edi, [esi+28]\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\tmov  edx, [esi+4]\r\n+\tmov  eax, [esi+0]\r\n+\r\n+\tadd  edx,eax\r\n+\tsub  edx,11\r\n+\r\n+\tmov  [esp+44],eax\r\n+\tmov  [esp+20],edx\r\n+\r\n+\tmov  ebp, [esp+92]\r\n+\tmov  ecx, [esi+16]\r\n+\tmov  ebx, [esi+12]\r\n+\r\n+\tsub  ebp,ecx\r\n+\tneg  ebp\r\n+\tadd  ebp,ebx\r\n+\r\n+\tsub  ecx,257\r\n+\tadd  ecx,ebx\r\n+\r\n+\tmov  [esp+60],ebx\r\n+\tmov  [esp+40],ebp\r\n+\tmov  [esp+16],ecx\r\n+; 285 \"inffast.S\"\r\n+\tmov  eax, [edi+lencode_state]\r\n+\tmov  ecx, [edi+distcode_state]\r\n+\r\n+\tmov  [esp+8],eax\r\n+\tmov  [esp+12],ecx\r\n+\r\n+\tmov  eax,1\r\n+\tmov  ecx, [edi+lenbits_state]\r\n+\tshl  eax,cl\r\n+\tdec  eax\r\n+\tmov  [esp+0],eax\r\n+\r\n+\tmov  eax,1\r\n+\tmov  ecx, [edi+distbits_state]\r\n+\tshl  eax,cl\r\n+\tdec  eax\r\n+\tmov  [esp+4],eax\r\n+\r\n+\tmov  eax, [edi+wsize_state]\r\n+\tmov  ecx, [edi+write_state]\r\n+\tmov  edx, [edi+window_state]\r\n+\r\n+\tmov  [esp+52],eax\r\n+\tmov  [esp+48],ecx\r\n+\tmov  [esp+56],edx\r\n+\r\n+\tmov  ebp, [edi+hold_state]\r\n+\tmov  ebx, [edi+bits_state]\r\n+; 321 \"inffast.S\"\r\n+\tmov  esi, [esp+44]\r\n+\tmov  ecx, [esp+20]\r\n+\tcmp  ecx,esi\r\n+\tja   L_align_long\r\n+\r\n+\tadd  ecx,11\r\n+\tsub  ecx,esi\r\n+\tmov  eax,12\r\n+\tsub  eax,ecx\r\n+\tlea  edi, [esp+28]\r\n+\trep movsb\r\n+\tmov  ecx,eax\r\n+\txor  eax,eax\r\n+\trep stosb\r\n+\tlea  esi, [esp+28]\r\n+\tmov  [esp+20],esi\r\n+\tjmp  L_is_aligned\r\n+\r\n+\r\n+L_align_long:\r\n+\ttest  esi,3\r\n+\tjz   L_is_aligned\r\n+\txor  eax,eax\r\n+\tmov  al, [esi]\r\n+\tinc  esi\r\n+\tmov  ecx,ebx\r\n+\tadd  ebx,8\r\n+\tshl  eax,cl\r\n+\tor  ebp,eax\r\n+\tjmp L_align_long\r\n+\r\n+L_is_aligned:\r\n+\tmov  edi, [esp+60]\r\n+; 366 \"inffast.S\"\r\n+L_check_mmx:\r\n+\tcmp  dword ptr [inflate_fast_use_mmx],2\r\n+\tje   L_init_mmx\r\n+\tja   L_do_loop\r\n+\r\n+\tpush  eax\r\n+\tpush  ebx\r\n+\tpush  ecx\r\n+\tpush  edx\r\n+\tpushfd\r\n+\tmov  eax, [esp]\r\n+\txor  dword ptr [esp],0200000h\r\n+\r\n+\r\n+\r\n+\r\n+\tpopfd\r\n+\tpushfd\r\n+\tpop  edx\r\n+\txor  edx,eax\r\n+\tjz   L_dont_use_mmx\r\n+\txor  eax,eax\r\n+\tcpuid\r\n+\tcmp  ebx,0756e6547h\r\n+\tjne  L_dont_use_mmx\r\n+\tcmp  ecx,06c65746eh\r\n+\tjne  L_dont_use_mmx\r\n+\tcmp  edx,049656e69h\r\n+\tjne  L_dont_use_mmx\r\n+\tmov  eax,1\r\n+\tcpuid\r\n+\tshr  eax,8\r\n+\tand  eax,15\r\n+\tcmp  eax,6\r\n+\tjne  L_dont_use_mmx\r\n+\ttest  edx,0800000h\r\n+\tjnz  L_use_mmx\r\n+\tjmp  L_dont_use_mmx\r\n+L_use_mmx:\r\n+\tmov  dword ptr [inflate_fast_use_mmx],2\r\n+\tjmp  L_check_mmx_pop\r\n+L_dont_use_mmx:\r\n+\tmov  dword ptr [inflate_fast_use_mmx],3\r\n+L_check_mmx_pop:\r\n+\tpop  edx\r\n+\tpop  ecx\r\n+\tpop  ebx\r\n+\tpop  eax\r\n+\tjmp  L_check_mmx\r\n+; 426 \"inffast.S\"\r\n+ALIGN 4\r\n+L_do_loop:\r\n+; 437 \"inffast.S\"\r\n+\tcmp  bl,15\r\n+\tja   L_get_length_code\r\n+\r\n+\txor  eax,eax\r\n+\tlodsw\r\n+\tmov  cl,bl\r\n+\tadd  bl,16\r\n+\tshl  eax,cl\r\n+\tor  ebp,eax\r\n+\r\n+L_get_length_code:\r\n+\tmov  edx, [esp+0]\r\n+\tmov  ecx, [esp+8]\r\n+\tand  edx,ebp\r\n+\tmov  eax, [ecx+edx*4]\r\n+\r\n+L_dolen:\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\tmov  cl,ah\r\n+\tsub  bl,ah\r\n+\tshr  ebp,cl\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\ttest  al,al\r\n+\tjnz   L_test_for_length_base\r\n+\r\n+\tshr  eax,16\r\n+\tstosb\r\n+\r\n+L_while_test:\r\n+\r\n+\r\n+\tcmp  [esp+16],edi\r\n+\tjbe  L_break_loop\r\n+\r\n+\tcmp  [esp+20],esi\r\n+\tja   L_do_loop\r\n+\tjmp  L_break_loop\r\n+\r\n+L_test_for_length_base:\r\n+; 502 \"inffast.S\"\r\n+\tmov  edx,eax\r\n+\tshr  edx,16\r\n+\tmov  cl,al\r\n+\r\n+\ttest  al,16\r\n+\tjz   L_test_for_second_level_length\r\n+\tand  cl,15\r\n+\tjz   L_save_len\r\n+\tcmp  bl,cl\r\n+\tjae  L_add_bits_to_len\r\n+\r\n+\tmov  ch,cl\r\n+\txor  eax,eax\r\n+\tlodsw\r\n+\tmov  cl,bl\r\n+\tadd  bl,16\r\n+\tshl  eax,cl\r\n+\tor  ebp,eax\r\n+\tmov  cl,ch\r\n+\r\n+L_add_bits_to_len:\r\n+\tmov  eax,1\r\n+\tshl  eax,cl\r\n+\tdec  eax\r\n+\tsub  bl,cl\r\n+\tand  eax,ebp\r\n+\tshr  ebp,cl\r\n+\tadd  edx,eax\r\n+\r\n+L_save_len:\r\n+\tmov  [esp+24],edx\r\n+\r\n+\r\n+L_decode_distance:\r\n+; 549 \"inffast.S\"\r\n+\tcmp  bl,15\r\n+\tja   L_get_distance_code\r\n+\r\n+\txor  eax,eax\r\n+\tlodsw\r\n+\tmov  cl,bl\r\n+\tadd  bl,16\r\n+\tshl  eax,cl\r\n+\tor  ebp,eax\r\n+\r\n+L_get_distance_code:\r\n+\tmov  edx, [esp+4]\r\n+\tmov  ecx, [esp+12]\r\n+\tand  edx,ebp\r\n+\tmov  eax, [ecx+edx*4]\r\n+\r\n+\r\n+L_dodist:\r\n+\tmov  edx,eax\r\n+\tshr  edx,16\r\n+\tmov  cl,ah\r\n+\tsub  bl,ah\r\n+\tshr  ebp,cl\r\n+; 584 \"inffast.S\"\r\n+\tmov  cl,al\r\n+\r\n+\ttest  al,16\r\n+\tjz  L_test_for_second_level_dist\r\n+\tand  cl,15\r\n+\tjz  L_check_dist_one\r\n+\tcmp  bl,cl\r\n+\tjae  L_add_bits_to_dist\r\n+\r\n+\tmov  ch,cl\r\n+\txor  eax,eax\r\n+\tlodsw\r\n+\tmov  cl,bl\r\n+\tadd  bl,16\r\n+\tshl  eax,cl\r\n+\tor  ebp,eax\r\n+\tmov  cl,ch\r\n+\r\n+L_add_bits_to_dist:\r\n+\tmov  eax,1\r\n+\tshl  eax,cl\r\n+\tdec  eax\r\n+\tsub  bl,cl\r\n+\tand  eax,ebp\r\n+\tshr  ebp,cl\r\n+\tadd  edx,eax\r\n+\tjmp  L_check_window\r\n+\r\n+L_check_window:\r\n+; 625 \"inffast.S\"\r\n+\tmov  [esp+44],esi\r\n+\tmov  eax,edi\r\n+\tsub  eax, [esp+40]\r\n+\r\n+\tcmp  eax,edx\r\n+\tjb   L_clip_window\r\n+\r\n+\tmov  ecx, [esp+24]\r\n+\tmov  esi,edi\r\n+\tsub  esi,edx\r\n+\r\n+\tsub  ecx,3\r\n+\tmov  al, [esi]\r\n+\tmov  [edi],al\r\n+\tmov  al, [esi+1]\r\n+\tmov  dl, [esi+2]\r\n+\tadd  esi,3\r\n+\tmov  [edi+1],al\r\n+\tmov  [edi+2],dl\r\n+\tadd  edi,3\r\n+\trep movsb\r\n+\r\n+\tmov  esi, [esp+44]\r\n+\tjmp  L_while_test\r\n+\r\n+ALIGN 4\r\n+L_check_dist_one:\r\n+\tcmp  edx,1\r\n+\tjne  L_check_window\r\n+\tcmp  [esp+40],edi\r\n+\tje  L_check_window\r\n+\r\n+\tdec  edi\r\n+\tmov  ecx, [esp+24]\r\n+\tmov  al, [edi]\r\n+\tsub  ecx,3\r\n+\r\n+\tmov  [edi+1],al\r\n+\tmov  [edi+2],al\r\n+\tmov  [edi+3],al\r\n+\tadd  edi,4\r\n+\trep stosb\r\n+\r\n+\tjmp  L_while_test\r\n+\r\n+ALIGN 4\r\n+L_test_for_second_level_length:\r\n+\r\n+\r\n+\r\n+\r\n+\ttest  al,64\r\n+\tjnz   L_test_for_end_of_block\r\n+\r\n+\tmov  eax,1\r\n+\tshl  eax,cl\r\n+\tdec  eax\r\n+\tand  eax,ebp\r\n+\tadd  eax,edx\r\n+\tmov  edx, [esp+8]\r\n+\tmov  eax, [edx+eax*4]\r\n+\tjmp  L_dolen\r\n+\r\n+ALIGN 4\r\n+L_test_for_second_level_dist:\r\n+\r\n+\r\n+\r\n+\r\n+\ttest  al,64\r\n+\tjnz   L_invalid_distance_code\r\n+\r\n+\tmov  eax,1\r\n+\tshl  eax,cl\r\n+\tdec  eax\r\n+\tand  eax,ebp\r\n+\tadd  eax,edx\r\n+\tmov  edx, [esp+12]\r\n+\tmov  eax, [edx+eax*4]\r\n+\tjmp  L_dodist\r\n+\r\n+ALIGN 4\r\n+L_clip_window:\r\n+; 721 \"inffast.S\"\r\n+\tmov  ecx,eax\r\n+\tmov  eax, [esp+52]\r\n+\tneg  ecx\r\n+\tmov  esi, [esp+56]\r\n+\r\n+\tcmp  eax,edx\r\n+\tjb   L_invalid_distance_too_far\r\n+\r\n+\tadd  ecx,edx\r\n+\tcmp  dword ptr [esp+48],0\r\n+\tjne  L_wrap_around_window\r\n+\r\n+\tsub  eax,ecx\r\n+\tadd  esi,eax\r\n+; 749 \"inffast.S\"\r\n+\tmov  eax, [esp+24]\r\n+\tcmp  eax,ecx\r\n+\tjbe  L_do_copy1\r\n+\r\n+\tsub  eax,ecx\r\n+\trep movsb\r\n+\tmov  esi,edi\r\n+\tsub  esi,edx\r\n+\tjmp  L_do_copy1\r\n+\r\n+\tcmp  eax,ecx\r\n+\tjbe  L_do_copy1\r\n+\r\n+\tsub  eax,ecx\r\n+\trep movsb\r\n+\tmov  esi,edi\r\n+\tsub  esi,edx\r\n+\tjmp  L_do_copy1\r\n+\r\n+L_wrap_around_window:\r\n+; 793 \"inffast.S\"\r\n+\tmov  eax, [esp+48]\r\n+\tcmp  ecx,eax\r\n+\tjbe  L_contiguous_in_window\r\n+\r\n+\tadd  esi, [esp+52]\r\n+\tadd  esi,eax\r\n+\tsub  esi,ecx\r\n+\tsub  ecx,eax\r\n+\r\n+\r\n+\tmov  eax, [esp+24]\r\n+\tcmp  eax,ecx\r\n+\tjbe  L_do_copy1\r\n+\r\n+\tsub  eax,ecx\r\n+\trep movsb\r\n+\tmov  esi, [esp+56]\r\n+\tmov  ecx, [esp+48]\r\n+\tcmp  eax,ecx\r\n+\tjbe  L_do_copy1\r\n+\r\n+\tsub  eax,ecx\r\n+\trep movsb\r\n+\tmov  esi,edi\r\n+\tsub  esi,edx\r\n+\tjmp  L_do_copy1\r\n+\r\n+L_contiguous_in_window:\r\n+; 836 \"inffast.S\"\r\n+\tadd  esi,eax\r\n+\tsub  esi,ecx\r\n+\r\n+\r\n+\tmov  eax, [esp+24]\r\n+\tcmp  eax,ecx\r\n+\tjbe  L_do_copy1\r\n+\r\n+\tsub  eax,ecx\r\n+\trep movsb\r\n+\tmov  esi,edi\r\n+\tsub  esi,edx\r\n+\r\n+L_do_copy1:\r\n+; 862 \"inffast.S\"\r\n+\tmov  ecx,eax\r\n+\trep movsb\r\n+\r\n+\tmov  esi, [esp+44]\r\n+\tjmp  L_while_test\r\n+; 878 \"inffast.S\"\r\n+ALIGN 4\r\n+L_init_mmx:\r\n+\temms\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\tmovd mm0,ebp\r\n+\tmov  ebp,ebx\r\n+; 896 \"inffast.S\"\r\n+\tmovd mm4,[esp+0]\r\n+\tmovq mm3,mm4\r\n+\tmovd mm5,[esp+4]\r\n+\tmovq mm2,mm5\r\n+\tpxor mm1,mm1\r\n+\tmov  ebx, [esp+8]\r\n+\tjmp  L_do_loop_mmx\r\n+\r\n+ALIGN 4\r\n+L_do_loop_mmx:\r\n+\tpsrlq mm0,mm1\r\n+\r\n+\tcmp  ebp,32\r\n+\tja  L_get_length_code_mmx\r\n+\r\n+\tmovd mm6,ebp\r\n+\tmovd mm7,[esi]\r\n+\tadd  esi,4\r\n+\tpsllq mm7,mm6\r\n+\tadd  ebp,32\r\n+\tpor mm0,mm7\r\n+\r\n+L_get_length_code_mmx:\r\n+\tpand mm4,mm0\r\n+\tmovd eax,mm4\r\n+\tmovq mm4,mm3\r\n+\tmov  eax, [ebx+eax*4]\r\n+\r\n+L_dolen_mmx:\r\n+\tmovzx  ecx,ah\r\n+\tmovd mm1,ecx\r\n+\tsub  ebp,ecx\r\n+\r\n+\ttest  al,al\r\n+\tjnz L_test_for_length_base_mmx\r\n+\r\n+\tshr  eax,16\r\n+\tstosb\r\n+\r\n+L_while_test_mmx:\r\n+\r\n+\r\n+\tcmp  [esp+16],edi\r\n+\tjbe L_break_loop\r\n+\r\n+\tcmp  [esp+20],esi\r\n+\tja L_do_loop_mmx\r\n+\tjmp L_break_loop\r\n+\r\n+L_test_for_length_base_mmx:\r\n+\r\n+\tmov  edx,eax\r\n+\tshr  edx,16\r\n+\r\n+\ttest  al,16\r\n+\tjz  L_test_for_second_level_length_mmx\r\n+\tand  eax,15\r\n+\tjz L_decode_distance_mmx\r\n+\r\n+\tpsrlq mm0,mm1\r\n+\tmovd mm1,eax\r\n+\tmovd ecx,mm0\r\n+\tsub  ebp,eax\r\n+\tand  ecx, [inflate_fast_mask+eax*4]\r\n+\tadd  edx,ecx\r\n+\r\n+L_decode_distance_mmx:\r\n+\tpsrlq mm0,mm1\r\n+\r\n+\tcmp  ebp,32\r\n+\tja L_get_dist_code_mmx\r\n+\r\n+\tmovd mm6,ebp\r\n+\tmovd mm7,[esi]\r\n+\tadd  esi,4\r\n+\tpsllq mm7,mm6\r\n+\tadd  ebp,32\r\n+\tpor mm0,mm7\r\n+\r\n+L_get_dist_code_mmx:\r\n+\tmov  ebx, [esp+12]\r\n+\tpand mm5,mm0\r\n+\tmovd eax,mm5\r\n+\tmovq mm5,mm2\r\n+\tmov  eax, [ebx+eax*4]\r\n+\r\n+L_dodist_mmx:\r\n+\r\n+\tmovzx  ecx,ah\r\n+\tmov  ebx,eax\r\n+\tshr  ebx,16\r\n+\tsub  ebp,ecx\r\n+\tmovd mm1,ecx\r\n+\r\n+\ttest  al,16\r\n+\tjz L_test_for_second_level_dist_mmx\r\n+\tand  eax,15\r\n+\tjz L_check_dist_one_mmx\r\n+\r\n+L_add_bits_to_dist_mmx:\r\n+\tpsrlq mm0,mm1\r\n+\tmovd mm1,eax\r\n+\tmovd ecx,mm0\r\n+\tsub  ebp,eax\r\n+\tand  ecx, [inflate_fast_mask+eax*4]\r\n+\tadd  ebx,ecx\r\n+\r\n+L_check_window_mmx:\r\n+\tmov  [esp+44],esi\r\n+\tmov  eax,edi\r\n+\tsub  eax, [esp+40]\r\n+\r\n+\tcmp  eax,ebx\r\n+\tjb L_clip_window_mmx\r\n+\r\n+\tmov  ecx,edx\r\n+\tmov  esi,edi\r\n+\tsub  esi,ebx\r\n+\r\n+\tsub  ecx,3\r\n+\tmov  al, [esi]\r\n+\tmov  [edi],al\r\n+\tmov  al, [esi+1]\r\n+\tmov  dl, [esi+2]\r\n+\tadd  esi,3\r\n+\tmov  [edi+1],al\r\n+\tmov  [edi+2],dl\r\n+\tadd  edi,3\r\n+\trep movsb\r\n+\r\n+\tmov  esi, [esp+44]\r\n+\tmov  ebx, [esp+8]\r\n+\tjmp  L_while_test_mmx\r\n+\r\n+ALIGN 4\r\n+L_check_dist_one_mmx:\r\n+\tcmp  ebx,1\r\n+\tjne  L_check_window_mmx\r\n+\tcmp  [esp+40],edi\r\n+\tje   L_check_window_mmx\r\n+\r\n+\tdec  edi\r\n+\tmov  ecx,edx\r\n+\tmov  al, [edi]\r\n+\tsub  ecx,3\r\n+\r\n+\tmov  [edi+1],al\r\n+\tmov  [edi+2],al\r\n+\tmov  [edi+3],al\r\n+\tadd  edi,4\r\n+\trep stosb\r\n+\r\n+\tmov  ebx, [esp+8]\r\n+\tjmp  L_while_test_mmx\r\n+\r\n+ALIGN 4\r\n+L_test_for_second_level_length_mmx:\r\n+\ttest  al,64\r\n+\tjnz L_test_for_end_of_block\r\n+\r\n+\tand  eax,15\r\n+\tpsrlq mm0,mm1\r\n+\tmovd ecx,mm0\r\n+\tand  ecx, [inflate_fast_mask+eax*4]\r\n+\tadd  ecx,edx\r\n+\tmov  eax, [ebx+ecx*4]\r\n+\tjmp L_dolen_mmx\r\n+\r\n+ALIGN 4\r\n+L_test_for_second_level_dist_mmx:\r\n+\ttest  al,64\r\n+\tjnz L_invalid_distance_code\r\n+\r\n+\tand  eax,15\r\n+\tpsrlq mm0,mm1\r\n+\tmovd ecx,mm0\r\n+\tand  ecx, [inflate_fast_mask+eax*4]\r\n+\tmov  eax, [esp+12]\r\n+\tadd  ecx,ebx\r\n+\tmov  eax, [eax+ecx*4]\r\n+\tjmp  L_dodist_mmx\r\n+\r\n+ALIGN 4\r\n+L_clip_window_mmx:\r\n+\r\n+\tmov  ecx,eax\r\n+\tmov  eax, [esp+52]\r\n+\tneg  ecx\r\n+\tmov  esi, [esp+56]\r\n+\r\n+\tcmp  eax,ebx\r\n+\tjb  L_invalid_distance_too_far\r\n+\r\n+\tadd  ecx,ebx\r\n+\tcmp  dword ptr [esp+48],0\r\n+\tjne  L_wrap_around_window_mmx\r\n+\r\n+\tsub  eax,ecx\r\n+\tadd  esi,eax\r\n+\r\n+\tcmp  edx,ecx\r\n+\tjbe  L_do_copy1_mmx\r\n+\r\n+\tsub  edx,ecx\r\n+\trep movsb\r\n+\tmov  esi,edi\r\n+\tsub  esi,ebx\r\n+\tjmp  L_do_copy1_mmx\r\n+\r\n+\tcmp  edx,ecx\r\n+\tjbe  L_do_copy1_mmx\r\n+\r\n+\tsub  edx,ecx\r\n+\trep movsb\r\n+\tmov  esi,edi\r\n+\tsub  esi,ebx\r\n+\tjmp  L_do_copy1_mmx\r\n+\r\n+L_wrap_around_window_mmx:\r\n+\r\n+\tmov  eax, [esp+48]\r\n+\tcmp  ecx,eax\r\n+\tjbe  L_contiguous_in_window_mmx\r\n+\r\n+\tadd  esi, [esp+52]\r\n+\tadd  esi,eax\r\n+\tsub  esi,ecx\r\n+\tsub  ecx,eax\r\n+\r\n+\r\n+\tcmp  edx,ecx\r\n+\tjbe  L_do_copy1_mmx\r\n+\r\n+\tsub  edx,ecx\r\n+\trep movsb\r\n+\tmov  esi, [esp+56]\r\n+\tmov  ecx, [esp+48]\r\n+\tcmp  edx,ecx\r\n+\tjbe  L_do_copy1_mmx\r\n+\r\n+\tsub  edx,ecx\r\n+\trep movsb\r\n+\tmov  esi,edi\r\n+\tsub  esi,ebx\r\n+\tjmp  L_do_copy1_mmx\r\n+\r\n+L_contiguous_in_window_mmx:\r\n+\r\n+\tadd  esi,eax\r\n+\tsub  esi,ecx\r\n+\r\n+\r\n+\tcmp  edx,ecx\r\n+\tjbe  L_do_copy1_mmx\r\n+\r\n+\tsub  edx,ecx\r\n+\trep movsb\r\n+\tmov  esi,edi\r\n+\tsub  esi,ebx\r\n+\r\n+L_do_copy1_mmx:\r\n+\r\n+\r\n+\tmov  ecx,edx\r\n+\trep movsb\r\n+\r\n+\tmov  esi, [esp+44]\r\n+\tmov  ebx, [esp+8]\r\n+\tjmp  L_while_test_mmx\r\n+; 1174 \"inffast.S\"\r\n+L_invalid_distance_code:\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\tmov  ecx, invalid_distance_code_msg\r\n+\tmov  edx,INFLATE_MODE_BAD\r\n+\tjmp  L_update_stream_state\r\n+\r\n+L_test_for_end_of_block:\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\ttest  al,32\r\n+\tjz  L_invalid_literal_length_code\r\n+\r\n+\tmov  ecx,0\r\n+\tmov  edx,INFLATE_MODE_TYPE\r\n+\tjmp  L_update_stream_state\r\n+\r\n+L_invalid_literal_length_code:\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\tmov  ecx, invalid_literal_length_code_msg\r\n+\tmov  edx,INFLATE_MODE_BAD\r\n+\tjmp  L_update_stream_state\r\n+\r\n+L_invalid_distance_too_far:\r\n+\r\n+\r\n+\r\n+\tmov  esi, [esp+44]\r\n+\tmov  ecx, invalid_distance_too_far_msg\r\n+\tmov  edx,INFLATE_MODE_BAD\r\n+\tjmp  L_update_stream_state\r\n+\r\n+L_update_stream_state:\r\n+\r\n+\tmov  eax, [esp+88]\r\n+\ttest  ecx,ecx\r\n+\tjz  L_skip_msg\r\n+\tmov  [eax+24],ecx\r\n+L_skip_msg:\r\n+\tmov  eax, [eax+28]\r\n+\tmov  [eax+mode_state],edx\r\n+\tjmp  L_break_loop\r\n+\r\n+ALIGN 4\r\n+L_break_loop:\r\n+; 1243 \"inffast.S\"\r\n+\tcmp  dword ptr [inflate_fast_use_mmx],2\r\n+\tjne  L_update_next_in\r\n+\r\n+\r\n+\r\n+\tmov  ebx,ebp\r\n+\r\n+L_update_next_in:\r\n+; 1266 \"inffast.S\"\r\n+\tmov  eax, [esp+88]\r\n+\tmov  ecx,ebx\r\n+\tmov  edx, [eax+28]\r\n+\tshr  ecx,3\r\n+\tsub  esi,ecx\r\n+\tshl  ecx,3\r\n+\tsub  ebx,ecx\r\n+\tmov  [eax+12],edi\r\n+\tmov  [edx+bits_state],ebx\r\n+\tmov  ecx,ebx\r\n+\r\n+\tlea  ebx, [esp+28]\r\n+\tcmp  [esp+20],ebx\r\n+\tjne  L_buf_not_used\r\n+\r\n+\tsub  esi,ebx\r\n+\tmov  ebx, [eax+0]\r\n+\tmov  [esp+20],ebx\r\n+\tadd  esi,ebx\r\n+\tmov  ebx, [eax+4]\r\n+\tsub  ebx,11\r\n+\tadd  [esp+20],ebx\r\n+\r\n+L_buf_not_used:\r\n+\tmov  [eax+0],esi\r\n+\r\n+\tmov  ebx,1\r\n+\tshl  ebx,cl\r\n+\tdec  ebx\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\tcmp  dword ptr [inflate_fast_use_mmx],2\r\n+\tjne  L_update_hold\r\n+\r\n+\r\n+\r\n+\tpsrlq mm0,mm1\r\n+\tmovd ebp,mm0\r\n+\r\n+\temms\r\n+\r\n+L_update_hold:\r\n+\r\n+\r\n+\r\n+\tand  ebp,ebx\r\n+\tmov  [edx+hold_state],ebp\r\n+\r\n+\r\n+\r\n+\r\n+\tmov  ebx, [esp+20]\r\n+\tcmp  ebx,esi\r\n+\tjbe  L_last_is_smaller\r\n+\r\n+\tsub  ebx,esi\r\n+\tadd  ebx,11\r\n+\tmov  [eax+4],ebx\r\n+\tjmp  L_fixup_out\r\n+L_last_is_smaller:\r\n+\tsub  esi,ebx\r\n+\tneg  esi\r\n+\tadd  esi,11\r\n+\tmov  [eax+4],esi\r\n+\r\n+\r\n+\r\n+\r\n+L_fixup_out:\r\n+\r\n+\tmov  ebx, [esp+16]\r\n+\tcmp  ebx,edi\r\n+\tjbe  L_end_is_smaller\r\n+\r\n+\tsub  ebx,edi\r\n+\tadd  ebx,257\r\n+\tmov  [eax+16],ebx\r\n+\tjmp  L_done\r\n+L_end_is_smaller:\r\n+\tsub  edi,ebx\r\n+\tneg  edi\r\n+\tadd  edi,257\r\n+\tmov  [eax+16],edi\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+L_done:\r\n+\tadd  esp,64\r\n+\tpopfd\r\n+\tpop  ebx\r\n+\tpop  ebp\r\n+\tpop  esi\r\n+\tpop  edi\r\n+\tret\r\n+\r\n+_TEXT\tends\r\n+end\r"}, {"sha": "70a51f83777641741e14cda729a41c90d5dcc8fc", "filename": "zlib/contrib/masmx86/mkasm.bat", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fmasmx86%2Fmkasm.bat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fmasmx86%2Fmkasm.bat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Fmkasm.bat?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,3 +1,3 @@\n-cl /I..\\.. /O2 /c gvmat32c.c\r\n+cl /DASMV /I..\\.. /O2 /c gvmat32c.c\r\n ml /coff /Zi /c /Flgvmat32.lst gvmat32.asm\r\n ml /coff /Zi /c /Flinffas32.lst inffas32.asm\r"}, {"sha": "622f4bc2ec45de7c2916f64c22b7bfbc203f8809", "filename": "zlib/contrib/minizip/crypt.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fminizip%2Fcrypt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fminizip%2Fcrypt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fcrypt.h?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,9 +1,9 @@\n /* crypt.h -- base code for crypt/uncrypt ZIPfile\n \n \n-   Version 1.00, September 10th, 2003\n+   Version 1.01e, February 12th, 2005\n \n-   Copyright (C) 1998-2003 Gilles Vollant\n+   Copyright (C) 1998-2005 Gilles Vollant\n \n    This code is a modified version of crypting code in Infozip distribution\n "}, {"sha": "f1bee23e64b09d87dfc30285fdc1a0cf0051ca03", "filename": "zlib/contrib/minizip/ioapi.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fminizip%2Fioapi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fminizip%2Fioapi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fioapi.c?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,9 +1,9 @@\n /* ioapi.c -- IO base function header for compress/uncompress .zip\n    files using zlib + zip or unzip API\n \n-   Version 1.00, September 10th, 2003\n+   Version 1.01e, February 12th, 2005\n \n-   Copyright (C) 1998-2003 Gilles Vollant\n+   Copyright (C) 1998-2005 Gilles Vollant\n */\n \n #include <stdio.h>\n@@ -94,7 +94,7 @@ uLong ZCALLBACK fread_file_func (opaque, stream, buf, size)\n    uLong size;\n {\n     uLong ret;\n-    ret = fread(buf, 1, (size_t)size, (FILE *)stream);\n+    ret = (uLong)fread(buf, 1, (size_t)size, (FILE *)stream);\n     return ret;\n }\n \n@@ -106,7 +106,7 @@ uLong ZCALLBACK fwrite_file_func (opaque, stream, buf, size)\n    uLong size;\n {\n     uLong ret;\n-    ret = fwrite(buf, 1, (size_t)size, (FILE *)stream);\n+    ret = (uLong)fwrite(buf, 1, (size_t)size, (FILE *)stream);\n     return ret;\n }\n "}, {"sha": "7d457baab34180639d97e82ffdf53d69df5cc6e2", "filename": "zlib/contrib/minizip/ioapi.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fminizip%2Fioapi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fminizip%2Fioapi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fioapi.h?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,9 +1,9 @@\n /* ioapi.h -- IO base function header for compress/uncompress .zip\n    files using zlib + zip or unzip API\n \n-   Version 1.00, September 10th, 2003\n+   Version 1.01e, February 12th, 2005\n \n-   Copyright (C) 1998-2003 Gilles Vollant\n+   Copyright (C) 1998-2005 Gilles Vollant\n */\n \n #ifndef _ZLIBIOAPI_H"}, {"sha": "a9b5f78399607598f9411767205eba45bb306261", "filename": "zlib/contrib/minizip/iowin32.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fminizip%2Fiowin32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fminizip%2Fiowin32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fiowin32.c?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -2,9 +2,9 @@\n    files using zlib + zip or unzip API\n    This IO API version uses the Win32 API (for Microsoft Windows)\n \n-   Version 1.00, September 10th, 2003\n+   Version 1.01e, February 12th, 2005\n \n-   Copyright (C) 1998-2003 Gilles Vollant\n+   Copyright (C) 1998-2005 Gilles Vollant\n */\n \n #include <stdlib.h>"}, {"sha": "a3a437adf84ab73b56433550c68fd1548ff4d1cc", "filename": "zlib/contrib/minizip/iowin32.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fminizip%2Fiowin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fminizip%2Fiowin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fiowin32.h?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -2,9 +2,9 @@\n    files using zlib + zip or unzip API\n    This IO API version uses the Win32 API (for Microsoft Windows)\n \n-   Version 1.00, September 10th, 2003\n+   Version 1.01e, February 12th, 2005\n \n-   Copyright (C) 1998-2003 Gilles Vollant\n+   Copyright (C) 1998-2005 Gilles Vollant\n */\n \n #include <windows.h>"}, {"sha": "836848c2b7ba9fb0585b409a085a461209a72152", "filename": "zlib/contrib/pascal/zlibpas.pas", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fpascal%2Fzlibpas.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fpascal%2Fzlibpas.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpascal%2Fzlibpas.pas?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -10,7 +10,7 @@\n interface\n \n const\n-  ZLIB_VERSION = '1.2.1';\n+  ZLIB_VERSION = '1.2.3';\n \n type\n   alloc_func = function(opaque: Pointer; items, size: Integer): Pointer;"}, {"sha": "ce0cc405e382a3c67348b9d13db4dcce7c5a227e", "filename": "zlib/contrib/puff/puff.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fpuff%2Fpuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fpuff%2Fpuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpuff%2Fpuff.c?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,8 +1,8 @@\n /*\n  * puff.c\n- * Copyright (C) 2002, 2003 Mark Adler\n+ * Copyright (C) 2002-2004 Mark Adler\n  * For conditions of distribution and use, see copyright notice in puff.h\n- * version 1.7, 3 Mar 2003\n+ * version 1.8, 9 Jan 2004\n  *\n  * puff.c is a simple inflate written to be an unambiguous way to specify the\n  * deflate format.  It is not written for speed but rather simplicity.  As a\n@@ -60,6 +60,7 @@\n  * 1.6   7 Aug 2002     - Minor format changes\n  * 1.7   3 Mar 2003     - Added test code for distribution\n  *                      - Added zlib-like license\n+ * 1.8   9 Jan 2004     - Added some comments on no distance codes case\n  */\n \n #include <setjmp.h>             /* for setjmp(), longjmp(), and jmp_buf */\n@@ -577,6 +578,9 @@ local int fixed(struct state *s)\n  *   block is fewer bits), but it is allowed by the format.  So incomplete\n  *   literal/length codes of one symbol should also be permitted.\n  *\n+ * - If there are only literal codes and no lengths, then there are no distance\n+ *   codes.  This is represented by one distance code with zero bits.\n+ *\n  * - The list of up to 286 length/literal lengths and up to 30 distance lengths\n  *   are themselves compressed using Huffman codes and run-length encoding.  In\n  *   the list of code lengths, a 0 symbol means no code, a 1..15 symbol means"}, {"sha": "e5574f45e7f80225c96cfe3b3cdae74a4689247a", "filename": "zlib/contrib/testzlib/testzlib.c", "status": "modified", "additions": 275, "deletions": 149, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.c?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,149 +1,275 @@\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <windows.h>\n-#include \"zlib.h\"\n-\n-int ReadFileMemory(const char* filename,long* plFileSize,void** pFilePtr)\n-{\n-    FILE* stream;\n-    void* ptr;\n-    int retVal=1;\n-    stream=fopen(filename, \"rb\");\n-    if (stream==NULL)\n-        return 0;\n-\n-    fseek(stream,0,SEEK_END);\n-\n-    *plFileSize=ftell(stream);\n-    fseek(stream,0,SEEK_SET);\n-    ptr=malloc((*plFileSize)+1);\n-    if (ptr==NULL)\n-        retVal=0;\n-    else\n-    {\n-        if (fread(ptr, 1, *plFileSize,stream) != (*plFileSize))\n-            retVal=0;\n-    }\n-    fclose(stream);\n-    *pFilePtr=ptr;\n-    return retVal;\n-}\n-\n-int main(int argc, char *argv[])\n-{\n-    int BlockSizeCompress=0x8000;\n-    int BlockSizeUncompress=0x8000;\n-    int cprLevel=Z_DEFAULT_COMPRESSION ;\n-    long lFileSize;\n-    unsigned char* FilePtr;\n-    long lBufferSizeCpr;\n-    long lBufferSizeUncpr;\n-    long lCompressedSize=0;\n-    unsigned char* CprPtr;\n-    unsigned char* UncprPtr;\n-    long lSizeCpr,lSizeUncpr;\n-    DWORD dwGetTick;\n-\n-    if (argc<=1)\n-    {\n-        printf(\"run TestZlib <File> [BlockSizeCompress] [BlockSizeUncompress] [compres. level]\\n\");\n-        return 0;\n-    }\n-\n-    if (ReadFileMemory(argv[1],&lFileSize,&FilePtr)==0)\n-    {\n-        printf(\"error reading %s\\n\",argv[1]);\n-        return 1;\n-    }\n-    else printf(\"file %s read, %u bytes\\n\",argv[1],lFileSize);\n-\n-    if (argc>=3)\n-        BlockSizeCompress=atol(argv[2]);\n-\n-    if (argc>=4)\n-        BlockSizeUncompress=atol(argv[3]);\n-\n-    if (argc>=5)\n-        cprLevel=(int)atol(argv[4]);\n-\n-    lBufferSizeCpr = lFileSize + (lFileSize/0x10) + 0x200;\n-    lBufferSizeUncpr = lBufferSizeCpr;\n-\n-    CprPtr=(unsigned char*)malloc(lBufferSizeCpr + BlockSizeCompress);\n-    UncprPtr=(unsigned char*)malloc(lBufferSizeUncpr + BlockSizeUncompress);\n-\n-    dwGetTick=GetTickCount();\n-    {\n-        z_stream zcpr;\n-        int ret=Z_OK;\n-        long lOrigToDo = lFileSize;\n-        long lOrigDone = 0;\n-        int step=0;\n-        memset(&zcpr,0,sizeof(z_stream));\n-        deflateInit(&zcpr,cprLevel);\n-\n-        zcpr.next_in = FilePtr;\n-        zcpr.next_out = CprPtr;\n-\n-\n-        do\n-        {\n-            long all_read_before = zcpr.total_in;\n-            zcpr.avail_in = min(lOrigToDo,BlockSizeCompress);\n-            zcpr.avail_out = BlockSizeCompress;\n-            ret=deflate(&zcpr,(zcpr.avail_in==lOrigToDo) ? Z_FINISH : Z_SYNC_FLUSH);\n-            lOrigDone += (zcpr.total_in-all_read_before);\n-            lOrigToDo -= (zcpr.total_in-all_read_before);\n-            step++;\n-        } while (ret==Z_OK);\n-\n-        lSizeCpr=zcpr.total_out;\n-        deflateEnd(&zcpr);\n-        dwGetTick=GetTickCount()-dwGetTick;\n-        printf(\"total compress size = %u, in %u step\\n\",lSizeCpr,step);\n-        printf(\"time = %u msec = %f sec\\n\\n\",dwGetTick,dwGetTick/(double)1000.);\n-    }\n-\n-    dwGetTick=GetTickCount();\n-    {\n-        z_stream zcpr;\n-        int ret=Z_OK;\n-        long lOrigToDo = lSizeCpr;\n-        long lOrigDone = 0;\n-        int step=0;\n-        memset(&zcpr,0,sizeof(z_stream));\n-        inflateInit(&zcpr);\n-\n-        zcpr.next_in = CprPtr;\n-        zcpr.next_out = UncprPtr;\n-\n-\n-        do\n-        {\n-            long all_read_before = zcpr.total_in;\n-            zcpr.avail_in = min(lOrigToDo,BlockSizeUncompress);\n-            zcpr.avail_out = BlockSizeUncompress;\n-            ret=inflate(&zcpr,Z_SYNC_FLUSH);\n-            lOrigDone += (zcpr.total_in-all_read_before);\n-            lOrigToDo -= (zcpr.total_in-all_read_before);\n-            step++;\n-        } while (ret==Z_OK);\n-\n-        lSizeUncpr=zcpr.total_out;\n-        inflateEnd(&zcpr);\n-        dwGetTick=GetTickCount()-dwGetTick;\n-        printf(\"total uncompress size = %u, in %u step\\n\",lSizeUncpr,step);\n-        printf(\"time = %u msec = %f sec\\n\\n\",dwGetTick,dwGetTick/(double)1000.);\n-    }\n-\n-    if (lSizeUncpr==lFileSize)\n-    {\n-        if (memcmp(FilePtr,UncprPtr,lFileSize)==0)\n-            printf(\"compare ok\\n\");\n-\n-    }\n-\n-    return 0;\n-\n-}\n+#include <stdio.h>\r\n+#include <stdlib.h>\r\n+#include <windows.h>\r\n+\r\n+#include \"zlib.h\"\r\n+\r\n+\r\n+void MyDoMinus64(LARGE_INTEGER *R,LARGE_INTEGER A,LARGE_INTEGER B)\r\n+{\r\n+    R->HighPart = A.HighPart - B.HighPart;\r\n+    if (A.LowPart >= B.LowPart)\r\n+        R->LowPart = A.LowPart - B.LowPart;\r\n+    else\r\n+    {\r\n+        R->LowPart = A.LowPart - B.LowPart;\r\n+        R->HighPart --;\r\n+    }\r\n+}\r\n+\r\n+#ifdef _M_X64\r\n+// see http://msdn2.microsoft.com/library/twchhe95(en-us,vs.80).aspx for __rdtsc\r\n+unsigned __int64 __rdtsc(void);\r\n+void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)\r\n+{\r\n+ //   printf(\"rdtsc = %I64x\\n\",__rdtsc());\r\n+   pbeginTime64->QuadPart=__rdtsc();\r\n+}\r\n+\r\n+LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\r\n+{\r\n+    LARGE_INTEGER LIres;\r\n+    unsigned _int64 res=__rdtsc()-((unsigned _int64)(beginTime64.QuadPart));\r\n+    LIres.QuadPart=res;\r\n+   // printf(\"rdtsc = %I64x\\n\",__rdtsc());\r\n+    return LIres;\r\n+}\r\n+#else\r\n+#ifdef _M_IX86\r\n+void myGetRDTSC32(LARGE_INTEGER * pbeginTime64)\r\n+{\r\n+    DWORD dwEdx,dwEax;\r\n+    _asm\r\n+    {\r\n+        rdtsc\r\n+        mov dwEax,eax\r\n+        mov dwEdx,edx\r\n+    }\r\n+    pbeginTime64->LowPart=dwEax;\r\n+    pbeginTime64->HighPart=dwEdx;\r\n+}\r\n+\r\n+void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)\r\n+{\r\n+    myGetRDTSC32(pbeginTime64);\r\n+}\r\n+\r\n+LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\r\n+{\r\n+    LARGE_INTEGER LIres,endTime64;\r\n+    myGetRDTSC32(&endTime64);\r\n+\r\n+    LIres.LowPart=LIres.HighPart=0;\r\n+    MyDoMinus64(&LIres,endTime64,beginTime64);\r\n+    return LIres;\r\n+}\r\n+#else\r\n+void myGetRDTSC32(LARGE_INTEGER * pbeginTime64)\r\n+{\r\n+}\r\n+\r\n+void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)\r\n+{\r\n+}\r\n+\r\n+LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\r\n+{\r\n+    LARGE_INTEGER lr;\r\n+    lr.QuadPart=0;\r\n+    return lr;\r\n+}\r\n+#endif\r\n+#endif\r\n+\r\n+void BeginCountPerfCounter(LARGE_INTEGER * pbeginTime64,BOOL fComputeTimeQueryPerf)\r\n+{\r\n+    if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(pbeginTime64)))\r\n+    {\r\n+        pbeginTime64->LowPart = GetTickCount();\r\n+        pbeginTime64->HighPart = 0;\r\n+    }\r\n+}\r\n+\r\n+DWORD GetMsecSincePerfCounter(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\r\n+{\r\n+    LARGE_INTEGER endTime64,ticksPerSecond,ticks;\r\n+    DWORDLONG ticksShifted,tickSecShifted;\r\n+    DWORD dwLog=16+0;\r\n+    DWORD dwRet;\r\n+    if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(&endTime64)))\r\n+        dwRet = (GetTickCount() - beginTime64.LowPart)*1;\r\n+    else\r\n+    {\r\n+        MyDoMinus64(&ticks,endTime64,beginTime64);\r\n+        QueryPerformanceFrequency(&ticksPerSecond);\r\n+\r\n+    \r\n+        {\r\n+            ticksShifted = Int64ShrlMod32(*(DWORDLONG*)&ticks,dwLog);\r\n+            tickSecShifted = Int64ShrlMod32(*(DWORDLONG*)&ticksPerSecond,dwLog);\r\n+        \r\n+        } \r\n+\r\n+        dwRet = (DWORD)((((DWORD)ticksShifted)*1000)/(DWORD)(tickSecShifted));\r\n+        dwRet *=1;\r\n+    }\r\n+    return dwRet;\r\n+}\r\n+\r\n+int ReadFileMemory(const char* filename,long* plFileSize,void** pFilePtr)\r\n+{\r\n+    FILE* stream;\r\n+    void* ptr;\r\n+    int retVal=1;\r\n+    stream=fopen(filename, \"rb\");\r\n+    if (stream==NULL)\r\n+        return 0;\r\n+\r\n+    fseek(stream,0,SEEK_END);\r\n+\r\n+    *plFileSize=ftell(stream);\r\n+    fseek(stream,0,SEEK_SET);\r\n+    ptr=malloc((*plFileSize)+1);\r\n+    if (ptr==NULL)\r\n+        retVal=0;\r\n+    else\r\n+    {\r\n+        if (fread(ptr, 1, *plFileSize,stream) != (*plFileSize))\r\n+            retVal=0;\r\n+    }\r\n+    fclose(stream);\r\n+    *pFilePtr=ptr;\r\n+    return retVal;\r\n+}\r\n+\r\n+int main(int argc, char *argv[])\r\n+{\r\n+    int BlockSizeCompress=0x8000;\r\n+    int BlockSizeUncompress=0x8000;\r\n+    int cprLevel=Z_DEFAULT_COMPRESSION ;\r\n+    long lFileSize;\r\n+    unsigned char* FilePtr;\r\n+    long lBufferSizeCpr;\r\n+    long lBufferSizeUncpr;\r\n+    long lCompressedSize=0;\r\n+    unsigned char* CprPtr;\r\n+    unsigned char* UncprPtr;\r\n+    long lSizeCpr,lSizeUncpr;\r\n+    DWORD dwGetTick,dwMsecQP;\r\n+    LARGE_INTEGER li_qp,li_rdtsc,dwResRdtsc;\r\n+\r\n+    if (argc<=1)\r\n+    {\r\n+        printf(\"run TestZlib <File> [BlockSizeCompress] [BlockSizeUncompress] [compres. level]\\n\");\r\n+        return 0;\r\n+    }\r\n+\r\n+    if (ReadFileMemory(argv[1],&lFileSize,&FilePtr)==0)\r\n+    {\r\n+        printf(\"error reading %s\\n\",argv[1]);\r\n+        return 1;\r\n+    }\r\n+    else printf(\"file %s read, %u bytes\\n\",argv[1],lFileSize);\r\n+\r\n+    if (argc>=3)\r\n+        BlockSizeCompress=atol(argv[2]);\r\n+\r\n+    if (argc>=4)\r\n+        BlockSizeUncompress=atol(argv[3]);\r\n+\r\n+    if (argc>=5)\r\n+        cprLevel=(int)atol(argv[4]);\r\n+\r\n+    lBufferSizeCpr = lFileSize + (lFileSize/0x10) + 0x200;\r\n+    lBufferSizeUncpr = lBufferSizeCpr;\r\n+\r\n+    CprPtr=(unsigned char*)malloc(lBufferSizeCpr + BlockSizeCompress);\r\n+\r\n+    BeginCountPerfCounter(&li_qp,TRUE);\r\n+    dwGetTick=GetTickCount();\r\n+    BeginCountRdtsc(&li_rdtsc);\r\n+    {\r\n+        z_stream zcpr;\r\n+        int ret=Z_OK;\r\n+        long lOrigToDo = lFileSize;\r\n+        long lOrigDone = 0;\r\n+        int step=0;\r\n+        memset(&zcpr,0,sizeof(z_stream));\r\n+        deflateInit(&zcpr,cprLevel);\r\n+\r\n+        zcpr.next_in = FilePtr;\r\n+        zcpr.next_out = CprPtr;\r\n+\r\n+\r\n+        do\r\n+        {\r\n+            long all_read_before = zcpr.total_in;\r\n+            zcpr.avail_in = min(lOrigToDo,BlockSizeCompress);\r\n+            zcpr.avail_out = BlockSizeCompress;\r\n+            ret=deflate(&zcpr,(zcpr.avail_in==lOrigToDo) ? Z_FINISH : Z_SYNC_FLUSH);\r\n+            lOrigDone += (zcpr.total_in-all_read_before);\r\n+            lOrigToDo -= (zcpr.total_in-all_read_before);\r\n+            step++;\r\n+        } while (ret==Z_OK);\r\n+\r\n+        lSizeCpr=zcpr.total_out;\r\n+        deflateEnd(&zcpr);\r\n+        dwGetTick=GetTickCount()-dwGetTick;\r\n+        dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);\r\n+        dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);\r\n+        printf(\"total compress size = %u, in %u step\\n\",lSizeCpr,step);\r\n+        printf(\"time = %u msec = %f sec\\n\",dwGetTick,dwGetTick/(double)1000.);\r\n+        printf(\"defcpr time QP = %u msec = %f sec\\n\",dwMsecQP,dwMsecQP/(double)1000.);\r\n+        printf(\"defcpr result rdtsc = %I64x\\n\\n\",dwResRdtsc.QuadPart);\r\n+    }\r\n+\r\n+    CprPtr=(unsigned char*)realloc(CprPtr,lSizeCpr);\r\n+    UncprPtr=(unsigned char*)malloc(lBufferSizeUncpr + BlockSizeUncompress);\r\n+\r\n+    BeginCountPerfCounter(&li_qp,TRUE);\r\n+    dwGetTick=GetTickCount();\r\n+    BeginCountRdtsc(&li_rdtsc);\r\n+    {\r\n+        z_stream zcpr;\r\n+        int ret=Z_OK;\r\n+        long lOrigToDo = lSizeCpr;\r\n+        long lOrigDone = 0;\r\n+        int step=0;\r\n+        memset(&zcpr,0,sizeof(z_stream));\r\n+        inflateInit(&zcpr);\r\n+\r\n+        zcpr.next_in = CprPtr;\r\n+        zcpr.next_out = UncprPtr;\r\n+\r\n+\r\n+        do\r\n+        {\r\n+            long all_read_before = zcpr.total_in;\r\n+            zcpr.avail_in = min(lOrigToDo,BlockSizeUncompress);\r\n+            zcpr.avail_out = BlockSizeUncompress;\r\n+            ret=inflate(&zcpr,Z_SYNC_FLUSH);\r\n+            lOrigDone += (zcpr.total_in-all_read_before);\r\n+            lOrigToDo -= (zcpr.total_in-all_read_before);\r\n+            step++;\r\n+        } while (ret==Z_OK);\r\n+\r\n+        lSizeUncpr=zcpr.total_out;\r\n+        inflateEnd(&zcpr);\r\n+        dwGetTick=GetTickCount()-dwGetTick;\r\n+        dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);\r\n+        dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);\r\n+        printf(\"total uncompress size = %u, in %u step\\n\",lSizeUncpr,step);\r\n+        printf(\"time = %u msec = %f sec\\n\",dwGetTick,dwGetTick/(double)1000.);\r\n+        printf(\"uncpr  time QP = %u msec = %f sec\\n\",dwMsecQP,dwMsecQP/(double)1000.);\r\n+        printf(\"uncpr  result rdtsc = %I64x\\n\\n\",dwResRdtsc.QuadPart);\r\n+    }\r\n+\r\n+    if (lSizeUncpr==lFileSize)\r\n+    {\r\n+        if (memcmp(FilePtr,UncprPtr,lFileSize)==0)\r\n+            printf(\"compare ok\\n\");\r\n+\r\n+    }\r\n+\r\n+    return 0;\r\n+}\r"}, {"sha": "16159f9cd0d1c57c0be8f42b5f718b8e98c5e2f9", "filename": "zlib/contrib/vstudio/readme.txt", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Freadme.txt?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,8 +1,8 @@\n-Building instructions for the DLL versions of Zlib 1.21\r\n-=======================================================\r\n+Building instructions for the DLL versions of Zlib 1.2.3\r\n+========================================================\r\n \r\n This directory contains projects that build zlib and minizip using\r\n-Microsoft Visual C++ 7.0/7.1.\r\n+Microsoft Visual C++ 7.0/7.1, and Visual C++ .\r\n \r\n You don't need to build these projects yourself. You can download the\r\n binaries from:\r\n@@ -11,18 +11,36 @@ binaries from:\n More information can be found at this site.\r\n \r\n \r\n-Build instructions\r\n-------------------\r\n-- Unzip zlib*.zip and copy the files from contrib\\vstudio\\vc7,\r\n-  from contrib\\vstudio\\masmx86 and from contrib\\minizip into the same\r\n-  directory.\r\n+Build instructions for Visual Studio 7.x (32 bits)\r\n+--------------------------------------------------\r\n+- Uncompress current zlib, including all contrib/* files\r\n - Download the crtdll library from\r\n     http://www.winimage.com/zLibDll/crtdll.zip\r\n-  Unzip crtdll.zip to extract crtdll.lib.\r\n-- If you are using x86, use the Release target.\r\n-- Open zlibvc.sln with Microsoft Visual C++ 7.0 or 7.1\r\n+  Unzip crtdll.zip to extract crtdll.lib on contrib\\vstudio\\vc7.\r\n+- Open contrib\\vstudio\\vc7\\zlibvc.sln with Microsoft Visual C++ 7.x\r\n   (Visual Studio .Net 2002 or 2003).\r\n \r\n+Build instructions for Visual Studio 2005 (32 bits or 64 bits)\r\n+--------------------------------------------------------------\r\n+- Uncompress current zlib, including all contrib/* files\r\n+- For 32 bits only: download the crtdll library from\r\n+    http://www.winimage.com/zLibDll/crtdll.zip\r\n+  Unzip crtdll.zip to extract crtdll.lib on contrib\\vstudio\\vc8.\r\n+- Open contrib\\vstudio\\vc8\\zlibvc.sln with Microsoft Visual C++ 8.0\r\n+\r\n+Build instructions for Visual Studio 2005 64 bits, PSDK compiler\r\n+----------------------------------------------------------------\r\n+at the time of writing this text file, Visual Studio 2005 (and \r\n+  Microsoft Visual C++ 8.0) is on the beta 2 stage.\r\n+Using you can get the free 64 bits compiler from Platform SDK, \r\n+  which is NOT a beta, and compile using the Visual studio 2005 IDE\r\n+see http://www.winimage.com/misc/sdk64onvs2005/ for instruction\r\n+\r\n+- Uncompress current zlib, including all contrib/* files\r\n+- start Visual Studio 2005 from a platform SDK command prompt, using\r\n+  the /useenv switch\r\n+- Open contrib\\vstudio\\vc8\\zlibvc.sln with Microsoft Visual C++ 8.0\r\n+\r\n \r\n Important\r\n ---------\r"}, {"sha": "ad5117c84517de0d36b281288839a77afda48328", "filename": "zlib/contrib/vstudio/vc7/miniunz.vcproj", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fminiunz.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fminiunz.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fminiunz.vcproj?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -19,6 +19,7 @@\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCCLCompilerTool\"\r\n \t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE\"\r\n \t\t\t\tMinimalRebuild=\"TRUE\"\r\n \t\t\t\tBasicRuntimeChecks=\"3\"\r\n@@ -63,6 +64,7 @@\n \t\t\t\tOptimization=\"2\"\r\n \t\t\t\tInlineFunctionExpansion=\"1\"\r\n \t\t\t\tOmitFramePointers=\"TRUE\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE\"\r\n \t\t\t\tStringPooling=\"TRUE\"\r\n \t\t\t\tRuntimeLibrary=\"4\"\r\n@@ -104,7 +106,7 @@\n \t\t\tName=\"Source Files\"\r\n \t\t\tFilter=\"cpp;c;cxx;def;odl;idl;hpj;bat;asm\">\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\"miniunz.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\miniunz.c\">\r\n \t\t\t</File>\r\n \t\t</Filter>\r\n \t\t<Filter\r\n@@ -116,7 +118,7 @@\n \t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\">\r\n \t\t</Filter>\r\n \t\t<File\r\n-\t\t\tRelativePath=\"zlibwapi.lib\">\r\n+\t\t\tRelativePath=\"ReleaseDll\\zlibwapi.lib\">\r\n \t\t</File>\r\n \t</Files>\r\n \t<Globals>\r"}, {"sha": "fb5b6320d503fd7776a14450ad17b117a7645024", "filename": "zlib/contrib/vstudio/vc7/minizip.vcproj", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fminizip.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fminizip.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fminizip.vcproj?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -19,6 +19,7 @@\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCCLCompilerTool\"\r\n \t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE\"\r\n \t\t\t\tMinimalRebuild=\"TRUE\"\r\n \t\t\t\tBasicRuntimeChecks=\"3\"\r\n@@ -63,6 +64,7 @@\n \t\t\t\tOptimization=\"2\"\r\n \t\t\t\tInlineFunctionExpansion=\"1\"\r\n \t\t\t\tOmitFramePointers=\"TRUE\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE\"\r\n \t\t\t\tStringPooling=\"TRUE\"\r\n \t\t\t\tRuntimeLibrary=\"4\"\r\n@@ -104,7 +106,7 @@\n \t\t\tName=\"Source Files\"\r\n \t\t\tFilter=\"cpp;c;cxx;def;odl;idl;hpj;bat;asm\">\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\"minizip.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\minizip.c\">\r\n \t\t\t</File>\r\n \t\t</Filter>\r\n \t\t<Filter\r\n@@ -116,7 +118,7 @@\n \t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\">\r\n \t\t</Filter>\r\n \t\t<File\r\n-\t\t\tRelativePath=\"zlibwapi.lib\">\r\n+\t\t\tRelativePath=\"ReleaseDll\\zlibwapi.lib\">\r\n \t\t</File>\r\n \t</Files>\r\n \t<Globals>\r"}, {"sha": "72cb8b4c31e2f867f87526db67cbe95f130db348", "filename": "zlib/contrib/vstudio/vc7/zlib.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlib.rc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlib.rc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlib.rc?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -2,8 +2,8 @@\n \r\n #define IDR_VERSION1  1\r\n IDR_VERSION1\tVERSIONINFO\tMOVEABLE IMPURE LOADONCALL DISCARDABLE\r\n-  FILEVERSION\t 1,2,1,0\r\n-  PRODUCTVERSION 1,2,1,0\r\n+  FILEVERSION\t 1,2,3,0\r\n+  PRODUCTVERSION 1,2,3,0\r\n   FILEFLAGSMASK\tVS_FFI_FILEFLAGSMASK\r\n   FILEFLAGS\t0\r\n   FILEOS\tVOS_DOS_WINDOWS32\r\n@@ -17,7 +17,7 @@ BEGIN\n \r\n     BEGIN\r\n       VALUE \"FileDescription\", \"zlib data compression library\\0\"\r\n-      VALUE \"FileVersion\",\t\"1.2.1.0\\0\"\r\n+      VALUE \"FileVersion\",\t\"1.2.3.0\\0\"\r\n       VALUE \"InternalName\",\t\"zlib\\0\"\r\n       VALUE \"OriginalFilename\",\t\"zlib.dll\\0\"\r\n       VALUE \"ProductName\",\t\"ZLib.DLL\\0\"\r"}, {"sha": "766d7a4d6e7b86e78e517331801527dc374605db", "filename": "zlib/contrib/vstudio/vc7/zlibstat.vcproj", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibstat.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibstat.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibstat.vcproj?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -20,6 +20,7 @@\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCCLCompilerTool\"\r\n \t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI\"\r\n \t\t\t\tExceptionHandling=\"FALSE\"\r\n \t\t\t\tRuntimeLibrary=\"5\"\r\n@@ -61,6 +62,7 @@\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCCLCompilerTool\"\r\n \t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI\"\r\n \t\t\t\tStringPooling=\"TRUE\"\r\n \t\t\t\tExceptionHandling=\"FALSE\"\r\n@@ -102,6 +104,7 @@\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCCLCompilerTool\"\r\n \t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;ASMV;ASMINF\"\r\n \t\t\t\tStringPooling=\"TRUE\"\r\n \t\t\t\tExceptionHandling=\"FALSE\"\r\n@@ -117,7 +120,7 @@\n \t\t\t\tName=\"VCCustomBuildTool\"/>\r\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCLibrarianTool\"\r\n-\t\t\t\tAdditionalOptions=\"gvmat32.obj inffas32.obj /NODEFAULTLIB \"\r\n+\t\t\t\tAdditionalOptions=\"..\\..\\masmx86\\gvmat32.obj ..\\..\\masmx86\\inffas32.obj /NODEFAULTLIB \"\r\n \t\t\t\tOutputFile=\".\\zlibstat\\zlibstat.lib\"\r\n \t\t\t\tSuppressStartupBanner=\"TRUE\"/>\r\n \t\t\t<Tool\r\n@@ -144,6 +147,7 @@\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCCLCompilerTool\"\r\n \t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI\"\r\n \t\t\t\tStringPooling=\"TRUE\"\r\n \t\t\t\tExceptionHandling=\"FALSE\"\r\n@@ -182,49 +186,49 @@\n \t\t\tName=\"Source Files\"\r\n \t\t\tFilter=\"\">\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\adler32.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\adler32.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\compress.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\compress.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\crc32.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\crc32.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\deflate.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\deflate.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\gvmat32c.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\masmx86\\gvmat32c.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\gzio.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\gzio.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\infback.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\infback.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\inffast.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inffast.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\inflate.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inflate.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\inftrees.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inftrees.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\ioapi.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\ioapi.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\trees.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\trees.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\uncompr.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\uncompr.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\unzip.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\unzip.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\zip.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\zip.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n \t\t\t\tRelativePath=\".\\zlib.rc\">\r\n@@ -233,7 +237,7 @@\n \t\t\t\tRelativePath=\".\\zlibvc.def\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\zutil.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\zutil.c\">\r\n \t\t\t</File>\r\n \t\t</Filter>\r\n \t</Files>\r"}, {"sha": "927b42b7bde0570787ebc6add0859072e5515b53", "filename": "zlib/contrib/vstudio/vc7/zlibvc.sln", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.sln", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.sln", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.sln?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -7,6 +7,8 @@ Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"minizip\", \"minizip.vcproj\",\n EndProject\r\n Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"miniunz\", \"miniunz.vcproj\", \"{C52F9E7B-498A-42BE-8DB4-85A15694382A}\"\r\n EndProject\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"testZlibDll\", \"testzlib.vcproj\", \"{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}\"\r\n+EndProject\r\n Global\r\n \tGlobalSection(SolutionConfiguration) = preSolution\r\n \t\tConfigName.0 = Debug\r\n@@ -58,6 +60,16 @@ Global\n \t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm.Build.0 = Release|Win32\r\n \t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutCrtdll.ActiveCfg = Release|Win32\r\n \t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutCrtdll.Build.0 = Release|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.Debug.ActiveCfg = Debug|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.Debug.Build.0 = Debug|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.Release.ActiveCfg = Release|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.Release.Build.0 = Release|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.ReleaseAxp.ActiveCfg = Release|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.ReleaseAxp.Build.0 = Release|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.ReleaseWithoutAsm.ActiveCfg = Release|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.ReleaseWithoutAsm.Build.0 = Release|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.ReleaseWithoutCrtdll.ActiveCfg = Release|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.ReleaseWithoutCrtdll.Build.0 = Release|Win32\r\n \tEndGlobalSection\r\n \tGlobalSection(ExtensibilityGlobals) = postSolution\r\n \tEndGlobalSection\r"}, {"sha": "8533b49475e1b4ab0f47886e96c4fc72fed3f361", "filename": "zlib/contrib/vstudio/vc7/zlibvc.vcproj", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.vcproj?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -20,6 +20,7 @@\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCCLCompilerTool\"\r\n \t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32,ZLIB_WINAPI,ASMV,ASMINF\"\r\n \t\t\t\tExceptionHandling=\"FALSE\"\r\n \t\t\t\tRuntimeLibrary=\"1\"\r\n@@ -35,7 +36,7 @@\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCLinkerTool\"\r\n \t\t\t\tAdditionalOptions=\"/MACHINE:I386\"\r\n-\t\t\t\tAdditionalDependencies=\"gvmat32.obj inffas32.obj\"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx86\\gvmat32.obj ..\\..\\masmx86\\inffas32.obj\"\r\n \t\t\t\tOutputFile=\".\\DebugDll\\zlibwapi.dll\"\r\n \t\t\t\tLinkIncremental=\"2\"\r\n \t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n@@ -72,10 +73,12 @@\n \t\t\tIntermediateDirectory=\".\\zlibDllWithoutAsm\"\r\n \t\t\tConfigurationType=\"2\"\r\n \t\t\tUseOfMFC=\"0\"\r\n-\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\"\r\n+\t\t\tWholeProgramOptimization=\"TRUE\">\r\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCCLCompilerTool\"\r\n \t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32,ZLIB_WINAPI\"\r\n \t\t\t\tStringPooling=\"TRUE\"\r\n \t\t\t\tExceptionHandling=\"FALSE\"\r\n@@ -134,10 +137,12 @@\n \t\t\tIntermediateDirectory=\".\\zlibDllWithoutCrtDll\"\r\n \t\t\tConfigurationType=\"2\"\r\n \t\t\tUseOfMFC=\"0\"\r\n-\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\"\r\n+\t\t\tWholeProgramOptimization=\"TRUE\">\r\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCCLCompilerTool\"\r\n \t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32,ZLIB_WINAPI,ASMV,ASMINF\"\r\n \t\t\t\tStringPooling=\"TRUE\"\r\n \t\t\t\tExceptionHandling=\"FALSE\"\r\n@@ -156,7 +161,7 @@\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCLinkerTool\"\r\n \t\t\t\tAdditionalOptions=\"/MACHINE:I386\"\r\n-\t\t\t\tAdditionalDependencies=\"gvmat32.obj inffas32.obj \"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx86\\gvmat32.obj ..\\..\\masmx86\\inffas32.obj \"\r\n \t\t\t\tOutputFile=\".\\zlibDllWithoutCrtDll\\zlibwapi.dll\"\r\n \t\t\t\tLinkIncremental=\"1\"\r\n \t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n@@ -196,10 +201,12 @@\n \t\t\tIntermediateDirectory=\".\\zlibvc__\"\r\n \t\t\tConfigurationType=\"2\"\r\n \t\t\tUseOfMFC=\"0\"\r\n-\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\"\r\n+\t\t\tWholeProgramOptimization=\"TRUE\">\r\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCCLCompilerTool\"\r\n \t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32,ZLIB_WINAPI\"\r\n \t\t\t\tStringPooling=\"TRUE\"\r\n \t\t\t\tExceptionHandling=\"FALSE\"\r\n@@ -256,10 +263,12 @@\n \t\t\tIntermediateDirectory=\".\\ReleaseDll\"\r\n \t\t\tConfigurationType=\"2\"\r\n \t\t\tUseOfMFC=\"0\"\r\n-\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\"\r\n+\t\t\tWholeProgramOptimization=\"TRUE\">\r\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCCLCompilerTool\"\r\n \t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n \t\t\t\tPreprocessorDefinitions=\"WIN32,ZLIB_WINAPI,ASMV,ASMINF\"\r\n \t\t\t\tStringPooling=\"TRUE\"\r\n \t\t\t\tExceptionHandling=\"FALSE\"\r\n@@ -278,7 +287,7 @@\n \t\t\t<Tool\r\n \t\t\t\tName=\"VCLinkerTool\"\r\n \t\t\t\tAdditionalOptions=\"/MACHINE:I386\"\r\n-\t\t\t\tAdditionalDependencies=\"gvmat32.obj inffas32.obj crtdll.lib\"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx86\\gvmat32.obj ..\\..\\masmx86\\inffas32.obj crtdll.lib\"\r\n \t\t\t\tOutputFile=\".\\ReleaseDll\\zlibwapi.dll\"\r\n \t\t\t\tLinkIncremental=\"1\"\r\n \t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n@@ -318,19 +327,19 @@\n \t\t\tName=\"Source Files\"\r\n \t\t\tFilter=\"cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90\">\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\adler32.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\adler32.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\compress.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\compress.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\crc32.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\crc32.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\deflate.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\deflate.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\gvmat32c.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\masmx86\\gvmat32c.c\">\r\n \t\t\t\t<FileConfiguration\r\n \t\t\t\t\tName=\"ReleaseWithoutAsm|Win32\"\r\n \t\t\t\t\tExcludedFromBuild=\"TRUE\">\r\n@@ -339,34 +348,34 @@\n \t\t\t\t</FileConfiguration>\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\gzio.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\gzio.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\infback.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\infback.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\inffast.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inffast.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\inflate.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inflate.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\inftrees.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inftrees.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\ioapi.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\ioapi.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\iowin32.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\iowin32.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\trees.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\trees.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\uncompr.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\uncompr.c\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\unzip.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\unzip.c\">\r\n \t\t\t\t<FileConfiguration\r\n \t\t\t\t\tName=\"Release|Win32\">\r\n \t\t\t\t\t<Tool\r\n@@ -376,7 +385,7 @@\n \t\t\t\t</FileConfiguration>\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\zip.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\zip.c\">\r\n \t\t\t\t<FileConfiguration\r\n \t\t\t\t\tName=\"Release|Win32\">\r\n \t\t\t\t\t<Tool\r\n@@ -392,38 +401,38 @@\n \t\t\t\tRelativePath=\".\\zlibvc.def\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\zutil.c\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\zutil.c\">\r\n \t\t\t</File>\r\n \t\t</Filter>\r\n \t\t<Filter\r\n \t\t\tName=\"Header Files\"\r\n \t\t\tFilter=\"h;hpp;hxx;hm;inl;fi;fd\">\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\deflate.h\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\deflate.h\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\infblock.h\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\infblock.h\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\infcodes.h\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\infcodes.h\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\inffast.h\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inffast.h\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\inftrees.h\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inftrees.h\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\infutil.h\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\infutil.h\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\zconf.h\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\zconf.h\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\zlib.h\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\zlib.h\">\r\n \t\t\t</File>\r\n \t\t\t<File\r\n-\t\t\t\tRelativePath=\".\\zutil.h\">\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\zutil.h\">\r\n \t\t\t</File>\r\n \t\t</Filter>\r\n \t\t<Filter\r"}, {"sha": "57e29d3fba917799382a539b80566d7494c9e8fb", "filename": "zlib/old/Makefile.riscos", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fold%2FMakefile.riscos", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fold%2FMakefile.riscos", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2FMakefile.riscos?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -3,12 +3,12 @@\n # test works out-of-the-box, installs `somewhere' on demand\n \n # Toolflags:\n-CCflags = -c -depend !Depend -IC: -g -throwback  -DRISCOS  -fah \n+CCflags = -c -depend !Depend -IC: -g -throwback  -DRISCOS  -fah\n C++flags = -c -depend !Depend -IC: -throwback\n-Linkflags = -aif -c++ -o $@ \n+Linkflags = -aif -c++ -o $@\n ObjAsmflags = -throwback -NoCache -depend !Depend\n-CMHGflags = \n-LibFileflags = -c -l -o $@ \n+CMHGflags =\n+LibFileflags = -c -l -o $@\n Squeezeflags = -o $@\n \n # change the line below to where _you_ want the library installed.\n@@ -17,10 +17,10 @@ libdest = lib:zlib\n # Final targets:\n @.lib:   @.o.adler32 @.o.compress @.o.crc32 @.o.deflate @.o.gzio \\\n         @.o.infblock @.o.infcodes @.o.inffast @.o.inflate @.o.inftrees @.o.infutil @.o.trees \\\n-        @.o.uncompr @.o.zutil \n+        @.o.uncompr @.o.zutil\n         LibFile $(LibFileflags) @.o.adler32 @.o.compress @.o.crc32 @.o.deflate \\\n         @.o.gzio @.o.infblock @.o.infcodes @.o.inffast @.o.inflate @.o.inftrees @.o.infutil \\\n-        @.o.trees @.o.uncompr @.o.zutil \n+        @.o.trees @.o.uncompr @.o.zutil\n test:   @.minigzip @.example @.lib\n \t@copy @.lib @.libc  A~C~DF~L~N~P~Q~RS~TV\n \t@echo running tests: hang on.\n@@ -41,9 +41,9 @@ test:   @.minigzip @.example @.lib\n \t@/@.example @.fred @.fred\n \t@echo that will have given lots of hello!'s.\n \n-@.minigzip:   @.o.minigzip @.lib C:o.Stubs \n-        Link $(Linkflags) @.o.minigzip @.lib C:o.Stubs \n-@.example:   @.o.example @.lib C:o.Stubs \n+@.minigzip:   @.o.minigzip @.lib C:o.Stubs\n+        Link $(Linkflags) @.o.minigzip @.lib C:o.Stubs\n+@.example:   @.o.example @.lib C:o.Stubs\n         Link $(Linkflags) @.o.example @.lib C:o.Stubs\n \n install: @.lib"}, {"sha": "800bf079827b7b1215b9ded3f7d373a5e8e124a9", "filename": "zlib/old/README", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fold%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fold%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2FREADME?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,3 +1,3 @@\n-This directory contains files that have not been updated for zlib 1.2.1\n+This directory contains files that have not been updated for zlib 1.2.x\n \n (Volunteers are encouraged to help clean this up.  Thanks.)"}, {"sha": "8a4a47c723a4e68a4ff00d134de658555910b236", "filename": "zlib/qnx/package.qpg", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fqnx%2Fpackage.qpg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fqnx%2Fpackage.qpg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fqnx%2Fpackage.qpg?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -25,10 +25,10 @@\n       <QPG:Files>\n          <QPG:Add file=\"../zconf.h\" install=\"/opt/include/\" user=\"root:sys\" permission=\"644\"/>\n          <QPG:Add file=\"../zlib.h\" install=\"/opt/include/\" user=\"root:sys\" permission=\"644\"/>\n-         <QPG:Add file=\"../libz.so.1.2.1\" install=\"/opt/lib/\" user=\"root:bin\" permission=\"644\"/>\n-         <QPG:Add file=\"libz.so\" install=\"/opt/lib/\" component=\"dev\" filetype=\"symlink\" linkto=\"libz.so.1.2.1\"/>\n-         <QPG:Add file=\"libz.so.1\" install=\"/opt/lib/\" filetype=\"symlink\" linkto=\"libz.so.1.2.1\"/>\n-         <QPG:Add file=\"../libz.so.1.2.1\" install=\"/opt/lib/\" component=\"slib\"/>\n+         <QPG:Add file=\"../libz.so.1.2.3\" install=\"/opt/lib/\" user=\"root:bin\" permission=\"644\"/>\n+         <QPG:Add file=\"libz.so\" install=\"/opt/lib/\" component=\"dev\" filetype=\"symlink\" linkto=\"libz.so.1.2.3\"/>\n+         <QPG:Add file=\"libz.so.1\" install=\"/opt/lib/\" filetype=\"symlink\" linkto=\"libz.so.1.2.3\"/>\n+         <QPG:Add file=\"../libz.so.1.2.3\" install=\"/opt/lib/\" component=\"slib\"/>\n       </QPG:Files>\n \n       <QPG:PackageFilter>\n@@ -63,7 +63,7 @@\n             </QPM:ProductDescription>\n \n             <QPM:ReleaseDescription>\n-               <QPM:ReleaseVersion>1.2.1</QPM:ReleaseVersion>\n+               <QPM:ReleaseVersion>1.2.3</QPM:ReleaseVersion>\n                <QPM:ReleaseUrgency>Medium</QPM:ReleaseUrgency>\n                <QPM:ReleaseStability>Stable</QPM:ReleaseStability>\n                <QPM:ReleaseNoteMinor></QPM:ReleaseNoteMinor>\n@@ -105,7 +105,7 @@\n                </QPM:Script>\n             </QPM:ProductInstallationProcedure>\n          </QPM:PackageManifest>\n-         \n+\n          <QPM:Launch>\n          </QPM:Launch>\n       </QPG:PackageFilter>\n@@ -119,7 +119,7 @@\n \t       </QPM:OrderDependency>\n             </QPM:ProductInstallationProcedure>\n          </QPM:PackageManifest>\n-         \n+\n          <QPM:Launch>\n          </QPM:Launch>\n       </QPG:PackageFilter>\n@@ -133,7 +133,7 @@\n \t       </QPM:OrderDependency>\n             </QPM:ProductInstallationProcedure>\n          </QPM:PackageManifest>\n-         \n+\n          <QPM:Launch>\n          </QPM:Launch>\n       </QPG:PackageFilter>"}, {"sha": "fb18e071189745a8fdc4dea98366cb275cfbd050", "filename": "zlib/win32/DLL_FAQ.txt", "status": "modified", "additions": 102, "deletions": 76, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fwin32%2FDLL_FAQ.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fwin32%2FDLL_FAQ.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2FDLL_FAQ.txt?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -12,7 +12,7 @@ in the zlib distribution, or at the following location:\n  1. What is ZLIB1.DLL, and how can I get it?\n \n   - ZLIB1.DLL is the official build of zlib as a DLL.\n-    (Please remark the symbol '1' in the name.)\n+    (Please remark the character '1' in the name.)\n \n     Pointers to a precompiled ZLIB1.DLL can be found in the zlib\n     web site at:\n@@ -37,20 +37,19 @@ in the zlib distribution, or at the following location:\n     and build settings.  If you do build the DLL yourself, please\n     make sure that it complies with all the above requirements,\n     and it runs with the precompiled test programs, bundled with\n-    the original ZLIB1.DLL distribution and available at the zlib\n-    web site.\n+    the original ZLIB1.DLL distribution.\n \n     If, for any reason, you need to build an incompatible DLL,\n-    please use a different name.\n+    please use a different file name.\n \n \n  2. Why did you change the name of the DLL to ZLIB1.DLL?\n     What happened to the old ZLIB.DLL?\n \n-  - The old ZLIB.DLL, built from zlib-1.1.x and earlier, required\n-    compilation settings that were incompatible to those used by a\n-    static build.  The DLL settings were supposed to be enabled by\n-    defining the macro ZLIB_DLL, before including \"zlib.h\".\n+  - The old ZLIB.DLL, built from zlib-1.1.4 or earlier, required\n+    compilation settings that were incompatible to those used by\n+    a static build.  The DLL settings were supposed to be enabled\n+    by defining the macro ZLIB_DLL, before including \"zlib.h\".\n     Incorrect handling of this macro was silently accepted at\n     build time, resulting in two major problems:\n \n@@ -65,8 +64,8 @@ in the zlib distribution, or at the following location:\n       functions.  Failure to do so resulted in creating binaries\n       that were unable to run with the official ZLIB.DLL build.\n \n-    The only possible solution that we could foresee was to make a\n-    binary-incompatible change in the DLL interfacing, in order to\n+    The only possible solution that we could foresee was to make\n+    a binary-incompatible change in the DLL interface, in order to\n     remove the dependency on the ZLIB_DLL macro, and to release\n     the new DLL under a different name.\n \n@@ -85,17 +84,13 @@ in the zlib distribution, or at the following location:\n \n   - In principle, you can do it by assigning calling convention\n     keywords to the macros ZEXPORT and ZEXPORTVA.  In practice,\n-    it depends on what you mean by \"an old ZLIB.DLL\", because\n-    the old DLL exists in several mutually-incompatible versions.\n-\n-    If you have a compiled application that works with a certain\n-    ZLIB.DLL without any known security issues, there is hardly\n-    a need to rebuild the DLL from new sources only to link it to\n-    the old app binary.  But if you really want to do it, you have\n-    to find out first what kind of calling convention uses your\n-    particular ZLIB.DLL build, and to use the same one in the new\n-    build.  If you don't know what this is all about, you might be\n-    better off if you would just forget it.\n+    it depends on what you mean by \"an old ZLIB.DLL\", because the\n+    old DLL exists in several mutually-incompatible versions.\n+    You have to find out first what kind of calling convention is\n+    being used in your particular ZLIB.DLL build, and to use the\n+    same one in the new build.  If you don't know what this is all\n+    about, you might be better off if you would just leave the old\n+    DLL intact.\n \n \n  4. Can I compile my application using the new zlib interface, and\n@@ -170,19 +165,19 @@ in the zlib distribution, or at the following location:\n     the K&R-style function prototypes, where the argument types\n     are not specified; but that is another story for another day.\n \n-    The fact that remains is that CDECL is the default convention.\n-    Even if an explicit convention (such as STDCALL or FASTCALL)\n-    is hard-coded into the function prototypes inside C headers,\n-    problems may appear.  One problem, for example, deals with the\n-    necessity to expose the convention in users' callbacks.\n+    The remaining fact is that CDECL is the default convention.\n+    Even if an explicit convention is hard-coded into the function\n+    prototypes inside C headers, problems may appear.  The\n+    necessity to expose the convention in users' callbacks is one\n+    of these problems.\n \n     The calling convention issues are also important when using\n     zlib in other programming languages.  Some of them, like Ada\n     (GNAT) and Fortran (GNU G77), have C bindings implemented\n     initially on Unix, and relying on the C calling convention.\n     On the other hand, the pre- .NET versions of Microsoft Visual\n-    Basic require STDCALL, while Borland Delphi prefers (although\n-    it does not require) FASTCALL.\n+    Basic require STDCALL, while Borland Delphi prefers, although\n+    it does not require, FASTCALL.\n \n     In fairness to all possible uses of zlib outside the C\n     programming language, we choose the default \"C\" convention.\n@@ -208,7 +203,14 @@ in the zlib distribution, or at the following location:\n     zlib distribution.\n \n \n- 8. If my application uses ZLIB1.DLL, should I link it to\n+ 8. I need to use zlib in my Microsoft .NET project.  What can I\n+    do?\n+\n+  - Henrik Ravn has contributed a .NET wrapper around zlib.  Look\n+    into contrib/dotzlib/, inside the zlib distribution.\n+\n+\n+ 9. If my application uses ZLIB1.DLL, should I link it to\n     MSVCRT.DLL?  Why?\n \n   - It is not required, but it is recommended to link your\n@@ -223,8 +225,8 @@ in the zlib distribution, or at the following location:\n     depend on it should also be linked to MSVCRT.DLL.\n \n \n- 9. Why are you saying that ZLIB1.DLL and my application must be\n-    linked to the same C run-time (CRT) library?  I linked my\n+10. Why are you saying that ZLIB1.DLL and my application should\n+    be linked to the same C run-time (CRT) library?  I linked my\n     application and my DLLs to different C libraries (e.g. my\n     application to a static library, and my DLLs to MSVCRT.DLL),\n     and everything works fine.\n@@ -255,11 +257,11 @@ in the zlib distribution, or at the following location:\n     and DLLs are avoiding the corruption of each of the CRTs'\n     internal states, maybe by careful design, or maybe by fortune.\n \n-    Also note that linking ZLIB1.DLL to non-Microsoft CRTs (such\n-    as those provided by Borland) raises similar problems.\n+    Also note that linking ZLIB1.DLL to non-Microsoft CRTs, such\n+    as those provided by Borland, raises similar problems.\n \n \n-10. Why are you linking ZLIB1.DLL to MSVCRT.DLL?\n+11. Why are you linking ZLIB1.DLL to MSVCRT.DLL?\n \n   - MSVCRT.DLL exists on every Windows 95 with a new service pack\n     installed, or with Microsoft Internet Explorer 4 or later, and\n@@ -269,21 +271,14 @@ in the zlib distribution, or at the following location:\n     software provider for free.\n \n     The fact that MSVCRT.DLL does not exist on a virgin Windows 95\n-    is not so problematic.  The number of Windows 95 installations\n-    is rapidly decreasing, Microsoft stopped supporting it a long\n-    time ago, and many recent applications from various vendors,\n-    including Microsoft, do not even run on it.  Furthermore, no\n-    serious user should run Windows 95 without a proper update\n-    installed.\n-\n-    There is also the fact that the mainstream C compilers for\n-    Windows are Microsoft Visual C++ 6.0, and gcc/MinGW.  Both\n-    are producing executables that link to MSVCRT.DLL by default,\n-    without offering other dynamic CRTs as alternatives easy to\n-    select by users.\n+    is not so problematic.  Windows 95 is scarcely found nowadays,\n+    Microsoft ended its support a long time ago, and many recent\n+    applications from various vendors, including Microsoft, do not\n+    even run on it.  Furthermore, no serious user should run\n+    Windows 95 without a proper update installed.\n \n \n-11. Why are you not linking ZLIB1.DLL to\n+12. Why are you not linking ZLIB1.DLL to\n     <<my favorite C run-time library>> ?\n \n   - We considered and abandoned the following alternatives:\n@@ -294,27 +289,60 @@ in the zlib distribution, or at the following location:\n       to a static C library, you may as well consider linking zlib\n       in statically, too.\n \n-    * Linking ZLIB1.DLL to CRTDLL.DLL looks very appealing,\n-      because CRTDLL.DLL is present on every Win32 installation.\n-      Unfortunately, it has a series of problems: it raises\n-      difficulties when using it with C++ code, it does not work\n-      with 64-bit file offsets, (and so on...), and Microsoft\n-      discontinued its support a long time ago.\n-\n-    * Linking ZLIB1.DLL to MSVCR70.DLL, supplied with the\n-      Microsoft .NET platform and Visual C++ 7.0 or newer, is not\n-      a good option.  Although it is available for free download\n-      and distribution, its presence is scarce on today's Win32\n-      installations.  If it will ever become more popular than\n-      MSVCRT.DLL and will be pre-installed on the future Win32\n-      systems, we will probably think again about it.\n-\n-    * Linking ZLIB1.DLL to NTDLL.DLL is not possible.\n-      NTDLL.DLL exports only a part of the C library, and only on\n-      Windows NT systems.\n-\n-\n-12. I need to link my own DLL build to a CRT different than\n+    * Linking ZLIB1.DLL to CRTDLL.DLL looks appealing, because\n+      CRTDLL.DLL is present on every Win32 installation.\n+      Unfortunately, it has a series of problems: it does not\n+      work properly with Microsoft's C++ libraries, it does not\n+      provide support for 64-bit file offsets, (and so on...),\n+      and Microsoft discontinued its support a long time ago.\n+\n+    * Linking ZLIB1.DLL to MSVCR70.DLL or MSVCR71.DLL, supplied\n+      with the Microsoft .NET platform, and Visual C++ 7.0/7.1,\n+      raises problems related to the status of ZLIB1.DLL as a\n+      system component.  According to the Microsoft Knowledge Base\n+      article KB326922 \"INFO: Redistribution of the Shared C\n+      Runtime Component in Visual C++ .NET\", MSVCR70.DLL and\n+      MSVCR71.DLL are not supposed to function as system DLLs,\n+      because they may clash with MSVCRT.DLL.  Instead, the\n+      application's installer is supposed to put these DLLs\n+      (if needed) in the application's private directory.\n+      If ZLIB1.DLL depends on a non-system runtime, it cannot\n+      function as a redistributable system component.\n+\n+    * Linking ZLIB1.DLL to non-Microsoft runtimes, such as\n+      Borland's, or Cygwin's, raises problems related to the\n+      reliable presence of these runtimes on Win32 systems.\n+      It's easier to let the DLL build of zlib up to the people\n+      who distribute these runtimes, and who may proceed as\n+      explained in the answer to Question 14.\n+\n+\n+13. If ZLIB1.DLL cannot be linked to MSVCR70.DLL or MSVCR71.DLL,\n+    how can I build/use ZLIB1.DLL in Microsoft Visual C++ 7.0\n+    (Visual Studio .NET) or newer?\n+\n+  - Due to the problems explained in the Microsoft Knowledge Base\n+    article KB326922 (see the previous answer), the C runtime that\n+    comes with the VC7 environment is no longer considered a\n+    system component.  That is, it should not be assumed that this\n+    runtime exists, or may be installed in a system directory.\n+    Since ZLIB1.DLL is supposed to be a system component, it may\n+    not depend on a non-system component.\n+\n+    In order to link ZLIB1.DLL and your application to MSVCRT.DLL\n+    in VC7, you need the library of Visual C++ 6.0 or older.  If\n+    you don't have this library at hand, it's probably best not to\n+    use ZLIB1.DLL.\n+\n+    We are hoping that, in the future, Microsoft will provide a\n+    way to build applications linked to a proper system runtime,\n+    from the Visual C++ environment.  Until then, you have a\n+    couple of alternatives, such as linking zlib in statically.\n+    If your application requires dynamic linking, you may proceed\n+    as explained in the answer to Question 14.\n+\n+\n+14. I need to link my own DLL build to a CRT different than\n     MSVCRT.DLL.  What can I do?\n \n   - Feel free to rebuild the DLL from the zlib sources, and link\n@@ -330,22 +358,20 @@ in the zlib distribution, or at the following location:\n     CYGWIN1.DLL, and it is distributed under the name CYGZ.DLL.\n \n \n-13. May I include additional pieces of code that I find useful,\n+15. May I include additional pieces of code that I find useful,\n     link them in ZLIB1.DLL, and export them?\n \n   - No.  A legitimate build of ZLIB1.DLL must not include code\n     that does not originate from the official zlib source code.\n     But you can make your own private DLL build, under a different\n     file name, as suggested in the previous answer.\n \n-    For example, in Borland Delphi and C++ Builder, zlib is a part\n-    of the standard VCL library.  If an application links to VCL\n-    dynamically, the name of the distributable binary (VCLxx.DLL)\n-    does not posess any danger of clashing with a legitimate but\n-    incompatible ZLIB1.DLL.\n+    For example, zlib is a part of the VCL library, distributed\n+    with Borland Delphi and C++ Builder.  The DLL build of VCL\n+    is a redistributable file, named VCLxx.DLL.\n \n \n-14. May I remove some functionality out of ZLIB1.DLL, by enabling\n+16. May I remove some functionality out of ZLIB1.DLL, by enabling\n     macros like NO_GZCOMPRESS or NO_GZIP at compile time?\n \n   - No.  A legitimate build of ZLIB1.DLL must provide the complete\n@@ -354,7 +380,7 @@ in the zlib distribution, or at the following location:\n     different file name, as suggested in the previous answer.\n \n \n-15. I made my own ZLIB1.DLL build.  Can I test it for compliance?\n+17. I made my own ZLIB1.DLL build.  Can I test it for compliance?\n \n   - We prefer that you download the official DLL from the zlib\n     web site.  If you need something peculiar from this DLL, you"}, {"sha": "99025c974221a5e4bc7b271b9453e45ebcc094a0", "filename": "zlib/win32/zlib1.rc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fwin32%2Fzlib1.rc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fwin32%2Fzlib1.rc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2Fzlib1.rc?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -5,8 +5,8 @@ VS_VERSION_INFO\t\tVERSIONINFO\n #else\n VS_VERSION_INFO\t\tVERSIONINFO\tMOVEABLE IMPURE LOADONCALL DISCARDABLE\n #endif\n-  FILEVERSION\t\t1,2,1,0\n-  PRODUCTVERSION\t1,2,1,0\n+  FILEVERSION\t\t1,2,2,0\n+  PRODUCTVERSION\t1,2,2,0\n   FILEFLAGSMASK\t\tVS_FFI_FILEFLAGSMASK\n #ifdef _DEBUG\n   FILEFLAGS\t\t1\n@@ -23,12 +23,12 @@ BEGIN\n     //language ID = U.S. English, char set = Windows, Multilingual\n     BEGIN\n       VALUE \"FileDescription\",\t\"zlib data compression library\\0\"\n-      VALUE \"FileVersion\",\t\"1.2.1\\0\"\n+      VALUE \"FileVersion\",\t\"1.2.3\\0\"\n       VALUE \"InternalName\",\t\"zlib1.dll\\0\"\n-      VALUE \"LegalCopyright\",\t\"(C) 1995-2003 Jean-loup Gailly & Mark Adler\\0\"\n+      VALUE \"LegalCopyright\",\t\"(C) 1995-2004 Jean-loup Gailly & Mark Adler\\0\"\n       VALUE \"OriginalFilename\",\t\"zlib1.dll\\0\"\n       VALUE \"ProductName\",\t\"zlib\\0\"\n-      VALUE \"ProductVersion\",\t\"1.2.1\\0\"\n+      VALUE \"ProductVersion\",\t\"1.2.3\\0\"\n       VALUE \"Comments\",\"DLL support by Alessandro Iacopetti & Gilles Vollant\\0\"\n     END\n   END"}]}