{"sha": "5f34005f06e800994dd6a305788cadd89488e92f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYzNDAwNWYwNmU4MDA5OTRkZDZhMzA1Nzg4Y2FkZDg5NDg4ZTkyZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-13T22:20:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-13T22:20:17Z"}, "message": "(start_function): Handle setting C_C_D here.\n\n(set_C_C_D): Removed.\n(struct saved_scope): Remove class_decl.\n(push_to_top_level): Don't save current_class_decl.\n(pop_from_top_level): Don't restore current_class_decl or C_C_D.\n(struct cp_function): Add C_C_D.\n(push_cp_function_context): Save C_C_D.\n(pop_cp_function_context): Restore C_C_D.\n(set_C_C_D): New function.\n(pop_from_top_level, start_function, pop_cp_function_context): Call it.\nLose all references\nto current_vtable_decl, CLASSTYPE_INST_VAR and CLASSTYPE_VTBL_PTR.\n(push_cp_function_context): Save current_class_decl.\n(pop_cp_function_context): Restore current_class_decl and set C_C_D.\n(pop_from_top_level): Don't use CLASSTYPE_INST_VAR to set C_C_D.\n(start_function): Ditto.\n\nFrom-SVN: r9935", "tree": {"sha": "b5c0540e018400ac13a652e7ab0c5733d1531ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5c0540e018400ac13a652e7ab0c5733d1531ee0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f34005f06e800994dd6a305788cadd89488e92f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f34005f06e800994dd6a305788cadd89488e92f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f34005f06e800994dd6a305788cadd89488e92f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f34005f06e800994dd6a305788cadd89488e92f/comments", "author": null, "committer": null, "parents": [{"sha": "8bf41929899a91163f6b45ed5965fb5be195abd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bf41929899a91163f6b45ed5965fb5be195abd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bf41929899a91163f6b45ed5965fb5be195abd3"}], "stats": {"total": 62, "additions": 20, "deletions": 42}, "files": [{"sha": "0c79da3aa903c3a2067c5ea103ea7a24d8fd2b9d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 20, "deletions": 42, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f34005f06e800994dd6a305788cadd89488e92f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f34005f06e800994dd6a305788cadd89488e92f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5f34005f06e800994dd6a305788cadd89488e92f", "patch": "@@ -1672,7 +1672,7 @@ struct saved_scope {\n   struct binding_level *old_binding_level;\n   tree old_bindings;\n   struct saved_scope *prev;\n-  tree class_name, class_type, class_decl, function_decl;\n+  tree class_name, class_type, function_decl;\n   tree base_init_list, member_init_list;\n   struct binding_level *class_bindings;\n   tree previous_class_type;\n@@ -1748,7 +1748,6 @@ push_to_top_level ()\n \n   s->class_name = current_class_name;\n   s->class_type = current_class_type;\n-  s->class_decl = current_class_decl;\n   s->function_decl = current_function_decl;\n   s->base_init_list = current_base_init_list;\n   s->member_init_list = current_member_init_list;\n@@ -1759,7 +1758,7 @@ push_to_top_level ()\n   s->lang_stacksize = current_lang_stacksize;\n   s->lang_name = current_lang_name;\n   s->named_labels = named_labels;\n-  current_class_name = current_class_type = current_class_decl = NULL_TREE;\n+  current_class_name = current_class_type = NULL_TREE;\n   current_function_decl = NULL_TREE;\n   class_binding_level = (struct binding_level *)0;\n   previous_class_type = NULL_TREE;\n@@ -1799,11 +1798,6 @@ pop_from_top_level ()\n     }\n   current_class_name = s->class_name;\n   current_class_type = s->class_type;\n-  current_class_decl = s->class_decl;\n-  if (current_class_type)\n-    C_C_D = CLASSTYPE_INST_VAR (current_class_type);\n-  else\n-    C_C_D = NULL_TREE;\n   current_base_init_list = s->base_init_list;\n   current_member_init_list = s->member_init_list;\n   current_function_decl = s->function_decl;\n@@ -11211,32 +11205,17 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \t     parse errors may never get us to that point.  Here\n \t     we keep the consistency between `current_class_type'\n \t     and `current_class_decl'.  */\n-\t  current_class_decl = last_function_parms;\n-\t  my_friendly_assert (current_class_decl != NULL_TREE\n-\t\t  && TREE_CODE (current_class_decl) == PARM_DECL, 162);\n-\t  if (TREE_CODE (TREE_TYPE (current_class_decl)) == POINTER_TYPE)\n-\t    {\n-\t      tree variant = TREE_TYPE (TREE_TYPE (current_class_decl));\n-\t      if (CLASSTYPE_INST_VAR (ctype) == NULL_TREE)\n-\t\t{\n-\t\t  /* Can't call build_indirect_ref here, because it has special\n-\t\t     logic to return C_C_D given this argument.  */\n-\t\t  C_C_D = build1 (INDIRECT_REF, current_class_type, current_class_decl);\n-\t\t  CLASSTYPE_INST_VAR (ctype) = C_C_D;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  C_C_D = CLASSTYPE_INST_VAR (ctype);\n-\t\t  /* `current_class_decl' is different for every\n-\t\t     function we compile.  */\n-\t\t  TREE_OPERAND (C_C_D, 0) = current_class_decl;\n-\t\t}\n-\t      TREE_READONLY (C_C_D) = TYPE_READONLY (variant);\n-\t      TREE_SIDE_EFFECTS (C_C_D) = TYPE_VOLATILE (variant);\n-\t      TREE_THIS_VOLATILE (C_C_D) = TYPE_VOLATILE (variant);\n-\t    }\n-\t  else\n-\t    C_C_D = current_class_decl;\n+\t  tree t = last_function_parms;\n+\t  int i = suspend_momentary ();\n+\n+\t  my_friendly_assert (t != NULL_TREE\n+\t\t\t      && TREE_CODE (t) == PARM_DECL, 162);\n+\n+\t  /* Fool build_indirect_ref.  */\n+\t  current_class_decl = NULL_TREE;\n+\t  C_C_D = build_indirect_ref (t, NULL_PTR);\n+\t  current_class_decl = t;\n+\t  resume_momentary (i);\n \t}\n     }\n   else\n@@ -11245,6 +11224,7 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \tpush_nested_class (DECL_CONTEXT (decl1), 2);\n       else\n \tpush_memoized_context (0, 1);\n+      current_class_decl = C_C_D = NULL_TREE;\n     }\n \n   pushlevel (0);\n@@ -11872,14 +11852,6 @@ finish_function (lineno, call_poplevel, nested)\n   if (flag_gc)\n     expand_gc_prologue_and_epilogue ();\n \n-  /* That's the end of the vtable decl's life.  Need to mark it such\n-     if doing stupid register allocation.\n-\n-     Note that current_vtable_decl is really an INDIRECT_REF\n-     on top of a VAR_DECL here.  */\n-  if (obey_regdecls && current_vtable_decl)\n-    use_variable (DECL_RTL (TREE_OPERAND (current_vtable_decl, 0)));\n-\n   /* If this function is supposed to return a value, ensure that\n      we do not fall into the cleanups by mistake.  The end of our\n      function will look like this:\n@@ -12477,6 +12449,8 @@ struct cp_function\n   tree base_init_list;\n   tree member_init_list;\n   tree base_init_expr;\n+  tree class_decl;\n+  tree C_C_D;\n   rtx result_rtx;\n   struct cp_function *next;\n   struct binding_level *binding_level;\n@@ -12518,6 +12492,8 @@ push_cp_function_context (context)\n   p->temp_name_counter = temp_name_counter;\n   p->base_init_list = current_base_init_list;\n   p->member_init_list = current_member_init_list;\n+  p->class_decl = current_class_decl;\n+  p->C_C_D = C_C_D;\n }\n \n /* Restore the variables used during compilation of a C++ function.  */\n@@ -12567,6 +12543,8 @@ pop_cp_function_context (context)\n   temp_name_counter = p->temp_name_counter;\n   current_base_init_list = p->base_init_list;\n   current_member_init_list = p->member_init_list;\n+  current_class_decl = p->class_decl;\n+  C_C_D = p->C_C_D;\n \n   free (p);\n }"}]}