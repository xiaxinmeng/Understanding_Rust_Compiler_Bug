{"sha": "fd295cb213e665379353d4e7b32f8bdcd8df7ade", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQyOTVjYjIxM2U2NjUzNzkzNTNkNGU3YjMyZjhiZGNkOGRmN2FkZQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-02-14T06:04:41Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-02-14T06:04:41Z"}, "message": "decl2.c: Include \"timevar.h\".\n\n\t* decl2.c: Include \"timevar.h\".\n\t(namespace_ancestor): Time name lookup.\n\t(add_using_namespace): Likewise.\n\t(lookup_using_namespace): Likewise.\n\t(qualified_lookup_using_namespace): Likewise.\n\t(decl_namespace): Likewise.\n\t(lookup_arg_dependent): Likewise.\n\t* lex.c (do_identifier): Likewise.\n\t(do_scoped_id): Likewise.\n\t* pt.c (lookup_template_class): Likewise.\n\nFrom-SVN: r62892", "tree": {"sha": "493575f55d880c051f09fca60d6cad6d860f7535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/493575f55d880c051f09fca60d6cad6d860f7535"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd295cb213e665379353d4e7b32f8bdcd8df7ade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd295cb213e665379353d4e7b32f8bdcd8df7ade", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd295cb213e665379353d4e7b32f8bdcd8df7ade", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd295cb213e665379353d4e7b32f8bdcd8df7ade/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ddb0ae00a2fefc266ad0cd0fa12de4368c23e97a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb0ae00a2fefc266ad0cd0fa12de4368c23e97a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddb0ae00a2fefc266ad0cd0fa12de4368c23e97a"}], "stats": {"total": 79, "additions": 53, "deletions": 26}, "files": [{"sha": "f5b9be28b3d2249f6bec5a85b5cda985438976bc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd295cb213e665379353d4e7b32f8bdcd8df7ade/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd295cb213e665379353d4e7b32f8bdcd8df7ade/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fd295cb213e665379353d4e7b32f8bdcd8df7ade", "patch": "@@ -1,3 +1,16 @@\n+2003-02-13  Gabriel Dos Reis <gdr@integrable-solutions.net>\n+\n+\t* decl2.c: Include \"timevar.h\".\n+\t(namespace_ancestor): Time name lookup.\n+\t(add_using_namespace): Likewise.\n+\t(lookup_using_namespace): Likewise.\n+\t(qualified_lookup_using_namespace): Likewise.\n+\t(decl_namespace): Likewise.\n+\t(lookup_arg_dependent): Likewise.\n+\t* lex.c (do_identifier): Likewise.\n+\t(do_scoped_id): Likewise.\n+\t* pt.c (lookup_template_class): Likewise.\n+\n 2003-02-14   Andrew Pinski <pinskia@physics.uc.edu>\n \n         * decl.c: (define_label): Fix warning for return 0 instead of NULL."}, {"sha": "0ee4dd36f0f202af1d4fb9db79ceb1d8de9d0b53", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd295cb213e665379353d4e7b32f8bdcd8df7ade/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd295cb213e665379353d4e7b32f8bdcd8df7ade/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=fd295cb213e665379353d4e7b32f8bdcd8df7ade", "patch": "@@ -3364,9 +3364,11 @@ is_namespace_ancestor (tree root, tree child)\n tree\n namespace_ancestor (tree ns1, tree ns2)\n {\n+  timevar_push (TV_NAME_LOOKUP);\n   if (is_namespace_ancestor (ns1, ns2))\n-    return ns1;\n-  return namespace_ancestor (CP_DECL_CONTEXT (ns1), ns2);\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ns1);\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n+                          namespace_ancestor (CP_DECL_CONTEXT (ns1), ns2));\n }\n \n /* Insert USED into the using list of USER. Set INDIRECT_flag if this\n@@ -3376,9 +3378,10 @@ static void\n add_using_namespace (tree user, tree used, bool indirect)\n {\n   tree t;\n+  timevar_push (TV_NAME_LOOKUP);\n   /* Using oneself is a no-op.  */\n   if (user == used)\n-    return;\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n   my_friendly_assert (TREE_CODE (user) == NAMESPACE_DECL, 380);\n   my_friendly_assert (TREE_CODE (used) == NAMESPACE_DECL, 380);\n   /* Check if we already have this.  */\n@@ -3388,7 +3391,7 @@ add_using_namespace (tree user, tree used, bool indirect)\n       if (!indirect)\n \t/* Promote to direct usage.  */\n \tTREE_INDIRECT_USING (t) = 0;\n-      return;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n     }\n \n   /* Add used to the user's using list.  */\n@@ -3410,6 +3413,7 @@ add_using_namespace (tree user, tree used, bool indirect)\n   /* Tell everyone using us about the new used namespaces.  */\n   for (t = DECL_NAMESPACE_USERS (user); t; t = TREE_CHAIN (t))\n     add_using_namespace (TREE_PURPOSE (t), used, 1);\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n /* Combines two sets of overloaded functions into an OVERLOAD chain, removing\n@@ -3551,6 +3555,7 @@ lookup_using_namespace (tree name, tree val, tree usings, tree scope,\n {\n   tree iter;\n   tree val1;\n+  timevar_push (TV_NAME_LOOKUP);\n   /* Iterate over all used namespaces in current, searching for using\n      directives of scope.  */\n   for (iter = usings; iter; iter = TREE_CHAIN (iter))\n@@ -3563,7 +3568,8 @@ lookup_using_namespace (tree name, tree val, tree usings, tree scope,\n \t/* Resolve ambiguities.  */\n \tval = ambiguous_decl (name, val, val1, flags);\n       }\n-  return BINDING_VALUE (val) != error_mark_node;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n+                          BINDING_VALUE (val) != error_mark_node);\n }\n \n /* [namespace.qual]\n@@ -3580,6 +3586,7 @@ qualified_lookup_using_namespace (tree name, tree scope, tree result,\n   /* ... and a list of namespace yet to see.  */\n   tree todo = NULL_TREE;\n   tree usings;\n+  timevar_push (TV_NAME_LOOKUP);\n   /* Look through namespace aliases.  */\n   scope = ORIGINAL_NAMESPACE (scope);\n   while (scope && (result != error_mark_node))\n@@ -3603,7 +3610,7 @@ qualified_lookup_using_namespace (tree name, tree scope, tree result,\n       else\n \tscope = NULL_TREE; /* If there never was a todo list.  */\n     }\n-  return result != error_mark_node;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result != error_mark_node);\n }\n \n /* [namespace.memdef]/2 */\n@@ -3670,19 +3677,20 @@ set_decl_namespace (tree decl, tree scope, bool friendp)\n static tree\n decl_namespace (tree decl)\n {\n+  timevar_push (TV_NAME_LOOKUP);\n   if (TYPE_P (decl))\n     decl = TYPE_STUB_DECL (decl);\n   while (DECL_CONTEXT (decl))\n     {\n       decl = DECL_CONTEXT (decl);\n       if (TREE_CODE (decl) == NAMESPACE_DECL)\n-\treturn decl;\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n       if (TYPE_P (decl))\n \tdecl = TYPE_STUB_DECL (decl);\n       my_friendly_assert (DECL_P (decl), 390);\n     }\n \n-  return global_namespace;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, global_namespace);\n }\n \n /* Return the namespace where the current declaration is declared.  */\n@@ -4064,6 +4072,7 @@ lookup_arg_dependent (tree name, tree fns, tree args)\n   struct arg_lookup k;\n   tree fn = NULL_TREE;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   k.name = name;\n   k.functions = fns;\n   k.classes = NULL_TREE;\n@@ -4078,7 +4087,7 @@ lookup_arg_dependent (tree name, tree fns, tree args)\n     unqualified_namespace_lookup (name, 0, &k.namespaces);\n \n   arg_assoc_args (&k, args);\n-  return k.functions;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, k.functions);\n }\n \n /* Process a namespace-alias declaration.  */"}, {"sha": "774ed10ede13a46a35d6415eeff68d2ce156c739", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd295cb213e665379353d4e7b32f8bdcd8df7ade/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd295cb213e665379353d4e7b32f8bdcd8df7ade/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=fd295cb213e665379353d4e7b32f8bdcd8df7ade", "patch": "@@ -746,6 +746,7 @@ do_identifier (token, args)\n {\n   register tree id;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   id = lookup_name (token, 0);\n \n   /* Do Koenig lookup if appropriate (inside templates we build lookup\n@@ -765,21 +766,22 @@ do_identifier (token, args)\n \t being used as a declarator.  So we call it again to get the error\n \t message.  */\n       id = lookup_name (token, 0);\n-      return error_mark_node;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n     }\n \n   if (!id || (TREE_CODE (id) == FUNCTION_DECL\n \t      && DECL_ANTICIPATED (id)))\n     {\n       if (current_template_parms)\n-\treturn build_min_nt (LOOKUP_EXPR, token);\n+        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n+                                build_min_nt (LOOKUP_EXPR, token));\n       else if (IDENTIFIER_TYPENAME_P (token))\n \t/* A templated conversion operator might exist.  */\n-\treturn token;\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, token);\n       else\n \t{\n \t  unqualified_name_lookup_error (token);\n-\t  return error_mark_node;\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \t}\n     }\n \n@@ -815,22 +817,23 @@ do_identifier (token, args)\n \t  || TREE_CODE (id) == USING_DECL))\n     id = build_min_nt (LOOKUP_EXPR, token);\n \n-  return id;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, id);\n }\n \n tree\n do_scoped_id (token, id)\n      tree token;\n      tree id;\n {\n+  timevar_push (TV_NAME_LOOKUP);\n   if (!id || (TREE_CODE (id) == FUNCTION_DECL\n \t      && DECL_ANTICIPATED (id)))\n     {\n       if (processing_template_decl)\n \t{\n \t  id = build_min_nt (LOOKUP_EXPR, token);\n \t  LOOKUP_EXPR_GLOBAL (id) = 1;\n-\t  return id;\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, id);\n \t}\n       if (IDENTIFIER_NAMESPACE_VALUE (token) != error_mark_node)\n         error (\"`::%D' undeclared (first use here)\", token);\n@@ -861,11 +864,11 @@ do_scoped_id (token, id)\n \t{\n \t  id = build_min_nt (LOOKUP_EXPR, token);\n \t  LOOKUP_EXPR_GLOBAL (id) = 1;\n-\t  return id;\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, id);\n \t}\n       /* else just use the decl */\n     }\n-  return convert_from_reference (id);\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, convert_from_reference (id));\n }\n \n tree"}, {"sha": "cd2e896969ad129e36bea03ccb9e5b51e185f01c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd295cb213e665379353d4e7b32f8bdcd8df7ade/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd295cb213e665379353d4e7b32f8bdcd8df7ade/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fd295cb213e665379353d4e7b32f8bdcd8df7ade", "patch": "@@ -4031,6 +4031,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n   tree template = NULL_TREE, parmlist;\n   tree t;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   if (TREE_CODE (d1) == IDENTIFIER_NODE)\n     {\n       if (IDENTIFIER_VALUE (d1) \n@@ -4086,7 +4087,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n     {\n       if (complain & tf_error)\n         error (\"`%T' is not a template\", d1);\n-      return error_mark_node;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n     }\n \n   if (TREE_CODE (template) != TEMPLATE_DECL\n@@ -4102,7 +4103,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n           if (in_decl)\n \t    cp_error_at (\"for template declaration `%D'\", in_decl);\n \t}\n-      return error_mark_node;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n     }\n \n   if (DECL_TEMPLATE_TEMPLATE_PARM_P (template))\n@@ -4137,10 +4138,10 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n       arglist2 = coerce_template_parms (parmlist, arglist, template,\n                                         complain, /*require_all_args=*/1);\n       if (arglist2 == error_mark_node)\n-\treturn error_mark_node;\n+        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n       parm = bind_template_template_parm (TREE_TYPE (template), arglist2);\n-      return parm;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, parm);\n     }\n   else \n     {\n@@ -4227,7 +4228,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n \n       if (arglist == error_mark_node)\n \t/* We were unable to bind the arguments.  */\n-\treturn error_mark_node;\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n       /* In the scope of a template class, explicit references to the\n \t template class refer to the type of the template, not any\n@@ -4264,7 +4265,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n \t    }\n \t}\n       if (found)\n-        return found;\n+        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n \n       for (tp = &DECL_TEMPLATE_INSTANTIATIONS (template);\n \t   *tp;\n@@ -4280,7 +4281,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n \t      = DECL_TEMPLATE_INSTANTIATIONS (template);\n \t    DECL_TEMPLATE_INSTANTIATIONS (template) = found;\n \n-\t    return TREE_VALUE (found);\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_VALUE (found));\n \t  }\n \n       /* This type is a \"partial instantiation\" if any of the template\n@@ -4296,7 +4297,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n \t  found = xref_tag_from_type (TREE_TYPE (template),\n \t\t\t\t      DECL_NAME (template),\n \t\t\t\t      /*globalize=*/1);\n-\t  return found;\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n \t}\n       \n       context = tsubst (DECL_CONTEXT (template), arglist,\n@@ -4452,8 +4453,9 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n \t   code that generates debugging information will crash.  */\n \tDECL_IGNORED_P (TYPE_STUB_DECL (t)) = 1;\n \n-      return t;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n     }\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \f\n struct pair_fn_data "}]}