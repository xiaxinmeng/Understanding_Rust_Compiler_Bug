{"sha": "bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY5ZThiNmI1MDk1MmIzMWQwNDE3OWJhZTFlYmI0YzA5ZmZkYzFjZg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-11-28T16:53:17Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-11-28T16:53:17Z"}, "message": "i386.md (UNSPEC_KMASKOP): New.\n\n\t* config/i386/i386.md (UNSPEC_KMASKOP): New.\n\t(UNSPEC_KMOV): Remove.\n\t(kmovw): Expand to plain HImode move.\n\t(k<any_logic:code><mode>): Rename from *k<logic><mode>. Use\n\tregister_operand predicates.  Tag pattern with UNSPEC_KMASKOP.\n\tRemove corresponding clobber-removing splitter.\n\t(*anddi_1): Remove mask register alternatives.\n\t(*andsi_1): Ditto.\n\t(*andhi_1): Ditto.\n\t(*andqi_1): Ditto.\n\t(*<any_or:code><mode>_1): Ditto.\n\t(*<any_or:code>qi_1): Ditto.\n\t(kandn<mode>): Use SWI1248_AVX512BW mode iterator.  Remove\n\tgeneral register alternatives.  Tag pattern with UNSPEC_KMASKOP.\n\tRemove corresponding splitter to operation with general registers.\n\t(*andn<SWI38:mode>): Rename from *bmi_andn_<mode>.\n\t(*andn<SWI12:mode>): New pattern.\n\t(*kxnor<mode>): Remove general register alternatives.  Tag pattern\n\twith UNSPEC_KMASKOP.  Remove corresponding splitter to operation\n\twith general registers.\n\t(knot<mode>): New insn pattern.\n\t(*one_cmpl<mode>2_1): Remove mask register alternatives.\n\t(one_cmplqi2_1): Ditto.\n\t(*k<any_lshift:code><mode>): Rename from *k<mshift><mode>3.\n\tTag pattern with UNSPEC_KMASKOP. Add mode attribute.\n\t* config/i386/predicates.md (mask_reg_operand): Remove predicate.\n\t* config/i386/sse.md (vec_unpacks_hi_hi): Update pattern\n\tto generate kmaskop shift.\n\t(vec_unpacks_hi_<mode>): Ditto.\n\t* config/i386/i386-builtin.def (__builtin_ia32_kandhi):\n\tUse CODE_FOR_kandhi.\n\t(__builtin_ia32_knothi): Use CODE_FOR_knothi.\n\t(__builtin_ia32_korhi): Use CODE_FOR_kiorhi.\n\t(__builtin_ia32_kxorhi): Use CODE_FOR_kxorhi.\n\ntestsuite/ChangeLog:\n\n\t* gcc.target/i386/bmi-andn-1a.c (dg-final): Update scan string.\n\t* gcc.target/i386/bmi-andn-2a.c (dg-final): Ditto.\n\nFrom-SVN: r242925", "tree": {"sha": "ad79fdbe20921ca158c76f860417c5bbf00435ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad79fdbe20921ca158c76f860417c5bbf00435ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/comments", "author": null, "committer": null, "parents": [{"sha": "f4bb5c171e3bcb244f90dfee5aae6e2bc9f92029", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4bb5c171e3bcb244f90dfee5aae6e2bc9f92029", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4bb5c171e3bcb244f90dfee5aae6e2bc9f92029"}], "stats": {"total": 443, "additions": 189, "deletions": 254}, "files": [{"sha": "b909e77b3c74eacd7243d1154dd24ec58ac36cc9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf", "patch": "@@ -1,3 +1,40 @@\n+2016-11-28  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (UNSPEC_KMASKOP): New.\n+\t(UNSPEC_KMOV): Remove.\n+\t(kmovw): Expand to plain HImode move.\n+\t(k<any_logic:code><mode>): Rename from *k<logic><mode>. Use\n+\tregister_operand predicates.  Tag pattern with UNSPEC_KMASKOP.\n+\tRemove corresponding clobber-removing splitter.\n+\t(*anddi_1): Remove mask register alternatives.\n+\t(*andsi_1): Ditto.\n+\t(*andhi_1): Ditto.\n+\t(*andqi_1): Ditto.\n+\t(*<any_or:code><mode>_1): Ditto.\n+\t(*<any_or:code>qi_1): Ditto.\n+\t(kandn<mode>): Use SWI1248_AVX512BW mode iterator.  Remove\n+\tgeneral register alternatives.  Tag pattern with UNSPEC_KMASKOP.\n+\tRemove corresponding splitter to operation with general registers.\n+\t(*andn<SWI38:mode>): Rename from *bmi_andn_<mode>.\n+\t(*andn<SWI12:mode>): New pattern.\n+\t(*kxnor<mode>): Remove general register alternatives.  Tag pattern\n+\twith UNSPEC_KMASKOP.  Remove corresponding splitter to operation\n+\twith general registers.\n+\t(knot<mode>): New insn pattern.\n+\t(*one_cmpl<mode>2_1): Remove mask register alternatives.\n+\t(one_cmplqi2_1): Ditto.\n+\t(*k<any_lshift:code><mode>): Rename from *k<mshift><mode>3.\n+\tTag pattern with UNSPEC_KMASKOP. Add mode attribute.\n+\t* config/i386/predicates.md (mask_reg_operand): Remove predicate.\n+\t* config/i386/sse.md (vec_unpacks_hi_hi): Update pattern\n+\tto generate kmaskop shift.\n+\t(vec_unpacks_hi_<mode>): Ditto.\n+\t* config/i386/i386-builtin.def (__builtin_ia32_kandhi):\n+\tUse CODE_FOR_kandhi.\n+\t(__builtin_ia32_knothi): Use CODE_FOR_knothi.\n+\t(__builtin_ia32_korhi): Use CODE_FOR_kiorhi.\n+\t(__builtin_ia32_kxorhi): Use CODE_FOR_kxorhi.\n+\n 2016-11-28  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vrp.c (vrp_visit_assignment_or_call): Handle\n@@ -124,8 +161,7 @@\n \n \tPR lto/78211\n \t* ipa-icf.h (sem_item_optimizer): Add m_classes_vec member.\n-\t* ipa-icf.c (sem_item_optimizer::sem_item_optimizer): Initialize\n-\tit.\n+\t* ipa-icf.c (sem_item_optimizer::sem_item_optimizer): Initialize it.\n \t(sem_item_optimizer::~sem_item_optimizer): Traverse m_classes_vec\n \tvector instead of traversing m_classes hash table.  Release\n \tm_classes_vec.\n@@ -220,11 +256,10 @@\n \tPR target/71767\n \t* configure.ac (with-ld64): New var, set for Darwin, set on\n \tdetection of ld64, gcc_cv_ld64_export_dynamic: New, New test.\n-\t* config/darwin.h: Use LD64_HAS_DYNAMIC export. DEF_LD64: New,\n-\tdefine.\n+\t* config/darwin.h: Use LD64_HAS_DYNAMIC export. DEF_LD64: New, define.\n \t* config/darwin10.h(DEF_LD64): Update for this target version.\n-\t* config/darwin12.h(LINK_GCC_C_SEQUENCE_SPEC): Remove rdynamic\n-\ttest.  (DEF_LD64): Update for this target version.\n+\t* config/darwin12.h(LINK_GCC_C_SEQUENCE_SPEC): Remove rdynamic test.\n+\t(DEF_LD64): Update for this target version.\n \t* configure: Regenerated.\n \t* config.in: Regenerated.\n "}, {"sha": "a9c272ac137c45893751337848981ac3c486d0e9", "filename": "gcc/config/i386/i386-builtin.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Fconfig%2Fi386%2Fi386-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Fconfig%2Fi386%2Fi386-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin.def?ref=bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf", "patch": "@@ -1436,15 +1436,15 @@ BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_roundpd_vec_pack_sfix512, \"__bu\n BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_avx512f_roundpd_vec_pack_sfix512, \"__builtin_ia32_ceilpd_vec_pack_sfix512\", IX86_BUILTIN_CEILPD_VEC_PACK_SFIX512, (enum rtx_code) ROUND_CEIL, (int) V16SI_FTYPE_V8DF_V8DF_ROUND)\n \n /* Mask arithmetic operations */\n-BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_andhi3, \"__builtin_ia32_kandhi\", IX86_BUILTIN_KAND16, UNKNOWN, (int) UHI_FTYPE_UHI_UHI)\n+BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_kandhi, \"__builtin_ia32_kandhi\", IX86_BUILTIN_KAND16, UNKNOWN, (int) UHI_FTYPE_UHI_UHI)\n BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_kandnhi, \"__builtin_ia32_kandnhi\", IX86_BUILTIN_KANDN16, UNKNOWN, (int) UHI_FTYPE_UHI_UHI)\n-BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_one_cmplhi2, \"__builtin_ia32_knothi\", IX86_BUILTIN_KNOT16, UNKNOWN, (int) UHI_FTYPE_UHI)\n-BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_iorhi3, \"__builtin_ia32_korhi\", IX86_BUILTIN_KOR16, UNKNOWN, (int) UHI_FTYPE_UHI_UHI)\n+BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_knothi, \"__builtin_ia32_knothi\", IX86_BUILTIN_KNOT16, UNKNOWN, (int) UHI_FTYPE_UHI)\n+BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_kiorhi, \"__builtin_ia32_korhi\", IX86_BUILTIN_KOR16, UNKNOWN, (int) UHI_FTYPE_UHI_UHI)\n BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_kortestchi, \"__builtin_ia32_kortestchi\", IX86_BUILTIN_KORTESTC16, UNKNOWN, (int) UHI_FTYPE_UHI_UHI)\n BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_kortestzhi, \"__builtin_ia32_kortestzhi\", IX86_BUILTIN_KORTESTZ16, UNKNOWN, (int) UHI_FTYPE_UHI_UHI)\n BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_kunpckhi, \"__builtin_ia32_kunpckhi\", IX86_BUILTIN_KUNPCKBW, UNKNOWN, (int) UHI_FTYPE_UHI_UHI)\n BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_kxnorhi, \"__builtin_ia32_kxnorhi\", IX86_BUILTIN_KXNOR16, UNKNOWN, (int) UHI_FTYPE_UHI_UHI)\n-BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_xorhi3, \"__builtin_ia32_kxorhi\", IX86_BUILTIN_KXOR16, UNKNOWN, (int) UHI_FTYPE_UHI_UHI)\n+BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_kxorhi, \"__builtin_ia32_kxorhi\", IX86_BUILTIN_KXOR16, UNKNOWN, (int) UHI_FTYPE_UHI_UHI)\n BDESC (OPTION_MASK_ISA_AVX512F, CODE_FOR_kmovw, \"__builtin_ia32_kmov16\", IX86_BUILTIN_KMOV16, UNKNOWN, (int) UHI_FTYPE_UHI)\n \n /* SHA */"}, {"sha": "123c4b8ccbd307bf1dff53a382cd707d5048d670", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 125, "deletions": 228, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf", "patch": "@@ -187,7 +187,7 @@\n   UNSPEC_PEXT\n \n   ;; For AVX512F support\n-  UNSPEC_KMOV\n+  UNSPEC_KMASKOP\n \n   UNSPEC_BNDMK\n   UNSPEC_BNDMK_ADDR\n@@ -2489,18 +2489,10 @@\n \t   ]\n \t   (const_string \"SI\")))])\n \n-(define_insn \"kmovw\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=k,k\")\n-\t(unspec:HI\n-\t  [(match_operand:HI 1 \"nonimmediate_operand\" \"r,km\")]\n-\t  UNSPEC_KMOV))]\n-  \"TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"@\n-   kmovw\\t{%k1, %0|%0, %k1}\n-   kmovw\\t{%1, %0|%0, %1}\";\n-  [(set_attr \"type\" \"mskmov\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"HI\")])\n+(define_expand \"kmovw\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\")\n+\t(match_operand:HI 1 \"nonimmediate_operand\"))]\n+  \"TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))\")\n \n (define_insn \"*movhi_internal\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r ,r ,m ,k,k ,r,m\")\n@@ -8069,28 +8061,19 @@\n   operands[3] = gen_lowpart (QImode, operands[3]);\n })\n \n-(define_split\n-  [(set (match_operand:SWI1248x 0 \"mask_reg_operand\")\n-\t(any_logic:SWI1248x (match_operand:SWI1248x 1 \"mask_reg_operand\")\n-\t\t\t    (match_operand:SWI1248x 2 \"mask_reg_operand\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_AVX512F && reload_completed\"\n-  [(set (match_dup 0)\n-\t(any_logic:SWI1248x (match_dup 1)\n-\t\t\t    (match_dup 2)))])\n-\n-(define_insn \"*k<logic><mode>\"\n-  [(set (match_operand:SWI1248_AVX512BW 0 \"mask_reg_operand\" \"=k\")\n+(define_insn \"k<code><mode>\"\n+  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=k\")\n \t(any_logic:SWI1248_AVX512BW\n-\t  (match_operand:SWI1248_AVX512BW 1 \"mask_reg_operand\" \"k\")\n-\t  (match_operand:SWI1248_AVX512BW 2 \"mask_reg_operand\" \"k\")))]\n+\t  (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"k\")\n+\t  (match_operand:SWI1248_AVX512BW 2 \"register_operand\" \"k\")))\n+   (unspec [(const_int 0)] UNSPEC_KMASKOP)]\n   \"TARGET_AVX512F\"\n-  {\n-    if (get_attr_mode (insn) == MODE_HI)\n-      return \"k<logic>w\\t{%2, %1, %0|%0, %1, %2}\";\n-    else\n-      return \"k<logic><mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n-  }\n+{\n+  if (get_attr_mode (insn) == MODE_HI)\n+    return \"k<logic>w\\t{%2, %1, %0|%0, %1, %2}\";\n+  else\n+    return \"k<logic><mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n+}\n   [(set_attr \"type\" \"msklog\")\n    (set_attr \"prefix\" \"vex\")\n    (set (attr \"mode\")\n@@ -8183,10 +8166,10 @@\n })\n \n (define_insn \"*anddi_1\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm,r,r,!k\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm,r,r\")\n \t(and:DI\n-\t (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0,qm,k\")\n-\t (match_operand:DI 2 \"x86_64_szext_general_operand\" \"Z,re,rm,L,k\")))\n+\t (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0,qm\")\n+\t (match_operand:DI 2 \"x86_64_szext_general_operand\" \"Z,re,rm,L\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (AND, DImode, operands)\"\n {\n@@ -8195,9 +8178,6 @@\n     case TYPE_IMOVX:\n       return \"#\";\n \n-    case TYPE_MSKLOG:\n-      return \"kandq\\t{%2, %1, %0|%0, %1, %2}\";\n-\n     default:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       if (get_attr_mode (insn) == MODE_SI)\n@@ -8206,16 +8186,16 @@\n \treturn \"and{q}\\t{%2, %0|%0, %2}\";\n     }\n }\n-  [(set_attr \"type\" \"alu,alu,alu,imovx,msklog\")\n-   (set_attr \"length_immediate\" \"*,*,*,0,0\")\n+  [(set_attr \"type\" \"alu,alu,alu,imovx\")\n+   (set_attr \"length_immediate\" \"*,*,*,0\")\n    (set (attr \"prefix_rex\")\n      (if_then_else\n        (and (eq_attr \"type\" \"imovx\")\n \t    (and (match_test \"INTVAL (operands[2]) == 0xff\")\n \t\t (match_operand 1 \"ext_QIreg_operand\")))\n        (const_string \"1\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"SI,DI,DI,SI,DI\")])\n+   (set_attr \"mode\" \"SI,DI,DI,SI\")])\n \n ;; Turn *anddi_1 into *andsi_1_zext if possible.\n (define_split\n@@ -8242,9 +8222,9 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*andsi_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r,Ya,!k\")\n-\t(and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,qm,k\")\n-\t\t(match_operand:SI 2 \"x86_64_general_operand\" \"re,rm,L,k\")))\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r,Ya\")\n+\t(and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,qm\")\n+\t\t(match_operand:SI 2 \"x86_64_general_operand\" \"re,rm,L\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (AND, SImode, operands)\"\n {\n@@ -8253,29 +8233,26 @@\n     case TYPE_IMOVX:\n       return \"#\";\n \n-    case TYPE_MSKLOG:\n-      return \"kandd\\t{%2, %1, %0|%0, %1, %2}\";\n-\n     default:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       return \"and{l}\\t{%2, %0|%0, %2}\";\n     }\n }\n-  [(set_attr \"type\" \"alu,alu,imovx,msklog\")\n+  [(set_attr \"type\" \"alu,alu,imovx\")\n    (set (attr \"prefix_rex\")\n      (if_then_else\n        (and (eq_attr \"type\" \"imovx\")\n \t    (and (match_test \"INTVAL (operands[2]) == 0xff\")\n \t\t (match_operand 1 \"ext_QIreg_operand\")))\n        (const_string \"1\")\n        (const_string \"*\")))\n-   (set_attr \"length_immediate\" \"*,*,0,0\")\n+   (set_attr \"length_immediate\" \"*,*,0\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*andhi_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r,Ya,!k\")\n-\t(and:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0,qm,k\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"rn,rm,L,k\")))\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r,Ya\")\n+\t(and:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0,qm\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"rn,rm,L\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (AND, HImode, operands)\"\n {\n@@ -8284,28 +8261,25 @@\n     case TYPE_IMOVX:\n       return \"#\";\n \n-    case TYPE_MSKLOG:\n-      return \"kandw\\t{%2, %1, %0|%0, %1, %2}\";\n-\n     default:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       return \"and{w}\\t{%2, %0|%0, %2}\";\n     }\n }\n-  [(set_attr \"type\" \"alu,alu,imovx,msklog\")\n-   (set_attr \"length_immediate\" \"*,*,0,*\")\n+  [(set_attr \"type\" \"alu,alu,imovx\")\n+   (set_attr \"length_immediate\" \"*,*,0\")\n    (set (attr \"prefix_rex\")\n      (if_then_else\n        (and (eq_attr \"type\" \"imovx\")\n \t    (match_operand 1 \"ext_QIreg_operand\"))\n        (const_string \"1\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"HI,HI,SI,HI\")])\n+   (set_attr \"mode\" \"HI,HI,SI\")])\n \n (define_insn \"*andqi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q,r,!k\")\n-\t(and:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0,k\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"qn,qmn,rn,k\")))\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q,r\")\n+\t(and:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"qn,qmn,rn\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (AND, QImode, operands)\"\n {\n@@ -8316,23 +8290,12 @@\n       return \"and{b}\\t{%2, %0|%0, %2}\";\n     case 2:\n       return \"and{l}\\t{%k2, %k0|%k0, %k2}\";\n-    case 3:\n-      if (get_attr_mode (insn) == MODE_HI)\n-\treturn \"kandw\\t{%2, %1, %0|%0, %1, %2}\";\n-      else\n-\treturn \"kandb\\t{%2, %1, %0|%0, %1, %2}\";\n     default:\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\" \"alu,alu,alu,msklog\")\n-   (set (attr \"mode\")\n-      (cond [(eq_attr \"alternative\" \"2\")\n-\t       (const_string \"SI\")\n-\t     (and (eq_attr \"alternative\" \"3\")\n-\t\t  (not (match_test \"TARGET_AVX512DQ\")))\n-\t       (const_string \"HI\")]\n-\t    (const_string \"QI\")))\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"QI,QI,SI\")\n    ;; Potential partial reg stall on alternative 2.\n    (set (attr \"preferred_for_speed\")\n      (cond [(eq_attr \"alternative\" \"2\")\n@@ -8665,56 +8628,28 @@\n })\n \n (define_insn \"kandn<mode>\"\n-  [(set (match_operand:SWI12 0 \"register_operand\" \"=r,&r,!k\")\n-\t(and:SWI12\n-\t  (not:SWI12\n-\t    (match_operand:SWI12 1 \"register_operand\" \"r,0,k\"))\n-\t  (match_operand:SWI12 2 \"register_operand\" \"r,r,k\")))\n-   (clobber (reg:CC FLAGS_REG))]\n+  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=k\")\n+\t(and:SWI1248_AVX512BW\n+\t  (not:SWI1248_AVX512BW\n+\t    (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"k\"))\n+\t  (match_operand:SWI1248_AVX512BW 2 \"register_operand\" \"k\")))\n+   (unspec [(const_int 0)] UNSPEC_KMASKOP)]\n   \"TARGET_AVX512F\"\n {\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"andn\\t{%k2, %k1, %k0|%k0, %k1, %k2}\";\n-    case 1:\n-      return \"#\";\n-    case 2:\n-      if (get_attr_mode (insn) == MODE_HI)\n-\treturn \"kandnw\\t{%2, %1, %0|%0, %1, %2}\";\n-      else\n-\treturn \"kandn<mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n-    default:\n-      gcc_unreachable ();\n-    }\n+  if (get_attr_mode (insn) == MODE_HI)\n+    return \"kandnw\\t{%2, %1, %0|%0, %1, %2}\";\n+  else\n+    return \"kandn<mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n }\n-  [(set_attr \"isa\" \"bmi,*,avx512f\")\n-   (set_attr \"type\" \"bitmanip,*,msklog\")\n-   (set_attr \"prefix\" \"*,*,vex\")\n-   (set_attr \"btver2_decode\" \"direct,*,*\")\n+  [(set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")\n    (set (attr \"mode\")\n-     (cond [(and (eq_attr \"alternative\" \"2\")\n-\t\t (and (match_test \"<MODE>mode == QImode\")\n-\t\t      (not (match_test \"TARGET_AVX512DQ\"))))\n-\t       (const_string \"HI\")\n+     (cond [(and (match_test \"<MODE>mode == QImode\")\n+\t\t (not (match_test \"TARGET_AVX512DQ\")))\n+\t      (const_string \"HI\")\n \t   ]\n \t   (const_string \"<MODE>\")))])\n \n-(define_split\n-  [(set (match_operand:SWI12 0 \"general_reg_operand\")\n-\t(and:SWI12\n-\t  (not:SWI12\n-\t    (match_dup 0))\n-\t  (match_operand:SWI12 1 \"general_reg_operand\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_AVX512F && !TARGET_BMI && reload_completed\"\n-  [(set (match_dup 0)\n-\t(not:SWI12 (match_dup 0)))\n-   (parallel [(set (match_dup 0)\n-\t\t   (and:SWI12 (match_dup 0)\n-\t\t\t      (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])])\n-\n (define_insn_and_split \"*andndi3_doubleword\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI\n@@ -8732,7 +8667,7 @@\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"split_double_mode (DImode, &operands[0], 3, &operands[0], &operands[3]);\")\n \n-(define_insn \"*bmi_andn_<mode>\"\n+(define_insn \"*andn<mode>_1\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r,r\")\n \t(and:SWI48\n \t  (not:SWI48 (match_operand:SWI48 1 \"register_operand\" \"r,r\"))\n@@ -8744,6 +8679,18 @@\n    (set_attr \"btver2_decode\" \"direct, double\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn \"*andn<mode>_1\"\n+  [(set (match_operand:SWI12 0 \"register_operand\" \"=r\")\n+\t(and:SWI12\n+\t  (not:SWI12 (match_operand:SWI12 1 \"register_operand\" \"r\"))\n+\t  (match_operand:SWI12 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_BMI\"\n+  \"andn\\t{%k2, %k1, %k0|%k0, %k1, %k2}\"\n+  [(set_attr \"type\" \"bitmanip\")\n+   (set_attr \"btver2_decode\" \"direct\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*bmi_andn_<mode>_ccno\"\n   [(set (reg FLAGS_REG)\n \t(compare\n@@ -8813,17 +8760,14 @@\n })\n \n (define_insn \"*<code><mode>_1\"\n-  [(set (match_operand:SWI48 0 \"nonimmediate_operand\" \"=r,rm,k\")\n-\t(any_or:SWI48\n-\t (match_operand:SWI48 1 \"nonimmediate_operand\" \"%0,0,k\")\n-\t (match_operand:SWI48 2 \"<general_operand>\" \"<g>,r<i>,k\")))\n+  [(set (match_operand:SWI248 0 \"nonimmediate_operand\" \"=r,rm\")\n+\t(any_or:SWI248\n+\t (match_operand:SWI248 1 \"nonimmediate_operand\" \"%0,0\")\n+\t (match_operand:SWI248 2 \"<general_operand>\" \"<g>,r<i>\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n-  \"@\n-   <logic>{<imodesuffix>}\\t{%2, %0|%0, %2}\n-   <logic>{<imodesuffix>}\\t{%2, %0|%0, %2}\n-   k<logic><mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"alu,alu,msklog\")\n+  \"<logic>{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; See comment for addsi_1_zext why we do use nonimmediate_operand\n@@ -8849,33 +8793,18 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*<code>hi_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,rm,!k\")\n-\t(any_or:HI\n-\t (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0,k\")\n-\t (match_operand:HI 2 \"general_operand\" \"rmn,rn,k\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (<CODE>, HImode, operands)\"\n-  \"@\n-  <logic>{w}\\t{%2, %0|%0, %2}\n-  <logic>{w}\\t{%2, %0|%0, %2}\n-  k<logic>w\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"alu,alu,msklog\")\n-   (set_attr \"mode\" \"HI\")])\n-\n (define_insn \"*<code>qi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,r,!k\")\n-\t(any_or:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0,k\")\n-\t\t   (match_operand:QI 2 \"general_operand\" \"qmn,qn,rn,k\")))\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,r\")\n+\t(any_or:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"qmn,qn,rn\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (<CODE>, QImode, operands)\"\n   \"@\n    <logic>{b}\\t{%2, %0|%0, %2}\n    <logic>{b}\\t{%2, %0|%0, %2}\n-   <logic>{l}\\t{%k2, %k0|%k0, %k2}\n-   k<logic>w\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"alu,alu,alu,msklog\")\n-   (set_attr \"mode\" \"QI,QI,SI,HI\")\n+   <logic>{l}\\t{%k2, %k0|%k0, %k2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"QI,QI,SI\")\n    ;; Potential partial reg stall on alternative 2.\n    (set (attr \"preferred_for_speed\")\n      (cond [(eq_attr \"alternative\" \"2\")\n@@ -9111,47 +9040,28 @@\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"kxnor<mode>\"\n-  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=r,!k\")\n+  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=k\")\n \t(not:SWI1248_AVX512BW\n \t  (xor:SWI1248_AVX512BW\n-\t    (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"0,k\")\n-\t    (match_operand:SWI1248_AVX512BW 2 \"register_operand\" \"r,k\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n+\t    (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"k\")\n+\t    (match_operand:SWI1248_AVX512BW 2 \"register_operand\" \"k\"))))\n+   (unspec [(const_int 0)] UNSPEC_KMASKOP)]\n   \"TARGET_AVX512F\"\n {\n-  if (which_alternative == 0)\n-    return \"#\";\n-\n   if (get_attr_mode (insn) == MODE_HI)\n     return \"kxnorw\\t{%2, %1, %0|%0, %1, %2}\";\n   else\n     return \"kxnor<mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n }\n-  [(set_attr \"type\" \"*,msklog\")\n-   (set_attr \"prefix\" \"*,vex\")\n+  [(set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")\n    (set (attr \"mode\")\n-     (cond [(and (eq_attr \"alternative\" \"1\")\n-\t\t (and (match_test \"<MODE>mode == QImode\")\n-\t\t      (not (match_test \"TARGET_AVX512DQ\"))))\n+     (cond [(and (match_test \"<MODE>mode == QImode\")\n+\t\t (not (match_test \"TARGET_AVX512DQ\")))\n \t      (const_string \"HI\")\n \t   ]\n \t   (const_string \"<MODE>\")))])\n \n-(define_split\n-  [(set (match_operand:SWI1248x 0 \"general_reg_operand\")\n-\t(not:SWI1248x\n-\t  (xor:SWI1248x\n-\t    (match_dup 0)\n-\t    (match_operand:SWI1248x 1 \"general_reg_operand\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_AVX512F && reload_completed\"\n-   [(parallel [(set (match_dup 0)\n-\t\t    (xor:SWI1248x (match_dup 0)\n-\t\t\t\t  (match_dup 1)))\n-\t       (clobber (reg:CC FLAGS_REG))])\n-    (set (match_dup 0)\n-\t (not:SWI1248x (match_dup 0)))])\n-\n ;;There are kortrest[bdq] but no intrinsics for them.\n ;;We probably don't need to implement them.\n (define_insn \"kortestzhi\"\n@@ -9604,22 +9514,39 @@\n \f\n ;; One complement instructions\n \n+(define_insn \"knot<mode>\"\n+  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=k\")\n+\t(not:SWI1248_AVX512BW\n+\t  (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"k\")))\n+   (unspec [(const_int 0)] UNSPEC_KMASKOP)]\n+  \"TARGET_AVX512F\"\n+{\n+  if (get_attr_mode (insn) == MODE_HI)\n+    return \"knotw\\t{%1, %0|%0, %1}\";\n+  else\n+    return \"knot<mskmodesuffix>\\t{%1, %0|%0, %1}\";\n+}\n+  [(set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")\n+   (set (attr \"mode\")\n+     (cond [(and (match_test \"<MODE>mode == QImode\")\n+\t\t (not (match_test \"TARGET_AVX512DQ\")))\n+\t       (const_string \"HI\")\n+\t   ]\n+\t   (const_string \"<MODE>\")))])\n+\n (define_expand \"one_cmpl<mode>2\"\n   [(set (match_operand:SWIM 0 \"nonimmediate_operand\")\n \t(not:SWIM (match_operand:SWIM 1 \"nonimmediate_operand\")))]\n   \"\"\n   \"ix86_expand_unary_operator (NOT, <MODE>mode, operands); DONE;\")\n \n (define_insn \"*one_cmpl<mode>2_1\"\n-  [(set (match_operand:SWI48 0 \"nonimmediate_operand\" \"=rm,k\")\n-\t(not:SWI48 (match_operand:SWI48 1 \"nonimmediate_operand\" \"0,k\")))]\n+  [(set (match_operand:SWI248 0 \"nonimmediate_operand\" \"=rm\")\n+\t(not:SWI248 (match_operand:SWI248 1 \"nonimmediate_operand\" \"0\")))]\n   \"ix86_unary_operator_ok (NOT, <MODE>mode, operands)\"\n-  \"@\n-   not{<imodesuffix>}\\t%0\n-   knot<mskmodesuffix>\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"isa\" \"*,avx512bw\")\n-   (set_attr \"type\" \"negnot,msklog\")\n-   (set_attr \"prefix\" \"*,vex\")\n+  \"not{<imodesuffix>}\\t%0\"\n+  [(set_attr \"type\" \"negnot\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; ??? Currently never generated - xor is used instead.\n@@ -9632,48 +9559,15 @@\n   [(set_attr \"type\" \"negnot\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*one_cmplhi2_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,!k\")\n-\t(not:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0,k\")))]\n-  \"ix86_unary_operator_ok (NOT, HImode, operands)\"\n-  \"@\n-   not{w}\\t%0\n-   knotw\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"isa\" \"*,avx512f\")\n-   (set_attr \"type\" \"negnot,msklog\")\n-   (set_attr \"prefix\" \"*,vex\")\n-   (set_attr \"mode\" \"HI\")])\n-\n (define_insn \"*one_cmplqi2_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,r,!k\")\n-\t(not:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0,k\")))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,r\")\n+\t(not:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")))]\n   \"ix86_unary_operator_ok (NOT, QImode, operands)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"not{b}\\t%0\";\n-    case 1:\n-      return \"not{l}\\t%k0\";\n-    case 2:\n-      if (get_attr_mode (insn) == MODE_HI)\n-\treturn \"knotw\\t{%1, %0|%0, %1}\";\n-      else\n-\treturn \"knotb\\t{%1, %0|%0, %1}\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"isa\" \"*,*,avx512f\")\n-   (set_attr \"type\" \"negnot,negnot,msklog\")\n-   (set_attr \"prefix\" \"*,*,vex\")\n-   (set (attr \"mode\")\n-      (cond [(eq_attr \"alternative\" \"1\")\n-\t       (const_string \"SI\")\n-\t     (and (eq_attr \"alternative\" \"2\")\n-\t\t  (not (match_test \"TARGET_AVX512DQ\")))\n-\t       (const_string \"HI\")]\n-\t    (const_string \"QI\")))\n+  \"@\n+   not{b}\\t%0\n+   not{l}\\t%k0\"\n+  [(set_attr \"type\" \"negnot\")\n+   (set_attr \"mode\" \"QI,SI\")\n    ;; Potential partial reg stall on alternative 1.\n    (set (attr \"preferred_for_speed\")\n      (cond [(eq_attr \"alternative\" \"1\")\n@@ -9757,14 +9651,17 @@\n ;; shift pair, instead using moves and sign extension for counts greater\n ;; than 31.\n \n-(define_insn \"*<mshift><mode>3\"\n+(define_insn \"*k<code><mode>\"\n   [(set (match_operand:SWI1248_AVX512BWDQ 0 \"register_operand\" \"=k\")\n-\t(any_lshift:SWI1248_AVX512BWDQ (match_operand:SWI1248_AVX512BWDQ 1 \"register_operand\" \"k\")\n-\t\t\t\t       (match_operand:QI 2 \"immediate_operand\" \"i\")))]\n+\t(any_lshift:SWI1248_AVX512BWDQ\n+\t  (match_operand:SWI1248_AVX512BWDQ 1 \"register_operand\" \"k\")\n+\t  (match_operand:QI 2 \"immediate_operand\" \"n\")))\n+   (unspec [(const_int 0)] UNSPEC_KMASKOP)]\n   \"TARGET_AVX512F\"\n   \"k<mshift><mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"msklog\")\n-   (set_attr \"prefix\" \"vex\")])\n+   (set_attr \"prefix\" \"vex\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_expand \"ashl<mode>3\"\n   [(set (match_operand:SDWIM 0 \"<shift_operand>\")"}, {"sha": "59566909f7e4887cf50ac93f16bdaf008152b142", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf", "patch": "@@ -53,11 +53,6 @@\n   (and (match_code \"reg\")\n        (match_test \"EXT_REX_SSE_REGNO_P (REGNO (op))\")))\n \n-;; True if the operand is an AVX-512 mask register.\n-(define_predicate \"mask_reg_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"MASK_REGNO_P (REGNO (op))\")))\n-\n ;; Return true if op is a QImode register.\n (define_predicate \"any_QIreg_operand\"\n   (and (match_code \"reg\")"}, {"sha": "82d49985f7ed5be0980f46b14f595cbc92bc948c", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf", "patch": "@@ -13712,19 +13712,22 @@\n   \"ix86_expand_sse_unpack (operands[0], operands[1], true, true); DONE;\")\n \n (define_expand \"vec_unpacks_hi_hi\"\n-  [(set (subreg:HI (match_operand:QI 0 \"register_operand\") 0)\n-        (lshiftrt:HI (match_operand:HI 1 \"register_operand\")\n-                     (const_int 8)))]\n+  [(parallel\n+     [(set (subreg:HI (match_operand:QI 0 \"register_operand\") 0)\n+\t   (lshiftrt:HI (match_operand:HI 1 \"register_operand\")\n+\t\t\t(const_int 8)))\n+      (unspec [(const_int 0)] UNSPEC_KMASKOP)])]\n   \"TARGET_AVX512F\")\n \n (define_expand \"vec_unpacks_hi_<mode>\"\n-  [(set (subreg:SWI48x (match_operand:<HALFMASKMODE> 0 \"register_operand\") 0)\n-        (lshiftrt:SWI48x (match_operand:SWI48x 1 \"register_operand\")\n-                         (match_dup 2)))]\n+  [(parallel\n+     [(set (subreg:SWI48x\n+\t     (match_operand:<HALFMASKMODE> 0 \"register_operand\") 0)\n+\t   (lshiftrt:SWI48x (match_operand:SWI48x 1 \"register_operand\")\n+\t\t\t    (match_dup 2)))\n+      (unspec [(const_int 0)] UNSPEC_KMASKOP)])]\n   \"TARGET_AVX512BW\"\n-{\n-  operands[2] = GEN_INT (GET_MODE_BITSIZE (<HALFMASKMODE>mode));\n-})\n+  \"operands[2] = GEN_INT (GET_MODE_BITSIZE (<HALFMASKMODE>mode));\")\n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;"}, {"sha": "25d7d37d66baa5fe1b1f86e9de5f0e9030fffc2c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf", "patch": "@@ -1,3 +1,8 @@\n+2016-11-28  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* gcc.target/i386/bmi-andn-1a.c (dg-final): Update scan string.\n+\t* gcc.target/i386/bmi-andn-2a.c (dg-final): Ditto.\n+\n 2016-11-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/77591"}, {"sha": "f3e80ec7e4d3c6362fa1ec11bbe0267e6a0816c7", "filename": "gcc/testsuite/gcc.target/i386/bmi-andn-1a.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbmi-andn-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbmi-andn-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbmi-andn-1a.c?ref=bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf", "patch": "@@ -3,4 +3,4 @@\n \n #include \"bmi-andn-1.c\"\n \n-/* { dg-final { scan-assembler-times \"bmi_andn_di\" 1 } } */\n+/* { dg-final { scan-assembler-times \"andndi\" 1 } } */"}, {"sha": "5d893eb9615ac655f2f13f92f3791a2c3c910490", "filename": "gcc/testsuite/gcc.target/i386/bmi-andn-2a.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbmi-andn-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbmi-andn-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbmi-andn-2a.c?ref=bf9e8b6b50952b31d04179bae1ebb4c09ffdc1cf", "patch": "@@ -3,4 +3,4 @@\n \n #include \"bmi-andn-2.c\"\n \n-/* { dg-final { scan-assembler-times \"bmi_andn_si\" 1 } } */\n+/* { dg-final { scan-assembler-times \"andnsi\" 1 } } */"}]}