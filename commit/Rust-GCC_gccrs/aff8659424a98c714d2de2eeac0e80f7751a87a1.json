{"sha": "aff8659424a98c714d2de2eeac0e80f7751a87a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZmODY1OTQyNGE5OGM3MTRkMmRlMmVlYWMwZTgwZjc3NTFhODdhMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-01-27T14:56:54Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-01-27T14:56:54Z"}, "message": "re PR tree-optimization/50444 (-ftree-sra ignores alignment)\n\n2012-01-27  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/50444\n\t* tree-sra.c (build_ref_for_offset): Properly adjust the\n\tMEM_REF type for unaligned accesses.\n\n\t* gcc.dg/torture/pr50444.c: New testcase.\n\nFrom-SVN: r183630", "tree": {"sha": "32ec665bb53ff9c8bb80cf933b2e0e8513aab2ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32ec665bb53ff9c8bb80cf933b2e0e8513aab2ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aff8659424a98c714d2de2eeac0e80f7751a87a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aff8659424a98c714d2de2eeac0e80f7751a87a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aff8659424a98c714d2de2eeac0e80f7751a87a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aff8659424a98c714d2de2eeac0e80f7751a87a1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "223453574e2860830258588ce0104d8971c43ee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/223453574e2860830258588ce0104d8971c43ee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/223453574e2860830258588ce0104d8971c43ee3"}], "stats": {"total": 106, "additions": 106, "deletions": 0}, "files": [{"sha": "009203b51b24060d65a834bd1aed15698f24f11e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aff8659424a98c714d2de2eeac0e80f7751a87a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aff8659424a98c714d2de2eeac0e80f7751a87a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aff8659424a98c714d2de2eeac0e80f7751a87a1", "patch": "@@ -1,3 +1,9 @@\n+2012-01-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/50444\n+\t* tree-sra.c (build_ref_for_offset): Properly adjust the\n+\tMEM_REF type for unaligned accesses.\n+\n 2012-01-27  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/50444"}, {"sha": "d7f276a9b3f8c0070cdca56a709da85eeca1a336", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aff8659424a98c714d2de2eeac0e80f7751a87a1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aff8659424a98c714d2de2eeac0e80f7751a87a1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aff8659424a98c714d2de2eeac0e80f7751a87a1", "patch": "@@ -1,3 +1,8 @@\n+2012-01-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/50444\n+\t* gcc.dg/torture/pr50444.c: New testcase.\n+\n 2012-01-27  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/51970"}, {"sha": "ba192bb0410c44d8ee3ca35dd70ed99b181c6585", "filename": "gcc/testsuite/gcc.dg/torture/pr50444.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aff8659424a98c714d2de2eeac0e80f7751a87a1/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr50444.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aff8659424a98c714d2de2eeac0e80f7751a87a1/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr50444.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr50444.c?ref=aff8659424a98c714d2de2eeac0e80f7751a87a1", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-require-effective-target sse2_runtime } */\n+/* { dg-do run } */\n+/* { dg-options \"-msse2\" } */\n+\n+typedef long long __m128i __attribute__ ((__vector_size__ (16),\n+__may_alias__));\n+typedef int __v4si __attribute__ ((__vector_size__ (16)));\n+typedef long long __v2di __attribute__ ((__vector_size__ (16)));\n+typedef unsigned int uint32_t;\n+\n+typedef struct {\n+    uint32_t v[4];\n+} a4x32;\n+\n+a4x32* incr(a4x32* x)\n+{\n+  x->v[0] += 1;\n+  return x;\n+}\n+\n+typedef struct {\n+    __m128i m;\n+} a1xm128i;\n+\n+static inline  a1xm128i ssefunc( a1xm128i in,  a1xm128i k)\n+{\n+  a1xm128i ret;\n+  ret.m = (__m128i)__builtin_ia32_pxor128 ((__v2di)in.m, (__v2di)k.m);\n+  return ret;\n+}\n+\n+static  a4x32  caster( a4x32 c4x32,  a1xm128i k)\n+{\n+  a1xm128i c1x128;\n+  if( sizeof(c4x32) != sizeof(c1x128) ) __builtin_abort();\n+  __builtin_memcpy(&c1x128, &c4x32, sizeof(c1x128));\n+  c1x128 = ssefunc(c1x128, k);\n+  __builtin_memcpy(&c4x32, &c1x128, sizeof(c4x32));\n+  return c4x32;\n+}\n+\n+typedef struct  {\n+    a1xm128i key;\n+    a4x32 c;\n+    __SIZE_TYPE__ elem;\n+    a4x32 v;\n+} Engine;\n+\n+void ctor(Engine *e)\n+{\n+  e->elem = 0;\n+  e->key.m = (__m128i)(__v4si){ 0, 0, 0, 0 };\n+  e->c.v[0] = 0;\n+  e->c.v[1] = 0;\n+  e->c.v[2] = 0;\n+  e->c.v[3] = 0;\n+}\n+\n+uint32_t method( Engine *e)\n+{\n+  if( e->elem == 0 )\n+    {\n+      e->v = caster(*incr(&e->c), e->key);\n+      e->elem = 4;\n+    }\n+  return e->v.v[--e->elem];\n+}\n+\n+int main()\n+{\n+  Engine e4; ctor(&e4);\n+  Engine e5; ctor(&e5);\n+  if(method(&e4)!=method(&e5))\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "fa67e94cca378e8e7b8842a7d94e220b5ffc00f0", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aff8659424a98c714d2de2eeac0e80f7751a87a1/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aff8659424a98c714d2de2eeac0e80f7751a87a1/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=aff8659424a98c714d2de2eeac0e80f7751a87a1", "patch": "@@ -1461,6 +1461,8 @@ build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n   tree prev_base = base;\n   tree off;\n   HOST_WIDE_INT base_offset;\n+  unsigned HOST_WIDE_INT misalign;\n+  unsigned int align;\n \n   gcc_checking_assert (offset % BITS_PER_UNIT == 0);\n \n@@ -1506,6 +1508,23 @@ build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n       base = build_fold_addr_expr (unshare_expr (base));\n     }\n \n+  /* If prev_base were always an originally performed access\n+     we can extract more optimistic alignment information\n+     by looking at the access mode.  That would constrain the\n+     alignment of base + base_offset which we would need to\n+     adjust according to offset.\n+     ???  But it is not at all clear that prev_base is an access\n+     that was in the IL that way, so be conservative for now.  */\n+  align = get_pointer_alignment_1 (base, &misalign);\n+  misalign += (double_int_sext (tree_to_double_int (off),\n+\t\t\t\tTYPE_PRECISION (TREE_TYPE (off))).low\n+\t       * BITS_PER_UNIT);\n+  misalign = misalign & (align - 1);\n+  if (misalign != 0)\n+    align = (misalign & -misalign);\n+  if (align < TYPE_ALIGN (exp_type))\n+    exp_type = build_aligned_type (exp_type, align);\n+\n   return fold_build2_loc (loc, MEM_REF, exp_type, base, off);\n }\n "}]}