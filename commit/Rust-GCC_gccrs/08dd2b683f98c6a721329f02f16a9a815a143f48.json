{"sha": "08dd2b683f98c6a721329f02f16a9a815a143f48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhkZDJiNjgzZjk4YzZhNzIxMzI5ZjAyZjE2YTlhODE1YTE0M2Y0OA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2016-11-29T02:19:04Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-11-29T02:19:04Z"}, "message": "shrink-wrap: New spread_components\n\nThis patch changes spread_components to use a simpler algorithm that\nputs prologue components as early as possible, and epilogue components\nas late as possible.  This allows better scheduling, and also saves a\nbit of code size.  The blocks that run with some specific component\nenabled after this patch is a strict superset of those that had it\nbefore the patch.\n\nIt does this by finding for every component the basic blocks where that\ncomponent is not needed on some path from the entry block (it reuses\nhead_components to store this), and similarly the blocks where the\ncomponent is not needed on some path to the exit block (or the exit can\nnot be reached from that block) (stored in tail_components).  Blocks\nthat then are not in both of those two sets get the component active.\n\n\n\t* shrink-wrap.c (init_separate_shrink_wrap): Do not clear\n\thead_components and tail_components.\n\t(spread_components): New algorithm.\n\t(emit_common_tails_for_components): Clear head_components and\n\ttail_components.\n\t(insert_prologue_epilogue_for_components): Write extra output to the\n\tdump file for sibcalls and abnormal exits.\n\nFrom-SVN: r242948", "tree": {"sha": "ca3c425636e87de9510053dab45590b1ad003c86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca3c425636e87de9510053dab45590b1ad003c86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08dd2b683f98c6a721329f02f16a9a815a143f48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08dd2b683f98c6a721329f02f16a9a815a143f48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08dd2b683f98c6a721329f02f16a9a815a143f48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08dd2b683f98c6a721329f02f16a9a815a143f48/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8"}], "stats": {"total": 191, "additions": 156, "deletions": 35}, "files": [{"sha": "da6c64097007561f412846bf54e1e7f205702966", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08dd2b683f98c6a721329f02f16a9a815a143f48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08dd2b683f98c6a721329f02f16a9a815a143f48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08dd2b683f98c6a721329f02f16a9a815a143f48", "patch": "@@ -1,3 +1,13 @@\n+2016-11-28  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* shrink-wrap.c (init_separate_shrink_wrap): Do not clear\n+\thead_components and tail_components.\n+\t(spread_components): New algorithm.\n+\t(emit_common_tails_for_components): Clear head_components and\n+\ttail_components.\n+\t(insert_prologue_epilogue_for_components): Write extra output to the\n+\tdump file for sibcalls and abnormal exits.\n+\n 2016-11-28  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/78342"}, {"sha": "59feca15aead9b913485a76e5b52192749663dfc", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 146, "deletions": 35, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08dd2b683f98c6a721329f02f16a9a815a143f48/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08dd2b683f98c6a721329f02f16a9a815a143f48/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=08dd2b683f98c6a721329f02f16a9a815a143f48", "patch": "@@ -1131,8 +1131,6 @@ init_separate_shrink_wrap (sbitmap components)\n       SW (bb)->head_components = sbitmap_alloc (SBITMAP_SIZE (components));\n       SW (bb)->tail_components = sbitmap_alloc (SBITMAP_SIZE (components));\n       bitmap_clear (SW (bb)->has_components);\n-      bitmap_clear (SW (bb)->head_components);\n-      bitmap_clear (SW (bb)->tail_components);\n     }\n }\n \n@@ -1253,48 +1251,151 @@ place_prologue_for_one_component (unsigned int which, basic_block head)\n     }\n }\n \n-/* Mark HAS_COMPONENTS for every block dominated by at least one block with\n-   HAS_COMPONENTS set for the respective components, starting at HEAD.  */\n+/* Set HAS_COMPONENTS in every block to the maximum it can be set to without\n+   setting it on any path from entry to exit where it was not already set\n+   somewhere (or, for blocks that have no path to the exit, consider only\n+   paths from the entry to the block itself).  */\n static void\n-spread_components (basic_block head)\n+spread_components (sbitmap components)\n {\n-  basic_block bb = head;\n-  bool first_visit = true;\n-  /* This keeps a tally of all components active.  */\n-  sbitmap components = SW (head)->has_components;\n+  basic_block entry_block = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  basic_block exit_block = EXIT_BLOCK_PTR_FOR_FN (cfun);\n \n-  for (;;)\n+  /* A stack of all blocks left to consider, and a bitmap of all blocks\n+     on that stack.  */\n+  vec<basic_block> todo;\n+  todo.create (n_basic_blocks_for_fn (cfun));\n+  bitmap seen = BITMAP_ALLOC (NULL);\n+\n+  sbitmap old = sbitmap_alloc (SBITMAP_SIZE (components));\n+\n+  /* Find for every block the components that are *not* needed on some path\n+     from the entry to that block.  Do this with a flood fill from the entry\n+     block.  Every block can be visited at most as often as the number of\n+     components (plus one), and usually much less often.  */\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Spreading down...\\n\");\n+\n+  basic_block bb;\n+  FOR_ALL_BB_FN (bb, cfun)\n+    bitmap_clear (SW (bb)->head_components);\n+\n+  bitmap_copy (SW (entry_block)->head_components, components);\n+\n+  edge e;\n+  edge_iterator ei;\n+\n+  todo.quick_push (single_succ (entry_block));\n+  bitmap_set_bit (seen, single_succ (entry_block)->index);\n+  while (!todo.is_empty ())\n     {\n-      if (first_visit)\n-\t{\n-\t  bitmap_ior (SW (bb)->has_components, SW (bb)->has_components,\n-\t\t      components);\n+      bb = todo.pop ();\n \n-\t  if (first_dom_son (CDI_DOMINATORS, bb))\n-\t    {\n-\t      components = SW (bb)->has_components;\n-\t      bb = first_dom_son (CDI_DOMINATORS, bb);\n-\t      continue;\n-\t    }\n-\t}\n+      bitmap_copy (old, SW (bb)->head_components);\n \n-      components = SW (bb)->has_components;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tbitmap_ior (SW (bb)->head_components, SW (bb)->head_components,\n+\t\t    SW (e->src)->head_components);\n \n-      if (next_dom_son (CDI_DOMINATORS, bb))\n-\t{\n-\t  bb = next_dom_son (CDI_DOMINATORS, bb);\n-\t  basic_block parent = get_immediate_dominator (CDI_DOMINATORS, bb);\n-\t  components = SW (parent)->has_components;\n-\t  first_visit = true;\n-\t}\n-      else\n+      bitmap_and_compl (SW (bb)->head_components, SW (bb)->head_components,\n+\t\t\tSW (bb)->has_components);\n+\n+      if (!bitmap_equal_p (old, SW (bb)->head_components))\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t  if (bitmap_set_bit (seen, e->dest->index))\n+\t    todo.quick_push (e->dest);\n+\n+      bitmap_clear_bit (seen, bb->index);\n+    }\n+\n+  /* Find for every block the components that are *not* needed on some reverse\n+     path from the exit to that block.  */\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Spreading up...\\n\");\n+\n+  /* First, mark all blocks not reachable from the exit block as not needing\n+     any component on any path to the exit.  Mark everything, and then clear\n+     again by a flood fill.  */\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n+    bitmap_copy (SW (bb)->tail_components, components);\n+\n+  FOR_EACH_EDGE (e, ei, exit_block->preds)\n+    {\n+      todo.quick_push (e->src);\n+      bitmap_set_bit (seen, e->src->index);\n+    }\n+\n+  while (!todo.is_empty ())\n+    {\n+      bb = todo.pop ();\n+\n+      if (!bitmap_empty_p (SW (bb)->tail_components))\n+\tFOR_EACH_EDGE (e, ei, bb->preds)\n+\t  if (bitmap_set_bit (seen, e->src->index))\n+\t    todo.quick_push (e->src);\n+\n+      bitmap_clear (SW (bb)->tail_components);\n+\n+      bitmap_clear_bit (seen, bb->index);\n+    }\n+\n+  /* And then, flood fill backwards to find for every block the components\n+     not needed on some path to the exit.  */\n+\n+  bitmap_copy (SW (exit_block)->tail_components, components);\n+\n+  FOR_EACH_EDGE (e, ei, exit_block->preds)\n+    {\n+      todo.quick_push (e->src);\n+      bitmap_set_bit (seen, e->src->index);\n+    }\n+\n+  while (!todo.is_empty ())\n+    {\n+      bb = todo.pop ();\n+\n+      bitmap_copy (old, SW (bb)->tail_components);\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tbitmap_ior (SW (bb)->tail_components, SW (bb)->tail_components,\n+\t\t    SW (e->dest)->tail_components);\n+\n+      bitmap_and_compl (SW (bb)->tail_components, SW (bb)->tail_components,\n+\t\t\tSW (bb)->has_components);\n+\n+      if (!bitmap_equal_p (old, SW (bb)->tail_components))\n+\tFOR_EACH_EDGE (e, ei, bb->preds)\n+\t  if (bitmap_set_bit (seen, e->src->index))\n+\t    todo.quick_push (e->src);\n+\n+      bitmap_clear_bit (seen, bb->index);\n+    }\n+\n+  /* Finally, mark everything not not needed both forwards and backwards.  */\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      bitmap_and (SW (bb)->head_components, SW (bb)->head_components,\n+\t\t  SW (bb)->tail_components);\n+      bitmap_and_compl (SW (bb)->has_components, components,\n+\t\t\tSW (bb)->head_components);\n+    }\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      if (dump_file)\n \t{\n-\t  if (bb == head)\n-\t    return;\n-\t  bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n-\t  first_visit = false;\n+\t  fprintf (dump_file, \"bb %d components:\", bb->index);\n+\t  dump_components (\"has\", SW (bb)->has_components);\n+\t  fprintf (dump_file, \"\\n\");\n \t}\n     }\n+\n+  sbitmap_free (old);\n+  BITMAP_FREE (seen);\n }\n \n /* If we cannot handle placing some component's prologues or epilogues where\n@@ -1384,6 +1485,9 @@ emit_common_heads_for_components (sbitmap components)\n   sbitmap tmp = sbitmap_alloc (SBITMAP_SIZE (components));\n \n   basic_block bb;\n+  FOR_ALL_BB_FN (bb, cfun)\n+    bitmap_clear (SW (bb)->head_components);\n+\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       /* Find which prologue resp. epilogue components are needed for all\n@@ -1470,6 +1574,9 @@ emit_common_tails_for_components (sbitmap components)\n   sbitmap tmp = sbitmap_alloc (SBITMAP_SIZE (components));\n \n   basic_block bb;\n+  FOR_ALL_BB_FN (bb, cfun)\n+    bitmap_clear (SW (bb)->tail_components);\n+\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       /* Find which prologue resp. epilogue components are needed for all\n@@ -1608,6 +1715,10 @@ insert_prologue_epilogue_for_components (sbitmap components)\n \t\t\t   e->dest->index);\n \t\t  dump_components (\"epi\", epi);\n \t\t  dump_components (\"pro\", pro);\n+\t\t  if (e->flags & EDGE_SIBCALL)\n+\t\t    fprintf (dump_file, \"  (SIBCALL)\");\n+\t\t  else if (e->flags & EDGE_ABNORMAL)\n+\t\t    fprintf (dump_file, \"  (ABNORMAL)\");\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \n@@ -1702,7 +1813,7 @@ try_shrink_wrapping_separate (basic_block first_bb)\n   EXECUTE_IF_SET_IN_BITMAP (components, 0, j, sbi)\n     place_prologue_for_one_component (j, first_bb);\n \n-  spread_components (first_bb);\n+  spread_components (components);\n \n   disqualify_problematic_components (components);\n "}]}