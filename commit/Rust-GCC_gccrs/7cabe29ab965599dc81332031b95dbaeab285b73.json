{"sha": "7cabe29ab965599dc81332031b95dbaeab285b73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NhYmUyOWFiOTY1NTk5ZGM4MTMzMjAzMWI5NWRiYWVhYjI4NWI3Mw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-10-23T18:07:15Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-10-23T18:07:15Z"}, "message": "(block_move_load_store, block_move_sequence): Delete.\n\n(block_move_loop): New parameter orig_dest.  Call change_address to\ncreate new MEM instead of gen_rtx.\n(expand_block_move): New local orig_dest.  Pass it to block_move_loop.\nCall change_address to create new MEM instead of gen_rtx.\n\nFrom-SVN: r13007", "tree": {"sha": "e74098be56fef476df00dda7e3eeb9c29b0085c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e74098be56fef476df00dda7e3eeb9c29b0085c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cabe29ab965599dc81332031b95dbaeab285b73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cabe29ab965599dc81332031b95dbaeab285b73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cabe29ab965599dc81332031b95dbaeab285b73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cabe29ab965599dc81332031b95dbaeab285b73/comments", "author": null, "committer": null, "parents": [{"sha": "ecd4080946e1ac6014123a65161c96c48e13ef21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecd4080946e1ac6014123a65161c96c48e13ef21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecd4080946e1ac6014123a65161c96c48e13ef21"}], "stats": {"total": 208, "additions": 18, "deletions": 190}, "files": [{"sha": "1026f0de510bef43f9a45b61f8b5e66dfa2f5172", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 18, "deletions": 190, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cabe29ab965599dc81332031b95dbaeab285b73/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cabe29ab965599dc81332031b95dbaeab285b73/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=7cabe29ab965599dc81332031b95dbaeab285b73", "patch": "@@ -2195,167 +2195,6 @@ gen_conditional_move (operands)\n \t\t\t       operands[2],\n \t\t\t       operands[3])));\n }\n-\f\n-#if 0\n-/* Internal code to generate the load and store of one word/short/byte.\n-   The load is emitted directly, and the store insn is returned.  */\n-\n-#define UNITS_PER_MIPS_DWORD\t8\n-#define UNITS_PER_MIPS_WORD\t4\n-#define UNITS_PER_MIPS_HWORD\t2\n-\n-static rtx\n-block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align, orig_src)\n-     rtx src_reg;\t\t/* register holding source memory address */\n-     rtx dest_reg;\t\t/* register holding dest. memory address */\n-     int *p_bytes;\t\t/* pointer to # bytes remaining */\n-     int *p_offset;\t\t/* pointer to current offset */\n-     int align;\t\t\t/* alignment */\n-     rtx orig_src;\t\t/* original source for making a reg note */\n-{\n-  int bytes;\t\t\t/* # bytes remaining */\n-  int offset;\t\t\t/* offset to use */\n-  int size;\t\t\t/* size in bytes of load/store */\n-  enum machine_mode mode;\t/* mode to use for load/store */\n-  rtx reg;\t\t\t/* temporary register */\n-  rtx src_addr;\t\t\t/* source address */\n-  rtx dest_addr;\t\t/* destination address */\n-  rtx insn;\t\t\t/* insn of the load */\n-  rtx orig_src_addr;\t\t/* original source address */\n-  rtx (*load_func)();\t\t/* function to generate load insn */\n-  rtx (*store_func)();\t\t/* function to generate destination insn */\n-\n-  bytes = *p_bytes;\n-  if (bytes <= 0 || align <= 0)\n-    abort ();\n-\n-  if (bytes >= UNITS_PER_MIPS_DWORD && align >= UNIS_PER_MIPS_DWORD)\n-    {\n-      mode = DImode;\n-      size = UNITS_PER_MIPS_DWORD;\n-      load_func = gen_movdi;\n-      store_func = gen_movdi;\n-    }\n-  else if (bytes >= UNITS_PER_MIPS_WORD && align >= UNITS_PER_MIPS_WORD)\n-    {\n-      mode = SImode;\n-      size = UNITS_PER_MIPS_WORD;\n-      load_func = gen_movsi;\n-      store_func = gen_movsi;\n-    }\n-\n-#if 0\n-  /* Don't generate unaligned moves here, rather defer those to the\n-     general movestrsi_internal pattern.\n-     If this gets commented back in, then should add the dword equivalent.  */\n-  else if (bytes >= UNITS_PER_MIPS_WORD)\n-    {\n-      mode = SImode;\n-      size = UNITS_PER_MIPS_WORD;\n-      load_func = gen_movsi_ulw;\n-      store_func = gen_movsi_usw;\n-    }\n-#endif\n-\n-  else if (bytes >= UNITS_PER_MIPS_SHORT && align >= UNITS_PER_MIPS_SHORT)\n-    {\n-      mode = HImode;\n-      size = UNITS_PER_MIPS_SHORT;\n-      load_func = gen_movhi;\n-      store_func = gen_movhi;\n-    }\n-\n-  else\n-    {\n-      mode = QImode;\n-      size = 1;\n-      load_func = gen_movqi;\n-      store_func = gen_movqi;\n-    }\n-\n-  offset = *p_offset;\n-  *p_offset = offset + size;\n-  *p_bytes = bytes - size;\n-\n-  if (offset == 0)\n-    {\n-      src_addr  = src_reg;\n-      dest_addr = dest_reg;\n-    }\n-  else\n-    {\n-      src_addr  = gen_rtx (PLUS, Pmode, src_reg,  GEN_INT (offset));\n-      dest_addr = gen_rtx (PLUS, Pmode, dest_reg, GEN_INT (offset));\n-    }\n-\n-  reg = gen_reg_rtx (mode);\n-  insn = emit_insn ((*load_func) (reg, gen_rtx (MEM, mode, src_addr)));\n-  orig_src_addr = XEXP (orig_src, 0);\n-  if (CONSTANT_P (orig_src_addr))\n-    REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUIV,\n-\t\t\t\tplus_constant (orig_src_addr, offset),\n-\t\t\t\tREG_NOTES (insn));\n-\n-  return (*store_func) (gen_rtx (MEM, mode, dest_addr), reg);\n-}\n-#endif\n-\n-\f\n-/* Write a series of loads/stores to move some bytes.  Generate load/stores as follows:\n-\n-   load  1\n-   load  2\n-   load  3\n-   store 1\n-   load  4\n-   store 2\n-   load  5\n-   store 3\n-   ...\n-\n-   This way, no NOP's are needed, except at the end, and only\n-   two temp registers are needed.  Two delay slots are used\n-   in deference to the R4000.  */\n-\n-#if 0\n-static void\n-block_move_sequence (dest_reg, src_reg, bytes, align, orig_src)\n-     rtx dest_reg;\t\t/* register holding destination address */\n-     rtx src_reg;\t\t/* register holding source address */\n-     int bytes;\t\t\t/* # bytes to move */\n-     int align;\t\t\t/* max alignment to assume */\n-     rtx orig_src;\t\t/* original source for making a reg note */\n-{\n-  int offset\t\t= 0;\n-  rtx prev2_store\t= (rtx)0;\n-  rtx prev_store\t= (rtx)0;\n-  rtx cur_store\t\t= (rtx)0;\n-\n-  while (bytes > 0)\n-    {\n-      /* Is there a store to do? */\n-      if (prev2_store)\n-\temit_insn (prev2_store);\n-\n-      prev2_store = prev_store;\n-      prev_store = cur_store;\n-      cur_store = block_move_load_store (dest_reg, src_reg,\n-\t\t\t\t\t &bytes, &offset,\n-\t\t\t\t\t align, orig_src);\n-    }\n-\n-  /* Finish up last three stores.  */\n-  if (prev2_store)\n-    emit_insn (prev2_store);\n-\n-  if (prev_store)\n-    emit_insn (prev_store);\n-\n-  if (cur_store)\n-    emit_insn (cur_store);\n-}\n-#endif\n-\n \f\n /* Write a loop to move a constant number of bytes.  Generate load/stores as follows:\n \n@@ -2382,18 +2221,17 @@ block_move_sequence (dest_reg, src_reg, bytes, align, orig_src)\n #define MAX_MOVE_REGS 4\n #define MAX_MOVE_BYTES (MAX_MOVE_REGS * UNITS_PER_WORD)\n \n-/* ??? Should add code to use DWORD load/stores.  */\n-\n static void\n-block_move_loop (dest_reg, src_reg, bytes, align, orig_src)\n+block_move_loop (dest_reg, src_reg, bytes, align, orig_dest, orig_src)\n      rtx dest_reg;\t\t/* register holding destination address */\n      rtx src_reg;\t\t/* register holding source address */\n      int bytes;\t\t\t/* # bytes to move */\n      int align;\t\t\t/* alignment */\n+     rtx orig_dest;\t\t/* original dest for change_address */\n      rtx orig_src;\t\t/* original source for making a reg note */\n {\n-  rtx dest_mem\t\t= gen_rtx (MEM, BLKmode, dest_reg);\n-  rtx src_mem\t\t= gen_rtx (MEM, BLKmode, src_reg);\n+  rtx dest_mem\t\t= change_address (orig_dest, BLKmode, dest_reg);\n+  rtx src_mem\t\t= change_address (orig_src, BLKmode, src_reg);\n   rtx align_rtx\t\t= GEN_INT (align);\n   rtx label;\n   rtx final_src;\n@@ -2454,7 +2292,6 @@ block_move_loop (dest_reg, src_reg, bytes, align, orig_src)\n \t\t\t\t      GEN_INT (leftover),\n \t\t\t\t      align_rtx));\n }\n-\n \f\n /* Use a library function to move some bytes.  */\n \n@@ -2508,6 +2345,7 @@ expand_block_move (operands)\n   int bytes\t= (constp ? INTVAL (bytes_rtx) : 0);\n   int align\t= INTVAL (align_rtx);\n   rtx orig_src\t= operands[1];\n+  rtx orig_dest\t= operands[0];\n   rtx src_reg;\n   rtx dest_reg;\n \n@@ -2518,26 +2356,21 @@ expand_block_move (operands)\n     align = UNITS_PER_WORD;\n \n   /* Move the address into scratch registers.  */\n-  dest_reg = copy_addr_to_reg (XEXP (operands[0], 0));\n+  dest_reg = copy_addr_to_reg (XEXP (orig_dest, 0));\n   src_reg  = copy_addr_to_reg (XEXP (orig_src, 0));\n \n   if (TARGET_MEMCPY)\n     block_move_call (dest_reg, src_reg, bytes_rtx);\n \n-#if 0\n-  else if (constp && bytes <= 3*align)\n-    block_move_sequence (dest_reg, src_reg, bytes, align, orig_src);\n-#endif\n-\n   else if (constp && bytes <= 2*MAX_MOVE_BYTES)\n-    emit_insn (gen_movstrsi_internal (change_address (operands[0],\n-\t\t\t\t\t\t      BLKmode, dest_reg),\n+    emit_insn (gen_movstrsi_internal (change_address (orig_dest, BLKmode,\n+\t\t\t\t\t\t      dest_reg),\n \t\t\t\t      change_address (orig_src, BLKmode,\n \t\t\t\t\t\t      src_reg),\n \t\t\t\t      bytes_rtx, align_rtx));\n \n   else if (constp && align >= UNITS_PER_WORD && optimize)\n-    block_move_loop (dest_reg, src_reg, bytes, align, orig_src);\n+    block_move_loop (dest_reg, src_reg, bytes, align, orig_dest, orig_src);\n \n   else if (constp && optimize)\n     {\n@@ -2567,29 +2400,24 @@ expand_block_move (operands)\n       emit_jump_insn (gen_beq (aligned_label));\n \n       /* Unaligned loop.  */\n-      block_move_loop (dest_reg, src_reg, bytes, 1, orig_src);\n+      block_move_loop (dest_reg, src_reg, bytes, 1, orig_dest, orig_src);\n       emit_jump_insn (gen_jump (join_label));\n       emit_barrier ();\n \n       /* Aligned loop.  */\n       emit_label (aligned_label);\n-      block_move_loop (dest_reg, src_reg, bytes, UNITS_PER_WORD, orig_src);\n+      block_move_loop (dest_reg, src_reg, bytes, UNITS_PER_WORD, orig_dest,\n+\t\t       orig_src);\n       emit_label (join_label);\n \n       /* Bytes at the end of the loop.  */\n       if (leftover)\n-\t{\n-#if 0\n-\t  if (leftover <= 3*align)\n-\t    block_move_sequence (dest_reg, src_reg, leftover, align, orig_src);\n-\n-\t  else\n-#endif\n-\t    emit_insn (gen_movstrsi_internal (gen_rtx (MEM, BLKmode, dest_reg),\n-\t\t\t\t\t      gen_rtx (MEM, BLKmode, src_reg),\n-\t\t\t\t\t      GEN_INT (leftover),\n-\t\t\t\t\t      GEN_INT (align)));\n-\t}\n+\temit_insn (gen_movstrsi_internal (change_address (orig_dest, BLKmode,\n+\t\t\t\t\t\t\t  dest_reg),\n+\t\t\t\t\t  change_address (orig_src, BLKmode,\n+\t\t\t\t\t\t\t  src_reg),\n+\t\t\t\t\t  GEN_INT (leftover),\n+\t\t\t\t\t  GEN_INT (align)));\n     }\n \n   else"}]}