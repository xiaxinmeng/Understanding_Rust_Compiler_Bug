{"sha": "d6416b380014540a1f6aebe28565e8be98d14833", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY0MTZiMzgwMDE0NTQwYTFmNmFlYmUyODU2NWU4YmU5OGQxNDgzMw==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-11-26T00:07:43Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-11-26T00:07:43Z"}, "message": "fix PR68453: recursively add phi nodes to merge points\n\nThe patch adds close phi nodes to every outer loop exit, and to every loop\nguard.  For loop guards it computes an initial value that determines where we\nstop inserting phi nodes.  When the initial value is a constant, the initial\nvalue is considered to be defined in the entry of the code gen region.\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r230918", "tree": {"sha": "ada978b1c08fb57489c812552d6c0d3b338ee9a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ada978b1c08fb57489c812552d6c0d3b338ee9a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6416b380014540a1f6aebe28565e8be98d14833", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6416b380014540a1f6aebe28565e8be98d14833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6416b380014540a1f6aebe28565e8be98d14833", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6416b380014540a1f6aebe28565e8be98d14833/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91f6ec2fc627aafe3ba7f0e563e7f06146066ed6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f6ec2fc627aafe3ba7f0e563e7f06146066ed6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91f6ec2fc627aafe3ba7f0e563e7f06146066ed6"}], "stats": {"total": 348, "additions": 260, "deletions": 88}, "files": [{"sha": "766f034ef60de983c99e2f54a6a08b44196ee119", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6416b380014540a1f6aebe28565e8be98d14833/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6416b380014540a1f6aebe28565e8be98d14833/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6416b380014540a1f6aebe28565e8be98d14833", "patch": "@@ -1,3 +1,20 @@\n+2015-11-25  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\tPR tree-optimization/68453\n+\t* graphite-isl-ast-to-gimple.c (translate_isl_ast_for_loop): Do\n+\tnot redirect edges already pointing to their destination.\n+\t(translate_isl_ast_node_for): Split edges after loops to create\n+\tbasic blocks for close phi nodes.  Save merge points at the end of\n+\ta loop guard.\n+\t(translate_isl_ast_node_if): Save merge points at the end of the\n+\tif region.\n+\t(add_close_phis_to_outer_loops): New.\n+\t(add_close_phis_to_merge_points): New.\n+\t(copy_loop_close_phi_args): Call add_close_phis_to_merge_points.\n+\t(copy_bb_and_scalar_dependences): Do not split basic blocks on\n+\tloop close phi locations.\n+\n 2015-11-25  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-visibility.c (cgraph_externally_visible_p,"}, {"sha": "33423dd2bab56533bb82ed805c685225f857d1e0", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 213, "deletions": 88, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6416b380014540a1f6aebe28565e8be98d14833/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6416b380014540a1f6aebe28565e8be98d14833/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=d6416b380014540a1f6aebe28565e8be98d14833", "patch": "@@ -360,6 +360,15 @@ class translate_isl_ast_to_gimple\n \n   bool copy_loop_phi_nodes (basic_block bb, basic_block new_bb);\n \n+  /* Add phi nodes to all merge points of all the diamonds enclosing the loop of\n+     the close phi node PHI.  */\n+\n+  bool add_close_phis_to_merge_points (gphi *old_phi, gphi *new_phi,\n+\t\t\t\t       tree default_value);\n+\n+  tree add_close_phis_to_outer_loops (tree last_merge_name, edge merge_e,\n+\t\t\t\t      gimple *old_close_phi);\n+\n   /* Copy all the loop-close phi args from BB to NEW_BB.  */\n \n   bool copy_loop_close_phi_args (basic_block old_bb, basic_block new_bb,\n@@ -471,11 +480,15 @@ class translate_isl_ast_to_gimple\n   }\n \n private:\n+  /* The region to be translated.  */\n   sese_info_p region;\n \n   /* This flag is set when an error occurred during the translation of ISL AST\n      to Gimple.  */\n   bool codegen_error;\n+\n+  /* A vector of all the edges at if_condition merge points.  */\n+  auto_vec<edge, 2> merge_points;\n };\n \n /* Return the tree variable that corresponds to the given isl ast identifier\n@@ -797,7 +810,8 @@ translate_isl_ast_for_loop (loop_p context_loop,\n   if (!next_e || codegen_error_p ())\n     return NULL;\n \n-  redirect_edge_succ_nodup (next_e, after);\n+  if (next_e->dest != after)\n+    redirect_edge_succ_nodup (next_e, after);\n   set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n \n   if (flag_loop_parallelize_all)\n@@ -938,12 +952,21 @@ translate_isl_ast_node_for (loop_p context_loop, __isl_keep isl_ast_node *node,\n \t\t\t\t\t\t&lb, &ub, ip);\n \n   if (last_e == next_e)\n-    /* There was no guard generated.  */\n-    return translate_isl_ast_for_loop (context_loop, node, last_e,\n-\t\t\t\t       type, lb, ub, ip);\n+    {\n+      /* There was no guard generated.  */\n+      last_e = single_succ_edge (split_edge (last_e));\n+\n+      translate_isl_ast_for_loop (context_loop, node, next_e,\n+\t\t\t\t  type, lb, ub, ip);\n+      return last_e;\n+    }\n \n   edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n+  merge_points.safe_push (last_e);\n+\n+  last_e = single_succ_edge (split_edge (last_e));\n   translate_isl_ast_for_loop (context_loop, node, true_e, type, lb, ub, ip);\n+\n   return last_e;\n }\n \n@@ -1081,8 +1104,9 @@ translate_isl_ast_node_if (loop_p context_loop,\n   gcc_assert (isl_ast_node_get_type (node) == isl_ast_node_if);\n   isl_ast_expr *if_cond = isl_ast_node_if_get_cond (node);\n   edge last_e = graphite_create_new_guard (next_e, if_cond, ip);\n-\n   edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n+  merge_points.safe_push (last_e);\n+\n   isl_ast_node *then_node = isl_ast_node_if_get_then (node);\n   translate_isl_ast (context_loop, then_node, true_e, ip);\n   isl_ast_node_free (then_node);\n@@ -1091,6 +1115,7 @@ translate_isl_ast_node_if (loop_p context_loop,\n   isl_ast_node *else_node = isl_ast_node_if_get_else (node);\n   if (isl_ast_node_get_type (else_node) != isl_ast_node_error)\n     translate_isl_ast (context_loop, else_node, false_e, ip);\n+\n   isl_ast_node_free (else_node);\n   return last_e;\n }\n@@ -1135,7 +1160,7 @@ translate_isl_ast_to_gimple::translate_isl_ast (loop_p context_loop,\n    at the exit of loop which takes one argument that is the last value of the\n    variable being used out of the loop.  */\n \n-bool\n+static bool\n bb_contains_loop_close_phi_nodes (basic_block bb)\n {\n   return single_pred_p (bb)\n@@ -1145,7 +1170,7 @@ bb_contains_loop_close_phi_nodes (basic_block bb)\n /* Return true when BB contains loop phi nodes.  A loop phi node is the loop\n    header containing phi nodes which has one init-edge and one back-edge.  */\n \n-bool\n+static bool\n bb_contains_loop_phi_nodes (basic_block bb)\n {\n   gcc_assert (EDGE_COUNT (bb->preds) <= 2);\n@@ -2050,35 +2075,139 @@ find_init_value_close_phi (gphi *phi)\n   return find_init_value (def);\n }\n \n+\n+tree translate_isl_ast_to_gimple::\n+add_close_phis_to_outer_loops (tree last_merge_name, edge last_e,\n+\t\t\t       gimple *old_close_phi)\n+{\n+  sese_l &codegen_region = region->if_region->true_region->region;\n+  gimple *stmt = SSA_NAME_DEF_STMT (last_merge_name);\n+  basic_block bb = gimple_bb (stmt);\n+  if (!bb_in_sese_p (bb, codegen_region))\n+    return last_merge_name;\n+\n+  loop_p loop = bb->loop_father;\n+  if (!loop_in_sese_p (loop, codegen_region))\n+    return last_merge_name;\n+\n+  edge e = single_exit (loop);\n+\n+  if (dominated_by_p (CDI_DOMINATORS, e->dest, last_e->src))\n+    return last_merge_name;\n+\n+  tree old_name = gimple_phi_arg_def (old_close_phi, 0);\n+  tree old_close_phi_name = gimple_phi_result (old_close_phi);\n+\n+  bb = e->dest;\n+  if (!bb_contains_loop_close_phi_nodes (bb) || !single_succ_p (bb))\n+    bb = split_edge (e);\n+\n+  gphi *close_phi = create_phi_node (SSA_NAME_VAR (last_merge_name), bb);\n+  tree res = create_new_def_for (last_merge_name, close_phi,\n+\t\t\t\t gimple_phi_result_ptr (close_phi));\n+  set_rename (old_close_phi_name, res);\n+  add_phi_arg (close_phi, last_merge_name, e, get_loc (old_name));\n+  last_merge_name = res;\n+\n+  return add_close_phis_to_outer_loops (last_merge_name, last_e, old_close_phi);\n+}\n+\n+/* Add phi nodes to all merge points of all the diamonds enclosing the loop of\n+   the close phi node PHI.  */\n+\n+bool translate_isl_ast_to_gimple::\n+add_close_phis_to_merge_points (gphi *old_close_phi, gphi *new_close_phi,\n+\t\t\t\ttree default_value)\n+{\n+  sese_l &codegen_region = region->if_region->true_region->region;\n+  basic_block default_value_bb = get_entry_bb (codegen_region);\n+  if (SSA_NAME == TREE_CODE (default_value))\n+    {\n+      gimple *stmt = SSA_NAME_DEF_STMT (default_value);\n+      if (!stmt || gimple_code (stmt) == GIMPLE_NOP)\n+\treturn false;\n+      default_value_bb = gimple_bb (stmt);\n+    }\n+\n+  basic_block new_close_phi_bb = gimple_bb (new_close_phi);\n+\n+  tree old_close_phi_name = gimple_phi_result (old_close_phi);\n+  tree new_close_phi_name = gimple_phi_result (new_close_phi);\n+  tree last_merge_name = new_close_phi_name;\n+  tree old_name = gimple_phi_arg_def (old_close_phi, 0);\n+\n+  int i;\n+  edge merge_e;\n+  FOR_EACH_VEC_ELT_REVERSE (merge_points, i, merge_e)\n+    {\n+      basic_block new_merge_bb = merge_e->src;\n+      if (!dominated_by_p (CDI_DOMINATORS, new_merge_bb, default_value_bb))\n+\tcontinue;\n+\n+      last_merge_name = add_close_phis_to_outer_loops (last_merge_name, merge_e,\n+\t\t\t\t\t\t       old_close_phi);\n+\n+      gphi *merge_phi = create_phi_node (SSA_NAME_VAR (old_close_phi_name), new_merge_bb);\n+      tree merge_res = create_new_def_for (old_close_phi_name, merge_phi,\n+\t\t\t\t\t   gimple_phi_result_ptr (merge_phi));\n+      set_rename (old_close_phi_name, merge_res);\n+\n+      edge from_loop = NULL, from_default_value = NULL;\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, new_merge_bb->preds)\n+\tif (dominated_by_p (CDI_DOMINATORS, e->src, new_close_phi_bb))\n+\t  from_loop = e;\n+\telse\n+\t  from_default_value = e;\n+\n+      /* Because CDI_POST_DOMINATORS are not updated, we only rely on\n+\t CDI_DOMINATORS, which may not handle all cases where new_close_phi_bb\n+\t is contained in another condition.  */\n+      if (!from_default_value || !from_loop)\n+\treturn false;\n+\n+      add_phi_arg (merge_phi, last_merge_name, from_loop, get_loc (old_name));\n+      add_phi_arg (merge_phi, default_value, from_default_value, get_loc (old_name));\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"[codegen] Adding guard-phi: \");\n+\t  print_gimple_stmt (dump_file, merge_phi, 0, 0);\n+\t}\n+\n+      update_stmt (merge_phi);\n+      last_merge_name = merge_res;\n+    }\n+\n+  return true;\n+}\n+\n /* Copy all the loop-close phi args from BB to NEW_BB.  */\n \n bool\n translate_isl_ast_to_gimple::copy_loop_close_phi_args (basic_block old_bb,\n \t\t\t\t\t\t       basic_block new_bb,\n \t\t\t\t\t\t       bool postpone)\n {\n-  /* The successor of bb having close phi should be a merge of the diamond\n-     inserted to guard the loop during codegen.  */\n-  basic_block succ_new_bb = single_succ (new_bb);\n-\n   for (gphi_iterator psi = gsi_start_phis (old_bb); !gsi_end_p (psi);\n        gsi_next (&psi))\n     {\n-      gphi *phi = psi.phi ();\n-      tree res = gimple_phi_result (phi);\n+      gphi *old_close_phi = psi.phi ();\n+      tree res = gimple_phi_result (old_close_phi);\n       if (virtual_operand_p (res))\n \tcontinue;\n \n       if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))\n \t/* Loop close phi nodes should not be scev_analyzable_p.  */\n \tgcc_unreachable ();\n \n-      gphi *new_phi = create_phi_node (SSA_NAME_VAR (res), new_bb);\n-      tree new_res = create_new_def_for (res, new_phi,\n-\t\t\t\t\t gimple_phi_result_ptr (new_phi));\n+      gphi *new_close_phi = create_phi_node (SSA_NAME_VAR (res), new_bb);\n+      tree new_res = create_new_def_for (res, new_close_phi,\n+\t\t\t\t\t gimple_phi_result_ptr (new_close_phi));\n       set_rename (res, new_res);\n \n-      tree old_name = gimple_phi_arg_def (phi, 0);\n+      tree old_name = gimple_phi_arg_def (old_close_phi, 0);\n       tree new_name = get_new_name (new_bb, old_name, old_bb, false);\n \n       /* Predecessor basic blocks of a loop close phi should have been code\n@@ -2087,60 +2216,43 @@ translate_isl_ast_to_gimple::copy_loop_close_phi_args (basic_block old_bb,\n       if (!new_name)\n \treturn false;\n \n-      add_phi_arg (new_phi, new_name, single_pred_edge (new_bb),\n+      add_phi_arg (new_close_phi, new_name, single_pred_edge (new_bb),\n \t\t   get_loc (old_name));\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"[codegen] Adding loop-closed phi: \");\n-\t  print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t  print_gimple_stmt (dump_file, new_close_phi, 0, 0);\n \t}\n \n-      update_stmt (new_phi);\n+      update_stmt (new_close_phi);\n \n       /* When there is no loop guard around this codegenerated loop, there is no\n \t need to collect the close-phi arg.  */\n-      if (2 != EDGE_COUNT (succ_new_bb->preds)\n-\t  || bb_contains_loop_phi_nodes (succ_new_bb))\n+      if (merge_points.is_empty ())\n \tcontinue;\n \n       /* Add a PHI in the succ_new_bb for each close phi of the loop.  */\n-      tree init = find_init_value_close_phi (new_phi);\n+      tree default_value = find_init_value_close_phi (new_close_phi);\n \n-      /* A close phi must come from a loop-phi having an init value.  */\n-      if (!init)\n+      /* A close phi must come from a loop-phi having a default value.  */\n+      if (!default_value)\n \t{\n \t  if (!postpone)\n \t    return false;\n \n-\t  region->incomplete_phis.safe_push (std::make_pair (phi, new_phi));\n+\t  region->incomplete_phis.safe_push (std::make_pair (old_close_phi,\n+\t\t\t\t\t\t\t     new_close_phi));\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"[codegen] postpone close phi nodes: \");\n-\t      print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t      print_gimple_stmt (dump_file, new_close_phi, 0, 0);\n \t    }\n \t  continue;\n \t}\n \n-      gphi *merge_phi = create_phi_node (SSA_NAME_VAR (res), succ_new_bb);\n-      tree merge_res = create_new_def_for (res, merge_phi,\n-\t\t\t\t\t   gimple_phi_result_ptr (merge_phi));\n-      set_rename (res, merge_res);\n-\n-      edge from_loop = single_succ_edge (new_bb);\n-      add_phi_arg (merge_phi, new_res, from_loop, get_loc (old_name));\n-\n-      /* The edge coming from loop guard.  */\n-      edge other = from_loop == (*succ_new_bb->preds)[0]\n-\t? (*succ_new_bb->preds)[1] : (*succ_new_bb->preds)[0];\n-\n-      add_phi_arg (merge_phi, init, other, get_loc (old_name));\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"[codegen] Adding guard-phi: \");\n-\t  print_gimple_stmt (dump_file, merge_phi, 0, 0);\n-\t}\n-\n-      update_stmt (new_phi);\n+      if (!add_close_phis_to_merge_points (old_close_phi, new_close_phi,\n+\t\t\t\t\t   default_value))\n+\treturn false;\n     }\n \n   return true;\n@@ -2651,31 +2763,8 @@ translate_isl_ast_to_gimple::copy_bb_and_scalar_dependences (basic_block bb,\n \t}\n     }\n \n-  basic_block new_bb = split_edge (next_e);\n-  if (num_phis > 0 && bb_contains_loop_phi_nodes (bb))\n-    {\n-      basic_block phi_bb = next_e->dest->loop_father->header;\n-\n-      /* At this point we are unable to codegenerate by still preserving the SSA\n-\t structure because maybe the loop is completely unrolled and the PHIs\n-\t and cross-bb scalar dependencies are untrackable w.r.t. the original\n-\t code.  See gfortran.dg/graphite/pr29832.f90.  */\n-      if (EDGE_COUNT (bb->preds) != EDGE_COUNT (phi_bb->preds))\n-\t{\n-\t  codegen_error = true;\n-\t  return NULL;\n-\t}\n-\n-      if (dump_file)\n-\tfprintf (dump_file, \"[codegen] bb_%d contains loop phi nodes.\\n\",\n-\t\t bb->index);\n-      if (!copy_loop_phi_nodes (bb, phi_bb))\n-\t{\n-\t  codegen_error = true;\n-\t  return NULL;\n-\t}\n-    }\n-  else if (bb_contains_loop_close_phi_nodes (bb))\n+  basic_block new_bb = NULL;\n+  if (bb_contains_loop_close_phi_nodes (bb))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"[codegen] bb_%d contains close phi nodes.\\n\",\n@@ -2688,7 +2777,11 @@ translate_isl_ast_to_gimple::copy_bb_and_scalar_dependences (basic_block bb,\n \t  return NULL;\n \t}\n \n-      basic_block phi_bb = split_edge (e);\n+      basic_block phi_bb = e->dest;\n+\n+      if (!bb_contains_loop_close_phi_nodes (phi_bb) || !single_succ_p (phi_bb))\n+\tphi_bb = split_edge (e);\n+\n       gcc_assert (single_pred_edge (phi_bb)->src->loop_father\n \t\t  != single_pred_edge (phi_bb)->dest->loop_father);\n \n@@ -2697,26 +2790,58 @@ translate_isl_ast_to_gimple::copy_bb_and_scalar_dependences (basic_block bb,\n \t  codegen_error = true;\n \t  return NULL;\n \t}\n+\n+      if (e == next_e)\n+\tnew_bb = phi_bb;\n+      else\n+\tnew_bb = split_edge (next_e);\n     }\n-  else if (num_phis > 0)\n+  else\n     {\n-      if (dump_file)\n-\tfprintf (dump_file, \"[codegen] bb_%d contains cond phi nodes.\\n\",\n-\t\t bb->index);\n-\n-      basic_block phi_bb = single_pred (new_bb);\n-      loop_p loop_father = new_bb->loop_father;\n+      new_bb = split_edge (next_e);\n+      if (num_phis > 0 && bb_contains_loop_phi_nodes (bb))\n+\t{\n+\t  basic_block phi_bb = next_e->dest->loop_father->header;\n \n-      /* Move back until we find the block with two predecessors.  */\n-      while (single_pred_p (phi_bb))\n-\tphi_bb = single_pred_edge (phi_bb)->src;\n+\t  /* At this point we are unable to codegenerate by still preserving the SSA\n+\t     structure because maybe the loop is completely unrolled and the PHIs\n+\t     and cross-bb scalar dependencies are untrackable w.r.t. the original\n+\t     code.  See gfortran.dg/graphite/pr29832.f90.  */\n+\t  if (EDGE_COUNT (bb->preds) != EDGE_COUNT (phi_bb->preds))\n+\t    {\n+\t      codegen_error = true;\n+\t      return NULL;\n+\t    }\n \n-      /* If a corresponding merge-point was not found, then abort codegen.  */\n-      if (phi_bb->loop_father != loop_father\n-\t  || !copy_cond_phi_nodes (bb, phi_bb, iv_map))\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"[codegen] bb_%d contains loop phi nodes.\\n\",\n+\t\t     bb->index);\n+\t  if (!copy_loop_phi_nodes (bb, phi_bb))\n+\t    {\n+\t      codegen_error = true;\n+\t      return NULL;\n+\t    }\n+\t}\n+      else if (num_phis > 0)\n \t{\n-\t  codegen_error = true;\n-\t  return NULL;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"[codegen] bb_%d contains cond phi nodes.\\n\",\n+\t\t     bb->index);\n+\n+\t  basic_block phi_bb = single_pred (new_bb);\n+\t  loop_p loop_father = new_bb->loop_father;\n+\n+\t  /* Move back until we find the block with two predecessors.  */\n+\t  while (single_pred_p (phi_bb))\n+\t    phi_bb = single_pred_edge (phi_bb)->src;\n+\n+\t  /* If a corresponding merge-point was not found, then abort codegen.  */\n+\t  if (phi_bb->loop_father != loop_father\n+\t      || !copy_cond_phi_nodes (bb, phi_bb, iv_map))\n+\t    {\n+\t      codegen_error = true;\n+\t      return NULL;\n+\t    }\n \t}\n     }\n "}, {"sha": "41804b98efcb0b2225978e50c676d2409c0dd422", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6416b380014540a1f6aebe28565e8be98d14833/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6416b380014540a1f6aebe28565e8be98d14833/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d6416b380014540a1f6aebe28565e8be98d14833", "patch": "@@ -1,3 +1,9 @@\n+2015-11-25  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\tPR tree-optimization/68453\n+\t* gfortran.dg/graphite/pr68453.f90: New.\n+\n 2015-11-25  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/66516"}, {"sha": "18bc593e2d350a4054dbfb892c39e6321d768c31", "filename": "gcc/testsuite/gfortran.dg/graphite/pr68453.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6416b380014540a1f6aebe28565e8be98d14833/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr68453.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6416b380014540a1f6aebe28565e8be98d14833/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr68453.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr68453.f90?ref=d6416b380014540a1f6aebe28565e8be98d14833", "patch": "@@ -0,0 +1,24 @@\n+! { dg-options \"-floop-nest-optimize -O2\" }\n+\n+MODULE dbcsr_geev\n+  INTEGER, PARAMETER :: real_8=8\n+CONTAINS\n+  SUBROUTINE dbcsr_dgeev(jobvl,jobvr,matrix,ndim,evals,revec,levec)\n+    CHARACTER(1)                             :: jobvl, jobvr\n+    REAL(real_8), DIMENSION(:, :)            :: matrix\n+    INTEGER                                  :: ndim\n+    COMPLEX(real_8), DIMENSION(:)            :: evals\n+    COMPLEX(real_8), DIMENSION(:, :)         :: revec, levec\n+    INTEGER                                  :: i, info, lwork\n+    REAL(real_8)                             :: norm, tmp_array(ndim,ndim), &\n+                                                work(20*ndim)\n+    REAL(real_8), DIMENSION(ndim)            :: eval1, eval2\n+    REAL(real_8), DIMENSION(ndim, ndim)      :: evec_l, evec_r\n+    DO WHILE (i.le.ndim)\n+      IF(ABS(eval2(i)).LT.EPSILON(REAL(0.0,real_8)))THEN\n+        norm=SQRT(SUM(evec_r(:,i)**2.0_real_8)+SUM(evec_r(:,i+1)**2.0_real_8))\n+        revec(:,i)=CMPLX(evec_r(:,i),evec_r(:,i+1),real_8)/norm\n+      END IF\n+    END DO\n+  END SUBROUTINE  dbcsr_dgeev\n+END MODULE dbcsr_geev"}]}