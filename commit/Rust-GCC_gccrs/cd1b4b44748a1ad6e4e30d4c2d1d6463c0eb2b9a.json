{"sha": "cd1b4b44748a1ad6e4e30d4c2d1d6463c0eb2b9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QxYjRiNDQ3NDhhMWFkNmU0ZTMwZDRjMmQxZDY0NjNjMGViMmI5YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-15T10:36:00Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-15T10:36:00Z"}, "message": "(convert_move): Copy SUBREG to REG in one more case.\n\n(do_jump*): Always do comparison in object's signedness now that\ncombine can remove extraneous sign extends.\n\nFrom-SVN: r1858", "tree": {"sha": "401e37fb2854d7f693c112c0f87deb281907d173", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/401e37fb2854d7f693c112c0f87deb281907d173"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd1b4b44748a1ad6e4e30d4c2d1d6463c0eb2b9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd1b4b44748a1ad6e4e30d4c2d1d6463c0eb2b9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd1b4b44748a1ad6e4e30d4c2d1d6463c0eb2b9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd1b4b44748a1ad6e4e30d4c2d1d6463c0eb2b9a/comments", "author": null, "committer": null, "parents": [{"sha": "2fc9c644a4b9184cc34f8bf7b7d3a62f954bbd8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fc9c644a4b9184cc34f8bf7b7d3a62f954bbd8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fc9c644a4b9184cc34f8bf7b7d3a62f954bbd8a"}], "stats": {"total": 20, "additions": 17, "deletions": 3}, "files": [{"sha": "1c4bf458556bb35e8b051d15e3a79707e38d33c1", "filename": "gcc/expr.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1b4b44748a1ad6e4e30d4c2d1d6463c0eb2b9a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1b4b44748a1ad6e4e30d4c2d1d6463c0eb2b9a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=cd1b4b44748a1ad6e4e30d4c2d1d6463c0eb2b9a", "patch": "@@ -589,6 +589,12 @@ convert_move (to, from, unsignedp)\n       if ((code = can_extend_p (to_mode, from_mode, unsignedp))\n \t  != CODE_FOR_nothing)\n \t{\n+\t  /* If FROM is a SUBREG, put it into a register.  Do this\n+\t     so that we always generate the same set of insns for\n+\t     better cse'ing; if an intermediate assignment occurred,\n+\t     we won't be doing the operation directly on the SUBREG.  */\n+\t  if (optimize > 0 && GET_CODE (from) == SUBREG)\n+\t    from = force_reg (from_mode, from);\n \t  emit_unop_insn (code, to, from, equiv_code);\n \t  return;\n \t}\n@@ -6198,7 +6204,8 @@ do_jump (exp, if_false_label, if_true_label)\n \tdo_jump_by_parts_equality_rtx (temp, if_true_label, if_false_label);\n       else if (GET_MODE (temp) != VOIDmode)\n \tcomparison = compare_from_rtx (temp, CONST0_RTX (GET_MODE (temp)),\n-\t\t\t\t       NE, 1, GET_MODE (temp), NULL_RTX, 0);\n+\t\t\t\t       NE, TREE_UNSIGNED (TREE_TYPE (exp)),\n+\t\t\t\t       GET_MODE (temp), NULL_RTX, 0);\n       else\n \tabort ();\n     }\n@@ -6324,7 +6331,8 @@ do_jump_by_parts_equality (exp, if_false_label, if_true_label)\n     {\n       rtx comp = compare_from_rtx (operand_subword_force (op0, i, mode),\n \t\t\t\t   operand_subword_force (op1, i, mode),\n-\t\t\t\t   EQ, 0, word_mode, NULL_RTX, 0);\n+\t\t\t\t   EQ, TREE_UNSIGNED (TREE_TYPE (exp)),\n+\t\t\t\t   word_mode, NULL_RTX, 0);\n       if (comp == const_true_rtx)\n \temit_jump (if_false_label);\n       else if (comp != const0_rtx)\n@@ -6357,7 +6365,7 @@ do_jump_by_parts_equality_rtx (op0, if_false_label, if_true_label)\n     {\n       rtx comp = compare_from_rtx (operand_subword_force (op0, i,\n \t\t\t\t\t\t\t  GET_MODE (op0)),\n-\t\t\t\t   const0_rtx, EQ, 0, word_mode, NULL_RTX, 0);\n+\t\t\t\t   const0_rtx, EQ, 1, word_mode, NULL_RTX, 0);\n       if (comp == const_true_rtx)\n \temit_jump (if_false_label);\n       else if (comp != const0_rtx)\n@@ -6502,6 +6510,11 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n   if (GET_CODE (op0) == CONST_INT && GET_CODE (op1) == CONST_INT)\n     return simplify_relational_operation (code, mode, op0, op1);\n \n+#if 0\n+  /* There's no need to do this now that combine.c can eliminate lots of\n+     sign extensions.  This can be less efficient in certain cases on other\n+     machines.\n+\n   /* If this is a signed equality comparison, we can do it as an\n      unsigned comparison since zero-extension is cheaper than sign\n      extension and comparisons with zero are done as unsigned.  This is\n@@ -6517,6 +6530,7 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n \top1 = GEN_INT (INTVAL (op1) & GET_MODE_MASK (GET_MODE (op0)));\n       unsignedp = 1;\n     }\n+#endif\n \t\n   emit_cmp_insn (op0, op1, code, size, mode, unsignedp, align);\n "}]}