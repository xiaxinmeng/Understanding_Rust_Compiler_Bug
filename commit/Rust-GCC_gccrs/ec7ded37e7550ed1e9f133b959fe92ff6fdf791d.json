{"sha": "ec7ded37e7550ed1e9f133b959fe92ff6fdf791d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM3ZGVkMzdlNzU1MGVkMWU5ZjEzM2I5NTlmZTkyZmY2ZmRmNzkxZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-08-04T23:58:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-08-04T23:58:20Z"}, "message": "Emit the prologue/epilogue using frame offsets.\n\nRecord register save offsets in ix86_frame.\n\nMove SP/FP offsets into the global state; update them everywhere\nwe currently handle CFA offsets.\n\nUse that global state to choose base registers and offsets for\nthe register saves and restores.\n\nThere is a bug fix contained herein, whereby r11 could be clobbered\nalong an indirect sibcall path when the stack frame is very large (>2GB).\nThe emit_restore_{sse_,}regs_using_mov functions didn't handle this\ncase, but pro_epilogue_adjust_stack does.\n\nFrom-SVN: r162888", "tree": {"sha": "eb7f0b5567cc7d6cb922b0481b3d5febf7bb2646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb7f0b5567cc7d6cb922b0481b3d5febf7bb2646"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec7ded37e7550ed1e9f133b959fe92ff6fdf791d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec7ded37e7550ed1e9f133b959fe92ff6fdf791d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec7ded37e7550ed1e9f133b959fe92ff6fdf791d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec7ded37e7550ed1e9f133b959fe92ff6fdf791d/comments", "author": null, "committer": null, "parents": [{"sha": "17959958bc8dbb861fb25cbf0edec426317e68bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17959958bc8dbb861fb25cbf0edec426317e68bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17959958bc8dbb861fb25cbf0edec426317e68bc"}], "stats": {"total": 982, "additions": 590, "deletions": 392}, "files": [{"sha": "cc867ffccf544a666f5af310bfb81701e3baefdb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec7ded37e7550ed1e9f133b959fe92ff6fdf791d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec7ded37e7550ed1e9f133b959fe92ff6fdf791d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec7ded37e7550ed1e9f133b959fe92ff6fdf791d", "patch": "@@ -1,5 +1,35 @@\n 2010-08-04  Richard Henderson  <rth@redhat.com>\n \n+\t* config/i386/i386.h (struct machine_frame_state): Rename from\n+\tmachine_cfa_state.  Add members tracking SP and FP regardless\n+\tof the current CFA register.  \n+\t(ix86_cfa_state): Remove.\n+\t* config/i386/i386.c (struct ix86_frame): Add reg_save_offset\n+\tand sse_reg_save_offset members.\n+\t(ix86_compute_frame_layout): Set them.\n+\t(gen_push): Increment sp_offset too.\n+\t(choose_baseaddr_len, choose_baseaddr): New.\n+\t(ix86_emit_save_reg_using_mov): New.\n+\t(ix86_emit_save_regs_using_mov): Use it.\n+\t(ix86_emit_save_sse_regs_using_mov): Likewise.\n+\t(ix86_add_cfa_restore_note): Take cfa_offset not red_offset argument;\n+\tcompare vs the saved red_zone_offset.\n+\t(pro_epilogue_adjust_stack): Adjust sp_offset.\n+\t(ix86_adjust_stack_and_probe): Likewise.\n+\t(ix86_expand_prologue): Set up, use, and validate the new\n+\tframe_state_info members.  Use gen_frame_mem.\n+\t(ix86_emit_restore_regs_using_pop): Remove red_offset parameter.\n+\t(ix86_emit_restore_reg_using_pop): Likewise.  Use and update the\n+\tnew frame_state_info members.\n+\t(ix86_emit_leave): Likewise.\n+\t(ix86_emit_restore_regs_using_mov): Likewise.  Don't check for\n+\tout-of-range stack pointer offsets here.\n+\t(ix86_emit_restore_sse_regs_using_mov): Likewise.\n+\t(ix86_expand_epilogue): Use and validate the new frame_state_info\n+\tmembers.  Break up and simplify the logic selecting the\n+\trestore_regs_via_mov code path.  Ensure that there will be no\n+\tout-of-range stack pointer offsets.\n+\n \t* config/i386/cygming.h (TARGET_64BIT_MS_ABI): Remove.\n \n \t* config/i386/i386.c (ix86_function_ms_hook_prologue): Fix"}, {"sha": "77dbef36ddc0ed052249a06c24bcac083511bbc9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 529, "deletions": 385, "changes": 914, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec7ded37e7550ed1e9f133b959fe92ff6fdf791d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec7ded37e7550ed1e9f133b959fe92ff6fdf791d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ec7ded37e7550ed1e9f133b959fe92ff6fdf791d", "patch": "@@ -1822,24 +1822,27 @@ struct GTY(()) stack_local_entry {\n    Stack grows downward:\n \n    [arguments]\n-\t\t\t\t\t      <- ARG_POINTER\n+\t\t\t\t\t<- ARG_POINTER\n    saved pc\n \n-   saved frame pointer if frame_pointer_needed\n-\t\t\t\t\t      <- HARD_FRAME_POINTER\n-   [saved regs]\n+   saved static chain\t\t\tif ix86_static_chain_on_stack\n \n+   saved frame pointer\t\t\tif frame_pointer_needed\n+\t\t\t\t\t<- HARD_FRAME_POINTER\n+   [saved regs]\n+\t\t\t\t\t<- regs_save_offset\n    [padding0]\n \n    [saved SSE regs]\n-\n-   [padding1]          \\\n-\t\t        )\n-   [va_arg registers]  (\n-\t\t        > to_allocate\t      <- FRAME_POINTER\n-   [frame]\t       (\n-\t\t        )\n-   [padding2]\t       /\n+\t\t\t\t\t<- sse_regs_save_offset\n+   [padding1]          |\n+\t\t       |\t\t<- FRAME_POINTER\n+   [va_arg registers]  |\n+\t\t       |\n+   [frame]\t       |\n+\t\t       |\n+   [padding2]\t       | = to_allocate\n+\t\t\t\t\t<- STACK_POINTER\n   */\n struct ix86_frame\n {\n@@ -1858,6 +1861,8 @@ struct ix86_frame\n   HOST_WIDE_INT frame_pointer_offset;\n   HOST_WIDE_INT hard_frame_pointer_offset;\n   HOST_WIDE_INT stack_pointer_offset;\n+  HOST_WIDE_INT reg_save_offset;\n+  HOST_WIDE_INT sse_reg_save_offset;\n \n   /* When save_regs_using_mov is set, emit prologue using\n      move instead of push instructions.  */\n@@ -8156,8 +8161,11 @@ output_set_got (rtx dest, rtx label ATTRIBUTE_UNUSED)\n static rtx\n gen_push (rtx arg)\n {\n-  if (ix86_cfa_state->reg == stack_pointer_rtx)\n-    ix86_cfa_state->offset += UNITS_PER_WORD;\n+  struct machine_function *m = cfun->machine;\n+\n+  if (m->fs.cfa_reg == stack_pointer_rtx)\n+    m->fs.cfa_offset += UNITS_PER_WORD;\n+  m->fs.sp_offset += UNITS_PER_WORD;\n \n   return gen_rtx_SET (VOIDmode,\n \t\t      gen_rtx_MEM (Pmode,\n@@ -8400,13 +8408,13 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n \n   frame->hard_frame_pointer_offset = offset;\n \n-  /* Set offset to aligned because the realigned frame starts from\n-     here.  */\n+  /* Set offset to aligned because the realigned frame starts from here.  */\n   if (stack_realign_fp)\n     offset = (offset + stack_alignment_needed -1) & -stack_alignment_needed;\n \n   /* Register save area */\n   offset += frame->nregs * UNITS_PER_WORD;\n+  frame->reg_save_offset = offset;\n \n   /* Align SSE reg save area.  */\n   if (frame->nsseregs)\n@@ -8416,6 +8424,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n \n   /* SSE register save area.  */\n   offset += frame->padding0 + frame->nsseregs * 16;\n+  frame->sse_reg_save_offset = offset;\n \n   /* Va-arg area */\n   frame->va_arg_size = ix86_varargs_gpr_size + ix86_varargs_fpr_size;\n@@ -8487,6 +8496,104 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   frame->stack_pointer_offset -= frame->red_zone_size;\n }\n \n+/* This is semi-inlined memory_address_length, but simplified\n+   since we know that we're always dealing with reg+offset, and\n+   to avoid having to create and discard all that rtl.  */\n+\n+static inline int\n+choose_baseaddr_len (unsigned int regno, HOST_WIDE_INT offset)\n+{\n+  int len = 4;\n+\n+  if (offset == 0)\n+    {\n+      /* EBP and R13 cannot be encoded without an offset.  */\n+      len = (regno == BP_REG || regno == R13_REG);\n+    }\n+  else if (IN_RANGE (offset, -128, 127))\n+    len = 1;\n+\n+  /* ESP and R12 must be encoded with a SIB byte.  */\n+  if (regno == SP_REG || regno == R12_REG)\n+    len++;\n+\n+  return len;\n+}\n+  \n+/* Return an RTX that points to CFA_OFFSET within the stack frame.\n+   The valid base registers are taken from CFUN->MACHINE->FS.  */\n+\n+static rtx\n+choose_baseaddr (HOST_WIDE_INT cfa_offset)\n+{\n+  const struct machine_function *m = cfun->machine;\n+  rtx base_reg = NULL;\n+  HOST_WIDE_INT base_offset = 0;\n+\n+  if (m->use_fast_prologue_epilogue)\n+    {\n+      /* Choose the base register most likely to allow the most scheduling\n+         opportunities.  Generally FP is valid througout the function,\n+         while DRAP must be reloaded within the epilogue.  But choose either\n+         over the SP due to increased encoding size.  */\n+\n+      if (m->fs.fp_valid)\n+\t{\n+\t  base_reg = hard_frame_pointer_rtx;\n+\t  base_offset = m->fs.fp_offset - cfa_offset;\n+\t}\n+      else if (m->fs.drap_valid)\n+\t{\n+\t  base_reg = crtl->drap_reg;\n+\t  base_offset = 0 - cfa_offset;\n+\t}\n+      else if (m->fs.sp_valid)\n+\t{\n+\t  base_reg = stack_pointer_rtx;\n+\t  base_offset = m->fs.sp_offset - cfa_offset;\n+\t}\n+    }\n+  else\n+    {\n+      HOST_WIDE_INT toffset;\n+      int len = 16, tlen;\n+\n+      /* Choose the base register with the smallest address encoding.\n+         With a tie, choose FP > DRAP > SP.  */\n+      if (m->fs.sp_valid)\n+\t{\n+\t  base_reg = stack_pointer_rtx;\n+\t  base_offset = m->fs.sp_offset - cfa_offset;\n+          len = choose_baseaddr_len (STACK_POINTER_REGNUM, base_offset);\n+\t}\n+      if (m->fs.drap_valid)\n+\t{\n+\t  toffset = 0 - cfa_offset;\n+\t  tlen = choose_baseaddr_len (REGNO (crtl->drap_reg), toffset);\n+\t  if (tlen <= len)\n+\t    {\n+\t      base_reg = crtl->drap_reg;\n+\t      base_offset = toffset;\n+\t      len = tlen;\n+\t    }\n+\t}\n+      if (m->fs.fp_valid)\n+\t{\n+\t  toffset = m->fs.fp_offset - cfa_offset;\n+\t  tlen = choose_baseaddr_len (HARD_FRAME_POINTER_REGNUM, toffset);\n+\t  if (tlen <= len)\n+\t    {\n+\t      base_reg = hard_frame_pointer_rtx;\n+\t      base_offset = toffset;\n+\t      len = tlen;\n+\t    }\n+\t}\n+    }\n+  gcc_assert (base_reg != NULL);\n+\n+  return plus_constant (base_reg, base_offset);\n+}\n+\n /* Emit code to save registers in the prologue.  */\n \n static void\n@@ -8503,59 +8610,80 @@ ix86_emit_save_regs (void)\n       }\n }\n \n-/* Emit code to save registers using MOV insns.  First register\n-   is restored from POINTER + OFFSET.  */\n+/* Emit a single register save at CFA - CFA_OFFSET.  */\n+\n+static void\n+ix86_emit_save_reg_using_mov (enum machine_mode mode, unsigned int regno,\n+\t\t\t      HOST_WIDE_INT cfa_offset)\n+{\n+  rtx reg = gen_rtx_REG (mode, regno);\n+  rtx mem, addr, insn;\n+\n+  addr = choose_baseaddr (cfa_offset);\n+  mem = gen_frame_mem (mode, addr);\n+\n+  /* For SSE saves, we need to indicate the 128-bit alignment.  */\n+  set_mem_align (mem, GET_MODE_ALIGNMENT (mode));\n+\n+  insn = emit_move_insn (mem, reg);\n+\n+  /* The memory may not be relative to the current CFA register,\n+     which means that we may need to generate a new pattern for\n+     use by the unwind info.  */\n+  if (GET_CODE (addr) == PLUS)\n+    addr = XEXP (addr, 0);\n+  if (addr != cfun->machine->fs.cfa_reg)\n+    {\n+      addr = plus_constant (cfun->machine->fs.cfa_reg,\n+\t\t\t    cfun->machine->fs.cfa_offset - cfa_offset);\n+      mem = gen_rtx_MEM (mode, addr);\n+      add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (VOIDmode, mem, reg));\n+    }\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n+/* Emit code to save registers using MOV insns.\n+   First register is stored at CFA - CFA_OFFSET.  */\n static void\n-ix86_emit_save_regs_using_mov (rtx pointer, HOST_WIDE_INT offset)\n+ix86_emit_save_regs_using_mov (HOST_WIDE_INT cfa_offset)\n {\n   unsigned int regno;\n-  rtx insn;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, true))\n       {\n-\tinsn = emit_move_insn (adjust_address (gen_rtx_MEM (Pmode, pointer),\n-\t\t\t\t\t       Pmode, offset),\n-\t\t\t       gen_rtx_REG (Pmode, regno));\n-\tRTX_FRAME_RELATED_P (insn) = 1;\n-\toffset += UNITS_PER_WORD;\n+        ix86_emit_save_reg_using_mov (Pmode, regno, cfa_offset);\n+\tcfa_offset -= UNITS_PER_WORD;\n       }\n }\n \n-/* Emit code to save registers using MOV insns.  First register\n-   is restored from POINTER + OFFSET.  */\n+/* Emit code to save SSE registers using MOV insns.\n+   First register is stored at CFA - CFA_OFFSET.  */\n static void\n-ix86_emit_save_sse_regs_using_mov (rtx pointer, HOST_WIDE_INT offset)\n+ix86_emit_save_sse_regs_using_mov (HOST_WIDE_INT cfa_offset)\n {\n   unsigned int regno;\n-  rtx insn;\n-  rtx mem;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (SSE_REGNO_P (regno) && ix86_save_reg (regno, true))\n       {\n-\tmem = adjust_address (gen_rtx_MEM (TImode, pointer), TImode, offset);\n-\tset_mem_align (mem, 128);\n-\tinsn = emit_move_insn (mem, gen_rtx_REG (TImode, regno));\n-\tRTX_FRAME_RELATED_P (insn) = 1;\n-\toffset += 16;\n+\tix86_emit_save_reg_using_mov (V4SFmode, regno, cfa_offset);\n+\tcfa_offset -= 16;\n       }\n }\n \n static GTY(()) rtx queued_cfa_restores;\n \n /* Add a REG_CFA_RESTORE REG note to INSN or queue them until next stack\n-   manipulation insn.  Don't add it if the previously\n-   saved value will be left untouched within stack red-zone till return,\n-   as unwinders can find the same value in the register and\n-   on the stack.  */\n+   manipulation insn.  The value is on the stack at CFA - CFA_OFFSET.\n+   Don't add the note if the previously saved value will be left untouched\n+   within stack red-zone till return, as unwinders can find the same value\n+   in the register and on the stack.  */\n \n static void\n-ix86_add_cfa_restore_note (rtx insn, rtx reg, HOST_WIDE_INT red_offset)\n+ix86_add_cfa_restore_note (rtx insn, rtx reg, HOST_WIDE_INT cfa_offset)\n {\n-  if (ix86_using_red_zone ()\n-      && red_offset + RED_ZONE_SIZE >= 0\n-      && crtl->args.pops_args < 65536)\n+  if (cfa_offset <= cfun->machine->fs.red_zone_offset)\n     return;\n \n   if (insn)\n@@ -8594,6 +8722,7 @@ static void\n pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset,\n \t\t\t   int style, bool set_cfa)\n {\n+  struct machine_function *m = cfun->machine;\n   rtx insn;\n \n   if (! TARGET_64BIT)\n@@ -8627,9 +8756,9 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset,\n     {\n       rtx r;\n \n-      gcc_assert (ix86_cfa_state->reg == src);\n-      ix86_cfa_state->offset += INTVAL (offset);\n-      ix86_cfa_state->reg = dest;\n+      gcc_assert (m->fs.cfa_reg == src);\n+      m->fs.cfa_offset += INTVAL (offset);\n+      m->fs.cfa_reg = dest;\n \n       r = gen_rtx_PLUS (Pmode, src, offset);\n       r = gen_rtx_SET (VOIDmode, dest, r);\n@@ -8638,6 +8767,34 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset,\n     }\n   else if (style < 0)\n     RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  if (dest == stack_pointer_rtx)\n+    {\n+      HOST_WIDE_INT ooffset = m->fs.sp_offset;\n+      bool valid = m->fs.sp_valid;\n+\n+      if (src == hard_frame_pointer_rtx)\n+\t{\n+\t  valid = m->fs.fp_valid;\n+\t  ooffset = m->fs.fp_offset;\n+\t}\n+      else if (src == crtl->drap_reg)\n+\t{\n+\t  valid = m->fs.drap_valid;\n+\t  ooffset = 0;\n+\t}\n+      else\n+\t{\n+\t  /* Else there are two possibilities: SP itself, which we set\n+\t     up as the default above.  Or EH_RETURN_STACKADJ_RTX, which is\n+\t     taken care of this by hand along the eh_return path.  */\n+\t  gcc_checking_assert (src == stack_pointer_rtx\n+\t\t\t       || offset == const0_rtx);\n+\t}\n+\n+      m->fs.sp_offset = ooffset - INTVAL (offset);\n+      m->fs.sp_valid = valid;\n+    }\n }\n \n /* Find an available register to be used as dynamic realign argument\n@@ -8883,7 +9040,7 @@ release_scratch_register_on_entry (struct scratch_reg *sr)\n /* Emit code to adjust the stack pointer by SIZE bytes while probing it.  */\n \n static void\n-ix86_adjust_stack_and_probe (HOST_WIDE_INT size)\n+ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n {\n   /* We skip the probe for the first interval + a small dope of 4 words and\n      probe that many bytes past the specified size to maintain a protection\n@@ -8999,7 +9156,8 @@ ix86_adjust_stack_and_probe (HOST_WIDE_INT size)\n       release_scratch_register_on_entry (&sr);\n     }\n \n-  gcc_assert (ix86_cfa_state->reg != stack_pointer_rtx);\n+  gcc_assert (cfun->machine->fs.cfa_reg != stack_pointer_rtx);\n+  cfun->machine->fs.sp_offset += size;\n \n   /* Make sure nothing is scheduled before we are done.  */\n   emit_insn (gen_blockage ());\n@@ -9199,21 +9357,29 @@ ix86_finalize_stack_realign_flags (void)\n void\n ix86_expand_prologue (void)\n {\n-  rtx insn;\n+  struct machine_function *m = cfun->machine;\n+  rtx insn, t;\n   bool pic_reg_used;\n   struct ix86_frame frame;\n   HOST_WIDE_INT allocate;\n-  bool gen_frame_pointer = frame_pointer_needed;\n   bool int_registers_saved = false;\n \n   ix86_finalize_stack_realign_flags ();\n \n   /* DRAP should not coexist with stack_realign_fp */\n   gcc_assert (!(crtl->drap_reg && stack_realign_fp));\n \n+  memset (&m->fs, 0, sizeof (m->fs));\n+\n   /* Initialize CFA state for before the prologue.  */\n-  ix86_cfa_state->reg = stack_pointer_rtx;\n-  ix86_cfa_state->offset = INCOMING_FRAME_SP_OFFSET;\n+  m->fs.cfa_reg = stack_pointer_rtx;\n+  m->fs.cfa_offset = INCOMING_FRAME_SP_OFFSET;\n+\n+  /* Track SP offset to the CFA.  We continue tracking this after we've\n+     swapped the CFA register away from SP.  In the case of re-alignment\n+     this is fudged; we're interested to offsets within the local frame.  */\n+  m->fs.sp_offset = INCOMING_FRAME_SP_OFFSET;\n+  m->fs.sp_valid = true;\n \n   ix86_compute_frame_layout (&frame);\n \n@@ -9275,9 +9441,11 @@ ix86_expand_prologue (void)\n \t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n \t\t\tgen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, push, mov)));\n \n-\t  if (ix86_cfa_state->reg == stack_pointer_rtx)\n-\t    ix86_cfa_state->reg = hard_frame_pointer_rtx;\n-\t  gen_frame_pointer = false;\n+\t  /* Note that gen_push incremented m->fs.cfa_offset, even\n+\t     though we didn't emit the push insn here.  */\n+\t  m->fs.cfa_reg = hard_frame_pointer_rtx;\n+\t  m->fs.fp_offset = m->fs.cfa_offset;\n+\t  m->fs.fp_valid = true;\n \t}\n       else\n \t{\n@@ -9292,8 +9460,6 @@ ix86_expand_prologue (void)\n      call.  This insn will be skipped by the trampoline.  */\n   else if (ix86_static_chain_on_stack)\n     {\n-      rtx t;\n-\n       insn = emit_insn (gen_push (ix86_static_chain (cfun->decl, false)));\n       emit_insn (gen_blockage ());\n \n@@ -9308,35 +9474,24 @@ ix86_expand_prologue (void)\n \n   /* Emit prologue code to adjust stack alignment and setup DRAP, in case\n      of DRAP is needed and stack realignment is really needed after reload */\n-  if (crtl->drap_reg && crtl->stack_realign_needed)\n+  if (stack_realign_drap)\n     {\n-      rtx x, y;\n       int align_bytes = crtl->stack_alignment_needed / BITS_PER_UNIT;\n-      int param_ptr_offset = UNITS_PER_WORD;\n-\n-      if (ix86_static_chain_on_stack)\n-\tparam_ptr_offset += UNITS_PER_WORD;\n-      if (!call_used_regs[REGNO (crtl->drap_reg)])\n-\tparam_ptr_offset += UNITS_PER_WORD;\n-\n-      gcc_assert (stack_realign_drap);\n-\n-      /* Grab the argument pointer.  */\n-      x = plus_constant (stack_pointer_rtx, param_ptr_offset);\n-      y = crtl->drap_reg;\n \n-      /* Only need to push parameter pointer reg if it is caller\n-\t saved reg */\n+      /* Only need to push parameter pointer reg if it is caller saved.  */\n       if (!call_used_regs[REGNO (crtl->drap_reg)])\n \t{\n \t  /* Push arg pointer reg */\n-\t  insn = emit_insn (gen_push (y));\n+\t  insn = emit_insn (gen_push (crtl->drap_reg));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n \n-      insn = emit_insn (gen_rtx_SET (VOIDmode, y, x));\n+      /* Grab the argument pointer.  */\n+      t = plus_constant (stack_pointer_rtx, m->fs.sp_offset);\n+      insn = emit_insn (gen_rtx_SET (VOIDmode, crtl->drap_reg, t));\n       RTX_FRAME_RELATED_P (insn) = 1;\n-      ix86_cfa_state->reg = crtl->drap_reg;\n+      m->fs.cfa_reg = crtl->drap_reg;\n+      m->fs.cfa_offset = 0;\n \n       /* Align the stack.  */\n       insn = emit_insn (ix86_gen_andsp (stack_pointer_rtx,\n@@ -9348,26 +9503,31 @@ ix86_expand_prologue (void)\n \t address can be reached via (argp - 1) slot.  This is needed\n \t to implement macro RETURN_ADDR_RTX and intrinsic function\n \t expand_builtin_return_addr etc.  */\n-      x = crtl->drap_reg;\n-      x = gen_frame_mem (Pmode,\n-                         plus_constant (x, -UNITS_PER_WORD));\n-      insn = emit_insn (gen_push (x));\n+      t = plus_constant (crtl->drap_reg, -UNITS_PER_WORD);\n+      t = gen_frame_mem (Pmode, t);\n+      insn = emit_insn (gen_push (t));\n       RTX_FRAME_RELATED_P (insn) = 1;\n-    }\n \n-  /* Note: AT&T enter does NOT have reversed args.  Enter is probably\n-     slower on all targets.  Also sdb doesn't like it.  */\n+      /* For the purposes of frame and register save area addressing,\n+\t we've started over with a new frame.  */\n+      m->fs.sp_offset = INCOMING_FRAME_SP_OFFSET;\n+    }\n \n-  if (gen_frame_pointer)\n+  if (frame_pointer_needed && !m->fs.fp_valid)\n     {\n+      /* Note: AT&T enter does NOT have reversed args.  Enter is probably\n+         slower on all targets.  Also sdb doesn't like it.  */\n       insn = emit_insn (gen_push (hard_frame_pointer_rtx));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n       insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n-      if (ix86_cfa_state->reg == stack_pointer_rtx)\n-        ix86_cfa_state->reg = hard_frame_pointer_rtx;\n+      if (m->fs.cfa_reg == stack_pointer_rtx)\n+        m->fs.cfa_reg = hard_frame_pointer_rtx;\n+      gcc_assert (m->fs.sp_offset == frame.hard_frame_pointer_offset);\n+      m->fs.fp_offset = m->fs.sp_offset;\n+      m->fs.fp_valid = true;\n     }\n \n   if (stack_realign_fp)\n@@ -9380,6 +9540,14 @@ ix86_expand_prologue (void)\n \t\t\t\t\tstack_pointer_rtx,\n \t\t\t\t\tGEN_INT (-align_bytes)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* For the purposes of register save area addressing, the frame\n+         pointer is no longer valid.  */\n+      /* ??? There's no need to place the register save area into the\n+\t aligned local stack frame.  We should do this later, after\n+\t the register saves.  */\n+      m->fs.fp_valid = false;\n+      m->fs.sp_offset = (m->fs.sp_offset + align_bytes - 1) & -align_bytes;\n     }\n \n   allocate = frame.to_allocate + frame.nsseregs * 16 + frame.padding0;\n@@ -9388,6 +9556,7 @@ ix86_expand_prologue (void)\n     {\n       ix86_emit_save_regs ();\n       int_registers_saved = true;\n+      gcc_assert (m->fs.sp_offset == frame.reg_save_offset);\n     }\n   else\n     allocate += frame.nregs * UNITS_PER_WORD;\n@@ -9418,34 +9587,30 @@ ix86_expand_prologue (void)\n \t}\n     }\n \n-  /* When using red zone we may start register saving before allocating\n-     the stack frame saving one cycle of the prologue. However I will\n-     avoid doing this if I am going to have to probe the stack since\n-     at least on x86_64 the stack probe can turn into a call that clobbers\n-     a red zone location */\n+  /* When using red zone we may start register saving before allocating the\n+     stack frame saving one cycle of the prologue.  However, avoid doing this\n+     if we have to probe the stack; at least on x86_64 the stack probe can\n+     turn into a call that clobbers a red zone location.  */\n   if (!int_registers_saved\n       && ix86_using_red_zone ()\n       && (! TARGET_STACK_PROBE || allocate < CHECK_STACK_LIMIT))\n     {\n-      ix86_emit_save_regs_using_mov ((frame_pointer_needed\n-\t\t\t\t      && !crtl->stack_realign_needed)\n-                                     ? hard_frame_pointer_rtx\n-\t\t\t\t     : stack_pointer_rtx,\n-\t\t\t\t     -frame.nregs * UNITS_PER_WORD);\n+      ix86_emit_save_regs_using_mov (frame.reg_save_offset);\n       int_registers_saved = true;\n     }\n \n   if (allocate == 0)\n     ;\n   else if (!ix86_target_stack_probe () || allocate < CHECK_STACK_LIMIT)\n-    pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t       GEN_INT (-allocate), -1,\n-\t\t\t       ix86_cfa_state->reg == stack_pointer_rtx);\n+    {\n+      pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t         GEN_INT (-allocate), -1,\n+\t\t\t         m->fs.cfa_reg == stack_pointer_rtx);\n+    }\n   else\n     {\n       rtx eax = gen_rtx_REG (Pmode, AX_REG);\n       bool eax_live;\n-      rtx t;\n \n       if (cfun->machine->call_abi == MS_ABI)\n \teax_live = false;\n@@ -9462,50 +9627,28 @@ ix86_expand_prologue (void)\n \n       insn = emit_insn (ix86_gen_allocate_stack_worker (eax, eax));\n \n-      if (ix86_cfa_state->reg == stack_pointer_rtx)\n+      if (m->fs.cfa_reg == stack_pointer_rtx)\n \t{\n-\t  ix86_cfa_state->offset += allocate;\n+\t  m->fs.cfa_offset += allocate;\n \t  t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (-allocate));\n \t  t = gen_rtx_SET (VOIDmode, stack_pointer_rtx, t);\n \t  add_reg_note (insn, REG_CFA_ADJUST_CFA, t);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n+      m->fs.sp_offset += allocate;\n \n       if (eax_live)\n \t{\n-\t  if (frame_pointer_needed)\n-\t    t = plus_constant (hard_frame_pointer_rtx,\n-\t\t\t       allocate\n-\t\t\t       - frame.to_allocate\n-\t\t\t       - frame.nregs * UNITS_PER_WORD);\n-\t  else\n-\t    t = plus_constant (stack_pointer_rtx, allocate);\n-\t  emit_move_insn (eax, gen_rtx_MEM (Pmode, t));\n+\t  t = choose_baseaddr (m->fs.sp_offset - allocate);\n+\t  emit_move_insn (eax, gen_frame_mem (Pmode, t));\n \t}\n     }\n+  gcc_assert (m->fs.sp_offset == frame.stack_pointer_offset);\n \n   if (!int_registers_saved)\n-    {\n-      if (!frame_pointer_needed\n-\t  || !(frame.to_allocate + frame.padding0)\n-\t  || crtl->stack_realign_needed)\n-        ix86_emit_save_regs_using_mov (stack_pointer_rtx,\n-\t\t\t\t       frame.to_allocate\n-\t\t\t\t       + frame.nsseregs * 16 + frame.padding0);\n-      else\n-        ix86_emit_save_regs_using_mov (hard_frame_pointer_rtx,\n-\t\t\t\t       -frame.nregs * UNITS_PER_WORD);\n-    }\n-  if (!frame_pointer_needed\n-      || !(frame.to_allocate + frame.padding0)\n-      || crtl->stack_realign_needed)\n-    ix86_emit_save_sse_regs_using_mov (stack_pointer_rtx,\n-\t\t\t\t       frame.to_allocate);\n-  else\n-    ix86_emit_save_sse_regs_using_mov (hard_frame_pointer_rtx,\n-\t\t\t\t       - frame.nregs * UNITS_PER_WORD\n-\t\t\t\t       - frame.nsseregs * 16\n-\t\t\t\t       - frame.padding0);\n+    ix86_emit_save_regs_using_mov (frame.reg_save_offset);\n+  if (frame.nsseregs)\n+    ix86_emit_save_sse_regs_using_mov (frame.sse_reg_save_offset);\n \n   pic_reg_used = false;\n   if (pic_offset_table_rtx\n@@ -9555,13 +9698,8 @@ ix86_expand_prologue (void)\n       /* vDRAP is setup but after reload it turns out stack realign\n          isn't necessary, here we will emit prologue to setup DRAP\n          without stack realign adjustment */\n-      rtx x;\n-      int drap_bp_offset = UNITS_PER_WORD * 2;\n-\n-      if (ix86_static_chain_on_stack)\n-\tdrap_bp_offset += UNITS_PER_WORD;\n-      x = plus_constant (hard_frame_pointer_rtx, drap_bp_offset);\n-      insn = emit_insn (gen_rtx_SET (VOIDmode, crtl->drap_reg, x));\n+      t = choose_baseaddr (0);\n+      emit_insn (gen_rtx_SET (VOIDmode, crtl->drap_reg, t));\n     }\n \n   /* Prevent instructions from being scheduled into register save push\n@@ -9581,11 +9719,15 @@ ix86_expand_prologue (void)\n /* Emit code to restore REG using a POP insn.  */\n \n static void\n-ix86_emit_restore_reg_using_pop (rtx reg, HOST_WIDE_INT red_offset)\n+ix86_emit_restore_reg_using_pop (rtx reg)\n {\n+  struct machine_function *m = cfun->machine;\n   rtx insn = emit_insn (ix86_gen_pop1 (reg));\n \n-  if (ix86_cfa_state->reg == crtl->drap_reg\n+  ix86_add_cfa_restore_note (insn, reg, m->fs.sp_offset);\n+  m->fs.sp_offset -= UNITS_PER_WORD;\n+\n+  if (m->fs.cfa_reg == crtl->drap_reg\n       && REGNO (reg) == REGNO (crtl->drap_reg))\n     {\n       /* Previously we'd represented the CFA as an expression\n@@ -9595,12 +9737,15 @@ ix86_emit_restore_reg_using_pop (rtx reg, HOST_WIDE_INT red_offset)\n \t the stack pointer.  */\n       add_reg_note (insn, REG_CFA_DEF_CFA, reg);\n       RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* This means that the DRAP register is valid for addressing too.  */\n+      m->fs.drap_valid = true;\n       return;\n     }\n \n-  if (ix86_cfa_state->reg == stack_pointer_rtx)\n+  if (m->fs.cfa_reg == stack_pointer_rtx)\n     {\n-      ix86_cfa_state->offset -= UNITS_PER_WORD;\n+      m->fs.cfa_offset -= UNITS_PER_WORD;\n       add_reg_note (insn, REG_CFA_ADJUST_CFA,\n \t\t    copy_rtx (XVECEXP (PATTERN (insn), 0, 1)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -9611,92 +9756,82 @@ ix86_emit_restore_reg_using_pop (rtx reg, HOST_WIDE_INT red_offset)\n      for stack frames that don't allocate other data, so we assume\n      the stack pointer is now pointing at the return address, i.e.\n      the function entry state, which makes the offset be 1 word.  */\n-  else if (ix86_cfa_state->reg == hard_frame_pointer_rtx\n-\t   && reg == hard_frame_pointer_rtx)\n+  if (reg == hard_frame_pointer_rtx)\n     {\n-      ix86_cfa_state->reg = stack_pointer_rtx;\n-      ix86_cfa_state->offset -= UNITS_PER_WORD;\n+      m->fs.fp_valid = false;\n+      if (m->fs.cfa_reg == hard_frame_pointer_rtx)\n+\t{\n+\t  m->fs.cfa_reg = stack_pointer_rtx;\n+\t  m->fs.cfa_offset -= UNITS_PER_WORD;\n \n-      add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t    gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t  GEN_INT (ix86_cfa_state->offset)));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t\tgen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t      GEN_INT (m->fs.cfa_offset)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n     }\n-\n-  ix86_add_cfa_restore_note (insn, reg, red_offset);\n }\n \n /* Emit code to restore saved registers using POP insns.  */\n \n static void\n-ix86_emit_restore_regs_using_pop (HOST_WIDE_INT red_offset)\n+ix86_emit_restore_regs_using_pop (void)\n {\n-  int regno;\n+  unsigned int regno;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, false))\n-      {\n-\tix86_emit_restore_reg_using_pop (gen_rtx_REG (Pmode, regno),\n-\t\t\t\t\t red_offset);\n-\tred_offset += UNITS_PER_WORD;\n-      }\n+      ix86_emit_restore_reg_using_pop (gen_rtx_REG (Pmode, regno));\n }\n \n /* Emit code and notes for the LEAVE instruction.  */\n \n static void\n-ix86_emit_leave (HOST_WIDE_INT red_offset)\n+ix86_emit_leave (void)\n {\n+  struct machine_function *m = cfun->machine;\n   rtx insn = emit_insn (ix86_gen_leave ());\n \n   ix86_add_queued_cfa_restore_notes (insn);\n \n-  if (ix86_cfa_state->reg == hard_frame_pointer_rtx)\n+  gcc_assert (m->fs.fp_valid);\n+  m->fs.sp_valid = true;\n+  m->fs.sp_offset = m->fs.fp_offset - UNITS_PER_WORD;\n+  m->fs.fp_valid = false;\n+\n+  if (m->fs.cfa_reg == hard_frame_pointer_rtx)\n     {\n-      ix86_cfa_state->reg = stack_pointer_rtx;\n-      ix86_cfa_state->offset -= UNITS_PER_WORD;\n+      m->fs.cfa_reg = stack_pointer_rtx;\n+      m->fs.cfa_offset = m->fs.sp_offset;\n \n-      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n-\t\t    copy_rtx (XVECEXP (PATTERN (insn), 0, 0)));\n+      add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t    plus_constant (stack_pointer_rtx, m->fs.sp_offset));\n       RTX_FRAME_RELATED_P (insn) = 1;\n-      ix86_add_cfa_restore_note (insn, hard_frame_pointer_rtx, red_offset);\n+      ix86_add_cfa_restore_note (insn, hard_frame_pointer_rtx,\n+\t\t\t\t m->fs.fp_offset);\n     }\n }\n \n-/* Emit code to restore saved registers using MOV insns.  First register\n-   is restored from POINTER + OFFSET.  */\n+/* Emit code to restore saved registers using MOV insns.\n+   First register is restored from CFA - CFA_OFFSET.  */\n static void\n-ix86_emit_restore_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n-\t\t\t\t  HOST_WIDE_INT red_offset,\n+ix86_emit_restore_regs_using_mov (HOST_WIDE_INT cfa_offset,\n \t\t\t\t  int maybe_eh_return)\n {\n+  struct machine_function *m = cfun->machine;\n   unsigned int regno;\n-  rtx base_address = gen_rtx_MEM (Pmode, pointer);\n-  rtx insn;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, maybe_eh_return))\n       {\n \trtx reg = gen_rtx_REG (Pmode, regno);\n+\trtx insn, mem;\n+\t\n+\tmem = choose_baseaddr (cfa_offset);\n+\tmem = gen_frame_mem (Pmode, mem);\n+\tinsn = emit_move_insn (reg, mem);\n \n-\t/* Ensure that adjust_address won't be forced to produce pointer\n-\t   out of range allowed by x86-64 instruction set.  */\n-\tif (TARGET_64BIT && offset != trunc_int_for_mode (offset, SImode))\n-\t  {\n-\t    rtx r11;\n-\n-\t    r11 = gen_rtx_REG (DImode, R11_REG);\n-\t    emit_move_insn (r11, GEN_INT (offset));\n-\t    emit_insn (gen_adddi3 (r11, r11, pointer));\n-\t    base_address = gen_rtx_MEM (Pmode, r11);\n-\t    offset = 0;\n-\t  }\n-\tinsn = emit_move_insn (reg,\n-\t\t\t       adjust_address (base_address, Pmode, offset));\n-\toffset += UNITS_PER_WORD;\n-\n-        if (ix86_cfa_state->reg == crtl->drap_reg\n-\t    && regno == REGNO (crtl->drap_reg))\n+        if (m->fs.cfa_reg == crtl->drap_reg && regno == REGNO (crtl->drap_reg))\n \t  {\n \t    /* Previously we'd represented the CFA as an expression\n \t       like *(%ebp - 8).  We've just popped that value from\n@@ -9705,50 +9840,39 @@ ix86_emit_restore_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n \t       the stack pointer.  */\n \t    add_reg_note (insn, REG_CFA_DEF_CFA, reg);\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t    /* This means that the DRAP register is valid for addressing.  */\n+\t    m->fs.drap_valid = true;\n \t  }\n \telse\n-\t  ix86_add_cfa_restore_note (NULL_RTX, reg, red_offset);\n+\t  ix86_add_cfa_restore_note (NULL_RTX, reg, cfa_offset);\n \n-\tred_offset += UNITS_PER_WORD;\n+\tcfa_offset -= UNITS_PER_WORD;\n       }\n }\n \n-/* Emit code to restore saved registers using MOV insns.  First register\n-   is restored from POINTER + OFFSET.  */\n+/* Emit code to restore saved registers using MOV insns.\n+   First register is restored from CFA - CFA_OFFSET.  */\n static void\n-ix86_emit_restore_sse_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n-\t\t\t\t      HOST_WIDE_INT red_offset,\n+ix86_emit_restore_sse_regs_using_mov (HOST_WIDE_INT cfa_offset,\n \t\t\t\t      int maybe_eh_return)\n {\n-  int regno;\n-  rtx base_address = gen_rtx_MEM (TImode, pointer);\n-  rtx mem;\n+  unsigned int regno;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (SSE_REGNO_P (regno) && ix86_save_reg (regno, maybe_eh_return))\n       {\n-\trtx reg = gen_rtx_REG (TImode, regno);\n-\n-\t/* Ensure that adjust_address won't be forced to produce pointer\n-\t   out of range allowed by x86-64 instruction set.  */\n-\tif (TARGET_64BIT && offset != trunc_int_for_mode (offset, SImode))\n-\t  {\n-\t    rtx r11;\n+\trtx reg = gen_rtx_REG (V4SFmode, regno);\n+\trtx mem;\n \n-\t    r11 = gen_rtx_REG (DImode, R11_REG);\n-\t    emit_move_insn (r11, GEN_INT (offset));\n-\t    emit_insn (gen_adddi3 (r11, r11, pointer));\n-\t    base_address = gen_rtx_MEM (TImode, r11);\n-\t    offset = 0;\n-\t  }\n-\tmem = adjust_address (base_address, TImode, offset);\n+\tmem = choose_baseaddr (cfa_offset);\n+\tmem = gen_rtx_MEM (V4SFmode, mem);\n \tset_mem_align (mem, 128);\n \temit_move_insn (reg, mem);\n-\toffset += 16;\n \n-\tix86_add_cfa_restore_note (NULL_RTX, reg, red_offset);\n+\tix86_add_cfa_restore_note (NULL_RTX, reg, cfa_offset);\n \n-\tred_offset += 16;\n+\tcfa_offset -= 16;\n       }\n }\n \n@@ -9757,120 +9881,124 @@ ix86_emit_restore_sse_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n void\n ix86_expand_epilogue (int style)\n {\n-  int sp_valid;\n+  struct machine_function *m = cfun->machine;\n+  struct machine_frame_state frame_state_save = m->fs;\n   struct ix86_frame frame;\n-  HOST_WIDE_INT offset, red_offset;\n-  struct machine_cfa_state cfa_state_save = *ix86_cfa_state;\n+  bool restore_regs_via_mov;\n   bool using_drap;\n \n   ix86_finalize_stack_realign_flags ();\n+  ix86_compute_frame_layout (&frame);\n \n- /* When stack is realigned, SP must be valid.  */\n-  sp_valid = (!frame_pointer_needed\n-\t      || current_function_sp_is_unchanging\n-\t      || stack_realign_fp);\n+  /* When stack is realigned, SP must be valid.  */\n+  m->fs.sp_valid = (!frame_pointer_needed\n+\t\t    || current_function_sp_is_unchanging\n+\t\t    || stack_realign_fp);\n+  gcc_assert (!m->fs.sp_valid\n+\t      || m->fs.sp_offset == frame.stack_pointer_offset);\n \n-  ix86_compute_frame_layout (&frame);\n+  /* The FP must be valid if the frame pointer is present, but not\n+     if the register save area is in the re-aligned local frame and\n+     the FP points to the unaligned argument frame.  */\n+  gcc_assert (frame_pointer_needed\n+\t      ? stack_realign_fp != m->fs.fp_valid\n+\t      : !m->fs.fp_valid);\n+  gcc_assert (!m->fs.fp_valid\n+\t      || m->fs.fp_offset == frame.hard_frame_pointer_offset);\n+\n+  /* We must have *some* valid pointer to the stack frame.  */\n+  gcc_assert (m->fs.sp_valid || m->fs.fp_valid);\n+\n+  /* The DRAP is never valid at this point.  */\n+  gcc_assert (!m->fs.drap_valid);\n \n   /* See the comment about red zone and frame\n      pointer usage in ix86_expand_prologue.  */\n   if (frame_pointer_needed && frame.red_zone_size)\n     emit_insn (gen_memory_blockage ());\n \n   using_drap = crtl->drap_reg && crtl->stack_realign_needed;\n-  gcc_assert (!using_drap || ix86_cfa_state->reg == crtl->drap_reg);\n+  gcc_assert (!using_drap || m->fs.cfa_reg == crtl->drap_reg);\n \n-  /* Calculate start of saved registers relative to ebp.  Special care\n-     must be taken for the normal return case of a function using\n-     eh_return: the eax and edx registers are marked as saved, but not\n-     restored along this path.  */\n-  offset = frame.nregs;\n+  /* Determine the CFA offset of the end of the red-zone.  */\n+  m->fs.red_zone_offset = 0;\n+  if (ix86_using_red_zone () && crtl->args.pops_args < 65536)\n+    {\n+      /* The red-zone begins below the return address.  */\n+      m->fs.red_zone_offset = RED_ZONE_SIZE + UNITS_PER_WORD;\n+\n+      /* Since the register save area is in the aligned portion of\n+         the stack, determine the maximum runtime displacement that\n+\t matches up with the aligned frame.  */\n+      if (crtl->stack_realign_needed)\n+\tm->fs.red_zone_offset -= (crtl->stack_alignment_needed / BITS_PER_UNIT\n+\t\t\t\t  + UNITS_PER_WORD);\n+    }\n+\n+  /* Special care must be taken for the normal return case of a function\n+     using eh_return: the eax and edx registers are marked as saved, but\n+     not restored along this path.  Adjust the save location to match.  */\n   if (crtl->calls_eh_return && style != 2)\n-    offset -= 2;\n-  offset *= -UNITS_PER_WORD;\n-  offset -= frame.nsseregs * 16 + frame.padding0;\n-\n-  /* Calculate start of saved registers relative to esp on entry of the\n-     function.  When realigning stack, this needs to be the most negative\n-     value possible at runtime.  */\n-  red_offset = offset;\n-  if (using_drap)\n-    red_offset -= crtl->stack_alignment_needed / BITS_PER_UNIT\n-\t\t  + UNITS_PER_WORD;\n-  else if (stack_realign_fp)\n-    red_offset -= crtl->stack_alignment_needed / BITS_PER_UNIT\n-\t\t  - UNITS_PER_WORD;\n-  if (ix86_static_chain_on_stack)\n-    red_offset -= UNITS_PER_WORD;\n-  if (frame_pointer_needed)\n-    red_offset -= UNITS_PER_WORD;\n+    frame.reg_save_offset -= 2 * UNITS_PER_WORD;\n \n   /* If we're only restoring one register and sp is not valid then\n      using a move instruction to restore the register since it's\n-     less work than reloading sp and popping the register.\n-\n-     The default code result in stack adjustment using add/lea instruction,\n-     while this code results in LEAVE instruction (or discrete equivalent),\n-     so it is profitable in some other cases as well.  Especially when there\n-     are no registers to restore.  We also use this code when TARGET_USE_LEAVE\n-     and there is exactly one register to pop. This heuristic may need some\n-     tuning in future.  */\n-  if ((!sp_valid && (frame.nregs + frame.nsseregs) <= 1)\n-      || (TARGET_EPILOGUE_USING_MOVE\n-\t  && cfun->machine->use_fast_prologue_epilogue\n-\t  && ((frame.nregs + frame.nsseregs) > 1\n-\t      || (frame.to_allocate + frame.padding0) != 0))\n-      || (frame_pointer_needed && !(frame.nregs + frame.nsseregs)\n-\t  && (frame.to_allocate + frame.padding0) != 0)\n-      || (frame_pointer_needed && TARGET_USE_LEAVE\n-\t  && cfun->machine->use_fast_prologue_epilogue\n-\t  && (frame.nregs + frame.nsseregs) == 1)\n-      || crtl->calls_eh_return)\n-    {\n-      /* Restore registers.  We can use ebp or esp to address the memory\n-\t locations.  If both are available, default to ebp, since offsets\n-\t are known to be small.  Only exception is esp pointing directly\n-\t to the end of block of saved registers, where we may simplify\n-\t addressing mode.\n-\n-\t If we are realigning stack with bp and sp, regs restore can't\n-\t be addressed by bp. sp must be used instead.  */\n-\n-      if (!frame_pointer_needed\n-\t  || (sp_valid && !(frame.to_allocate + frame.padding0))\n-\t  || stack_realign_fp)\n-\t{\n-\t  ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,\n-\t\t\t\t\t\tframe.to_allocate, red_offset,\n-\t\t\t\t\t\tstyle == 2);\n-\t  ix86_emit_restore_regs_using_mov (stack_pointer_rtx,\n-\t\t\t\t\t    frame.to_allocate\n-\t\t\t\t\t    + frame.nsseregs * 16\n-\t\t\t\t\t    + frame.padding0,\n-\t\t\t\t\t    red_offset\n-\t\t\t\t\t    + frame.nsseregs * 16\n-\t\t\t\t\t    + frame.padding0, style == 2);\n+     less work than reloading sp and popping the register.  */\n+  if (!m->fs.sp_valid && frame.nregs <= 1)\n+    restore_regs_via_mov = true;\n+  /* EH_RETURN requires the use of moves to function properly.  */\n+  else if (crtl->calls_eh_return)\n+    restore_regs_via_mov = true;\n+  else if (TARGET_EPILOGUE_USING_MOVE\n+\t   && cfun->machine->use_fast_prologue_epilogue\n+\t   && (frame.nregs > 1 || (frame.to_allocate + frame.padding0) != 0))\n+    restore_regs_via_mov = true;\n+  else if (frame_pointer_needed\n+\t   && !frame.nregs\n+\t   && (frame.to_allocate + frame.padding0) != 0)\n+    restore_regs_via_mov = true;\n+  else if (frame_pointer_needed\n+\t   && TARGET_USE_LEAVE\n+\t   && cfun->machine->use_fast_prologue_epilogue\n+\t   && frame.nregs == 1)\n+    restore_regs_via_mov = true;\n+  else\n+    restore_regs_via_mov = false;\n+\n+  if (restore_regs_via_mov || frame.nsseregs)\n+    {\n+      /* Ensure that the entire register save area is addressable via\n+\t the stack pointer, if we will restore via sp.  */\n+      if (TARGET_64BIT\n+\t  && m->fs.sp_offset > 0x7fffffff\n+\t  && !(m->fs.fp_valid || m->fs.drap_valid)\n+\t  && (frame.nsseregs + frame.nregs) != 0)\n+\t{\n+\t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t     GEN_INT (m->fs.sp_offset\n+\t\t\t\t\t      - frame.sse_reg_save_offset),\n+\t\t\t\t     style,\n+\t\t\t\t     m->fs.cfa_reg == stack_pointer_rtx);\n \t}\n-      else\n-        {\n-\t  ix86_emit_restore_sse_regs_using_mov (hard_frame_pointer_rtx,\n-\t\t\t\t\t\toffset, red_offset,\n-\t\t\t\t\t\tstyle == 2);\n-\t  ix86_emit_restore_regs_using_mov (hard_frame_pointer_rtx,\n-\t\t\t\t\t    offset\n-\t\t\t\t\t    + frame.nsseregs * 16\n-\t\t\t\t\t    + frame.padding0,\n-\t\t\t\t\t    red_offset\n-\t\t\t\t\t    + frame.nsseregs * 16\n-\t\t\t\t\t    + frame.padding0, style == 2);\n-        }\n+    }\n+\n+  /* If there are any SSE registers to restore, then we have to do it\n+     via moves, since there's obviously no pop for SSE regs.  */\n+  if (frame.nsseregs)\n+    ix86_emit_restore_sse_regs_using_mov (frame.sse_reg_save_offset,\n+\t\t\t\t\t  style == 2);\n \n-      red_offset -= offset;\n+  if (restore_regs_via_mov)\n+    {\n+      rtx t;\n+\n+      if (frame.nregs)\n+\tix86_emit_restore_regs_using_mov (frame.reg_save_offset, style == 2);\n \n       /* eh_return epilogues need %ecx added to the stack pointer.  */\n       if (style == 2)\n \t{\n-\t  rtx tmp, sa = EH_RETURN_STACKADJ_RTX;\n+\t  rtx insn, sa = EH_RETURN_STACKADJ_RTX;\n \n \t  /* Stack align doesn't work with eh_return.  */\n \t  gcc_assert (!crtl->stack_realign_needed);\n@@ -9879,12 +10007,12 @@ ix86_expand_epilogue (int style)\n \n \t  if (frame_pointer_needed)\n \t    {\n-\t      tmp = gen_rtx_PLUS (Pmode, hard_frame_pointer_rtx, sa);\n-\t      tmp = plus_constant (tmp, UNITS_PER_WORD);\n-\t      tmp = emit_insn (gen_rtx_SET (VOIDmode, sa, tmp));\n+\t      t = gen_rtx_PLUS (Pmode, hard_frame_pointer_rtx, sa);\n+\t      t = plus_constant (t, m->fs.fp_offset - UNITS_PER_WORD);\n+\t      emit_insn (gen_rtx_SET (VOIDmode, sa, t));\n \n-\t      tmp = gen_rtx_MEM (Pmode, hard_frame_pointer_rtx);\n-\t      tmp = emit_move_insn (hard_frame_pointer_rtx, tmp);\n+\t      t = gen_frame_mem (Pmode, hard_frame_pointer_rtx);\n+\t      insn = emit_move_insn (hard_frame_pointer_rtx, t);\n \n \t      /* Note that we use SA as a temporary CFA, as the return\n \t\t address is at the proper place relative to it.  We\n@@ -9894,56 +10022,69 @@ ix86_expand_epilogue (int style)\n \t\t other reasonable register to use for the CFA.  We don't\n \t\t bother resetting the CFA to the SP for the duration of\n \t\t the return insn.  */\n-\t      add_reg_note (tmp, REG_CFA_DEF_CFA,\n+\t      add_reg_note (insn, REG_CFA_DEF_CFA,\n \t\t\t    plus_constant (sa, UNITS_PER_WORD));\n-\t      ix86_add_queued_cfa_restore_notes (tmp);\n-\t      add_reg_note (tmp, REG_CFA_RESTORE, hard_frame_pointer_rtx);\n-\t      RTX_FRAME_RELATED_P (tmp) = 1;\n-\t      ix86_cfa_state->reg = sa;\n-\t      ix86_cfa_state->offset = UNITS_PER_WORD;\n+\t      ix86_add_queued_cfa_restore_notes (insn);\n+\t      add_reg_note (insn, REG_CFA_RESTORE, hard_frame_pointer_rtx);\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t      m->fs.cfa_reg = sa;\n+\t      m->fs.cfa_offset = UNITS_PER_WORD;\n+\t      m->fs.fp_valid = false;\n \n \t      pro_epilogue_adjust_stack (stack_pointer_rtx, sa,\n \t\t\t\t\t const0_rtx, style, false);\n \t    }\n \t  else\n \t    {\n-\t      tmp = gen_rtx_PLUS (Pmode, stack_pointer_rtx, sa);\n-\t      tmp = plus_constant (tmp, (frame.to_allocate\n-                                         + frame.nregs * UNITS_PER_WORD\n-\t\t\t\t\t + frame.nsseregs * 16\n-\t\t\t\t\t + frame.padding0));\n-\t      tmp = emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx, tmp));\n-\t      ix86_add_queued_cfa_restore_notes (tmp);\n-\n-\t      gcc_assert (ix86_cfa_state->reg == stack_pointer_rtx);\n-\t      if (ix86_cfa_state->offset != UNITS_PER_WORD)\n+\t      t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, sa);\n+\t      t = plus_constant (t, m->fs.sp_offset - UNITS_PER_WORD);\n+\t      insn = emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx, t));\n+\t      ix86_add_queued_cfa_restore_notes (insn);\n+\n+\t      gcc_assert (m->fs.cfa_reg == stack_pointer_rtx);\n+\t      if (m->fs.cfa_offset != UNITS_PER_WORD)\n \t\t{\n-\t\t  ix86_cfa_state->offset = UNITS_PER_WORD;\n-\t\t  add_reg_note (tmp, REG_CFA_DEF_CFA,\n+\t\t  m->fs.cfa_offset = UNITS_PER_WORD;\n+\t\t  add_reg_note (insn, REG_CFA_DEF_CFA,\n \t\t\t\tplus_constant (stack_pointer_rtx,\n \t\t\t\t\t       UNITS_PER_WORD));\n-\t\t  RTX_FRAME_RELATED_P (tmp) = 1;\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t\t}\n \t    }\n+\t  m->fs.sp_offset = UNITS_PER_WORD;\n \t}\n       else if (!frame_pointer_needed)\n-\tpro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t   GEN_INT (frame.to_allocate\n-\t\t\t\t\t    + frame.nregs * UNITS_PER_WORD\n-\t\t\t\t\t    + frame.nsseregs * 16\n-\t\t\t\t\t    + frame.padding0),\n-\t\t\t\t   style, !using_drap);\n-      /* If not an i386, mov & pop is faster than \"leave\".  */\n-      else if (TARGET_USE_LEAVE || optimize_function_for_size_p (cfun)\n-\t       || !cfun->machine->use_fast_prologue_epilogue)\n-\tix86_emit_leave (red_offset);\n+\t{\n+\t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t     GEN_INT (m->fs.sp_offset\n+\t\t\t\t\t      - frame.reg_save_offset\n+\t\t\t\t\t      + frame.nregs * UNITS_PER_WORD),\n+\t\t\t\t     style, !using_drap);\n+\t}\n       else\n \t{\n-\t  pro_epilogue_adjust_stack (stack_pointer_rtx,\n-\t\t\t\t     hard_frame_pointer_rtx,\n-\t\t\t\t     const0_rtx, style, !using_drap);\n+          if (stack_realign_fp)\n+\t    {\n+\t      /* We're re-defining what it means to be the local stack\n+\t\t frame.  Thus the FP is suddenly valid and the SP isn't.  */\n+\t      m->fs.fp_valid = true;\n+\t      m->fs.sp_valid = false;\n+\t    }\n \n-\t  ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx, red_offset);\n+\t  /* Leave results in shorter dependency chains on CPUs that are\n+\t     able to grok it fast.  */\n+\t  if (TARGET_USE_LEAVE\n+\t      || optimize_function_for_size_p (cfun)\n+\t      || !cfun->machine->use_fast_prologue_epilogue)\n+\t    ix86_emit_leave ();\n+          else\n+\t    {\n+\t      pro_epilogue_adjust_stack (stack_pointer_rtx,\n+\t\t\t\t         hard_frame_pointer_rtx,\n+\t\t\t\t         const0_rtx, style, !using_drap);\n+\t      ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx);\n+\t    }\n \t}\n     }\n   else\n@@ -9955,54 +10096,48 @@ ix86_expand_epilogue (int style)\n          won't be able to recover via lea $offset(%bp), %sp, because\n          there is a padding area between bp and sp for realign.\n          \"add $to_allocate, %sp\" must be used instead.  */\n-      if (!sp_valid)\n-\t{\n-\t  gcc_assert (frame_pointer_needed);\n-          gcc_assert (!stack_realign_fp);\n-\t  pro_epilogue_adjust_stack (stack_pointer_rtx,\n-\t\t\t\t     hard_frame_pointer_rtx,\n-\t\t\t\t     GEN_INT (offset), style, false);\n-          ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,\n-\t\t\t\t\t\t0, red_offset,\n-\t\t\t\t\t\tstyle == 2);\n-\t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t     GEN_INT (frame.nsseregs * 16\n-\t\t\t\t\t      + frame.padding0),\n+      if (!m->fs.sp_valid)\n+\t{\n+\t  pro_epilogue_adjust_stack (stack_pointer_rtx, hard_frame_pointer_rtx,\n+\t\t\t\t     GEN_INT (m->fs.fp_offset\n+\t\t\t\t\t      - frame.reg_save_offset),\n \t\t\t\t     style, false);\n \t}\n-      else if (frame.to_allocate || frame.padding0 || frame.nsseregs)\n+      else if (m->fs.sp_offset != frame.reg_save_offset)\n \t{\n-          ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,\n-\t\t\t\t\t\tframe.to_allocate, red_offset,\n-\t\t\t\t\t\tstyle == 2);\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t     GEN_INT (frame.to_allocate\n-\t\t\t\t     \t      + frame.nsseregs * 16\n-\t\t\t\t\t      + frame.padding0), style,\n-\t\t\t\t     !using_drap && !frame_pointer_needed);\n+\t\t\t\t     GEN_INT (m->fs.sp_offset\n+\t\t\t\t\t      - frame.reg_save_offset),\n+\t\t\t\t     style,\n+\t\t\t\t     m->fs.cfa_reg == stack_pointer_rtx);\n \t}\n \n-      ix86_emit_restore_regs_using_pop (red_offset + frame.nsseregs * 16\n-\t\t\t\t\t+ frame.padding0);\n-      red_offset -= offset;\n+      ix86_emit_restore_regs_using_pop ();\n \n       if (frame_pointer_needed)\n \t{\n+\t  if (stack_realign_fp)\n+\t    {\n+\t      /* We're re-defining what it means to be the local stack\n+\t\t frame.  Thus the FP is suddenly valid and the SP isn't.  */\n+\t      m->fs.fp_valid = true;\n+\t      m->fs.sp_valid = false;\n+\t    }\n+\n \t  /* Leave results in shorter dependency chains on CPUs that are\n \t     able to grok it fast.  */\n-\t  if (TARGET_USE_LEAVE)\n-\t    ix86_emit_leave (red_offset);\n+\t  if (TARGET_USE_LEAVE\n+\t      || (stack_realign_fp\n+\t\t  && (optimize_function_for_size_p (cfun)\n+\t\t      || !cfun->machine->use_fast_prologue_epilogue)))\n+\t    ix86_emit_leave ();\n \t  else\n             {\n-              /* For stack realigned really happens, recover stack\n-                 pointer to hard frame pointer is a must, if not using\n-                 leave.  */\n               if (stack_realign_fp)\n \t\tpro_epilogue_adjust_stack (stack_pointer_rtx,\n \t\t\t\t\t   hard_frame_pointer_rtx,\n \t\t\t\t\t   const0_rtx, style, !using_drap);\n-\t      ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx,\n-\t\t\t\t\t       red_offset);\n+\t      ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx);\n             }\n \t}\n     }\n@@ -10024,16 +10159,17 @@ ix86_expand_epilogue (int style)\n \t\t\t gen_rtx_PLUS (Pmode,\n \t\t\t\t       crtl->drap_reg,\n \t\t\t\t       GEN_INT (-param_ptr_offset))));\n-      ix86_cfa_state->reg = stack_pointer_rtx;\n-      ix86_cfa_state->offset = param_ptr_offset;\n+      m->fs.cfa_reg = stack_pointer_rtx;\n+      m->fs.cfa_offset = param_ptr_offset;\n+      m->fs.sp_offset = param_ptr_offset;\n \n       add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t    gen_rtx_PLUS (Pmode, ix86_cfa_state->reg,\n-\t\t\t\t  GEN_INT (ix86_cfa_state->offset)));\n+\t\t    gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t  GEN_INT (param_ptr_offset)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n       if (!call_used_regs[REGNO (crtl->drap_reg)])\n-\tix86_emit_restore_reg_using_pop (crtl->drap_reg, -UNITS_PER_WORD);\n+\tix86_emit_restore_reg_using_pop (crtl->drap_reg);\n     }\n \n   /* Remove the saved static chain from the stack.  The use of ECX is\n@@ -10042,8 +10178,9 @@ ix86_expand_epilogue (int style)\n     {\n       rtx r, insn;\n \n-      gcc_assert (ix86_cfa_state->reg == stack_pointer_rtx);\n-      ix86_cfa_state->offset += UNITS_PER_WORD;\n+      gcc_assert (m->fs.cfa_reg == stack_pointer_rtx);\n+      m->fs.cfa_offset -= UNITS_PER_WORD;\n+      m->fs.sp_offset -= UNITS_PER_WORD;\n \n       r = gen_rtx_REG (Pmode, CX_REG);\n       insn = emit_insn (ix86_gen_pop1 (r));\n@@ -10054,10 +10191,16 @@ ix86_expand_epilogue (int style)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n+  /* At this point we should have de-allocated the entire stack frame,\n+     so the stack pointer points to the return address.  */\n+  gcc_assert (m->fs.sp_offset == UNITS_PER_WORD);\n+  gcc_assert (m->fs.sp_valid);\n+  gcc_assert (!m->fs.fp_valid);\n+\n   /* Sibcall epilogues don't want a return instruction.  */\n   if (style == 0)\n     {\n-      *ix86_cfa_state = cfa_state_save;\n+      m->fs = frame_state_save;\n       return;\n     }\n \n@@ -10077,7 +10220,8 @@ ix86_expand_epilogue (int style)\n \t  gcc_assert (!TARGET_64BIT);\n \n \t  insn = emit_insn (gen_popsi1 (ecx));\n-\t  ix86_cfa_state->offset -= UNITS_PER_WORD;\n+\t  m->fs.cfa_offset -= UNITS_PER_WORD;\n+\t  m->fs.sp_offset -= UNITS_PER_WORD;\n \n \t  add_reg_note (insn, REG_CFA_ADJUST_CFA,\n \t\t\tcopy_rtx (XVECEXP (PATTERN (insn), 0, 1)));\n@@ -10097,7 +10241,7 @@ ix86_expand_epilogue (int style)\n \n   /* Restore the state back to the state from the prologue,\n      so that it's correct for the next epilogue.  */\n-  *ix86_cfa_state = cfa_state_save;\n+  m->fs = frame_state_save;\n }\n \n /* Reset from the function's potential modifications.  */"}, {"sha": "300f22e58c7530823aa6ac36b4c01f984d9cad07", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec7ded37e7550ed1e9f133b959fe92ff6fdf791d/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec7ded37e7550ed1e9f133b959fe92ff6fdf791d/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=ec7ded37e7550ed1e9f133b959fe92ff6fdf791d", "patch": "@@ -2292,13 +2292,37 @@ enum ix86_stack_slot\n \f\n #define FASTCALL_PREFIX '@'\n \f\n-/* Machine specific CFA tracking during prologue/epilogue generation.  */\n+/* Machine specific frame tracking during prologue/epilogue generation.  */\n \n #ifndef USED_FOR_TARGET\n-struct GTY(()) machine_cfa_state\n+struct GTY(()) machine_frame_state\n {\n-  rtx reg;\n-  HOST_WIDE_INT offset;\n+  /* This pair tracks the currently active CFA as reg+offset.  When reg\n+     is drap_reg, we don't bother trying to record here the real CFA when\n+     it might really be a DW_CFA_def_cfa_expression.  */\n+  rtx cfa_reg;\n+  HOST_WIDE_INT cfa_offset;\n+\n+  /* The current offset (canonically from the CFA) of ESP and EBP.\n+     When stack frame re-alignment is active, these may not be relative\n+     to the CFA.  However, in all cases they are relative to the offsets\n+     of the saved registers stored in ix86_frame.  */\n+  HOST_WIDE_INT sp_offset;\n+  HOST_WIDE_INT fp_offset;\n+\n+  /* The size of the red-zone that may be assumed for the purposes of\n+     eliding register restore notes in the epilogue.  This may be zero\n+     if no red-zone is in effect, or may be reduced from the real\n+     red-zone value by a maximum runtime stack re-alignment value.  */\n+  int red_zone_offset;\n+\n+  /* Indicate whether each of ESP, EBP or DRAP currently holds a valid\n+     value within the frame.  If false then the offset above should be\n+     ignored.  Note that DRAP, if valid, *always* points to the CFA and\n+     thus has an offset of zero.  */\n+  BOOL_BITFIELD sp_valid : 1;\n+  BOOL_BITFIELD fp_valid : 1;\n+  BOOL_BITFIELD drap_valid : 1;\n };\n \n struct GTY(()) machine_function {\n@@ -2341,8 +2365,9 @@ struct GTY(()) machine_function {\n      stack below the return address.  */\n   BOOL_BITFIELD static_chain_on_stack : 1;\n \n-  /* The CFA state at the end of the prologue.  */\n-  struct machine_cfa_state cfa;\n+  /* During prologue/epilogue generation, the current frame state.\n+     Otherwise, the frame state at the end of the prologue.  */\n+  struct machine_frame_state fs;\n };\n #endif\n \n@@ -2360,7 +2385,6 @@ struct GTY(()) machine_function {\n    REG_SP is live.  */\n #define ix86_current_function_calls_tls_descriptor \\\n   (ix86_tls_descriptor_calls_expanded_in_cfun && df_regs_ever_live_p (SP_REG))\n-#define ix86_cfa_state (&cfun->machine->cfa)\n #define ix86_static_chain_on_stack (cfun->machine->static_chain_on_stack)\n \n /* Control behavior of x86_file_start.  */"}]}