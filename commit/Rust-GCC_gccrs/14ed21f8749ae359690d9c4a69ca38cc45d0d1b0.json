{"sha": "14ed21f8749ae359690d9c4a69ca38cc45d0d1b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRlZDIxZjg3NDlhZTM1OTY5MGQ5YzRhNjljYTM4Y2M0NWQwZDFiMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-05-05T01:33:36Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-05-07T16:07:04Z"}, "message": "c++: don't call 'rvalue' in coroutines code\n\nA change to check glvalue_p rather than specifically for TARGET_EXPR\nrevealed issues with the coroutines code's use of the 'rvalue' function,\nwhich shouldn't be used on class glvalues, so I've removed those calls.\n\nIn build_co_await I just dropped them, because I don't see anything in the\nco_await specification that indicates that we would want to move from an\nlvalue result of operator co_await.  And simplified that code while I was\ntouching it; cp_build_modify_expr (...INIT_EXPR...) will call the\nconstructor.\n\nIn morph_fn_to_coro I changed the handling of the rvalue reference coroutine\nframe field to use move, to treat the rval ref as an xvalue.  I used\nforward_parm to pass the function parms to the constructor for the field.\nAnd I simplified the return handling so we get the desired rvalue semantics\nfrom the normal implicit move on return.\n\nI question default-initializing the non-void return value of the function if\nget_return_object returns void; I'm not messing with it here, but I've filed\nPR100476 about it.\n\ngcc/cp/ChangeLog:\n\n\t* coroutines.cc (build_co_await): Don't call 'rvalue'.\n\t(flatten_await_stmt): Simplify initialization.\n\t(morph_fn_to_coro): Change 'rvalue' to 'move'.  Simplify.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/coroutines/coro-bad-gro-00-class-gro-scalar-return.C:\n\tAdjust diagnostic.", "tree": {"sha": "e2f4bfe98c12d38717b5d1a4a9e500695f425e64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2f4bfe98c12d38717b5d1a4a9e500695f425e64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14ed21f8749ae359690d9c4a69ca38cc45d0d1b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14ed21f8749ae359690d9c4a69ca38cc45d0d1b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14ed21f8749ae359690d9c4a69ca38cc45d0d1b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14ed21f8749ae359690d9c4a69ca38cc45d0d1b0/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "601191b2a48cb8f4657bb2fa2270a7fde9d52e9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/601191b2a48cb8f4657bb2fa2270a7fde9d52e9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/601191b2a48cb8f4657bb2fa2270a7fde9d52e9c"}], "stats": {"total": 119, "additions": 31, "deletions": 88}, "files": [{"sha": "71662061f5a9f6b70408106dc2301cb58bf63d50", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 30, "deletions": 87, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14ed21f8749ae359690d9c4a69ca38cc45d0d1b0/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14ed21f8749ae359690d9c4a69ca38cc45d0d1b0/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=14ed21f8749ae359690d9c4a69ca38cc45d0d1b0", "patch": "@@ -950,18 +950,11 @@ build_co_await (location_t loc, tree a, suspend_point_kind suspend_kind)\n       e_proxy = o;\n       o = NULL_TREE; /* The var is already present.  */\n     }\n-  else if (type_build_ctor_call (o_type))\n-    {\n-      e_proxy = get_awaitable_var (suspend_kind, o_type);\n-      releasing_vec arg (make_tree_vector_single (rvalue (o)));\n-      o = build_special_member_call (e_proxy, complete_ctor_identifier,\n-\t\t\t\t     &arg, o_type, LOOKUP_NORMAL,\n-\t\t\t\t     tf_warning_or_error);\n-    }\n   else\n     {\n       e_proxy = get_awaitable_var (suspend_kind, o_type);\n-      o = build2 (INIT_EXPR, o_type, e_proxy, rvalue (o));\n+      o = cp_build_modify_expr (loc, e_proxy, INIT_EXPR, o,\n+\t\t\t\ttf_warning_or_error);\n     }\n \n   /* I suppose we could check that this is contextually convertible to bool.  */\n@@ -2989,15 +2982,8 @@ flatten_await_stmt (var_nest_node *n, hash_set<tree> *promoted,\n \t  gcc_checking_assert (!already_present);\n \t  tree inner = TREE_OPERAND (init, 1);\n \t  gcc_checking_assert (TREE_CODE (inner) != COND_EXPR);\n-\t  if (type_build_ctor_call (var_type))\n-\t    {\n-\t      releasing_vec p_in (make_tree_vector_single (init));\n-\t      init = build_special_member_call (var, complete_ctor_identifier,\n-\t\t\t\t\t\t&p_in, var_type, LOOKUP_NORMAL,\n-\t\t\t\t\t\ttf_warning_or_error);\n-\t    }\n-\t  else\n-\t    init = build2 (INIT_EXPR, var_type, var, init);\n+\t  init = cp_build_modify_expr (input_location, var, INIT_EXPR, init,\n+\t\t\t\t       tf_warning_or_error);\n \t  /* Simplify for the case that we have an init containing the temp\n \t     alone.  */\n \t  if (t == n->init && n->var == NULL_TREE)\n@@ -4862,43 +4848,19 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t      vec_safe_push (promise_args, this_ref);\n \t    }\n \t  else if (parm.rv_ref)\n-\t    vec_safe_push (promise_args, rvalue(fld_idx));\n+\t    vec_safe_push (promise_args, move (fld_idx));\n \t  else\n \t    vec_safe_push (promise_args, fld_idx);\n \n \t  if (parm.rv_ref || parm.pt_ref)\n \t    /* Initialise the frame reference field directly.  */\n-\t    r = build_modify_expr (fn_start, TREE_OPERAND (fld_idx, 0),\n-\t\t\t\t   parm.frame_type, INIT_EXPR,\n-\t\t\t\t   DECL_SOURCE_LOCATION (arg), arg,\n-\t\t\t\t   DECL_ARG_TYPE (arg));\n-\t  else if (type_build_ctor_call (parm.frame_type))\n-\t    {\n-\t      vec<tree, va_gc> *p_in;\n-\t      if (CLASS_TYPE_P (parm.frame_type)\n-\t\t  && classtype_has_non_deleted_move_ctor (parm.frame_type))\n-\t\tp_in = make_tree_vector_single (move (arg));\n-\t      else if (lvalue_p (arg))\n-\t\tp_in = make_tree_vector_single (rvalue (arg));\n-\t      else\n-\t\tp_in = make_tree_vector_single (arg);\n-\t      /* Construct in place or move as relevant.  */\n-\t      r = build_special_member_call (fld_idx, complete_ctor_identifier,\n-\t\t\t\t\t     &p_in, parm.frame_type,\n-\t\t\t\t\t     LOOKUP_NORMAL,\n-\t\t\t\t\t     tf_warning_or_error);\n-\t      release_tree_vector (p_in);\n-\t    }\n+\t    r = cp_build_modify_expr (fn_start, TREE_OPERAND (fld_idx, 0),\n+\t\t\t\t      INIT_EXPR, arg, tf_warning_or_error);\n \t  else\n \t    {\n-\t      if (!same_type_p (parm.frame_type, DECL_ARG_TYPE (arg)))\n-\t\tr = build1_loc (DECL_SOURCE_LOCATION (arg), CONVERT_EXPR,\n-\t\t\t\tparm.frame_type, arg);\n-\t      else\n-\t\tr = arg;\n-\t      r = build_modify_expr (fn_start, fld_idx, parm.frame_type,\n-\t\t\t\t     INIT_EXPR, DECL_SOURCE_LOCATION (arg), r,\n-\t\t\t\t     TREE_TYPE (r));\n+\t      r = forward_parm (arg);\n+\t      r = cp_build_modify_expr (fn_start, fld_idx, INIT_EXPR, r,\n+\t\t\t\t\ttf_warning_or_error);\n \t    }\n \t  finish_expr_stmt (r);\n \t  if (!parm.trivial_dtor)\n@@ -5044,16 +5006,8 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       DECL_IGNORED_P (gro) = true;\n       add_decl_expr (gro);\n       gro_bind_vars = gro;\n-      if (type_build_ctor_call (gro_type))\n-\t{\n-\t  vec<tree, va_gc> *arg = make_tree_vector_single (get_ro);\n-\t  r = build_special_member_call (gro, complete_ctor_identifier,\n-\t\t\t\t\t &arg, gro_type, LOOKUP_NORMAL,\n-\t\t\t\t\t tf_warning_or_error);\n-\t  release_tree_vector (arg);\n-\t}\n-      else\n-\tr = build2_loc (fn_start, INIT_EXPR, gro_type, gro, get_ro);\n+      r = cp_build_modify_expr (input_location, gro, INIT_EXPR, get_ro,\n+\t\t\t\ttf_warning_or_error);\n       /* The constructed object might require a cleanup.  */\n       if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (gro_type))\n \t{\n@@ -5111,37 +5065,26 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   if (same_type_p (gro_type, fn_return_type))\n     r = gro_is_void_p ? NULL_TREE : DECL_RESULT (orig);\n+  else if (!gro_is_void_p)\n+    /* check_return_expr will automatically return gro as an rvalue via\n+       treat_lvalue_as_rvalue_p.  */\n+    r = gro;\n+  else if (CLASS_TYPE_P (fn_return_type))\n+    {\n+      /* For class type return objects, we can attempt to construct,\n+\t even if the gro is void. ??? Citation ??? c++/100476  */\n+      r = build_special_member_call (NULL_TREE,\n+\t\t\t\t     complete_ctor_identifier, NULL,\n+\t\t\t\t     fn_return_type, LOOKUP_NORMAL,\n+\t\t\t\t     tf_warning_or_error);\n+      r = build_cplus_new (fn_return_type, r, tf_warning_or_error);\n+    }\n   else\n     {\n-      if (CLASS_TYPE_P (fn_return_type))\n-\t{\n-\t  /* For class type return objects, we can attempt to construct,\n-\t     even if the gro is void.  */\n-\t  vec<tree, va_gc> *args = NULL;\n-\t  vec<tree, va_gc> **arglist = NULL;\n-\t  if (!gro_is_void_p)\n-\t    {\n-\t      args = make_tree_vector_single (rvalue (gro));\n-\t      arglist = &args;\n-\t    }\n-\t  r = build_special_member_call (NULL_TREE,\n-\t\t\t\t\t complete_ctor_identifier, arglist,\n-\t\t\t\t\t fn_return_type, LOOKUP_NORMAL,\n-\t\t\t\t\t tf_warning_or_error);\n-\t  r = build_cplus_new (fn_return_type, r, tf_warning_or_error);\n-\t  if (args)\n-\t    release_tree_vector (args);\n-\t}\n-      else if (gro_is_void_p)\n-\t{\n-\t  /* We can't initialize a non-class return value from void.  */\n-\t  error_at (input_location, \"cannot initialize a return object of type\"\n-\t\t    \" %qT with an rvalue of type %<void%>\", fn_return_type);\n-\t  r = error_mark_node;\n-\t}\n-      else\n-\tr = build1_loc (input_location, CONVERT_EXPR,\n-\t\t\tfn_return_type, rvalue (gro));\n+      /* We can't initialize a non-class return value from void.  */\n+      error_at (input_location, \"cannot initialize a return object of type\"\n+\t\t\" %qT with an rvalue of type %<void%>\", fn_return_type);\n+      r = error_mark_node;\n     }\n \n   finish_return_stmt (r);"}, {"sha": "0512f03f4d0a3660838ea3d825a872b2e25619a8", "filename": "gcc/testsuite/g++.dg/coroutines/coro-bad-gro-00-class-gro-scalar-return.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14ed21f8749ae359690d9c4a69ca38cc45d0d1b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-gro-00-class-gro-scalar-return.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14ed21f8749ae359690d9c4a69ca38cc45d0d1b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-gro-00-class-gro-scalar-return.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-gro-00-class-gro-scalar-return.C?ref=14ed21f8749ae359690d9c4a69ca38cc45d0d1b0", "patch": "@@ -37,7 +37,7 @@ my_coro (std::coroutine_handle<>& h)\n {\n   PRINT (\"coro1: about to return\");\n   co_return;\n-} // { dg-error {'struct Thing' used where a 'int' was expected} }\n+} // { dg-error {cannot convert 'Thing' to 'int' in return} }\n \n int main ()\n {"}]}