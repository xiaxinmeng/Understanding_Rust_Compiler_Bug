{"sha": "cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QzY2U5YjQ0YzFjM2I0ZjQ1NjdkZTBkMjc2N2RmMDU4Yjg5Y2U1OA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2004-06-09T15:32:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-06-09T15:32:44Z"}, "message": "Gimplify VA_ARG_EXPR into simpler forms.\n\n        * target.h: Add gimplify_va_arg_expr hook.\n        * target-def.h: Add TARGET_GIMPLIFY_VA_ARG_EXPR.\n        * fold-const.c (build_fold_addr_expr)\n        (build_fold_addr_expr_with_type): Move from gimplify.c.\n        * tree.h: Declare them.\n        * gimplify.c (gimplify_and_add): New fn.\n        (build_addr_expr, build_addr_expr_with_type): Move to fold-const.c.\n        (gimplify_array_ref_to_plus, gimplify_modify_expr)\n        (gimplify_expr): Use build_fold_*.\n        (copy_if_shared_r): Only mark VA_ARG_EXPR volatile if we\n        don't know how to gimplify it.\n        * builtins.c (std_gimplify_va_arg_expr): New fn.\n        (dummy_object): New static fn.\n        (gimplify_va_arg_expr): New fn.\n        (stabilize_va_list): Use build_fold_*.\n        * tree-gimple.h: Declare new fns.\n        * config/i386/i386.c (TARGET_GIMPLIFY_VA_ARG_EXPR): Define.\n        (ix86_gimplify_va_arg): New fn.\n        * config/i386/ia64.c (TARGET_GIMPLIFY_VA_ARG_EXPR): Define.\n        (ia64_gimplify_va_arg): New fn.\n        * config/i386/rs6000.c (rs6000_gimplify_va_arg): New fn.\n        (TARGET_GIMPLIFY_VA_ARG_EXPR): Define.\n        * config/i386/sparc.c (sparc_gimplify_va_arg): New fn.\n        * alias.c (get_varargs_alias_set): Just return 0 for now.\n\n        * c-objc-common.c (c_tree_printer): Improve handling of %T.\n\nFrom-SVN: r82838", "tree": {"sha": "a63536f7f79b61493abe2609fb704c1c740bcd7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a63536f7f79b61493abe2609fb704c1c740bcd7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e072ae27e0898a7244b08d003a43b4cecf146df0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e072ae27e0898a7244b08d003a43b4cecf146df0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e072ae27e0898a7244b08d003a43b4cecf146df0"}], "stats": {"total": 929, "additions": 869, "deletions": 60}, "files": [{"sha": "1793e5c590e9ec10336f76a0f68f3dada3cf121f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -1,3 +1,33 @@\n+2004-06-08  Jason Merrill  <jason@redhat.com>\n+\n+\tGimplify VA_ARG_EXPR into simpler forms.\n+\t* target.h: Add gimplify_va_arg_expr hook.\n+\t* target-def.h: Add TARGET_GIMPLIFY_VA_ARG_EXPR.\n+\t* fold-const.c (build_fold_addr_expr)\n+\t(build_fold_addr_expr_with_type): Move from gimplify.c.\n+\t* tree.h: Declare them.\n+\t* gimplify.c (gimplify_and_add): New fn.\n+\t(build_addr_expr, build_addr_expr_with_type): Move to fold-const.c.\n+\t(gimplify_array_ref_to_plus, gimplify_modify_expr)\n+\t(gimplify_expr): Use build_fold_*.\n+\t(copy_if_shared_r): Only mark VA_ARG_EXPR volatile if we\n+\tdon't know how to gimplify it.\n+\t* builtins.c (std_gimplify_va_arg_expr): New fn.\n+\t(dummy_object): New static fn.\n+\t(gimplify_va_arg_expr): New fn.\n+\t(stabilize_va_list): Use build_fold_*.\n+\t* tree-gimple.h: Declare new fns.\n+\t* config/i386/i386.c (TARGET_GIMPLIFY_VA_ARG_EXPR): Define.\n+\t(ix86_gimplify_va_arg): New fn.\n+\t* config/i386/ia64.c (TARGET_GIMPLIFY_VA_ARG_EXPR): Define.\n+\t(ia64_gimplify_va_arg): New fn.\n+\t* config/i386/rs6000.c (rs6000_gimplify_va_arg): New fn.\n+\t(TARGET_GIMPLIFY_VA_ARG_EXPR): Define.\n+\t* config/i386/sparc.c (sparc_gimplify_va_arg): New fn.\n+\t* alias.c (get_varargs_alias_set): Just return 0 for now.\n+\t\n+\t* c-objc-common.c (c_tree_printer): Improve handling of %T.\n+\n 2004-06-09  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* tree-complex.c (expand_complex_comparison): Use fold_convert instead"}, {"sha": "3e2bbbbad5d913029322c166ef21977eb4425da8", "filename": "gcc/alias.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -737,10 +737,18 @@ static GTY(()) HOST_WIDE_INT varargs_set = -1;\n HOST_WIDE_INT\n get_varargs_alias_set (void)\n {\n+#if 1\n+  /* We now lower VA_ARG_EXPR, and there's currently no way to attach the\n+     varargs alias set to an INDIRECT_REF (FIXME!), so we can't\n+     consistently use the varargs alias set for loads from the varargs\n+     area.  So don't use it anywhere.  */\n+  return 0;\n+#else\n   if (varargs_set == -1)\n     varargs_set = new_alias_set ();\n \n   return varargs_set;\n+#endif\n }\n \n /* Likewise, but used for the fixed portions of the frame, e.g., register"}, {"sha": "9816af0817c57c035ab242a7a4799ca3c906e9b1", "filename": "gcc/builtins.c", "status": "modified", "additions": 180, "deletions": 6, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -4106,10 +4106,7 @@ stabilize_va_list (tree valist, int needs_lvalue)\n       if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n \t{\n \t  tree p1 = build_pointer_type (TREE_TYPE (va_list_type_node));\n-\t  tree p2 = build_pointer_type (va_list_type_node);\n-\n-\t  valist = build1 (ADDR_EXPR, p2, valist);\n-\t  valist = fold_convert (p1, valist);\n+\t  valist = build_fold_addr_expr_with_type (valist, p1);\n \t}\n     }\n   else\n@@ -4128,8 +4125,7 @@ stabilize_va_list (tree valist, int needs_lvalue)\n \n       if (TREE_SIDE_EFFECTS (valist))\n \tvalist = save_expr (valist);\n-      valist = fold (build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)),\n-\t\t\t     valist));\n+      valist = build_fold_indirect_ref (valist);\n     }\n \n   return valist;\n@@ -4364,6 +4360,184 @@ expand_builtin_va_arg (tree valist, tree type)\n   return result;\n }\n \n+/* Like std_expand_builtin_va_arg, but gimplify instead of expanding.  */\n+\n+void\n+std_gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n+{\n+  tree addr, t, type_size = NULL;\n+  tree align, alignm1;\n+  tree rounded_size;\n+  HOST_WIDE_INT boundary;\n+  tree valist = TREE_OPERAND (*expr_p, 0);\n+  tree type = TREE_TYPE (*expr_p);\n+\n+  /* Compute the rounded size of the type.  */\n+  align = size_int (PARM_BOUNDARY / BITS_PER_UNIT);\n+  alignm1 = size_int (PARM_BOUNDARY / BITS_PER_UNIT - 1);\n+  boundary = FUNCTION_ARG_BOUNDARY (TYPE_MODE (type), type);\n+\n+  /* Reduce valist it so it's sharable with the postqueue.  */\n+  gimplify_expr (&valist, pre_p, post_p, is_gimple_min_lval, fb_lvalue);\n+\n+  /* va_list pointer is aligned to PARM_BOUNDARY.  If argument actually\n+     requires greater alignment, we must perform dynamic alignment.  */\n+\n+  if (boundary > PARM_BOUNDARY)\n+    {\n+      if (!PAD_VARARGS_DOWN)\n+\t{\n+\t  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+\t\t      build2 (PLUS_EXPR, TREE_TYPE (valist), valist,\n+\t\t\t      build_int_2 (boundary / BITS_PER_UNIT - 1, 0)));\n+\t  gimplify_stmt (&t);\n+\t  append_to_statement_list (t, pre_p);\n+\t}\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+\t\t  build2 (BIT_AND_EXPR, TREE_TYPE (valist), valist,\n+\t\t\t  build_int_2 (~(boundary / BITS_PER_UNIT - 1), -1)));\n+      gimplify_stmt (&t);\n+      append_to_statement_list (t, pre_p);\n+    }\n+  if (type == error_mark_node\n+      || (type_size = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (type))) == NULL\n+      || TREE_OVERFLOW (type_size))\n+    rounded_size = size_zero_node;\n+  else\n+    {\n+      rounded_size = fold (build2 (PLUS_EXPR, sizetype, type_size, alignm1));\n+      rounded_size = fold (build2 (TRUNC_DIV_EXPR, sizetype,\n+\t\t\t\t   rounded_size, align));\n+      rounded_size = fold (build2 (MULT_EXPR, sizetype,\n+\t\t\t\t   rounded_size, align));\n+    }\n+\n+  /* Reduce rounded_size so it's sharable with the postqueue.  */\n+  gimplify_expr (&rounded_size, pre_p, post_p, is_gimple_val, fb_rvalue);\n+\n+  /* Get AP.  */\n+  addr = valist;\n+  if (PAD_VARARGS_DOWN && ! integer_zerop (rounded_size))\n+    {\n+      /* Small args are padded downward.  */\n+      addr = fold (build2 (PLUS_EXPR, TREE_TYPE (addr), addr,\n+\t\t\t\tfold (build3 (COND_EXPR, sizetype,\n+\t\t\t\t\t      fold (build2 (GT_EXPR, sizetype,\n+\t\t\t\t\t\t\t    rounded_size,\n+\t\t\t\t\t\t\t    align)),\n+\t\t\t\t\t      size_zero_node,\n+\t\t\t\t\t      fold (build2 (MINUS_EXPR,\n+\t\t\t\t\t\t\t    sizetype,\n+\t\t\t\t\t\t\t    rounded_size,\n+\t\t\t\t\t\t\t    type_size))))));\n+    }\n+\n+  addr = convert (build_pointer_type (type), addr);\n+  *expr_p = build1 (INDIRECT_REF, type, addr);\n+\n+  /* Compute new value for AP.  */\n+  if (! integer_zerop (rounded_size))\n+    {\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+\t\t  build2 (PLUS_EXPR, TREE_TYPE (valist), valist,\n+\t\t\t  rounded_size));\n+      gimplify_stmt (&t);\n+      append_to_statement_list (t, post_p);\n+    }\n+}\n+\n+/* Return a dummy expression of type TYPE in order to keep going after an\n+   error.  */\n+\n+static tree\n+dummy_object (tree type)\n+{\n+  tree t = convert (build_pointer_type (type), null_pointer_node);\n+  return build1 (INDIRECT_REF, type, t);\n+}\n+\n+/* Like expand_builtin_va_arg, but gimplify instead of expanding.  */\n+\n+enum gimplify_status\n+gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n+{\n+  tree promoted_type, want_va_type, have_va_type;\n+  tree valist = TREE_OPERAND (*expr_p, 0);\n+  tree type = TREE_TYPE (*expr_p);\n+  tree t;\n+\n+  /* Verify that valist is of the proper type.  */\n+\n+  want_va_type = va_list_type_node;\n+  have_va_type = TREE_TYPE (valist);\n+  if (TREE_CODE (want_va_type) == ARRAY_TYPE)\n+    {\n+      /* If va_list is an array type, the argument may have decayed\n+\t to a pointer type, e.g. by being passed to another function.\n+         In that case, unwrap both types so that we can compare the\n+\t underlying records.  */\n+      if (TREE_CODE (have_va_type) == ARRAY_TYPE\n+\t  || TREE_CODE (have_va_type) == POINTER_TYPE)\n+\t{\n+\t  want_va_type = TREE_TYPE (want_va_type);\n+\t  have_va_type = TREE_TYPE (have_va_type);\n+\t}\n+    }\n+\n+  if (TYPE_MAIN_VARIANT (want_va_type) != TYPE_MAIN_VARIANT (have_va_type))\n+    {\n+      error (\"first argument to `va_arg' not of type `va_list'\");\n+      *expr_p = dummy_object (type);\n+      return GS_ALL_DONE;\n+    }\n+\n+  /* Generate a diagnostic for requesting data of a type that cannot\n+     be passed through `...' due to type promotion at the call site.  */\n+  else if ((promoted_type = lang_hooks.types.type_promotes_to (type))\n+\t   != type)\n+    {\n+      static bool gave_help;\n+\n+      /* Unfortunately, this is merely undefined, rather than a constraint\n+\t violation, so we cannot make this an error.  If this call is never\n+\t executed, the program is still strictly conforming.  */\n+      warning (\"`%T' is promoted to `%T' when passed through `...'\",\n+\t       type, promoted_type);\n+      if (! gave_help)\n+\t{\n+\t  gave_help = true;\n+\t  warning (\"(so you should pass `%T' not `%T' to `va_arg')\",\n+\t\t   promoted_type, type);\n+\t}\n+\n+      /* We can, however, treat \"undefined\" any way we please.\n+\t Call abort to encourage the user to fix the program.  */\n+      inform (\"if this code is reached, the program will abort\");\n+      t = build_function_call_expr (implicit_built_in_decls[BUILT_IN_TRAP],\n+\t\t\t\t    NULL);\n+      append_to_statement_list (t, pre_p);\n+\n+      /* This is dead code, but go ahead and finish so that the\n+\t mode of the result comes out right.  */\n+      *expr_p = dummy_object (type);\n+      return GS_ALL_DONE;\n+    }\n+  else\n+    {\n+      /* Make it easier for the backends by protecting the valist argument\n+         from multiple evaluations.  */\n+      valist = stabilize_va_list (valist, 0);\n+      TREE_OPERAND (*expr_p, 0) = valist;\n+\n+      if (!targetm.calls.gimplify_va_arg_expr)\n+\t/* Once most targets are converted this should abort.  */\n+\treturn GS_ALL_DONE;\n+\n+      targetm.calls.gimplify_va_arg_expr (expr_p, pre_p, post_p);\n+      return GS_OK;\n+    }\n+}\n+\n /* Expand ARGLIST, from a call to __builtin_va_end.  */\n \n static rtx"}, {"sha": "f32bf6d8fe0f9ceda6a9ef7e20a6052032ef200f", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -270,17 +270,15 @@ c_tree_printer (pretty_printer *pp, text_info *text)\n       break;\n \n     case 'T':\n-      if (TREE_CODE (t) == TYPE_DECL)\n+      if (TYPE_P (t))\n+\tt = TYPE_NAME (t);\n+      if (t && TREE_CODE (t) == TYPE_DECL)\n \t{\n \t  if (DECL_NAME (t))\n \t    n = lang_hooks.decl_printable_name (t, 2);\n \t}\n-      else\n-\t{\n-\t  t = TYPE_NAME (t);\n-\t  if (t)\n-\t    n = IDENTIFIER_POINTER (t);\n-\t}\n+      else if (t)\n+\tn = IDENTIFIER_POINTER (t);\n       break;\n \n     case 'E':"}, {"sha": "6e2463b727e6cfc28a48e60703cdfd3eec50229c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -46,6 +46,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"target-def.h\"\n #include \"langhooks.h\"\n #include \"cgraph.h\"\n+#include \"tree-gimple.h\"\n \n #ifndef CHECK_STACK_LIMIT\n #define CHECK_STACK_LIMIT (-1)\n@@ -877,6 +878,7 @@ static bool ix86_expand_carry_flag_compare (enum rtx_code, rtx, rtx, rtx*);\n static tree ix86_build_builtin_va_list (void);\n static void ix86_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n+static void ix86_gimplify_va_arg (tree *expr_p, tree *pre_p, tree *post_p);\n \n struct ix86_address\n {\n@@ -1069,6 +1071,9 @@ static void init_ext_80387_constants (void);\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS ix86_setup_incoming_varargs\n \n+#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR ix86_gimplify_va_arg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f\n@@ -3410,6 +3415,258 @@ ix86_va_arg (tree valist, tree type)\n \n   return addr_rtx;\n }\n+\n+/* Lower VA_ARG_EXPR at gimplification time.  */\n+\n+void\n+ix86_gimplify_va_arg (tree *expr_p, tree *pre_p, tree *post_p)\n+{\n+  tree valist = TREE_OPERAND (*expr_p, 0);\n+  tree type = TREE_TYPE (*expr_p);\n+  static const int intreg[6] = { 0, 1, 2, 3, 4, 5 };\n+  tree f_gpr, f_fpr, f_ovf, f_sav;\n+  tree gpr, fpr, ovf, sav, t;\n+  int size, rsize;\n+  tree lab_false, lab_over = NULL_TREE;\n+  tree addr, t2;\n+  rtx container;\n+  int indirect_p = 0;\n+  tree ptrtype;\n+\n+  /* Only 64bit target needs something special.  */\n+  if (!TARGET_64BIT)\n+    {\n+      std_gimplify_va_arg_expr (expr_p, pre_p, post_p);\n+      return;\n+    }\n+\n+  f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n+  f_fpr = TREE_CHAIN (f_gpr);\n+  f_ovf = TREE_CHAIN (f_fpr);\n+  f_sav = TREE_CHAIN (f_ovf);\n+\n+  valist = build_fold_indirect_ref (valist);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+\n+  size = int_size_in_bytes (type);\n+  if (size == -1)\n+    {\n+      /* Variable-size types are passed by reference.  */\n+      indirect_p = 1;\n+      type = build_pointer_type (type);\n+      size = int_size_in_bytes (type);\n+    }\n+  rsize = (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  container = construct_container (TYPE_MODE (type), type, 0,\n+\t\t\t\t   REGPARM_MAX, SSE_REGPARM_MAX, intreg, 0);\n+  /*\n+   * Pull the value out of the saved registers ...\n+   */\n+\n+  addr = create_tmp_var (ptr_type_node, \"addr\");\n+  DECL_POINTER_ALIAS_SET (addr) = get_varargs_alias_set ();\n+\n+  if (container)\n+    {\n+      int needed_intregs, needed_sseregs;\n+      int need_temp;\n+      tree int_addr, sse_addr;\n+\n+      lab_false = create_artificial_label ();\n+      lab_over = create_artificial_label ();\n+\n+      examine_argument (TYPE_MODE (type), type, 0,\n+\t\t        &needed_intregs, &needed_sseregs);\n+\n+\n+      need_temp = ((needed_intregs && TYPE_ALIGN (type) > 64)\n+\t\t   || TYPE_ALIGN (type) > 128);\n+\n+      /* In case we are passing structure, verify that it is consecutive block\n+         on the register save area.  If not we need to do moves.  */\n+      if (!need_temp && !REG_P (container))\n+\t{\n+\t  /* Verify that all registers are strictly consecutive  */\n+\t  if (SSE_REGNO_P (REGNO (XEXP (XVECEXP (container, 0, 0), 0))))\n+\t    {\n+\t      int i;\n+\n+\t      for (i = 0; i < XVECLEN (container, 0) && !need_temp; i++)\n+\t\t{\n+\t\t  rtx slot = XVECEXP (container, 0, i);\n+\t\t  if (REGNO (XEXP (slot, 0)) != FIRST_SSE_REG + (unsigned int) i\n+\t\t      || INTVAL (XEXP (slot, 1)) != i * 16)\n+\t\t    need_temp = 1;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      int i;\n+\n+\t      for (i = 0; i < XVECLEN (container, 0) && !need_temp; i++)\n+\t\t{\n+\t\t  rtx slot = XVECEXP (container, 0, i);\n+\t\t  if (REGNO (XEXP (slot, 0)) != (unsigned int) i\n+\t\t      || INTVAL (XEXP (slot, 1)) != i * 8)\n+\t\t    need_temp = 1;\n+\t\t}\n+\t    }\n+\t}\n+      if (!need_temp)\n+\t{\n+\t  int_addr = addr;\n+\t  sse_addr = addr;\n+\t}\n+      else\n+\t{\n+\t  int_addr = create_tmp_var (ptr_type_node, \"int_addr\");\n+\t  DECL_POINTER_ALIAS_SET (int_addr) = get_varargs_alias_set ();\n+\t  sse_addr = create_tmp_var (ptr_type_node, \"sse_addr\");\n+\t  DECL_POINTER_ALIAS_SET (sse_addr) = get_varargs_alias_set ();\n+\t}\n+      /* First ensure that we fit completely in registers.  */\n+      if (needed_intregs)\n+\t{\n+\t  t = build_int_2 ((REGPARM_MAX - needed_intregs + 1) * 8, 0);\n+\t  TREE_TYPE (t) = TREE_TYPE (gpr);\n+\t  t = build2 (GE_EXPR, boolean_type_node, gpr, t);\n+\t  t2 = build1 (GOTO_EXPR, void_type_node, lab_false);\n+\t  t = build (COND_EXPR, void_type_node, t, t2, NULL_TREE);\n+\t  gimplify_and_add (t, pre_p);\n+\t}\n+      if (needed_sseregs)\n+\t{\n+\t  t = build_int_2 ((SSE_REGPARM_MAX - needed_sseregs + 1) * 16\n+\t\t\t   + REGPARM_MAX * 8, 0);\n+\t  TREE_TYPE (t) = TREE_TYPE (fpr);\n+\t  t = build2 (GE_EXPR, boolean_type_node, fpr, t);\n+\t  t2 = build1 (GOTO_EXPR, void_type_node, lab_false);\n+\t  t = build (COND_EXPR, void_type_node, t, t2, NULL_TREE);\n+\t  gimplify_and_add (t, pre_p);\n+\t}\n+\n+      /* Compute index to start of area used for integer regs.  */\n+      if (needed_intregs)\n+\t{\n+\t  /* int_addr = gpr + sav; */\n+\t  t = build2 (PLUS_EXPR, ptr_type_node, sav, gpr);\n+\t  t = build2 (MODIFY_EXPR, void_type_node, int_addr, t);\n+\t  gimplify_and_add (t, pre_p);\n+\t}\n+      if (needed_sseregs)\n+\t{\n+\t  /* sse_addr = fpr + sav; */\n+\t  t = build2 (PLUS_EXPR, ptr_type_node, sav, fpr);\n+\t  t = build2 (MODIFY_EXPR, void_type_node, sse_addr, t);\n+\t  gimplify_and_add (t, pre_p);\n+\t}\n+      if (need_temp)\n+\t{\n+\t  int i;\n+\t  tree temp = create_tmp_var (type, \"va_arg_tmp\");\n+\n+\t  /* addr = &temp; */\n+\t  t = build1 (ADDR_EXPR, build_pointer_type (type), temp);\n+\t  t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+\t  gimplify_and_add (t, pre_p);\n+\t  \n+\t  for (i = 0; i < XVECLEN (container, 0); i++)\n+\t    {\n+\t      rtx slot = XVECEXP (container, 0, i);\n+\t      rtx reg = XEXP (slot, 0);\n+\t      enum machine_mode mode = GET_MODE (reg);\n+\t      tree piece_type = lang_hooks.types.type_for_mode (mode, 1);\n+\t      tree addr_type = build_pointer_type (piece_type);\n+\t      tree src_addr, src;\n+\t      int src_offset;\n+\t      tree dest_addr, dest;\n+\n+\t      if (SSE_REGNO_P (REGNO (reg)))\n+\t\t{\n+\t\t  src_addr = sse_addr;\n+\t\t  src_offset = (REGNO (reg) - FIRST_SSE_REG) * 16;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  src_addr = int_addr;\n+\t\t  src_offset = REGNO (reg) * 8;\n+\t\t}\n+\t      src_addr = convert (addr_type, src_addr);\n+\t      src_addr = fold (build2 (PLUS_EXPR, addr_type, src_addr,\n+\t\t\t\t       size_int (src_offset)));\n+\t      src = build_fold_indirect_ref (src_addr);\n+\n+\t      dest_addr = convert (addr_type, addr);\n+\t      dest_addr = fold (build2 (PLUS_EXPR, addr_type, dest_addr,\n+\t\t\t\t\tsize_int (INTVAL (XEXP (slot, 1)))));\n+\t      dest = build_fold_indirect_ref (dest_addr);\n+\n+\t      t = build2 (MODIFY_EXPR, void_type_node, dest, src);\n+\t      gimplify_and_add (t, pre_p);\n+\t    }\n+\t}\n+\n+      if (needed_intregs)\n+\t{\n+\t  t = build2 (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n+\t\t      build_int_2 (needed_intregs * 8, 0));\n+\t  t = build2 (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n+\t  gimplify_and_add (t, pre_p);\n+\t}\n+      if (needed_sseregs)\n+\t{\n+\t  t =\n+\t    build2 (PLUS_EXPR, TREE_TYPE (fpr), fpr,\n+\t\t   build_int_2 (needed_sseregs * 16, 0));\n+\t  t = build2 (MODIFY_EXPR, TREE_TYPE (fpr), fpr, t);\n+\t  gimplify_and_add (t, pre_p);\n+\t}\n+\n+      t = build1 (GOTO_EXPR, void_type_node, lab_over);\n+      gimplify_and_add (t, pre_p);\n+\n+      t = build1 (LABEL_EXPR, void_type_node, lab_false);\n+      append_to_statement_list (t, pre_p);\n+    }\n+\n+  /* ... otherwise out of the overflow area.  */\n+\n+  /* Care for on-stack alignment if needed.  */\n+  if (FUNCTION_ARG_BOUNDARY (VOIDmode, type) <= 64)\n+    t = ovf;\n+  else\n+    {\n+      HOST_WIDE_INT align = FUNCTION_ARG_BOUNDARY (VOIDmode, type) / 8;\n+      t = build (PLUS_EXPR, TREE_TYPE (ovf), ovf, build_int_2 (align - 1, 0));\n+      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align, -1));\n+    }\n+  gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n+\n+  t2 = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+  gimplify_and_add (t2, pre_p);\n+\n+  t = build2 (PLUS_EXPR, TREE_TYPE (t), t,\n+\t      build_int_2 (rsize * UNITS_PER_WORD, 0));\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+  gimplify_and_add (t, pre_p);\n+\n+  if (container)\n+    {\n+      t = build1 (LABEL_EXPR, void_type_node, lab_over);\n+      append_to_statement_list (t, pre_p);\n+    }\n+\n+  ptrtype = build_pointer_type (type);\n+  addr = convert (ptrtype, addr);\n+\n+  if (indirect_p)\n+    addr = build_fold_indirect_ref (addr);\n+  *expr_p = build_fold_indirect_ref (addr);\n+}\n \f\n /* Return nonzero if OP is either a i387 or SSE fp register.  */\n int"}, {"sha": "14fdfe25a1c48a9830360d206a513044e601a46a", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -51,6 +51,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"hashtab.h\"\n #include \"langhooks.h\"\n #include \"cfglayout.h\"\n+#include \"tree-gimple.h\"\n \n /* This is used for communication between ASM_OUTPUT_LABEL and\n    ASM_OUTPUT_LABELREF.  */\n@@ -273,6 +274,7 @@ static void ia64_vms_init_libfuncs (void)\n static tree ia64_handle_model_attribute (tree *, tree, tree, int, bool *);\n static void ia64_encode_section_info (tree, rtx, int);\n static rtx ia64_struct_value_rtx (tree, int);\n+static void ia64_gimplify_va_arg (tree *, tree *, tree *);\n \n \f\n /* Table of valid machine attributes.  */\n@@ -407,6 +409,9 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_STRICT_ARGUMENT_NAMING\n #define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true\n \n+#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR ia64_gimplify_va_arg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n@@ -3987,6 +3992,39 @@ ia64_va_arg (tree valist, tree type)\n \n   return std_expand_builtin_va_arg (valist, type);\n }\n+\n+static void\n+ia64_gimplify_va_arg (tree *expr_p, tree *pre_p, tree *post_p)\n+{\n+  tree valist = TREE_OPERAND (*expr_p, 0);\n+  tree type = TREE_TYPE (*expr_p);\n+\n+  /* Variable sized types are passed by reference.  */\n+  if (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+    {\n+      TREE_TYPE (*expr_p) = build_pointer_type (type);\n+      std_gimplify_va_arg_expr (expr_p, pre_p, post_p);\n+      *expr_p = build_fold_indirect_ref (*expr_p);\n+      return;\n+    }\n+\n+  /* Aggregate arguments with alignment larger than 8 bytes start at\n+     the next even boundary.  Integer and floating point arguments\n+     do so if they are larger than 8 bytes, whether or not they are\n+     also aligned larger than 8 bytes.  */\n+  if ((TREE_CODE (type) == REAL_TYPE || TREE_CODE (type) == INTEGER_TYPE)\n+      ? int_size_in_bytes (type) > 8 : TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)\n+    {\n+      tree t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n+\t\t      build_int_2 (2 * UNITS_PER_WORD - 1, 0));\n+      t = build (BIT_AND_EXPR, TREE_TYPE (t), t,\n+\t\t build_int_2 (-2 * UNITS_PER_WORD, -1));\n+      t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n+      gimplify_and_add (t, pre_p);\n+    }\n+\n+  std_gimplify_va_arg_expr (expr_p, pre_p, post_p);\n+}\n \f\n /* Return 1 if function return value returned in memory.  Return 0 if it is\n    in a register.  */"}, {"sha": "d0bc91d40d6bcde5d651a115f2dab3f59a6934ce", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -52,6 +52,7 @@\n #include \"reload.h\"\n #include \"cfglayout.h\"\n #include \"sched-int.h\"\n+#include \"tree-gimple.h\"\n #if TARGET_XCOFF\n #include \"xcoffout.h\"  /* get declarations of xcoff_*_section_name */\n #endif\n@@ -439,6 +440,7 @@ static tree get_prev_label (tree function_name);\n #endif\n \n static tree rs6000_build_builtin_va_list (void);\n+static void rs6000_gimplify_va_arg (tree *, tree *, tree *);\n \n /* Hash table stuff for keeping track of TOC entries.  */\n \n@@ -647,6 +649,9 @@ static const char alt_reg_names[][8] =\n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST rs6000_build_builtin_va_list\n \n+#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR rs6000_gimplify_va_arg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -5287,6 +5292,243 @@ rs6000_va_arg (tree valist, tree type)\n   return addr_rtx;\n }\n \n+void\n+rs6000_gimplify_va_arg (tree *expr_p, tree *pre_p, tree *post_p)\n+{\n+  tree valist = TREE_OPERAND (*expr_p, 0);\n+  tree type = TREE_TYPE (*expr_p);\n+  tree f_gpr, f_fpr, f_res, f_ovf, f_sav;\n+  tree gpr, fpr, ovf, sav, reg, t, u;\n+  int indirect_p, size, rsize, n_reg, sav_ofs, sav_scale;\n+  tree lab_false, lab_over, addr;\n+  int align;\n+  tree ptrtype = build_pointer_type (type);\n+\n+  if (DEFAULT_ABI != ABI_V4)\n+    {\n+      /* Variable sized types are passed by reference, as are AltiVec\n+\t vectors when 32-bit and not using the AltiVec ABI extension.  */\n+      if (int_size_in_bytes (type) < 0\n+\t  || (TARGET_32BIT\n+\t      && !TARGET_ALTIVEC_ABI\n+\t      && ALTIVEC_VECTOR_MODE (TYPE_MODE (type))))\n+\t{\n+\t  /* Args grow upward.  */\n+\t  t = build2 (POSTINCREMENT_EXPR, TREE_TYPE (valist), valist,\n+\t\t      build_int_2 (POINTER_SIZE / BITS_PER_UNIT, 0));\n+\t  t = build1 (NOP_EXPR, build_pointer_type (ptrtype), t);\n+\t  t = build_fold_indirect_ref (t);\n+\t  t = build_fold_indirect_ref (t);\n+\n+\t  *expr_p = t;\n+\t  return;\n+\t}\n+      if (targetm.calls.split_complex_arg\n+\t  && TREE_CODE (type) == COMPLEX_TYPE)\n+\t{\n+\t  tree elem_type = TREE_TYPE (type);\n+\t  enum machine_mode elem_mode = TYPE_MODE (elem_type);\n+\t  int elem_size = GET_MODE_SIZE (elem_mode);\n+\n+\t  if (elem_size < UNITS_PER_WORD)\n+\t    {\n+\t      tree real_part, imag_addr, dest_real, rr;\n+\t      tree post = NULL_TREE;\n+\n+\t      /* This is a bit tricky because we can't just feed the\n+\t\t VA_ARG_EXPRs back into gimplify_expr; if we did,\n+\t\t gimplify_va_arg_expr would complain about trying to pass a\n+\t\t float. */\n+\t      real_part = build1 (VA_ARG_EXPR, elem_type, valist);\n+\t      rs6000_gimplify_va_arg (&real_part, pre_p, &post);\n+\t      gimplify_expr (&real_part, pre_p, &post, is_gimple_val,\n+\t\t\t     fb_rvalue);\n+\t      append_to_statement_list (post, pre_p);\n+\n+\t      imag_addr = build1 (VA_ARG_EXPR, elem_type, valist);\n+\t      rs6000_gimplify_va_arg (&imag_addr, pre_p, post_p);\n+\t      imag_addr = build_fold_addr_expr (imag_addr);\n+\t      gimplify_expr (&imag_addr, pre_p, post_p, is_gimple_val,\n+\t\t\t     fb_rvalue);\n+\n+\t      /* We're not returning the value here, but the address.\n+\t\t real_part and imag_part are not contiguous, and we know\n+\t\t there is space available to pack real_part next to\n+\t\t imag_part.  float _Complex is not promoted to\n+\t\t double _Complex by the default promotion rules that\n+\t\t promote float to double.  */\n+\t      if (2 * elem_size > UNITS_PER_WORD)\n+\t\tabort ();\n+\n+\t      dest_real = fold (build2 (MINUS_EXPR, TREE_TYPE (imag_addr),\n+\t\t\t\t\timag_addr, ssize_int (elem_size)));\n+\t      gimplify_expr (&dest_real, pre_p, post_p, is_gimple_val,\n+\t\t\t     fb_rvalue);\n+\n+\t      rr = build_fold_indirect_ref (dest_real);\n+\t      rr = build2 (MODIFY_EXPR, void_type_node, rr, real_part);\n+\t      gimplify_and_add (rr, pre_p);\n+\n+\t      dest_real = convert (build_pointer_type (type), dest_real);\n+\t      *expr_p = build_fold_indirect_ref (dest_real);\n+\n+\t      return;\n+\t    }\n+\t}\n+\n+      std_gimplify_va_arg_expr (expr_p, pre_p, post_p);\n+      return;\n+    }\n+\n+  f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n+  f_fpr = TREE_CHAIN (f_gpr);\n+  f_res = TREE_CHAIN (f_fpr);\n+  f_ovf = TREE_CHAIN (f_res);\n+  f_sav = TREE_CHAIN (f_ovf);\n+\n+  valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+\n+  size = int_size_in_bytes (type);\n+  rsize = (size + 3) / 4;\n+  align = 1;\n+\n+  if (AGGREGATE_TYPE_P (type)\n+      || TYPE_MODE (type) == TFmode\n+      || (!TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (TYPE_MODE (type))))\n+    {\n+      /* Aggregates, long doubles, and AltiVec vectors are passed by\n+\t reference.  */\n+      indirect_p = 1;\n+      reg = gpr;\n+      n_reg = 1;\n+      sav_ofs = 0;\n+      sav_scale = 4;\n+      size = 4;\n+      rsize = 1;\n+    }\n+  else if (TARGET_HARD_FLOAT && TARGET_FPRS\n+\t   && (TYPE_MODE (type) == SFmode || TYPE_MODE (type) == DFmode))\n+    {\n+      /* FP args go in FP registers, if present.  */\n+      indirect_p = 0;\n+      reg = fpr;\n+      n_reg = 1;\n+      sav_ofs = 8*4;\n+      sav_scale = 8;\n+      if (TYPE_MODE (type) == DFmode)\n+\talign = 8;\n+    }\n+  else\n+    {\n+      /* Otherwise into GP registers.  */\n+      indirect_p = 0;\n+      reg = gpr;\n+      n_reg = rsize;\n+      sav_ofs = 0;\n+      sav_scale = 4;\n+      if (n_reg == 2)\n+\talign = 8;\n+    }\n+\n+  /* Pull the value out of the saved registers....  */\n+\n+  lab_over = NULL;\n+  addr = create_tmp_var (ptr_type_node, \"addr\");\n+  DECL_POINTER_ALIAS_SET (addr) = get_varargs_alias_set ();\n+\n+  /*  AltiVec vectors never go in registers when -mabi=altivec.  */\n+  if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (TYPE_MODE (type)))\n+    align = 16;\n+  else\n+    {\n+      lab_false = create_artificial_label ();\n+      lab_over = create_artificial_label ();\n+\n+      /* Long long and SPE vectors are aligned in the registers.\n+\t As are any other 2 gpr item such as complex int due to a\n+\t historical mistake.  */\n+      u = reg;\n+      if (n_reg == 2)\n+\t{\n+\t  u = build2 (BIT_AND_EXPR, TREE_TYPE (reg), reg,\n+\t\t     build_int_2 (n_reg - 1, 0));\n+\t  u = build2 (POSTINCREMENT_EXPR, TREE_TYPE (reg), reg, u);\n+\t}\n+\n+      t = build_int_2 (8 - n_reg + 1, 0);\n+      TREE_TYPE (t) = TREE_TYPE (reg);\n+      t = build2 (GE_EXPR, boolean_type_node, u, t);\n+      u = build1 (GOTO_EXPR, void_type_node, lab_false);\n+      t = build3 (COND_EXPR, void_type_node, t, u, NULL_TREE);\n+      gimplify_and_add (t, pre_p);\n+\n+      t = sav;\n+      if (sav_ofs)\n+\tt = build2 (PLUS_EXPR, ptr_type_node, sav, build_int_2 (sav_ofs, 0));\n+\n+      u = build2 (POSTINCREMENT_EXPR, TREE_TYPE (reg), reg,\n+\t\t build_int_2 (n_reg, 0));\n+      u = build1 (CONVERT_EXPR, integer_type_node, u);\n+      u = build2 (MULT_EXPR, integer_type_node, u, build_int_2 (sav_scale, 0));\n+      t = build2 (PLUS_EXPR, ptr_type_node, t, u);\n+\n+      t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+      gimplify_and_add (t, pre_p);\n+\n+      t = build1 (GOTO_EXPR, void_type_node, lab_over);\n+      gimplify_and_add (t, pre_p);\n+\n+      t = build1 (LABEL_EXPR, void_type_node, lab_false);\n+      append_to_statement_list (t, pre_p);\n+\n+      if (n_reg > 2)\n+\t{\n+\t  /* Ensure that we don't find any more args in regs.\n+\t     Alignment has taken care of the n_reg == 2 case.  */\n+\t  t = build (MODIFY_EXPR, TREE_TYPE (reg), reg, build_int_2 (8, 0));\n+\t  gimplify_and_add (t, pre_p);\n+\t}\n+    }\n+\n+  /* ... otherwise out of the overflow area.  */\n+\n+  /* Care for on-stack alignment if needed.  */\n+  t = ovf;\n+  if (align != 1)\n+    {\n+      t = build2 (PLUS_EXPR, TREE_TYPE (t), t, build_int_2 (align - 1, 0));\n+      t = build2 (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align, -1));\n+    }\n+  gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n+\n+  u = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+  gimplify_and_add (u, pre_p);\n+\n+  t = build2 (PLUS_EXPR, TREE_TYPE (t), t, build_int_2 (size, 0));\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+  gimplify_and_add (t, pre_p);\n+\n+  if (lab_over)\n+    {\n+      t = build1 (LABEL_EXPR, void_type_node, lab_over);\n+      append_to_statement_list (t, pre_p);\n+    }\n+\n+  if (indirect_p)\n+    {\n+      addr = convert (build_pointer_type (ptrtype), addr);\n+      addr = build_fold_indirect_ref (addr);\n+    }\n+  else\n+    addr = convert (ptrtype, addr);\n+\n+  *expr_p = build_fold_indirect_ref (addr);\n+}\n+\n /* Builtins.  */\n \n #define def_builtin(MASK, NAME, TYPE, CODE)\t\t\t\\"}, {"sha": "ecd59f844f775bea3718574eea0f5ddb1bc132ce", "filename": "gcc/fold-const.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -10001,4 +10001,73 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n   return tem;\n }\n \n+/* Build an expression for the address of T.  Folds away INDIRECT_REF to\n+   avoid confusing the gimplify process.  */\n+\n+tree\n+build_fold_addr_expr_with_type (tree t, tree ptrtype)\n+{\n+  if (TREE_CODE (t) == INDIRECT_REF)\n+    {\n+      t = TREE_OPERAND (t, 0);\n+      if (TREE_TYPE (t) != ptrtype)\n+\tt = build1 (NOP_EXPR, ptrtype, t);\n+    }\n+  else\n+    {\n+      tree base = t;\n+      while (TREE_CODE (base) == COMPONENT_REF\n+\t     || TREE_CODE (base) == ARRAY_REF)\n+\tbase = TREE_OPERAND (base, 0);\n+      if (DECL_P (base))\n+\tTREE_ADDRESSABLE (base) = 1;\n+\n+      t = build1 (ADDR_EXPR, ptrtype, t);\n+    }\n+\n+  return t;\n+}\n+\n+tree\n+build_fold_addr_expr (tree t)\n+{\n+  return build_fold_addr_expr_with_type (t, build_pointer_type (TREE_TYPE (t)));\n+}\n+\n+/* Builds an expression for an indirection through T, simplifying some\n+   cases.  */\n+\n+tree\n+build_fold_indirect_ref (tree t)\n+{\n+  tree type = TREE_TYPE (TREE_TYPE (t));\n+  tree sub = t;\n+  tree subtype;\n+\n+  STRIP_NOPS (sub);\n+  if (TREE_CODE (sub) == ADDR_EXPR)\n+    {\n+      tree op = TREE_OPERAND (sub, 0);\n+      tree optype = TREE_TYPE (op);\n+      /* *&p => p */\n+      if (lang_hooks.types_compatible_p (type, optype))\n+\treturn op;\n+      /* *(foo *)&fooarray => fooarray[0] */\n+      else if (TREE_CODE (optype) == ARRAY_TYPE\n+\t       && lang_hooks.types_compatible_p (type, TREE_TYPE (optype)))\n+\treturn build2 (ARRAY_REF, type, op, size_zero_node);\n+    }\n+\n+  /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n+  subtype = TREE_TYPE (sub);\n+  if (TREE_CODE (TREE_TYPE (subtype)) == ARRAY_TYPE\n+      && lang_hooks.types_compatible_p (type, TREE_TYPE (TREE_TYPE (subtype))))\n+    {\n+      sub = build_fold_indirect_ref (sub);\n+      return build2 (ARRAY_REF, type, sub, size_zero_node);\n+    }\n+\n+  return build1 (INDIRECT_REF, type, t);\n+}\n+\n #include \"gt-fold-const.h\""}, {"sha": "c25a89171b3e52ea3dfcf8fbd269bdaa80039b90", "filename": "gcc/gimplify.c", "status": "modified", "additions": 20, "deletions": 46, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -45,6 +45,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"output.h\"\n #include \"expr.h\"\n #include \"ggc.h\"\n+#include \"target.h\"\n \n static struct gimplify_ctx\n {\n@@ -237,6 +238,15 @@ append_to_statement_list_force (tree t, tree *list_p)\n   append_to_statement_list_1 (t, list_p, t != NULL);\n }\n \n+/* Both gimplify the statement T and append it to LIST_P.  */\n+\n+void\n+gimplify_and_add (tree t, tree *list_p)\n+{\n+  gimplify_stmt (&t);\n+  append_to_statement_list (t, list_p);\n+}\n+\n /* Add T to the end of a COMPOUND_EXPR pointed by LIST_P.  The type\n    of the result is the type of T.  */\n \n@@ -668,13 +678,17 @@ copy_if_shared_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   else\n     {\n       TREE_VISITED (t) = 1;\n-      if (TREE_CODE (*tp) == VA_ARG_EXPR)\n+      if (TREE_CODE (*tp) == VA_ARG_EXPR\n+\t  && targetm.calls.gimplify_va_arg_expr == NULL)\n \t{\n \t  /* Mark any _DECL inside the operand as volatile to avoid\n \t     the optimizers messing around with it. We have to do this\n \t     early, otherwise we might mark a variable as volatile\n \t     after we gimplify other statements that use the variable\n \t     assuming it's not volatile.  */\n+\n+\t  /* FIXME once most targets define the above hook, this should\n+\t     go away (perhaps along with the #include \"target.h\").  */\n \t  walk_tree (&TREE_OPERAND (*tp, 0), mark_decls_volatile_r,\n \t\t     NULL, NULL);\n \t}\n@@ -1633,39 +1647,6 @@ gimplify_minimax_expr (tree *expr_p, tree *pre_p, tree *post_p)\n     return GS_OK;\n }\n \n-/*  Build an expression for the address of T.  Folds away INDIRECT_REF to\n-    avoid confusing the gimplify process.  */\n-\n-static tree\n-build_addr_expr_with_type (tree t, tree ptrtype)\n-{\n-  if (TREE_CODE (t) == INDIRECT_REF)\n-    {\n-      t = TREE_OPERAND (t, 0);\n-      if (TREE_TYPE (t) != ptrtype)\n-\tt = build1 (NOP_EXPR, ptrtype, t);\n-    }\n-  else\n-    {\n-      tree base = t;\n-      while (TREE_CODE (base) == COMPONENT_REF\n-\t     || TREE_CODE (base) == ARRAY_REF)\n-\tbase = TREE_OPERAND (base, 0);\n-      if (DECL_P (base))\n-\tTREE_ADDRESSABLE (base) = 1;\n-\n-      t = build1 (ADDR_EXPR, ptrtype, t);\n-    }\n-\n-  return t;\n-}\n-\n-static tree\n-build_addr_expr (tree t)\n-{\n-  return build_addr_expr_with_type (t, build_pointer_type (TREE_TYPE (t)));\n-}\n-\n /* Subroutine of gimplify_compound_lval and gimplify_array_ref.\n    Converts an ARRAY_REF to the equivalent *(&array + offset) form.  */\n \n@@ -1716,7 +1697,7 @@ gimplify_array_ref_to_plus (tree *expr_p, tree *pre_p, tree *post_p)\n   if (ret == GS_ERROR)\n     return ret;\n \n-  addr = build_addr_expr_with_type (array, ptrtype);\n+  addr = build_fold_addr_expr_with_type (array, ptrtype);\n   result = fold (build (add_code, ptrtype, addr, offset));\n   *expr_p = build1 (INDIRECT_REF, elttype, result);\n \n@@ -2533,9 +2514,9 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n \t  t = TYPE_SIZE_UNIT (TREE_TYPE (*to_p));\n \t  t = unshare_expr (t);\n \t  args = tree_cons (NULL, t, NULL);\n-\t  t = build_addr_expr (*from_p);\n+\t  t = build_fold_addr_expr (*from_p);\n \t  args = tree_cons (NULL, t, args);\n-\t  dest = build_addr_expr (*to_p);\n+\t  dest = build_fold_addr_expr (*to_p);\n \t  args = tree_cons (NULL, dest, args);\n \t  t = implicit_built_in_decls[BUILT_IN_MEMCPY];\n \t  t = build_function_call_expr (t, args);\n@@ -3239,14 +3220,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tcase VA_ARG_EXPR:\n-\t  /* Mark any _DECL inside the operand as volatile to avoid the\n-\t     optimizers messing around with it. FIXME: Remove this once\n-\t     VA_ARG_EXPRs are properly lowered.  */\n-\t  walk_tree (&TREE_OPERAND (*expr_p, 0), mark_decls_volatile_r,\n-\t\t     NULL, NULL);\n-\n-\t  /* va_arg expressions are in GIMPLE form already.  */\n-\t  ret = GS_ALL_DONE;\n+\t  ret = gimplify_va_arg_expr (expr_p, pre_p, post_p);\n \t  break;\n \n \tcase CONVERT_EXPR:\n@@ -3586,7 +3560,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n       /* An lvalue will do.  Take the address of the expression, store it\n \t in a temporary, and replace the expression with an INDIRECT_REF of\n \t that temporary.  */\n-      tmp = build_addr_expr (*expr_p);\n+      tmp = build_fold_addr_expr (*expr_p);\n       gimplify_expr (&tmp, pre_p, post_p, is_gimple_reg, fb_rvalue);\n       *expr_p = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (tmp)), tmp);\n     }"}, {"sha": "40e9610ef61ccb8f0744a3a9eaeeb3ac8b2d1926", "filename": "gcc/target-def.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -358,6 +358,14 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   default_pretend_outgoing_varargs_named\n #define TARGET_SPLIT_COMPLEX_ARG NULL\n \n+#ifdef EXPAND_BUILTIN_VA_ARG\n+/* If there's a target-specific va_arg expander, there needs to be a\n+   target-specific gimplifier.  */\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR NULL\n+#else\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR std_gimplify_va_arg_expr\n+#endif\n+\n #define TARGET_CALLS {\t\t\t\t\t\t\\\n    TARGET_PROMOTE_FUNCTION_ARGS,\t\t\t\t\\\n    TARGET_PROMOTE_FUNCTION_RETURN,\t\t\t\t\\\n@@ -370,6 +378,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_STRICT_ARGUMENT_NAMING,\t\t\t\t\\\n    TARGET_PRETEND_OUTGOING_VARARGS_NAMED,\t\t\t\\\n    TARGET_SPLIT_COMPLEX_ARG,\t\t\t\t\t\\\n+   TARGET_GIMPLIFY_VA_ARG_EXPR,\t\t\t\t\t\\\n    }\n \n /* The whole shebang.  */"}, {"sha": "a2a564619fae1d29df1ff2eac941c899510a7e0e", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -470,6 +470,10 @@ struct gcc_target\n     /* Given a complex type T, return true if a parameter of type T\n        should be passed as two scalars.  */\n     bool (* split_complex_arg) (tree type);\n+\n+    /* Gimplifies a VA_ARG_EXPR.  */\n+    void (* gimplify_va_arg_expr) (tree *expr_p, tree *pre_p,\n+\t\t\t\t   tree *post_p);\n   } calls;\n \n   /* Leave the boolean fields at the end.  */"}, {"sha": "eb3dea86e85037c967379d76fc19a4f2ff855fc0", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -107,6 +107,7 @@ void gimplify_to_stmt_list (tree *);\n void gimplify_body (tree *, tree);\n void push_gimplify_context (void);\n void pop_gimplify_context (tree);\n+void gimplify_and_add (tree, tree *);\n \n /* Miscellaneous helpers.  */\n tree get_base_address (tree t);\n@@ -121,6 +122,8 @@ tree build_and_jump (tree *);\n tree alloc_stmt_list (void);\n void free_stmt_list (tree);\n tree force_labels_r (tree *, int *, void *);\n+enum gimplify_status gimplify_va_arg_expr (tree *, tree *, tree *);\n+void std_gimplify_va_arg_expr (tree *, tree *, tree *);\n \n /* In tree-nested.c.  */\n extern void lower_nested_functions (tree);"}, {"sha": "03c6415d2759ae293933a5bcd18f85e8afc51543", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ce9b44c1c3b4f4567de0d2767df058b89ce58/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=cd3ce9b44c1c3b4f4567de0d2767df058b89ce58", "patch": "@@ -1602,7 +1602,7 @@ struct tree_block GTY(())\n #define TYPE_VECTOR_SUBPARTS(VECTOR_TYPE) \\\n   GET_MODE_NUNITS (VECTOR_TYPE_CHECK (VECTOR_TYPE)->type.mode)\n \n-  /* Indicates that objects of this type must be initialized by calling a\n+/* Indicates that objects of this type must be initialized by calling a\n    function when they are created.  */\n #define TYPE_NEEDS_CONSTRUCTING(NODE) \\\n   (TYPE_CHECK (NODE)->type.needs_constructing_flag)\n@@ -3468,6 +3468,9 @@ extern tree nondestructive_fold_unary_to_constant (enum tree_code, tree, tree);\n extern tree nondestructive_fold_binary_to_constant (enum tree_code, tree, tree, tree);\n extern tree fold_read_from_constant_string (tree);\n extern tree int_const_binop (enum tree_code, tree, tree, int);\n+extern tree build_fold_addr_expr (tree);\n+extern tree build_fold_addr_expr_with_type (tree, tree);\n+extern tree build_fold_indirect_ref (tree);\n \n /* In builtins.c */\n extern tree fold_builtin (tree);"}]}