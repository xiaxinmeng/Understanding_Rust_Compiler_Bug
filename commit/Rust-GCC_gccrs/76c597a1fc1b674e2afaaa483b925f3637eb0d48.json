{"sha": "76c597a1fc1b674e2afaaa483b925f3637eb0d48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZjNTk3YTFmYzFiNjc0ZTJhZmFhYTQ4M2I5MjVmMzYzN2ViMGQ0OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-09T08:21:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-09T08:21:08Z"}, "message": "[multiple changes]\n\n2009-04-09  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch4.adb (Expand_Concatenate): Add circuitry to properly handle\n\toverflows in computation of bounds.\n\n2009-04-09  Pascal Obry  <obry@adacore.com>\n\n\t* a-cihama.adb, a-cgcaso.adb, a-cihase.adb, a-cohase.adb: Fix some\n\ttypos in comment.\n\nFrom-SVN: r145803", "tree": {"sha": "2be644ec89c994a9cd3412babb7db6cee034c6fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2be644ec89c994a9cd3412babb7db6cee034c6fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76c597a1fc1b674e2afaaa483b925f3637eb0d48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76c597a1fc1b674e2afaaa483b925f3637eb0d48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76c597a1fc1b674e2afaaa483b925f3637eb0d48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76c597a1fc1b674e2afaaa483b925f3637eb0d48/comments", "author": null, "committer": null, "parents": [{"sha": "95b89f1bf9d363aaa98b55caae4ce1ffd8d6fef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95b89f1bf9d363aaa98b55caae4ce1ffd8d6fef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95b89f1bf9d363aaa98b55caae4ce1ffd8d6fef6"}], "stats": {"total": 168, "additions": 108, "deletions": 60}, "files": [{"sha": "1a5089c3c928f916683cdb9d063a8658afa5633a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76c597a1fc1b674e2afaaa483b925f3637eb0d48/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76c597a1fc1b674e2afaaa483b925f3637eb0d48/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=76c597a1fc1b674e2afaaa483b925f3637eb0d48", "patch": "@@ -1,3 +1,13 @@\n+2009-04-09  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Concatenate): Add circuitry to properly handle\n+\toverflows in computation of bounds.\n+\n+2009-04-09  Pascal Obry  <obry@adacore.com>\n+\n+\t* a-cihama.adb, a-cgcaso.adb, a-cihase.adb, a-cohase.adb: Fix some\n+\ttypos in comment.\n+\n 2009-04-09  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_attr.adb (Check_Stream_Attribute): Check violation of"}, {"sha": "760238d46843d0675e784a6784f50264de990f07", "filename": "gcc/ada/a-cgcaso.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76c597a1fc1b674e2afaaa483b925f3637eb0d48/gcc%2Fada%2Fa-cgcaso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76c597a1fc1b674e2afaaa483b925f3637eb0d48/gcc%2Fada%2Fa-cgcaso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cgcaso.adb?ref=76c597a1fc1b674e2afaaa483b925f3637eb0d48", "patch": "@@ -26,7 +26,7 @@\n -- however invalidate  any other reasons why  the executable file  might be --\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n--- This unit has originally being developed by Matthew J Heaney.            --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n --  This algorithm was adapted from GNAT.Heap_Sort_G (see g-hesorg.ad[sb])"}, {"sha": "faca39b8b5917f9596a5a3eb504fa05452495661", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76c597a1fc1b674e2afaaa483b925f3637eb0d48/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76c597a1fc1b674e2afaaa483b925f3637eb0d48/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=76c597a1fc1b674e2afaaa483b925f3637eb0d48", "patch": "@@ -26,7 +26,7 @@\n -- however invalidate  any other reasons why  the executable file  might be --\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n--- This unit has originally being developed by Matthew J Heaney.            --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n with Ada.Containers.Hash_Tables.Generic_Operations;"}, {"sha": "aac3509457a32d5905652821cd6b31a3a3a98092", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76c597a1fc1b674e2afaaa483b925f3637eb0d48/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76c597a1fc1b674e2afaaa483b925f3637eb0d48/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=76c597a1fc1b674e2afaaa483b925f3637eb0d48", "patch": "@@ -26,7 +26,7 @@\n -- however invalidate  any other reasons why  the executable file  might be --\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n--- This unit has originally being developed by Matthew J Heaney.            --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n with Ada.Unchecked_Deallocation;"}, {"sha": "61598ee6fbdb9028104c4479a50d347baaf4eaf2", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76c597a1fc1b674e2afaaa483b925f3637eb0d48/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76c597a1fc1b674e2afaaa483b925f3637eb0d48/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=76c597a1fc1b674e2afaaa483b925f3637eb0d48", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,7 +26,7 @@\n -- however invalidate  any other reasons why  the executable file  might be --\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n--- This unit has originally being developed by Matthew J Heaney.            --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n with Ada.Unchecked_Deallocation;"}, {"sha": "f49afe7e7e014e749b86236f131dfa08d0409c08", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 93, "deletions": 55, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76c597a1fc1b674e2afaaa483b925f3637eb0d48/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76c597a1fc1b674e2afaaa483b925f3637eb0d48/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=76c597a1fc1b674e2afaaa483b925f3637eb0d48", "patch": "@@ -2232,12 +2232,16 @@ package body Exp_Ch4 is\n \n       function To_Artyp (X : Node_Id) return Node_Id;\n       --  Given a node of type Ityp, returns the corresponding value of type\n-      --  Artyp. For non-enumeration types, this is the identity. For enum\n-      --  types, the Pos of the value is returned.\n+      --  Artyp. For non-enumeration types, this is a plain integer conversion.\n+      --  For enum types, the Pos of the value is returned.\n \n       function To_Ityp (X : Node_Id) return Node_Id;\n       --  The inverse function (uses Val in the case of enumeration types)\n \n+      Known_Non_Null_Operand_Seen : Boolean;\n+      --  Set True during generation of the assignements of operands into\n+      --  result once an operand known to be non-null has been seen.\n+\n       --------------\n       -- To_Artyp --\n       --------------\n@@ -2275,38 +2279,10 @@ package body Exp_Ch4 is\n          --  Case where we will do a type conversion\n \n          else\n-            --  If the value is known at compile time, and known to be out of\n-            --  range of the index subtype or its base type, we can signal that\n-            --  we are sure to have a constraint error at run time.\n-\n-            --  There are two reasons for doing this. First of all, it is of\n-            --  course nice to detect situations of certain exceptions, and\n-            --  generate a warning. But there is a more important reason. If\n-            --  the high bound is out of range of the base type, and is a\n-            --  literal, then that would cause a compilation illegality when\n-            --  we analyzed and resolved the expression.\n-\n-            Set_Parent (X, Cnode);\n-            Analyze_And_Resolve (X, Artyp, Suppress => All_Checks);\n-\n-            if Compile_Time_Compare\n-                 (X, Type_High_Bound (Istyp), Assume_Valid => False) = GT\n-              or else\n-               Compile_Time_Compare\n-                 (X, Type_High_Bound (Ityp), Assume_Valid => False) = GT\n-            then\n-               Apply_Compile_Time_Constraint_Error\n-                 (N      => Cnode,\n-                  Msg    => \"concatenation result upper bound out of range?\",\n-                  Reason => CE_Range_Check_Failed);\n-               raise Concatenation_Error;\n-\n+            if Ityp = Base_Type (Artyp) then\n+               return X;\n             else\n-               if Ityp = Base_Type (Artyp) then\n-                  return X;\n-               else\n-                  return Convert_To (Ityp, X);\n-               end if;\n+               return Convert_To (Ityp, X);\n             end if;\n          end if;\n       end To_Ityp;\n@@ -2320,6 +2296,8 @@ package body Exp_Ch4 is\n       Clen     : Node_Id;\n       Set      : Boolean;\n \n+      Saved_In_Inlined_Body : Boolean;\n+\n    begin\n       Aggr_Length (0) := Make_Integer_Literal (Loc, 0);\n \n@@ -2607,9 +2585,7 @@ package body Exp_Ch4 is\n \n               Suppress => All_Checks);\n \n-            Aggr_Length (NN) :=\n-              Make_Identifier (Loc,\n-                Chars => Chars (Ent));\n+            Aggr_Length (NN) := Make_Identifier (Loc, Chars => Chars (Ent));\n          end if;\n \n       <<Continue>>\n@@ -2707,8 +2683,7 @@ package body Exp_Ch4 is\n \n          begin\n             Ent :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_Internal_Name ('L'));\n+              Make_Defining_Identifier (Loc, Chars => New_Internal_Name ('L'));\n \n             Insert_Action (Cnode,\n               Make_Object_Declaration (Loc,\n@@ -2722,7 +2697,8 @@ package body Exp_Ch4 is\n          end;\n       end if;\n \n-      --  Now find the upper bound, normally this is Low_Bound + Length - 1\n+      --  Now we can safely compute the upper bound, normally\n+      --  Low_Bound + Length - 1.\n \n       High_Bound :=\n         To_Ityp (\n@@ -2733,7 +2709,11 @@ package body Exp_Ch4 is\n                 Left_Opnd  => New_Copy (Aggr_Length (NN)),\n                 Right_Opnd => Make_Integer_Literal (Loc, 1))));\n \n-      --  But there is one exception, namely when the result is null in which\n+      --  Now force overflow checking on High_Bound\n+\n+      Activate_Overflow_Check (High_Bound);\n+\n+      --  Handle the exceptional case where the result is null, in which case\n       --  case the bounds come from the last operand (so that we get the proper\n       --  bounds if the last operand is super-flat).\n \n@@ -2754,6 +2734,17 @@ package body Exp_Ch4 is\n         Make_Defining_Identifier (Loc,\n           Chars => New_Internal_Name ('S'));\n \n+      --  Kludge! Kludge! ???\n+      --  If the bound is statically known to be out of range, we do not want\n+      --  to abort, we want a warning and a runtime constraint error, so we\n+      --  pretend this comes from an inlined body (otherwise a static out\n+      --  of range value would be an illegality).\n+\n+      --  This is horrible, we really must find a better way ???\n+\n+      Saved_In_Inlined_Body := In_Inlined_Body;\n+      In_Inlined_Body := True;\n+\n       Insert_Action (Cnode,\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => Ent,\n@@ -2766,11 +2757,20 @@ package body Exp_Ch4 is\n                     Make_Range (Loc,\n                       Low_Bound  => Low_Bound,\n                       High_Bound => High_Bound))))),\n-\n         Suppress => All_Checks);\n \n+      In_Inlined_Body := Saved_In_Inlined_Body;\n+\n+      --  Catch the static out of range case now\n+\n+      if Raises_Constraint_Error (High_Bound) then\n+         raise Concatenation_Error;\n+      end if;\n+\n       --  Now we will generate the assignments to do the actual concatenation\n \n+      Known_Non_Null_Operand_Seen := False;\n+\n       for J in 1 .. NN loop\n          declare\n             Lo : constant Node_Id :=\n@@ -2790,6 +2790,7 @@ package body Exp_Ch4 is\n             --  Singleton case, simple assignment\n \n             if Base_Type (Etype (Operands (J))) = Ctyp then\n+               Known_Non_Null_Operand_Seen := True;\n                Insert_Action (Cnode,\n                  Make_Assignment_Statement (Loc,\n                    Name       =>\n@@ -2799,20 +2800,47 @@ package body Exp_Ch4 is\n                    Expression => Operands (J)),\n                  Suppress => All_Checks);\n \n-            --  Array case, slice assignment\n+            --  Array case, slice assignment, skipped when argument is fixed\n+            --  length and known to be null.\n \n-            else\n-               Insert_Action (Cnode,\n-                 Make_Assignment_Statement (Loc,\n-                   Name       =>\n-                     Make_Slice (Loc,\n-                       Prefix         => New_Occurrence_Of (Ent, Loc),\n-                       Discrete_Range =>\n-                         Make_Range (Loc,\n-                           Low_Bound  => To_Ityp (Lo),\n-                           High_Bound => To_Ityp (Hi))),\n-                   Expression => Operands (J)),\n-                 Suppress => All_Checks);\n+            elsif (not Is_Fixed_Length (J)) or else (Fixed_Length (J) > 0) then\n+               declare\n+                  Assign : Node_Id :=\n+                             Make_Assignment_Statement (Loc,\n+                               Name       =>\n+                                 Make_Slice (Loc,\n+                                   Prefix         =>\n+                                     New_Occurrence_Of (Ent, Loc),\n+                                   Discrete_Range =>\n+                                     Make_Range (Loc,\n+                                       Low_Bound  => To_Ityp (Lo),\n+                                       High_Bound => To_Ityp (Hi))),\n+                               Expression => Operands (J));\n+               begin\n+                  if Is_Fixed_Length (J) then\n+                     Known_Non_Null_Operand_Seen := True;\n+\n+                  elsif not Known_Non_Null_Operand_Seen then\n+\n+                     --  Here if operand length is not statically known and no\n+                     --  operand known to be non-null has been processed yet.\n+                     --  If operand length is 0, we do not need to perform the\n+                     --  assignment, and we must avoid the evaluation of the\n+                     --  high bound of the slice, since it may underflow if the\n+                     --  low bound is Ityp'First.\n+\n+                     Assign :=\n+                       Make_Implicit_If_Statement (Cnode,\n+                         Condition =>\n+                           Make_Op_Ne (Loc,\n+                             Left_Opnd =>\n+                               New_Occurrence_Of (Var_Length (J), Loc),\n+                             Right_Opnd => Make_Integer_Literal (Loc, 0)),\n+                         Then_Statements =>\n+                           New_List (Assign));\n+                  end if;\n+                  Insert_Action (Cnode, Assign, Suppress => All_Checks);\n+               end;\n             end if;\n          end;\n       end loop;\n@@ -2827,7 +2855,17 @@ package body Exp_Ch4 is\n \n    exception\n       when Concatenation_Error =>\n-         Set_Etype (Cnode, Atyp);\n+\n+         --  Kill warning generated for the declaration of the static out of\n+         --  range high bound, and instead generate a Constraint_Error with\n+         --  an appropriate specific message.\n+\n+         Kill_Dead_Code (Declaration_Node (Entity (High_Bound)));\n+         Apply_Compile_Time_Constraint_Error\n+           (N      => Cnode,\n+            Msg    => \"concatenation result upper bound out of range?\",\n+            Reason => CE_Range_Check_Failed);\n+         --  Set_Etype (Cnode, Atyp);\n    end Expand_Concatenate;\n \n    ------------------------"}]}