{"sha": "7372d214af51c622d77b18b9b51ea58960ab554e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM3MmQyMTRhZjUxYzYyMmQ3N2IxOGI5YjUxZWE1ODk2MGFiNTU0ZQ==", "commit": {"author": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2005-02-07T13:22:36Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2005-02-07T13:22:36Z"}, "message": "[multiple changes]\n\n2005-02-06  Jerry Quinn  <jlquinn@optonline.net>\n\n        * javax/imageio/metadata/IIOMetadataNode.java:\n        Implemented.\n        * javax/imageio/metadata/IIOAttr.java,\n        javax/imageio/metadata/IIONamedNodeMap.java,\n        javax/imageio/metadata/IIONodeList.java:\n        New files\n\n2005-02-06  Graydon Hoare  <graydon@redhat.com>\n\n        * gnu/java/awt/ClasspathToolkit.java\n        (registerImageIOSpis): New method.\n        * javax/imageio/ImageIO.java\n        (WriterFormatFilter.filter): Fix copy-and-paste typos.\n        (WriterMIMETypeFilter.filter): Likewise.\n        (ImageReaderIterator): Pass extension argument through to SPI.\n        (getReadersByFilter): Likewise.\n        (getWritersByFilter): Likewise.\n        (getImageReadersByFormatName): Likewise.\n        (getImageReadersByMIMEType): Likewise.\n        (getImageReadersBySuffix): Likewise.\n        (getImageWritersByFormatName): Likewise.\n        (getImageWritersByMIMEType): Likewise.\n        (getImageWritersBySuffix): Likewise.\n        (read): Implement.\n        (write): Implement.\n        * javax/imageio/ImageReader.java\n        (progressListeners): Initialize.\n        (setInput): Implement.\n        * javax/imageio/ImageWriter.java\n        (progressListeners): Initialize.\n        (warningListeners): Likewise.\n        (warningLocales): Likewise.\n        (setOutput): Test \"isInstance\" rather than class equality.\n        * javax/imageio/spi/IIORegistry.java\n        (static): Add reader and writer SPIs.\n        (IIORegistry): Call ClasspathToolkit.registerImageIOSpis.\n\n2004-02-06  Michael Koch  <konqueror@gmx.de>\n\n        * javax/imageio/metadata/IIOInvalidTreeException.java\n        (IIOInvalidTreeException): Reformatted.\n        * javax/imageio/spi/IIORegistry.java\n        (static): Register ImageReaderSpi.class and ImageWriterSpi.class.\n        * javax/imageio/stream/MemoryCacheImageInputStream.java:\n        Reworked import statements.\n\n2004-02-06  Michael Koch  <konqueror@gmx.de>\n\n        * javax/imageio/stream/FileImageOutputStream.java:\n        Implemented.\n\n2004-02-06  Michael Koch  <konqueror@gmx.de>\n\n        * javax/imageio/stream/FileCacheImageInputStream.java,\n        javax/imageio/stream/FileCacheImageOutputStream.java,\n        javax/imageio/stream/FileImageInputStream.java,\n        javax/imageio/stream/ImageInputStreamImpl.java,\n        javax/imageio/stream/ImageOutputStreamImpl.java,\n        javax/imageio/stream/MemoryCacheImageInputStream.java,\n        javax/imageio/stream/MemoryCacheImageOutputStream.java:\n        Added all missing methods in javax.imageio.stream.\n\nFrom-SVN: r94698", "tree": {"sha": "eb4b5755fc00c7e2b76292c38237cdefc4c946cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb4b5755fc00c7e2b76292c38237cdefc4c946cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7372d214af51c622d77b18b9b51ea58960ab554e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7372d214af51c622d77b18b9b51ea58960ab554e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7372d214af51c622d77b18b9b51ea58960ab554e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7372d214af51c622d77b18b9b51ea58960ab554e/comments", "author": null, "committer": null, "parents": [{"sha": "c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c866976a42ad9ea612d840a1a92c4bbaf0e2a494"}], "stats": {"total": 2202, "additions": 2162, "deletions": 40}, "files": [{"sha": "b294c0b1a1900ed0a42e263a962baa4b37c95821", "filename": "libjava/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -1,3 +1,67 @@\n+2005-02-06  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* javax/imageio/metadata/IIOMetadataNode.java:\n+\tImplemented.\n+\t* javax/imageio/metadata/IIOAttr.java,\n+\tjavax/imageio/metadata/IIONamedNodeMap.java,\n+\tjavax/imageio/metadata/IIONodeList.java:\n+\tNew files\n+\n+2005-02-06  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* gnu/java/awt/ClasspathToolkit.java\n+\t(registerImageIOSpis): New method.\n+\t* javax/imageio/ImageIO.java\n+\t(WriterFormatFilter.filter): Fix copy-and-paste typos.\n+\t(WriterMIMETypeFilter.filter): Likewise.\n+\t(ImageReaderIterator): Pass extension argument through to SPI.\n+\t(getReadersByFilter): Likewise.\n+\t(getWritersByFilter): Likewise.\n+\t(getImageReadersByFormatName): Likewise.\n+\t(getImageReadersByMIMEType): Likewise.\n+\t(getImageReadersBySuffix): Likewise.\n+\t(getImageWritersByFormatName): Likewise.\n+\t(getImageWritersByMIMEType): Likewise.\n+\t(getImageWritersBySuffix): Likewise.\n+\t(read): Implement.\n+\t(write): Implement.\n+\t* javax/imageio/ImageReader.java\n+\t(progressListeners): Initialize.\n+\t(setInput): Implement.\n+\t* javax/imageio/ImageWriter.java\n+\t(progressListeners): Initialize.\n+\t(warningListeners): Likewise.\n+\t(warningLocales): Likewise.\n+\t(setOutput): Test \"isInstance\" rather than class equality.\n+\t* javax/imageio/spi/IIORegistry.java\n+\t(static): Add reader and writer SPIs.\n+\t(IIORegistry): Call ClasspathToolkit.registerImageIOSpis.\n+\n+2004-02-06  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/imageio/metadata/IIOInvalidTreeException.java\n+\t(IIOInvalidTreeException): Reformatted.\n+\t* javax/imageio/spi/IIORegistry.java\n+\t(static): Register ImageReaderSpi.class and ImageWriterSpi.class.\n+\t* javax/imageio/stream/MemoryCacheImageInputStream.java:\n+\tReworked import statements.\n+\n+2004-02-06  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/imageio/stream/FileImageOutputStream.java:\n+\tImplemented.\n+\n+2004-02-06  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/imageio/stream/FileCacheImageInputStream.java,\n+\tjavax/imageio/stream/FileCacheImageOutputStream.java,\n+\tjavax/imageio/stream/FileImageInputStream.java,\n+\tjavax/imageio/stream/ImageInputStreamImpl.java,\n+\tjavax/imageio/stream/ImageOutputStreamImpl.java,\n+\tjavax/imageio/stream/MemoryCacheImageInputStream.java,\n+\tjavax/imageio/stream/MemoryCacheImageOutputStream.java:\n+\tAdded all missing methods in javax.imageio.stream.\n+\n 2005-02-02  David Daney  <ddaney@avtrex.com>\n \n \t* java/net/InetAddress.java (InetAddress): Make a private copy of"}, {"sha": "1a59123995ffe2c02414c1c9ed860deb25f303a5", "filename": "libjava/javax/imageio/IIOParam.java", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2FIIOParam.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2FIIOParam.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2FIIOParam.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -141,6 +141,11 @@ public void setDestinationOffset(Point destinationOffset)\n     this.destinationOffset = destinationOffset;\n   }\n \n+  public void setSourceBands(int[] sourceBands)\n+  {\n+    this.sourceBands = sourceBands;\n+  }\n+\n   public void setSourceRegion(Rectangle sourceRegion)\n   {\n     if (sourceRegion != null\n@@ -154,4 +159,13 @@ public void setSourceRegion(Rectangle sourceRegion)\n \n     this.sourceRegion = sourceRegion;\n   }\n+\n+  public void setSourceSubsampling(int sourceXSubsampling, int sourceYSubsampling,\n+\t\t\t\t   int subsamplingXOffset, int subsamplingYOffset)\n+  {\n+    this.sourceXSubsampling = sourceXSubsampling;\n+    this.sourceYSubsampling = sourceYSubsampling;\n+    this.subsamplingXOffset = subsamplingXOffset;\n+    this.subsamplingYOffset = subsamplingYOffset;\n+  }\n }"}, {"sha": "3d74ae0745d7252ee9458a5217f319a7ffb082ba", "filename": "libjava/javax/imageio/ImageIO.java", "status": "modified", "additions": 126, "deletions": 20, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2FImageIO.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2FImageIO.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2FImageIO.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -38,8 +38,15 @@\n \n package javax.imageio;\n \n+import java.awt.image.RenderedImage;\n+import java.awt.image.BufferedImage;\n+import java.net.URL;\n import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n import java.io.IOException;\n+import java.io.OutputStream;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n@@ -48,6 +55,10 @@\n import javax.imageio.spi.ImageReaderSpi;\n import javax.imageio.spi.ImageWriterSpi;\n import javax.imageio.spi.ServiceRegistry;\n+import javax.imageio.stream.ImageOutputStream;\n+import javax.imageio.stream.ImageInputStream;\n+import javax.imageio.stream.MemoryCacheImageInputStream;\n+import javax.imageio.stream.MemoryCacheImageOutputStream;\n \n public final class ImageIO\n {\n@@ -142,14 +153,14 @@ public WriterFormatFilter(String formatName)\n \n     public boolean filter(Object provider)\n     {\n-      if (provider instanceof ImageReaderSpi)\n+      if (provider instanceof ImageWriterSpi)\n \t{\n-\t  ImageReaderSpi spi = (ImageReaderSpi) provider;\n+\t  ImageWriterSpi spi = (ImageWriterSpi) provider;\n \t  String[] formatNames = spi.getFormatNames();\n \t  \n \t  for (int i = formatNames.length - 1; i >= 0; --i)\n-\t    if (formatName.equals(formatNames[i]))\n-\t      return true;\n+            if (formatName.equals(formatNames[i]))\n+              return true;\n \t}\n \n       return false;\n@@ -167,7 +178,7 @@ public WriterMIMETypeFilter(String MIMEType)\n \n     public boolean filter(Object provider)\n     {\n-      if (provider instanceof ImageReaderSpi)\n+      if (provider instanceof ImageWriterSpi)\n         {\n           ImageWriterSpi spi = (ImageWriterSpi) provider;\n           String[] mimetypes = spi.getMIMETypes();\n@@ -192,7 +203,7 @@ public WriterSuffixFilter(String fileSuffix)\n \n     public boolean filter(Object provider)\n     {\n-      if (provider instanceof ImageReaderSpi)\n+      if (provider instanceof ImageWriterSpi)\n         {\n           ImageWriterSpi spi = (ImageWriterSpi) provider;\n           String[] suffixes = spi.getFileSuffixes();\n@@ -209,10 +220,12 @@ public boolean filter(Object provider)\n   private static final class ImageReaderIterator implements Iterator\n   {\n     Iterator it;\n+    Object readerExtension;\n     \n-    public ImageReaderIterator(Iterator it)\n+    public ImageReaderIterator(Iterator it, Object readerExtension)\n     {\n       this.it = it;\n+      this.readerExtension = readerExtension;\n     }\n \n     public boolean hasNext()\n@@ -224,7 +237,7 @@ public Object next()\n     {\n       try\n         {\n-          return ((ImageReaderSpi) it.next()).createReaderInstance();\n+          return ((ImageReaderSpi) it.next()).createReaderInstance(readerExtension);\n         }\n       catch (IOException e)\n         {\n@@ -241,10 +254,12 @@ public void remove()\n   private static final class ImageWriterIterator implements Iterator\n   {\n     Iterator it;\n+    Object writerExtension;\n     \n-    public ImageWriterIterator(Iterator it)\n+    public ImageWriterIterator(Iterator it, Object writerExtension)\n     {\n       this.it = it;\n+      this.writerExtension = writerExtension;\n     }\n \n     public boolean hasNext()\n@@ -256,7 +271,7 @@ public Object next()\n     {\n       try\n         {\n-          return ((ImageWriterSpi) it.next()).createWriterInstance();\n+          return ((ImageWriterSpi) it.next()).createWriterInstance(writerExtension);\n         }\n       catch (IOException e)\n         {\n@@ -274,12 +289,13 @@ public void remove()\n   private static boolean useCache = true;\n \n   private static Iterator getReadersByFilter(Class type,\n-                                             ServiceRegistry.Filter filter)\n+                                             ServiceRegistry.Filter filter,\n+                                             Object readerExtension)\n   {\n     try\n       {\n         Iterator it = getRegistry().getServiceProviders(type, filter, true);\n-        return new ImageReaderIterator(it);\n+        return new ImageReaderIterator(it, readerExtension);\n       }\n     catch (IllegalArgumentException e)\n       {\n@@ -288,12 +304,13 @@ private static Iterator getReadersByFilter(Class type,\n   }\n   \n   private static Iterator getWritersByFilter(Class type,\n-\t\t\t\t\t     ServiceRegistry.Filter filter)\n+\t\t\t\t\t     ServiceRegistry.Filter filter,\n+                                             Object writerExtension)\n   {\n     try\n       {\n         Iterator it = getRegistry().getServiceProviders(type, filter, true);\n-        return new ImageWriterIterator(it);\n+        return new ImageWriterIterator(it, writerExtension);\n       }\n     catch (IllegalArgumentException e)\n       {\n@@ -312,7 +329,8 @@ public static Iterator getImageReadersByFormatName(String formatName)\n       throw new IllegalArgumentException(\"formatName may not be null\");\n \n     return getReadersByFilter(ImageReaderSpi.class,\n-                              new ReaderFormatFilter(formatName));\n+                              new ReaderFormatFilter(formatName),\n+                              formatName);\n   }\n \n   public static Iterator getImageReadersByMIMEType(String MIMEType)\n@@ -321,7 +339,8 @@ public static Iterator getImageReadersByMIMEType(String MIMEType)\n       throw new IllegalArgumentException(\"MIMEType may not be null\");\n \n     return getReadersByFilter(ImageReaderSpi.class,\n-                              new ReaderMIMETypeFilter(MIMEType));\n+                              new ReaderMIMETypeFilter(MIMEType),\n+                              MIMEType);\n   }\n \n   public static Iterator getImageReadersBySuffix(String fileSuffix)\n@@ -330,7 +349,8 @@ public static Iterator getImageReadersBySuffix(String fileSuffix)\n       throw new IllegalArgumentException(\"formatName may not be null\");\n     \n     return getReadersByFilter(ImageReaderSpi.class,\n-                              new ReaderSuffixFilter(fileSuffix));\n+                              new ReaderSuffixFilter(fileSuffix),\n+                              fileSuffix);\n   }\n \n   public static Iterator getImageWritersByFormatName(String formatName)\n@@ -339,7 +359,8 @@ public static Iterator getImageWritersByFormatName(String formatName)\n       throw new IllegalArgumentException(\"formatName may not be null\");\n     \n     return getWritersByFilter(ImageWriterSpi.class,\n-                              new WriterFormatFilter(formatName));\n+                              new WriterFormatFilter(formatName),\n+                              formatName);\n   }\n \n   public static Iterator getImageWritersByMIMEType(String MIMEType)\n@@ -348,7 +369,8 @@ public static Iterator getImageWritersByMIMEType(String MIMEType)\n       throw new IllegalArgumentException(\"MIMEType may not be null\");\n     \n     return getWritersByFilter(ImageWriterSpi.class,\n-                              new WriterMIMETypeFilter(MIMEType));\n+                              new WriterMIMETypeFilter(MIMEType),\n+                              MIMEType);\n   }\n \n   public static Iterator getImageWritersBySuffix(String fileSuffix)\n@@ -357,7 +379,8 @@ public static Iterator getImageWritersBySuffix(String fileSuffix)\n       throw new IllegalArgumentException(\"fileSuffix may not be null\");\n     \n     return getWritersByFilter(ImageWriterSpi.class,\n-                              new WriterSuffixFilter(fileSuffix));\n+                              new WriterSuffixFilter(fileSuffix),\n+                              fileSuffix);\n   }\n \n   public static String[] getReaderFormatNames()\n@@ -496,4 +519,87 @@ public static void setUseCache(boolean useCache)\n   {\n     ImageIO.useCache = useCache;\n   }\n+\n+  /* \n+   * \"Standard\" simplified entry points.\n+   */\n+\n+  public static boolean write(RenderedImage im,\n+                              String formatName,\n+                              File output)\n+    throws IOException\n+  {\n+    return write(im, formatName, new FileOutputStream(output));\n+  }\n+\n+  public static boolean write(RenderedImage im,\n+                              String formatName,\n+                              OutputStream output)\n+    throws IOException\n+  {\n+    return write(im, formatName, new MemoryCacheImageOutputStream(output));\n+  }\n+  \n+  \n+  public static boolean write(RenderedImage im,\n+                              String formatName,\n+                              ImageOutputStream output)\n+    throws IOException\n+  {\n+    Iterator writers = getImageWritersByFormatName(formatName);\n+    IIOImage img = new IIOImage(im, null, null);\n+    while (writers.hasNext())\n+      {\n+        ImageWriter w = (ImageWriter) writers.next();\n+        try \n+          {\n+            w.setOutput(output);\n+          }\n+        catch (IllegalArgumentException e)\n+          {\n+            continue;\n+          }\n+        \n+        w.write(null, img, null);\n+        output.close();\n+        return true;\n+      }\n+    return false;\n+  }\n+\n+  public static BufferedImage read(ImageInputStream stream)\n+    throws IOException\n+  {\n+    Iterator providers = getRegistry().getServiceProviders(ImageReaderSpi.class, true);\n+    while (providers.hasNext())\n+      {\n+        ImageReaderSpi spi = (ImageReaderSpi) providers.next();\n+        if (spi.canDecodeInput(stream))\n+          {\n+            ImageReader reader = spi.createReaderInstance();\n+            reader.setInput(stream);\n+            return reader.read(0, null);\n+          }\n+      }\n+    return null;\n+  }\n+        \n+  public static BufferedImage read(URL input)\n+    throws IOException\n+  {\n+    return read(input.openStream());\n+  }\n+\n+  public static BufferedImage read(InputStream input)\n+    throws IOException\n+  {\n+    return read(new MemoryCacheImageInputStream(input));\n+  }\n+\n+  public static BufferedImage read(File input)\n+    throws IOException\n+  {\n+    return read(new FileInputStream(input));\n+  }\n+\n }"}, {"sha": "4192c563b14a172ef64307b62ab8247748a25117", "filename": "libjava/javax/imageio/ImageReadParam.java", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2FImageReadParam.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2FImageReadParam.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2FImageReadParam.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -94,6 +94,22 @@ public Dimension getSourceRenderSize()\n   {\n     return sourceRenderSize;\n   }\n+\n+  public void setDestination(BufferedImage destination)\n+  {\n+    this.destination = destination;\n+  }\n+\n+  public void setDestinationBands(int[] destinationBands)\n+  {\n+    this.destinationBands = destinationBands;\n+  }\n+\n+  public void setSourceProgressivePasses(int minPass, int numPasses)\n+  {\n+    this.minProgressivePass = minPass;\n+    this.numProgressivePasses = numPasses;\n+  }\n   \n   public void setSourceRenderSize(Dimension size)\n     throws UnsupportedOperationException"}, {"sha": "6e5a1b2d87e98081ef277226eb90e3545871c8d7", "filename": "libjava/javax/imageio/ImageReader.java", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2FImageReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2FImageReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2FImageReader.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -51,6 +51,7 @@\n import javax.imageio.event.IIOReadWarningListener;\n import javax.imageio.metadata.IIOMetadata;\n import javax.imageio.spi.ImageReaderSpi;\n+import javax.imageio.stream.ImageInputStream;\n \n public abstract class ImageReader\n {\n@@ -62,7 +63,7 @@\n   protected Locale locale;\n   protected int minIndex;\n   protected ImageReaderSpi originatingProvider;\n-  protected List progressListeners;\n+  protected List progressListeners = new ArrayList();\n   protected boolean seekForwardOnly;\n   protected List updateListeners = new ArrayList();\n   protected List warningListeners = new ArrayList();\n@@ -156,6 +157,42 @@ public abstract IIOMetadata getImageMetadata(int imageIndex)\n   public abstract Iterator getImageTypes(int imageIndex)\n     throws IOException;\n \n+  public void setInput(Object input,\n+                       boolean seekForwardOnly,\n+                       boolean ignoreMetadata)\n+  {\n+    Class[] okClasses = originatingProvider.getInputTypes();\n+    if (okClasses == null)\n+      {\n+        if (!(input instanceof ImageInputStream))\n+          throw new IllegalArgumentException();\n+      }\n+    else\n+      {\n+        boolean classOk = false;\n+        for (int i = 0; i < okClasses.length; ++i)\n+          if (okClasses[i].isInstance(input))\n+            classOk = true;\n+        if (!classOk)\n+          throw new IllegalArgumentException();\n+      }\n+\n+    this.input = input;\n+    this.seekForwardOnly = seekForwardOnly;\n+    this.ignoreMetadata = ignoreMetadata;\n+    this.minIndex = 0;\n+  }\n+\n+  public void setInput(Object in, boolean seekForwardOnly)\n+  {\n+    setInput(in, seekForwardOnly, false);\n+  }\n+\n+  public void setInput(Object in)\n+  {\n+    setInput(in, false, false);\n+  }\n+\n   public Object getInput()\n   {\n     return input;"}, {"sha": "389ca4360a703ef718f0815c6e4c6dd90083a88f", "filename": "libjava/javax/imageio/ImageWriter.java", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2FImageWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2FImageWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2FImageWriter.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -40,6 +40,7 @@\n \n import java.awt.Dimension;\n import java.io.IOException;\n+import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Locale;\n@@ -59,9 +60,9 @@\n   protected Locale locale;\n   protected ImageWriterSpi originatingProvider;\n   protected Object output;\n-  protected List progressListeners;\n-  protected List warningListeners;\n-  protected List warningLocales;\n+  protected List progressListeners = new ArrayList();\n+  protected List warningListeners = new ArrayList();\n+  protected List warningLocales = new ArrayList();\n \n   protected ImageWriter(ImageWriterSpi originatingProvider)\n   {\n@@ -371,11 +372,11 @@ public void setOutput(Object output)\n \n \tif (originatingProvider != null)\n \t  types = originatingProvider.getOutputTypes();\n-\t\n+        \n \tif (types != null)\n \t  for (int i = types.length - 1; i >= 0; --i)\n-\t    if (types[i].equals(output.getClass()))\n-\t      found = true;\n+            if (types[i].isInstance(output))\n+              found = true;\n \n \tif (! found)\n \t  throw new IllegalArgumentException(\"output type not available\");"}, {"sha": "c041d396b1a6544cd5c6f8d15b2914936bb90061", "filename": "libjava/javax/imageio/metadata/IIOAttr.java", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIOAttr.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIOAttr.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIOAttr.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -0,0 +1,378 @@\n+/* IIOAttr.java --\n+   Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio.metadata;\n+\n+import org.w3c.dom.Attr;\n+import org.w3c.dom.DOMException;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.w3c.dom.TypeInfo;\n+import org.w3c.dom.UserDataHandler;\n+\n+/**\n+ * Simple Attr node for metadata trees\n+ * \n+ * @author jlquinn\n+ */\n+class IIOAttr implements Attr\n+{\n+  String name;\n+  String value;\n+  IIOMetadataNode owner;\n+  \n+  public IIOAttr(String name, String value, IIOMetadataNode owner)\n+  {\n+    this.name = name;\n+    this.value = value;\n+    this.owner = owner;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Attr#getName()\n+   */\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  public TypeInfo getSchemaTypeInfo()\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Attr#getSpecified()\n+   */\n+  public boolean getSpecified()\n+  {\n+    // I don't think there can be default attrs in metadata\n+    return true;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Attr#getValue()\n+   */\n+  public String getValue()\n+  {\n+    return value;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Attr#setValue(java.lang.String)\n+   */\n+  public void setValue(String value) throws DOMException\n+  {\n+    this.value = value;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Attr#getOwnerElement()\n+   */\n+  public Element getOwnerElement()\n+  {\n+    return owner;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getNodeName()\n+   */\n+  public String getNodeName()\n+  {\n+    return name;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getNodeValue()\n+   */\n+  public String getNodeValue() throws DOMException\n+  {\n+    return value;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#setNodeValue(java.lang.String)\n+   */\n+  public void setNodeValue(String nodeValue) throws DOMException\n+  {\n+    this.value = nodeValue;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getNodeType()\n+   */\n+  public short getNodeType()\n+  {\n+    return ATTRIBUTE_NODE;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getParentNode()\n+   */\n+  public Node getParentNode()\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getChildNodes()\n+   */\n+  public NodeList getChildNodes()\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getFirstChild()\n+   */\n+  public Node getFirstChild()\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getLastChild()\n+   */\n+  public Node getLastChild()\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getPreviousSibling()\n+   */\n+  public Node getPreviousSibling()\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getNextSibling()\n+   */\n+  public Node getNextSibling()\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getAttributes()\n+   */\n+  public NamedNodeMap getAttributes()\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getOwnerDocument()\n+   */\n+  public Document getOwnerDocument()\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#insertBefore(org.w3c.dom.Node, org.w3c.dom.Node)\n+   */\n+  public Node insertBefore(Node newChild, Node refChild) throws DOMException\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#replaceChild(org.w3c.dom.Node, org.w3c.dom.Node)\n+   */\n+  public Node replaceChild(Node newChild, Node oldChild) throws DOMException\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#removeChild(org.w3c.dom.Node)\n+   */\n+  public Node removeChild(Node oldChild) throws DOMException\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#appendChild(org.w3c.dom.Node)\n+   */\n+  public Node appendChild(Node newChild) throws DOMException\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#hasChildNodes()\n+   */\n+  public boolean hasChildNodes()\n+  {\n+    return false;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#cloneNode(boolean)\n+   */\n+  public Node cloneNode(boolean deep)\n+  {\n+    return new IIOAttr(name, value, owner);\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#normalize()\n+   */\n+  public void normalize()\n+  {\n+  }\n+\n+  public boolean isDefaultNamespace(String namespaceURI)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#isSupported(java.lang.String, java.lang.String)\n+   */\n+  public boolean isSupported(String feature, String version)\n+  {\n+    return false;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getNamespaceURI()\n+   */\n+  public String getNamespaceURI()\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getPrefix()\n+   */\n+  public String getPrefix()\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#setPrefix(java.lang.String)\n+   */\n+  public void setPrefix(String prefix) throws DOMException\n+  {\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getLocalName()\n+   */\n+  public String getLocalName()\n+  {\n+    return name;\n+  }\n+\n+  public Object getUserData(String key)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#hasAttributes()\n+   */\n+  public boolean hasAttributes()\n+  {\n+    return false;\n+  }\n+\n+  public boolean isId()\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public String lookupNamespaceURI(String prefix)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public String lookupPrefix(String namespaceURI)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+  \n+  public Object setUserData(String key, Object data, UserDataHandler handler)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public String getBaseURI()\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public String getTextContent()\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public void setTextContent(String textContent)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public short compareDocumentPosition(Node other)\n+    throws DOMException\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public Object getFeature(String feature, String version)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+  \n+  public boolean isEqualNode(Node other)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+  \n+  public boolean isSameNode(Node other)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+}"}, {"sha": "af84f0732c28fe2125d9d18de2e8d961363fcd31", "filename": "libjava/javax/imageio/metadata/IIOInvalidTreeException.java", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIOInvalidTreeException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIOInvalidTreeException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIOInvalidTreeException.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -40,23 +40,28 @@\n \n import javax.imageio.IIOException;\n \n+import org.w3c.dom.Node;\n+\n public class IIOInvalidTreeException extends IIOException\n {\n-  protected /*Node*/ Object offendingNode;\n+  private static final long serialVersionUID = -1314083172544132777L;\n+\n+  protected Node offendingNode;\n \n-  public IIOInvalidTreeException(String message, /*Node*/ Object offendingNode)\n+  public IIOInvalidTreeException(String message, Node offendingNode)\n   {\n     super(message);\n     this.offendingNode = offendingNode;\n   }\n \n-  public IIOInvalidTreeException(String message, Throwable cause, /*Node*/ Object offendingNode)\n+  public IIOInvalidTreeException(String message, Throwable cause,\n+\t\t\t\t Node offendingNode)\n   {\n     super(message, cause);\n     this.offendingNode = offendingNode;\n   }\n \n-  public /*Node*/ Object getOffendingNode()\n+  public Node getOffendingNode()\n   {\n     return offendingNode;\n   }"}, {"sha": "609db4d782311cc7af2089cbcc2cd46ef404e171", "filename": "libjava/javax/imageio/metadata/IIOMetadataNode.java", "status": "modified", "additions": 549, "deletions": 0, "changes": 549, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIOMetadataNode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIOMetadataNode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIOMetadataNode.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -38,6 +38,555 @@\n \n package javax.imageio.metadata;\n \n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.w3c.dom.Attr;\n+import org.w3c.dom.DOMException;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.w3c.dom.TypeInfo;\n+import org.w3c.dom.UserDataHandler;\n+\n public class IIOMetadataNode\n+  implements Element, NodeList\n {\n+  private String name;\n+  private HashMap attrs = new HashMap();\n+  private List children = new ArrayList();\n+  private IIOMetadataNode parent;\n+  private Object obj;\n+  \n+  public IIOMetadataNode()\n+  {\n+    // Do nothing here.\n+  }\n+  \n+  public IIOMetadataNode(String nodename)\n+  {\n+    name = nodename;\n+  }\n+  \n+  public Object getUserObject()\n+  {\n+    return obj;\n+  }\n+  \n+  public void setUserObject(Object o)\n+  {\n+    obj = o;\n+  }\n+  \n+  public short compareDocumentPosition(Node other)\n+    throws DOMException\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#getAttribute(java.lang.String)\n+   */\n+  public String getAttribute(String name)\n+  {\n+    Attr anode = (Attr) attrs.get(name);\n+    return anode != null ? anode.getValue() : null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#getAttributeNode(java.lang.String)\n+   */\n+  public Attr getAttributeNode(String name)\n+  {\n+    String val = getAttribute(name);\n+    if (val != null)\n+      return new IIOAttr(name, val, this);\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#getAttributeNodeNS(java.lang.String, java.lang.String)\n+   */\n+  public Attr getAttributeNodeNS(String namespaceURI, String localName)\n+  {\n+    return getAttributeNode(localName);\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#getAttributeNS(java.lang.String, java.lang.String)\n+   */\n+  public String getAttributeNS(String namespaceURI, String localName)\n+  {\n+    return getAttribute(localName);\n+  }\n+\n+  public String getBaseURI()\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  // Recursive function for assembling a node list.\n+  private void getElementsRecurse(IIONodeList list, String name)\n+  {\n+    for (int i=0; i < children.size(); i++)\n+    {\n+      if (((Node)children.get(i)).getNodeName().equals(name))\n+        list.children.add(children.get(i));\n+      getElementsRecurse(list, name);\n+    }\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#getElementsByTagName(java.lang.String)\n+   */\n+  public NodeList getElementsByTagName(String name)\n+  {\n+    IIONodeList list = new IIONodeList();\n+    getElementsRecurse(list, name);\n+    return list;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#getElementsByTagNameNS(java.lang.String, java.lang.String)\n+   */\n+  public NodeList getElementsByTagNameNS(String namespaceURI, String localName)\n+  {\n+    IIONodeList list = new IIONodeList();\n+    getElementsRecurse(list, name);\n+    return list;\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#getTagName()\n+   */\n+  public String getTagName()\n+  {\n+    return name;\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#hasAttribute(java.lang.String)\n+   */\n+  public boolean hasAttribute(String name)\n+  {\n+    return attrs.containsKey(name);\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#hasAttributeNS(java.lang.String, java.lang.String)\n+   */\n+  public boolean hasAttributeNS(String namespaceURI, String localName)\n+  {\n+    return attrs.containsKey(localName);\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#removeAttribute(java.lang.String)\n+   */\n+  public void removeAttribute(String name)\n+  {\n+    attrs.remove(name);\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#removeAttributeNode(org.w3c.dom.Attr)\n+   */\n+  public Attr removeAttributeNode(Attr oldAttr)\n+  {\n+    return (Attr)attrs.remove(oldAttr.getName());\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#removeAttributeNS(java.lang.String, java.lang.String)\n+   */\n+  public void removeAttributeNS(String namespaceURI, String localName)\n+  {\n+    removeAttribute(localName);\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#setAttribute(java.lang.String, java.lang.String)\n+   */\n+  public void setAttribute(String name, String value)\n+  {\n+    Attr attr = (Attr) getAttributeNode(name);\n+    if (attr != null)\n+      attr.setValue(value);\n+    else\n+      attrs.put(name, new IIOAttr(name, value, this));\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#setAttributeNode(org.w3c.dom.Attr)\n+   */\n+  public Attr setAttributeNode(Attr newAttr)\n+  {\n+    return (Attr)attrs.put(newAttr.getName(), newAttr);\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#setAttributeNodeNS(org.w3c.dom.Attr)\n+   */\n+  public Attr setAttributeNodeNS(Attr newAttr)\n+  {\n+    return (Attr)attrs.put(newAttr.getName(), newAttr);\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Element#setAttributeNS(java.lang.String, java.lang.String, java.lang.String)\n+   */\n+  public void setAttributeNS(String namespaceURI, String qualifiedName, String value)\n+  {\n+    setAttribute(qualifiedName, value);    \n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.NodeList#getLength()\n+   */\n+  public int getLength()\n+  {\n+    return children.size();\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.NodeList#item(int)\n+   */\n+  public Node item(int index)\n+  {\n+    if (index < children.size())\n+      return (Node)children.get(index);\n+    else\n+      return null;\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#appendChild(org.w3c.dom.Node)\n+   */\n+  public Node appendChild(Node newChild)\n+  {\n+    if (newChild == null)\n+      throw new IllegalArgumentException(\"Child node is null\");\n+    \n+    IIOMetadataNode child = (IIOMetadataNode) newChild;\n+    \n+    children.add(child);\n+    child.parent = this;\n+    return this;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#cloneNode(boolean)\n+   */\n+  public Node cloneNode(boolean deep)\n+  {\n+    IIOMetadataNode newnode = new IIOMetadataNode(name);\n+    newnode.parent = null;\n+    newnode.obj = obj;\n+    if (deep)\n+    {\n+      for (int i=0; i < children.size(); i++)\n+        newnode.children.add(((Node)children.get(i)).cloneNode(deep));\n+    }\n+    \n+    // clone attrs\n+    for (Iterator it = attrs.values().iterator(); it.hasNext();)\n+    {\n+      IIOAttr attr = (IIOAttr)it.next();\n+      newnode.attrs.put(attr.name, attr.cloneNode(deep));\n+      attr.owner = newnode;\n+    }\n+\n+    return newnode;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getAttributes()\n+   */\n+  public NamedNodeMap getAttributes()\n+  {\n+    return new IIONamedNodeMap(attrs);\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getChildNodes()\n+   */\n+  public NodeList getChildNodes()\n+  {\n+    return this;\n+  }\n+\n+  public Object getFeature(String feature, String version)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getFirstChild()\n+   */\n+  public Node getFirstChild()\n+  {\n+    return (children.size() > 0) ? (Node)children.get(0) : null;\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getLastChild()\n+   */\n+  public Node getLastChild()\n+  {\n+    return (children.size() > 0) ? (Node)children.get(children.size() - 1)\n+           : null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getLocalName()\n+   */\n+  public String getLocalName()\n+  {\n+    return name;\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getNamespaceURI()\n+   */\n+  public String getNamespaceURI()\n+  {\n+    return null;\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getNextSibling()\n+   */\n+  public Node getNextSibling()\n+  {\n+    // If this op needs to be faster, add links to prev and next nodes.\n+    if (parent == null) return null;\n+    int idx = parent.children.indexOf(this);\n+    return (idx == parent.children.size() - 1) ? null\n+        : (Node)parent.children.get(idx + 1);\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getNodeName()\n+   */\n+  public String getNodeName()\n+  {\n+    return name;\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getNodeType()\n+   */\n+  public short getNodeType()\n+  {\n+    return ELEMENT_NODE;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getNodeValue()\n+   */\n+  public String getNodeValue()\n+  {\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getOwnerDocument()\n+   */\n+  public Document getOwnerDocument()\n+  {\n+    // IOMetadataNodes have no owner\n+    return null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getParentNode()\n+   */\n+  public Node getParentNode()\n+  {\n+    return parent;\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getPrefix()\n+   */\n+  public String getPrefix()\n+  {\n+    return null;\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#getPreviousSibling()\n+   */\n+  public Node getPreviousSibling()\n+  {\n+    // If this op needs to be faster, add links to prev and next nodes.\n+    if (parent == null) return null;\n+    int idx = parent.children.indexOf(this);\n+    return (idx == 0) ? null\n+        : (Node)parent.children.get(idx - 1);\n+  }\n+\n+  public TypeInfo getSchemaTypeInfo()\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public String getTextContent()\n+    throws DOMException\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public Object getUserData(String key)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#hasAttributes()\n+   */\n+  public boolean hasAttributes()\n+  {\n+    return !attrs.isEmpty();\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#hasChildNodes()\n+   */\n+  public boolean hasChildNodes()\n+  {\n+    return !children.isEmpty();\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#insertBefore(org.w3c.dom.Node, org.w3c.dom.Node)\n+   */\n+  public Node insertBefore(Node newChild, Node refChild)\n+  {\n+    if (newChild == null)\n+      throw new IllegalArgumentException();\n+    \n+    int idx = children.indexOf(refChild);\n+    if (idx == -1)\n+      children.add(newChild);\n+    else\n+      children.add(idx, newChild);\n+    ((IIOMetadataNode)newChild).parent = this;\n+    \n+    return newChild;\n+  }\n+\n+  public boolean isDefaultNamespace(String namespaceURI)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public boolean isEqualNode(Node arg)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+  \n+  public boolean isSameNode(Node other)\n+  {\n+    return this == other;\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#isSupported(java.lang.String, java.lang.String)\n+   */\n+  public boolean isSupported(String feature, String version)\n+  {\n+    // No DOM features are supported\n+    return false;\n+  }\n+  \n+  public String lookupNamespaceURI(String prefix)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+  \n+  public String lookupPrefix(String namespaceURI)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#normalize()\n+   */\n+  public void normalize()\n+  {\n+    // No text nodes so no action\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#removeChild(org.w3c.dom.Node)\n+   */\n+  public Node removeChild(Node oldChild)\n+  {\n+    if (oldChild == null)\n+      throw new IllegalArgumentException();\n+    children.remove(oldChild);\n+    ((IIOMetadataNode)oldChild).parent = null;\n+\n+    return oldChild;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#replaceChild(org.w3c.dom.Node, org.w3c.dom.Node)\n+   */\n+  public Node replaceChild(Node newChild, Node oldChild)\n+  {\n+    if (newChild == null)\n+      throw new IllegalArgumentException();\n+    children.set(children.indexOf(oldChild), newChild);\n+    ((IIOMetadataNode)oldChild).parent = null;\n+    return oldChild;\n+  }\n+  \n+  public void setIdAttribute(String name, boolean isId)\n+    throws DOMException\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public void setIdAttributeNode(Attr idAttr, boolean isId)\n+    throws DOMException\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public void setIdAttributeNS(String namespaceURI, String localName, boolean isId)\n+    throws DOMException\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#setNodeValue(java.lang.String)\n+   */\n+  public void setNodeValue(String nodeValue) throws DOMException\n+  {\n+  }\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.Node#setPrefix(java.lang.String)\n+   */\n+  public void setPrefix(String prefix)\n+  {\n+  }\n+\n+  public void setTextContent(String textContent)\n+    throws DOMException\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n+  \n+  public Object setUserData(String key, Object data, UserDataHandler handler)\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n }"}, {"sha": "e549c1cf06fb48b7e81dc4b8596200a753e45ebf", "filename": "libjava/javax/imageio/metadata/IIONamedNodeMap.java", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIONamedNodeMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIONamedNodeMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIONamedNodeMap.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -0,0 +1,138 @@\n+/* IIONamedNodeMap.java --\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.imageio.metadata;\n+\n+import java.util.HashMap;\n+\n+import org.w3c.dom.DOMException;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+\n+/**\n+ * Simple NamedNodeMap class for IIOMetadataNode.\n+ *\n+ * @author jlquinn\n+ */\n+class IIONamedNodeMap implements NamedNodeMap\n+{\n+  HashMap attrs;\n+\n+  /**\n+   * @param attrs\n+   * @param node\n+   */\n+  public IIONamedNodeMap(HashMap attrs)\n+  {\n+    this.attrs = attrs;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.NamedNodeMap#getNamedItem(java.lang.String)\n+   */\n+  public Node getNamedItem(String name)\n+  {\n+    return (Node)attrs.get(name);\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.NamedNodeMap#setNamedItem(org.w3c.dom.Node)\n+   */\n+  public Node setNamedItem(Node arg) throws DOMException\n+  {\n+    if (arg instanceof IIOAttr)\n+    {\n+      IIOAttr attr = (IIOAttr) arg;\n+      // The only code that can successfully do this is in this package.\n+      if (attr.owner != null)\n+        throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR, \"\");\n+      return (Node)attrs.put(attr.name, attr);\n+    }\n+    // Anything else gets treated as an invalid op.\n+    throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, \"\");\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.NamedNodeMap#removeNamedItem(java.lang.String)\n+   */\n+  public Node removeNamedItem(String name) throws DOMException\n+  {\n+    return (Node)attrs.remove(name);\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.NamedNodeMap#item(int)\n+   */\n+  public Node item(int index)\n+  {\n+    return (Node)attrs.values().toArray()[index];\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.NamedNodeMap#getLength()\n+   */\n+  public int getLength()\n+  {\n+    return attrs.size();\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.NamedNodeMap#getNamedItemNS(java.lang.String, java.lang.String)\n+   */\n+  public Node getNamedItemNS(String namespaceURI, String localName)\n+  {\n+    return getNamedItem(localName);\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.NamedNodeMap#setNamedItemNS(org.w3c.dom.Node)\n+   */\n+  public Node setNamedItemNS(Node arg) throws DOMException\n+  {\n+    return setNamedItem(arg);\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.NamedNodeMap#removeNamedItemNS(java.lang.String, java.lang.String)\n+   */\n+  public Node removeNamedItemNS(String namespaceURI, String localName)\n+      throws DOMException\n+  {\n+    return removeNamedItem(localName);\n+  }\n+\n+}"}, {"sha": "4ef7f4cbe81566f7a1c4f224b12ea76797734609", "filename": "libjava/javax/imageio/metadata/IIONodeList.java", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIONodeList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIONodeList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fmetadata%2FIIONodeList.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -0,0 +1,72 @@\n+/* IIOAttr.java --\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.imageio.metadata;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * Simple NodeList implementation for IIOMetadataNode.\n+ *\n+ * @author jlquinn\n+ *\n+ */\n+class IIONodeList implements NodeList\n+{\n+  List children = new ArrayList();\n+  \n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.NodeList#item(int)\n+   */\n+  public Node item(int index)\n+  {\n+    return (index < children.size()) ? (Node)children.get(index) : null;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see org.w3c.dom.NodeList#getLength()\n+   */\n+  public int getLength()\n+  {\n+    return children.size();\n+  }\n+\n+}"}, {"sha": "6531fabca104fb11b9c8266a42a5bde0ec5aa81c", "filename": "libjava/javax/imageio/spi/IIORegistry.java", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fspi%2FIIORegistry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fspi%2FIIORegistry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fspi%2FIIORegistry.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -39,7 +39,9 @@\n package javax.imageio.spi;\n \n import gnu.classpath.ServiceFactory;\n+import gnu.java.awt.ClasspathToolkit;\n \n+import java.awt.Toolkit;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n@@ -52,8 +54,8 @@ public final class IIORegistry extends ServiceRegistry\n \n   static\n   {\n-    //defaultCategories.add(ImageReaderSpi.class);\n-    //defaultCategories.add(ImageWriterSpi.class);\n+    defaultCategories.add(ImageReaderSpi.class);\n+    defaultCategories.add(ImageWriterSpi.class);\n     defaultCategories.add(ImageTranscoderSpi.class);\n     defaultCategories.add(ImageInputStreamSpi.class);\n     defaultCategories.add(ImageOutputStreamSpi.class);\n@@ -78,6 +80,8 @@ private IIORegistry()\n     super(defaultCategories.iterator());\n \n     // XXX: Register built-in Spis here.\n+\n+    ((ClasspathToolkit)Toolkit.getDefaultToolkit()).registerImageIOSpis(this);\n     \n     registerApplicationClasspathSpis();\n   }"}, {"sha": "a8db4779bba830756e971d8a657251b8b1319455", "filename": "libjava/javax/imageio/stream/FileCacheImageInputStream.java", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FFileCacheImageInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FFileCacheImageInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fstream%2FFileCacheImageInputStream.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -45,7 +45,7 @@\n /**\n  * @author Michael Koch (konqueror@gmx.de)\n  */\n-public class FileCacheImageInputStream\n+public class FileCacheImageInputStream extends ImageInputStreamImpl\n {\n   private InputStream stream;\n   private File cacheDir;\n@@ -90,4 +90,20 @@ public boolean isCachedMemory()\n   {\n     return false;\n   }\n+\n+  public int read()\n+    throws IOException\n+  {\n+    checkStreamClosed();\n+    setBitOffset(0);\n+    return stream.read();\n+  }\n+\n+  public int read(byte[] data, int offset, int len)\n+    throws IOException\n+  {\n+    checkStreamClosed();\n+    setBitOffset(0);\n+    return stream.read(data, offset, len);\n+  }\n }"}, {"sha": "912b368d146fe78bf95f847527b2cf29e1bc32f0", "filename": "libjava/javax/imageio/stream/FileCacheImageOutputStream.java", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FFileCacheImageOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FFileCacheImageOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fstream%2FFileCacheImageOutputStream.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -45,7 +45,7 @@\n /**\n  * @author Michael Koch (konqueror@gmx.de)\n  */\n-public class FileCacheImageOutputStream\n+public class FileCacheImageOutputStream extends ImageOutputStreamImpl\n {\n   private OutputStream stream;\n   private File cacheDir;\n@@ -90,4 +90,34 @@ public boolean isCachedMemory()\n   {\n     return false;\n   }\n+  \n+  public int read()\n+    throws IOException\n+  {\n+    // FIXME: Implement me.\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public int read(byte[] data, int offset, int len)\n+    throws IOException\n+  {\n+    // FIXME: Implement me.\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public void write(byte[] data, int offset, int len)\n+    throws IOException\n+  {\n+    checkStreamClosed();\n+    // FIXME: Flush pending bits.\n+    stream.write(data, offset, len);\n+  }\n+\n+  public void write(int value)\n+    throws IOException\n+  {\n+    checkStreamClosed();\n+    // FIXME: Flush pending bits.\n+    stream.write(value);\n+  }\n }"}, {"sha": "1684632553e77645996eeb456c6438b3c4a51492", "filename": "libjava/javax/imageio/stream/FileImageInputStream.java", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FFileImageInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FFileImageInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fstream%2FFileImageInputStream.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -46,7 +46,7 @@\n /**\n  * @author Michael Koch (konqueror@gmx.de)\n  */\n-public class FileImageInputStream\n+public class FileImageInputStream extends ImageInputStreamImpl\n {\n   private RandomAccessFile file;\n   \n@@ -84,4 +84,25 @@ public long length()\n         return -1L;\n       }\n   }\n+\n+  public int read()\n+    throws IOException\n+  {\n+    setBitOffset(0);\n+    return file.read();\n+  }\n+\n+  public int read(byte[] data, int offset, int len)\n+    throws IOException\n+  {\n+    setBitOffset(0);\n+    return file.read(data, offset, len);\n+  }\n+\n+  public void seek(long position)\n+    throws IOException\n+  {\n+    super.seek(position);\n+    file.seek(position);\n+  }\n }"}, {"sha": "5b47af840d4a8c3f33d93d85b9ebf3c30b30f152", "filename": "libjava/javax/imageio/stream/FileImageOutputStream.java", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FFileImageOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FFileImageOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fstream%2FFileImageOutputStream.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -46,7 +46,7 @@\n /**\n  * @author Michael Koch (konqueror@gmx.de)\n  */\n-public class FileImageOutputStream\n+public class FileImageOutputStream extends ImageOutputStreamImpl\n {\n   private RandomAccessFile file;\n   \n@@ -87,4 +87,47 @@ public long length()\n         return -1L;\n       }\n   }\n+\n+  public int read()\n+    throws IOException\n+  {\n+    checkClosed();\n+    \n+    setBitOffset(0);\n+    return file.read();\n+  }\n+\n+  public int read(byte[] data, int offset, int len)\n+    throws IOException\n+  {\n+    checkClosed();\n+    \n+    setBitOffset(0);\n+    return file.read(data, offset, len);\n+  }\n+\n+  public void seek(long position)\n+    throws IOException\n+  {\n+    super.seek(position);\n+    file.seek(position);\n+  }\n+\n+  public void write(byte[] data, int offset, int len)\n+    throws IOException\n+  {\n+    checkClosed();\n+    \n+    flushBits();\n+    file.write(data, offset, len);\n+  }\n+\n+  public void write(int value)\n+    throws IOException\n+  {\n+    checkClosed();\n+    \n+    // FIXME: Flush pending bits.\n+    file.write(value);\n+  }\n }"}, {"sha": "dbe6d1aaab9cef97aab1e37d4faa4e1d84ebbfad", "filename": "libjava/javax/imageio/stream/ImageInputStreamImpl.java", "status": "modified", "additions": 359, "deletions": 1, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FImageInputStreamImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FImageInputStreamImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fstream%2FImageInputStreamImpl.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -38,15 +38,21 @@\n \n package javax.imageio.stream;\n \n+import java.io.DataInputStream;\n+import java.io.EOFException;\n import java.io.IOException;\n import java.nio.ByteOrder;\n+import java.util.Stack;\n \n /**\n  * @author Michael Koch (konqueror@gmx.de)\n  */\n public abstract class ImageInputStreamImpl implements ImageInputStream\n {\n   private boolean closed;\n+  private Stack markStack = new Stack();\n+  \n+  byte[] buffer = new byte[8];\n   \n   protected int bitOffset;\n   protected ByteOrder byteOrder;\n@@ -99,6 +105,7 @@ public void flushBefore(long position)\n   public int getBitOffset()\n     throws IOException\n   {\n+    checkClosed();\n     return bitOffset;\n   }\n \n@@ -115,6 +122,7 @@ public long getFlushedPosition()\n   public long getStreamPosition()\n     throws IOException\n   {\n+    checkClosed();\n     return streamPos;\n   }\n \n@@ -138,6 +146,18 @@ public long length()\n     return -1L;\n   }\n \n+  public void mark()\n+  {\n+    try\n+      {\n+\tmarkStack.push(new Long(getStreamPosition()));\n+      }\n+    catch (IOException e)\n+      {\n+\t// Ignored.\n+      }\n+  }\n+\n   public abstract int read()\n     throws IOException;\n \n@@ -150,8 +170,346 @@ public int read(byte[] data)\n   public abstract int read(byte[] data, int offset, int len)\n     throws IOException;\n \n-  public void setByteOrder (ByteOrder byteOrder)\n+  public int readBit()\n+    throws IOException\n+  {\n+    checkClosed();\n+\n+    // Calc new bit offset here, readByte resets it.\n+    int newOffset = (bitOffset + 1) & 0x7;\n+\n+    byte data = readByte();\n+    \n+    if (bitOffset != 0)\n+      {\n+\tseek(getStreamPosition() - 1);\n+\tdata = (byte) (data >> (8 - newOffset));\n+      }\n+\n+    bitOffset = newOffset;\n+    return data & 0x1;\n+  }\n+\n+  public long readBits(int numBits)\n+    throws IOException\n+  {\n+    checkClosed();\n+\n+    if (numBits < 0 || numBits > 64)\n+      throw new IllegalArgumentException();\n+\n+    if (numBits == 0)\n+      return 0L;\n+\n+    long bits = 0L;\n+    \n+    for (int i = 0; i < numBits; i++)\n+      {\n+\tbits <<= 1;\n+\tbits |= readBit();\n+      }\n+\n+    return bits;\n+  }\n+\n+  public boolean readBoolean()\n+    throws IOException\n+  {\n+    byte data = readByte();\n+    return data != 0;\n+  }\n+\n+  public byte readByte()\n+    throws IOException\n+  {\n+    int data = read();\n+\n+    if (data == -1)\n+      throw new EOFException();\n+\n+    return (byte) data;\n+  }\n+\n+  public void readBytes(IIOByteBuffer buffer, int len)\n+    throws IOException\n+  {\n+    int result = read(buffer.getData(), buffer.getOffset(), len);\n+    \n+    if (result == -1 || result < len)\n+      throw new EOFException();\n+\n+    buffer.setLength(len);\n+  }\n+\n+  public char readChar()\n+    throws IOException\n+  {\n+    return (char) readShort();\n+  }\n+\n+  public double readDouble()\n+    throws IOException\n+  {\n+    return (double) readLong();\n+  }\n+\n+  public float readFloat()\n+    throws IOException\n+  {\n+    return (float) readInt();\n+  }\n+\n+  public void readFully(byte[] data)\n+    throws IOException\n+  {\n+    readFully(data, 0, data.length);\n+  }\n+\n+  public void readFully(byte[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for (int i = 0; i < len; ++i)\n+      data[offset + i] = readByte();\n+  }\n+\n+  public void readFully(char[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for (int i = 0; i < len; ++i)\n+      data[offset + i] = readChar();\n+  }\n+\n+  public void readFully(double[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for (int i = 0; i < len; ++i)\n+      data[offset + i] = readDouble();\n+  }\n+\n+  public void readFully(float[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for (int i = 0; i < len; ++i)\n+      data[offset + i] = readFloat();\n+  }\n+\n+  public void readFully(int[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for (int i = 0; i < len; ++i)\n+      data[offset + i] = readInt();\n+  }\n+\n+  public void readFully(long[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for (int i = 0; i < len; ++i)\n+      data[offset + i] = readLong();\n+  }\n+\n+  public void readFully(short[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for (int i = 0; i < len; ++i)\n+      data[offset + i] = readShort();\n+  }\n+\n+  public int readInt()\n+    throws IOException\n+  {\n+    int result = read(buffer, 0, 4);\n+\n+    if (result == -1)\n+      throw new EOFException();\n+    \n+    if (getByteOrder() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+\treturn ((buffer[0] & 0xff)\n+\t\t+ (buffer[1] << 8)\n+\t\t+ (buffer[2] << 16)\n+\t\t+ (buffer[3] << 24));\n+      }\n+\n+    return ((buffer[4] << 24)\n+\t    + (buffer[3] << 16)\n+\t    + (buffer[2] << 8)\n+\t    + (buffer[1] & 0xff));\n+  }\n+\n+  public String readLine()\n+    throws IOException\n+  {\n+    checkClosed();\n+\n+    int c = -1;\n+    boolean eol = false;\n+    StringBuffer buffer = new StringBuffer();\n+\n+    while (!eol && (c = read()) != -1)\n+      {\n+\tswitch(c)\n+\t  {\n+\t  case '\\r':\n+\t    // Consume following \\n'\n+\t    long oldPosition = getStreamPosition();\n+\t    if (read() != '\\n')\n+\t       seek(oldPosition);\n+\t  case '\\n':\n+\t    eol = true;\n+\t    break;\n+\t  default:\n+\t    buffer.append((char) c);\n+\t    break;\n+\t  }\n+      }\n+\n+    if (c == -1 && buffer.length() == 0)\n+      return null;\n+\n+    return buffer.toString();\n+  }\n+\n+  public long readLong()\n+    throws IOException\n+  {\n+    int result = read(buffer, 0, 8);\n+\n+    if (result == -1)\n+      throw new EOFException();\n+    \n+    if (getByteOrder() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return ((buffer[0] & 0xff)\n+                + (((buffer[1] & 0xff)) << 8)\n+                + (((buffer[2] & 0xff)) << 16)\n+                + (((buffer[3] & 0xffL)) << 24)\n+                + (((buffer[4] & 0xffL)) << 32)\n+                + (((buffer[5] & 0xffL)) << 40)\n+                + (((buffer[6] & 0xffL)) << 48)\n+                + (((long) buffer[7]) << 56));\n+      }\n+\n+    return ((((long) buffer[7]) << 56)\n+            + ((buffer[6] & 0xffL) << 48)\n+            + ((buffer[5] & 0xffL) << 40)\n+            + ((buffer[4] & 0xffL) << 32)\n+            + ((buffer[3] & 0xffL) << 24)\n+            + ((buffer[2] & 0xff) << 16)\n+            + ((buffer[1] & 0xff) << 8)\n+            + (buffer[0] & 0xff));\n+  }\n+\n+  public short readShort()\n+    throws IOException\n+  {\n+    int result = read(buffer, 0, 2);\n+\n+    if (result == -1)\n+      throw new EOFException();\n+    \n+    if (getByteOrder() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+\treturn (short) ((buffer[0] & 0xff)\n+\t\t\t+ (buffer[1] << 8));\n+      }\n+\n+    return (short) ((buffer[0] << 8)\n+\t\t    + (buffer[1] & 0xff));\n+  }\n+\n+  public int readUnsignedByte()\n+    throws IOException\n+  {\n+    return readByte() & 0xff;\n+  }\n+\n+  public long readUnsignedInt()\n+    throws IOException\n+  {\n+    return readInt() & 0xffffffff;\n+  }\n+\n+  public int readUnsignedShort()\n+    throws IOException\n+  {\n+    return readShort() & 0xffff;\n+  }\n+\n+  public String readUTF()\n+    throws IOException\n+  {\n+    checkClosed();\n+\n+    String data;\n+    ByteOrder old = getByteOrder();\n+    setByteOrder(ByteOrder.BIG_ENDIAN); // Strings are always big endian.\n+\n+    try\n+      {\n+\tdata = DataInputStream.readUTF(this);\n+      }\n+    finally\n+      {\n+\tsetByteOrder(old);\n+      }\n+    \n+    return data;\n+  }\n+\n+  public void reset()\n+    throws IOException\n+  {\n+    checkClosed();\n+    \n+    long mark = ((Long) markStack.pop()).longValue();\n+    seek(mark);\n+  }\n+\n+  public void seek(long position)\n+    throws IOException\n+  {\n+    checkClosed();\n+\n+    if (position < getFlushedPosition())\n+      throw new IndexOutOfBoundsException(\"position < flushed position\");\n+\n+    streamPos = position;\n+    bitOffset = 0;\n+  }\n+\n+  public void setBitOffset (int bitOffset)\n+    throws IOException\n+  {\n+    checkClosed();\n+    \n+    if (bitOffset < 0 || bitOffset > 7)\n+      throw new IllegalArgumentException();\n+\n+    this.bitOffset = bitOffset;\n+  }\n+\n+  public void setByteOrder(ByteOrder byteOrder)\n   {\n     this.byteOrder = byteOrder;\n   }\n+\n+  public int skipBytes(int num)\n+    throws IOException\n+  {\n+    checkClosed();\n+    \n+    seek(getStreamPosition() + num);\n+    bitOffset = 0;\n+    return num;\n+  }\n+\n+  public long skipBytes(long num)\n+    throws IOException\n+  {\n+    checkClosed();\n+    \n+    seek(getStreamPosition() + num);\n+    bitOffset = 0;\n+    return num;\n+  }\n }"}, {"sha": "2149255457d7053fcbfd03bd721782163cbead00", "filename": "libjava/javax/imageio/stream/ImageOutputStreamImpl.java", "status": "modified", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FImageOutputStreamImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FImageOutputStreamImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fstream%2FImageOutputStreamImpl.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -39,6 +39,7 @@\n package javax.imageio.stream;\n \n import java.io.IOException;\n+import java.nio.ByteOrder;\n \n /**\n  * @author Michael Koch (konqueror@gmx.de)\n@@ -51,6 +52,13 @@ public ImageOutputStreamImpl()\n     // Do nothing here.\n   }\n \n+  protected void flushBits()\n+    throws IOException\n+  {\n+    // FIXME: Implement me.\n+    throw new Error(\"not implemented\");\n+  }\n+\n   public void write(byte[] data)\n     throws IOException\n   {\n@@ -62,4 +70,176 @@ public abstract void write(byte[] data, int offset, int len)\n \n   public abstract void write(int value)\n     throws IOException;\n+\n+  public void writeBit(int bit)\n+    throws IOException\n+  {\n+    // FIXME: Implement me.\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public void writeBits(long bits, int numBits)\n+    throws IOException\n+  {\n+    // FIXME: Implement me.\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public void writeBoolean(boolean value)\n+    throws IOException\n+  {\n+    writeByte(value ? 1 : 0);\n+  }\n+\n+  public void writeByte(int value)\n+    throws IOException\n+  {\n+    write(value & 0xff);\n+  }\n+\n+  public void writeBytes(String data)\n+    throws IOException\n+  {\n+    write(data.getBytes());\n+  }\n+\n+  public void writeChar(int value)\n+    throws IOException\n+  {\n+    writeShort((short) value);\n+  }\n+\n+  public void writeChars(char[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for(int i = 0; i < len; ++len)\n+      writeChar(data[offset + i]);\n+  }\n+\n+  public void writeChars(String data)\n+    throws IOException\n+  {\n+    // FIXME: Implement me.\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public void writeDouble(double value)\n+    throws IOException\n+  {\n+    writeLong((long) value);\n+  }\n+\n+  public void writeDoubles(double[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for(int i = 0; i < len; ++len)\n+      writeDouble(data[offset + i]);\n+  }\n+  \n+  public void writeFloat(float value)\n+    throws IOException\n+  {\n+    writeInt((int) value);\n+  }\n+  \n+  public void writeFloats(float[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for(int i = 0; i < len; ++len)\n+      writeFloat(data[offset + i]);\n+  }\n+  \n+  public void writeInt(int value)\n+    throws IOException\n+  {\n+    if (getByteOrder() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer[0] = ((byte) value);\n+        buffer[1] = ((byte) (value >> 8));\n+        buffer[2] = ((byte) (value >> 16));\n+        buffer[3] = ((byte) (value >> 24));\n+      }\n+    else\n+      {\n+        buffer[0] = ((byte) (value >> 24));\n+        buffer[1] = ((byte) (value >> 16));\n+        buffer[2] = ((byte) (value >> 8));\n+        buffer[3] = ((byte) value);\n+      }\n+    \n+    write(buffer, 0, 4);\n+  }\n+  \n+  public void writeInts(int[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for(int i = 0; i < len; ++len)\n+      writeInt(data[offset + i]);\n+  }\n+  \n+  public void writeLong(long value)\n+    throws IOException\n+  {\n+    if (getByteOrder() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer[0] = ((byte) value);\n+        buffer[1] = ((byte) (value >> 8));\n+        buffer[2] = ((byte) (value >> 16));\n+        buffer[3] = ((byte) (value >> 24));\n+        buffer[4] = ((byte) (value >> 32));\n+        buffer[5] = ((byte) (value >> 40));\n+        buffer[6] = ((byte) (value >> 48));\n+        buffer[7] = ((byte) (value >> 56));\n+      }\n+    else\n+      {\n+        buffer[0] = ((byte) (value >> 56));\n+        buffer[1] = ((byte) (value >> 48));\n+        buffer[2] = ((byte) (value >> 40));\n+        buffer[3] = ((byte) (value >> 32));\n+        buffer[4] = ((byte) (value >> 24));\n+        buffer[5] = ((byte) (value >> 16));\n+        buffer[6] = ((byte) (value >> 8));\n+        buffer[7] = ((byte) value);\n+      }\n+    \n+    write(buffer, 0, 8);\n+  }\n+  \n+  public void writeLongs(long[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for(int i = 0; i < len; ++len)\n+      writeLong(data[offset + i]);\n+  }\n+  \n+  public void writeShort(int value)\n+    throws IOException\n+  {\n+    if (getByteOrder() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer[0] = ((byte) value);\n+        buffer[1] = ((byte) (value >> 8));\n+      }\n+    else\n+      {\n+        buffer[0] = ((byte) (value >> 8));\n+        buffer[1] = ((byte) value);\n+      }\n+    \n+    write(buffer, 0, 2);\n+  }\n+  \n+  public void writeShorts(short[] data, int offset, int len)\n+    throws IOException\n+  {\n+    for(int i = 0; i < len; ++len)\n+      writeShort(data[offset + i]);\n+  }\n+  \n+  public void writeUTF(String data)\n+    throws IOException\n+  {\n+    throw new Error(\"not implemented\");\n+  }\n }"}, {"sha": "3631e64fc205767fffe711d8eca5912b00c36b92", "filename": "libjava/javax/imageio/stream/MemoryCacheImageInputStream.java", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FMemoryCacheImageInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FMemoryCacheImageInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fstream%2FMemoryCacheImageInputStream.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -38,11 +38,35 @@\n \n package javax.imageio.stream;\n \n+import java.io.IOException;\n+import java.io.InputStream;\n+\n /**\n  * @author Michael Koch (konqueror@gmx.de)\n  */\n-public class MemoryCacheImageInputStream\n+public class MemoryCacheImageInputStream extends ImageInputStreamImpl\n {\n+  private InputStream stream;\n+  \n+  public MemoryCacheImageInputStream(InputStream stream)\n+  {\n+    this.stream = stream;\n+  }\n+\n+  public void close()\n+    throws IOException\n+  {\n+    super.close();\n+    stream.close();\n+  }\n+\n+  public void flushBefore(long position)\n+    throws IOException\n+  {\n+    // FIXME: Implement me.\n+    throw new Error(\"not implemented\");\n+  }\n+\n   public boolean isCached()\n   {\n     return true;\n@@ -57,4 +81,18 @@ public boolean isCachedMemory()\n   {\n     return true;\n   }\n+\n+  public int read()\n+    throws IOException\n+  {\n+    setBitOffset(0);\n+    return stream.read();\n+  }\n+\n+  public int read(byte[] data, int offset, int len)\n+    throws IOException\n+  {\n+    setBitOffset(0);\n+    return stream.read(data, offset, len);\n+  }\n }"}, {"sha": "a21efae984faeae786a5d76419985243665c404d", "filename": "libjava/javax/imageio/stream/MemoryCacheImageOutputStream.java", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FMemoryCacheImageOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7372d214af51c622d77b18b9b51ea58960ab554e/libjava%2Fjavax%2Fimageio%2Fstream%2FMemoryCacheImageOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fstream%2FMemoryCacheImageOutputStream.java?ref=7372d214af51c622d77b18b9b51ea58960ab554e", "patch": "@@ -38,11 +38,35 @@\n \n package javax.imageio.stream;\n \n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n /**\n  * @author Michael Koch (konqueror@gmx.de)\n  */\n-public class MemoryCacheImageOutputStream\n+public class MemoryCacheImageOutputStream extends ImageOutputStreamImpl\n {\n+  private OutputStream stream;\n+\n+  public MemoryCacheImageOutputStream(OutputStream stream)\n+  {\n+    this.stream = stream;\n+  }\n+\n+  public void close()\n+    throws IOException\n+  {\n+    super.close();\n+    stream.close();\n+  }\n+\n+  public void flushBefore(long position)\n+    throws IOException\n+  {\n+    // FIXME: Implement me.\n+    throw new Error(\"not implemented\");\n+  }\n+\n   public boolean isCached()\n   {\n     return true;\n@@ -57,4 +81,32 @@ public boolean isCachedMemory()\n   {\n     return true;\n   }\n+\n+  public int read()\n+    throws IOException\n+  {\n+    // FIXME: Implement me.\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public int read (byte[] data, int offset, int len)\n+    throws IOException\n+  {\n+    // FIXME: Implement me.\n+    throw new Error(\"not implemented\");\n+  }\n+\n+  public void write(byte[] data, int offset, int len)\n+    throws IOException\n+  {\n+    // FIXME: Flush pending bits.\n+    stream.write(data, offset, len);\n+  }\n+\n+  public void write(int value)\n+    throws IOException\n+  {\n+    // FIXME: Flush pending bits.\n+    stream.write(value);\n+  }\n }"}]}