{"sha": "cfc219ae689fd94bbe1bb12686bb04fa09b93046", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZjMjE5YWU2ODlmZDk0YmJlMWJiMTI2ODZiYjA0ZmEwOWI5MzA0Ng==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-10-11T15:53:52Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-10-11T15:53:52Z"}, "message": "Implement <concepts> header for C++20\n\nThere are currently no tests for [concepts.compare], but they will be\nadded ASAP.\n\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/precompiled/stdc++.h: Include <concepts>.\n\t* include/std/concepts: New header for C++20.\n\t* include/std/version (__cpp_lib_concepts): Define.\n\t* scripts/create_testsuite_files: Look for test files in new std\n\tdirectory.\n\t* testsuite/libstdc++-dg/conformance.exp: Likewise.\n\t* testsuite/std/concepts/concepts.callable/invocable.cc: New test.\n\t* testsuite/std/concepts/concepts.callable/regular_invocable.cc: New\n\ttest.\n\t* testsuite/std/concepts/concepts.callable/relation.cc: New test.\n\t* testsuite/std/concepts/concepts.callable/strictweakorder.cc: New\n\ttest.\n\t* testsuite/std/concepts/concepts.lang/concept.arithmetic/\n\tfloating_point.cc: New test.\n\t* testsuite/std/concepts/concepts.lang/concept.arithmetic/integral.cc:\n\tNew test.\n\t* testsuite/std/concepts/concepts.lang/concept.arithmetic/\n\tsigned_integral.cc: New test.\n\t* testsuite/std/concepts/concepts.lang/concept.arithmetic/\n\tunsigned_integral.cc: New test.\n\t* testsuite/std/concepts/concepts.lang/concept.assignable/1.cc: New\n\ttest.\n\t* testsuite/std/concepts/concepts.lang/concept.common/1.cc: New test.\n\t* testsuite/std/concepts/concepts.lang/concept.commonref/1.cc: New\n\ttest.\n\t* testsuite/std/concepts/concepts.lang/concept.constructible/1.cc:\n\tNew test.\n\t* testsuite/std/concepts/concepts.lang/concept.convertible/1.cc:\n\tNew test.\n\t* testsuite/std/concepts/concepts.lang/concept.copyconstructible/1.cc:\n\tNew test.\n\t* testsuite/std/concepts/concepts.lang/concept.defaultconstructible/\n\t1.cc: New test.\n\t* testsuite/std/concepts/concepts.lang/concept.derived/1.cc:\n\tNew test.\n\t* testsuite/std/concepts/concepts.lang/concept.destructible/1.cc:\n\tNew test.\n\t* testsuite/std/concepts/concepts.lang/concept.moveconstructible/1.cc:\n\tNew test.\n\t* testsuite/std/concepts/concepts.lang/concept.same/1.cc:\n\tNew test.\n\t* testsuite/std/concepts/concepts.lang/concept.swappable/swap.cc:\n\tNew test.\n\t* testsuite/std/concepts/concepts.lang/concept.swappable/swappable.cc:\n\tNew test.\n\t* testsuite/std/concepts/concepts.lang/concept.swappable/\n\tswappable_with.cc: New test.\n\t* testsuite/std/concepts/concepts.object/copyable.cc: New test.\n\t* testsuite/std/concepts/concepts.object/movable.cc: New test.\n\t* testsuite/std/concepts/concepts.object/regular.cc: New test.\n\t* testsuite/std/concepts/concepts.object/semiregular.cc: New test.\n\nFrom-SVN: r276892", "tree": {"sha": "ff762f43759af77cdeff475bc1f39c79ffb92540", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff762f43759af77cdeff475bc1f39c79ffb92540"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfc219ae689fd94bbe1bb12686bb04fa09b93046", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfc219ae689fd94bbe1bb12686bb04fa09b93046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfc219ae689fd94bbe1bb12686bb04fa09b93046", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfc219ae689fd94bbe1bb12686bb04fa09b93046/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02f6fdff65671ccfaf2f79092ccdfccdef1bcebf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f6fdff65671ccfaf2f79092ccdfccdef1bcebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02f6fdff65671ccfaf2f79092ccdfccdef1bcebf"}], "stats": {"total": 2147, "additions": 2139, "deletions": 8}, "files": [{"sha": "8119455e1addcce44a96bda188109dee1ea2ac97", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -1,5 +1,59 @@\n 2019-10-11  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/Makefile.am: Add new header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/precompiled/stdc++.h: Include <concepts>.\n+\t* include/std/concepts: New header for C++20.\n+\t* include/std/version (__cpp_lib_concepts): Define.\n+\t* scripts/create_testsuite_files: Look for test files in new std\n+\tdirectory.\n+\t* testsuite/libstdc++-dg/conformance.exp: Likewise.\n+\t* testsuite/std/concepts/concepts.callable/invocable.cc: New test.\n+\t* testsuite/std/concepts/concepts.callable/regular_invocable.cc: New\n+\ttest.\n+\t* testsuite/std/concepts/concepts.callable/relation.cc: New test.\n+\t* testsuite/std/concepts/concepts.callable/strictweakorder.cc: New\n+\ttest.\n+\t* testsuite/std/concepts/concepts.lang/concept.arithmetic/\n+\tfloating_point.cc: New test.\n+\t* testsuite/std/concepts/concepts.lang/concept.arithmetic/integral.cc:\n+\tNew test.\n+\t* testsuite/std/concepts/concepts.lang/concept.arithmetic/\n+\tsigned_integral.cc: New test.\n+\t* testsuite/std/concepts/concepts.lang/concept.arithmetic/\n+\tunsigned_integral.cc: New test.\n+\t* testsuite/std/concepts/concepts.lang/concept.assignable/1.cc: New\n+\ttest.\n+\t* testsuite/std/concepts/concepts.lang/concept.common/1.cc: New test.\n+\t* testsuite/std/concepts/concepts.lang/concept.commonref/1.cc: New\n+\ttest.\n+\t* testsuite/std/concepts/concepts.lang/concept.constructible/1.cc:\n+\tNew test.\n+\t* testsuite/std/concepts/concepts.lang/concept.convertible/1.cc:\n+\tNew test.\n+\t* testsuite/std/concepts/concepts.lang/concept.copyconstructible/1.cc:\n+\tNew test.\n+\t* testsuite/std/concepts/concepts.lang/concept.defaultconstructible/\n+\t1.cc: New test.\n+\t* testsuite/std/concepts/concepts.lang/concept.derived/1.cc:\n+\tNew test.\n+\t* testsuite/std/concepts/concepts.lang/concept.destructible/1.cc:\n+\tNew test.\n+\t* testsuite/std/concepts/concepts.lang/concept.moveconstructible/1.cc:\n+\tNew test.\n+\t* testsuite/std/concepts/concepts.lang/concept.same/1.cc:\n+\tNew test.\n+\t* testsuite/std/concepts/concepts.lang/concept.swappable/swap.cc:\n+\tNew test.\n+\t* testsuite/std/concepts/concepts.lang/concept.swappable/swappable.cc:\n+\tNew test.\n+\t* testsuite/std/concepts/concepts.lang/concept.swappable/\n+\tswappable_with.cc: New test.\n+\t* testsuite/std/concepts/concepts.object/copyable.cc: New test.\n+\t* testsuite/std/concepts/concepts.object/movable.cc: New test.\n+\t* testsuite/std/concepts/concepts.object/regular.cc: New test.\n+\t* testsuite/std/concepts/concepts.object/semiregular.cc: New test.\n+\n \t* include/std/type_traits (is_same): Replace partial specialization\n \tby using __is_same_as built-in in primary template.\n \t(is_same_v): Use __is_same_as built-in instead of instantiating the"}, {"sha": "35ee3cfcd344d50c037dfd186dac472ca18e76d6", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -36,6 +36,7 @@ std_headers = \\\n \t${std_srcdir}/chrono \\\n \t${std_srcdir}/codecvt \\\n \t${std_srcdir}/complex \\\n+\t${std_srcdir}/concepts \\\n \t${std_srcdir}/condition_variable \\\n \t${std_srcdir}/deque \\\n \t${std_srcdir}/execution \\\n@@ -1379,8 +1380,8 @@ endif\n # This is a subset of the full install-headers rule.  We only need <ciso646>,\n # <cstddef>, <cfloat>, <limits>, <climits>, <version>, <cstdint>, <cstdlib>,\n # <new>, <typeinfo>, <exception>, <initializer_list>, <cstdalign>, <cstdarg>,\n-# <cstdbool>, <type_traits>, <bit>, <atomic>, and any files which they include\n-# (and which we provide).\n+# <concepts>, <cstdbool>, <type_traits>, <bit>, <atomic>,\n+# and any files which they include (and which we provide).\n # <new>, <typeinfo>, <exception>, and <initializer_list> are installed by\n # libsupc++, so only the others and the sub-includes are copied here.\n install-freestanding-headers:\n@@ -1393,7 +1394,7 @@ install-freestanding-headers:\n \t  ${glibcxx_srcdir}/$(CPU_DEFINES_SRCDIR)/cpu_defines.h; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${host_installdir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${std_builddir}\n-\tfor file in limits type_traits atomic bit version; do \\\n+\tfor file in limits type_traits atomic bit concepts version; do \\\n \t  $(INSTALL_DATA) ${std_builddir}/$${file} $(DESTDIR)${gxx_include_dir}/${std_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${c_base_builddir}\n \tfor file in ciso646 cstddef cfloat climits cstdint cstdlib \\"}, {"sha": "5d0488846ffb6cebb7c7cdcb85c6091dc165440e", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -380,6 +380,7 @@ std_headers = \\\n \t${std_srcdir}/chrono \\\n \t${std_srcdir}/codecvt \\\n \t${std_srcdir}/complex \\\n+\t${std_srcdir}/concepts \\\n \t${std_srcdir}/condition_variable \\\n \t${std_srcdir}/deque \\\n \t${std_srcdir}/execution \\\n@@ -1853,8 +1854,8 @@ ${pch3_output}: ${pch3_source} ${pch2_output}\n # This is a subset of the full install-headers rule.  We only need <ciso646>,\n # <cstddef>, <cfloat>, <limits>, <climits>, <version>, <cstdint>, <cstdlib>,\n # <new>, <typeinfo>, <exception>, <initializer_list>, <cstdalign>, <cstdarg>,\n-# <cstdbool>, <type_traits>, <bit>, <atomic>, and any files which they include\n-# (and which we provide).\n+# <concepts>, <cstdbool>, <type_traits>, <bit>, <atomic>,\n+# and any files which they include (and which we provide).\n # <new>, <typeinfo>, <exception>, and <initializer_list> are installed by\n # libsupc++, so only the others and the sub-includes are copied here.\n install-freestanding-headers:\n@@ -1867,7 +1868,7 @@ install-freestanding-headers:\n \t  ${glibcxx_srcdir}/$(CPU_DEFINES_SRCDIR)/cpu_defines.h; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${host_installdir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${std_builddir}\n-\tfor file in limits type_traits atomic bit version; do \\\n+\tfor file in limits type_traits atomic bit concepts version; do \\\n \t  $(INSTALL_DATA) ${std_builddir}/$${file} $(DESTDIR)${gxx_include_dir}/${std_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${c_base_builddir}\n \tfor file in ciso646 cstddef cfloat climits cstdint cstdlib \\"}, {"sha": "fefd6e76845a03d4f3b64cc3cf316b08416022da", "filename": "libstdc++-v3/include/precompiled/stdc++.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -136,7 +136,7 @@\n #if __cplusplus > 201703L\n #include <bit>\n // #include <compare>\n-// #include <concepts>\n+#include <concepts>\n #include <numbers>\n // #include <ranges>\n #include <span>"}, {"sha": "6b1150a32d21f9c13fb9bd52b8e6e57396d95a7d", "filename": "libstdc++-v3/include/std/concepts", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fconcepts", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fconcepts", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fconcepts?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,351 @@\n+// <concepts> -*- C++ -*-\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received __a copy of the GNU General Public License and\n+// __a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/concepts\n+ *  This is __a Standard C++ Library header.\n+ *  @ingroup concepts\n+ */\n+\n+#ifndef _GLIBCXX_CONCEPTS\n+#define _GLIBCXX_CONCEPTS 1\n+\n+#if __cplusplus > 201703L && __cpp_concepts\n+\n+#pragma GCC system_header\n+\n+/**\n+ * @defgroup concepts Concepts\n+ * @ingroup utilities\n+ *\n+ * Concepts for checking type requirements.\n+ */\n+\n+#include <type_traits>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+#define __cpp_lib_concepts 201806L\n+\n+  // [concepts.lang], language-related concepts\n+\n+  namespace __detail\n+  {\n+    template<typename _Tp, typename _Up>\n+      concept __same_as = __is_same_as(_Tp, _Up);\n+  } // namespace __detail\n+\n+  /// [concept.same], concept same_as\n+  template<typename _Tp, typename _Up>\n+    concept same_as\n+      = __detail::__same_as<_Tp, _Up> && __detail::__same_as<_Up, _Tp>;\n+\n+  /// [concept.derived], concept derived_from\n+  template<typename _Derived, typename _Base>\n+    concept derived_from = __is_base_of(_Base, _Derived)\n+      && is_convertible_v<const volatile _Derived*, const volatile _Base*>;\n+\n+  /// [concept.convertible], concept convertible_to\n+  template<typename _From, typename _To>\n+    concept convertible_to = is_convertible_v<_From, _To>\n+      && requires(add_rvalue_reference_t<_From> (&__f)()) {\n+\t  static_cast<_To>(__f());\n+      };\n+\n+  /// [concept.commonref], concept common_reference_with\n+  template<typename _Tp, typename _Up>\n+    concept common_reference_with\n+      = same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>>\n+      && convertible_to<_Tp, common_reference_t<_Tp, _Up>>\n+      && convertible_to<_Up, common_reference_t<_Tp, _Up>>;\n+\n+  /// [concept.common], concept common_with\n+  template<typename _Tp, typename _Up>\n+    concept common_with\n+      = same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>>\n+      && requires {\n+\tstatic_cast<common_type_t<_Tp, _Up>>(std::declval<_Tp>());\n+\tstatic_cast<common_type_t<_Tp, _Up>>(std::declval<_Up>());\n+      }\n+      && common_reference_with<add_lvalue_reference_t<const _Tp>,\n+\t\t\t       add_lvalue_reference_t<const _Up>>\n+      && common_reference_with<add_lvalue_reference_t<common_type_t<_Tp, _Up>>,\n+\t\t\t       common_reference_t<\n+\t\t\t\t add_lvalue_reference_t<const _Tp>,\n+\t\t\t\t add_lvalue_reference_t<const _Up>>>;\n+\n+  // [concepts.arithmetic], arithmetic concepts\n+\n+  template<typename _Tp>\n+    concept integral = is_integral_v<_Tp>;\n+\n+  template<typename _Tp>\n+    concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;\n+\n+  template<typename _Tp>\n+    concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;\n+\n+  template<typename _Tp>\n+    concept floating_point = is_floating_point_v<_Tp>;\n+\n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+      using __cref = const remove_reference_t<_Tp>&;\n+  } // namespace __detail\n+\n+  /// [concept.assignable], concept assignable_from\n+  template<typename _Lhs, typename _Rhs>\n+    concept assignable_from\n+      = is_lvalue_reference_v<_Lhs>\n+      && common_reference_with<__detail::__cref<_Lhs>, __detail::__cref<_Rhs>>\n+      && requires(_Lhs __lhs, _Rhs&& __rhs) {\n+\t{ __lhs = static_cast<_Rhs&&>(__rhs) } -> same_as<_Lhs>;\n+      };\n+\n+  /// [concept.destructible], concept destructible\n+  template<typename _Tp>\n+    concept destructible = is_nothrow_destructible_v<_Tp>;\n+\n+  /// [concept.constructible], concept constructible_from\n+  template<typename _Tp, typename... _Args>\n+    concept constructible_from\n+      = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;\n+\n+  /// [concept.defaultconstructible], concept default_constructible\n+  template<typename _Tp>\n+    concept default_constructible = constructible_from<_Tp>;\n+\n+  /// [concept.moveconstructible], concept move_constructible\n+  template<typename _Tp>\n+    concept move_constructible\n+    = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;\n+\n+  /// [concept.copyconstructible], concept copy_constructible\n+  template<typename _Tp>\n+    concept copy_constructible\n+      = move_constructible<_Tp>\n+      && constructible_from<_Tp, _Tp&> && convertible_to<_Tp&, _Tp>\n+      && constructible_from<_Tp, const _Tp&> && convertible_to<const _Tp&, _Tp>\n+      && constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;\n+\n+  // [concept.swappable], concept swappable\n+\n+  namespace ranges\n+  {\n+    namespace __cust_swap\n+    {\n+      template<typename _Tp> void swap(_Tp&, _Tp&) = delete;\n+\n+      template<typename _Tp>\n+\tconcept __class_or_enum\n+\t  = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;\n+\n+      template<typename _Tp, typename _Up>\n+\tconcept __adl_swap\n+\t  = (__class_or_enum<remove_cvref_t<_Tp>>\n+\t    || __class_or_enum<remove_cvref_t<_Up>>)\n+\t  && requires(_Tp&& __t, _Up&& __u) {\n+\t    swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));\n+\t  };\n+\n+      struct _Swap\n+      {\n+\ttemplate<typename _Tp, typename _Up>\n+\t  requires __adl_swap<_Tp, _Up>\n+\t  constexpr void operator()(_Tp&& __t, _Up&& __u) const\n+\t  noexcept(noexcept(swap(std::declval<_Tp>(), std::declval<_Up>())))\n+\t  { swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u)); }\n+\n+\ttemplate<typename _Tp, typename _Up, size_t _Num>\n+\t  requires requires(const _Swap& __swap, _Tp& __e1, _Up& __e2) {\n+\t    __swap(__e1, __e2);\n+\t  }\n+\t  constexpr void\n+\t  operator()(_Tp (&__e1)[_Num], _Up (&__e2)[_Num]) const\n+\t  noexcept(noexcept(std::declval<const _Swap&>()(*__e1, *__e2)))\n+\t  {\n+\t    for (size_t __n = 0; __n < _Num; ++__n)\n+\t      (*this)(__e1[__n], __e2[__n]);\n+\t  }\n+\n+\ttemplate<typename _Tp>\n+\t  requires (!__adl_swap<_Tp&, _Tp&>\n+\t    && move_constructible<_Tp> && assignable_from<_Tp&, _Tp>)\n+\t  constexpr void\n+\t  operator()(_Tp& __e1, _Tp& __e2) const\n+\t  noexcept(is_nothrow_move_constructible_v<_Tp>\n+\t\t   && is_nothrow_move_assignable_v<_Tp>)\n+\t  {\n+\t    _Tp __tmp = static_cast<_Tp&&>(__e1);\n+\t    __e1 = static_cast<_Tp&&>(__e2);\n+\t    __e2 = static_cast<_Tp&&>(__tmp);\n+\t  }\n+      };\n+    } // namespace __cust_swap\n+\n+    inline namespace __cust\n+    {\n+      inline constexpr __cust_swap::_Swap swap{};\n+    } // inline namespace __cust\n+  } // namespace ranges\n+\n+  template<typename _Tp>\n+    concept swappable\n+      = requires(_Tp& __a, _Tp& __b) { ranges::swap(__a, __b); };\n+\n+  template<typename _Tp, typename _Up>\n+    concept swappable_with = common_reference_with<_Tp, _Up>\n+      && requires(_Tp&& __t, _Up&& __u) {\n+\tranges::swap(static_cast<_Tp&&>(__t), static_cast<_Tp&&>(__t));\n+\tranges::swap(static_cast<_Up&&>(__u), static_cast<_Up&&>(__u));\n+\tranges::swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));\n+\tranges::swap(static_cast<_Up&&>(__u), static_cast<_Tp&&>(__t));\n+      };\n+\n+  // [concepts.object], Object concepts\n+\n+  template<typename _Tp>\n+    concept movable = is_object_v<_Tp> && move_constructible<_Tp>\n+      && assignable_from<_Tp&, _Tp> && swappable<_Tp>;\n+\n+  template<typename _Tp>\n+    concept copyable = copy_constructible<_Tp> && movable<_Tp>\n+      && assignable_from<_Tp&, const _Tp&>;\n+\n+  template<typename _Tp>\n+    concept semiregular = copyable<_Tp> && default_constructible<_Tp>;\n+\n+  // [concepts.compare], comparison concepts\n+\n+  /// [concept.boolean], concept boolean\n+  template<typename _Bp>\n+    concept boolean\n+      = movable<remove_cvref_t<_Bp>>\n+      && requires(__detail::__cref<_Bp> __b1, __detail::__cref<_Bp> __b2,\n+\t\t  const bool __a) {\n+\t{ __b1 } -> convertible_to<bool>;\n+\t{ !__b1 } -> convertible_to<bool>;\n+\t{ __b1 && __b2 } -> same_as<bool>;\n+\t{ __b1 && __a  } -> same_as<bool>;\n+\t{ __a  && __b2 } -> same_as<bool>;\n+\t{ __b1 || __b2 } -> same_as<bool>;\n+\t{ __b1 || __a  } -> same_as<bool>;\n+\t{ __a  || __b2 } -> same_as<bool>;\n+\t{ __b1 == __b2 } -> convertible_to<bool>;\n+\t{ __b1 == __a  } -> convertible_to<bool>;\n+\t{ __a  == __b2 } -> convertible_to<bool>;\n+\t{ __b1 != __b2 } -> convertible_to<bool>;\n+\t{ __b1 != __a  } -> convertible_to<bool>;\n+\t{ __a  != __b2 } -> convertible_to<bool>;\n+      };\n+\n+  // [concept.equalitycomparable], concept equality_comparable\n+\n+  namespace __detail\n+  {\n+    template<typename _Tp, typename _Up>\n+      concept __weakly_eq_cmp_with\n+\t= requires(__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) {\n+\t  { __t == __u } -> boolean;\n+\t  { __t != __u } -> boolean;\n+\t  { __u == __t } -> boolean;\n+\t  { __u != __t } -> boolean;\n+\t};\n+  } // namespace __detail\n+\n+  template<typename _Tp>\n+    concept equality_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp>;\n+\n+  template<typename _Tp, typename _Up>\n+    concept equality_comparable_with\n+      = equality_comparable<_Tp> && equality_comparable<_Up>\n+      && common_reference_with<__detail::__cref<_Tp>, __detail::__cref<_Up>>\n+      && equality_comparable<common_reference_t<__detail::__cref<_Tp>,\n+\t\t\t\t\t\t__detail::__cref<_Up>>>\n+      && __detail::__weakly_eq_cmp_with<_Tp, _Up>;\n+\n+  // [concept.totallyordered], concept totally_ordered\n+  template<typename _Tp>\n+    concept totally_ordered\n+      = equality_comparable<_Tp>\n+      && requires(__detail::__cref<_Tp> __a, __detail::__cref<_Tp> __b) {\n+\t{ __a <  __b } -> boolean;\n+\t{ __a >  __b } -> boolean;\n+\t{ __a <= __b } -> boolean;\n+\t{ __a >= __b } -> boolean;\n+      };\n+\n+  template<typename _Tp, typename _Up>\n+    concept totally_ordered_with\n+      = totally_ordered<_Tp> && totally_ordered<_Up>\n+      && common_reference_with<__detail::__cref<_Tp>, __detail::__cref<_Up>>\n+      && totally_ordered<common_reference_t<__detail::__cref<_Tp>,\n+\t\t\t\t\t    __detail::__cref<_Up>>>\n+      && equality_comparable_with<_Tp, _Up>\n+      && requires(__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) {\n+\t{ __t <  __u } -> boolean;\n+\t{ __t >  __u } -> boolean;\n+\t{ __t <= __u } -> boolean;\n+\t{ __t >= __u } -> boolean;\n+\t{ __u <  __t } -> boolean;\n+\t{ __u >  __t } -> boolean;\n+\t{ __u <= __t } -> boolean;\n+\t{ __u >= __t } -> boolean;\n+      };\n+\n+  template<typename _Tp>\n+    concept regular = semiregular<_Tp> && equality_comparable<_Tp>;\n+\n+  // [concepts.callable], callable concepts\n+\n+  // [concept.invocable], concept invocable\n+  template<typename _Fn, typename... _Args>\n+    concept invocable = is_invocable_v<_Fn, _Args...>;\n+\n+  // [concept.regularinvocable], concept regular_invocable\n+  template<typename _Fn, typename... _Args>\n+    concept regular_invocable = invocable<_Fn, _Args...>;\n+\n+  // [concept.predicate], concept predicate\n+  template<typename _Fn, typename... _Args>\n+    concept predicate = regular_invocable<_Fn, _Args...>\n+      && boolean<invoke_result_t<_Fn, _Args...>>;\n+\n+  // [concept.relation], concept relation\n+  template<typename _Rel, typename _Tp, typename _Up>\n+    concept relation\n+      = predicate<_Rel, _Tp, _Tp> && predicate<_Rel, _Up, _Up>\n+      && predicate<_Rel, _Tp, _Up> && predicate<_Rel, _Up, _Tp>;\n+\n+  // [concept.strictweakorder], concept strict_weak_order\n+  template<typename _Rel, typename _Tp, typename _Up>\n+    concept strict_weak_order = relation<_Rel, _Tp, _Up>;\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+#endif // C++2a\n+\n+#endif /* _GLIBCXX_CONCEPTS */"}, {"sha": "21cc28b345047e47faa1fdc87542ca7c4dd30fec", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -153,6 +153,9 @@\n #define __cpp_lib_atomic_ref 201806L\n #define __cpp_lib_bind_front 201907L\n #define __cpp_lib_bounded_array_traits 201902L\n+#if __cpp_concepts\n+# define __cpp_lib_concepts 201806L\n+#endif\n #define __cpp_lib_constexpr 201711L\n #define __cpp_lib_constexpr_algorithms 201806L\n #if __cpp_impl_destroying_delete"}, {"sha": "52bbb5cda5a7487ca125d7eadffafb3565946516", "filename": "libstdc++-v3/scripts/create_testsuite_files", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Fscripts%2Fcreate_testsuite_files", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Fscripts%2Fcreate_testsuite_files", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fscripts%2Fcreate_testsuite_files?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -33,7 +33,7 @@ cd $srcdir\n # what has to happen when find(1) doesn't support -mindepth, or -xtype.\n # The directories here should be consistent with libstdc++-dg/conformance.exp\n dlist=`echo [0-9][0-9]*`\n-dlist=\"$dlist abi backward ext performance tr1 tr2 decimal experimental\"\n+dlist=\"$dlist std abi backward ext performance tr1 tr2 decimal experimental\"\n dlist=\"$dlist special_functions\"\n find $dlist \"(\" -type f -o -type l \")\" -name \"*.cc\" -print > $tmp.01\n find $dlist \"(\" -type f -o -type l \")\" -name \"*.c\" -print > $tmp.02"}, {"sha": "f334f76a8d98db3b4a744e4d3c8bfa7b707beef2", "filename": "libstdc++-v3/testsuite/libstdc++-dg/conformance.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-dg%2Fconformance.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-dg%2Fconformance.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-dg%2Fconformance.exp?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -54,6 +54,7 @@ if {[info exists tests_file] && [file exists $tests_file]} {\n     # Find directories that might have tests.\n     # This list should be consistent with scripts/create_testsuite_files\n     set subdirs [glob \"$srcdir/\\[0-9\\]\\[0-9\\]*\"]\n+    lappend subdirs \"$srcdir/std\"\n     lappend subdirs \"$srcdir/abi\"\n     lappend subdirs \"$srcdir/backward\"\n     lappend subdirs \"$srcdir/ext\""}, {"sha": "d6a8549eaba51b81cd69f629b46e9b2a21971e22", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.callable/invocable.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.callable%2Finvocable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.callable%2Finvocable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.callable%2Finvocable.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( ! std::invocable<int> );\n+static_assert( std::invocable<int()> );\n+static_assert( std::invocable<int(*)()> );\n+static_assert( std::invocable<int(&)()> );\n+static_assert( ! std::invocable<int(), int> );\n+static_assert( ! std::invocable<int() const> );\n+\n+static_assert( std::invocable<int(const long*, short), long*, char> );\n+\n+struct A;\n+static_assert( std::invocable<int A::*, const A&> );\n+static_assert( ! std::invocable<void (A::*)(long&), const A*, long&> );\n+static_assert( std::invocable<void (A::*)(long&) const, A*, long&> );\n+\n+struct F\n+{\n+  void operator()() const;\n+  void operator()(int);\n+};\n+static_assert( std::invocable<F> );\n+static_assert( std::invocable<F, int> );\n+static_assert( std::invocable<const F&> );\n+static_assert( ! std::invocable<const F&, int> );"}, {"sha": "f7ca447ab8543261ec3708b2ecabd09e5535f52e", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.callable/regular_invocable.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.callable%2Fregular_invocable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.callable%2Fregular_invocable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.callable%2Fregular_invocable.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( ! std::regular_invocable<int> );\n+static_assert( std::regular_invocable<int()> );\n+static_assert( std::regular_invocable<int(*)()> );\n+static_assert( std::regular_invocable<int(&)()> );\n+static_assert( ! std::regular_invocable<int(), int> );\n+static_assert( ! std::regular_invocable<int() const> );\n+\n+static_assert( std::regular_invocable<int(const long*, short), long*, char> );\n+\n+struct A;\n+static_assert( std::regular_invocable<int A::*, const A&> );\n+static_assert( ! std::regular_invocable<void (A::*)(long&), const A*, long&> );\n+static_assert( std::regular_invocable<void (A::*)(long&) const, A*, long&> );\n+\n+struct F\n+{\n+  void operator()() const;\n+  void operator()(int);\n+};\n+static_assert( std::regular_invocable<F> );\n+static_assert( std::regular_invocable<F, int> );\n+static_assert( std::regular_invocable<const F&> );\n+static_assert( ! std::regular_invocable<const F&, int> );"}, {"sha": "783c3ab9c4aab8d04966cffe87b4be29f54c638c", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.callable/relation.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.callable%2Frelation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.callable%2Frelation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.callable%2Frelation.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( ! std::relation<bool, void, void> );\n+static_assert( ! std::relation<bool(), void, void> );\n+static_assert( ! std::relation<bool(*)(), void, void> );\n+static_assert( ! std::relation<bool(&)(int, int), void, void> );\n+static_assert( ! std::relation<bool(), int, int> );\n+static_assert( ! std::relation<bool() const, int, int> );\n+\n+static_assert( std::relation<bool(*)(int, int), short, long> );\n+static_assert( std::relation<bool(&)(const void*, const void*), char[2], int*> );\n+\n+static_assert( ! std::relation<bool& (const long*, short), long*, char> );\n+\n+struct A;\n+static_assert( ! std::relation<int A::*, const A&, const A&> );\n+static_assert( ! std::relation<void (A::*)(long&), const A*, long&> );\n+static_assert( ! std::relation<void (A::*)(long&) const, A*, long&> );\n+static_assert( std::relation<long (A::*)(A*) const, A*, A*> );\n+\n+struct F\n+{\n+  void operator()(long, long) const;\n+  bool& operator()(int, const int&) const;\n+};\n+static_assert( ! std::relation<F, long, long> );\n+static_assert( std::relation<F&, int, int> );\n+static_assert( std::relation<const F&, const int, const int> );"}, {"sha": "9a01eb259cb00c8f85690cda655231792508db11", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.callable/strictweakorder.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.callable%2Fstrictweakorder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.callable%2Fstrictweakorder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.callable%2Fstrictweakorder.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( ! std::strict_weak_order<bool, void, void> );\n+static_assert( ! std::strict_weak_order<bool(), void, void> );\n+static_assert( ! std::strict_weak_order<bool(*)(), void, void> );\n+static_assert( ! std::strict_weak_order<bool(&)(int, int), void, void> );\n+static_assert( ! std::strict_weak_order<bool(), int, int> );\n+static_assert( ! std::strict_weak_order<bool() const, int, int> );\n+\n+static_assert( std::strict_weak_order<bool(*)(int, int), short, long> );\n+static_assert( std::strict_weak_order<bool(&)(const void*, const void*), char[2], int*> );\n+\n+static_assert( ! std::strict_weak_order<bool& (const long*, short), long*, char> );\n+\n+struct A;\n+static_assert( ! std::strict_weak_order<int A::*, const A&, const A&> );\n+static_assert( ! std::strict_weak_order<void (A::*)(long&), const A*, long&> );\n+static_assert( ! std::strict_weak_order<void (A::*)(long&) const, A*, long&> );\n+static_assert( std::strict_weak_order<long (A::*)(A*) const, A*, A*> );\n+\n+struct F\n+{\n+  void operator()(long, long) const;\n+  bool& operator()(int, const int&) const;\n+};\n+static_assert( ! std::strict_weak_order<F, long, long> );\n+static_assert( std::strict_weak_order<F&, int, int> );\n+static_assert( std::strict_weak_order<const F&, const int, const int> );"}, {"sha": "802f237480560d6fdd7c3cc1f2cf99aea0af0d7b", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.arithmetic/floating_point.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.arithmetic%2Ffloating_point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.arithmetic%2Ffloating_point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.arithmetic%2Ffloating_point.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( std::floating_point<float> );\n+static_assert( std::floating_point<double> );\n+static_assert( std::floating_point<long double> );\n+#ifdef _GLIBCXX_USE_FLOAT128\n+static_assert( std::floating_point<__float128> );\n+#endif\n+\n+static_assert( !std::floating_point<char> );\n+static_assert( !std::floating_point<signed char> );\n+static_assert( !std::floating_point<bool> );\n+static_assert( !std::floating_point<int> );\n+static_assert( !std::floating_point<char32_t> );\n+\n+#ifdef __GLIBCXX_TYPE_INT_N_0\n+static_assert( !std::floating_point<signed __GLIBCXX_TYPE_INT_N_0> );\n+#endif\n+\n+static_assert( !std::floating_point<void> );\n+static_assert( !std::floating_point<float*> );\n+static_assert( !std::floating_point<float&> );\n+static_assert( !std::floating_point<float&&> );\n+static_assert( !std::floating_point<const float&> );\n+static_assert( !std::floating_point<float[]> );\n+static_assert( !std::floating_point<float[2]> );\n+static_assert( !std::floating_point<float()> );\n+static_assert( !std::floating_point<float(*)()> );\n+static_assert( !std::floating_point<float(&)()> );\n+\n+enum E { };\n+static_assert( !std::floating_point<E> );\n+enum class CE { };\n+static_assert( !std::floating_point<CE> );\n+struct A { };\n+static_assert( !std::floating_point<A> );\n+union B { };\n+static_assert( !std::floating_point<B> );"}, {"sha": "4716dde03b1838e38ebb63efba3fdf2220b23518", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.arithmetic/integral.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.arithmetic%2Fintegral.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.arithmetic%2Fintegral.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.arithmetic%2Fintegral.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+// signed integer types\n+static_assert( std::integral<signed char> );\n+static_assert( std::integral<signed short> );\n+static_assert( std::integral<signed int> );\n+static_assert( std::integral<signed long> );\n+static_assert( std::integral<signed long long> );\n+\n+// unsigned integer types\n+static_assert( std::integral<unsigned char> );\n+static_assert( std::integral<unsigned short> );\n+static_assert( std::integral<unsigned int> );\n+static_assert( std::integral<unsigned long> );\n+static_assert( std::integral<unsigned long long> );\n+\n+// other integral types\n+static_assert( std::integral<bool> );\n+static_assert( std::integral<char> );\n+static_assert( std::integral<char16_t> );\n+static_assert( std::integral<char32_t> );\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+static_assert( std::integral<wchar_t> );\n+#endif\n+#ifdef _GLIBCXX_USE_CHAR8_T\n+static_assert( std::integral<char8_t> );\n+#endif\n+\n+#ifdef __GLIBCXX_TYPE_INT_N_0\n+static_assert( std::integral<signed __GLIBCXX_TYPE_INT_N_0> );\n+static_assert( std::integral<unsigned __GLIBCXX_TYPE_INT_N_0> );\n+#endif\n+\n+static_assert( !std::integral<void> );\n+static_assert( !std::integral<float> );\n+static_assert( !std::integral<int*> );\n+static_assert( !std::integral<int&> );\n+static_assert( !std::integral<int&&> );\n+static_assert( !std::integral<const int&> );\n+static_assert( !std::integral<int[]> );\n+static_assert( !std::integral<int[2]> );\n+static_assert( !std::integral<int()> );\n+static_assert( !std::integral<int(*)()> );\n+static_assert( !std::integral<int(&)()> );\n+\n+enum E { };\n+static_assert( !std::integral<E> );\n+enum class CE { };\n+static_assert( !std::integral<CE> );\n+struct A { };\n+static_assert( !std::integral<A> );\n+union B { };\n+static_assert( !std::integral<B> );"}, {"sha": "8dd33e51ae726e537753a11a769a26d7960c8c94", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.arithmetic/signed_integral.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.arithmetic%2Fsigned_integral.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.arithmetic%2Fsigned_integral.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.arithmetic%2Fsigned_integral.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+// signed integer types\n+static_assert( std::signed_integral<signed char> );\n+static_assert( std::signed_integral<signed short> );\n+static_assert( std::signed_integral<signed int> );\n+static_assert( std::signed_integral<signed long> );\n+static_assert( std::signed_integral<signed long long> );\n+\n+// unsigned integer types\n+static_assert( !std::signed_integral<unsigned char> );\n+static_assert( !std::signed_integral<unsigned short> );\n+static_assert( !std::signed_integral<unsigned int> );\n+static_assert( !std::signed_integral<unsigned long> );\n+static_assert( !std::signed_integral<unsigned long long> );\n+\n+// other integral types\n+static_assert( !std::signed_integral<bool> );\n+static_assert( std::is_signed_v<char> ? std::signed_integral<char> : true );\n+static_assert( !std::signed_integral<char16_t> );\n+static_assert( !std::signed_integral<char32_t> );\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+static_assert( std::is_signed_v<wchar_t> ? std::signed_integral<wchar_t> : true );\n+#endif\n+#ifdef _GLIBCXX_USE_CHAR8_T\n+static_assert( !std::signed_integral<char8_t> );\n+#endif\n+\n+#ifdef __GLIBCXX_TYPE_INT_N_0\n+static_assert( std::signed_integral<signed __GLIBCXX_TYPE_INT_N_0> );\n+static_assert( !std::signed_integral<unsigned __GLIBCXX_TYPE_INT_N_0> );\n+#endif\n+\n+static_assert( !std::signed_integral<void> );\n+static_assert( !std::signed_integral<float> );\n+static_assert( !std::signed_integral<int&> );\n+static_assert( !std::signed_integral<int&> );\n+static_assert( !std::signed_integral<int&&> );\n+static_assert( !std::signed_integral<const int&> );\n+static_assert( !std::signed_integral<int[]> );\n+static_assert( !std::signed_integral<int[2]> );\n+static_assert( !std::signed_integral<int()> );\n+static_assert( !std::signed_integral<int(*)()> );\n+static_assert( !std::signed_integral<int(&)()> );\n+\n+enum E { };\n+static_assert( !std::signed_integral<E> );\n+enum class CE { };\n+static_assert( !std::signed_integral<CE> );\n+struct A { };\n+static_assert( !std::signed_integral<A> );\n+union B { };\n+static_assert( !std::signed_integral<B> );"}, {"sha": "33affffc8952d9a6db11c66a086630514ba79f7f", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.arithmetic/unsigned_integral.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.arithmetic%2Funsigned_integral.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.arithmetic%2Funsigned_integral.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.arithmetic%2Funsigned_integral.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+// unsigned integer types\n+static_assert( std::unsigned_integral<unsigned char> );\n+static_assert( std::unsigned_integral<unsigned short> );\n+static_assert( std::unsigned_integral<unsigned int> );\n+static_assert( std::unsigned_integral<unsigned long> );\n+static_assert( std::unsigned_integral<unsigned long long> );\n+\n+// signed integer types\n+static_assert( !std::unsigned_integral<signed char> );\n+static_assert( !std::unsigned_integral<signed short> );\n+static_assert( !std::unsigned_integral<signed int> );\n+static_assert( !std::unsigned_integral<signed long> );\n+static_assert( !std::unsigned_integral<signed long long> );\n+\n+// other integral types\n+static_assert( std::unsigned_integral<bool> );\n+static_assert( std::is_signed_v<char> ? true : std::unsigned_integral<char> );\n+static_assert( std::unsigned_integral<char16_t> );\n+static_assert( std::unsigned_integral<char32_t> );\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+static_assert( std::is_signed_v<wchar_t> ? true : std::unsigned_integral<wchar_t> );\n+#endif\n+#ifdef _GLIBCXX_USE_CHAR8_T\n+static_assert( std::unsigned_integral<char8_t> );\n+#endif\n+\n+#ifdef __GLIBCXX_TYPE_INT_N_0\n+static_assert( !std::unsigned_integral<signed __GLIBCXX_TYPE_INT_N_0> );\n+static_assert( std::unsigned_integral<unsigned __GLIBCXX_TYPE_INT_N_0> );\n+#endif\n+\n+static_assert( !std::unsigned_integral<void> );\n+static_assert( !std::unsigned_integral<float> );\n+static_assert( !std::unsigned_integral<unsigned&> );\n+static_assert( !std::unsigned_integral<unsigned&> );\n+static_assert( !std::unsigned_integral<unsigned&&> );\n+static_assert( !std::unsigned_integral<const unsigned&> );\n+static_assert( !std::unsigned_integral<unsigned[]> );\n+static_assert( !std::unsigned_integral<unsigned[2]> );\n+static_assert( !std::unsigned_integral<unsigned()> );\n+static_assert( !std::unsigned_integral<unsigned(*)()> );\n+static_assert( !std::unsigned_integral<unsigned(&)()> );\n+\n+enum E { };\n+static_assert( !std::unsigned_integral<E> );\n+enum class CE { };\n+static_assert( !std::unsigned_integral<CE> );\n+struct A { };\n+static_assert( !std::unsigned_integral<A> );\n+union B { };\n+static_assert( !std::unsigned_integral<B> );"}, {"sha": "64773924682a7c4a6b22d4e3b58efde940718a30", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.assignable/1.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.assignable%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.assignable%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.assignable%2F1.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,85 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( !std::assignable_from<void, void> );\n+static_assert( !std::assignable_from<void*, int*> );\n+static_assert( std::assignable_from<void*&, int*> );\n+static_assert( !std::assignable_from<void*&, const int*> );\n+static_assert( std::assignable_from<const void*&, const int*> );\n+static_assert( !std::assignable_from<char, char> );\n+static_assert( std::assignable_from<char&, char> );\n+static_assert( !std::assignable_from<float, float> );\n+static_assert( std::assignable_from<float&, double> );\n+static_assert( std::assignable_from<int*&, int*> );\n+static_assert( std::assignable_from<int&, int&> );\n+static_assert( std::assignable_from<int&, int&&> );\n+static_assert( !std::assignable_from<int&&, int> );\n+static_assert( !std::assignable_from<const int&, int> );\n+static_assert( !std::assignable_from<const int&, int&> );\n+static_assert( !std::assignable_from<const int&, const int> );\n+static_assert( !std::assignable_from<const int&, const int&> );\n+static_assert( !std::assignable_from<int(&)[], int(&)[]> );\n+static_assert( !std::assignable_from<int(&)[], int> );\n+static_assert( !std::assignable_from<int(&)[2], int(&)[2]> );\n+static_assert( !std::assignable_from<int(), int()> );\n+static_assert( !std::assignable_from<int(*)(), int(*)()> );\n+static_assert( std::assignable_from<int(*&)(), int(*)()> );\n+static_assert( std::assignable_from<int(*&)(), std::nullptr_t> );\n+static_assert( std::assignable_from<int(*&)(), int(*)() noexcept> );\n+static_assert( std::assignable_from<int(*&)(), int(&)() noexcept> );\n+static_assert( !std::assignable_from<int(&)(), std::nullptr_t> );\n+static_assert( !std::assignable_from<int(&)(), int(&)() noexcept> );\n+\n+enum E { };\n+static_assert( !std::assignable_from<E, E> );\n+static_assert( std::assignable_from<E&, E> );\n+static_assert( std::assignable_from<E&, E&> );\n+static_assert( std::assignable_from<E&, const E&> );\n+static_assert( !std::assignable_from<const E&, const E&> );\n+enum class CE { };\n+static_assert( !std::assignable_from<CE, CE> );\n+static_assert( std::assignable_from<CE&, CE&> );\n+static_assert( std::assignable_from<CE&, const CE&> );\n+static_assert( !std::assignable_from<const CE&, const CE&> );\n+struct A { };\n+static_assert( !std::assignable_from<A, A> );\n+static_assert( std::assignable_from<A&, A> );\n+static_assert( !std::assignable_from<A, A&> );\n+static_assert( std::assignable_from<A&, const A&> );\n+union B { };\n+static_assert( !std::assignable_from<B, B> );\n+static_assert( std::assignable_from<B&, B> );\n+static_assert( !std::assignable_from<B, B&> );\n+static_assert( std::assignable_from<B&, const B&> );\n+\n+struct C\n+{\n+  C(int) { }\n+  C& operator=(const C&) { return *this; }\n+  C& operator=(int) { return *this; }\n+  void operator=(void*) { }\n+};\n+static_assert( std::assignable_from<C&, C> );\n+static_assert( std::assignable_from<C&, const C&> );\n+static_assert( std::assignable_from<C&, int> );\n+static_assert( !std::assignable_from<C&, void*> );\n+static_assert( !std::assignable_from<C&, std::nullptr_t> );"}, {"sha": "2432ab8e5612adaa2b733ee84b168811fc5a4b85", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.common/1.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.common%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.common%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.common%2F1.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( std::common_with<int, int> );\n+static_assert( std::common_with<int, const int> );\n+static_assert( std::common_with<int&&, const int&> );\n+static_assert( std::common_with<int&, const int&&> );\n+static_assert( std::common_with<void, void> );\n+static_assert( ! std::common_with<int, void> );\n+static_assert( ! std::common_with<int, int*> );\n+static_assert( ! std::common_with<int, int()> );\n+\n+static_assert( std::common_with<int, short> );\n+static_assert( std::common_with<short, int> );\n+static_assert( std::common_with<void*, const int*> );\n+\n+struct A { A(int) { } };\n+static_assert( std::common_with<A, int> );\n+\n+struct B { };\n+static_assert( ! std::common_with<A, B> );\n+\n+struct C { C(const A&) { } };\n+static_assert( std::common_with<A, C> );\n+static_assert( std::common_with<A, const C> );\n+static_assert( std::common_with<const A, C> );\n+static_assert( std::common_with<const A, const C> );\n+\n+struct D;\n+struct E { E(const D&) { } };\n+struct D { D(const E&) { } };\n+static_assert( ! std::common_with<D, E> ); // ambiguous conversion\n+\n+struct F { };\n+struct G { };\n+struct H {\n+  H(const F&) { }\n+  H(const G&) { }\n+};\n+namespace std\n+{\n+  template<> struct common_type<F, G> { using type = H; };\n+  template<> struct common_type<G, F> { using type = H; };\n+}\n+\n+static_assert( std::common_with<F, G> );\n+static_assert( std::common_with<F, const G> );\n+static_assert( std::common_with<const F, G> );\n+static_assert( std::common_with<const F, const G> );\n+\n+struct Base { };\n+struct Derived : Base { };\n+static_assert( std::common_with<Derived, Base> );\n+static_assert( std::common_with<Derived*, Base*> );"}, {"sha": "4b56dd716798fed0b156030ee9655c3a494cb7a6", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.commonref/1.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.commonref%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.commonref%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.commonref%2F1.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,71 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( std::common_reference_with<int, int> );\n+static_assert( std::common_reference_with<int, const int> );\n+static_assert( std::common_reference_with<int&&, const int&> );\n+static_assert( std::common_reference_with<int&, const int&&> );\n+static_assert( ! std::common_reference_with<int, void> );\n+static_assert( ! std::common_reference_with<int, int*> );\n+static_assert( ! std::common_reference_with<int, int()> );\n+\n+struct A { A(int) { } };\n+static_assert( std::common_reference_with<A, int> );\n+\n+struct B { };\n+static_assert( ! std::common_reference_with<A, B> );\n+\n+struct C { C(A&) { } };\n+static_assert( std::common_reference_with<A&, C> );\n+static_assert( std::common_reference_with<A&, C&&> );\n+static_assert( std::common_reference_with<A&, const C&> );\n+static_assert( std::common_reference_with<A&, C&> );\n+static_assert( ! std::common_reference_with<const A&, C> );\n+static_assert( ! std::common_reference_with<const A&, const C&> );\n+\n+struct D;\n+struct E { E(D&) { } };\n+struct D { D(E&) { } };\n+static_assert( ! std::common_reference_with<D&, E&> ); // ambiguous conversion\n+\n+struct F;\n+struct G { G(const F&) { } };\n+struct F { F(const G&) { } };\n+namespace std\n+{\n+  template<template<typename> class Qual1, template<typename> class Qual2>\n+    struct basic_common_reference<F, G, Qual1, Qual2>\n+    { using type = Qual1<Qual2<F>>; };\n+  template<template<typename> class Qual1, template<typename> class Qual2>\n+    struct basic_common_reference<G, F, Qual1, Qual2>\n+    { using type = Qual1<Qual2<F>>; };\n+}\n+\n+static_assert( ! std::common_reference_with<F&, G&> );\n+static_assert( std::common_reference_with<F, G> );\n+static_assert( std::common_reference_with<F, const G> );\n+static_assert( std::common_reference_with<const F, const G> );\n+\n+struct Base { };\n+struct Derived : Base { };\n+static_assert( std::common_reference_with<Derived&, Base&> );\n+static_assert( std::common_with<Derived*, Base*> );"}, {"sha": "22a52d023602769e4845fc39d0ce686bf06ce1a2", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.constructible/1.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.constructible%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.constructible%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.constructible%2F1.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,89 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( !std::constructible_from<void> );\n+static_assert( !std::constructible_from<void, void> );\n+static_assert( std::constructible_from<void*, int*> );\n+static_assert( !std::constructible_from<void*, const int*> );\n+static_assert( std::constructible_from<const void*, const int*> );\n+static_assert( std::constructible_from<char> );\n+static_assert( std::constructible_from<float> );\n+static_assert( std::constructible_from<float, float> );\n+static_assert( std::constructible_from<float, double> );\n+static_assert( std::constructible_from<int*> );\n+static_assert( std::constructible_from<int*, int*> );\n+static_assert( !std::constructible_from<int&> );\n+static_assert( std::constructible_from<int&, int&> );\n+static_assert( !std::constructible_from<int&&> );\n+static_assert( std::constructible_from<int&&, int> );\n+static_assert( !std::constructible_from<const int&> );\n+static_assert( std::constructible_from<const int&, int> );\n+static_assert( std::constructible_from<const int&, int&> );\n+static_assert( std::constructible_from<const int&, const int> );\n+static_assert( std::constructible_from<const int&, const int&> );\n+static_assert( !std::constructible_from<const int&, int, int> );\n+static_assert( !std::constructible_from<int[]> );\n+static_assert( std::constructible_from<int[2]> );\n+static_assert( !std::constructible_from<int()> );\n+static_assert( std::constructible_from<int(*)()> );\n+static_assert( std::constructible_from<int(*)(), std::nullptr_t> );\n+static_assert( std::constructible_from<int(*)(), int(*)() noexcept> );\n+static_assert( std::constructible_from<int(*)(), int(&)() noexcept> );\n+static_assert( !std::constructible_from<int(&)()> );\n+static_assert( std::constructible_from<int(&)(), int(&)() noexcept> );\n+\n+enum E { };\n+static_assert( std::constructible_from<E> );\n+static_assert( std::constructible_from<E, E&> );\n+enum class CE { };\n+static_assert( std::constructible_from<CE> );\n+static_assert( std::constructible_from<CE, CE&> );\n+struct A { };\n+static_assert( std::constructible_from<A> );\n+static_assert( std::constructible_from<A, A> );\n+static_assert( std::constructible_from<A, A&> );\n+static_assert( std::constructible_from<A, const A&> );\n+union B { };\n+static_assert( std::constructible_from<B> );\n+static_assert( std::constructible_from<B, B> );\n+static_assert( std::constructible_from<B, B&> );\n+static_assert( std::constructible_from<B, const B&> );\n+\n+struct C\n+{\n+  C(void* = nullptr) { }\n+  ~C() noexcept(false) { }\n+};\n+static_assert( !std::constructible_from<C> );\n+static_assert( !std::constructible_from<C, void*> );\n+static_assert( !std::constructible_from<C, std::nullptr_t> );\n+\n+class D\n+{\n+public:\n+  D() { }\n+  D(int) { }\n+private:\n+  ~D() { }\n+};\n+static_assert( !std::constructible_from<D> );\n+static_assert( !std::constructible_from<D, int> );"}, {"sha": "295706c044055579e4709f5019ff0911b4135b4e", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.convertible/1.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.convertible%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.convertible%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.convertible%2F1.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( std::convertible_to<int, int> );\n+static_assert( std::convertible_to<int&, int> );\n+static_assert( !std::convertible_to<int, int&> );\n+static_assert( std::convertible_to<int, const int&> );\n+static_assert( !std::convertible_to<int&&, int&> );\n+static_assert( std::convertible_to<int&&, const int&> );\n+static_assert( std::convertible_to<const int, int> );\n+static_assert( !std::convertible_to<const int, int&> );\n+static_assert( std::convertible_to<const int, const int> );\n+static_assert( std::convertible_to<const int, const int&> );\n+\n+static_assert( std::convertible_to<int, float> );\n+static_assert( !std::convertible_to<int, float&> );\n+static_assert( !std::convertible_to<int, int*> );\n+static_assert( std::convertible_to<int*, void*> );\n+static_assert( std::convertible_to<int*, const void*> );\n+static_assert( !std::convertible_to<const int*, void*> );\n+static_assert( !std::convertible_to<int, void> );\n+\n+struct A { };\n+static_assert( std::convertible_to<A, A> );\n+static_assert( std::convertible_to<A, const A> );\n+static_assert( std::convertible_to<A const, const A> );\n+static_assert( !std::convertible_to<volatile A, const A> );\n+static_assert( !std::convertible_to<volatile A, const volatile A&> );\n+static_assert( std::convertible_to<volatile A&, const volatile A&> );\n+\n+struct B : A { };\n+static_assert( !std::convertible_to<A, B> );\n+static_assert( std::convertible_to<B, A> );\n+static_assert( std::convertible_to<const B, A> );\n+static_assert( std::convertible_to<B, const A> );\n+static_assert( std::convertible_to<B, const A&> );\n+static_assert( !std::convertible_to<volatile B, const A> );\n+static_assert( !std::convertible_to<volatile B, const A&> );\n+\n+struct C : private A { };\n+static_assert( !std::convertible_to<A, C> );\n+static_assert( !std::convertible_to<C, A> );\n+\n+struct D : A { };\n+struct E : B, D { };\n+static_assert( !std::convertible_to<A, E> );\n+static_assert( !std::convertible_to<E, A> );\n+\n+struct F\n+{\n+  F(A) { }\n+  F(C&&) { }\n+};\n+static_assert( std::convertible_to<A, F> );\n+static_assert( std::convertible_to<const A, F> );\n+static_assert( std::convertible_to<C, F> );\n+static_assert( !std::convertible_to<C&, F> );\n+static_assert( !std::convertible_to<const C, F> );"}, {"sha": "0e7843ebb9d0af98b952ca646836b492cfddabaa", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.copyconstructible/1.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.copyconstructible%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.copyconstructible%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.copyconstructible%2F1.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( !std::copy_constructible<void> );\n+static_assert( std::copy_constructible<void*> );\n+static_assert( std::copy_constructible<const void*> );\n+static_assert( std::copy_constructible<char> );\n+static_assert( std::copy_constructible<const float> );\n+static_assert( std::copy_constructible<int*> );\n+static_assert( std::copy_constructible<int&> );\n+static_assert( !std::copy_constructible<int&&> );\n+static_assert( std::copy_constructible<const int&> );\n+static_assert( !std::copy_constructible<int[]> );\n+static_assert( !std::copy_constructible<int[2]> );\n+static_assert( !std::copy_constructible<int()> );\n+static_assert( std::copy_constructible<int(*)()> );\n+static_assert( std::copy_constructible<int(&)()> );\n+static_assert( std::copy_constructible<int(&)() noexcept> );\n+\n+enum E { };\n+static_assert( std::copy_constructible<E> );\n+enum class CE { };\n+static_assert( std::copy_constructible<CE> );\n+struct A { };\n+static_assert( std::copy_constructible<A> );\n+union B { };\n+static_assert( std::copy_constructible<B> );\n+\n+struct C\n+{\n+  C(void* = nullptr) { }\n+  ~C() noexcept(false) { }\n+};\n+static_assert( !std::copy_constructible<C> );\n+\n+class D\n+{\n+public:\n+  D() { }\n+  D(int) { }\n+private:\n+  ~D() { }\n+};\n+static_assert( !std::copy_constructible<D> );"}, {"sha": "56a4844a957a83279d1e057f41f80a85f9cddeb8", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.defaultconstructible/1.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.defaultconstructible%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.defaultconstructible%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.defaultconstructible%2F1.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( !std::default_constructible<void> );\n+static_assert( std::default_constructible<void*> );\n+static_assert( std::default_constructible<const void*> );\n+static_assert( std::default_constructible<char> );\n+static_assert( std::default_constructible<float> );\n+static_assert( std::default_constructible<const int> );\n+static_assert( std::default_constructible<int*> );\n+static_assert( !std::default_constructible<int&> );\n+static_assert( !std::default_constructible<int&&> );\n+static_assert( !std::default_constructible<const int&> );\n+static_assert( !std::default_constructible<int[]> );\n+static_assert( std::default_constructible<int[2]> );\n+static_assert( !std::default_constructible<int()> );\n+static_assert( std::default_constructible<int(*)()> );\n+static_assert( !std::default_constructible<int(&)()> );\n+\n+enum E { };\n+static_assert( std::default_constructible<E> );\n+enum class CE { };\n+static_assert( std::default_constructible<CE> );\n+struct A { };\n+static_assert( std::default_constructible<A> );\n+union B { };\n+static_assert( std::constructible_from<B> );\n+\n+struct C\n+{\n+  C(void* = nullptr) { }\n+  ~C() noexcept(false) { }\n+};\n+static_assert( !std::default_constructible<C> );\n+\n+class D\n+{\n+public:\n+  D() { }\n+  D(int) { }\n+private:\n+  ~D() { }\n+};\n+static_assert( !std::default_constructible<D> );"}, {"sha": "f376aee7ee4ef6c91db6ac0c96c06924a35a1248", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.derived/1.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.derived%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.derived%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.derived%2F1.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( !std::derived_from<int, int> );\n+static_assert( !std::derived_from<int&, int> );\n+static_assert( !std::derived_from<int, int&> );\n+static_assert( !std::derived_from<int&&, int&> );\n+static_assert( !std::derived_from<const int, int> );\n+static_assert( !std::derived_from<const int, const int> );\n+\n+struct A { };\n+static_assert( std::derived_from<A, A> );\n+static_assert( std::derived_from<A, const A> );\n+static_assert( std::derived_from<A const, const A> );\n+static_assert( std::derived_from<volatile A, const A> );\n+\n+struct B : A { };\n+static_assert( !std::derived_from<A, B> );\n+static_assert( std::derived_from<B, A> );\n+static_assert( std::derived_from<const B, A> );\n+static_assert( std::derived_from<B, const A> );\n+static_assert( std::derived_from<volatile B, const A> );\n+\n+struct C : private A { };\n+static_assert( !std::derived_from<A, C> );\n+static_assert( !std::derived_from<C, A> );\n+\n+struct D : A { };\n+struct E : B, D { };\n+static_assert( !std::derived_from<A, E> );\n+static_assert( !std::derived_from<E, A> );"}, {"sha": "279072aa4c847c6073ce4ef9a1cd99aeffb7ed41", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.destructible/1.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.destructible%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.destructible%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.destructible%2F1.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( !std::destructible<void> );\n+static_assert( std::destructible<char> );\n+static_assert( std::destructible<float> );\n+static_assert( std::destructible<int*> );\n+static_assert( std::destructible<int&> );\n+static_assert( std::destructible<int&&> );\n+static_assert( std::destructible<const int&> );\n+static_assert( !std::destructible<int[]> );\n+static_assert( std::destructible<int[2]> );\n+static_assert( !std::destructible<int()> );\n+static_assert( std::destructible<int(*)()> );\n+static_assert( std::destructible<int(&)()> );\n+\n+enum E { };\n+static_assert( std::destructible<E> );\n+enum class CE { };\n+static_assert( std::destructible<CE> );\n+struct A { };\n+static_assert( std::destructible<A> );\n+union B { };\n+static_assert( std::destructible<B> );\n+\n+struct C\n+{\n+  ~C() noexcept(false) { }\n+};\n+static_assert( !std::destructible<C> );\n+class D\n+{\n+public:\n+  D() { }\n+private:\n+  ~D() { }\n+};\n+static_assert( !std::destructible<D> );"}, {"sha": "9bdf87bcaa2f3ee6438f69aa303e621b349bec52", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.moveconstructible/1.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.moveconstructible%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.moveconstructible%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.moveconstructible%2F1.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( !std::move_constructible<void> );\n+static_assert( std::move_constructible<void*> );\n+static_assert( std::move_constructible<const void*> );\n+static_assert( std::move_constructible<char> );\n+static_assert( std::move_constructible<const float> );\n+static_assert( std::move_constructible<int*> );\n+static_assert( std::move_constructible<int&> );\n+static_assert( std::move_constructible<int&&> );\n+static_assert( std::move_constructible<const int&> );\n+static_assert( !std::move_constructible<int[]> );\n+static_assert( !std::move_constructible<int[2]> );\n+static_assert( !std::move_constructible<int()> );\n+static_assert( std::move_constructible<int(*)()> );\n+static_assert( std::move_constructible<int(&)()> );\n+static_assert( std::move_constructible<int(&)() noexcept> );\n+\n+enum E { };\n+static_assert( std::move_constructible<E> );\n+enum class CE { };\n+static_assert( std::move_constructible<CE> );\n+struct A { };\n+static_assert( std::move_constructible<A> );\n+union B { };\n+static_assert( std::move_constructible<B> );\n+\n+struct C\n+{\n+  C(void* = nullptr) { }\n+  ~C() noexcept(false) { }\n+};\n+static_assert( !std::move_constructible<C> );\n+\n+class D\n+{\n+public:\n+  D() { }\n+  D(int) { }\n+private:\n+  ~D() { }\n+};\n+static_assert( !std::move_constructible<D> );"}, {"sha": "dfb66f4df9ade2b517660f4511297eea46fd0ba0", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.same/1.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.same%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.same%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.same%2F1.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,66 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( std::same_as<int, int> );\n+static_assert( !std::same_as<int&, int> );\n+static_assert( !std::same_as<int, int&> );\n+static_assert( !std::same_as<int&&, int&> );\n+static_assert( !std::same_as<const int, int> );\n+static_assert( std::same_as<const int, const int> );\n+\n+struct A { };\n+static_assert( std::same_as<A, A> );\n+static_assert( !std::same_as<A, const A> );\n+static_assert( std::same_as<A const, const A> );\n+static_assert( !std::same_as<volatile A, const A> );\n+\n+struct B : A { };\n+static_assert( !std::same_as<A, B> );\n+\n+template<typename T, typename U>\n+  constexpr int\n+  check_subsumption()\n+  { return 0; }\n+\n+template<typename T, typename U>\n+  requires std::same_as<T, U>\n+  constexpr int\n+  check_subsumption()\n+  { return 1; }\n+\n+template<typename T, typename U>\n+  requires std::same_as<U, T> && std::is_const_v<T>\n+  constexpr int\n+  check_subsumption()\n+  { return 2; }\n+\n+template<typename T, typename U>\n+  requires std::same_as<U, T> && std::is_volatile_v<T>\n+  constexpr int\n+  check_subsumption()\n+  { return 3; }\n+\n+static_assert( check_subsumption<short, long>() == 0 );\n+static_assert( check_subsumption<unsigned, unsigned>() == 1 );\n+// These will be ambiguous if same_as<T,U> doesn't subsume same_as<U,T>:\n+static_assert( check_subsumption<const char, const char>() == 2 );\n+static_assert( check_subsumption<volatile int, volatile int>() == 3 );"}, {"sha": "0b7f28cc6fb3a5ac5c3caf7ff247e34219d544ff", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.swappable/swap.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.swappable%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.swappable%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.swappable%2Fswap.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,78 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+namespace nu\n+{\n+  struct S { bool swapped = false; };\n+  constexpr void swap(S& l, S& r) { l.swapped = r.swapped = true; }\n+  struct T { int i; };\n+\n+  union U { char c; int i; };\n+  constexpr void swap(U& l, U& r) { l.i = r.i = 99; }\n+}\n+\n+constexpr bool check_struct_with_adl_swap(int i)\n+{\n+  nu::S s1, s2;\n+  std::ranges::swap(s1, s2);\n+  return s1.swapped && s2.swapped;\n+}\n+\n+static_assert(check_struct_with_adl_swap(1));\n+\n+constexpr bool check_array_with_adl_swap(int i)\n+{\n+  nu::S s1[2], s2[2];\n+  std::ranges::swap(s1, s2);\n+  return s1[0].swapped && s2[0].swapped && s1[1].swapped && s2[1].swapped;\n+}\n+\n+static_assert(check_array_with_adl_swap(1));\n+\n+constexpr bool check_struct_without_adl_swap(int i)\n+{\n+  nu::T t1{i}, t2{2*i};\n+  std::ranges::swap(t1, t2);\n+  return t1.i == 2*i && t2.i == i;\n+}\n+\n+static_assert(check_struct_without_adl_swap(1));\n+\n+constexpr bool check_array_without_adl_swap(int i)\n+{\n+  nu::T t1[2]{i, 2*i}, t2[2]{3*i, 4*i};\n+  std::ranges::swap(t1, t2);\n+  return t1[0].i == 3*i && t2[0].i == i && t1[1].i == 4*i && t2[1].i == 2*i;\n+}\n+\n+static_assert(check_array_without_adl_swap(1));\n+\n+\n+constexpr bool check_union_with_adl_swap(int i)\n+{\n+  nu::U u1{}, u2{};\n+  u1.i = u2.i = i;\n+  std::ranges::swap(u1, u2);\n+  return u1.i == 99 && u2.i == 99;\n+}\n+\n+static_assert(check_union_with_adl_swap(1));"}, {"sha": "b5a302468db05ff0e5164dd1b8e40d6b47dd0247", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.swappable/swappable.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.swappable%2Fswappable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.swappable%2Fswappable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.swappable%2Fswappable.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,38 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+namespace nu\n+{\n+  struct S { bool swapped = false; };\n+  constexpr void swap(S& l, S& r) { }\n+  struct T { int i; };\n+\n+  union U { char c; int i; };\n+  constexpr void swap(U& l, U& r) { }\n+}\n+\n+static_assert( std::swappable<nu::S> );\n+static_assert( !std::swappable<const nu::S> );\n+static_assert( std::swappable<nu::T> );\n+static_assert( !std::swappable<const nu::T> );\n+static_assert( std::swappable<nu::U> );\n+static_assert( !std::swappable<const nu::U> );"}, {"sha": "7d1147fdf7b42eb7aedb99e77c81ccb0b3187452", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.lang/concept.swappable/swappable_with.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.swappable%2Fswappable_with.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.swappable%2Fswappable_with.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.lang%2Fconcept.swappable%2Fswappable_with.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( std::swappable_with<int&, int&> );\n+static_assert( ! std::swappable_with<int, int> );\n+static_assert( ! std::swappable_with<int*, int*> );\n+static_assert( ! std::swappable_with<int&, const int&> );\n+static_assert( ! std::swappable_with<const int&, const int&> );\n+static_assert( ! std::swappable_with<int&, long&> );\n+\n+namespace N1\n+{\n+  struct Immovable\n+  {\n+    Immovable() = default;\n+    Immovable(Immovable&&) = delete;\n+  };\n+}\n+static_assert( ! std::swappable_with<N1::Immovable&, N1::Immovable&> );\n+\n+namespace N2\n+{\n+  struct Swappable\n+  {\n+    Swappable() = default;\n+    Swappable(Swappable&&) = delete;\n+    friend void swap(Swappable&, Swappable&) { }\n+  };\n+}\n+static_assert( std::swappable_with<N2::Swappable&, N2::Swappable&> );\n+\n+namespace N3\n+{\n+  struct A { };\n+  struct Proxy {\n+    Proxy(A&) { }\n+    friend void swap(Proxy, Proxy) { }\n+  };\n+}\n+\n+static_assert( std::swappable_with<N3::A&, N3::A&> );\n+static_assert( std::swappable_with<N3::A&, N3::Proxy> );\n+static_assert( std::swappable_with<N3::Proxy, N3::A&> );\n+static_assert( std::swappable_with<N3::Proxy, N3::Proxy> );\n+\n+struct C { C(int&) { } };\n+void swap(int&, C&) { } // not symmetrical\n+static_assert( ! std::swappable_with<int, C> );\n+static_assert( ! std::swappable_with<C, int> );\n+\n+struct D { D(int&) { } };\n+void swap(int&, D&) { }\n+void swap(D&&, int&) { } // only accepts rvalues\n+static_assert( ! std::swappable_with<int&, D> );\n+static_assert( ! std::swappable_with<D, int> );\n+\n+struct E { E(int&) { } };\n+void swap(int, E&&) { } // only accepts rvalues\n+void swap(E&, int) { }\n+static_assert( ! std::swappable_with<int, E> );\n+static_assert( ! std::swappable_with<E, int> );"}, {"sha": "abb16895eb6f5a20434e9fa45271abc9245dbec8", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.object/copyable.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fcopyable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fcopyable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fcopyable.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,108 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( std::copyable<int> );\n+static_assert( std::copyable<int*> );\n+static_assert( ! std::copyable<int&> );\n+static_assert( ! std::copyable<void> );\n+static_assert( ! std::copyable<void()> );\n+static_assert( ! std::copyable<void() noexcept> );\n+static_assert( ! std::copyable<void() const> );\n+\n+struct Trivial { };\n+static_assert( std::copyable<Trivial> );\n+\n+struct NotTrivial\n+{\n+  NotTrivial(int) { }\n+  NotTrivial(const NotTrivial&) { }\n+  NotTrivial& operator=(const NotTrivial&) { return *this; }\n+  ~NotTrivial() { }\n+};\n+static_assert( std::copyable<NotTrivial> );\n+\n+namespace N1\n+{\n+  struct Immovable\n+  {\n+    Immovable() = default;\n+    Immovable(Immovable&&) = delete;\n+  };\n+}\n+static_assert( ! std::copyable<N1::Immovable> );\n+\n+struct Movable\n+{\n+  Movable() = default;\n+  Movable(Movable&&) = default;\n+  Movable& operator=(Movable&&) = default;\n+};\n+static_assert( ! std::copyable<Movable> );\n+\n+struct MovableAndCopyAssignable\n+{\n+  MovableAndCopyAssignable() = default;\n+  MovableAndCopyAssignable(MovableAndCopyAssignable&&) = default;\n+  MovableAndCopyAssignable& operator=(MovableAndCopyAssignable&&) = default;\n+  MovableAndCopyAssignable& operator=(const MovableAndCopyAssignable&) = default;\n+};\n+static_assert( ! std::copyable<MovableAndCopyAssignable> );\n+\n+struct MovableAndCopyConstructible\n+{\n+  MovableAndCopyConstructible() = default;\n+  MovableAndCopyConstructible(MovableAndCopyConstructible&&) = default;\n+  MovableAndCopyConstructible(const MovableAndCopyConstructible&) = default;\n+  MovableAndCopyConstructible& operator=(MovableAndCopyConstructible&&) = default;\n+};\n+static_assert( ! std::copyable<MovableAndCopyConstructible> );\n+\n+namespace N2\n+{\n+  struct Swappable\n+  {\n+    Swappable() = default;\n+    Swappable(Swappable&&) = default;\n+    friend void swap(Swappable&, Swappable&) { }\n+  };\n+}\n+static_assert( ! std::copyable<N2::Swappable> );\n+\n+struct NotAssignable\n+{\n+  NotAssignable() = default;\n+  NotAssignable(NotAssignable&&) = default;\n+  NotAssignable& operator=(NotAssignable&&) = default;\n+  NotAssignable(const NotAssignable&) = default;\n+  NotAssignable& operator=(const NotAssignable&) = delete;\n+  friend void swap(NotAssignable&, NotAssignable&) { }\n+};\n+static_assert( ! std::copyable<NotAssignable> );\n+\n+struct NotSwappable\n+{\n+  NotSwappable() = default;\n+  NotSwappable(const NotSwappable&) = default;\n+  NotSwappable& operator=(const NotSwappable&) = default;\n+};\n+void swap(NotSwappable&, NotSwappable&) = delete;\n+static_assert( std::copyable<NotSwappable> ); // ranges::swap still works!"}, {"sha": "48fddc1e113bed2bec9a1b0821d8b8146ce8e062", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.object/movable.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fmovable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fmovable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fmovable.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( std::movable<int> );\n+static_assert( std::movable<int*> );\n+static_assert( ! std::movable<int&> );\n+static_assert( ! std::movable<void> );\n+static_assert( ! std::movable<void()> );\n+static_assert( ! std::movable<void() noexcept> );\n+static_assert( ! std::movable<void() const> );\n+\n+struct Trivial { };\n+static_assert( std::movable<Trivial> );\n+\n+struct NotTrivial\n+{\n+  NotTrivial(int) { }\n+  NotTrivial(NotTrivial&&) { }\n+  NotTrivial& operator=(NotTrivial&&) { return *this; }\n+  ~NotTrivial() { }\n+};\n+static_assert( std::movable<NotTrivial> );\n+\n+namespace N1\n+{\n+  struct Immovable\n+  {\n+    Immovable() = default;\n+    Immovable(Immovable&&) = delete;\n+  };\n+}\n+static_assert( ! std::movable<N1::Immovable> );\n+\n+namespace N2\n+{\n+  struct Swappable\n+  {\n+    Swappable() = default;\n+    Swappable(Swappable&&) = delete;\n+    Swappable& operator=(Swappable&&) = default;\n+    friend void swap(Swappable&, Swappable&) { }\n+  };\n+}\n+static_assert( ! std::movable<N2::Swappable> );\n+\n+struct NotAssignable\n+{\n+  NotAssignable() = default;\n+  NotAssignable(NotAssignable&&) = default;\n+  NotAssignable& operator=(NotAssignable&&) = delete;\n+  friend void swap(NotAssignable&, NotAssignable&) { }\n+};\n+static_assert( ! std::movable<NotAssignable> );\n+\n+struct NotSwappable\n+{\n+  NotSwappable() = default;\n+  NotSwappable(NotSwappable&&) = default;\n+  NotSwappable& operator=(NotSwappable&&) = default;\n+};\n+void swap(NotSwappable&, NotSwappable&) = delete;\n+static_assert( std::movable<NotSwappable> ); // ranges::swap still works!"}, {"sha": "338cf1ba32c87a7bda7b4fc03beee0cd2e50b4cf", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.object/regular.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fregular.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fregular.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fregular.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,64 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( std::regular<int> );\n+static_assert( std::regular<int*> );\n+static_assert( ! std::regular<int&> );\n+static_assert( ! std::regular<void> );\n+static_assert( ! std::regular<void()> );\n+static_assert( ! std::regular<void() noexcept> );\n+static_assert( ! std::regular<void() const> );\n+\n+struct Trivial { };\n+static_assert( ! std::regular<Trivial> );\n+\n+struct NotTrivial\n+{\n+  NotTrivial() { }\n+  ~NotTrivial() { }\n+};\n+static_assert( ! std::regular<NotTrivial> );\n+\n+struct NotDefaultConstructible\n+{\n+  NotDefaultConstructible(int) { }\n+};\n+static_assert( ! std::regular<NotDefaultConstructible> );\n+\n+struct HasReference\n+{\n+  int& ref;\n+};\n+static_assert( ! std::regular<HasReference> );\n+\n+struct HasEq { };\n+bool operator==(HasEq, HasEq) { return true; }\n+#ifdef __cpp_lib_three_way_comparison\n+static_assert( std::regular<HasEq> );\n+#else\n+static_assert( ! std::regular<HasEq> );\n+#endif\n+\n+struct HasEqNeq { };\n+bool operator==(HasEqNeq, HasEqNeq) { return true; }\n+bool operator!=(HasEqNeq, HasEqNeq) { return false; }\n+static_assert( std::regular<HasEqNeq> );"}, {"sha": "1e095d60194234d8a98ed5027722d783c555789a", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.object/semiregular.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fsemiregular.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc219ae689fd94bbe1bb12686bb04fa09b93046/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fsemiregular.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fsemiregular.cc?ref=cfc219ae689fd94bbe1bb12686bb04fa09b93046", "patch": "@@ -0,0 +1,51 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <concepts>\n+\n+static_assert( std::semiregular<int> );\n+static_assert( std::semiregular<int*> );\n+static_assert( ! std::semiregular<int&> );\n+static_assert( ! std::semiregular<void> );\n+static_assert( ! std::semiregular<void()> );\n+static_assert( ! std::semiregular<void() noexcept> );\n+static_assert( ! std::semiregular<void() const> );\n+\n+struct Trivial { };\n+static_assert( std::semiregular<Trivial> );\n+\n+struct NotTrivial\n+{\n+  NotTrivial() { }\n+  ~NotTrivial() { }\n+};\n+static_assert( std::semiregular<NotTrivial> );\n+\n+struct NotDefaultConstructible\n+{\n+  NotDefaultConstructible(int) { }\n+};\n+static_assert( ! std::semiregular<NotDefaultConstructible> );\n+\n+struct HasReference\n+{\n+  int& ref;\n+};\n+static_assert( ! std::semiregular<HasReference> );"}]}