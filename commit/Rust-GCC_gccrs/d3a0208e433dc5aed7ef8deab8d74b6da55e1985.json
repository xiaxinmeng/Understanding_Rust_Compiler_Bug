{"sha": "d3a0208e433dc5aed7ef8deab8d74b6da55e1985", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNhMDIwOGU0MzNkYzVhZWQ3ZWY4ZGVhYjhkNzRiNmRhNTVlMTk4NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-05-17T14:35:38Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-05-18T11:55:37Z"}, "message": "Avoid setting TREE_ADDRESSABLE on stack vars during RTL expansion\n\nThis avoids setting TREE_ADDRESSABLE on variables we want to force to\nthe stack.  Instead track those in a temporary bitmap and force\nstack expansion that way, leaving TREE_ADDRESSABLE alone, not\npessimizing future alias queries.\n\n2021-05-17  Richard Biener  <rguenther@suse.de>\n\n\t* cfgexpand.c (expand_one_var): Pass in forced_stack_var\n\tand honor it when expanding.\n\t(expand_used_vars_for_block): Pass through forced_stack_var.\n\t(expand_used_vars): Likewise.\n\t(discover_nonconstant_array_refs_r): Set bits in\n\tforced_stack_vars instead of marking vars TREE_ADDRESSABLE.\n\t(avoid_type_punning_on_regs): Likewise.\n\t(discover_nonconstant_array_refs): Likewise.\n\t(pass_expand::execute): Create and pass down forced_stack_var\n\tbitmap.  For parameters and returns temporarily set\n\tTREE_ADDRESSABLE when expand_function_start.", "tree": {"sha": "2e65420ea3648c9aa6d0a5c0f7623792d5eb3fe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e65420ea3648c9aa6d0a5c0f7623792d5eb3fe4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3a0208e433dc5aed7ef8deab8d74b6da55e1985", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a0208e433dc5aed7ef8deab8d74b6da55e1985", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3a0208e433dc5aed7ef8deab8d74b6da55e1985", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a0208e433dc5aed7ef8deab8d74b6da55e1985/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5c3145ad9ac04654d4947d34d1e9dc5c26f4c53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c3145ad9ac04654d4947d34d1e9dc5c26f4c53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5c3145ad9ac04654d4947d34d1e9dc5c26f4c53"}], "stats": {"total": 107, "additions": 75, "deletions": 32}, "files": [{"sha": "3e6f7cafc4c383a07b17f90bb1f4bd01eb201b0b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 75, "deletions": 32, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a0208e433dc5aed7ef8deab8d74b6da55e1985/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a0208e433dc5aed7ef8deab8d74b6da55e1985/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=d3a0208e433dc5aed7ef8deab8d74b6da55e1985", "patch": "@@ -1719,7 +1719,8 @@ defer_stack_allocation (tree var, bool toplevel)\n */\n \n static poly_uint64\n-expand_one_var (tree var, bool toplevel, bool really_expand)\n+expand_one_var (tree var, bool toplevel, bool really_expand,\n+\t\tbitmap forced_stack_var = NULL)\n {\n   unsigned int align = BITS_PER_UNIT;\n   tree origvar = var;\n@@ -1797,7 +1798,9 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n \t    expand_one_error_var (var);\n \t}\n     }\n-  else if (use_register_for_decl (var))\n+  else if (use_register_for_decl (var)\n+\t   && (!forced_stack_var\n+\t       || !bitmap_bit_p (forced_stack_var, DECL_UID (var))))\n     {\n       if (really_expand)\n         expand_one_register_var (origvar);\n@@ -1842,7 +1845,7 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n    TOPLEVEL is true if this is the outermost BLOCK.  */\n \n static void\n-expand_used_vars_for_block (tree block, bool toplevel)\n+expand_used_vars_for_block (tree block, bool toplevel, bitmap forced_stack_vars)\n {\n   tree t;\n \n@@ -1851,11 +1854,11 @@ expand_used_vars_for_block (tree block, bool toplevel)\n     if (TREE_USED (t)\n         && ((!VAR_P (t) && TREE_CODE (t) != RESULT_DECL)\n \t    || !DECL_NONSHAREABLE (t)))\n-      expand_one_var (t, toplevel, true);\n+      expand_one_var (t, toplevel, true, forced_stack_vars);\n \n   /* Expand all variables at containing levels.  */\n   for (t = BLOCK_SUBBLOCKS (block); t ; t = BLOCK_CHAIN (t))\n-    expand_used_vars_for_block (t, false);\n+    expand_used_vars_for_block (t, false, forced_stack_vars);\n }\n \n /* A subroutine of expand_used_vars.  Walk down through the BLOCK tree\n@@ -2139,7 +2142,7 @@ stack_protect_return_slot_p ()\n /* Expand all variables used in the function.  */\n \n static rtx_insn *\n-expand_used_vars (void)\n+expand_used_vars (bitmap forced_stack_vars)\n {\n   tree var, outer_block = DECL_INITIAL (current_function_decl);\n   auto_vec<tree> maybe_local_decls;\n@@ -2216,7 +2219,7 @@ expand_used_vars (void)\n       TREE_USED (var) = 1;\n \n       if (expand_now)\n-\texpand_one_var (var, true, true);\n+\texpand_one_var (var, true, true, forced_stack_vars);\n \n     next:\n       if (DECL_ARTIFICIAL (var) && !DECL_IGNORED_P (var))\n@@ -2251,7 +2254,7 @@ expand_used_vars (void)\n \n   /* At this point, all variables within the block tree with TREE_USED\n      set are actually used by the optimized function.  Lay them out.  */\n-  expand_used_vars_for_block (outer_block, true);\n+  expand_used_vars_for_block (outer_block, true, forced_stack_vars);\n \n   tree attribs = DECL_ATTRIBUTES (current_function_decl);\n   if (stack_vars_num > 0)\n@@ -6241,9 +6244,10 @@ construct_exit_block (void)\n \n static tree\n discover_nonconstant_array_refs_r (tree * tp, int *walk_subtrees,\n-\t\t\t\t   void *data ATTRIBUTE_UNUSED)\n+\t\t\t\t   void *data)\n {\n   tree t = *tp;\n+  bitmap forced_stack_vars = (bitmap)((walk_stmt_info *)data)->info;\n \n   if (IS_TYPE_OR_DECL_P (t))\n     *walk_subtrees = 0;\n@@ -6267,8 +6271,9 @@ discover_nonconstant_array_refs_r (tree * tp, int *walk_subtrees,\n \t{\n \t  t = get_base_address (t);\n \t  if (t && DECL_P (t)\n-              && DECL_MODE (t) != BLKmode)\n-\t    TREE_ADDRESSABLE (t) = 1;\n+\t      && DECL_MODE (t) != BLKmode\n+\t      && !TREE_ADDRESSABLE (t))\n+\t    bitmap_set_bit (forced_stack_vars, DECL_UID (t));\n \t}\n \n       *walk_subtrees = 0;\n@@ -6283,9 +6288,10 @@ discover_nonconstant_array_refs_r (tree * tp, int *walk_subtrees,\n       tree base = get_base_address (t);\n       if (base\n \t  && DECL_P (base)\n+\t  && !TREE_ADDRESSABLE (base)\n \t  && DECL_MODE (base) != BLKmode\n \t  && GET_MODE_SIZE (DECL_MODE (base)).is_constant ())\n-\tTREE_ADDRESSABLE (base) = 1;\n+\tbitmap_set_bit (forced_stack_vars, DECL_UID (base));\n       *walk_subtrees = 0;\n     }\n \n@@ -6298,7 +6304,7 @@ discover_nonconstant_array_refs_r (tree * tp, int *walk_subtrees,\n    suitable for raw bits processing (like XFmode on i?86).  */\n \n static void\n-avoid_type_punning_on_regs (tree t)\n+avoid_type_punning_on_regs (tree t, bitmap forced_stack_vars)\n {\n   machine_mode access_mode = TYPE_MODE (TREE_TYPE (t));\n   if (access_mode != BLKmode\n@@ -6312,7 +6318,7 @@ avoid_type_punning_on_regs (tree t)\n \t\t   GET_MODE_BITSIZE (GET_MODE_INNER (DECL_MODE (base))))\n       /* Double check in the expensive way we really would get a pseudo.  */\n       && use_register_for_decl (base))\n-    TREE_ADDRESSABLE (base) = 1;\n+    bitmap_set_bit (forced_stack_vars, DECL_UID (base));\n }\n \n /* RTL expansion is not able to compile array references with variable\n@@ -6321,38 +6327,49 @@ avoid_type_punning_on_regs (tree t)\n    scenario.  */\n \n static void\n-discover_nonconstant_array_refs (void)\n+discover_nonconstant_array_refs (bitmap forced_stack_vars)\n {\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n \n+  walk_stmt_info wi = {};\n+  wi.info = forced_stack_vars;\n   FOR_EACH_BB_FN (bb, cfun)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n \tgimple *stmt = gsi_stmt (gsi);\n \tif (!is_gimple_debug (stmt))\n \t  {\n-\t    walk_gimple_op (stmt, discover_nonconstant_array_refs_r, NULL);\n+\t    walk_gimple_op (stmt, discover_nonconstant_array_refs_r, &wi);\n \t    gcall *call = dyn_cast <gcall *> (stmt);\n \t    if (call && gimple_call_internal_p (call))\n-\t      switch (gimple_call_internal_fn (call))\n-\t\t{\n-\t\tcase IFN_LOAD_LANES:\n-\t\t  /* The source must be a MEM.  */\n-\t\t  mark_addressable (gimple_call_arg (call, 0));\n-\t\t  break;\n-\t\tcase IFN_STORE_LANES:\n-\t\t  /* The destination must be a MEM.  */\n-\t\t  mark_addressable (gimple_call_lhs (call));\n-\t\t  break;\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n+\t      {\n+\t\ttree cand = NULL_TREE;\n+\t\tswitch (gimple_call_internal_fn (call))\n+\t\t  {\n+\t\t  case IFN_LOAD_LANES:\n+\t\t    /* The source must be a MEM.  */\n+\t\t    cand = gimple_call_arg (call, 0);\n+\t\t    break;\n+\t\t  case IFN_STORE_LANES:\n+\t\t    /* The destination must be a MEM.  */\n+\t\t    cand = gimple_call_lhs (call);\n+\t\t    break;\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\t\tif (cand)\n+\t\t  cand = get_base_address (cand);\n+\t\tif (cand\n+\t\t    && DECL_P (cand)\n+\t\t    && use_register_for_decl (cand))\n+\t\t  bitmap_set_bit (forced_stack_vars, DECL_UID (cand));\n+\t      }\n \t    if (gimple_vdef (stmt))\n \t      {\n \t\ttree t = gimple_get_lhs (stmt);\n \t\tif (t && REFERENCE_CLASS_P (t))\n-\t\t  avoid_type_punning_on_regs (t);\n+\t\t  avoid_type_punning_on_regs (t, forced_stack_vars);\n \t      }\n \t  }\n       }\n@@ -6553,7 +6570,8 @@ pass_expand::execute (function *fun)\n     }\n \n   /* Mark arrays indexed with non-constant indices with TREE_ADDRESSABLE.  */\n-  discover_nonconstant_array_refs ();\n+  auto_bitmap forced_stack_vars;\n+  discover_nonconstant_array_refs (forced_stack_vars);\n \n   /* Make sure all values used by the optimization passes have sane\n      defaults.  */\n@@ -6601,7 +6619,7 @@ pass_expand::execute (function *fun)\n   timevar_push (TV_VAR_EXPAND);\n   start_sequence ();\n \n-  var_ret_seq = expand_used_vars ();\n+  var_ret_seq = expand_used_vars (forced_stack_vars);\n \n   var_seq = get_insns ();\n   end_sequence ();\n@@ -6621,9 +6639,34 @@ pass_expand::execute (function *fun)\n \t\t (int) param_ssp_buffer_size);\n     }\n \n+  /* Temporarily mark PARM_DECLs and RESULT_DECLs we need to expand to\n+     memory addressable so expand_function_start can emit the required\n+     copies.  */\n+  auto_vec<tree, 16> marked_parms;\n+  for (tree parm = DECL_ARGUMENTS (current_function_decl); parm;\n+       parm = DECL_CHAIN (parm))\n+    if (!TREE_ADDRESSABLE (parm)\n+\t&& bitmap_bit_p (forced_stack_vars, DECL_UID (parm)))\n+      {\n+\tTREE_ADDRESSABLE (parm) = 1;\n+\tmarked_parms.safe_push (parm);\n+      }\n+  if (DECL_RESULT (current_function_decl)\n+      && !TREE_ADDRESSABLE (DECL_RESULT (current_function_decl))\n+      && bitmap_bit_p (forced_stack_vars,\n+\t\t       DECL_UID (DECL_RESULT (current_function_decl))))\n+    {\n+      TREE_ADDRESSABLE (DECL_RESULT (current_function_decl)) = 1;\n+      marked_parms.safe_push (DECL_RESULT (current_function_decl));\n+    }\n+\n   /* Set up parameters and prepare for return, for the function.  */\n   expand_function_start (current_function_decl);\n \n+  /* Clear TREE_ADDRESSABLE again.  */\n+  while (!marked_parms.is_empty ())\n+    TREE_ADDRESSABLE (marked_parms.pop ()) = 0;\n+\n   /* If we emitted any instructions for setting up the variables,\n      emit them before the FUNCTION_START note.  */\n   if (var_seq)"}]}