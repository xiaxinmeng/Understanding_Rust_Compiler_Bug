{"sha": "e6df04c105464436e700013e1f665ebf0f94c9f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZkZjA0YzEwNTQ2NDQzNmU3MDAwMTNlMWY2NjVlYmYwZjk0YzlmMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-02-27T21:54:25Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-02-27T21:54:25Z"}, "message": "PR c++/86969 - ICE with constexpr if and recursive generic lambdas.\n\nHere, the problem was that extract_local_specs wasn't seeing that we use\n'self' inside the lambda in the else of the inner constexpr if, because we\ndon't walk into lambda bodies and we didn't capture it in the lambda because\n'self' is still dependent.  Marek recently changed process_outer_var_ref to\ndo more implicit capture in templates; this example shows that we should\nalways capture non-packs, so that we can continue to not walk into lambda\nbodies.  We do walk into lambda bodies for pack expansions, so we can delay\ndeciding whether we're capturing a single element or the entire pack.\n\nImmediately capturing a VLA means we need to create a dependent VLA capture\ntype, and not in the context of the lambda op(), since trying to look up the\ninstantiation of the op() while we're substituting into the capture list\nwould crash.  So I force TYPE_CONTEXT and the binding level out to the\nenclosing function before pushtag, avoid adding a TAG_DEFN, and instead\nforce the type to be complete in tsubst_lambda_expr.\n\n\t* semantics.c (process_outer_var_ref): Do capture dependent vars.\n\t* class.c (finish_struct): Only add TAG_DEFN if T is in\n\tcurrent_function_decl.\n\t* lambda.c (vla_capture_type): Force the capture type out into the\n\tlambda's enclosing function.\n\t(add_capture): Pass in the lambda.\n\t* pt.c (tsubst_lambda_expr): complete_type a VLA capture type.\n\nFrom-SVN: r269265", "tree": {"sha": "13b41c71195608f85e18e625f3a53dd5ecb4a1ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13b41c71195608f85e18e625f3a53dd5ecb4a1ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6df04c105464436e700013e1f665ebf0f94c9f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6df04c105464436e700013e1f665ebf0f94c9f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6df04c105464436e700013e1f665ebf0f94c9f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6df04c105464436e700013e1f665ebf0f94c9f2/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5b0a9c7cc1fa723369df61598cd3a8af4d21f5ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0a9c7cc1fa723369df61598cd3a8af4d21f5ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b0a9c7cc1fa723369df61598cd3a8af4d21f5ff"}], "stats": {"total": 74, "additions": 68, "deletions": 6}, "files": [{"sha": "e4d876b4c0bad9911a3e27283cb292ee529ff100", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6df04c105464436e700013e1f665ebf0f94c9f2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6df04c105464436e700013e1f665ebf0f94c9f2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e6df04c105464436e700013e1f665ebf0f94c9f2", "patch": "@@ -1,3 +1,14 @@\n+2019-02-27  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/86969 - ICE with constexpr if and recursive generic lambdas.\n+\t* semantics.c (process_outer_var_ref): Do capture dependent vars.\n+\t* class.c (finish_struct): Only add TAG_DEFN if T is in\n+\tcurrent_function_decl.\n+\t* lambda.c (vla_capture_type): Force the capture type out into the\n+\tlambda's enclosing function.\n+\t(add_capture): Pass in the lambda.\n+\t* pt.c (tsubst_lambda_expr): complete_type a VLA capture type.\n+\n 2019-02-27  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/89511 - ICE with using-declaration and unscoped enumerator."}, {"sha": "830ede56af8b5e5e8d65af4cd4f3bd4151e3d680", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6df04c105464436e700013e1f665ebf0f94c9f2/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6df04c105464436e700013e1f665ebf0f94c9f2/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e6df04c105464436e700013e1f665ebf0f94c9f2", "patch": "@@ -7246,6 +7246,7 @@ finish_struct (tree t, tree attributes)\n     error (\"trying to finish struct, but kicked out due to previous parse errors\");\n \n   if (processing_template_decl && at_function_scope_p ()\n+      && TYPE_CONTEXT (t) == current_function_decl\n       /* Lambdas are defined by the LAMBDA_EXPR.  */\n       && !LAMBDA_TYPE_P (t))\n     add_stmt (build_min (TAG_DEFN, t));"}, {"sha": "c25df2fbc0ee63ccfddffa6f68c20f3ddaccede7", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6df04c105464436e700013e1f665ebf0f94c9f2/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6df04c105464436e700013e1f665ebf0f94c9f2/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=e6df04c105464436e700013e1f665ebf0f94c9f2", "patch": "@@ -479,9 +479,31 @@ static GTY(()) tree max_id;\n    an array of runtime length.  */\n \n static tree\n-vla_capture_type (tree array_type)\n+vla_capture_type (tree array_type, tree lambda)\n {\n-  tree type = xref_tag (record_type, make_anon_name (), ts_current, false);\n+  tree closure = LAMBDA_EXPR_CLOSURE (lambda);\n+  tree type = make_class_type (RECORD_TYPE);\n+  cp_binding_level *slev = current_binding_level;\n+  if (closure)\n+    {\n+      /* If we're already inside the lambda body, force the capture type out\n+\t into the enclosing context, so we don't crash trying to instantiate\n+\t the capture field in tsubst_lambda_expr.  We won't have a TAG_DEFN\n+\t from finish_struct in the enclosing context, which we work around in\n+\t tsubst_lambda_expr.  */\n+      TYPE_CONTEXT (type) = TYPE_CONTEXT (closure);\n+      cp_binding_level *b = current_binding_level;\n+      for (;; b = b->level_chain)\n+\tif (b->this_entity == closure)\n+\t  {\n+\t    while (b->this_entity == closure)\n+\t      b = b->level_chain;\n+\t    break;\n+\t  }\n+      current_binding_level = b;\n+    }\n+  type = pushtag (make_anon_name (), type, ts_current);\n+  current_binding_level = slev;\n   xref_basetypes (type, NULL_TREE);\n   type = begin_class_definition (type);\n   if (!ptr_id)\n@@ -541,7 +563,7 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n       initializer = build_constructor_va (init_list_type_node, 2,\n \t\t\t\t\t  NULL_TREE, build_address (elt),\n \t\t\t\t\t  NULL_TREE, array_type_nelts (type));\n-      type = vla_capture_type (type);\n+      type = vla_capture_type (type, lambda);\n     }\n   else if (!dependent_type_p (type)\n \t   && variably_modified_type_p (type, NULL_TREE))"}, {"sha": "673ea8e2258136722b09651d9b65879fde0f081e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6df04c105464436e700013e1f665ebf0f94c9f2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6df04c105464436e700013e1f665ebf0f94c9f2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e6df04c105464436e700013e1f665ebf0f94c9f2", "patch": "@@ -17989,6 +17989,10 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       if (PACK_EXPANSION_P (ofield))\n \tofield = PACK_EXPANSION_PATTERN (ofield);\n       tree field = tsubst_decl (ofield, args, complain);\n+      if (DECL_VLA_CAPTURE_P (ofield))\n+\t/* The type of a VLA capture might not have a TAG_DEFN in the enclosing\n+\t   context, so complete it here.  */\n+\tcomplete_type (TREE_TYPE (field));\n \n       if (DECL_PACK_P (ofield) && !DECL_NORMAL_CAPTURE_P (ofield))\n \t{"}, {"sha": "d1a378acd98965fe3612540f1757af0ae4d79c23", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6df04c105464436e700013e1f665ebf0f94c9f2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6df04c105464436e700013e1f665ebf0f94c9f2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e6df04c105464436e700013e1f665ebf0f94c9f2", "patch": "@@ -3469,10 +3469,12 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain, bool odr_use)\n \t= decl_function_context (containing_function);\n     }\n \n-  /* In a lambda within a template, wait until instantiation\n-     time to implicitly capture a dependent type.  */\n+  /* In a lambda within a template, wait until instantiation time to implicitly\n+     capture a parameter pack.  We want to wait because we don't know if we're\n+     capturing the whole pack or a single element, and it's OK to wait because\n+     find_parameter_packs_r walks into the lambda body.  */\n   if (context == containing_function\n-      && dependent_type_p (TREE_TYPE (decl)))\n+      && DECL_PACK_P (decl))\n     return decl;\n \n   if (lambda_expr && VAR_P (decl)"}, {"sha": "a1a6e0b78f69b150bfd4c26ed26b1dd1673a1515", "filename": "gcc/testsuite/g++.dg/cpp1z/constexpr-if27.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6df04c105464436e700013e1f665ebf0f94c9f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-if27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6df04c105464436e700013e1f665ebf0f94c9f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-if27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-if27.C?ref=e6df04c105464436e700013e1f665ebf0f94c9f2", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/86969\n+// { dg-do compile { target c++17 } }\n+\n+auto compose = [](auto... fs) {\n+    if constexpr (sizeof...(fs) == 0) {\n+        return [](auto x) { return x; };\n+    } else {\n+        auto fn = [](auto self, auto f, auto... fs) {\n+            if constexpr (sizeof...(fs) == 0) return f;\n+            else return [=](auto x) { \n+                return f(self(self, fs...)(x));\n+            };\n+        };\n+        return fn(fn, fs...);\n+    }\n+};\n+\n+static_assert(compose(\n+        [](auto x) { return x * 3; },\n+        [](auto x) { return x + 1; },\n+        [](auto x) { return x / 2; }\n+    )(6) == 12);"}]}