{"sha": "111c3f39f58e7fd55f072243e6d8dc31987f0e45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTExYzNmMzlmNThlN2ZkNTVmMDcyMjQzZTZkOGRjMzE5ODdmMGU0NQ==", "commit": {"author": {"name": "Rong Xu", "email": "xur@google.com", "date": "2013-10-03T17:15:56Z"}, "committer": {"name": "Rong Xu", "email": "xur@gcc.gnu.org", "date": "2013-10-03T17:15:56Z"}, "message": "ipa-inline-analysis.c (find_foldable_builtin_expect): Find the candidate of builtin_expect such that we should fix the size/time...\n\n        * ipa-inline-analysis.c (find_foldable_builtin_expect): Find\n        the candidate of builtin_expect such that we should fix the \n        size/time estimation.\n        (estimate_function_body_sizes): Do the acutally size/time fix-up\n        for builtin_expect.\n\nFrom-SVN: r203168", "tree": {"sha": "efe579f6f8610a35fc0a9ddc6b4829762b5e7461", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efe579f6f8610a35fc0a9ddc6b4829762b5e7461"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/111c3f39f58e7fd55f072243e6d8dc31987f0e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/111c3f39f58e7fd55f072243e6d8dc31987f0e45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/111c3f39f58e7fd55f072243e6d8dc31987f0e45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/111c3f39f58e7fd55f072243e6d8dc31987f0e45/comments", "author": {"login": "xur-llvm", "id": 59886942, "node_id": "MDQ6VXNlcjU5ODg2OTQy", "avatar_url": "https://avatars.githubusercontent.com/u/59886942?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xur-llvm", "html_url": "https://github.com/xur-llvm", "followers_url": "https://api.github.com/users/xur-llvm/followers", "following_url": "https://api.github.com/users/xur-llvm/following{/other_user}", "gists_url": "https://api.github.com/users/xur-llvm/gists{/gist_id}", "starred_url": "https://api.github.com/users/xur-llvm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xur-llvm/subscriptions", "organizations_url": "https://api.github.com/users/xur-llvm/orgs", "repos_url": "https://api.github.com/users/xur-llvm/repos", "events_url": "https://api.github.com/users/xur-llvm/events{/privacy}", "received_events_url": "https://api.github.com/users/xur-llvm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "942df7390fb64e26bb7ed6ac58ee9911be4ea5cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/942df7390fb64e26bb7ed6ac58ee9911be4ea5cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/942df7390fb64e26bb7ed6ac58ee9911be4ea5cb"}], "stats": {"total": 90, "additions": 90, "deletions": 0}, "files": [{"sha": "f6c57ff0b9865801be3ba8d9465cda52aaec2dc2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/111c3f39f58e7fd55f072243e6d8dc31987f0e45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/111c3f39f58e7fd55f072243e6d8dc31987f0e45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=111c3f39f58e7fd55f072243e6d8dc31987f0e45", "patch": "@@ -1,3 +1,11 @@\n+2013-10-03  Rong Xu  <xur@google.com>\n+\n+        * ipa-inline-analysis.c (find_foldable_builtin_expect): Find\n+        the candidate of builtin_expect such that we should fix the \n+        size/time estimation.\n+        (estimate_function_body_sizes): Do the acutally size/time fix-up\n+        for builtin_expect.\n+\n 2013-10-03  Rong Xu  <xur@google.com>\n \n         * predict.c (tree_predict_by_opcode): Get the probability"}, {"sha": "304f9f5d7cc8a03c8fc16187cb049c6bc3a21df2", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/111c3f39f58e7fd55f072243e6d8dc31987f0e45/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/111c3f39f58e7fd55f072243e6d8dc31987f0e45/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=111c3f39f58e7fd55f072243e6d8dc31987f0e45", "patch": "@@ -2257,6 +2257,77 @@ array_index_predicate (struct inline_summary *info,\n   return p;\n }\n \n+/* For a typical usage of __builtin_expect (a<b, 1), we\n+   may introduce an extra relation stmt:\n+   With the builtin, we have\n+     t1 = a <= b;\n+     t2 = (long int) t1;\n+     t3 = __builtin_expect (t2, 1);\n+     if (t3 != 0)\n+       goto ...\n+   Without the builtin, we have\n+     if (a<=b)\n+       goto...\n+   This affects the size/time estimation and may have\n+   an impact on the earlier inlining.\n+   Here find this pattern and fix it up later.  */\n+\n+static gimple\n+find_foldable_builtin_expect (basic_block bb)\n+{\n+  gimple_stmt_iterator bsi;\n+\n+  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+    {\n+      gimple stmt = gsi_stmt (bsi);\n+      if (gimple_call_builtin_p (stmt, BUILT_IN_EXPECT))\n+        {\n+          tree var = gimple_call_lhs (stmt);\n+          tree arg = gimple_call_arg (stmt, 0);\n+          use_operand_p use_p;\n+          gimple use_stmt;\n+          bool match = false;\n+          bool done = false;\n+\n+          if (!var || !arg)\n+            continue;\n+          gcc_assert (TREE_CODE (var) == SSA_NAME);\n+\n+          while (TREE_CODE (arg) == SSA_NAME)\n+            {\n+              gimple stmt_tmp = SSA_NAME_DEF_STMT (arg);\n+              if (!is_gimple_assign (stmt_tmp))\n+                break;\n+              switch (gimple_assign_rhs_code (stmt_tmp))\n+                {\n+                  case LT_EXPR:\n+                  case LE_EXPR:\n+                  case GT_EXPR:\n+                  case GE_EXPR:\n+                  case EQ_EXPR:\n+                  case NE_EXPR:\n+                    match = true;\n+                    done = true;\n+                    break;\n+                  case NOP_EXPR:\n+                    break;\n+                  default:\n+                    done = true;\n+                    break;\n+                }\n+              if (done)\n+                break;\n+              arg = gimple_assign_rhs1 (stmt_tmp);\n+            }\n+\n+          if (match && single_imm_use (var, &use_p, &use_stmt)\n+              && gimple_code (use_stmt) == GIMPLE_COND)\n+            return use_stmt;\n+        }\n+    }\n+  return NULL;\n+}\n+\n /* Compute function body size parameters for NODE.\n    When EARLY is true, we compute only simple summaries without\n    non-trivial predicates to drive the early inliner.  */\n@@ -2280,6 +2351,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   int nblocks, n;\n   int *order;\n   predicate array_index = true_predicate ();\n+  gimple fix_builtin_expect_stmt;\n \n   info->conds = NULL;\n   info->entry = NULL;\n@@ -2360,6 +2432,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t    }\n \t}\n \n+      fix_builtin_expect_stmt = find_foldable_builtin_expect (bb);\n+\n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n \t  gimple stmt = gsi_stmt (bsi);\n@@ -2368,6 +2442,14 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  int prob;\n \t  struct predicate will_be_nonconstant;\n \n+          /* This relation stmt should be folded after we remove\n+             buildin_expect call. Adjust the cost here.  */\n+\t  if (stmt == fix_builtin_expect_stmt)\n+            {\n+              this_size--;\n+              this_time--;\n+            }\n+\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \"  \");"}]}