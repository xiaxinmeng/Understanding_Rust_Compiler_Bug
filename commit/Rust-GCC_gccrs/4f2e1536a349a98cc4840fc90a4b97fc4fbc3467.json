{"sha": "4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYyZTE1MzZhMzQ5YTk4Y2M0ODQwZmM5MGE0Yjk3ZmM0ZmJjMzQ2Nw==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2016-05-12T15:28:08Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2016-05-12T15:28:08Z"}, "message": "re PR c/70756 (Wrong column number shown for \"error: invalid use of flexible array member\")\n\n\tPR c/70756\n\t* c-common.c (pointer_int_sum): Call size_in_bytes_loc instead of\n\tsize_in_bytes and pass LOC to it.\n\n\t* c-decl.c (build_compound_literal): Pass LOC down to\n\tc_incomplete_type_error.\n\t* c-tree.h (require_complete_type): Adjust declaration.\n\t(c_incomplete_type_error): Likewise.\n\t* c-typeck.c (require_complete_type): Add location parameter, pass it\n\tdown to c_incomplete_type_error.\n\t(c_incomplete_type_error): Add location parameter, pass it down to\n\terror_at.\n\t(build_component_ref): Pass location down to c_incomplete_type_error.\n\t(default_conversion): Pass location down to require_complete_type.\n\t(build_array_ref): Likewise.\n\t(build_function_call_vec): Likewise.\n\t(convert_arguments): Likewise.\n\t(build_unary_op): Likewise.\n\t(build_c_cast): Likewise.\n\t(build_modify_expr): Likewise.\n\t(convert_for_assignment): Likewise.\n\t(c_finish_omp_clauses): Likewise.\n\n\t* call.c (build_new_op_1): Pass LOC to cp_build_modify_expr.\n\t* cp-tree.h (cp_build_modify_expr): Update declaration.\n\t(cxx_incomplete_type_error, cxx_incomplete_type_diagnostic): New inline\n\toverloads.\n\t* cp-ubsan.c (cp_ubsan_dfs_initialize_vtbl_ptrs): Pass INPUT_LOCATION to\n\tcp_build_modify_expr.\n\t* decl2.c (set_guard): Likewise.\n\t(handle_tls_init): Likewise.\n\t* init.c (perform_member_init): Likewise.\n\t(expand_virtual_init): Likewise.\n\t(build_new_1): Likewise.\n\t(build_vec_delete_1): Likewise.\n\t(get_temp_regvar): Likewise.\n\t(build_vec_init): Likewise.\n\t* method.c (do_build_copy_assign): Likewise.\n\t(assignable_expr): Likewise.\n\t* semantics.c (finish_omp_for): Likewise.\n\t* typeck.c (cp_build_binary_op): Pass LOCATION to pointer_diff and\n\tcp_pointer_int_sum.\n\t(cp_pointer_int_sum): Add location parameter.  Pass it down to\n\tpointer_int_sum.\n\t(pointer_diff): Add location parameter.  Use it.\n\t(build_modify_expr): Pass location down to cp_build_modify_expr.\n\t(cp_build_modify_expr): Add location parameter.  Use it.\n\t(build_x_modify_expr): Pass location down to cp_build_modify_expr.\n\t* typeck2.c (cxx_incomplete_type_diagnostic,\n\tcxx_incomplete_type_error): Add location parameter.\n\n\t* langhooks-def.h (lhd_incomplete_type_error): Adjust declaration.\n\t* langhooks.c (lhd_incomplete_type_error): Add location parameter.\n\t* langhooks.h (incomplete_type_error): Likewise.\n\t* tree.c (size_in_bytes_loc): Renamed from size_in_bytes.  Add location\n\tparameter, pass it down to incomplete_type_error.\n\t* tree.h (size_in_bytes): New inline overload.\n\t(size_in_bytes_loc): Renamed from size_in_bytes.\n\n\t* c-c++-common/pr70756-2.c: New test.\n\t* c-c++-common/pr70756.c: New test.\n\nFrom-SVN: r236180", "tree": {"sha": "e015f7057ed3ce7ab6a9895c022fd4e6f3c51088", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e015f7057ed3ce7ab6a9895c022fd4e6f3c51088"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "068b220e52e70976f8220b0d501cbf450fb775dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068b220e52e70976f8220b0d501cbf450fb775dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/068b220e52e70976f8220b0d501cbf450fb775dd"}], "stats": {"total": 350, "additions": 244, "deletions": 106}, "files": [{"sha": "de20f4ba3ff2a7bbcb25a395c766928c5f775618", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -1,3 +1,14 @@\n+2016-05-12  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/70756\n+\t* langhooks-def.h (lhd_incomplete_type_error): Adjust declaration.\n+\t* langhooks.c (lhd_incomplete_type_error): Add location parameter.\n+\t* langhooks.h (incomplete_type_error): Likewise.\n+\t* tree.c (size_in_bytes_loc): Renamed from size_in_bytes.  Add location\n+\tparameter, pass it down to incomplete_type_error.\n+\t* tree.h (size_in_bytes): New inline overload.\n+\t(size_in_bytes_loc): Renamed from size_in_bytes.\n+\n 2016-05-12  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/71059"}, {"sha": "f6ba9410200dfef21a485af5cd7b4727b8f07500", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -1,3 +1,9 @@\n+2016-05-12  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/70756\n+\t* c-common.c (pointer_int_sum): Call size_in_bytes_loc instead of\n+\tsize_in_bytes and pass LOC to it.\n+\n 2016-05-11  Mikhail Maltsev  <maltsevm@gmail.com>\n \n \tPR c/43651"}, {"sha": "146e8059c1a06a50f387e6811d2328f65e1d2142", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -4269,7 +4269,7 @@ pointer_int_sum (location_t loc, enum tree_code resultcode,\n       size_exp = integer_one_node;\n     }\n   else\n-    size_exp = size_in_bytes (TREE_TYPE (result_type));\n+    size_exp = size_in_bytes_loc (loc, TREE_TYPE (result_type));\n \n   /* We are manipulating pointer values, so we don't need to warn\n      about relying on undefined signed overflow.  We disable the"}, {"sha": "af0bbe4bef5662ae79cd0023f8e5df80442a439b", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -1,3 +1,25 @@\n+2016-05-12  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/70756\n+\t* c-decl.c (build_compound_literal): Pass LOC down to\n+\tc_incomplete_type_error.\n+\t* c-tree.h (require_complete_type): Adjust declaration.\n+\t(c_incomplete_type_error): Likewise.\n+\t* c-typeck.c (require_complete_type): Add location parameter, pass it\n+\tdown to c_incomplete_type_error.\n+\t(c_incomplete_type_error): Add location parameter, pass it down to\n+\terror_at.\n+\t(build_component_ref): Pass location down to c_incomplete_type_error.\n+\t(default_conversion): Pass location down to require_complete_type.\n+\t(build_array_ref): Likewise.\n+\t(build_function_call_vec): Likewise.\n+\t(convert_arguments): Likewise.\n+\t(build_unary_op): Likewise.\n+\t(build_c_cast): Likewise.\n+\t(build_modify_expr): Likewise.\n+\t(convert_for_assignment): Likewise.\n+\t(c_finish_omp_clauses): Likewise.\n+\n 2016-05-11  Mikhail Maltsev  <maltsevm@gmail.com>\n \n \tPR c/43651"}, {"sha": "19260343c553416131d607b7692cff6b64fb220f", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -5076,7 +5076,7 @@ build_compound_literal (location_t loc, tree type, tree init, bool non_const)\n \n   if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n     {\n-      c_incomplete_type_error (NULL_TREE, type);\n+      c_incomplete_type_error (loc, NULL_TREE, type);\n       return error_mark_node;\n     }\n "}, {"sha": "4a0236d87a9e3939d49dc93114734b50b751dea8", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -589,13 +589,13 @@ extern tree c_last_sizeof_arg;\n extern struct c_switch *c_switch_stack;\n \n extern tree c_objc_common_truthvalue_conversion (location_t, tree);\n-extern tree require_complete_type (tree);\n+extern tree require_complete_type (location_t, tree);\n extern int same_translation_unit_p (const_tree, const_tree);\n extern int comptypes (tree, tree);\n extern int comptypes_check_different_types (tree, tree, bool *);\n extern bool c_vla_type_p (const_tree);\n extern bool c_mark_addressable (tree);\n-extern void c_incomplete_type_error (const_tree, const_tree);\n+extern void c_incomplete_type_error (location_t, const_tree, const_tree);\n extern tree c_type_promotes_to (tree);\n extern struct c_expr default_function_array_conversion (location_t,\n \t\t\t\t\t\t\tstruct c_expr);"}, {"sha": "b037f46cc77d86b307e82c3005aaf22243321534", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -183,11 +183,12 @@ struct tagged_tu_seen_cache {\n static const struct tagged_tu_seen_cache * tagged_tu_seen_base;\n static void free_all_tagged_tu_seen_up_to (const struct tagged_tu_seen_cache *);\n \n-/* Do `exp = require_complete_type (exp);' to make sure exp\n-   does not have an incomplete type.  (That includes void types.)  */\n+/* Do `exp = require_complete_type (loc, exp);' to make sure exp\n+   does not have an incomplete type.  (That includes void types.)\n+   LOC is the location of the use.  */\n \n tree\n-require_complete_type (tree value)\n+require_complete_type (location_t loc, tree value)\n {\n   tree type = TREE_TYPE (value);\n \n@@ -198,23 +199,24 @@ require_complete_type (tree value)\n   if (COMPLETE_TYPE_P (type))\n     return value;\n \n-  c_incomplete_type_error (value, type);\n+  c_incomplete_type_error (loc, value, type);\n   return error_mark_node;\n }\n \n /* Print an error message for invalid use of an incomplete type.\n    VALUE is the expression that was used (or 0 if that isn't known)\n-   and TYPE is the type that was invalid.  */\n+   and TYPE is the type that was invalid.  LOC is the location for\n+   the error.  */\n \n void\n-c_incomplete_type_error (const_tree value, const_tree type)\n+c_incomplete_type_error (location_t loc, const_tree value, const_tree type)\n {\n   /* Avoid duplicate error message.  */\n   if (TREE_CODE (type) == ERROR_MARK)\n     return;\n \n   if (value != 0 && (VAR_P (value) || TREE_CODE (value) == PARM_DECL))\n-    error (\"%qD has an incomplete type %qT\", value, type);\n+    error_at (loc, \"%qD has an incomplete type %qT\", value, type);\n   else\n     {\n     retry:\n@@ -228,32 +230,32 @@ c_incomplete_type_error (const_tree value, const_tree type)\n \t  break;\n \n \tcase VOID_TYPE:\n-\t  error (\"invalid use of void expression\");\n+\t  error_at (loc, \"invalid use of void expression\");\n \t  return;\n \n \tcase ARRAY_TYPE:\n \t  if (TYPE_DOMAIN (type))\n \t    {\n \t      if (TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL)\n \t\t{\n-\t\t  error (\"invalid use of flexible array member\");\n+\t\t  error_at (loc, \"invalid use of flexible array member\");\n \t\t  return;\n \t\t}\n \t      type = TREE_TYPE (type);\n \t      goto retry;\n \t    }\n-\t  error (\"invalid use of array with unspecified bounds\");\n+\t  error_at (loc, \"invalid use of array with unspecified bounds\");\n \t  return;\n \n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n       if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n-\terror (\"invalid use of undefined type %qT\", type);\n+\terror_at (loc, \"invalid use of undefined type %qT\", type);\n       else\n \t/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */\n-\terror (\"invalid use of incomplete typedef %qT\", type);\n+\terror_at (loc, \"invalid use of incomplete typedef %qT\", type);\n     }\n }\n \n@@ -2117,7 +2119,7 @@ default_conversion (tree exp)\n       return error_mark_node;\n     }\n \n-  exp = require_complete_type (exp);\n+  exp = require_complete_type (EXPR_LOC_OR_LOC (exp, input_location), exp);\n   if (exp == error_mark_node)\n     return error_mark_node;\n \n@@ -2334,7 +2336,7 @@ build_component_ref (location_t loc, tree datum, tree component)\n     {\n       if (!COMPLETE_TYPE_P (type))\n \t{\n-\t  c_incomplete_type_error (NULL_TREE, type);\n+\t  c_incomplete_type_error (loc, NULL_TREE, type);\n \t  return error_mark_node;\n \t}\n \n@@ -2642,7 +2644,7 @@ build_array_ref (location_t loc, tree array, tree index)\n \t       in an inline function.\n \t       Hope it doesn't break something else.  */\n \t    | TREE_THIS_VOLATILE (array));\n-      ret = require_complete_type (rval);\n+      ret = require_complete_type (loc, rval);\n       protected_set_expr_location (ret, loc);\n       if (non_lvalue)\n \tret = non_lvalue_loc (loc, ret);\n@@ -3088,7 +3090,7 @@ build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n \t\t \"function with qualified void return type called\");\n       return result;\n     }\n-  return require_complete_type (result);\n+  return require_complete_type (loc, result);\n }\n \n /* Like build_function_call_vec, but call also resolve_overloaded_builtin.  */\n@@ -3239,7 +3241,7 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n       val = c_fully_fold (val, false, NULL);\n       STRIP_TYPE_NOPS (val);\n \n-      val = require_complete_type (val);\n+      val = require_complete_type (ploc, val);\n \n       if (type != 0)\n \t{\n@@ -4047,7 +4049,7 @@ build_unary_op (location_t location,\n     arg = remove_c_maybe_const_expr (arg);\n \n   if (code != ADDR_EXPR)\n-    arg = require_complete_type (arg);\n+    arg = require_complete_type (location, arg);\n \n   typecode = TREE_CODE (TREE_TYPE (arg));\n   if (typecode == ERROR_MARK)\n@@ -5268,7 +5270,7 @@ build_c_cast (location_t loc, tree type, tree expr)\n \n   if (!VOID_TYPE_P (type))\n     {\n-      value = require_complete_type (value);\n+      value = require_complete_type (loc, value);\n       if (value == error_mark_node)\n \treturn error_mark_node;\n     }\n@@ -5538,7 +5540,7 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   bool is_atomic_op;\n \n   /* Types that aren't fully specified cannot be used in assignments.  */\n-  lhs = require_complete_type (lhs);\n+  lhs = require_complete_type (location, lhs);\n \n   /* Avoid duplicate error messages from operands that had errors.  */\n   if (TREE_CODE (lhs) == ERROR_MARK || TREE_CODE (rhs) == ERROR_MARK)\n@@ -6133,7 +6135,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n       error_at (location, \"void value not ignored as it ought to be\");\n       return error_mark_node;\n     }\n-  rhs = require_complete_type (rhs);\n+  rhs = require_complete_type (location, rhs);\n   if (rhs == error_mark_node)\n     return error_mark_node;\n \n@@ -12550,7 +12552,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \n \t      t = OMP_CLAUSE_DECL (c);\n \t    }\n-\t  t = require_complete_type (t);\n+\t  t = require_complete_type (OMP_CLAUSE_LOCATION (c), t);\n \t  if (t == error_mark_node)\n \t    {\n \t      remove = true;\n@@ -13361,7 +13363,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \n \t  if (need_complete)\n \t    {\n-\t      t = require_complete_type (t);\n+\t      t = require_complete_type (OMP_CLAUSE_LOCATION (c), t);\n \t      if (t == error_mark_node)\n \t\tremove = true;\n \t    }"}, {"sha": "a48bd4740fa2f7306f8dc9785b01e5b4dbb652fb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -1,3 +1,34 @@\n+2016-05-12  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/70756\n+\t* call.c (build_new_op_1): Pass LOC to cp_build_modify_expr.\n+\t* cp-tree.h (cp_build_modify_expr): Update declaration.\n+\t(cxx_incomplete_type_error, cxx_incomplete_type_diagnostic): New inline\n+\toverloads.\n+\t* cp-ubsan.c (cp_ubsan_dfs_initialize_vtbl_ptrs): Pass INPUT_LOCATION to\n+\tcp_build_modify_expr.\n+\t* decl2.c (set_guard): Likewise.\n+\t(handle_tls_init): Likewise.\n+\t* init.c (perform_member_init): Likewise.\n+\t(expand_virtual_init): Likewise.\n+\t(build_new_1): Likewise.\n+\t(build_vec_delete_1): Likewise.\n+\t(get_temp_regvar): Likewise.\n+\t(build_vec_init): Likewise.\n+\t* method.c (do_build_copy_assign): Likewise.\n+\t(assignable_expr): Likewise.\n+\t* semantics.c (finish_omp_for): Likewise.\n+\t* typeck.c (cp_build_binary_op): Pass LOCATION to pointer_diff and\n+\tcp_pointer_int_sum.\n+\t(cp_pointer_int_sum): Add location parameter.  Pass it down to\n+\tpointer_int_sum.\n+\t(pointer_diff): Add location parameter.  Use it.\n+\t(build_modify_expr): Pass location down to cp_build_modify_expr.\n+\t(cp_build_modify_expr): Add location parameter.  Use it.\n+\t(build_x_modify_expr): Pass location down to cp_build_modify_expr.\n+\t* typeck2.c (cxx_incomplete_type_diagnostic,\n+\tcxx_incomplete_type_error): Add location parameter.\n+\n 2016-05-11  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/71024"}, {"sha": "a49bbb5bdee5f225615a9ae3c99d8aa495c50f3d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -5757,7 +5757,7 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n   switch (code)\n     {\n     case MODIFY_EXPR:\n-      return cp_build_modify_expr (arg1, code2, arg2, complain);\n+      return cp_build_modify_expr (loc, arg1, code2, arg2, complain);\n \n     case INDIRECT_REF:\n       return cp_build_indirect_ref (arg1, RO_UNARY_STAR, complain);"}, {"sha": "556c2569d6e054d8d909114bd4f944860cc7f55e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -6666,7 +6666,8 @@ extern tree cp_build_c_cast\t\t\t(tree, tree, tsubst_flags_t);\n extern cp_expr build_x_modify_expr\t\t(location_t, tree,\n \t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree cp_build_modify_expr\t\t(tree, enum tree_code, tree,\n+extern tree cp_build_modify_expr\t\t(location_t, tree,\n+\t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree convert_for_initialization\t\t(tree, tree, tree, int,\n \t\t\t\t\t\t impl_conv_rhs, tree, int,\n@@ -6726,11 +6727,24 @@ extern tree finish_binary_fold_expr          (tree, tree, int);\n \n /* in typeck2.c */\n extern void require_complete_eh_spec_types\t(tree, tree);\n-extern void cxx_incomplete_type_diagnostic\t(const_tree, const_tree, diagnostic_t);\n-#undef cxx_incomplete_type_error\n-extern void cxx_incomplete_type_error\t\t(const_tree, const_tree);\n-#define cxx_incomplete_type_error(V,T) \\\n-  (cxx_incomplete_type_diagnostic ((V), (T), DK_ERROR))\n+extern void cxx_incomplete_type_diagnostic\t(location_t, const_tree,\n+\t\t\t\t\t\t const_tree, diagnostic_t);\n+inline void\n+cxx_incomplete_type_diagnostic (const_tree value, const_tree type,\n+\t\t\t\tdiagnostic_t diag_kind)\n+{\n+  cxx_incomplete_type_diagnostic (EXPR_LOC_OR_LOC (value, input_location),\n+\t\t\t\t  value, type, diag_kind);\n+}\n+\n+extern void cxx_incomplete_type_error\t\t(location_t, const_tree,\n+\t\t\t\t\t\t const_tree);\n+inline void\n+cxx_incomplete_type_error (const_tree value, const_tree type)\n+{\n+  cxx_incomplete_type_diagnostic (value, type, DK_ERROR);\n+}\n+\n extern void cxx_incomplete_type_inform \t        (const_tree);\n extern tree error_not_base_type\t\t\t(tree, tree);\n extern tree binfo_or_else\t\t\t(tree, tree);"}, {"sha": "9c8f6e67d54c29598b6a969b509e7d782026837b", "filename": "gcc/cp/cp-ubsan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Fcp-ubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Fcp-ubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-ubsan.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -299,8 +299,8 @@ cp_ubsan_dfs_initialize_vtbl_ptrs (tree binfo, void *data)\n \n       /* Assign NULL to the vptr.  */\n       tree vtbl = build_zero_cst (TREE_TYPE (vtbl_ptr));\n-      tree stmt = cp_build_modify_expr (vtbl_ptr, NOP_EXPR, vtbl,\n-\t\t\t\t\ttf_warning_or_error);\n+      tree stmt = cp_build_modify_expr (input_location, vtbl_ptr, NOP_EXPR,\n+\t\t\t\t\tvtbl, tf_warning_or_error);\n       if (vptr_via_virtual_p (binfo))\n \t/* If this vptr comes from a virtual base of the complete object, only\n \t   clear it if we're in charge of virtual bases.  */"}, {"sha": "22f9eded29185a5b932b1d9f8c2415582df68c85", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -3161,7 +3161,7 @@ set_guard (tree guard)\n   guard_init = integer_one_node;\n   if (!same_type_p (TREE_TYPE (guard_init), TREE_TYPE (guard)))\n     guard_init = fold_convert (TREE_TYPE (guard), guard_init);\n-  return cp_build_modify_expr (guard, NOP_EXPR, guard_init, \n+  return cp_build_modify_expr (input_location, guard, NOP_EXPR, guard_init,\n \t\t\t       tf_warning_or_error);\n }\n \n@@ -4346,7 +4346,8 @@ handle_tls_init (void)\n   tree cond = cp_build_unary_op (TRUTH_NOT_EXPR, guard, false,\n \t\t\t\t tf_warning_or_error);\n   finish_if_stmt_cond (cond, if_stmt);\n-  finish_expr_stmt (cp_build_modify_expr (guard, NOP_EXPR, boolean_true_node,\n+  finish_expr_stmt (cp_build_modify_expr (loc, guard, NOP_EXPR,\n+\t\t\t\t\t  boolean_true_node,\n \t\t\t\t\t  tf_warning_or_error));\n   for (; vars; vars = TREE_CHAIN (vars))\n     {"}, {"sha": "8e7541fcf987c66c8f16a411b86bd4a334d65f05", "filename": "gcc/cp/init.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -798,7 +798,8 @@ perform_member_init (tree member, tree init)\n \t\t\t\t\t\ttf_warning_or_error);\n \n       if (init)\n-\tfinish_expr_stmt (cp_build_modify_expr (decl, INIT_EXPR, init,\n+\tfinish_expr_stmt (cp_build_modify_expr (input_location, decl,\n+\t\t\t\t\t\tINIT_EXPR, init,\n \t\t\t\t\t\ttf_warning_or_error));\n     }\n \n@@ -1254,8 +1255,8 @@ expand_virtual_init (tree binfo, tree decl)\n \n   /* Assign the vtable to the vptr.  */\n   vtbl = convert_force (TREE_TYPE (vtbl_ptr), vtbl, 0, tf_warning_or_error);\n-  finish_expr_stmt (cp_build_modify_expr (vtbl_ptr, NOP_EXPR, vtbl,\n-\t\t\t\t\t  tf_warning_or_error));\n+  finish_expr_stmt (cp_build_modify_expr (input_location, vtbl_ptr, NOP_EXPR,\n+\t\t\t\t\t  vtbl, tf_warning_or_error));\n }\n \n /* If an exception is thrown in a constructor, those base classes already\n@@ -3208,8 +3209,8 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \n \t      ie = build_x_compound_expr_from_vec (*init, \"new initializer\",\n \t\t\t\t\t\t   complain);\n-\t      init_expr = cp_build_modify_expr (init_expr, INIT_EXPR, ie,\n-\t\t\t\t\t\tcomplain);\n+\t      init_expr = cp_build_modify_expr (input_location, init_expr,\n+\t\t\t\t\t\tINIT_EXPR, ie, complain);\n \t    }\n \t  stable = stabilize_init (init_expr, &init_preeval_expr);\n \t}\n@@ -3596,7 +3597,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \n   tbase = create_temporary_var (ptype);\n   tbase_init\n-    = cp_build_modify_expr (tbase, NOP_EXPR,\n+    = cp_build_modify_expr (input_location, tbase, NOP_EXPR,\n \t\t\t    fold_build_pointer_plus_loc (input_location,\n \t\t\t\t\t\t\t fold_convert (ptype,\n \t\t\t\t\t\t\t\t       base),\n@@ -3613,7 +3614,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t\t\t fold_convert (ptype, base)));\n   tmp = fold_build1_loc (input_location, NEGATE_EXPR, sizetype, size_exp);\n   tmp = fold_build_pointer_plus (tbase, tmp);\n-  tmp = cp_build_modify_expr (tbase, NOP_EXPR, tmp, complain);\n+  tmp = cp_build_modify_expr (input_location, tbase, NOP_EXPR, tmp, complain);\n   if (tmp == error_mark_node)\n     return error_mark_node;\n   body = build_compound_expr (input_location, body, tmp);\n@@ -3735,8 +3736,8 @@ get_temp_regvar (tree type, tree init)\n   decl = create_temporary_var (type);\n   add_decl_expr (decl);\n \n-  finish_expr_stmt (cp_build_modify_expr (decl, INIT_EXPR, init, \n-\t\t\t\t\t  tf_warning_or_error));\n+  finish_expr_stmt (cp_build_modify_expr (input_location, decl, INIT_EXPR,\n+\t\t\t\t\t  init, tf_warning_or_error));\n \n   return decl;\n }\n@@ -4000,8 +4001,8 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t  else if (MAYBE_CLASS_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n \t    one_init = build_aggr_init (baseref, elt, 0, complain);\n \t  else\n-\t    one_init = cp_build_modify_expr (baseref, NOP_EXPR,\n-\t\t\t\t\t     elt, complain);\n+\t    one_init = cp_build_modify_expr (input_location, baseref,\n+\t\t\t\t\t     NOP_EXPR, elt, complain);\n \t  if (one_init == error_mark_node)\n \t    errors = true;\n \t  if (try_const)\n@@ -4128,12 +4129,12 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t    from = NULL_TREE;\n \n \t  if (from_array == 2)\n-\t    elt_init = cp_build_modify_expr (to, NOP_EXPR, from, \n-\t\t\t\t\t     complain);\n+\t    elt_init = cp_build_modify_expr (input_location, to, NOP_EXPR,\n+\t\t\t\t\t     from, complain);\n \t  else if (type_build_ctor_call (type))\n \t    elt_init = build_aggr_init (to, from, 0, complain);\n \t  else if (from)\n-\t    elt_init = cp_build_modify_expr (to, NOP_EXPR, from,\n+\t    elt_init = cp_build_modify_expr (input_location, to, NOP_EXPR, from,\n \t\t\t\t\t     complain);\n \t  else\n \t    gcc_unreachable ();"}, {"sha": "310e7ebe728a677f98a10b67ee74cf7c40bfcec0", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -741,7 +741,7 @@ do_build_copy_assign (tree fndecl)\n \t    init = move (init);\n \n \t  if (DECL_NAME (field))\n-\t    init = cp_build_modify_expr (comp, NOP_EXPR, init, \n+\t    init = cp_build_modify_expr (input_location, comp, NOP_EXPR, init,\n \t\t\t\t\t tf_warning_or_error);\n \t  else\n \t    init = build2 (MODIFY_EXPR, TREE_TYPE (comp), comp, init);\n@@ -1023,7 +1023,7 @@ assignable_expr (tree to, tree from)\n   ++cp_unevaluated_operand;\n   to = build_stub_object (to);\n   from = build_stub_object (from);\n-  tree r = cp_build_modify_expr (to, NOP_EXPR, from, tf_none);\n+  tree r = cp_build_modify_expr (input_location, to, NOP_EXPR, from, tf_none);\n   --cp_unevaluated_operand;\n   return r;\n }"}, {"sha": "817ef995a4cb7958ef939f4e56d037e2b8e0265e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -8073,7 +8073,7 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t{\n \t  if (orig_incr)\n \t    TREE_VEC_ELT (orig_incr, i) = incr;\n-\t  incr = cp_build_modify_expr (TREE_OPERAND (incr, 0),\n+\t  incr = cp_build_modify_expr (elocus, TREE_OPERAND (incr, 0),\n \t\t\t\t       TREE_CODE (TREE_OPERAND (incr, 1)),\n \t\t\t\t       TREE_OPERAND (incr, 2),\n \t\t\t\t       tf_warning_or_error);\n@@ -8107,7 +8107,8 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n       if (!processing_template_decl)\n \t{\n \t  init = fold_build_cleanup_point_expr (TREE_TYPE (init), init);\n-\t  init = cp_build_modify_expr (decl, NOP_EXPR, init, tf_warning_or_error);\n+\t  init = cp_build_modify_expr (elocus, decl, NOP_EXPR, init,\n+\t\t\t\t       tf_warning_or_error);\n \t}\n       else\n \tinit = build2 (MODIFY_EXPR, void_type_node, decl, init);"}, {"sha": "0d8a9807bfee877640f22014e6dd32a07ab963cd", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -43,13 +43,14 @@ static tree pfn_from_ptrmemfunc (tree);\n static tree delta_from_ptrmemfunc (tree);\n static tree convert_for_assignment (tree, tree, impl_conv_rhs, tree, int,\n \t\t\t\t    tsubst_flags_t, int);\n-static tree cp_pointer_int_sum (enum tree_code, tree, tree, tsubst_flags_t);\n+static tree cp_pointer_int_sum (location_t, enum tree_code, tree, tree,\n+\t\t\t\ttsubst_flags_t);\n static tree rationalize_conditional_expr (enum tree_code, tree, \n \t\t\t\t\t  tsubst_flags_t);\n static int comp_ptr_ttypes_real (tree, tree, int);\n static bool comp_except_types (tree, tree, bool);\n static bool comp_array_types (const_tree, const_tree, bool);\n-static tree pointer_diff (tree, tree, tree, tsubst_flags_t);\n+static tree pointer_diff (location_t, tree, tree, tree, tsubst_flags_t);\n static tree get_delta_difference (tree, tree, bool, bool, tsubst_flags_t);\n static void casts_away_constness_r (tree *, tree *, tsubst_flags_t);\n static bool casts_away_constness (tree, tree, tsubst_flags_t);\n@@ -4236,8 +4237,8 @@ cp_build_binary_op (location_t location,\n       if (code0 == POINTER_TYPE && code1 == POINTER_TYPE\n \t  && same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (type0),\n \t\t\t\t\t\t\tTREE_TYPE (type1)))\n-\treturn pointer_diff (op0, op1, common_pointer_type (type0, type1),\n-\t\t\t     complain);\n+\treturn pointer_diff (location, op0, op1,\n+\t\t\t     common_pointer_type (type0, type1), complain);\n       /* In all other cases except pointer - int, the usual arithmetic\n \t rules apply.  */\n       else if (!(code0 == POINTER_TYPE && code1 == INTEGER_TYPE))\n@@ -4260,8 +4261,8 @@ cp_build_binary_op (location_t location,\n \t      result_type = TREE_TYPE (ptr_operand);\n \t      break;\n \t    }\n-\t  return cp_pointer_int_sum (code,\n-\t\t\t\t     ptr_operand, \n+\t  return cp_pointer_int_sum (location, code,\n+\t\t\t\t     ptr_operand,\n \t\t\t\t     int_operand,\n \t\t\t\t     complain);\n \t}\n@@ -5226,8 +5227,8 @@ build_x_vec_perm_expr (location_t loc,\n    of pointer PTROP and integer INTOP.  */\n \n static tree\n-cp_pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop,\n-\t\t    tsubst_flags_t complain)\n+cp_pointer_int_sum (location_t loc, enum tree_code resultcode, tree ptrop,\n+\t\t    tree intop, tsubst_flags_t complain)\n {\n   tree res_type = TREE_TYPE (ptrop);\n \n@@ -5238,15 +5239,16 @@ cp_pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop,\n      pointer_int_sum() anyway.  */\n   complete_type (TREE_TYPE (res_type));\n \n-  return pointer_int_sum (input_location, resultcode, ptrop,\n+  return pointer_int_sum (loc, resultcode, ptrop,\n \t\t\t  intop, complain & tf_warning_or_error);\n }\n \n /* Return a tree for the difference of pointers OP0 and OP1.\n    The resulting tree has type int.  */\n \n static tree\n-pointer_diff (tree op0, tree op1, tree ptrtype, tsubst_flags_t complain)\n+pointer_diff (location_t loc, tree op0, tree op1, tree ptrtype,\n+\t      tsubst_flags_t complain)\n {\n   tree result;\n   tree restype = ptrdiff_type_node;\n@@ -5258,23 +5260,23 @@ pointer_diff (tree op0, tree op1, tree ptrtype, tsubst_flags_t complain)\n   if (VOID_TYPE_P (target_type))\n     {\n       if (complain & tf_error)\n-\tpermerror (input_location, \"ISO C++ forbids using pointer of \"\n+\tpermerror (loc, \"ISO C++ forbids using pointer of \"\n \t\t   \"type %<void *%> in subtraction\");\n       else\n \treturn error_mark_node;\n     }\n   if (TREE_CODE (target_type) == FUNCTION_TYPE)\n     {\n       if (complain & tf_error)\n-\tpermerror (input_location, \"ISO C++ forbids using pointer to \"\n+\tpermerror (loc, \"ISO C++ forbids using pointer to \"\n \t\t   \"a function in subtraction\");\n       else\n \treturn error_mark_node;\n     }\n   if (TREE_CODE (target_type) == METHOD_TYPE)\n     {\n       if (complain & tf_error)\n-\tpermerror (input_location, \"ISO C++ forbids using pointer to \"\n+\tpermerror (loc, \"ISO C++ forbids using pointer to \"\n \t\t   \"a method in subtraction\");\n       else\n \treturn error_mark_node;\n@@ -5283,7 +5285,7 @@ pointer_diff (tree op0, tree op1, tree ptrtype, tsubst_flags_t complain)\n   /* First do the subtraction as integers;\n      then drop through to build the divide operator.  */\n \n-  op0 = cp_build_binary_op (input_location,\n+  op0 = cp_build_binary_op (loc,\n \t\t\t    MINUS_EXPR,\n \t\t\t    cp_convert (restype, op0, complain),\n \t\t\t    cp_convert (restype, op1, complain),\n@@ -5293,28 +5295,28 @@ pointer_diff (tree op0, tree op1, tree ptrtype, tsubst_flags_t complain)\n   if (!COMPLETE_TYPE_P (TREE_TYPE (TREE_TYPE (op1))))\n     {\n       if (complain & tf_error)\n-\terror (\"invalid use of a pointer to an incomplete type in \"\n-\t       \"pointer arithmetic\");\n+\terror_at (loc, \"invalid use of a pointer to an incomplete type in \"\n+\t\t  \"pointer arithmetic\");\n       else\n \treturn error_mark_node;\n     }\n \n   if (pointer_to_zero_sized_aggr_p (TREE_TYPE (op1)))\n     {\n       if (complain & tf_error)\n-\terror (\"arithmetic on pointer to an empty aggregate\");\n+\terror_at (loc, \"arithmetic on pointer to an empty aggregate\");\n       else\n \treturn error_mark_node;\n     }\n \n   op1 = (TYPE_PTROB_P (ptrtype)\n-\t ? size_in_bytes (target_type)\n+\t ? size_in_bytes_loc (loc, target_type)\n \t : integer_one_node);\n \n   /* Do the division.  */\n \n-  result = build2 (EXACT_DIV_EXPR, restype, op0,\n-\t\t   cp_convert (restype, op1, complain));\n+  result = build2_loc (loc, EXACT_DIV_EXPR, restype, op0,\n+\t\t       cp_convert (restype, op1, complain));\n   return result;\n }\n \f\n@@ -7470,13 +7472,14 @@ cp_build_c_cast (tree type, tree expr, tsubst_flags_t complain)\n \f\n /* For use from the C common bits.  */\n tree\n-build_modify_expr (location_t /*location*/,\n+build_modify_expr (location_t location,\n \t\t   tree lhs, tree /*lhs_origtype*/,\n \t\t   enum tree_code modifycode, \n \t\t   location_t /*rhs_location*/, tree rhs,\n \t\t   tree /*rhs_origtype*/)\n {\n-  return cp_build_modify_expr (lhs, modifycode, rhs, tf_warning_or_error);\n+  return cp_build_modify_expr (location, lhs, modifycode, rhs,\n+\t\t\t       tf_warning_or_error);\n }\n \n /* Build an assignment expression of lvalue LHS from value RHS.\n@@ -7487,8 +7490,8 @@ build_modify_expr (location_t /*location*/,\n    C++: If MODIFYCODE is INIT_EXPR, then leave references unbashed.  */\n \n tree\n-cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n-\t\t      tsubst_flags_t complain)\n+cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n+\t\t      tree rhs, tsubst_flags_t complain)\n {\n   tree result;\n   tree newrhs = rhs;\n@@ -7510,15 +7513,15 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \tlhs = build2 (TREE_CODE (lhs), TREE_TYPE (lhs),\n \t\t      cp_stabilize_reference (TREE_OPERAND (lhs, 0)),\n \t\t      TREE_OPERAND (lhs, 1));\n-      newrhs = cp_build_modify_expr (TREE_OPERAND (lhs, 0),\n+      newrhs = cp_build_modify_expr (loc, TREE_OPERAND (lhs, 0),\n \t\t\t\t     modifycode, rhs, complain);\n       if (newrhs == error_mark_node)\n \treturn error_mark_node;\n       return build2 (COMPOUND_EXPR, lhstype, lhs, newrhs);\n \n       /* Handle (a, b) used as an \"lvalue\".  */\n     case COMPOUND_EXPR:\n-      newrhs = cp_build_modify_expr (TREE_OPERAND (lhs, 1),\n+      newrhs = cp_build_modify_expr (loc, TREE_OPERAND (lhs, 1),\n \t\t\t\t     modifycode, rhs, complain);\n       if (newrhs == error_mark_node)\n \treturn error_mark_node;\n@@ -7530,8 +7533,8 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \tlhs = build2 (TREE_CODE (lhs), TREE_TYPE (lhs),\n \t\t      cp_stabilize_reference (TREE_OPERAND (lhs, 0)),\n \t\t      TREE_OPERAND (lhs, 1));\n-      newrhs = cp_build_modify_expr (TREE_OPERAND (lhs, 0), modifycode, rhs,\n-\t\t\t\t     complain);\n+      newrhs = cp_build_modify_expr (loc, TREE_OPERAND (lhs, 0), modifycode,\n+\t\t\t\t     rhs, complain);\n       if (newrhs == error_mark_node)\n \treturn error_mark_node;\n       return build2 (COMPOUND_EXPR, lhstype, lhs, newrhs);\n@@ -7580,9 +7583,9 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \n \tcond = build_conditional_expr\n \t  (input_location, TREE_OPERAND (lhs, 0),\n-\t   cp_build_modify_expr (TREE_OPERAND (lhs, 1),\n+\t   cp_build_modify_expr (loc, TREE_OPERAND (lhs, 1),\n \t\t\t\t modifycode, rhs, complain),\n-\t   cp_build_modify_expr (TREE_OPERAND (lhs, 2),\n+\t   cp_build_modify_expr (loc, TREE_OPERAND (lhs, 2),\n \t\t\t\t modifycode, rhs, complain),\n            complain);\n \n@@ -7680,9 +7683,7 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \t  lhs = cp_stabilize_reference (lhs);\n \t  rhs = rvalue (rhs);\n \t  rhs = stabilize_expr (rhs, &init);\n-\t  newrhs = cp_build_binary_op (input_location,\n-\t\t\t\t       modifycode, lhs, rhs,\n-\t\t\t\t       complain);\n+\t  newrhs = cp_build_binary_op (loc, modifycode, lhs, rhs, complain);\n \t  if (newrhs == error_mark_node)\n \t    {\n \t      if (complain & tf_error)\n@@ -7893,7 +7894,7 @@ build_x_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t  return rval;\n \t}\n     }\n-  return cp_build_modify_expr (lhs, modifycode, rhs, complain);\n+  return cp_build_modify_expr (loc, lhs, modifycode, rhs, complain);\n }\n \n /* Helper function for get_delta_difference which assumes FROM is a base"}, {"sha": "1c4e832ff854408d737a6fc93f0f2fb667312aab", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -451,8 +451,8 @@ cxx_incomplete_type_inform (const_tree type)\n    type of diagnostic (see diagnostic.def).  */\n \n void\n-cxx_incomplete_type_diagnostic (const_tree value, const_tree type, \n-\t\t\t\tdiagnostic_t diag_kind)\n+cxx_incomplete_type_diagnostic (location_t loc, const_tree value,\n+\t\t\t\tconst_tree type, diagnostic_t diag_kind)\n {\n   bool is_decl = false, complained = false;\n \n@@ -475,8 +475,6 @@ cxx_incomplete_type_diagnostic (const_tree value, const_tree type,\n  retry:\n   /* We must print an error message.  Be clever about what it says.  */\n \n-  location_t loc = EXPR_LOC_OR_LOC (value, input_location);\n-\n   switch (TREE_CODE (type))\n     {\n     case RECORD_TYPE:\n@@ -570,13 +568,14 @@ cxx_incomplete_type_diagnostic (const_tree value, const_tree type,\n     }\n }\n \n-/* Backward-compatibility interface to incomplete_type_diagnostic;\n-   required by ../tree.c.  */\n-#undef cxx_incomplete_type_error\n+/* Print an error message for invalid use of an incomplete type.\n+   VALUE is the expression that was used (or 0 if that isn't known)\n+   and TYPE is the type that was invalid.  */\n+\n void\n-cxx_incomplete_type_error (const_tree value, const_tree type)\n+cxx_incomplete_type_error (location_t loc, const_tree value, const_tree type)\n {\n-  cxx_incomplete_type_diagnostic (value, type, DK_ERROR);\n+  cxx_incomplete_type_diagnostic (loc, value, type, DK_ERROR);\n }\n \n \f"}, {"sha": "034b3b7e84cfd2c94984830c3b830b313f558489", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -52,7 +52,7 @@ extern void lhd_print_error_function (diagnostic_context *,\n \t\t\t\t      const char *, struct diagnostic_info *);\n extern void lhd_set_decl_assembler_name (tree);\n extern bool lhd_warn_unused_global_decl (const_tree);\n-extern void lhd_incomplete_type_error (const_tree, const_tree);\n+extern void lhd_incomplete_type_error (location_t, const_tree, const_tree);\n extern tree lhd_type_promotes_to (tree);\n extern void lhd_register_builtin_type (tree, const char *);\n extern bool lhd_decl_ok_for_sibcall (const_tree);"}, {"sha": "644463138a923046d9df3641910fbf84204107b5", "filename": "gcc/langhooks.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -199,7 +199,8 @@ lhd_register_builtin_type (tree ARG_UNUSED (type),\n \n /* Invalid use of an incomplete type.  */\n void\n-lhd_incomplete_type_error (const_tree ARG_UNUSED (value), const_tree type)\n+lhd_incomplete_type_error (location_t ARG_UNUSED (loc),\n+\t\t\t   const_tree ARG_UNUSED (value), const_tree type)\n {\n   gcc_assert (TREE_CODE (type) == ERROR_MARK);\n   return;"}, {"sha": "0593424e026faaae2b35cde3873fdd54d74a29c0", "filename": "gcc/langhooks.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -100,8 +100,9 @@ struct lang_hooks_for_types\n   /* This routine is called in tree.c to print an error message for\n      invalid use of an incomplete type.  VALUE is the expression that\n      was used (or 0 if that isn't known) and TYPE is the type that was\n-     invalid.  */\n-  void (*incomplete_type_error) (const_tree value, const_tree type);\n+     invalid.  LOC is the location of the use.  */\n+  void (*incomplete_type_error) (location_t loc, const_tree value,\n+\t\t\t\t const_tree type);\n \n   /* Called from assign_temp to return the maximum size, if there is one,\n      for a type.  */"}, {"sha": "fd0702b157cdc19fcabf66b9d187fa11bfc08d35", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -1,3 +1,9 @@\n+2016-05-12  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/70756\n+\t* c-c++-common/pr70756-2.c: New test.\n+\t* c-c++-common/pr70756.c: New test.\n+\n 2016-05-12  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/71059"}, {"sha": "b7df3b798539baac1fbc51be24d3e10608365b0f", "filename": "gcc/testsuite/c-c++-common/pr70756-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr70756-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr70756-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr70756-2.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -0,0 +1,12 @@\n+/* PR c/70756 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wpointer-arith\" } */\n+\n+extern void bar (void);\n+\n+void\n+fn (void *p)\n+{\n+  void *a = p + 1; /* { dg-warning \"15:pointer of type\" } */\n+  void (*a2)(void) = &bar + 1; /* { dg-warning \"27:pointer to a function\" } */\n+}"}, {"sha": "37259229be971b8ed5b2345a629c50648fa1cb19", "filename": "gcc/testsuite/c-c++-common/pr70756.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr70756.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr70756.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr70756.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -0,0 +1,23 @@\n+/* PR c/70756 */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+enum E e; /* { dg-error \"storage size|use of enum\" } */\n+int (*A)[];\n+\n+void\n+fn0 (void)\n+{\n+  struct\n+  {\n+    int x;\n+    int y[];\n+  } s;\n+  1234 && &s.y + 1; /* { dg-error \"16:invalid use of\" } */\n+}\n+\n+void\n+fn1 (void)\n+{\n+  1234, A += 1; /* { dg-error \"11:invalid use of array with unspecified bounds\" } */\n+}"}, {"sha": "b63f64cd96d5add2ce4ea3283a5f069d0ba19d2d", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -2939,7 +2939,7 @@ ctor_to_vec (tree ctor)\n    make_unsigned_type).  */\n \n tree\n-size_in_bytes (const_tree type)\n+size_in_bytes_loc (location_t loc, const_tree type)\n {\n   tree t;\n \n@@ -2951,7 +2951,7 @@ size_in_bytes (const_tree type)\n \n   if (t == 0)\n     {\n-      lang_hooks.types.incomplete_type_error (NULL_TREE, type);\n+      lang_hooks.types.incomplete_type_error (loc, NULL_TREE, type);\n       return size_zero_node;\n     }\n "}, {"sha": "37324bf86b8ccca177690554d45fc2115c9e1094", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e1536a349a98cc4840fc90a4b97fc4fbc3467/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4f2e1536a349a98cc4840fc90a4b97fc4fbc3467", "patch": "@@ -4224,7 +4224,13 @@ extern tree type_hash_canon (unsigned int, tree);\n \n extern tree convert (tree, tree);\n extern unsigned int expr_align (const_tree);\n-extern tree size_in_bytes (const_tree);\n+extern tree size_in_bytes_loc (location_t, const_tree);\n+inline tree\n+size_in_bytes (const_tree t)\n+{\n+  return size_in_bytes_loc (input_location, t);\n+}\n+\n extern HOST_WIDE_INT int_size_in_bytes (const_tree);\n extern HOST_WIDE_INT max_int_size_in_bytes (const_tree);\n extern tree bit_position (const_tree);"}]}