{"sha": "2f8e468bf32574acaa21dbb8409b579ff8f16b92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY4ZTQ2OGJmMzI1NzRhY2FhMjFkYmI4NDA5YjU3OWZmOGYxNmI5Mg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-12-02T02:26:04Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-12-02T02:26:04Z"}, "message": "builtins.c, [...]: Fix comment typos.\n\n\t* builtins.c, cfgloop.h, cgraph.h, config/arm/arm.c,\n\tconfig/i386/i386.c, config/i386/i386.h, config/mips/mips.h,\n\tconfig/rs6000/cell.md, config/rs6000/rs6000.c, config/sh/sh.c,\n\tconfig/sh/sh4-300.md, config/spu/spu-builtins.def,\n\tconfig/spu/spu-c.c, config/spu/spu-modes.def,\n\tconfig/spu/spu.c, config/spu/spu.md,\n\tconfig/spu/spu_internals.h, config/spu/vmx2spu.h,\n\tfold-const.c, fwprop.c, predict.c, tree-data-ref.h,\n\ttree-flow.h, tree-ssa-loop-manip.c, tree-ssa-loop-niter.c,\n\ttree-ssa-pre.c, tree-vect-analyze.c, tree-vect-transform.c,\n\ttree-vectorizer.c, tree-vrp.c: Fix comment typos.  Follow\n\tspelling conventions.\n\nFrom-SVN: r119442", "tree": {"sha": "dd382bd43e9be4352a80ae68890c6ba09ba0cad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd382bd43e9be4352a80ae68890c6ba09ba0cad1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f8e468bf32574acaa21dbb8409b579ff8f16b92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f8e468bf32574acaa21dbb8409b579ff8f16b92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f8e468bf32574acaa21dbb8409b579ff8f16b92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f8e468bf32574acaa21dbb8409b579ff8f16b92/comments", "author": null, "committer": null, "parents": [{"sha": "5681c208fa990b5f827b3fc97ff33c076376e44d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5681c208fa990b5f827b3fc97ff33c076376e44d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5681c208fa990b5f827b3fc97ff33c076376e44d"}], "stats": {"total": 170, "additions": 92, "deletions": 78}, "files": [{"sha": "a1eb38bcb1b50d4197f32b8eaf62fa1f74797ffe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -2,6 +2,19 @@\n \n \t* doc/extend.texi, doc/invoke.texi, doc/md.texi: Fix typos.\n \n+\t* builtins.c, cfgloop.h, cgraph.h, config/arm/arm.c,\n+\tconfig/i386/i386.c, config/i386/i386.h, config/mips/mips.h,\n+\tconfig/rs6000/cell.md, config/rs6000/rs6000.c, config/sh/sh.c,\n+\tconfig/sh/sh4-300.md, config/spu/spu-builtins.def,\n+\tconfig/spu/spu-c.c, config/spu/spu-modes.def,\n+\tconfig/spu/spu.c, config/spu/spu.md,\n+\tconfig/spu/spu_internals.h, config/spu/vmx2spu.h,\n+\tfold-const.c, fwprop.c, predict.c, tree-data-ref.h,\n+\ttree-flow.h, tree-ssa-loop-manip.c, tree-ssa-loop-niter.c,\n+\ttree-ssa-pre.c, tree-vect-analyze.c, tree-vect-transform.c,\n+\ttree-vectorizer.c, tree-vrp.c: Fix comment typos.  Follow\n+\tspelling conventions.\n+\n 2006-12-01  Trevor Smigiel  <trevor_smigiel@playstation.sony.com>\n \n \t* config/spu/spu.c (spu_immediate): Remove trailing comma."}, {"sha": "80c5e1f6d088d64488f200aa4db387d4e10ea19f", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -554,7 +554,7 @@ expand_builtin_return_addr (enum built_in_function fndecl_code, int count)\n      override us.  Therefore frame pointer elimination is OK, and using\n      the soft frame pointer is OK.\n \n-     For a non-zero count, or a zero count with __builtin_frame_address,\n+     For a nonzero count, or a zero count with __builtin_frame_address,\n      we require a stable offset from the current frame pointer to the\n      previous one, so we must use the hard frame pointer, and\n      we must disable frame pointer elimination.  */\n@@ -11495,7 +11495,7 @@ init_target_chars (void)\n \n /* Helper function for do_mpfr_arg*().  Ensure M is a normal number\n    and no overflow/underflow occurred.  INEXACT is true if M was not\n-   exacly calculated.  TYPE is the tree type for the result.  This\n+   exactly calculated.  TYPE is the tree type for the result.  This\n    function assumes that you cleared the MPFR flags and then\n    calculated M to see if anything subsequently set a flag prior to\n    entering this function.  Return NULL_TREE if any checks fail.  */"}, {"sha": "fa0a456fc5684430637fea8e434f35cf39def03a", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -143,7 +143,7 @@ struct loop\n   struct nb_iter_bound *bounds;\n \n   /* If not NULL, loop has just single exit edge stored here (edges to the\n-     EXIT_BLOCK_PTR do not count.  Do not use direcly, this field should\n+     EXIT_BLOCK_PTR do not count.  Do not use directly; this field should\n      only be accessed via single_exit/set_single_exit functions.  */\n   edge single_exit_;\n "}, {"sha": "be800620e82e3ae4a6192731f29f426cc41e16e7", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -51,7 +51,7 @@ enum availability\n \n struct cgraph_local_info GTY(())\n {\n-  /* Estiimated stack frame consumption by the function.  */\n+  /* Estimated stack frame consumption by the function.  */\n   HOST_WIDE_INT estimated_self_stack_size;\n \n   /* Size of the function before inlining.  */"}, {"sha": "41c44e274dd98acb730a54de38927f2972b3086f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -394,7 +394,7 @@ rtx arm_compare_op0, arm_compare_op1;\n /* The processor for which instructions should be scheduled.  */\n enum processor_type arm_tune = arm_none;\n \n-/* The default processor used if not overriden by commandline.  */\n+/* The default processor used if not overridden by commandline.  */\n static enum processor_type arm_default_cpu = arm_none;\n \n /* Which floating point model to use.  */"}, {"sha": "6f0701b52413dbce83c653adf9c98b357f77006c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -530,7 +530,7 @@ struct processor_costs athlon_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n   /* For some reason, Athlon deals better with REP prefix (relative to loops)\n-     comopared to K8. Alignment becomes important after 8 bytes for mempcy and\n+     compared to K8. Alignment becomes important after 8 bytes for mempcy and\n      128 bytes for memset.  */\n   {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n@@ -13171,7 +13171,7 @@ expand_movmem_epilogue (rtx destmem, rtx srcmem,\n \n   /* When there are stringops, we can cheaply increase dest and src pointers.\n      Otherwise we save code size by maintaining offset (zero is readily\n-     available from preceeding rep operation) and using x86 addressing modes.\n+     available from preceding rep operation) and using x86 addressing modes.\n    */\n   if (TARGET_SINGLE_STRINGOP)\n     {\n@@ -13621,7 +13621,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \n   if (GET_CODE (align_exp) == CONST_INT)\n     align = INTVAL (align_exp);\n-  /* i386 can do missaligned access on resonably increased cost.  */\n+  /* i386 can do misaligned access on reasonably increased cost.  */\n   if (GET_CODE (expected_align_exp) == CONST_INT\n       && INTVAL (expected_align_exp) > align)\n     align = INTVAL (expected_align_exp);\n@@ -13783,7 +13783,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n       dst = change_address (dst, BLKmode, destreg);\n     }\n \n-  /* Epologue to copy the remaining bytes.  */\n+  /* Epilogue to copy the remaining bytes.  */\n   if (label)\n     {\n       if (size_needed < desired_align - align)\n@@ -13909,7 +13909,7 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \n   if (GET_CODE (align_exp) == CONST_INT)\n     align = INTVAL (align_exp);\n-  /* i386 can do missaligned access on resonably increased cost.  */\n+  /* i386 can do misaligned access on reasonably increased cost.  */\n   if (GET_CODE (expected_align_exp) == CONST_INT\n       && INTVAL (expected_align_exp) > align)\n     align = INTVAL (expected_align_exp);"}, {"sha": "14de5d848d69363e0942c7aa5ada2454b7d646fe", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -1494,7 +1494,7 @@ typedef struct ix86_args {\n   int warn_mmx;\t\t\t/* True when we want to warn about MMX ABI.  */\n   int maybe_vaarg;\t\t/* true for calls to possibly vardic fncts.  */\n   int float_in_x87;\t\t/* 1 if floating point arguments should\n-\t\t\t\t   be passed in 80387 registere.  */\n+\t\t\t\t   be passed in 80387 registers.  */\n   int float_in_sse;\t\t/* 1 if in 32-bit mode SFmode (2 for DFmode) should\n \t\t\t\t   be passed in SSE registers.  Otherwise 0.  */\n } CUMULATIVE_ARGS;"}, {"sha": "4905966cbfe1985daf2756333d472b808fc36ce0", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -576,7 +576,7 @@ extern const struct mips_rtx_cost_data *mips_cost;\n    been generated up to this point.  */\n #define ISA_HAS_BRANCHLIKELY\t(!ISA_MIPS1)\n \n-/* ISA has a three-operand multiplcation instruction (usually spelt \"mul\").  */\n+/* ISA has a three-operand multiplication instruction (usually spelt \"mul\").  */\n #define ISA_HAS_MUL3\t\t((TARGET_MIPS3900                       \\\n \t\t\t\t  || TARGET_MIPS5400\t\t\t\\\n \t\t\t\t  || TARGET_MIPS5500\t\t\t\\"}, {"sha": "17a07b585edb75137aeb23588deb0f023155963c", "filename": "gcc/config/rs6000/cell.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Frs6000%2Fcell.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Frs6000%2Fcell.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fcell.md?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -21,10 +21,10 @@\n \n ;; Sources: BE BOOK4 (/sfs/enc/doc/PPU_BookIV_DD3.0_latest.pdf)\n \n-;; BE Architechture *DD3.0 and DD3.1*\n+;; BE Architecture *DD3.0 and DD3.1*\n ;; This file simulate PPU processor unit backend of pipeline, maualP24. \n ;; manual P27, stall and flush points\n-;; IU, XU, VSU, dipatcher decodes and dispatch 2 insns per cycle in program\n+;; IU, XU, VSU, dispatcher decodes and dispatch 2 insns per cycle in program\n ;;  order, the grouped adress are aligned by 8\n ;; This file only simulate one thread situation\n ;; XU executes all fixed point insns(3 units, a simple alu, a complex unit,\n@@ -43,15 +43,15 @@\n ;;VMX(perm,vsu_ls, fp_ls)\t\t\t\t\tX\n ;;    X are illegal combination.\n \n-;; Dual issue exceptons: \n+;; Dual issue exceptions:\n ;;(1) nop-pipelined FXU instr in slot 0 \n ;;(2) non-pipelined FPU inst in slot 0\n ;; CSI instr(contex-synchronizing insn)\n ;; Microcode insn\n \n ;; BRU unit: bru(none register stall), bru_cr(cr register stall)\n ;; VSU unit: vus(vmx simple), vup(vmx permute), vuc(vmx complex),\n-;;  vuf(vmx float), fpu(floats). fpu_div is hypthetical, it is for \n+;;  vuf(vmx float), fpu(floats). fpu_div is hypothetical, it is for\n ;;  nonpipelined simulation\n ;; micr insns will stall at least 7 cycles to get the first instr from ROM,\n ;;  micro instructions are not dual issued. \n@@ -378,7 +378,7 @@\n ; this is not correct, \n ;;  this is a stall in general and not dependent on result\n (define_bypass 13 \"cell-vecstore\" \"cell-fpstore\")\n-; this is not correct, this can never be true, not depent on result\n+; this is not correct, this can never be true, not dependent on result\n (define_bypass 7 \"cell-fp\" \"cell-fpload\")\n ;; vsu1 should avoid writing to the same target register as vsu2 insn\n ;;   within 12 cycles. \n@@ -396,6 +396,6 @@\n \n ;;Things are not simulated:\n ;; update instruction, update address gpr are not simulated\n-;; vrefp, vrsqrtefp have latency(14), currently simluated as 12 cycle float\n+;; vrefp, vrsqrtefp have latency(14), currently simulated as 12 cycle float\n ;;  insns\n "}, {"sha": "37e30022b5567b4a7a081c5a022244cd73d5f0ce", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -17557,7 +17557,7 @@ rs6000_sched_reorder2 (FILE *dump, int sched_verbose, rtx *ready,\n          cycle and we attempt to locate another load in the ready list to\n          issue with it.\n \n-       - If the pedulum is -2, then two stores have already been\n+       - If the pendulum is -2, then two stores have already been\n          issued in this cycle, so we increase the priority of the first load\n          in the ready list to increase it's likelihood of being chosen first\n          in the next cycle."}, {"sha": "11766cbd7adb2c84cf2a7d1fdc5bd5ce9ffc7c20", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -1416,7 +1416,7 @@ prepare_cbranch_operands (rtx *operands, enum machine_mode mode,\n      compare r0.  Hence, if operands[1] has to be loaded from somewhere else\n      into a register, that register might as well be r0, and we allow the\n      constant.  If it is already in a register, this is likely to be\n-     allocatated to a different hard register, thus we load the constant into\n+     allocated to a different hard register, thus we load the constant into\n      a register unless it is zero.  */\n   if (!REG_P (operands[2])\n       && (GET_CODE (operands[2]) != CONST_INT\n@@ -1468,7 +1468,7 @@ expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int probability)\n      operation should be EQ or NE.\n    - If items are searched in an ordered tree from the root, we can expect\n      the highpart to be unequal about half of the time; operation should be\n-     an unequality comparison, operands non-constant, and overall probability\n+     an inequality comparison, operands non-constant, and overall probability\n      about 50%.  Likewise for quicksort.\n    - Range checks will be often made against constants.  Even if we assume for\n      simplicity an even distribution of the non-constant operand over a\n@@ -2413,7 +2413,7 @@ sh_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t       && CONST_OK_FOR_K08 (INTVAL (x)))\n         *total = 1;\n       /* prepare_cmp_insn will force costly constants int registers before\n-\t the cbrach[sd]i4 pattterns can see them, so preserve potentially\n+\t the cbrach[sd]i4 patterns can see them, so preserve potentially\n \t interesting ones not covered by I08 above.  */\n       else if (outer_code == COMPARE\n \t       && ((unsigned HOST_WIDE_INT) INTVAL (x)\n@@ -2440,7 +2440,7 @@ sh_rtx_costs (rtx x, int code, int outer_code, int *total)\n       if (TARGET_SHMEDIA)\n         *total = COSTS_N_INSNS (4);\n       /* prepare_cmp_insn will force costly constants int registers before\n-\t the cbrachdi4 patttern can see them, so preserve potentially\n+\t the cbrachdi4 pattern can see them, so preserve potentially\n \t interesting ones.  */\n       else if (outer_code == COMPARE && GET_MODE (x) == DImode)\n         *total = 1;"}, {"sha": "ac107722df418ed4a42163e8dabdf85a362361f4", "filename": "gcc/config/sh/sh4-300.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fsh%2Fsh4-300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fsh%2Fsh4-300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh4-300.md?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -189,7 +189,7 @@\n ;; In most cases, the insn that loads the address of the call should have\n ;; a non-zero latency (mov rn,rm doesn't make sense since we could use rn\n ;; for the address then).  Thus, a preceding insn that can be paired with\n-;; a call should be elegible for the delay slot.\n+;; a call should be eligible for the delay slot.\n ;;\n ;; calls introduce a longisch delay that is likely to flush the pipelines\n ;; of the caller's instructions.  Ordinary functions tend to end with a"}, {"sha": "5fdd0cb0b1ac41342dbacdacfe32ecfd3ce84528", "filename": "gcc/config/spu/spu-builtins.def", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fspu-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fspu-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-builtins.def?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -1,4 +1,4 @@\n-/* Definitions of builtin fuctions for the Synergistic Processing Unit (SPU). */\n+/* Definitions of builtin functions for the Synergistic Processing Unit (SPU).  */\n /* Copyright (C) 2006 Free Software Foundation, Inc.\n \n    This file is free software; you can redistribute it and/or modify it under\n@@ -24,8 +24,8 @@\n #define _A3(a,b,c)   {a, b, c, SPU_BTI_END_OF_PARAMS}\n #define _A4(a,b,c,d) {a, b, c, d, SPU_BTI_END_OF_PARAMS}\n \n-/* definitions to support si intrinisic functions: (These and other builtin \n- * definitions must preceed definitions of the overloaded generic intrinsics */\n+/* definitions to support si intrinsic functions: (These and other builtin\n+ * definitions must precede definitions of the overloaded generic intrinsics */\n \n DEF_BUILTIN (SI_LQD,         CODE_FOR_spu_lqd,       \"si_lqd\",         B_INSN,   _A3(SPU_BTI_QUADWORD, SPU_BTI_QUADWORD, SPU_BTI_S10_4))\n DEF_BUILTIN (SI_LQX,         CODE_FOR_spu_lqx,       \"si_lqx\",         B_INSN,   _A3(SPU_BTI_QUADWORD, SPU_BTI_QUADWORD, SPU_BTI_QUADWORD))\n@@ -701,10 +701,10 @@ DEF_BUILTIN (SPU_PROMOTE_7,        CODE_FOR_spu_promote,   \"spu_promote_7\",\n DEF_BUILTIN (SPU_PROMOTE_8,        CODE_FOR_spu_promote,   \"spu_promote_8\",        B_INTERNAL, _A3(SPU_BTI_V4SF,   SPU_BTI_FLOAT,  SPU_BTI_INTSI))\n DEF_BUILTIN (SPU_PROMOTE_9,        CODE_FOR_spu_promote,   \"spu_promote_9\",        B_INTERNAL, _A3(SPU_BTI_V2DF,   SPU_BTI_DOUBLE, SPU_BTI_INTSI))\n \n-/* We need something that is not B_INTERNAL as a sentinal. */\n+/* We need something that is not B_INTERNAL as a sentinel.  */\n \n-/* These are for the convenience of imlpemnting fma() in the standard\n-   libraries. */\n+/* These are for the convenience of implementing fma() in the standard\n+   libraries.  */\n DEF_BUILTIN (SCALAR_FMA,           CODE_FOR_fma_sf,        \"fmas\",                 B_INSN,     _A4(SPU_BTI_FLOAT,  SPU_BTI_FLOAT, SPU_BTI_FLOAT, SPU_BTI_FLOAT))\n DEF_BUILTIN (SCALAR_DFMA,          CODE_FOR_fma_df,        \"dfmas\",                B_INSN,     _A4(SPU_BTI_DOUBLE, SPU_BTI_DOUBLE, SPU_BTI_DOUBLE, SPU_BTI_DOUBLE))\n "}, {"sha": "c88e627a49fad0b85ae30d0cf86aee9426fbf088", "filename": "gcc/config/spu/spu-c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fspu-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fspu-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-c.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -72,7 +72,7 @@ spu_resolve_overloaded_builtin (tree fndecl, tree fnargs)\n   struct spu_builtin_description *desc;\n   tree match = NULL_TREE;\n \n-  /* The vector types are not available if the backend is not initalized */\n+  /* The vector types are not available if the backend is not initialized.  */\n   gcc_assert (!flag_preprocess_only);\n \n   desc = &spu_builtins[fcode];"}, {"sha": "49d577b63ea896700ce7a8a645220311d7df9a6d", "filename": "gcc/config/spu/spu-modes.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fspu-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fspu-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-modes.def?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -25,8 +25,8 @@ VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */\n VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */ \n VECTOR_MODES (FLOAT, 16);     /*       V8HF V4SF V2DF */ \n         \n-/* A special mode for the intr regsister so we can treat it differently\n-   for conditional moves. */\n+/* A special mode for the intr register so we can treat it differently\n+   for conditional moves.  */\n RANDOM_MODE (INTR);\n \n /* cse_insn needs an INT_MODE larger than WORD_MODE, otherwise some"}, {"sha": "055c414c70528b0e07979701041b33ae5d98f857", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -322,7 +322,7 @@ valid_subreg (rtx op)\n }\n \n /* When insv and ext[sz]v ar passed a TI SUBREG, we want to strip it off\n-   and ajust the start offset. */\n+   and adjust the start offset.  */\n static rtx\n adjust_operand (rtx op, HOST_WIDE_INT * start)\n {\n@@ -1651,8 +1651,8 @@ int spu_hint_dist = (8 * 4);\n /* An array of these is used to propagate hints to predecessor blocks. */\n struct spu_bb_info\n {\n-  rtx prop_jump;\t\t/* propogated from another block */\n-  basic_block bb;\t\t/* the orignal block. */\n+  rtx prop_jump;\t\t/* propagated from another block */\n+  basic_block bb;\t\t/* the original block. */\n };\n \n /* The special $hbr register is used to prevent the insn scheduler from\n@@ -2455,7 +2455,7 @@ spu_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED,\n }\n \n /* When the address is reg + const_int, force the const_int into a\n-   regiser. */\n+   register.  */\n rtx\n spu_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode)\n@@ -2697,7 +2697,7 @@ spu_pass_by_reference (CUMULATIVE_ARGS * cum ATTRIBUTE_UNUSED,\n             \n         } va_list[1];\n \n-   wheare __args points to the arg that will be returned by the next\n+   where __args points to the arg that will be returned by the next\n    va_arg(), and __skip points to the previous stack frame such that\n    when __args == __skip we should advance __args by 32 bytes. */\n static tree\n@@ -2913,8 +2913,8 @@ spu_conditional_register_usage (void)\n    aligned.  Taking into account that CSE might replace this reg with\n    another one that has not been marked aligned.  \n    So this is really only true for frame, stack and virtual registers,\n-   which we know are always aligned and should not be adversly effected\n-   by CSE. */\n+   which we know are always aligned and should not be adversely effected\n+   by CSE.  */\n static int\n regno_aligned_for_load (int regno)\n {\n@@ -2981,7 +2981,7 @@ store_with_one_insn_p (rtx mem)\n   if (GET_CODE (addr) == SYMBOL_REF)\n     {\n       /* We use the associated declaration to make sure the access is\n-         refering to the whole object.\n+         referring to the whole object.\n          We check both MEM_EXPR and and SYMBOL_REF_DECL.  I'm not sure\n          if it is necessary.  Will there be cases where one exists, and\n          the other does not?  Will there be cases where both exist, but\n@@ -3426,8 +3426,8 @@ mem_is_padded_component_ref (rtx x)\n   if (GET_MODE (x) != TYPE_MODE (TREE_TYPE (t)))\n     return 0;\n   /* If there are no following fields then the field alignment assures\n-     the structure is padded to the alignement which means this field is\n-     padded too. */\n+     the structure is padded to the alignment which means this field is\n+     padded too.  */\n   if (TREE_CHAIN (t) == 0)\n     return 1;\n   /* If the following field is also aligned then this field will be"}, {"sha": "417081b6711d8278a258a42efd8c4c2361d7bc5c", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -1178,8 +1178,8 @@\n   [(set_attr \"type\" \"fp7\")])\n \n ;; This isn't always profitable to use.  Consider r = a * b + c * d.\n-;; It's faster to do  the multplies in parallel then add them.  If we\n-;; merge a multply and add it prevents the multplies from happening in \n+;; It's faster to do the multiplies in parallel then add them.  If we\n+;; merge a multiply and add it prevents the multiplies from happening in\n ;; parallel.\n (define_insn \"mpya_si\"\n   [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")"}, {"sha": "6a71f27981935311a773bff5d318f3b5a78ecc0f", "filename": "gcc/config/spu/spu_internals.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fspu_internals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fspu_internals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu_internals.h?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -256,7 +256,7 @@\n \n #define __align_hint(ptr,base,offset) __builtin_spu_align_hint(ptr,base,offset)\n \n-/* generic spu_* intrinisics */ \n+/* generic spu_* intrinsics */\n \n #define spu_splats(scalar)        __builtin_spu_splats(scalar) \n #define spu_convtf(ra,imm)        __builtin_spu_convtf(ra,imm)"}, {"sha": "0236eba1714432ce1ecffcdc2e3a4559afb76128", "filename": "gcc/config/spu/vmx2spu.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fvmx2spu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fconfig%2Fspu%2Fvmx2spu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fvmx2spu.h?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -2155,7 +2155,7 @@ static inline vec_int4 vec_subs(vec_int4 a, vec_bint4 b)\n }\n \n \n-/* vec_sum4s (vector sum across partial (1/4) staturated)\n+/* vec_sum4s (vector sum across partial (1/4) saturated)\n  * =========\n  */\n static inline vec_uint4 vec_sum4s(vec_uchar16 a, vec_uint4 b)\n@@ -2187,7 +2187,7 @@ static inline vec_int4 vec_sum4s(vec_short8 a, vec_int4 b)\n }\n \n \n-/* vec_sum2s (vector sum across partial (1/2) staturated)\n+/* vec_sum2s (vector sum across partial (1/2) saturated)\n  * =========\n  */\n static inline vec_int4 vec_sum2s(vec_int4 a, vec_int4 b)\n@@ -2223,7 +2223,7 @@ static inline vec_int4 vec_sum2s(vec_int4 a, vec_int4 b)\n }\n \n \n-/* vec_sums (vector sum staturated)\n+/* vec_sums (vector sum saturated)\n  * ========\n  */\n static inline vec_int4 vec_sums(vec_int4 a, vec_int4 b)\n@@ -2909,7 +2909,7 @@ static inline int vec_all_ne(vec_float4 a, vec_float4 b)\n }\n \n \n-/* vec_all_nge (all elements not greater than or eqaul)\n+/* vec_all_nge (all elements not greater than or equal)\n  * ===========\n  */\n static inline int vec_all_nge(vec_float4 a, vec_float4 b)\n@@ -3385,7 +3385,7 @@ static inline int vec_any_ne(vec_float4 a, vec_float4 b)\n }\n \n \n-/* vec_any_nge (any elements not greater than or eqaul)\n+/* vec_any_nge (any elements not greater than or equal)\n  * ===========\n  */\n static inline int vec_any_nge(vec_float4 a, vec_float4 b)"}, {"sha": "93dee15ce287955caec97e1964f1cc34a8e74f50", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -7818,7 +7818,7 @@ maybe_canonicalize_comparison_1 (enum tree_code code, tree type,\n       || TREE_OVERFLOW (cst0))\n     return NULL_TREE;\n \n-  /* See if we can reduce the mangitude of the constant in\n+  /* See if we can reduce the magnitude of the constant in\n      arg0 by changing the comparison code.  */\n   if (code0 == INTEGER_CST)\n     {\n@@ -7899,7 +7899,7 @@ maybe_canonicalize_comparison (enum tree_code code, tree type,\n     return t;\n \n   /* Try canonicalization by simplifying arg1 using the swapped\n-     comparsion.  */\n+     comparison.  */\n   code = swap_tree_comparison (code);\n   return maybe_canonicalize_comparison_1 (code, type, arg1, arg0);\n }"}, {"sha": "887da7009e49bdc997419c83e1df1b2ddf71dffa", "filename": "gcc/fwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -389,7 +389,7 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, bool can_appear)\n }\n \n /* Replace all occurrences of OLD in X with NEW and try to simplify the\n-   resulting expression (in mode MODE).  Return a new expresion if it is\n+   resulting expression (in mode MODE).  Return a new expression if it is\n    a constant, otherwise X.\n \n    Simplifications where occurrences of NEW collapse to a constant are always"}, {"sha": "d28e515386a0764540cfde19cf254beb63ea5992", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -1601,7 +1601,7 @@ estimate_loops_at_level (struct loop *first_loop)\n     }\n }\n \n-/* Propates frequencies through structure of loops.  */\n+/* Propagates frequencies through structure of loops.  */\n \n static void\n estimate_loops (void)"}, {"sha": "2d23dce82075ae773e36b47cffcbf0ca1e6d07b1", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -119,7 +119,7 @@ struct data_reference\n           a[j].b[5][j] = 0; \n \n      Here the offset expression (j * C_j + C) will not contain variables after\n-     subsitution of j=3 (3*C_j + C).\n+     substitution of j=3 (3*C_j + C).\n \n      Misalignment can be calculated only if all the variables can be \n      substituted with constants, otherwise, we record maximum possible alignment"}, {"sha": "3be370ce4033231524c17e0ec53e22b6c20b937d", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -39,8 +39,8 @@ struct basic_block_def;\n typedef struct basic_block_def *basic_block;\n #endif\n \n-/* Gimple dataflow datastructure. All publically available fields shall have\n-   gimple_ accessor defined in tree-flow-inline.h, all publically modifiable\n+/* Gimple dataflow datastructure. All publicly available fields shall have\n+   gimple_ accessor defined in tree-flow-inline.h, all publicly modifiable\n    fields should have gimple_set accessor.  */\n struct gimple_df GTY(()) {\n   /* Array of all variables referenced in the function.  */"}, {"sha": "d92f6e91ba51d891e536cacea7083bae3f3eabb1", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -627,7 +627,7 @@ can_unroll_loop_p (struct loop *loop, unsigned factor,\n       || niter->cmp == ERROR_MARK\n       /* Scalar evolutions analysis might have copy propagated\n \t the abnormal ssa names into these expressions, hence\n-\t emiting the computations based on them during loop\n+\t emitting the computations based on them during loop\n \t unrolling might create overlapping life ranges for\n \t them, and failures in out-of-ssa.  */\n       || contains_abnormal_ssa_name_p (niter->may_be_zero)"}, {"sha": "862f993f3b686aea7c493003a6657db982ba1129", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -1831,7 +1831,7 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n      unsigned char).\n \n      To make things simpler, we require both bounds to fit into type, although\n-     there are cases where this would not be strightly necessary.  */\n+     there are cases where this would not be strictly necessary.  */\n   if (!int_fits_type_p (high, type)\n       || !int_fits_type_p (low, type))\n     return true;\n@@ -2086,7 +2086,7 @@ n_of_executions_at_most (tree stmt,\n      \n      -- if NITER_BOUND->is_exit is true, then everything before\n         NITER_BOUND->stmt is executed at most NITER_BOUND->bound + 1\n-\ttimes, and everyting after it at most NITER_BOUND->bound times.\n+\ttimes, and everything after it at most NITER_BOUND->bound times.\n \n      -- If NITER_BOUND->is_exit is false, then if we can prove that when STMT\n \tis executed, then NITER_BOUND->stmt is executed as well in the same"}, {"sha": "1bbd77e96c8b77d4ae3056419abd61209be2e815", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -1668,7 +1668,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \t (since the maximal set often has 300+ members, even when you\n \t have a small number of blocks).\n \t Basically, we defer the computation of ANTIC for this block\n-\t until we have processed it's successor, which will inveitably\n+\t until we have processed it's successor, which will inevitably\n \t have a *much* smaller set of values to phi translate once\n \t clean has been run on it.\n \t The cost of doing this is that we technically perform more"}, {"sha": "89555151387cbcf818d3abe188d24855aa334837", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -1428,7 +1428,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t    {\n \t      /* For interleaved access we peel only if number of iterations in\n \t\t the prolog loop ({VF - misalignment}), is a multiple of the\n-\t\t number of the interelaved accesses.  */\n+\t\t number of the interleaved accesses.  */\n \t      int elem_size, mis_in_elements;\n \t      int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n@@ -2228,7 +2228,8 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n              is not used inside the loop), it will be vectorized, and therefore\n              the corresponding DEF_STMTs need to marked as relevant.\n \t     We distinguish between two kinds of relevant stmts - those that are\n-\t     used by a reduction conputation, and those that are (also) used by \t     a regular computation. This allows us later on to identify stmts \n+\t     used by a reduction computation, and those that are (also) used by\n+ \t     a regular computation. This allows us later on to identify stmts\n \t     that are used solely by a reduction, and therefore the order of \n \t     the results that they produce does not have to be kept.\n        */"}, {"sha": "a33cbaa6d30f23fd3eb498b97c4901dc60388179", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -368,7 +368,7 @@ vect_create_data_ref_ptr (tree stmt,\n /* Function bump_vector_ptr\n \n    Increment a pointer (to a vector type) by vector-size. Connect the new \n-   increment stmt to the exising def-use update-chain of the pointer.\n+   increment stmt to the existing def-use update-chain of the pointer.\n \n    The pointer def-use update-chain before this function:\n                         DATAREF_PTR = phi (p_0, p_2)\n@@ -658,7 +658,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n    stmts operating on wider types we need to create 'VF/nunits' \"copies\" of the\n    vector stmt (each computing a vector of 'nunits' results, and together\n    computing 'VF' results in each iteration).  This function is called when \n-   vectorizing such a stmt (e.g. vectorizing S2 in the illusration below, in \n+   vectorizing such a stmt (e.g. vectorizing S2 in the illustration below, in\n    which VF=16 and nuniti=4, so the number of copies required is 4):\n \n    scalar stmt:         vectorized into:        STMT_VINFO_RELATED_STMT\n@@ -2495,13 +2495,13 @@ vect_strided_store_supported (tree vectype)\n \n /* Function vect_permute_store_chain.\n \n-   Given a chain of interleaved strores in DR_CHAIN of LENGTH that must be\n+   Given a chain of interleaved stores in DR_CHAIN of LENGTH that must be\n    a power of 2, generate interleave_high/low stmts to reorder the data \n    correctly for the stores. Return the final references for stores in\n    RESULT_CHAIN.\n \n    E.g., LENGTH is 4 and the scalar type is short, i.e., VF is 8.\n-   The input is 4 vectors each containg 8 elements. We assign a number to each \n+   The input is 4 vectors each containing 8 elements. We assign a number to each\n    element, the input sequence is:\n \n    1st vec:   0  1  2  3  4  5  6  7\n@@ -2529,7 +2529,7 @@ vect_strided_store_supported (tree vectype)\n    and of interleave_low:                   2 6 3 7\n \n    \n-   The permutaion is done in log LENGTH stages. In each stage interleave_high \n+   The permutation is done in log LENGTH stages. In each stage interleave_high\n    and interleave_low stmts are created for each pair of vectors in DR_CHAIN, \n    where the first argument is taken from the first half of DR_CHAIN and the \n    second argument from it's second half. \n@@ -2758,7 +2758,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n      And they are put in STMT_VINFO_VEC_STMT of the corresponding scalar stmts\n      (the order of the data-refs in the output of vect_permute_store_chain\n      corresponds to the order of scalar stmts in the interleaving chain - see\n-     the documentaion of vect_permute_store_chain()).\n+     the documentation of vect_permute_store_chain()).\n \n      In case of both multiple types and interleaving, above vector stores and\n      permutation stmts are created for every copy. The result vector stmts are\n@@ -3050,7 +3050,7 @@ vect_strided_load_supported (tree vectype)\n    correctly. Return the final references for loads in RESULT_CHAIN.\n \n    E.g., LENGTH is 4 and the scalar type is short, i.e., VF is 8.\n-   The input is 4 vectors each containg 8 elements. We assign a number to each \n+   The input is 4 vectors each containing 8 elements. We assign a number to each\n    element, the input sequence is:\n \n    1st vec:   0  1  2  3  4  5  6  7\n@@ -3078,7 +3078,7 @@ vect_strided_load_supported (tree vectype)\n    and of extract_odd:     1 3 5 7\n \n    \n-   The permutaion is done in log LENGTH stages. In each stage extract_even and \n+   The permutation is done in log LENGTH stages. In each stage extract_even and\n    extract_odd stmts are created for each pair of vectors in DR_CHAIN in their \n    order. In our example, \n \n@@ -3443,7 +3443,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n      And they are put in STMT_VINFO_VEC_STMT of the corresponding scalar stmts\n      (the order of the data-refs in the output of vect_permute_load_chain\n      corresponds to the order of scalar stmts in the interleaving chain - see\n-     the documentaion of vect_permute_load_chain()).\n+     the documentation of vect_permute_load_chain()).\n      The generation of permutation stmts and recording them in\n      STMT_VINFO_VEC_STMT is done in vect_transform_strided_load().\n \n@@ -4332,7 +4332,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n \n   if (DR_GROUP_FIRST_DR (stmt_info))\n     {\n-      /* For interleaved access element size must be multipled by the size of\n+      /* For interleaved access element size must be multiplied by the size of\n \t the interleaved group.  */\n       group_size = DR_GROUP_SIZE (vinfo_for_stmt (\n \t\t\t\t\t       DR_GROUP_FIRST_DR (stmt_info)));"}, {"sha": "3e186a3c370f2a4d3b66d23453b5f3b178022730", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -1762,7 +1762,7 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n    vector form (i.e., when operating on arguments of type VECTYPE).\n     \n    The two kinds of widening operations we currently support are\n-   NOP and WIDEN_MULT. This function checks if these oprations\n+   NOP and WIDEN_MULT. This function checks if these operations\n    are supported by the target platform either directly (via vector \n    tree-codes), or via target builtins.\n \n@@ -1796,9 +1796,9 @@ supportable_widening_operation (enum tree_code code, tree stmt, tree vectype,\n         vect1: [res1,res2,res3,res4], vect2: [res5,res6,res7,res8]. \n \n      However, in the special case that the result of the widening operation is \n-     used in a reduction copmutation only, the order doesn't matter (because \n+     used in a reduction computation only, the order doesn't matter (because\n      when vectorizing a reduction we change the order of the computation). \n-     Some targets can take advatage of this and generate more efficient code. \n+     Some targets can take advantage of this and generate more efficient code.\n      For example, targets like Altivec, that support widen_mult using a sequence\n      of {mult_even,mult_odd} generate the following vectors:\n         vect1: [res1,res3,res5,res7], vect2: [res2,res4,res6,res8].  */"}, {"sha": "adcbbdc616e445477cadbdf4d9f1029fbe3bc28f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e468bf32574acaa21dbb8409b579ff8f16b92/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=2f8e468bf32574acaa21dbb8409b579ff8f16b92", "patch": "@@ -2902,7 +2902,7 @@ register_edge_assert_for (tree name, edge e, block_stmt_iterator si, tree cond)\n \n   /* In the case of NAME == 1 or NAME != 0, for TRUTH_AND_EXPR defining\n      statement of NAME we can assert both operands of the TRUTH_AND_EXPR\n-     have non-zero value.  */\n+     have nonzero value.  */\n   if (((comp_code == EQ_EXPR && integer_onep (val))\n        || (comp_code == NE_EXPR && integer_zerop (val))))\n     {"}]}