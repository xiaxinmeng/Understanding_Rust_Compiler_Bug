{"sha": "486d850940b886d03a7be2c525a9cc80f90c669c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg2ZDg1MDk0MGI4ODZkMDNhN2JlMmM1MjVhOWNjODBmOTBjNjY5Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-07T12:53:02Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-07T12:53:02Z"}, "message": "(push_reload): Make test in LOAD_EXTEND_OP case more precise; handle CLASS_CANNOT_CHANGE_SIZE.\n\n(push_reload): Make test in LOAD_EXTEND_OP case more precise; handle\nCLASS_CANNOT_CHANGE_SIZE.\n(find_relods): When setting force_reloads, make LOAD_EXTEND_OP case\nmore precise.\n\nFrom-SVN: r7868", "tree": {"sha": "903441655ed218697ad636a94cc908323442e2b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/903441655ed218697ad636a94cc908323442e2b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/486d850940b886d03a7be2c525a9cc80f90c669c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/486d850940b886d03a7be2c525a9cc80f90c669c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/486d850940b886d03a7be2c525a9cc80f90c669c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/486d850940b886d03a7be2c525a9cc80f90c669c/comments", "author": null, "committer": null, "parents": [{"sha": "cc33944ac1fb05cc2db7e3ba31a1de8fead581ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc33944ac1fb05cc2db7e3ba31a1de8fead581ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc33944ac1fb05cc2db7e3ba31a1de8fead581ad"}], "stats": {"total": 53, "additions": 36, "deletions": 17}, "files": [{"sha": "b1727c843f16d132e90107422144562692fa6103", "filename": "gcc/reload.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/486d850940b886d03a7be2c525a9cc80f90c669c/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/486d850940b886d03a7be2c525a9cc80f90c669c/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=486d850940b886d03a7be2c525a9cc80f90c669c", "patch": "@@ -777,8 +777,8 @@ push_reload (in, out, inloc, outloc, class,\n      a pseudo and hence will become a MEM) with M1 wider than M2 and the\n      register is a pseudo, also reload the inside expression.\n      For machines that extend byte loads, do this for any SUBREG of a pseudo\n-     where both M1 and M2 are a word or smaller unless they are the same\n-     size.\n+     where both M1 and M2 are a word or smaller, M1 is wider than M2, and\n+     M2 is an integral mode that gets extended when loaded.\n      Similar issue for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R where\n      either M1 is not valid for R or M2 is wider than a word but we only\n      need one word to store an M2-sized quantity in R.\n@@ -792,7 +792,11 @@ push_reload (in, out, inloc, outloc, class,\n      STRICT_LOW_PART (presumably, in == out in the cas).\n \n      Also reload the inner expression if it does not require a secondary\n-     reload but the SUBREG does.  */\n+     reload but the SUBREG does.\n+\n+     Finally, reload the inner expression if it is a register that is in\n+     the class whose registers cannot be referenced in a different size\n+     and M1 is not the same size as M2.  */\n \n   if (in != 0 && GET_CODE (in) == SUBREG\n       && (CONSTANT_P (SUBREG_REG (in))\n@@ -808,7 +812,9 @@ push_reload (in, out, inloc, outloc, class,\n \t\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n \t\t\t  <= UNITS_PER_WORD)\n \t\t      && (GET_MODE_SIZE (inmode)\n-\t\t\t  != GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))))\n+\t\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))))\n+\t\t      && INTEGRAL_MODE_P (GET_MODE (SUBREG_REG (in)))\n+\t\t      && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (in))) != NIL)\n #endif\n \t\t  ))\n \t  || (GET_CODE (SUBREG_REG (in)) == REG\n@@ -832,6 +838,15 @@ push_reload (in, out, inloc, outloc, class,\n \t\t\t\t\t\tGET_MODE (SUBREG_REG (in)),\n \t\t\t\t\t\tSUBREG_REG (in))\n \t\t  == NO_REGS))\n+#endif\n+#ifdef CLASS_CANNOT_CHANGE_SIZE\n+\t  || (GET_CODE (SUBREG_REG (in)) == REG\n+\t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n+\t      && (TEST_HARD_REG_BIT\n+\t\t  (reg_class_contents[(int) CLASS_CANNOT_CHANGE_SIZE],\n+\t\t   REGNO (SUBREG_REG (in))))\n+\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n+\t\t  != GET_MODE_SIZE (inmode)))\n #endif\n \t  ))\n     {\n@@ -885,15 +900,7 @@ push_reload (in, out, inloc, outloc, class,\n \t\t&& REGNO (SUBREG_REG (out)) >= FIRST_PSEUDO_REGISTER)\n \t       || GET_CODE (SUBREG_REG (out)) == MEM)\n \t      && ((GET_MODE_SIZE (outmode)\n-\t\t   > GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))\n-#ifdef LOAD_EXTEND_OP\n-\t\t  || (GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n-\t\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n-\t\t\t  <= UNITS_PER_WORD)\n-\t\t      && (GET_MODE_SIZE (outmode)\n-\t\t\t  != GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))))\n-#endif\n-\t\t  ))\n+\t\t   > GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))))\n \t  || (GET_CODE (SUBREG_REG (out)) == REG\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n \t      && ((GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n@@ -912,6 +919,15 @@ push_reload (in, out, inloc, outloc, class,\n \t\t\t\t\t\t GET_MODE (SUBREG_REG (out)),\n \t\t\t\t\t\t SUBREG_REG (out))\n \t\t  == NO_REGS))\n+#endif\n+#ifdef CLASS_CANNOT_CHANGE_SIZE\n+\t  || (GET_CODE (SUBREG_REG (out)) == REG\n+\t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n+\t      && (TEST_HARD_REG_BIT\n+\t\t  (reg_class_contents[(int) CLASS_CANNOT_CHANGE_SIZE],\n+\t\t   REGNO (SUBREG_REG (out))))\n+\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n+\t\t  != GET_MODE_SIZE (outmode)))\n #endif\n \t  ))\n     {\n@@ -2553,9 +2569,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t     may not be enough to do the outer reference.\n \n \t\t     On machines that extend byte operations and we have a\n-\t\t     SUBREG where both the inner and outer modes are different\n-\t\t     size but no wider than a word, combine.c has made\n-\t\t     assumptions about the behavior of the machine in such\n+\t\t     SUBREG where both the inner and outer modes are no wider\n+\t\t     than a word and the inner mode is narrower, is integral,\n+\t\t     and gets extended when loaded from memory, combine.c has\n+\t\t     made assumptions about the behavior of the machine in such\n \t\t     register access.  If the data is, in fact, in memory we\n \t\t     must always load using the size assumed to be in the\n \t\t     register and let the insn do the different-sized \n@@ -2572,7 +2589,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t      && (GET_MODE_SIZE (GET_MODE (operand))\n \t\t\t\t  <= UNITS_PER_WORD)\n \t\t\t      && (GET_MODE_SIZE (operand_mode[i])\n-\t\t\t\t  != GET_MODE_SIZE (GET_MODE (operand))))\n+\t\t\t\t  > GET_MODE_SIZE (GET_MODE (operand)))\n+\t\t\t      && INTEGRAL_MODE_P (GET_MODE (operand))\n+\t\t\t      && LOAD_EXTEND_OP (GET_MODE (operand)) != NIL)\n #endif\n \t\t\t  ))\n \t\t  /* Subreg of a hard reg which can't handle the subreg's mode"}]}