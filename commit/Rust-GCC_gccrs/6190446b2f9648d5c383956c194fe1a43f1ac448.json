{"sha": "6190446b2f9648d5c383956c194fe1a43f1ac448", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE5MDQ0NmIyZjk2NDhkNWMzODM5NTZjMTk0ZmUxYTQzZjFhYzQ0OA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2010-04-16T23:13:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2010-04-16T23:13:37Z"}, "message": "ira-color.c (ira_reassign_pseudos): Collect and sort all the pseudos needing assignment rather than doing a...\n\n\t* ira-color.c (ira_reassign_pseudos): Collect and sort all the pseudos\n\tneeding assignment rather than doing a two-phase assignment.\n\nFrom-SVN: r158453", "tree": {"sha": "b6e61f49d2dd1f6bbd9434cc4660e72e97d08ebd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6e61f49d2dd1f6bbd9434cc4660e72e97d08ebd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6190446b2f9648d5c383956c194fe1a43f1ac448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6190446b2f9648d5c383956c194fe1a43f1ac448", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6190446b2f9648d5c383956c194fe1a43f1ac448", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6190446b2f9648d5c383956c194fe1a43f1ac448/comments", "author": null, "committer": null, "parents": [{"sha": "0f6b820c5d3f39cf1ae01dfd6e523990e199d7e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f6b820c5d3f39cf1ae01dfd6e523990e199d7e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f6b820c5d3f39cf1ae01dfd6e523990e199d7e5"}], "stats": {"total": 91, "additions": 36, "deletions": 55}, "files": [{"sha": "04dbba4c2d34b5bbd499790f39a2603788fd9b0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6190446b2f9648d5c383956c194fe1a43f1ac448/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6190446b2f9648d5c383956c194fe1a43f1ac448/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6190446b2f9648d5c383956c194fe1a43f1ac448", "patch": "@@ -1,3 +1,8 @@\n+2010-04-16  Jeff Law  <law@redhat.com>\n+\n+\t* ira-color.c (ira_reassign_pseudos): Collect and sort all the pseudos\n+\tneeding assignment rather than doing a two-phase assignment.\n+\n 2010-04-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR bootstrap/43767"}, {"sha": "feeaa627f0dc148a12c8f54911fe0d6fc5733e48", "filename": "gcc/ira-color.c", "status": "modified", "additions": 31, "deletions": 55, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6190446b2f9648d5c383956c194fe1a43f1ac448/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6190446b2f9648d5c383956c194fe1a43f1ac448/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=6190446b2f9648d5c383956c194fe1a43f1ac448", "patch": "@@ -2860,13 +2860,41 @@ bool\n ira_reassign_pseudos (int *spilled_pseudo_regs, int num,\n \t\t      HARD_REG_SET bad_spill_regs,\n \t\t      HARD_REG_SET *pseudo_forbidden_regs,\n-\t\t      HARD_REG_SET *pseudo_previous_regs,  bitmap spilled)\n+\t\t      HARD_REG_SET *pseudo_previous_regs,\n+\t\t      bitmap spilled)\n {\n   int i, m, n, regno;\n   bool changed_p;\n   ira_allocno_t a, conflict_a;\n   HARD_REG_SET forbidden_regs;\n   ira_allocno_conflict_iterator aci;\n+  bitmap temp = BITMAP_ALLOC (NULL);\n+\n+  /* Add pseudos which conflict with pseudos already in\n+     SPILLED_PSEUDO_REGS to SPILLED_PSEUDO_REGS.  This is preferable\n+     to allocating in two steps as some of the conflicts might have\n+     a higher priority than the pseudos passed in SPILLED_PSEUDO_REGS.  */\n+  for (i = 0; i < num; i++)\n+    bitmap_set_bit (temp, spilled_pseudo_regs[i]);\n+\n+  for (i = 0, n = num; i < n; i++)\n+    {\n+      int regno = spilled_pseudo_regs[i];\n+      bitmap_set_bit (temp, regno);\n+\n+      a = ira_regno_allocno_map[regno];\n+      FOR_EACH_ALLOCNO_CONFLICT (a, conflict_a, aci)\n+\tif (ALLOCNO_HARD_REGNO (conflict_a) < 0\n+\t    && ! ALLOCNO_DONT_REASSIGN_P (conflict_a)\n+\t    && ! bitmap_bit_p (temp, ALLOCNO_REGNO (conflict_a)))\n+\t  {\n+\t    spilled_pseudo_regs[num++] = ALLOCNO_REGNO (conflict_a);\n+\t    bitmap_set_bit (temp, ALLOCNO_REGNO (conflict_a));\n+\t    /* ?!? This seems wrong.  */\n+\t    bitmap_set_bit (consideration_allocno_bitmap,\n+\t\t\t    ALLOCNO_NUM (conflict_a));\n+\t  }\n+    }\n \n   if (num > 1)\n     qsort (spilled_pseudo_regs, num, sizeof (int), pseudo_reg_compare);\n@@ -2885,7 +2913,7 @@ ira_reassign_pseudos (int *spilled_pseudo_regs, int num,\n       ira_assert (reg_renumber[regno] < 0);\n       if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n \tfprintf (ira_dump_file,\n-\t\t \"      Spill %d(a%d), cost=%d\", regno, ALLOCNO_NUM (a),\n+\t\t \"      Try Assign %d(a%d), cost=%d\", regno, ALLOCNO_NUM (a),\n \t\t ALLOCNO_MEMORY_COST (a)\n \t\t - ALLOCNO_COVER_CLASS_COST (a));\n       allocno_reload_assign (a, forbidden_regs);\n@@ -2894,60 +2922,8 @@ ira_reassign_pseudos (int *spilled_pseudo_regs, int num,\n \t  CLEAR_REGNO_REG_SET (spilled, regno);\n \t  changed_p = true;\n \t}\n-      else\n-\tspilled_pseudo_regs[m++] = regno;\n-    }\n-  if (m == 0)\n-    return changed_p;\n-  if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n-    {\n-      fprintf (ira_dump_file, \"      Spilled regs\");\n-      for (i = 0; i < m; i++)\n-\tfprintf (ira_dump_file, \" %d\", spilled_pseudo_regs[i]);\n-      fprintf (ira_dump_file, \"\\n\");\n-    }\n-  /* Try to assign hard registers to pseudos conflicting with ones\n-     from SPILLED_PSEUDO_REGS.  */\n-  for (i = n = 0; i < m; i++)\n-    {\n-      regno = spilled_pseudo_regs[i];\n-      a = ira_regno_allocno_map[regno];\n-      FOR_EACH_ALLOCNO_CONFLICT (a, conflict_a, aci)\n-\tif (ALLOCNO_HARD_REGNO (conflict_a) < 0\n-\t    && ! ALLOCNO_DONT_REASSIGN_P (conflict_a)\n-\t    && ! bitmap_bit_p (consideration_allocno_bitmap,\n-\t\t\t       ALLOCNO_NUM (conflict_a)))\n-\t  {\n-\t    sorted_allocnos[n++] = conflict_a;\n-\t    bitmap_set_bit (consideration_allocno_bitmap,\n-\t\t\t    ALLOCNO_NUM (conflict_a));\n-\t  }\n-    }\n-  if (n != 0)\n-    {\n-      setup_allocno_priorities (sorted_allocnos, n);\n-      qsort (sorted_allocnos, n, sizeof (ira_allocno_t),\n-\t     allocno_priority_compare_func);\n-      for (i = 0; i < n; i++)\n-\t{\n-\t  a = sorted_allocnos[i];\n-\t  regno = ALLOCNO_REGNO (a);\n-\t  COPY_HARD_REG_SET (forbidden_regs, bad_spill_regs);\n-\t  IOR_HARD_REG_SET (forbidden_regs, pseudo_forbidden_regs[regno]);\n-\t  IOR_HARD_REG_SET (forbidden_regs, pseudo_previous_regs[regno]);\n-\t  if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n-\t    fprintf (ira_dump_file,\n-\t\t     \"        Try assign %d(a%d), cost=%d\",\n-\t\t     regno, ALLOCNO_NUM (a),\n-\t\t     ALLOCNO_MEMORY_COST (a)\n-\t\t     - ALLOCNO_COVER_CLASS_COST (a));\n-\t  if (allocno_reload_assign (a, forbidden_regs))\n-\t    {\n-\t      changed_p = true;\n-\t      bitmap_clear_bit (spilled, regno);\n-\t    }\n-\t}\n     }\n+  BITMAP_FREE (temp);\n   return changed_p;\n }\n "}]}