{"sha": "ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM0NzhhYzBmZDYzMmQ3NWNhNmI1MWExMDRhNGVjZWRhYTdiZmVkNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-07-28T22:30:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-07-28T22:30:29Z"}, "message": "cygwin32.h (VALID_MACHINE_TYPE_ATTRIBUTE): New macro.\n\nTue Jul 28 23:29:04 1998  Jason Merrill  <jason@yorick.cygnus.com>\n        * i386/cygwin32.h (VALID_MACHINE_TYPE_ATTRIBUTE): New macro.\n        * i386/winnt.c (associated_type): New fn.\n        (i386_pe_valid_type_attribute_p): New fn.\n        (i386_pe_check_vtable_importexport): Remove.\n        (i386_pe_dllexport_p): Use associated_type.\n        (i386_pe_dllimport_p): Likewise.\n        From Antonio M. O. Neto <anmendes@cruzeironet.com.br>:\n        * i386.c (i386_valid_type_attribute_p): Also accept\n        attributes for METHOD_TYPEs.\n\nFrom-SVN: r21456", "tree": {"sha": "78d997c9ac755b5775a4bd3a500d8a6482dacd83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78d997c9ac755b5775a4bd3a500d8a6482dacd83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6/comments", "author": null, "committer": null, "parents": [{"sha": "28372f4188cf1e6a89b4aa340ab6d5dcb73fe142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28372f4188cf1e6a89b4aa340ab6d5dcb73fe142", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28372f4188cf1e6a89b4aa340ab6d5dcb73fe142"}], "stats": {"total": 146, "additions": 80, "deletions": 66}, "files": [{"sha": "5696d4d79bab1b1077811fded005568349765af0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6", "patch": "@@ -1,3 +1,16 @@\n+Tue Jul 28 23:29:04 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* i386/cygwin32.h (VALID_MACHINE_TYPE_ATTRIBUTE): New macro.\n+\t* i386/winnt.c (associated_type): New fn.\n+\t(i386_pe_valid_type_attribute_p): New fn.\n+\t(i386_pe_check_vtable_importexport): Remove.\n+\t(i386_pe_dllexport_p): Use associated_type.\n+\t(i386_pe_dllimport_p): Likewise.\n+\n+\tFrom Antonio M. O. Neto <anmendes@cruzeironet.com.br>:\n+\t* i386.c (i386_valid_type_attribute_p): Also accept\n+\tattributes for METHOD_TYPEs.\n+\n Tue Jul 28 23:17:39 1998  Peter Gerwinski <peter@gerwinski.de>\n \n \t* tree.c (build_range_type): Copy TYPE_SIZE_UNIT."}, {"sha": "66b0f7481f946118633092cb4e57dcdc97f408d1", "filename": "gcc/config/i386/cygwin32.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6/gcc%2Fconfig%2Fi386%2Fcygwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6/gcc%2Fconfig%2Fi386%2Fcygwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin32.h?ref=ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6", "patch": "@@ -98,6 +98,15 @@ extern int i386_pe_valid_decl_attribute_p ();\n #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n   i386_pe_valid_decl_attribute_p (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n \n+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n+   is a valid machine specific attribute for TYPE.\n+   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n+\n+#undef VALID_MACHINE_TYPE_ATTRIBUTE\n+#define VALID_MACHINE_TYPE_ATTRIBUTE(TYPE, ATTRIBUTES, IDENTIFIER, ARGS) \\\n+  i386_pe_valid_type_attribute_p (TYPE, ATTRIBUTES, IDENTIFIER, ARGS)\n+extern int i386_pe_valid_type_attribute_p ();\n+\n extern union tree_node *i386_pe_merge_decl_attributes ();\n #define MERGE_MACHINE_DECL_ATTRIBUTES(OLD, NEW) \\\n   i386_pe_merge_decl_attributes ((OLD), (NEW))"}, {"sha": "73036ea4f09b79f0196c9fd91933ccb1cfaaa1a0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6", "patch": "@@ -546,6 +546,7 @@ i386_valid_type_attribute_p (type, attributes, identifier, args)\n      tree args;\n {\n   if (TREE_CODE (type) != FUNCTION_TYPE\n+      && TREE_CODE (type) != METHOD_TYPE\n       && TREE_CODE (type) != FIELD_DECL\n       && TREE_CODE (type) != TYPE_DECL)\n     return 0;"}, {"sha": "f78b709aeee2373b478f7a21a11cb9ca5c104c28", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 57, "deletions": 66, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=ac478ac0fd632d75ca6b51a104a4ecedaa7bfed6", "patch": "@@ -50,17 +50,40 @@ i386_pe_valid_decl_attribute_p (decl, attributes, attr, args)\n      tree attr;\n      tree args;\n {\n-  if (args != NULL_TREE)\n-    return 0;\n-\n-  if (is_attribute_p (\"dllexport\", attr))\n-    return 1;\n-  if (is_attribute_p (\"dllimport\", attr))\n-    return 1;\n+  if (args == NULL_TREE)\n+    {\n+      if (is_attribute_p (\"dllexport\", attr))\n+\treturn 1;\n+      if (is_attribute_p (\"dllimport\", attr))\n+\treturn 1;\n+    }\n \n   return i386_valid_decl_attribute_p (decl, attributes, attr, args);\n }\n \n+/* Return nonzero if ATTR is a valid attribute for TYPE.\n+   ATTRIBUTES are any existing attributes and ARGS are the arguments\n+   supplied with ATTR.  */\n+\n+int\n+i386_pe_valid_type_attribute_p (type, attributes, attr, args)\n+     tree type;\n+     tree attributes;\n+     tree attr;\n+     tree args;\n+{\n+  if (args == NULL_TREE\n+      && (TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE))\n+    {\n+      if (is_attribute_p (\"dllexport\", attr))\n+\treturn 1;\n+      if (is_attribute_p (\"dllimport\", attr))\n+\treturn 1;\n+    }\n+\n+  return i386_valid_type_attribute_p (type, attributes, attr, args);\n+}\n+\n /* Merge attributes in decls OLD and NEW.\n \n    This handles the following situation:\n@@ -114,49 +137,33 @@ i386_pe_merge_decl_attributes (old, new)\n   return a;\n }\n \f\n-/* Check a type that has a virtual table, and see if any virtual methods are\n-   marked for import or export, and if so, arrange for the vtable to\n-   be imported or exported.  */\n+/* Return the type that we should use to determine if DECL is\n+   imported or exported.  */\n \n-static int\n-i386_pe_check_vtable_importexport (type)\n-     tree type;\n+static tree\n+associated_type (decl)\n+     tree decl;\n {\n-  tree methods = TYPE_METHODS (type);\n-  tree fndecl;\n-\n-  if (TREE_CODE (methods) == FUNCTION_DECL)\n-    fndecl = methods;\n-  else if (TREE_VEC_ELT (methods, 0) != NULL_TREE)\n-    fndecl = TREE_VEC_ELT (methods, 0);\n-  else\n-    fndecl = TREE_VEC_ELT (methods, 1);\n+  tree t = NULL_TREE;\n \n-  while (fndecl)\n+  /* In the C++ frontend, DECL_CONTEXT for a method doesn't actually refer\n+     to the containing class.  So we look at the 'this' arg.  */\n+  if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n     {\n-      if (DECL_VIRTUAL_P (fndecl) || DECL_VINDEX (fndecl) != NULL_TREE)\n-\t{\n-\t  tree exp = lookup_attribute (\"dllimport\",\n-\t\t\t\t       DECL_MACHINE_ATTRIBUTES (fndecl));\n-\t  if (exp == 0)\n-\t    exp = lookup_attribute (\"dllexport\",\n-\t\t\t\t    DECL_MACHINE_ATTRIBUTES (fndecl));\n-\t  if (exp)\n-\t    return 1;\n-\t}\n-\n-      fndecl = TREE_CHAIN (fndecl);\n+      /* Artificial methods are not affected by the import/export status of\n+\t their class unless they are virtual.  */\n+      if (! DECL_ARTIFICIAL (decl) || DECL_VINDEX (decl))\n+\tt = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (decl))));\n     }\n+  else if (DECL_CONTEXT (decl)\n+\t   && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (decl))) == 't')\n+    t = DECL_CONTEXT (decl);\n \n-  return 0;\n+  return t;\n }\n \n /* Return non-zero if DECL is a dllexport'd object.  */\n \n-#if 0\n-tree current_class_type; /* FIXME */\n-#endif\n-\n int\n i386_pe_dllexport_p (decl)\n      tree decl;\n@@ -170,22 +177,14 @@ i386_pe_dllexport_p (decl)\n   if (exp)\n     return 1;\n \n-#if 0 /* This was a hack to get vtable's exported or imported since only one\n-\t copy of them is ever output.  Disabled pending better solution.  */\n-  /* For C++, the vtables might have to be marked.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n+  /* Class members get the dllexport status of their class.  */\n+  if (associated_type (decl))\n     {\n-      if (TREE_PUBLIC (decl)\n-\t  && DECL_EXTERNAL (decl) == 0\n-\t  && (DECL_CONTEXT (decl)\n-\t      ? i386_pe_check_vtable_importexport (DECL_CONTEXT (decl))\n-\t      : current_class_type\n-\t      ? i386_pe_check_vtable_importexport (current_class_type)\n-\t      : 0)\n-\t  )\n+      exp = lookup_attribute (\"dllexport\",\n+\t\t\t      TYPE_ATTRIBUTES (associated_type (decl)));\n+      if (exp)\n \treturn 1;\n     }\n-#endif\n \n   return 0;\n }\n@@ -209,22 +208,14 @@ i386_pe_dllimport_p (decl)\n   if (imp)\n     return 1;\n \n-#if 0 /* This was a hack to get vtable's exported or imported since only one\n-\t copy of them is ever output.  Disabled pending better solution.  */\n-  /* For C++, the vtables might have to be marked.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n+  /* Class members get the dllimport status of their class.  */\n+  if (associated_type (decl))\n     {\n-      if (TREE_PUBLIC (decl)\n-\t  && DECL_EXTERNAL (decl)\n-\t  && (DECL_CONTEXT (decl)\n-\t      ? i386_pe_check_vtable_importexport (DECL_CONTEXT (decl))\n-\t      : current_class_type\n-\t      ? i386_pe_check_vtable_importexport (current_class_type)\n-\t      : 0)\n-\t  )\n+      imp = lookup_attribute (\"dllimport\",\n+\t\t\t      TYPE_ATTRIBUTES (associated_type (decl)));\n+      if (imp)\n \treturn 1;\n     }\n-#endif\n \n   return 0;\n }"}]}