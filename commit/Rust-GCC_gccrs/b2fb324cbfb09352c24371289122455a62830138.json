{"sha": "b2fb324cbfb09352c24371289122455a62830138", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJmYjMyNGNiZmIwOTM1MmMyNDM3MTI4OTEyMjQ1NWE2MjgzMDEzOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-15T23:38:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-15T23:38:07Z"}, "message": "(lea_max_mul): Delete.\n\n(init_expmed): Delete unused variable I.\n(enum alg_code): New tag alg_shift.  Document it.\n(synth_mult): Delete unused variable N.  Handle new trivial case\nfirst, for T <= 1.  Generalize shifting code to shift whenever a\nnumber is even; use alg_shift for this.  Set best_alg->ops only in\ntrivial case.  Clean up cost calculation code for the `simple case' at\nthe end; use shiftadd_cost when appropriate.  Combine declarations of\nQ and move to top of function.  Eliminate use of Q in factoring cases.\nIf we are getting too long a sequence for `struct algorithm' to\nrecord, fail.\n(expand_mult): Handle alg_shift instead of alg_add_t_m2 as first\noperation.  In RLT emit loop, handle alg_shift; special case LOG == 0\nfor alg_add_t_m2 and alg_sub_t_m2.\n\nFrom-SVN: r3750", "tree": {"sha": "4744a33f76e185ec9461bd6cc11e1f93ff3a6043", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4744a33f76e185ec9461bd6cc11e1f93ff3a6043"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2fb324cbfb09352c24371289122455a62830138", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2fb324cbfb09352c24371289122455a62830138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2fb324cbfb09352c24371289122455a62830138", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2fb324cbfb09352c24371289122455a62830138/comments", "author": null, "committer": null, "parents": [{"sha": "690ef02f086250157fe0988e752eb9f82e687119", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/690ef02f086250157fe0988e752eb9f82e687119", "html_url": "https://github.com/Rust-GCC/gccrs/commit/690ef02f086250157fe0988e752eb9f82e687119"}], "stats": {"total": 139, "additions": 88, "deletions": 51}, "files": [{"sha": "15d863bad9b56c6126cf86428804cb49077062c8", "filename": "gcc/expmed.c", "status": "modified", "additions": 88, "deletions": 51, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2fb324cbfb09352c24371289122455a62830138/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2fb324cbfb09352c24371289122455a62830138/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b2fb324cbfb09352c24371289122455a62830138", "patch": "@@ -55,9 +55,6 @@ static int shift_cost[BITS_PER_WORD];\n static int shiftadd_cost[BITS_PER_WORD];\n static int shiftsub_cost[BITS_PER_WORD];\n \n-/* Max scale factor for scaled address in lea instruction.  */\n-static int lea_max_mul;\n-\n void\n init_expmed ()\n {\n@@ -67,7 +64,6 @@ init_expmed ()\n   rtx reg = gen_rtx (REG, word_mode, FIRST_PSEUDO_REGISTER);\n   rtx pow2 = GEN_INT (32);\n   rtx shift_tmp, shiftadd_tmp, shiftsub_tmp;\n-  HOST_WIDE_INT i;\n   int dummy;\n   int m;\n \n@@ -1722,7 +1718,8 @@ expand_shift (code, mode, shifted, amount, target, unsignedp)\n   return temp;\n }\n \f\n-enum alg_code { alg_none, alg_add_t_m2, alg_sub_t_m2,\n+enum alg_code { alg_none, alg_shift,\n+\t\t  alg_add_t_m2, alg_sub_t_m2,\n \t\t  alg_add_factor, alg_sub_factor,\n \t\t  alg_add_t2_m, alg_sub_t2_m,\n alg_add, alg_subtract, alg_factor, alg_shiftop };\n@@ -1733,6 +1730,7 @@ alg_add, alg_subtract, alg_factor, alg_shiftop };\n    The operations are stored in `op' and the corresponding\n    integer coefficients in `coeff'.\n    These are the operations:\n+   alg_shift\t\ttotal := total * coeff\n    alg_add_t_m2\t\ttotal := total + multiplicand * coeff;\n    alg_sub_t_m2\t\ttotal := total - multiplicand * coeff;\n    alg_add_factor\ttotal := total * coeff + total;\n@@ -1750,8 +1748,10 @@ struct algorithm\n   short cost;\n   short ops;\n /* The size of the OP and COEFF fields are not directly related to the\n-   word size, but that is the worst-case algorithm for any machine for\n-   the multiplicand 10101010101...  */\n+   word size, but the worst-case algorithms will be if we have few\n+   consecutive ones or zeros, i.e., a multiplicand like 10101010101...\n+   In that case we will generate shift-by-2, add, shift-by-2, add,...,\n+   in total wordsize operations.  */\n   enum alg_code op[MAX_BITS_PER_WORD];\n   char coeff[MAX_BITS_PER_WORD];\n };\n@@ -1766,40 +1766,48 @@ synth_mult (t, cost_limit)\n      unsigned HOST_WIDE_INT t;\n      int cost_limit;\n {\n-  int m, n;\n+  int m;\n   struct algorithm *best_alg\n     = (struct algorithm *)alloca (sizeof (struct algorithm));\n   struct algorithm *alg_in\n     = (struct algorithm *)alloca (sizeof (struct algorithm));\n   unsigned int cost;\n+  unsigned HOST_WIDE_INT q;\n \n   /* Indicate that no algorithm is yet found.  If no algorithm\n      is found, this value will be returned and indicate failure.  */\n   best_alg->cost = cost_limit;\n-  best_alg->ops = 0;\n \n-  if (cost_limit < 0)\n+  if (cost_limit <= 0)\n     return *best_alg;\n \n-  /* Is t an exponent of 2, so we can just do a shift?  */\n-  if ((t & (t - 1)) == 0)\n+  if (t <= 1)\n+    {\n+      /* t == 0 or t == 1 takes no instructions.  */\n+      best_alg->ops = 0;\n+      best_alg->cost = 0;\n+      return *best_alg;\n+    }\n+\n+  if ((t & 1) == 0)\n     {\n-      if (t > 1)\n+      m = floor_log2 (t & -t);\t/* m = number of low zero bits */\n+      q = t >> m;\n+      cost = shift_cost[m];\n+      if (cost < cost_limit)\n \t{\n-\t  m = exact_log2 (t);\n-\t  if (shift_cost[m] < cost_limit)\n+\t  *alg_in = synth_mult (q, cost_limit - cost);\n+\n+\t  cost += alg_in->cost;\n+\t  if (cost < best_alg->cost)\n \t    {\n-\t      best_alg->cost = shift_cost[m];\n-\t      best_alg->ops = 1;\n-\t      best_alg->op[0] = alg_add_t_m2;\n-\t      best_alg->coeff[0] = m;\n+\t      struct algorithm *x;\n+\t      x = alg_in, alg_in = best_alg, best_alg = x;\n+\t      best_alg->coeff[best_alg->ops] = m;\n+\t      best_alg->op[best_alg->ops++] = alg_shift;\n+\t      best_alg->cost = cost_limit = cost;\n \t    }\n \t}\n-      else\n-\t/* t == 0 or t == 1 takes no instructions.  */\n-\tbest_alg->cost = 0;\n-\n-      return *best_alg;\n     }\n \n   /* Look for factors of t of the form\n@@ -1819,14 +1827,12 @@ synth_mult (t, cost_limit)\n       d = ((unsigned HOST_WIDE_INT) 1 << m) + 1;\n       if (t % d == 0 && t > d)\n \t{\n-\t  unsigned HOST_WIDE_INT q = t / d;\n-\n \t  if (shiftadd_cost[m] <= add_cost + shift_cost[m])\n \t    cost = shiftadd_cost[m];\n \t  else\n \t    cost = add_cost + shift_cost[m];\n \n-\t  *alg_in = synth_mult (q, cost_limit - cost);\n+\t  *alg_in = synth_mult (t / d, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n \t  if (cost < best_alg->cost)\n@@ -1842,14 +1848,12 @@ synth_mult (t, cost_limit)\n       d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;\n       if (t % d == 0 && t > d)\n \t{\n-\t  unsigned HOST_WIDE_INT q = t / d;\n-\n \t  if (shiftsub_cost[m] <= add_cost + shift_cost[m])\n \t    cost = shiftsub_cost[m];\n \t  else\n \t    cost = add_cost + shift_cost[m];\n \n-\t  *alg_in = synth_mult (q, cost_limit - cost);\n+\t  *alg_in = synth_mult (t / d, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n \t  if (cost < best_alg->cost)\n@@ -1867,8 +1871,6 @@ synth_mult (t, cost_limit)\n      i.e. do a*3, a*5, a*9.  */\n   if ((t & 1) != 0)\n     {\n-      unsigned HOST_WIDE_INT q;\n-\n       q = t - 1;\n       q = q & -q;\n       m = exact_log2 (q);\n@@ -1911,7 +1913,6 @@ synth_mult (t, cost_limit)\n   /* Now, use the simple method of adding or subtracting at the leftmost\n      1-bit.  */\n   {\n-    unsigned HOST_WIDE_INT q;\n     unsigned HOST_WIDE_INT w;\n \n     q = t & -t;\t\t\t/* get out lsb */\n@@ -1925,9 +1926,14 @@ synth_mult (t, cost_limit)\n \t/* There are many bits in a row.  Make 'em by subtraction.  */\n \n \tm = exact_log2 (q);\n-\tcost = add_cost;\n-\tif (q != 1)\n-\t  cost += shift_cost[m];\n+\tif (m == 0)\n+\t  cost = add_cost;\n+\telse\n+\t  {\n+\t    /* Don't use shiftsub_cost here, this operation\n+\t       scales wrong operand.  */\n+\t    cost = add_cost + shift_cost[m];\n+\t  }\n \n \t*alg_in = synth_mult (t + q, cost_limit - cost);\n \n@@ -1946,9 +1952,15 @@ synth_mult (t, cost_limit)\n \t/* There's only one or two bit at the left.  Make it by addition.  */\n \n \tm = exact_log2 (q);\n-\tcost = add_cost;\n-\tif (q != 1)\n-\t  cost += shift_cost[m];\n+\tif (m == 0)\n+\t  cost = add_cost;\n+\telse\n+\t  {\n+\t    if (shiftadd_cost[m] <= add_cost + shift_cost[m])\n+\t      cost = shiftadd_cost[m];\n+\t    else\n+\t      cost = add_cost + shift_cost[m];\n+\t  }\n \n \t*alg_in = synth_mult (t - q, cost_limit - cost);\n \n@@ -1964,6 +1976,11 @@ synth_mult (t, cost_limit)\n       }\n   }\n \n+  /* If we are getting a too long sequence for `struct algorithm'\n+     to record, store a fake cost to make this search fail.  */\n+  if (best_alg->ops == MAX_BITS_PER_WORD)\n+    best_alg->cost = cost_limit;\n+\n   return *best_alg;\n }\n \f\n@@ -2014,16 +2031,15 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \n       alg = synth_mult (val, mult_cost);\n       neg_alg = synth_mult (- val,\n-\t\t\t    (alg.cost >= 0 ? alg.cost : mult_cost)\n+\t\t\t    (alg.cost < mult_cost ? alg.cost : mult_cost)\n \t\t\t    - negate_cost);\n \n       if (neg_alg.cost + negate_cost < alg.cost)\n \talg = neg_alg, negate = 1, val = - val;\n \n       if (alg.cost < mult_cost)\n \t{\n-\t  /* If we found something, it must be cheaper than multiply.\n-\t     So use it.  */\n+\t  /* We found something cheaper than a multiply insn.  */\n \t  int opno;\n \t  rtx accum, tem;\n \n@@ -2040,7 +2056,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t    {\n \t      int log = alg.coeff[0];\n \t      enum alg_code op = alg.op[0];\n-\t      if (op == alg_add_t_m2)\n+\t      if (op == alg_shift)\n \t\t{\n \t\t  accum = expand_shift (LSHIFT_EXPR, mode, op0,\n \t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n@@ -2068,18 +2084,39 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t      int log = alg.coeff[opno];\n \t      switch (alg.op[opno])\n \t\t{\n+\t\tcase alg_shift:\n+\t\t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n+\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n+\t\t  break;\n+\n \t\tcase alg_add_t_m2:\n-\t\t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n-\t\t  accum = force_operand (gen_rtx (PLUS, mode, accum, tem),\n-\t\t\t\t\t accum);\n+\t\t  if (log != 0)\n+\t\t    {\n+\t\t      tem = expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t\t  build_int_2 (log, 0), NULL_RTX, 0);\n+\t\t      accum = force_operand (gen_rtx (PLUS, mode, accum, tem),\n+\t\t\t\t\t     accum);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      accum = force_operand (gen_rtx (PLUS, mode, accum, op0),\n+\t\t\t\t\t     accum);\n+\t\t    }\n \t\t  break;\n \n \t\tcase alg_sub_t_m2:\n-\t\t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n-\t\t  accum = force_operand (gen_rtx (MINUS, mode, accum, tem),\n-\t\t\t\t\t accum);\n+\t\t  if (log != 0)\n+\t\t    {\n+\t\t      tem = expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t\t  build_int_2 (log, 0), NULL_RTX, 0);\n+\t\t      accum = force_operand (gen_rtx (MINUS, mode, accum, tem),\n+\t\t\t\t\t     accum);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      accum = force_operand (gen_rtx (MINUS, mode, accum, op0),\n+\t\t\t\t\t     accum);\n+\t\t    }\n \t\t  break;\n \n \t\tcase alg_add_t2_m:"}]}