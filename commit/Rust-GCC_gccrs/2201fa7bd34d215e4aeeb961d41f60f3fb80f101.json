{"sha": "2201fa7bd34d215e4aeeb961d41f60f3fb80f101", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIwMWZhN2JkMzRkMjE1ZTRhZWViOTYxZDQxZjYwZjNmYjgwZjEwMQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-08-21T14:45:49Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-08-21T14:45:49Z"}, "message": "[Ada] General purpose doubly linked list for compiler and tool use\n\nThis patch adds unit GNAT.Lists which currently contains the\nimplementation of a general purpose doubly linked list intended for use\nby the compiler and the tools around it.\n\n2018-08-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* impunit.adb: Add g-lists to the set of non-implementation\n\tunits.\n\t* libgnat/g-lists.adb, libgnat/g-lists.ads: New unit.\n\t* Makefile.rtl: Add g-lists to the set of non-tasking units.\n\t* gcc-interface/Make-lang.in: Add g-lists to the set of files\n\tused by gnat1.\n\ngcc/testsuite/\n\n\t* gnat.dg/linkedlist.adb: New testcase.\n\nFrom-SVN: r263714", "tree": {"sha": "cb36eda183a044c293786c8783b0e9c4064218ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb36eda183a044c293786c8783b0e9c4064218ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2201fa7bd34d215e4aeeb961d41f60f3fb80f101", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2201fa7bd34d215e4aeeb961d41f60f3fb80f101", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2201fa7bd34d215e4aeeb961d41f60f3fb80f101", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c36d21ee42349ea0e8565daa2013ba4f193d4ffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c36d21ee42349ea0e8565daa2013ba4f193d4ffe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c36d21ee42349ea0e8565daa2013ba4f193d4ffe"}], "stats": {"total": 2080, "additions": 2080, "deletions": 0}, "files": [{"sha": "f21b11cf50decfffc332d56d42ba40c684fe2141", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2201fa7bd34d215e4aeeb961d41f60f3fb80f101", "patch": "@@ -1,3 +1,12 @@\n+2018-08-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* impunit.adb: Add g-lists to the set of non-implementation\n+\tunits.\n+\t* libgnat/g-lists.adb, libgnat/g-lists.ads: New unit.\n+\t* Makefile.rtl: Add g-lists to the set of non-tasking units.\n+\t* gcc-interface/Make-lang.in: Add g-lists to the set of files\n+\tused by gnat1.\n+\n 2018-08-21  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_ch9.adb (Reset_Scopes): Do not recurse into type"}, {"sha": "2e4ee8df7fafd6ed362bd2cbf18e89409ccaf6c4", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=2201fa7bd34d215e4aeeb961d41f60f3fb80f101", "patch": "@@ -427,6 +427,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-htable$(objext) \\\n   g-io$(objext) \\\n   g-io_aux$(objext) \\\n+  g-lists$(objext) \\\n   g-locfil$(objext) \\\n   g-mbdira$(objext) \\\n   g-mbflra$(objext) \\"}, {"sha": "d8dac73fb389f6be45ce5f1c498e6aa2b74d26ea", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=2201fa7bd34d215e4aeeb961d41f60f3fb80f101", "patch": "@@ -319,6 +319,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/libgnat/g-dynhta.o\t\\\n  ada/libgnat/g-hesora.o\t\\\n  ada/libgnat/g-htable.o\t\\\n+ ada/libgnat/g-lists.o \\\n  ada/libgnat/g-spchge.o\t\\\n  ada/libgnat/g-speche.o\t\\\n  ada/libgnat/g-u3spch.o\t\\"}, {"sha": "7d35902b91db987c4a03791230920f2323f70a43", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=2201fa7bd34d215e4aeeb961d41f60f3fb80f101", "patch": "@@ -281,6 +281,7 @@ package body Impunit is\n     (\"g-htable\", F),  -- GNAT.Htable\n     (\"g-io    \", F),  -- GNAT.IO\n     (\"g-io_aux\", F),  -- GNAT.IO_Aux\n+    (\"g-lists \", F),  -- GNAT.Lists\n     (\"g-locfil\", F),  -- GNAT.Lock_Files\n     (\"g-mbdira\", F),  -- GNAT.MBBS_Discrete_Random\n     (\"g-mbflra\", F),  -- GNAT.MBBS_Float_Random"}, {"sha": "a058f33aa7f30da849a9165049dc3e7a54f5cb83", "filename": "gcc/ada/libgnat/g-lists.adb", "status": "added", "additions": 635, "deletions": 0, "changes": 635, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Fada%2Flibgnat%2Fg-lists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Fada%2Flibgnat%2Fg-lists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-lists.adb?ref=2201fa7bd34d215e4aeeb961d41f60f3fb80f101", "patch": "@@ -0,0 +1,635 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                            G N A T . L I S T S                           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2018, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+package body GNAT.Lists is\n+\n+   package body Doubly_Linked_List is\n+      procedure Delete_Node (L : Instance; Nod : Node_Ptr);\n+      pragma Inline (Delete_Node);\n+      --  Detach and delete node Nod from list L\n+\n+      procedure Ensure_Circular (Head : Node_Ptr);\n+      pragma Inline (Ensure_Circular);\n+      --  Ensure that dummy head Head is circular with respect to itself\n+\n+      procedure Ensure_Created (L : Instance);\n+      pragma Inline (Ensure_Created);\n+      --  Verify that list L is created. Raise Not_Created if this is not the\n+      --  case.\n+\n+      procedure Ensure_Full (L : Instance);\n+      pragma Inline (Ensure_Full);\n+      --  Verify that list L contains at least one element. Raise List_Empty if\n+      --  this is not the case.\n+\n+      procedure Ensure_Unlocked (L : Instance);\n+      pragma Inline (Ensure_Unlocked);\n+      --  Verify that list L is unlocked. Raise List_Locked if this is not the\n+      --  case.\n+\n+      function Find_Node\n+        (Head : Node_Ptr;\n+         Elem : Element_Type) return Node_Ptr;\n+      pragma Inline (Find_Node);\n+      --  Travers a list indicated by dummy head Head to determine whethe there\n+      --  exists a node with element Elem. If such a node exists, return it,\n+      --  otherwise return null;\n+\n+      procedure Free is new Ada.Unchecked_Deallocation (Linked_List, Instance);\n+\n+      procedure Free is new Ada.Unchecked_Deallocation (Node, Node_Ptr);\n+\n+      procedure Insert_Between\n+        (L     : Instance;\n+         Elem  : Element_Type;\n+         Left  : Node_Ptr;\n+         Right : Node_Ptr);\n+      pragma Inline (Insert_Between);\n+      --  Insert element Elem between nodes Left and Right of list L\n+\n+      function Is_Valid (Iter : Iterator) return Boolean;\n+      pragma Inline (Is_Valid);\n+      --  Determine whether iterator Iter refers to a valid element\n+\n+      function Is_Valid (Nod : Node_Ptr; Head : Node_Ptr) return Boolean;\n+      pragma Inline (Is_Valid);\n+      --  Determine whether node Nod is non-null and does not refer to dummy\n+      --  head Head, thus making it valid.\n+\n+      procedure Lock (L : Instance);\n+      pragma Inline (Lock);\n+      --  Lock all mutation functionality of list L\n+\n+      procedure Unlock (L : Instance);\n+      pragma Inline (Unlock);\n+      --  Unlock all mutation functionality of list L\n+\n+      ------------\n+      -- Append --\n+      ------------\n+\n+      procedure Append (L : Instance; Elem : Element_Type) is\n+         Head : Node_Ptr;\n+\n+      begin\n+         Ensure_Created  (L);\n+         Ensure_Unlocked (L);\n+\n+         --  Ensure that the dummy head of an empty list is circular with\n+         --  respect to itself.\n+\n+         Head := L.Nodes'Access;\n+         Ensure_Circular (Head);\n+\n+         --  Append the node by inserting it between the last node and the\n+         --  dummy head.\n+\n+         Insert_Between\n+           (L     => L,\n+            Elem  => Elem,\n+            Left  => Head.Prev,\n+            Right => Head);\n+      end Append;\n+\n+      ------------\n+      -- Create --\n+      ------------\n+\n+      function Create return Instance is\n+      begin\n+         return new Linked_List;\n+      end Create;\n+\n+      --------------\n+      -- Contains --\n+      --------------\n+\n+      function Contains (L : Instance; Elem : Element_Type) return Boolean is\n+         Head : Node_Ptr;\n+         Nod  : Node_Ptr;\n+\n+      begin\n+         Ensure_Created (L);\n+\n+         Head := L.Nodes'Access;\n+         Nod  := Find_Node (Head, Elem);\n+\n+         return Is_Valid (Nod, Head);\n+      end Contains;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      procedure Delete (L : Instance; Elem : Element_Type) is\n+         Head : Node_Ptr;\n+         Nod  : Node_Ptr;\n+\n+      begin\n+         Ensure_Created  (L);\n+         Ensure_Full     (L);\n+         Ensure_Unlocked (L);\n+\n+         Head := L.Nodes'Access;\n+         Nod  := Find_Node (Head, Elem);\n+\n+         if Is_Valid (Nod, Head) then\n+            Delete_Node (L, Nod);\n+         end if;\n+      end Delete;\n+\n+      ------------------\n+      -- Delete_First --\n+      ------------------\n+\n+      procedure Delete_First (L : Instance) is\n+         Head : Node_Ptr;\n+         Nod  : Node_Ptr;\n+\n+      begin\n+         Ensure_Created  (L);\n+         Ensure_Full     (L);\n+         Ensure_Unlocked (L);\n+\n+         Head := L.Nodes'Access;\n+         Nod  := Head.Next;\n+\n+         if Is_Valid (Nod, Head) then\n+            Delete_Node (L, Nod);\n+         end if;\n+      end Delete_First;\n+\n+      -----------------\n+      -- Delete_Last --\n+      -----------------\n+\n+      procedure Delete_Last (L : Instance) is\n+         Head : Node_Ptr;\n+         Nod  : Node_Ptr;\n+\n+      begin\n+         Ensure_Created  (L);\n+         Ensure_Full     (L);\n+         Ensure_Unlocked (L);\n+\n+         Head := L.Nodes'Access;\n+         Nod  := Head.Prev;\n+\n+         if Is_Valid (Nod, Head) then\n+            Delete_Node (L, Nod);\n+         end if;\n+      end Delete_Last;\n+\n+      -----------------\n+      -- Delete_Node --\n+      -----------------\n+\n+      procedure Delete_Node (L : Instance; Nod : Node_Ptr) is\n+         Ref : Node_Ptr := Nod;\n+\n+         pragma Assert (Ref /= null);\n+\n+         Next : constant Node_Ptr := Ref.Next;\n+         Prev : constant Node_Ptr := Ref.Prev;\n+\n+      begin\n+         pragma Assert (L    /= null);\n+         pragma Assert (Next /= null);\n+         pragma Assert (Prev /= null);\n+\n+         Prev.Next := Next;  --  Prev ---> Next\n+         Next.Prev := Prev;  --  Prev <--> Next\n+\n+         Ref.Next := null;\n+         Ref.Prev := null;\n+\n+         L.Elements := L.Elements - 1;\n+\n+         Free (Ref);\n+      end Delete_Node;\n+\n+      -------------\n+      -- Destroy --\n+      -------------\n+\n+      procedure Destroy (L : in out Instance) is\n+         Head : Node_Ptr;\n+\n+      begin\n+         Ensure_Created  (L);\n+         Ensure_Unlocked (L);\n+\n+         Head := L.Nodes'Access;\n+\n+         while Is_Valid (Head.Next, Head) loop\n+            Delete_Node (L, Head.Next);\n+         end loop;\n+\n+         Free (L);\n+      end Destroy;\n+\n+      ---------------------\n+      -- Ensure_Circular --\n+      ---------------------\n+\n+      procedure Ensure_Circular (Head : Node_Ptr) is\n+         pragma Assert (Head /= null);\n+\n+      begin\n+         if Head.Next = null and then Head.Prev = null then\n+            Head.Next := Head;\n+            Head.Prev := Head;\n+         end if;\n+      end Ensure_Circular;\n+\n+      --------------------\n+      -- Ensure_Created --\n+      --------------------\n+\n+      procedure Ensure_Created (L : Instance) is\n+      begin\n+         if L = null then\n+            raise Not_Created;\n+         end if;\n+      end Ensure_Created;\n+\n+      -----------------\n+      -- Ensure_Full --\n+      -----------------\n+\n+      procedure Ensure_Full (L : Instance) is\n+      begin\n+         pragma Assert (L /= null);\n+\n+         if L.Elements = 0 then\n+            raise List_Empty;\n+         end if;\n+      end Ensure_Full;\n+\n+      ---------------------\n+      -- Ensure_Unlocked --\n+      ---------------------\n+\n+      procedure Ensure_Unlocked (L : Instance) is\n+      begin\n+         pragma Assert (L /= null);\n+\n+         --  The list has at least one outstanding iterator\n+\n+         if L.Locked > 0 then\n+            raise List_Locked;\n+         end if;\n+      end Ensure_Unlocked;\n+\n+      ---------------\n+      -- Find_Node --\n+      ---------------\n+\n+      function Find_Node\n+        (Head : Node_Ptr;\n+         Elem : Element_Type) return Node_Ptr\n+      is\n+         pragma Assert (Head /= null);\n+\n+         Nod : Node_Ptr;\n+\n+      begin\n+         --  Traverse the nodes of the list, looking for a matching element\n+\n+         Nod := Head.Next;\n+         while Is_Valid (Nod, Head) loop\n+            if Nod.Elem = Elem then\n+               return Nod;\n+            end if;\n+\n+            Nod := Nod.Next;\n+         end loop;\n+\n+         return null;\n+      end Find_Node;\n+\n+      -----------\n+      -- First --\n+      -----------\n+\n+      function First (L : Instance) return Element_Type is\n+      begin\n+         Ensure_Created (L);\n+         Ensure_Full    (L);\n+\n+         return L.Nodes.Next.Elem;\n+      end First;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : Iterator) return Boolean is\n+         Is_OK : constant Boolean := Is_Valid (Iter);\n+\n+      begin\n+         --  The iterator is no longer valid which indicates that it has been\n+         --  exhausted. Unlock all mutation functionality of the list because\n+         --  the iterator cannot be advanced any further.\n+\n+         if not Is_OK then\n+            Unlock (Iter.List);\n+         end if;\n+\n+         return Is_OK;\n+      end Has_Next;\n+\n+      ------------------\n+      -- Insert_After --\n+      ------------------\n+\n+      procedure Insert_After\n+        (L     : Instance;\n+         After : Element_Type;\n+         Elem  : Element_Type)\n+      is\n+         Head : Node_Ptr;\n+         Nod  : Node_Ptr;\n+\n+      begin\n+         Ensure_Created  (L);\n+         Ensure_Unlocked (L);\n+\n+         Head := L.Nodes'Access;\n+         Nod  := Find_Node (Head, After);\n+\n+         if Is_Valid (Nod, Head) then\n+            Insert_Between\n+              (L     => L,\n+               Elem  => Elem,\n+               Left  => Nod,\n+               Right => Nod.Next);\n+         end if;\n+      end Insert_After;\n+\n+      -------------------\n+      -- Insert_Before --\n+      -------------------\n+\n+      procedure Insert_Before\n+        (L      : Instance;\n+         Before : Element_Type;\n+         Elem   : Element_Type)\n+      is\n+         Head : Node_Ptr;\n+         Nod  : Node_Ptr;\n+\n+      begin\n+         Ensure_Created  (L);\n+         Ensure_Unlocked (L);\n+\n+         Head := L.Nodes'Access;\n+         Nod  := Find_Node (Head, Before);\n+\n+         if Is_Valid (Nod, Head) then\n+            Insert_Between\n+              (L     => L,\n+               Elem  => Elem,\n+               Left  => Nod.Prev,\n+               Right => Nod);\n+         end if;\n+      end Insert_Before;\n+\n+      --------------------\n+      -- Insert_Between --\n+      --------------------\n+\n+      procedure Insert_Between\n+        (L     : Instance;\n+         Elem  : Element_Type;\n+         Left  : Node_Ptr;\n+         Right : Node_Ptr)\n+      is\n+         pragma Assert (L     /= null);\n+         pragma Assert (Left  /= null);\n+         pragma Assert (Right /= null);\n+\n+         Nod : constant Node_Ptr :=\n+                 new Node'(Elem => Elem,\n+                           Next => Right,  --  Left      Nod ---> Right\n+                           Prev => Left);  --  Left <--- Nod ---> Right\n+\n+      begin\n+         Left.Next  := Nod;                --  Left <--> Nod ---> Right\n+         Right.Prev := Nod;                --  Left <--> Nod <--> Right\n+\n+         L.Elements := L.Elements + 1;\n+      end Insert_Between;\n+\n+      --------------\n+      -- Is_Empty --\n+      --------------\n+\n+      function Is_Empty (L : Instance) return Boolean is\n+      begin\n+         Ensure_Created (L);\n+\n+         return L.Elements = 0;\n+      end Is_Empty;\n+\n+      --------------\n+      -- Is_Valid --\n+      --------------\n+\n+      function Is_Valid (Iter : Iterator) return Boolean is\n+      begin\n+         --  The invariant of Iterate and Next ensures that the iterator always\n+         --  refers to a valid node if there exists one.\n+\n+         return Is_Valid (Iter.Nod, Iter.List.Nodes'Access);\n+      end Is_Valid;\n+\n+      --------------\n+      -- Is_Valid --\n+      --------------\n+\n+      function Is_Valid (Nod : Node_Ptr; Head : Node_Ptr) return Boolean is\n+      begin\n+         --  A node is valid if it is non-null, and does not refer to the dummy\n+         --  head of some list.\n+\n+         return Nod /= null and then Nod /= Head;\n+      end Is_Valid;\n+\n+      -------------\n+      -- Iterate --\n+      -------------\n+\n+      function Iterate (L : Instance) return Iterator is\n+      begin\n+         Ensure_Created (L);\n+\n+         --  Lock all mutation functionality of the list while it is being\n+         --  iterated on.\n+\n+         Lock (L);\n+\n+         return (List => L, Nod => L.Nodes.Next);\n+      end Iterate;\n+\n+      ----------\n+      -- Last --\n+      ----------\n+\n+      function Last (L : Instance) return Element_Type is\n+      begin\n+         Ensure_Created (L);\n+         Ensure_Full   (L);\n+\n+         return L.Nodes.Prev.Elem;\n+      end Last;\n+\n+      ------------\n+      -- Length --\n+      ------------\n+\n+      function Length (L : Instance) return Element_Count_Type is\n+      begin\n+         Ensure_Created (L);\n+\n+         return L.Elements;\n+      end Length;\n+\n+      ----------\n+      -- Lock --\n+      ----------\n+\n+      procedure Lock (L : Instance) is\n+      begin\n+         pragma Assert (L /= null);\n+\n+         --  The list may be locked multiple times if multiple iterators are\n+         --  operating over it.\n+\n+         L.Locked := L.Locked + 1;\n+      end Lock;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter : in out Iterator;\n+         Elem : out Element_Type)\n+      is\n+         Is_OK : constant Boolean  := Is_Valid (Iter);\n+         Saved : constant Node_Ptr := Iter.Nod;\n+\n+      begin\n+         --  The iterator is no linger valid which indicates that it has been\n+         --  exhausted. Unlock all mutation functionality of the list as the\n+         --  iterator cannot be advanced any further.\n+\n+         if not Is_OK then\n+            Unlock (Iter.List);\n+            raise Iterator_Exhausted;\n+         end if;\n+\n+         --  Advance to the next node along the list\n+\n+         Iter.Nod := Iter.Nod.Next;\n+         Elem     := Saved.Elem;\n+      end Next;\n+\n+      -------------\n+      -- Prepend --\n+      -------------\n+\n+      procedure Prepend (L : Instance; Elem : Element_Type) is\n+         Head : Node_Ptr;\n+\n+      begin\n+         Ensure_Created  (L);\n+         Ensure_Unlocked (L);\n+\n+         --  Ensure that the dummy head of an empty list is circular with\n+         --  respect to itself.\n+\n+         Head := L.Nodes'Access;\n+         Ensure_Circular (Head);\n+\n+         --  Append the node by inserting it between the dummy head and the\n+         --  first node.\n+\n+         Insert_Between\n+           (L     => L,\n+            Elem  => Elem,\n+            Left  => Head,\n+            Right => Head.Next);\n+      end Prepend;\n+\n+      -------------\n+      -- Replace --\n+      -------------\n+\n+      procedure Replace\n+        (L        : Instance;\n+         Old_Elem : Element_Type;\n+         New_Elem : Element_Type)\n+      is\n+         Head : Node_Ptr;\n+         Nod  : Node_Ptr;\n+\n+      begin\n+         Ensure_Created  (L);\n+         Ensure_Unlocked (L);\n+\n+         Head := L.Nodes'Access;\n+         Nod  := Find_Node (Head, Old_Elem);\n+\n+         if Is_Valid (Nod, Head) then\n+            Nod.Elem := New_Elem;\n+         end if;\n+      end Replace;\n+\n+      ------------\n+      -- Unlock --\n+      ------------\n+\n+      procedure Unlock (L : Instance) is\n+      begin\n+         pragma Assert (L /= null);\n+\n+         --  The list may be locked multiple times if multiple iterators are\n+         --  operating over it.\n+\n+         L.Locked := L.Locked - 1;\n+      end Unlock;\n+   end Doubly_Linked_List;\n+\n+end GNAT.Lists;"}, {"sha": "777b4f637ae228ff461f13f4885dafb91becc8e5", "filename": "gcc/ada/libgnat/g-lists.ads", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Fada%2Flibgnat%2Fg-lists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Fada%2Flibgnat%2Fg-lists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-lists.ads?ref=2201fa7bd34d215e4aeeb961d41f60f3fb80f101", "patch": "@@ -0,0 +1,245 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                            G N A T . L I S T S                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2018, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Compiler_Unit_Warning;\n+\n+package GNAT.Lists is\n+\n+   ------------------------\n+   -- Doubly_Linked_List --\n+   ------------------------\n+\n+   --  The following package offers a doubly linked list abstraction with the\n+   --  following characteristics:\n+   --\n+   --    * Creation of multiple instances, of different sizes.\n+   --    * Iterable elements.\n+   --\n+   --  The following use pattern must be employed with this list:\n+   --\n+   --    List : Instance := Create;\n+   --\n+   --    <various operations>\n+   --\n+   --    Destroy (List)\n+   --\n+   --  The destruction of the list reclaims all storage occupied by it.\n+\n+   --  The following type denotes the number of elements stored in a list\n+\n+   type Element_Count_Type is range 0 .. 2 ** 31 - 1;\n+\n+   generic\n+      type Element_Type is private;\n+\n+      with function \"=\"\n+        (Left  : Element_Type;\n+         Right : Element_Type) return Boolean;\n+\n+   package Doubly_Linked_List is\n+\n+      ---------------------\n+      -- List operations --\n+      ---------------------\n+\n+      type Instance is private;\n+      Nil : constant Instance;\n+\n+      List_Empty : exception;\n+      --  This exception is raised when the list is empty, and an attempt is\n+      --  made to delete an element from it.\n+\n+      List_Locked : exception;\n+      --  This exception is raised when the list is being iterated on, and an\n+      --  attempt is made to mutate its state.\n+\n+      Not_Created : exception;\n+      --  This exception is raised when the list has not been created by\n+      --  routine Create, and an attempt is made to read or mutate its state.\n+\n+      procedure Append (L : Instance; Elem : Element_Type);\n+      --  Insert element Elem at the end of list L. This action will raise\n+      --  List_Locked if the list has outstanding iterators.\n+\n+      function Contains (L : Instance; Elem : Element_Type) return Boolean;\n+      --  Determine whether list L contains element Elem\n+\n+      function Create return Instance;\n+      --  Create a new list\n+\n+      procedure Delete (L : Instance; Elem : Element_Type);\n+      --  Delete element Elem from list L. The routine has no effect if Elem is\n+      --  not present. This action will raise\n+      --\n+      --    * List_Empty if the list is empty.\n+      --    * List_Locked if the list has outstanding iterators.\n+\n+      procedure Delete_First (L : Instance);\n+      --  Delete an element from the start of list L. This action will raise\n+      --\n+      --    * List_Empty if the list is empty.\n+      --    * List_Locked if the list has outstanding iterators.\n+\n+      procedure Delete_Last (L : Instance);\n+      --  Delete an element from the end of list L. This action will raise\n+      --\n+      --    * List_Empty if the list is empty.\n+      --    * List_Locked if the list has outstanding iterators.\n+\n+      procedure Destroy (L : in out Instance);\n+      --  Destroy the contents of list L. This routine must be called at the\n+      --  end of a list's lifetime. This action will raise List_Locked if the\n+      --  list has outstanding iterators.\n+\n+      function First (L : Instance) return Element_Type;\n+      --  Obtain an element from the start of list L. This action will raise\n+      --  List_Empty if the list is empty.\n+\n+      procedure Insert_After\n+        (L     : Instance;\n+         After : Element_Type;\n+         Elem  : Element_Type);\n+      --  Insert new element Elem after element After in list L. The routine\n+      --  has no effect if After is not present. This action will raise\n+      --  List_Locked if the list has outstanding iterators.\n+\n+      procedure Insert_Before\n+        (L      : Instance;\n+         Before : Element_Type;\n+         Elem   : Element_Type);\n+      --  Insert new element Elem before element Before in list L. The routine\n+      --  has no effect if After is not present. This action will raise\n+      --  List_Locked if the list has outstanding iterators.\n+\n+      function Is_Empty (L : Instance) return Boolean;\n+      --  Determine whether list L is empty\n+\n+      function Last (L : Instance) return Element_Type;\n+      --  Obtain an element from the end of list L. This action will raise\n+      --  List_Empty if the list is empty.\n+\n+      function Length (L : Instance) return Element_Count_Type;\n+      --  Obtain the number of elements in list L\n+\n+      procedure Prepend (L : Instance; Elem : Element_Type);\n+      --  Insert element Elem at the start of list L. This action will raise\n+      --  List_Locked if the list has outstanding iterators.\n+\n+      procedure Replace\n+        (L        : Instance;\n+         Old_Elem : Element_Type;\n+         New_Elem : Element_Type);\n+      --  Replace old element Old_Elem with new element New_Elem in list L. The\n+      --  routine has no effect if Old_Elem is not present. This action will\n+      --  raise List_Locked if the list has outstanding iterators.\n+\n+      -------------------------\n+      -- Iterator operations --\n+      -------------------------\n+\n+      --  The following type represents an element iterator. An iterator locks\n+      --  all mutation operations, and ulocks them once it is exhausted. The\n+      --  iterator must be used with the following pattern:\n+      --\n+      --    Iter := Iterate (My_List);\n+      --    while Has_Next (Iter) loop\n+      --       Next (Iter, Element);\n+      --    end loop;\n+      --\n+      --  It is possible to advance the iterator by using Next only, however\n+      --  this risks raising Iterator_Exhausted.\n+\n+      type Iterator is private;\n+\n+      Iterator_Exhausted : exception;\n+      --  This exception is raised when an iterator is exhausted and further\n+      --  attempts to advance it are made by calling routine Next.\n+\n+      function Iterate (L : Instance) return Iterator;\n+      --  Obtain an iterator over the elements of list L. This action locks all\n+      --  mutation functionality of the associated list.\n+\n+      function Has_Next (Iter : Iterator) return Boolean;\n+      --  Determine whether iterator Iter has more elements to examine. If the\n+      --  iterator has been exhausted, restore all mutation functionality of\n+      --  the associated list.\n+\n+      procedure Next\n+        (Iter : in out Iterator;\n+         Elem : out Element_Type);\n+      --  Return the current element referenced by iterator Iter and advance\n+      --  to the next available element. If the iterator has been exhausted\n+      --  and further attempts are made to advance it, this routine restores\n+      --  mutation functionality of the associated list, and then raises\n+      --  Iterator_Exhausted.\n+\n+   private\n+      --  The following type represents a list node\n+\n+      type Node;\n+      type Node_Ptr is access all Node;\n+      type Node is record\n+         Elem : Element_Type;\n+\n+         Next : Node_Ptr := null;\n+         Prev : Node_Ptr := null;\n+      end record;\n+\n+      --  The following type represents a list\n+\n+      type Linked_List is record\n+         Elements : Element_Count_Type := 0;\n+         --  The number of elements in the list\n+\n+         Locked : Natural := 0;\n+         --  Number of outstanding iterators\n+\n+         Nodes : aliased Node;\n+         --  The dummy head of the list\n+      end record;\n+\n+      type Instance is access all Linked_List;\n+      Nil : constant Instance := null;\n+\n+      --  The following type represents an element iterator\n+\n+      type Iterator is record\n+         List : Instance := null;\n+         --  Reference to the associated list\n+\n+         Nod : Node_Ptr := null;\n+         --  Reference to the current node being examined. The invariant of the\n+         --  iterator requires that this field always points to a valid node. A\n+         --  value of null indicates that the iterator is exhausted.\n+      end record;\n+   end Doubly_Linked_List;\n+\n+end GNAT.Lists;"}, {"sha": "f95fe09eb3daf0811d9c53080f7191df4c597856", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2201fa7bd34d215e4aeeb961d41f60f3fb80f101", "patch": "@@ -1,3 +1,7 @@\n+2018-08-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* gnat.dg/linkedlist.adb: New testcase.\n+\n 2018-08-21  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* gnat.dg/elab6.adb, gnat.dg/elab6.ads, gnat.dg/elab6_pkg.adb,"}, {"sha": "53a272fe9253b452f8fecd08299bc821a8cbf1c7", "filename": "gcc/testsuite/gnat.dg/linkedlist.adb", "status": "added", "additions": 1184, "deletions": 0, "changes": 1184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Ftestsuite%2Fgnat.dg%2Flinkedlist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2201fa7bd34d215e4aeeb961d41f60f3fb80f101/gcc%2Ftestsuite%2Fgnat.dg%2Flinkedlist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flinkedlist.adb?ref=2201fa7bd34d215e4aeeb961d41f60f3fb80f101", "patch": "@@ -0,0 +1,1184 @@\n+--  { dg-do run }\n+\n+with Ada.Text_IO; use Ada.Text_IO;\n+with GNAT.Lists;  use GNAT.Lists;\n+\n+procedure Linkedlist is\n+   package Integer_Lists is new Doubly_Linked_List\n+     (Element_Type => Integer,\n+      \"=\"          => \"=\");\n+   use Integer_Lists;\n+\n+   procedure Check_Empty\n+     (Caller    : String;\n+      L         : Instance;\n+      Low_Elem  : Integer;\n+      High_Elem : Integer);\n+   --  Ensure that none of the elements in the range Low_Elem .. High_Elem are\n+   --  present in list L, and that the list's length is 0.\n+\n+   procedure Check_Locked_Mutations (Caller : String; L : in out Instance);\n+   --  Ensure that all mutation operations of list L are locked\n+\n+   procedure Check_Present\n+     (Caller    : String;\n+      L         : Instance;\n+      Low_Elem  : Integer;\n+      High_Elem : Integer);\n+   --  Ensure that all elements in the range Low_Elem .. High_Elem are present\n+   --  in list L.\n+\n+   procedure Check_Unlocked_Mutations (Caller : String; L : in out Instance);\n+   --  Ensure that all mutation operations of list L are unlocked\n+\n+   procedure Populate_With_Append\n+     (L         : Instance;\n+      Low_Elem  : Integer;\n+      High_Elem : Integer);\n+   --  Add elements in the range Low_Elem .. High_Elem in that order in list L\n+\n+   procedure Test_Append;\n+   --  Verify that Append properly inserts at the tail of a list\n+\n+   procedure Test_Contains\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer);\n+   --  Verify that Contains properly identifies that elements in the range\n+   --  Low_Elem .. High_Elem are within a list.\n+\n+   procedure Test_Create;\n+   --  Verify that all list operations fail on a non-created list\n+\n+   procedure Test_Delete\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer);\n+   --  Verify that Delete properly removes elements in the range Low_Elem ..\n+   --  High_Elem from a list.\n+\n+   procedure Test_Delete_First\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer);\n+   --  Verify that Delete properly removes elements in the range Low_Elem ..\n+   --  High_Elem from the head of a list.\n+\n+   procedure Test_Delete_Last\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer);\n+   --  Verify that Delete properly removes elements in the range Low_Elem ..\n+   --  High_Elem from the tail of a list.\n+\n+   procedure Test_First;\n+   --  Verify that First properly returns the head of a list\n+\n+   procedure Test_Insert_After;\n+   --  Verify that Insert_After properly adds an element after some other\n+   --  element.\n+\n+   procedure Test_Insert_Before;\n+   --  Vefity that Insert_Before properly adds an element before some other\n+   --  element.\n+\n+   procedure Test_Is_Empty;\n+   --  Verify that Is_Empty properly returns this status of a list\n+\n+   procedure Test_Iterate;\n+   --  Verify that iterators properly manipulate mutation operations\n+\n+   procedure Test_Iterate_Empty;\n+   --  Verify that iterators properly manipulate mutation operations of an\n+   --  empty list.\n+\n+   procedure Test_Iterate_Forced\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer);\n+   --  Verify that an iterator that is forcefully advanced by Next properly\n+   --  unlocks the mutation operations of a list.\n+\n+   procedure Test_Last;\n+   --  Verify that Last properly returns the tail of a list\n+\n+   procedure Test_Length;\n+   --  Verify that Length returns the correct length of a list\n+\n+   procedure Test_Prepend;\n+   --  Verify that Prepend properly inserts at the head of a list\n+\n+   procedure Test_Replace;\n+   --  Verify that Replace properly substitutes old elements with new ones\n+\n+   -----------------\n+   -- Check_Empty --\n+   -----------------\n+\n+   procedure Check_Empty\n+     (Caller    : String;\n+      L         : Instance;\n+      Low_Elem  : Integer;\n+      High_Elem : Integer)\n+   is\n+      Len : constant Element_Count_Type := Length (L);\n+\n+   begin\n+      for Elem in Low_Elem .. High_Elem loop\n+         if Contains (L, Elem) then\n+            Put_Line (\"ERROR: \" & Caller & \": extra element\" & Elem'Img);\n+         end if;\n+      end loop;\n+\n+      if Len /= 0 then\n+         Put_Line (\"ERROR: \" & Caller & \": wrong length\");\n+         Put_Line (\"expected: 0\");\n+         Put_Line (\"got     :\" & Len'Img);\n+      end if;\n+   end Check_Empty;\n+\n+   ----------------------------\n+   -- Check_Locked_Mutations --\n+   ----------------------------\n+\n+   procedure Check_Locked_Mutations (Caller : String; L : in out Instance) is\n+   begin\n+      begin\n+         Append (L, 1);\n+         Put_Line (\"ERROR: \" & Caller & \": Append: no exception raised\");\n+      exception\n+         when List_Locked =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: \" & Caller & \": Append: unexpected exception\");\n+      end;\n+\n+      begin\n+         Delete (L, 1);\n+         Put_Line (\"ERROR: \" & Caller & \": Delete: no exception raised\");\n+      exception\n+         when List_Empty =>\n+            null;\n+         when List_Locked =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: \" & Caller & \": Delete: unexpected exception\");\n+      end;\n+\n+      begin\n+         Delete_First (L);\n+         Put_Line (\"ERROR: \" & Caller & \": Delete_First: no exception raised\");\n+      exception\n+         when List_Empty =>\n+            null;\n+         when List_Locked =>\n+            null;\n+         when others =>\n+            Put_Line\n+              (\"ERROR: \" & Caller & \": Delete_First: unexpected exception\");\n+      end;\n+\n+      begin\n+         Delete_Last (L);\n+         Put_Line (\"ERROR: \" & Caller & \": Delete_List: no exception raised\");\n+      exception\n+         when List_Empty =>\n+            null;\n+         when List_Locked =>\n+            null;\n+         when others =>\n+            Put_Line\n+              (\"ERROR: \" & Caller & \": Delete_Last: unexpected exception\");\n+      end;\n+\n+      begin\n+         Destroy (L);\n+         Put_Line (\"ERROR: \" & Caller & \": Destroy: no exception raised\");\n+      exception\n+         when List_Locked =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: \" & Caller & \": Destroy: unexpected exception\");\n+      end;\n+\n+      begin\n+         Insert_After (L, 1, 2);\n+         Put_Line (\"ERROR: \" & Caller & \": Insert_After: no exception raised\");\n+      exception\n+         when List_Locked =>\n+            null;\n+         when others =>\n+            Put_Line\n+              (\"ERROR: \" & Caller & \": Insert_After: unexpected exception\");\n+      end;\n+\n+      begin\n+         Insert_Before (L, 1, 2);\n+         Put_Line\n+           (\"ERROR: \" & Caller & \": Insert_Before: no exception raised\");\n+      exception\n+         when List_Locked =>\n+            null;\n+         when others =>\n+            Put_Line\n+              (\"ERROR: \" & Caller & \": Insert_Before: unexpected exception\");\n+      end;\n+\n+      begin\n+         Prepend (L, 1);\n+         Put_Line (\"ERROR: \" & Caller & \": Prepend: no exception raised\");\n+      exception\n+         when List_Locked =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: \" & Caller & \": Prepend: unexpected exception\");\n+      end;\n+\n+      begin\n+         Replace (L, 1, 2);\n+         Put_Line (\"ERROR: \" & Caller & \": Replace: no exception raised\");\n+      exception\n+         when List_Locked =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: \" & Caller & \": Replace: unexpected exception\");\n+      end;\n+   end Check_Locked_Mutations;\n+\n+   -------------------\n+   -- Check_Present --\n+   -------------------\n+\n+   procedure Check_Present\n+     (Caller    : String;\n+      L         : Instance;\n+      Low_Elem  : Integer;\n+      High_Elem : Integer)\n+   is\n+      Elem : Integer;\n+      Iter : Iterator;\n+\n+   begin\n+      Iter := Iterate (L);\n+      for Exp_Elem in Low_Elem .. High_Elem loop\n+         Next (Iter, Elem);\n+\n+         if Elem /= Exp_Elem then\n+            Put_Line (\"ERROR: \" & Caller & \": Check_Present: wrong element\");\n+            Put_Line (\"expected:\" & Exp_Elem'Img);\n+            Put_Line (\"got     :\" & Elem'Img);\n+         end if;\n+      end loop;\n+\n+      --  At this point all elements should have been accounted for. Check for\n+      --  extra elements.\n+\n+      while Has_Next (Iter) loop\n+         Next (Iter, Elem);\n+         Put_Line\n+           (\"ERROR: \" & Caller & \": Check_Present: extra element\" & Elem'Img);\n+      end loop;\n+\n+   exception\n+      when Iterator_Exhausted =>\n+         Put_Line\n+           (\"ERROR: \"\n+            & Caller\n+            & \"Check_Present: incorrect number of elements\");\n+   end Check_Present;\n+\n+   ------------------------------\n+   -- Check_Unlocked_Mutations --\n+   ------------------------------\n+\n+   procedure Check_Unlocked_Mutations (Caller : String; L : in out Instance) is\n+   begin\n+      Append        (L, 1);\n+      Append        (L, 2);\n+      Append        (L, 3);\n+      Delete        (L, 1);\n+      Delete_First  (L);\n+      Delete_Last   (L);\n+      Insert_After  (L, 2, 3);\n+      Insert_Before (L, 2, 1);\n+      Prepend       (L, 0);\n+      Replace       (L, 3, 4);\n+   end Check_Unlocked_Mutations;\n+\n+   --------------------------\n+   -- Populate_With_Append --\n+   --------------------------\n+\n+   procedure Populate_With_Append\n+     (L         : Instance;\n+      Low_Elem  : Integer;\n+      High_Elem : Integer)\n+   is\n+   begin\n+      for Elem in Low_Elem .. High_Elem loop\n+         Append (L, Elem);\n+      end loop;\n+   end Populate_With_Append;\n+\n+   -----------------\n+   -- Test_Append --\n+   -----------------\n+\n+   procedure Test_Append is\n+      L : Instance := Create;\n+\n+   begin\n+      Append (L, 1);\n+      Append (L, 2);\n+      Append (L, 3);\n+      Append (L, 4);\n+      Append (L, 5);\n+\n+      Check_Present\n+        (Caller    => \"Test_Append\",\n+         L         => L,\n+         Low_Elem  => 1,\n+         High_Elem => 5);\n+\n+      Destroy (L);\n+   end Test_Append;\n+\n+   -------------------\n+   -- Test_Contains --\n+   -------------------\n+\n+   procedure Test_Contains\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer)\n+   is\n+      Low_Bogus  : constant Integer := Low_Elem  - 1;\n+      High_Bogus : constant Integer := High_Elem + 1;\n+\n+      L : Instance := Create;\n+\n+   begin\n+      Populate_With_Append (L, Low_Elem, High_Elem);\n+\n+      --  Ensure that the elements are contained in the list\n+\n+      for Elem in Low_Elem .. High_Elem loop\n+         if not Contains (L, Elem) then\n+            Put_Line\n+              (\"ERROR: Test_Contains: element\" & Elem'Img & \" not in list\");\n+         end if;\n+      end loop;\n+\n+      --  Ensure that arbitrary elements which were not inserted in the list\n+      --  are not contained in the list.\n+\n+      if Contains (L, Low_Bogus) then\n+         Put_Line\n+           (\"ERROR: Test_Contains: element\" & Low_Bogus'Img & \" in list\");\n+      end if;\n+\n+      if Contains (L, High_Bogus) then\n+         Put_Line\n+           (\"ERROR: Test_Contains: element\" & High_Bogus'Img & \" in list\");\n+      end if;\n+\n+      Destroy (L);\n+   end Test_Contains;\n+\n+   -----------------\n+   -- Test_Create --\n+   -----------------\n+\n+   procedure Test_Create is\n+      Count : Element_Count_Type;\n+      Flag  : Boolean;\n+      Iter  : Iterator;\n+      L     : Instance;\n+      Val   : Integer;\n+\n+   begin\n+      --  Ensure that every routine defined in the API fails on a list which\n+      --  has not been created yet.\n+\n+      begin\n+         Append (L, 1);\n+         Put_Line (\"ERROR: Test_Create: Append: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Append: unexpected exception\");\n+      end;\n+\n+      begin\n+         Flag := Contains (L, 1);\n+         Put_Line (\"ERROR: Test_Create: Contains: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Contains: unexpected exception\");\n+      end;\n+\n+      begin\n+         Delete (L, 1);\n+         Put_Line (\"ERROR: Test_Create: Delete: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Delete: unexpected exception\");\n+      end;\n+\n+      begin\n+         Delete_First (L);\n+         Put_Line (\"ERROR: Test_Create: Delete_First: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line\n+              (\"ERROR: Test_Create: Delete_First: unexpected exception\");\n+      end;\n+\n+      begin\n+         Delete_Last (L);\n+         Put_Line (\"ERROR: Test_Create: Delete_Last: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Delete_Last: unexpected exception\");\n+      end;\n+\n+      begin\n+         Val := First (L);\n+         Put_Line (\"ERROR: Test_Create: First: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: First: unexpected exception\");\n+      end;\n+\n+      begin\n+         Insert_After (L, 1, 2);\n+         Put_Line (\"ERROR: Test_Create: Insert_After: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line\n+              (\"ERROR: Test_Create: Insert_After: unexpected exception\");\n+      end;\n+\n+      begin\n+         Insert_Before (L, 1, 2);\n+         Put_Line (\"ERROR: Test_Create: Insert_Before: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line\n+              (\"ERROR: Test_Create: Insert_Before: unexpected exception\");\n+      end;\n+\n+      begin\n+         Flag := Is_Empty (L);\n+         Put_Line (\"ERROR: Test_Create: Is_Empty: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Is_Empty: unexpected exception\");\n+      end;\n+\n+      begin\n+         Iter := Iterate (L);\n+         Put_Line (\"ERROR: Test_Create: Iterate: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Iterate: unexpected exception\");\n+      end;\n+\n+      begin\n+         Val := Last (L);\n+         Put_Line (\"ERROR: Test_Create: Last: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Last: unexpected exception\");\n+      end;\n+\n+      begin\n+         Count := Length (L);\n+         Put_Line (\"ERROR: Test_Create: Length: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Length: unexpected exception\");\n+      end;\n+\n+      begin\n+         Prepend (L, 1);\n+         Put_Line (\"ERROR: Test_Create: Prepend: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Prepend: unexpected exception\");\n+      end;\n+\n+      begin\n+         Replace (L, 1, 2);\n+         Put_Line (\"ERROR: Test_Create: Replace: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Replace: unexpected exception\");\n+      end;\n+   end Test_Create;\n+\n+   -----------------\n+   -- Test_Delete --\n+   -----------------\n+\n+   procedure Test_Delete\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer)\n+   is\n+      Iter : Iterator;\n+      L    : Instance := Create;\n+\n+   begin\n+      Populate_With_Append (L, Low_Elem, High_Elem);\n+\n+      --  Delete the first element, which is technically the head\n+\n+      Delete (L, Low_Elem);\n+\n+      --  Ensure that all remaining elements except for the head are present in\n+      --  the list.\n+\n+      Check_Present\n+        (Caller    => \"Test_Delete\",\n+         L         => L,\n+         Low_Elem  => Low_Elem + 1,\n+         High_Elem => High_Elem);\n+\n+      --  Delete the last element, which is technically the tail\n+\n+      Delete (L, High_Elem);\n+\n+      --  Ensure that all remaining elements except for the head and tail are\n+      --  present in the list.\n+\n+      Check_Present\n+        (Caller    => \"Test_Delete\",\n+         L         => L,\n+         Low_Elem  => Low_Elem  + 1,\n+         High_Elem => High_Elem - 1);\n+\n+      --  Delete all even elements\n+\n+      for Elem in Low_Elem + 1 .. High_Elem - 1 loop\n+         if Elem mod 2 = 0 then\n+            Delete (L, Elem);\n+         end if;\n+      end loop;\n+\n+      --  Ensure that all remaining elements except the head, tail, and even\n+      --  elements are present in the list.\n+\n+      for Elem in Low_Elem + 1 .. High_Elem - 1 loop\n+         if Elem mod 2 /= 0 and then not Contains (L, Elem) then\n+            Put_Line (\"ERROR: Test_Delete: missing element\" & Elem'Img);\n+         end if;\n+      end loop;\n+\n+      --  Delete all odd elements\n+\n+      for Elem in Low_Elem + 1 .. High_Elem - 1 loop\n+         if Elem mod 2 /= 0 then\n+            Delete (L, Elem);\n+         end if;\n+      end loop;\n+\n+      --  At this point the list should be completely empty\n+\n+      Check_Empty\n+        (Caller    => \"Test_Delete\",\n+         L         => L,\n+         Low_Elem  => Low_Elem,\n+         High_Elem => High_Elem);\n+\n+      --  Try to delete an element. This operation should raise List_Empty.\n+\n+      begin\n+         Delete (L, Low_Elem);\n+         Put_Line (\"ERROR: Test_Delete: List_Empty not raised\");\n+      exception\n+         when List_Empty =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Delete: unexpected exception\");\n+      end;\n+\n+      Destroy (L);\n+   end Test_Delete;\n+\n+   -----------------------\n+   -- Test_Delete_First --\n+   -----------------------\n+\n+   procedure Test_Delete_First\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer)\n+   is\n+      L : Instance := Create;\n+\n+   begin\n+      Populate_With_Append (L, Low_Elem, High_Elem);\n+\n+      --  Delete the head of the list, and verify that the remaining elements\n+      --  are still present in the list.\n+\n+      for Elem in Low_Elem .. High_Elem loop\n+         Delete_First (L);\n+\n+         Check_Present\n+           (Caller    => \"Test_Delete_First\",\n+            L         => L,\n+            Low_Elem  => Elem + 1,\n+            High_Elem => High_Elem);\n+      end loop;\n+\n+      --  At this point the list should be completely empty\n+\n+      Check_Empty\n+        (Caller    => \"Test_Delete_First\",\n+         L         => L,\n+         Low_Elem  => Low_Elem,\n+         High_Elem => High_Elem);\n+\n+      --  Try to delete an element. This operation should raise List_Empty.\n+\n+      begin\n+         Delete_First (L);\n+         Put_Line (\"ERROR: Test_Delete_First: List_Empty not raised\");\n+      exception\n+         when List_Empty =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Delete_First: unexpected exception\");\n+      end;\n+\n+      Destroy (L);\n+   end Test_Delete_First;\n+\n+   ----------------------\n+   -- Test_Delete_Last --\n+   ----------------------\n+\n+   procedure Test_Delete_Last\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer)\n+   is\n+      L : Instance := Create;\n+\n+   begin\n+      Populate_With_Append (L, Low_Elem, High_Elem);\n+\n+      --  Delete the tail of the list, and verify that the remaining elements\n+      --  are still present in the list.\n+\n+      for Elem in reverse Low_Elem .. High_Elem loop\n+         Delete_Last (L);\n+\n+         Check_Present\n+           (Caller    => \"Test_Delete_Last\",\n+            L         => L,\n+            Low_Elem  => Low_Elem,\n+            High_Elem => Elem - 1);\n+      end loop;\n+\n+      --  At this point the list should be completely empty\n+\n+      Check_Empty\n+        (Caller    => \"Test_Delete_Last\",\n+         L         => L,\n+         Low_Elem  => Low_Elem,\n+         High_Elem => High_Elem);\n+\n+      --  Try to delete an element. This operation should raise List_Empty.\n+\n+      begin\n+         Delete_Last (L);\n+         Put_Line (\"ERROR: Test_Delete_Last: List_Empty not raised\");\n+      exception\n+         when List_Empty =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Delete_First: unexpected exception\");\n+      end;\n+\n+      Destroy (L);\n+   end Test_Delete_Last;\n+\n+   ----------------\n+   -- Test_First --\n+   ----------------\n+\n+   procedure Test_First is\n+      Elem : Integer;\n+      L    : Instance := Create;\n+\n+   begin\n+      --  Try to obtain the head. This operation should raise List_Empty.\n+\n+      begin\n+         Elem := First (L);\n+         Put_Line (\"ERROR: Test_First: List_Empty not raised\");\n+      exception\n+         when List_Empty =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_First: unexpected exception\");\n+      end;\n+\n+      Populate_With_Append (L, 1, 2);\n+\n+      --  Obtain the head\n+\n+      Elem := First (L);\n+\n+      if Elem /= 1 then\n+         Put_Line (\"ERROR: Test_First: wrong element\");\n+         Put_Line (\"expected: 1\");\n+         Put_Line (\"got     :\" & Elem'Img);\n+      end if;\n+\n+      Destroy (L);\n+   end Test_First;\n+\n+   -----------------------\n+   -- Test_Insert_After --\n+   -----------------------\n+\n+   procedure Test_Insert_After is\n+      L : Instance := Create;\n+\n+   begin\n+      --  Try to insert after a non-inserted element, in an empty list\n+\n+      Insert_After (L, 1, 2);\n+\n+      --  At this point the list should be completely empty\n+\n+      Check_Empty\n+        (Caller    => \"Test_Insert_After\",\n+         L         => L,\n+         Low_Elem  => 0,\n+         High_Elem => -1);\n+\n+      Append (L, 1);           --  1\n+\n+      Insert_After (L, 1, 3);  --  1, 3\n+      Insert_After (L, 1, 2);  --  1, 2, 3\n+      Insert_After (L, 3, 4);  --  1, 2, 3, 4\n+\n+      --  Try to insert after a non-inserted element, in a full list\n+\n+      Insert_After (L, 10, 11);\n+\n+      Check_Present\n+        (Caller    => \"Test_Insert_After\",\n+         L         => L,\n+         Low_Elem  => 1,\n+         High_Elem => 4);\n+\n+      Destroy (L);\n+   end Test_Insert_After;\n+\n+   ------------------------\n+   -- Test_Insert_Before --\n+   ------------------------\n+\n+   procedure Test_Insert_Before is\n+      L : Instance := Create;\n+\n+   begin\n+      --  Try to insert before a non-inserted element, in an empty list\n+\n+      Insert_Before (L, 1, 2);\n+\n+      --  At this point the list should be completely empty\n+\n+      Check_Empty\n+        (Caller    => \"Test_Insert_Before\",\n+         L         => L,\n+         Low_Elem  => 0,\n+         High_Elem => -1);\n+\n+      Append (L, 4);            --  4\n+\n+      Insert_Before (L, 4, 2);  --  2, 4\n+      Insert_Before (L, 2, 1);  --  1, 2, 4\n+      Insert_Before (L, 4, 3);  --  1, 2, 3, 4\n+\n+      --  Try to insert before a non-inserted element, in a full list\n+\n+      Insert_Before (L, 10, 11);\n+\n+      Check_Present\n+        (Caller    => \"Test_Insert_Before\",\n+         L         => L,\n+         Low_Elem  => 1,\n+         High_Elem => 4);\n+\n+      Destroy (L);\n+   end Test_Insert_Before;\n+\n+   -------------------\n+   -- Test_Is_Empty --\n+   -------------------\n+\n+   procedure Test_Is_Empty is\n+      L : Instance := Create;\n+\n+   begin\n+      if not Is_Empty (L) then\n+         Put_Line (\"ERROR: Test_Is_Empty: list is not empty\");\n+      end if;\n+\n+      Append (L, 1);\n+\n+      if Is_Empty (L) then\n+         Put_Line (\"ERROR: Test_Is_Empty: list is empty\");\n+      end if;\n+\n+      Delete_First (L);\n+\n+      if not Is_Empty (L) then\n+         Put_Line (\"ERROR: Test_Is_Empty: list is not empty\");\n+      end if;\n+\n+      Destroy (L);\n+   end Test_Is_Empty;\n+\n+   ------------------\n+   -- Test_Iterate --\n+   ------------------\n+\n+   procedure Test_Iterate is\n+      Elem   : Integer;\n+      Iter_1 : Iterator;\n+      Iter_2 : Iterator;\n+      L      : Instance := Create;\n+\n+   begin\n+      Populate_With_Append (L, 1, 5);\n+\n+      --  Obtain an iterator. This action must lock all mutation operations of\n+      --  the list.\n+\n+      Iter_1 := Iterate (L);\n+\n+      --  Ensure that every mutation routine defined in the API fails on a list\n+      --  with at least one outstanding iterator.\n+\n+      Check_Locked_Mutations\n+        (Caller => \"Test_Iterate\",\n+         L      => L);\n+\n+      --  Obtain another iterator\n+\n+      Iter_2 := Iterate (L);\n+\n+      --  Ensure that every mutation is still locked\n+\n+      Check_Locked_Mutations\n+        (Caller => \"Test_Iterate\",\n+         L      => L);\n+\n+      --  Exhaust the first itertor\n+\n+      while Has_Next (Iter_1) loop\n+         Next (Iter_1, Elem);\n+      end loop;\n+\n+      --  Ensure that every mutation is still locked\n+\n+      Check_Locked_Mutations\n+        (Caller => \"Test_Iterate\",\n+         L      => L);\n+\n+      --  Exhaust the second itertor\n+\n+      while Has_Next (Iter_2) loop\n+         Next (Iter_2, Elem);\n+      end loop;\n+\n+      --  Ensure that all mutation operations are once again callable\n+\n+      Check_Unlocked_Mutations\n+        (Caller => \"Test_Iterate\",\n+         L      => L);\n+\n+      Destroy (L);\n+   end Test_Iterate;\n+\n+   ------------------------\n+   -- Test_Iterate_Empty --\n+   ------------------------\n+\n+   procedure Test_Iterate_Empty is\n+      Elem : Integer;\n+      Iter : Iterator;\n+      L    : Instance := Create;\n+\n+   begin\n+      --  Obtain an iterator. This action must lock all mutation operations of\n+      --  the list.\n+\n+      Iter := Iterate (L);\n+\n+      --  Ensure that every mutation routine defined in the API fails on a list\n+      --  with at least one outstanding iterator.\n+\n+      Check_Locked_Mutations\n+        (Caller => \"Test_Iterate_Empty\",\n+         L      => L);\n+\n+      --  Attempt to iterate over the elements\n+\n+      while Has_Next (Iter) loop\n+         Next (Iter, Elem);\n+\n+         Put_Line\n+           (\"ERROR: Test_Iterate_Empty: element\" & Elem'Img & \" exists\");\n+      end loop;\n+\n+      --  Ensure that all mutation operations are once again callable\n+\n+      Check_Unlocked_Mutations\n+        (Caller => \"Test_Iterate_Empty\",\n+         L      => L);\n+\n+      Destroy (L);\n+   end Test_Iterate_Empty;\n+\n+   -------------------------\n+   -- Test_Iterate_Forced --\n+   -------------------------\n+\n+   procedure Test_Iterate_Forced\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer)\n+   is\n+      Elem : Integer;\n+      Iter : Iterator;\n+      L    : Instance := Create;\n+\n+   begin\n+      Populate_With_Append (L, Low_Elem, High_Elem);\n+\n+      --  Obtain an iterator. This action must lock all mutation operations of\n+      --  the list.\n+\n+      Iter := Iterate (L);\n+\n+      --  Ensure that every mutation routine defined in the API fails on a list\n+      --  with at least one outstanding iterator.\n+\n+      Check_Locked_Mutations\n+        (Caller => \"Test_Iterate_Forced\",\n+         L      => L);\n+\n+      --  Forcibly advance the iterator until it raises an exception\n+\n+      begin\n+         for Guard in Low_Elem .. High_Elem + 1 loop\n+            Next (Iter, Elem);\n+         end loop;\n+\n+         Put_Line\n+           (\"ERROR: Test_Iterate_Forced: Iterator_Exhausted not raised\");\n+      exception\n+         when Iterator_Exhausted =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Iterate_Forced: unexpected exception\");\n+      end;\n+\n+      --  Ensure that all mutation operations are once again callable\n+\n+      Check_Unlocked_Mutations\n+        (Caller => \"Test_Iterate_Forced\",\n+         L      => L);\n+\n+      Destroy (L);\n+   end Test_Iterate_Forced;\n+\n+   ---------------\n+   -- Test_Last --\n+   ---------------\n+\n+   procedure Test_Last is\n+      Elem : Integer;\n+      L    : Instance := Create;\n+\n+   begin\n+      --  Try to obtain the tail. This operation should raise List_Empty.\n+\n+      begin\n+         Elem := First (L);\n+         Put_Line (\"ERROR: Test_Last: List_Empty not raised\");\n+      exception\n+         when List_Empty =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Last: unexpected exception\");\n+      end;\n+\n+      Populate_With_Append (L, 1, 2);\n+\n+      --  Obtain the tail\n+\n+      Elem := Last (L);\n+\n+      if Elem /= 2 then\n+         Put_Line (\"ERROR: Test_Last: wrong element\");\n+         Put_Line (\"expected: 2\");\n+         Put_Line (\"got     :\" & Elem'Img);\n+      end if;\n+\n+      Destroy (L);\n+   end Test_Last;\n+\n+   -----------------\n+   -- Test_Length --\n+   -----------------\n+\n+   procedure Test_Length is\n+      L   : Instance := Create;\n+      Len : Element_Count_Type;\n+\n+   begin\n+      Len := Length (L);\n+\n+      if Len /= 0 then\n+         Put_Line (\"ERROR: Test_Length: wrong length\");\n+         Put_Line (\"expected: 0\");\n+         Put_Line (\"got     :\" & Len'Img);\n+      end if;\n+\n+      Populate_With_Append (L, 1, 2);\n+      Len := Length (L);\n+\n+      if Len /= 2 then\n+         Put_Line (\"ERROR: Test_Length: wrong length\");\n+         Put_Line (\"expected: 2\");\n+         Put_Line (\"got     :\" & Len'Img);\n+      end if;\n+\n+      Populate_With_Append (L, 3, 6);\n+      Len := Length (L);\n+\n+      if Len /= 6 then\n+         Put_Line (\"ERROR: Test_Length: wrong length\");\n+         Put_Line (\"expected: 6\");\n+         Put_Line (\"got     :\" & Len'Img);\n+      end if;\n+\n+      Destroy (L);\n+   end Test_Length;\n+\n+   ------------------\n+   -- Test_Prepend --\n+   ------------------\n+\n+   procedure Test_Prepend is\n+      L : Instance := Create;\n+\n+   begin\n+      Prepend (L, 5);\n+      Prepend (L, 4);\n+      Prepend (L, 3);\n+      Prepend (L, 2);\n+      Prepend (L, 1);\n+\n+      Check_Present\n+        (Caller    => \"Test_Prepend\",\n+         L         => L,\n+         Low_Elem  => 1,\n+         High_Elem => 5);\n+\n+      Destroy (L);\n+   end Test_Prepend;\n+\n+   ------------------\n+   -- Test_Replace --\n+   ------------------\n+\n+   procedure Test_Replace is\n+      L : Instance := Create;\n+\n+   begin\n+      Populate_With_Append (L, 1, 5);\n+\n+      Replace (L, 3, 8);\n+      Replace (L, 1, 6);\n+      Replace (L, 4, 9);\n+      Replace (L, 5, 10);\n+      Replace (L, 2, 7);\n+\n+      Replace (L, 11, 12);\n+\n+      Check_Present\n+        (Caller    => \"Test_Replace\",\n+         L         => L,\n+         Low_Elem  => 6,\n+         High_Elem => 10);\n+\n+      Destroy (L);\n+   end Test_Replace;\n+\n+--  Start of processing for Operations\n+\n+begin\n+   Test_Append;\n+\n+   Test_Contains\n+     (Low_Elem  => 1,\n+      High_Elem => 5);\n+\n+   Test_Create;\n+\n+   Test_Delete\n+     (Low_Elem  => 1,\n+      High_Elem => 10);\n+\n+   Test_Delete_First\n+     (Low_Elem  => 1,\n+      High_Elem => 5);\n+\n+   Test_Delete_Last\n+     (Low_Elem  => 1,\n+      High_Elem => 5);\n+\n+   Test_First;\n+   Test_Insert_After;\n+   Test_Insert_Before;\n+   Test_Is_Empty;\n+   Test_Iterate;\n+   Test_Iterate_Empty;\n+\n+   Test_Iterate_Forced\n+     (Low_Elem  => 1,\n+      High_Elem => 5);\n+\n+   Test_Last;\n+   Test_Length;\n+   Test_Prepend;\n+   Test_Replace;\n+end Linkedlist;"}]}