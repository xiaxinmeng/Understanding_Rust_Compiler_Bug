{"sha": "fc249fe5d62c73210b3f752fb45119391d0774f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMyNDlmZTVkNjJjNzMyMTBiM2Y3NTJmYjQ1MTE5MzkxZDA3NzRmMA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2010-04-14T14:50:33Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2010-04-14T14:50:33Z"}, "message": "re PR tree-optimization/42963 (Redundant switch labels not cleaned up anymore)\n\n\tPR tree-optimization/42963\n\t* tree-cfg.c (touched_switch_bbs): New static variable.\n\t(group_case_labels_stmt): New function broken out from ...\n\t(group_case_labels): ... here, use the above.\n\t(start_recording_case_labels): Allocate touched_switch_bbs.\n\t(end_recording_case_labels): Deallocate it, call\n\tgroup_case_labels_stmt.\n\t(gimple_redirect_edge_and_branch): Remember index of affected BB.\n\ntestsuite/\n\t* testsuite/gcc.dg/pr42963.c: New testcase.\n\nFrom-SVN: r158345", "tree": {"sha": "05e8f3fe688ca2ced73803178ff9b08bfa60f8b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05e8f3fe688ca2ced73803178ff9b08bfa60f8b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc249fe5d62c73210b3f752fb45119391d0774f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc249fe5d62c73210b3f752fb45119391d0774f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc249fe5d62c73210b3f752fb45119391d0774f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc249fe5d62c73210b3f752fb45119391d0774f0/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "289a9f867a78d0c928eed2d9793964b9c7272022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/289a9f867a78d0c928eed2d9793964b9c7272022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/289a9f867a78d0c928eed2d9793964b9c7272022"}], "stats": {"total": 249, "additions": 161, "deletions": 88}, "files": [{"sha": "06e1af49a18e3774d5fa76e1b92a8570d8c8d702", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc249fe5d62c73210b3f752fb45119391d0774f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc249fe5d62c73210b3f752fb45119391d0774f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc249fe5d62c73210b3f752fb45119391d0774f0", "patch": "@@ -1,3 +1,14 @@\n+2010-04-14  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/42963\n+\t* tree-cfg.c (touched_switch_bbs): New static variable.\n+\t(group_case_labels_stmt): New function broken out from ...\n+\t(group_case_labels): ... here, use the above.\n+\t(start_recording_case_labels): Allocate touched_switch_bbs.\n+\t(end_recording_case_labels): Deallocate it, call\n+\tgroup_case_labels_stmt.\n+\t(gimple_redirect_edge_and_branch): Remember index of affected BB.\n+\n 2010-04-14  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*popcountsi2_cmp_zext): Remove mode attribute"}, {"sha": "13ef39fc56bbef893395a0054920b8ae4ea36c63", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc249fe5d62c73210b3f752fb45119391d0774f0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc249fe5d62c73210b3f752fb45119391d0774f0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc249fe5d62c73210b3f752fb45119391d0774f0", "patch": "@@ -1,3 +1,8 @@\n+2010-04-14  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/42963\n+\t* testsuite/gcc.dg/pr42963.c: New testcase.\n+\n 2010-04-14  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/class_wide.adb: Rename into..."}, {"sha": "8664b0d847c6ae2532f079f6ddc51814da1dc9c6", "filename": "gcc/testsuite/gcc.dg/pr42963.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc249fe5d62c73210b3f752fb45119391d0774f0/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42963.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc249fe5d62c73210b3f752fb45119391d0774f0/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42963.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42963.c?ref=fc249fe5d62c73210b3f752fb45119391d0774f0", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-cfg\" } */\n+extern void foo (void);\n+extern int i;\n+void\n+bar (void)\n+{\n+  switch (i)\n+    {\n+    case 0:\n+      foo ();\n+      break;\n+    case 1:\n+      break;\n+    }\n+\n+\n+  switch (i)\n+    {\n+    case 0:\n+      foo ();\n+      break;\n+    case 1:\n+      break;\n+    }\n+}\n+/* { dg-final { scan-tree-dump-times \"case 1:\" 0 \"cfg\" } } */\n+/* { dg-final { cleanup-tree-dump \"cfg\" } } */"}, {"sha": "0e89f999a6f9db944dcbb5103daadf86264ea3e2", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 117, "deletions": 88, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc249fe5d62c73210b3f752fb45119391d0774f0/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc249fe5d62c73210b3f752fb45119391d0774f0/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=fc249fe5d62c73210b3f752fb45119391d0774f0", "patch": "@@ -71,6 +71,12 @@ static const int initial_cfg_capacity = 20;\n \n static struct pointer_map_t *edge_to_cases;\n \n+/* If we record edge_to_cases, this bitmap will hold indexes\n+   of basic blocks that end in a GIMPLE_SWITCH which we touched\n+   due to edge manipulations.  */\n+\n+static bitmap touched_switch_bbs;\n+\n /* CFG statistics.  */\n struct cfg_stats_d\n {\n@@ -122,6 +128,7 @@ static edge find_taken_edge_computed_goto (basic_block, tree);\n static edge find_taken_edge_cond_expr (basic_block, tree);\n static edge find_taken_edge_switch_expr (basic_block, tree);\n static tree find_case_label_for_value (gimple, tree);\n+static void group_case_labels_stmt (gimple);\n \n void\n init_empty_tree_cfg_for_function (struct function *fn)\n@@ -848,6 +855,7 @@ start_recording_case_labels (void)\n {\n   gcc_assert (edge_to_cases == NULL);\n   edge_to_cases = pointer_map_create ();\n+  touched_switch_bbs = BITMAP_ALLOC (NULL);\n }\n \n /* Return nonzero if we are recording information for case labels.  */\n@@ -863,9 +871,22 @@ recording_case_labels_p (void)\n void\n end_recording_case_labels (void)\n {\n+  bitmap_iterator bi;\n+  unsigned i;\n   pointer_map_traverse (edge_to_cases, edge_to_cases_cleanup, NULL);\n   pointer_map_destroy (edge_to_cases);\n   edge_to_cases = NULL;\n+  EXECUTE_IF_SET_IN_BITMAP (touched_switch_bbs, 0, i, bi)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      if (bb)\n+\t{\n+\t  gimple stmt = last_stmt (bb);\n+\t  if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n+\t    group_case_labels_stmt (stmt);\n+\t}\n+    }\n+  BITMAP_FREE (touched_switch_bbs);\n }\n \n /* If we are inside a {start,end}_recording_cases block, then return\n@@ -1278,108 +1299,115 @@ cleanup_dead_labels (void)\n   free (label_for_bb);\n }\n \n-/* Look for blocks ending in a multiway branch (a SWITCH_EXPR in GIMPLE),\n-   and scan the sorted vector of cases.  Combine the ones jumping to the\n-   same label.\n+/* Scan the sorted vector of cases in STMT (a GIMPLE_SWITCH) and combine\n+   the ones jumping to the same label.\n    Eg. three separate entries 1: 2: 3: become one entry 1..3:  */\n \n-void\n-group_case_labels (void)\n+static void\n+group_case_labels_stmt (gimple stmt)\n {\n-  basic_block bb;\n+  int old_size = gimple_switch_num_labels (stmt);\n+  int i, j, new_size = old_size;\n+  tree default_case = NULL_TREE;\n+  tree default_label = NULL_TREE;\n+  bool has_default;\n \n-  FOR_EACH_BB (bb)\n+  /* The default label is always the first case in a switch\n+     statement after gimplification if it was not optimized\n+     away */\n+  if (!CASE_LOW (gimple_switch_default_label (stmt))\n+      && !CASE_HIGH (gimple_switch_default_label (stmt)))\n     {\n-      gimple stmt = last_stmt (bb);\n-      if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n+      default_case = gimple_switch_default_label (stmt);\n+      default_label = CASE_LABEL (default_case);\n+      has_default = true;\n+    }\n+  else\n+    has_default = false;\n+\n+  /* Look for possible opportunities to merge cases.  */\n+  if (has_default)\n+    i = 1;\n+  else\n+    i = 0;\n+  while (i < old_size)\n+    {\n+      tree base_case, base_label, base_high;\n+      base_case = gimple_switch_label (stmt, i);\n+\n+      gcc_assert (base_case);\n+      base_label = CASE_LABEL (base_case);\n+\n+      /* Discard cases that have the same destination as the\n+\t default case.  */\n+      if (base_label == default_label)\n \t{\n-\t  int old_size = gimple_switch_num_labels (stmt);\n-\t  int i, j, new_size = old_size;\n-\t  tree default_case = NULL_TREE;\n-\t  tree default_label = NULL_TREE;\n-\t  bool has_default;\n-\n-\t  /* The default label is always the first case in a switch\n-\t     statement after gimplification if it was not optimized\n-\t     away */\n-\t  if (!CASE_LOW (gimple_switch_default_label (stmt))\n-\t      && !CASE_HIGH (gimple_switch_default_label (stmt)))\n+\t  gimple_switch_set_label (stmt, i, NULL_TREE);\n+\t  i++;\n+\t  new_size--;\n+\t  continue;\n+\t}\n+\n+      base_high = CASE_HIGH (base_case)\n+\t  ? CASE_HIGH (base_case)\n+\t  : CASE_LOW (base_case);\n+      i++;\n+\n+      /* Try to merge case labels.  Break out when we reach the end\n+\t of the label vector or when we cannot merge the next case\n+\t label with the current one.  */\n+      while (i < old_size)\n+\t{\n+\t  tree merge_case = gimple_switch_label (stmt, i);\n+\t  tree merge_label = CASE_LABEL (merge_case);\n+\t  tree t = int_const_binop (PLUS_EXPR, base_high,\n+\t\t\t\t    integer_one_node, 1);\n+\n+\t  /* Merge the cases if they jump to the same place,\n+\t     and their ranges are consecutive.  */\n+\t  if (merge_label == base_label\n+\t      && tree_int_cst_equal (CASE_LOW (merge_case), t))\n \t    {\n-\t      default_case = gimple_switch_default_label (stmt);\n-\t      default_label = CASE_LABEL (default_case);\n-\t      has_default = true;\n+\t      base_high = CASE_HIGH (merge_case) ?\n+\t\t  CASE_HIGH (merge_case) : CASE_LOW (merge_case);\n+\t      CASE_HIGH (base_case) = base_high;\n+\t      gimple_switch_set_label (stmt, i, NULL_TREE);\n+\t      new_size--;\n+\t      i++;\n \t    }\n \t  else\n-\t    has_default = false;\n-\n-\t  /* Look for possible opportunities to merge cases.  */\n-\t  if (has_default)\n-\t    i = 1;\n-\t  else\n-\t    i = 0;\n-\t  while (i < old_size)\n-\t    {\n-\t      tree base_case, base_label, base_high;\n-\t      base_case = gimple_switch_label (stmt, i);\n-\n-\t      gcc_assert (base_case);\n-\t      base_label = CASE_LABEL (base_case);\n+\t    break;\n+\t}\n+    }\n \n-\t      /* Discard cases that have the same destination as the\n-\t\t default case.  */\n-\t      if (base_label == default_label)\n-\t\t{\n-\t\t  gimple_switch_set_label (stmt, i, NULL_TREE);\n-\t\t  i++;\n-\t\t  new_size--;\n-\t\t  continue;\n-\t\t}\n+  /* Compress the case labels in the label vector, and adjust the\n+     length of the vector.  */\n+  for (i = 0, j = 0; i < new_size; i++)\n+    {\n+      while (! gimple_switch_label (stmt, j))\n+\tj++;\n+      gimple_switch_set_label (stmt, i,\n+\t\t\t       gimple_switch_label (stmt, j++));\n+    }\n \n-\t      base_high = CASE_HIGH (base_case)\n-\t\t\t  ? CASE_HIGH (base_case)\n-\t\t\t  : CASE_LOW (base_case);\n-\t      i++;\n+  gcc_assert (new_size <= old_size);\n+  gimple_switch_set_num_labels (stmt, new_size);\n+}\n \n-\t      /* Try to merge case labels.  Break out when we reach the end\n-\t\t of the label vector or when we cannot merge the next case\n-\t\t label with the current one.  */\n-\t      while (i < old_size)\n-\t\t{\n-\t\t  tree merge_case = gimple_switch_label (stmt, i);\n-\t          tree merge_label = CASE_LABEL (merge_case);\n-\t\t  tree t = int_const_binop (PLUS_EXPR, base_high,\n-\t\t\t\t\t    integer_one_node, 1);\n-\n-\t\t  /* Merge the cases if they jump to the same place,\n-\t\t     and their ranges are consecutive.  */\n-\t\t  if (merge_label == base_label\n-\t\t      && tree_int_cst_equal (CASE_LOW (merge_case), t))\n-\t\t    {\n-\t\t      base_high = CASE_HIGH (merge_case) ?\n-\t\t\tCASE_HIGH (merge_case) : CASE_LOW (merge_case);\n-\t\t      CASE_HIGH (base_case) = base_high;\n-\t\t      gimple_switch_set_label (stmt, i, NULL_TREE);\n-\t\t      new_size--;\n-\t\t      i++;\n-\t\t    }\n-\t\t  else\n-\t\t    break;\n-\t\t}\n-\t    }\n+/* Look for blocks ending in a multiway branch (a GIMPLE_SWITCH),\n+   and scan the sorted vector of cases.  Combine the ones jumping to the\n+   same label.  */\n \n-\t  /* Compress the case labels in the label vector, and adjust the\n-\t     length of the vector.  */\n-\t  for (i = 0, j = 0; i < new_size; i++)\n-\t    {\n-\t      while (! gimple_switch_label (stmt, j))\n-\t\tj++;\n-\t      gimple_switch_set_label (stmt, i,\n-\t\t\t\t       gimple_switch_label (stmt, j++));\n-\t    }\n+void\n+group_case_labels (void)\n+{\n+  basic_block bb;\n \n-\t  gcc_assert (new_size <= old_size);\n-\t  gimple_switch_set_num_labels (stmt, new_size);\n-\t}\n+  FOR_EACH_BB (bb)\n+    {\n+      gimple stmt = last_stmt (bb);\n+      if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n+\tgroup_case_labels_stmt (stmt);\n     }\n }\n \n@@ -4689,6 +4717,7 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n \t\tTREE_CHAIN (last) = TREE_CHAIN (cases2);\n \t\tTREE_CHAIN (cases2) = first;\n \t      }\n+\t    bitmap_set_bit (touched_switch_bbs, gimple_bb (stmt)->index);\n \t  }\n \telse\n \t  {"}]}