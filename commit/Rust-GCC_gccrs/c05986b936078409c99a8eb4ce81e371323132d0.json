{"sha": "c05986b936078409c99a8eb4ce81e371323132d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA1OTg2YjkzNjA3ODQwOWM5OWE4ZWI0Y2U4MWUzNzEzMjMxMzJkMA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2016-10-21T15:32:25Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2016-10-21T15:32:25Z"}, "message": "Split <functional> into smaller pieces\n\n\t* include/Makefile.am: Add <bits/refwrap.h> and <bits/std_function.h>.\n\tOrder alphabetically.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/refwrap.h: New header.\n\t(_Maybe_get_result_type,_Weak_result_type_impl, _Weak_result_type)\n\t(_Reference_wrapper_base_impl, _Reference_wrapper_base)\n\t(reference_wrapper, ref, cref): Move here from <functional>.\n\t* include/bits/shared_ptr_base.h: Include <bits/refwrap.h> and\n\t<bits/stl_function.h> instead of <functional>.\n\t* include/bits/std_function.h: New header.\n\t(_Maybe_unary_or_binary_function, bad_function_call)\n\t(__is_location_invariant, _Nocopy_types, _Any_data)\n\t(_Simple_type_wrapper, _Function_base, _Function_handler, function):\n\tMove here from <functional>.\n\t* include/bits/unique_ptr.h: Include <bits/stl_function.h>.\n\t* include/std/functional: Include new headers and move components to\n\tthem.\n\t* include/std/future: Include <bits/std_function.h> instead of\n\t<functional>.\n\t* include/std/mutex: Likewise.\n\t* include/std/regex: Likewise.\n\t* src/c++11/compatibility-thread-c++0x.cc: Include <functional>.\n\t* testsuite/20_util/default_delete/48631_neg.cc: Adjust dg-error line.\n\t* testsuite/20_util/default_delete/void_neg.cc: Likewise.\n\t* testsuite/20_util/unique_ptr/assign/48635_neg.cc: Adjust dg-error\n\tlines.\n\t* testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc: Likewise.\n\t* testsuite/30_threads/packaged_task/49668.cc: Include <functional>.\n\nFrom-SVN: r241410", "tree": {"sha": "01c8b3f590f5e0d815a19879bd4dd02c5fbc3644", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01c8b3f590f5e0d815a19879bd4dd02c5fbc3644"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c05986b936078409c99a8eb4ce81e371323132d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05986b936078409c99a8eb4ce81e371323132d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c05986b936078409c99a8eb4ce81e371323132d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05986b936078409c99a8eb4ce81e371323132d0/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75a434a91b590ce1e733ffcb5a5810221f94571f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75a434a91b590ce1e733ffcb5a5810221f94571f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75a434a91b590ce1e733ffcb5a5810221f94571f"}], "stats": {"total": 2443, "additions": 1292, "deletions": 1151}, "files": [{"sha": "51e9653d5219e28eb7aebaa52991bd2694a448ce", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -1,5 +1,34 @@\n 2016-10-21  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/Makefile.am: Add <bits/refwrap.h> and <bits/std_function.h>.\n+\tOrder alphabetically.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/refwrap.h: New header.\n+\t(_Maybe_get_result_type,_Weak_result_type_impl, _Weak_result_type)\n+\t(_Reference_wrapper_base_impl, _Reference_wrapper_base)\n+\t(reference_wrapper, ref, cref): Move here from <functional>.\n+\t* include/bits/shared_ptr_base.h: Include <bits/refwrap.h> and\n+\t<bits/stl_function.h> instead of <functional>.\n+\t* include/bits/std_function.h: New header.\n+\t(_Maybe_unary_or_binary_function, bad_function_call)\n+\t(__is_location_invariant, _Nocopy_types, _Any_data)\n+\t(_Simple_type_wrapper, _Function_base, _Function_handler, function):\n+\tMove here from <functional>.\n+\t* include/bits/unique_ptr.h: Include <bits/stl_function.h>.\n+\t* include/std/functional: Include new headers and move components to\n+\tthem.\n+\t* include/std/future: Include <bits/std_function.h> instead of\n+\t<functional>.\n+\t* include/std/mutex: Likewise.\n+\t* include/std/regex: Likewise.\n+\t* src/c++11/compatibility-thread-c++0x.cc: Include <functional>.\n+\t* testsuite/20_util/default_delete/48631_neg.cc: Adjust dg-error line.\n+\t* testsuite/20_util/default_delete/void_neg.cc: Likewise.\n+\t* testsuite/20_util/unique_ptr/assign/48635_neg.cc: Adjust dg-error\n+\tlines.\n+\t* testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc: Likewise.\n+\t* testsuite/30_threads/packaged_task/49668.cc: Include <functional>.\n+\n \t* libsupc++/exception_ptr.h (make_exception_ptr): Qualify new.\n \t* testsuite/18_support/exception_ptr/make_exception_ptr_2.cc: New\n \ttest.\n@@ -3582,6 +3611,7 @@\n \t* include/std/future: Include <functional>.\n \t* include/std/memory: Do not include <functional>.\n \t* include/std/mutex: [_GLIBCXX_HAVE_TLS]: Likewise.\n+\t* src/c++11/compatibility-thread-c++0x.cc: Include <functional>.\n \t* testsuite/20_util/shared_ptr/thread/default_weaktoshared.cc: Add\n \tmissing includes.\n \t* testsuite/20_util/shared_ptr/thread/mutex_weaktoshared.cc: Likewise."}, {"sha": "15a164e49697709ac2b41d22d55013a50b9ecf0f", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -140,6 +140,7 @@ bits_headers = \\\n \t${bits_srcdir}/random.h \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n+\t${bits_srcdir}/refwrap.h \\\n \t${bits_srcdir}/regex.h \\\n \t${bits_srcdir}/regex.tcc \\\n \t${bits_srcdir}/regex_constants.h \\\n@@ -152,14 +153,13 @@ bits_headers = \\\n \t${bits_srcdir}/regex_compiler.tcc \\\n \t${bits_srcdir}/regex_executor.h \\\n \t${bits_srcdir}/regex_executor.tcc \\\n-\t${bits_srcdir}/stream_iterator.h \\\n-\t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/shared_ptr.h \\\n \t${bits_srcdir}/shared_ptr_atomic.h \\\n \t${bits_srcdir}/shared_ptr_base.h \\\n \t${bits_srcdir}/slice_array.h \\\n \t${bits_srcdir}/sstream.tcc \\\n \t${bits_srcdir}/std_abs.h \\\n+\t${bits_srcdir}/std_function.h \\\n \t${bits_srcdir}/std_mutex.h \\\n \t${bits_srcdir}/stl_algo.h \\\n \t${bits_srcdir}/stl_algobase.h \\\n@@ -186,6 +186,8 @@ bits_headers = \\\n \t${bits_srcdir}/stl_tree.h \\\n \t${bits_srcdir}/stl_uninitialized.h \\\n \t${bits_srcdir}/stl_vector.h \\\n+\t${bits_srcdir}/stream_iterator.h \\\n+\t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/streambuf.tcc \\\n \t${bits_srcdir}/stringfwd.h \\\n \t${bits_srcdir}/string_view.tcc \\"}, {"sha": "1a8e2b2908e0330b0e17865ea2b5de2a64a9db0e", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -431,6 +431,7 @@ bits_headers = \\\n \t${bits_srcdir}/random.h \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n+\t${bits_srcdir}/refwrap.h \\\n \t${bits_srcdir}/regex.h \\\n \t${bits_srcdir}/regex.tcc \\\n \t${bits_srcdir}/regex_constants.h \\\n@@ -443,14 +444,13 @@ bits_headers = \\\n \t${bits_srcdir}/regex_compiler.tcc \\\n \t${bits_srcdir}/regex_executor.h \\\n \t${bits_srcdir}/regex_executor.tcc \\\n-\t${bits_srcdir}/stream_iterator.h \\\n-\t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/shared_ptr.h \\\n \t${bits_srcdir}/shared_ptr_atomic.h \\\n \t${bits_srcdir}/shared_ptr_base.h \\\n \t${bits_srcdir}/slice_array.h \\\n \t${bits_srcdir}/sstream.tcc \\\n \t${bits_srcdir}/std_abs.h \\\n+\t${bits_srcdir}/std_function.h \\\n \t${bits_srcdir}/std_mutex.h \\\n \t${bits_srcdir}/stl_algo.h \\\n \t${bits_srcdir}/stl_algobase.h \\\n@@ -477,6 +477,8 @@ bits_headers = \\\n \t${bits_srcdir}/stl_tree.h \\\n \t${bits_srcdir}/stl_uninitialized.h \\\n \t${bits_srcdir}/stl_vector.h \\\n+\t${bits_srcdir}/stream_iterator.h \\\n+\t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/streambuf.tcc \\\n \t${bits_srcdir}/stringfwd.h \\\n \t${bits_srcdir}/string_view.tcc \\"}, {"sha": "06948ff8d5c71065c1456fee2997618415267551", "filename": "libstdc++-v3/include/bits/refwrap.h", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frefwrap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frefwrap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frefwrap.h?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -0,0 +1,383 @@\n+// Implementation of std::reference_wrapper -*- C++ -*-\n+\n+// Copyright (C) 2004-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/bits/bind.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{functional}\n+ */\n+\n+#ifndef _GLIBCXX_REFWRAP_H\n+#define _GLIBCXX_REFWRAP_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus < 201103L\n+# include <bits/c++0x_warning.h>\n+#else\n+\n+#include <bits/move.h>\n+#include <bits/invoke.h>\n+#include <bits/stl_function.h> // for unary_function and binary_function\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /// If we have found a result_type, extract it.\n+  template<typename _Functor, typename = __void_t<>>\n+    struct _Maybe_get_result_type\n+    { };\n+\n+  template<typename _Functor>\n+    struct _Maybe_get_result_type<_Functor,\n+\t\t\t\t  __void_t<typename _Functor::result_type>>\n+    { typedef typename _Functor::result_type result_type; };\n+\n+  /**\n+   *  Base class for any function object that has a weak result type, as\n+   *  defined in 20.8.2 [func.require] of C++11.\n+  */\n+  template<typename _Functor>\n+    struct _Weak_result_type_impl\n+    : _Maybe_get_result_type<_Functor>\n+    { };\n+\n+  /// Retrieve the result type for a function type.\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res(_ArgTypes...)>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res(_ArgTypes......)>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>\n+    { typedef _Res result_type; };\n+\n+  /// Retrieve the result type for a function reference.\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>\n+    { typedef _Res result_type; };\n+\n+  /// Retrieve the result type for a function pointer.\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>\n+    { typedef _Res result_type; };\n+\n+  /// Retrieve result type for a member function pointer.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>\n+    { typedef _Res result_type; };\n+\n+  /// Retrieve result type for a const member function pointer.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>\n+    { typedef _Res result_type; };\n+\n+  /// Retrieve result type for a volatile member function pointer.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>\n+    { typedef _Res result_type; };\n+\n+  /// Retrieve result type for a const volatile member function pointer.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)\n+\t\t\t\t  const volatile>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)\n+\t\t\t\t  const volatile>\n+    { typedef _Res result_type; };\n+\n+  /**\n+   *  Strip top-level cv-qualifiers from the function object and let\n+   *  _Weak_result_type_impl perform the real work.\n+  */\n+  template<typename _Functor>\n+    struct _Weak_result_type\n+    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>\n+    { };\n+\n+  // Detect nested argument_type.\n+  template<typename _Tp, typename = __void_t<>>\n+    struct _Refwrap_base_arg1\n+    { };\n+\n+  // Nested argument_type.\n+  template<typename _Tp>\n+    struct _Refwrap_base_arg1<_Tp,\n+\t\t\t      __void_t<typename _Tp::argument_type>>\n+    {\n+      typedef typename _Tp::argument_type argument_type;\n+    };\n+\n+  // Detect nested first_argument_type and second_argument_type.\n+  template<typename _Tp, typename = __void_t<>>\n+    struct _Refwrap_base_arg2\n+    { };\n+\n+  // Nested first_argument_type and second_argument_type.\n+  template<typename _Tp>\n+    struct _Refwrap_base_arg2<_Tp,\n+\t\t\t      __void_t<typename _Tp::first_argument_type,\n+\t\t\t\t       typename _Tp::second_argument_type>>\n+    {\n+      typedef typename _Tp::first_argument_type first_argument_type;\n+      typedef typename _Tp::second_argument_type second_argument_type;\n+    };\n+\n+  /**\n+   *  Derives from unary_function or binary_function when it\n+   *  can. Specializations handle all of the easy cases. The primary\n+   *  template determines what to do with a class type, which may\n+   *  derive from both unary_function and binary_function.\n+  */\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base\n+    : _Weak_result_type<_Tp>, _Refwrap_base_arg1<_Tp>, _Refwrap_base_arg2<_Tp>\n+    { };\n+\n+  // - a function type (unary)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(_T1)>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(_T1) const>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(_T1) volatile>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(_T1) const volatile>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  // - a function type (binary)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(_T1, _T2)>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(_T1, _T2) const>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  // - a function pointer type (unary)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(*)(_T1)>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  // - a function pointer type (binary)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, no qualifiers)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)()>\n+    : unary_function<_T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, no qualifiers)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>\n+    : binary_function<_T1*, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, const)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)() const>\n+    : unary_function<const _T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, const)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>\n+    : binary_function<const _T1*, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, volatile)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>\n+    : unary_function<volatile _T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, volatile)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>\n+    : binary_function<volatile _T1*, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, const volatile)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>\n+    : unary_function<const volatile _T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, const volatile)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>\n+    : binary_function<const volatile _T1*, _T2, _Res>\n+    { };\n+\n+  /**\n+   *  @brief Primary class template for reference_wrapper.\n+   *  @ingroup functors\n+   *  @{\n+   */\n+  template<typename _Tp>\n+    class reference_wrapper\n+    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>\n+    {\n+      _Tp* _M_data;\n+\n+    public:\n+      typedef _Tp type;\n+\n+      reference_wrapper(_Tp& __indata) noexcept\n+      : _M_data(std::__addressof(__indata))\n+      { }\n+\n+      reference_wrapper(_Tp&&) = delete;\n+\n+      reference_wrapper(const reference_wrapper&) = default;\n+\n+      reference_wrapper&\n+      operator=(const reference_wrapper&) = default;\n+\n+      operator _Tp&() const noexcept\n+      { return this->get(); }\n+\n+      _Tp&\n+      get() const noexcept\n+      { return *_M_data; }\n+\n+      template<typename... _Args>\n+\ttypename result_of<_Tp&(_Args&&...)>::type\n+\toperator()(_Args&&... __args) const\n+\t{\n+\t  return std::__invoke(get(), std::forward<_Args>(__args)...);\n+\t}\n+    };\n+\n+\n+  /// Denotes a reference should be taken to a variable.\n+  template<typename _Tp>\n+    inline reference_wrapper<_Tp>\n+    ref(_Tp& __t) noexcept\n+    { return reference_wrapper<_Tp>(__t); }\n+\n+  /// Denotes a const reference should be taken to a variable.\n+  template<typename _Tp>\n+    inline reference_wrapper<const _Tp>\n+    cref(const _Tp& __t) noexcept\n+    { return reference_wrapper<const _Tp>(__t); }\n+\n+  template<typename _Tp>\n+    void ref(const _Tp&&) = delete;\n+\n+  template<typename _Tp>\n+    void cref(const _Tp&&) = delete;\n+\n+  /// Partial specialization.\n+  template<typename _Tp>\n+    inline reference_wrapper<_Tp>\n+    ref(reference_wrapper<_Tp> __t) noexcept\n+    { return ref(__t.get()); }\n+\n+  /// Partial specialization.\n+  template<typename _Tp>\n+    inline reference_wrapper<const _Tp>\n+    cref(reference_wrapper<_Tp> __t) noexcept\n+    { return cref(__t.get()); }\n+\n+  // @} group functors\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++11\n+\n+#endif // _GLIBCXX_REFWRAP_H"}, {"sha": "1a9e3e901e97f3ceda6b5d3cbf0dbd688e4ae958", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -49,11 +49,12 @@\n #ifndef _SHARED_PTR_BASE_H\n #define _SHARED_PTR_BASE_H 1\n \n-#include <functional>\n #if __cpp_rtti\n # include <typeinfo>\n #endif\n #include <bits/allocated_ptr.h>\n+#include <bits/refwrap.h>\n+#include <bits/stl_function.h>\n #include <ext/aligned_buffer.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)"}, {"sha": "97399a16d70f0baaf4a861e2198334b1c548b92f", "filename": "libstdc++-v3/include/bits/std_function.h", "status": "added", "additions": 848, "deletions": 0, "changes": 848, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -0,0 +1,848 @@\n+// Implementation of std::function -*- C++ -*-\n+\n+// Copyright (C) 2004-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/bits/function.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{functional}\n+ */\n+\n+#ifndef _GLIBCXX_STD_FUNCTION_H\n+#define _GLIBCXX_STD_FUNCTION_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus < 201103L\n+# include <bits/c++0x_warning.h>\n+#else\n+\n+#if __cpp_rtti\n+# include <typeinfo>\n+#endif\n+#include <bits/stl_function.h>\n+#include <bits/invoke.h>\n+#include <bits/refwrap.h>\n+#include <bits/functexcept.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * Derives from @c unary_function or @c binary_function, or perhaps\n+   * nothing, depending on the number of arguments provided. The\n+   * primary template is the basis case, which derives nothing.\n+   */\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Maybe_unary_or_binary_function { };\n+\n+  /// Derives from @c unary_function, as appropriate.\n+  template<typename _Res, typename _T1>\n+    struct _Maybe_unary_or_binary_function<_Res, _T1>\n+    : std::unary_function<_T1, _Res> { };\n+\n+  /// Derives from @c binary_function, as appropriate.\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n+    : std::binary_function<_T1, _T2, _Res> { };\n+\n+\n+  /**\n+   *  @brief Exception class thrown when class template function's\n+   *  operator() is called with an empty target.\n+   *  @ingroup exceptions\n+   */\n+  class bad_function_call : public std::exception\n+  {\n+  public:\n+    virtual ~bad_function_call() noexcept;\n+\n+    const char* what() const noexcept;\n+  };\n+\n+  /**\n+   *  Trait identifying \"location-invariant\" types, meaning that the\n+   *  address of the object (or any of its members) will not escape.\n+   *  Trivially copyable types are location-invariant and users can\n+   *  specialize this trait for other types.\n+   */\n+  template<typename _Tp>\n+    struct __is_location_invariant\n+    : is_trivially_copyable<_Tp>::type\n+    { };\n+\n+  class _Undefined_class;\n+\n+  union _Nocopy_types\n+  {\n+    void*       _M_object;\n+    const void* _M_const_object;\n+    void (*_M_function_pointer)();\n+    void (_Undefined_class::*_M_member_pointer)();\n+  };\n+\n+  union [[gnu::may_alias]] _Any_data\n+  {\n+    void*       _M_access()       { return &_M_pod_data[0]; }\n+    const void* _M_access() const { return &_M_pod_data[0]; }\n+\n+    template<typename _Tp>\n+      _Tp&\n+      _M_access()\n+      { return *static_cast<_Tp*>(_M_access()); }\n+\n+    template<typename _Tp>\n+      const _Tp&\n+      _M_access() const\n+      { return *static_cast<const _Tp*>(_M_access()); }\n+\n+    _Nocopy_types _M_unused;\n+    char _M_pod_data[sizeof(_Nocopy_types)];\n+  };\n+\n+  enum _Manager_operation\n+  {\n+    __get_type_info,\n+    __get_functor_ptr,\n+    __clone_functor,\n+    __destroy_functor\n+  };\n+\n+  // Simple type wrapper that helps avoid annoying const problems\n+  // when casting between void pointers and pointers-to-pointers.\n+  template<typename _Tp>\n+    struct _Simple_type_wrapper\n+    {\n+      _Simple_type_wrapper(_Tp __value) : __value(__value) { }\n+\n+      _Tp __value;\n+    };\n+\n+  template<typename _Tp>\n+    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >\n+    : __is_location_invariant<_Tp>\n+    { };\n+\n+  template<typename _Signature>\n+    class function;\n+\n+  /// Base class of all polymorphic function object wrappers.\n+  class _Function_base\n+  {\n+  public:\n+    static const std::size_t _M_max_size = sizeof(_Nocopy_types);\n+    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);\n+\n+    template<typename _Functor>\n+      class _Base_manager\n+      {\n+      protected:\n+\tstatic const bool __stored_locally =\n+\t(__is_location_invariant<_Functor>::value\n+\t && sizeof(_Functor) <= _M_max_size\n+\t && __alignof__(_Functor) <= _M_max_align\n+\t && (_M_max_align % __alignof__(_Functor) == 0));\n+\n+\ttypedef integral_constant<bool, __stored_locally> _Local_storage;\n+\n+\t// Retrieve a pointer to the function object\n+\tstatic _Functor*\n+\t_M_get_pointer(const _Any_data& __source)\n+\t{\n+\t  const _Functor* __ptr =\n+\t    __stored_locally? std::__addressof(__source._M_access<_Functor>())\n+\t    /* have stored a pointer */ : __source._M_access<_Functor*>();\n+\t  return const_cast<_Functor*>(__ptr);\n+\t}\n+\n+\t// Clone a location-invariant function object that fits within\n+\t// an _Any_data structure.\n+\tstatic void\n+\t_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)\n+\t{\n+\t  ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());\n+\t}\n+\n+\t// Clone a function object that is not location-invariant or\n+\t// that cannot fit into an _Any_data structure.\n+\tstatic void\n+\t_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)\n+\t{\n+\t  __dest._M_access<_Functor*>() =\n+\t    new _Functor(*__source._M_access<_Functor*>());\n+\t}\n+\n+\t// Destroying a location-invariant object may still require\n+\t// destruction.\n+\tstatic void\n+\t_M_destroy(_Any_data& __victim, true_type)\n+\t{\n+\t  __victim._M_access<_Functor>().~_Functor();\n+\t}\n+\n+\t// Destroying an object located on the heap.\n+\tstatic void\n+\t_M_destroy(_Any_data& __victim, false_type)\n+\t{\n+\t  delete __victim._M_access<_Functor*>();\n+\t}\n+\n+      public:\n+\tstatic bool\n+\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n+\t\t   _Manager_operation __op)\n+\t{\n+\t  switch (__op)\n+\t    {\n+#if __cpp_rtti\n+\t    case __get_type_info:\n+\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t      break;\n+#endif\n+\t    case __get_functor_ptr:\n+\t      __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n+\t      break;\n+\n+\t    case __clone_functor:\n+\t      _M_clone(__dest, __source, _Local_storage());\n+\t      break;\n+\n+\t    case __destroy_functor:\n+\t      _M_destroy(__dest, _Local_storage());\n+\t      break;\n+\t    }\n+\t  return false;\n+\t}\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, _Functor&& __f)\n+\t{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }\n+\n+\ttemplate<typename _Signature>\n+\t  static bool\n+\t  _M_not_empty_function(const function<_Signature>& __f)\n+\t  { return static_cast<bool>(__f); }\n+\n+\ttemplate<typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(_Tp* __fp)\n+\t  { return __fp != nullptr; }\n+\n+\ttemplate<typename _Class, typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(_Tp _Class::* __mp)\n+\t  { return __mp != nullptr; }\n+\n+\ttemplate<typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(const _Tp&)\n+\t  { return true; }\n+\n+      private:\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)\n+\t{ ::new (__functor._M_access()) _Functor(std::move(__f)); }\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)\n+\t{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }\n+      };\n+\n+    template<typename _Functor>\n+      class _Ref_manager : public _Base_manager<_Functor*>\n+      {\n+\ttypedef _Function_base::_Base_manager<_Functor*> _Base;\n+\n+      public:\n+\tstatic bool\n+\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n+\t\t   _Manager_operation __op)\n+\t{\n+\t  switch (__op)\n+\t    {\n+#if __cpp_rtti\n+\t    case __get_type_info:\n+\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t      break;\n+#endif\n+\t    case __get_functor_ptr:\n+\t      __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);\n+\t      return is_const<_Functor>::value;\n+\t      break;\n+\n+\t    default:\n+\t      _Base::_M_manager(__dest, __source, __op);\n+\t    }\n+\t  return false;\n+\t}\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)\n+\t{\n+\t  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));\n+\t}\n+      };\n+\n+    _Function_base() : _M_manager(nullptr) { }\n+\n+    ~_Function_base()\n+    {\n+      if (_M_manager)\n+\t_M_manager(_M_functor, _M_functor, __destroy_functor);\n+    }\n+\n+\n+    bool _M_empty() const { return !_M_manager; }\n+\n+    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,\n+\t\t\t\t  _Manager_operation);\n+\n+    _Any_data     _M_functor;\n+    _Manager_type _M_manager;\n+  };\n+\n+  template<typename _Signature, typename _Functor>\n+    class _Function_handler;\n+\n+  template<typename _Res, typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), _Functor>\n+    : public _Function_base::_Base_manager<_Functor>\n+    {\n+      typedef _Function_base::_Base_manager<_Functor> _Base;\n+\n+    public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n+      {\n+\treturn (*_Base::_M_get_pointer(__functor))(\n+\t    std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), _Functor>\n+    : public _Function_base::_Base_manager<_Functor>\n+    {\n+      typedef _Function_base::_Base_manager<_Functor> _Base;\n+\n+     public:\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n+      {\n+\t(*_Base::_M_get_pointer(__functor))(\n+\t    std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+\n+  template<typename _Res, typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >\n+    : public _Function_base::_Ref_manager<_Functor>\n+    {\n+      typedef _Function_base::_Ref_manager<_Functor> _Base;\n+\n+     public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n+      {\n+\treturn std::__invoke(**_Base::_M_get_pointer(__functor),\n+\t\t\t     std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >\n+    : public _Function_base::_Ref_manager<_Functor>\n+    {\n+      typedef _Function_base::_Ref_manager<_Functor> _Base;\n+\n+     public:\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n+      {\n+\tstd::__invoke(**_Base::_M_get_pointer(__functor),\n+\t\t      std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+\n+  template<typename _Class, typename _Member, typename _Res,\n+\t   typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>\n+    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+    {\n+      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+\t_Base;\n+\n+     public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n+      {\n+\treturn std::__invoke(_Base::_M_get_pointer(__functor)->__value,\n+\t\t\t     std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+\n+  template<typename _Class, typename _Member, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+    : public _Function_base::_Base_manager<\n+\t\t _Simple_type_wrapper< _Member _Class::* > >\n+    {\n+      typedef _Member _Class::* _Functor;\n+      typedef _Simple_type_wrapper<_Functor> _Wrapper;\n+      typedef _Function_base::_Base_manager<_Wrapper> _Base;\n+\n+    public:\n+      static bool\n+      _M_manager(_Any_data& __dest, const _Any_data& __source,\n+\t\t _Manager_operation __op)\n+      {\n+\tswitch (__op)\n+\t  {\n+#if __cpp_rtti\n+\t  case __get_type_info:\n+\t    __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t    break;\n+#endif\n+\t  case __get_functor_ptr:\n+\t    __dest._M_access<_Functor*>() =\n+\t      &_Base::_M_get_pointer(__source)->__value;\n+\t    break;\n+\n+\t  default:\n+\t    _Base::_M_manager(__dest, __source, __op);\n+\t  }\n+\treturn false;\n+      }\n+\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n+      {\n+\tstd::__invoke(_Base::_M_get_pointer(__functor)->__value,\n+\t\t      std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+\n+  template<typename _From, typename _To>\n+    using __check_func_return_type\n+      = __or_<is_void<_To>, is_same<_From, _To>, is_convertible<_From, _To>>;\n+\n+  /**\n+   *  @brief Primary class template for std::function.\n+   *  @ingroup functors\n+   *\n+   *  Polymorphic function wrapper.\n+   */\n+  template<typename _Res, typename... _ArgTypes>\n+    class function<_Res(_ArgTypes...)>\n+    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,\n+      private _Function_base\n+    {\n+      typedef _Res _Signature_type(_ArgTypes...);\n+\n+      template<typename _Func,\n+\t       typename _Res2 = typename result_of<_Func&(_ArgTypes...)>::type>\n+\tstruct _Callable : __check_func_return_type<_Res2, _Res> { };\n+\n+      // Used so the return type convertibility checks aren't done when\n+      // performing overload resolution for copy construction/assignment.\n+      template<typename _Tp>\n+\tstruct _Callable<function, _Tp> : false_type { };\n+\n+      template<typename _Cond, typename _Tp>\n+\tusing _Requires = typename enable_if<_Cond::value, _Tp>::type;\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      // [3.7.2.1] construct/copy/destroy\n+\n+      /**\n+       *  @brief Default construct creates an empty function call wrapper.\n+       *  @post @c !(bool)*this\n+       */\n+      function() noexcept\n+      : _Function_base() { }\n+\n+      /**\n+       *  @brief Creates an empty function call wrapper.\n+       *  @post @c !(bool)*this\n+       */\n+      function(nullptr_t) noexcept\n+      : _Function_base() { }\n+\n+      /**\n+       *  @brief %Function copy constructor.\n+       *  @param __x A %function object with identical call signature.\n+       *  @post @c bool(*this) == bool(__x)\n+       *\n+       *  The newly-created %function contains a copy of the target of @a\n+       *  __x (if it has one).\n+       */\n+      function(const function& __x);\n+\n+      /**\n+       *  @brief %Function move constructor.\n+       *  @param __x A %function object rvalue with identical call signature.\n+       *\n+       *  The newly-created %function contains the target of @a __x\n+       *  (if it has one).\n+       */\n+      function(function&& __x) : _Function_base()\n+      {\n+\t__x.swap(*this);\n+      }\n+\n+      /**\n+       *  @brief Builds a %function that targets a copy of the incoming\n+       *  function object.\n+       *  @param __f A %function object that is callable with parameters of\n+       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+       *  to @c Res.\n+       *\n+       *  The newly-created %function object will target a copy of\n+       *  @a __f. If @a __f is @c reference_wrapper<F>, then this function\n+       *  object will contain a reference to the function object @c\n+       *  __f.get(). If @a __f is a NULL function pointer or NULL\n+       *  pointer-to-member, the newly-created object will be empty.\n+       *\n+       *  If @a __f is a non-NULL function pointer or an object of type @c\n+       *  reference_wrapper<F>, this function will not throw.\n+       */\n+      template<typename _Functor,\n+\t       typename = _Requires<__not_<is_same<_Functor, function>>, void>,\n+\t       typename = _Requires<_Callable<_Functor>, void>>\n+\tfunction(_Functor);\n+\n+      /**\n+       *  @brief %Function assignment operator.\n+       *  @param __x A %function with identical call signature.\n+       *  @post @c (bool)*this == (bool)x\n+       *  @returns @c *this\n+       *\n+       *  The target of @a __x is copied to @c *this. If @a __x has no\n+       *  target, then @c *this will be empty.\n+       *\n+       *  If @a __x targets a function pointer or a reference to a function\n+       *  object, then this operation will not throw an %exception.\n+       */\n+      function&\n+      operator=(const function& __x)\n+      {\n+\tfunction(__x).swap(*this);\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief %Function move-assignment operator.\n+       *  @param __x A %function rvalue with identical call signature.\n+       *  @returns @c *this\n+       *\n+       *  The target of @a __x is moved to @c *this. If @a __x has no\n+       *  target, then @c *this will be empty.\n+       *\n+       *  If @a __x targets a function pointer or a reference to a function\n+       *  object, then this operation will not throw an %exception.\n+       */\n+      function&\n+      operator=(function&& __x)\n+      {\n+\tfunction(std::move(__x)).swap(*this);\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief %Function assignment to zero.\n+       *  @post @c !(bool)*this\n+       *  @returns @c *this\n+       *\n+       *  The target of @c *this is deallocated, leaving it empty.\n+       */\n+      function&\n+      operator=(nullptr_t) noexcept\n+      {\n+\tif (_M_manager)\n+\t  {\n+\t    _M_manager(_M_functor, _M_functor, __destroy_functor);\n+\t    _M_manager = nullptr;\n+\t    _M_invoker = nullptr;\n+\t  }\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief %Function assignment to a new target.\n+       *  @param __f A %function object that is callable with parameters of\n+       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+       *  to @c Res.\n+       *  @return @c *this\n+       *\n+       *  This  %function object wrapper will target a copy of @a\n+       *  __f. If @a __f is @c reference_wrapper<F>, then this function\n+       *  object will contain a reference to the function object @c\n+       *  __f.get(). If @a __f is a NULL function pointer or NULL\n+       *  pointer-to-member, @c this object will be empty.\n+       *\n+       *  If @a __f is a non-NULL function pointer or an object of type @c\n+       *  reference_wrapper<F>, this function will not throw.\n+       */\n+      template<typename _Functor>\n+\t_Requires<_Callable<typename decay<_Functor>::type>, function&>\n+\toperator=(_Functor&& __f)\n+\t{\n+\t  function(std::forward<_Functor>(__f)).swap(*this);\n+\t  return *this;\n+\t}\n+\n+      /// @overload\n+      template<typename _Functor>\n+\tfunction&\n+\toperator=(reference_wrapper<_Functor> __f) noexcept\n+\t{\n+\t  function(__f).swap(*this);\n+\t  return *this;\n+\t}\n+\n+      // [3.7.2.2] function modifiers\n+\n+      /**\n+       *  @brief Swap the targets of two %function objects.\n+       *  @param __x A %function with identical call signature.\n+       *\n+       *  Swap the targets of @c this function object and @a __f. This\n+       *  function will not throw an %exception.\n+       */\n+      void swap(function& __x) noexcept\n+      {\n+\tstd::swap(_M_functor, __x._M_functor);\n+\tstd::swap(_M_manager, __x._M_manager);\n+\tstd::swap(_M_invoker, __x._M_invoker);\n+      }\n+\n+      // [3.7.2.3] function capacity\n+\n+      /**\n+       *  @brief Determine if the %function wrapper has a target.\n+       *\n+       *  @return @c true when this %function object contains a target,\n+       *  or @c false when it is empty.\n+       *\n+       *  This function will not throw an %exception.\n+       */\n+      explicit operator bool() const noexcept\n+      { return !_M_empty(); }\n+\n+      // [3.7.2.4] function invocation\n+\n+      /**\n+       *  @brief Invokes the function targeted by @c *this.\n+       *  @returns the result of the target.\n+       *  @throws bad_function_call when @c !(bool)*this\n+       *\n+       *  The function call operator invokes the target function object\n+       *  stored by @c this.\n+       */\n+      _Res operator()(_ArgTypes... __args) const;\n+\n+#if __cpp_rtti\n+      // [3.7.2.5] function target access\n+      /**\n+       *  @brief Determine the type of the target of this function object\n+       *  wrapper.\n+       *\n+       *  @returns the type identifier of the target function object, or\n+       *  @c typeid(void) if @c !(bool)*this.\n+       *\n+       *  This function will not throw an %exception.\n+       */\n+      const type_info& target_type() const noexcept;\n+\n+      /**\n+       *  @brief Access the stored target function object.\n+       *\n+       *  @return Returns a pointer to the stored target function object,\n+       *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n+       *  pointer.\n+       *\n+       * This function will not throw an %exception.\n+       */\n+      template<typename _Functor>       _Functor* target() noexcept;\n+\n+      /// @overload\n+      template<typename _Functor> const _Functor* target() const noexcept;\n+#endif\n+\n+    private:\n+      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);\n+      _Invoker_type _M_invoker;\n+  };\n+\n+  // Out-of-line member definitions.\n+  template<typename _Res, typename... _ArgTypes>\n+    function<_Res(_ArgTypes...)>::\n+    function(const function& __x)\n+    : _Function_base()\n+    {\n+      if (static_cast<bool>(__x))\n+\t{\n+\t  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n+\t  _M_invoker = __x._M_invoker;\n+\t  _M_manager = __x._M_manager;\n+\t}\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor, typename, typename>\n+      function<_Res(_ArgTypes...)>::\n+      function(_Functor __f)\n+      : _Function_base()\n+      {\n+\ttypedef _Function_handler<_Signature_type, _Functor> _My_handler;\n+\n+\tif (_My_handler::_M_not_empty_function(__f))\n+\t  {\n+\t    _My_handler::_M_init_functor(_M_functor, std::move(__f));\n+\t    _M_invoker = &_My_handler::_M_invoke;\n+\t    _M_manager = &_My_handler::_M_manager;\n+\t  }\n+      }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    _Res\n+    function<_Res(_ArgTypes...)>::\n+    operator()(_ArgTypes... __args) const\n+    {\n+      if (_M_empty())\n+\t__throw_bad_function_call();\n+      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);\n+    }\n+\n+#if __cpp_rtti\n+  template<typename _Res, typename... _ArgTypes>\n+    const type_info&\n+    function<_Res(_ArgTypes...)>::\n+    target_type() const noexcept\n+    {\n+      if (_M_manager)\n+\t{\n+\t  _Any_data __typeinfo_result;\n+\t  _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n+\t  return *__typeinfo_result._M_access<const type_info*>();\n+\t}\n+      else\n+\treturn typeid(void);\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor>\n+      _Functor*\n+      function<_Res(_ArgTypes...)>::\n+      target() noexcept\n+      {\n+\tif (typeid(_Functor) == target_type() && _M_manager)\n+\t  {\n+\t    _Any_data __ptr;\n+\t    if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n+\t\t&& !is_const<_Functor>::value)\n+\t      return 0;\n+\t    else\n+\t      return __ptr._M_access<_Functor*>();\n+\t  }\n+\telse\n+\t  return 0;\n+      }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor>\n+      const _Functor*\n+      function<_Res(_ArgTypes...)>::\n+      target() const noexcept\n+      {\n+\tif (typeid(_Functor) == target_type() && _M_manager)\n+\t  {\n+\t    _Any_data __ptr;\n+\t    _M_manager(__ptr, _M_functor, __get_functor_ptr);\n+\t    return __ptr._M_access<const _Functor*>();\n+\t  }\n+\telse\n+\t  return 0;\n+      }\n+#endif\n+\n+  // [20.7.15.2.6] null pointer comparisons\n+\n+  /**\n+   *  @brief Compares a polymorphic function object wrapper against 0\n+   *  (the NULL pointer).\n+   *  @returns @c true if the wrapper has no target, @c false otherwise\n+   *\n+   *  This function will not throw an %exception.\n+   */\n+  template<typename _Res, typename... _Args>\n+    inline bool\n+    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept\n+    { return !static_cast<bool>(__f); }\n+\n+  /// @overload\n+  template<typename _Res, typename... _Args>\n+    inline bool\n+    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept\n+    { return !static_cast<bool>(__f); }\n+\n+  /**\n+   *  @brief Compares a polymorphic function object wrapper against 0\n+   *  (the NULL pointer).\n+   *  @returns @c false if the wrapper has no target, @c true otherwise\n+   *\n+   *  This function will not throw an %exception.\n+   */\n+  template<typename _Res, typename... _Args>\n+    inline bool\n+    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept\n+    { return static_cast<bool>(__f); }\n+\n+  /// @overload\n+  template<typename _Res, typename... _Args>\n+    inline bool\n+    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept\n+    { return static_cast<bool>(__f); }\n+\n+\n+  // [20.7.15.2.7] specialized algorithms\n+\n+  /**\n+   *  @brief Swap the targets of two polymorphic function object wrappers.\n+   *\n+   *  This function will not throw an %exception.\n+   */\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 2062. Effect contradictions w/o no-throw guarantee of std::function swaps\n+  template<typename _Res, typename... _Args>\n+    inline void\n+    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y) noexcept\n+    { __x.swap(__y); }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++11\n+\n+#endif // _GLIBCXX_STD_FUNCTION_H"}, {"sha": "996c9eac3c3d5de15e0d03225a55cabb29256ea1", "filename": "libstdc++-v3/include/bits/unique_ptr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -35,6 +35,7 @@\n #include <type_traits>\n #include <utility>\n #include <tuple>\n+#include <bits/stl_function.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {"}, {"sha": "24854c003abf8f4749a42ac0b9a8c6707ea326f5", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 10, "deletions": 1138, "changes": 1148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -50,149 +50,24 @@\n \n #if __cplusplus >= 201103L\n \n-#include <typeinfo>\n #include <new>\n #include <tuple>\n #include <type_traits>\n-#include <bits/functexcept.h>\n #include <bits/functional_hash.h>\n #include <bits/invoke.h>\n-\n+#include <bits/std_function.h>\n #if __cplusplus > 201402L\n-#include <unordered_map>\n-#include <vector>\n-#include <array>\n-#include <utility>\n-#include <bits/stl_algo.h>\n+# include <unordered_map>\n+# include <vector>\n+# include <array>\n+# include <utility>\n+# include <bits/stl_algo.h>\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  template<typename _MemberPointer>\n-    class _Mem_fn;\n-  template<typename _Tp, typename _Class>\n-    _Mem_fn<_Tp _Class::*>\n-    mem_fn(_Tp _Class::*) noexcept;\n-\n-  /// If we have found a result_type, extract it.\n-  template<typename _Functor, typename = __void_t<>>\n-    struct _Maybe_get_result_type\n-    { };\n-\n-  template<typename _Functor>\n-    struct _Maybe_get_result_type<_Functor,\n-\t\t\t\t  __void_t<typename _Functor::result_type>>\n-    { typedef typename _Functor::result_type result_type; };\n-\n-  /**\n-   *  Base class for any function object that has a weak result type, as\n-   *  defined in 20.8.2 [func.require] of C++11.\n-  */\n-  template<typename _Functor>\n-    struct _Weak_result_type_impl\n-    : _Maybe_get_result_type<_Functor>\n-    { };\n-\n-  /// Retrieve the result type for a function type.\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes...)>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes......)>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>\n-    { typedef _Res result_type; };\n-\n-  /// Retrieve the result type for a function reference.\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>\n-    { typedef _Res result_type; };\n-\n-  /// Retrieve the result type for a function pointer.\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>\n-    { typedef _Res result_type; };\n-\n-  /// Retrieve result type for a member function pointer.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>\n-    { typedef _Res result_type; };\n-\n-  /// Retrieve result type for a const member function pointer.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>\n-    { typedef _Res result_type; };\n-\n-  /// Retrieve result type for a volatile member function pointer.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>\n-    { typedef _Res result_type; };\n-\n-  /// Retrieve result type for a const volatile member function pointer.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)\n-\t\t\t\t  const volatile>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)\n-\t\t\t\t  const volatile>\n-    { typedef _Res result_type; };\n-\n-  /**\n-   *  Strip top-level cv-qualifiers from the function object and let\n-   *  _Weak_result_type_impl perform the real work.\n-  */\n-  template<typename _Functor>\n-    struct _Weak_result_type\n-    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>\n-    { };\n-\n #if __cplusplus > 201402L\n # define __cpp_lib_invoke 201411\n \n@@ -207,220 +82,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n #endif\n \n-  // Detect nested argument_type.\n-  template<typename _Tp, typename = __void_t<>>\n-    struct _Refwrap_base_arg1\n-    { };\n-\n-  // Nested argument_type.\n-  template<typename _Tp>\n-    struct _Refwrap_base_arg1<_Tp,\n-\t\t\t      __void_t<typename _Tp::argument_type>>\n-    {\n-      typedef typename _Tp::argument_type argument_type;\n-    };\n-\n-  // Detect nested first_argument_type and second_argument_type.\n-  template<typename _Tp, typename = __void_t<>>\n-    struct _Refwrap_base_arg2\n-    { };\n-\n-  // Nested first_argument_type and second_argument_type.\n-  template<typename _Tp>\n-    struct _Refwrap_base_arg2<_Tp,\n-\t\t\t      __void_t<typename _Tp::first_argument_type,\n-\t\t\t\t       typename _Tp::second_argument_type>>\n-    {\n-      typedef typename _Tp::first_argument_type first_argument_type;\n-      typedef typename _Tp::second_argument_type second_argument_type;\n-    };\n-\n-  /**\n-   *  Derives from unary_function or binary_function when it\n-   *  can. Specializations handle all of the easy cases. The primary\n-   *  template determines what to do with a class type, which may\n-   *  derive from both unary_function and binary_function.\n-  */\n-  template<typename _Tp>\n-    struct _Reference_wrapper_base\n-    : _Weak_result_type<_Tp>, _Refwrap_base_arg1<_Tp>, _Refwrap_base_arg2<_Tp>\n-    { };\n-\n-  // - a function type (unary)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res(_T1)>\n-    : unary_function<_T1, _Res>\n-    { };\n-\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res(_T1) const>\n-    : unary_function<_T1, _Res>\n-    { };\n-\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res(_T1) volatile>\n-    : unary_function<_T1, _Res>\n-    { };\n-\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res(_T1) const volatile>\n-    : unary_function<_T1, _Res>\n-    { };\n-\n-  // - a function type (binary)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res(_T1, _T2)>\n-    : binary_function<_T1, _T2, _Res>\n-    { };\n-\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res(_T1, _T2) const>\n-    : binary_function<_T1, _T2, _Res>\n-    { };\n-\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>\n-    : binary_function<_T1, _T2, _Res>\n-    { };\n-\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>\n-    : binary_function<_T1, _T2, _Res>\n-    { };\n-\n-  // - a function pointer type (unary)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res(*)(_T1)>\n-    : unary_function<_T1, _Res>\n-    { };\n-\n-  // - a function pointer type (binary)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>\n-    : binary_function<_T1, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, no qualifiers)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)()>\n-    : unary_function<_T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, no qualifiers)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>\n-    : binary_function<_T1*, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, const)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)() const>\n-    : unary_function<const _T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, const)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>\n-    : binary_function<const _T1*, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, volatile)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>\n-    : unary_function<volatile _T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, volatile)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>\n-    : binary_function<volatile _T1*, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, const volatile)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>\n-    : unary_function<const volatile _T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, const volatile)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>\n-    : binary_function<const volatile _T1*, _T2, _Res>\n-    { };\n-\n-  /**\n-   *  @brief Primary class template for reference_wrapper.\n-   *  @ingroup functors\n-   *  @{\n-   */\n-  template<typename _Tp>\n-    class reference_wrapper\n-    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>\n-    {\n-      _Tp* _M_data;\n-\n-    public:\n-      typedef _Tp type;\n-\n-      reference_wrapper(_Tp& __indata) noexcept\n-      : _M_data(std::__addressof(__indata))\n-      { }\n-\n-      reference_wrapper(_Tp&&) = delete;\n-\n-      reference_wrapper(const reference_wrapper&) = default;\n-\n-      reference_wrapper&\n-      operator=(const reference_wrapper&) = default;\n-\n-      operator _Tp&() const noexcept\n-      { return this->get(); }\n-\n-      _Tp&\n-      get() const noexcept\n-      { return *_M_data; }\n-\n-      template<typename... _Args>\n-\ttypename result_of<_Tp&(_Args&&...)>::type\n-\toperator()(_Args&&... __args) const\n-\t{\n-\t  return std::__invoke(get(), std::forward<_Args>(__args)...);\n-\t}\n-    };\n-\n-\n-  /// Denotes a reference should be taken to a variable.\n-  template<typename _Tp>\n-    inline reference_wrapper<_Tp>\n-    ref(_Tp& __t) noexcept\n-    { return reference_wrapper<_Tp>(__t); }\n-\n-  /// Denotes a const reference should be taken to a variable.\n-  template<typename _Tp>\n-    inline reference_wrapper<const _Tp>\n-    cref(const _Tp& __t) noexcept\n-    { return reference_wrapper<const _Tp>(__t); }\n-\n-  template<typename _Tp>\n-    void ref(const _Tp&&) = delete;\n-\n-  template<typename _Tp>\n-    void cref(const _Tp&&) = delete;\n-\n-  /// Partial specialization.\n-  template<typename _Tp>\n-    inline reference_wrapper<_Tp>\n-    ref(reference_wrapper<_Tp> __t) noexcept\n-    { return ref(__t.get()); }\n-\n-  /// Partial specialization.\n-  template<typename _Tp>\n-    inline reference_wrapper<const _Tp>\n-    cref(reference_wrapper<_Tp> __t) noexcept\n-    { return cref(__t.get()); }\n-\n-  // @} group functors\n-\n   template<typename... _Types>\n     struct _Pack : integral_constant<size_t, sizeof...(_Types)>\n     { };\n@@ -438,24 +99,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,\n \t\t\t\t    typename std::decay<_Tp2>::type>>;\n \n-  /**\n-   * Derives from @c unary_function or @c binary_function, or perhaps\n-   * nothing, depending on the number of arguments provided. The\n-   * primary template is the basis case, which derives nothing.\n-   */\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Maybe_unary_or_binary_function { };\n-\n-  /// Derives from @c unary_function, as appropriate.\n-  template<typename _Res, typename _T1>\n-    struct _Maybe_unary_or_binary_function<_Res, _T1>\n-    : std::unary_function<_T1, _Res> { };\n-\n-  /// Derives from @c binary_function, as appropriate.\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n-    : std::binary_function<_T1, _T2, _Res> { };\n-\n   template<typename _Signature>\n     struct _Mem_fn_traits;\n \n@@ -550,6 +193,9 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n \t{ return std::__invoke(_M_pm, std::forward<_Tp>(__obj)); }\n     };\n \n+  template<typename _MemberPointer>\n+    struct _Mem_fn; // undefined\n+\n   template<typename _Res, typename _Class>\n     struct _Mem_fn<_Res _Class::*>\n     : _Mem_fn_base<_Res _Class::*>\n@@ -1251,778 +897,6 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n \t\t\t\t\t  std::forward<_BoundArgs>(__args)...);\n     }\n \n-  /**\n-   *  @brief Exception class thrown when class template function's\n-   *  operator() is called with an empty target.\n-   *  @ingroup exceptions\n-   */\n-  class bad_function_call : public std::exception\n-  {\n-  public:\n-    virtual ~bad_function_call() noexcept;\n-\n-    const char* what() const noexcept;\n-  };\n-\n-  /**\n-   *  Trait identifying \"location-invariant\" types, meaning that the\n-   *  address of the object (or any of its members) will not escape.\n-   *  Trivially copyable types are location-invariant and users can\n-   *  specialize this trait for other types.\n-   */\n-  template<typename _Tp>\n-    struct __is_location_invariant\n-    : is_trivially_copyable<_Tp>::type\n-    { };\n-\n-  class _Undefined_class;\n-\n-  union _Nocopy_types\n-  {\n-    void*       _M_object;\n-    const void* _M_const_object;\n-    void (*_M_function_pointer)();\n-    void (_Undefined_class::*_M_member_pointer)();\n-  };\n-\n-  union [[gnu::may_alias]] _Any_data\n-  {\n-    void*       _M_access()       { return &_M_pod_data[0]; }\n-    const void* _M_access() const { return &_M_pod_data[0]; }\n-\n-    template<typename _Tp>\n-      _Tp&\n-      _M_access()\n-      { return *static_cast<_Tp*>(_M_access()); }\n-\n-    template<typename _Tp>\n-      const _Tp&\n-      _M_access() const\n-      { return *static_cast<const _Tp*>(_M_access()); }\n-\n-    _Nocopy_types _M_unused;\n-    char _M_pod_data[sizeof(_Nocopy_types)];\n-  };\n-\n-  enum _Manager_operation\n-  {\n-    __get_type_info,\n-    __get_functor_ptr,\n-    __clone_functor,\n-    __destroy_functor\n-  };\n-\n-  // Simple type wrapper that helps avoid annoying const problems\n-  // when casting between void pointers and pointers-to-pointers.\n-  template<typename _Tp>\n-    struct _Simple_type_wrapper\n-    {\n-      _Simple_type_wrapper(_Tp __value) : __value(__value) { }\n-\n-      _Tp __value;\n-    };\n-\n-  template<typename _Tp>\n-    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >\n-    : __is_location_invariant<_Tp>\n-    { };\n-\n-  template<typename _Signature>\n-    class function;\n-\n-  /// Base class of all polymorphic function object wrappers.\n-  class _Function_base\n-  {\n-  public:\n-    static const std::size_t _M_max_size = sizeof(_Nocopy_types);\n-    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);\n-\n-    template<typename _Functor>\n-      class _Base_manager\n-      {\n-      protected:\n-\tstatic const bool __stored_locally =\n-\t(__is_location_invariant<_Functor>::value\n-\t && sizeof(_Functor) <= _M_max_size\n-\t && __alignof__(_Functor) <= _M_max_align\n-\t && (_M_max_align % __alignof__(_Functor) == 0));\n-\n-\ttypedef integral_constant<bool, __stored_locally> _Local_storage;\n-\n-\t// Retrieve a pointer to the function object\n-\tstatic _Functor*\n-\t_M_get_pointer(const _Any_data& __source)\n-\t{\n-\t  const _Functor* __ptr =\n-\t    __stored_locally? std::__addressof(__source._M_access<_Functor>())\n-\t    /* have stored a pointer */ : __source._M_access<_Functor*>();\n-\t  return const_cast<_Functor*>(__ptr);\n-\t}\n-\n-\t// Clone a location-invariant function object that fits within\n-\t// an _Any_data structure.\n-\tstatic void\n-\t_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)\n-\t{\n-\t  ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());\n-\t}\n-\n-\t// Clone a function object that is not location-invariant or\n-\t// that cannot fit into an _Any_data structure.\n-\tstatic void\n-\t_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)\n-\t{\n-\t  __dest._M_access<_Functor*>() =\n-\t    new _Functor(*__source._M_access<_Functor*>());\n-\t}\n-\n-\t// Destroying a location-invariant object may still require\n-\t// destruction.\n-\tstatic void\n-\t_M_destroy(_Any_data& __victim, true_type)\n-\t{\n-\t  __victim._M_access<_Functor>().~_Functor();\n-\t}\n-\n-\t// Destroying an object located on the heap.\n-\tstatic void\n-\t_M_destroy(_Any_data& __victim, false_type)\n-\t{\n-\t  delete __victim._M_access<_Functor*>();\n-\t}\n-\n-      public:\n-\tstatic bool\n-\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n-\t\t   _Manager_operation __op)\n-\t{\n-\t  switch (__op)\n-\t    {\n-#if __cpp_rtti\n-\t    case __get_type_info:\n-\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n-\t      break;\n-#endif\n-\t    case __get_functor_ptr:\n-\t      __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n-\t      break;\n-\n-\t    case __clone_functor:\n-\t      _M_clone(__dest, __source, _Local_storage());\n-\t      break;\n-\n-\t    case __destroy_functor:\n-\t      _M_destroy(__dest, _Local_storage());\n-\t      break;\n-\t    }\n-\t  return false;\n-\t}\n-\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, _Functor&& __f)\n-\t{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }\n-\n-\ttemplate<typename _Signature>\n-\t  static bool\n-\t  _M_not_empty_function(const function<_Signature>& __f)\n-\t  { return static_cast<bool>(__f); }\n-\n-\ttemplate<typename _Tp>\n-\t  static bool\n-\t  _M_not_empty_function(_Tp* __fp)\n-\t  { return __fp != nullptr; }\n-\n-\ttemplate<typename _Class, typename _Tp>\n-\t  static bool\n-\t  _M_not_empty_function(_Tp _Class::* __mp)\n-\t  { return __mp != nullptr; }\n-\n-\ttemplate<typename _Tp>\n-\t  static bool\n-\t  _M_not_empty_function(const _Tp&)\n-\t  { return true; }\n-\n-      private:\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)\n-\t{ ::new (__functor._M_access()) _Functor(std::move(__f)); }\n-\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)\n-\t{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }\n-      };\n-\n-    template<typename _Functor>\n-      class _Ref_manager : public _Base_manager<_Functor*>\n-      {\n-\ttypedef _Function_base::_Base_manager<_Functor*> _Base;\n-\n-      public:\n-\tstatic bool\n-\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n-\t\t   _Manager_operation __op)\n-\t{\n-\t  switch (__op)\n-\t    {\n-#if __cpp_rtti\n-\t    case __get_type_info:\n-\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n-\t      break;\n-#endif\n-\t    case __get_functor_ptr:\n-\t      __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);\n-\t      return is_const<_Functor>::value;\n-\t      break;\n-\n-\t    default:\n-\t      _Base::_M_manager(__dest, __source, __op);\n-\t    }\n-\t  return false;\n-\t}\n-\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)\n-\t{\n-\t  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));\n-\t}\n-      };\n-\n-    _Function_base() : _M_manager(nullptr) { }\n-\n-    ~_Function_base()\n-    {\n-      if (_M_manager)\n-\t_M_manager(_M_functor, _M_functor, __destroy_functor);\n-    }\n-\n-\n-    bool _M_empty() const { return !_M_manager; }\n-\n-    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,\n-\t\t\t\t  _Manager_operation);\n-\n-    _Any_data     _M_functor;\n-    _Manager_type _M_manager;\n-  };\n-\n-  template<typename _Signature, typename _Functor>\n-    class _Function_handler;\n-\n-  template<typename _Res, typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<_Res(_ArgTypes...), _Functor>\n-    : public _Function_base::_Base_manager<_Functor>\n-    {\n-      typedef _Function_base::_Base_manager<_Functor> _Base;\n-\n-    public:\n-      static _Res\n-      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n-      {\n-\treturn (*_Base::_M_get_pointer(__functor))(\n-\t    std::forward<_ArgTypes>(__args)...);\n-      }\n-    };\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<void(_ArgTypes...), _Functor>\n-    : public _Function_base::_Base_manager<_Functor>\n-    {\n-      typedef _Function_base::_Base_manager<_Functor> _Base;\n-\n-     public:\n-      static void\n-      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n-      {\n-\t(*_Base::_M_get_pointer(__functor))(\n-\t    std::forward<_ArgTypes>(__args)...);\n-      }\n-    };\n-\n-  template<typename _Res, typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >\n-    : public _Function_base::_Ref_manager<_Functor>\n-    {\n-      typedef _Function_base::_Ref_manager<_Functor> _Base;\n-\n-     public:\n-      static _Res\n-      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n-      {\n-\treturn std::__invoke(**_Base::_M_get_pointer(__functor),\n-\t\t\t     std::forward<_ArgTypes>(__args)...);\n-      }\n-    };\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >\n-    : public _Function_base::_Ref_manager<_Functor>\n-    {\n-      typedef _Function_base::_Ref_manager<_Functor> _Base;\n-\n-     public:\n-      static void\n-      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n-      {\n-\tstd::__invoke(**_Base::_M_get_pointer(__functor),\n-\t\t      std::forward<_ArgTypes>(__args)...);\n-      }\n-    };\n-\n-  template<typename _Class, typename _Member, typename _Res,\n-\t   typename... _ArgTypes>\n-    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>\n-    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>\n-    {\n-      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>\n-\t_Base;\n-\n-     public:\n-      static _Res\n-      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n-      {\n-\treturn std::__invoke(_Base::_M_get_pointer(__functor)->__value,\n-\t\t\t     std::forward<_ArgTypes>(__args)...);\n-      }\n-    };\n-\n-  template<typename _Class, typename _Member, typename... _ArgTypes>\n-    class _Function_handler<void(_ArgTypes...), _Member _Class::*>\n-    : public _Function_base::_Base_manager<\n-\t\t _Simple_type_wrapper< _Member _Class::* > >\n-    {\n-      typedef _Member _Class::* _Functor;\n-      typedef _Simple_type_wrapper<_Functor> _Wrapper;\n-      typedef _Function_base::_Base_manager<_Wrapper> _Base;\n-\n-    public:\n-      static bool\n-      _M_manager(_Any_data& __dest, const _Any_data& __source,\n-\t\t _Manager_operation __op)\n-      {\n-\tswitch (__op)\n-\t  {\n-#if __cpp_rtti\n-\t  case __get_type_info:\n-\t    __dest._M_access<const type_info*>() = &typeid(_Functor);\n-\t    break;\n-#endif\n-\t  case __get_functor_ptr:\n-\t    __dest._M_access<_Functor*>() =\n-\t      &_Base::_M_get_pointer(__source)->__value;\n-\t    break;\n-\n-\t  default:\n-\t    _Base::_M_manager(__dest, __source, __op);\n-\t  }\n-\treturn false;\n-      }\n-\n-      static void\n-      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n-      {\n-\tstd::__invoke(_Base::_M_get_pointer(__functor)->__value,\n-\t\t      std::forward<_ArgTypes>(__args)...);\n-      }\n-    };\n-\n-  template<typename _From, typename _To>\n-    using __check_func_return_type\n-      = __or_<is_void<_To>, is_same<_From, _To>, is_convertible<_From, _To>>;\n-\n-  /**\n-   *  @brief Primary class template for std::function.\n-   *  @ingroup functors\n-   *\n-   *  Polymorphic function wrapper.\n-   */\n-  template<typename _Res, typename... _ArgTypes>\n-    class function<_Res(_ArgTypes...)>\n-    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,\n-      private _Function_base\n-    {\n-      typedef _Res _Signature_type(_ArgTypes...);\n-\n-      template<typename _Func,\n-\t       typename _Res2 = typename result_of<_Func&(_ArgTypes...)>::type>\n-\tstruct _Callable : __check_func_return_type<_Res2, _Res> { };\n-\n-      // Used so the return type convertibility checks aren't done when\n-      // performing overload resolution for copy construction/assignment.\n-      template<typename _Tp>\n-\tstruct _Callable<function, _Tp> : false_type { };\n-\n-      template<typename _Cond, typename _Tp>\n-\tusing _Requires = typename enable_if<_Cond::value, _Tp>::type;\n-\n-    public:\n-      typedef _Res result_type;\n-\n-      // [3.7.2.1] construct/copy/destroy\n-\n-      /**\n-       *  @brief Default construct creates an empty function call wrapper.\n-       *  @post @c !(bool)*this\n-       */\n-      function() noexcept\n-      : _Function_base() { }\n-\n-      /**\n-       *  @brief Creates an empty function call wrapper.\n-       *  @post @c !(bool)*this\n-       */\n-      function(nullptr_t) noexcept\n-      : _Function_base() { }\n-\n-      /**\n-       *  @brief %Function copy constructor.\n-       *  @param __x A %function object with identical call signature.\n-       *  @post @c bool(*this) == bool(__x)\n-       *\n-       *  The newly-created %function contains a copy of the target of @a\n-       *  __x (if it has one).\n-       */\n-      function(const function& __x);\n-\n-      /**\n-       *  @brief %Function move constructor.\n-       *  @param __x A %function object rvalue with identical call signature.\n-       *\n-       *  The newly-created %function contains the target of @a __x\n-       *  (if it has one).\n-       */\n-      function(function&& __x) : _Function_base()\n-      {\n-\t__x.swap(*this);\n-      }\n-\n-      /**\n-       *  @brief Builds a %function that targets a copy of the incoming\n-       *  function object.\n-       *  @param __f A %function object that is callable with parameters of\n-       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n-       *  to @c Res.\n-       *\n-       *  The newly-created %function object will target a copy of\n-       *  @a __f. If @a __f is @c reference_wrapper<F>, then this function\n-       *  object will contain a reference to the function object @c\n-       *  __f.get(). If @a __f is a NULL function pointer or NULL\n-       *  pointer-to-member, the newly-created object will be empty.\n-       *\n-       *  If @a __f is a non-NULL function pointer or an object of type @c\n-       *  reference_wrapper<F>, this function will not throw.\n-       */\n-      template<typename _Functor,\n-\t       typename = _Requires<__not_<is_same<_Functor, function>>, void>,\n-\t       typename = _Requires<_Callable<_Functor>, void>>\n-\tfunction(_Functor);\n-\n-      /**\n-       *  @brief %Function assignment operator.\n-       *  @param __x A %function with identical call signature.\n-       *  @post @c (bool)*this == (bool)x\n-       *  @returns @c *this\n-       *\n-       *  The target of @a __x is copied to @c *this. If @a __x has no\n-       *  target, then @c *this will be empty.\n-       *\n-       *  If @a __x targets a function pointer or a reference to a function\n-       *  object, then this operation will not throw an %exception.\n-       */\n-      function&\n-      operator=(const function& __x)\n-      {\n-\tfunction(__x).swap(*this);\n-\treturn *this;\n-      }\n-\n-      /**\n-       *  @brief %Function move-assignment operator.\n-       *  @param __x A %function rvalue with identical call signature.\n-       *  @returns @c *this\n-       *\n-       *  The target of @a __x is moved to @c *this. If @a __x has no\n-       *  target, then @c *this will be empty.\n-       *\n-       *  If @a __x targets a function pointer or a reference to a function\n-       *  object, then this operation will not throw an %exception.\n-       */\n-      function&\n-      operator=(function&& __x)\n-      {\n-\tfunction(std::move(__x)).swap(*this);\n-\treturn *this;\n-      }\n-\n-      /**\n-       *  @brief %Function assignment to zero.\n-       *  @post @c !(bool)*this\n-       *  @returns @c *this\n-       *\n-       *  The target of @c *this is deallocated, leaving it empty.\n-       */\n-      function&\n-      operator=(nullptr_t) noexcept\n-      {\n-\tif (_M_manager)\n-\t  {\n-\t    _M_manager(_M_functor, _M_functor, __destroy_functor);\n-\t    _M_manager = nullptr;\n-\t    _M_invoker = nullptr;\n-\t  }\n-\treturn *this;\n-      }\n-\n-      /**\n-       *  @brief %Function assignment to a new target.\n-       *  @param __f A %function object that is callable with parameters of\n-       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n-       *  to @c Res.\n-       *  @return @c *this\n-       *\n-       *  This  %function object wrapper will target a copy of @a\n-       *  __f. If @a __f is @c reference_wrapper<F>, then this function\n-       *  object will contain a reference to the function object @c\n-       *  __f.get(). If @a __f is a NULL function pointer or NULL\n-       *  pointer-to-member, @c this object will be empty.\n-       *\n-       *  If @a __f is a non-NULL function pointer or an object of type @c\n-       *  reference_wrapper<F>, this function will not throw.\n-       */\n-      template<typename _Functor>\n-\t_Requires<_Callable<typename decay<_Functor>::type>, function&>\n-\toperator=(_Functor&& __f)\n-\t{\n-\t  function(std::forward<_Functor>(__f)).swap(*this);\n-\t  return *this;\n-\t}\n-\n-      /// @overload\n-      template<typename _Functor>\n-\tfunction&\n-\toperator=(reference_wrapper<_Functor> __f) noexcept\n-\t{\n-\t  function(__f).swap(*this);\n-\t  return *this;\n-\t}\n-\n-      // [3.7.2.2] function modifiers\n-\n-      /**\n-       *  @brief Swap the targets of two %function objects.\n-       *  @param __x A %function with identical call signature.\n-       *\n-       *  Swap the targets of @c this function object and @a __f. This\n-       *  function will not throw an %exception.\n-       */\n-      void swap(function& __x) noexcept\n-      {\n-\tstd::swap(_M_functor, __x._M_functor);\n-\tstd::swap(_M_manager, __x._M_manager);\n-\tstd::swap(_M_invoker, __x._M_invoker);\n-      }\n-\n-      // [3.7.2.3] function capacity\n-\n-      /**\n-       *  @brief Determine if the %function wrapper has a target.\n-       *\n-       *  @return @c true when this %function object contains a target,\n-       *  or @c false when it is empty.\n-       *\n-       *  This function will not throw an %exception.\n-       */\n-      explicit operator bool() const noexcept\n-      { return !_M_empty(); }\n-\n-      // [3.7.2.4] function invocation\n-\n-      /**\n-       *  @brief Invokes the function targeted by @c *this.\n-       *  @returns the result of the target.\n-       *  @throws bad_function_call when @c !(bool)*this\n-       *\n-       *  The function call operator invokes the target function object\n-       *  stored by @c this.\n-       */\n-      _Res operator()(_ArgTypes... __args) const;\n-\n-#if __cpp_rtti\n-      // [3.7.2.5] function target access\n-      /**\n-       *  @brief Determine the type of the target of this function object\n-       *  wrapper.\n-       *\n-       *  @returns the type identifier of the target function object, or\n-       *  @c typeid(void) if @c !(bool)*this.\n-       *\n-       *  This function will not throw an %exception.\n-       */\n-      const type_info& target_type() const noexcept;\n-\n-      /**\n-       *  @brief Access the stored target function object.\n-       *\n-       *  @return Returns a pointer to the stored target function object,\n-       *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n-       *  pointer.\n-       *\n-       * This function will not throw an %exception.\n-       */\n-      template<typename _Functor>       _Functor* target() noexcept;\n-\n-      /// @overload\n-      template<typename _Functor> const _Functor* target() const noexcept;\n-#endif\n-\n-    private:\n-      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);\n-      _Invoker_type _M_invoker;\n-  };\n-\n-  // Out-of-line member definitions.\n-  template<typename _Res, typename... _ArgTypes>\n-    function<_Res(_ArgTypes...)>::\n-    function(const function& __x)\n-    : _Function_base()\n-    {\n-      if (static_cast<bool>(__x))\n-\t{\n-\t  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n-\t  _M_invoker = __x._M_invoker;\n-\t  _M_manager = __x._M_manager;\n-\t}\n-    }\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    template<typename _Functor, typename, typename>\n-      function<_Res(_ArgTypes...)>::\n-      function(_Functor __f)\n-      : _Function_base()\n-      {\n-\ttypedef _Function_handler<_Signature_type, _Functor> _My_handler;\n-\n-\tif (_My_handler::_M_not_empty_function(__f))\n-\t  {\n-\t    _My_handler::_M_init_functor(_M_functor, std::move(__f));\n-\t    _M_invoker = &_My_handler::_M_invoke;\n-\t    _M_manager = &_My_handler::_M_manager;\n-\t  }\n-      }\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    _Res\n-    function<_Res(_ArgTypes...)>::\n-    operator()(_ArgTypes... __args) const\n-    {\n-      if (_M_empty())\n-\t__throw_bad_function_call();\n-      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);\n-    }\n-\n-#if __cpp_rtti\n-  template<typename _Res, typename... _ArgTypes>\n-    const type_info&\n-    function<_Res(_ArgTypes...)>::\n-    target_type() const noexcept\n-    {\n-      if (_M_manager)\n-\t{\n-\t  _Any_data __typeinfo_result;\n-\t  _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n-\t  return *__typeinfo_result._M_access<const type_info*>();\n-\t}\n-      else\n-\treturn typeid(void);\n-    }\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    template<typename _Functor>\n-      _Functor*\n-      function<_Res(_ArgTypes...)>::\n-      target() noexcept\n-      {\n-\tif (typeid(_Functor) == target_type() && _M_manager)\n-\t  {\n-\t    _Any_data __ptr;\n-\t    if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n-\t\t&& !is_const<_Functor>::value)\n-\t      return 0;\n-\t    else\n-\t      return __ptr._M_access<_Functor*>();\n-\t  }\n-\telse\n-\t  return 0;\n-      }\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    template<typename _Functor>\n-      const _Functor*\n-      function<_Res(_ArgTypes...)>::\n-      target() const noexcept\n-      {\n-\tif (typeid(_Functor) == target_type() && _M_manager)\n-\t  {\n-\t    _Any_data __ptr;\n-\t    _M_manager(__ptr, _M_functor, __get_functor_ptr);\n-\t    return __ptr._M_access<const _Functor*>();\n-\t  }\n-\telse\n-\t  return 0;\n-      }\n-#endif\n-\n-  // [20.7.15.2.6] null pointer comparisons\n-\n-  /**\n-   *  @brief Compares a polymorphic function object wrapper against 0\n-   *  (the NULL pointer).\n-   *  @returns @c true if the wrapper has no target, @c false otherwise\n-   *\n-   *  This function will not throw an %exception.\n-   */\n-  template<typename _Res, typename... _Args>\n-    inline bool\n-    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept\n-    { return !static_cast<bool>(__f); }\n-\n-  /// @overload\n-  template<typename _Res, typename... _Args>\n-    inline bool\n-    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept\n-    { return !static_cast<bool>(__f); }\n-\n-  /**\n-   *  @brief Compares a polymorphic function object wrapper against 0\n-   *  (the NULL pointer).\n-   *  @returns @c false if the wrapper has no target, @c true otherwise\n-   *\n-   *  This function will not throw an %exception.\n-   */\n-  template<typename _Res, typename... _Args>\n-    inline bool\n-    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept\n-    { return static_cast<bool>(__f); }\n-\n-  /// @overload\n-  template<typename _Res, typename... _Args>\n-    inline bool\n-    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept\n-    { return static_cast<bool>(__f); }\n-\n-  // [20.7.15.2.7] specialized algorithms\n-\n-  /**\n-   *  @brief Swap the targets of two polymorphic function object wrappers.\n-   *\n-   *  This function will not throw an %exception.\n-   */\n-  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-  // 2062. Effect contradictions w/o no-throw guarantee of std::function swaps\n-  template<typename _Res, typename... _Args>\n-    inline void\n-    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y) noexcept\n-    { __x.swap(__y); }\n-\n #if __cplusplus >= 201402L\n   /// Generalized negator.\n   template<typename _Fn>\n@@ -2084,12 +958,9 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n     private:\n       _Fn _M_fn;\n     };\n-#endif // C++14\n \n #if __cplusplus > 201402L\n-\n #define __cpp_lib_not_fn 201603\n-\n   /// [func.not_fn] Function template not_fn\n   template<typename _Fn>\n     inline auto\n@@ -2410,6 +1281,7 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n     }\n \n #endif // C++17\n+#endif // C++14\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std"}, {"sha": "fea915b0a8765f1e14633cb8a46a38400aaa7112", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -40,12 +40,12 @@\n #include <condition_variable>\n #include <system_error>\n #include <atomic>\n-#include <functional>\n #include <bits/atomic_futex.h>\n #include <bits/functexcept.h>\n #include <bits/invoke.h>\n #include <bits/unique_ptr.h>\n #include <bits/shared_ptr.h>\n+#include <bits/std_function.h>\n #include <bits/uses_allocator.h>\n #include <bits/allocated_ptr.h>\n #include <ext/aligned_buffer.h>"}, {"sha": "c34ba4b50b62d5fb090772049e13f57d662af19e", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -46,7 +46,7 @@\n # include <thread>\n #endif\n #ifndef _GLIBCXX_HAVE_TLS\n-# include <functional>\n+# include <bits/std_function.h>\n #endif\n \n #ifdef _GLIBCXX_USE_C99_STDINT_TR1"}, {"sha": "f5728245eb869ad02033689ef60d3b23172e56cf", "filename": "libstdc++-v3/include/std/regex", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -37,7 +37,6 @@\n \n #include <algorithm>\n #include <bitset>\n-#include <functional>\n #ifdef _GLIBCXX_DEBUG\n # include <iosfwd>\n #endif\n@@ -54,6 +53,7 @@\n #include <cstring>\n \n #include <ext/aligned_buffer.h>\n+#include <bits/std_function.h>\n #include <bits/regex_constants.h>\n #include <bits/regex_error.h>\n #include <bits/regex_automaton.h>"}, {"sha": "0f9dc3dcaa9284e7ac07c7fac9c27d03b0fba08c", "filename": "libstdc++-v3/src/c++11/compatibility-thread-c++0x.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcompatibility-thread-c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcompatibility-thread-c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcompatibility-thread-c%2B%2B0x.cc?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -29,6 +29,7 @@\n \n #include <future>\n #include <mutex>\n+#include <functional>\n \n #if __cplusplus < 201103L\n # error \"compatibility-thread-c++0x.cc must be compiled with -std=gnu++0x\""}, {"sha": "23b3f8b6c46406ea121da76836adec225bd203eb", "filename": "libstdc++-v3/testsuite/20_util/default_delete/48631_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2F48631_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2F48631_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2F48631_neg.cc?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -26,4 +26,4 @@ struct D : B { };\n D d;\n std::default_delete<B[]> db;\n typedef decltype(db(&d)) type; // { dg-error \"no match\" }\n-// { dg-error \"no type\" \"\" { target *-*-* } 106 }\n+// { dg-error \"no type\" \"\" { target *-*-* } 107 }"}, {"sha": "c9688bcda7b5e95015447807911ae1b8ae2e0029", "filename": "libstdc++-v3/testsuite/20_util/default_delete/void_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2Fvoid_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2Fvoid_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2Fvoid_neg.cc?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -25,5 +25,5 @@ void test01()\n {\n   std::default_delete<void> d;\n   d(nullptr);   // { dg-error \"here\" }\n-  // { dg-error \"incomplete\" \"\" { target *-*-* } 72 }\n+  // { dg-error \"incomplete\" \"\" { target *-*-* } 73 }\n }"}, {"sha": "9d248265be97950c0116c397cacb4b7531e414dc", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/assign/48635_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2F48635_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2F48635_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2F48635_neg.cc?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -42,10 +42,10 @@ void f()\n   std::unique_ptr<int, D&> ud(nullptr, d);\n   ub = std::move(ud); // { dg-error \"no match\" }\n   ub2 = ud; // { dg-error \"no match\" }\n-// { dg-error \"no type\" \"\" { target *-*-* } 287 }\n+// { dg-error \"no type\" \"\" { target *-*-* } 288 }\n \n   std::unique_ptr<int[], B&> uba(nullptr, b);\n   std::unique_ptr<int[], D&> uda(nullptr, d);\n   uba = std::move(uda); // { dg-error \"no match\" }\n-// { dg-error \"no type\" \"\" { target *-*-* } 538 }\n+// { dg-error \"no type\" \"\" { target *-*-* } 539 }\n }"}, {"sha": "a0f77c0c00979abbf82ceccabad66cc1f33fac5d", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fcv_qual_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fcv_qual_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fcv_qual_neg.cc?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -39,7 +39,7 @@ test07()\n   std::unique_ptr<const A[]> cA3(p); // { dg-error \"no matching function\" }\n   std::unique_ptr<volatile A[]> vA3(p); // { dg-error \"no matching function\" }\n   std::unique_ptr<const volatile A[]> cvA3(p); // { dg-error \"no matching function\" }\n-  // { dg-error \"no type\" \"\" { target *-*-* } 446 }\n+  // { dg-error \"no type\" \"\" { target *-*-* } 447 }\n }\n \n template<typename T>"}, {"sha": "1ab9d192ac5d824d9212a073780b065810817ce3", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/49668.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2F49668.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05986b936078409c99a8eb4ce81e371323132d0/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2F49668.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2F49668.cc?ref=c05986b936078409c99a8eb4ce81e371323132d0", "patch": "@@ -24,6 +24,7 @@\n \n \n #include <future>\n+#include <functional>\n #include <testsuite_hooks.h>\n \n struct moveable"}]}