{"sha": "a703fb388ba235e449aad17c618d50fe48a03812", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcwM2ZiMzg4YmEyMzVlNDQ5YWFkMTdjNjE4ZDUwZmU0OGEwMzgxMg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1998-02-02T00:04:13Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-02-02T00:04:13Z"}, "message": "Various fixes for -Wall problems from Kaveh.  See ChangeLog for details.\n\nFrom-SVN: r17586", "tree": {"sha": "420be67f33cf5a55fab47f8908be1b9617e6e46d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/420be67f33cf5a55fab47f8908be1b9617e6e46d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a703fb388ba235e449aad17c618d50fe48a03812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a703fb388ba235e449aad17c618d50fe48a03812", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a703fb388ba235e449aad17c618d50fe48a03812", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a703fb388ba235e449aad17c618d50fe48a03812/comments", "author": null, "committer": null, "parents": [{"sha": "ceb6edf2498ce4a8714e90f48d9ff2ba66af059a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceb6edf2498ce4a8714e90f48d9ff2ba66af059a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceb6edf2498ce4a8714e90f48d9ff2ba66af059a"}], "stats": {"total": 617, "additions": 389, "deletions": 228}, "files": [{"sha": "4d6476adacfbbb5e1a2e5f54a3af153eea943091", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -1,3 +1,127 @@\n+Mon Feb  2 00:57:38 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* call.c (user_harshness): Initialize `code' to 0.\n+\t(build_method_call): Initialize `candidates', `cp' and `len' to 0.\n+\t(null_ptr_cst_p): Add parentheses around && within ||.\n+\t(standard_conversion): Likewise.\n+\t(z_candidate): Likewise.\n+\t(build_user_type_conversion_1): Initialize `args' to NULL_TREE.\n+\t(build_object_call): Likewise for `mem_args'.\n+\t(build_new_op): Likewise for `mem_arglist'.  Add `return' from\n+\tdefault case in enumeration switch.\n+\n+\t* class.c (build_vtable_entry): Add explicit braces to avoid\n+\tambiguous `else'.\n+\t(build_class_init_list): Likewise.\n+\t(finish_struct_1): Initialize `width' to 0.\n+\t(instantiate_type): Initialize `name' to NULL_TREE.  Add\n+\texplicit braces to avoid ambiguous `else'.\n+\n+\t* cvt.c (convert_to_aggr): Add explicit braces to avoid ambiguous\n+\t`else'.\n+\n+\t* decl.c (grok_reference_init): Eliminate unused parameter, all\n+\tcallers changed.\n+\t(record_builtin_type): Initialize `tdecl' to NULL_TREE.\n+\t(init_decl_processing): Initialize `vb_off_identifier' to NULL_TREE.\n+\t(cp_finish_decl): Initialize `ttype' to NULL_TREE.\n+\t(grokdeclarator): Add parentheses around && within ||.  Add\n+\texplicit braces to avoid ambiguous `else'.\n+\t(grokparms): Initialize `type' to NULL_TREE.\n+\t(xref_tag): Remove unused label\t`just_return'.\n+\t(finish_enum): Initialize `minnode' and `maxnode' to NULL_TREE.\n+\t(finish_function): Initialize `cond' and `thenclause' to NULL_TREE.\n+\t(hack_incomplete_structures): Add parentheses around assignment\n+\tused as truth value.\n+\n+\t* decl2.c (coerce_delete_type): Hide definition of `e3'.\n+\n+\t* error.c: Include <stdlib.h>.\n+\t(dump_expr): Change the type of `i' to size_t.  Remove unused\n+\tlabel `error'. \n+\n+\t* except.c (init_exception_processing): Remove unused variable `d'.\n+\t(expand_throw): Likewise for `label'.\n+\n+\t* friend.c (add_friends): Add explicit braces to avoid ambiguous\n+\t`else'.\n+\n+\t* init.c (sort_member_init): Initialize `last_field' to NULL_TREE.\n+\t(sort_base_init): Likewise for `binfo'.\n+\t(expand_member_init): Likewise for `rval'.\n+\t(build_member_call): Add parentheses around assignment used as\n+\ttruth value.\n+\t(build_offset_ref): Add explicit braces to avoid ambiguous `else'.\n+\t(build_new): Initialize `nelts' to NULL_TREE.  Initialize\n+\t`old_immediate_size_expand' to 0.\n+\t(build_new_1): Initialize `nelts' and `alloc_node' to NULL_TREE.\n+\t(build_vec_delete_1): Remove unused variable `block'.\n+\t(expand_vec_init): Initialize `itype' to NULL_TREE.\n+\n+\t* lex.c: Include <strings.h> if we don't have <string.h>.  Protect\n+\tdeclaration of `index' and `rindex' with autoconf macros.\n+\t(reinit_parse_for_expr): Remove unused variables\n+\t`look_for_semicolon' and `look_for_lbrac'.\n+\t(cons_up_default_function): Initialize `args' to NULL_TREE.\n+\t(readescape): Initialize `firstdig' to 0.\n+\t(real_yylex): Add parentheses around assignment used as truth value. \n+\n+\t* method.c: Include <strings.h> if we don't have <string.h>.\n+\tProtect declaration of `index' with autoconf macro.\n+\n+\t* parse.y (primary): Add explicit braces to avoid ambiguous `else'.\n+\tInitialize `type' to NULL_TREE.\n+\t(structsp): Remove unused variable `id'.\n+\n+\t* pt.c (coerce_template_parms): Add explicit braces to avoid\n+\tambiguous `else'.\n+\t(lookup_template_class): Initialize `template' to NULL_TREE.\n+\t(instantiate_class_template): Remove unused variable `name' and `e'.\n+\t(tsubst): Likewise for `i'.  Initialize `last' to NULL_TREE.\n+\t(do_poplevel): Initialize `saved_warn_unused' to 0.\n+\t(type_unification): Remove unused varable `parm'.\n+\t(unify): Likewise for `j'.\n+\n+\t* repo.c (init_repo): Add parentheses around assignment used as\n+\ttruth value.\n+\t(finish_repo): Remove unused varable `p'.\n+\t\n+\t* search.c (get_binfo): Initiize `type' to NULL_TREE.\n+\t(get_base_distance): Likewise.\n+\t(lookup_field): Initialize `rval_binfo_h', `type', `basetype_path'\n+\tand `new_v' to NULL_TREE.\n+\t(lookup_fnfields): Likewise for `rval_binfo_h'.\n+\t(breadth_first_search): Add parentheses around assignment used as\n+\ttruth value.\n+\t(get_template_base): Initialize `type' to NULL_TREE.\n+\n+\t* sig.c (append_signature_fields): Initialize `last_mfptr' to\n+\tNULL_TREE.\n+\t(build_signature_table_constructor): Likewise for\n+\t`last_rhs_field', `pfn' and `vt_off'.\n+\t(build_sigtable): Likewise for `init'.\n+\n+\t* tree.c (break_out_calls): Initialize `t2' to NULL_TREE.\n+\t(propagate_binfo_offsets): Likewise for `delta'.\n+\t(hash_tree_cons): Initialize hashcode to 0.\n+\t(can_free): Likewise for `size'.\n+\t(cp_tree_equal): Add explicit braces to avoid ambiguous `else'.\n+\t\n+\t* typeck.c (convert_sequence): Hide prototype.\n+\t(common_type): Add explicit braces to avoid ambiguous `else'.\n+\t(comp_target_types): Likewise.\n+\t(build_x_function_call): Initialize `ctypeptr' to NULL_TREE.\n+\t(build_function_call_real): Add explicit braces to avoid ambiguous\n+\t`else'.\n+\t(convert_arguments): Initialize `called_thing' to 0.\n+\t(convert_for_initialization): Initialize `savew' and `savee' to 0.\n+\n+\t* typeck2.c (incomplete_type_error): Initialize `errmsg' to 0.\n+\t(digest_init): Initialize `old_tail_contents' to NULL_TREE.\n+\t(build_x_arrow): Likewise for `last_rval'.\n+\n+\t* xref.c (GNU_xref_decl): Initialize `cls' to 0.\n+\n Sun Feb  1 12:45:34 1998 J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* decl.c (init_decl_processing): Use set_sizetype."}, {"sha": "d97f86167d51e82956025970ed26cab7302e4c49", "filename": "gcc/cp/call.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -692,7 +692,7 @@ user_harshness (type, parmtype)\n {\n   tree conv;\n   tree winner = NULL_TREE;\n-  int code;\n+  int code = 0;\n \n   {\n     tree typename = build_typename_overload (type);\n@@ -2195,9 +2195,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n   for (pass = 0; pass < 2; pass++)\n     {\n-      struct candidate *candidates;\n-      struct candidate *cp;\n-      int len;\n+      struct candidate *candidates = 0;\n+      struct candidate *cp = 0;\n+      int len = 0;\n       unsigned best = 1;\n \n       baselink = result;\n@@ -3000,7 +3000,7 @@ null_ptr_cst_p (t)\n      tree t;\n {\n   if (t == null_node\n-      || integer_zerop (t) && TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE)\n+      || (integer_zerop (t) && TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE))\n     return 1;\n   return 0;\n }\n@@ -3192,8 +3192,8 @@ standard_conversion (to, from, expr)\n \treturn 0;\n \n       conv = build_conv (STD_CONV, to, conv);\n-      if (fcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (from)\n-\t  && ICS_STD_RANK (conv) < PBOOL_RANK)\n+      if (fcode == POINTER_TYPE\n+\t  || (TYPE_PTRMEMFUNC_P (from) && ICS_STD_RANK (conv) < PBOOL_RANK))\n \tICS_STD_RANK (conv) = PBOOL_RANK;\n     }\n   /* We don't check for ENUMERAL_TYPE here because there are no standard\n@@ -3768,8 +3768,8 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n \n     case EQ_EXPR:\n     case NE_EXPR:\n-      if (TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2)\n-\t  || TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2))\n+      if ((TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2))\n+\t  || (TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2)))\n \tbreak;\n       if ((TYPE_PTRMEMFUNC_P (type1) || TYPE_PTRMEM_P (type1))\n \t  && null_ptr_cst_p (args[1]))\n@@ -3789,8 +3789,8 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n     case GE_EXPR:\n     case MAX_EXPR:\n     case MIN_EXPR:\n-      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2)\n-\t  || TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n+      if ((ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n+\t  || (TYPE_PTR_P (type1) && TYPE_PTR_P (type2)))\n \tbreak;\n       if (TYPE_PTR_P (type1) && null_ptr_cst_p (args[1]))\n \t{\n@@ -4322,7 +4322,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n   struct z_candidate *candidates, *cand;\n   tree fromtype = TREE_TYPE (expr);\n   tree ctors = NULL_TREE, convs = NULL_TREE, *p;\n-  tree args;\n+  tree args = NULL_TREE;\n   tree templates = NULL_TREE;\n \n   if (IS_AGGR_TYPE (totype))\n@@ -4597,7 +4597,7 @@ build_object_call (obj, args)\n      tree obj, args;\n {\n   struct z_candidate *candidates = 0, *cand;\n-  tree fns, convs, mem_args;\n+  tree fns, convs, mem_args = NULL_TREE;\n   tree type = TREE_TYPE (obj);\n   tree templates = NULL_TREE;\n \n@@ -4725,7 +4725,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n      tree arg1, arg2, arg3;\n {\n   struct z_candidate *candidates = 0, *cand;\n-  tree fns, mem_arglist, arglist, fnname;\n+  tree fns, mem_arglist = NULL_TREE, arglist, fnname;\n   enum tree_code code2 = NOP_EXPR;\n   tree templates = NULL_TREE;\n   tree conv;\n@@ -5117,6 +5117,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \n     default:\n       my_friendly_abort (367);\n+      return NULL_TREE;\n     }\n }\n \n@@ -5665,7 +5666,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree explicit_targs = NULL_TREE;\n-  tree basetype, mem_args, fns, instance_ptr;\n+  tree basetype, mem_args = NULL_TREE, fns, instance_ptr;\n   tree pretty_name;\n   tree user_args = args;\n   tree templates = NULL_TREE;"}, {"sha": "e8d9ab19a4f64165c410a305801695cc8aea7372", "filename": "gcc/cp/class.c", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -458,11 +458,13 @@ build_vtable_entry (delta, pfn)\n \t   < TREE_INT_CST_LOW (delta))\n \t  || (TREE_INT_CST_LOW (delta)\n \t      < TREE_INT_CST_LOW (TYPE_MIN_VALUE (delta_type_node))))\n-\tif (flag_huge_objects)\n-\t  sorry (\"object size exceeds built-in limit for virtual function table implementation\");\n-\telse\n-\t  sorry (\"object size exceeds normal limit for virtual function table implementation, recompile all source and use -fhuge-objects\");\n-\n+\t{\n+\t  if (flag_huge_objects)\n+\t    sorry (\"object size exceeds built-in limit for virtual function table implementation\");\n+\t  else\n+\t    sorry (\"object size exceeds normal limit for virtual function table implementation, recompile all source and use -fhuge-objects\");\n+\t}\n+      \n       TREE_CONSTANT (entry) = 1;\n       TREE_STATIC (entry) = 1;\n       TREE_READONLY (entry) = 1;\n@@ -1493,10 +1495,13 @@ build_class_init_list (type)\n     }\n \n   if (base_init_list)\n-    if (member_init_list)\n-      CLASSTYPE_BASE_INIT_LIST (type) = build_tree_list (base_init_list, member_init_list);\n-    else\n-      CLASSTYPE_BASE_INIT_LIST (type) = base_init_list;\n+    {\n+      if (member_init_list)\n+\tCLASSTYPE_BASE_INIT_LIST (type) =\n+\t  build_tree_list (base_init_list, member_init_list);\n+      else\n+\tCLASSTYPE_BASE_INIT_LIST (type) = base_init_list;\n+    }\n   else if (member_init_list)\n     CLASSTYPE_BASE_INIT_LIST (type) = member_init_list;\n }\n@@ -3461,7 +3466,7 @@ finish_struct_1 (t, warn_anon)\n \t  if (DECL_INITIAL (x))\n \t    {\n \t      tree w = DECL_INITIAL (x);\n-\t      register int width;\n+\t      register int width = 0;\n \n \t      /* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */\n \t      STRIP_NOPS (w);\n@@ -5102,7 +5107,7 @@ instantiate_type (lhstype, rhs, complain)\n \n     case TREE_LIST:\n       {\n-\ttree elem, baselink, name;\n+\ttree elem, baselink, name = NULL_TREE;\n \tint globals = overloaded_globals_p (rhs);\n \n \t/* First look for an exact match.  Search either overloaded\n@@ -5113,15 +5118,17 @@ instantiate_type (lhstype, rhs, complain)\n \t  lhstype = TYPE_PTRMEMFUNC_FN_TYPE (lhstype);\n \n \tif (TREE_CODE (lhstype) == POINTER_TYPE)\n-\t  if (TREE_CODE (TREE_TYPE (lhstype)) == FUNCTION_TYPE\n-\t      || TREE_CODE (TREE_TYPE (lhstype)) == METHOD_TYPE)\n-\t    lhstype = TREE_TYPE (lhstype);\n-\t  else\n-\t    {\n-\t      if (complain)\n-\t\terror (\"invalid type combination for overload\");\n-\t      return error_mark_node;\n-\t    }\n+\t  {\n+\t    if (TREE_CODE (TREE_TYPE (lhstype)) == FUNCTION_TYPE\n+\t\t|| TREE_CODE (TREE_TYPE (lhstype)) == METHOD_TYPE)\n+\t      lhstype = TREE_TYPE (lhstype);\n+\t    else\n+\t      {\n+\t\tif (complain)\n+\t\t  error (\"invalid type combination for overload\");\n+\t\treturn error_mark_node;\n+\t      }\n+\t  }\n \n \tif (TREE_CODE (lhstype) != FUNCTION_TYPE && globals > 0)\n \t  {\n@@ -5138,13 +5145,15 @@ instantiate_type (lhstype, rhs, complain)\n \t       can match.  */\n \t    if (explicit_targs == NULL_TREE)\n \t      while (elem)\n-\t\tif (! comptypes (lhstype, TREE_TYPE (elem), 1))\n-\t\t  elem = DECL_CHAIN (elem);\n-\t\telse\n-\t\t  {\n-\t\t    mark_used (elem);\n-\t\t    return elem;\n-\t\t  }\n+\t\t{\n+\t\t  if (! comptypes (lhstype, TREE_TYPE (elem), 1))\n+\t\t    elem = DECL_CHAIN (elem);\n+\t\t  else\n+\t\t    {\n+\t\t      mark_used (elem);\n+\t\t      return elem;\n+\t\t    }\n+\t\t}\n \n \t    /* No exact match found, look for a compatible template.  */\n \t    {"}, {"sha": "c5a5f938943a60f20945cee1ed0b31758a243cca", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -818,10 +818,12 @@ convert_to_aggr (type, expr, msgp, protect)\n     else if (msgp)\n       {\n \tif (saw_private)\n-\t  if (saw_protected)\n-\t    *msgp = \"only private and protected conversions apply\";\n-\t  else\n-\t    *msgp = \"only private conversions apply\";\n+\t  {\n+\t    if (saw_protected)\n+\t      *msgp = \"only private and protected conversions apply\";\n+\t    else\n+\t      *msgp = \"only private conversions apply\";\n+\t  }\n \telse if (saw_protected)\n \t  *msgp = \"only protected conversions apply\";\n \telse"}, {"sha": "27e4b31c08b79f030c392fe0e98b6e46f909aa25", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -164,7 +164,7 @@ static tree obscure_complex_init PROTO((tree, tree));\n static tree maybe_build_cleanup_1 PROTO((tree, tree));\n static tree lookup_name_real PROTO((tree, int, int));\n static void warn_extern_redeclared_static PROTO((tree, tree));\n-static void grok_reference_init PROTO((tree, tree, tree, tree *));\n+static void grok_reference_init PROTO((tree, tree, tree));\n static tree grokfndecl PROTO((tree, tree, tree, tree, int,\n \t\t\t      enum overload_flags,\n \t\t\t      tree, tree, tree, int, int, int, int, int, int));\n@@ -4798,7 +4798,7 @@ record_builtin_type (rid_index, name, type)\n      tree type;\n {\n   tree rname = NULL_TREE, tname = NULL_TREE;\n-  tree tdecl;\n+  tree tdecl = NULL_TREE;\n \n   if ((int) rid_index < (int) RID_MAX)\n     rname = ridpointers[(int) rid_index];\n@@ -4870,7 +4870,7 @@ init_decl_processing ()\n   tree temp;\n   tree array_domain_type;\n   extern int flag_strict_prototype;\n-  tree vb_off_identifier;\n+  tree vb_off_identifier = NULL_TREE;\n   /* Function type `char *(char *, char *)' and similar ones */\n   tree string_ftype_ptr_ptr, int_ftype_string_string;\n   tree sizetype_endlink;\n@@ -6299,9 +6299,8 @@ start_decl_1 (decl)\n    Quotes on semantics can be found in ARM 8.4.3.  */\n \n static void\n-grok_reference_init (decl, type, init, cleanupp)\n+grok_reference_init (decl, type, init)\n      tree decl, type, init;\n-     tree *cleanupp;\n {\n   tree tmp;\n \n@@ -6442,7 +6441,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n      int flags;\n {\n   register tree type;\n-  tree cleanup = NULL_TREE, ttype;\n+  tree cleanup = NULL_TREE, ttype = NULL_TREE;\n   int was_incomplete;\n   int temporary = allocation_temporary_p ();\n   char *asmspec = NULL;\n@@ -6569,7 +6568,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \tmake_decl_rtl (decl, NULL_PTR,\n \t\t       toplevel_bindings_p ()\n \t\t       || pseudo_global_level_p ());\n-      grok_reference_init (decl, type, init, &cleanup);\n+      grok_reference_init (decl, type, init);\n       init = NULL_TREE;\n     }\n \n@@ -7976,7 +7975,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      }\n \t    if (! IDENTIFIER_OPNAME_P (dname)\n \t\t/* GNU/Linux headers use '__op'.  Arrgh.  */\n-\t\t|| IDENTIFIER_TYPENAME_P (dname) && ! TREE_TYPE (dname))\n+\t\t|| (IDENTIFIER_TYPENAME_P (dname) && ! TREE_TYPE (dname)))\n \t      name = IDENTIFIER_POINTER (dname);\n \t    else\n \t      {\n@@ -9521,10 +9520,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       /* Note that the grammar rejects storage classes\n \t in typenames, fields or parameters.  */\n       if (constp || volatilep)\n-\tif (IS_SIGNATURE (type))\n-\t  error (\"`const' or `volatile' specified with signature type\");\n-\telse  \n-\t  type = cp_build_type_variant (type, constp, volatilep);\n+\t{\n+\t  if (IS_SIGNATURE (type))\n+\t    error (\"`const' or `volatile' specified with signature type\");\n+\t  else  \n+\t    type = cp_build_type_variant (type, constp, volatilep);\n+\t}\n \n       /* Special case: \"friend class foo\" looks like a TYPENAME context.  */\n       if (friendp)\n@@ -10204,7 +10205,7 @@ grokparms (first_parm, funcdef_flag)\n \n \t  for (parm = first_parm; parm != NULL_TREE; parm = chain)\n \t    {\n-\t      tree type, list_node = parm;\n+\t      tree type = NULL_TREE, list_node = parm;\n \t      register tree decl = TREE_VALUE (parm);\n \t      tree init = TREE_PURPOSE (parm);\n \n@@ -10951,8 +10952,6 @@ xref_tag (code_type_node, name, binfo, globalize)\n   if (binfo)\n     xref_basetypes (code_type_node, name, ref, binfo);\n \n- just_return:\n-\n   /* Until the type is defined, tentatively accept whatever\n      structure tag the user hands us.  */\n   if (TYPE_SIZE (ref) == NULL_TREE\n@@ -11182,7 +11181,7 @@ tree\n finish_enum (enumtype, values)\n      register tree enumtype, values;\n {\n-  register tree minnode, maxnode;\n+  register tree minnode = NULL_TREE, maxnode = NULL_TREE;\n   /* Calculate the maximum value of any enumerator in this type.  */\n \n   if (values)\n@@ -12328,7 +12327,7 @@ finish_function (lineno, call_poplevel, nested)\n \t}\n       else if (DECL_CONSTRUCTOR_P (fndecl))\n \t{\n-\t  tree cond, thenclause;\n+\t  tree cond = NULL_TREE, thenclause = NULL_TREE;\n \t  /* Allow constructor for a type to get a new instance of the object\n \t     using `build_new'.  */\n \t  tree abstract_virtuals = CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type);\n@@ -12816,7 +12815,7 @@ hack_incomplete_structures (type)\n   for (list = &current_binding_level->incomplete; *list; )\n     {\n       tree decl = TREE_VALUE (*list);\n-      if (decl && TREE_TYPE (decl) == type\n+      if ((decl && TREE_TYPE (decl) == type)\n \t  || (TREE_TYPE (decl)\n \t      && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n \t      && TREE_TYPE (TREE_TYPE (decl)) == type))"}, {"sha": "1409c2fd3212a996c1d8c993affa2ee6253a4150", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -2399,7 +2399,10 @@ tree\n coerce_delete_type (type)\n      tree type;\n {\n-  int e1 = 0, e2 = 0, e3 = 0;\n+  int e1 = 0, e2 = 0;\n+#if 0\n+  e3 = 0;\n+#endif\n   tree arg_types = TYPE_ARG_TYPES (type);\n \n   if (TREE_CODE (type) == METHOD_TYPE)"}, {"sha": "a8be7582d26c7a72b36218a31a0cfe21ca2ebe56", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -21,6 +21,9 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include <stdio.h>\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n #include \"tree.h\"\n #include \"cp-tree.h\"\n #include \"obstack.h\"\n@@ -1221,7 +1224,7 @@ dump_expr (t, nop)\n #else\n       {\n \tunsigned char *p = (unsigned char *) &TREE_REAL_CST (t);\n-\tint i;\n+\tsize_t i;\n \tstrcpy (digit_buffer, \"0x\");\n \tfor (i = 0; i < sizeof TREE_REAL_CST (t); i++)\n \t  sprintf (digit_buffer + 2 + 2*i, \"%02x\", *p++);\n@@ -1629,7 +1632,6 @@ dump_expr (t, nop)\n \n       /* fall through to ERROR_MARK...  */\n     case ERROR_MARK:\n-    error:\n       OB_PUTCP (\"{error}\");\n       break;\n     }"}, {"sha": "0f2a8df81adc577dd38cf301fc3e8ac8f7175735", "filename": "gcc/cp/except.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -215,8 +215,6 @@ do_function_call (func, params, return_type)\n void\n init_exception_processing ()\n {\n-  tree d;\n-\n   /* void vtype () */\n   tree vtype = build_function_type (void_type_node, void_list_node);\n   \n@@ -972,7 +970,6 @@ void\n expand_throw (exp)\n      tree exp;\n {\n-  rtx label;\n   tree fn;\n   static tree cleanup_type;\n "}, {"sha": "7263e6426c02af65f74c924522ff6f02926bc63a", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -195,14 +195,16 @@ add_friends (type, name, friend_type)\n \t  while (friends && TREE_PURPOSE (friends) != friend_type)\n \t    friends = TREE_CHAIN (friends);\n \t  if (friends)\n-\t    if (friend_type)\n-\t      warning (\"method `%s::%s' is already a friend of class\",\n-\t\t       TYPE_NAME_STRING (friend_type),\n-\t\t       IDENTIFIER_POINTER (name));\n-\t    else\n-\t      warning (\"function `%s' is already a friend of class `%s'\",\n-\t\t       IDENTIFIER_POINTER (name),\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (typedecl)));\n+\t    {\n+\t      if (friend_type)\n+\t\twarning (\"method `%s::%s' is already a friend of class\",\n+\t\t\t TYPE_NAME_STRING (friend_type),\n+\t\t\t IDENTIFIER_POINTER (name));\n+\t      else\n+\t\twarning (\"function `%s' is already a friend of class `%s'\",\n+\t\t\t IDENTIFIER_POINTER (name),\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (typedecl)));\n+\t    }\n \t  else\n \t    TREE_VALUE (list) = tree_cons (friend_type, NULL_TREE,\n \t\t\t\t\t   TREE_VALUE (list));"}, {"sha": "c3bb1a86ee60be99f8732302c51df3826cc700d0", "filename": "gcc/cp/init.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -259,7 +259,7 @@ sort_member_init (t)\n   tree x, member, name, field;\n   tree init_list = NULL_TREE;\n   int last_pos = 0;\n-  tree last_field;\n+  tree last_field = NULL_TREE;\n \n   for (member = TYPE_FIELDS (t); member ; member = TREE_CHAIN (member))\n     {\n@@ -369,7 +369,7 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n   for (x = TREE_CHAIN (last); x; x = TREE_CHAIN (x))\n     {\n       tree basetype = TREE_PURPOSE (x);\n-      tree binfo;\n+      tree binfo = NULL_TREE;\n \n       if (basetype == NULL_TREE)\n \t{\n@@ -925,7 +925,7 @@ expand_member_init (exp, name, init)\n \n   tree basetype = NULL_TREE, field;\n   tree parm;\n-  tree rval, type;\n+  tree rval = NULL_TREE, type;\n \n   if (exp == NULL_TREE)\n     return;\t\t\t/* complain about this later */\n@@ -1776,7 +1776,7 @@ build_member_call (type, name, parmlist)\n   if (method_name == constructor_name (type)\n       || method_name == constructor_name_full (type))\n     return build_functional_cast (type, parmlist);\n-  if (t = lookup_fnfields (basetype_path, method_name, 0))\n+  if ((t = lookup_fnfields (basetype_path, method_name, 0)))\n     return build_method_call (decl, \n \t\t\t      TREE_CODE (name) == TEMPLATE_ID_EXPR\n \t\t\t      ? name : method_name,\n@@ -1906,10 +1906,12 @@ build_offset_ref (type, name)\n     decl = current_class_ref;\n \n   if (constructor_name (BINFO_TYPE (basebinfo)) == name)\n-    if (dtor)\n-      name = dtor_identifier;\n-    else\n-      name = ctor_identifier;\n+    {\n+      if (dtor)\n+\tname = dtor_identifier;\n+      else\n+\tname = ctor_identifier;\n+    }\n   else\n     if (dtor)\n       my_friendly_abort (999);\n@@ -2250,7 +2252,7 @@ build_new (placement, decl, init, use_global_new)\n      int use_global_new;\n {\n   tree type, rval;\n-  tree nelts, t;\n+  tree nelts = NULL_TREE, t;\n   int has_array = 0;\n \n   tree pending_sizes = NULL_TREE;\n@@ -2262,7 +2264,7 @@ build_new (placement, decl, init, use_global_new)\n     {\n       tree absdcl = TREE_VALUE (decl);\n       tree last_absdcl = NULL_TREE;\n-      int old_immediate_size_expand;\n+      int old_immediate_size_expand = 0;\n \n       if (current_function_decl\n \t  && DECL_CONSTRUCTOR_P (current_function_decl))\n@@ -2434,8 +2436,8 @@ build_new_1 (exp)\n {\n   tree placement, init, t;\n   tree type, true_type, size, rval;\n-  tree nelts;\n-  tree alloc_expr, alloc_node;\n+  tree nelts = NULL_TREE;\n+  tree alloc_expr, alloc_node = NULL_TREE;\n   int has_array = 0;\n   enum tree_code code = NEW_EXPR;\n   int use_cookie, nothrow, check_new;\n@@ -2806,9 +2808,6 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n      This is also the containing expression returned by this function.  */\n   tree controller = NULL_TREE;\n \n-  /* This is the BLOCK to record the symbol binding for debugging.  */\n-  tree block;\n-\n   if (! IS_AGGR_TYPE (type) || ! TYPE_NEEDS_DESTRUCTOR (type))\n     {\n       loop = integer_zero_node;\n@@ -3049,6 +3048,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n       iterator = get_temp_regvar (ptrdiff_type_node, maxindex);\n \n     init_by_default:\n+      itype = NULL_TREE;\n \n       /* If initializing one array from another,\n \t initialize element by element.  */"}, {"sha": "2960d24b9fe8bde663a2550490871167b32694c7", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -62,7 +62,16 @@ extern double atof ();\n #ifdef HAVE_STRING_H\n #include <string.h>\n #else\n+#ifdef HAVE_STRINGS_H\n+#include <strings.h>\n+#endif\n+#endif\n+\n+#ifdef NEED_DECLARATION_INDEX\n extern char *index ();\n+#endif\n+\n+#ifdef NEED_DECLARATION_RINDEX\n extern char *rindex ();\n #endif\n \n@@ -1675,8 +1684,6 @@ reinit_parse_for_expr (obstackp)\n   int starting_lineno = lineno;\n   char *starting_filename = input_filename;\n   int len;\n-  int look_for_semicolon = 0;\n-  int look_for_lbrac = 0;\n   int plev = 0;\n \n   if (nextchar != EOF)\n@@ -1936,7 +1943,7 @@ cons_up_default_function (type, full_name, kind)\n {\n   extern tree void_list_node;\n   tree declspecs = NULL_TREE;\n-  tree fn, args;\n+  tree fn, args = NULL_TREE;\n   tree argtype;\n   int retref = 0;\n   tree name = constructor_name (full_name);\n@@ -2612,7 +2619,7 @@ readescape (ignore_ptr)\n   register int c = getch ();\n   register int code;\n   register unsigned count;\n-  unsigned firstdig;\n+  unsigned firstdig = 0;\n   int nonnull;\n \n   switch (c)\n@@ -3218,7 +3225,7 @@ real_yylex ()\n \t{\n \t  register struct resword *ptr;\n \n-\t  if (ptr = is_reserved_word (token_buffer, p - token_buffer))\n+\t  if ((ptr = is_reserved_word (token_buffer, p - token_buffer)))\n \t    {\n \t      if (ptr->rid)\n \t\t{"}, {"sha": "30ddf5227e7e2d9e4b0f16dc20e218bbfce56b53", "filename": "gcc/cp/method.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -42,6 +42,12 @@ Boston, MA 02111-1307, USA.  */\n #ifdef HAVE_STRING_H\n #include <string.h>\n #else\n+#ifdef HAVE_STRINGS_H\n+#include <strings.h>\n+#endif\n+#endif\n+\n+#ifdef NEED_DECLARATION_INDEX\n extern char *index ();\n #endif\n "}, {"sha": "c72cc082cbab48f2898cfc14f8292d7ca95b4577", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -5192,21 +5192,23 @@ case 281:\n \t\t  if (TREE_CODE (yyval.ttype) == BIT_NOT_EXPR)\n \t\t    yyval.ttype = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND (yyval.ttype, 0));\n \t\t  else if (TREE_CODE (yyval.ttype) != TEMPLATE_ID_EXPR)\n-\t\t    if (processing_template_arg)\n-\t\t      {\n-\t\t\ttree id;\n-\t\t\targ_looking_for_template = processing_template_arg;\n-\t\t\tid = lookup_name (yyval.ttype, 0);\n-\t\t\targ_looking_for_template = 0;\n+\t\t    {\n+\t\t      if (processing_template_arg)\n+\t\t\t{\n+\t\t\t  tree id;\n+\t\t\t  arg_looking_for_template = processing_template_arg;\n+\t\t\t  id = lookup_name (yyval.ttype, 0);\n+\t\t\t  arg_looking_for_template = 0;\n \t\t\t\n-\t\t\tif (!id || id == error_mark_node\n-\t\t\t    || (TREE_CODE (id) != TEMPLATE_DECL\n-\t\t\t\t&& TREE_CODE (id) != TEMPLATE_TEMPLATE_PARM))\n-\t\t\t  id = do_identifier (yyval.ttype, 1);\n-\t\t\tyyval.ttype = id;\n-\t\t      } \n-\t\t    else\n-\t\t      yyval.ttype = do_identifier (yyval.ttype, 1);\n+\t\t\t  if (!id || id == error_mark_node\n+\t\t\t      || (TREE_CODE (id) != TEMPLATE_DECL\n+\t\t\t\t  && TREE_CODE (id) != TEMPLATE_TEMPLATE_PARM))\n+\t\t\t    id = do_identifier (yyval.ttype, 1);\n+\t\t\t  yyval.ttype = id;\n+\t\t\t} \n+\t\t      else\n+\t\t\tyyval.ttype = do_identifier (yyval.ttype, 1);\n+\t\t    }\n \t\t;\n     break;}\n case 284:\n@@ -5343,7 +5345,7 @@ case 295:\n case 296:\n #line 1511 \"parse.y\"\n {\n-\t\t  tree type;\n+\t\t  tree type = NULL_TREE;\n \t\t  tree id = yyval.ttype;\n \n \t\t  /* This is a C cast in C++'s `functional' notation.  */\n@@ -6178,7 +6180,6 @@ case 453:\n #line 2307 \"parse.y\"\n {\n \t\t  int semi;\n-\t\t  tree id;\n \n \t\t  yyval.ttype = yyvsp[-4].ttype;\n #if 0"}, {"sha": "45e14a7507cfb97b3d5a5873011aeeff349697c9", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -1381,21 +1381,23 @@ primary:\n \t\t  if (TREE_CODE ($$) == BIT_NOT_EXPR)\n \t\t    $$ = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND ($$, 0));\n \t\t  else if (TREE_CODE ($$) != TEMPLATE_ID_EXPR)\n-\t\t    if (processing_template_arg)\n-\t\t      {\n-\t\t\ttree id;\n-\t\t\targ_looking_for_template = processing_template_arg;\n-\t\t\tid = lookup_name ($$, 0);\n-\t\t\targ_looking_for_template = 0;\n+\t\t    {\n+\t\t      if (processing_template_arg)\n+\t\t\t{\n+\t\t\t  tree id;\n+\t\t\t  arg_looking_for_template = processing_template_arg;\n+\t\t\t  id = lookup_name ($$, 0);\n+\t\t\t  arg_looking_for_template = 0;\n \t\t\t\n-\t\t\tif (!id || id == error_mark_node\n-\t\t\t    || (TREE_CODE (id) != TEMPLATE_DECL\n-\t\t\t\t&& TREE_CODE (id) != TEMPLATE_TEMPLATE_PARM))\n-\t\t\t  id = do_identifier ($$, 1);\n-\t\t\t$$ = id;\n-\t\t      } \n-\t\t    else\n-\t\t      $$ = do_identifier ($$, 1);\n+\t\t\t  if (!id || id == error_mark_node\n+\t\t\t      || (TREE_CODE (id) != TEMPLATE_DECL\n+\t\t\t\t  && TREE_CODE (id) != TEMPLATE_TEMPLATE_PARM))\n+\t\t\t    id = do_identifier ($$, 1);\n+\t\t\t  $$ = id;\n+\t\t\t} \n+\t\t      else\n+\t\t\t$$ = do_identifier ($$, 1);\n+\t\t    }\n \t\t}\t\t\n \t| CONSTANT\n \t| boolean.literal\n@@ -1509,7 +1511,7 @@ primary:\n \t\t}\n \t| CV_QUALIFIER '(' nonnull_exprlist ')'\n \t\t{\n-\t\t  tree type;\n+\t\t  tree type = NULL_TREE;\n \t\t  tree id = $$;\n \n \t\t  /* This is a C cast in C++'s `functional' notation.  */\n@@ -2306,7 +2308,6 @@ structsp:\n           opt.component_decl_list '}' maybe_attribute\n \t\t{\n \t\t  int semi;\n-\t\t  tree id;\n \n \t\t  $<ttype>$ = $1;\n #if 0"}, {"sha": "ba1d884e38e07abdb097c2a6ce3268db75e9dce3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -1742,31 +1742,33 @@ coerce_template_parms (parms, arglist, in_decl,\n     }\n \n   if (arglist && TREE_CODE (arglist) == TREE_VEC)\n-    if (nargs == nparms)\n-      vec = copy_node (arglist);\n-    else\n-      {\n-\t/* We arrive here when a template with some default arguments\n-\t   is used as template template argument.  */\n-\tis_tmpl_parm = 1;\n-\tvec = make_tree_vec (nparms);\n-\tfor (i = 0; i < nparms; i++)\n-\t  {\n-\t    tree arg;\n-\n-\t    if (i < nargs)\n+    {\n+      if (nargs == nparms)\n+\tvec = copy_node (arglist);\n+      else\n+\t{\n+\t  /* We arrive here when a template with some default arguments\n+\t     is used as template template argument.  */\n+\t  is_tmpl_parm = 1;\n+\t  vec = make_tree_vec (nparms);\n+\t  for (i = 0; i < nparms; i++)\n+\t    {\n+\t      tree arg;\n+\t      \n+\t      if (i < nargs)\n \t      arg = TREE_VEC_ELT (arglist, i);\n-\t    else if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (parms, i)))\n-\t\t     == TYPE_DECL)\n-\t      arg = tsubst (TREE_PURPOSE (TREE_VEC_ELT (parms, i)),\n-\t\t\t    vec, i, in_decl);\n-\t    else\n-\t      arg = tsubst_expr (TREE_PURPOSE (TREE_VEC_ELT (parms, i)),\n-\t\t\t\t vec, i, in_decl);\n-\n-\t    TREE_VEC_ELT (vec, i) = arg;\n-\t  }\n-      }\n+\t      else if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (parms, i)))\n+\t\t       == TYPE_DECL)\n+\t\targ = tsubst (TREE_PURPOSE (TREE_VEC_ELT (parms, i)),\n+\t\t\t      vec, i, in_decl);\n+\t      else\n+\t\targ = tsubst_expr (TREE_PURPOSE (TREE_VEC_ELT (parms, i)),\n+\t\t\t\t   vec, i, in_decl);\n+\t      \n+\t      TREE_VEC_ELT (vec, i) = arg;\n+\t    }\n+\t}\n+    }\n   else\n     {\n       vec = make_tree_vec (nparms);\n@@ -2213,7 +2215,7 @@ lookup_template_class (d1, arglist, in_decl, context)\n      tree in_decl;\n      tree context;\n {\n-  tree template, parmlist;\n+  tree template = NULL_TREE, parmlist;\n   char *mangled_name;\n   tree id, t;\n \n@@ -2819,14 +2821,13 @@ instantiate_class_template (type)\n \n   for (t = CLASSTYPE_TAGS (pattern); t; t = TREE_CHAIN (t))\n     {\n-      tree name = TREE_PURPOSE (t);\n       tree tag = TREE_VALUE (t);\n \n       /* These will add themselves to CLASSTYPE_TAGS for the new type.  */\n       if (TREE_CODE (tag) == ENUMERAL_TYPE)\n \t{\n-\t  tree e, newtag = tsubst_enum (tag, args, \n-\t\t\t\t\tTREE_VEC_LENGTH (args), field_chain);\n+\t  tree newtag =\n+\t    tsubst_enum (tag, args, TREE_VEC_LENGTH (args), field_chain);\n \n \t  while (*field_chain)\n \t    {\n@@ -3190,7 +3191,6 @@ tsubst (t, args, nargs, in_decl)\n \ttree new_decl;\n \ttree parms;\n \ttree spec;\n-\tint i;\n \n \t/* We might already have an instance of this template. */\n \tspec = retrieve_specialization (t, args);\n@@ -3785,7 +3785,7 @@ tsubst (t, args, nargs, in_decl)\n \t    /* This should probably be rewritten to use hash_tree_cons for\n                the memory savings.  */\n \t    tree first = NULL_TREE;\n-\t    tree last;\n+\t    tree last = NULL_TREE;\n \n \t    for (; values && values != void_list_node;\n \t\t values = TREE_CHAIN (values))\n@@ -3934,7 +3934,7 @@ tree\n do_poplevel ()\n {\n   tree t;\n-  int saved_warn_unused;\n+  int saved_warn_unused = 0;\n \n   if (processing_template_decl)\n     {\n@@ -4652,7 +4652,6 @@ type_unification (tparms, targs, parms, args, targs_in, nsubsts,\n {\n   int ntparms = TREE_VEC_LENGTH (tparms);\n   tree arg;\n-  tree parm;\n   int i;\n   int r;\n \n@@ -4937,7 +4936,7 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \t    tree argvec = CLASSTYPE_TI_ARGS (arg);\n \t    tree argtmplvec\n \t      = DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (arg));\n-\t    int i, j;\n+\t    int i;\n \n \t    /* The parameter and argument roles have to be switched here \n \t       in order to handle default arguments properly.  For example, "}, {"sha": "27a1f4dda316d499814a540373fb10ac900c01b0", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -336,7 +336,7 @@ init_repo (filename)\n   if (repo_file == 0)\n     return;\n \n-  while (buf = afgets (repo_file))\n+  while ((buf = afgets (repo_file)))\n     {\n       switch (buf[0])\n \t{\n@@ -396,7 +396,6 @@ void\n finish_repo ()\n {\n   tree t;\n-  char *p;\n   int repo_changed = 0;\n   char *dir, *args;\n "}, {"sha": "b059fbdb589d658f875bb5e8d60eb5265b0360b7", "filename": "gcc/cp/search.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -545,7 +545,7 @@ get_binfo (parent, binfo, protect)\n      register tree parent, binfo;\n      int protect;\n {\n-  tree type;\n+  tree type = NULL_TREE;\n   int dist;\n   tree rval = NULL_TREE;\n   \n@@ -716,7 +716,7 @@ get_base_distance (parent, binfo, protect, path_ptr)\n {\n   int rval;\n   int rval_private = 0;\n-  tree type;\n+  tree type = NULL_TREE;\n   tree new_binfo = NULL_TREE;\n   int via_virtual;\n   int watch_access = protect;\n@@ -1154,8 +1154,8 @@ lookup_field (xbasetype, name, protect, want_type)\n      int protect, want_type;\n {\n   int head = 0, tail = 0;\n-  tree rval, rval_binfo = NULL_TREE, rval_binfo_h;\n-  tree type, basetype_chain, basetype_path;\n+  tree rval, rval_binfo = NULL_TREE, rval_binfo_h = NULL_TREE;\n+  tree type = NULL_TREE, basetype_chain, basetype_path = NULL_TREE;\n   tree this_v = access_default_node;\n   tree entry, binfo, binfo_h;\n   tree own_access = access_default_node;\n@@ -1470,7 +1470,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \t    /* If is possible for one of the derived types on the path to\n \t       have defined special access for this field.  Look for such\n \t       declarations and report an error if a conflict is found.  */\n-\t    tree new_v;\n+\t    tree new_v = NULL_TREE;\n \n \t    if (this_v != access_default_node)\n \t      new_v = compute_access (TREE_VALUE (TREE_CHAIN (*tp)), rval);\n@@ -1689,8 +1689,8 @@ lookup_fnfields (basetype_path, name, complain)\n      int complain;\n {\n   int head = 0, tail = 0;\n-  tree type, rval, rval_binfo = NULL_TREE, rvals = NULL_TREE, rval_binfo_h;\n-  tree entry, binfo, basetype_chain, binfo_h;\n+  tree type, rval, rval_binfo = NULL_TREE, rvals = NULL_TREE;\n+  tree rval_binfo_h = NULL_TREE, entry, binfo, basetype_chain, binfo_h;\n   int find_all = 0;\n \n   /* rval_binfo is the binfo associated with the found member, note,\n@@ -2034,7 +2034,7 @@ breadth_first_search (binfo, testfn, qfn)\n \n       binfo = search_stack->first[head++];\n       i = (HOST_WIDE_INT) search_stack->first[head++];\n-      if (rval = (*testfn) (binfo, i))\n+      if ((rval = (*testfn) (binfo, i)))\n \tbreak;\n       binfo = BINFO_BASETYPE (binfo, i);\n     }\n@@ -3768,7 +3768,7 @@ tree\n get_template_base (template, binfo)\n      register tree template, binfo;\n {\n-  tree type, rval;\n+  tree type = NULL_TREE, rval;\n \n   if (TREE_CODE (binfo) == TREE_VEC)\n     type = BINFO_TYPE (binfo);"}, {"sha": "72eb314aeb231aaf177ff36244a6cf97f0016a6e", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -350,7 +350,7 @@ append_signature_fields (list_of_fieldlists)\n   tree l, x;\n   tree last_x = NULL_TREE;\n   tree mfptr;\n-  tree last_mfptr;\n+  tree last_mfptr = NULL_TREE;\n   tree mfptr_list = NULL_TREE;\n \t      \n   /* For signatures it should actually be only a list with one element.  */\n@@ -461,7 +461,7 @@ build_signature_table_constructor (sig_ty, rhs)\n   tree sig_field = TYPE_FIELDS (sig_ty);\n   tree result = NULL_TREE;\n   tree first_rhs_field = NULL_TREE;\n-  tree last_rhs_field;\n+  tree last_rhs_field = NULL_TREE;\n   int sig_ptr_p = IS_SIGNATURE (rhstype);\n   int offset_p = sig_ptr_p;\n \n@@ -574,7 +574,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \t}\n       else\n \t{\n-\t  tree tag, vb_off, delta, idx, pfn, vt_off;\n+\t  tree tag, vb_off, delta, idx, pfn = NULL_TREE, vt_off = NULL_TREE;\n \t  tree tag_decl, vb_off_decl, delta_decl, index_decl;\n \t  tree pfn_decl, vt_off_decl;\n \n@@ -724,7 +724,7 @@ build_sigtable (sig_type, rhs_type, init_from)\n     }\n   if (decl == NULL_TREE)\n     {\n-      tree init;\n+      tree init = NULL_TREE;\n \n       /* We allow only one signature table to be generated for signatures\n \t with opaque types.  Otherwise we create a loophole in the type"}, {"sha": "bfe25991465e046e1d1d9a27f5b66de0cfbc77eb", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -323,7 +323,7 @@ tree\n break_out_calls (exp)\n      tree exp;\n {\n-  register tree t1, t2;\n+  register tree t1, t2 = NULL_TREE;\n   register enum tree_code code;\n   register int changed = 0;\n   register int i;\n@@ -574,7 +574,7 @@ propagate_binfo_offsets (binfo, offset)\n \t{\n \t  int j;\n \t  tree base_binfos = BINFO_BASETYPES (base_binfo);\n-\t  tree delta;\n+\t  tree delta = NULL_TREE;\n \n \t  for (j = i+1; j < n_baselinks; j++)\n \t    if (! TREE_VIA_VIRTUAL (TREE_VEC_ELT (binfos, j)))\n@@ -1046,7 +1046,7 @@ hash_tree_cons (via_public, via_virtual, via_protected, purpose, value, chain)\n {\n   struct obstack *ambient_obstack = current_obstack;\n   tree t;\n-  int hashcode;\n+  int hashcode = 0;\n \n   if (! debug_no_list_hash)\n     {\n@@ -1928,7 +1928,7 @@ can_free (obstack, t)\n      struct obstack *obstack;\n      tree t;\n {\n-  int size;\n+  int size = 0;\n \n   if (TREE_CODE (t) == TREE_VEC)\n     size = (TREE_VEC_LENGTH (t)-1) * sizeof (tree) + sizeof (struct tree_vec);\n@@ -1997,10 +1997,12 @@ cp_tree_equal (t1, t2)\n   code2 = TREE_CODE (t2);\n \n   if (code1 == NOP_EXPR || code1 == CONVERT_EXPR || code1 == NON_LVALUE_EXPR)\n-    if (code2 == NOP_EXPR || code2 == CONVERT_EXPR || code2 == NON_LVALUE_EXPR)\n-      return cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n-    else\n-      return cp_tree_equal (TREE_OPERAND (t1, 0), t2);\n+    {\n+      if (code2 == NOP_EXPR || code2 == CONVERT_EXPR || code2 == NON_LVALUE_EXPR)\n+\treturn cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+      else\n+\treturn cp_tree_equal (TREE_OPERAND (t1, 0), t2);\n+    }\n   else if (code2 == NOP_EXPR || code2 == CONVERT_EXPR\n \t   || code2 == NON_LVALUE_EXPR)\n     return cp_tree_equal (t1, TREE_OPERAND (t2, 0));"}, {"sha": "f401d68a1e3eb888a2ca87873057ec38dc0ca6c6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -56,7 +56,9 @@ static int comp_array_types PROTO((int (*) (tree, tree, int), tree,\n \t\t\t\t   tree, int));\n static tree build_ptrmemfunc1 PROTO((tree, tree, tree, tree, tree));\n static tree common_base_type PROTO((tree, tree));\n+#if 0\n static tree convert_sequence PROTO((tree, tree));\n+#endif\n static tree lookup_anon_field PROTO((tree, tree));\n static tree pointer_diff PROTO((tree, tree, tree));\n static tree qualify_type PROTO((tree, tree));\n@@ -327,25 +329,27 @@ common_type (t1, t2)\n     /* One that completely contains the other?  Take it.  */\n \n     else if (a2 && !attribute_list_contained (a1, a2))\n-       if (attribute_list_contained (a2, a1))\n+      {\n+\tif (attribute_list_contained (a2, a1))\n \t  attributes = a2;\n-       else\n-\t{\n-\t  /* Pick the longest list, and hang on the other list.  */\n-\t  /* ??? For the moment we punt on the issue of attrs with args.  */\n+\telse\n+\t  {\n+\t    /* Pick the longest list, and hang on the other list.  */\n+\t    /* ??? For the moment we punt on the issue of attrs with args.  */\n \t\n-\t  if (list_length (a1) < list_length (a2))\n-\t     attributes = a2, a2 = a1;\n+\t    if (list_length (a1) < list_length (a2))\n+\t      attributes = a2, a2 = a1;\n \n-\t  for (; a2; a2 = TREE_CHAIN (a2))\n-\t    if (lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n-\t\t\t\t  attributes) == NULL_TREE)\n-\t      {\n-\t\ta1 = copy_node (a2);\n-\t\tTREE_CHAIN (a1) = attributes;\n-\t\tattributes = a1;\n-\t      }\n-\t}\n+\t    for (; a2; a2 = TREE_CHAIN (a2))\n+\t      if (lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n+\t\t\t\t    attributes) == NULL_TREE)\n+\t\t{\n+\t\t  a1 = copy_node (a2);\n+\t\t  TREE_CHAIN (a1) = attributes;\n+\t\t  attributes = a1;\n+\t\t}\n+\t  }\n+      }\n   }\n \n   /* Treat an enum type as the unsigned integer type of the same width.  */\n@@ -966,21 +970,22 @@ comp_target_types (ttl, ttr, nptrs)\n   if (TREE_CODE (ttr) == ARRAY_TYPE)\n     return comp_array_types (comp_target_types, ttl, ttr, 0);\n   else if (TREE_CODE (ttr) == FUNCTION_TYPE || TREE_CODE (ttr) == METHOD_TYPE)\n-    if (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), -1))\n-      switch (comp_target_parms (TYPE_ARG_TYPES (ttl), TYPE_ARG_TYPES (ttr), 1))\n-\t{\n-\tcase 0:\n-\t  return 0;\n-\tcase 1:\n-\t  return 1;\n-\tcase 2:\n-\t  return -1;\n-\tdefault:\n-\t  my_friendly_abort (112);\n-\t}\n-    else\n-      return 0;\n-\n+    {\n+      if (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), -1))\n+\tswitch (comp_target_parms (TYPE_ARG_TYPES (ttl), TYPE_ARG_TYPES (ttr), 1))\n+\t  {\n+\t  case 0:\n+\t    return 0;\n+\t  case 1:\n+\t    return 1;\n+\t  case 2:\n+\t    return -1;\n+\t  default:\n+\t    my_friendly_abort (112);\n+\t  }\n+      else\n+\treturn 0;\n+    }\n   /* for C++ */\n   else if (TREE_CODE (ttr) == OFFSET_TYPE)\n     {\n@@ -2521,7 +2526,7 @@ build_x_function_call (function, params, decl)\n   if (is_method)\n     {\n       tree fntype = TREE_TYPE (function);\n-      tree ctypeptr;\n+      tree ctypeptr = NULL_TREE;\n \n       /* Explicitly named method?  */\n       if (TREE_CODE (function) == FUNCTION_DECL)\n@@ -2746,10 +2751,12 @@ build_function_call_real (function, params, require_complete, flags)\n \t\t\t\t\tparams, fndecl, 0);\n \n   if (coerced_params == error_mark_node)\n-    if (flags & LOOKUP_SPECULATIVELY)\n-      return NULL_TREE;\n-    else\n-      return error_mark_node;\n+    {\n+      if (flags & LOOKUP_SPECULATIVELY)\n+\treturn NULL_TREE;\n+      else\n+\treturn error_mark_node;\n+    }\n \n   /* Check for errors in format strings.  */\n \n@@ -2831,7 +2838,7 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n {\n   register tree typetail, valtail;\n   register tree result = NULL_TREE;\n-  char *called_thing;\n+  char *called_thing = 0;\n   int i = 0;\n \n   if (! flag_elide_constructors)\n@@ -7048,7 +7055,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n     {\n       /* This should eventually happen in convert_arguments.  */\n       extern int warningcount, errorcount;\n-      int savew, savee;\n+      int savew = 0, savee = 0;\n \n       if (fndecl)\n \tsavew = warningcount, savee = errorcount;"}, {"sha": "c460f45652690f9a29f24350b942717424b7e841", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -208,7 +208,7 @@ incomplete_type_error (value, type)\n      tree value;\n      tree type;\n {\n-  char *errmsg;\n+  char *errmsg = 0;\n \n   /* Avoid duplicate error message.  */\n   if (TREE_CODE (type) == ERROR_MARK)\n@@ -685,7 +685,7 @@ digest_init (type, init, tail)\n {\n   enum tree_code code = TREE_CODE (type);\n   tree element = NULL_TREE;\n-  tree old_tail_contents;\n+  tree old_tail_contents = NULL_TREE;\n   /* Nonzero if INIT is a braced grouping, which comes in as a CONSTRUCTOR\n      tree node which has no TREE_TYPE.  */\n   int raw_constructor;\n@@ -1265,7 +1265,7 @@ build_x_arrow (datum)\n   tree types_memoized = NULL_TREE;\n   register tree rval = datum;\n   tree type = TREE_TYPE (rval);\n-  tree last_rval;\n+  tree last_rval = NULL_TREE;\n \n   if (type == error_mark_node)\n     return error_mark_node;"}, {"sha": "c3c35de7f4ab5a4bdea6fa48296ce9dcbc327828", "filename": "gcc/cp/xref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a703fb388ba235e449aad17c618d50fe48a03812/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=a703fb388ba235e449aad17c618d50fe48a03812", "patch": "@@ -337,7 +337,7 @@ GNU_xref_decl (fndecl,decl)\n    tree decl;\n {\n   XREF_FILE xf,xf1;\n-  char *cls;\n+  char *cls = 0;\n   char *name;\n   char buf[10240];\n   int uselin;"}]}