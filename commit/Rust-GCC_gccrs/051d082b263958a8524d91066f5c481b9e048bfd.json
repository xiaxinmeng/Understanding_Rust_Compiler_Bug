{"sha": "051d082b263958a8524d91066f5c481b9e048bfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUxZDA4MmIyNjM5NThhODUyNGQ5MTA2NmY1YzQ4MWI5ZTA0OGJmZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-04-21T20:12:05Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-04-21T20:12:05Z"}, "message": "PipedInputStream.java, [...]: New version from Classpath.\n\n\t* java/io/PipedInputStream.java, java/io/PipedReader.java,\n\tjava/io/PipedOutputStream.java, java/io/PipedWriter.java: New\n\tversion from Classpath.\n\nFrom-SVN: r33316", "tree": {"sha": "aed131c09e0d570c468634b5a8b519f8092e5501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aed131c09e0d570c468634b5a8b519f8092e5501"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/051d082b263958a8524d91066f5c481b9e048bfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051d082b263958a8524d91066f5c481b9e048bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/051d082b263958a8524d91066f5c481b9e048bfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051d082b263958a8524d91066f5c481b9e048bfd/comments", "author": null, "committer": null, "parents": [{"sha": "473e7b07f16b5099ecb3b788fa47da773974d8bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473e7b07f16b5099ecb3b788fa47da773974d8bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/473e7b07f16b5099ecb3b788fa47da773974d8bc"}], "stats": {"total": 455, "additions": 214, "deletions": 241}, "files": [{"sha": "305d1d3eed5060e8a97dff2da19b6dc5563d92fb", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051d082b263958a8524d91066f5c481b9e048bfd/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051d082b263958a8524d91066f5c481b9e048bfd/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=051d082b263958a8524d91066f5c481b9e048bfd", "patch": "@@ -1,5 +1,9 @@\n 2000-04-21  Tom Tromey  <tromey@cygnus.com>\n \n+\t* java/io/PipedInputStream.java, java/io/PipedReader.java,\n+\tjava/io/PipedOutputStream.java, java/io/PipedWriter.java: New\n+\tversion from Classpath.\n+\n \tFix for PR libgcj/213:\n \t* Makefile.in: Rebuilt.\n \t* Makefile.am (gij_SOURCES): Added gij.cc."}, {"sha": "97c034bd11b781eab43fe9e66c07b370fa6daf4a", "filename": "libjava/java/io/PipedInputStream.java", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051d082b263958a8524d91066f5c481b9e048bfd/libjava%2Fjava%2Fio%2FPipedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051d082b263958a8524d91066f5c481b9e048bfd/libjava%2Fjava%2Fio%2FPipedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedInputStream.java?ref=051d082b263958a8524d91066f5c481b9e048bfd", "patch": "@@ -1,5 +1,5 @@\n /* PipedInputStream.java -- Input stream that reads from an output stream\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -67,23 +67,10 @@ public class PipedInputStream extends InputStream\n   */\n private static int pipe_size;\n \n-/**\n-  * This variable indicates whether or not the <code>read()</code> method will attempt\n-  * return a short count if this will possibly keep the stream from blocking.  \n-  * The default for this is <code>false</code> because that is what what the JDK seems\n-  * to imply in its javadocs.  We set this to <code>false</code> if the system \n-  * property <code>gnu.java.io.try_not_to_block</code> is set.\n-  */\n-private static boolean try_not_to_block = false;\n-\n static\n {\n   pipe_size = Integer.getInteger(\"gnu.java.io.PipedInputStream.pipe_size\",\n                                  PIPE_SIZE).intValue();\n-\n-  String block_prop = System.getProperty(\"gnu.java.io.try_not_to_block\");\n-  if (block_prop != null)\n-    try_not_to_block = true;\n }\n \n /*************************************************************************/\n@@ -373,9 +360,8 @@ else if (in > out)\n         return(bytes_read);\n \n       // Return a short count if necessary\n-      if (bytes_read < len)\n-        if (try_not_to_block)\n-           return(bytes_read);\n+      if (bytes_read > 0 && bytes_read < len)\n+\treturn(bytes_read);\n \n       // Handle the case where the end of stream was encountered.\n       if (closed)"}, {"sha": "f877a6a02eafd36fcdb1f130de08b971444ad9f2", "filename": "libjava/java/io/PipedReader.java", "status": "modified", "additions": 207, "deletions": 224, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051d082b263958a8524d91066f5c481b9e048bfd/libjava%2Fjava%2Fio%2FPipedReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051d082b263958a8524d91066f5c481b9e048bfd/libjava%2Fjava%2Fio%2FPipedReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedReader.java?ref=051d082b263958a8524d91066f5c481b9e048bfd", "patch": "@@ -1,5 +1,5 @@\n /* PipedReader.java -- Input stream that reads from an output stream\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -67,23 +67,10 @@ public class PipedReader extends Reader\n   */\n private static int pipe_size;\n \n-/**\n-  * This variable indicates whether or not the <code>read()</code> method will attempt\n-  * return a short count if this will possibly keep the stream from blocking.  \n-  * The default for this is <code>false</code> because that is what what the JDK seems\n-  * to imply in its javadocs.  We set this to <code>false</code> if the system \n-  * property <code>gnu.java.io.try_not_to_block</code> is set.\n-  */\n-private static boolean try_not_to_block = false;\n-\n static\n {\n   pipe_size =  Integer.getInteger(\"gnu.java.io.PipedReader.pipe_size\",\n                                   PIPE_SIZE).intValue();\n-\n-  String block_prop = System.getProperty(\"gnu.java.io.try_not_to_block\");\n-  if (block_prop != null)\n-    try_not_to_block = true;\n }\n \n /*************************************************************************/\n@@ -192,13 +179,12 @@ public class PipedReader extends Reader\n   if (closed)\n     throw new IOException(\"Stream is closed and cannot be reopened\");\n \n-  synchronized (lock) {\n-\n-  src.connect(this);\n-\n-  ever_connected = true;\n+  synchronized (lock)\n+    {\n+      src.connect(this);\n \n-  } // synchronized\n+      ever_connected = true;\n+    } // synchronized\n }\n \n /*************************************************************************/\n@@ -212,12 +198,11 @@ public class PipedReader extends Reader\n public void\n close() throws IOException\n {\n-  synchronized (lock) {\n-\n-  closed = true;\n-  notifyAll();\n-\n-  } // synchronized\n+  synchronized (lock)\n+    {\n+      closed = true;\n+      notifyAll();\n+    } // synchronized\n }\n \n /*************************************************************************/\n@@ -290,118 +275,116 @@ public class PipedReader extends Reader\n   if (!ever_connected)\n     throw new IOException(\"Not connected\"); \n \n-  synchronized (lock) {\n-\n-  int chars_read = 0;\n-  for (;;)\n+  synchronized (lock)\n     {\n-      // If there are chars, take them\n-      if (in != -1)\n-        {\n-          int desired_chars = len - chars_read;\n-\n-          // We are in a \"wrap\" condition\n-          if (out > in)\n-            {\n-              if (desired_chars > (pipe_size - out))\n-                {\n-                  if (in == 0)\n-                    desired_chars = (pipe_size - out) - 1;\n-                  else\n-                    desired_chars = pipe_size - out;\n-\n-                  System.arraycopy(buffer, out, buf, offset + chars_read,\n-                                   desired_chars);\n-\n-                  chars_read += desired_chars;\n-                  out += desired_chars;\n-                  desired_chars = len - chars_read;\n-\n-                  if (out == pipe_size)\n-                    out = 0;\n-\n-                  notifyAll();\n-                }\n-              else\n-                {\n-                  if ((out + desired_chars) == in)\n-                    --desired_chars;\n-\n-                  if (((out + desired_chars) == pipe_size) && (in == 0)) \n-                    desired_chars = (pipe_size - out) - 1;\n-\n-                  System.arraycopy(buffer, out, buf, offset + chars_read,\n-                                   desired_chars); \n-\n-                  chars_read += desired_chars;\n-                  out += desired_chars;\n-                  desired_chars = len - chars_read;\n-\n-                  if (out == pipe_size)\n-                    out = 0;\n-\n-                  notifyAll();\n-                }\n-            }\n+      int chars_read = 0;\n+      for (;;)\n+\t{\n+\t  // If there are chars, take them\n+\t  if (in != -1)\n+\t    {\n+\t      int desired_chars = len - chars_read;\n+\n+\t      // We are in a \"wrap\" condition\n+\t      if (out > in)\n+\t\t{\n+\t\t  if (desired_chars > (pipe_size - out))\n+\t\t    {\n+\t\t      if (in == 0)\n+\t\t\tdesired_chars = (pipe_size - out) - 1;\n+\t\t      else\n+\t\t\tdesired_chars = pipe_size - out;\n+\n+\t\t      System.arraycopy(buffer, out, buf, offset + chars_read,\n+\t\t\t\t       desired_chars);\n+\n+\t\t      chars_read += desired_chars;\n+\t\t      out += desired_chars;\n+\t\t      desired_chars = len - chars_read;\n+\n+\t\t      if (out == pipe_size)\n+\t\t\tout = 0;\n+\n+\t\t      notifyAll();\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if ((out + desired_chars) == in)\n+\t\t\t--desired_chars;\n+\n+\t\t      if (((out + desired_chars) == pipe_size) && (in == 0)) \n+\t\t\tdesired_chars = (pipe_size - out) - 1;\n+\n+\t\t      System.arraycopy(buffer, out, buf, offset + chars_read,\n+\t\t\t\t       desired_chars); \n+\n+\t\t      chars_read += desired_chars;\n+\t\t      out += desired_chars;\n+\t\t      desired_chars = len - chars_read;\n+\n+\t\t      if (out == pipe_size)\n+\t\t\tout = 0;\n+\n+\t\t      notifyAll();\n+\t\t    }\n+\t\t}\n  \n-          // We are in a \"no wrap\" or condition (can also be fall through\n-          // from above\n-          if (in > out)\n-            {\n-              if (desired_chars >= ((in - out) - 1))\n-                desired_chars = (in - out) - 1;\n-\n-              System.arraycopy(buffer, out, buf, offset + chars_read, \n-                               desired_chars);\n-\n-              chars_read += desired_chars;\n-              out += desired_chars;\n-              desired_chars = len - chars_read;\n-\n-              if (out == pipe_size)\n-                out = 0;\n-\n-              notifyAll();\n-            }\n-        }\n-\n-      // If we are done, return\n-      if (chars_read == len)\n-        return(chars_read);\n-\n-      // Return a short count if necessary\n-      if (chars_read < len)\n-        if (try_not_to_block)\n-           return(chars_read);\n-\n-      // Handle the case where the end of stream was encountered.\n-      if (closed)\n-        {\n-          // We never let in == out so there might be one last char\n-          // available that we have not copied yet.\n-          if (in != -1)\n-            {\n-              buf[offset + chars_read] = buffer[out];\n-              in = -1;\n-              ++out;\n-              ++chars_read;\n-            }\n-\n-          if (chars_read != 0)\n-            return(chars_read);\n-          else\n-            return(-1);\n-        }\n-\n-      // Wait for a char to be read\n-      try\n-        {\n-          wait();\n-        }\n-      catch(InterruptedException e) { ; }\n-    } \n-\n-  } // synchronized\n+\t      // We are in a \"no wrap\" or condition (can also be fall through\n+\t      // from above\n+\t      if (in > out)\n+\t\t{\n+\t\t  if (desired_chars >= ((in - out) - 1))\n+\t\t    desired_chars = (in - out) - 1;\n+\n+\t\t  System.arraycopy(buffer, out, buf, offset + chars_read, \n+\t\t\t\t   desired_chars);\n+\n+\t\t  chars_read += desired_chars;\n+\t\t  out += desired_chars;\n+\t\t  desired_chars = len - chars_read;\n+\n+\t\t  if (out == pipe_size)\n+\t\t    out = 0;\n+\n+\t\t  notifyAll();\n+\t\t}\n+\t    }\n+\n+\t  // If we are done, return\n+\t  if (chars_read == len)\n+\t    return(chars_read);\n+\n+\t  // Return a short count if necessary\n+\t  if (chars_read > 0 && chars_read < len)\n+\t    return(chars_read);\n+\n+\t  // Handle the case where the end of stream was encountered.\n+\t  if (closed)\n+\t    {\n+\t      // We never let in == out so there might be one last char\n+\t      // available that we have not copied yet.\n+\t      if (in != -1)\n+\t\t{\n+\t\t  buf[offset + chars_read] = buffer[out];\n+\t\t  in = -1;\n+\t\t  ++out;\n+\t\t  ++chars_read;\n+\t\t}\n+\n+\t      if (chars_read != 0)\n+\t\treturn(chars_read);\n+\t      else\n+\t\treturn(-1);\n+\t    }\n+\n+\t  // Wait for a char to be read\n+\t  try\n+\t    {\n+\t      wait();\n+\t    }\n+\t  catch(InterruptedException e) { ; }\n+\t} \n+    } // synchronized\n }\n \n /*************************************************************************/\n@@ -424,95 +407,95 @@ public class PipedReader extends Reader\n   if (len <= 0)\n     return;\n \n-  synchronized (lock) {\n-\n-  int total_written = 0;\n-  while (total_written < len)\n+  synchronized (lock)\n     {\n-      // If we are not at the end of the buffer with out = 0\n-      if (!((in == (buffer.length - 1)) && (out == 0)))\n-        {\n-          // This is the \"no wrap\" situation\n-          if ((in - 1) >= out)\n-            {\n-              int chars_written = 0;\n-              if ((buffer.length - in) > (len - total_written))\n-                chars_written = (len - total_written);\n-              else if (out == 0)\n-                chars_written = (buffer.length - in) - 1;\n-              else \n-                chars_written = (buffer.length - in);\n-\n-              if (chars_written > 0) \n-                System.arraycopy(buf, offset + total_written, buffer, in, \n-                                 chars_written);\n-              total_written += chars_written;\n-              in += chars_written;\n-\n-              if (in == buffer.length)\n-                in = 0;\n-\n-              notifyAll();\n-            }\n-          // This is the \"wrap\" situtation\n-          if ((out > in) && (total_written != len))\n-            {\n-              int chars_written = 0;\n-\n-              // Do special processing if we are at the beginning\n-              if (in == -1)\n-                {\n-                  in = 0;\n-\n-                  if (buffer.length > len)\n-                    chars_written = len;\n-                  else\n-                    chars_written = buffer.length - 1;\n-                }\n-              else if (((out - in) - 1) < (len - total_written))\n-                {\n-                  chars_written = (out - in) - 1;\n-                }\n-              else\n-                {\n-                  chars_written = len - total_written;\n-                }\n-\n-              // If the buffer is full, wait for it to empty out\n-              if ((out - 1) == in)\n-                {\n-                  try\n-                    {         \n-                      wait(); \n-                    }\n-                  catch (InterruptedException e) \n-                    { \n-                      continue; \n-                    }\n-                }\n-\n-              System.arraycopy(buf, offset + total_written, buffer, in,\n-                               chars_written);\n-              total_written += chars_written;\n-              in += chars_written;\n-\n-              if (in == buffer.length)\n-                in = 0;\n-\n-              notifyAll();\n-            }\n-        }\n-      // Wait for some reads to occur before we write anything.\n-      else\n-        {\n-          try\n-            {\n-              wait();\n-            }\n-          catch (InterruptedException e) { ; }\n-        }\n-    }\n-  } // synchronized\n+      int total_written = 0;\n+      while (total_written < len)\n+\t{\n+\t  // If we are not at the end of the buffer with out = 0\n+\t  if (!((in == (buffer.length - 1)) && (out == 0)))\n+\t    {\n+\t      // This is the \"no wrap\" situation\n+\t      if ((in - 1) >= out)\n+\t\t{\n+\t\t  int chars_written = 0;\n+\t\t  if ((buffer.length - in) > (len - total_written))\n+\t\t    chars_written = (len - total_written);\n+\t\t  else if (out == 0)\n+\t\t    chars_written = (buffer.length - in) - 1;\n+\t\t  else \n+\t\t    chars_written = (buffer.length - in);\n+\n+\t\t  if (chars_written > 0) \n+\t\t    System.arraycopy(buf, offset + total_written, buffer, in, \n+\t\t\t\t     chars_written);\n+\t\t  total_written += chars_written;\n+\t\t  in += chars_written;\n+\n+\t\t  if (in == buffer.length)\n+\t\t    in = 0;\n+\n+\t\t  notifyAll();\n+\t\t}\n+\t      // This is the \"wrap\" situtation\n+\t      if ((out > in) && (total_written != len))\n+\t\t{\n+\t\t  int chars_written = 0;\n+\n+\t\t  // Do special processing if we are at the beginning\n+\t\t  if (in == -1)\n+\t\t    {\n+\t\t      in = 0;\n+\n+\t\t      if (buffer.length > len)\n+\t\t\tchars_written = len;\n+\t\t      else\n+\t\t\tchars_written = buffer.length - 1;\n+\t\t    }\n+\t\t  else if (((out - in) - 1) < (len - total_written))\n+\t\t    {\n+\t\t      chars_written = (out - in) - 1;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      chars_written = len - total_written;\n+\t\t    }\n+\n+\t\t  // If the buffer is full, wait for it to empty out\n+\t\t  if ((out - 1) == in)\n+\t\t    {\n+\t\t      try\n+\t\t\t{         \n+\t\t\t  wait(); \n+\t\t\t}\n+\t\t      catch (InterruptedException e) \n+\t\t\t{ \n+\t\t\t  continue; \n+\t\t\t}\n+\t\t    }\n+\n+\t\t  System.arraycopy(buf, offset + total_written, buffer, in,\n+\t\t\t\t   chars_written);\n+\t\t  total_written += chars_written;\n+\t\t  in += chars_written;\n+\n+\t\t  if (in == buffer.length)\n+\t\t    in = 0;\n+\n+\t\t  notifyAll();\n+\t\t}\n+\t    }\n+\t  // Wait for some reads to occur before we write anything.\n+\t  else\n+\t    {\n+\t      try\n+\t\t{\n+\t\t  wait();\n+\t\t}\n+\t      catch (InterruptedException e) { ; }\n+\t    }\n+\t}\n+    } // synchronized\n }\n \n } // class PipedReader"}]}