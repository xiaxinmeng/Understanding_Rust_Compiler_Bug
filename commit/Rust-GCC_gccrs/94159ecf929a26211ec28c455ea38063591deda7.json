{"sha": "94159ecf929a26211ec28c455ea38063591deda7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQxNTllY2Y5MjlhMjYyMTFlYzI4YzQ1NWVhMzgwNjM1OTFkZWRhNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-11-04T07:24:44Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-11-04T07:24:44Z"}, "message": "c-ada-spec.h (cpp_operation): Add IS_TRIVIAL.\n\nc-family/\n\t* c-ada-spec.h (cpp_operation): Add IS_TRIVIAL.\n\t(dump_ada_specs): Adjust prototype of second callback.\n\t* c-ada-spec.c (cpp_check): New global variable.\n\t(dump_ada_nodes): Remove cpp_check parameter and do not pass it down.\n\t(print_generic_ada_decl): Likewise.\n\t(has_static_fields): Change return type to bool and add guard.\n\t(has_nontrivial_methods): New predicate.\n\t(is_tagged_type): Change return type to bool.\n\t(separate_class_package): Call has_nontrivial_methods.\n\t(pp_ada_tree_identifier): Minor tweaks.\n\t(dump_ada_function_declaration): Adjust calls to dump_generic_ada_node.\n\t(dump_ada_array_domains): Likewise.\n\t(dump_ada_array_type): Likewise.\n\t(dump_template_types): Remove cpp_check parameter and do not pass it to\n\tdump_generic_ada_node.\n\t(dump_ada_template): Likewise.\n\t(dump_generic_ada_node): Remove cpp_check parameter and do not pass it\n\trecursively.\n\t(print_ada_methods): Change return type to integer.  Remove cpp_check\n\tparameter and do not pass it down.\n\t(dump_nested_types): Remove cpp_check parameter and do not pass it to\n\tdump_generic_ada_node.\n\t(print_ada_declaration): Likewise.  Test RECORD_OR_UNION_TYPE_P before\n\taccessing methods.\n\t(print_ada_struct_decl): Remove cpp_check parameter and do not pass it\n\tdown.  Use has_nontrivial_methods to recognize C++ classes.  Use return\n\tvalue of print_ada_methods.\n\t(dump_ads): Rename cpp_check parameter to check and adjust prototype.\n\tSet cpp_check to it before invoking dump_ada_nodes.\n\t(dump_ada_specs): Likewise.\ncp/\n\t* decl2.c (cpp_check): Change type of first parameter and deal with\n\tIS_TRIVIAL.\n\nFrom-SVN: r204344", "tree": {"sha": "0a4a887f309eb204b419aa7d22bdd10ddede977a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a4a887f309eb204b419aa7d22bdd10ddede977a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94159ecf929a26211ec28c455ea38063591deda7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94159ecf929a26211ec28c455ea38063591deda7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94159ecf929a26211ec28c455ea38063591deda7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94159ecf929a26211ec28c455ea38063591deda7/comments", "author": null, "committer": null, "parents": [{"sha": "846276fae10922d24c9be666e264aa8058384de4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/846276fae10922d24c9be666e264aa8058384de4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/846276fae10922d24c9be666e264aa8058384de4"}], "stats": {"total": 474, "additions": 247, "deletions": 227}, "files": [{"sha": "2a6223b5017d65f53d008af6142f19aa4f289750", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94159ecf929a26211ec28c455ea38063591deda7/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94159ecf929a26211ec28c455ea38063591deda7/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=94159ecf929a26211ec28c455ea38063591deda7", "patch": "@@ -1,3 +1,36 @@\n+2013-11-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-ada-spec.h (cpp_operation): Add IS_TRIVIAL.\n+\t(dump_ada_specs): Adjust prototype of second callback.\n+\t* c-ada-spec.c (cpp_check): New global variable.\n+\t(dump_ada_nodes): Remove cpp_check parameter and do not pass it down.\n+\t(print_generic_ada_decl): Likewise.\n+\t(has_static_fields): Change return type to bool and add guard.\n+\t(has_nontrivial_methods): New predicate.\n+\t(is_tagged_type): Change return type to bool.\n+\t(separate_class_package): Call has_nontrivial_methods.\n+\t(pp_ada_tree_identifier): Minor tweaks.\n+\t(dump_ada_function_declaration): Adjust calls to dump_generic_ada_node.\n+\t(dump_ada_array_domains): Likewise.\n+\t(dump_ada_array_type): Likewise.\n+\t(dump_template_types): Remove cpp_check parameter and do not pass it to\n+\tdump_generic_ada_node.\n+\t(dump_ada_template): Likewise.\n+\t(dump_generic_ada_node): Remove cpp_check parameter and do not pass it\n+\trecursively.\n+\t(print_ada_methods): Change return type to integer.  Remove cpp_check\n+\tparameter and do not pass it down.\n+\t(dump_nested_types): Remove cpp_check parameter and do not pass it to\n+\tdump_generic_ada_node.\n+\t(print_ada_declaration): Likewise.  Test RECORD_OR_UNION_TYPE_P before\n+\taccessing methods.\n+\t(print_ada_struct_decl): Remove cpp_check parameter and do not pass it\n+\tdown.  Use has_nontrivial_methods to recognize C++ classes.  Use return\n+\tvalue of print_ada_methods.\n+\t(dump_ads): Rename cpp_check parameter to check and adjust prototype.\n+\tSet cpp_check to it before invoking dump_ada_nodes.\n+\t(dump_ada_specs): Likewise.\n+\n 2013-11-03  Marek Polacek  <polacek@redhat.com>\n \n \t* c-ubsan.c: Don't include hash-table.h."}, {"sha": "3f325e77098776fb4734deaabacc6460726e0da0", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 203, "deletions": 224, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94159ecf929a26211ec28c455ea38063591deda7/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94159ecf929a26211ec28c455ea38063591deda7/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=94159ecf929a26211ec28c455ea38063591deda7", "patch": "@@ -46,32 +46,31 @@ along with GCC; see the file COPYING3.  If not see\n #endif /* HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG */\n \n /* Local functions, macros and variables.  */\n-static int dump_generic_ada_node (pretty_printer *, tree, tree,\n-\t\t\t\t  int (*)(tree, cpp_operation), int, int, bool);\n-static int print_ada_declaration (pretty_printer *, tree, tree,\n-\t\t\t\t  int (*cpp_check)(tree, cpp_operation), int);\n-static void print_ada_struct_decl (pretty_printer *, tree, tree,\n-\t\t\t\t   int (*cpp_check)(tree, cpp_operation), int,\n-\t\t\t\t   bool);\n+static int dump_generic_ada_node (pretty_printer *, tree, tree, int, int,\n+\t\t\t\t  bool);\n+static int print_ada_declaration (pretty_printer *, tree, tree, int);\n+static void print_ada_struct_decl (pretty_printer *, tree, tree, int, bool);\n static void dump_sloc (pretty_printer *buffer, tree node);\n static void print_comment (pretty_printer *, const char *);\n-static void print_generic_ada_decl (pretty_printer *, tree,\n-\t\t\t\t    int (*)(tree, cpp_operation), const char *);\n+static void print_generic_ada_decl (pretty_printer *, tree, const char *);\n static char *get_ada_package (const char *);\n-static void dump_ada_nodes (pretty_printer *, const char *,\n-\t\t\t    int (*)(tree, cpp_operation));\n+static void dump_ada_nodes (pretty_printer *, const char *);\n static void reset_ada_withs (void);\n static void dump_ada_withs (FILE *);\n static void dump_ads (const char *, void (*)(const char *),\n-\t\t      int (*)(tree, cpp_operation));\n+\t\t      int (*)(const_tree, cpp_operation));\n static char *to_ada_name (const char *, int *);\n static bool separate_class_package (tree);\n \n-#define INDENT(SPACE) do { \\\n-  int i; for (i = 0; i<SPACE; i++) pp_space (buffer); } while (0)\n+#define INDENT(SPACE) \\\n+  do { int i; for (i = 0; i<SPACE; i++) pp_space (buffer); } while (0)\n \n #define INDENT_INCR 3\n \n+/* Global hook used to perform C++ queries on nodes.  */\n+static int (*cpp_check) (const_tree, cpp_operation) = NULL;\n+\n+\n /* Given a cpp MACRO, compute the max length BUFFER_LEN of the macro, as well\n    as max length PARAM_LEN of arguments for fun_like macros, and also set\n    SUPPORTED to 0 if the macro cannot be mapped to an Ada construct.  */\n@@ -636,11 +635,10 @@ unmark_visited_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n }\n \n /* Dump nodes into PP relevant to SOURCE_FILE, as collected by previous calls\n-   to collect_ada_nodes.  CPP_CHECK is used to perform C++ queries on nodes.  */\n+   to collect_ada_nodes.  */\n \n static void\n-dump_ada_nodes (pretty_printer *pp, const char *source_file,\n-\t\tint (*cpp_check)(tree, cpp_operation))\n+dump_ada_nodes (pretty_printer *pp, const char *source_file)\n {\n   int i, j;\n   cpp_comment_table *comments;\n@@ -676,7 +674,7 @@ dump_ada_nodes (pretty_printer *pp, const char *source_file,\n \t  if (j == comments->count\n \t      || LOCATION_LINE (decl_sloc (to_dump[i], false))\n \t      <  LOCATION_LINE (comments->entries[j].sloc))\n-\t    print_generic_ada_decl (pp, to_dump[i++], cpp_check, source_file);\n+\t    print_generic_ada_decl (pp, to_dump[i++], source_file);\n \t  else\n \t    break;\n \t}\n@@ -736,18 +734,15 @@ print_comment (pretty_printer *pp, const char *comment)\n     pp_newline (pp);\n }\n \n-/* Prints declaration DECL to PP in Ada syntax. The current source file being\n-   handled is SOURCE_FILE, and CPP_CHECK is used to perform C++ queries on\n-   nodes.  */\n+/* Print declaration DECL to PP in Ada syntax.  The current source file being\n+   handled is SOURCE_FILE.  */\n \n static void\n-print_generic_ada_decl (pretty_printer *pp, tree decl,\n-\t\t\tint (*cpp_check)(tree, cpp_operation),\n-\t\t\tconst char* source_file)\n+print_generic_ada_decl (pretty_printer *pp, tree decl, const char *source_file)\n {\n   source_file_base = source_file;\n \n-  if (print_ada_declaration (pp, decl, 0, cpp_check, INDENT_INCR))\n+  if (print_ada_declaration (pp, decl, 0, INDENT_INCR))\n     {\n       pp_newline (pp);\n       pp_newline (pp);\n@@ -941,23 +936,25 @@ get_underlying_decl (tree type)\n \n /* Return whether TYPE has static fields.  */\n \n-static int\n+static bool\n has_static_fields (const_tree type)\n {\n   tree tmp;\n \n+  if (!type || !RECORD_OR_UNION_TYPE_P (type))\n+    return false;\n+\n   for (tmp = TYPE_FIELDS (type); tmp; tmp = TREE_CHAIN (tmp))\n-    {\n-      if (DECL_NAME (tmp) && TREE_STATIC (tmp))\n-\treturn true;\n-    }\n+    if (DECL_NAME (tmp) && TREE_STATIC (tmp))\n+      return true;\n+\n   return false;\n }\n \n /* Return whether TYPE corresponds to an Ada tagged type (has a dispatch\n    table).  */\n \n-static int\n+static bool\n is_tagged_type (const_tree type)\n {\n   tree tmp;\n@@ -972,6 +969,35 @@ is_tagged_type (const_tree type)\n   return false;\n }\n \n+/* Return whether TYPE has non-trivial methods, i.e. methods that do something\n+   for the objects of TYPE.  In C++, all classes have implicit special methods,\n+   e.g. constructors and destructors, but they can be trivial if the type is\n+   sufficiently simple.  */\n+\n+static bool\n+has_nontrivial_methods (const_tree type)\n+{\n+  tree tmp;\n+\n+  if (!type || !RECORD_OR_UNION_TYPE_P (type))\n+    return false;\n+\n+  /* Only C++ types can have methods.  */\n+  if (!cpp_check)\n+    return false;\n+\n+  /* A non-trivial type has non-trivial special methods.  */\n+  if (!cpp_check (type, IS_TRIVIAL))\n+    return true;\n+\n+  /* If there are user-defined methods, they are deemed non-trivial.  */\n+  for (tmp = TYPE_METHODS (type); tmp; tmp = TREE_CHAIN (tmp))\n+    if (!DECL_ARTIFICIAL (tmp))\n+      return true;\n+\n+  return false;\n+}\n+\n /* Generate a legal Ada name from a C NAME, returning a malloc'd string.\n    SPACE_FOUND, if not NULL, is used to indicate whether a space was found in\n    NAME.  */\n@@ -1193,15 +1219,8 @@ to_ada_name (const char *name, int *space_found)\n static bool\n separate_class_package (tree decl)\n {\n-  if (decl) \n-    {\n-      tree type = TREE_TYPE (decl);\n-      return type\n-\t&& TREE_CODE (type) == RECORD_TYPE\n-\t&& (TYPE_METHODS (type) || has_static_fields (type));\n-    }\n-  else\n-    return false;\n+  tree type = TREE_TYPE (decl);\n+  return has_nontrivial_methods (type) || has_static_fields (type);\n }\n \n static bool package_prefix = true;\n@@ -1221,7 +1240,6 @@ pp_ada_tree_identifier (pretty_printer *buffer, tree node, tree type,\n \n   /* If the entity is a type and comes from another file, generate \"package\"\n      prefix.  */\n-\n   decl = get_underlying_decl (type);\n \n   if (decl)\n@@ -1246,30 +1264,27 @@ pp_ada_tree_identifier (pretty_printer *buffer, tree node, tree type,\n \t\t  case UNION_TYPE:\n \t\t  case QUAL_UNION_TYPE:\n \t\t  case TYPE_DECL:\n-\t\t    {\n-\t\t      char *s1 = get_ada_package (xloc.file);\n-\n-\t\t      if (package_prefix)\n-\t\t\t{\n-\t\t\t  append_withs (s1, limited_access);\n-\t\t\t  pp_string (buffer, s1);\n-\t\t\t  pp_dot (buffer);\n-\t\t\t}\n-\t\t      free (s1);\n-\t\t    }\n+\t\t    if (package_prefix)\n+\t\t      {\n+\t\t\tchar *s1 = get_ada_package (xloc.file);\n+\t\t\tappend_withs (s1, limited_access);\n+\t\t\tpp_string (buffer, s1);\n+\t\t\tpp_dot (buffer);\n+\t\t\tfree (s1);\n+\t\t      }\n \t\t    break;\n \t\t  default:\n \t\t    break;\n \t\t}\n-              \n-              if (separate_class_package (decl))\n-                {\n-                  pp_string (buffer, \"Class_\");\n-                  pp_string (buffer, s);\n-                  pp_dot (buffer);\n-                }\n-\n-            }\n+\n+\t      /* Generate the additional package prefix for C++ classes.  */\n+\t      if (separate_class_package (decl))\n+\t\t{\n+\t\t  pp_string (buffer, \"Class_\");\n+\t\t  pp_string (buffer, s);\n+\t\t  pp_dot (buffer);\n+\t\t}\n+\t     }\n \t}\n     }\n \n@@ -1527,15 +1542,13 @@ dump_ada_function_declaration (pretty_printer *buffer, tree func,\n \t      pp_string (buffer, buf);\n \t    }\n \n-\t  dump_generic_ada_node\n-\t    (buffer, TREE_TYPE (arg), node, NULL, spc, 0, true);\n+\t  dump_generic_ada_node (buffer, TREE_TYPE (arg), node, spc, 0, true);\n \t}\n       else\n \t{\n \t  sprintf (buf, \"arg%d : \", num);\n \t  pp_string (buffer, buf);\n-\t  dump_generic_ada_node\n-\t    (buffer, TREE_VALUE (arg), node, NULL, spc, 0, true);\n+\t  dump_generic_ada_node (buffer, TREE_VALUE (arg), node, spc, 0, true);\n \t}\n \n       if (TREE_TYPE (arg) && TREE_TYPE (TREE_TYPE (arg))\n@@ -1593,13 +1606,13 @@ dump_ada_array_domains (pretty_printer *buffer, tree node, int spc)\n \t  first = 0;\n \n \t  if (min)\n-\t    dump_generic_ada_node (buffer, min, NULL_TREE, NULL, spc, 0, true);\n+\t    dump_generic_ada_node (buffer, min, NULL_TREE, spc, 0, true);\n \t  pp_string (buffer, \" .. \");\n \n \t  /* If the upper bound is zero, gcc may generate a NULL_TREE\n \t     for TYPE_MAX_VALUE rather than an integer_cst.  */\n \t  if (max)\n-\t    dump_generic_ada_node (buffer, max, NULL_TREE, NULL, spc, 0, true);\n+\t    dump_generic_ada_node (buffer, max, NULL_TREE, spc, 0, true);\n \t  else\n \t    pp_string (buffer, \"0\");\n \t}\n@@ -1687,18 +1700,16 @@ dump_ada_array_type (pretty_printer *buffer, tree t, int spc)\n \tpp_string (buffer, \"aliased \");\n \n       dump_generic_ada_node\n-\t(buffer, TREE_TYPE (tmp), TREE_TYPE (t), NULL, spc, false, true);\n+\t(buffer, TREE_TYPE (tmp), TREE_TYPE (t), spc, false, true);\n     }\n }\n \n /* Dump in BUFFER type names associated with a template, each prepended with\n-   '_'.  TYPES is the TREE_PURPOSE of a DECL_TEMPLATE_INSTANTIATIONS.\n-   CPP_CHECK is used to perform C++ queries on nodes.\n-   SPC is the indentation level.  */\n+   '_'.  TYPES is the TREE_PURPOSE of a DECL_TEMPLATE_INSTANTIATIONS.  SPC is\n+   the indentation level.  */\n \n static void\n-dump_template_types (pretty_printer *buffer, tree types,\n-\t\t     int (*cpp_check)(tree, cpp_operation), int spc)\n+dump_template_types (pretty_printer *buffer, tree types, int spc)\n {\n   size_t i;\n   size_t len = TREE_VEC_LENGTH (types);\n@@ -1707,7 +1718,7 @@ dump_template_types (pretty_printer *buffer, tree types,\n     {\n       tree elem = TREE_VEC_ELT (types, i);\n       pp_underscore (buffer);\n-      if (!dump_generic_ada_node (buffer, elem, 0, cpp_check, spc, false, true))\n+      if (!dump_generic_ada_node (buffer, elem, 0, spc, false, true))\n \t{\n \t  pp_string (buffer, \"unknown\");\n \t  pp_scalar (buffer, \"%lu\", (unsigned long) TREE_HASH (elem));\n@@ -1716,12 +1727,10 @@ dump_template_types (pretty_printer *buffer, tree types,\n }\n \n /* Dump in BUFFER the contents of all class instantiations associated with\n-   a given template T.  CPP_CHECK is used to perform C++ queries on nodes.\n-   SPC is the indentation level. */\n+   a given template T.  SPC is the indentation level.  */\n \n static int\n-dump_ada_template (pretty_printer *buffer, tree t,\n-\t\t   int (*cpp_check)(tree, cpp_operation), int spc)\n+dump_ada_template (pretty_printer *buffer, tree t, int spc)\n {\n   /* DECL_VINDEX is DECL_TEMPLATE_INSTANTIATIONS in this context.  */\n   tree inst = DECL_VINDEX (t);\n@@ -1750,23 +1759,23 @@ dump_ada_template (pretty_printer *buffer, tree t,\n       INDENT (spc);\n       pp_string (buffer, \"package \");\n       package_prefix = false;\n-      dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, true);\n-      dump_template_types (buffer, types, cpp_check, spc);\n+      dump_generic_ada_node (buffer, instance, t, spc, false, true);\n+      dump_template_types (buffer, types, spc);\n       pp_string (buffer, \" is\");\n       spc += INDENT_INCR;\n       newline_and_indent (buffer, spc);\n \n       TREE_VISITED (get_underlying_decl (instance)) = 1;\n       pp_string (buffer, \"type \");\n-      dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, true);\n+      dump_generic_ada_node (buffer, instance, t, spc, false, true);\n       package_prefix = true;\n \n       if (is_tagged_type (instance))\n \tpp_string (buffer, \" is tagged limited \");\n       else\n \tpp_string (buffer, \" is limited \");\n \n-      dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, false);\n+      dump_generic_ada_node (buffer, instance, t, spc, false, false);\n       pp_newline (buffer);\n       spc -= INDENT_INCR;\n       newline_and_indent (buffer, spc);\n@@ -1775,8 +1784,8 @@ dump_ada_template (pretty_printer *buffer, tree t,\n       newline_and_indent (buffer, spc);\n       pp_string (buffer, \"use \");\n       package_prefix = false;\n-      dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, true);\n-      dump_template_types (buffer, types, cpp_check, spc);\n+      dump_generic_ada_node (buffer, instance, t, spc, false, true);\n+      dump_template_types (buffer, types, spc);\n       package_prefix = true;\n       pp_semicolon (buffer);\n       pp_newline (buffer);\n@@ -1819,14 +1828,12 @@ static bool in_function = true;\n static bool bitfield_used = false;\n \n /* Recursively dump in BUFFER Ada declarations corresponding to NODE of type\n-   TYPE.  CPP_CHECK is used to perform C++ queries on nodes.  SPC is the\n-   indentation level.  LIMITED_ACCESS indicates whether NODE can be referenced\n-   via a \"limited with\" clause.  NAME_ONLY indicates whether we should only\n-   dump the name of NODE, instead of its full declaration.  */\n+   TYPE.  SPC is the indentation level.  LIMITED_ACCESS indicates whether NODE\n+   can be referenced via a \"limited with\" clause.  NAME_ONLY indicates whether\n+   we should only dump the name of NODE, instead of its full declaration.  */\n \n static int\n-dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n-\t\t       int (*cpp_check)(tree, cpp_operation), int spc,\n+dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t       int limited_access, bool name_only)\n {\n   if (node == NULL_TREE)\n@@ -1848,8 +1855,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n \n     case TREE_BINFO:\n       dump_generic_ada_node\n-\t(buffer, BINFO_TYPE (node), type, cpp_check,\n-\t spc, limited_access, name_only);\n+\t(buffer, BINFO_TYPE (node), type, spc, limited_access, name_only);\n \n     case TREE_VEC:\n       pp_string (buffer, \"--- unexpected node: TREE_VEC\");\n@@ -1876,7 +1882,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n     case ENUMERAL_TYPE:\n       if (name_only)\n \tdump_generic_ada_node\n-\t  (buffer, TYPE_NAME (node), node, cpp_check, spc, 0, true);\n+\t  (buffer, TYPE_NAME (node), node, spc, 0, true);\n       else\n \t{\n \t  tree value = TYPE_VALUES (node);\n@@ -1906,7 +1912,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n \t      pp_string (buffer, \"pragma Convention (C, \");\n \t      dump_generic_ada_node\n \t\t(buffer, DECL_NAME (type) ? type : TYPE_NAME (node), type,\n-\t\t cpp_check, spc, 0, true);\n+\t\t spc, 0, true);\n \t      pp_right_paren (buffer);\n \t    }\n \t  else\n@@ -1923,14 +1929,14 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n \n \t\t  dump_generic_ada_node\n \t\t    (buffer, DECL_NAME (type) ? type : TYPE_NAME (node), type,\n-\t\t     cpp_check, spc, 0, true);\n+\t\t     spc, 0, true);\n \n \t\t  pp_string (buffer, \" := \");\n \t\t  dump_generic_ada_node\n \t\t    (buffer,\n \t\t     TREE_CODE (TREE_VALUE (value)) == INTEGER_CST ?\n \t\t       TREE_VALUE (value) : DECL_INITIAL (TREE_VALUE (value)),\n-\t\t     node, cpp_check, spc, false, true);\n+\t\t     node, spc, false, true);\n \t\t}\n \t    }\n \t}\n@@ -1991,8 +1997,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n     case REFERENCE_TYPE:\n       if (name_only && TYPE_NAME (node))\n \tdump_generic_ada_node\n-\t  (buffer, TYPE_NAME (node), node, cpp_check,\n-\t   spc, limited_access, true);\n+\t  (buffer, TYPE_NAME (node), node, spc, limited_access, true);\n \n       else if (TREE_CODE (TREE_TYPE (node)) == FUNCTION_TYPE)\n \t{\n@@ -2020,7 +2025,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n \t    {\n \t      pp_string (buffer, \" return \");\n \t      dump_generic_ada_node\n-\t\t(buffer, TREE_TYPE (fnode), type, cpp_check, spc, 0, true);\n+\t\t(buffer, TREE_TYPE (fnode), type, spc, 0, true);\n \t    }\n \n \t    /* If we are dumping the full type, it means we are part of a\n@@ -2031,7 +2036,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n \t\tnewline_and_indent (buffer, spc);\n \t\tpp_string (buffer, \"pragma Convention (C, \");\n \t\tdump_generic_ada_node\n-\t\t  (buffer, type, 0, cpp_check, spc, false, true);\n+\t\t  (buffer, type, 0, spc, false, true);\n \t\tpp_right_paren (buffer);\n \t      }\n \t}\n@@ -2158,11 +2163,11 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n \t\t      && type_name != NULL_TREE)\n \t\t    dump_generic_ada_node\n \t\t      (buffer, type_name,\n-\t\t       TREE_TYPE (node), cpp_check, spc, is_access, true);\n+\t\t       TREE_TYPE (node), spc, is_access, true);\n \t\t  else\n \t\t    dump_generic_ada_node\n \t\t      (buffer, TREE_TYPE (node), TREE_TYPE (node),\n-\t\t       cpp_check, spc, 0, true);\n+\t\t       spc, 0, true);\n \t\t}\n \t    }\n \t}\n@@ -2171,8 +2176,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n     case ARRAY_TYPE:\n       if (name_only)\n \tdump_generic_ada_node\n-\t  (buffer, TYPE_NAME (node), node, cpp_check,\n-\t   spc, limited_access, true);\n+\t  (buffer, TYPE_NAME (node), node, spc, limited_access, true);\n       else\n \tdump_ada_array_type (buffer, node, spc);\n       break;\n@@ -2184,17 +2188,15 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n \t{\n \t  if (TYPE_NAME (node))\n \t    dump_generic_ada_node\n-\t      (buffer, TYPE_NAME (node), node, cpp_check,\n-\t       spc, limited_access, true);\n+\t      (buffer, TYPE_NAME (node), node, spc, limited_access, true);\n \t  else\n \t    {\n \t      pp_string (buffer, \"anon_\");\n \t      pp_scalar (buffer, \"%d\", TYPE_UID (node));\n \t    }\n \t}\n       else\n-\tprint_ada_struct_decl\n-\t  (buffer, node, type, cpp_check, spc, true);\n+\tprint_ada_struct_decl (buffer, node, type, spc, true);\n       break;\n \n     case INTEGER_CST:\n@@ -2287,12 +2289,11 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n \n \t      pp_string (buffer, first ? \"tagged limited \" : \" with \");\n \t    }\n-\t  else if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (node))\n-\t\t   && TYPE_METHODS (TREE_TYPE (node)))\n+\t  else if (has_nontrivial_methods (TREE_TYPE (node)))\n \t    pp_string (buffer, \"limited \");\n \n \t  dump_generic_ada_node\n-\t    (buffer, TREE_TYPE (node), type, cpp_check, spc, false, false);\n+\t    (buffer, TREE_TYPE (node), type, spc, false, false);\n \t}\n       break;\n \n@@ -2311,41 +2312,41 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n   return 1;\n }\n \n-/* Dump in BUFFER NODE's methods.  CPP_CHECK is used to perform C++ queries on\n-   nodes.  SPC is the indentation level.  */\n+/* Dump in BUFFER NODE's methods.  SPC is the indentation level.  Return 1 if\n+   methods were printed, 0 otherwise.  */\n \n-static void\n-print_ada_methods (pretty_printer *buffer, tree node,\n-\t\t   int (*cpp_check)(tree, cpp_operation), int spc)\n+static int\n+print_ada_methods (pretty_printer *buffer, tree node, int spc)\n {\n-  tree tmp = TYPE_METHODS (node);\n   int res = 1;\n+  tree tmp;\n \n-  if (tmp)\n-    {\n-      pp_semicolon (buffer);\n+  if (!has_nontrivial_methods (node))\n+    return 0;\n \n-      for (; tmp; tmp = TREE_CHAIN (tmp))\n+  pp_semicolon (buffer);\n+\n+  for (tmp = TYPE_METHODS (node); tmp; tmp = TREE_CHAIN (tmp))\n+    {\n+      if (res)\n \t{\n-\t  if (res)\n-\t    {\n-\t      pp_newline (buffer);\n-\t      pp_newline (buffer);\n-\t    }\n-\t  res = print_ada_declaration (buffer, tmp, node, cpp_check, spc);\n+\t  pp_newline (buffer);\n+\t  pp_newline (buffer);\n \t}\n+      res = print_ada_declaration (buffer, tmp, node, spc);\n     }\n+\n+  return 1;\n }\n \n /* Dump in BUFFER anonymous types nested inside T's definition.\n    PARENT is the parent node of T.\n    FORWARD indicates whether a forward declaration of T should be generated.\n-   CPP_CHECK is used to perform C++ queries on\n-   nodes.  SPC is the indentation level.  */\n+   SPC is the indentation level.  */\n \n static void\n dump_nested_types (pretty_printer *buffer, tree t, tree parent, bool forward,\n-\t\t   int (*cpp_check)(tree, cpp_operation), int spc)\n+\t\t   int spc)\n {\n   tree field, outer, decl;\n \n@@ -2363,8 +2364,7 @@ dump_nested_types (pretty_printer *buffer, tree t, tree parent, bool forward,\n   if (forward)\n     {\n       pp_string (buffer, \"type \");\n-      dump_generic_ada_node\n-\t(buffer, t, t, cpp_check, spc, false, true);\n+      dump_generic_ada_node (buffer, t, t, spc, false, true);\n       pp_semicolon (buffer);\n       newline_and_indent (buffer, spc);\n       TREE_VISITED (t) = 1;\n@@ -2406,8 +2406,7 @@ dump_nested_types (pretty_printer *buffer, tree t, tree parent, bool forward,\n \t\t    /* Generate forward declaration.  */\n \n \t\t    pp_string (buffer, \"type \");\n-\t\t    dump_generic_ada_node\n-\t\t      (buffer, decl, 0, cpp_check, spc, false, true);\n+\t\t    dump_generic_ada_node (buffer, decl, 0, spc, false, true);\n \t\t    pp_semicolon (buffer);\n \t\t    newline_and_indent (buffer, spc);\n \n@@ -2431,30 +2430,28 @@ dump_nested_types (pretty_printer *buffer, tree t, tree parent, bool forward,\n \n \t      case UNION_TYPE:\n \t\tTREE_VISITED (t) = 1;\n-\t\tdump_nested_types (buffer, field, t, false, cpp_check, spc);\n+\t\tdump_nested_types (buffer, field, t, false, spc);\n \n \t\tpp_string (buffer, \"type \");\n \n \t\tif (TYPE_NAME (TREE_TYPE (field)))\n \t\t  {\n \t\t    dump_generic_ada_node\n-\t\t      (buffer, TYPE_NAME (TREE_TYPE (field)), 0, cpp_check,\n-\t\t       spc, false, true);\n+\t\t      (buffer, TYPE_NAME (TREE_TYPE (field)), 0, spc, false,\n+\t\t       true);\n \t\t    pp_string (buffer, \" (discr : unsigned := 0) is \");\n \t\t    print_ada_struct_decl\n-\t\t      (buffer, TREE_TYPE (field), t, cpp_check, spc, false);\n+\t\t      (buffer, TREE_TYPE (field), t, spc, false);\n \n \t\t    pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n \t\t    dump_generic_ada_node\n-\t\t      (buffer, TREE_TYPE (field), 0, cpp_check,\n-\t\t       spc, false, true);\n+\t\t      (buffer, TREE_TYPE (field), 0, spc, false, true);\n \t\t    pp_string (buffer, \");\");\n \t\t    newline_and_indent (buffer, spc);\n \n \t\t    pp_string (buffer, \"pragma Unchecked_Union (\");\n \t\t    dump_generic_ada_node\n-\t\t      (buffer, TREE_TYPE (field), 0, cpp_check,\n-\t\t       spc, false, true);\n+\t\t      (buffer, TREE_TYPE (field), 0, spc, false, true);\n \t\t    pp_string (buffer, \");\");\n \t\t  }\n \t\telse\n@@ -2463,7 +2460,7 @@ dump_nested_types (pretty_printer *buffer, tree t, tree parent, bool forward,\n \t\t      (buffer, parent, field,\n \t\t       \t\"_union (discr : unsigned := 0) is \");\n \t\t    print_ada_struct_decl\n-\t\t      (buffer, TREE_TYPE (field), t, cpp_check, spc, false);\n+\t\t      (buffer, TREE_TYPE (field), t, spc, false);\n \t\t    pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n \t\t    dump_ada_double_name (buffer, parent, field, \"_union);\");\n \t\t    newline_and_indent (buffer, spc);\n@@ -2480,35 +2477,33 @@ dump_nested_types (pretty_printer *buffer, tree t, tree parent, bool forward,\n \t\t  {\n \t\t    pp_string (buffer, \"type \");\n \t\t    dump_generic_ada_node\n-\t\t      (buffer, t, parent, 0, spc, false, true);\n+\t\t      (buffer, t, parent, spc, false, true);\n \t\t    pp_semicolon (buffer);\n \t\t    newline_and_indent (buffer, spc);\n \t\t  }\n \n \t\tTREE_VISITED (t) = 1;\n-\t\tdump_nested_types (buffer, field, t, false, cpp_check, spc);\n+\t\tdump_nested_types (buffer, field, t, false, spc);\n \t\tpp_string (buffer, \"type \");\n \n \t\tif (TYPE_NAME (TREE_TYPE (field)))\n \t\t  {\n \t\t    dump_generic_ada_node\n-\t\t      (buffer, TREE_TYPE (field), 0, cpp_check,\n-\t\t       spc, false, true);\n+\t\t      (buffer, TREE_TYPE (field), 0, spc, false, true);\n \t\t    pp_string (buffer, \" is \");\n \t\t    print_ada_struct_decl\n-\t\t      (buffer, TREE_TYPE (field), t, cpp_check, spc, false);\n+\t\t      (buffer, TREE_TYPE (field), t, spc, false);\n \t\t    pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n \t\t    dump_generic_ada_node\n-\t\t      (buffer, TREE_TYPE (field), 0, cpp_check,\n-\t\t       spc, false, true);\n+\t\t      (buffer, TREE_TYPE (field), 0, spc, false, true);\n \t\t    pp_string (buffer, \");\");\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    dump_ada_double_name\n \t\t      (buffer, parent, field, \"_struct is \");\n \t\t    print_ada_struct_decl\n-\t\t      (buffer, TREE_TYPE (field), t, cpp_check, spc, false);\n+\t\t      (buffer, TREE_TYPE (field), t, spc, false);\n \t\t    pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n \t\t    dump_ada_double_name (buffer, parent, field, \"_struct);\");\n \t\t  }\n@@ -2557,12 +2552,11 @@ type_name (tree t)\n }\n \n /* Print in BUFFER the declaration of a variable T of type TYPE in Ada syntax.\n-   CPP_CHECK is used to perform C++ queries on nodes.  SPC is the indentation\n-   level.  Return 1 if a declaration was printed, 0 otherwise.  */\n+   SPC is the indentation level.  Return 1 if a declaration was printed,\n+   0 otherwise.  */\n \n static int\n-print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n-\t\t       int (*cpp_check)(tree, cpp_operation), int spc)\n+print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n {\n   int is_var = 0, need_indent = 0;\n   int is_class = false;\n@@ -2571,7 +2565,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n   tree orig = NULL_TREE;\n \n   if (cpp_check && cpp_check (t, IS_TEMPLATE))\n-    return dump_ada_template (buffer, t, cpp_check, spc);\n+    return dump_ada_template (buffer, t, spc);\n \n   if (TREE_CODE (t) == CONST_DECL && TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE)\n     /* Skip enumeral values: will be handled as part of the type itself.  */\n@@ -2599,20 +2593,18 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t      if (RECORD_OR_UNION_TYPE_P (typ) && !TYPE_FIELDS (typ))\n \t\t{\n \t\t  pp_string (buffer, \"--  skipped empty struct \");\n-\t\t  dump_generic_ada_node (buffer, t, type, 0, spc, false, true);\n+\t\t  dump_generic_ada_node (buffer, t, type, spc, false, true);\n \t\t}\n \t      else\n \t\t{\n \t\t  if (!TREE_VISITED (stub)\n \t\t      && DECL_SOURCE_FILE (stub) == source_file_base)\n-\t\t    dump_nested_types\n-\t\t      (buffer, stub, stub, true, cpp_check, spc);\n+\t\t    dump_nested_types (buffer, stub, stub, true, spc);\n \n \t\t  pp_string (buffer, \"subtype \");\n-\t\t  dump_generic_ada_node (buffer, t, type, 0, spc, false, true);\n+\t\t  dump_generic_ada_node (buffer, t, type, spc, false, true);\n \t\t  pp_string (buffer, \" is \");\n-\t\t  dump_generic_ada_node\n-\t\t    (buffer, typ, type, 0, spc, false, true);\n+\t\t  dump_generic_ada_node (buffer, typ, type, spc, false, true);\n \t\t  pp_semicolon (buffer);\n \t\t}\n \t      return 1;\n@@ -2671,7 +2663,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t    if (!TYPE_FIELDS (TREE_TYPE (t)))\n \t      {\n \t\tpp_string (buffer, \"--  skipped empty struct \");\n-\t\tdump_generic_ada_node (buffer, t, type, 0, spc, false, true);\n+\t\tdump_generic_ada_node (buffer, t, type, spc, false, true);\n \t\treturn 1;\n \t      }\n \n@@ -2680,7 +2672,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t\t    || *IDENTIFIER_POINTER (decl_name) == '$'))\n \t      {\n \t\tpp_string (buffer, \"--  skipped anonymous struct \");\n-\t\tdump_generic_ada_node (buffer, t, type, 0, spc, false, true);\n+\t\tdump_generic_ada_node (buffer, t, type, spc, false, true);\n \t\tTREE_VISITED (t) = 1;\n \t\treturn 1;\n \t      }\n@@ -2689,14 +2681,13 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t      pp_string (buffer, \"subtype \");\n \t    else\n \t      {\n-\t\tdump_nested_types (buffer, t, t, false, cpp_check, spc);\n+\t\tdump_nested_types (buffer, t, t, false, spc);\n \n                 if (separate_class_package (t))\n \t\t  {\n \t\t    is_class = true;\n \t\t    pp_string (buffer, \"package Class_\");\n-\t\t    dump_generic_ada_node\n-\t\t      (buffer, t, type, 0, spc, false, true);\n+\t\t    dump_generic_ada_node (buffer, t, type, spc, false, true);\n \t\t    pp_string (buffer, \" is\");\n \t\t    spc += INDENT_INCR;\n \t\t    newline_and_indent (buffer, spc);\n@@ -2718,7 +2709,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \n \t  case FUNCTION_TYPE:\n \t    pp_string (buffer, \"--  skipped function type \");\n-\t    dump_generic_ada_node (buffer, t, type, 0, spc, false, true);\n+\t    dump_generic_ada_node (buffer, t, type, spc, false, true);\n \t    return 1;\n \t    break;\n \n@@ -2752,16 +2743,15 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \tINDENT (spc);\n \n       /* Print variable's name.  */\n-      dump_generic_ada_node (buffer, t, type, cpp_check, spc, false, true);\n+      dump_generic_ada_node (buffer, t, type, spc, false, true);\n \n       if (TREE_CODE (t) == TYPE_DECL)\n \t{\n \t  pp_string (buffer, \" is \");\n \n \t  if (orig && TYPE_NAME (orig) && orig != TREE_TYPE (t))\n \t    dump_generic_ada_node\n-\t      (buffer, TYPE_NAME (orig), type,\n-\t       cpp_check, spc, false, true);\n+\t      (buffer, TYPE_NAME (orig), type, spc, false, true);\n \t  else\n \t    dump_ada_array_type (buffer, t, spc);\n \t}\n@@ -2780,7 +2770,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t\t  && TREE_CODE (tmp) != INTEGER_TYPE)\n \t\tpp_string (buffer, \"aliased \");\n \n-\t      dump_generic_ada_node (buffer, tmp, type, 0, spc, false, true);\n+\t      dump_generic_ada_node (buffer, tmp, type, spc, false, true);\n \t    }\n \t  else\n \t    {\n@@ -2795,7 +2785,8 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n     }\n   else if (TREE_CODE (t) == FUNCTION_DECL)\n     {\n-      bool is_function = true, is_method, is_abstract_class = false;\n+      bool is_function = true, is_abstract_class = false;\n+      bool is_method = TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE;\n       tree decl_name = DECL_NAME (t);\n       int prev_in_function = in_function;\n       bool is_abstract = false;\n@@ -2852,7 +2843,6 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \tpp_string (buffer, \"function \");\n \n       in_function = is_function;\n-      is_method = TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE;\n \n       if (is_destructor)\n \tprint_destructor (buffer, t);\n@@ -2874,18 +2864,17 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t  else\n \t    {\n \t      dump_generic_ada_node\n-\t\t(buffer, TREE_TYPE (TREE_TYPE (t)), type, cpp_check,\n-\t\t spc, false, true);\n+\t\t(buffer, TREE_TYPE (TREE_TYPE (t)), type, spc, false, true);\n \t    }\n \t}\n \n-      if (is_constructor && cpp_check && type\n-\t  && AGGREGATE_TYPE_P (type)\n+      if (is_constructor\n+\t  && RECORD_OR_UNION_TYPE_P (type)\n \t  && TYPE_METHODS (type))\n \t{\n-\t  tree tmp = TYPE_METHODS (type);\n+\t  tree tmp;\n \n-\t  for (; tmp; tmp = TREE_CHAIN (tmp))\n+\t  for (tmp = TYPE_METHODS (type); tmp; tmp = TREE_CHAIN (tmp))\n \t    if (cpp_check (tmp, IS_ABSTRACT))\n \t      {\n \t\tis_abstract_class = 1;\n@@ -2937,8 +2926,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \tINDENT (spc);\n \n       /* Anonymous structs/unions */\n-      dump_generic_ada_node\n-\t(buffer, TREE_TYPE (t), t, cpp_check, spc, false, true);\n+      dump_generic_ada_node (buffer, TREE_TYPE (t), t, spc, false, true);\n \n       if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE\n \t  || TREE_CODE (TREE_TYPE (t)) == QUAL_UNION_TYPE)\n@@ -2949,14 +2937,15 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n       pp_string (buffer, \" is \");\n \n       /* Check whether we have an Ada interface compatible class.  */\n-      if (cpp_check && AGGREGATE_TYPE_P (TREE_TYPE (t))\n+      if (cpp_check\n+\t  && RECORD_OR_UNION_TYPE_P (TREE_TYPE (t))\n \t  && TYPE_METHODS (TREE_TYPE (t)))\n \t{\n \t  int num_fields = 0;\n-\t  tree tmp = TYPE_FIELDS (TREE_TYPE (t));\n+\t  tree tmp;\n \n \t  /* Check that there are no fields other than the virtual table.  */\n-\t  for (; tmp; tmp = TREE_CHAIN (tmp))\n+\t  for (tmp = TYPE_FIELDS (TREE_TYPE (t)); tmp; tmp = TREE_CHAIN (tmp))\n \t    {\n \t      if (TREE_CODE (tmp) == TYPE_DECL)\n \t\tcontinue;\n@@ -2984,17 +2973,16 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t  newline_and_indent (buffer, spc);\n \t  pp_string (buffer, \"pragma Import (CPP, \");\n  \t  dump_generic_ada_node\n-\t    (buffer, TYPE_NAME (TREE_TYPE (t)), type, cpp_check,\n-\t     spc, false, true);\n+\t    (buffer, TYPE_NAME (TREE_TYPE (t)), type, spc, false, true);\n   \t  pp_right_paren (buffer);\n \n-\t  print_ada_methods (buffer, TREE_TYPE (t), cpp_check, spc);\n+\t  print_ada_methods (buffer, TREE_TYPE (t), spc);\n \t}\n       else\n \t{\n \t  if (is_abstract_record)\n \t    pp_string (buffer, \"abstract \");\n-\t  dump_generic_ada_node (buffer, t, t, cpp_check, spc, false, false);\n+\t  dump_generic_ada_node (buffer, t, t, spc, false, false);\n \t}\n     }\n   else\n@@ -3006,7 +2994,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \tcheck_name (buffer, t);\n \n       /* Print variable/type's name.  */\n-      dump_generic_ada_node (buffer, t, t, cpp_check, spc, false, true);\n+      dump_generic_ada_node (buffer, t, t, spc, false, true);\n \n       if (TREE_CODE (t) == TYPE_DECL)\n \t{\n@@ -3020,8 +3008,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \n \t  pp_string (buffer, \" is \");\n \n-\t  dump_generic_ada_node\n-\t    (buffer, orig, t, cpp_check, spc, false, is_subtype);\n+\t  dump_generic_ada_node (buffer, orig, t, spc, false, is_subtype);\n \t}\n       else\n \t{\n@@ -3043,7 +3030,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t\tpp_string (buffer, \"aliased \");\n \n \t      dump_generic_ada_node\n-\t\t(buffer, TREE_TYPE (t), t, cpp_check, spc, false, true);\n+\t\t(buffer, TREE_TYPE (t), t, spc, false, true);\n \t    }\n \t  else\n \t    {\n@@ -3053,8 +3040,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t\tpp_string (buffer, \"aliased \");\n \n \t      dump_generic_ada_node\n-\t\t(buffer, TREE_TYPE (t), TREE_TYPE (t), cpp_check,\n-\t\t spc, false, true);\n+\t\t(buffer, TREE_TYPE (t), TREE_TYPE (t), spc, false, true);\n \t    }\n \t}\n     }\n@@ -3066,7 +3052,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n       pp_string (buffer, \"end;\");\n       newline_and_indent (buffer, spc);\n       pp_string (buffer, \"use Class_\");\n-      dump_generic_ada_node (buffer, t, type, 0, spc, false, true);\n+      dump_generic_ada_node (buffer, t, type, spc, false, true);\n       pp_semicolon (buffer);\n       pp_newline (buffer);\n \n@@ -3089,18 +3075,16 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n }\n \n /* Prints in BUFFER a structure NODE of type TYPE: name, fields, and methods\n-   with Ada syntax.  CPP_CHECK is used to perform C++ queries on nodes.  SPC\n-   is the indentation level.  If DISPLAY_CONVENTION is true, also print the\n-   pragma Convention for NODE.  */\n+   with Ada syntax.  SPC is the indentation level.  If DISPLAY_CONVENTION is\n+   true, also print the pragma Convention for NODE.  */\n \n static void\n-print_ada_struct_decl (pretty_printer *buffer, tree node, tree type,\n-\t\t       int (*cpp_check)(tree, cpp_operation), int spc,\n+print_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t       bool display_convention)\n {\n   tree tmp;\n-  int is_union =\n-    TREE_CODE (node) == UNION_TYPE || TREE_CODE (node) == QUAL_UNION_TYPE;\n+  const bool is_union\n+    = TREE_CODE (node) == UNION_TYPE || TREE_CODE (node) == QUAL_UNION_TYPE;\n   char buf[32];\n   int field_num = 0;\n   int field_spc = spc + INDENT_INCR;\n@@ -3134,8 +3118,7 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type,\n \t      if (!is_tagged_type (TREE_TYPE (tmp)))\n \t\t{\n \t\t  if (!TYPE_NAME (TREE_TYPE (tmp)))\n-\t\t    print_ada_declaration\n-\t\t      (buffer, tmp, type, cpp_check, field_spc);\n+\t\t    print_ada_declaration (buffer, tmp, type, field_spc);\n \t\t  else\n \t\t    {\n \t\t      INDENT (field_spc);\n@@ -3179,8 +3162,7 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type,\n \t\t      pp_newline (buffer);\n \t\t    }\n \n-\t\t  if (print_ada_declaration (buffer,\n-\t\t\t\t\t     tmp, type, cpp_check, field_spc))\n+\t\t  if (print_ada_declaration (buffer, tmp, type, field_spc))\n \t\t    {\n \t\t      pp_newline (buffer);\n \t\t      field_num++;\n@@ -3214,7 +3196,7 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type,\n \n   if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type)))\n     {\n-      if (TYPE_METHODS (TREE_TYPE (type)))\n+      if (has_nontrivial_methods (TREE_TYPE (type)))\n \tpp_string (buffer, \"pragma Import (CPP, \");\n       else\n \tpp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n@@ -3223,8 +3205,7 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type,\n     pp_string (buffer, \"pragma Convention (C, \");\n \n   package_prefix = false;\n-  dump_generic_ada_node\n-    (buffer, TREE_TYPE (type), type, cpp_check, spc, false, true);\n+  dump_generic_ada_node (buffer, TREE_TYPE (type), type, spc, false, true);\n   package_prefix = true;\n   pp_right_paren (buffer);\n \n@@ -3234,8 +3215,7 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type,\n       newline_and_indent (buffer, spc);\n       pp_string (buffer, \"pragma Unchecked_Union (\");\n \n-      dump_generic_ada_node\n-\t(buffer, TREE_TYPE (type), type, cpp_check, spc, false, true);\n+      dump_generic_ada_node (buffer, TREE_TYPE (type), type, spc, false, true);\n       pp_right_paren (buffer);\n     }\n \n@@ -3245,15 +3225,14 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type,\n       newline_and_indent (buffer, spc);\n       pp_string (buffer, \"pragma Pack (\");\n       dump_generic_ada_node\n-\t(buffer, TREE_TYPE (type), type, cpp_check, spc, false, true);\n+\t(buffer, TREE_TYPE (type), type, spc, false, true);\n       pp_right_paren (buffer);\n       bitfield_used = false;\n     }\n \n-  print_ada_methods (buffer, node, cpp_check, spc);\n+  need_semicolon = !print_ada_methods (buffer, node, spc);\n \n   /* Print the static fields of the structure, if any.  */\n-  need_semicolon = TYPE_METHODS (node) == NULL_TREE;\n   for (tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))\n     {\n       if (DECL_NAME (tmp) && TREE_STATIC (tmp))\n@@ -3265,20 +3244,19 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type,\n \t    }\n \t  pp_newline (buffer);\n \t  pp_newline (buffer);\n-\t  print_ada_declaration (buffer, tmp, type, cpp_check, spc);\n+\t  print_ada_declaration (buffer, tmp, type, spc);\n \t}\n     }\n }\n \n /* Dump all the declarations in SOURCE_FILE to an Ada spec.\n    COLLECT_ALL_REFS is a front-end callback used to collect all relevant\n-   nodes for SOURCE_FILE.  CPP_CHECK is used to perform C++ queries on\n-   nodes.  */\n+   nodes for SOURCE_FILE.  CHECK is used to perform C++ queries on nodes.  */\n \n static void\n dump_ads (const char *source_file,\n \t  void (*collect_all_refs)(const char *),\n-\t  int (*cpp_check)(tree, cpp_operation))\n+\t  int (*check)(const_tree, cpp_operation))\n {\n   char *ads_name;\n   char *pkg_name;\n@@ -3316,7 +3294,8 @@ dump_ads (const char *source_file,\n       (*collect_all_refs) (source_file);\n \n       /* Dump all references.  */\n-      dump_ada_nodes (&pp, source_file, cpp_check);\n+      cpp_check = check;\n+      dump_ada_nodes (&pp, source_file);\n \n       /* Requires Ada 2005 syntax, so generate corresponding pragma.\n          Also, disable style checks since this file is auto-generated.  */\n@@ -3370,21 +3349,21 @@ collect_source_ref (const char *filename)\n }\n \n /* Main entry point: dump all Ada specs corresponding to SOURCE_REFS\n-   using callbacks COLLECT_ALL_REFS and CPP_CHECK.\n+   using callbacks COLLECT_ALL_REFS and CHECK.\n    COLLECT_ALL_REFS is a front-end callback used to collect all relevant\n    nodes for a given source file.\n-   CPP_CHECK is used to perform C++ queries on nodes, or NULL for the C\n+   CHECK is used to perform C++ queries on nodes, or NULL for the C\n    front-end.  */\n \n void\n dump_ada_specs (void (*collect_all_refs)(const char *),\n-\t\tint (*cpp_check)(tree, cpp_operation))\n+\t\tint (*check)(const_tree, cpp_operation))\n {\n   int i;\n \n   /* Iterate over the list of files to dump specs for */\n   for (i = 0; i < source_refs_used; i++)\n-    dump_ads (source_refs[i], collect_all_refs, cpp_check);\n+    dump_ads (source_refs[i], collect_all_refs, check);\n \n   /* Free files table.  */\n   free (source_refs);"}, {"sha": "64f0ecd4b22c6843317648cbfbf4e144f1d0c870", "filename": "gcc/c-family/c-ada-spec.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94159ecf929a26211ec28c455ea38063591deda7/gcc%2Fc-family%2Fc-ada-spec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94159ecf929a26211ec28c455ea38063591deda7/gcc%2Fc-family%2Fc-ada-spec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.h?ref=94159ecf929a26211ec28c455ea38063591deda7", "patch": "@@ -29,13 +29,14 @@ typedef enum {\n   IS_CONSTRUCTOR,\n   IS_DESTRUCTOR,\n   IS_COPY_CONSTRUCTOR,\n-  IS_TEMPLATE\n+  IS_TEMPLATE,\n+  IS_TRIVIAL\n } cpp_operation;\n \n extern location_t decl_sloc (const_tree, bool);\n extern void collect_ada_nodes (tree, const char *);\n extern void collect_source_ref (const char *);\n extern void dump_ada_specs (void (*)(const char *),\n-\t\t\t    int (*)(tree, cpp_operation));\n+\t\t\t    int (*)(const_tree, cpp_operation));\n \n #endif /* ! C_ADA_SPEC_H */"}, {"sha": "8a3df56e63f52ce6284209007e5c3ede8cad1231", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94159ecf929a26211ec28c455ea38063591deda7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94159ecf929a26211ec28c455ea38063591deda7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=94159ecf929a26211ec28c455ea38063591deda7", "patch": "@@ -1,3 +1,8 @@\n+2013-11-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* decl2.c (cpp_check): Change type of first parameter and deal with\n+\tIS_TRIVIAL.\n+\n 2013-11-03  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/38313"}, {"sha": "a094ff3b5462630118106db771178b6566bbe14e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94159ecf929a26211ec28c455ea38063591deda7/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94159ecf929a26211ec28c455ea38063591deda7/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=94159ecf929a26211ec28c455ea38063591deda7", "patch": "@@ -3789,7 +3789,7 @@ build_java_method_aliases (struct pointer_set_t *candidates)\n /* Return C++ property of T, based on given operation OP.  */\n \n static int\n-cpp_check (tree t, cpp_operation op)\n+cpp_check (const_tree t, cpp_operation op)\n {\n   switch (op)\n     {\n@@ -3803,6 +3803,8 @@ cpp_check (tree t, cpp_operation op)\n \treturn DECL_COPY_CONSTRUCTOR_P (t);\n       case IS_TEMPLATE:\n \treturn TREE_CODE (t) == TEMPLATE_DECL;\n+      case IS_TRIVIAL:\n+\treturn trivial_type_p (t);\n       default:\n         return 0;\n     }"}]}