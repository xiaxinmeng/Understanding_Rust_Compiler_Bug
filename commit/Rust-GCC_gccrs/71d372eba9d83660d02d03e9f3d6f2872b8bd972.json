{"sha": "71d372eba9d83660d02d03e9f3d6f2872b8bd972", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFkMzcyZWJhOWQ4MzY2MGQwMmQwM2U5ZjNkNmYyODcyYjhiZDk3Mg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2018-05-04T13:47:11Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2018-05-04T13:47:11Z"}, "message": "libffi PowerPC64 ELFv1 fp arg fixes\n\nThe ELFv1 ABI says: \"Single precision floating point values are mapped\nto the second word in a single doubleword\" and also \"Floating point\nregisters f1 through f13 are used consecutively to pass up to 13\nfloating point values, one member aggregates passed by value\ncontaining a floating point value, and to pass complex floating point\nvalues\".\n\nlibffi wasn't expecting float args in the second word, and wasn't\npassing one member aggregates in fp registers.  This patch fixes those\nproblems, making use of the existing ELFv2 homogeneous aggregate\nsupport since a one element fp struct is a special case of an\nhomogeneous aggregate.\n\nI've also set a flag when returning pointers that might be used one\nday.  This is just a tidy since the ppc64 assembly support code\ncurrently doesn't test FLAG_RETURNS_64BITS for integer types..\n\n\t* src/powerpc/ffi_linux64.c (discover_homogeneous_aggregate):\n\tCompile for ELFv1 too, handling single element aggregates.\n\t(ffi_prep_cif_linux64_core): Call discover_homogeneous_aggregate\n\tfor ELFv1.  Set FLAG_RETURNS_64BITS for FFI_TYPE_POINTER return.\n\t(ffi_prep_args64): Call discover_homogeneous_aggregate for ELFv1,\n\tand handle single element structs containing float or double\n\tas if the element wasn't wrapped in a struct.  Store floats in\n\tsecond word of doubleword slot when big-endian.\n\t(ffi_closure_helper_LINUX64): Similarly.\n\nFrom-SVN: r259934", "tree": {"sha": "8640270aa588400317c2731ffbea77b72b12cfe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8640270aa588400317c2731ffbea77b72b12cfe2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71d372eba9d83660d02d03e9f3d6f2872b8bd972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d372eba9d83660d02d03e9f3d6f2872b8bd972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71d372eba9d83660d02d03e9f3d6f2872b8bd972", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d372eba9d83660d02d03e9f3d6f2872b8bd972/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dd17274465724f65c09dc2f654d92f6ba92cd90f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd17274465724f65c09dc2f654d92f6ba92cd90f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd17274465724f65c09dc2f654d92f6ba92cd90f"}], "stats": {"total": 74, "additions": 58, "deletions": 16}, "files": [{"sha": "837b77013555776a5a55b4fac8e77eac8f111ad4", "filename": "libffi/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d372eba9d83660d02d03e9f3d6f2872b8bd972/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d372eba9d83660d02d03e9f3d6f2872b8bd972/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=71d372eba9d83660d02d03e9f3d6f2872b8bd972", "patch": "@@ -1,3 +1,16 @@\n+2018-05-04  Alan Modra  <amodra@gmail.com>\n+\n+\tImport from upstream\n+\t* src/powerpc/ffi_linux64.c (discover_homogeneous_aggregate):\n+\tCompile for ELFv1 too, handling single element aggregates.\n+\t(ffi_prep_cif_linux64_core): Call discover_homogeneous_aggregate\n+\tfor ELFv1.  Set FLAG_RETURNS_64BITS for FFI_TYPE_POINTER return.\n+\t(ffi_prep_args64): Call discover_homogeneous_aggregate for ELFv1,\n+\tand handle single element structs containing float or double\n+\tas if the element wasn't wrapped in a struct.  Store floats in\n+\tsecond word of doubleword slot when big-endian.\n+\t(ffi_closure_helper_LINUX64): Similarly.\n+\n 2018-04-18  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR jit/85384"}, {"sha": "ef0361b24ee3a2e93bba909dae75a561dd815d02", "filename": "libffi/src/powerpc/ffi_linux64.c", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d372eba9d83660d02d03e9f3d6f2872b8bd972/libffi%2Fsrc%2Fpowerpc%2Fffi_linux64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d372eba9d83660d02d03e9f3d6f2872b8bd972/libffi%2Fsrc%2Fpowerpc%2Fffi_linux64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_linux64.c?ref=71d372eba9d83660d02d03e9f3d6f2872b8bd972", "patch": "@@ -62,7 +62,6 @@ ffi_prep_types_linux64 (ffi_abi abi)\n #endif\n \n \n-#if _CALL_ELF == 2\n static unsigned int\n discover_homogeneous_aggregate (const ffi_type *t, unsigned int *elnum)\n {\n@@ -86,8 +85,13 @@ discover_homogeneous_aggregate (const ffi_type *t, unsigned int *elnum)\n \t      return 0;\n \t    base_elt = el_elt;\n \t    total_elnum += el_elnum;\n+#if _CALL_ELF == 2\n \t    if (total_elnum > 8)\n \t      return 0;\n+#else\n+\t    if (total_elnum > 1)\n+\t      return 0;\n+#endif\n \t    el++;\n \t  }\n \t*elnum = total_elnum;\n@@ -98,7 +102,6 @@ discover_homogeneous_aggregate (const ffi_type *t, unsigned int *elnum)\n       return 0;\n     }\n }\n-#endif\n \n \n /* Perform machine dependent cif processing */\n@@ -109,9 +112,7 @@ ffi_prep_cif_linux64_core (ffi_cif *cif)\n   unsigned bytes;\n   unsigned i, fparg_count = 0, intarg_count = 0;\n   unsigned flags = cif->flags;\n-#if _CALL_ELF == 2\n   unsigned int elt, elnum;\n-#endif\n \n #if FFI_TYPE_LONGDOUBLE == FFI_TYPE_DOUBLE\n   /* If compiled without long double support..  */\n@@ -157,6 +158,7 @@ ffi_prep_cif_linux64_core (ffi_cif *cif)\n       /* Fall through.  */\n     case FFI_TYPE_UINT64:\n     case FFI_TYPE_SINT64:\n+    case FFI_TYPE_POINTER:\n       flags |= FLAG_RETURNS_64BITS;\n       break;\n \n@@ -222,7 +224,6 @@ ffi_prep_cif_linux64_core (ffi_cif *cif)\n \t\tintarg_count = ALIGN (intarg_count, align);\n \t    }\n \t  intarg_count += ((*ptr)->size + 7) / 8;\n-#if _CALL_ELF == 2\n \t  elt = discover_homogeneous_aggregate (*ptr, &elnum);\n \t  if (elt)\n \t    {\n@@ -231,7 +232,6 @@ ffi_prep_cif_linux64_core (ffi_cif *cif)\n \t\tflags |= FLAG_ARG_NEEDS_PSAVE;\n \t    }\n \t  else\n-#endif\n \t    {\n \t      if (intarg_count > NUM_GPR_ARG_REGISTERS64)\n \t\tflags |= FLAG_ARG_NEEDS_PSAVE;\n@@ -449,9 +449,7 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n        i < nargs;\n        i++, ptr++, p_argv.v++)\n     {\n-#if _CALL_ELF == 2\n       unsigned int elt, elnum;\n-#endif\n \n       switch ((*ptr)->type)\n \t{\n@@ -494,6 +492,7 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n \t  /* Fall through.  */\n #endif\n \tcase FFI_TYPE_DOUBLE:\n+\tdo_double:\n \t  double_tmp = **p_argv.d;\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n \t    {\n@@ -512,17 +511,30 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n+\tdo_float:\n \t  double_tmp = **p_argv.f;\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n \t    {\n \t      *fpr_base.d++ = double_tmp;\n #if _CALL_ELF != 2\n \t      if ((flags & FLAG_COMPAT) != 0)\n-\t\t*next_arg.f = (float) double_tmp;\n+\t\t{\n+# ifndef __LITTLE_ENDIAN__\n+\t\t  next_arg.f[1] = (float) double_tmp;\n+# else\n+\t\t  next_arg.f[0] = (float) double_tmp;\n+# endif\n+\t\t}\n #endif\n \t    }\n \t  else\n-\t    *next_arg.f = (float) double_tmp;\n+\t    {\n+# ifndef __LITTLE_ENDIAN__\n+\t      next_arg.f[1] = (float) double_tmp;\n+# else\n+\t      next_arg.f[0] = (float) double_tmp;\n+# endif\n+\t    }\n \t  if (++next_arg.ul == gpr_end.ul)\n \t    next_arg.ul = rest.ul;\n \t  fparg_count++;\n@@ -538,10 +550,10 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n \t      if (align > 1)\n \t\tnext_arg.p = ALIGN (next_arg.p, align);\n \t    }\n-#if _CALL_ELF == 2\n \t  elt = discover_homogeneous_aggregate (*ptr, &elnum);\n \t  if (elt)\n \t    {\n+#if _CALL_ELF == 2\n \t      union {\n \t\tvoid *v;\n \t\tfloat *f;\n@@ -583,9 +595,14 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n \t\t    fparg_count++;\n \t\t  }\n \t\twhile (--elnum != 0);\n+#else\n+\t      if (elt == FFI_TYPE_FLOAT)\n+\t\tgoto do_float;\n+\t      else\n+\t\tgoto do_double;\n+#endif\n \t    }\n \t  else\n-#endif\n \t    {\n \t      words = ((*ptr)->size + 7) / 8;\n \t      if (next_arg.ul >= gpr_base.ul && next_arg.ul + words > gpr_end.ul)\n@@ -796,12 +813,10 @@ ffi_closure_helper_LINUX64 (ffi_cif *cif,\n \t      if (align > 1)\n \t\tpst = (unsigned long *) ALIGN ((size_t) pst, align);\n \t    }\n-\t  elt = 0;\n-#if _CALL_ELF == 2\n \t  elt = discover_homogeneous_aggregate (arg_types[i], &elnum);\n-#endif\n \t  if (elt)\n \t    {\n+#if _CALL_ELF == 2\n \t      union {\n \t\tvoid *v;\n \t\tunsigned long *ul;\n@@ -853,6 +868,12 @@ ffi_closure_helper_LINUX64 (ffi_cif *cif,\n \t\t    }\n \t\t  while (--elnum != 0);\n \t\t}\n+#else\n+\t      if (elt == FFI_TYPE_FLOAT)\n+\t\tgoto do_float;\n+\t      else\n+\t\tgoto do_double;\n+#endif\n \t    }\n \t  else\n \t    {\n@@ -894,6 +915,7 @@ ffi_closure_helper_LINUX64 (ffi_cif *cif,\n \t  /* Fall through.  */\n #endif\n \tcase FFI_TYPE_DOUBLE:\n+\tdo_double:\n \t  /* On the outgoing stack all values are aligned to 8 */\n \t  /* there are 13 64bit floating point registers */\n \n@@ -908,6 +930,7 @@ ffi_closure_helper_LINUX64 (ffi_cif *cif,\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n+\tdo_float:\n \t  if (pfr < end_pfr && i < nfixedargs)\n \t    {\n \t      /* Float values are stored as doubles in the\n@@ -917,7 +940,13 @@ ffi_closure_helper_LINUX64 (ffi_cif *cif,\n \t      pfr++;\n \t    }\n \t  else\n-\t    avalue[i] = pst;\n+\t    {\n+#ifndef __LITTLE_ENDIAN__\n+\t      avalue[i] = (char *) pst + 4;\n+#else\n+\t      avalue[i] = pst;\n+#endif\n+\t    }\n \t  pst++;\n \t  break;\n "}]}