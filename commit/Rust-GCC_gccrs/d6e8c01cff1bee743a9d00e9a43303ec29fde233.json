{"sha": "d6e8c01cff1bee743a9d00e9a43303ec29fde233", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZlOGMwMWNmZjFiZWU3NDNhOWQwMGU5YTQzMzAzZWMyOWZkZTIzMw==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2019-12-11T16:49:27Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2019-12-11T16:49:27Z"}, "message": "[PR92843] [OpenACC] Fix dynamic reference counting for structured 'REFCOUNT_INFINITY'\n\n\tlibgomp/\n\tPR libgomp/92843\n\t* oacc-mem.c (present_create_copy, delete_copyout): Fix dynamic\n\treference counting for structured 'REFCOUNT_INFINITY'.  Add some\n\tassertions.\n\t(goacc_insert_pointer, goacc_remove_pointer): Adjust accordingly.\n\t* testsuite/libgomp.oacc-c-c++-common/pr92843-1.c: New file.\n\t* testsuite/libgomp.oacc-c-c++-common/clauses-1.c: Fix OpenACC.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-82.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/nested-1.c: Likewise.\n\nFrom-SVN: r279234", "tree": {"sha": "a256dc21f4379bbf80ccbefa183250b98d71d98a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a256dc21f4379bbf80ccbefa183250b98d71d98a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6e8c01cff1bee743a9d00e9a43303ec29fde233", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6e8c01cff1bee743a9d00e9a43303ec29fde233", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6e8c01cff1bee743a9d00e9a43303ec29fde233", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6e8c01cff1bee743a9d00e9a43303ec29fde233/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57963e3934de387ade6b314a5d72330c28f30806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57963e3934de387ade6b314a5d72330c28f30806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57963e3934de387ade6b314a5d72330c28f30806"}], "stats": {"total": 263, "additions": 242, "deletions": 21}, "files": [{"sha": "e5fb05aea6dd72c44c1851ccfffea5386b0d0653", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e8c01cff1bee743a9d00e9a43303ec29fde233/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e8c01cff1bee743a9d00e9a43303ec29fde233/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=d6e8c01cff1bee743a9d00e9a43303ec29fde233", "patch": "@@ -1,5 +1,15 @@\n 2019-12-11  Thomas Schwinge  <thomas@codesourcery.com>\n \n+\tPR libgomp/92843\n+\t* oacc-mem.c (present_create_copy, delete_copyout): Fix dynamic\n+\treference counting for structured 'REFCOUNT_INFINITY'.  Add some\n+\tassertions.\n+\t(goacc_insert_pointer, goacc_remove_pointer): Adjust accordingly.\n+\t* testsuite/libgomp.oacc-c-c++-common/pr92843-1.c: New file.\n+\t* testsuite/libgomp.oacc-c-c++-common/clauses-1.c: Fix OpenACC.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-82.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/nested-1.c: Likewise.\n+\n \t* oacc-parallel.c (find_pointer, GOACC_enter_exit_data): Move...\n \t* oacc-mem.c: ... here.\n \t(gomp_acc_insert_pointer, gomp_acc_remove_pointer): Rename to"}, {"sha": "a809d0495a6725c9640431421b8484bed7810ca5", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e8c01cff1bee743a9d00e9a43303ec29fde233/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e8c01cff1bee743a9d00e9a43303ec29fde233/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=d6e8c01cff1bee743a9d00e9a43303ec29fde233", "patch": "@@ -543,11 +543,11 @@ present_create_copy (unsigned f, void *h, size_t s, int async)\n \t  gomp_fatal (\"[%p,+%d] not mapped\", (void *)h, (int)s);\n \t}\n \n+      assert (n->refcount != REFCOUNT_LINK);\n       if (n->refcount != REFCOUNT_INFINITY)\n-\t{\n-\t  n->refcount++;\n-\t  n->dynamic_refcount++;\n-\t}\n+\tn->refcount++;\n+      n->dynamic_refcount++;\n+\n       gomp_mutex_unlock (&acc_dev->lock);\n     }\n   else if (!(f & FLAG_CREATE))\n@@ -573,8 +573,10 @@ present_create_copy (unsigned f, void *h, size_t s, int async)\n \n       tgt = gomp_map_vars_async (acc_dev, aq, mapnum, &hostaddrs, NULL, &s,\n \t\t\t\t &kinds, true, GOMP_MAP_VARS_OPENACC);\n-      /* Initialize dynamic refcount.  */\n-      tgt->list[0].key->dynamic_refcount = 1;\n+      n = tgt->list[0].key;\n+      assert (n->refcount == 1);\n+      assert (n->dynamic_refcount == 0);\n+      n->dynamic_refcount++;\n \n       d = tgt->to_free;\n     }\n@@ -698,26 +700,25 @@ delete_copyout (unsigned f, void *h, size_t s, int async, const char *libfnname)\n \t\t  (void *) h, (int) s, (void *) n->host_start, (int) host_size);\n     }\n \n-  if (n->refcount == REFCOUNT_INFINITY)\n-    {\n-      n->refcount = 0;\n-      n->dynamic_refcount = 0;\n-    }\n-  if (n->refcount < n->dynamic_refcount)\n+  assert (n->refcount != REFCOUNT_LINK);\n+  if (n->refcount != REFCOUNT_INFINITY\n+      && n->refcount < n->dynamic_refcount)\n     {\n       gomp_mutex_unlock (&acc_dev->lock);\n       gomp_fatal (\"Dynamic reference counting assert fail\\n\");\n     }\n \n   if (f & FLAG_FINALIZE)\n     {\n-      n->refcount -= n->dynamic_refcount;\n+      if (n->refcount != REFCOUNT_INFINITY)\n+\tn->refcount -= n->dynamic_refcount;\n       n->dynamic_refcount = 0;\n     }\n   else if (n->dynamic_refcount)\n     {\n+      if (n->refcount != REFCOUNT_INFINITY)\n+\tn->refcount--;\n       n->dynamic_refcount--;\n-      n->refcount--;\n     }\n \n   if (n->refcount == 0)\n@@ -895,6 +896,8 @@ goacc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n       splay_tree_key n;\n       gomp_mutex_lock (&acc_dev->lock);\n       n = lookup_host (acc_dev, *hostaddrs, *sizes);\n+      assert (n->refcount != REFCOUNT_INFINITY\n+\t      && n->refcount != REFCOUNT_LINK);\n       gomp_mutex_unlock (&acc_dev->lock);\n \n       tgt = n->tgt;\n@@ -917,10 +920,11 @@ goacc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n   goacc_aq aq = get_goacc_asyncqueue (async);\n   tgt = gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs,\n \t\t\t     NULL, sizes, kinds, true, GOMP_MAP_VARS_OPENACC);\n+  splay_tree_key n = tgt->list[0].key;\n+  assert (n->refcount == 1);\n+  assert (n->dynamic_refcount == 0);\n+  n->dynamic_refcount++;\n   gomp_debug (0, \"  %s: mappings prepared\\n\", __FUNCTION__);\n-\n-  /* Initialize dynamic refcount.  */\n-  tgt->list[0].key->dynamic_refcount = 1;\n }\n \n static void\n@@ -950,6 +954,8 @@ goacc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,\n \n   t = n->tgt;\n \n+  assert (n->refcount != REFCOUNT_INFINITY\n+\t  && n->refcount != REFCOUNT_LINK);\n   if (n->refcount < n->dynamic_refcount)\n     {\n       gomp_mutex_unlock (&acc_dev->lock);\n@@ -963,8 +969,8 @@ goacc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,\n     }\n   else if (n->dynamic_refcount)\n     {\n-      n->dynamic_refcount--;\n       n->refcount--;\n+      n->dynamic_refcount--;\n     }\n \n   gomp_mutex_unlock (&acc_dev->lock);"}, {"sha": "8f01d5f32f83579d4281e5cbd2fbf139c1a8b9ff", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/clauses-1.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e8c01cff1bee743a9d00e9a43303ec29fde233/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fclauses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e8c01cff1bee743a9d00e9a43303ec29fde233/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fclauses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fclauses-1.c?ref=d6e8c01cff1bee743a9d00e9a43303ec29fde233", "patch": "@@ -469,7 +469,9 @@ main (int argc, char **argv)\n     if (!acc_is_present (c, (N * sizeof (float))))\n       abort ();\n \n-    acc_copyout (b, N * sizeof (float));\n+    d = (float *) acc_deviceptr (b);\n+\n+    acc_memcpy_from_device (b, d, N * sizeof (float));\n \n     for (i = 0; i < N; i++)\n     {\n@@ -485,10 +487,22 @@ main (int argc, char **argv)\n     if (acc_is_present (a, N * sizeof (float)))\n       abort ();\n \n+    d = (float *) acc_deviceptr (b);\n+\n+    acc_unmap_data (b);\n+\n+    if (acc_is_present (b, N * sizeof (float)))\n+      abort ();\n+\n+    acc_free (d);\n+\n     d = (float *) acc_deviceptr (c);\n \n     acc_unmap_data (c);\n \n+    if (acc_is_present (c, N * sizeof (float)))\n+      abort ();\n+\n     acc_free (d);\n \n     for (i = 0; i < N; i++)"}, {"sha": "9cf73b31964c315c3f2a67e90b9d7166ef69b287", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-82.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e8c01cff1bee743a9d00e9a43303ec29fde233/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-82.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e8c01cff1bee743a9d00e9a43303ec29fde233/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-82.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-82.c?ref=d6e8c01cff1bee743a9d00e9a43303ec29fde233", "patch": "@@ -120,9 +120,13 @@ main (int argc, char **argv)\n \n   for (i = 0; i < N; i++)\n     {\n-      acc_copyout (a[i], nbytes);\n+      acc_memcpy_from_device (a[i], d_a[i], nbytes);\n       if (*a[i] != i)\n \tabort ();\n+\n+      acc_unmap_data (a[i]);\n+\n+      acc_free (d_a[i]);\n     }\n \n   free (streams);"}, {"sha": "3e8b42527cf9b3ac5f44aebbef80380dc1471145", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/nested-1.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e8c01cff1bee743a9d00e9a43303ec29fde233/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fnested-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e8c01cff1bee743a9d00e9a43303ec29fde233/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fnested-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fnested-1.c?ref=d6e8c01cff1bee743a9d00e9a43303ec29fde233", "patch": "@@ -517,7 +517,9 @@ main (int argc, char **argv)\n     if (!acc_is_present (c, (N * sizeof (float))))\n       abort ();\n \n-    acc_copyout (b, N * sizeof (float));\n+    d = (float *) acc_deviceptr (b);\n+\n+    acc_memcpy_from_device (b, d, N * sizeof (float));\n \n     for (i = 0; i < N; i++)\n     {\n@@ -534,6 +536,12 @@ main (int argc, char **argv)\n \n     acc_free (d);\n \n+    d = (float *) acc_deviceptr (b);\n+\n+    acc_unmap_data (b);\n+\n+    acc_free (d);\n+\n     d = (float *) acc_deviceptr (c);\n \n     acc_unmap_data (c);"}, {"sha": "db5b35b08d9f56b95eb8dae42d07141540f816b5", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/pr92843-1.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e8c01cff1bee743a9d00e9a43303ec29fde233/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92843-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e8c01cff1bee743a9d00e9a43303ec29fde233/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92843-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92843-1.c?ref=d6e8c01cff1bee743a9d00e9a43303ec29fde233", "patch": "@@ -0,0 +1,179 @@\n+/* Verify that 'acc_copyout' etc. is a no-op if there's still a structured\n+   reference count.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } } */\n+\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <openacc.h>\n+\n+\n+const int c0 = 58;\n+const int c1 = 81;\n+\n+static void\n+assign_array (char *array, size_t size, char value)\n+{\n+  for (size_t i = 0; i < size; ++i)\n+    array[i] = value;\n+}\n+\n+static void\n+verify_array (const char *array, size_t size, char value)\n+{\n+  for (size_t i = 0; i < size; ++i)\n+    assert (array[i] == value);\n+}\n+\n+\n+float global_var;\n+#pragma acc declare create (global_var)\n+\n+static void\n+test_acc_declare ()\n+{\n+  assert (acc_is_present (&global_var, sizeof global_var));\n+\n+  global_var = c0;\n+#pragma acc update device (global_var)\n+\n+  global_var = c1;\n+  acc_copyout (&global_var, sizeof global_var);\n+  assert (acc_is_present (&global_var, sizeof global_var));\n+  assert (global_var == c1);\n+\n+  global_var = c1;\n+  acc_copyout_finalize (&global_var, sizeof global_var);\n+  assert (acc_is_present (&global_var, sizeof global_var));\n+  assert (global_var == c1);\n+\n+  void *global_var_d_p = acc_deviceptr (&global_var);\n+  assert (global_var_d_p);\n+\n+  void *d_p = acc_copyin (&global_var, sizeof global_var);\n+  assert (d_p == global_var_d_p);\n+\n+  acc_copyout (&global_var, sizeof global_var);\n+  assert (acc_is_present (&global_var, sizeof global_var));\n+\n+  d_p = acc_copyin (&global_var, sizeof global_var);\n+  assert (d_p == global_var_d_p);\n+\n+  d_p = acc_copyin (&global_var, sizeof global_var);\n+  assert (d_p == global_var_d_p);\n+\n+  global_var = c1;\n+  acc_copyout_finalize (&global_var, sizeof global_var);\n+  assert (acc_is_present (&global_var, sizeof global_var));\n+  assert (global_var == c1);\n+\n+  global_var = c1;\n+  acc_copyout (&global_var, sizeof global_var);\n+  assert (acc_is_present (&global_var, sizeof global_var));\n+  assert (global_var == c1);\n+}\n+\n+\n+static void\n+test_acc_map_data ()\n+{\n+  const int N = 801;\n+\n+  char *h = (char *) malloc (N);\n+  assert (h);\n+  void *d = acc_malloc (N);\n+  assert (d);\n+  acc_map_data (h, d, N);\n+  assert (acc_is_present (h, N));\n+\n+  assign_array (h, N, c0);\n+#pragma acc update device (h[0:N])\n+\n+  assign_array (h, N, c1);\n+#pragma acc exit data copyout (h[0:N])\n+  assert (acc_is_present (h, N));\n+  verify_array (h, N, c1);\n+\n+  assign_array (h, N, c1);\n+#pragma acc exit data copyout (h[0:N]) finalize\n+  assert (acc_is_present (h, N));\n+  verify_array (h, N, c1);\n+\n+#pragma acc enter data copyin (h[0:N])\n+\n+  assign_array (h, N, c1);\n+#pragma acc exit data copyout (h[0:N])\n+  assert (acc_is_present (h, N));\n+  verify_array (h, N, c1);\n+\n+#pragma acc enter data copyin (h[0:N])\n+\n+#pragma acc enter data copyin (h[0:N])\n+\n+  assign_array (h, N, c1);\n+#pragma acc exit data copyout (h[0:N]) finalize\n+  assert (acc_is_present (h, N));\n+  verify_array (h, N, c1);\n+\n+  assign_array (h, N, c1);\n+#pragma acc exit data copyout (h[0:N])\n+  assert (acc_is_present (h, N));\n+  verify_array (h, N, c1);\n+}\n+\n+\n+static void\n+test_acc_data ()\n+{\n+#define N 23\n+  char h[N];\n+\n+  assign_array (h, N, c0);\n+#pragma acc data copyin (h)\n+  {\n+    assert (acc_is_present (h, sizeof h));\n+\n+    assign_array (h, N, c1);\n+    acc_copyout_finalize (h, sizeof h);\n+    assert (acc_is_present (h, sizeof h));\n+    verify_array (h, N, c1);\n+\n+    assign_array (h, N, c1);\n+    acc_copyout (h, sizeof h);\n+    assert (acc_is_present (h, sizeof h));\n+    verify_array (h, N, c1);\n+\n+    acc_copyin (h, sizeof h);\n+\n+    assign_array (h, N, c1);\n+    acc_copyout (h, sizeof h);\n+    assert (acc_is_present (h, sizeof h));\n+    verify_array (h, N, c1);\n+\n+    acc_copyin (h, sizeof h);\n+\n+    acc_copyin (h, sizeof h);\n+\n+    assign_array (h, N, c1);\n+    acc_copyout_finalize (h, sizeof h);\n+    assert (acc_is_present (h, sizeof h));\n+    verify_array (h, N, c1);\n+\n+    assign_array (h, N, c1);\n+    acc_copyout (h, sizeof h);\n+    assert (acc_is_present (h, sizeof h));\n+    verify_array (h, N, c1);\n+  }\n+#undef N\n+}\n+\n+\n+int\n+main ()\n+{\n+  test_acc_declare ();\n+  test_acc_map_data ();\n+  test_acc_data ();\n+\n+  return 0;\n+}"}]}