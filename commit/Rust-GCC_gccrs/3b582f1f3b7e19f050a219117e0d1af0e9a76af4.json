{"sha": "3b582f1f3b7e19f050a219117e0d1af0e9a76af4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I1ODJmMWYzYjdlMTlmMDUwYTIxOTExN2UwZDFhZjBlOWE3NmFmNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-09-12T18:33:13Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-09-12T18:33:13Z"}, "message": "re PR fortran/87284 (Allocation of class arrays with mold results in \"conditional jump or move depends on uninitialised value\")\n\n2018-09-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/87284\n\t* trans-expr.c (gfc_trans_class_init_assign): Access to\n\tto array elements of the dynamic type requires that the array\n\treference be added to the class expression and not the _data\n\tcomponent, unlike scalar expressions.\n\n2018-09-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/87284\n\t* gfortran.dg/allocate_with_mold_2.f90: New test.\n\nFrom-SVN: r264249", "tree": {"sha": "c9348caadcc91e4c780f6e543070c5a33405dc15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9348caadcc91e4c780f6e543070c5a33405dc15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b582f1f3b7e19f050a219117e0d1af0e9a76af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b582f1f3b7e19f050a219117e0d1af0e9a76af4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b582f1f3b7e19f050a219117e0d1af0e9a76af4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b582f1f3b7e19f050a219117e0d1af0e9a76af4/comments", "author": null, "committer": null, "parents": [{"sha": "c0cbe5260fab673f7cd755df2226422b88b28837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0cbe5260fab673f7cd755df2226422b88b28837", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0cbe5260fab673f7cd755df2226422b88b28837"}], "stats": {"total": 80, "additions": 79, "deletions": 1}, "files": [{"sha": "6249996ccbc3344c6373ffa8faf54b501e5cfa8a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b582f1f3b7e19f050a219117e0d1af0e9a76af4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b582f1f3b7e19f050a219117e0d1af0e9a76af4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3b582f1f3b7e19f050a219117e0d1af0e9a76af4", "patch": "@@ -1,3 +1,11 @@\n+2018-09-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/87284\n+\t* trans-expr.c (gfc_trans_class_init_assign): Access to\n+\tto array elements of the dynamic type requires that the array\n+\treference be added to the class expression and not the _data\n+\tcomponent, unlike scalar expressions.\n+\n 2018-09-11  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/87172"}, {"sha": "2596b8e151d4ac26aecf9230430e4bc13042d93a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b582f1f3b7e19f050a219117e0d1af0e9a76af4/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b582f1f3b7e19f050a219117e0d1af0e9a76af4/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=3b582f1f3b7e19f050a219117e0d1af0e9a76af4", "patch": "@@ -1505,7 +1505,6 @@ gfc_trans_class_init_assign (gfc_code *code)\n   gfc_start_block (&block);\n \n   lhs = gfc_copy_expr (code->expr1);\n-  gfc_add_data_component (lhs);\n \n   rhs = gfc_copy_expr (code->expr1);\n   gfc_add_vptr_component (rhs);\n@@ -1523,11 +1522,15 @@ gfc_trans_class_init_assign (gfc_code *code)\n     {\n       gfc_array_spec *tmparr = gfc_get_array_spec ();\n       *tmparr = *CLASS_DATA (code->expr1)->as;\n+      /* Adding the array ref to the class expression results in correct\n+\t indexing to the dynamic type.  */\n       gfc_add_full_array_ref (lhs, tmparr);\n       tmp = gfc_trans_class_array_init_assign (rhs, lhs, code->expr1);\n     }\n   else\n     {\n+      /* Scalar initialization needs the _data component.  */\n+      gfc_add_data_component (lhs);\n       sz = gfc_copy_expr (code->expr1);\n       gfc_add_vptr_component (sz);\n       gfc_add_size_component (sz);"}, {"sha": "4cd8859e2bf551a6a682eaafd8ae91a77ed94919", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b582f1f3b7e19f050a219117e0d1af0e9a76af4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b582f1f3b7e19f050a219117e0d1af0e9a76af4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3b582f1f3b7e19f050a219117e0d1af0e9a76af4", "patch": "@@ -1,3 +1,8 @@\n+2018-09-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/87284\n+\t* gfortran.dg/allocate_with_mold_2.f90: New test.\n+\n 2018-09-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/82853"}, {"sha": "fcf7a8a44250bf319a5e3e73733fcf051153b94b", "filename": "gcc/testsuite/gfortran.dg/allocate_with_mold_2.f90", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b582f1f3b7e19f050a219117e0d1af0e9a76af4/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_mold_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b582f1f3b7e19f050a219117e0d1af0e9a76af4/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_mold_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_mold_2.f90?ref=3b582f1f3b7e19f050a219117e0d1af0e9a76af4", "patch": "@@ -0,0 +1,62 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Test the fix for PR87284 in which the indexing in allocate with mold\n+! was incorrect for class array initialization and resulted in the valgrind\n+! error:\n+! \"Conditional jump or move depends on uninitialised value(s)\" at line 42.\n+!\n+! Contributed by Andrew Baldwin on clf.\n+!\n+      MODULE INTS_TYPE_MODULE\n+        TYPE, ABSTRACT :: BASE_TYPE\n+        END TYPE BASE_TYPE\n+\n+        TYPE, EXTENDS (BASE_TYPE) :: INTS_TYPE\n+          INTEGER, ALLOCATABLE :: INTS(:)\n+        END TYPE INTS_TYPE\n+      CONTAINS\n+        SUBROUTINE MOLD_ALLOCATE (IT_OBJS, MOLD_OBJ)\n+          CLASS (BASE_TYPE), ALLOCATABLE, INTENT (OUT) :: IT_OBJS(:)\n+          CLASS (BASE_TYPE), INTENT (IN) :: MOLD_OBJ\n+\n+          ALLOCATE (IT_OBJS(2), mold = MOLD_OBJ)\n+\n+          RETURN\n+        END SUBROUTINE MOLD_ALLOCATE\n+      END MODULE INTS_TYPE_MODULE\n+\n+      PROGRAM MFE\n+        USE INTS_TYPE_MODULE\n+        IMPLICIT NONE\n+\n+        CLASS (BASE_TYPE), ALLOCATABLE :: IT_OBJS(:)\n+        INTEGER :: I\n+        TYPE (INTS_TYPE) :: MOLD_OBJ\n+\n+        ALLOCATE (INTS_TYPE :: IT_OBJS(2))\n+\n+        SELECT TYPE (IT_OBJS)\n+        TYPE IS (INTS_TYPE)\n+          ALLOCATE (IT_OBJS(1)%INTS(10))\n+\n+          ALLOCATE (IT_OBJS(2)%INTS(10))\n+        END SELECT\n+\n+\n+        DEALLOCATE (IT_OBJS)\n+\n+        CALL MOLD_ALLOCATE (IT_OBJS, MOLD_OBJ)\n+\n+        IF (ALLOCATED(IT_OBJS)) THEN\n+          IF (SIZE(IT_OBJS) .GE. 2) THEN\n+            SELECT TYPE (IT_OBJS)\n+            TYPE IS (INTS_TYPE)\n+              ALLOCATE (IT_OBJS(1)%INTS(10))\n+\n+              ALLOCATE (IT_OBJS(2)%INTS(10))\n+            END SELECT\n+          END IF\n+        END IF\n+      END PROGRAM MFE\n+! { dg-final { scan-tree-dump-times \"it_objs->_vptr->_size\" 1 \"original\" } }"}]}