{"sha": "84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRkNjU4MTQxZTZiMWQzMTViMGViYTVmMTlhM2M1N2E3YzUxZmQzZg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-04-23T00:59:54Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-04-23T00:59:54Z"}, "message": "[multiple changes]\n\n2005-04-22  Diego Novillo  <dnovillo@redhat.com>\n\n\t* Makefile.in (tree-into-ssa.o): Add dependency on PARAMS_H.\n\t* lambda-code.c (perfect_nestify): Mark virtual operands in\n\tthe moved statement for renaming.\n\t* params.def (PARAM_MIN_VIRTUAL_MAPPINGS): Define.\n\t(PARAM_VIRTUAL_MAPPINGS_TO_SYMS_RATIO): Define.\n\t* params.h (MIN_VIRTUAL_MAPPINGS): Define.\n\t(VIRTUAL_MAPPINGS_TO_SYMS_RATIO): Define.\n\t* tree-flow.h (struct var_ann_d): Update comments.\n\t(rewrite_to_new_ssa_names_bb, rewrite_to_new_ssa_names,\n\tallocate_ssa_names, find_phi_node_for, dump_tree_ssa,\n\tdebug_tree_ssa, debug_def_blocks, dump_tree_ssa_stats,\n\tdebug_tree_ssa_stats, rewrite_ssa_into_ssa,\n\tdump_repl_tbl, debug_repl_tbl, dump_names_replaced_by,\n\tdebug_names_replaced_by): Remove declarations.\n\t(delete_update_ssa, get_current_def, set_current_def): Declare.\n\t(rewrite_into_loop_closed_ssa): Add new argument.  Update\n\tall callers.\n\t* tree-into-ssa.c: Include params.h.\n\t(old_virtual_ssa_names): Remove.  Update all users.\n\t(need_to_replace_names_p): Remove.  Update all users.\n\t(struct update_ssa_stats_d): Declare.\n\t(update_ssa_stats): New local.\n\t(dump_tree_ssa, debug_tree_ssa, debug_def_blocks,\n\tdump_tree_ssa_stats, debug_tree_ssa_stats,\n\tdump_update_ssa, debug_update_ssa,\n\tdump_names_replaced_by, debug_names_replaced_by): Declare.\n\t(get_current_def, set current_def): Make extern.\n\t(is_old_name, is_new_name): Protect against references\n\tpast the end of the sets.\n\t(add_new_name_mapping): Assert that OLD and NEW are\n\tdifferent SSA names for the same symbol.\n\tWhen adding a virtual mapping, update stats for virtual\n\tmapping heuristic.\n\t(insert_phi_nodes_for): If UPDATE_P is true, create the\n\tLHS of the new PHI by duplicating SSA name VAR.\n\t(insert_phi_nodes_1): Remove.  Update all users.\n\t(insert_phi_nodes): Remove second argument.  Update all\n\tusers.\n\t(maybe_replace_use, maybe_replace_def): New.\n\t(rewrite_update_stmt): Call them.\n\t(mark_def_interesting): Remove calls to is_gimple_reg.\n\t(prepare_phi_args_for_update): Remove.  Update all users.\n\t(prepare_block_for_update): Only process virtual operands\n\tand GIMPLE registers in normal form.\n\t(prepare_use_sites_for): New.\n\t(prepare_names_to_update): Rename from prepare_def_sites.\n\tCall prepare_use_sites_for.\n\t(dump_update_ssa): Rename from dump_repl_tbl.\n\tUpdate all users.\n\tShow statistics for virtual mapping heuristic.\n\t(debug_update_ssa): Rename from debug_debug_repl_tbl.\n\t(init_update_ssa): Initialize UPDATE_SSA_STATS.\n\t(delete_update_ssa): Make extern.\n\t(mark_set_for_renaming): If the set is empty, do nothing.\n\t(release_ssa_name_after_update_ssa): Update comment.\n\t(insert_updated_phi_nodes_for): Do not remove existing\n\tPHI nodes for symbols.\n\t(switch_virtuals_to_full_rewrite_p): New.\n\t(switch_virtuals_to_full_rewrite): New.\n\t(update_ssa): Call them.\n\tClear REWRITE_THIS_STMT and REGISTER_DEFS_IN_THIS_STMT\n\tfor every statement before updating.\n\tIf all the names in NEW_SSA_NAMES have been marked for\n\tremoval, do nothing.\n\tOnly start at the top of the CFG if there are symbols in\n\tSYMS_TO_RENAME.\n\t(ssa_rewrite_finalize_block): Remove.\n\t(ssa_register_new_def): Remove.\n\t(ssa_rewrite_stmt): Remove.\n\t(ssa_rewrite_phi_arguments): Remove.\n\t(ssa_rewrite_initialize_block): Remove.\n\t(ssa_mark_def_sites): Remove.\n\t(ssa_mark_def_sites_initialize_block): Remove.\n\t(ssa_mark_phi_uses): Remove.\n\t(rewrite_ssa_into_ssa): Remove.\n\t* tree-phinodes.c (find_phi_node_for): Remove.\n\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely):\n\tCall update_ssa.\n\t* tree-ssa-loop-unswitch.c (tree_ssa_unswitch_loops):\n\tRemove calls to verify_dominators and\n\tverify_loop_structure.\n\t(tree_unswitch_single_loop): Call update_ssa.\n\t* tree-ssa.c (verify_ssa): Assert that need_ssa_update_p\n\treturns false.\n\tCall verify_stmts.\n\t(delete_tree_ssa): Assert that need_ssa_update_p returns\n\tfalse.\n\t* tree-vect-transform.c (vect_transform_loop): Call update_ssa.\n\t* tree-vectorizer.c (allocate_new_names, rename_def_op,\n\tfree_new_names): Remove.  Update all users.\n\t(rename_use_op): Call get_current_def.\n\t(rename_variables_in_bb): Do not handle any real or\n\tvirtual definition.\n\t(slpeel_update_phis_for_duplicate_loop): Call\n\tget_current_def and set_current_def instead of using\n\tSSA_NAME_AUX.\n\t(slpeel_update_phi_nodes_for_guard2): Reformat comments.\n\t(slpeel_can_duplicate_loop_p): Call need_ssa_update_p,\n\tssa_names_to_replace and delete_update_ssa.\n\t* doc/invoke.texi: Document --param min-virtual-mappings\n\tand --param virtual-mappings-ratio.\n\n2005-04-22  Zdenek Dvorak  <dvorakz@suse.cz>\n\t    Diego Novillo  <dnovillo@redhat.com>\n\n\t* tree-cfg.c (tree_duplicate_bb): Call create_new_def_for\n\tfor newly created PHI nodes.\n\tCall create_new_def_for for every new V_MAY_DEF and\n\tV_MUST_DEF on the copied statement.\n\t(struct ssa_name_map_entry): Remove.\n\t(ssa_name_map_entry_hash): Remove.\n\t(ssa_name_map_entry_eq): Remove.\n\t(allocate_ssa_names): Remove.\n\t(rewrite_to_new_ssa_names_def): Remove.\n\t(rewrite_to_new_ssa_names_use): Remove.\n\t(rewrite_to_new_ssa_names_bb): Remove.\n\t(rewrite_to_new_ssa_names): Remove.\n\t(tree_duplicate_sese_region): Remove variables ver,\n\tdefinitions, phi, ssa_name_map and bi.\n\tCall need_ssa_update_p instead of any_marked_for_rewrite_p.\n\tCall update_ssa.\n\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Call\n\tupdate_ssa instead of rewrite_ssa_into_ssa.\n\t* tree-ssa-loop-manip.c (add_exit_phis_edge): Call\n\tcreate_new_def_for.\n\t(find_uses_to_rename_use): Add argument 'need_phis'.\n\t(find_uses_to_rename_stmt): Do not scan virtual operands.\n\t(find_uses_to_rename): Only scan PHI nodes for\n\tnon-virtual names.\n\t(rewrite_into_loop_closed_ssa): Call update_ssa.\n\t(check_loop_closed_ssa_use): Ignore virtual operands.\n\t(check_loop_closed_ssa_stmt): Likewise.\n\t(verify_loop_closed_ssa): Do nothing if CURRENT_LOOPS is\n\tNULL.\n\t(rename_variables, set_phi_def_stmts): Remove.\n\t(tree_duplicate_loop_to_header_edge): Reformat comment.\n\tRemove variables BB, I and DEFINITIONS.\n\tCall need_ssa_update_p.\n\tCall update_ssa.\n\t(lv_adjust_loop_header_phi): Reformat comment.\n\t* tree-ssanames.c (ssa_names_to_rewrite): Remove.\n\t(marked_for_rewrite_p, any_marked_for_rewrite_p,\n\tmark_for_rewrite, unmark_all_for_rewrite,\n\tmarked_ssa_names): Remove.  Update all users.\n\t(release_ssa_name): If VAR has been registered for SSA\n\tupdating, do nothing.\n\t* tree-vrp.c (new_ssa_names, old_ssa_names): Remove.\n\t(build_assert_expr_for): Call register_new_name_mapping.\n\t(insert_range_assertions): Update call to update_ssa.\n\t* tree.h (mark_for_rewrite, unmark_all_for_rewrite,\n\tmarked_for_rewrite_p, any_marked_for_rewrite_p,\n\tmarked_ssa_names): Remove.\n\nFrom-SVN: r98599", "tree": {"sha": "91adcaea930945439c930df02da120abe55f1ac1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91adcaea930945439c930df02da120abe55f1ac1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/comments", "author": null, "committer": null, "parents": [{"sha": "be240c882fab19b69247c4d9a252873fd7ebc59c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be240c882fab19b69247c4d9a252873fd7ebc59c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be240c882fab19b69247c4d9a252873fd7ebc59c"}], "stats": {"total": 2331, "additions": 803, "deletions": 1528}, "files": [{"sha": "9bfd962b37b27ef30050423fce86402f34ef15cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -1,3 +1,158 @@\n+2005-04-22  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* Makefile.in (tree-into-ssa.o): Add dependency on PARAMS_H.\n+\t* lambda-code.c (perfect_nestify): Mark virtual operands in\n+\tthe moved statement for renaming.\n+\t* params.def (PARAM_MIN_VIRTUAL_MAPPINGS): Define.\n+\t(PARAM_VIRTUAL_MAPPINGS_TO_SYMS_RATIO): Define.\n+\t* params.h (MIN_VIRTUAL_MAPPINGS): Define.\n+\t(VIRTUAL_MAPPINGS_TO_SYMS_RATIO): Define.\n+\t* tree-flow.h (struct var_ann_d): Update comments.\n+\t(rewrite_to_new_ssa_names_bb, rewrite_to_new_ssa_names,\n+\tallocate_ssa_names, find_phi_node_for, dump_tree_ssa,\n+\tdebug_tree_ssa, debug_def_blocks, dump_tree_ssa_stats,\n+\tdebug_tree_ssa_stats, rewrite_ssa_into_ssa,\n+\tdump_repl_tbl, debug_repl_tbl, dump_names_replaced_by,\n+\tdebug_names_replaced_by): Remove declarations.\n+\t(delete_update_ssa, get_current_def, set_current_def): Declare.\n+\t(rewrite_into_loop_closed_ssa): Add new argument.  Update\n+\tall callers.\n+\t* tree-into-ssa.c: Include params.h.\n+\t(old_virtual_ssa_names): Remove.  Update all users.\n+\t(need_to_replace_names_p): Remove.  Update all users.\n+\t(struct update_ssa_stats_d): Declare.\n+\t(update_ssa_stats): New local.\n+\t(dump_tree_ssa, debug_tree_ssa, debug_def_blocks,\n+\tdump_tree_ssa_stats, debug_tree_ssa_stats,\n+\tdump_update_ssa, debug_update_ssa,\n+\tdump_names_replaced_by, debug_names_replaced_by): Declare.\n+\t(get_current_def, set current_def): Make extern.\n+\t(is_old_name, is_new_name): Protect against references\n+\tpast the end of the sets.\n+\t(add_new_name_mapping): Assert that OLD and NEW are\n+\tdifferent SSA names for the same symbol.\n+\tWhen adding a virtual mapping, update stats for virtual\n+\tmapping heuristic.\n+\t(insert_phi_nodes_for): If UPDATE_P is true, create the\n+\tLHS of the new PHI by duplicating SSA name VAR.\n+\t(insert_phi_nodes_1): Remove.  Update all users.\n+\t(insert_phi_nodes): Remove second argument.  Update all\n+\tusers.\n+\t(maybe_replace_use, maybe_replace_def): New.\n+\t(rewrite_update_stmt): Call them.\n+\t(mark_def_interesting): Remove calls to is_gimple_reg.\n+\t(prepare_phi_args_for_update): Remove.  Update all users.\n+\t(prepare_block_for_update): Only process virtual operands\n+\tand GIMPLE registers in normal form.\n+\t(prepare_use_sites_for): New.\n+\t(prepare_names_to_update): Rename from prepare_def_sites.\n+\tCall prepare_use_sites_for.\n+\t(dump_update_ssa): Rename from dump_repl_tbl.\n+\tUpdate all users.\n+\tShow statistics for virtual mapping heuristic.\n+\t(debug_update_ssa): Rename from debug_debug_repl_tbl.\n+\t(init_update_ssa): Initialize UPDATE_SSA_STATS.\n+\t(delete_update_ssa): Make extern.\n+\t(mark_set_for_renaming): If the set is empty, do nothing.\n+\t(release_ssa_name_after_update_ssa): Update comment.\n+\t(insert_updated_phi_nodes_for): Do not remove existing\n+\tPHI nodes for symbols.\n+\t(switch_virtuals_to_full_rewrite_p): New.\n+\t(switch_virtuals_to_full_rewrite): New.\n+\t(update_ssa): Call them.\n+\tClear REWRITE_THIS_STMT and REGISTER_DEFS_IN_THIS_STMT\n+\tfor every statement before updating.\n+\tIf all the names in NEW_SSA_NAMES have been marked for\n+\tremoval, do nothing.\n+\tOnly start at the top of the CFG if there are symbols in\n+\tSYMS_TO_RENAME.\n+\t(ssa_rewrite_finalize_block): Remove.\n+\t(ssa_register_new_def): Remove.\n+\t(ssa_rewrite_stmt): Remove.\n+\t(ssa_rewrite_phi_arguments): Remove.\n+\t(ssa_rewrite_initialize_block): Remove.\n+\t(ssa_mark_def_sites): Remove.\n+\t(ssa_mark_def_sites_initialize_block): Remove.\n+\t(ssa_mark_phi_uses): Remove.\n+\t(rewrite_ssa_into_ssa): Remove.\n+\t* tree-phinodes.c (find_phi_node_for): Remove.\n+\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely):\n+\tCall update_ssa.\n+\t* tree-ssa-loop-unswitch.c (tree_ssa_unswitch_loops):\n+\tRemove calls to verify_dominators and\n+\tverify_loop_structure.\n+\t(tree_unswitch_single_loop): Call update_ssa.\n+\t* tree-ssa.c (verify_ssa): Assert that need_ssa_update_p\n+\treturns false.\n+\tCall verify_stmts.\n+\t(delete_tree_ssa): Assert that need_ssa_update_p returns\n+\tfalse.\n+\t* tree-vect-transform.c (vect_transform_loop): Call update_ssa.\n+\t* tree-vectorizer.c (allocate_new_names, rename_def_op,\n+\tfree_new_names): Remove.  Update all users.\n+\t(rename_use_op): Call get_current_def.\n+\t(rename_variables_in_bb): Do not handle any real or\n+\tvirtual definition.\n+\t(slpeel_update_phis_for_duplicate_loop): Call\n+\tget_current_def and set_current_def instead of using\n+\tSSA_NAME_AUX.\n+\t(slpeel_update_phi_nodes_for_guard2): Reformat comments.\n+\t(slpeel_can_duplicate_loop_p): Call need_ssa_update_p,\n+\tssa_names_to_replace and delete_update_ssa.\n+\t* doc/invoke.texi: Document --param min-virtual-mappings\n+\tand --param virtual-mappings-ratio.\n+\n+2005-04-22  Zdenek Dvorak  <dvorakz@suse.cz>\n+\t    Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-cfg.c (tree_duplicate_bb): Call create_new_def_for\n+\tfor newly created PHI nodes.\n+\tCall create_new_def_for for every new V_MAY_DEF and\n+\tV_MUST_DEF on the copied statement.\n+\t(struct ssa_name_map_entry): Remove.\n+\t(ssa_name_map_entry_hash): Remove.\n+\t(ssa_name_map_entry_eq): Remove.\n+\t(allocate_ssa_names): Remove.\n+\t(rewrite_to_new_ssa_names_def): Remove.\n+\t(rewrite_to_new_ssa_names_use): Remove.\n+\t(rewrite_to_new_ssa_names_bb): Remove.\n+\t(rewrite_to_new_ssa_names): Remove.\n+\t(tree_duplicate_sese_region): Remove variables ver,\n+\tdefinitions, phi, ssa_name_map and bi.\n+\tCall need_ssa_update_p instead of any_marked_for_rewrite_p.\n+\tCall update_ssa.\n+\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Call\n+\tupdate_ssa instead of rewrite_ssa_into_ssa.\n+\t* tree-ssa-loop-manip.c (add_exit_phis_edge): Call\n+\tcreate_new_def_for.\n+\t(find_uses_to_rename_use): Add argument 'need_phis'.\n+\t(find_uses_to_rename_stmt): Do not scan virtual operands.\n+\t(find_uses_to_rename): Only scan PHI nodes for\n+\tnon-virtual names.\n+\t(rewrite_into_loop_closed_ssa): Call update_ssa.\n+\t(check_loop_closed_ssa_use): Ignore virtual operands.\n+\t(check_loop_closed_ssa_stmt): Likewise.\n+\t(verify_loop_closed_ssa): Do nothing if CURRENT_LOOPS is\n+\tNULL.\n+\t(rename_variables, set_phi_def_stmts): Remove.\n+\t(tree_duplicate_loop_to_header_edge): Reformat comment.\n+\tRemove variables BB, I and DEFINITIONS.\n+\tCall need_ssa_update_p.\n+\tCall update_ssa.\n+\t(lv_adjust_loop_header_phi): Reformat comment.\n+\t* tree-ssanames.c (ssa_names_to_rewrite): Remove.\n+\t(marked_for_rewrite_p, any_marked_for_rewrite_p,\n+\tmark_for_rewrite, unmark_all_for_rewrite,\n+\tmarked_ssa_names): Remove.  Update all users.\n+\t(release_ssa_name): If VAR has been registered for SSA\n+\tupdating, do nothing.\n+\t* tree-vrp.c (new_ssa_names, old_ssa_names): Remove.\n+\t(build_assert_expr_for): Call register_new_name_mapping.\n+\t(insert_range_assertions): Update call to update_ssa.\n+\t* tree.h (mark_for_rewrite, unmark_all_for_rewrite,\n+\tmarked_for_rewrite_p, any_marked_for_rewrite_p,\n+\tmarked_ssa_names): Remove.\n+\n 2005-04-22  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-dom.c (block_defs_stack): Remove, no longer needed."}, {"sha": "70ffa3d33d9480a03fcbdd13672abafeef276953", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -1635,7 +1635,7 @@ tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h diagnostic.h \\\n    errors.h toplev.h function.h $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) langhooks.h domwalk.h tree-pass.h \\\n-   $(GGC_H)\n+   $(GGC_H) $(PARAMS_H)\n tree-outof-ssa.o : tree-outof-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h diagnostic.h \\\n    errors.h toplev.h function.h $(TIMEVAR_H) \\"}, {"sha": "8419422c61c0f5c4bb224b6f3f7f8a2bba26f1fc", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -5827,6 +5827,18 @@ Small integer constants can use a shared data structure, reducing the\n compiler's memory usage and increasing its speed.  This sets the maximum\n value of a shared integer constant's.  The default value is 256.\n \n+@item min-virtual-mappings\n+Specifies the minimum number of virtual mappings in the incremental\n+SSA updater that should be registered to trigger the virtual mappings\n+heuristic defined by virtual-mappings-ratio.  The default value is\n+100.\n+\n+@item virtual-mappings-ratio\n+If the number of virtual mappings is virtual-mappings-ratio bigger\n+than the number of virtual symbols to be updated, then the incremental\n+SSA updater switches to a full update for those symbols.  The default\n+ratio is 3.\n+\n @end table\n @end table\n "}, {"sha": "a81af8f8314daed84566a186280aca6ee1936785", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -2443,19 +2443,29 @@ perfect_nestify (struct loops *loops,\n \t     incremented when we do.  */\n \t  for (bsi = bsi_start (bbs[i]); !bsi_end_p (bsi);)\n \t    { \n-\t      tree stmt = bsi_stmt (bsi);\n+\t      ssa_op_iter i;\n+\t      tree n, stmt = bsi_stmt (bsi);\n+\n \t      if (stmt == exit_condition\n \t\t  || not_interesting_stmt (stmt)\n \t\t  || stmt_is_bumper_for_loop (loop, stmt))\n \t\t{\n \t\t  bsi_next (&bsi);\n \t\t  continue;\n \t\t}\n+\n \t      replace_uses_of_x_with_y (stmt, oldivvar, ivvar);\n \t      bsi_move_before (&bsi, &tobsi);\n+\n+\t      /* If the statement has any virtual operands, they may\n+\t\t need to be rewired because the original loop may\n+\t\t still reference them.  */\n+\t      FOR_EACH_SSA_TREE_OPERAND (n, stmt, i, SSA_OP_ALL_VIRTUALS)\n+\t\tmark_sym_for_renaming (SSA_NAME_VAR (n));\n \t    }\n \t}\n     }\n+\n   free (bbs);\n   return perfect_nest_p (loop);\n }"}, {"sha": "d9871a5b00b9a6a404a0116e33c02f28269b649e", "filename": "gcc/params.def", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -443,6 +443,30 @@ DEFPARAM (PARAM_INTEGER_SHARE_LIMIT,\n \t  \"The upper bound for sharing integer constants\",\n \t  256, 2, 2)\n \n+/* Incremental SSA updates for virtual operands may be very slow if\n+   there is a large number of mappings to process.  In those cases, it\n+   is faster to rewrite the virtual symbols from scratch as if they\n+   had been recently introduced.  This heuristic cannot be applied to\n+   SSA mappings for real SSA names, only symbols kept in FUD chains.\n+\n+   PARAM_MIN_VIRTUAL_MAPPINGS specifies the minimum number of virtual\n+   mappings that should be registered to trigger the heuristic.\n+   \n+   PARAM_VIRTUAL_MAPPINGS_TO_SYMS_RATIO specifies the ratio between\n+   mappings and symbols.  If the number of virtual mappings is\n+   PARAM_VIRTUAL_MAPPINGS_TO_SYMS_RATIO bigger than the number of\n+   virtual symbols to be updated, then the updater switches to a full\n+   update for those symbols.  */\n+DEFPARAM (PARAM_MIN_VIRTUAL_MAPPINGS,\n+\t  \"min-virtual-mappings\",\n+\t  \"Minimum number of virtual mappings to consider switching to full virtual renames\",\n+\t  100, 0, 0)\n+\n+DEFPARAM (PARAM_VIRTUAL_MAPPINGS_TO_SYMS_RATIO,\n+\t  \"virtual-mappings-ratio\",\n+\t  \"Ratio between virtual mappings and virtual symbols to do full virtual renames\",\n+\t  3, 0, 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "fc1c377fb3b313c588552c01f0da12b3592ffebc", "filename": "gcc/params.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -139,4 +139,8 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_INTEGER_SHARE_LIMIT)\n #define MAX_LAST_VALUE_RTL \\\n   PARAM_VALUE (PARAM_MAX_LAST_VALUE_RTL)\n+#define MIN_VIRTUAL_MAPPINGS \\\n+  PARAM_VALUE (PARAM_MIN_VIRTUAL_MAPPINGS)\n+#define VIRTUAL_MAPPINGS_TO_SYMS_RATIO \\\n+  PARAM_VALUE (PARAM_VIRTUAL_MAPPINGS_TO_SYMS_RATIO)\n #endif /* ! GCC_PARAMS_H */"}, {"sha": "a73d72228793743e0c90ff6bba4ef67978c927b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -1,3 +1,7 @@\n+2005-04-22  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/ltrans-4.c: Fix typo in dg-options.\n+\n 2005-04-22  Jeff Law  <law@redhat.com>\n \n \t* gcc.dg/uninit-5.c: Remove xfails."}, {"sha": "4e60eae4d51f81a788a7ed2af49931f27a84864d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-4.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O20 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n \n double u[1782225];\n int foo(int N, int *res)"}, {"sha": "bf4d934e9737203479c22043d634391fb6bb0a70", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 32, "deletions": 244, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -963,7 +963,7 @@ cleanup_tree_cfg_loop (void)\n   /* This usually does nothing.  But sometimes parts of cfg that originally\n      were inside a loop get out of it due to edge removal (since they\n      become unreachable by back edges from latch).  */\n-  rewrite_into_loop_closed_ssa (changed_bbs);\n+  rewrite_into_loop_closed_ssa (changed_bbs, TODO_update_ssa);\n \n   BITMAP_FREE (changed_bbs);\n \n@@ -4698,6 +4698,7 @@ tree_can_duplicate_bb_p (basic_block bb ATTRIBUTE_UNUSED)\n   return true;\n }\n \n+\n /* Create a duplicate of the basic block BB.  NOTE: This does not\n    preserve SSA form.  */\n \n@@ -4706,45 +4707,49 @@ tree_duplicate_bb (basic_block bb)\n {\n   basic_block new_bb;\n   block_stmt_iterator bsi, bsi_tgt;\n-  tree phi, val;\n-  ssa_op_iter op_iter;\n+  tree phi;\n \n   new_bb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n \n-  /* First copy the phi nodes.  We do not copy phi node arguments here,\n-     since the edges are not ready yet.  Keep the chain of phi nodes in\n-     the same order, so that we can add them later.  */\n+  /* Copy the PHI nodes.  We ignore PHI node arguments here because\n+     the incoming edges have not been setup yet.  */\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n-      mark_for_rewrite (PHI_RESULT (phi));\n-      create_phi_node (PHI_RESULT (phi), new_bb);\n+      tree copy = create_phi_node (PHI_RESULT (phi), new_bb);\n+      create_new_def_for (PHI_RESULT (copy), copy, PHI_RESULT_PTR (copy));\n     }\n+\n+  /* Keep the chain of PHI nodes in the same order so that they can be\n+     updated by ssa_redirect_edge.  */\n   set_phi_nodes (new_bb, phi_reverse (phi_nodes (new_bb)));\n \n   bsi_tgt = bsi_start (new_bb);\n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n-      tree stmt = bsi_stmt (bsi);\n-      tree copy;\n+      def_operand_p def_p;\n+      ssa_op_iter op_iter;\n+      tree stmt, copy;\n \n+      stmt = bsi_stmt (bsi);\n       if (TREE_CODE (stmt) == LABEL_EXPR)\n \tcontinue;\n \n-      FOR_EACH_SSA_TREE_OPERAND (val, stmt, op_iter, SSA_OP_ALL_DEFS)\n-\tmark_for_rewrite (val);\n-\n+      /* Create a new copy of STMT and duplicate STMT's virtual\n+\t operands.  */\n       copy = unshare_expr (stmt);\n-\n-      /* Copy also the virtual operands.  */\n-      get_stmt_ann (copy);\n-      copy_virtual_operands (copy, stmt);\n-      \n       bsi_insert_after (&bsi_tgt, copy, BSI_NEW_STMT);\n+      copy_virtual_operands (copy, stmt);\n+\n+      /* Create new names for all the definitions created by COPY and\n+\t add replacement mappings for each new name.  */\n+      FOR_EACH_SSA_DEF_OPERAND (def_p, copy, op_iter, SSA_OP_ALL_DEFS)\n+\tcreate_new_def_for (DEF_FROM_PTR (def_p), copy, def_p);\n     }\n \n   return new_bb;\n }\n \n+\n /* Basic block BB_COPY was created by code duplication.  Add phi node\n    arguments for edges going out of BB_COPY.  The blocks that were\n    duplicated have rbi->duplicated set to one.  */\n@@ -4788,8 +4793,6 @@ add_phi_args_after_copy_bb (basic_block bb_copy)\n \t   phi = phi_next, phi_copy = PHI_CHAIN (phi_copy))\n \t{\n \t  phi_next = PHI_CHAIN (phi);\n-\n-\t  gcc_assert (PHI_RESULT (phi) == PHI_RESULT (phi_copy));\n \t  def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n \t  add_phi_arg (phi_copy, def, e_copy);\n \t}\n@@ -4815,193 +4818,6 @@ add_phi_args_after_copy (basic_block *region_copy, unsigned n_region)\n     region_copy[i]->rbi->duplicated = 0;\n }\n \n-/* Maps the old ssa name FROM_NAME to TO_NAME.  */\n-\n-struct ssa_name_map_entry\n-{\n-  tree from_name;\n-  tree to_name;\n-};\n-\n-/* Hash function for ssa_name_map_entry.  */\n-\n-static hashval_t\n-ssa_name_map_entry_hash (const void *entry)\n-{\n-  const struct ssa_name_map_entry *en = entry;\n-  return SSA_NAME_VERSION (en->from_name);\n-}\n-\n-/* Equality function for ssa_name_map_entry.  */\n-\n-static int\n-ssa_name_map_entry_eq (const void *in_table, const void *ssa_name)\n-{\n-  const struct ssa_name_map_entry *en = in_table;\n-\n-  return en->from_name == ssa_name;\n-}\n-\n-/* Allocate duplicates of ssa names in list DEFINITIONS and store the mapping\n-   to MAP.  */\n-\n-void\n-allocate_ssa_names (bitmap definitions, htab_t *map)\n-{\n-  tree name;\n-  struct ssa_name_map_entry *entry;\n-  PTR *slot;\n-  unsigned ver;\n-  bitmap_iterator bi;\n-\n-  if (!*map)\n-    *map = htab_create (10, ssa_name_map_entry_hash,\n-\t\t\tssa_name_map_entry_eq, free);\n-  EXECUTE_IF_SET_IN_BITMAP (definitions, 0, ver, bi)\n-    {\n-      name = ssa_name (ver);\n-      slot = htab_find_slot_with_hash (*map, name, SSA_NAME_VERSION (name),\n-\t\t\t\t       INSERT);\n-      if (*slot)\n-\tentry = *slot;\n-      else\n-\t{\n-\t  entry = xmalloc (sizeof (struct ssa_name_map_entry));\n-\t  entry->from_name = name;\n-\t  *slot = entry;\n-\t}\n-      entry->to_name = duplicate_ssa_name (name, SSA_NAME_DEF_STMT (name));\n-    }\n-}\n-\n-/* Rewrite the definition DEF in statement STMT to new ssa name as specified\n-   by the mapping MAP.  */\n-\n-static void\n-rewrite_to_new_ssa_names_def (def_operand_p def, tree stmt, htab_t map)\n-{\n-  tree name = DEF_FROM_PTR (def);\n-  struct ssa_name_map_entry *entry;\n-\n-  gcc_assert (TREE_CODE (name) == SSA_NAME);\n-\n-  entry = htab_find_with_hash (map, name, SSA_NAME_VERSION (name));\n-  if (!entry)\n-    return;\n-\n-  SET_DEF (def, entry->to_name);\n-  SSA_NAME_DEF_STMT (entry->to_name) = stmt;\n-}\n-\n-/* Rewrite the USE to new ssa name as specified by the mapping MAP.  */\n-\n-static void\n-rewrite_to_new_ssa_names_use (use_operand_p use, htab_t map)\n-{\n-  tree name = USE_FROM_PTR (use);\n-  struct ssa_name_map_entry *entry;\n-\n-  if (TREE_CODE (name) != SSA_NAME)\n-    return;\n-\n-  entry = htab_find_with_hash (map, name, SSA_NAME_VERSION (name));\n-  if (!entry)\n-    return;\n-\n-  SET_USE (use, entry->to_name);\n-}\n-\n-/* Rewrite the ssa names in basic block BB to new ones as specified by the\n-   mapping MAP.  */\n-\n-void\n-rewrite_to_new_ssa_names_bb (basic_block bb, htab_t map)\n-{\n-  unsigned i;\n-  edge e;\n-  edge_iterator ei;\n-  tree phi, stmt;\n-  block_stmt_iterator bsi;\n-  use_optype uses;\n-  vuse_optype vuses;\n-  def_optype defs;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  stmt_ann_t ann;\n-\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e->flags & EDGE_ABNORMAL)\n-      break;\n-\n-  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-    {\n-      rewrite_to_new_ssa_names_def (PHI_RESULT_PTR (phi), phi, map);\n-      if (e)\n-\tSSA_NAME_OCCURS_IN_ABNORMAL_PHI (PHI_RESULT (phi)) = 1;\n-    }\n-\n-  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-    {\n-      stmt = bsi_stmt (bsi);\n-      ann = stmt_ann (stmt);\n-\n-      uses = USE_OPS (ann);\n-      for (i = 0; i < NUM_USES (uses); i++)\n-\trewrite_to_new_ssa_names_use (USE_OP_PTR (uses, i), map);\n-\n-      defs = DEF_OPS (ann);\n-      for (i = 0; i < NUM_DEFS (defs); i++)\n-\trewrite_to_new_ssa_names_def (DEF_OP_PTR (defs, i), stmt, map);\n-\n-      vuses = VUSE_OPS (ann);\n-      for (i = 0; i < NUM_VUSES (vuses); i++)\n-\trewrite_to_new_ssa_names_use (VUSE_OP_PTR (vuses, i), map);\n-\n-      v_may_defs = V_MAY_DEF_OPS (ann);\n-      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-\t{\n-\t  rewrite_to_new_ssa_names_use\n-\t\t  (V_MAY_DEF_OP_PTR (v_may_defs, i), map);\n-\t  rewrite_to_new_ssa_names_def\n-\t\t  (V_MAY_DEF_RESULT_PTR (v_may_defs, i), stmt, map);\n-\t}\n-\n-      v_must_defs = V_MUST_DEF_OPS (ann);\n-      for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-\t{\n-\t  rewrite_to_new_ssa_names_def\n-\t    (V_MUST_DEF_RESULT_PTR (v_must_defs, i), stmt, map);\n-\t  rewrite_to_new_ssa_names_use\n-\t    (V_MUST_DEF_KILL_PTR (v_must_defs, i),  map);\n-\t}\n-    }\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n-      {\n-\trewrite_to_new_ssa_names_use\n-\t\t(PHI_ARG_DEF_PTR_FROM_EDGE (phi, e), map);\n-\n-\tif (e->flags & EDGE_ABNORMAL)\n-\t  {\n-\t    tree op = PHI_ARG_DEF_FROM_EDGE (phi, e);\n-\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op) = 1;\n-\t  }\n-      }\n-}\n-\n-/* Rewrite the ssa names in N_REGION blocks REGION to the new ones as specified\n-   by the mapping MAP.  */\n-\n-void\n-rewrite_to_new_ssa_names (basic_block *region, unsigned n_region, htab_t map)\n-{\n-  unsigned r;\n-\n-  for (r = 0; r < n_region; r++)\n-    rewrite_to_new_ssa_names_bb (region[r], map);\n-}\n-\n /* Duplicates a REGION (set of N_REGION basic blocks) with just a single\n    important exit edge EXIT.  By important we mean that no SSA name defined\n    inside region is live over the other exit edges of the region.  All entry\n@@ -5017,16 +4833,12 @@ tree_duplicate_sese_region (edge entry, edge exit,\n \t\t\t    basic_block *region, unsigned n_region,\n \t\t\t    basic_block *region_copy)\n {\n-  unsigned i, n_doms, ver;\n+  unsigned i, n_doms;\n   bool free_region_copy = false, copying_header = false;\n   struct loop *loop = entry->dest->loop_father;\n   edge exit_copy;\n-  bitmap definitions;\n-  tree phi;\n   basic_block *doms;\n-  htab_t ssa_name_map = NULL;\n   edge redirected;\n-  bitmap_iterator bi;\n \n   if (!can_copy_bbs_p (region, n_region))\n     return false;\n@@ -5035,7 +4847,6 @@ tree_duplicate_sese_region (edge entry, edge exit,\n      missuses of the functions.  I.e. if you ask to copy something weird,\n      it will work, but the state of structures probably will not be\n      correct.  */\n-\n   for (i = 0; i < n_region; i++)\n     {\n       /* We do not handle subloops, i.e. all the blocks must belong to the\n@@ -5072,15 +4883,14 @@ tree_duplicate_sese_region (edge entry, edge exit,\n       free_region_copy = true;\n     }\n \n-  gcc_assert (!any_marked_for_rewrite_p ());\n+  gcc_assert (!need_ssa_update_p ());\n \n   /* Record blocks outside the region that are duplicated by something\n      inside.  */\n   doms = xmalloc (sizeof (basic_block) * n_basic_blocks);\n   n_doms = get_dominated_by_region (CDI_DOMINATORS, region, n_region, doms);\n \n   copy_bbs (region, n_region, region_copy, &exit, 1, &exit_copy, loop);\n-  definitions = marked_ssa_names ();\n \n   if (copying_header)\n     {\n@@ -5094,49 +4904,27 @@ tree_duplicate_sese_region (edge entry, edge exit,\n   flush_pending_stmts (entry);\n \n   /* Concerning updating of dominators:  We must recount dominators\n-     for entry block and its copy.  Anything that is outside of the region, but\n-     was dominated by something inside needs recounting as well.  */\n+     for entry block and its copy.  Anything that is outside of the\n+     region, but was dominated by something inside needs recounting as\n+     well.  */\n   set_immediate_dominator (CDI_DOMINATORS, entry->dest, entry->src);\n   doms[n_doms++] = entry->dest->rbi->original;\n   iterate_fix_dominators (CDI_DOMINATORS, doms, n_doms);\n   free (doms);\n \n-  /* Add the other phi node arguments.  */\n+  /* Add the other PHI node arguments.  */\n   add_phi_args_after_copy (region_copy, n_region);\n \n-  /* Add phi nodes for definitions at exit.  TODO -- once we have immediate\n-     uses, it should be possible to emit phi nodes just for definitions that\n-     are used outside region.  */\n-  EXECUTE_IF_SET_IN_BITMAP (definitions, 0, ver, bi)\n-    {\n-      tree name = ssa_name (ver);\n-\n-      phi = create_phi_node (name, exit->dest);\n-      add_phi_arg (phi, name, exit);\n-      add_phi_arg (phi, name, exit_copy);\n-\n-      SSA_NAME_DEF_STMT (name) = phi;\n-    }\n-\n-  /* And create new definitions inside region and its copy.  TODO -- once we\n-     have immediate uses, it might be better to leave definitions in region\n-     unchanged, create new ssa names for phi nodes on exit, and rewrite\n-     the uses, to avoid changing the copied region.  */\n-  allocate_ssa_names (definitions, &ssa_name_map);\n-  rewrite_to_new_ssa_names (region, n_region, ssa_name_map);\n-  allocate_ssa_names (definitions, &ssa_name_map);\n-  rewrite_to_new_ssa_names (region_copy, n_region, ssa_name_map);\n-  htab_delete (ssa_name_map);\n+  /* Update the SSA web.  */\n+  update_ssa (TODO_update_ssa);\n \n   if (free_region_copy)\n     free (region_copy);\n \n-  unmark_all_for_rewrite ();\n-  BITMAP_FREE (definitions);\n-\n   return true;\n }\n \n+\n /* Dump FUNCTION_DECL FN to file FILE using FLAGS (see TDF_* in tree.h)  */\n \n void"}, {"sha": "378599eee23d1471575903ac8658a5e36c0d33a7", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -253,15 +253,11 @@ struct var_ann_d GTY(())\n   tree default_def;\n \n   /* During into-ssa and the dominator optimizer, this field holds the\n-     current version of this variable (an SSA_NAME). \n-\n-     This was previously two varrays (one in into-ssa the other in the\n-     dominator optimizer).  That is wasteful, particularly since the\n-     dominator optimizer calls into-ssa resulting in having two varrays\n-     live at the same time and this can happen for each call to the\n-     dominator optimizer.  */\n+     current version of this variable (an SSA_NAME).  */\n   tree current_def;\n   \n+  /* If this variable is a structure, this fields holds a list of\n+     symbols representing each of the fields of the structure.  */\n   subvar_t subvars;\n };\n \n@@ -540,9 +536,6 @@ extern bool tree_duplicate_sese_region (edge, edge, basic_block *, unsigned,\n \t\t\t\t\tbasic_block *);\n extern void add_phi_args_after_copy_bb (basic_block);\n extern void add_phi_args_after_copy (basic_block *, unsigned);\n-extern void rewrite_to_new_ssa_names_bb (basic_block, struct htab *);\n-extern void rewrite_to_new_ssa_names (basic_block *, unsigned, htab_t);\n-extern void allocate_ssa_names (bitmap, struct htab **);\n extern bool tree_purge_dead_eh_edges (basic_block);\n extern bool tree_purge_all_dead_eh_edges (bitmap);\n extern tree gimplify_val (block_stmt_iterator *, tree, tree);\n@@ -565,7 +558,6 @@ extern tree create_phi_node (tree, basic_block);\n extern void add_phi_arg (tree, tree, edge);\n extern void remove_phi_args (edge);\n extern void remove_phi_node (tree, tree);\n-extern tree find_phi_node_for (basic_block, tree, tree *);\n extern tree phi_reverse (tree);\n extern void dump_dfa_stats (FILE *);\n extern void debug_dfa_stats (void);\n@@ -612,11 +604,6 @@ typedef bool (*walk_use_def_chains_fn) (tree, tree, void *);\n \n /* In tree-ssa.c  */\n extern void init_tree_ssa (void);\n-extern void dump_tree_ssa (FILE *);\n-extern void debug_tree_ssa (void);\n-extern void debug_def_blocks (void);\n-extern void dump_tree_ssa_stats (FILE *);\n-extern void debug_tree_ssa_stats (void);\n extern edge ssa_redirect_edge (edge, basic_block);\n extern void flush_pending_stmts (edge);\n extern bool tree_ssa_useless_type_conversion (tree);\n@@ -628,23 +615,20 @@ extern void walk_use_def_chains (tree, walk_use_def_chains_fn, void *, bool);\n extern bool stmt_references_memory_p (tree);\n \n /* In tree-into-ssa.c  */\n-extern void rewrite_ssa_into_ssa (void);\n-\n void update_ssa (unsigned);\n+void delete_update_ssa (void);\n void register_new_name_mapping (tree, tree);\n tree create_new_def_for (tree, tree, def_operand_p);\n bool need_ssa_update_p (void);\n bool name_registered_for_update_p (tree);\n bitmap ssa_names_to_replace (void);\n void release_ssa_name_after_update_ssa (tree name);\n-void dump_repl_tbl (FILE *);\n-void debug_repl_tbl (void);\n-void dump_names_replaced_by (FILE *, tree);\n-void debug_names_replaced_by (tree);\n void compute_global_livein (bitmap, bitmap);\n tree duplicate_ssa_name (tree, tree);\n void mark_sym_for_renaming (tree);\n void mark_set_for_renaming (bitmap);\n+tree get_current_def (tree);\n+void set_current_def (tree, tree);\n \n /* In tree-ssa-ccp.c  */\n bool fold_stmt (tree *);\n@@ -724,7 +708,7 @@ tree find_loop_niter_by_eval (struct loop *, edge *);\n void estimate_numbers_of_iterations (struct loops *);\n tree can_count_iv_in_wider_type (struct loop *, tree, tree, tree, tree);\n void free_numbers_of_iterations_estimates (struct loops *);\n-void rewrite_into_loop_closed_ssa (bitmap);\n+void rewrite_into_loop_closed_ssa (bitmap, unsigned);\n void verify_loop_closed_ssa (void);\n void loop_commit_inserts (void);\n bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);"}, {"sha": "f903eabf89d3ed6f454f0f67deadf18490d9b893", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 419, "deletions": 889, "changes": 1308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -47,6 +47,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"cfgloop.h\"\n #include \"domwalk.h\"\n #include \"ggc.h\"\n+#include \"params.h\"\n \n /* This file builds the SSA form for a function as described in:\n    R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and K. Zadeck. Efficiently\n@@ -117,13 +118,6 @@ static sbitmap old_ssa_names;\n    the operations done on them are presence tests.  */\n static sbitmap new_ssa_names;\n \n-/* Set of virtual SSA names to be updated.  Since virtuals are always\n-   in FUD chain form, these names are not used as a mapping mechanism\n-   like OLD_SSA_NAMES and NEW_SSA_NAMES.  Instead, the names in this\n-   set are used by ssa_names_to_replace to inform its caller which\n-   names are going to be updated.  */\n-static bitmap old_virtual_ssa_names;\n-\n /* Symbols whose SSA form needs to be updated or created for the first\n    time.  */\n static bitmap syms_to_rename;\n@@ -159,8 +153,20 @@ static bool need_to_initialize_update_ssa_p = true;\n /* true if update_ssa needs to update virtual operands.  */\n static bool need_to_update_vops_p = false;\n \n-/* true if update_ssa is replacing existing SSA names.  */\n-static bool need_to_replace_names_p = false;\n+/* Statistics kept by update_ssa to use in the virtual mapping\n+   heuristic.  If the number of virtual mappings is beyond certain\n+   threshold, the updater will switch from using the mappings into\n+   renaming the virtual symbols from scratch.  In some cases, the\n+   large number of name mappings for virtual names causes significant\n+   slowdowns in the PHI insertion code.  */\n+struct update_ssa_stats_d\n+{\n+  unsigned num_virtual_mappings;\n+  unsigned num_total_mappings;\n+  bitmap virtual_symbols;\n+  unsigned num_virtual_symbols;\n+};\n+static struct update_ssa_stats_d update_ssa_stats;\n \n /* Global data to attach to the main dominator walk structure.  */\n struct mark_def_sites_global_data\n@@ -222,6 +228,17 @@ enum rewrite_mode {\n #define REGISTER_DEFS_IN_THIS_STMT(T)\t(T)->common.unsigned_flag\n \n \n+/* Prototypes for debugging functions.  */\n+extern void dump_tree_ssa (FILE *);\n+extern void debug_tree_ssa (void);\n+extern void debug_def_blocks (void);\n+extern void dump_tree_ssa_stats (FILE *);\n+extern void debug_tree_ssa_stats (void);\n+void dump_update_ssa (FILE *);\n+void debug_update_ssa (void);\n+void dump_names_replaced_by (FILE *, tree);\n+void debug_names_replaced_by (tree);\n+\n /* Get the information associated with NAME.  */\n \n static inline struct ssa_name_info *\n@@ -260,7 +277,7 @@ set_phi_state (tree var, enum need_phi_state state)\n \n /* Return the current definition for VAR.  */\n \n-static inline tree\n+tree\n get_current_def (tree var)\n {\n   if (TREE_CODE (var) == SSA_NAME)\n@@ -272,7 +289,7 @@ get_current_def (tree var)\n \n /* Sets current definition of VAR to DEF.  */\n \n-static inline void\n+void\n set_current_def (tree var, tree def)\n {\n   if (TREE_CODE (var) == SSA_NAME)\n@@ -447,10 +464,8 @@ symbol_marked_for_renaming (tree sym)\n static inline bool\n is_old_name (tree name)\n {\n-  if (!need_to_replace_names_p)\n-    return false;\n-\n-  return TEST_BIT (old_ssa_names, SSA_NAME_VERSION (name));\n+  unsigned ver = SSA_NAME_VERSION (name);\n+  return ver < new_ssa_names->n_bits && TEST_BIT (old_ssa_names, ver);\n }\n \n \n@@ -459,10 +474,8 @@ is_old_name (tree name)\n static inline bool\n is_new_name (tree name)\n {\n-  if (!need_to_replace_names_p)\n-    return false;\n-\n-  return TEST_BIT (new_ssa_names, SSA_NAME_VERSION (name));\n+  unsigned ver = SSA_NAME_VERSION (name);\n+  return ver < new_ssa_names->n_bits && TEST_BIT (new_ssa_names, ver);\n }\n \n \n@@ -542,6 +555,9 @@ add_new_name_mapping (tree new, tree old)\n {\n   timevar_push (TV_TREE_SSA_INCREMENTAL);\n \n+  /* OLD and NEW must be different SSA names for the same symbol.  */\n+  gcc_assert (new != old && SSA_NAME_VAR (new) == SSA_NAME_VAR (old));\n+\n   /* We may need to grow NEW_SSA_NAMES and OLD_SSA_NAMES because our\n      caller may have created new names since the set was created.  */\n   if (new_ssa_names->n_bits <= num_ssa_names - 1)\n@@ -551,34 +567,31 @@ add_new_name_mapping (tree new, tree old)\n       old_ssa_names = sbitmap_resize (old_ssa_names, new_sz, 0);\n     }\n \n-  /* We don't need to keep replacement mappings for virtual names.\n-     Since these names are kept in FUD-chain form, we need to traverse\n-     the CFG from ENTRY to repair FUD chains.  */\n+  /* If this mapping is for virtual names, we will need to update\n+     virtual operands.  */\n   if (!is_gimple_reg (new))\n     {\n       tree sym;\n+      size_t uid;\n \n-      gcc_assert (!is_gimple_reg (old));\n+      need_to_update_vops_p = true;\n \n-      if (DECL_P (old))\n-\tsym = new;\n-      else\n+      /* Keep counts of virtual mappings and symbols to use in the\n+\t virtual mapping heuristic.  If we have large numbers of\n+\t virtual mappings for a relatively low number of symbols, it\n+\t will make more sense to rename the symbols from scratch.\n+\t Otherwise, the insertion of PHI nodes for each of the old\n+\t names in these mappings will be very slow.  */\n+      sym = SSA_NAME_VAR (new);\n+      uid = var_ann (sym)->uid;\n+      update_ssa_stats.num_virtual_mappings++;\n+      if (!bitmap_bit_p (update_ssa_stats.virtual_symbols, uid))\n \t{\n-\t  sym = SSA_NAME_VAR (old);\n-\t  bitmap_set_bit (old_virtual_ssa_names, SSA_NAME_VERSION (old));\n+\t  bitmap_set_bit (update_ssa_stats.virtual_symbols, uid);\n+\t  update_ssa_stats.num_virtual_symbols++;\n \t}\n-\n-      mark_sym_for_renaming (sym);\n-      need_to_update_vops_p = true;\n-\n-      timevar_pop (TV_TREE_SSA_INCREMENTAL);\n-\n-      return;\n     }\n \n-  /* Assume that OLD and NEW are different GIMPLE register names.  */\n-  gcc_assert (new != old && is_gimple_reg (old));\n-\n   /* Update the REPL_TBL table.  */\n   add_to_repl_tbl (new, old);\n \n@@ -592,8 +605,8 @@ add_new_name_mapping (tree new, tree old)\n   SET_BIT (new_ssa_names, SSA_NAME_VERSION (new));\n   SET_BIT (old_ssa_names, SSA_NAME_VERSION (old));\n \n-  /* Indicate that we are going to be replacing existing names.  */\n-  need_to_replace_names_p = true;\n+  /* Update mapping counter to use in the virtual mapping heuristic.  */\n+  update_ssa_stats.num_total_mappings++;\n \n   timevar_pop (TV_TREE_SSA_INCREMENTAL);\n }\n@@ -802,24 +815,20 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points, bool update_p)\n \t\t\t    0, bb_index, bi)\n     {\n       bb = BASIC_BLOCK (bb_index);\n-      phi = create_phi_node (var, bb);\n \n-      if (TREE_CODE (var) == SSA_NAME)\n+      if (update_p && TREE_CODE (var) == SSA_NAME)\n \t{\n+\t  /* If we are rewriting SSA names, create the LHS of the PHI\n+\t     node by duplicating VAR.  This is useful in the case of\n+\t     pointers, to also duplicate pointer attributes (alias\n+\t     information, in particular).  */\n \t  edge_iterator ei;\n+\t  tree new_lhs;\n \n-\t  /* FIXME.  After removing rewrite_ssa_into_ssa, change this\n-\t     if() to gcc_assert().  */\n-\t  if (update_p)\n-\t    {\n-\t      /* If we are rewriting SSA names, create the LHS of the\n-\t\t PHI node by duplicating VAR.  This is useful in the\n-\t\t case of pointers, to also duplicate pointer\n-\t\t attributes (alias information, in particular).  */\n-\t      tree new_lhs = duplicate_ssa_name (var, phi);\n-\t      SET_PHI_RESULT (phi, new_lhs);\n-\t      add_new_name_mapping (new_lhs, var);\n-\t    }\n+\t  phi = create_phi_node (var, bb);\n+\t  new_lhs = duplicate_ssa_name (var, phi);\n+\t  SET_PHI_RESULT (phi, new_lhs);\n+\t  add_new_name_mapping (new_lhs, var);\n \n \t  /* Add VAR to every argument slot of PHI.  We need VAR in\n \t     every argument so that rewrite_update_phi_arguments knows\n@@ -830,6 +839,11 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points, bool update_p)\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    add_phi_arg (phi, var, e);\n \t}\n+      else\n+\t{\n+\t  tree sym = DECL_P (var) ? var : SSA_NAME_VAR (var);\n+\t  phi = create_phi_node (sym, bb);\n+\t}\n \n       /* Mark this PHI node as interesting for update_ssa.  */\n       REGISTER_DEFS_IN_THIS_STMT (phi) = 1;\n@@ -838,55 +852,36 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points, bool update_p)\n }\n \n \n-/* Helper for insert_phi_nodes.  If VAR needs PHI nodes, insert them\n-   at the dominance frontier (DFS) of blocks defining VAR.  */\n-\n-static inline void\n-insert_phi_nodes_1 (tree var, bitmap *dfs)\n-{\n-  struct def_blocks_d *def_map;\n-  bitmap idf;\n-\n-  def_map = find_def_blocks_for (var);\n-  if (def_map == NULL)\n-    return;\n-\n-  if (get_phi_state (var) != NEED_PHI_STATE_NO)\n-    {\n-      idf = find_idf (def_map->def_blocks, dfs);\n-      insert_phi_nodes_for (var, idf, false);\n-      BITMAP_FREE (idf);\n-    }\n-}\n-\n-\n /* Insert PHI nodes at the dominance frontier of blocks with variable\n    definitions.  DFS contains the dominance frontier information for\n    the flowgraph.  PHI nodes will only be inserted at the dominance\n    frontier of definition blocks for variables whose NEED_PHI_STATE\n    annotation is marked as ``maybe'' or ``unknown'' (computed by\n-   mark_def_sites).  If NAMES_TO_RENAME is not NULL, do the same but\n-   for ssa name rewriting.  */\n+   mark_def_sites).  */\n \n static void\n-insert_phi_nodes (bitmap *dfs, bitmap names_to_rename)\n+insert_phi_nodes (bitmap *dfs)\n {\n   unsigned i;\n \n   timevar_push (TV_TREE_INSERT_PHI_NODES);\n \n-  if (names_to_rename)\n+  for (i = 0; i < num_referenced_vars; i++)\n     {\n-      bitmap_iterator bi;\n+      struct def_blocks_d *def_map;\n+      bitmap idf;\n+      tree var = referenced_var (i);\n \n-      EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i, bi)\n-\tif (ssa_name (i))\n-\t  insert_phi_nodes_1 (ssa_name (i), dfs);\n-    }\n-  else\n-    {\n-      for (i = 0; i < num_referenced_vars; i++)\n-\tinsert_phi_nodes_1 (referenced_var (i), dfs);\n+      def_map = find_def_blocks_for (var);\n+      if (def_map == NULL)\n+\tcontinue;\n+\n+      if (get_phi_state (var) != NEED_PHI_STATE_NO)\n+\t{\n+\t  idf = find_idf (def_map->def_blocks, dfs);\n+\t  insert_phi_nodes_for (var, idf, false);\n+\t  BITMAP_FREE (idf);\n+\t}\n     }\n \n   timevar_pop (TV_TREE_INSERT_PHI_NODES);\n@@ -1347,18 +1342,6 @@ rewrite_update_init_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n }\n \n \n-/* Replace the operand pointed by USE_P with USE's current reaching\n-   definition.  */\n-\n-static inline void\n-replace_use (use_operand_p use_p, tree use)\n-{\n-  tree rdef = get_reaching_def (use);\n-  if (rdef != use)\n-    SET_USE (use_p, rdef);\n-}\n-\n-\n /* Called after visiting block BB.  Unwind BLOCK_DEFS_STACK to restore\n    the current reaching definition of every name re-written in BB to\n    the original reaching definition before visiting BB.  This\n@@ -1385,6 +1368,65 @@ rewrite_update_fini_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n }\n \n \n+/* If the operand pointed to by USE_P is a name in OLD_SSA_NAMES or\n+   it is a symbol marked for renaming, replace it with USE_P's current\n+   reaching definition.  */\n+\n+static inline void\n+maybe_replace_use (use_operand_p use_p)\n+{\n+  tree rdef = NULL_TREE;\n+  tree use = USE_FROM_PTR (use_p);\n+  tree sym = DECL_P (use) ? use : SSA_NAME_VAR (use);\n+\n+  if (symbol_marked_for_renaming (sym))\n+    rdef = get_reaching_def (sym);\n+  else if (is_old_name (use))\n+    rdef = get_reaching_def (use);\n+\n+  if (rdef && rdef != use)\n+    SET_USE (use_p, rdef);\n+}\n+\n+\n+/* If the operand pointed to by DEF_P is an SSA name in NEW_SSA_NAMES\n+   or OLD_SSA_NAMES, or if it is a symbol marked for renaming,\n+   register it as the current definition for the names replaced by\n+   DEF_P.  */\n+\n+static inline void\n+maybe_register_def (def_operand_p def_p, tree stmt)\n+{\n+  tree def = DEF_FROM_PTR (def_p);\n+  tree sym = DECL_P (def) ? def : SSA_NAME_VAR (def);\n+\n+  /* If DEF is a naked symbol that needs renaming, create a\n+     new name for it.  */\n+  if (symbol_marked_for_renaming (sym))\n+    {\n+      if (DECL_P (def))\n+\t{\n+\t  def = make_ssa_name (def, stmt);\n+\t  SET_DEF (def_p, def);\n+\t}\n+\n+      register_new_update_single (def, sym);\n+    }\n+  else\n+    {\n+      /* If DEF is a new name, register it as a new definition\n+\t for all the names replaced by DEF.  */\n+      if (is_new_name (def))\n+\tregister_new_update_set (def, names_replaced_by (def));\n+\n+      /* If DEF is an old name, register DEF as a new\n+\t definition for itself.  */\n+      if (is_old_name (def))\n+\tregister_new_update_single (def, def);\n+    }\n+}\n+\n+\n /* Update every variable used in the statement pointed-to by SI.  The\n    statement is assumed to be in SSA form already.  Names in\n    OLD_SSA_NAMES used by SI will be updated to their current reaching\n@@ -1422,26 +1464,12 @@ rewrite_update_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   if (REWRITE_THIS_STMT (stmt))\n     {\n       FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n-\t{\n-\t  tree use = USE_FROM_PTR (use_p);\n-\t  tree sym = DECL_P (use) ? use : SSA_NAME_VAR (use);\n-\n-\t  if (symbol_marked_for_renaming (sym))\n-\t    replace_use (use_p, sym);\n-\t  else if (is_old_name (use))\n-\t    replace_use (use_p, use);\n-\t}\n+\tmaybe_replace_use (use_p);\n \n       if (need_to_update_vops_p)\n \tFOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter,\n \t\t\t\t  SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS)\n-\t  {\n-\t    tree use = USE_FROM_PTR (use_p);\n-\t    tree sym = DECL_P (use) ? use : SSA_NAME_VAR (use);\n-\n-\t    if (symbol_marked_for_renaming (sym))\n-\t      replace_use (use_p, sym);\n-\t  }\n+\t  maybe_replace_use (use_p);\n     }\n \n   /* Register definitions of names in NEW_SSA_NAMES and OLD_SSA_NAMES.\n@@ -1450,57 +1478,27 @@ rewrite_update_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   if (REGISTER_DEFS_IN_THIS_STMT (stmt))\n     {\n       FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_DEF)\n-\t{\n-\t  tree def = DEF_FROM_PTR (def_p);\n-\t  tree sym = DECL_P (def) ? def : SSA_NAME_VAR (def);\n-\n-\t  /* If DEF is a naked symbol that needs renaming, create a\n-\t     new name for it.  */\n-\t  if (symbol_marked_for_renaming (sym))\n-\t    {\n-\t      if (DECL_P (def))\n-\t\t{\n-\t\t  def = make_ssa_name (def, stmt);\n-\t\t  SET_DEF (def_p, def);\n-\t\t}\n-\n-\t      register_new_update_single (def, sym);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If DEF is a new name, register it as a new definition\n-\t\t for all the names replaced by DEF.  */\n-\t      if (is_new_name (def))\n-\t\tregister_new_update_set (def, names_replaced_by (def));\n-\n-\t      /* If DEF is an old name, register DEF as a new\n-\t\t definition for itself.  */\n-\t      if (is_old_name (def))\n-\t\tregister_new_update_single (def, def);\n-\t    }\n-\t}\n+\tmaybe_register_def (def_p, stmt);\n \n       if (need_to_update_vops_p)\n \tFOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n-\t  {\n-\t    tree def = DEF_FROM_PTR (def_p);\n-\t    tree sym = DECL_P (def) ? def : SSA_NAME_VAR (def);\n-\n-\t    if (symbol_marked_for_renaming (sym))\n-\t      {\n-\t\tif (DECL_P (def))\n-\t\t  {\n-\t\t    def = make_ssa_name (def, stmt);\n-\t\t    SET_DEF (def_p, def);\n-\t\t  }\n-\n-\t\tregister_new_update_single (def, sym);\n-\t      }\n-\t  }\n+\t  maybe_register_def (def_p, stmt);\n     }\n }\n \n \n+/* Replace the operand pointed by USE_P with USE's current reaching\n+   definition.  */\n+\n+static inline void\n+replace_use (use_operand_p use_p, tree use)\n+{\n+  tree rdef = get_reaching_def (use);\n+  if (rdef != use)\n+    SET_USE (use_p, rdef);\n+}\n+\n+\n /* Visit all the successor blocks of BB looking for PHI nodes.  For\n    every PHI node found, check if any of its arguments is in\n    OLD_SSA_NAMES.  If so, and if the argument has a current reaching\n@@ -1764,7 +1762,7 @@ rewrite_into_ssa (void)\n   mark_def_site_blocks (interesting_blocks);\n \n   /* 3- Insert PHI nodes at dominance frontiers of definition blocks.  */\n-  insert_phi_nodes (dfs, NULL);\n+  insert_phi_nodes (dfs);\n \n   /* 4- Rename all the blocks.  */\n   rewrite_blocks (ENTRY_BLOCK_PTR, REWRITE_ALL, interesting_blocks);\n@@ -1812,15 +1810,6 @@ mark_def_interesting (tree var, tree stmt, basic_block bb, bitmap blocks,\n     {\n       bool is_phi_p = TREE_CODE (stmt) == PHI_NODE;\n \n-#if defined ENABLE_CHECKING\n-      /* If VAR is a virtual, then it had better be a symbol.\n-\t Virtuals are in FUD-chain form, so we are interested in the\n-\t definition and use sites of the symbol, not the individual\n-\t SSA names.  */\n-      if (!is_gimple_reg (var))\n-\tgcc_assert (DECL_P (var));\n-#endif\n-\n       set_def_block (var, bb, is_phi_p);\n \n       /* If VAR is an SSA name in NEW_SSA_NAMES, this is a definition\n@@ -1856,146 +1845,43 @@ mark_use_interesting (tree var, tree stmt, basic_block bb, bitmap blocks,\n      replace it).  */\n   if (insert_phi_p)\n     {\n-      struct def_blocks_d *db_p;\n-\n-#if defined ENABLE_CHECKING\n-      /* If VAR is a virtual, then it had better be a symbol.\n-\t Virtuals are in FUD-chain form, so we are interested in the\n-\t definition and use sites of the symbol, not the individual\n-\t SSA names.  */\n-      if (!is_gimple_reg (var))\n-\tgcc_assert (DECL_P (var));\n-#endif\n-\n-      db_p = get_def_blocks_for (var);\n+      struct def_blocks_d *db_p = get_def_blocks_for (var);\n       if (!bitmap_bit_p (db_p->def_blocks, bb->index))\n \tset_livein_block (var, bb);\n     }\n }\n \n \n-/* If any of the arguments of PHI is in OLD_SSA_NAMES, mark PHI to\n-   be rewritten.  BB is the block where PHI resides, BLOCKS is the\n-   region to be renamed and INSERT_PHI_P is true if the updating\n-   process should insert new PHI nodes.  */\n-\n-static void\n-prepare_phi_args_for_update (tree phi, basic_block bb, bitmap blocks,\n-                             bool insert_phi_p)\n-{\n-  int i;\n-\n-  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n-    {\n-      tree arg = PHI_ARG_DEF (phi, i);\n-\n-      if (TREE_CODE (arg) == SSA_NAME && is_old_name (arg))\n-\t{\n-\t  /* Mark this use of ARG interesting for the renamer.  Notice\n-\t     that we explicitly call mark_use_interesting with\n-\t     INSERT_PHI_P == false.\n-\n-\t     This is to avoid marking ARG as live-in in this block BB.\n-\t     If we were to mark ARG live-in to BB, then ARG would be\n-\t     considered live-in through ALL incoming edges to BB which\n-\t     is not what we want.  Since we are updating the SSA form\n-\t     for ARG, we don't really know what other names of ARG are\n-\t     coming in through other edges into BB.\n-\n-\t     If we considered ARG live-in at BB, then the PHI\n-\t     placement algorithm may try to insert PHI nodes in blocks\n-\t     that are not only unnecessary but also the renamer would\n-\t     not know how to fill in.  */\n-\t  mark_use_interesting (arg, phi, bb, blocks, false);\n-\n-\t  /* As discussed above, we only want to mark ARG live-in\n-\t     through the edge corresponding to its slot inside the PHI\n-\t     argument list.  So, we look for the block BB1 where ARG is\n-\t     flowing through.  If BB1 does not contain a definition of\n-\t     ARG, then consider ARG live-in at BB1.  */\n-\t  if (insert_phi_p)\n-\t    {\n-\t      edge e = PHI_ARG_EDGE (phi, i);\n-\t      basic_block bb1 = e->src;\n-\t      struct def_blocks_d *db = get_def_blocks_for (arg);\n-\n-\t      if (!bitmap_bit_p (db->def_blocks, bb1->index))\n-\t\tset_livein_block (arg, bb1);\n-\t    }\n-\t}\n-    }\n-}\n-\n-\n /* Do a dominator walk starting at BB processing statements that\n-   reference variables in OLD_SSA_NAMES and NEW_SSA_NAMES.\n-\n-   1- Mark in BLOCKS the defining block of every name N in\n-      NEW_SSA_NAMES.\n-\n-   2- Mark in BLOCKS the defining block of every name O in\n-      OLD_SSA_NAMES.\n-\n-   3- For every statement or PHI node that uses a name O in\n-      OLD_SSA_NAMES.  If INSERT_PHI_P is true, mark those uses as live\n-      in the corresponding block.  This is later used by the PHI\n-      placement algorithm to make PHI pruning decisions.\n+   reference symbols in SYMS_TO_RENAME.  This is very similar to\n+   mark_def_sites, but the scan handles statements whose operands may\n+   already be SSA names.  Blocks that contain defs or uses of symbols\n+   in SYMS_TO_RENAME are added to BLOCKS.\n \n-   If VISIT_DOM_P is true, all the dominator children of BB are also\n-   visited.\n-\n-   FIXME.  This process is slower than necessary.  Once we have\n-   immediate uses merged in, we should be able to just visit the\n-   immediate uses of all the names that we are about to replace,\n-   instead of visiting the whole block.  */\n+   If INSERT_PHI_P is true, mark those uses as live in the\n+   corresponding block.  This is later used by the PHI placement\n+   algorithm to make PHI pruning decisions.  */\n \n static void\n-prepare_block_for_update (basic_block bb, bool insert_phi_p,\n-                          bitmap blocks, bool visit_dom_p)\n+prepare_block_for_update (basic_block bb, bitmap blocks, bool insert_phi_p)\n {\n   basic_block son;\n   block_stmt_iterator si;\n   tree phi;\n \n   /* Process PHI nodes marking interesting those that define or use\n-     the names that we are interested in.  */\n+     the symbols that we are interested in.  */\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n       tree lhs_sym, lhs = PHI_RESULT (phi);\n \n-      REWRITE_THIS_STMT (phi) = 0;\n-      REGISTER_DEFS_IN_THIS_STMT (phi) = 0;\n-\n-      /* Ignore virtual PHIs if we are not updating virtual operands.\n-\t Note that even if NEED_TO_REPLACE_NAMES_P is false, we need\n-\t to process real PHIs because we may be rewriting GIMPLE regs\n-\t into SSA for the first time.  Therefore, we cannot do a\n-\t similar shortcut for real PHIs.  */\n-      if (!need_to_update_vops_p && !is_gimple_reg (lhs))\n-\tcontinue;\n-\n       lhs_sym = DECL_P (lhs) ? lhs : SSA_NAME_VAR (lhs);\n \n       if (symbol_marked_for_renaming (lhs_sym))\n \t{\n-\t  /* If the LHS is a virtual symbol marked for renaming, then\n-\t     we don't need to scan the argument list.  Since virtual\n-\t     operands are in FUD-chain form, all the arguments of this\n-\t     PHI must be the same symbol as the LHS.  So, we just need\n-\t     to mark this site as both an interesting use and an\n-\t     interesting def for the symbol.  */\n \t  mark_use_interesting (lhs_sym, phi, bb, blocks, insert_phi_p);\n \t  mark_def_interesting (lhs_sym, phi, bb, blocks, insert_phi_p);\n \t}\n-      else if (need_to_replace_names_p)\n-\t{\n-\t  /* If the LHS is in OLD_SSA_NAMES or NEW_SSA_NAMES, this is\n-\t     a definition site for it.  */\n-\t  if (is_old_name (lhs) || is_new_name (lhs))\n-\t    mark_def_interesting (lhs, phi, bb, blocks, insert_phi_p);\n-\n-\t  prepare_phi_args_for_update (phi, bb, blocks, insert_phi_p);\n-\t}\n     }\n \n   /* Process the statements.  */\n@@ -2008,17 +1894,11 @@ prepare_block_for_update (basic_block bb, bool insert_phi_p,\n       \n       stmt = bsi_stmt (si);\n \n-      REWRITE_THIS_STMT (stmt) = 0;\n-      REGISTER_DEFS_IN_THIS_STMT (stmt) = 0;\n-\n-      /* Note, even if NEED_TO_REPLACE_NAMES_P is false, we need to\n-\t scan real uses and defs, as we may be renaming a GIMPLE\n-\t register for the first time.  */\n       FOR_EACH_SSA_USE_OPERAND (use_p, stmt, i, SSA_OP_USE)\n \t{\n \t  tree use = USE_FROM_PTR (use_p);\n \t  tree sym = DECL_P (use) ? use : SSA_NAME_VAR (use);\n-\t  if (symbol_marked_for_renaming (sym) || is_old_name (use))\n+\t  if (symbol_marked_for_renaming (sym))\n \t    mark_use_interesting (use, stmt, bb, blocks, insert_phi_p);\n \t}\n \n@@ -2027,23 +1907,10 @@ prepare_block_for_update (basic_block bb, bool insert_phi_p,\n \t  tree def = DEF_FROM_PTR (def_p);\n \t  tree sym = DECL_P (def) ? def : SSA_NAME_VAR (def);\n \n-\t  if (symbol_marked_for_renaming (sym)\n-\t      || is_new_name (def)\n-\t      || is_old_name (def))\n+\t  if (symbol_marked_for_renaming (sym))\n \t    mark_def_interesting (def, stmt, bb, blocks, insert_phi_p);\n \t}\n \n-      /* If we don't need to update virtual operands, continue to the\n-\t next statement.  */\n-      if (!need_to_update_vops_p)\n-\tcontinue;\n-\n-      /* For every interesting N_i = V_MAY_DEF <N_j> and\n-\t N_i = V_MUST_DEF <N_j>, mark the statement as interesting.\n-\t Notice that N_j may in fact be a naked symbol (if this\n-\t statement is the result of basic block duplication). The\n-\t rename process will later fill in the appropriate reaching\n-\t definition for the symbol.  */\n       FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, i, SSA_OP_VIRTUAL_DEFS)\n \t{\n \t  tree def = DEF_FROM_PTR (def_p);\n@@ -2056,7 +1923,6 @@ prepare_block_for_update (basic_block bb, bool insert_phi_p,\n \t    }\n \t}\n \n-      /* Similarly, for V_USE <N_i>.  */\n       FOR_EACH_SSA_USE_OPERAND (use_p, stmt, i, SSA_OP_VUSE)\n \t{\n \t  tree use = USE_FROM_PTR (use_p);\n@@ -2068,24 +1934,83 @@ prepare_block_for_update (basic_block bb, bool insert_phi_p,\n     }\n \n   /* Now visit all the blocks dominated by BB.  */\n-  if (visit_dom_p)\n-    for (son = first_dom_son (CDI_DOMINATORS, bb);\n-\t son;\n-\t son = next_dom_son (CDI_DOMINATORS, son))\n-      prepare_block_for_update (son, insert_phi_p, blocks, true);\n+  for (son = first_dom_son (CDI_DOMINATORS, bb);\n+      son;\n+      son = next_dom_son (CDI_DOMINATORS, son))\n+    prepare_block_for_update (son, blocks, insert_phi_p);\n+}\n+\n+\n+/* Helper for prepare_names_to_update.  Mark all the use sites for\n+   NAME as interesting.  BLOCKS and INSERT_PHI_P are as in\n+   prepare_names_to_update.  */\n+\n+static void\n+prepare_use_sites_for (tree name, bitmap blocks, bool insert_phi_p)\n+{\n+  use_operand_p use_p;\n+  imm_use_iterator iter;\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, name)\n+    {\n+      tree stmt = USE_STMT (use_p);\n+      basic_block bb = bb_for_stmt (stmt);\n+\n+      if (TREE_CODE (stmt) == PHI_NODE)\n+\t{\n+\t  /* Mark this use of NAME interesting for the renamer.\n+\t     Notice that we explicitly call mark_use_interesting with\n+\t     INSERT_PHI_P == false.\n+\n+\t     This is to avoid marking NAME as live-in in this block\n+\t     BB. If we were to mark NAME live-in to BB, then NAME\n+\t     would be considered live-in through ALL incoming edges to\n+\t     BB which is not what we want.  Since we are updating the\n+\t     SSA form for NAME, we don't really know what other names\n+\t     of NAME are coming in through other edges into BB.\n+\n+\t     If we considered NAME live-in at BB, then the PHI\n+\t     placement algorithm may try to insert PHI nodes in blocks\n+\t     that are not only unnecessary but also the renamer would\n+\t     not know how to fill in.  */\n+\t  mark_use_interesting (name, stmt, bb, blocks, false);\n+\n+\t  /* As discussed above, we only want to mark NAME live-in\n+\t     through the edge corresponding to its slot inside the PHI\n+\t     argument list.  So, we look for the block BB1 where NAME\n+\t     is flowing through.  If BB1 does not contain a definition\n+\t     of NAME, then consider NAME live-in at BB1.  */\n+\t  if (insert_phi_p)\n+\t    {\n+\t      int ix = PHI_ARG_INDEX_FROM_USE (use_p);\n+\t      edge e = PHI_ARG_EDGE (stmt, ix);\n+\t      basic_block bb1 = e->src;\n+\t      struct def_blocks_d *db = get_def_blocks_for (name);\n+\n+\t      if (!bitmap_bit_p (db->def_blocks, bb1->index))\n+\t\tset_livein_block (name, bb1);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* For regular statements, mark this as an interesting use\n+\t     for NAME.  */\n+\t  mark_use_interesting (name, stmt, bb, blocks, insert_phi_p);\n+\t}\n+    }\n }\n \n \n-/* Helper for prepare_def_sites.  Mark the definition site for NAME as\n-   interesting.  BLOCKS and INSERT_PHI_P are as in prepare_def_sites.  */\n+/* Helper for prepare_names_to_update.  Mark the definition site for\n+   NAME as interesting.  BLOCKS and INSERT_PHI_P are as in\n+   prepare_names_to_update.  */\n \n static void\n prepare_def_site_for (tree name, bitmap blocks, bool insert_phi_p)\n {\n   tree stmt;\n   basic_block bb;\n \n-  gcc_assert (name && is_gimple_reg (name));\n   gcc_assert (names_to_release == NULL\n \t      || !bitmap_bit_p (names_to_release, SSA_NAME_VERSION (name)));\n \n@@ -2099,12 +2024,13 @@ prepare_def_site_for (tree name, bitmap blocks, bool insert_phi_p)\n }\n \n \n-/* Mark definition sites of names in NEW_SSA_NAMES and OLD_SSA_NAMES.\n-   Add each definition block to BLOCKS.  INSERT_PHI_P is true if the\n-   caller wants to insert PHI nodes for newly created names.  */\n+/* Mark definition and use sites of names in NEW_SSA_NAMES and\n+   OLD_SSA_NAMES.  Add each definition block to BLOCKS.  INSERT_PHI_P\n+   is true if the caller wants to insert PHI nodes for newly created\n+   names.  */\n \n static void\n-prepare_def_sites (bitmap blocks, bool insert_phi_p)\n+prepare_names_to_update (bitmap blocks, bool insert_phi_p)\n {\n   unsigned i;\n   bitmap_iterator bi;\n@@ -2118,14 +2044,20 @@ prepare_def_sites (bitmap blocks, bool insert_phi_p)\n     EXECUTE_IF_SET_IN_BITMAP (names_to_release, 0, i, bi)\n       RESET_BIT (new_ssa_names, i);\n \n+  /* First process names in NEW_SSA_NAMES.  Otherwise, uses of old\n+     names may be considered to be live-in on blocks that contain\n+     definitions for their replacements.  */\n+  EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i,\n+    prepare_def_site_for (ssa_name (i), blocks, insert_phi_p));\n+\n   /* If an old name is in NAMES_TO_RELEASE, we cannot remove it from\n      OLD_SSA_NAMES, but we have to ignore its definition site.  */\n   EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n-    if (names_to_release == NULL || !bitmap_bit_p (names_to_release, i))\n-      prepare_def_site_for (ssa_name (i), blocks, insert_phi_p));\n-\n-  EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i,\n-    prepare_def_site_for (ssa_name (i), blocks, insert_phi_p));\n+    {\n+      if (names_to_release == NULL || !bitmap_bit_p (names_to_release, i))\n+\tprepare_def_site_for (ssa_name (i), blocks, insert_phi_p);\n+      prepare_use_sites_for (ssa_name (i), blocks, insert_phi_p);\n+    });\n }\n \n \n@@ -2161,10 +2093,10 @@ debug_names_replaced_by (tree name)\n }\n \n \n-/* Dump the SSA name replacement table to FILE.  */\n+/* Dump SSA update information to FILE.  */\n \n void\n-dump_repl_tbl (FILE *file)\n+dump_update_ssa (FILE *file)\n {\n   unsigned i;\n   bitmap_iterator bi;\n@@ -2180,6 +2112,18 @@ dump_repl_tbl (FILE *file)\n \n       EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i,\n \tdump_names_replaced_by (file, ssa_name (i)));\n+\n+      fprintf (file, \"\\n\");\n+      fprintf (file, \"Number of virtual NEW -> OLD mappings: %7u\\n\",\n+\t       update_ssa_stats.num_virtual_mappings);\n+      fprintf (file, \"Number of real NEW -> OLD mappings:    %7u\\n\",\n+\t       update_ssa_stats.num_total_mappings\n+\t       - update_ssa_stats.num_virtual_mappings);\n+      fprintf (file, \"Number of total NEW -> OLD mappings:   %7u\\n\",\n+\t       update_ssa_stats.num_total_mappings);\n+\n+      fprintf (file, \"\\nNumber of virtual symbols: %u\\n\",\n+\t       update_ssa_stats.num_virtual_symbols);\n     }\n \n   if (syms_to_rename && !bitmap_empty_p (syms_to_rename))\n@@ -2192,16 +2136,6 @@ dump_repl_tbl (FILE *file)\n \t}\n     }\n \n-  if (old_virtual_ssa_names && !bitmap_empty_p (old_virtual_ssa_names))\n-    {\n-      fprintf (file, \"\\n\\nVirtual SSA names to be updated\\n\\n\");\n-      EXECUTE_IF_SET_IN_BITMAP (old_virtual_ssa_names, 0, i, bi)\n-\t{\n-\t  print_generic_expr (file, ssa_name (i), 0);\n-\t  fprintf (file, \" \");\n-\t}\n-    }\n-\n   if (names_to_release && !bitmap_empty_p (names_to_release))\n     {\n       fprintf (file, \"\\n\\nSSA names to release after updating the SSA web\\n\\n\");\n@@ -2216,12 +2150,12 @@ dump_repl_tbl (FILE *file)\n }\n \n \n-/* Dump the SSA name replacement table to stderr.  */\n+/* Dump SSA update information to stderr.  */\n \n void\n-debug_repl_tbl (void)\n+debug_update_ssa (void)\n {\n-  dump_repl_tbl (stderr);\n+  dump_update_ssa (stderr);\n }\n \n \n@@ -2230,7 +2164,7 @@ debug_repl_tbl (void)\n static void\n init_update_ssa (void)\n {\n-  /* Reserve 1/3 more than the current number of names.  The calls to\n+  /* Reserve more space than the current number of names.  The calls to\n      add_new_name_mapping are typically done after creating new SSA\n      names, so we'll need to reallocate these arrays.  */\n   old_ssa_names = sbitmap_alloc (num_ssa_names + NAME_SETS_GROWTH_FACTOR);\n@@ -2242,16 +2176,16 @@ init_update_ssa (void)\n   repl_tbl = htab_create (20, repl_map_hash, repl_map_eq, repl_map_free);\n   need_to_initialize_update_ssa_p = false;\n   need_to_update_vops_p = false;\n-  need_to_replace_names_p = false;\n   syms_to_rename = BITMAP_ALLOC (NULL);\n-  old_virtual_ssa_names = BITMAP_ALLOC (NULL);\n   names_to_release = NULL;\n+  memset (&update_ssa_stats, 0, sizeof (update_ssa_stats));\n+  update_ssa_stats.virtual_symbols = BITMAP_ALLOC (NULL);\n }\n \n \n /* Deallocate data structures used for incremental SSA updates.  */\n \n-static void\n+void\n delete_update_ssa (void)\n {\n   unsigned i;\n@@ -2268,9 +2202,8 @@ delete_update_ssa (void)\n \n   need_to_initialize_update_ssa_p = true;\n   need_to_update_vops_p = false;\n-  need_to_replace_names_p = false;\n   BITMAP_FREE (syms_to_rename);\n-  BITMAP_FREE (old_virtual_ssa_names);\n+  BITMAP_FREE (update_ssa_stats.virtual_symbols);\n \n   if (names_to_release)\n     {\n@@ -2289,10 +2222,6 @@ delete_update_ssa (void)\n \t  SSA_NAME_AUX (n) = NULL;\n \t}\n     }\n-\n-  /* Unmark all the names we may have protected from being released in\n-     insert_updated_phi_nodes_for.  */\n-  unmark_all_for_rewrite ();\n }\n \n \n@@ -2371,6 +2300,9 @@ mark_set_for_renaming (bitmap set)\n   bitmap_iterator bi;\n   unsigned i;\n \n+  if (bitmap_empty_p (set))\n+    return;\n+\n   if (need_to_initialize_update_ssa_p)\n     init_update_ssa ();\n \n@@ -2420,8 +2352,6 @@ ssa_names_to_replace (void)\n   EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n     bitmap_set_bit (ret, i));\n \n-  bitmap_ior_into (ret, old_virtual_ssa_names);\n-\n   return ret;\n }\n \n@@ -2450,8 +2380,7 @@ release_ssa_name_after_update_ssa (tree name)\n    - If UPDATE_FLAGS == TODO_update_ssa, we are only interested in PHI\n      nodes inside the region affected by the block that defines VAR\n      and the blocks that define all its replacements.  All these\n-     definition blocks have been gathered by prepare_block_for_update\n-     and they are stored in DEF_BLOCKS[VAR]->DEF_BLOCKS.\n+     definition blocks are stored in DEF_BLOCKS[VAR]->DEF_BLOCKS.\n \n      First, we compute the entry point to the region (ENTRY).  This is\n      given by the nearest common dominator to all the definition\n@@ -2521,31 +2450,6 @@ insert_updated_phi_nodes_for (tree var, bitmap *dfs, bitmap blocks,\n \t for the first time, so we need to compute the full IDF for\n \t it.  */\n       bitmap_copy (pruned_idf, idf);\n-\n-      /* There may already be PHI nodes for VAR in the flowgraph.\n-\t Some of them are no longer necessary.  PRUNED_IDF is\n-\t the set of blocks that need PHI nodes for VAR and\n-\t DB.PHI_BLOCKS is the set of blocks that already contain a PHI\n-\t node for VAR.  Therefore, the set DB.PHI_BLOCKS - PRUNED_IDF\n-\t gives us the set of blocks that contain PHI nodes which are\n-\t no longer needed.  */\n-      if (!bitmap_empty_p (db->phi_blocks) && !bitmap_empty_p (pruned_idf))\n-\tEXECUTE_IF_AND_COMPL_IN_BITMAP (db->phi_blocks, pruned_idf, 0, i, bi)\n-\t  {\n-\t    tree phi, prev;\n-\t    unsigned ver;\n-\n-\t    phi = find_phi_node_for (BASIC_BLOCK (i), var, &prev);\n-\t    \n-\t    /* Protect the name on PHI's LHS from being released into\n-\t       the SSA name free list.  Since we have still not\n-\t       updated the SSA form of the program, there may be\n-\t       instances of PHI's LHS in the IL.  */\n-\t    ver = SSA_NAME_VERSION (PHI_RESULT (phi));\n-\t    mark_for_rewrite (PHI_RESULT (phi));\n-\t    release_ssa_name_after_update_ssa (PHI_RESULT (phi));\n-\t    remove_phi_node (phi, prev);\n-\t  }\n     }\n \n   if (!bitmap_empty_p (pruned_idf))\n@@ -2574,6 +2478,72 @@ insert_updated_phi_nodes_for (tree var, bitmap *dfs, bitmap blocks,\n }\n \n \n+/* Heuristic to determine whether SSA name mappings for virtual names\n+   should be discarded and their symbols rewritten from scratch.  When\n+   there is a large number of mappings for virtual names, the\n+   insertion of PHI nodes for the old names in the mappings takes\n+   considerable more time than if we inserted PHI nodes for the\n+   symbols instead.\n+\n+   Currently the heuristic takes these stats into account:\n+\n+   \t- Number of mappings for virtual SSA names.\n+\t- Number of distinct virtual symbols involved in those mappings.\n+\n+   If the number of virtual mappings is much larger than the number of\n+   virtual symbols, then it will be faster to compute PHI insertion\n+   spots for the symbols.  Even if this involves traversing the whole\n+   CFG, which is what happens when symbols are renamed from scratch.  */\n+\n+static bool\n+switch_virtuals_to_full_rewrite_p (void)\n+{\n+  if (update_ssa_stats.num_virtual_mappings < (unsigned) MIN_VIRTUAL_MAPPINGS)\n+    return false;\n+\n+  if (update_ssa_stats.num_virtual_mappings\n+      > (unsigned) VIRTUAL_MAPPINGS_TO_SYMS_RATIO\n+        * update_ssa_stats.num_virtual_symbols)\n+    return true;\n+\n+  return false;\n+}\n+\n+\n+/* Remove every virtual mapping and mark all the affected virtual\n+   symbols for renaming.  */\n+\n+static void\n+switch_virtuals_to_full_rewrite (void)\n+{\n+  unsigned i;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nEnabled virtual name mapping heuristic.\\n\");\n+      fprintf (dump_file, \"\\tNumber of virtual mappings:       %7u\\n\",\n+\t       update_ssa_stats.num_virtual_mappings);\n+      fprintf (dump_file, \"\\tNumber of unique virtual symbols: %7u\\n\",\n+\t       update_ssa_stats.num_virtual_symbols);\n+      fprintf (dump_file, \"Updating FUD-chains from top of CFG will be \"\n+\t                  \"faster than processing\\nthe name mappings.\\n\\n\");\n+    }\n+\n+  /* Remove all virtual names from NEW_SSA_NAMES and OLD_SSA_NAMES.\n+     Note that it is not really necessary to remove the mappings from\n+     REPL_TBL, that would only waste time.  */\n+  EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i,\n+    if (!is_gimple_reg (ssa_name (i)))\n+      RESET_BIT (new_ssa_names, i));\n+\n+  EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n+    if (!is_gimple_reg (ssa_name (i)))\n+      RESET_BIT (old_ssa_names, i));\n+\n+  bitmap_ior_into (syms_to_rename, update_ssa_stats.virtual_symbols);\n+}\n+\n+\n /* Given a set of newly created SSA names (NEW_SSA_NAMES) and a set of\n    existing SSA names (OLD_SSA_NAMES), update the SSA form so that:\n \n@@ -2663,21 +2633,16 @@ update_ssa (unsigned update_flags)\n \t      || update_flags == TODO_update_ssa_only_virtuals);\n \n   /* If we only need to update virtuals, remove all the mappings for\n-     real names before proceeding.  */\n+     real names before proceeding.  The caller is responsible for\n+     having dealt with the name mappings before calling update_ssa.  */\n   if (update_flags == TODO_update_ssa_only_virtuals)\n     {\n       sbitmap_zero (old_ssa_names);\n       sbitmap_zero (new_ssa_names);\n       htab_empty (repl_tbl);\n-      need_to_replace_names_p = false;\n     }\n \n-  if (update_flags == TODO_update_ssa\n-      || update_flags == TODO_update_ssa_full_phi\n-      || update_flags == TODO_update_ssa_only_virtuals)\n-    insert_phi_p = true;\n-  else\n-    insert_phi_p = false;\n+  insert_phi_p = (update_flags != TODO_update_ssa_no_phi);\n \n   if (insert_phi_p)\n     {\n@@ -2704,54 +2669,82 @@ update_ssa (unsigned update_flags)\n \n   blocks = BITMAP_ALLOC (NULL);\n \n-  /* Determine the CFG region that we are going to update.  First add\n-     all the blocks that define each of the names in NEW_SSA_NAMES\n-     and OLD_SSA_NAMES.  */\n-  prepare_def_sites (blocks, insert_phi_p);\n-\n-  /* Next, determine the nearest common dominator START_BB for all the\n-     blocks in the region.  */\n-  if (!bitmap_empty_p (syms_to_rename) || bitmap_empty_p (blocks))\n+  /* Clear the REWRITE_THIS_STMT and REGISTER_DEFS_IN_THIS_STMT flags\n+     for every statement and PHI node.  */\n+  FOR_EACH_BB (bb)\n     {\n-      /* If the region to update is seemingly empty, or if we have to\n-\t rename some symbols from scratch, we need to start the\n-\t process at the root of the CFG.\n+      block_stmt_iterator si;\n+      tree phi;\n \n-\t FIXME, it should be possible to determine the nearest block\n-\t that had a definition for each of the symbols that are marked\n-\t for updating.  For now this seems more work than it's worth.  */\n-      start_bb = ENTRY_BLOCK_PTR;\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  REWRITE_THIS_STMT (phi) = 0;\n+\t  REGISTER_DEFS_IN_THIS_STMT (phi) = 0;\n+\t}\n+\n+      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+\t{\n+\t  tree stmt = bsi_stmt (si);\n+\t  REWRITE_THIS_STMT (stmt) = 0;\n+\t  REGISTER_DEFS_IN_THIS_STMT (stmt) = 0;\n+\t}\n+    }\n+\n+  /* Heuristic to avoid massive slow downs when the replacement\n+     mappings include lots of virtual names.  */\n+  if (insert_phi_p && switch_virtuals_to_full_rewrite_p ())\n+    switch_virtuals_to_full_rewrite ();\n+\n+  /* If there are names defined in the replacement table, prepare\n+     definition and use sites for all the names in NEW_SSA_NAMES and\n+     OLD_SSA_NAMES.  */\n+  if (sbitmap_first_set_bit (new_ssa_names) >= 0)\n+    {\n+      prepare_names_to_update (blocks, insert_phi_p);\n+\n+      /* If all the names in NEW_SSA_NAMES had been marked for\n+\t removal, and there are no symbols to rename, then there's\n+\t nothing else to do.  */\n+      if (sbitmap_first_set_bit (new_ssa_names) < 0\n+\t  && bitmap_empty_p (syms_to_rename))\n+\tgoto done;\n+    }\n+\n+  /* Next, determine the block at which to start the renaming process.  */\n+  if (!bitmap_empty_p (syms_to_rename))\n+    {\n+      /* If we have to rename some symbols from scratch, we need to\n+\t start the process at the root of the CFG.  FIXME, it should\n+\t be possible to determine the nearest block that had a\n+\t definition for each of the symbols that are marked for\n+\t updating.  For now this seems more work than it's worth.  */\n+      start_bb = ENTRY_BLOCK_PTR;\n+\n+      /* Traverse the CFG looking for definitions and uses of symbols\n+\t in SYMS_TO_RENAME.  Mark interesting blocks and statements\n+\t and set local live-in information for the PHI placement\n+\t heuristics.  */\n+      prepare_block_for_update (start_bb, blocks, insert_phi_p);\n     }\n   else\n-    start_bb = nearest_common_dominator_for_set (CDI_DOMINATORS, blocks);\n-\n-  /* Traverse all the blocks dominated by START_BB.  Mark interesting\n-     blocks and statements and set local live-in information for the\n-     PHI placement heuristics.  */\n-  prepare_block_for_update (start_bb, insert_phi_p, blocks, true);\n-\n-  /* If are going to insert PHI nodes, blocks in the dominance\n-     frontier of START_BB may be affected.  Note that we don't need to\n-     visit the dominator children of blocks in the dominance frontier\n-     of START_BB.  None of the changes inside this region can affect\n-     blocks on the outside.  */\n-  if (insert_phi_p && start_bb->index >= 0)\n-    EXECUTE_IF_SET_IN_BITMAP (dfs[start_bb->index], 0, i, bi)\n-      prepare_block_for_update (BASIC_BLOCK (i), insert_phi_p,\n-\t\t\t\tblocks, false);\n+    {\n+      /* Otherwise, the entry block to the region is the nearest\n+\t common dominator for the blocks in BLOCKS.  */\n+      start_bb = nearest_common_dominator_for_set (CDI_DOMINATORS, blocks);\n+    }\n \n   /* If requested, insert PHI nodes at the iterated dominance frontier\n-     of every block making new definitions for names in OLD_SSA_NAMES\n+     of every block, creating new definitions for names in OLD_SSA_NAMES\n      and for symbols in SYMS_TO_RENAME.  */\n   if (insert_phi_p)\n     {\n       if (sbitmap_first_set_bit (old_ssa_names) >= 0)\n \t{\n-\t  /* insert_updated_phi_nodes_for will call\n-\t     add_new_name_mapping when inserting new PHI nodes, so the\n-\t     set OLD_SSA_NAMES will grow while we are traversing it\n-\t     (but it will not gain any new members).  Copy\n-\t     OLD_SSA_NAMES to a temporary for traversal.  */\n+\t  /* insert_update_phi_nodes_for will call add_new_name_mapping\n+\t     when inserting new PHI nodes, so the set OLD_SSA_NAMES\n+\t     will grow while we are traversing it (but it will not\n+\t     gain any new members).  Copy OLD_SSA_NAMES to a temporary\n+\t     for traversal.  */\n \t  sbitmap tmp = sbitmap_alloc (old_ssa_names->n_bits);\n \t  sbitmap_copy (tmp, old_ssa_names);\n \t  EXECUTE_IF_SET_IN_SBITMAP (tmp, 0, i,\n@@ -2773,22 +2766,8 @@ update_ssa (unsigned update_flags)\n \n   /* Reset the current definition for name and symbol before renaming\n      the sub-graph.  */\n-  if (update_flags == TODO_update_ssa_full_phi)\n-    {\n-      /* If we are not prunning the IDF for new PHI nodes, set the\n-\t current name of every GIMPLE register to NULL.  This way, PHI\n-\t arguments coming from edges with uninitialized values will be\n-\t renamed to use the symbol's default definition.  */\n-      EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n-\tset_current_def (ssa_name (i), NULL_TREE));\n-    }\n-  else\n-    {\n-      /* Otherwise, set each old name to be its current reaching\n-\t definition.  */\n-      EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n-\tset_current_def (ssa_name (i), NULL_TREE));\n-    }\n+  EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n+      set_current_def (ssa_name (i), NULL_TREE));\n \n   EXECUTE_IF_SET_IN_BITMAP (syms_to_rename, 0, i, bi)\n     set_current_def (referenced_var (i), NULL_TREE);\n@@ -2809,7 +2788,7 @@ update_ssa (unsigned update_flags)\n       int c;\n       unsigned i;\n \n-      dump_repl_tbl (dump_file);\n+      dump_update_ssa (dump_file);\n \n       fprintf (dump_file, \"Incremental SSA update started at block: %d\\n\\n\",\n \t       start_bb->index);\n@@ -2833,6 +2812,7 @@ update_ssa (unsigned update_flags)\n     }\n \n   /* Free allocated memory.  */\n+done:\n   if (insert_phi_p)\n     {\n       FOR_EACH_BB (bb)\n@@ -2845,453 +2825,3 @@ update_ssa (unsigned update_flags)\n \n   timevar_pop (TV_TREE_SSA_INCREMENTAL);\n }\n-\n-\n-/*---------------------------------------------------------------------------\n-    Functions to fix a program in invalid SSA form into valid SSA\n-    form.  The main entry point here is rewrite_ssa_into_ssa.\n----------------------------------------------------------------------------*/\n-\n-/* Called after visiting basic block BB.  Restore CURRDEFS to its\n-   original value.  */\n-\n-static void\n-ssa_rewrite_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t    basic_block bb ATTRIBUTE_UNUSED)\n-{\n-\n-  /* Step 5.  Restore the current reaching definition for each variable\n-     referenced in the block (in reverse order).  */\n-  while (VEC_length (tree, block_defs_stack) > 0)\n-    {\n-      tree var = VEC_pop (tree, block_defs_stack);\n-      tree saved_def;\n-      \n-      if (var == NULL)\n-\tbreak;\n-\n-      saved_def = VEC_pop (tree, block_defs_stack);\n-      set_current_def (var, saved_def);\n-    }\n-}\n-\n-\n-/* Register DEF (an SSA_NAME) to be a new definition for the original\n-   ssa name VAR and push VAR's current reaching definition\n-   into the stack pointed by BLOCK_DEFS_P.  */\n-\n-static void\n-ssa_register_new_def (tree var, tree def)\n-{\n-  tree currdef;\n-   \n-  /* If this variable is set in a single basic block and all uses are\n-     dominated by the set(s) in that single basic block, then there is\n-     nothing to do.  TODO we should not be called at all, and just\n-     keep the original name.  */\n-  if (get_phi_state (var) == NEED_PHI_STATE_NO)\n-    {\n-      set_current_def (var, def);\n-      return;\n-    }\n-\n-  currdef = get_current_def (var);\n-\n-  /* Push the current reaching definition into *BLOCK_DEFS_P.  This stack is\n-     later used by the dominator tree callbacks to restore the reaching\n-     definitions for all the variables defined in the block after a recursive\n-     visit to all its immediately dominated blocks.  */\n-  VEC_reserve (tree, heap, block_defs_stack, 2);\n-  VEC_quick_push (tree, block_defs_stack, currdef);\n-  VEC_quick_push (tree, block_defs_stack, var);\n-\n-  /* Set the current reaching definition for VAR to be DEF.  */\n-  set_current_def (var, def);\n-}\n-\n-\n-/* Same as rewrite_stmt, for rewriting ssa names.  */\n-\n-static void\n-ssa_rewrite_stmt (struct dom_walk_data *walk_data,\n-\t\t  basic_block bb ATTRIBUTE_UNUSED,\n-\t\t  block_stmt_iterator si)\n-{\n-  stmt_ann_t ann;\n-  tree stmt, var;\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-  def_operand_p def_p;\n-  sbitmap names_to_rename = walk_data->global_data;\n-\n-  stmt = bsi_stmt (si);\n-  ann = stmt_ann (stmt);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Renaming statement \");\n-      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  /* We have just scanned the code for operands.  No statement should\n-     be modified.  */\n-  gcc_assert (!ann->modified);\n-\n-  /* Step 1.  Rewrite USES and VUSES in the statement.  */\n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n-    {\n-      if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (use_p))))\n-\tSET_USE (use_p, get_reaching_def (USE_FROM_PTR (use_p)));\n-    }\n-\n-  /* Step 2.  Register the statement's DEF and VDEF operands.  */\n-  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n-    {\n-      var = DEF_FROM_PTR (def_p);\n-\n-      if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (var)))\n-\tcontinue;\n-\n-      SET_DEF (def_p, duplicate_ssa_name (var, stmt));\n-      ssa_register_new_def (var, DEF_FROM_PTR (def_p));\n-    }\n-}\n-\n-\n-/* Ditto, for ssa name rewriting.  */\n-\n-static void\n-ssa_rewrite_phi_arguments (struct dom_walk_data *walk_data, basic_block bb)\n-{\n-  edge e;\n-  sbitmap names_to_rename = walk_data->global_data;\n-  use_operand_p op;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    {\n-      tree phi;\n-\n-      if (e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n-\n-      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  op = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n-\t  if (TREE_CODE (USE_FROM_PTR (op)) != SSA_NAME)\n-\t    continue;\n-\t  \n-\t  if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (op))))\n-\t    continue; \n-\n-\t  SET_USE (op, get_reaching_def (USE_FROM_PTR (op)));\n-\t  if (e->flags & EDGE_ABNORMAL)\n-\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (USE_FROM_PTR (op)) = 1;\n-\t}\n-    }\n-}\n-\n-/* Ditto, for rewriting ssa names.  */\n-\n-static void\n-ssa_rewrite_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n-{\n-  tree phi, new_name;\n-  sbitmap names_to_rename = walk_data->global_data;\n-  edge e;\n-  bool abnormal_phi;\n-  edge_iterator ei;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\n\\nRenaming block #%d\\n\\n\", bb->index);\n-\n-  /* Mark the unwind point for this block.  */\n-  VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n-\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e->flags & EDGE_ABNORMAL)\n-      break;\n-  abnormal_phi = (e != NULL);\n-\n-  /* Step 1.  Register new definitions for every PHI node in the block.\n-     Conceptually, all the PHI nodes are executed in parallel and each PHI\n-     node introduces a new version for the associated variable.  */\n-  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-    {\n-      tree result = PHI_RESULT (phi);\n-\n-      if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (result)))\n-\t{\n-\t  new_name = duplicate_ssa_name (result, phi);\n-\t  SET_PHI_RESULT (phi, new_name);\n-\n-\t  if (abnormal_phi)\n-\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_name) = 1;\n-\t  ssa_register_new_def (result, new_name);\n-\t}\n-    }\n-}\n-\n-\n-/* Same as mark_def_sites, but works over SSA names.  */\n-\n-static void\n-ssa_mark_def_sites (struct dom_walk_data *walk_data,\n-\t\t    basic_block bb,\n-\t\t    block_stmt_iterator bsi)\n-{\n-  struct mark_def_sites_global_data *gd = walk_data->global_data;\n-  bitmap kills = gd->kills;\n-  size_t uid, def_uid;\n-  tree stmt, use, def;\n-  ssa_op_iter iter;\n-\n-  /* Mark all the blocks that have definitions for each variable in the\n-     names_to_rename bitmap.  */\n-  stmt = bsi_stmt (bsi);\n-  update_stmt_if_modified (stmt);\n-\n-  /* If a variable is used before being set, then the variable is live\n-     across a block boundary, so mark it live-on-entry to BB.  */\n-  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n-    {\n-      uid = SSA_NAME_VERSION (use);\n-\n-      if (TEST_BIT (gd->names_to_rename, uid)\n-\t  && !bitmap_bit_p (kills, uid))\n-\tset_livein_block (use, bb);\n-    }\n-\t  \n-  /* Now process the definition made by this statement.  Mark the\n-     variables in KILLS.  */\n-  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n-    {\n-      def_uid = SSA_NAME_VERSION (def);\n-\n-      if (TEST_BIT (gd->names_to_rename, def_uid))\n-\t{\n-\t  set_def_block (def, bb, false);\n-\t  bitmap_set_bit (kills, def_uid);\n-\t}\n-    }\n-}\n-\n-\n-/* Block initialization routine for mark_def_sites.  Clear the \n-   KILLS bitmap at the start of each block.  */\n-\n-static void\n-ssa_mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n-\t\t\t\t     basic_block bb)\n-{\n-  struct mark_def_sites_global_data *gd = walk_data->global_data;\n-  bitmap kills = gd->kills;\n-  tree phi, def;\n-  unsigned def_uid;\n-\n-  bitmap_clear (kills);\n-\n-  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-    {\n-      def = PHI_RESULT (phi);\n-      def_uid = SSA_NAME_VERSION (def);\n-\n-      if (!TEST_BIT (gd->names_to_rename, def_uid))\n-\tcontinue;\n-\n-      set_def_block (def, bb, true);\n-      bitmap_set_bit (kills, def_uid);\n-    }\n-}\n-\n-/* Marks ssa names used as arguments of phis at the end of BB.  */\n-\n-static void\n-ssa_mark_phi_uses (struct dom_walk_data *walk_data, basic_block bb)\n-{\n-  struct mark_def_sites_global_data *gd = walk_data->global_data;\n-  bitmap kills = gd->kills;\n-  edge e;\n-  tree phi, use;\n-  unsigned uid;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    {\n-      if (e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n-\n-      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  use = PHI_ARG_DEF_FROM_EDGE (phi, e);\n-\t  if (TREE_CODE (use) != SSA_NAME)\n-\t    continue;\n-\n-\t  uid = SSA_NAME_VERSION (use);\n-\n-\t  if (TEST_BIT (gd->names_to_rename, uid)\n-\t      && !bitmap_bit_p (kills, uid))\n-\t    set_livein_block (use, bb);\n-\t}\n-    }\n-}\n-       \n-   \n-/* The marked ssa names may have more than one definition;\n-   add PHI nodes and rewrite them to fix this.  */\n-\n-void\n-rewrite_ssa_into_ssa (void)\n-{\n-  bitmap *dfs;\n-  basic_block bb;\n-  struct dom_walk_data walk_data;\n-  struct mark_def_sites_global_data mark_def_sites_global_data;\n-  unsigned i;\n-  sbitmap snames_to_rename;\n-  bitmap to_rename;\n-  bitmap_iterator bi;\n-  \n-  if (!any_marked_for_rewrite_p ())\n-    return;\n-  to_rename = marked_ssa_names ();\n-\n-  timevar_push (TV_TREE_SSA_OTHER);\n-\n-  /* Allocate memory for the DEF_BLOCKS hash table.  */\n-  def_blocks = htab_create (num_ssa_names,\n-\t\t\t    def_blocks_hash, def_blocks_eq, def_blocks_free);\n-\n-  /* Initialize dominance frontier and immediate dominator bitmaps. \n-     Also count the number of predecessors for each block.  Doing so\n-     can save significant time during PHI insertion for large graphs.  */\n-  dfs = (bitmap *) xmalloc (last_basic_block * sizeof (bitmap *));\n-  FOR_EACH_BB (bb)\n-    dfs[bb->index] = BITMAP_ALLOC (NULL);\n-\n-  /* Ensure that the dominance information is OK.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n-  /* Compute dominance frontiers.  */\n-  compute_dominance_frontiers (dfs);\n-\n-  /* Setup callbacks for the generic dominator tree walker to find and\n-     mark definition sites.  */\n-  walk_data.walk_stmts_backward = false;\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.interesting_blocks = NULL;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children_before_stmts\n-\t  = ssa_mark_def_sites_initialize_block;\n-  walk_data.before_dom_children_walk_stmts = ssa_mark_def_sites;\n-  walk_data.before_dom_children_after_stmts = ssa_mark_phi_uses; \n-  walk_data.after_dom_children_before_stmts =  NULL;\n-  walk_data.after_dom_children_walk_stmts =  NULL;\n-  walk_data.after_dom_children_after_stmts =  NULL;\n-\n-  snames_to_rename = sbitmap_alloc (num_ssa_names);\n-  sbitmap_zero (snames_to_rename);\n-  EXECUTE_IF_SET_IN_BITMAP (to_rename, 0, i, bi)\n-    {\n-      SET_BIT (snames_to_rename, i);\n-      set_current_def (ssa_name (i), NULL_TREE);\n-    }\n-\n-  mark_def_sites_global_data.kills = BITMAP_ALLOC (NULL);\n-  mark_def_sites_global_data.names_to_rename = snames_to_rename;\n-  walk_data.global_data = &mark_def_sites_global_data;\n-\n-  block_defs_stack = VEC_alloc (tree, heap, 10);\n-\n-  /* We do not have any local data.  */\n-  walk_data.block_local_data_size = 0;\n-\n-  /* Initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n-\n-  /* Recursively walk the dominator tree.  */\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n-\n-  /* Finalize the dominator walker.  */\n-  fini_walk_dominator_tree (&walk_data);\n-\n-  /* We no longer need this bitmap, clear and free it.  */\n-  BITMAP_FREE (mark_def_sites_global_data.kills);\n-\n-  /* Insert PHI nodes at dominance frontiers of definition blocks.  */\n-  insert_phi_nodes (dfs, to_rename);\n-\n-  /* Rewrite all the basic blocks in the program.  */\n-  timevar_push (TV_TREE_SSA_REWRITE_BLOCKS);\n-\n-  /* Setup callbacks for the generic dominator tree walker.  */\n-  walk_data.walk_stmts_backward = false;\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.interesting_blocks = NULL;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children_before_stmts = ssa_rewrite_initialize_block;\n-  walk_data.before_dom_children_walk_stmts = ssa_rewrite_stmt;\n-  walk_data.before_dom_children_after_stmts = ssa_rewrite_phi_arguments;\n-  walk_data.after_dom_children_before_stmts = NULL;\n-  walk_data.after_dom_children_walk_stmts =  NULL;\n-  walk_data.after_dom_children_after_stmts =  ssa_rewrite_finalize_block;\n-  walk_data.global_data = snames_to_rename;\n-  walk_data.block_local_data_size = 0;\n-\n-  /* Initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n-\n-  /* Recursively walk the dominator tree rewriting each statement in\n-     each basic block.  */\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n-\n-  /* Finalize the dominator walker.  */\n-  fini_walk_dominator_tree (&walk_data);\n-\n-  unmark_all_for_rewrite ();\n-\n-  EXECUTE_IF_SET_IN_BITMAP (to_rename, 0, i, bi)\n-    {\n-      /* Free SSA_NAME_AUX.  We don't have to zero it because\n-\t release_ssa_name will.  */\n-      if (SSA_NAME_AUX (ssa_name (i)))\n-\tfree (SSA_NAME_AUX (ssa_name (i)));\n-\n-      release_ssa_name (ssa_name (i));\n-    }\n-\n-  sbitmap_free (snames_to_rename);\n-\n-  timevar_pop (TV_TREE_SSA_REWRITE_BLOCKS);\n-\n-  /* Debugging dumps.  */\n-  if (dump_file && (dump_flags & TDF_STATS))\n-    {\n-      dump_dfa_stats (dump_file);\n-      dump_tree_ssa_stats (dump_file);\n-    }\n-\n-  /* Free allocated memory.  */\n-  FOR_EACH_BB (bb)\n-    BITMAP_FREE (dfs[bb->index]);\n-  free (dfs);\n-\n-  htab_delete (def_blocks);\n-\n-#ifdef ENABLE_CHECKING\n-  for (i = 1; i < num_ssa_names; i++)\n-    {\n-      tree name = ssa_name (i);\n-      if (!name)\n-\tcontinue;\n-\n-      gcc_assert (SSA_NAME_AUX (name) == NULL);\n-    }\n-#endif\n-\n-  BITMAP_FREE (to_rename);\n-  \n-  VEC_free (tree, heap, block_defs_stack);\n-  timevar_pop (TV_TREE_SSA_OTHER);\n-}"}, {"sha": "5c28996477451a5268e0a396a0267cd150b3aaf8", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -373,6 +373,5 @@ linear_transform_loops (struct loops *loops)\n   VEC_free (tree, heap, oldivs);\n   VEC_free (tree, heap, invariants);\n   scev_reset ();\n-  update_ssa (TODO_update_ssa);\n-  rewrite_into_loop_closed_ssa (NULL);\n+  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa_full_phi);\n }"}, {"sha": "0c6693b85c2b684126bb3a3c6aff57730e4a472d", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -466,30 +466,6 @@ remove_phi_node (tree phi, tree prev)\n }\n \n \n-/* Find the first PHI node P in basic block BB for symbol SYM.  If\n-   PREV_P is given, the PHI node preceding P is stored in *PREV_P.  */\n-\n-tree\n-find_phi_node_for (basic_block bb, tree sym, tree *prev_p)\n-{\n-  tree phi;\n-\n-  if (prev_p)\n-    *prev_p = NULL_TREE;\n-\n-  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-    {\n-      if (SSA_NAME_VAR (PHI_RESULT (phi)) == sym)\n-\treturn phi;\n-\n-      if (prev_p)\n-\t*prev_p = phi;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-\n /* Reverse the order of PHI nodes in the chain PHI.\n    Return the new head of the chain (old last PHI node).  */\n "}, {"sha": "d4e50606bde316800130302672bf33e5ab800425", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -474,7 +474,7 @@ tree_ssa_dominator_optimize (void)\n \n       calculate_dominance_info (CDI_DOMINATORS);\n \n-      rewrite_ssa_into_ssa ();\n+      update_ssa (TODO_update_ssa);\n \n       /* Reinitialize the various tables.  */\n       bitmap_clear (nonzero_vars);"}, {"sha": "18afec1e079265f458678f9dfb92c2b5555c7e78", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -136,7 +136,7 @@ copy_loop_headers (void)\n   loops = loop_optimizer_init (dump_file);\n   if (!loops)\n     return;\n-  rewrite_into_loop_closed_ssa (NULL);\n+  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n   \n   /* We do not try to keep the information about irreducible regions\n      up-to-date.  */"}, {"sha": "e34a821137559623770c329b19ae6715eede8f0e", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -757,14 +757,8 @@ move_computations (void)\n   fini_walk_dominator_tree (&walk_data);\n \n   loop_commit_inserts ();\n-\n   if (need_ssa_update_p ())\n-    update_ssa (TODO_update_ssa);\n-\n-  /* The movement of LI code may cause violation of loop closed SSA\n-     form invariants.  TODO -- avoid these rewrites completely.\n-     Information in virtual phi nodes is sufficient for it.  */\n-  rewrite_into_loop_closed_ssa (NULL);\n+    rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n }\n \n /* Checks whether the statement defining variable *INDEX can be hoisted"}, {"sha": "f2898b5c781c5a48b8c68232a8135fc83d619c2e", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -185,6 +185,8 @@ try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n   COND_EXPR_COND (cond) = do_exit;\n   update_stmt (cond);\n \n+  update_ssa (TODO_update_ssa);\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Unrolled loop %d completely.\\n\", loop->num);\n "}, {"sha": "d9ffc658d06a299b2c5a2a1df866a23aa1d76f02", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -5416,10 +5416,8 @@ tree_ssa_iv_optimize (struct loops *loops)\n       FOR_EACH_BB (bb)\n \tfor (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \t  update_stmt (bsi_stmt (si));\n-\n-      update_ssa (TODO_update_ssa);\n     }\n \n-  rewrite_into_loop_closed_ssa (NULL);\n+  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n   tree_ssa_iv_optimize_finalize (loops, &data);\n }"}, {"sha": "f16ec3f752268bf28699b502016ab1817f7730ca", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 52, "deletions": 113, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -139,11 +139,9 @@ add_exit_phis_edge (basic_block exit, tree use)\n     return;\n \n   phi = create_phi_node (use, exit);\n-\n+  create_new_def_for (PHI_RESULT (phi), phi, PHI_RESULT_PTR (phi));\n   FOR_EACH_EDGE (e, ei, exit->preds)\n     add_phi_arg (phi, use, e);\n-\n-  SSA_NAME_DEF_STMT (use) = def_stmt;\n }\n \n /* Add exit phis for VAR that is used in LIVEIN.\n@@ -215,10 +213,11 @@ get_loops_exits (void)\n \n /* For USE in BB, if it is used outside of the loop it is defined in,\n    mark it for rewrite.  Record basic block BB where it is used\n-   to USE_BLOCKS.  */\n+   to USE_BLOCKS.  Record the ssa name index to NEED_PHIS bitmap.  */\n \n static void\n-find_uses_to_rename_use (basic_block bb, tree use, bitmap *use_blocks)\n+find_uses_to_rename_use (basic_block bb, tree use, bitmap *use_blocks,\n+\t\t\t bitmap need_phis)\n {\n   unsigned ver;\n   basic_block def_bb;\n@@ -227,6 +226,10 @@ find_uses_to_rename_use (basic_block bb, tree use, bitmap *use_blocks)\n   if (TREE_CODE (use) != SSA_NAME)\n     return;\n \n+  /* We don't need to keep virtual operands in loop-closed form.  */\n+  if (!is_gimple_reg (use))\n+    return;\n+\n   ver = SSA_NAME_VERSION (use);\n   def_bb = bb_for_stmt (SSA_NAME_DEF_STMT (use));\n   if (!def_bb)\n@@ -241,31 +244,32 @@ find_uses_to_rename_use (basic_block bb, tree use, bitmap *use_blocks)\n     use_blocks[ver] = BITMAP_ALLOC (NULL);\n   bitmap_set_bit (use_blocks[ver], bb->index);\n \n-  if (!flow_bb_inside_loop_p (def_loop, bb))\n-    mark_for_rewrite (use);\n+  bitmap_set_bit (need_phis, ver);\n }\n \n /* For uses in STMT, mark names that are used outside of the loop they are\n    defined to rewrite.  Record the set of blocks in that the ssa\n-   names are defined to USE_BLOCKS.  */\n+   names are defined to USE_BLOCKS and the ssa names themselves to\n+   NEED_PHIS.  */\n \n static void\n-find_uses_to_rename_stmt (tree stmt, bitmap *use_blocks)\n+find_uses_to_rename_stmt (tree stmt, bitmap *use_blocks, bitmap need_phis)\n {\n   ssa_op_iter iter;\n   tree var;\n   basic_block bb = bb_for_stmt (stmt);\n \n   FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n-    find_uses_to_rename_use (bb, var, use_blocks);\n+    find_uses_to_rename_use (bb, var, use_blocks, need_phis);\n }\n \n /* Marks names that are used in BB and outside of the loop they are\n    defined in for rewrite.  Records the set of blocks in that the ssa\n-   names are defined to USE_BLOCKS.  */\n+   names are defined to USE_BLOCKS.  Record the SSA names that will\n+   need exit PHIs in NEED_PHIS.  */\n \n static void\n-find_uses_to_rename_bb (basic_block bb, bitmap *use_blocks)\n+find_uses_to_rename_bb (basic_block bb, bitmap *use_blocks, bitmap need_phis)\n {\n   block_stmt_iterator bsi;\n   edge e;\n@@ -275,10 +279,10 @@ find_uses_to_rename_bb (basic_block bb, bitmap *use_blocks)\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n       find_uses_to_rename_use (bb, PHI_ARG_DEF_FROM_EDGE (phi, e),\n-\t\t\t       use_blocks);\n+\t\t\t       use_blocks, need_phis);\n  \n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-    find_uses_to_rename_stmt (bsi_stmt (bsi), use_blocks);\n+    find_uses_to_rename_stmt (bsi_stmt (bsi), use_blocks, need_phis);\n }\n      \n /* Marks names that are used outside of the loop they are defined in\n@@ -287,24 +291,24 @@ find_uses_to_rename_bb (basic_block bb, bitmap *use_blocks)\n    scan only blocks in this set.  */\n \n static void\n-find_uses_to_rename (bitmap changed_bbs, bitmap *use_blocks)\n+find_uses_to_rename (bitmap changed_bbs, bitmap *use_blocks, bitmap need_phis)\n {\n   basic_block bb;\n   unsigned index;\n   bitmap_iterator bi;\n \n-  if (changed_bbs)\n+  if (changed_bbs && !bitmap_empty_p (changed_bbs))\n     {\n       EXECUTE_IF_SET_IN_BITMAP (changed_bbs, 0, index, bi)\n \t{\n-\t  find_uses_to_rename_bb (BASIC_BLOCK (index), use_blocks);\n+\t  find_uses_to_rename_bb (BASIC_BLOCK (index), use_blocks, need_phis);\n \t}\n     }\n   else\n     {\n       FOR_EACH_BB (bb)\n \t{\n-\t  find_uses_to_rename_bb (bb, use_blocks);\n+\t  find_uses_to_rename_bb (bb, use_blocks, need_phis);\n \t}\n     }\n }\n@@ -336,43 +340,42 @@ find_uses_to_rename (bitmap changed_bbs, bitmap *use_blocks)\n       base 99 and step 1.\n       \n       If CHANGED_BBS is not NULL, we look for uses outside loops only in\n-      the basic blocks in this set.  */\n+      the basic blocks in this set.\n+\n+      UPDATE_FLAG is used in the call to update_ssa.  See\n+      TODO_update_ssa* for documentation.  */\n \n void\n-rewrite_into_loop_closed_ssa (bitmap changed_bbs)\n+rewrite_into_loop_closed_ssa (bitmap changed_bbs, unsigned update_flag)\n {\n   bitmap loop_exits = get_loops_exits ();\n   bitmap *use_blocks;\n-  unsigned i;\n-  bitmap names_to_rename;\n+  unsigned i, old_num_ssa_names;\n+  bitmap names_to_rename = BITMAP_ALLOC (NULL);\n \n-  gcc_assert (!any_marked_for_rewrite_p ());\n+  /* If the pass has caused the SSA form to be out-of-date, update it\n+     now.  */\n+  update_ssa (update_flag);\n \n-  use_blocks = xcalloc (num_ssa_names, sizeof (bitmap));\n+  old_num_ssa_names = num_ssa_names;\n+  use_blocks = xcalloc (old_num_ssa_names, sizeof (bitmap));\n \n   /* Find the uses outside loops.  */\n-  find_uses_to_rename (changed_bbs, use_blocks);\n+  find_uses_to_rename (changed_bbs, use_blocks, names_to_rename);\n \n-  if (!any_marked_for_rewrite_p ())\n-    {\n-      free (use_blocks);\n-      BITMAP_FREE (loop_exits);\n-      return;\n-    }\n-\n-  /* Add the phi nodes on exits of the loops for the names we need to\n+  /* Add the PHI nodes on exits of the loops for the names we need to\n      rewrite.  */\n-  names_to_rename = marked_ssa_names ();\n   add_exit_phis (names_to_rename, use_blocks, loop_exits);\n \n-  for (i = 0; i < num_ssa_names; i++)\n+  for (i = 0; i < old_num_ssa_names; i++)\n     BITMAP_FREE (use_blocks[i]);\n   free (use_blocks);\n   BITMAP_FREE (loop_exits);\n   BITMAP_FREE (names_to_rename);\n \n-  /* Do the rewriting.  */\n-  rewrite_ssa_into_ssa ();\n+  /* Fix up all the names found to be used outside their original\n+     loops.  */\n+  update_ssa (TODO_update_ssa);\n }\n \n /* Check invariants of the loop closed ssa form for the USE in BB.  */\n@@ -383,7 +386,7 @@ check_loop_closed_ssa_use (basic_block bb, tree use)\n   tree def;\n   basic_block def_bb;\n   \n-  if (TREE_CODE (use) != SSA_NAME)\n+  if (TREE_CODE (use) != SSA_NAME || !is_gimple_reg (use))\n     return;\n \n   def = SSA_NAME_DEF_STMT (use);\n@@ -400,7 +403,7 @@ check_loop_closed_ssa_stmt (basic_block bb, tree stmt)\n   ssa_op_iter iter;\n   tree var;\n \n-  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES)\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n     check_loop_closed_ssa_use (bb, var);\n }\n \n@@ -414,6 +417,9 @@ verify_loop_closed_ssa (void)\n   tree phi;\n   unsigned i;\n \n+  if (current_loops == NULL)\n+    return;\n+\n   verify_ssa (false);\n \n   FOR_EACH_BB (bb)\n@@ -566,53 +572,15 @@ copy_phi_node_args (unsigned first_new_block)\n     BASIC_BLOCK (i)->rbi->duplicated = 0;\n }\n \n-/* Renames variables in the area copied by tree_duplicate_loop_to_header_edge.\n-   FIRST_NEW_BLOCK is the first block in the copied area.   DEFINITIONS is\n-   a bitmap of all ssa names defined inside the loop.  */\n-\n-static void\n-rename_variables (unsigned first_new_block, bitmap definitions)\n-{\n-  unsigned i, copy_number = 0;\n-  basic_block bb;\n-  htab_t ssa_name_map = NULL;\n-\n-  for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n-    {\n-      bb = BASIC_BLOCK (i);\n \n-      /* We assume that first come all blocks from the first copy, then all\n-\t blocks from the second copy, etc.  */\n-      if (copy_number != (unsigned) bb->rbi->copy_number)\n-\t{\n-\t  allocate_ssa_names (definitions, &ssa_name_map);\n-\t  copy_number = bb->rbi->copy_number;\n-\t}\n+/* The same as cfgloopmanip.c:duplicate_loop_to_header_edge, but also\n+   updates the PHI nodes at start of the copied region.  In order to\n+   achieve this, only loops whose exits all lead to the same location\n+   are handled.\n \n-      rewrite_to_new_ssa_names_bb (bb, ssa_name_map);\n-    }\n-\n-  htab_delete (ssa_name_map);\n-}\n-\n-/* Sets SSA_NAME_DEF_STMT for results of all phi nodes in BB.  */\n-\n-static void\n-set_phi_def_stmts (basic_block bb)\n-{\n-  tree phi;\n-\n-  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-    SSA_NAME_DEF_STMT (PHI_RESULT (phi)) = phi;\n-}\n-\n-/* The same as cfgloopmanip.c:duplicate_loop_to_header_edge, but also updates\n-   ssa.  In order to achieve this, only loops whose exits all lead to the same\n-   location are handled.\n-   \n-   FIXME: we create some degenerate phi nodes that could be avoided by copy\n-   propagating them instead.  Unfortunately this is not completely\n-   straightforward due to problems with constant folding.  */\n+   Notice that we do not completely update the SSA web after\n+   duplication.  The caller is responsible for calling update_ssa\n+   after the loop has been duplicated.  */\n \n bool\n tree_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n@@ -622,9 +590,6 @@ tree_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t\t\t\t    unsigned int *n_to_remove, int flags)\n {\n   unsigned first_new_block;\n-  basic_block bb;\n-  unsigned i;\n-  bitmap definitions;\n \n   if (!(loops->state & LOOPS_HAVE_SIMPLE_LATCHES))\n     return false;\n@@ -635,8 +600,6 @@ tree_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   verify_loop_closed_ssa ();\n #endif\n \n-  gcc_assert (!any_marked_for_rewrite_p ());\n-\n   first_new_block = last_basic_block;\n   if (!duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit,\n \t\t\t\t      orig, to_remove, n_to_remove, flags))\n@@ -648,31 +611,7 @@ tree_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   /* Copy the phi node arguments.  */\n   copy_phi_node_args (first_new_block);\n \n-  /* Rename the variables.  */\n-  definitions = marked_ssa_names ();\n-  rename_variables (first_new_block, definitions);\n-  unmark_all_for_rewrite ();\n-  BITMAP_FREE (definitions);\n-\n-  /* For some time we have the identical ssa names as results in multiple phi\n-     nodes.  When phi node is resized, it sets SSA_NAME_DEF_STMT of its result\n-     to the new copy.  This means that we cannot easily ensure that the ssa\n-     names defined in those phis are pointing to the right one -- so just\n-     recompute SSA_NAME_DEF_STMT for them.  */ \n-\n-  for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n-    {\n-      bb = BASIC_BLOCK (i);\n-      set_phi_def_stmts (bb);\n-      if (bb->rbi->copy_number == 1)\n-  \tset_phi_def_stmts (bb->rbi->original);\n-    }\n-\n   scev_reset ();\n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa ();\n-#endif\n \n   return true;\n }\n-"}, {"sha": "e00fe189514e3ee4248eacc707fbf1a48664e1b4", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -101,10 +101,6 @@ tree_ssa_unswitch_loops (struct loops *loops)\n \tcontinue;\n \n       changed |= tree_unswitch_single_loop (loops, loop, 0);\n-#ifdef ENABLE_CHECKING\n-      verify_dominators (CDI_DOMINATORS);\n-      verify_loop_structure (loops);\n-#endif\n     }\n \n   if (changed)\n@@ -260,6 +256,9 @@ tree_unswitch_single_loop (struct loops *loops, struct loop *loop, int num)\n   if (!nloop)\n     return changed;\n \n+  /* Update the SSA form after unswitching.  */\n+  update_ssa (TODO_update_ssa);\n+\n   /* Invoke itself on modified loops.  */\n   tree_unswitch_single_loop (loops, nloop, num + 1);\n   tree_unswitch_single_loop (loops, loop, num + 1);"}, {"sha": "b86820ecfa4046e725a0b7ff8d9e621a725609e9", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -40,7 +40,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* The loop tree currently optimized.  */\n \n-struct loops *current_loops;\n+struct loops *current_loops = NULL;\n \n /* Initializes the loop structures.  DUMP is the file to that the details\n    about the analysis should be dumped.  */\n@@ -53,8 +53,7 @@ tree_loop_optimizer_init (FILE *dump)\n   if (!loops)\n     return NULL;\n \n-  update_ssa (TODO_update_ssa);\n-  rewrite_into_loop_closed_ssa (NULL);\n+  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n \n   return loops;\n }"}, {"sha": "125e6c8158397f3bb98761ca542cad341d955715", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -644,6 +644,10 @@ verify_ssa (bool check_modified_stmt)\n   enum dom_state orig_dom_state = dom_computed[CDI_DOMINATORS];\n   bitmap names_defined_in_bb = BITMAP_ALLOC (NULL);\n \n+  gcc_assert (!need_ssa_update_p ());\n+\n+  verify_stmts ();\n+\n   timevar_push (TV_TREE_SSA_VERIFY);\n \n   /* Keep track of SSA names present in the IL.  */\n@@ -751,9 +755,7 @@ verify_ssa (bool check_modified_stmt)\n \t    }\n \n \t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_ALL_DEFS)\n-\t    {\n-\t      bitmap_set_bit (names_defined_in_bb, SSA_NAME_VERSION (op));\n-\t    }\n+\t    bitmap_set_bit (names_defined_in_bb, SSA_NAME_VERSION (op));\n \t}\n \n       bitmap_clear (names_defined_in_bb);\n@@ -763,6 +765,7 @@ verify_ssa (bool check_modified_stmt)\n   verify_alias_info ();\n \n   free (definition_block);\n+\n   /* Restore the dominance information to its prior known state, so\n      that we do not perturb the compiler's subsequent behavior.  */\n   if (orig_dom_state == DOM_NONE)\n@@ -835,6 +838,7 @@ delete_tree_ssa (void)\n   addressable_vars = NULL;\n   modified_noreturn_calls = NULL;\n   aliases_computed_p = false;\n+  gcc_assert (!need_ssa_update_p ());\n }\n \n "}, {"sha": "0f0381f4a9803604c88a6d5bc386a9b429da7917", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 8, "deletions": 59, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -61,9 +61,6 @@ Boston, MA 02111-1307, USA.  */\n /* Array of all SSA_NAMEs used in the function.  */\n varray_type ssa_names;\n \n-/* Bitmap of ssa names marked for rewriting.  */\n-static bitmap ssa_names_to_rewrite;\n-\n /* Free list of SSA_NAMEs.  This list is wiped at the end of each function\n    after we leave SSA form.  */\n static GTY (()) tree free_ssanames;\n@@ -77,54 +74,6 @@ unsigned int ssa_name_nodes_reused;\n unsigned int ssa_name_nodes_created;\n #endif\n \n-/* Returns true if ssa name VAR is marked for rewrite.  */\n-\n-bool\n-marked_for_rewrite_p (tree var)\n-{\n-  return bitmap_bit_p (ssa_names_to_rewrite, SSA_NAME_VERSION (var));\n-}\n-\n-/* Returns true if any ssa name is marked for rewrite.  */\n-\n-bool\n-any_marked_for_rewrite_p (void)\n-{\n-  if (!ssa_names_to_rewrite)\n-    return false;\n-\n-  return !bitmap_empty_p (ssa_names_to_rewrite);\n-}\n-\n-/* Mark ssa name VAR for rewriting.  */\n-\n-void\n-mark_for_rewrite (tree var)\n-{\n-  bitmap_set_bit (ssa_names_to_rewrite, SSA_NAME_VERSION (var));\n-}\n-\n-/* Unmark all ssa names marked for rewrite.  */\n-\n-void\n-unmark_all_for_rewrite (void)\n-{\n-  bitmap_clear (ssa_names_to_rewrite);\n-}\n-\n-/* Return the bitmap of ssa names to rewrite.  Copy the bitmap,\n-   so that the optimizers cannot access internals directly  */\n-\n-bitmap\n-marked_ssa_names (void)\n-{\n-  bitmap ret = BITMAP_ALLOC (NULL);\n-\n-  bitmap_copy (ret, ssa_names_to_rewrite);\n-\n-  return ret;\n-}\n-\n /* Initialize management of SSA_NAMEs.  */\n \n void\n@@ -138,15 +87,13 @@ init_ssanames (void)\n      large.  */\n   VARRAY_PUSH_TREE (ssa_names, NULL_TREE);\n   free_ssanames = NULL;\n-  ssa_names_to_rewrite = BITMAP_ALLOC (NULL);\n }\n \n /* Finalize management of SSA_NAMEs.  */\n \n void\n fini_ssanames (void)\n {\n-  BITMAP_FREE (ssa_names_to_rewrite);\n   ggc_free (ssa_names);\n   ssa_names = NULL;\n   free_ssanames = NULL;\n@@ -237,11 +184,13 @@ release_ssa_name (tree var)\n   if (var == var_ann (SSA_NAME_VAR (var))->default_def)\n     return;\n \n-  /* If the ssa name is marked for rewriting, it may have multiple definitions,\n-     but we may happen to remove just one of them.  So do not remove the\n-     ssa name now.  */\n-  if (marked_for_rewrite_p (var))\n-    return;\n+  /* If VAR has been registered for SSA updating, don't remove it.\n+     After update_ssa has run, the name will be released.  */\n+  if (name_registered_for_update_p (var))\n+    {\n+      release_ssa_name_after_update_ssa (var);\n+      return;\n+    }\n \n   /* release_ssa_name can be called multiple times on a single SSA_NAME.\n      However, it should only end up on our free list one time.   We\n@@ -304,7 +253,7 @@ duplicate_ssa_name (tree name, tree stmt)\n \n \n /* Creates a duplicate of the ptr_info_def at PTR_INFO for use by\n-   the ssa name NAME.  */\n+   the SSA name NAME.  */\n \n void\n duplicate_ssa_name_ptr_info (tree name, struct ptr_info_def *ptr_info)"}, {"sha": "7e2f37dbd6742f4320633b4248ededce4e22a007", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -1991,6 +1991,11 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \n   slpeel_make_loop_iterate_ntimes (loop, ratio);\n \n+  /* The memory tags and pointers in vectorized statements need to\n+     have their SSA forms updated.  FIXME, why can't this be delayed\n+     until all the loops have been transformed?  */\n+  update_ssa (TODO_update_ssa);\n+\n   if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS, LOOP_LOC (loop_vinfo)))\n     fprintf (vect_dump, \"LOOP VECTORIZED.\");\n }"}, {"sha": "ed95eba2d80c796fde3273b4de168a829977917c", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 49, "deletions": 142, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -159,11 +159,8 @@ static void slpeel_update_phi_nodes_for_guard2\n   (edge, struct loop *, bool, basic_block *);\n static edge slpeel_add_loop_guard (basic_block, tree, basic_block, basic_block);\n \n-static void allocate_new_names (bitmap);\n static void rename_use_op (use_operand_p);\n-static void rename_def_op (def_operand_p, tree);\n static void rename_variables_in_bb (basic_block);\n-static void free_new_names (bitmap);\n static void rename_variables_in_loop (struct loop *);\n \n /*************************************************************************\n@@ -188,72 +185,25 @@ unsigned int vect_loops_num;\n  *************************************************************************/\n \n \n-/* For each definition in DEFINITIONS this function allocates \n-   new ssa name.  */\n-\n-static void\n-allocate_new_names (bitmap definitions)\n-{\n-  unsigned ver;\n-  bitmap_iterator bi;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (definitions, 0, ver, bi)\n-    {\n-      tree def = ssa_name (ver);\n-      tree *new_name_ptr = xmalloc (sizeof (tree));\n-\n-      bool abnormal = SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def);\n-\n-      *new_name_ptr = duplicate_ssa_name (def, SSA_NAME_DEF_STMT (def));\n-      SSA_NAME_OCCURS_IN_ABNORMAL_PHI (*new_name_ptr) = abnormal;\n-\n-      SSA_NAME_AUX (def) = new_name_ptr;\n-    }\n-}\n-\n-\n /* Renames the use *OP_P.  */\n \n static void\n rename_use_op (use_operand_p op_p)\n {\n-  tree *new_name_ptr;\n+  tree new_name;\n \n   if (TREE_CODE (USE_FROM_PTR (op_p)) != SSA_NAME)\n     return;\n \n-  new_name_ptr = SSA_NAME_AUX (USE_FROM_PTR (op_p));\n-\n-  /* Something defined outside of the loop.  */\n-  if (!new_name_ptr)\n-    return;\n-\n-  /* An ordinary ssa name defined in the loop.  */\n-\n-  SET_USE (op_p, *new_name_ptr);\n-}\n-\n-\n-/* Renames the def *OP_P in statement STMT.  */\n-\n-static void\n-rename_def_op (def_operand_p op_p, tree stmt)\n-{\n-  tree *new_name_ptr;\n-\n-  if (TREE_CODE (DEF_FROM_PTR (op_p)) != SSA_NAME)\n-    return;\n-\n-  new_name_ptr = SSA_NAME_AUX (DEF_FROM_PTR (op_p));\n+  new_name = get_current_def (USE_FROM_PTR (op_p));\n \n   /* Something defined outside of the loop.  */\n-  if (!new_name_ptr)\n+  if (!new_name)\n     return;\n \n   /* An ordinary ssa name defined in the loop.  */\n \n-  SET_DEF (op_p, *new_name_ptr);\n-  SSA_NAME_DEF_STMT (DEF_FROM_PTR (op_p)) = stmt;\n+  SET_USE (op_p, new_name);\n }\n \n \n@@ -268,17 +218,13 @@ rename_variables_in_bb (basic_block bb)\n   stmt_ann_t ann;\n   use_optype uses;\n   vuse_optype vuses;\n-  def_optype defs;\n   v_may_def_optype v_may_defs;\n   v_must_def_optype v_must_defs;\n   unsigned i;\n   edge e;\n   edge_iterator ei;\n   struct loop *loop = bb->loop_father;\n \n-  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-    rename_def_op (PHI_RESULT_PTR (phi), phi);\n-\n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n       stmt = bsi_stmt (bsi);\n@@ -288,27 +234,17 @@ rename_variables_in_bb (basic_block bb)\n       for (i = 0; i < NUM_USES (uses); i++)\n \trename_use_op (USE_OP_PTR (uses, i));\n \n-      defs = DEF_OPS (ann);\n-      for (i = 0; i < NUM_DEFS (defs); i++)\n-\trename_def_op (DEF_OP_PTR (defs, i), stmt);\n-\n       vuses = VUSE_OPS (ann);\n       for (i = 0; i < NUM_VUSES (vuses); i++)\n \trename_use_op (VUSE_OP_PTR (vuses, i));\n \n       v_may_defs = V_MAY_DEF_OPS (ann);\n       for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-\t{\n-\t  rename_use_op (V_MAY_DEF_OP_PTR (v_may_defs, i));\n-\t  rename_def_op (V_MAY_DEF_RESULT_PTR (v_may_defs, i), stmt);\n-\t}\n+\trename_use_op (V_MAY_DEF_OP_PTR (v_may_defs, i));\n \n       v_must_defs = V_MUST_DEF_OPS (ann);\n       for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-\t{\n-\t  rename_use_op (V_MUST_DEF_KILL_PTR (v_must_defs, i));\n-\t  rename_def_op (V_MUST_DEF_RESULT_PTR (v_must_defs, i), stmt);\n-\t}\n+\trename_use_op (V_MUST_DEF_KILL_PTR (v_must_defs, i));\n     }\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -321,27 +257,6 @@ rename_variables_in_bb (basic_block bb)\n }\n \n \n-/* Releases the structures holding the new ssa names.  */\n-\n-static void\n-free_new_names (bitmap definitions)\n-{\n-  unsigned ver;\n-  bitmap_iterator bi;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (definitions, 0, ver, bi)\n-    {\n-      tree def = ssa_name (ver);\n-\n-      if (SSA_NAME_AUX (def))\n-\t{\n-\t  free (SSA_NAME_AUX (def));\n-\t  SSA_NAME_AUX (def) = NULL;\n-\t}\n-    }\n-}\n-\n-\n /* Renames variables in new generated LOOP.  */\n \n static void\n@@ -370,7 +285,7 @@ static void\n slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n \t\t\t\t       struct loop *new_loop, bool after)\n {\n-  tree *new_name_ptr, new_ssa_name;\n+  tree new_ssa_name;\n   tree phi_new, phi_orig;\n   tree def;\n   edge orig_loop_latch = loop_latch_edge (orig_loop);\n@@ -422,13 +337,12 @@ slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n       if (TREE_CODE (def) != SSA_NAME)\n         continue;\n \n-      new_name_ptr = SSA_NAME_AUX (def);\n-      if (!new_name_ptr)\n+      new_ssa_name = get_current_def (def);\n+      if (!new_ssa_name)\n         /* Something defined outside of the loop.  */\n         continue;\n \n       /* An ordinary ssa name defined in the loop.  */\n-      new_ssa_name = *new_name_ptr;\n       add_phi_arg (phi_new, new_ssa_name, loop_latch_edge (new_loop));\n \n       /* step 3 (case 1).  */\n@@ -565,9 +479,9 @@ slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n            new_merge\n            next_bb\n \n-     The ssa-names defined in the original loop have an SSA_NAME_AUX pointer\n-     that records the corresponding new ssa-name used in the new duplicated\n-     loop copy.\n+     The SSA names defined in the original loop have a current\n+     reaching definition that that records the corresponding new\n+     ssa-name used in the new duplicated loop copy.\n   */\n \n /* Function slpeel_update_phi_nodes_for_guard1\n@@ -603,7 +517,6 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n {\n   tree orig_phi, new_phi;\n   tree update_phi, update_phi2;\n-  tree *new_name_ptr, *new_name_ptr2;\n   tree guard_arg, loop_arg;\n   basic_block new_merge_bb = guard_edge->dest;\n   edge e = EDGE_SUCC (new_merge_bb, 0);\n@@ -656,31 +569,28 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, new_exit_e) == loop_arg);\n       SET_PHI_ARG_DEF (update_phi2, new_exit_e->dest_idx, PHI_RESULT (new_phi));\n \n-      /* 2.4. Record the newly created name in SSA_NAME_AUX.\n+      /* 2.4. Record the newly created name with set_current_def.\n          We want to find a name such that\n-                name = *(SSA_NAME_AUX (orig_loop_name))\n-         and to set its SSA_NAME_AUX as follows:\n-                *(SSA_NAME_AUX (name)) = new_phi_name\n+                name = get_current_def (orig_loop_name)\n+         and to set its current definition as follows:\n+                set_current_def (name, new_phi_name)\n \n          If LOOP is a new loop then loop_arg is already the name we're\n          looking for. If LOOP is the original loop, then loop_arg is\n          the orig_loop_name and the relevant name is recorded in its\n-         SSA_NAME_AUX  */\n+         current reaching definition.  */\n       if (is_new_loop)\n         current_new_name = loop_arg;\n       else\n         {\n-          new_name_ptr = SSA_NAME_AUX (loop_arg);\n-          gcc_assert (new_name_ptr);\n-          current_new_name = *new_name_ptr;\n+          current_new_name = get_current_def (loop_arg);\n+          gcc_assert (current_new_name);\n         }\n #ifdef ENABLE_CHECKING\n-      gcc_assert (! SSA_NAME_AUX (current_new_name));\n+      gcc_assert (get_current_def (current_new_name) == NULL_TREE);\n #endif\n \n-      new_name_ptr2 = xmalloc (sizeof (tree));\n-      *new_name_ptr2 = PHI_RESULT (new_phi);\n-      SSA_NAME_AUX (current_new_name) = new_name_ptr2;\n+      set_current_def (current_new_name, PHI_RESULT (new_phi));\n       bitmap_set_bit (*defs, SSA_NAME_VERSION (current_new_name));\n     }\n \n@@ -720,13 +630,12 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n {\n   tree orig_phi, new_phi;\n   tree update_phi, update_phi2;\n-  tree *new_name_ptr, *new_name_ptr2;\n   tree guard_arg, loop_arg;\n   basic_block new_merge_bb = guard_edge->dest;\n   edge e = EDGE_SUCC (new_merge_bb, 0);\n   basic_block update_bb = e->dest;\n   edge new_exit_e;\n-  tree orig_def;\n+  tree orig_def, orig_def_new_name;\n   tree new_name, new_name2;\n   tree arg;\n \n@@ -741,7 +650,7 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n     {\n       orig_phi = update_phi;\n       orig_def = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n-      new_name_ptr = SSA_NAME_AUX (orig_def);\n+      orig_def_new_name = get_current_def (orig_def);\n       arg = NULL_TREE;\n \n       /** 1. Handle new-merge-point phis  **/\n@@ -751,19 +660,17 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n                                  new_merge_bb);\n \n       /* 1.2. NEW_MERGE_BB has two incoming edges: GUARD_EDGE and the exit-edge\n-            of LOOP. Set the two phi args in NEW_PHI for these edges:  */\n+            of LOOP. Set the two PHI args in NEW_PHI for these edges:  */\n       new_name = orig_def;\n       new_name2 = NULL_TREE;\n-      if (new_name_ptr)\n+      if (orig_def_new_name)\n         {\n-          new_name = *new_name_ptr;\n-          new_name_ptr2 = SSA_NAME_AUX (new_name);\n-          if (new_name_ptr2)\n-            /* Some variables have both loop-entry-phis and loop-exit-phis.\n-               Such variables were given yet newer names by phis placed in\n-               guard_bb by slpeel_update_phi_nodes_for_guard1. I.e:\n-               new_name2 = SSA_NAME_AUX (SSA_NAME_AUX (orig_name)).  */\n-            new_name2 = *new_name_ptr2;\n+          new_name = orig_def_new_name;\n+\t  /* Some variables have both loop-entry-phis and loop-exit-phis.\n+\t     Such variables were given yet newer names by phis placed in\n+\t     guard_bb by slpeel_update_phi_nodes_for_guard1. I.e:\n+\t     new_name2 = get_current_def (get_current_def (orig_name)).  */\n+          new_name2 = get_current_def (new_name);\n         }\n   \n       if (is_new_loop)\n@@ -804,20 +711,22 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n \n       /** 3. Handle loop-closed-ssa-form phis for first loop  **/\n \n-      /* 3.1. Find the relevant names that need an exit-phi in GUARD_BB, i.e.\n-         names for which slpeel_update_phi_nodes_for_guard1 had not already\n-         created a phi node. This is the case for names that are used outside\n+      /* 3.1. Find the relevant names that need an exit-phi in\n+\t GUARD_BB, i.e. names for which\n+\t slpeel_update_phi_nodes_for_guard1 had not already created a\n+\t phi node. This is the case for names that are used outside\n \t the loop (and therefore need an exit phi) but are not updated\n-         across loop iterations (and therefore don't have a loop-header-phi).\n-\n-         slpeel_update_phi_nodes_for_guard1 is responsible for creating\n-         loop-exit phis in GUARD_BB for names that have a loop-header-phi. When\n-         such a phi is created we also record the new name in SSA_NAME_AUX. If\n-         this new name exists, then guard_arg was set to this new name\n-         (see 1.2 above). Therefore, if guard_arg is not this new name, this is\n-         an indication that an exit-phi in GUARD_BB was not yet created, so we\n-         take care of it here.\n-       */\n+\t across loop iterations (and therefore don't have a\n+\t loop-header-phi).\n+\n+\t slpeel_update_phi_nodes_for_guard1 is responsible for\n+\t creating loop-exit phis in GUARD_BB for names that have a\n+\t loop-header-phi.  When such a phi is created we also record\n+\t the new name in its current definition.  If this new name\n+\t exists, then guard_arg was set to this new name (see 1.2\n+\t above).  Therefore, if guard_arg is not this new name, this\n+\t is an indication that an exit-phi in GUARD_BB was not yet\n+\t created, so we take care of it here.  */\n       if (guard_arg == new_name2)\n \tcontinue;\n       arg = guard_arg;\n@@ -1059,7 +968,7 @@ slpeel_can_duplicate_loop_p (struct loop *loop, edge e)\n   tree orig_cond = get_loop_exit_condition (loop);\n   block_stmt_iterator loop_exit_bsi = bsi_last (exit_e->src);\n \n-  if (any_marked_for_rewrite_p ())\n+  if (need_ssa_update_p ())\n     return false;\n \n   if (loop->inner\n@@ -1214,8 +1123,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n       second_loop = loop;\n     }\n \n-  definitions = marked_ssa_names ();\n-  allocate_new_names (definitions);\n+  definitions = ssa_names_to_replace ();\n   slpeel_update_phis_for_duplicate_loop (loop, new_loop, e == exit_e);\n   rename_variables_in_loop (new_loop);\n \n@@ -1296,9 +1204,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   if (update_first_loop_count)\n     slpeel_make_loop_iterate_ntimes (first_loop, first_niters);\n \n-  free_new_names (definitions);\n   BITMAP_FREE (definitions);\n-  unmark_all_for_rewrite ();\n+  delete_update_ssa ();\n \n   return new_loop;\n }"}, {"sha": "ba1e1fd5876eda715722be69424ca85b80c02f9e", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d658141e6b1d315b0eba5f19a3c57a7c51fd3f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=84d658141e6b1d315b0eba5f19a3c57a7c51fd3f", "patch": "@@ -2833,13 +2833,6 @@ extern void replace_ssa_name_symbol (tree, tree);\n extern void ssanames_print_statistics (void);\n #endif\n \n-extern void mark_for_rewrite (tree);\n-extern void unmark_all_for_rewrite (void);\n-extern bool marked_for_rewrite_p (tree);\n-extern bool any_marked_for_rewrite_p (void);\n-extern struct bitmap_head_def *marked_ssa_names (void);\n-\n-\n /* Return the (unique) IDENTIFIER_NODE node for a given name.\n    The name is supplied as a char *.  */\n "}]}