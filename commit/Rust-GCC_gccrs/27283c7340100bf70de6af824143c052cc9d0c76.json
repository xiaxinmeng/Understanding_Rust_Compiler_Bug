{"sha": "27283c7340100bf70de6af824143c052cc9d0c76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcyODNjNzM0MDEwMGJmNzBkZTZhZjgyNDE0M2MwNTJjYzlkMGM3Ng==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-03-31T15:18:24Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-03-31T15:18:24Z"}, "message": "gcov.c: Add -a & -u options.\n\n\t* gcov.c: Add -a & -u options.\n\t(struct arc_info): Add local_span, is_call_non_return,\n\tis_nonlocal_return, is_unconditional flags, remove is_call flag.\n\t(struct block_info): Add flags, is_call_site, is_nonlocal_return\n\tmembers. Make encodings a union with span member.\n\t(struct function_info): Add blocks_executed, line, src, line_next\n\tmembers.\n\t(struct coverage_info): Make branches a union with blocks member.\n\t(struct source_info): Add functions member.\n\t(object_summary, program_count): New global variables.\n\t(flag_all_blocks, flag_unconditional): New flags.\n\t(find_source, output_branch_count): New functions.\n\t(print_usage): Adjust.\n\t(options): Adjust.\n\t(process_args): Adjust.\n\t(read_graph_file) <GCOV_TAG_FUNCTION>: Adjust.\n\t<GCOV_TAG_BLOCKS>: Read flags.\n\t<GCOV_TAG_LINES>: Adjust.\n\t(read_count_file): Process SUMMARY tags.\n\t(solve_flow_graph): Set is_unconditional and clear is_call_site\n\tappropriately.\n\t(add_branch_counts): Adjust. Don't count unconditional branches.\n\t(add_line_counts): Deal with all-blocks mode, accumulate block\n\tcoverage.\n\t(accumulate_line_counts): Adjust, generate local spanning tree for\n\tall-blocks mode.\n\t(output_lines): Adjust.\n\t* profile.c (branch_prob): Alter GCOV_FUNCTION_TAG record.\n\t* doc/gcov.texi: Document.\ntestsuite:\n\t* lib/gcov.exp: Adjust call return testing strings.\n\t* g77.dg/gcov/gcov-1.f: Don't expect unconditional branches.\n\nFrom-SVN: r65090", "tree": {"sha": "79429246167a06afe199b37908d8c7b8ada6a867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79429246167a06afe199b37908d8c7b8ada6a867"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27283c7340100bf70de6af824143c052cc9d0c76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27283c7340100bf70de6af824143c052cc9d0c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27283c7340100bf70de6af824143c052cc9d0c76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27283c7340100bf70de6af824143c052cc9d0c76/comments", "author": null, "committer": null, "parents": [{"sha": "212d93131f96661d194fe74bd5be893cac093664", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/212d93131f96661d194fe74bd5be893cac093664", "html_url": "https://github.com/Rust-GCC/gccrs/commit/212d93131f96661d194fe74bd5be893cac093664"}], "stats": {"total": 719, "additions": 584, "deletions": 135}, "files": [{"sha": "820deea60b7071f37a2896b0316464fdc0468fe2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27283c7340100bf70de6af824143c052cc9d0c76", "patch": "@@ -1,3 +1,35 @@\n+2003-03-31  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcov.c: Add -a & -u options.\n+\t(struct arc_info): Add local_span, is_call_non_return,\n+\tis_nonlocal_return, is_unconditional flags, remove is_call flag.\n+\t(struct block_info): Add flags, is_call_site, is_nonlocal_return\n+\tmembers. Make encodings a union with span member.\n+\t(struct function_info): Add blocks_executed, line, src, line_next\n+\tmembers.\n+\t(struct coverage_info): Make branches a union with blocks member.\n+\t(struct source_info): Add functions member.\n+\t(object_summary, program_count): New global variables.\n+\t(flag_all_blocks, flag_unconditional): New flags.\n+\t(find_source, output_branch_count): New functions.\n+\t(print_usage): Adjust.\n+\t(options): Adjust.\n+\t(process_args): Adjust.\n+\t(read_graph_file) <GCOV_TAG_FUNCTION>: Adjust.\n+\t<GCOV_TAG_BLOCKS>: Read flags.\n+\t<GCOV_TAG_LINES>: Adjust.\n+\t(read_count_file): Process SUMMARY tags.\n+\t(solve_flow_graph): Set is_unconditional and clear is_call_site\n+\tappropriately.\n+\t(add_branch_counts): Adjust. Don't count unconditional branches.\n+\t(add_line_counts): Deal with all-blocks mode, accumulate block\n+\tcoverage.\n+\t(accumulate_line_counts): Adjust, generate local spanning tree for\n+\tall-blocks mode.\n+\t(output_lines): Adjust.\n+\t* profile.c (branch_prob): Alter GCOV_FUNCTION_TAG record.\n+\t* doc/gcov.texi: Document.\n+\n 2003-03-31  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md: Organize peephole2's that trasform"}, {"sha": "c1eae2c7bdf7fa22caa499e231f260132c870e77", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 76, "deletions": 12, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=27283c7340100bf70de6af824143c052cc9d0c76", "patch": "@@ -120,13 +120,15 @@ gcov @r{[}@var{options}@r{]} @var{sourcefile}\n @ignore\n @c man begin SYNOPSIS\n gcov [@option{-v}|@option{--version}] [@option{-h}|@option{--help}]\n+     [@option{-a}|@option{--all-blocks}]\n      [@option{-b}|@option{--branch-probabilities}]\n      [@option{-c}|@option{--branch-counts}]\n      [@option{-n}|@option{--no-output}]\n      [@option{-l}|@option{--long-file-names}]\n      [@option{-p}|@option{--preserve-paths}]\n      [@option{-f}|@option{--function-summaries}]\n      [@option{-o}|@option{--object-directory} @var{directory|file}] @var{sourcefile}\n+     [@option{-u}|@option{--unconditional-branches}]\n @c man end\n @c man begin SEEALSO\n gpl(7), gfdl(7), fsf-funding(7), gcc(1) and the Info entry for @file{gcc}.\n@@ -145,11 +147,23 @@ exit without doing any further processing.\n Display the @command{gcov} version number (on the standard output),\n and exit without doing any further processing.\n \n+@item -a\n+@itemx --all-blocks\n+Write individual execution counts for every basic block. Normally gcov\n+outputs execution counts only for the main blocks of a line. With this\n+option you can determine if blocks within a single line are not being\n+executed. In this mode each block is shown, and contributes to the\n+occupancy and execution count of, the first line of source that it\n+contains. A multi-line block will only contribute to that first line,\n+and other lines will not be show to contain code, unless a subsequent\n+block begins on those lines.\n+\n @item -b\n @itemx --branch-probabilities\n Write branch frequencies to the output file, and write branch summary\n info to the standard output.  This option allows you to see how often\n-each branch in your program was taken.\n+each branch in your program was taken. Unconditional branches will not\n+be shown, unless the @option{-u} option is given.\n \n @item -c\n @itemx --branch-counts\n@@ -192,6 +206,11 @@ source file name, without its extension. If a file is specified here,\n the data files are named after that file, without its extension. If this\n option is not supplied, it defaults to the current directory.\n \n+@item -u\n+@itemx --unconditional-branches\n+When branch counts are given, include those of unconditional branches.\n+Unconditional branches are normally not interesting.\n+\n @end table\n \n Gcov should be run with the current directory the same as that when you\n@@ -248,26 +267,68 @@ Here is a sample:\n \n @smallexample\n         -:    0:Source:tmp.c\n-        -:    0:Object:tmp.bb\n+        -:    0:Graph:tmp.bbg\n+        -:    0:Data:tmp.da\n+        -:    0:Runs:1\n+        -:    0:Programs:1\n+        -:    1:#include <stdio.h>\n+        -:    2:\n+        -:    3:int main (void)\n+function main called 1 returned 1 blocks executed 75%\n+        1:    4:@{\n+        1:    5:  int i, total;\n+        -:    6:  \n+        1:    7:  total = 0;\n+        -:    8:  \n+       11:    9:  for (i = 0; i < 10; i++)\n+       10:   10:    total += i;\n+        -:   11:  \n+        1:   12:  if (total != 45)\n+    #####:   13:    printf (\"Failure\\n\");\n+        -:   14:  else\n+        1:   15:    printf (\"Success\\n\");\n+        1:   16:  return 0;\n+        -:   17:@}\n+@end smallexample\n+\n+When you use the @option{-a} option, you will get individual block\n+counts, and the output looks like this:\n+\n+@smallexample\n+        -:    0:Source:tmp.c\n+        -:    0:Graph:tmp.bbg\n+        -:    0:Data:tmp.da\n+        -:    0:Runs:1\n+        -:    0:Programs:1\n         -:    1:#include <stdio.h>\n         -:    2:\n         -:    3:int main (void)\n+function main called 1 returned 1 blocks executed 75%\n         1:    4:@{\n+        1:    4-block  0\n         1:    5:  int i, total;\n         -:    6:  \n         1:    7:  total = 0;\n         -:    8:  \n        11:    9:  for (i = 0; i < 10; i++)\n+       11:    9-block  0\n        10:   10:    total += i;\n+       10:   10-block  0\n         -:   11:  \n         1:   12:  if (total != 45)\n+        1:   12-block  0\n     #####:   13:    printf (\"Failure\\n\");\n+    $$$$$:   13-block  0\n         -:   14:  else\n         1:   15:    printf (\"Success\\n\");\n+        1:   15-block  0\n         1:   16:  return 0;\n-        1:   17:@}\n+        1:   16-block  0\n+        -:   17:@}\n @end smallexample\n \n+As you can see, line 13 contains a basic block that was not executed.\n+\n @need 450\n When you use the @option{-b} option, your output looks like this:\n \n@@ -284,31 +345,34 @@ Here is a sample of a resulting @file{tmp.c.gcov} file:\n \n @smallexample\n         -:    0:Source:tmp.c\n-        -:    0:Object:tmp.bb\n+        -:    0:Graph:tmp.bbg\n+        -:    0:Data:tmp.da\n+        -:    0:Runs:1\n+        -:    0:Programs:1\n         -:    1:#include <stdio.h>\n         -:    2:\n         -:    3:int main (void)\n+function main called 1 returned 1 blocks executed 75%\n         1:    4:@{\n         1:    5:  int i, total;\n         -:    6:  \n         1:    7:  total = 0;\n         -:    8:  \n        11:    9:  for (i = 0; i < 10; i++)\n-branch  0: taken 90%\n-branch  1: taken 100%\n-branch  2: taken 100%\n+branch  0 taken 91% (fallthrough)\n+branch  1 taken 9%\n        10:   10:    total += i;\n         -:   11:  \n         1:   12:  if (total != 45)\n-branch  0: taken 100%\n+branch  0 taken 0% (fallthrough)\n+branch  1 taken 100%\n     #####:   13:    printf (\"Failure\\n\");\n-call    0: never executed\n-branch  1: never executed\n+call    0 never executed\n         -:   14:  else\n         1:   15:    printf (\"Success\\n\");\n-call    0: returns 100%\n+call    0 called 1 returned 100%\n         1:   16:  return 0;\n-        1:   17:@}\n+        -:   17:@}\n @end smallexample\n \n For each basic block, a line is printed after the last line of the basic"}, {"sha": "14dc5842ad10f56aeae37c1ced8cb912d392222e", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=27283c7340100bf70de6af824143c052cc9d0c76", "patch": "@@ -90,6 +90,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    \tbbg:  function-graph*\n \tfunction-graph: announce_function basic_blocks {arcs | lines}*\n \tannounce_function: header string:name int32:checksum\n+\t\tstring:source int32:lineno\n \tbasic_block: header int32:flags*\n \tarcs: header int32:block_no arc*\n \tarc:  int32:dest_block int32:flags\n@@ -121,7 +122,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \tsummary: in32:checksum int32:runs int32:arcs int64:sum int64:max \\\n \t\tint64:max_sum int64:sum_max\n \n-   The ANNOUNCE_FUNCTION record is the same as that in the BBG file.\n+   The ANNOUNCE_FUNCTION record is the same as that in the BBG file,\n+   but without the source location.\n    The ARC_COUNTS gives the counter values for those arcs that are\n    instrumented.  The SUMMARY records give information about the whole\n    object file and about the whole program.  The checksum is used for\n@@ -195,7 +197,7 @@ typedef long long gcov_type;\n      \t(GCOV_TAG_MASK (TAG) > GCOV_TAG_MASK (SUB))\n \n /* Basic block flags.  */\n-#define GCOV_BLOCK_UNEXPECTED\t(1 << 0)\n+#define GCOV_BLOCK_UNEXPECTED\t(1 << 1)\n \n /* Arc flags.  */\n #define GCOV_ARC_ON_TREE \t(1 << 0)"}, {"sha": "964e5e84be91b511a100e31acf3b3d16c65a457b", "filename": "gcc/gcov.c", "status": "modified", "additions": 459, "deletions": 109, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=27283c7340100bf70de6af824143c052cc9d0c76", "patch": "@@ -69,6 +69,7 @@ typedef HOST_WIDEST_INT gcov_type;\n \n struct function_info;\n struct block_info;\n+struct source_info;\n \n /* Describes an arc between two basic blocks.  */\n \n@@ -86,8 +87,17 @@ typedef struct arc_info\n   unsigned int fake : 1;\n   unsigned int fall_through : 1;\n \n-  /* Arc to a call.  */\n-  unsigned int is_call : 1;\n+  /* Arc is for a function that abnormally returns.  */\n+  unsigned int is_call_non_return : 1;\n+\n+  /* Arc is for catch/setjump.  */\n+  unsigned int is_nonlocal_return : 1;\n+\n+  /* Is an unconditional branch.  */\n+  unsigned int is_unconditional : 1;\n+\n+  /* Arc on the local block spanning tree. */\n+  unsigned int local_span : 1;\n   \n   /* Next branch on line.  */\n   struct arc_info *line_next;\n@@ -112,17 +122,39 @@ typedef struct block_info\n \n   /* Block execution count.  */\n   gcov_type count;\n+  unsigned flags : 13;\n   unsigned count_valid : 1;\n   unsigned valid_chain : 1;\n   unsigned invalid_chain : 1;\n \n-  /* Array of line numbers and source files. source files are\n-     introduced by a linenumber of zero, the next 'line number' is the\n-     number of the source file.  Always starts with a source file.  */\n-  unsigned *encoding;\n-  unsigned num_encodings;\n+  /* Block is a call instrumenting site.  */\n+  unsigned is_call_site : 1;\n \n-  /* Temporary chain for solving graph.  */\n+  /* Block is a landing pad for longjmp or throw.  */\n+  unsigned is_nonlocal_return : 1;\n+\n+  union\n+  {\n+    struct\n+    {\n+     /* Array of line numbers and source files. source files are\n+        introduced by a linenumber of zero, the next 'line number' is\n+        the number of the source file.  Always starts with a source\n+        file.  */\n+      unsigned *encoding;\n+      unsigned num;\n+    } line; /* Valid until blocks are linked onto lines */\n+    struct\n+    {\n+      /* Single line spanning tree workspace.  Used for all-blocks mode. */\n+      struct block_info *root;\n+      unsigned siblings;\n+    } span; /* Used in all-blocks mode, after blocks are linked onto\n+\t       lines. */\n+  } u;\n+\n+  /* Temporary chain for solving graph, and for chaining blocks on one\n+     line.  */\n   struct block_info *chain;\n   \n } block_t;\n@@ -138,10 +170,18 @@ typedef struct function_info\n   /* Array of basic blocks.  */\n   block_t *blocks;\n   unsigned num_blocks;\n+  unsigned blocks_executed;\n \n   /* Raw arc coverage counts.  */\n   gcov_type *counts;\n   unsigned num_counts;\n+\n+  /* First line number.  */\n+  unsigned line;\n+  struct source_info *src;\n+\n+  /* Next function in same source file.  */\n+  struct function_info *line_next;\n   \n   /* Next function.  */\n   struct function_info *next;\n@@ -170,8 +210,14 @@ typedef struct coverage_info\n typedef struct line_info\n {\n   gcov_type count;\t   /* execution count */\n-  arc_t *branches; \t   /* branches from blocks that end on this\n-\t\t\t      line.  */\n+  union\n+  {\n+    arc_t *branches; \t   /* branches from blocks that end on this\n+\t\t\t      line. Used for branch-counts when not\n+\t\t\t      all-blocks mode. */\n+    block_t *blocks;       /* blocks which start on this line.  Used\n+\t\t\t      in all-blocks mode. */\n+  } u;\n   unsigned exists : 1;\n } line_t;\n \n@@ -189,6 +235,10 @@ typedef struct source_info\n   unsigned num_lines;\n \n   coverage_t coverage;\n+\n+  /* Functions in this source file.  These are in ascending line\n+     number order.  */\n+  function_t *functions;\n   \n   /* Next source file.  */\n   struct source_info *next;\n@@ -202,6 +252,11 @@ static function_t *functions;\n \n static source_t *sources;\n \n+/* This holds data summary information.  */\n+\n+static struct gcov_summary object_summary;\n+static unsigned program_count;\n+\n /* Modification time of graph file.  */\n \n static time_t bbg_file_time;\n@@ -218,6 +273,9 @@ static char *da_file_name;\n \n static int flag_branches = 0;\n \n+/* Show unconditional branches too.  */ \n+static int flag_unconditional = 0;\n+\n /* Output a gcov file if this is true.  This is on by default, and can\n    be turned off by the -n option.  */\n \n@@ -229,6 +287,11 @@ static int flag_gcov_file = 1;\n \n static int flag_long_names = 0;\n \n+/* Output count information for every basic block, not merely those\n+   that contain line number information.  */\n+\n+static int flag_all_blocks = 0;\n+\n /* Output summary info for each function.  */\n \n static int flag_function_summary = 0;\n@@ -256,14 +319,16 @@ static void print_usage PARAMS ((int)) ATTRIBUTE_NORETURN;\n static void print_version PARAMS ((void)) ATTRIBUTE_NORETURN;\n static void process_file PARAMS ((const char *));\n static void create_file_names PARAMS ((const char *));\n+static source_t *find_source PARAMS ((char *));\n static int read_graph_file PARAMS ((void));\n static int read_count_file PARAMS ((void));\n static void solve_flow_graph PARAMS ((function_t *));\n static void add_branch_counts PARAMS ((coverage_t *, const arc_t *));\n-static void add_line_counts PARAMS ((coverage_t *, const function_t *));\n+static void add_line_counts PARAMS ((coverage_t *, function_t *));\n static void function_summary PARAMS ((const coverage_t *, const char *));\n static const char *format_gcov PARAMS ((gcov_type, gcov_type, int));\n static void accumulate_line_counts PARAMS ((source_t *));\n+static int output_branch_count PARAMS ((FILE *, int, const arc_t *));\n static void output_lines PARAMS ((FILE *, const source_t *));\n static char *make_gcov_file_name PARAMS ((const char *, const char *));\n static void release_structures PARAMS ((void));\n@@ -328,6 +393,7 @@ print_usage (error_p)\n   fnotice (file, \"Print code coverage information.\\n\\n\");\n   fnotice (file, \"  -h, --help                      Print this help, then exit\\n\");\n   fnotice (file, \"  -v, --version                   Print version number, then exit\\n\");\n+  fnotice (file, \"  -a, --all-blocks                Show information for every basic block\\n\");\n   fnotice (file, \"  -b, --branch-probabilities      Include branch probabilities in output\\n\");\n   fnotice (file, \"  -c, --branch-counts             Given counts of branches taken\\n\\\n                                     rather than percentages\\n\");\n@@ -337,6 +403,7 @@ print_usage (error_p)\n   fnotice (file, \"  -f, --function-summaries        Output summaries for each function\\n\");\n   fnotice (file, \"  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\\n\");\n   fnotice (file, \"  -p, --preserve-paths            Preserve all pathname components\\n\");\n+  fnotice (file, \"  -u, --unconditional-branches    Show unconditional branch counts too\\n\");\n   fnotice (file, \"\\nFor bug reporting instructions, please see:\\n%s.\\n\",\n \t   bug_report_url);\n   exit (status);\n@@ -365,6 +432,7 @@ static const struct option options[] =\n {\n   { \"help\",                 no_argument,       NULL, 'h' },\n   { \"version\",              no_argument,       NULL, 'v' },\n+  { \"all-blocks\",           no_argument,       NULL, 'a' },\n   { \"branch-probabilities\", no_argument,       NULL, 'b' },\n   { \"branch-counts\",        no_argument,       NULL, 'c' },\n   { \"no-output\",            no_argument,       NULL, 'n' },\n@@ -373,6 +441,7 @@ static const struct option options[] =\n   { \"preserve-paths\",       no_argument,       NULL, 'p' },\n   { \"object-directory\",     required_argument, NULL, 'o' },\n   { \"object-file\",          required_argument, NULL, 'o' },\n+  { \"unconditional-branches\", no_argument,     NULL, 'u' },\n };\n \n /* Process args, return index to first non-arg.  */\n@@ -384,37 +453,43 @@ process_args (argc, argv)\n {\n   int opt;\n \n-  while ((opt = getopt_long (argc, argv, \"hvbclnfo:p\", options, NULL)) != -1)\n+  while ((opt = getopt_long (argc, argv, \"abcfhlno:puv\", options, NULL)) != -1)\n     {\n       switch (opt)\n \t{\n-\tcase 'h':\n-\t  print_usage (false);\n-\t  /* print_usage will exit.  */\n-\tcase 'v':\n-\t  print_version ();\n-\t  /* print_version will exit.  */\n+\tcase 'a':\n+\t  flag_all_blocks = 1;\n+\t  break;\n \tcase 'b':\n \t  flag_branches = 1;\n \t  break;\n \tcase 'c':\n \t  flag_counts = 1;\n \t  break;\n-\tcase 'n':\n-\t  flag_gcov_file = 0;\n+\tcase 'f':\n+\t  flag_function_summary = 1;\n \t  break;\n+\tcase 'h':\n+\t  print_usage (false);\n+\t  /* print_usage will exit.  */\n \tcase 'l':\n \t  flag_long_names = 1;\n \t  break;\n-\tcase 'f':\n-\t  flag_function_summary = 1;\n+\tcase 'n':\n+\t  flag_gcov_file = 0;\n \t  break;\n \tcase 'o':\n \t  object_directory = optarg;\n \t  break;\n \tcase 'p':\n \t  flag_preserve_paths = 1;\n \t  break;\n+\tcase 'u':\n+\t  flag_unconditional = 1;\n+\t  break;\n+\tcase 'v':\n+\t  print_version ();\n+\t  /* print_version will exit.  */\n \tdefault:\n \t  print_usage (true);\n \t  /* print_usage will exit.  */\n@@ -528,7 +603,6 @@ release_structures ()\n \t      arc_n = arc->succ_next;\n \t      free (arc);\n \t    }\n-\t  free (block->encoding);\n \t}\n       free (fn->blocks);\n       free (fn->counts);\n@@ -597,6 +671,34 @@ create_file_names (file_name)\n   return;\n }\n \n+/* Find or create a source file structure for FILE_NAME. Free\n+   FILE_NAME appropriately */\n+\n+static source_t *\n+find_source (file_name)\n+     char *file_name;\n+{\n+\n+  source_t *src;\n+  \n+  for (src = sources; src; src = src->next)\n+    if (!strcmp (file_name, src->name))\n+      {\n+\tfree (file_name);\n+\tbreak;\n+      }\n+  if (!src)\n+    {\n+      src = (source_t *)xcalloc (1, sizeof (source_t));\n+      src->name = file_name;\n+      src->coverage.name = file_name;\n+      src->index = sources ? sources->index + 1 : 1;\n+      src->next = sources;\n+      sources = src;\n+    }\n+  return src;\n+}\n+\n /* Read the graph file. Return nonzero on fatal error.  */\n \n static int\n@@ -650,22 +752,45 @@ read_graph_file ()\n \tgoto corrupt;\n \n       base = gcov_save_position (file);\n-      \n+\n       if (tag == GCOV_TAG_FUNCTION)\n \t{\n \t  char *function_name = NULL;\n-\t  unsigned checksum;\n+\t  char *function_file = NULL;\n+\t  unsigned checksum, lineno;\n+\t  source_t *src;\n+\t  function_t *probe, *prev;\n \n \t  if (gcov_read_string (file, &function_name, NULL)\n-\t      || gcov_read_unsigned (file, &checksum))\n+\t      || gcov_read_unsigned (file, &checksum)\n+\t      || gcov_read_string (file, &function_file, NULL)\n+\t      || gcov_read_unsigned (file, &lineno))\n \t    goto corrupt;\n+\t  src = find_source (function_file);\n \t  fn = (function_t *)xcalloc (1, sizeof (function_t));\n \t  fn->name = function_name;\n \t  fn->checksum = checksum;\n+\t  fn->src = src;\n+\t  fn->line = lineno;\n \n \t  fn->next = functions;\n \t  functions = fn;\n \t  current_tag = tag;\n+\t  \n+\t  if (lineno >= src->num_lines)\n+\t    src->num_lines = lineno + 1;\n+\t  /* Now insert it into the source file's list of\n+\t     functions. Normally functions will be encountered in\n+\t     ascending order, so a simple scan is quick.  */\n+\t  for (probe = src->functions, prev = NULL;\n+\t       probe && probe->line > lineno;\n+\t       prev = probe, probe = probe->line_next)\n+\t    continue;\n+\t  fn->line_next = probe;\n+\t  if (prev)\n+\t    prev->line_next = fn;\n+\t  else\n+\t    src->functions = fn;\n \t}\n       else if (fn && tag == GCOV_TAG_BLOCKS)\n \t{\n@@ -674,9 +799,19 @@ read_graph_file ()\n \t\t     bbg_file_name, fn->name);\n \t  else\n \t    {\n-\t      fn->num_blocks = length / 4;\n+\t      unsigned ix, num_blocks = length / 4;\n+\t      fn->num_blocks = num_blocks;\n+\t      \n \t      fn->blocks\n \t\t= (block_t *)xcalloc (fn->num_blocks, sizeof (block_t));\n+\t      for (ix = 0; ix != num_blocks; ix++)\n+\t\t{\n+\t\t  unsigned flags;\n+\t\t  \n+\t\t  if (gcov_read_unsigned (file, &flags))\n+\t\t    goto corrupt;\n+\t\t  fn->blocks[ix].flags = flags;\n+\t\t}\n \t    }\n \t}\n       else if (fn && tag == GCOV_TAG_ARCS)\n@@ -717,7 +852,24 @@ read_graph_file ()\n \t      fn->blocks[dest].pred = arc;\n \t      fn->blocks[dest].num_pred++;\n \n-\t      arc->is_call = arc->fake;\n+\t      if (arc->fake)\n+\t\t{\n+\t\t  if (src)\n+\t\t    {\n+\t\t      /* Exceptional exit from this function, the\n+\t\t\t source block must be a call.  */\n+\t\t      fn->blocks[src].is_call_site = 1;\n+\t\t      arc->is_call_non_return = 1;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* Non-local return from a callee of this\n+  \t\t         function. The destination block is a catch or\n+  \t\t         setjmp.  */\n+\t\t      arc->is_nonlocal_return = 1;\n+\t\t      fn->blocks[dest].is_nonlocal_return = 1;\n+\t\t    }\n+\t\t}\n \t      \n \t      if (!arc->on_tree)\n \t\tfn->num_counts++;\n@@ -731,7 +883,7 @@ read_graph_file ()\n \n \t  if (gcov_read_unsigned (file, &blockno)\n \t      || blockno >= fn->num_blocks\n-\t      || fn->blocks[blockno].encoding)\n+\t      || fn->blocks[blockno].u.line.encoding)\n \t    goto corrupt;\n \t  \n \t  for (ix = 0; ;  )\n@@ -759,28 +911,15 @@ read_graph_file ()\n \t\t    goto corrupt;\n \t\t  if (!file_name)\n \t\t    break;\n-\t\t  for (src = sources; src; src = src->next)\n-\t\t    if (!strcmp (file_name, src->name))\n-\t\t      {\n-\t\t\tfree (file_name);\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  if (!src)\n-\t\t    {\n-\t\t      src = (source_t *)xcalloc (1, sizeof (source_t));\n-\t\t      src->name = file_name;\n-\t\t      src->coverage.name = file_name;\n-\t\t      src->index = sources ? sources->index + 1 : 1;\n-\t\t      src->next = sources;\n-\t\t      sources = src;\n-\t\t    }\n+\t\t  src = find_source (file_name);\n+\t\t  \n \t\t  line_nos[ix++] = 0;\n \t\t  line_nos[ix++] = src->index;\n \t\t}\n \t    }\n \t  \n-\t  fn->blocks[blockno].encoding = line_nos;\n-\t  fn->blocks[blockno].num_encodings = ix;\n+\t  fn->blocks[blockno].u.line.encoding = line_nos;\n+\t  fn->blocks[blockno].u.line.num = ix;\n \t}\n       else if (current_tag && !GCOV_TAG_IS_SUBTAG (current_tag, tag))\n \t{\n@@ -906,7 +1045,15 @@ read_count_file ()\n \t  goto cleanup;\n \t}\n       base = gcov_save_position (file);\n-      if (tag == GCOV_TAG_FUNCTION)\n+      if (tag == GCOV_TAG_OBJECT_SUMMARY)\n+\t{\n+\t  if (gcov_read_summary (file, &object_summary))\n+\t    goto corrupt;\n+\t}\n+      else if (tag == GCOV_TAG_PROGRAM_SUMMARY\n+\t       || tag == GCOV_TAG_INCORRECT_SUMMARY)\n+\tprogram_count++;\n+      else if (tag == GCOV_TAG_FUNCTION)\n \t{\n \t  unsigned checksum;\n \t  struct function_info *fn_n = functions;\n@@ -977,6 +1124,7 @@ solve_flow_graph (fn)\n   unsigned ix;\n   arc_t *arc;\n   gcov_type *count_ptr = fn->counts;\n+  block_t *blk;\n   block_t *valid_blocks = NULL;    /* valid, but unpropagated blocks.  */\n   block_t *invalid_blocks = NULL;  /* invalid, but inferable blocks.  */\n   \n@@ -1004,33 +1152,58 @@ solve_flow_graph (fn)\n \n   /* Propagate the measured counts, this must be done in the same\n      order as the code in profile.c  */\n-  for (ix = 0; ix != fn->num_blocks; ix++)\n+  for (ix = 0, blk = fn->blocks; ix != fn->num_blocks; ix++, blk++)\n     {\n       block_t const *prev_dst = NULL;\n       int out_of_order = 0;\n+      int non_fake_succ = 0;\n       \n-      for (arc = fn->blocks[ix].succ; arc; arc = arc->succ_next)\n+      for (arc = blk->succ; arc; arc = arc->succ_next)\n \t{\n+\t  if (!arc->fake)\n+\t    non_fake_succ++;\n+\t  \n \t  if (!arc->on_tree)\n \t    {\n \t      if (count_ptr)\n \t\tarc->count = *count_ptr++;\n \t      arc->count_valid = 1;\n-\t      fn->blocks[ix].num_succ--;\n+\t      blk->num_succ--;\n \t      arc->dst->num_pred--;\n \t    }\n \t  if (prev_dst && prev_dst > arc->dst)\n \t    out_of_order = 1;\n \t  prev_dst = arc->dst;\n \t}\n+      if (non_fake_succ == 1)\n+\t{\n+\t  /* If there is only one non-fake exit, it is an\n+\t     unconditional branch.  */\n+\t  for (arc = blk->succ; arc; arc = arc->succ_next)\n+\t    if (!arc->fake)\n+\t      {\n+\t\tarc->is_unconditional = 1;\n+\t\t/* If this block is instrumenting a call, it might be\n+\t\t   an artifical block. It is not artificial if it has\n+\t\t   a non-fallthrough exit, or the destination of the\n+\t\t   exit has more than one entry.  */\n+\t\tif (!arc->fall_through\n+\t\t    || arc->dst->pred != arc || arc->pred_next)\n+\t\t  blk->is_call_site = 0;\n+\t      }\n+\t}\n+      else\n+\t/* If there is more than one exit, it cannot be an artificial\n+\t   call instrumenting site.  */\n+\tblk->is_call_site = 0;\n       \n       /* Sort the successor arcs into ascending dst order. profile.c\n \t normally produces arcs in the right order, but sometimes with\n \t one or two out of order.  We're not using a particularly\n \t smart sort.  */\n       if (out_of_order)\n \t{\n-\t  arc_t *start = fn->blocks[ix].succ;\n+\t  arc_t *start = blk->succ;\n \t  unsigned changes = 1;\n \t  \n \t  while (changes)\n@@ -1058,20 +1231,18 @@ solve_flow_graph (fn)\n \t\t    }\n \t\t}\n \t    }\n-\t  fn->blocks[ix].succ = start;\n+\t  blk->succ = start;\n \t}\n       \n       /* Place it on the invalid chain, it will be ignored if that's\n \t wrong.  */\n-      fn->blocks[ix].invalid_chain = 1;\n-      fn->blocks[ix].chain = invalid_blocks;\n-      invalid_blocks = &fn->blocks[ix];\n+      blk->invalid_chain = 1;\n+      blk->chain = invalid_blocks;\n+      invalid_blocks = blk;\n     }\n \n   while (invalid_blocks || valid_blocks)\n     {\n-      block_t *blk;\n-      \n       while ((blk = invalid_blocks))\n \t{\n \t  gcov_type total = 0;\n@@ -1196,13 +1367,13 @@ add_branch_counts (coverage, arc)\n      coverage_t *coverage;\n      const arc_t *arc;\n {\n-  if (arc->is_call)\n+  if (arc->is_call_non_return)\n     {\n       coverage->calls++;\n       if (arc->src->count)\n \tcoverage->calls_executed++;\n     }\n-  else\n+  else if (!arc->is_unconditional)\n     {\n       coverage->branches++;\n       if (arc->src->count)\n@@ -1374,7 +1545,7 @@ make_gcov_file_name (input_name, src_name)\n static void\n add_line_counts (coverage, fn)\n      coverage_t *coverage;\n-     const function_t *fn;\n+     function_t *fn;\n {\n   unsigned ix;\n   line_t *line = NULL; /* this is propagated from one iteration to the\n@@ -1383,13 +1554,16 @@ add_line_counts (coverage, fn)\n   /* Scan each basic block.  */\n   for (ix = 0; ix != fn->num_blocks; ix++)\n     {\n-      const block_t *block = &fn->blocks[ix];\n+      block_t *block = &fn->blocks[ix];\n       unsigned *encoding;\n       const source_t *src = NULL;\n       unsigned jx;\n+      line_t *first_line = NULL;\n \n-      for (jx = 0, encoding = block->encoding;\n-\t   jx != block->num_encodings; jx++, encoding++)\n+      if (block->count && ix && ix + 1 != fn->num_blocks)\n+\tfn->blocks_executed++;\n+      for (jx = 0, encoding = block->u.line.encoding;\n+\t   jx != block->u.line.num; jx++, encoding++)\n \tif (!*encoding)\n \t  {\n \t    unsigned src_n = *++encoding;\n@@ -1406,26 +1580,38 @@ add_line_counts (coverage, fn)\n \t      {\n \t\tif (!line->exists)\n \t\t  coverage->lines++;\n-\t\tif  (!line->count && block->count)\n+\t\tif (!line->count && block->count)\n \t\t  coverage->lines_executed++;\n \t      }\n \t    line->exists = 1;\n \t    line->count += block->count;\n+\t    if (!first_line)\n+\t      first_line = line;\n \t  }\n-      \n-      if (line && flag_branches)\n+      free (block->u.line.encoding);\n+      block->u.span.root = NULL;\n+      if (!first_line)\n+\tfirst_line = line;\n+\t  \n+      if (!ix || ix + 1 == fn->num_blocks)\n+\t/* Entry or exit block */;\n+      else if (flag_all_blocks)\n \t{\n-\t  arc_t *arc;\n+\t  if (!first_line)\n+\t    first_line = &fn->src->lines[fn->line];\n \t  \n+\t  block->chain = first_line->u.blocks;\n+\t  first_line->u.blocks = block;\n+\t}\n+      else if (flag_branches)\n+\t{\n+\t  arc_t *arc;\n+\n \t  for (arc = block->succ; arc; arc = arc->succ_next)\n \t    {\n-\t      /* Ignore fall through arcs as they aren't really branches.  */\n-\t      if (arc->fall_through)\n-\t\tcontinue;\n-\t      \n-\t      arc->line_next = line->branches;\n-\t      line->branches = arc;\n-\t      if (coverage)\n+\t      arc->line_next = line->u.branches;\n+\t      line->u.branches = arc;\n+\t      if (coverage && !arc->is_unconditional)\n \t\tadd_branch_counts (coverage, arc);\n \t    }\n \t}\n@@ -1441,22 +1627,123 @@ accumulate_line_counts (src)\n      source_t *src;\n {\n   line_t *line;\n+  function_t *fn, *fn_p, *fn_n;\n   unsigned ix;\n+\n+  /* Reverse the function order.  */\n+  for (fn = src->functions, fn_p = NULL; fn;\n+       fn_p = fn, fn = fn_n)\n+    {\n+      fn_n = fn->line_next;\n+      fn->line_next = fn_p;\n+    }\n+  src->functions = fn_p;\n   \n   for (ix = src->num_lines, line = src->lines; ix--; line++)\n     {\n-      arc_t *arc, *arc_p, *arc_n;\n-      \n-      /* Total and reverse the branch information.  */\n-      for (arc = line->branches, arc_p = NULL; arc; arc_p = arc, arc = arc_n)\n+      if (!flag_all_blocks)\n \t{\n-\t  arc_n = arc->line_next;\n-\t  arc->line_next = arc_p;\n-\n-\t  add_branch_counts (&src->coverage, arc);\n+\t  arc_t *arc, *arc_p, *arc_n;\n+\t  \n+\t  /* Total and reverse the branch information.  */\n+\t  for (arc = line->u.branches, arc_p = NULL; arc;\n+\t       arc_p = arc, arc = arc_n)\n+\t    {\n+\t      arc_n = arc->line_next;\n+\t      arc->line_next = arc_p;\n+\t      \n+\t      add_branch_counts (&src->coverage, arc);\n+\t    }\n+\t  line->u.branches = arc_p;\n \t}\n-      line->branches = arc_p;\n+      else if (line->u.blocks)\n+\t{\n+\t  /* The user expects the line count to be the number of times\n+\t     a line has been executed. Simply summing the block count\n+\t     will give an artificially high number.  The Right Thing\n+\t     is to generate the spanning tree of the blocks on this\n+\t     line, and the sum the entry arcs to that tree.  */\n+\t  block_t *block, *block_p, *block_n;\n+\t  int changes = 1;\n+\t  gcov_type count = 0;\n+\t  \n+\t  /* Reverse the block information */\n+\t  for (block = line->u.blocks, block_p = NULL; block;\n+\t       block_p = block, block = block_n)\n+\t    {\n+\t      block_n = block->chain;\n+\t      block->chain = block_p;\n+\t      /* Each block is it's own spanning tree, with no siblings  */\n+\t      block->u.span.root = block;\n+\t      block->u.span.siblings = 0;\n+\t    }\n+\t  line->u.blocks = block_p;\n \n+\t  while (changes)\n+\t    {\n+\t      changes = 0;\n+\t      \n+\t      for (block = line->u.blocks; block; block = block->chain)\n+\t\t{\n+\t\t  arc_t *arc;\n+\t\t  \n+\t\t  for (arc = block->succ; arc; arc = arc->succ_next)\n+\t\t    {\n+\t\t      block_t *dst = arc->dst;\n+\t\t      \n+\t\t      if (!dst->u.span.root)\n+\t\t\t/* Not on this line.  */;\n+\t\t      else if (dst->u.span.root == block->u.span.root)\n+\t\t\t/* Same spanning tree.  */;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  block_t *root = block->u.span.root;\n+\t\t\t  block_t *dst_root = dst->u.span.root;\n+\t\t\t  \n+\t\t\t  /* Join spanning trees */\n+\t\t\t  if (root->u.span.siblings && !dst_root->u.span.root)\n+\t\t\t    {\n+\t\t\t      root = dst->u.span.root;\n+\t\t\t      dst_root = block->u.span.root;\n+\t\t\t    }\n+\t\t\t  \n+\t\t\t  dst->u.span.root = root;\n+\t\t\t  root->u.span.siblings += 1 + dst->u.span.siblings;\n+\t\t\t  if (dst->u.span.siblings)\n+\t\t\t    {\n+\t\t\t      block_t *dst_sib;\n+\t\t\t      \n+\t\t\t      dst->u.span.siblings = 0;\n+\t\t\t      for (dst_sib = line->u.blocks; dst_sib;\n+\t\t\t\t   dst_sib = dst_sib->chain)\n+\t\t\t\tif (dst_sib->u.span.root == dst_root)\n+\t\t\t\t  dst_sib->u.span.root = root;\n+\t\t\t    }\n+\t\t\t  arc->local_span = 1;\n+\t\t\t  changes = 1;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* Now sum the entry counts */\n+\t  for (block = line->u.blocks; block; block = block->chain)\n+\t    {\n+\t      arc_t *arc;\n+\n+\t      for (arc = block->succ; arc; arc = arc->succ_next)\n+\t\t{\n+\t\t  if (!arc->local_span)\n+\t\t    count += arc->count;\n+\t\t  if (flag_branches)\n+\t\t    add_branch_counts (&src->coverage, arc);\n+\t\t}\n+\t      block->u.span.root = NULL;\n+\t    }\n+\t  \n+\t  line->count = count;\n+\t}\n+      \n       if (line->exists)\n \t{\n \t  src->coverage.lines++;\n@@ -1466,6 +1753,50 @@ accumulate_line_counts (src)\n     }\n }\n \n+/* Ouput information about ARC number IX.  Returns non-zero if\n+   anything is output.  */\n+\n+static int\n+output_branch_count (gcov_file, ix, arc)\n+     FILE *gcov_file;\n+     int ix;\n+     const arc_t *arc;\n+{\n+  \n+  if (arc->is_call_non_return)\n+    {\n+      if (arc->src->count)\n+\t{\n+\t  fnotice (gcov_file, \"call   %2d returned %s\\n\", ix,\n+\t\t   format_gcov (arc->src->count - arc->count,\n+\t\t\t\tarc->src->count, -flag_counts));\n+\t}\n+      else\n+\tfnotice (gcov_file, \"call   %2d never executed\\n\", ix);\n+    }\n+  else if (!arc->is_unconditional)\n+    {\n+      if (arc->src->count)\n+\tfnotice (gcov_file, \"branch %2d taken %s%s\\n\", ix,\n+\t\t format_gcov (arc->count, arc->src->count, -flag_counts),\n+\t\t arc->fall_through ? \" (fallthrough)\" : \"\");\n+      else\n+\tfnotice (gcov_file, \"branch %2d never executed\\n\", ix);\n+    }\n+  else if (flag_unconditional && !arc->src->is_call_site)\n+    {\n+      if (arc->src->count)\n+\tfnotice (gcov_file, \"unconditional %2d taken %s\\n\", ix,\n+\t\t format_gcov (arc->count, arc->src->count, -flag_counts));\n+      else\n+\tfnotice (gcov_file, \"unconditional %2d never executed\\n\", ix);\n+    }\n+  else\n+    return 0;\n+  return 1;\n+  \n+}\n+\n /* Read in the source file one line at a time, and output that line to\n    the gcov file preceded by its execution count and other\n    information.  */\n@@ -1480,10 +1811,13 @@ output_lines (gcov_file, src)\n   const line_t *line;           /* current line info ptr.  */\n   char string[STRING_SIZE];     /* line buffer.  */\n   char const *retval = \"\";\t/* status of source file reading.  */\n+  function_t *fn = src->functions;\n \n   fprintf (gcov_file, \"%9s:%5d:Source:%s\\n\", \"-\", 0, src->name);\n   fprintf (gcov_file, \"%9s:%5d:Graph:%s\\n\", \"-\", 0, bbg_file_name);\n   fprintf (gcov_file, \"%9s:%5d:Data:%s\\n\", \"-\", 0, da_file_name);\n+  fprintf (gcov_file, \"%9s:%5d:Runs:%u\\n\", \"-\", 0, object_summary.runs);\n+  fprintf (gcov_file, \"%9s:%5d:Programs:%u\\n\", \"-\", 0, program_count);\n   \n   source_file = fopen (src->name, \"r\");\n   if (!source_file)\n@@ -1508,6 +1842,25 @@ output_lines (gcov_file, src)\n   for (line_num = 1, line = &src->lines[line_num];\n        line_num < src->num_lines; line_num++, line++)\n     {\n+      for (; fn && fn->line == line_num; fn = fn->line_next)\n+\t{\n+\t  arc_t *arc = fn->blocks[fn->num_blocks - 1].pred;\n+\t  gcov_type return_count = fn->blocks[fn->num_blocks - 1].count;\n+\n+\t  for (; arc; arc = arc->pred_next)\n+\t    if (arc->fake)\n+\t      return_count -= arc->count;\n+\t  \n+\t  fprintf (gcov_file, \"function %s\", fn->name);\n+\t  fprintf (gcov_file, \" called %s\",\n+\t\t   format_gcov (fn->blocks[0].count, 0, -1));\n+\t  fprintf (gcov_file, \" returned %s\",\n+\t\t   format_gcov (return_count, fn->blocks[0].count, 0));\n+\t  fprintf (gcov_file, \" blocks executed %s\",\n+\t\t   format_gcov (fn->blocks_executed, fn->num_blocks - 2, 0));\n+\t  fprintf (gcov_file, \"\\n\");\n+\t}\n+      \n       /* For lines which don't exist in the .bb file, print '-' before\n  \t the source line.  For lines which exist but were never\n  \t executed, print '#####' before the source line.  Otherwise,\n@@ -1535,37 +1888,34 @@ output_lines (gcov_file, src)\n \t}\n       if (!retval)\n \tfputs (\"??\\n\", gcov_file);\n-      \n-      if (flag_branches)\n+\n+      if (flag_all_blocks)\n \t{\n-\t  int ix;\n-\t  arc_t *arc;\n+\t  block_t *block;\n+\t  int ix, jx;\n \t  \n-\t  for (ix = 0, arc = line->branches; arc; arc = arc->line_next, ix++)\n+\t  for (ix = jx = 0, block = line->u.blocks; block;\n+\t       block = block->chain)\n \t    {\n-\t      if (arc->is_call)\n-\t\t{\n-\t\t  if (arc->src->count)\n-\t\t    fnotice\n-\t\t      (gcov_file, \"call   %2d returns %s\\n\", ix,\n-\t\t       format_gcov (arc->src->count - arc->count,\n-\t\t\t\t    arc->src->count,\n-\t\t\t\t    -flag_counts));\n-\t\t  else\n-\t\t    fnotice (gcov_file, \"call   %2d never executed\\n\", ix);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (arc->src->count)\n-\t\t    fnotice\n-\t\t      (gcov_file, \"branch %2d taken %s\\n\", ix,\n-\t\t       format_gcov (arc->count, arc->src->count,\n-\t\t\t\t    -flag_counts));\n-\t\t  else\n-\t\t    fnotice (gcov_file, \"branch %2d never executed\\n\", ix);\n-\t\t}\n+\t      arc_t *arc;\n+\n+\t      if (!block->is_call_site)\n+\t\tfprintf (gcov_file, \"%9s:%5u-block %2d\\n\",\n+\t\t\t !line->exists ? \"-\" : !block->count ? \"$$$$$\"\n+\t\t\t : format_gcov (block->count, 0, -1), line_num, ix++);\n+\t      if (flag_branches)\n+\t\tfor (arc = block->succ; arc; arc = arc->succ_next)\n+\t\t  jx += output_branch_count (gcov_file, jx, arc);\n \t    }\n \t}\n+      else if (flag_branches)\n+\t{\n+\t  int ix;\n+\t  arc_t *arc;\n+\t  \n+\t  for (ix = 0, arc = line->u.branches; arc; arc = arc->line_next)\n+\t    ix += output_branch_count (gcov_file, ix, arc);\n+\t}\n     }\n   \n   /* Handle all remaining source lines.  There may be lines after the"}, {"sha": "68435dfd987d6a3a69b554efb66db86444653c94", "filename": "gcc/profile.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=27283c7340100bf70de6af824143c052cc9d0c76", "patch": "@@ -926,7 +926,7 @@ branch_prob ()\n   unsigned num_edges, ignored_edges;\n   struct edge_list *el;\n   const char *name = IDENTIFIER_POINTER\n-\t\t      (DECL_ASSEMBLER_NAME (current_function_decl));\n+    (DECL_ASSEMBLER_NAME (current_function_decl));\n \n   profile_info.current_function_cfg_checksum = compute_checksum ();\n   for (i = 0; i < profile_info.n_sections; i++)\n@@ -1086,6 +1086,8 @@ branch_prob ()\n   if (flag_test_coverage && bbg_file)\n     {\n       long offset;\n+      const char *file = DECL_SOURCE_FILE (current_function_decl);\n+      unsigned line = DECL_SOURCE_LINE (current_function_decl);\n       \n       /* Announce function */\n       if (gcov_write_unsigned (bbg_file, GCOV_TAG_FUNCTION)\n@@ -1094,6 +1096,8 @@ branch_prob ()\n \t\t\t     strlen (name))\n \t  || gcov_write_unsigned (bbg_file,\n \t\t\t    profile_info.current_function_cfg_checksum)\n+\t  || gcov_write_string (bbg_file, file, strlen (file))\n+\t  || gcov_write_unsigned (bbg_file, line)\n \t  || gcov_write_length (bbg_file, offset))\n \tgoto bbg_error;\n "}, {"sha": "d70d3355e893ef9bea05bd6e367b7d18ce50239f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=27283c7340100bf70de6af824143c052cc9d0c76", "patch": "@@ -1,3 +1,8 @@\n+2003-03-31  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* lib/gcov.exp: Adjust call return testing strings.\n+\t* g77.dg/gcov/gcov-1.f: Don't expect unconditional branches.\n+\n 2003-03-31  Roger Sayle  <roger@eyesopen.com>\n \n \t* gcc.dg/builtins-3.c: Add new tests for sin and cos."}, {"sha": "fa0ce55f8f83c15be8598aba642890ec43d28464", "filename": "gcc/testsuite/g77.dg/gcov/gcov-1.f", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Ftestsuite%2Fg77.dg%2Fgcov%2Fgcov-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Ftestsuite%2Fg77.dg%2Fgcov%2Fgcov-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.dg%2Fgcov%2Fgcov-1.f?ref=27283c7340100bf70de6af824143c052cc9d0c76", "patch": "@@ -118,9 +118,7 @@ integer function gt1(f)\n       if (f .ne. 0) goto 100\t\t! count(2)\n \t\t\t\t\t! branch(end)\n       gt1 = 1\t\t\t\t! count(1)\n-\t\t\t\t\t! branch(100)\n       goto 101\t\t\t\t! count(1)\n-\t\t\t\t\t! branch(end)\n   100 gt1 = 2\t\t\t\t! count(1)\n   101 continue\t\t\t\t! count(2)\n       end\n@@ -136,9 +134,7 @@ integer function gt2(f)\n          if (i .eq. f) goto 100\t\t! count(19)\n       end do\n       gt2 = 4\t\t\t\t! count(1)\n-\t\t\t\t\t! branch(100)\n       goto 101\t\t\t\t! count(1)\n-\t\t\t\t\t! branch(end)\n   100 gt2 = 8\t\t\t\t! count(1)\n   101 continue\t\t\t\t! count(2)\n       end\n@@ -149,17 +145,13 @@ integer function gt3(i)\n       integer i\n       goto (101, 102, 103, 104), i\t! count(2)\n       gt3 = 8\t\t\t\t! count(1)\n-\t\t\t\t\t! branch(100)\n       goto 105\t\t\t\t! count(1)\n-\t\t\t\t\t! branch(end)\n   101 gt3 = 1024\n       goto 105\n   102 gt3 = 2048\n       goto 105\n   103 gt3 = 16\t\t\t\t! count(1)\n-\t\t\t\t\t! branch(100)\n       goto 105\t\t\t\t! count(1)\n-\t\t\t\t\t! branch(end)\n   104 gt3 = 4096\n       goto 105\n   105 gt3 = gt3 * 2\t\t\t! count(2)"}, {"sha": "3350d288c04e54155fdd0304989447a147ee467c", "filename": "gcc/testsuite/lib/gcov.exp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Ftestsuite%2Flib%2Fgcov.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27283c7340100bf70de6af824143c052cc9d0c76/gcc%2Ftestsuite%2Flib%2Fgcov.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcov.exp?ref=27283c7340100bf70de6af824143c052cc9d0c76", "patch": "@@ -168,7 +168,7 @@ proc verify-calls { testcase file } {\n     set n 0\n     while { [gets $fd line] >= 0 } {\n \tregexp \"^\\[^:\\]+: *(\\[0-9\\]+):\" \"$line\" all n\n-\tif [regexp \"returns\" $line] {\n+\tif [regexp \"return\" $line] {\n \t    verbose \"Processing returns line $n: $line\" 3\n \t    if [regexp \"returns\\\\((\\[0-9 \\]+)\\\\)\" \"$line\" all new_shouldbe] {\n \t\t# All percentages in the current list should have been seen.\n@@ -179,12 +179,12 @@ proc verify-calls { testcase file } {\n \t\t}\n \t        # Record the percentages to check for.\n \t\tset shouldbe $new_shouldbe\n-\t    } elseif [regexp \"call +\\[0-9\\]+ returns (-\\[0-9\\]+)%\" \"$line\" \\\n+\t    } elseif [regexp \"call +\\[0-9\\]+ returned (-\\[0-9\\]+)%\" \"$line\" \\\n \t\t\tall returns] {\n \t\t# Percentages should never be negative.\n \t\tfail \"$n: negative percentage: $returns\"\n \t\tincr failed\n-\t    } elseif [regexp \"call +\\[0-9\\]+ returns (\\[0-9\\]+)%\" \"$line\" \\\n+\t    } elseif [regexp \"call +\\[0-9\\]+ returned (\\[0-9\\]+)%\" \"$line\" \\\n \t\t\tall returns] {\n \t\t# For branches we check that percentages are not greater than\n \t\t# 100 but call return percentages can be, as for setjmp(), so"}]}