{"sha": "a10631530f1719c92d70117455e2a207975b350b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEwNjMxNTMwZjE3MTljOTJkNzAxMTc0NTVlMmEyMDc5NzViMzUwYg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-07-11T13:43:31Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-07-11T13:43:31Z"}, "message": "diagnostics: support compact printing of secondary locations\n\ngcc/ChangeLog:\n\t* diagnostic-show-locus.c: Include \"gcc-rich-location.h\".\n\t(layout::m_primary_loc): New field.\n\t(layout::layout): Initialize new field.  Move location filtering\n\tlogic from here to...\n\t(layout::maybe_add_location_range): ...this new method.  Add\n\tsupport for filtering to just the lines already specified by other\n\tlocations.\n\t(layout::will_show_line_p): New method.\n\t(selftest::test_add_location_if_nearby): New test function.\n\t(selftest::diagnostic_show_locus_c_tests): Call it.\n\t* gcc-rich-location.h (gcc_rich_location::add_location_if_nearby):\n\tNew method.\n\nFrom-SVN: r250133", "tree": {"sha": "acbc15e7a9bfdeafeb290b090773e2ae649fdc6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acbc15e7a9bfdeafeb290b090773e2ae649fdc6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a10631530f1719c92d70117455e2a207975b350b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a10631530f1719c92d70117455e2a207975b350b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a10631530f1719c92d70117455e2a207975b350b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a10631530f1719c92d70117455e2a207975b350b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d988b35c9a330535dda0a46c79f6312fd3f846c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d988b35c9a330535dda0a46c79f6312fd3f846c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d988b35c9a330535dda0a46c79f6312fd3f846c6"}], "stats": {"total": 309, "additions": 243, "deletions": 66}, "files": [{"sha": "c971e8abccb0f1bfb370d2fbefcaa158d5aca299", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a10631530f1719c92d70117455e2a207975b350b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a10631530f1719c92d70117455e2a207975b350b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a10631530f1719c92d70117455e2a207975b350b", "patch": "@@ -1,3 +1,18 @@\n+2017-07-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* diagnostic-show-locus.c: Include \"gcc-rich-location.h\".\n+\t(layout::m_primary_loc): New field.\n+\t(layout::layout): Initialize new field.  Move location filtering\n+\tlogic from here to...\n+\t(layout::maybe_add_location_range): ...this new method.  Add\n+\tsupport for filtering to just the lines already specified by other\n+\tlocations.\n+\t(layout::will_show_line_p): New method.\n+\t(selftest::test_add_location_if_nearby): New test function.\n+\t(selftest::diagnostic_show_locus_c_tests): Call it.\n+\t* gcc-rich-location.h (gcc_rich_location::add_location_if_nearby):\n+\tNew method.\n+\n 2017-07-11  Tom de Vries  <tom@codesourcery.com>\n \n \t* config/nvptx/nvptx.c (WORKAROUND_PTXJIT_BUG): New macro."}, {"sha": "5227400b716a691937e3ca728ffa38cd3d6c7eba", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 207, "deletions": 66, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a10631530f1719c92d70117455e2a207975b350b/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a10631530f1719c92d70117455e2a207975b350b/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=a10631530f1719c92d70117455e2a207975b350b", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"backtrace.h\"\n #include \"diagnostic.h\"\n #include \"diagnostic-color.h\"\n+#include \"gcc-rich-location.h\"\n #include \"selftest.h\"\n \n #ifdef HAVE_TERMIOS_H\n@@ -196,6 +197,9 @@ class layout\n \t  rich_location *richloc,\n \t  diagnostic_t diagnostic_kind);\n \n+  bool maybe_add_location_range (const location_range *loc_range,\n+\t\t\t\t bool restrict_to_current_line_spans);\n+\n   int get_num_line_spans () const { return m_line_spans.length (); }\n   const line_span *get_line_span (int idx) const { return &m_line_spans[idx]; }\n \n@@ -206,6 +210,7 @@ class layout\n   void print_line (int row);\n \n  private:\n+  bool will_show_line_p (int row) const;\n   void print_leading_fixits (int row);\n   void print_source_line (int row, const char *line, int line_width,\n \t\t\t  line_bounds *lbounds_out);\n@@ -241,6 +246,7 @@ class layout\n   diagnostic_context *m_context;\n   pretty_printer *m_pp;\n   diagnostic_t m_diagnostic_kind;\n+  location_t m_primary_loc;\n   expanded_location m_exploc;\n   colorizer m_colorizer;\n   bool m_colorize_source_p;\n@@ -767,6 +773,7 @@ layout::layout (diagnostic_context * context,\n : m_context (context),\n   m_pp (context->printer),\n   m_diagnostic_kind (diagnostic_kind),\n+  m_primary_loc (richloc->get_range (0)->m_loc),\n   m_exploc (richloc->get_expanded_location (0)),\n   m_colorizer (context, diagnostic_kind),\n   m_colorize_source_p (context->colorize_source_p),\n@@ -775,77 +782,12 @@ layout::layout (diagnostic_context * context,\n   m_line_spans (1 + richloc->get_num_locations ()),\n   m_x_offset (0)\n {\n-  source_location primary_loc = richloc->get_range (0)->m_loc;\n-\n   for (unsigned int idx = 0; idx < richloc->get_num_locations (); idx++)\n     {\n       /* This diagnostic printer can only cope with \"sufficiently sane\" ranges.\n \t Ignore any ranges that are awkward to handle.  */\n       const location_range *loc_range = richloc->get_range (idx);\n-\n-      /* Split the \"range\" into caret and range information.  */\n-      source_range src_range = get_range_from_loc (line_table, loc_range->m_loc);\n-\n-      /* Expand the various locations.  */\n-      expanded_location start\n-\t= linemap_client_expand_location_to_spelling_point\n-\t    (src_range.m_start, LOCATION_ASPECT_START);\n-      expanded_location finish\n-\t= linemap_client_expand_location_to_spelling_point\n-\t    (src_range.m_finish, LOCATION_ASPECT_FINISH);\n-      expanded_location caret\n-\t= linemap_client_expand_location_to_spelling_point\n-\t    (loc_range->m_loc, LOCATION_ASPECT_CARET);\n-\n-      /* If any part of the range isn't in the same file as the primary\n-\t location of this diagnostic, ignore the range.  */\n-      if (start.file != m_exploc.file)\n-\tcontinue;\n-      if (finish.file != m_exploc.file)\n-\tcontinue;\n-      if (loc_range->m_show_caret_p)\n-\tif (caret.file != m_exploc.file)\n-\t  continue;\n-\n-      /* Sanitize the caret location for non-primary ranges.  */\n-      if (m_layout_ranges.length () > 0)\n-\tif (loc_range->m_show_caret_p)\n-\t  if (!compatible_locations_p (loc_range->m_loc, primary_loc))\n-\t    /* Discard any non-primary ranges that can't be printed\n-\t       sanely relative to the primary location.  */\n-\t    continue;\n-\n-      /* Everything is now known to be in the correct source file,\n-\t but it may require further sanitization.  */\n-      layout_range ri (&start, &finish, loc_range->m_show_caret_p, &caret);\n-\n-      /* If we have a range that finishes before it starts (perhaps\n-\t from something built via macro expansion), printing the\n-\t range is likely to be nonsensical.  Also, attempting to do so\n-\t breaks assumptions within the printing code  (PR c/68473).\n-\t Similarly, don't attempt to print ranges if one or both ends\n-\t of the range aren't sane to print relative to the\n-\t primary location (PR c++/70105).  */\n-      if (start.line > finish.line\n-\t  || !compatible_locations_p (src_range.m_start, primary_loc)\n-\t  || !compatible_locations_p (src_range.m_finish, primary_loc))\n-\t{\n-\t  /* Is this the primary location?  */\n-\t  if (m_layout_ranges.length () == 0)\n-\t    {\n-\t      /* We want to print the caret for the primary location, but\n-\t\t we must sanitize away m_start and m_finish.  */\n-\t      ri.m_start = ri.m_caret;\n-\t      ri.m_finish = ri.m_caret;\n-\t    }\n-\t  else\n-\t    /* This is a non-primary range; ignore it.  */\n-\t    continue;\n-\t}\n-\n-      /* Passed all the tests; add the range to m_layout_ranges so that\n-\t it will be printed.  */\n-      m_layout_ranges.safe_push (ri);\n+      maybe_add_location_range (loc_range, false);\n     }\n \n   /* Populate m_fixit_hints, filtering to only those that are in the\n@@ -882,6 +824,118 @@ layout::layout (diagnostic_context * context,\n     show_ruler (m_x_offset + max_width);\n }\n \n+/* Attempt to add LOC_RANGE to m_layout_ranges, filtering them to\n+   those that we can sanely print.\n+\n+   If RESTRICT_TO_CURRENT_LINE_SPANS is true, then LOC_RANGE is also\n+   filtered against this layout instance's current line spans: it\n+   will only be added if the location is fully within the lines\n+   already specified by other locations.\n+\n+   Return true iff LOC_RANGE was added.  */\n+\n+bool\n+layout::maybe_add_location_range (const location_range *loc_range,\n+\t\t\t\t  bool restrict_to_current_line_spans)\n+{\n+  gcc_assert (loc_range);\n+\n+  /* Split the \"range\" into caret and range information.  */\n+  source_range src_range = get_range_from_loc (line_table, loc_range->m_loc);\n+\n+  /* Expand the various locations.  */\n+  expanded_location start\n+    = linemap_client_expand_location_to_spelling_point\n+    (src_range.m_start, LOCATION_ASPECT_START);\n+  expanded_location finish\n+    = linemap_client_expand_location_to_spelling_point\n+    (src_range.m_finish, LOCATION_ASPECT_FINISH);\n+  expanded_location caret\n+    = linemap_client_expand_location_to_spelling_point\n+    (loc_range->m_loc, LOCATION_ASPECT_CARET);\n+\n+  /* If any part of the range isn't in the same file as the primary\n+     location of this diagnostic, ignore the range.  */\n+  if (start.file != m_exploc.file)\n+    return false;\n+  if (finish.file != m_exploc.file)\n+    return false;\n+  if (loc_range->m_show_caret_p)\n+    if (caret.file != m_exploc.file)\n+      return false;\n+\n+  /* Sanitize the caret location for non-primary ranges.  */\n+  if (m_layout_ranges.length () > 0)\n+    if (loc_range->m_show_caret_p)\n+      if (!compatible_locations_p (loc_range->m_loc, m_primary_loc))\n+\t/* Discard any non-primary ranges that can't be printed\n+\t   sanely relative to the primary location.  */\n+\treturn false;\n+\n+  /* Everything is now known to be in the correct source file,\n+     but it may require further sanitization.  */\n+  layout_range ri (&start, &finish, loc_range->m_show_caret_p, &caret);\n+\n+  /* If we have a range that finishes before it starts (perhaps\n+     from something built via macro expansion), printing the\n+     range is likely to be nonsensical.  Also, attempting to do so\n+     breaks assumptions within the printing code  (PR c/68473).\n+     Similarly, don't attempt to print ranges if one or both ends\n+     of the range aren't sane to print relative to the\n+     primary location (PR c++/70105).  */\n+  if (start.line > finish.line\n+      || !compatible_locations_p (src_range.m_start, m_primary_loc)\n+      || !compatible_locations_p (src_range.m_finish, m_primary_loc))\n+    {\n+      /* Is this the primary location?  */\n+      if (m_layout_ranges.length () == 0)\n+\t{\n+\t  /* We want to print the caret for the primary location, but\n+\t     we must sanitize away m_start and m_finish.  */\n+\t  ri.m_start = ri.m_caret;\n+\t  ri.m_finish = ri.m_caret;\n+\t}\n+      else\n+\t/* This is a non-primary range; ignore it.  */\n+\treturn false;\n+    }\n+\n+  /* Potentially filter to just the lines already specified by other\n+     locations.  This is for use by gcc_rich_location::add_location_if_nearby.\n+     The layout ctor doesn't use it, and can't because m_line_spans\n+     hasn't been set up at that point.  */\n+  if (restrict_to_current_line_spans)\n+    {\n+      if (!will_show_line_p (start.line))\n+\treturn false;\n+      if (!will_show_line_p (finish.line))\n+\treturn false;\n+      if (loc_range->m_show_caret_p)\n+\tif (!will_show_line_p (caret.line))\n+\t  return false;\n+    }\n+\n+  /* Passed all the tests; add the range to m_layout_ranges so that\n+     it will be printed.  */\n+  m_layout_ranges.safe_push (ri);\n+  return true;\n+}\n+\n+/* Return true iff ROW is within one of the line spans for this layout.  */\n+\n+bool\n+layout::will_show_line_p (int row) const\n+{\n+  for (int line_span_idx = 0; line_span_idx < get_num_line_spans ();\n+       line_span_idx++)\n+    {\n+      const line_span *line_span = get_line_span (line_span_idx);\n+      if (line_span->contains_line_p (row))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Return true iff we should print a heading when starting the\n    line span with the given index.  */\n \n@@ -1782,6 +1836,28 @@ layout::print_line (int row)\n \n } /* End of anonymous namespace.  */\n \n+/* If LOC is within the spans of lines that will already be printed for\n+   this gcc_rich_location, then add it as a secondary location and return true.\n+\n+   Otherwise return false.  */\n+\n+bool\n+gcc_rich_location::add_location_if_nearby (location_t loc)\n+{\n+  /* Use the layout location-handling logic to sanitize LOC,\n+     filtering it to the current line spans within a temporary\n+     layout instance.  */\n+  layout layout (global_dc, this, DK_ERROR);\n+  location_range loc_range;\n+  loc_range.m_loc = loc;\n+  loc_range.m_show_caret_p = false;\n+  if (!layout.maybe_add_location_range (&loc_range, true))\n+    return false;\n+\n+  add_range (loc, false);\n+  return true;\n+}\n+\n /* Print the physical source code corresponding to the location of\n    this diagnostic, with additional annotations.  */\n \n@@ -2226,6 +2302,70 @@ test_diagnostic_show_locus_one_liner (const line_table_case &case_)\n   test_one_liner_many_fixits_2 ();\n }\n \n+/* Verify that gcc_rich_location::add_location_if_nearby works.  */\n+\n+static void\n+test_add_location_if_nearby (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     ...000000000111111111122222222223333333333.\n+     ...123456789012345678901234567890123456789.  */\n+  const char *content\n+    = (\"struct same_line { double x; double y; ;\\n\" /* line 1.  */\n+       \"struct different_line\\n\"                    /* line 2.  */\n+       \"{\\n\"                                        /* line 3.  */\n+       \"  double x;\\n\"                              /* line 4.  */\n+       \"  double y;\\n\"                              /* line 5.  */\n+       \";\\n\");                                      /* line 6.  */\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n+  line_table_test ltt (case_);\n+\n+  const line_map_ordinary *ord_map\n+    = linemap_check_ordinary (linemap_add (line_table, LC_ENTER, false,\n+\t\t\t\t\t   tmp.get_filename (), 0));\n+\n+  linemap_line_start (line_table, 1, 100);\n+\n+  const location_t final_line_end\n+    = linemap_position_for_line_and_column (line_table, ord_map, 6, 7);\n+\n+  /* Don't attempt to run the tests if column data might be unavailable.  */\n+  if (final_line_end > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  /* Test of add_location_if_nearby on the same line as the\n+     primary location.  */\n+  {\n+    const location_t missing_close_brace_1_39\n+      = linemap_position_for_line_and_column (line_table, ord_map, 1, 39);\n+    const location_t matching_open_brace_1_18\n+      = linemap_position_for_line_and_column (line_table, ord_map, 1, 18);\n+    gcc_rich_location richloc (missing_close_brace_1_39);\n+    bool added = richloc.add_location_if_nearby (matching_open_brace_1_18);\n+    ASSERT_TRUE (added);\n+    ASSERT_EQ (2, richloc.get_num_locations ());\n+    test_diagnostic_context dc;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \" struct same_line { double x; double y; ;\\n\"\n+\t\t  \"                  ~                    ^\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Test of add_location_if_nearby on a different line to the\n+     primary location.  */\n+  {\n+    const location_t missing_close_brace_6_1\n+      = linemap_position_for_line_and_column (line_table, ord_map, 6, 1);\n+    const location_t matching_open_brace_3_1\n+      = linemap_position_for_line_and_column (line_table, ord_map, 3, 1);\n+    gcc_rich_location richloc (missing_close_brace_6_1);\n+    bool added = richloc.add_location_if_nearby (matching_open_brace_3_1);\n+    ASSERT_FALSE (added);\n+    ASSERT_EQ (1, richloc.get_num_locations ());\n+  }\n+}\n+\n /* Verify that we print fixits even if they only affect lines\n    outside those covered by the ranges in the rich_location.  */\n \n@@ -2857,6 +2997,7 @@ diagnostic_show_locus_c_tests ()\n   test_diagnostic_show_locus_unknown_location ();\n \n   for_each_line_table_case (test_diagnostic_show_locus_one_liner);\n+  for_each_line_table_case (test_add_location_if_nearby);\n   for_each_line_table_case (test_diagnostic_show_locus_fixit_lines);\n   for_each_line_table_case (test_fixit_consolidation);\n   for_each_line_table_case (test_overlapped_fixit_printing);"}, {"sha": "2720f38d0ebe534c13fced434660183bab58ad22", "filename": "gcc/gcc-rich-location.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a10631530f1719c92d70117455e2a207975b350b/gcc%2Fgcc-rich-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a10631530f1719c92d70117455e2a207975b350b/gcc%2Fgcc-rich-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-rich-location.h?ref=a10631530f1719c92d70117455e2a207975b350b", "patch": "@@ -40,6 +40,27 @@ class gcc_rich_location : public rich_location\n \n   void add_fixit_misspelled_id (location_t misspelled_token_loc,\n \t\t\t\ttree hint_id);\n+\n+  /* If LOC is within the spans of lines that will already be printed for\n+     this gcc_rich_location, then add it as a secondary location\n+     and return true.\n+\n+     Otherwise return false.\n+\n+     This allows for a diagnostic to compactly print secondary locations\n+     in one diagnostic when these are near enough the primary locations for\n+     diagnostics-show-locus.c to cope with them, and to fall back to\n+     printing them via a note otherwise e.g.:\n+\n+\tgcc_rich_location richloc (primary_loc);\n+\tbool added secondary = richloc.add_location_if_nearby (secondary_loc);\n+\terror_at_rich_loc (&richloc, \"main message\");\n+\tif (!added secondary)\n+\t  inform (secondary_loc, \"message for secondary\");\n+\n+     Implemented in diagnostic-show-locus.c.  */\n+\n+  bool add_location_if_nearby (location_t loc);\n };\n \n #endif /* GCC_RICH_LOCATION_H */"}]}