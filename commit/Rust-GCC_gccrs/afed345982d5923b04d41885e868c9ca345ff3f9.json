{"sha": "afed345982d5923b04d41885e868c9ca345ff3f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZlZDM0NTk4MmQ1OTIzYjA0ZDQxODg1ZTg2OGM5Y2EzNDVmZjNmOQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-08-03T20:14:21Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-08-03T20:14:21Z"}, "message": "Refactoring of timevar API\n\ngcc/ChangeLog:\n\t* main.c (main): Pass in NULL for toplev's external_timer.\n\t* timevar.c: Include coretypes.h.\n\t(class timer::named_items): New.\n\t(timer::named_items::named_items): New.\n\t(timer::named_items::~named_items): New.\n\t(timer::named_items::push): New.\n\t(timer::named_items::pop): New.\n\t(timer::named_items::print): New.\n\t(timer::timer): Initialize field \"m_jit_client_items\".\n\t(timer::~timer): New.\n\t(timer::push): Move bulk of implementation to...\n\t(timer::push_internal): ...here.  New function.\n\t(timer::pop): Move bulk of implementation to...\n\t(timer::pop_internal): ...here.  New function.\n\t(timer::push_client_item): New.\n\t(timer::pop_client_item): New.\n\t(timer::print_row): New function, taken from timer::print.\n\t(timer::print): Print \"GCC items\" header if we also have client\n\titems.  Move row-printing to timer::print_row.  Print any client\n\titems.\n\t(timer::get_topmost_item_name): New method.\n\t* timevar.def (TV_JIT_ACQUIRING_MUTEX): New.\n\t(TV_JIT_CLIENT_CODE): New.\n\t* timevar.h (timer::push_client_item): New declaration.\n\t(timer::pop_client_item): New declaration.\n\t(timer::get_topmost_item_name): New method.\n\t(timer::push_internal): New declaration.\n\t(timer::pop_internal): New declaration.\n\t(timer::print_row): New declaration.\n\t(timer::named_items): New declaration.\n\t(timer::m_jit_client_items): New field.\n\t(timer): Add friend class named_items.\n\t(auto_timevar::auto_timevar): Add timer param.\n\t(auto_timevar::~auto_timevar): Use field \"m_timer\".\n\t(auto_timevar::m_timer): New field.\n\t* toplev.c (initialize_rtl): Add g_timer as param when\n\tconstructing auto_timevar instance.\n\t(toplev::toplev): Add \"external_timer\" param, and use it to\n\tinitialize the \"g_timer\" global if non-NULL.\n\t(toplev::~toplev): If this created \"g_timer\", delete it.\n\t* toplev.h (toplev::toplev): Replace \"use_TV_TOTAL\" bool param\n\twith \"external_timer\" timer *.\n\ngcc/jit/ChangeLog:\n\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_4): New.\n\t* docs/topics/contexts.rst (GCC_JIT_BOOL_OPTION_DUMP_SUMMARY):\n\tWe no longer show a profile.\n\t* docs/topics/index.rst (Topic Reference): Add performance.rst.\n\t* docs/topics/performance.rst: New file.\n\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n\t* jit-playback.c (gcc::jit::playback::context::compile): Add timer\n\tparam when constructing the \"toplev\" instance.\n\t(gcc::jit::playback::context::acquire_mutex): Add timer param when\n\tconstructing auto_timevar instance.\n\t(gcc::jit::playback::context::make_fake_args): If we have a timer,\n\tadd \"-ftime-report\".\n\t(gcc::jit::playback::context::invoke_driver): Add timer param when\n\tconstructing auto_timevar instance.\n\t(gcc::jit::playback::context::dlopen_built_dso): Likewise.\n\t* jit-playback.h (gcc::jit::playback::context::get_timer): New accessor.\n\t* jit-recording.c: Include timevar.h.\n\t(gcc::jit::recording::context::context): Initialize field \"m_timer\".\n\t* jit-recording.h: Add forward declaration of class timer.\n\t(gcc::jit::recording::context::set_timer): New method.\n\t(gcc::jit::recording::context::get_timer): New method.\n\t(gcc::jit::recording::context::m_timer): New field.\n\t* libgccjit++.h (gccjit::timer): New class.\n\t(gccjit::auto_time): New class.\n\t(gccjit::context::set_timer): New method.\n\t(gccjit::context::get_timer): New.\n\t(gccjit::timer::timer): New.\n\t(gccjit::timer::push): New.\n\t(gccjit::timer::pop): New.\n\t(timer::print): New.\n\t(timer::get_inner_timer): New.\n\t(timer::release): New.\n\t(auto_time::auto_time): New.\n\t(auto_time::~auto_time): New.\n\t* libgccjit.c: Include timevar.h.\n\t(struct gcc_jit_timer): New.\n\t(gcc_jit_timer_new): New function.\n\t(gcc_jit_timer_release): New function.\n\t(gcc_jit_context_set_timer): New function.\n\t(gcc_jit_context_get_timer): New function.\n\t(gcc_jit_timer_push): New function.\n\t(gcc_jit_timer_pop): New function.\n\t(gcc_jit_timer_print): New function.\n\t* libgccjit.h (LIBGCCJIT_HAVE_TIMING_API): New macro.\n\t(gcc_jit_timer): New typedef.\n\t(gcc_jit_timer_new): New function.\n\t(gcc_jit_timer_release): New function.\n\t(gcc_jit_context_set_timer): New function.\n\t(gcc_jit_context_get_timer): New function.\n\t(gcc_jit_timer_push): New function.\n\t(gcc_jit_timer_pop): New function.\n\t(gcc_jit_timer_print): New function.\n\t* libgccjit.map (LIBGCCJIT_ABI_4): New.\n\t(gcc_jit_timer_new): New function.\n\t(gcc_jit_timer_release): New function.\n\t(gcc_jit_context_set_timer): New function.\n\t(gcc_jit_context_get_timer): New function.\n\t(gcc_jit_timer_push): New function.\n\t(gcc_jit_timer_pop): New function.\n\t(gcc_jit_timer_print): New function.\n\ngcc/testsuite/ChangeLog:\n\t* jit.dg/test-benchmark.c (test_jit): Add param \"timer\" and use\n\tit to push/pop timing items.\n\t(main): For each optimization level, create a gcc_jit_timer, and\n\ttime all of the iteration within that level cumulatively.\n\t* jit.dg/test-error-gcc_jit_timer_pop-mismatch.c: New test case.\n\t* jit.dg/test-error-gcc_jit_timer_pop-too-many.c: New test case.\n\nFrom-SVN: r226530", "tree": {"sha": "b90c7df0235fa14daf2c76f22203ee08c2c32bcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b90c7df0235fa14daf2c76f22203ee08c2c32bcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afed345982d5923b04d41885e868c9ca345ff3f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afed345982d5923b04d41885e868c9ca345ff3f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afed345982d5923b04d41885e868c9ca345ff3f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afed345982d5923b04d41885e868c9ca345ff3f9/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef9da28d8fa1e2c0dc890f87374c0f21b18430c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef9da28d8fa1e2c0dc890f87374c0f21b18430c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef9da28d8fa1e2c0dc890f87374c0f21b18430c3"}], "stats": {"total": 1987, "additions": 1667, "deletions": 320}, "files": [{"sha": "8e1df7205b5083d1ba68a522fb0a73eb607fb821", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -1,3 +1,48 @@\n+2015-08-03  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* main.c (main): Pass in NULL for toplev's external_timer.\n+\t* timevar.c: Include coretypes.h.\n+\t(class timer::named_items): New.\n+\t(timer::named_items::named_items): New.\n+\t(timer::named_items::~named_items): New.\n+\t(timer::named_items::push): New.\n+\t(timer::named_items::pop): New.\n+\t(timer::named_items::print): New.\n+\t(timer::timer): Initialize field \"m_jit_client_items\".\n+\t(timer::~timer): New.\n+\t(timer::push): Move bulk of implementation to...\n+\t(timer::push_internal): ...here.  New function.\n+\t(timer::pop): Move bulk of implementation to...\n+\t(timer::pop_internal): ...here.  New function.\n+\t(timer::push_client_item): New.\n+\t(timer::pop_client_item): New.\n+\t(timer::print_row): New function, taken from timer::print.\n+\t(timer::print): Print \"GCC items\" header if we also have client\n+\titems.  Move row-printing to timer::print_row.  Print any client\n+\titems.\n+\t(timer::get_topmost_item_name): New method.\n+\t* timevar.def (TV_JIT_ACQUIRING_MUTEX): New.\n+\t(TV_JIT_CLIENT_CODE): New.\n+\t* timevar.h (timer::push_client_item): New declaration.\n+\t(timer::pop_client_item): New declaration.\n+\t(timer::get_topmost_item_name): New method.\n+\t(timer::push_internal): New declaration.\n+\t(timer::pop_internal): New declaration.\n+\t(timer::print_row): New declaration.\n+\t(timer::named_items): New declaration.\n+\t(timer::m_jit_client_items): New field.\n+\t(timer): Add friend class named_items.\n+\t(auto_timevar::auto_timevar): Add timer param.\n+\t(auto_timevar::~auto_timevar): Use field \"m_timer\".\n+\t(auto_timevar::m_timer): New field.\n+\t* toplev.c (initialize_rtl): Add g_timer as param when\n+\tconstructing auto_timevar instance.\n+\t(toplev::toplev): Add \"external_timer\" param, and use it to\n+\tinitialize the \"g_timer\" global if non-NULL.\n+\t(toplev::~toplev): If this created \"g_timer\", delete it.\n+\t* toplev.h (toplev::toplev): Replace \"use_TV_TOTAL\" bool param\n+\twith \"external_timer\" timer *.\n+\n 2015-08-03  Alexander Basov <coohpt@gmail.com>\n \n \tPR middle-end/64744"}, {"sha": "2cb6dfc215a8be8c3313a7db74c772d61984f694", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -1,3 +1,66 @@\n+2015-08-03  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_4): New.\n+\t* docs/topics/contexts.rst (GCC_JIT_BOOL_OPTION_DUMP_SUMMARY):\n+\tWe no longer show a profile.\n+\t* docs/topics/index.rst (Topic Reference): Add performance.rst.\n+\t* docs/topics/performance.rst: New file.\n+\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n+\t* jit-playback.c (gcc::jit::playback::context::compile): Add timer\n+\tparam when constructing the \"toplev\" instance.\n+\t(gcc::jit::playback::context::acquire_mutex): Add timer param when\n+\tconstructing auto_timevar instance.\n+\t(gcc::jit::playback::context::make_fake_args): If we have a timer,\n+\tadd \"-ftime-report\".\n+\t(gcc::jit::playback::context::invoke_driver): Add timer param when\n+\tconstructing auto_timevar instance.\n+\t(gcc::jit::playback::context::dlopen_built_dso): Likewise.\n+\t* jit-playback.h (gcc::jit::playback::context::get_timer): New accessor.\n+\t* jit-recording.c: Include timevar.h.\n+\t(gcc::jit::recording::context::context): Initialize field \"m_timer\".\n+\t* jit-recording.h: Add forward declaration of class timer.\n+\t(gcc::jit::recording::context::set_timer): New method.\n+\t(gcc::jit::recording::context::get_timer): New method.\n+\t(gcc::jit::recording::context::m_timer): New field.\n+\t* libgccjit++.h (gccjit::timer): New class.\n+\t(gccjit::auto_time): New class.\n+\t(gccjit::context::set_timer): New method.\n+\t(gccjit::context::get_timer): New.\n+\t(gccjit::timer::timer): New.\n+\t(gccjit::timer::push): New.\n+\t(gccjit::timer::pop): New.\n+\t(timer::print): New.\n+\t(timer::get_inner_timer): New.\n+\t(timer::release): New.\n+\t(auto_time::auto_time): New.\n+\t(auto_time::~auto_time): New.\n+\t* libgccjit.c: Include timevar.h.\n+\t(struct gcc_jit_timer): New.\n+\t(gcc_jit_timer_new): New function.\n+\t(gcc_jit_timer_release): New function.\n+\t(gcc_jit_context_set_timer): New function.\n+\t(gcc_jit_context_get_timer): New function.\n+\t(gcc_jit_timer_push): New function.\n+\t(gcc_jit_timer_pop): New function.\n+\t(gcc_jit_timer_print): New function.\n+\t* libgccjit.h (LIBGCCJIT_HAVE_TIMING_API): New macro.\n+\t(gcc_jit_timer): New typedef.\n+\t(gcc_jit_timer_new): New function.\n+\t(gcc_jit_timer_release): New function.\n+\t(gcc_jit_context_set_timer): New function.\n+\t(gcc_jit_context_get_timer): New function.\n+\t(gcc_jit_timer_push): New function.\n+\t(gcc_jit_timer_pop): New function.\n+\t(gcc_jit_timer_print): New function.\n+\t* libgccjit.map (LIBGCCJIT_ABI_4): New.\n+\t(gcc_jit_timer_new): New function.\n+\t(gcc_jit_timer_release): New function.\n+\t(gcc_jit_context_set_timer): New function.\n+\t(gcc_jit_context_get_timer): New function.\n+\t(gcc_jit_timer_push): New function.\n+\t(gcc_jit_timer_pop): New function.\n+\t(gcc_jit_timer_print): New function.\n+\n 2015-07-23  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit-playback.c (invoke_driver): Convert local \"argvec\""}, {"sha": "f688e2d7d2d80b119f57f6e0ed61b2537bf80905", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "modified", "additions": 626, "deletions": 266, "changes": 892, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=afed345982d5923b04d41885e868c9ca345ff3f9"}, {"sha": "0a4b4533f7ebe9a9c7fcdda27d66e4ef4bacf524", "filename": "gcc/jit/docs/topics/compatibility.rst", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -107,3 +107,24 @@ entrypoints:\n   * :func:`gcc_jit_case_as_object`\n \n   * :func:`gcc_jit_context_new_case`\n+\n+.. _LIBGCCJIT_ABI_4:\n+\n+``LIBGCCJIT_ABI_4``\n+-------------------\n+``LIBGCCJIT_ABI_4`` covers the addition of timers via API\n+entrypoints:\n+\n+  * :func:`gcc_jit_context_get_timer`\n+\n+  * :func:`gcc_jit_context_set_timer`\n+\n+  * :func:`gcc_jit_timer_new`\n+\n+  * :func:`gcc_jit_timer_release`\n+\n+  * :func:`gcc_jit_timer_push`\n+\n+  * :func:`gcc_jit_timer_pop`\n+\n+  * :func:`gcc_jit_timer_print`"}, {"sha": "1aa319a9a3f4f1d199332379b05686d96f802592", "filename": "gcc/jit/docs/topics/contexts.rst", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -430,8 +430,7 @@ Boolean options\n   .. macro:: GCC_JIT_BOOL_OPTION_DUMP_SUMMARY\n \n      If true, :func:`gcc_jit_context_compile` will print information to stderr\n-     on the actions it is performing, followed by a profile showing\n-     the time taken and memory usage of each phase.\n+     on the actions it is performing.\n \n   .. macro:: GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING\n "}, {"sha": "d32f63b15fce7af5a8ff48f7ad12f296bc1680d5", "filename": "gcc/jit/docs/topics/index.rst", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fdocs%2Ftopics%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fdocs%2Ftopics%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Findex.rst?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -29,3 +29,4 @@ Topic Reference\n    locations.rst\n    compilation.rst\n    compatibility.rst\n+   performance.rst"}, {"sha": "4dfc13944124521f97a2908948e0055122f1ebfe", "filename": "gcc/jit/docs/topics/performance.rst", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fdocs%2Ftopics%2Fperformance.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fdocs%2Ftopics%2Fperformance.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fperformance.rst?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -0,0 +1,240 @@\n+.. Copyright (C) 2015 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: c\n+\n+Performance\n+===========\n+\n+The timing API\n+--------------\n+\n+As of GCC 6, libgccjit exposes a timing API, for printing reports on\n+how long was spent in different parts of code.\n+\n+You can create a :c:type:`gcc_jit_timer` instance, which will\n+measure time spent since its creation.  The timer maintains a stack\n+of \"timer items\": as control flow moves through your code, you can push\n+and pop named items relating to your code onto the stack, and the timer\n+will account the time spent accordingly.\n+\n+You can also asssociate a timer with a :c:type:`gcc_jit_context`, in\n+which case the time spent inside compilation will be subdivided.\n+\n+For example, the following code uses a timer, recording client items\n+\"create_code\", \"compile\", and \"running code\":\n+\n+.. code-block:: c\n+\n+  /* Create a timer.  */\n+  gcc_jit_timer *timer = gcc_jit_timer_new ();\n+  if (!timer)\n+    {\n+       error (\"gcc_jit_timer_new failed\");\n+       return -1;\n+    }\n+\n+  /* Let's repeatedly compile and run some code, accumulating it\n+     all into the timer.  */\n+  for (int i = 0; i < num_iterations; i++)\n+    {\n+      /* Create a context and associate it with the timer.  */\n+      gcc_jit_context *ctxt = gcc_jit_context_acquire ();\n+      if (!ctxt)\n+        {\n+          error (\"gcc_jit_context_acquire failed\");\n+          return -1;\n+        }\n+      gcc_jit_context_set_timer (ctxt, timer);\n+\n+      /* Populate the context, timing it as client item \"create_code\".  */\n+      gcc_jit_timer_push (timer, \"create_code\");\n+      create_code (ctxt);\n+      gcc_jit_timer_pop (timer, \"create_code\");\n+\n+      /* Compile the context, timing it as client item \"compile\".  */\n+      gcc_jit_timer_push (timer, \"compile\");\n+      result = gcc_jit_context_compile (ctxt);\n+      gcc_jit_timer_pop (timer, \"compile\");\n+\n+      /* Run the generated code, timing it as client item \"running code\".  */\n+      gcc_jit_timer_push (timer, \"running code\");\n+      run_the_code (ctxt, result);\n+      gcc_jit_timer_pop (timer, \"running code\");\n+\n+      /* Clean up.  */\n+      gcc_jit_context_release (ctxt);\n+      gcc_jit_result_release (result);\n+  }\n+\n+  /* Print the accumulated timings.  */\n+  gcc_jit_timer_print (timer, stderr);\n+  gcc_jit_timer_release (timer);\n+\n+giving output like this, showing the internal GCC items at the top, then\n+client items, then the total::\n+\n+  Execution times (seconds)\n+  GCC items:\n+   phase setup             :   0.29 (14%) usr   0.00 ( 0%) sys   0.32 ( 5%) wall   10661 kB (50%) ggc\n+   phase parsing           :   0.02 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall     653 kB ( 3%) ggc\n+   phase finalize          :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n+   dump files              :   0.02 ( 1%) usr   0.00 ( 0%) sys   0.01 ( 0%) wall       0 kB ( 0%) ggc\n+   callgraph construction  :   0.02 ( 1%) usr   0.01 ( 6%) sys   0.01 ( 0%) wall     242 kB ( 1%) ggc\n+   callgraph optimization  :   0.03 ( 2%) usr   0.00 ( 0%) sys   0.02 ( 0%) wall     142 kB ( 1%) ggc\n+   trivially dead code     :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n+   df scan insns           :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       9 kB ( 0%) ggc\n+   df live regs            :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.01 ( 0%) wall       0 kB ( 0%) ggc\n+   inline parameters       :   0.02 ( 1%) usr   0.00 ( 0%) sys   0.01 ( 0%) wall      82 kB ( 0%) ggc\n+   tree CFG cleanup        :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n+   tree PHI insertion      :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.02 ( 0%) wall      64 kB ( 0%) ggc\n+   tree SSA other          :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.01 ( 0%) wall      18 kB ( 0%) ggc\n+   expand                  :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall     398 kB ( 2%) ggc\n+   jump                    :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n+   loop init               :   0.01 ( 0%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall      67 kB ( 0%) ggc\n+   integrated RA           :   0.02 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall    2468 kB (12%) ggc\n+   thread pro- & epilogue  :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall     162 kB ( 1%) ggc\n+   final                   :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall     216 kB ( 1%) ggc\n+   rest of compilation     :   1.37 (69%) usr   0.00 ( 0%) sys   1.13 (18%) wall    1391 kB ( 6%) ggc\n+   assemble JIT code       :   0.01 ( 1%) usr   0.00 ( 0%) sys   4.04 (66%) wall       0 kB ( 0%) ggc\n+   load JIT result         :   0.02 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n+   JIT client code         :   0.00 ( 0%) usr   0.01 ( 6%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n+  Client items:\n+   create_code             :   0.00 ( 0%) usr   0.01 ( 6%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n+   compile                 :   0.36 (18%) usr   0.15 (83%) sys   0.86 (14%) wall   14939 kB (70%) ggc\n+   running code            :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n+   TOTAL                   :   2.00             0.18             6.12              21444 kB\n+\n+The exact format is intended to be human-readable, and is subject to change.\n+\n+.. macro:: LIBGCCJIT_HAVE_TIMING_API\n+\n+   The timer API was added to libgccjit in GCC 6.\n+   This macro is only defined in versions of libgccjit.h which have the\n+   timer API, and so can be used to guard code that may need to compile\n+   against earlier releases::\n+\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+     gcc_jit_timer *t = gcc_jit_timer_new ();\n+     gcc_jit_context_set_timer (ctxt, t);\n+     #endif\n+\n+.. type:: gcc_jit_timer\n+\n+.. function:: gcc_jit_timer * gcc_jit_timer_new(void)\n+\n+   Create a :c:type:`gcc_jit_timer` instance, and start timing::\n+\n+     gcc_jit_timer *t = gcc_jit_timer_new ();\n+\n+   This API entrypoint was added in :ref:`LIBGCCJIT_ABI_4`; you can test\n+   for its presence using\n+\n+   .. code-block:: c\n+\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+\n+.. function:: void gcc_jit_timer_release(gcc_jit_timer *timer)\n+\n+   Release a :c:type:`gcc_jit_timer` instance::\n+\n+     gcc_jit_timer_release (t);\n+\n+   This should be called exactly once on a timer.\n+\n+   This API entrypoint was added in :ref:`LIBGCCJIT_ABI_4`; you can test\n+   for its presence using\n+\n+   .. code-block:: c\n+\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+\n+.. function:: void gcc_jit_context_set_timer(gcc_jit_context *ctxt, \\\n+                                             gcc_jit_timer *timer)\n+\n+   Associate a :c:type:`gcc_jit_timer` instance with a context::\n+\n+      gcc_jit_context_set_timer (ctxt, t);\n+\n+   A timer instance can be shared between multiple\n+   :c:type:`gcc_jit_context` instances.\n+\n+   Timers have no locking, so if you have a multithreaded program, you\n+   must provide your own locks if more than one thread could be working\n+   with the same timer via timer-associated contexts.\n+\n+   This API entrypoint was added in :ref:`LIBGCCJIT_ABI_4`; you can test\n+   for its presence using\n+\n+   .. code-block:: c\n+\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+\n+.. function:: gcc_jit_timer *gcc_jit_context_get_timer(gcc_jit_context *ctxt)\n+\n+   Get the timer associated with a context (if any).\n+\n+   This API entrypoint was added in :ref:`LIBGCCJIT_ABI_4`; you can test\n+   for its presence using\n+\n+   .. code-block:: c\n+\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+\n+.. function:: void gcc_jit_timer_push(gcc_jit_timer *timer, \\\n+                                      const char *item_name)\n+\n+   Push the given item onto the timer's stack::\n+\n+      gcc_jit_timer_push (t, \"running code\");\n+      run_the_code (ctxt, result);\n+      gcc_jit_timer_pop (t, \"running code\");\n+\n+   This API entrypoint was added in :ref:`LIBGCCJIT_ABI_4`; you can test\n+   for its presence using\n+\n+   .. code-block:: c\n+\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+\n+.. function:: void gcc_jit_timer_pop(gcc_jit_timer *timer, \\\n+                                     const char *item_name)\n+\n+   Pop the top item from the timer's stack.\n+\n+   If \"item_name\" is provided, it must match that of the top item.\n+   Alternatively, ``NULL`` can be passed in, to suppress checking.\n+\n+   This API entrypoint was added in :ref:`LIBGCCJIT_ABI_4`; you can test\n+   for its presence using\n+\n+   .. code-block:: c\n+\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+\n+.. function:: void gcc_jit_timer_print(gcc_jit_timer *timer, \\\n+                                       FILE *f_out)\n+\n+   Print timing information to the given stream about activity since\n+   the timer was started.\n+\n+   This API entrypoint was added in :ref:`LIBGCCJIT_ABI_4`; you can test\n+   for its presence using\n+\n+   .. code-block:: c\n+\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API"}, {"sha": "925fa86474ed0608d1cb04de930588e99dfa36a5", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -1793,7 +1793,7 @@ compile ()\n     }\n \n   /* This runs the compiler.  */\n-  toplev toplev (false, /* use_TV_TOTAL */\n+  toplev toplev (get_timer (), /* external_timer */\n \t\t false); /* init_signals */\n   enter_scope (\"toplev::main\");\n   if (get_logger ())\n@@ -2085,6 +2085,8 @@ static pthread_mutex_t jit_mutex = PTHREAD_MUTEX_INITIALIZER;\n void\n playback::context::acquire_mutex ()\n {\n+  auto_timevar tv (get_timer (), TV_JIT_ACQUIRING_MUTEX);\n+\n   /* Acquire the big GCC mutex. */\n   JIT_LOG_SCOPE (get_logger ());\n   pthread_mutex_lock (&jit_mutex);\n@@ -2252,6 +2254,9 @@ make_fake_args (vec <char *> *argvec,\n       }\n   }\n \n+  if (get_timer ())\n+    ADD_ARG (\"-ftime-report\");\n+\n   /* Add any user-provided extra options, starting with any from\n      parent contexts.  */\n   m_recording_ctxt->append_command_line_options (argvec);\n@@ -2380,7 +2385,7 @@ invoke_driver (const char *ctxt_progname,\n   JIT_LOG_SCOPE (get_logger ());\n   /* Currently this lumps together both assembling and linking into\n      TV_ASSEMBLE.  */\n-  auto_timevar assemble_timevar (tv_id);\n+  auto_timevar assemble_timevar (get_timer (), tv_id);\n   const char *errmsg;\n   auto_argvec argvec;\n #define ADD_ARG(arg) argvec.safe_push (xstrdup (arg))\n@@ -2492,7 +2497,7 @@ playback::context::\n dlopen_built_dso ()\n {\n   JIT_LOG_SCOPE (get_logger ());\n-  auto_timevar load_timevar (TV_LOAD);\n+  auto_timevar load_timevar (get_timer (), TV_LOAD);\n   void *handle = NULL;\n   const char *error = NULL;\n   result *result_obj = NULL;"}, {"sha": "52e402f9eec72d8bbe5d067dd932a7740183f5bc", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -215,6 +215,8 @@ class context : public log_user\n     return m_recording_ctxt->errors_occurred ();\n   }\n \n+  timer *get_timer () const { return m_recording_ctxt->get_timer (); }\n+\n private:\n   void dump_generated_code ();\n "}, {"sha": "811d7c0354436fa75d4dfb8866c09916e8c8b7fe", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pretty-print.h\"\n #include \"hash-map.h\"\n #include \"toplev.h\"\n+#include \"timevar.h\"\n \n #include <pthread.h>\n \n@@ -461,6 +462,7 @@ recording::context::context (context *parent_ctxt)\n   : log_user (NULL),\n     m_parent_ctxt (parent_ctxt),\n     m_toplevel_ctxt (m_parent_ctxt ? m_parent_ctxt->m_toplevel_ctxt : this),\n+    m_timer (NULL),\n     m_error_count (0),\n     m_first_error_str (NULL),\n     m_owns_first_error_str (false),"}, {"sha": "3d88b890b9a01ef311ec38624b0720d0b82ae669", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -24,6 +24,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"jit-common.h\"\n #include \"jit-logging.h\"\n \n+class timer;\n+\n namespace gcc {\n \n namespace jit {\n@@ -276,6 +278,9 @@ class context : public log_user\n   void\n   get_all_requested_dumps (vec <recording::requested_dump> *out);\n \n+  void set_timer (timer *t) { m_timer = t; }\n+  timer *get_timer () const { return m_timer; }\n+\n private:\n   void log_all_options () const;\n   void log_str_option (enum gcc_jit_str_option opt) const;\n@@ -292,6 +297,8 @@ class context : public log_user\n      contexts.  This has itself as its own m_toplevel_ctxt.  */\n   context *m_toplevel_ctxt;\n \n+  timer *m_timer;\n+\n   int m_error_count;\n \n   char *m_first_error_str;"}, {"sha": "d7e491bbfdccd0810a7b55d09980ee67c74f6b9f", "filename": "gcc/jit/libgccjit++.h", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Flibgccjit%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Flibgccjit%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit%2B%2B.h?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -46,6 +46,8 @@ namespace gccjit\n      class lvalue;\n        class param;\n     class case_;\n+  class timer;\n+  class auto_time;\n \n   /* Errors within the API become C++ exceptions of this class.  */\n   class error\n@@ -125,6 +127,9 @@ namespace gccjit\n \n     void add_command_line_option (const char *optname);\n \n+    void set_timer (gccjit::timer t);\n+    gccjit::timer get_timer () const;\n+\n     location\n     new_location (const std::string &filename,\n \t\t  int line,\n@@ -523,6 +528,36 @@ namespace gccjit\n \n   /* Dereferencing. */\n   lvalue operator* (rvalue ptr);\n+\n+  class timer\n+  {\n+  public:\n+    timer ();\n+    timer (gcc_jit_timer *inner_timer);\n+\n+    void push (const char *item_name);\n+    void pop (const char *item_name);\n+    void print (FILE *f_out) const;\n+\n+    void release ();\n+\n+    gcc_jit_timer *get_inner_timer () const;\n+\n+  private:\n+    gcc_jit_timer *m_inner_timer;\n+  };\n+\n+  class auto_time\n+  {\n+  public:\n+    auto_time (timer t, const char *item_name);\n+    auto_time (context ctxt, const char *item_name);\n+    ~auto_time ();\n+\n+  private:\n+    timer m_timer;\n+    const char *m_item_name;\n+  };\n }\n \n /****************************************************************************\n@@ -636,6 +671,19 @@ context::add_command_line_option (const char *optname)\n   gcc_jit_context_add_command_line_option (m_inner_ctxt, optname);\n }\n \n+inline void\n+context::set_timer (gccjit::timer t)\n+{\n+  gcc_jit_context_set_timer (m_inner_ctxt, t.get_inner_timer ());\n+}\n+\n+inline gccjit::timer\n+context::get_timer () const\n+{\n+  return gccjit::timer (gcc_jit_context_get_timer (m_inner_ctxt));\n+}\n+\n+\n inline location\n context::new_location (const std::string &filename,\n \t\t       int line,\n@@ -1713,6 +1761,75 @@ inline lvalue operator* (rvalue ptr)\n   return ptr.dereference ();\n }\n \n+// class timer\n+inline\n+timer::timer ()\n+{\n+  m_inner_timer = gcc_jit_timer_new ();\n+}\n+\n+inline\n+timer::timer (gcc_jit_timer *inner_timer)\n+{\n+  m_inner_timer = inner_timer;\n+}\n+\n+inline void\n+timer::push (const char *item_name)\n+{\n+  gcc_jit_timer_push (m_inner_timer, item_name);\n+\n+}\n+\n+inline void\n+timer::pop (const char *item_name)\n+{\n+  gcc_jit_timer_pop (m_inner_timer, item_name);\n+}\n+\n+inline void\n+timer::print (FILE *f_out) const\n+{\n+  gcc_jit_timer_print (m_inner_timer, f_out);\n+}\n+\n+inline gcc_jit_timer *\n+timer::get_inner_timer () const\n+{\n+  return m_inner_timer;\n+}\n+\n+inline void\n+timer::release ()\n+{\n+  gcc_jit_timer_release (m_inner_timer);\n+  m_inner_timer = NULL;\n+}\n+\n+// class auto_time\n+\n+inline\n+auto_time::auto_time (timer t, const char *item_name)\n+  : m_timer (t),\n+    m_item_name (item_name)\n+{\n+  t.push (item_name);\n+}\n+\n+inline\n+auto_time::auto_time (context ctxt, const char *item_name)\n+  : m_timer (ctxt.get_timer ()),\n+    m_item_name (item_name)\n+{\n+  m_timer.push (item_name);\n+}\n+\n+inline\n+auto_time::~auto_time ()\n+{\n+  m_timer.pop (m_item_name);\n+}\n+\n } // namespace gccjit\n \n #endif /* #ifndef LIBGCCJIT_PLUS_PLUS_H */"}, {"sha": "eb9200cef5f846b8883bb43e4e73e9dfdbaac4dd", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"opts.h\"\n #include \"safe-ctype.h\"\n #include \"typed-splay-tree.h\"\n+#include \"timevar.h\"\n \n #include \"libgccjit.h\"\n #include \"jit-common.h\"\n@@ -89,6 +90,10 @@ struct gcc_jit_case : public gcc::jit::recording::case_\n {\n };\n \n+struct gcc_jit_timer : public timer\n+{\n+};\n+\n /**********************************************************************\n  Error-handling.\n \n@@ -2828,3 +2833,107 @@ gcc_jit_result_release (gcc_jit_result *result)\n   result->log (\"deleting result: %p\", (void *)result);\n   delete result;\n }\n+\n+/**********************************************************************\n+ Timing support.\n+ **********************************************************************/\n+\n+/* Create a gcc_jit_timer instance, and start timing.  */\n+\n+gcc_jit_timer *\n+gcc_jit_timer_new (void)\n+{\n+  gcc_jit_timer *timer = new gcc_jit_timer ();\n+  timer->start (TV_TOTAL);\n+  timer->push (TV_JIT_CLIENT_CODE);\n+  return timer;\n+}\n+\n+/* Release a gcc_jit_timer instance.  */\n+\n+void\n+gcc_jit_timer_release (gcc_jit_timer *timer)\n+{\n+  RETURN_IF_FAIL (timer, NULL, NULL, \"NULL timer\");\n+\n+  delete timer;\n+}\n+\n+/* Associate a gcc_jit_timer instance with a context.  */\n+\n+void\n+gcc_jit_context_set_timer (gcc_jit_context *ctxt,\n+\t\t\t   gcc_jit_timer *timer)\n+{\n+  RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL ctxt\");\n+  RETURN_IF_FAIL (timer, ctxt, NULL, \"NULL timer\");\n+\n+  ctxt->set_timer (timer);\n+}\n+\n+/* Get the timer associated with a context (if any).  */\n+\n+gcc_jit_timer *\n+gcc_jit_context_get_timer (gcc_jit_context *ctxt)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL ctxt\");\n+\n+  return (gcc_jit_timer *)ctxt->get_timer ();\n+}\n+\n+/* Push the given item onto the timing stack.  */\n+\n+void\n+gcc_jit_timer_push (gcc_jit_timer *timer,\n+\t\t    const char *item_name)\n+{\n+  RETURN_IF_FAIL (timer, NULL, NULL, \"NULL timer\");\n+  RETURN_IF_FAIL (item_name, NULL, NULL, \"NULL item_name\");\n+  timer->push_client_item (item_name);\n+}\n+\n+/* Pop the top item from the timing stack.  */\n+\n+void\n+gcc_jit_timer_pop (gcc_jit_timer *timer,\n+\t\t   const char *item_name)\n+{\n+  RETURN_IF_FAIL (timer, NULL, NULL, \"NULL timer\");\n+\n+  if (item_name)\n+    {\n+      const char *top_item_name = timer->get_topmost_item_name ();\n+\n+      RETURN_IF_FAIL_PRINTF1\n+\t(top_item_name, NULL, NULL,\n+\t \"pop of empty timing stack (attempting to pop: \\\"%s\\\")\",\n+\t item_name);\n+\n+      RETURN_IF_FAIL_PRINTF2\n+\t(0 == strcmp (item_name, top_item_name), NULL, NULL,\n+\t \"mismatching item_name:\"\n+\t \" top of timing stack: \\\"%s\\\",\"\n+\t \" attempting to pop: \\\"%s\\\"\",\n+\t top_item_name,\n+\t item_name);\n+    }\n+\n+  timer->pop_client_item ();\n+}\n+\n+/* Print timing information to the given stream about activity since\n+   the timer was started.  */\n+\n+void\n+gcc_jit_timer_print (gcc_jit_timer *timer,\n+\t\t     FILE *f_out)\n+{\n+  RETURN_IF_FAIL (timer, NULL, NULL, \"NULL timer\");\n+  RETURN_IF_FAIL (f_out, NULL, NULL, \"NULL f_out\");\n+\n+  timer->pop (TV_JIT_CLIENT_CODE);\n+  timer->stop (TV_TOTAL);\n+  timer->print (f_out);\n+  timer->start (TV_TOTAL);\n+  timer->push (TV_JIT_CLIENT_CODE);\n+}"}, {"sha": "88e4ff31a2886df184100b825ffa953ae2fb47a9", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -1266,6 +1266,90 @@ gcc_jit_context_enable_dump (gcc_jit_context *ctxt,\n \t\t\t     const char *dumpname,\n \t\t\t     char **out_ptr);\n \n+/**********************************************************************\n+ Timing support.\n+ **********************************************************************/\n+\n+/* The timing API was added in LIBGCCJIT_ABI_4; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+*/\n+#define LIBGCCJIT_HAVE_TIMING_API\n+\n+typedef struct gcc_jit_timer gcc_jit_timer;\n+\n+/* Create a gcc_jit_timer instance, and start timing.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+*/\n+extern gcc_jit_timer *\n+gcc_jit_timer_new (void);\n+\n+/* Release a gcc_jit_timer instance.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+*/\n+extern void\n+gcc_jit_timer_release (gcc_jit_timer *timer);\n+\n+/* Associate a gcc_jit_timer instance with a context.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+*/\n+extern void\n+gcc_jit_context_set_timer (gcc_jit_context *ctxt,\n+\t\t\t   gcc_jit_timer *timer);\n+\n+/* Get the timer associated with a context (if any).\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+*/\n+\n+extern gcc_jit_timer *\n+gcc_jit_context_get_timer (gcc_jit_context *ctxt);\n+\n+/* Push the given item onto the timing stack.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+*/\n+\n+extern void\n+gcc_jit_timer_push (gcc_jit_timer *timer,\n+\t\t    const char *item_name);\n+\n+/* Pop the top item from the timing stack.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+*/\n+\n+extern void\n+gcc_jit_timer_pop (gcc_jit_timer *timer,\n+\t\t   const char *item_name);\n+\n+/* Print timing information to the given stream about activity since\n+   the timer was started.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_TIMING_API\n+*/\n+\n+extern void\n+gcc_jit_timer_print (gcc_jit_timer *timer,\n+\t\t     FILE *f_out);\n+\n #ifdef __cplusplus\n }\n #endif /* __cplusplus */"}, {"sha": "e4302c6d379c37da27abc608f251954fd0665343", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -128,3 +128,15 @@ LIBGCCJIT_ABI_3 {\n     gcc_jit_case_as_object;\n     gcc_jit_context_new_case;\n } LIBGCCJIT_ABI_2;\n+\n+# Add timing API.\n+LIBGCCJIT_ABI_4 {\n+  global:\n+    gcc_jit_context_get_timer;\n+    gcc_jit_context_set_timer;\n+    gcc_jit_timer_new;\n+    gcc_jit_timer_release;\n+    gcc_jit_timer_push;\n+    gcc_jit_timer_pop;\n+    gcc_jit_timer_print;\n+};"}, {"sha": "bbd8b67718da60abc99a3bf3e33d78c31346beb3", "filename": "gcc/main.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmain.c?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -33,7 +33,7 @@ int main (int argc, char **argv);\n int\n main (int argc, char **argv)\n {\n-  toplev toplev (true, /* use_TV_TOTAL */\n+  toplev toplev (NULL, /* external_timer */\n \t\t true /* init_signals */);\n \n   return toplev.main (argc, argv);"}, {"sha": "058c4ec509d93d51a81b20a20c42d3076e53295d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -1,3 +1,12 @@\n+2015-08-03  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-benchmark.c (test_jit): Add param \"timer\" and use\n+\tit to push/pop timing items.\n+\t(main): For each optimization level, create a gcc_jit_timer, and\n+\ttime all of the iteration within that level cumulatively.\n+\t* jit.dg/test-error-gcc_jit_timer_pop-mismatch.c: New test case.\n+\t* jit.dg/test-error-gcc_jit_timer_pop-too-many.c: New test case.\n+\n 2015-08-03  Alexander Basov <coohpt@gmail.com>\n \n \tPR middle-end/64744"}, {"sha": "4952fff07b537a2100697430190fe402bb8b2a05", "filename": "gcc/testsuite/jit.dg/test-benchmark.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftestsuite%2Fjit.dg%2Ftest-benchmark.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftestsuite%2Fjit.dg%2Ftest-benchmark.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-benchmark.c?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -141,18 +141,22 @@ verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n \n /* Run one iteration of the test.  */\n static void\n-test_jit (const char *argv0, int opt_level)\n+test_jit (const char *argv0, int opt_level, gcc_jit_timer *timer)\n {\n   gcc_jit_context *ctxt;\n   gcc_jit_result *result;\n \n+  gcc_jit_timer_push (timer, \"test_jit\");\n+\n   ctxt = gcc_jit_context_acquire ();\n   if (!ctxt)\n     {\n       fail (\"gcc_jit_context_acquire failed\");\n       return;\n     }\n \n+  gcc_jit_context_set_timer (ctxt, timer);\n+\n   /* Set up options.  */\n   gcc_jit_context_set_str_option (\n     ctxt,\n@@ -182,13 +186,22 @@ test_jit (const char *argv0, int opt_level)\n       GCC_JIT_BOOL_OPTION_DUMP_SUMMARY,\n       1);\n \n+  gcc_jit_timer_push (timer, \"create_code\");\n   create_code (ctxt, NULL);\n+  gcc_jit_timer_pop (timer, \"create_code\");\n \n+  gcc_jit_timer_push (timer, \"compile\");\n   result = gcc_jit_context_compile (ctxt);\n+  gcc_jit_timer_pop (timer, \"compile\");\n+\n+  gcc_jit_timer_push (timer, \"verify_code\");\n   verify_code (ctxt, result);\n+  gcc_jit_timer_pop (timer, \"verify_code\");\n \n   gcc_jit_context_release (ctxt);\n   gcc_jit_result_release (result);\n+\n+  gcc_jit_timer_pop (timer, \"test_jit\");\n }\n \n /* Taken from timevar.c.  */\n@@ -217,16 +230,19 @@ main (int argc, char **argv)\n       int i;\n       double start_time, end_time, elapsed_time;\n       start_time = get_wallclock_time ();\n+      gcc_jit_timer *timer = gcc_jit_timer_new ();\n       for (i = 1; i <= num_iterations; i++)\n \t{\n \t  snprintf (test, sizeof (test),\n \t\t    \"%s iteration %d of %d\",\n \t\t    extract_progname (argv[0]),\n \t\t    i, num_iterations);\n-\t  test_jit (argv[0], opt_level);\n+\t  test_jit (argv[0], opt_level, timer);\n \t}\n       end_time = get_wallclock_time ();\n       elapsed_time = end_time - start_time;\n+      gcc_jit_timer_print (timer, stderr);\n+      gcc_jit_timer_release (timer);\n       pass (\"%s: survived %i iterations at optlevel %i\",\n \t    argv[0], num_iterations, opt_level);\n       note ((\"%s: %i iterations at optlevel %i\""}, {"sha": "d0862ddd40b0e1a4bb400c46467b6df332901a33", "filename": "gcc/testsuite/jit.dg/test-error-gcc_jit_timer_pop-mismatch.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_timer_pop-mismatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_timer_pop-mismatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_timer_pop-mismatch.c?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -0,0 +1,22 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_timer *timer = gcc_jit_timer_new ();\n+  /* Error: mismatched push/pop.  */\n+  gcc_jit_timer_push (timer, \"apples\");\n+  gcc_jit_timer_pop (timer, \"oranges\");\n+  gcc_jit_timer_release (timer);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* empty */\n+}"}, {"sha": "62faeaf8c7ca58dc39a190f1126c140dc5bce83d", "filename": "gcc/testsuite/jit.dg/test-error-gcc_jit_timer_pop-too-many.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_timer_pop-too-many.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_timer_pop-too-many.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_timer_pop-too-many.c?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -0,0 +1,21 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_timer *timer = gcc_jit_timer_new ();\n+  /* Erroneous: pop of an empty timing stack.  */\n+  gcc_jit_timer_pop (timer, \"test\");\n+  gcc_jit_timer_release (timer);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* empty */\n+}"}, {"sha": "82497270d6aab2eb10ac3d446430da60c847d90c", "filename": "gcc/timevar.c", "status": "modified", "additions": 210, "deletions": 35, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"coretypes.h\"\n #include \"timevar.h\"\n \n #ifndef HAVE_CLOCK_T\n@@ -120,6 +121,93 @@ static void timevar_accumulate (struct timevar_time_def *,\n \t\t\t\tstruct timevar_time_def *,\n \t\t\t\tstruct timevar_time_def *);\n \n+/* The implementation of timing events for jit client code, allowing\n+   arbitrary named items to appear on the timing stack.  */\n+\n+class timer::named_items\n+{\n+ public:\n+  named_items (timer *t);\n+  ~named_items ();\n+\n+  void push (const char *item_name);\n+  void pop ();\n+  void print (FILE *fp, const timevar_time_def *total);\n+\n+ private:\n+  /* Which timer instance does this relate to?  */\n+  timer *m_timer;\n+\n+  /* Dictionary, mapping from item names to timevar_def.\n+     Note that currently we merely store/compare the raw string\n+     pointers provided by client code; we don't take a copy,\n+     or use strcmp.  */\n+  hash_map <const char *, timer::timevar_def> m_hash_map;\n+\n+  /* The order in which items were originally inserted.  */\n+  auto_vec <const char *> m_names;\n+};\n+\n+/* The constructor for class timer::named_items.  */\n+\n+timer::named_items::named_items (timer *t)\n+: m_timer (t),\n+  m_hash_map (),\n+  m_names ()\n+{\n+}\n+\n+/* The destructor for class timer::named_items.  */\n+\n+timer::named_items::~named_items ()\n+{\n+}\n+\n+/* Push the named item onto the timer stack.  */\n+\n+void\n+timer::named_items::push (const char *item_name)\n+{\n+  gcc_assert (item_name);\n+\n+  bool existed;\n+  timer::timevar_def *def = &m_hash_map.get_or_insert (item_name, &existed);\n+  if (!existed)\n+    {\n+      def->elapsed.user = 0;\n+      def->elapsed.sys = 0;\n+      def->elapsed.wall = 0;\n+      def->name = item_name;\n+      def->standalone = 0;\n+      m_names.safe_push (item_name);\n+    }\n+  m_timer->push_internal (def);\n+}\n+\n+/* Pop the top item from the timer stack.  */\n+\n+void\n+timer::named_items::pop ()\n+{\n+  m_timer->pop_internal ();\n+}\n+\n+/* Print the given client item.  Helper function for timer::print.  */\n+\n+void\n+timer::named_items::print (FILE *fp, const timevar_time_def *total)\n+{\n+  unsigned int i;\n+  const char *item_name;\n+  fprintf (fp, \"Client items:\\n\");\n+  FOR_EACH_VEC_ELT (m_names, i, item_name)\n+    {\n+      timer::timevar_def *def = m_hash_map.get (item_name);\n+      gcc_assert (def);\n+      m_timer->print_row (fp, total, def);\n+    }\n+}\n+\n /* Fill the current times into TIME.  The definition of this function\n    also defines any or all of the HAVE_USER_TIME, HAVE_SYS_TIME, and\n    HAVE_WALL_TIME macros.  */\n@@ -169,7 +257,8 @@ timevar_accumulate (struct timevar_time_def *timer,\n timer::timer () :\n   m_stack (NULL),\n   m_unused_stack_instances (NULL),\n-  m_start_time ()\n+  m_start_time (),\n+  m_jit_client_items (NULL)\n {\n   /* Zero all elapsed times.  */\n   memset (m_timevars, 0, sizeof (m_timevars));\n@@ -190,6 +279,26 @@ timer::timer () :\n #endif\n }\n \n+/* Class timer's destructor.  */\n+\n+timer::~timer ()\n+{\n+  timevar_stack_def *iter, *next;\n+\n+  for (iter = m_stack; iter; iter = next)\n+    {\n+      next = iter->next;\n+      free (iter);\n+    }\n+  for (iter = m_unused_stack_instances; iter; iter = next)\n+    {\n+      next = iter->next;\n+      free (iter);\n+    }\n+\n+  delete m_jit_client_items;\n+}\n+\n /* Initialize timing variables.  */\n \n void\n@@ -212,9 +321,20 @@ void\n timer::push (timevar_id_t timevar)\n {\n   struct timevar_def *tv = &m_timevars[timevar];\n+  push_internal (tv);\n+}\n+\n+/* Push TV onto the timing stack, either one of the builtin ones\n+   for a timevar_id_t, or one provided by client code to libgccjit.  */\n+\n+void\n+timer::push_internal (struct timevar_def *tv)\n+{\n   struct timevar_stack_def *context;\n   struct timevar_time_def now;\n \n+  gcc_assert (tv);\n+\n   /* Mark this timing variable as used.  */\n   tv->used = 1;\n \n@@ -257,12 +377,21 @@ timer::push (timevar_id_t timevar)\n \n void\n timer::pop (timevar_id_t timevar)\n+{\n+  gcc_assert (&m_timevars[timevar] == m_stack->timevar);\n+\n+  pop_internal ();\n+}\n+\n+/* Pop the topmost item from the stack, either one of the builtin ones\n+   for a timevar_id_t, or one provided by client code to libgccjit.  */\n+\n+void\n+timer::pop_internal ()\n {\n   struct timevar_time_def now;\n   struct timevar_stack_def *popped = m_stack;\n \n-  gcc_assert (&m_timevars[timevar] == m_stack->timevar);\n-\n   /* What time is it?  */\n   get_time (&now);\n \n@@ -410,6 +539,28 @@ timer::cond_stop (timevar_id_t timevar)\n   timevar_accumulate (&tv->elapsed, &tv->start_time, &now);\n }\n \n+/* Push the named item onto the timing stack.  */\n+\n+void\n+timer::push_client_item (const char *item_name)\n+{\n+  gcc_assert (item_name);\n+\n+  /* Lazily create the named_items instance.  */\n+  if (!m_jit_client_items)\n+    m_jit_client_items = new named_items (this);\n+\n+  m_jit_client_items->push (item_name);\n+}\n+\n+/* Pop the top-most client item from the timing stack.  */\n+\n+void\n+timer::pop_client_item ()\n+{\n+  gcc_assert (m_jit_client_items);\n+  m_jit_client_items->pop ();\n+}\n \n /* Validate that phase times are consistent.  */\n \n@@ -462,6 +613,46 @@ timer::validate_phases (FILE *fp) const\n     }\n }\n \n+/* Helper function for timer::print.  */\n+\n+void\n+timer::print_row (FILE *fp,\n+\t\t  const timevar_time_def *total,\n+\t\t  const timevar_def *tv)\n+{\n+  /* The timing variable name.  */\n+  fprintf (fp, \" %-24s:\", tv->name);\n+\n+#ifdef HAVE_USER_TIME\n+  /* Print user-mode time for this process.  */\n+  fprintf (fp, \"%7.2f (%2.0f%%) usr\",\n+\t   tv->elapsed.user,\n+\t   (total->user == 0 ? 0 : tv->elapsed.user / total->user) * 100);\n+#endif /* HAVE_USER_TIME */\n+\n+#ifdef HAVE_SYS_TIME\n+  /* Print system-mode time for this process.  */\n+  fprintf (fp, \"%7.2f (%2.0f%%) sys\",\n+\t   tv->elapsed.sys,\n+\t   (total->sys == 0 ? 0 : tv->elapsed.sys / total->sys) * 100);\n+#endif /* HAVE_SYS_TIME */\n+\n+#ifdef HAVE_WALL_TIME\n+  /* Print wall clock time elapsed.  */\n+  fprintf (fp, \"%7.2f (%2.0f%%) wall\",\n+\t   tv->elapsed.wall,\n+\t   (total->wall == 0 ? 0 : tv->elapsed.wall / total->wall) * 100);\n+#endif /* HAVE_WALL_TIME */\n+\n+  /* Print the amount of ggc memory allocated.  */\n+  fprintf (fp, \"%8u kB (%2.0f%%) ggc\",\n+\t   (unsigned) (tv->elapsed.ggc_mem >> 10),\n+\t   (total->ggc_mem == 0\n+\t    ? 0\n+\t    : (float) tv->elapsed.ggc_mem / total->ggc_mem) * 100);\n+\n+  putc ('\\n', fp);\n+}\n \n /* Summarize timing variables to FP.  The timing variable TV_TOTAL has\n    a special meaning -- it's considered to be the total elapsed time,\n@@ -494,6 +685,8 @@ timer::print (FILE *fp)\n   m_start_time = now;\n \n   fputs (\"\\nExecution times (seconds)\\n\", fp);\n+  if (m_jit_client_items)\n+    fputs (\"GCC items:\\n\", fp);\n   for (id = 0; id < (unsigned int) TIMEVAR_LAST; ++id)\n     {\n       const timevar_def *tv = &m_timevars[(timevar_id_t) id];\n@@ -516,39 +709,10 @@ timer::print (FILE *fp)\n \t  && tv->elapsed.ggc_mem < GGC_MEM_BOUND)\n \tcontinue;\n \n-      /* The timing variable name.  */\n-      fprintf (fp, \" %-24s:\", tv->name);\n-\n-#ifdef HAVE_USER_TIME\n-      /* Print user-mode time for this process.  */\n-      fprintf (fp, \"%7.2f (%2.0f%%) usr\",\n-\t       tv->elapsed.user,\n-\t       (total->user == 0 ? 0 : tv->elapsed.user / total->user) * 100);\n-#endif /* HAVE_USER_TIME */\n-\n-#ifdef HAVE_SYS_TIME\n-      /* Print system-mode time for this process.  */\n-      fprintf (fp, \"%7.2f (%2.0f%%) sys\",\n-\t       tv->elapsed.sys,\n-\t       (total->sys == 0 ? 0 : tv->elapsed.sys / total->sys) * 100);\n-#endif /* HAVE_SYS_TIME */\n-\n-#ifdef HAVE_WALL_TIME\n-      /* Print wall clock time elapsed.  */\n-      fprintf (fp, \"%7.2f (%2.0f%%) wall\",\n-\t       tv->elapsed.wall,\n-\t       (total->wall == 0 ? 0 : tv->elapsed.wall / total->wall) * 100);\n-#endif /* HAVE_WALL_TIME */\n-\n-      /* Print the amount of ggc memory allocated.  */\n-      fprintf (fp, \"%8u kB (%2.0f%%) ggc\",\n-\t       (unsigned) (tv->elapsed.ggc_mem >> 10),\n-\t       (total->ggc_mem == 0\n-\t\t? 0\n-\t\t: (float) tv->elapsed.ggc_mem / total->ggc_mem) * 100);\n-\n-      putc ('\\n', fp);\n+      print_row (fp, total, tv);\n     }\n+  if (m_jit_client_items)\n+    m_jit_client_items->print (fp, total);\n \n   /* Print total time.  */\n   fputs (\" TOTAL                 :\", fp);\n@@ -578,6 +742,17 @@ timer::print (FILE *fp)\n   validate_phases (fp);\n }\n \n+/* Get the name of the topmost item.  For use by jit for validating\n+   inputs to gcc_jit_timer_pop.  */\n+const char *\n+timer::get_topmost_item_name () const\n+{\n+  if (m_stack)\n+    return m_stack->timevar->name;\n+  else\n+    return NULL;\n+}\n+\n /* Prints a message to stderr stating that time elapsed in STR is\n    TOTAL (given in microseconds).  */\n "}, {"sha": "ac410751b685a31d90a3ca06061972f13c94b18f", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -296,3 +296,5 @@ DEFTIMEVAR (TV_JIT_REPLAY\t     , \"replay of JIT client activity\")\n DEFTIMEVAR (TV_ASSEMBLE\t     , \"assemble JIT code\")\n DEFTIMEVAR (TV_LINK\t\t     , \"link JIT code\")\n DEFTIMEVAR (TV_LOAD\t\t     , \"load JIT result\")\n+DEFTIMEVAR (TV_JIT_ACQUIRING_MUTEX   , \"acquiring JIT mutex\")\n+DEFTIMEVAR (TV_JIT_CLIENT_CODE   , \"JIT client code\")"}, {"sha": "85c761009c27eb0793acfdaea1bc273640f8d70f", "filename": "gcc/timevar.h", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftimevar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftimevar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.h?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -115,12 +115,24 @@ class timer\n   bool cond_start (timevar_id_t tv);\n   void cond_stop (timevar_id_t tv);\n \n+  void push_client_item (const char *item_name);\n+  void pop_client_item ();\n+\n   void print (FILE *fp);\n \n+  const char *get_topmost_item_name () const;\n+\n  private:\n   /* Private member functions.  */\n   void validate_phases (FILE *fp) const;\n \n+  struct timevar_def;\n+  void push_internal (struct timevar_def *tv);\n+  void pop_internal ();\n+  static void print_row (FILE *fp,\n+\t\t\t const timevar_time_def *total,\n+\t\t\t const timevar_def *tv);\n+\n  private:\n \n   /* Private type: a timing variable.  */\n@@ -157,6 +169,12 @@ class timer\n     struct timevar_stack_def *next;\n   };\n \n+  /* A class for managing a collection of named timing items, for use\n+     e.g. by libgccjit for timing client code.  This class is declared\n+     inside timevar.c to avoid everything using timevar.h\n+     from needing vec and hash_map.  */\n+  class named_items;\n+\n  private:\n \n   /* Data members (all private).  */\n@@ -176,6 +194,11 @@ class timer\n      pushed.  Time elapsed since then is attributed to the topmost\n      element.  */\n   timevar_time_def m_start_time;\n+\n+  /* If non-NULL, for use when timing libgccjit's client code.  */\n+  named_items *m_jit_client_items;\n+\n+  friend class named_items;\n };\n \n /* Provided for backward compatibility.  */\n@@ -198,22 +221,26 @@ timevar_pop (timevar_id_t tv)\n class auto_timevar\n {\n  public:\n-  auto_timevar (timevar_id_t tv)\n-    : m_tv (tv)\n+  auto_timevar (timer *t, timevar_id_t tv)\n+    : m_timer (t),\n+      m_tv (tv)\n   {\n-    timevar_push (m_tv);\n+    if (m_timer)\n+      m_timer->push (m_tv);\n   }\n \n   ~auto_timevar ()\n   {\n-    timevar_pop (m_tv);\n+    if (m_timer)\n+      m_timer->pop (m_tv);\n   }\n \n  private:\n \n   // Private to disallow copies.\n   auto_timevar (const auto_timevar &);\n \n+  timer *m_timer;\n   timevar_id_t m_tv;\n };\n "}, {"sha": "0b0c7f1da766737f1bff03b62f166a1194f8bbd0", "filename": "gcc/toplev.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -1781,7 +1781,7 @@ static int rtl_initialized;\n void\n initialize_rtl (void)\n {\n-  auto_timevar tv (TV_INITIALIZE_RTL);\n+  auto_timevar tv (g_timer, TV_INITIALIZE_RTL);\n \n   /* Initialization done just once per compilation, but delayed\n      till code generation.  */\n@@ -2054,23 +2054,29 @@ do_compile ()\n     }\n }\n \n-toplev::toplev (bool use_TV_TOTAL, bool init_signals)\n-  : m_use_TV_TOTAL (use_TV_TOTAL),\n+toplev::toplev (timer *external_timer,\n+\t\tbool init_signals)\n+  : m_use_TV_TOTAL (external_timer == NULL),\n     m_init_signals (init_signals)\n {\n-  if (!m_use_TV_TOTAL)\n-    start_timevars ();\n+  if (external_timer)\n+    g_timer = external_timer;\n }\n \n toplev::~toplev ()\n {\n-  if (g_timer)\n+  if (g_timer && m_use_TV_TOTAL)\n     {\n       g_timer->stop (TV_TOTAL);\n       g_timer->print (stderr);\n+      delete g_timer;\n+      g_timer = NULL;\n     }\n }\n \n+/* Potentially call timevar_init (which will create g_timevars if it\n+   doesn't already exist).  */\n+\n void\n toplev::start_timevars ()\n {"}, {"sha": "21d9a75ed4f7199e55a349d762499f3e5bd12384", "filename": "gcc/toplev.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afed345982d5923b04d41885e868c9ca345ff3f9/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=afed345982d5923b04d41885e868c9ca345ff3f9", "patch": "@@ -24,11 +24,13 @@ along with GCC; see the file COPYING3.  If not see\n extern struct cl_decoded_option *save_decoded_options;\n extern unsigned int save_decoded_options_count;\n \n+class timer;\n+\n /* Invoking the compiler.  */\n class toplev\n {\n public:\n-  toplev (bool use_TV_TOTAL,\n+  toplev (timer *external_timer,\n \t  bool init_signals);\n   ~toplev ();\n "}]}