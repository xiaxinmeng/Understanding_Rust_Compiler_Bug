{"sha": "a7abcbbf92b21842d774a96fae56122c95544f44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdhYmNiYmY5MmIyMTg0MmQ3NzRhOTZmYWU1NjEyMmM5NTU0NGY0NA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-05-01T18:20:10Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-05-01T18:20:10Z"}, "message": "cpphash.c (_cpp_make_hashnode): Rename make_HASHNODE, now static.\n\n\t* cpphash.c (_cpp_make_hashnode): Rename make_HASHNODE, now\n\tstatic.  Allocate the hashnode and its string in the same\n\tblock of memory.\n\t(del_HASHNODE): Don't free h->name.\n\t(_cpp_lookup): If there is no entry for this string, create\n\tone, of type T_VOID.\n\t(_cpp_lookup_slot): Delete.\n\t* cpphash.h: Update prototypes.\n\n\t* cpplex.c (maybe_macroexpand): Check for hp->type == T_VOID,\n\tnot hp == NULL.\n\t* cpplib.c (do_define, do_undef, do_pragma_poison, do_assert,\n\tdo_unassert, cpp_defined): Use _cpp_lookup.  Don't create a\n\tnode here, just fill in the value field properly.  \"Delete\"\n\tentries by setting the value field to T_VOID.  Check for\n\thp->type == T_VOID, not hp == NULL.\n\n\t* Makefile.in (cpplib.o): Don't depend on $(HASHTAB_H).\n\t* cpperror.c, cppexp.c, cpplex.c, cpplib.c:  Don't include\n\thashtab.h.\n\nFrom-SVN: r33581", "tree": {"sha": "f86e627be1bd97d95d7ce2354cf47e7860868588", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f86e627be1bd97d95d7ce2354cf47e7860868588"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7abcbbf92b21842d774a96fae56122c95544f44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7abcbbf92b21842d774a96fae56122c95544f44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7abcbbf92b21842d774a96fae56122c95544f44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7abcbbf92b21842d774a96fae56122c95544f44/comments", "author": null, "committer": null, "parents": [{"sha": "b7fe530c1e209f8f7588ce369bae21725346a662", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7fe530c1e209f8f7588ce369bae21725346a662", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7fe530c1e209f8f7588ce369bae21725346a662"}], "stats": {"total": 223, "additions": 85, "deletions": 138}, "files": [{"sha": "20d10aac09adbe08e4b5fa595fe4b7ad0d02a855", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a7abcbbf92b21842d774a96fae56122c95544f44", "patch": "@@ -2064,7 +2064,7 @@ cppulp.o:   cppulp.c   $(CONFIG_H) system.h output.h\n cpperror.o: cpperror.c $(CONFIG_H) $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(CONFIG_H) $(LIBCPP_DEPS)\n cpplex.o:   cpplex.c   $(CONFIG_H) $(LIBCPP_DEPS)\n-cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H)\n+cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS)\n cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H)\n cppfiles.o: cppfiles.c $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H) mkdeps.h\n "}, {"sha": "0e8afc4ffa9a7fe1277cb7fc5caa254cf91bce30", "filename": "gcc/cpperror.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=a7abcbbf92b21842d774a96fae56122c95544f44", "patch": "@@ -25,7 +25,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #include \"config.h\"\n #include \"system.h\"\n-#include \"hashtab.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n #include \"intl.h\""}, {"sha": "40ca900570385f523b8d08d3efa3586514b16007", "filename": "gcc/cppexp.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=a7abcbbf92b21842d774a96fae56122c95544f44", "patch": "@@ -22,7 +22,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"cpplib.h\"\n-#include \"hashtab.h\"\n #include \"cpphash.h\"\n \n #ifndef CHAR_TYPE_SIZE"}, {"sha": "97ca109cbdd48f73e105d2d8efc68f274ec7b221", "filename": "gcc/cpphash.c", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=a7abcbbf92b21842d774a96fae56122c95544f44", "patch": "@@ -103,6 +103,9 @@ struct funct_defn\n static unsigned int hash_HASHNODE PARAMS ((const void *));\n static int eq_HASHNODE\t\t  PARAMS ((const void *, const void *));\n static void del_HASHNODE\t  PARAMS ((void *));\n+static HASHNODE *make_HASHNODE\t  PARAMS ((const U_CHAR *, size_t,\n+\t\t\t\t\t   enum node_type, unsigned int));\n+\n static void dump_funlike_macro\t  PARAMS ((cpp_reader *,\n \t\t\t\t\t   const struct funct_defn *));\n static int dump_hash_helper\t  PARAMS ((void **, void *));\n@@ -234,22 +237,21 @@ del_HASHNODE (x)\n   HASHNODE *h = (HASHNODE *)x;\n \n   _cpp_free_definition (h);\n-  free ((void *) h->name);\n   free (h);\n }\n \n /* Allocate and initialize a HASHNODE structure.\n    Caller must fill in the value field.  */\n \n-HASHNODE *\n-_cpp_make_hashnode (name, len, type, hash)\n+static HASHNODE *\n+make_HASHNODE (name, len, type, hash)\n      const U_CHAR *name;\n      size_t len;\n      enum node_type type;\n      unsigned int hash;\n {\n-  HASHNODE *hp = (HASHNODE *) xmalloc (sizeof (HASHNODE));\n-  U_CHAR *p = xmalloc (len + 1);\n+  HASHNODE *hp = (HASHNODE *) xmalloc (sizeof (HASHNODE) + len + 1);\n+  U_CHAR *p = (U_CHAR *)hp + sizeof (HASHNODE);\n \n   hp->type = type;\n   hp->length = len;\n@@ -271,37 +273,23 @@ _cpp_lookup (pfile, name, len)\n      const U_CHAR *name;\n      int len;\n {\n-  const U_CHAR *bp;\n   HASHNODE dummy;\n+  HASHNODE *new, **slot;\n \n   dummy.name = name;\n   dummy.length = len;\n   dummy.hash = _cpp_calc_hash (name, len);\n \n-  return (HASHNODE *) htab_find_with_hash (pfile->hashtab,\n-\t\t\t\t\t   (void *)&dummy, dummy.hash);\n-}\n-\n-/* Find the hashtable slot for name \"name\".  Used to insert or delete.  */\n-\n-HASHNODE **\n-_cpp_lookup_slot (pfile, name, len, insert, hash)\n-     cpp_reader *pfile;\n-     const U_CHAR *name;\n-     int len;\n-     enum insert_option insert;\n-     unsigned int hash;\n-{\n-  const U_CHAR *bp;\n-  HASHNODE dummy;\n-\n-  dummy.name = name;\n-  dummy.length = len;\n-  dummy.hash = hash;\n+  slot = (HASHNODE **)\n+    htab_find_slot_with_hash (pfile->hashtab, (void *)&dummy,\n+\t\t\t      dummy.hash, INSERT);\n+  if (*slot)\n+    return *slot;\n \n-  return (HASHNODE **) htab_find_slot_with_hash (pfile->hashtab,\n-\t\t\t\t\t\t (void *) &dummy,\n-\t\t\t\t\t\t dummy.hash, insert);\n+  new = make_HASHNODE (name, len, T_VOID, dummy.hash);\n+  new->value.cpval = NULL;\n+  *slot = new;\n+  return new;\n }\n \n /* Init the hash table.  In here so it can see the hash and eq functions.  */"}, {"sha": "855df3bf069ef73bfc9e305aae352bb401fb4a6a", "filename": "gcc/cpphash.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=a7abcbbf92b21842d774a96fae56122c95544f44", "patch": "@@ -210,16 +210,9 @@ extern unsigned char _cpp_IStable[256];\n  (CPP_BUFFER(PFILE)->cur - CPP_BUFFER(PFILE)->mark == 1)\n \n /* In cpphash.c */\n-extern HASHNODE *_cpp_make_hashnode\tPARAMS ((const U_CHAR *, size_t,\n-\t\t\t\t\t\t enum node_type,\n-\t\t\t\t\t\t unsigned int));\n extern unsigned int _cpp_calc_hash\tPARAMS ((const U_CHAR *, size_t));\n extern HASHNODE *_cpp_lookup\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const U_CHAR *, int));\n-extern HASHNODE **_cpp_lookup_slot\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const U_CHAR *, int,\n-\t\t\t\t\t\t enum insert_option,\n-\t\t\t\t\t\t unsigned int));\n extern void _cpp_free_definition\tPARAMS ((HASHNODE *));\n extern int _cpp_create_definition\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t cpp_toklist *, HASHNODE *));"}, {"sha": "944dd599dd8fa5cfabcb076906920a0a437bdce8", "filename": "gcc/cppinit.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=a7abcbbf92b21842d774a96fae56122c95544f44", "patch": "@@ -679,10 +679,9 @@ initialize_builtins (pfile)\n \tval = b->value;\n \n       len = strlen (b->name);\n-      hp = _cpp_make_hashnode (b->name, len, b->type,\n-\t\t\t       _cpp_calc_hash (b->name, len));\n+      hp = _cpp_lookup (pfile, b->name, len);\n       hp->value.cpval = val;\n-      *(htab_find_slot (pfile->hashtab, (void *) hp, INSERT)) = hp;\n+      hp->type = b->type;\n \n       if ((b->flags & DUMP) && CPP_OPTION (pfile, debug_output))\n \tdump_special_to_buffer (pfile, b->name);"}, {"sha": "3feacd28170b5b04a9755412245ab4216b51245b", "filename": "gcc/cpplex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=a7abcbbf92b21842d774a96fae56122c95544f44", "patch": "@@ -23,7 +23,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"intl.h\"\n-#include \"hashtab.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n@@ -1463,7 +1462,8 @@ maybe_macroexpand (pfile, written)\n   size_t len = CPP_WRITTEN (pfile) - written;\n   HASHNODE *hp = _cpp_lookup (pfile, macro, len);\n \n-  if (!hp)\n+  /* _cpp_lookup never returns null.  */\n+  if (hp->type == T_VOID)\n     return 0;\n   if (hp->disabled || hp->type == T_IDENTITY)\n     {"}, {"sha": "d51c0b39e11884691742812ae2f74945f8eb2bab", "filename": "gcc/cpplib.c", "status": "modified", "additions": 63, "deletions": 94, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7abcbbf92b21842d774a96fae56122c95544f44/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=a7abcbbf92b21842d774a96fae56122c95544f44", "patch": "@@ -22,10 +22,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n \n-#include \"hashtab.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n-#include \"hashtab.h\"\n #include \"intl.h\"\n #include \"symcat.h\"\n \n@@ -338,8 +336,7 @@ static int\n do_define (pfile)\n      cpp_reader *pfile;\n {\n-  HASHNODE **slot;\n-  unsigned int hash;\n+  HASHNODE *node;\n   int len;\n   U_CHAR *sym;\n   cpp_toklist *list = &pfile->directbuf;\n@@ -371,27 +368,21 @@ do_define (pfile)\n       goto out;\n     }\n \n-  hash = _cpp_calc_hash (sym, len);\n-  slot = _cpp_lookup_slot (pfile, sym, len, INSERT, hash);\n-  if (*slot)\n+  node = _cpp_lookup (pfile, sym, len);\n+  /* Check for poisoned identifiers now.  All other checks\n+     are done in cpphash.c.  */\n+  if (node->type == T_POISON)\n     {\n-      /* Check for poisoned identifiers now.  All other checks\n-\t are done in cpphash.c.  */\n-      if ((*slot)->type == T_POISON)\n-\t{\n-\t  cpp_error (pfile, \"redefining poisoned `%.*s'\", len, sym);\n-\t  goto out;\n-\t}\n+      cpp_error (pfile, \"redefining poisoned `%.*s'\", len, sym);\n+      goto out;\n     }\n-  else\n-    *slot = _cpp_make_hashnode (sym, len, T_VOID, hash);\n     \n-  if (_cpp_create_definition (pfile, list, *slot) == 0)\n+  if (_cpp_create_definition (pfile, list, node) == 0)\n     goto out;\n \n   if (CPP_OPTION (pfile, debug_output)\n       || CPP_OPTION (pfile, dump_macros) == dump_definitions)\n-    _cpp_dump_definition (pfile, *slot);\n+    _cpp_dump_definition (pfile, node);\n   else if (CPP_OPTION (pfile, dump_macros) == dump_names)\n     pass_thru_directive (sym, len, pfile, T_DEFINE);\n \n@@ -687,8 +678,7 @@ do_undef (pfile)\n      cpp_reader *pfile;\n {\n   int len;\n-  unsigned int hash;\n-  HASHNODE **slot;\n+  HASHNODE *hp;\n   U_CHAR *name;\n   long here = CPP_WRITTEN (pfile);\n   enum cpp_ttype token;\n@@ -715,26 +705,24 @@ do_undef (pfile)\n   name = pfile->token_buffer + here;\n   CPP_SET_WRITTEN (pfile, here);\n \n-  hash = _cpp_calc_hash (name, len);\n-  slot = _cpp_lookup_slot (pfile, name, len, NO_INSERT, hash);\n-  if (slot)\n+  hp = _cpp_lookup (pfile, name, len);\n+  if (hp->type == T_VOID)\n+    ; /* Not defined in the first place - do nothing.  */\n+  else if (hp->type == T_POISON)\n+    cpp_error (pfile, \"cannot undefine poisoned \\\"%s\\\"\", hp->name);\n+  else\n     {\n-      HASHNODE *hp = *slot;\n-      if (hp->type == T_POISON)\n-\tcpp_error (pfile, \"cannot undefine poisoned `%s'\", hp->name);\n-      else\n-\t{\n-\t  /* If we are generating additional info for debugging (with -g) we\n-\t     need to pass through all effective #undef commands.  */\n-\t  if (CPP_OPTION (pfile, debug_output))\n-\t    pass_thru_directive (hp->name, len, pfile, T_UNDEF);\n+      /* If we are generating additional info for debugging (with -g) we\n+\t need to pass through all effective #undef commands.  */\n+      if (CPP_OPTION (pfile, debug_output))\n+\tpass_thru_directive (hp->name, len, pfile, T_UNDEF);\n \n-\t  if (hp->type != T_MACRO && hp->type != T_FMACRO\n-\t      && hp->type != T_EMPTY && hp->type != T_IDENTITY)\n-\t    cpp_warning (pfile, \"undefining `%s'\", hp->name);\n+      if (hp->type != T_MACRO && hp->type != T_FMACRO\n+\t  && hp->type != T_EMPTY && hp->type != T_IDENTITY)\n+\tcpp_warning (pfile, \"undefining `%s'\", hp->name);\n \n-\t  htab_clear_slot (pfile->hashtab, (void **)slot);\n-\t}\n+      _cpp_free_definition (hp);\n+      hp->type = T_VOID;\n     }\n \n   return 0;\n@@ -947,12 +935,11 @@ do_pragma_poison (pfile)\n   /* Poison these symbols so that all subsequent usage produces an\n      error message.  */\n   U_CHAR *p;\n-  HASHNODE **slot;\n+  HASHNODE *hp;\n   long written;\n   size_t len;\n   enum cpp_ttype token;\n   int writeit;\n-  unsigned int hash;\n \n   /* As a rule, don't include #pragma poison commands in output,  \n      unless the user asks for them.  */\n@@ -975,23 +962,15 @@ do_pragma_poison (pfile)\n \n       p = pfile->token_buffer + written;\n       len = CPP_PWRITTEN (pfile) - p;\n-      hash = _cpp_calc_hash (p, len);\n-      slot = _cpp_lookup_slot (pfile, p, len, INSERT, hash);\n-      if (*slot)\n-\t{\n-\t  HASHNODE *hp = *slot;\n-\t  if (hp->type != T_POISON)\n-\t    {\n-\t      cpp_warning (pfile, \"poisoning existing macro `%s'\", hp->name);\n-\t      _cpp_free_definition (hp);\n-\t      hp->type = T_POISON;\n-\t    }\n-\t}\n+      hp = _cpp_lookup (pfile, p, len);\n+      if (hp->type == T_POISON)\n+\t;  /* It is allowed to poison the same identifier twice.  */\n       else\n \t{\n-\t  HASHNODE *hp = _cpp_make_hashnode (p, len, T_POISON, hash);\n-\t  hp->value.cpval = 0;\n-\t  *slot = hp;\n+\t  if (hp->type != T_VOID)\n+\t    cpp_warning (pfile, \"poisoning existing macro `%s'\", hp->name);\n+\t  _cpp_free_definition (hp);\n+\t  hp->type = T_POISON;\n \t}\n       if (writeit)\n \tCPP_PUTC (pfile, ' ');\n@@ -1509,9 +1488,7 @@ do_assert (pfile)\n   U_CHAR *sym;\n   int ret;\n   HASHNODE *base, *this;\n-  HASHNODE **bslot, **tslot;\n   size_t blen, tlen;\n-  unsigned int bhash, thash;\n \n   old_written = CPP_WRITTEN (pfile);\t/* remember where it starts */\n   ret = _cpp_parse_assertion (pfile);\n@@ -1529,35 +1506,24 @@ do_assert (pfile)\n       cpp_error (pfile, \"junk at end of #assert\");\n       goto error;\n     }\n-\n   sym = pfile->token_buffer + old_written;\n-  blen = (U_CHAR *) strchr (sym, '(') - sym;\n-  thash = _cpp_calc_hash (sym, tlen);\n-  tslot = _cpp_lookup_slot (pfile, sym, tlen, INSERT, thash);\n-  if (*tslot)\n+\n+  this = _cpp_lookup (pfile, sym, tlen);\n+  if (this->type == T_ASSERT)\n     {\n       cpp_warning (pfile, \"%s re-asserted\", sym);\n       goto error;\n     }\n-\n-  bhash = _cpp_calc_hash (sym, blen);\n-  bslot = _cpp_lookup_slot (pfile, sym, blen, INSERT, bhash);\n-  if (! *bslot)\n+      \n+  blen = (U_CHAR *) strchr (sym, '(') - sym;\n+  base = _cpp_lookup (pfile, sym, blen);\n+  if (base->type == T_VOID)\n     {\n-      *bslot = base = _cpp_make_hashnode (sym, blen, T_ASSERT, bhash);\n+      base->type = T_ASSERT;\n       base->value.aschain = 0;\n     }\n-  else\n-    {\n-      base = *bslot;\n-      if (base->type != T_ASSERT)\n-\t{\n-\t  /* Token clash - but with what?! */\n-\t  cpp_ice (pfile, \"base->type != T_ASSERT in do_assert\");\n-\t  goto error;\n-\t}\n-    }\n-  *tslot = this = _cpp_make_hashnode (sym, tlen, T_ASSERT, thash);\n+\n+  this->type = T_ASSERT;\n   this->value.aschain = base->value.aschain;\n   base->value.aschain = this;\n \n@@ -1580,54 +1546,57 @@ do_unassert (pfile)\n   old_written = CPP_WRITTEN (pfile);\n   ret = _cpp_parse_assertion (pfile);\n   if (ret == 0)\n-    goto error;\n+    goto out;\n   thislen = CPP_WRITTEN (pfile) - old_written;\n \n   if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n     {\n       cpp_error (pfile, \"junk at end of #unassert\");\n-      goto error;\n+      goto out;\n     }\n   sym = pfile->token_buffer + old_written;\n   CPP_SET_WRITTEN (pfile, old_written);\n \n   if (ret == 1)\n     {\n       base = _cpp_lookup (pfile, sym, thislen);\n-      if (! base)\n-\tgoto error;  /* It isn't an error to #undef what isn't #defined,\n-\t\t\tso it isn't an error to #unassert what isn't\n-\t\t\t#asserted either. */\n-      \n+      if (base->type == T_VOID)\n+\tgoto out;  /* It isn't an error to #undef what isn't #defined,\n+\t\t      so it isn't an error to #unassert what isn't\n+\t\t      #asserted either. */\n+\n       for (this = base->value.aschain; this; this = next)\n         {\n \t  next = this->value.aschain;\n-\t  htab_remove_elt (pfile->hashtab, this);\n+\t  this->value.aschain = NULL;\n+\t  this->type = T_VOID;\n \t}\n-      htab_remove_elt (pfile->hashtab, base);\n+      base->value.aschain = NULL;\n+      base->type = T_VOID;\n     }\n   else\n     {\n       baselen = (U_CHAR *) strchr (sym, '(') - sym;\n       base = _cpp_lookup (pfile, sym, baselen);\n-      if (! base) goto error;\n+      if (base->type == T_VOID) goto out;\n       this = _cpp_lookup (pfile, sym, thislen);\n-      if (! this) goto error;\n+      if (this->type == T_VOID) goto out;\n \n       next = base;\n       while (next->value.aschain != this)\n \tnext = next->value.aschain;\n \n       next->value.aschain = this->value.aschain;\n-      htab_remove_elt (pfile->hashtab, this);\n+      this->value.aschain = NULL;\n+      this->type = T_VOID;\n \n       if (base->value.aschain == NULL)\n \t/* Last answer for this predicate deleted. */\n-\thtab_remove_elt (pfile->hashtab, base);\n+\tbase->type = T_VOID;\n     }\n   return 0;\n-  \n- error:\n+\n+ out:\n   _cpp_skip_rest_of_line (pfile);\n   CPP_SET_WRITTEN (pfile, old_written);\n   return 0;\n@@ -1730,10 +1699,10 @@ cpp_defined (pfile, id, len)\n      int len;\n {\n   HASHNODE *hp = _cpp_lookup (pfile, id, len);\n-  if (hp && hp->type == T_POISON)\n+  if (hp->type == T_POISON)\n     {\n       cpp_error (pfile, \"attempt to use poisoned `%s'\", hp->name);\n       return 0;\n     }\n-  return (hp != NULL);\n+  return (hp->type != T_VOID);\n }"}]}