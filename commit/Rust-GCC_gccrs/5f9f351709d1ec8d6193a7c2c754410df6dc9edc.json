{"sha": "5f9f351709d1ec8d6193a7c2c754410df6dc9edc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY5ZjM1MTcwOWQxZWM4ZDYxOTNhN2MyYzc1NDQxMGRmNmRjOWVkYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-09-21T23:11:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-09-21T23:11:08Z"}, "message": "ipa-inline-analsis.c (compute_inline_parameters): Set cfun and current_function_decl.\n\n\t* ipa-inline-analsis.c (compute_inline_parameters): Set\n\tcfun and current_function_decl.\n\nFrom-SVN: r179065", "tree": {"sha": "f464d963ac5d50d93fd668345f1d5f11f629ac8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f464d963ac5d50d93fd668345f1d5f11f629ac8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f9f351709d1ec8d6193a7c2c754410df6dc9edc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f9f351709d1ec8d6193a7c2c754410df6dc9edc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f9f351709d1ec8d6193a7c2c754410df6dc9edc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f9f351709d1ec8d6193a7c2c754410df6dc9edc/comments", "author": null, "committer": null, "parents": [{"sha": "b439486d5ea107753d27548edeb515bb4fee14e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b439486d5ea107753d27548edeb515bb4fee14e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b439486d5ea107753d27548edeb515bb4fee14e9"}], "stats": {"total": 56, "additions": 52, "deletions": 4}, "files": [{"sha": "3f9562293c856bf3a546ebeaa3125f256e2fdcb8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f9f351709d1ec8d6193a7c2c754410df6dc9edc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f9f351709d1ec8d6193a7c2c754410df6dc9edc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f9f351709d1ec8d6193a7c2c754410df6dc9edc", "patch": "@@ -1,3 +1,14 @@\n+2011-09-21  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-analsis.c (compute_inline_parameters): Set\n+\tcfun and current_function_decl.\n+\n+2011-09-21  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-analysis.c (set_cond_stmt_execution_predicate): Allow\n+\thandled components in parameter of builtin_constant_p.\n+\t(will_be_nonconstant_predicate): Allow loads of non-SSA parameters.\n+\n 2011-09-21  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-inline.c (relative_time_benefit): Fix wrong bracketting."}, {"sha": "3437c1cc5232f6fc6265c900529a1c97f1bcc162", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f9f351709d1ec8d6193a7c2c754410df6dc9edc/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f9f351709d1ec8d6193a7c2c754410df6dc9edc/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=5f9f351709d1ec8d6193a7c2c754410df6dc9edc", "patch": "@@ -1202,6 +1202,7 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n   gimple set_stmt;\n   tree op2;\n   tree parm;\n+  tree base;\n \n   last = last_stmt (bb);\n   if (!last\n@@ -1252,7 +1253,8 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n       || gimple_call_num_args (set_stmt) != 1)\n     return;\n   op2 = gimple_call_arg (set_stmt, 0);\n-  parm = unmodified_parm (set_stmt, op2);\n+  base = get_base_address (op2);\n+  parm = unmodified_parm (set_stmt, base ? base : op2);\n   if (!parm)\n     return;\n   index = ipa_get_param_decl_index (info, parm);\n@@ -1433,6 +1435,7 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n   ssa_op_iter iter;\n   tree use;\n   struct predicate op_non_const;\n+  bool is_load;\n \n   /* What statments might be optimized away\n      when their arguments are constant\n@@ -1443,11 +1446,29 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n       && gimple_code (stmt) != GIMPLE_SWITCH)\n     return p;\n \n-  /* Stores and loads will stay anyway.\n-     TODO: Constant memory accesses could be handled here, too.  */\n-  if (gimple_vuse (stmt))\n+  /* Stores will stay anyway.  */\n+  if (gimple_vdef (stmt))\n     return p;\n \n+  is_load = gimple_vuse (stmt) != NULL;\n+\n+  /* Loads can be optimized when the value is known.  */\n+  if (is_load)\n+    {\n+      tree op = gimple_assign_rhs1 (stmt);\n+      tree base = get_base_address (op);\n+      tree parm;\n+\n+      gcc_assert (gimple_assign_single_p (stmt));\n+      if (!base)\n+\treturn p;\n+      parm = unmodified_parm (stmt, base);\n+      if (!parm )\n+\treturn p;\n+      if (ipa_get_param_decl_index (info, parm) < 0)\n+\treturn p;\n+    }\n+\n   /* See if we understand all operands before we start\n      adding conditionals.  */\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n@@ -1466,6 +1487,15 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n       return p;\n     }\n   op_non_const = false_predicate ();\n+  if (is_load)\n+    {\n+      tree parm = unmodified_parm\n+\t\t    (stmt, get_base_address (gimple_assign_rhs1 (stmt)));\n+      p = add_condition (summary,\n+\t\t\t ipa_get_param_decl_index (info, parm),\n+\t\t\t IS_NOT_CONSTANT, NULL);\n+      op_non_const = or_predicates (summary->conds, &p, &op_non_const);\n+    }\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n       tree parm = unmodified_parm (stmt, use);\n@@ -1694,6 +1724,7 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   HOST_WIDE_INT self_stack_size;\n   struct cgraph_edge *e;\n   struct inline_summary *info;\n+  tree old_decl = current_function_decl;\n \n   gcc_assert (!node->global.inlined_to);\n \n@@ -1718,6 +1749,10 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n       return;\n     }\n \n+  /* Even is_gimple_min_invariant rely on current_function_decl.  */\n+  current_function_decl = node->decl;\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\n   /* Estimate the stack size for the function if we're optimizing.  */\n   self_stack_size = optimize ? estimated_stack_frame_size (node) : 0;\n   info->estimated_self_stack_size = self_stack_size;\n@@ -1757,6 +1792,8 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   info->size = info->self_size;\n   info->stack_frame_offset = 0;\n   info->estimated_stack_size = info->estimated_self_stack_size;\n+  current_function_decl = old_decl;\n+  pop_cfun ();\n }\n \n "}]}