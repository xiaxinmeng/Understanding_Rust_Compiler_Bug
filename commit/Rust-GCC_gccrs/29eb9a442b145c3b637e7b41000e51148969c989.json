{"sha": "29eb9a442b145c3b637e7b41000e51148969c989", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjllYjlhNDQyYjE0NWMzYjYzN2U3YjQxMDAwZTUxMTQ4OTY5Yzk4OQ==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2017-05-08T17:44:36Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2017-05-08T17:44:36Z"}, "message": "target.def (compute_frame_layout): New optional target hook.\n\n2017-05-08  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        * target.def (compute_frame_layout): New optional target hook.\n        * doc/tm.texi.in (TARGET_COMPUTE_FRAME_LAYOUT): Add hook.\n        * doc/tm.texi (TARGET_COMPUTE_FRAME_LAYOUT): Add documentation.\n        * lra-eliminations.c (update_reg_eliminate): Call compute_frame_layout\n        target hook.\n        * reload1.c (verify_initial_elim_offsets): Likewise.\n        * config/arm/arm.c (TARGET_COMPUTE_FRAME_LAYOUT): Define.\n        (use_simple_return_p): Call arm_compute_frame_layout if needed.\n        (arm_get_frame_offsets): Split up into this ...\n        (arm_compute_frame_layout): ... and this function.\n\nFrom-SVN: r247750", "tree": {"sha": "25451e4bef78a2286c4eb70717dba908095ae3b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25451e4bef78a2286c4eb70717dba908095ae3b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29eb9a442b145c3b637e7b41000e51148969c989", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29eb9a442b145c3b637e7b41000e51148969c989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29eb9a442b145c3b637e7b41000e51148969c989", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29eb9a442b145c3b637e7b41000e51148969c989/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9057edd30c40ea77707650699f38734eb949b7d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9057edd30c40ea77707650699f38734eb949b7d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9057edd30c40ea77707650699f38734eb949b7d6"}], "stats": {"total": 74, "additions": 65, "deletions": 9}, "files": [{"sha": "dc2d9df83db907a202a23661fde1d6b497b3aa35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29eb9a442b145c3b637e7b41000e51148969c989", "patch": "@@ -1,3 +1,16 @@\n+2017-05-08  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\t* target.def (compute_frame_layout): New optional target hook.\n+\t* doc/tm.texi.in (TARGET_COMPUTE_FRAME_LAYOUT): Add hook.\n+\t* doc/tm.texi (TARGET_COMPUTE_FRAME_LAYOUT): Add documentation.\n+\t* lra-eliminations.c (update_reg_eliminate): Call compute_frame_layout\n+\ttarget hook.\n+\t* reload1.c (verify_initial_elim_offsets): Likewise.\n+\t* config/arm/arm.c (TARGET_COMPUTE_FRAME_LAYOUT): Define.\n+\t(use_simple_return_p): Call arm_compute_frame_layout if needed.\n+\t(arm_get_frame_offsets): Split up into this ...\n+\t(arm_compute_frame_layout): ... and this function.\n+\n 2017-05-08  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/constraints.md (Usa): New constraint."}, {"sha": "3ae999cb723a234332bd1ca2e80b09df240c67f0", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=29eb9a442b145c3b637e7b41000e51148969c989", "patch": "@@ -85,6 +85,7 @@ static bool arm_const_not_ok_for_debug_p (rtx);\n static int arm_needs_doubleword_align (machine_mode, const_tree);\n static int arm_compute_static_chain_stack_bytes (void);\n static arm_stack_offsets *arm_get_frame_offsets (void);\n+static void arm_compute_frame_layout (void);\n static void arm_add_gc_roots (void);\n static int arm_gen_constant (enum rtx_code, machine_mode, rtx,\n \t\t\t     unsigned HOST_WIDE_INT, rtx, rtx, int, int);\n@@ -680,6 +681,9 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P arm_scalar_mode_supported_p\n \n+#undef TARGET_COMPUTE_FRAME_LAYOUT\n+#define TARGET_COMPUTE_FRAME_LAYOUT arm_compute_frame_layout\n+\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED arm_frame_pointer_required\n \n@@ -4031,6 +4035,10 @@ use_simple_return_p (void)\n {\n   arm_stack_offsets *offsets;\n \n+  /* Note this function can be called before or after reload.  */\n+  if (!reload_completed)\n+    arm_compute_frame_layout ();\n+\n   offsets = arm_get_frame_offsets ();\n   return offsets->outgoing_args != 0;\n }\n@@ -19138,7 +19146,7 @@ arm_compute_static_chain_stack_bytes (void)\n \n /* Compute a bit mask of which registers need to be\n    saved on the stack for the current function.\n-   This is used by arm_get_frame_offsets, which may add extra registers.  */\n+   This is used by arm_compute_frame_layout, which may add extra registers.  */\n \n static unsigned long\n arm_compute_save_reg_mask (void)\n@@ -20772,12 +20780,25 @@ any_sibcall_could_use_r3 (void)\n   alignment.  */\n \n \n+/* Return cached stack offsets.  */\n+\n+static arm_stack_offsets *\n+arm_get_frame_offsets (void)\n+{\n+  struct arm_stack_offsets *offsets;\n+\n+  offsets = &cfun->machine->stack_offsets;\n+\n+  return offsets;\n+}\n+\n+\n /* Calculate stack offsets.  These are used to calculate register elimination\n    offsets and in prologue/epilogue code.  Also calculates which registers\n    should be saved.  */\n \n-static arm_stack_offsets *\n-arm_get_frame_offsets (void)\n+static void\n+arm_compute_frame_layout (void)\n {\n   struct arm_stack_offsets *offsets;\n   unsigned long func_type;\n@@ -20788,9 +20809,6 @@ arm_get_frame_offsets (void)\n \n   offsets = &cfun->machine->stack_offsets;\n \n-  if (reload_completed)\n-    return offsets;\n-\n   /* Initially this is the size of the local variables.  It will translated\n      into an offset once we have determined the size of preceding data.  */\n   frame_size = ROUND_UP_WORD (get_frame_size ());\n@@ -20855,7 +20873,7 @@ arm_get_frame_offsets (void)\n     {\n       offsets->outgoing_args = offsets->soft_frame;\n       offsets->locals_base = offsets->soft_frame;\n-      return offsets;\n+      return;\n     }\n \n   /* Ensure SFP has the correct alignment.  */\n@@ -20931,8 +20949,6 @@ arm_get_frame_offsets (void)\n \toffsets->outgoing_args += 4;\n       gcc_assert (!(offsets->outgoing_args & 7));\n     }\n-\n-  return offsets;\n }\n \n "}, {"sha": "2790dd6a5d5faea9b451fa05398e13960dd05e14", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=29eb9a442b145c3b637e7b41000e51148969c989", "patch": "@@ -3684,6 +3684,15 @@ such as the result of @code{get_frame_size ()} and the tables of\n registers @code{df_regs_ever_live_p} and @code{call_used_regs}.\n @end defmac\n \n+@deftypefn {Target Hook} void TARGET_COMPUTE_FRAME_LAYOUT (void)\n+This target hook is called once each time the frame layout needs to be\n+recalculated.  The calculations can be cached by the target and can then\n+be used by @code{INITIAL_ELIMINATION_OFFSET} instead of re-computing the\n+layout on every invocation of that hook.  This is particularly useful\n+for targets that have an expensive frame layout function.  Implementing\n+this callback is optional.\n+@end deftypefn\n+\n @node Stack Arguments\n @subsection Passing Function Arguments on the Stack\n @cindex arguments on stack"}, {"sha": "dff6cf8e038701215ab81d0ac153231a68554adb", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=29eb9a442b145c3b637e7b41000e51148969c989", "patch": "@@ -3213,6 +3213,8 @@ such as the result of @code{get_frame_size ()} and the tables of\n registers @code{df_regs_ever_live_p} and @code{call_used_regs}.\n @end defmac\n \n+@hook TARGET_COMPUTE_FRAME_LAYOUT\n+\n @node Stack Arguments\n @subsection Passing Function Arguments on the Stack\n @cindex arguments on stack"}, {"sha": "ab51b6738261274e22779d677b503cd52eda6afc", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=29eb9a442b145c3b637e7b41000e51148969c989", "patch": "@@ -1196,6 +1196,8 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n   struct lra_elim_table *ep, *ep1;\n   HARD_REG_SET temp_hard_reg_set;\n \n+  targetm.compute_frame_layout ();\n+\n   /* Clear self elimination offsets.  */\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     self_elim_offsets[ep->from] = 0;"}, {"sha": "e993749a0000cf66bae14c9d8f6eec6e44555988", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=29eb9a442b145c3b637e7b41000e51148969c989", "patch": "@@ -3821,6 +3821,7 @@ verify_initial_elim_offsets (void)\n   if (!num_eliminable)\n     return true;\n \n+  targetm.compute_frame_layout ();\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n       INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, t);\n@@ -3838,6 +3839,7 @@ set_initial_elim_offsets (void)\n {\n   struct elim_table *ep = reg_eliminate;\n \n+  targetm.compute_frame_layout ();\n   for (; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n       INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, ep->initial_offset);"}, {"sha": "bd60484c4fdfacded2c7d68106328173b4ec571b", "filename": "gcc/target.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29eb9a442b145c3b637e7b41000e51148969c989/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=29eb9a442b145c3b637e7b41000e51148969c989", "patch": "@@ -5395,6 +5395,18 @@ five otherwise.  This is best for most machines.\",\n  unsigned int, (void),\n  default_case_values_threshold)\n \n+/* Optional callback to advise the target to compute the frame layout.  */\n+DEFHOOK\n+(compute_frame_layout,\n+ \"This target hook is called once each time the frame layout needs to be\\n\\\n+recalculated.  The calculations can be cached by the target and can then\\n\\\n+be used by @code{INITIAL_ELIMINATION_OFFSET} instead of re-computing the\\n\\\n+layout on every invocation of that hook.  This is particularly useful\\n\\\n+for targets that have an expensive frame layout function.  Implementing\\n\\\n+this callback is optional.\",\n+ void, (void),\n+ hook_void_void)\n+\n /* Return true if a function must have and use a frame pointer.  */\n DEFHOOK\n (frame_pointer_required,"}]}