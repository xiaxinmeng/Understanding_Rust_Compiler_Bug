{"sha": "bbead5babc046279d886b059e68e613b0185b2ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJlYWQ1YmFiYzA0NjI3OWQ4ODZiMDU5ZTY4ZTYxM2IwMTg1YjJmZg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:02:50Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:02:50Z"}, "message": "[arm] Correct cost calculations involving borrow for subtracts.\n\nThe rtx_cost calculations when a borrow operation was being performed were\nnot being calculated correctly.  The borrow is free as part of the\nsubtract-with-carry instructions.  This patch recognizes the various\nidioms that can describe this and returns the correct costs.\n\n\t* config/arm/arm.c (arm_rtx_costs_internal, case MINUS): Handle\n\tborrow operations.\n\nFrom-SVN: r277173", "tree": {"sha": "124a99d80876a893377cb89eb847f09c6eca55f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/124a99d80876a893377cb89eb847f09c6eca55f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbead5babc046279d886b059e68e613b0185b2ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbead5babc046279d886b059e68e613b0185b2ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbead5babc046279d886b059e68e613b0185b2ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbead5babc046279d886b059e68e613b0185b2ff/comments", "author": null, "committer": null, "parents": [{"sha": "0a67306e3cc2adfe0ef2fe313a86f57141ab57b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a67306e3cc2adfe0ef2fe313a86f57141ab57b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a67306e3cc2adfe0ef2fe313a86f57141ab57b2"}], "stats": {"total": 54, "additions": 47, "deletions": 7}, "files": [{"sha": "e40511bf148d0f4a70fb2ea6c86b015952d7b3c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbead5babc046279d886b059e68e613b0185b2ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbead5babc046279d886b059e68e613b0185b2ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbead5babc046279d886b059e68e613b0185b2ff", "patch": "@@ -1,3 +1,8 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.c (arm_rtx_costs_internal, case MINUS): Handle\n+\tborrow operations.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.c (strip_carry_operation): New function."}, {"sha": "fd742226f16ed65b40137865ab1640c24b0700e3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbead5babc046279d886b059e68e613b0185b2ff/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbead5babc046279d886b059e68e613b0185b2ff/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=bbead5babc046279d886b059e68e613b0185b2ff", "patch": "@@ -10049,15 +10049,46 @@ arm_rtx_costs_internal (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  rtx shift_by_reg = NULL;\n \t  rtx shift_op;\n \t  rtx non_shift_op;\n+\t  rtx op0 = XEXP (x, 0);\n+\t  rtx op1 = XEXP (x, 1);\n \n-\t  shift_op = shifter_op_p (XEXP (x, 0), &shift_by_reg);\n+\t  /* Factor out any borrow operation.  There's more than one way\n+\t     of expressing this; try to recognize them all.  */\n+\t  if (GET_CODE (op0) == MINUS)\n+\t    {\n+\t      if (arm_borrow_operation (op1, SImode))\n+\t\t{\n+\t\t  op1 = XEXP (op0, 1);\n+\t\t  op0 = XEXP (op0, 0);\n+\t\t}\n+\t      else if (arm_borrow_operation (XEXP (op0, 1), SImode))\n+\t\top0 = XEXP (op0, 0);\n+\t    }\n+\t  else if (GET_CODE (op1) == PLUS\n+\t\t   && arm_borrow_operation (XEXP (op1, 0), SImode))\n+\t    op1 = XEXP (op1, 0);\n+\t  else if (GET_CODE (op0) == NEG\n+\t\t   && arm_borrow_operation (op1, SImode))\n+\t    {\n+\t      /* Negate with carry-in.  For Thumb2 this is done with\n+\t\t SBC R, X, X lsl #1 (ie X - 2X - C) as Thumb lacks the\n+\t\t RSC instruction that exists in Arm mode.  */\n+\t      if (speed_p)\n+\t\t*cost += (TARGET_THUMB2\n+\t\t\t  ? extra_cost->alu.arith_shift\n+\t\t\t  : extra_cost->alu.arith);\n+\t      *cost += rtx_cost (XEXP (op0, 0), mode, MINUS, 0, speed_p);\n+\t      return true;\n+\t    }\n+\n+\t  shift_op = shifter_op_p (op0, &shift_by_reg);\n \t  if (shift_op == NULL)\n \t    {\n-\t      shift_op = shifter_op_p (XEXP (x, 1), &shift_by_reg);\n-\t      non_shift_op = XEXP (x, 0);\n+\t      shift_op = shifter_op_p (op1, &shift_by_reg);\n+\t      non_shift_op = op0;\n \t    }\n \t  else\n-\t    non_shift_op = XEXP (x, 1);\n+\t    non_shift_op = op1;\n \n \t  if (shift_op != NULL)\n \t    {\n@@ -10087,10 +10118,10 @@ arm_rtx_costs_internal (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      return true;\n \t    }\n \n-\t  if (CONST_INT_P (XEXP (x, 0)))\n+\t  if (CONST_INT_P (op0))\n \t    {\n \t      int insns = arm_gen_constant (MINUS, SImode, NULL_RTX,\n-\t\t\t\t\t    INTVAL (XEXP (x, 0)), NULL_RTX,\n+\t\t\t\t\t    INTVAL (op0), NULL_RTX,\n \t\t\t\t\t    NULL_RTX, 1, 0);\n \t      *cost = COSTS_N_INSNS (insns);\n \t      if (speed_p)\n@@ -10101,7 +10132,11 @@ arm_rtx_costs_internal (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  else if (speed_p)\n \t    *cost += extra_cost->alu.arith;\n \n-\t  return false;\n+\t  /* Don't recurse as we don't want to cost any borrow that\n+\t     we've stripped.  */\n+\t  *cost += rtx_cost (op0, mode, MINUS, 0, speed_p);\n+\t  *cost += rtx_cost (op1, mode, MINUS, 1, speed_p);\n+\t  return true;\n \t}\n \n       if (GET_MODE_CLASS (mode) == MODE_INT"}]}