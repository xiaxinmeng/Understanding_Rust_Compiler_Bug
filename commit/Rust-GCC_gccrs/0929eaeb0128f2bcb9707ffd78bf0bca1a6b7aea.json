{"sha": "0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkyOWVhZWIwMTI4ZjJiY2I5NzA3ZmZkNzhiZjBiY2ExYTZiN2FlYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T10:07:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T10:07:24Z"}, "message": "[multiple changes]\n\n2012-10-01  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Process_Convention, Process_Import_Or_Interface):\n\tAdjust test so that when the pragma comes from an aspect\n\tspecification it only applies to the entity in the original\n\tdeclaration.\n\n2012-10-01  Thomas Quinot  <quinot@adacore.com>\n\n\t* gnat_ugn.texi: Document new command line switch -fada-spec-parent.\n\n2012-10-01  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-oscons-tmplt.c, g-socket.ads: Minor code improvement: use gcc\n\tbuiltin __alignof__ to get the alignment of struct fd_set.\n\n2012-10-01  Vincent Pucci  <pucci@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call): Remove call to\n\tRemove_Dimension_In_Call.\n\t* sem_aggr.adb (Resolve_Array_Aggregate): Analyze dimension of\n\tcomponents in array aggregate.\n\t(Resolve_Aggr_Expr): Propagate dimensions from the original expression\n\tExpr to the new created expression New_Expr when resolving the\n\texpression of a component in record aggregates.\n\t(Resolve_Record_Aggregate): Analyze\n\tdimension of components in record (or extension) aggregate.\n\t* sem_ch6.adb (Analyze_Subprogram_Specification): Analyze\n\tdimension of formals with default expressions in subprogram\n\tspecification.\n\t* sem_ch8.adb (Analyze_Expanded_Name): Analyze dimension of\n\texpanded names.\n\t(Find_Selected_Component): Analyze dimension of selected component.\n\t* sem_dim.adb: Several dimension error messages reformatting.\n\t(Dimensions_Msg_Of): New flag Description_Needed in order to\n\tdifferentiate two different sort of dimension error messages.\n\t(Dim_Warning_For_Numeric_Literal): New routine.\n\t(Exists): New routine.\n\t(Move_Dimensions): Routine spec moved to spec file.\n\t* sem_dim.ads (String_From_Numeric_Literal): New routine.\n\t(Analyze_Dimension): Analyze dimension only when the\n\tnode comes from source.  Dimension analysis for expanded names added.\n\t(Analyze_Dimension_Array_Aggregate): New routine.\n\t(Analyze_Dimension_Call): New routine.\n\t(Analyze_Dimension_Component_Declaration): Warning if default\n\texpression is a numeric literal.\n\t(Analyze_Dimension_Extension_Or_Record_Aggregate): New routine.\n\t(Analyze_Dimension_Formals): New routine.\n\t(Analyze_Dimension_Object_Declaration): Warning if default\n\texpression is a numeric literal.\n\t(Symbol_Of): Return either the dimension subtype symbol or the\n\tdimension symbol built by From_Dim_To_Str_Of_Unit_Symbols.\n\t* sem_dim.ads (Analyze_Dimension_Array_Aggregate): New routine.\n\t(Analyze_Dimension_Call): New routine.\n\t(Analyze_Dimension_Extension_Or_Record_Aggregate): New routine.\n\t(Analyze_Dimension_Formals): New routine.\n\t(Move_Dimensions): Moved from sem_dim.adb.\n\t* s-dimmks.ads: Turn off the warnings for dimensioned object\n\tdeclaration.  Dimensioned subtypes sorted in alphabetical\n\torder. New subtypes Area, Speed, Volume.\n\t* s-dmotpr.ads: Turn off the warnings for dimensioned object\n\tdeclaration.\n\t* sem_res.adb (Resolve_Call): Analyze dimension for calls.\n\n2012-10-01  Thomas Quinot  <quinot@adacore.com>\n\n\t* Make-generated.in: Minor cleanup of all targets: use\n\tMOVE_IF_CHANGE to put generated files in place, to avoid useless\n\trecompilations.\n\n2012-10-01  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.adb (Expand_Dispatching_Call): For functions returning\n\tinterface types add an implicit conversion to the returned object\n\tto force the displacement of the pointer to the returned object\n\tto reference the corresponding secondary dispatch table. This\n\tis needed to handle well combined calls involving secondary\n\tdispatch tables (for example Obj.Prim1.Prim2).\n\t* exp_ch4.adb (Expand_Allocator_Expression): Declare internal\n\taccess type as access to constant or access to variable depending\n\ton the context. Found working in this ticket.\n\n2012-10-01  Ed Schonberg  <schonberg@adacore.com>\n\n\t* checks.adb (Apply_Predicate_Check): Do not apply check to\n\tactual of predicate checking procedure, to prevent infinite\n\trecursion.\n\nFrom-SVN: r191910", "tree": {"sha": "91820ae56088b235e14ebd8b3e430343693d843a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91820ae56088b235e14ebd8b3e430343693d843a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/comments", "author": null, "committer": null, "parents": [{"sha": "5f6e1c559b08a262977b1cbcfe16f75116fef4f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f6e1c559b08a262977b1cbcfe16f75116fef4f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f6e1c559b08a262977b1cbcfe16f75116fef4f7"}], "stats": {"total": 1299, "additions": 989, "deletions": 310}, "files": [{"sha": "6b2c9dfef1b5d85a0aa1680a9c8367e48eeb8229", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -1,3 +1,91 @@\n+2012-10-01  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Process_Convention, Process_Import_Or_Interface):\n+\tAdjust test so that when the pragma comes from an aspect\n+\tspecification it only applies to the entity in the original\n+\tdeclaration.\n+\n+2012-10-01  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* gnat_ugn.texi: Document new command line switch -fada-spec-parent.\n+\n+2012-10-01  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-oscons-tmplt.c, g-socket.ads: Minor code improvement: use gcc\n+\tbuiltin __alignof__ to get the alignment of struct fd_set.\n+\n+2012-10-01  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call): Remove call to\n+\tRemove_Dimension_In_Call.\n+\t* sem_aggr.adb (Resolve_Array_Aggregate): Analyze dimension of\n+\tcomponents in array aggregate.\n+\t(Resolve_Aggr_Expr): Propagate dimensions from the original expression\n+\tExpr to the new created expression New_Expr when resolving the\n+\texpression of a component in record aggregates.\n+\t(Resolve_Record_Aggregate): Analyze\n+\tdimension of components in record (or extension) aggregate.\n+\t* sem_ch6.adb (Analyze_Subprogram_Specification): Analyze\n+\tdimension of formals with default expressions in subprogram\n+\tspecification.\n+\t* sem_ch8.adb (Analyze_Expanded_Name): Analyze dimension of\n+\texpanded names.\n+\t(Find_Selected_Component): Analyze dimension of selected component.\n+\t* sem_dim.adb: Several dimension error messages reformatting.\n+\t(Dimensions_Msg_Of): New flag Description_Needed in order to\n+\tdifferentiate two different sort of dimension error messages.\n+\t(Dim_Warning_For_Numeric_Literal): New routine.\n+\t(Exists): New routine.\n+\t(Move_Dimensions): Routine spec moved to spec file.\n+\t* sem_dim.ads (String_From_Numeric_Literal): New routine.\n+\t(Analyze_Dimension): Analyze dimension only when the\n+\tnode comes from source.  Dimension analysis for expanded names added.\n+\t(Analyze_Dimension_Array_Aggregate): New routine.\n+\t(Analyze_Dimension_Call): New routine.\n+\t(Analyze_Dimension_Component_Declaration): Warning if default\n+\texpression is a numeric literal.\n+\t(Analyze_Dimension_Extension_Or_Record_Aggregate): New routine.\n+\t(Analyze_Dimension_Formals): New routine.\n+\t(Analyze_Dimension_Object_Declaration): Warning if default\n+\texpression is a numeric literal.\n+\t(Symbol_Of): Return either the dimension subtype symbol or the\n+\tdimension symbol built by From_Dim_To_Str_Of_Unit_Symbols.\n+\t* sem_dim.ads (Analyze_Dimension_Array_Aggregate): New routine.\n+\t(Analyze_Dimension_Call): New routine.\n+\t(Analyze_Dimension_Extension_Or_Record_Aggregate): New routine.\n+\t(Analyze_Dimension_Formals): New routine.\n+\t(Move_Dimensions): Moved from sem_dim.adb.\n+\t* s-dimmks.ads: Turn off the warnings for dimensioned object\n+\tdeclaration.  Dimensioned subtypes sorted in alphabetical\n+\torder. New subtypes Area, Speed, Volume.\n+\t* s-dmotpr.ads: Turn off the warnings for dimensioned object\n+\tdeclaration.\n+\t* sem_res.adb (Resolve_Call): Analyze dimension for calls.\n+\n+2012-10-01  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* Make-generated.in: Minor cleanup of all targets: use\n+\tMOVE_IF_CHANGE to put generated files in place, to avoid useless\n+\trecompilations.\n+\n+2012-10-01  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.adb (Expand_Dispatching_Call): For functions returning\n+\tinterface types add an implicit conversion to the returned object\n+\tto force the displacement of the pointer to the returned object\n+\tto reference the corresponding secondary dispatch table. This\n+\tis needed to handle well combined calls involving secondary\n+\tdispatch tables (for example Obj.Prim1.Prim2).\n+\t* exp_ch4.adb (Expand_Allocator_Expression): Declare internal\n+\taccess type as access to constant or access to variable depending\n+\ton the context. Found working in this ticket.\n+\n+2012-10-01  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* checks.adb (Apply_Predicate_Check): Do not apply check to\n+\tactual of predicate checking procedure, to prevent infinite\n+\trecursion.\n+\n 2012-10-01  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Update dependencies."}, {"sha": "57159342ff777b769bd763645775ee3f4aacc2ea", "filename": "gcc/ada/Make-generated.in", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2FMake-generated.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2FMake-generated.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-generated.in?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -18,6 +18,7 @@ ifeq ($(origin MOVE_IF_CHANGE), undefined)\n MOVE_IF_CHANGE=mv -f\n endif\n \n+.PHONY: ada_extra_files\n ada_extra_files : $(ADA_GEN_SUBDIR)/treeprs.ads $(ADA_GEN_SUBDIR)/einfo.h $(ADA_GEN_SUBDIR)/sinfo.h $(ADA_GEN_SUBDIR)/nmake.adb \\\n \t$(ADA_GEN_SUBDIR)/nmake.ads $(ADA_GEN_SUBDIR)/snames.ads $(ADA_GEN_SUBDIR)/snames.adb $(ADA_GEN_SUBDIR)/snames.h\n \n@@ -27,19 +28,22 @@ $(ADA_GEN_SUBDIR)/treeprs.ads : $(ADA_GEN_SUBDIR)/treeprs.adt $(ADA_GEN_SUBDIR)/\n \t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/treeprs\n \t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/treeprs/,$(notdir $^))\n \t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/treeprs\n-\t(cd $(ADA_GEN_SUBDIR)/bldtools/treeprs; gnatmake -q xtreeprs ; ./xtreeprs ../../treeprs.ads )\n+\t(cd $(ADA_GEN_SUBDIR)/bldtools/treeprs; gnatmake -q xtreeprs ; ./xtreeprs treeprs.ads )\n+\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/treeprs/treeprs.ads $(ADA_GEN_SUBDIR)/treeprs.ads\n \n $(ADA_GEN_SUBDIR)/einfo.h : $(ADA_GEN_SUBDIR)/einfo.ads $(ADA_GEN_SUBDIR)/einfo.adb $(ADA_GEN_SUBDIR)/xeinfo.adb $(ADA_GEN_SUBDIR)/ceinfo.adb\n \t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/einfo\n \t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/einfo/,$(notdir $^))\n \t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/einfo\n-\t(cd $(ADA_GEN_SUBDIR)/bldtools/einfo; gnatmake -q xeinfo ; ./xeinfo ../../einfo.h )\n+\t(cd $(ADA_GEN_SUBDIR)/bldtools/einfo; gnatmake -q xeinfo ; ./xeinfo einfo.h )\n+\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/einfo/einfo.h $(ADA_GEN_SUBDIR)/einfo.h\n \n $(ADA_GEN_SUBDIR)/sinfo.h : $(ADA_GEN_SUBDIR)/sinfo.ads $(ADA_GEN_SUBDIR)/sinfo.adb $(ADA_GEN_SUBDIR)/xsinfo.adb $(ADA_GEN_SUBDIR)/csinfo.adb\n \t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/sinfo\n \t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/sinfo/,$(notdir $^))\n \t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/sinfo\n-\t(cd $(ADA_GEN_SUBDIR)/bldtools/sinfo; gnatmake -q xsinfo ; ./xsinfo ../../sinfo.h )\n+\t(cd $(ADA_GEN_SUBDIR)/bldtools/sinfo; gnatmake -q xsinfo ; ./xsinfo sinfo.h )\n+\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/sinfo/sinfo.h $(ADA_GEN_SUBDIR)/sinfo.h\n \n $(ADA_GEN_SUBDIR)/snames.h $(ADA_GEN_SUBDIR)/snames.ads $(ADA_GEN_SUBDIR)/snames.adb : $(ADA_GEN_SUBDIR)/stamp-snames ; @true\n $(ADA_GEN_SUBDIR)/stamp-snames : $(ADA_GEN_SUBDIR)/snames.ads-tmpl $(ADA_GEN_SUBDIR)/snames.adb-tmpl $(ADA_GEN_SUBDIR)/snames.h-tmpl $(ADA_GEN_SUBDIR)/xsnamest.adb $(ADA_GEN_SUBDIR)/xutil.ads $(ADA_GEN_SUBDIR)/xutil.adb\n@@ -52,17 +56,47 @@ $(ADA_GEN_SUBDIR)/stamp-snames : $(ADA_GEN_SUBDIR)/snames.ads-tmpl $(ADA_GEN_SUB\n \t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/snamest/snames.nh $(ADA_GEN_SUBDIR)/snames.h\n \ttouch $(ADA_GEN_SUBDIR)/stamp-snames\n \n-$(ADA_GEN_SUBDIR)/nmake.adb : $(ADA_GEN_SUBDIR)/sinfo.ads $(ADA_GEN_SUBDIR)/nmake.adt $(ADA_GEN_SUBDIR)/xnmake.adb $(ADA_GEN_SUBDIR)/xutil.ads $(ADA_GEN_SUBDIR)/xutil.adb\n-\t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/nmake_b\n-\t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/nmake_b/,$(notdir $^))\n-\t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/nmake_b\n-\t(cd $(ADA_GEN_SUBDIR)/bldtools/nmake_b; gnatmake -q xnmake ; ./xnmake -b ../../nmake.adb )\n-\n-$(ADA_GEN_SUBDIR)/nmake.ads :  $(ADA_GEN_SUBDIR)/sinfo.ads $(ADA_GEN_SUBDIR)/nmake.adt $(ADA_GEN_SUBDIR)/xnmake.adb $(ADA_GEN_SUBDIR)/nmake.adb $(ADA_GEN_SUBDIR)/xutil.ads $(ADA_GEN_SUBDIR)/xutil.adb\n-\t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/nmake_s\n-\t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/nmake_s/,$(notdir $^))\n-\t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/nmake_s\n-\t(cd $(ADA_GEN_SUBDIR)/bldtools/nmake_s; gnatmake -q xnmake ; ./xnmake -s ../../nmake.ads )\n+$(ADA_GEN_SUBDIR)/nmake.adb $(ADA_GEN_SUBDIR)/nmake.ads: $(ADA_GEN_SUBDIR)/stamp-nmake ; @true\n+$(ADA_GEN_SUBDIR)/stamp-nmake: $(ADA_GEN_SUBDIR)/sinfo.ads $(ADA_GEN_SUBDIR)/nmake.adt $(ADA_GEN_SUBDIR)/xnmake.adb $(ADA_GEN_SUBDIR)/xutil.ads $(ADA_GEN_SUBDIR)/xutil.adb\n+\t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/nmake\n+\t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/nmake/,$(notdir $^))\n+\t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/nmake\n+\t(cd $(ADA_GEN_SUBDIR)/bldtools/nmake; gnatmake -q xnmake ; ./xnmake -b nmake.adb ; ./xnmake -s nmake.ads)\n+\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/nmake/nmake.ads $(ADA_GEN_SUBDIR)/nmake.ads\n+\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/nmake/nmake.adb $(ADA_GEN_SUBDIR)/nmake.adb\n+\ttouch $(ADA_GEN_SUBDIR)/stamp-nmake\n+\n+ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(subst -, ,$(host)))),)\n+OSCONS_CPP=../../../$(DECC) -E /comment=as_is -DNATIVE \\\n+             -DTARGET='\"\"$(target)\"\"' s-oscons-tmplt.c\n+\n+OSCONS_EXTRACT=../../../$(DECC) -DNATIVE \\\n+                 -DTARGET='\"\"$(target)\"\"' s-oscons-tmplt.c ; \\\n+  ld -o s-oscons-tmplt.exe s-oscons-tmplt.obj; \\\n+  ./s-oscons-tmplt.exe > s-oscons-tmplt.s\n+\n+else\n+# GCC_FOR_TARGET has paths relative to the gcc directory, so we need to adjust\n+# for running it from $(ADA_GEN_SUBDIR)/bldtools/oscons\n+OSCONS_CC=`echo \"$(GCC_FOR_TARGET)\" \\\n+  | sed -e 's^\\./xgcc^../../../xgcc^' -e 's^-B./^-B../../../^'`\n+OSCONS_CPP=$(OSCONS_CC) $(GNATLIBCFLAGS) -E -C \\\n+  -DTARGET=\\\"$(target)\\\" s-oscons-tmplt.c > s-oscons-tmplt.i\n+OSCONS_EXTRACT=$(OSCONS_CC) -S s-oscons-tmplt.i\n+endif\n+\n+$(ADA_GEN_SUBDIR)/s-oscons.ads : $(ADA_GEN_SUBDIR)/s-oscons-tmplt.c $(ADA_GEN_SUBDIR)/gsocket.h $(ADA_GEN_SUBDIR)/xoscons.adb $(ADA_GEN_SUBDIR)/xutil.ads $(ADA_GEN_SUBDIR)/xutil.adb\n+\t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/oscons\n+\t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/oscons/,$(notdir $^))\n+\t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/oscons\n+\t(cd $(ADA_GEN_SUBDIR)/bldtools/oscons ; gnatmake -q xoscons ; \\\n+\t\t$(RM) s-oscons-tmplt.i s-oscons-tmplt.s ; \\\n+\t\t$(OSCONS_CPP) ; \\\n+\t\t$(OSCONS_EXTRACT) ; \\\n+\t\t./xoscons ; \\\n+\t\t$(RM) ../../s-oscons.ads ; \\\n+\t\t$(MOVE_IF_CHANGE) s-oscons.ads $(ADA_GEN_SUBDIR)/s-oscons.ads ; \\\n+\t\t$(MOVE_IF_CHANGE) s-oscons.h $(ADA_GEN_SUBDIR)/s-oscons.h)\n \n $(ADA_GEN_SUBDIR)/sdefault.adb: $(ADA_GEN_SUBDIR)/stamp-sdefault ; @true\n $(ADA_GEN_SUBDIR)/stamp-sdefault : $(srcdir)/version.c Makefile"}, {"sha": "c331c339ec7f0da7e97f8457c9a8c8dc5114812d", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -2055,6 +2055,13 @@ package body Checks is\n \n          if Present (S) and then Get_TSS_Name (S) /= TSS_Null then\n             return;\n+\n+         --  Check certainly does not apply within the predicate function\n+         --  itself, else we have a infinite recursion.\n+\n+         elsif S = Predicate_Function (Typ) then\n+            return;\n+\n          else\n             Insert_Action (N,\n               Make_Predicate_Check (Typ, Duplicate_Subexpr (N)));"}, {"sha": "1f30582d07b834449d550a53891bde1c821516e4", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -1089,7 +1089,8 @@ package body Exp_Ch4 is\n                      Make_Access_To_Object_Definition (Loc,\n                        All_Present            => True,\n                        Null_Exclusion_Present => False,\n-                       Constant_Present       => False,\n+                       Constant_Present       =>\n+                         Is_Access_Constant (Etype (N)),\n                        Subtype_Indication     =>\n                          New_Reference_To (Etype (Exp), Loc)));\n "}, {"sha": "fe01e34331d9b87515e42f51a16ee6714fa281d3", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -2392,10 +2392,6 @@ package body Exp_Ch6 is\n          Expand_Put_Call_With_Symbol (Call_Node);\n       end if;\n \n-      --  Remove the dimensions of every parameters in call\n-\n-      Remove_Dimension_In_Call (N);\n-\n       --  Ignore if previous error\n \n       if Nkind (Call_Node) in N_Has_Etype"}, {"sha": "d5861b47807a77f51e907bb016f9ec3548f2097f", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -1068,6 +1068,32 @@ package body Exp_Disp is\n       --  to avoid the generation of spurious warnings under ZFP run-time.\n \n       Analyze_And_Resolve (Call_Node, Call_Typ, Suppress => All_Checks);\n+\n+      --  For functions returning interface types add implicit conversion to\n+      --  force the displacement of the pointer to the object to reference\n+      --  the corresponding secondary dispatch table. This is needed to\n+      --  handle well nested calls through secondary dispatch tables\n+      --  (for example Obj.Prim1.Prim2).\n+\n+      if Is_Interface (Res_Typ) then\n+         Rewrite (Call_Node,\n+           Make_Type_Conversion (Loc,\n+             Subtype_Mark => New_Occurrence_Of (Res_Typ, Loc),\n+             Expression => Relocate_Node (Call_Node)));\n+         Set_Etype (Call_Node, Res_Typ);\n+         Expand_Interface_Conversion (Call_Node, Is_Static => False);\n+         Force_Evaluation (Call_Node);\n+\n+         pragma Assert (Nkind (Call_Node) = N_Explicit_Dereference\n+           and then Nkind (Prefix (Call_Node)) = N_Identifier\n+           and then Nkind (Parent (Entity (Prefix (Call_Node))))\n+                             = N_Object_Declaration);\n+         Set_Assignment_OK (Parent (Entity (Prefix (Call_Node))));\n+\n+         if Nkind (Parent (Call_Node)) = N_Object_Declaration then\n+            Set_Assignment_OK (Parent (Call_Node));\n+         end if;\n+      end if;\n    end Expand_Dispatching_Call;\n \n    ---------------------------------"}, {"sha": "8ee2d0ad9a27421d9167d69998866ea70cdcd12b", "filename": "gcc/ada/g-socket.ads", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.ads?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2011, AdaCore                     --\n+--                     Copyright (C) 2001-2012, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1155,10 +1155,7 @@ private\n \n    type Fd_Set is\n      new System.Storage_Elements.Storage_Array (1 .. SOSC.SIZEOF_fd_set);\n-   for Fd_Set'Alignment use Interfaces.C.long'Alignment;\n-   --  Set conservative alignment so that our Fd_Sets are always adequately\n-   --  aligned for the underlying data type (which is implementation defined\n-   --  and may be an array of C long integers).\n+   for Fd_Set'Alignment use SOSC.ALIGNOF_fd_set;\n \n    type Fd_Set_Access is access all Fd_Set;\n    pragma Convention (C, Fd_Set_Access);"}, {"sha": "2ee17554d56ad798f6d366d8e9578c30f042f542", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -18876,6 +18876,9 @@ and will attempt to generate corresponding Ada comments.\n If you want to generate a single Ada file and not the transitive closure, you\n can use instead the @option{-fdump-ada-spec-slim} switch.\n \n+You can optionally specify a parent unit, of which all generated units will\n+be children, using @code{-fada-spec-parent=}@var{unit}.\n+\n Note that we recommend when possible to use the @command{g++} driver to\n generate bindings, even for most C headers, since this will in general\n generate better Ada specs. For generating bindings for C++ headers, it is\n@@ -19059,6 +19062,11 @@ all header files that these headers depend upon).\n Generate Ada spec files for the header files specified on the command line\n only.\n \n+@item -fada-spec-parent=@var{unit}\n+@cindex -fada-spec-parent (@command{gcc})\n+Specifies that all files generated by @option{-fdump-ada-spec-slim} are\n+to be child units of the specified parent unit.\n+\n @item -C\n @cindex @option{-C} (@command{gcc})\n Extract comments from headers and generate Ada comments in the Ada spec files."}, {"sha": "fa0c6e0356dac4311c12dbd0892ec891ed8446aa", "filename": "gcc/ada/s-dimmks.ads", "status": "modified", "additions": 106, "deletions": 78, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fs-dimmks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fs-dimmks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-dimmks.ads?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -103,6 +103,9 @@ package System.Dim.Mks is\n \n    --  SI Base units\n \n+   pragma Warnings (Off);\n+   --  Turn off the all the dimension warnings\n+\n    m   : constant Length                    := 1.0;\n    kg  : constant Mass                      := 1.0;\n    s   : constant Time                      := 1.0;\n@@ -111,98 +114,134 @@ package System.Dim.Mks is\n    mol : constant Amount_Of_Substance       := 1.0;\n    cd  : constant Luminous_Intensity        := 1.0;\n \n+   pragma Warnings (On);\n+\n    --  SI Derived dimensioned subtypes\n \n+   subtype Absorbed_Dose is Mks_Type\n+     with\n+      Dimension => (Symbol => \"Gy\",\n+        Meter =>  2,\n+        Second => -2,\n+        others => 0);\n+\n    subtype Angle is Mks_Type\n      with\n       Dimension => (Symbol => \"rad\",\n         others => 0);\n \n-   subtype Solid_Angle is Mks_Type\n+   subtype Area is Mks_Type\n      with\n-      Dimension => (Symbol => \"sr\",\n+      Dimension => (\n+        Meter =>  2,\n         others => 0);\n \n-   subtype Frequency is Mks_Type\n+   subtype Catalytic_Activity is Mks_Type\n      with\n-      Dimension => (Symbol => \"Hz\",\n+      Dimension => (Symbol => \"kat\",\n         Second => -1,\n+        Mole =>   1,\n         others => 0);\n \n-   subtype Force is Mks_Type\n+   subtype Celsius_Temperature is Mks_Type\n      with\n-      Dimension => (Symbol => 'N',\n-        Meter =>    1,\n-        Kilogram => 1,\n-        Second =>  -2,\n+      Dimension => (Symbol => \"\u00b0C\",\n+        Kelvin => 1,\n+        others => 0);\n+\n+   subtype Electric_Capacitance is Mks_Type\n+     with\n+      Dimension => (Symbol => 'F',\n+        Meter =>    -2,\n+        Kilogram => -1,\n+        Second =>   4,\n+        Ampere =>   2,\n         others =>   0);\n \n-   subtype Pressure is Mks_Type\n+   subtype Electric_Charge is Mks_Type\n      with\n-      Dimension => (Symbol => \"Pa\",\n-        Meter =>    -1,\n-        Kilogram => 1,\n-        Second =>   -2,\n+      Dimension => (Symbol => 'C',\n+        Second => 1,\n+        Ampere => 1,\n+        others => 0);\n+\n+   subtype Electric_Conductance is Mks_Type\n+     with\n+      Dimension => (Symbol => 'S',\n+        Meter =>    -2,\n+        Kilogram => -1,\n+        Second =>   3,\n+        Ampere =>   2,\n         others =>   0);\n \n-   subtype Energy is Mks_Type\n+   subtype Electric_Potential_Difference is Mks_Type\n      with\n-      Dimension => (Symbol => 'J',\n+      Dimension => (Symbol => 'V',\n         Meter =>    2,\n         Kilogram => 1,\n-        Second =>   -2,\n+        Second =>   -3,\n+        Ampere =>   -1,\n         others =>   0);\n \n-   subtype Power is Mks_Type\n+   subtype Electric_Resistance is Mks_Type\n      with\n-      Dimension => (Symbol => 'W',\n+      Dimension => (Symbol => \"\u03a9\",\n         Meter =>    2,\n         Kilogram => 1,\n         Second =>   -3,\n+        Ampere =>   -2,\n         others =>   0);\n \n-   subtype Electric_Charge is Mks_Type\n+   subtype Energy is Mks_Type\n      with\n-      Dimension => (Symbol => 'C',\n-        Second => 1,\n-        Ampere => 1,\n+      Dimension => (Symbol => 'J',\n+        Meter =>    2,\n+        Kilogram => 1,\n+        Second =>   -2,\n+        others =>   0);\n+\n+   subtype Equivalent_Dose is Mks_Type\n+     with\n+      Dimension => (Symbol => \"Sv\",\n+        Meter =>  2,\n+        Second => -2,\n         others => 0);\n \n-   subtype Electric_Potential_Difference is Mks_Type\n+   subtype Force is Mks_Type\n      with\n-      Dimension => (Symbol => 'V',\n-        Meter =>    2,\n+      Dimension => (Symbol => 'N',\n+        Meter =>    1,\n         Kilogram => 1,\n-        Second =>   -3,\n-        Ampere =>   -1,\n+        Second =>  -2,\n         others =>   0);\n \n-   subtype Electric_Capacitance is Mks_Type\n+   subtype Frequency is Mks_Type\n      with\n-      Dimension => (Symbol => 'F',\n-        Meter =>    -2,\n-        Kilogram => -1,\n-        Second =>   4,\n-        Ampere =>   2,\n-        others =>   0);\n+      Dimension => (Symbol => \"Hz\",\n+        Second => -1,\n+        others => 0);\n \n-   subtype Electric_Resistance is Mks_Type\n+   subtype Illuminance is Mks_Type\n      with\n-      Dimension => (Symbol => \"\u03a9\",\n+      Dimension => (Symbol => \"lx\",\n+        Meter =>   -2,\n+        Candela => 1,\n+        others =>  0);\n+\n+   subtype Inductance is Mks_Type\n+     with\n+      Dimension => (Symbol => 'H',\n         Meter =>    2,\n         Kilogram => 1,\n-        Second =>   -3,\n+        Second =>   -2,\n         Ampere =>   -2,\n         others =>   0);\n \n-   subtype Electric_Conductance is Mks_Type\n+   subtype Luminous_Flux is Mks_Type\n      with\n-      Dimension => (Symbol => 'S',\n-        Meter =>    -2,\n-        Kilogram => -1,\n-        Second =>   3,\n-        Ampere =>   2,\n-        others =>   0);\n+      Dimension => (Symbol => \"lm\",\n+        Candela => 1,\n+        others =>  0);\n \n    subtype Magnetic_Flux is Mks_Type\n      with\n@@ -221,61 +260,49 @@ package System.Dim.Mks is\n         Ampere =>   -1,\n         others =>   0);\n \n-   subtype Inductance is Mks_Type\n+   subtype Power is Mks_Type\n      with\n-      Dimension => (Symbol => 'H',\n+      Dimension => (Symbol => 'W',\n         Meter =>    2,\n         Kilogram => 1,\n-        Second =>   -2,\n-        Ampere =>   -2,\n+        Second =>   -3,\n         others =>   0);\n \n-   subtype Celsius_Temperature is Mks_Type\n-     with\n-      Dimension => (Symbol => \"\u00b0C\",\n-        Kelvin => 1,\n-        others => 0);\n-\n-   subtype Luminous_Flux is Mks_Type\n-     with\n-      Dimension => (Symbol => \"lm\",\n-        Candela => 1,\n-        others =>  0);\n-\n-   subtype Illuminance is Mks_Type\n+   subtype Pressure is Mks_Type\n      with\n-      Dimension => (Symbol => \"lx\",\n-        Meter =>   -2,\n-        Candela => 1,\n-        others =>  0);\n+      Dimension => (Symbol => \"Pa\",\n+        Meter =>    -1,\n+        Kilogram => 1,\n+        Second =>   -2,\n+        others =>   0);\n \n    subtype Radioactivity is Mks_Type\n      with\n       Dimension => (Symbol => \"Bq\",\n         Second => -1,\n         others => 0);\n \n-   subtype Absorbed_Dose is Mks_Type\n+   subtype Solid_Angle is Mks_Type\n      with\n-      Dimension => (Symbol => \"Gy\",\n-        Meter =>  2,\n-        Second => -2,\n+      Dimension => (Symbol => \"sr\",\n         others => 0);\n \n-   subtype Equivalent_Dose is Mks_Type\n+   subtype Speed is Mks_Type\n      with\n-      Dimension => (Symbol => \"Sv\",\n-        Meter =>  2,\n-        Second => -2,\n+      Dimension => (\n+        Meter =>  1,\n+        Second => -1,\n         others => 0);\n \n-   subtype Catalytic_Activity is Mks_Type\n+   subtype Volume is Mks_Type\n      with\n-      Dimension => (Symbol => \"kat\",\n-        Second => -1,\n-        Mole =>   1,\n+      Dimension => (\n+        Meter =>  3,\n         others => 0);\n \n+   pragma Warnings (Off);\n+   --  Turn off the all the dimension warnings\n+\n    rad : constant Angle                         := 1.0;\n    sr  : constant Solid_Angle                   := 1.0;\n    Hz  : constant Frequency                     := 1.0;\n@@ -349,4 +376,5 @@ package System.Dim.Mks is\n    kA  : constant Electric_Current := 1.0E+03;  -- kilo\n    MeA : constant Electric_Current := 1.0E+06;  -- mega\n \n+   pragma Warnings (On);\n end System.Dim.Mks;"}, {"sha": "902341c5936a17c7a39f4f13e6411ecec10a43a6", "filename": "gcc/ada/s-dmotpr.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fs-dmotpr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fs-dmotpr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-dmotpr.ads?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -38,6 +38,9 @@ package System.Dim.Mks.Other_Prefixes is\n \n    --  SI prefixes for Meter\n \n+   pragma Warnings (Off);\n+   --  Turn off the all the dimension warnings\n+\n    ym  : constant Length := 1.0E-24;  -- yocto\n    zm  : constant Length := 1.0E-21;  -- zepto\n    am  : constant Length := 1.0E-18;  -- atto\n@@ -165,4 +168,5 @@ package System.Dim.Mks.Other_Prefixes is\n    Zecd : constant Luminous_Intensity := 1.0E+21;  -- zetta\n    Yocd : constant Luminous_Intensity := 1.0E+24;  -- yotta\n \n+   pragma Warnings (On);\n end System.Dim.Mks.Other_Prefixes;"}, {"sha": "332c51322691915f0c8c5e3ec80dcb2e04ae1370", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -1292,7 +1292,7 @@ CNS(MAX_tv_sec, \"\")\n }\n /*\n \n-   --  Sizes of various data types\n+   --  Sizes and alignments of various data types\n */\n \n #define SIZEOF_sockaddr_in (sizeof (struct sockaddr_in))\n@@ -1306,6 +1306,9 @@ CND(SIZEOF_sockaddr_in6, \"struct sockaddr_in6\")\n \n #define SIZEOF_fd_set (sizeof (fd_set))\n CND(SIZEOF_fd_set, \"fd_set\");\n+#define ALIGNOF_fd_set (__alignof__ (fd_set))\n+CND(ALIGNOF_fd_set, \"\");\n+\n CND(FD_SETSIZE, \"Max fd value\");\n \n #define SIZEOF_struct_hostent (sizeof (struct hostent))"}, {"sha": "f0e90ee19e3576b0199a94d34ffe687654209512", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -47,6 +47,7 @@ with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n+with Sem_Dim;  use Sem_Dim;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n@@ -2549,6 +2550,10 @@ package body Sem_Aggr is\n              Duplicate_Subexpr (High_Bound (Aggregate_Bounds (N))));\n       end if;\n \n+      --  Check the dimensions of each component in the array aggregate.\n+\n+      Analyze_Dimension_Array_Aggregate (N, Component_Typ);\n+\n       return Success;\n    end Resolve_Array_Aggregate;\n \n@@ -3225,8 +3230,9 @@ package body Sem_Aggr is\n       -----------------------\n \n       procedure Resolve_Aggr_Expr (Expr : Node_Id; Component : Node_Id) is\n-         New_C     : Entity_Id := Component;\n          Expr_Type : Entity_Id := Empty;\n+         New_C     : Entity_Id := Component;\n+         New_Expr  : Node_Id;\n \n          function Has_Expansion_Delayed (Expr : Node_Id) return Boolean;\n          --  If the expression is an aggregate (possibly qualified) then its\n@@ -3380,10 +3386,17 @@ package body Sem_Aggr is\n          end if;\n \n          if Relocate then\n-            Add_Association (New_C, Relocate_Node (Expr), New_Assoc_List);\n+            New_Expr := Relocate_Node (Expr);\n+\n+            --  Since New_Expr is not gonna be analyzed later on, we need to\n+            --  propagate here the dimensions form Expr to New_Expr.\n+\n+            Move_Dimensions (Expr, New_Expr);\n          else\n-            Add_Association (New_C, Expr, New_Assoc_List);\n+            New_Expr := Expr;\n          end if;\n+\n+         Add_Association (New_C, New_Expr, New_Assoc_List);\n       end Resolve_Aggr_Expr;\n \n    --  Start of processing for Resolve_Record_Aggregate\n@@ -4490,6 +4503,10 @@ package body Sem_Aggr is\n \n          Rewrite (N, New_Aggregate);\n       end Step_8;\n+\n+      --  Check the dimensions of the components in the record aggregate.\n+\n+      Analyze_Dimension_Extension_Or_Record_Aggregate (N);\n    end Resolve_Record_Aggregate;\n \n    -----------------------------"}, {"sha": "cdb39fb35bed8a2316858c92e52acae4096970ce", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -3450,6 +3450,10 @@ package body Sem_Ch6 is\n          Push_Scope (Designator);\n          Process_Formals (Formals, N);\n \n+         --  Check dimensions in N for formals with default expression\n+\n+         Analyze_Dimension_Formals (N, Formals);\n+\n          --  Ada 2005 (AI-345): If this is an overriding operation of an\n          --  inherited interface operation, and the controlling type is\n          --  a synchronized type, replace the type with its corresponding"}, {"sha": "53ff3274e8ba63d2ab57843ef1a6bc151884f35b", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -577,6 +577,8 @@ package body Sem_Ch8 is\n       else\n          Find_Expanded_Name (N);\n       end if;\n+\n+      Analyze_Dimension (N);\n    end Analyze_Expanded_Name;\n \n    ---------------------------------------\n@@ -6153,6 +6155,8 @@ package body Sem_Ch8 is\n \n          Analyze_Selected_Component (N);\n       end if;\n+\n+      Analyze_Dimension (N);\n    end Find_Selected_Component;\n \n    ---------------"}, {"sha": "8a8b1957f29ee86b86bb9ee84a1feb4e6a8cc6fd", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 610, "deletions": 194, "changes": 804, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -36,7 +36,9 @@ with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n+with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n@@ -190,6 +192,7 @@ package body Sem_Dim is\n \n    OK_For_Dimension : constant array (Node_Kind) of Boolean :=\n      (N_Attribute_Reference       => True,\n+      N_Expanded_Name             => True,\n       N_Defining_Identifier       => True,\n       N_Function_Call             => True,\n       N_Identifier                => True,\n@@ -236,14 +239,6 @@ package body Sem_Dim is\n    --  that the dimensions of the returned type and of the returned object\n    --  match.\n \n-   procedure Analyze_Dimension_Function_Call (N : Node_Id);\n-   --  Subroutine of Analyze_Dimension for function call. General case:\n-   --  propagate the dimensions from the returned type to N. Elementary\n-   --  function case (Ada.Numerics.Generic_Elementary_Functions): If N\n-   --  is a Sqrt call, then evaluate the resulting dimensions as half the\n-   --  dimensions of the parameter. Otherwise, verify that each parameters\n-   --  are dimensionless.\n-\n    procedure Analyze_Dimension_Has_Etype (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for a subset of N_Has_Etype denoted by\n    --  the list below:\n@@ -292,9 +287,17 @@ package body Sem_Dim is\n    function Dimensions_Of (N : Node_Id) return Dimension_Type;\n    --  Return the dimension vector of node N\n \n-   function Dimensions_Msg_Of (N : Node_Id) return String;\n-   --  Given a node, return \"has dimension\" followed by the dimension symbols\n-   --  of N or \"is dimensionless\" if N is dimensionless.\n+   function Dimensions_Msg_Of\n+      (N                  : Node_Id;\n+       Description_Needed : Boolean := False) return String;\n+   --  Given a node N, return the dimension symbols of N, preceded by \"has\n+   --  dimension\" if Description_Needed. if N is dimensionless, return \"[]\", or\n+   --  \"is dimensionless\" if Description_Needed.\n+\n+   procedure Dim_Warning_For_Numeric_Literal (N : Node_Id; Typ : Entity_Id);\n+   --  Issue a warning on the given numeric literal N to indicate the\n+   --  compilateur made the assumption that the literal is not dimensionless\n+   --  but has the dimension of Typ.\n \n    procedure Eval_Op_Expon_With_Rational_Exponent\n      (N              : Node_Id;\n@@ -304,6 +307,9 @@ package body Sem_Dim is\n    function Exists (Dim : Dimension_Type) return Boolean;\n    --  Returns True iff Dim does not denote the null dimension\n \n+   function Exists (Str : String_Id) return Boolean;\n+   --  Returns True iff Str does not denote No_String\n+\n    function Exists (Sys : System_Type) return Boolean;\n    --  Returns True iff Sys does not denote the null system\n \n@@ -330,9 +336,6 @@ package body Sem_Dim is\n    function Is_Invalid (Position : Dimension_Position) return Boolean;\n    --  Return True if Pos denotes the invalid position\n \n-   procedure Move_Dimensions (From : Node_Id; To : Node_Id);\n-   --  Copy dimension vector of From to To, delete dimension vector of From\n-\n    procedure Remove_Dimensions (N : Node_Id);\n    --  Remove the dimension vector of node N\n \n@@ -342,6 +345,10 @@ package body Sem_Dim is\n    procedure Set_Symbol (E : Entity_Id; Val : String_Id);\n    --  Associate a symbol representation of a dimension vector with a subtype\n \n+   function String_From_Numeric_Literal (N : Node_Id) return String_Id;\n+   --  Return the string that corresponds to the numeric litteral N as it\n+   --  appears in the source.\n+\n    function Symbol_Of (E : Entity_Id) return String_Id;\n    --  E denotes a subtype with a dimension. Return the symbol representation\n    --  of the dimension vector.\n@@ -1122,14 +1129,16 @@ package body Sem_Dim is\n \n    procedure Analyze_Dimension (N : Node_Id) is\n    begin\n-      --  Aspect is an Ada 2012 feature\n+      --  Aspect is an Ada 2012 feature. Note that there is no need to check\n+      --  dimensions for nodes that don't come from source.\n \n-      if Ada_Version < Ada_2012 then\n+      if Ada_Version < Ada_2012\n+        or else not Comes_From_Source (N)\n+      then\n          return;\n       end if;\n \n       case Nkind (N) is\n-\n          when N_Assignment_Statement =>\n             Analyze_Dimension_Assignment_Statement (N);\n \n@@ -1142,10 +1151,8 @@ package body Sem_Dim is\n          when N_Extended_Return_Statement =>\n             Analyze_Dimension_Extended_Return_Statement (N);\n \n-         when N_Function_Call =>\n-            Analyze_Dimension_Function_Call (N);\n-\n          when N_Attribute_Reference       |\n+              N_Expanded_Name             |\n               N_Identifier                |\n               N_Indexed_Component         |\n               N_Qualified_Expression      |\n@@ -1177,6 +1184,95 @@ package body Sem_Dim is\n       end case;\n    end Analyze_Dimension;\n \n+   ---------------------------------------\n+   -- Analyze_Dimension_Array_Aggregate --\n+   ---------------------------------------\n+\n+   procedure Analyze_Dimension_Array_Aggregate\n+     (N        : Node_Id;\n+      Comp_Typ : Entity_Id)\n+   is\n+      Comp_Ass         : constant List_Id        := Component_Associations (N);\n+      Dims_Of_Comp_Typ : constant Dimension_Type := Dimensions_Of (Comp_Typ);\n+      Exps             : constant List_Id        := Expressions (N);\n+\n+      Comp : Node_Id;\n+      Expr : Node_Id;\n+\n+      Error_Detected : Boolean := False;\n+      --  This flag is used in order to indicate if an error has been detected\n+      --  so far by the compiler in this routine.\n+\n+   begin\n+      --  Aspect is an Ada 2012 feature. Nothing to do here if the component\n+      --  base type is not a dimensioned type.\n+\n+      --  Note that here the original node must come from source since the\n+      --  original array aggregate may not have been entirely decorated.\n+\n+      if Ada_Version < Ada_2012\n+        or else not Comes_From_Source (Original_Node (N))\n+        or else not Has_Dimension_System (Base_Type (Comp_Typ))\n+      then\n+         return;\n+      end if;\n+\n+      --  Check whether there is any positional component association\n+\n+      if Is_Empty_List (Exps) then\n+         Comp := First (Comp_Ass);\n+      else\n+         Comp := First (Exps);\n+      end if;\n+\n+      while Present (Comp) loop\n+         --  Get the expression from the component\n+\n+         if Nkind (Comp) = N_Component_Association then\n+            Expr := Expression (Comp);\n+         else\n+            Expr := Comp;\n+         end if;\n+\n+         --  Issue an error if the dimensions of the component type and the\n+         --  dimensions of the component mismatch.\n+\n+         --  Note that we must ensure the expression has been fully analyzed\n+         --  since it may not be decorated at this point. We also don't want to\n+         --  issue the same error message multiple times on the same expression\n+         --  (may happen when an aggregate is converted into a positional\n+         --  aggregate).\n+\n+         if Comes_From_Source (Original_Node (Expr))\n+           and then Present (Etype (Expr))\n+           and then Dimensions_Of (Expr) /= Dims_Of_Comp_Typ\n+           and then Sloc (Comp) /= Sloc (Prev (Comp))\n+         then\n+            --  Check if an error has already been encountered so far\n+\n+            if not Error_Detected then\n+               Error_Msg_N (\"dimensions mismatch in array aggregate\", N);\n+               Error_Detected := True;\n+            end if;\n+\n+            Error_Msg_N (\"\\expected dimension \" &\n+                         Dimensions_Msg_Of (Comp_Typ) & \", found \" &\n+                         Dimensions_Msg_Of (Expr),\n+                         Expr);\n+         end if;\n+\n+         --  Look at the named components right after the positional components\n+\n+         if not Present (Next (Comp))\n+           and then List_Containing (Comp) = Exps\n+         then\n+            Comp := First (Comp_Ass);\n+         else\n+            Next (Comp);\n+         end if;\n+      end loop;\n+   end Analyze_Dimension_Array_Aggregate;\n+\n    --------------------------------------------\n    -- Analyze_Dimension_Assignment_Statement --\n    --------------------------------------------\n@@ -1205,8 +1301,8 @@ package body Sem_Dim is\n       is\n       begin\n          Error_Msg_N (\"dimensions mismatch in assignment\", N);\n-         Error_Msg_N (\"\\left-hand side \" & Dimensions_Msg_Of (Lhs), N);\n-         Error_Msg_N (\"\\right-hand side \" & Dimensions_Msg_Of (Rhs), N);\n+         Error_Msg_N (\"\\left-hand side \" & Dimensions_Msg_Of (Lhs, True), N);\n+         Error_Msg_N (\"\\right-hand side \" & Dimensions_Msg_Of (Rhs, True), N);\n       end Error_Dim_Msg_For_Assignment_Statement;\n \n    --  Start of processing for Analyze_Dimension_Assignment\n@@ -1241,8 +1337,8 @@ package body Sem_Dim is\n                        \"dimensions\",\n                        N,\n                        Entity (N));\n-         Error_Msg_N (\"\\left operand \" & Dimensions_Msg_Of (L), N);\n-         Error_Msg_N (\"\\right operand \" & Dimensions_Msg_Of (R), N);\n+         Error_Msg_N (\"\\left operand \" & Dimensions_Msg_Of (L, True), N);\n+         Error_Msg_N (\"\\right operand \" & Dimensions_Msg_Of (R, True), N);\n       end Error_Dim_Msg_For_Binary_Op;\n \n    --  Start of processing for Analyze_Dimension_Binary_Op\n@@ -1390,6 +1486,174 @@ package body Sem_Dim is\n       end if;\n    end Analyze_Dimension_Binary_Op;\n \n+   ----------------------------\n+   -- Analyze_Dimension_Call --\n+   ----------------------------\n+\n+   procedure Analyze_Dimension_Call (N : Node_Id; Nam : Entity_Id) is\n+      Actuals        : constant List_Id := Parameter_Associations (N);\n+      Actual         : Node_Id;\n+      Dims_Of_Formal : Dimension_Type;\n+      Formal         : Node_Id;\n+      Formal_Typ     : Entity_Id;\n+\n+      Error_Detected : Boolean := False;\n+      --  This flag is used in order to indicate if an error has been detected\n+      --  so far by the compiler in this routine.\n+\n+   begin\n+      --  Aspect is an Ada 2012 feature. Nothing to do here if the list of\n+      --  actuals is empty.Note that there is no need to check dimensions for\n+      --  calls that don't come from source.\n+\n+      if Ada_Version < Ada_2012\n+        or else not Comes_From_Source (N)\n+        or else Is_Empty_List (Actuals)\n+      then\n+         return;\n+      end if;\n+\n+      --  Special processing for elementary functions\n+\n+      --  For Sqrt call, the resulting dimensions equal to half the dimensions\n+      --  of the actual. For all other elementary calls, this routine check\n+      --  that every actual is dimensionless.\n+\n+      if Nkind (N) = N_Function_Call then\n+         Elementary_Function_Calls : declare\n+            Dims_Of_Call : Dimension_Type;\n+            Ent          : Entity_Id := Nam;\n+\n+            function Is_Elementary_Function_Entity\n+              (Sub_Id : Entity_Id) return Boolean;\n+            --  Given Sub_Id, the original subprogram entity, return True if\n+            --  call is to an elementary function\n+            --  (see Ada.Numerics.Generic_Elementary_Functions).\n+\n+            -----------------------------------\n+            -- Is_Elementary_Function_Entity --\n+            -----------------------------------\n+\n+            function Is_Elementary_Function_Entity\n+              (Sub_Id : Entity_Id) return Boolean\n+            is\n+               Loc : constant Source_Ptr := Sloc (Sub_Id);\n+\n+            begin\n+               --  Is function entity in\n+               --  Ada.Numerics.Generic_Elementary_Functions?\n+\n+               return\n+                 Loc > No_Location\n+                   and then\n+                     Is_RTU\n+                       (Cunit_Entity (Get_Source_Unit (Loc)),\n+                         Ada_Numerics_Generic_Elementary_Functions);\n+            end Is_Elementary_Function_Entity;\n+\n+         begin\n+            --  Get the original subprogram entity following the renaming chain\n+\n+            if Present (Alias (Ent)) then\n+               Ent := Alias (Ent);\n+            end if;\n+\n+            --  Check the call is an Elementary function call\n+\n+            if Is_Elementary_Function_Entity (Ent) then\n+               --  Sqrt function call case\n+\n+               if Chars (Ent) = Name_Sqrt then\n+                  Dims_Of_Call := Dimensions_Of (First_Actual (N));\n+\n+                  --  Eavluates the resulting dimensions (i.e. half the\n+                  --  dimensions of the actual).\n+\n+                  if Exists (Dims_Of_Call) then\n+                     for Position in Dims_Of_Call'Range loop\n+                        Dims_Of_Call (Position) :=\n+                          Dims_Of_Call (Position) *\n+                            Rational'(Numerator   => 1,\n+                                      Denominator => 2);\n+                     end loop;\n+\n+                     Set_Dimensions (N, Dims_Of_Call);\n+                  end if;\n+\n+               --  All other elementary functions case. Note that every actual\n+               --  here should be dimensionless.\n+\n+               else\n+                  Actual := First_Actual (N);\n+\n+                  while Present (Actual) loop\n+                     if Exists (Dimensions_Of (Actual)) then\n+                        --  Check if an error has already been encountered so\n+                        --  far.\n+\n+                        if not Error_Detected then\n+                           Error_Msg_NE (\"dimensions mismatch in call of&\",\n+                                         N, Name (N));\n+                           Error_Detected := True;\n+                        end if;\n+\n+                        Error_Msg_N (\"\\expected dimension [], found \" &\n+                                     Dimensions_Msg_Of (Actual),\n+                                     Actual);\n+                     end if;\n+\n+                     Next_Actual (Actual);\n+                  end loop;\n+               end if;\n+\n+               --  Nothing more to do for elementary functions\n+\n+               return;\n+            end if;\n+         end Elementary_Function_Calls;\n+      end if;\n+\n+      --  General case. Check, for each parameter, the dimensions of the actual\n+      --  and its corresponding formal match. Otherwise, complain.\n+\n+      Actual  := First_Actual (N);\n+      Formal  := First_Formal (Nam);\n+\n+      while Present (Formal) loop\n+         Formal_Typ     := Etype (Formal);\n+         Dims_Of_Formal := Dimensions_Of (Formal_Typ);\n+\n+         --  If the formal is not dimensionless, check dimensions of formal and\n+         --  actual match. Otherwise, complain.\n+\n+         if Exists (Dims_Of_Formal)\n+           and then Dimensions_Of (Actual) /= Dims_Of_Formal\n+         then\n+            --  Check if an error has already been encountered so far\n+\n+            if not Error_Detected then\n+               Error_Msg_NE (\"dimensions mismatch in& call\", N, Name (N));\n+               Error_Detected := True;\n+            end if;\n+\n+            Error_Msg_N (\"\\expected dimension \" &\n+                         Dimensions_Msg_Of (Formal_Typ) & \", found \" &\n+                         Dimensions_Msg_Of (Actual),\n+                         Actual);\n+         end if;\n+\n+         Next_Actual (Actual);\n+         Next_Formal (Formal);\n+      end loop;\n+\n+      --  For function calls, propagate the dimensions from the returned type\n+      --  to the function call.\n+\n+      if Nkind (N) = N_Function_Call then\n+         Analyze_Dimension_Has_Etype (N);\n+      end if;\n+   end Analyze_Dimension_Call;\n+\n    ---------------------------------------------\n    -- Analyze_Dimension_Component_Declaration --\n    ---------------------------------------------\n@@ -1418,21 +1682,38 @@ package body Sem_Dim is\n          Expr : Node_Id) is\n       begin\n          Error_Msg_N (\"dimensions mismatch in component declaration\", N);\n-         Error_Msg_N (\"\\component type \" & Dimensions_Msg_Of (Etyp), N);\n-         Error_Msg_N (\"\\component expression \" & Dimensions_Msg_Of (Expr), N);\n+         Error_Msg_N (\"\\expected dimension \" &\n+                      Dimensions_Msg_Of (Etyp) & \", found \" &\n+                      Dimensions_Msg_Of (Expr),\n+                      Expr);\n       end Error_Dim_Msg_For_Component_Declaration;\n \n    --  Start of processing for Analyze_Dimension_Component_Declaration\n \n    begin\n+      --  Expression is present\n+\n       if Present (Expr) then\n          Dims_Of_Expr := Dimensions_Of (Expr);\n \n-         --  Return an error if the dimension of the expression and the\n-         --  dimension of the type mismatch.\n+         --  Check dimensions match\n \n          if Dims_Of_Etyp /= Dims_Of_Expr then\n-            Error_Dim_Msg_For_Component_Declaration (N, Etyp, Expr);\n+            --  Numeric literal case. Issue a warning if the object type is not\n+            --  dimensionless to indicate the literal is treated as if its\n+            --  dimension matches the type dimension.\n+\n+            if Nkind_In (Original_Node (Expr),\n+                             N_Real_Literal,\n+                             N_Integer_Literal)\n+            then\n+               Dim_Warning_For_Numeric_Literal (Expr, Etyp);\n+\n+            --  Issue a dimension mismatch error for all other cases\n+\n+            else\n+               Error_Dim_Msg_For_Component_Declaration (N, Etyp, Expr);\n+            end if;\n          end if;\n \n          --  Removal of dimensions in expression\n@@ -1446,38 +1727,36 @@ package body Sem_Dim is\n    -------------------------------------------------\n \n    procedure Analyze_Dimension_Extended_Return_Statement (N : Node_Id) is\n-      Return_Ent            : constant Entity_Id :=\n-                                Return_Statement_Entity (N);\n-      Return_Etyp           : constant Entity_Id :=\n-                                Etype (Return_Applies_To (Return_Ent));\n-      Dims_Of_Return_Etyp   : constant Dimension_Type :=\n-                                Dimensions_Of (Return_Etyp);\n-      Return_Obj_Decls      : constant List_Id :=\n-                                Return_Object_Declarations (N);\n-      Dims_Of_Return_Obj_Id : Dimension_Type;\n-      Return_Obj_Decl       : Node_Id;\n-      Return_Obj_Id         : Entity_Id;\n+      Return_Ent       : constant Entity_Id := Return_Statement_Entity (N);\n+      Return_Etyp      : constant Entity_Id :=\n+                           Etype (Return_Applies_To (Return_Ent));\n+      Return_Obj_Decls : constant List_Id := Return_Object_Declarations (N);\n+      Return_Obj_Decl  : Node_Id;\n+      Return_Obj_Id    : Entity_Id;\n+      Return_Obj_Typ   : Entity_Id;\n \n       procedure Error_Dim_Msg_For_Extended_Return_Statement\n-        (N             : Node_Id;\n-         Return_Etyp   : Entity_Id;\n-         Return_Obj_Id : Entity_Id);\n+        (N              : Node_Id;\n+         Return_Etyp    : Entity_Id;\n+         Return_Obj_Typ : Entity_Id);\n       --  Error using Error_Msg_N at node N. Output the dimensions of the\n-      --  returned type Return_Etyp and the returned object Return_Obj_Id of N.\n+      --  returned type Return_Etyp and the returned object type Return_Obj_Typ\n+      --  of N.\n \n       -------------------------------------------------\n       -- Error_Dim_Msg_For_Extended_Return_Statement --\n       -------------------------------------------------\n \n       procedure Error_Dim_Msg_For_Extended_Return_Statement\n-        (N             : Node_Id;\n-         Return_Etyp   : Entity_Id;\n-         Return_Obj_Id : Entity_Id)\n+        (N              : Node_Id;\n+         Return_Etyp    : Entity_Id;\n+         Return_Obj_Typ : Entity_Id)\n       is\n       begin\n          Error_Msg_N (\"dimensions mismatch in extended return statement\", N);\n-         Error_Msg_N (\"\\returned type \" & Dimensions_Msg_Of (Return_Etyp), N);\n-         Error_Msg_N (\"\\returned object \" & Dimensions_Msg_Of (Return_Obj_Id),\n+         Error_Msg_N (\"\\expected dimension \" &\n+                      Dimensions_Msg_Of (Return_Etyp) & \", found \" &\n+                      Dimensions_Msg_Of (Return_Obj_Typ),\n                       N);\n       end Error_Dim_Msg_For_Extended_Return_Statement;\n \n@@ -1486,16 +1765,21 @@ package body Sem_Dim is\n    begin\n       if Present (Return_Obj_Decls) then\n          Return_Obj_Decl := First (Return_Obj_Decls);\n+\n          while Present (Return_Obj_Decl) loop\n             if Nkind (Return_Obj_Decl) = N_Object_Declaration then\n-               Return_Obj_Id := Defining_Identifier (Return_Obj_Decl);\n+               Return_Obj_Id  := Defining_Identifier (Return_Obj_Decl);\n \n                if Is_Return_Object (Return_Obj_Id) then\n-                  Dims_Of_Return_Obj_Id := Dimensions_Of (Return_Obj_Id);\n+                  Return_Obj_Typ := Etype (Return_Obj_Id);\n+\n+                  --  Issue an error message if dimensions mismatch\n \n-                  if Dims_Of_Return_Etyp /= Dims_Of_Return_Obj_Id then\n+                  if Dimensions_Of (Return_Etyp) /=\n+                       Dimensions_Of (Return_Obj_Typ)\n+                  then\n                      Error_Dim_Msg_For_Extended_Return_Statement\n-                       (N, Return_Etyp, Return_Obj_Id);\n+                       (N, Return_Etyp, Return_Obj_Typ);\n                      return;\n                   end if;\n                end if;\n@@ -1506,106 +1790,121 @@ package body Sem_Dim is\n       end if;\n    end Analyze_Dimension_Extended_Return_Statement;\n \n-   -------------------------------------\n-   -- Analyze_Dimension_Function_Call --\n-   -------------------------------------\n+   -----------------------------------------------------\n+   -- Analyze_Dimension_Extension_Or_Record_Aggregate --\n+   -----------------------------------------------------\n \n-   --  Propagate the dimensions from the returned type to the call node. Note\n-   --  that there is a special treatment for elementary function calls. Indeed\n-   --  for Sqrt call, the resulting dimensions equal to half the dimensions of\n-   --  the actual, and for other elementary calls, this routine check that\n-   --  every actuals are dimensionless.\n+   procedure Analyze_Dimension_Extension_Or_Record_Aggregate (N : Node_Id) is\n+      Comp     : Node_Id := First (Component_Associations (N));\n+      Comp_Id  : Entity_Id;\n+      Comp_Typ : Entity_Id;\n+      Expr     : Node_Id;\n \n-   procedure Analyze_Dimension_Function_Call (N : Node_Id) is\n-      Actuals        : constant List_Id := Parameter_Associations (N);\n-      Name_Call      : constant Node_Id := Name (N);\n-      Actual         : Node_Id;\n-      Dims_Of_Actual : Dimension_Type;\n-      Dims_Of_Call   : Dimension_Type;\n-      Ent            : Entity_Id;\n+      Error_Detected : Boolean := False;\n+      --  This flag is used in order to indicate if an error has been detected\n+      --  so far by the compiler in this routine.\n+\n+   begin\n+      --  Aspect is an Ada 2012 feature. Note that there is no need to check\n+      --  dimensions for aggregates that don't come from source.\n \n-      function Is_Elementary_Function_Entity (E : Entity_Id) return Boolean;\n-      --  Given E, the original subprogram entity, return True if call is to an\n-      --  elementary function (see Ada.Numerics.Generic_Elementary_Functions).\n+      if Ada_Version < Ada_2012\n+        or else not Comes_From_Source (N)\n+      then\n+         return;\n+      end if;\n \n-      -----------------------------------\n-      -- Is_Elementary_Function_Entity --\n-      -----------------------------------\n+      while Present (Comp) loop\n+         Comp_Id  := Entity (First (Choices (Comp)));\n+         Comp_Typ := Etype (Comp_Id);\n \n-      function Is_Elementary_Function_Entity (E : Entity_Id) return Boolean is\n-         Loc : constant Source_Ptr := Sloc (E);\n+         --  Check the component type is either a dimensioned type or a\n+         --  dimensioned subtype.\n \n-      begin\n-         --  Is function entity in Ada.Numerics.Generic_Elementary_Functions?\n+         if Has_Dimension_System (Base_Type (Comp_Typ)) then\n+            Expr := Expression (Comp);\n \n-         return\n-           Loc > No_Location\n-             and then\n-               Is_RTU\n-                (Cunit_Entity (Get_Source_Unit (Loc)),\n-                 Ada_Numerics_Generic_Elementary_Functions);\n-      end Is_Elementary_Function_Entity;\n+            --  Issue an error if the dimensions of the component type and the\n+            --  dimensions of the component mismatch.\n \n-   --  Start of processing for Analyze_Dimension_Function_Call\n+            if Dimensions_Of (Expr) /= Dimensions_Of (Comp_Typ) then\n+               --  Check if an error has already been encountered so far\n \n-   begin\n-      --  Look for elementary function call\n+               if not Error_Detected then\n+                  --  Extension aggregate case\n \n-      if Is_Entity_Name (Name_Call) then\n-         Ent := Entity (Name_Call);\n+                  if Nkind (N) = N_Extension_Aggregate then\n+                     Error_Msg_N (\"dimensions mismatch in extension aggregate\",\n+                                  N);\n \n-         --  Get the original subprogram entity following the renaming chain\n+                  --  Record aggregate case\n \n-         if Present (Alias (Ent)) then\n-            Ent := Alias (Ent);\n-         end if;\n+                  else\n+                     Error_Msg_N (\"dimensions mismatch in record aggregate\",\n+                                  N);\n+                  end if;\n \n-         --  Elementary function case\n+                  Error_Detected := True;\n+               end if;\n \n-         if Is_Elementary_Function_Entity (Ent) then\n+               Error_Msg_N (\"\\expected dimension \" &\n+                            Dimensions_Msg_Of (Comp_Typ) & \", found \" &\n+                            Dimensions_Msg_Of (Expr),\n+                            Comp);\n+            end if;\n+         end if;\n \n-         --  Sqrt function call case\n+         Next (Comp);\n+      end loop;\n+   end Analyze_Dimension_Extension_Or_Record_Aggregate;\n \n-            if Chars (Ent) = Name_Sqrt then\n-               Dims_Of_Call := Dimensions_Of (First (Actuals));\n+   -------------------------------\n+   -- Analyze_Dimension_Formals --\n+   -------------------------------\n \n-               if Exists (Dims_Of_Call) then\n-                  for Position in Dims_Of_Call'Range loop\n-                     Dims_Of_Call (Position) :=\n-                       Dims_Of_Call (Position) * Rational'(Numerator   => 1,\n-                                                           Denominator => 2);\n-                  end loop;\n+   procedure Analyze_Dimension_Formals (N : Node_Id; Formals : List_Id) is\n+      Dims_Of_Typ : Dimension_Type;\n+      Formal      : Node_Id;\n+      Typ         : Entity_Id;\n \n-                  Set_Dimensions (N, Dims_Of_Call);\n-               end if;\n+   begin\n+      --  Aspect is an Ada 2012 feature. Note that there is no need to check\n+      --  dimensions for sub specs that don't come from source.\n \n-            --  All other elementary functions case. Note that every actual\n-            --  here should be dimensionless.\n+      if Ada_Version < Ada_2012\n+        or else not Comes_From_Source (N)\n+      then\n+         return;\n+      end if;\n \n-            else\n-               Actual := First (Actuals);\n-               while Present (Actual) loop\n-                  Dims_Of_Actual := Dimensions_Of (Actual);\n-\n-                  if Exists (Dims_Of_Actual) then\n-                     Error_Msg_NE (\"parameter of& must be dimensionless\",\n-                                   Actual, Name_Call);\n-                     Error_Msg_N (\"\\parameter \" & Dimensions_Msg_Of (Actual),\n-                                  Actual);\n-                  end if;\n+      Formal := First (Formals);\n \n-                  Next (Actual);\n-               end loop;\n-            end if;\n+      while Present (Formal) loop\n+         Typ         := Parameter_Type (Formal);\n+         Dims_Of_Typ := Dimensions_Of  (Typ);\n \n-            return;\n-         end if;\n-      end if;\n+         if Exists (Dims_Of_Typ) then\n+            declare\n+               Expr : constant Node_Id := Expression (Formal);\n \n-      --  Other cases\n+            begin\n+               --  Issue a warning if Expr is a numeric literal and if its\n+               --  dimensions differ with the dimensions of the formal type.\n+\n+               if Present (Expr)\n+                 and then Dims_Of_Typ /= Dimensions_Of (Expr)\n+                 and then Nkind_In (Original_Node (Expr),\n+                                       N_Real_Literal,\n+                                       N_Integer_Literal)\n+               then\n+                  Dim_Warning_For_Numeric_Literal (Expr, Etype (Typ));\n+               end if;\n+            end;\n+         end if;\n \n-      Analyze_Dimension_Has_Etype (N);\n-   end Analyze_Dimension_Function_Call;\n+         Next (Formal);\n+      end loop;\n+   end Analyze_Dimension_Formals;\n \n    ---------------------------------\n    -- Analyze_Dimension_Has_Etype --\n@@ -1691,8 +1990,10 @@ package body Sem_Dim is\n          Expr : Node_Id) is\n       begin\n          Error_Msg_N (\"dimensions mismatch in object declaration\", N);\n-         Error_Msg_N (\"\\object type \" & Dimensions_Msg_Of (Etyp), N);\n-         Error_Msg_N (\"\\object expression \" & Dimensions_Msg_Of (Expr), N);\n+         Error_Msg_N (\"\\expected dimension \" &\n+                      Dimensions_Msg_Of (Etyp) & \", found \" &\n+                      Dimensions_Msg_Of (Expr),\n+                      Expr);\n       end Error_Dim_Msg_For_Object_Declaration;\n \n    --  Start of processing for Analyze_Dimension_Object_Declaration\n@@ -1703,22 +2004,29 @@ package body Sem_Dim is\n       if Present (Expr) then\n          Dim_Of_Expr := Dimensions_Of (Expr);\n \n-         --  Case when expression is not a literal and when dimensions of the\n-         --  expression and of the type mismatch\n+         --  Check dimensions match\n \n-         if not Nkind_In (Original_Node (Expr),\n+         if Dim_Of_Expr /= Dim_Of_Etyp then\n+            --  Numeric literal case. Issue a warning if the object type is not\n+            --  dimensionless to indicate the literal is treated as if its\n+            --  dimension matches the type dimension.\n+\n+            if Nkind_In (Original_Node (Expr),\n                              N_Real_Literal,\n                              N_Integer_Literal)\n-           and then Dim_Of_Expr /= Dim_Of_Etyp\n-         then\n-            --  Propagate the dimension from the expression to the object\n-            --  entity when the object is a constant whose type is a\n-            --  dimensioned type.\n+            then\n+               Dim_Warning_For_Numeric_Literal (Expr, Etyp);\n+\n+            --  Case where the object is a constant whose type is a dimensioned\n+            --  type.\n+\n+            elsif Constant_Present (N) and then not Exists (Dim_Of_Etyp) then\n+               --  Propagate the dimension from the expression to the object\n+               --  entity\n \n-            if Constant_Present (N) and then not Exists (Dim_Of_Etyp) then\n                Set_Dimensions (Id, Dim_Of_Expr);\n \n-            --  Otherwise, issue an error message\n+            --  For all other cases, issue an error message\n \n             else\n                Error_Dim_Msg_For_Object_Declaration (N, Etyp, Expr);\n@@ -1755,11 +2063,11 @@ package body Sem_Dim is\n          Sub_Mark     : Node_Id;\n          Renamed_Name : Node_Id) is\n       begin\n-         Error_Msg_N (\"dimensions mismatch in object renaming declaration\",\n-                      N);\n-         Error_Msg_N (\"\\type \" & Dimensions_Msg_Of (Sub_Mark), N);\n-         Error_Msg_N (\"\\renamed object \" & Dimensions_Msg_Of (Renamed_Name),\n-                      N);\n+         Error_Msg_N (\"dimensions mismatch in object renaming declaration\", N);\n+         Error_Msg_N (\"\\expected dimension \" &\n+                      Dimensions_Msg_Of (Sub_Mark) & \", found \" &\n+                      Dimensions_Msg_Of (Renamed_Name),\n+                      Renamed_Name);\n       end Error_Dim_Msg_For_Object_Renaming_Declaration;\n \n    --  Start of processing for Analyze_Dimension_Object_Renaming_Declaration\n@@ -1802,8 +2110,10 @@ package body Sem_Dim is\n       is\n       begin\n          Error_Msg_N (\"dimensions mismatch in return statement\", N);\n-         Error_Msg_N (\"\\returned type \" & Dimensions_Msg_Of (Return_Etyp), N);\n-         Error_Msg_N (\"\\returned expression \" & Dimensions_Msg_Of (Expr), N);\n+         Error_Msg_N (\"\\expected dimension \" &\n+                      Dimensions_Msg_Of (Return_Etyp) & \", found \" &\n+                      Dimensions_Msg_Of (Expr),\n+                      Expr);\n       end Error_Dim_Msg_For_Simple_Return_Statement;\n \n    --  Start of processing for Analyze_Dimension_Simple_Return_Statement\n@@ -1838,7 +2148,8 @@ package body Sem_Dim is\n             --  it cannot inherit a dimension from its subtype.\n \n             if Exists (Dims_Of_Id) then\n-               Error_Msg_N (\"subtype& already\" & Dimensions_Msg_Of (Id), N);\n+               Error_Msg_N (\"subtype& already\" & Dimensions_Msg_Of (Id, True),\n+                            N);\n             else\n                Set_Dimensions (Id, Dims_Of_Etyp);\n                Set_Symbol (Id, Symbol_Of (Etyp));\n@@ -2011,7 +2322,10 @@ package body Sem_Dim is\n    -- Dimensions_Msg_Of --\n    -----------------------\n \n-   function Dimensions_Msg_Of (N : Node_Id) return String is\n+   function Dimensions_Msg_Of\n+      (N                  : Node_Id;\n+       Description_Needed : Boolean := False) return String\n+   is\n       Dims_Of_N      : constant Dimension_Type := Dimensions_Of (N);\n       Dimensions_Msg : Name_Id;\n       System         : System_Type;\n@@ -2021,13 +2335,32 @@ package body Sem_Dim is\n \n       Name_Len := 0;\n \n+      --  N is not dimensionless\n+\n       if Exists (Dims_Of_N) then\n          System := System_Of (Base_Type (Etype (N)));\n-         Add_Str_To_Name_Buffer (\"has dimension \");\n+\n+         --  When Description_Needed, add to string \"has dimension \" before the\n+         --  actual dimension.\n+\n+         if Description_Needed then\n+            Add_Str_To_Name_Buffer (\"has dimension \");\n+         end if;\n+\n          Add_String_To_Name_Buffer\n            (From_Dim_To_Str_Of_Dim_Symbols (Dims_Of_N, System, True));\n-      else\n+\n+      --  N is dimensionless\n+\n+      --  When Description_Needed, return \"is dimensionless\"\n+\n+      elsif Description_Needed then\n          Add_Str_To_Name_Buffer (\"is dimensionless\");\n+\n+      --  Otherwise, return \"[]\"\n+\n+      else\n+         Add_Str_To_Name_Buffer (\"[]\");\n       end if;\n \n       Dimensions_Msg := Name_Find;\n@@ -2045,6 +2378,27 @@ package body Sem_Dim is\n       return Dimension_Table_Range (Key mod 511);\n    end Dimension_Table_Hash;\n \n+   -------------------------------------\n+   -- Dim_Warning_For_Numeric_Literal --\n+   -------------------------------------\n+\n+   procedure Dim_Warning_For_Numeric_Literal (N : Node_Id; Typ : Entity_Id) is\n+   begin\n+      --  Initialize name buffer\n+\n+      Name_Len := 0;\n+\n+      Add_String_To_Name_Buffer (String_From_Numeric_Literal (N));\n+\n+      --  Insert a blank between the literal and the symbol\n+      Add_Str_To_Name_Buffer    (\" \");\n+\n+      Add_String_To_Name_Buffer (Symbol_Of (Typ));\n+\n+      Error_Msg_Name_1 := Name_Find;\n+      Error_Msg_N (\"?assumed to be%%\", N);\n+   end Dim_Warning_For_Numeric_Literal;\n+\n    ----------------------------------------\n    -- Eval_Op_Expon_For_Dimensioned_Type --\n    ----------------------------------------\n@@ -2243,6 +2597,11 @@ package body Sem_Dim is\n       return Dim /= Null_Dimension;\n    end Exists;\n \n+   function Exists (Str : String_Id) return Boolean is\n+   begin\n+      return Str /= No_String;\n+   end Exists;\n+\n    function Exists (Sys : System_Type) return Boolean is\n    begin\n       return Sys /= Null_System;\n@@ -2311,7 +2670,7 @@ package body Sem_Dim is\n       Dims_Of_Actual : Dimension_Type;\n       Etyp           : Entity_Id;\n       New_Str_Lit    : Node_Id := Empty;\n-      System         : System_Type;\n+      Symbols        : String_Id;\n \n       Is_Put_Dim_Of : Boolean := False;\n       --  This flag is used in order to differentiate routines Put and\n@@ -2463,10 +2822,10 @@ package body Sem_Dim is\n             --  by the routine From_Dim_To_Str_Of_Dim_Symbols.\n \n             if Exists (Dims_Of_Actual) then\n-               System := System_Of (Base_Type (Etyp));\n                New_Str_Lit :=\n                  Make_String_Literal (Loc,\n-                   From_Dim_To_Str_Of_Dim_Symbols (Dims_Of_Actual, System));\n+                   From_Dim_To_Str_Of_Dim_Symbols\n+                     (Dims_Of_Actual, System_Of (Base_Type (Etyp))));\n \n             --  If dimensionless, the output is []\n \n@@ -2481,25 +2840,24 @@ package body Sem_Dim is\n             --  Add the symbol as a suffix of the value if the subtype has a\n             --  unit symbol or if the parameter is not dimensionless.\n \n-            if Symbol_Of (Etyp) /= No_String then\n+            if Exists (Symbol_Of (Etyp)) then\n+               Symbols := Symbol_Of (Etyp);\n+\n+            else\n+               Symbols := From_Dim_To_Str_Of_Unit_Symbols\n+                            (Dims_Of_Actual, System_Of (Base_Type (Etyp)));\n+            end if;\n+\n+            --  Check Symbols exists\n+\n+            if Exists (Symbols) then\n                Start_String;\n \n                --  Put a space between the value and the dimension\n \n                Store_String_Char (' ');\n-               Store_String_Chars (Symbol_Of (Etyp));\n+               Store_String_Chars (Symbols);\n                New_Str_Lit := Make_String_Literal (Loc, End_String);\n-\n-            --  Check that the item is not dimensionless\n-\n-            --  Create the new String_Literal with the new String_Id generated\n-            --  by the routine From_Dim_To_Str_Of_Unit_Symbols.\n-\n-            elsif Exists (Dims_Of_Actual) then\n-               System := System_Of (Base_Type (Etyp));\n-               New_Str_Lit :=\n-                 Make_String_Literal (Loc,\n-                   From_Dim_To_Str_Of_Unit_Symbols (Dims_Of_Actual, System));\n             end if;\n          end if;\n \n@@ -2672,13 +3030,15 @@ package body Sem_Dim is\n       First_Dim : Boolean := True;\n \n    begin\n-      --  Initialization of the new String_Id\n+      --  Return No_String if dimensionless\n \n-      Start_String;\n+      if not Exists (Dims) then\n+         return No_String;\n+      end if;\n \n-      --  Put a space between the value and the symbols\n+      --  Initialization of the new String_Id\n \n-      Store_String_Char (' ');\n+      Start_String;\n \n       for Position in Dimension_Type'Range loop\n          Dim_Power := Dims (Position);\n@@ -2823,6 +3183,10 @@ package body Sem_Dim is\n       Dims_Of_From : constant Dimension_Type := Dimensions_Of (From);\n \n    begin\n+      if Ada_Version < Ada_2012 then\n+         return;\n+      end if;\n+\n       --  Copy the dimension of 'From to 'To' and remove dimension of 'From'\n \n       if Exists (Dims_Of_From) then\n@@ -2861,26 +3225,6 @@ package body Sem_Dim is\n       end if;\n    end Remove_Dimensions;\n \n-   ------------------------------\n-   -- Remove_Dimension_In_Call --\n-   ------------------------------\n-\n-   procedure Remove_Dimension_In_Call (Call : Node_Id) is\n-      Actual : Node_Id;\n-\n-   begin\n-      if Ada_Version < Ada_2012 then\n-         return;\n-      end if;\n-\n-      Actual := First (Parameter_Associations (Call));\n-\n-      while Present (Actual) loop\n-         Remove_Dimensions (Actual);\n-         Next (Actual);\n-      end loop;\n-   end Remove_Dimension_In_Call;\n-\n    -----------------------------------\n    -- Remove_Dimension_In_Statement --\n    -----------------------------------\n@@ -2935,13 +3279,86 @@ package body Sem_Dim is\n       Symbol_Table.Set (E, Val);\n    end Set_Symbol;\n \n+   ---------------------------------\n+   -- String_From_Numeric_Literal --\n+   ---------------------------------\n+\n+   function String_From_Numeric_Literal (N : Node_Id) return String_Id is\n+      Loc     : constant Source_Ptr        := Sloc (N);\n+      Sbuffer : constant Source_Buffer_Ptr :=\n+                  Source_Text (Get_Source_File_Index (Loc));\n+      Src_Ptr : Source_Ptr := Loc;\n+      C       : Character  := Sbuffer (Src_Ptr);\n+         --  Current source program character\n+\n+      function Belong_To_Numeric_Literal (C : Character) return Boolean;\n+      --  Return True if C belongs to a numeric literal\n+\n+      -------------------------------\n+      -- Belong_To_Numeric_Literal --\n+      -------------------------------\n+\n+      function Belong_To_Numeric_Literal (C : Character) return Boolean is\n+      begin\n+         case C is\n+            when '0' .. '9' |\n+                 '_'        |\n+                 '.'        |\n+                 'e'        |\n+                 '#'        |\n+                 'A'        |\n+                 'B'        |\n+                 'C'        |\n+                 'D'        |\n+                 'E'        |\n+                 'F'        =>\n+               return True;\n+\n+            --  Make sure '+' or '-' is part of an exponent.\n+\n+            when '+'  | '-' =>\n+               declare\n+                  Prev_C : constant Character := Sbuffer (Src_Ptr - 1);\n+               begin\n+                  return Prev_C = 'e' or else Prev_C = 'E';\n+               end;\n+\n+            --  All other character doesn't belong to a numeric literal\n+\n+            when others     =>\n+               return False;\n+         end case;\n+      end Belong_To_Numeric_Literal;\n+\n+   --  Start of processing for String_From_Numeric_Literal\n+\n+   begin\n+      Start_String;\n+\n+      while Belong_To_Numeric_Literal (C) loop\n+         Store_String_Char (C);\n+         Src_Ptr := Src_Ptr + 1;\n+         C       := Sbuffer (Src_Ptr);\n+      end loop;\n+\n+      return End_String;\n+   end String_From_Numeric_Literal;\n+\n    ---------------\n    -- Symbol_Of --\n    ---------------\n \n    function Symbol_Of (E : Entity_Id) return String_Id is\n+      Subtype_Symbol : constant String_Id := Symbol_Table.Get (E);\n+\n    begin\n-      return Symbol_Table.Get (E);\n+      if Subtype_Symbol /= No_String then\n+         return Subtype_Symbol;\n+\n+      else\n+         return From_Dim_To_Str_Of_Unit_Symbols\n+                  (Dimensions_Of (E), System_Of (Base_Type (E)));\n+      end if;\n    end Symbol_Of;\n \n    -----------------------\n@@ -2971,5 +3388,4 @@ package body Sem_Dim is\n \n       return Null_System;\n    end System_Of;\n-\n end Sem_Dim;"}, {"sha": "86ada35f3674b45c21dfb25cd5f27b5271091f0b", "filename": "gcc/ada/sem_dim.ads", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_dim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_dim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.ads?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -108,16 +108,19 @@ package Sem_Dim is\n \n    procedure Analyze_Dimension (N : Node_Id);\n    --  N may denote any of the following contexts:\n+   --    * aggregate\n    --    * assignment statement\n    --    * attribute reference\n    --    * binary operator\n+   --    * call\n    --    * compontent declaration\n    --    * extended return statement\n-   --    * function call\n+   --    * expanded name\n    --    * identifier\n    --    * indexed component\n    --    * object declaration\n    --    * object renaming declaration\n+   --    * procedure call statement\n    --    * qualified expression\n    --    * selected component\n    --    * simple return statement\n@@ -129,6 +132,36 @@ package Sem_Dim is\n    --  Depending on the context, ensure that all expressions and entities\n    --  involved do not violate the rules of a system.\n \n+   procedure Analyze_Dimension_Array_Aggregate\n+     (N        : Node_Id;\n+      Comp_Typ : Entity_Id);\n+   --  Check, for each component of the array aggregate denoted by N, the\n+   --  dimensions of the component expression match the dimensions of the\n+   --  component type Comp_Typ.\n+\n+   procedure Analyze_Dimension_Call (N : Node_Id; Nam : Entity_Id);\n+   --  This routine is split in two steps. Note the second step applies only to\n+   --  function calls.\n+   --  Step 1. Dimension checking:\n+   --    * General case: check the dimensions of each actual parameter match\n+   --      the dimensions of the corresponding formal parameter.\n+   --    * Elementary function case: check each actual is dimensionless except\n+   --      for Sqrt call.\n+   --  Step 2. Dimension propagation (only for functions):\n+   --    * General case: propagate the dimensions from the returned type to the\n+   --      function call.\n+   --    * Sqrt case: the resulting dimensions equal to half the dimensions of\n+   --      the actual\n+\n+   procedure Analyze_Dimension_Extension_Or_Record_Aggregate (N : Node_Id);\n+   --  Check, for each component of the extension or record aggregate denoted\n+   --  by N, the dimensions of the component expression match the dimensions of\n+   --  the component type.\n+\n+   procedure Analyze_Dimension_Formals (N : Node_Id; Formals : List_Id);\n+   --  For sub spec N, issue a warning for each dimensioned formal with a\n+   --  literal default value in the list of formals Formals.\n+\n    procedure Eval_Op_Expon_For_Dimensioned_Type\n      (N    : Node_Id;\n       Btyp : Entity_Id);\n@@ -150,8 +183,8 @@ package Sem_Dim is\n    --  Return True if N is a package instantiation of System.Dim.Integer_IO or\n    --  of System.Dim.Float_IO.\n \n-   procedure Remove_Dimension_In_Call (Call : Node_Id);\n-   --  Remove the dimensions from all formal parameters of Call\n+   procedure Move_Dimensions (From : Node_Id; To : Node_Id);\n+   --  Copy dimension vector of From to To, delete dimension vector of From\n \n    procedure Remove_Dimension_In_Statement (Stmt : Node_Id);\n    --  Remove the dimensions associated with Stmt"}, {"sha": "6f9789e0ccb1b197bb0f2e393cad9826bf03c00e", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -3629,9 +3629,18 @@ package body Sem_Prag is\n                Generate_Reference (E, Id, 'i');\n             end if;\n \n-            --  Loop through the homonyms of the pragma argument's entity\n+            --  If the pragma comes from from an aspect, it only applies\n+            --   to the given entity, not its homonyms.\n+\n+            if From_Aspect_Specification (N) then\n+               return;\n+            end if;\n+\n+            --  Otherwise Loop through the homonyms of the pragma argument's\n+            --  entity, an apply convention to those in the current scope.\n \n             E1 := Ent;\n+\n             loop\n                E1 := Homonym (E1);\n                exit when No (E1) or else Scope (E1) /= Current_Scope;\n@@ -3659,10 +3668,6 @@ package body Sem_Prag is\n                      Generate_Reference (E1, Id, 'b');\n                   end if;\n                end if;\n-\n-               --  For aspect case, do NOT apply to homonyms\n-\n-               exit when From_Aspect_Specification (N);\n             end loop;\n          end if;\n       end Process_Convention;\n@@ -4528,10 +4533,12 @@ package body Sem_Prag is\n            or else Is_Generic_Subprogram (Def_Id)\n          then\n             --  If the name is overloaded, pragma applies to all of the denoted\n-            --  entities in the same declarative part.\n+            --  entities in the same declarative part, unless the pragma comes\n+            --  from an aspect specification.\n \n             Hom_Id := Def_Id;\n             while Present (Hom_Id) loop\n+\n                Def_Id := Get_Base_Subprogram (Hom_Id);\n \n                --  Ignore inherited subprograms because the pragma will apply\n@@ -4642,6 +4649,9 @@ package body Sem_Prag is\n \n                   exit;\n \n+               elsif From_Aspect_Specification (N) then\n+                  exit;\n+\n                else\n                   Hom_Id := Homonym (Hom_Id);\n                end if;"}, {"sha": "90b069da8b2726b1169998fc3f415acef07e7249", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=0929eaeb0128f2bcb9707ffd78bf0bca1a6b7aea", "patch": "@@ -5888,7 +5888,10 @@ package body Sem_Res is\n          end;\n       end if;\n \n-      Analyze_Dimension (N);\n+      --  Check the dimensions of the actuals in the call. For function calls,\n+      --  propagate the dimensions from the returned type to N.\n+\n+      Analyze_Dimension_Call (N, Nam);\n \n       --  All done, evaluate call and deal with elaboration issues\n "}]}