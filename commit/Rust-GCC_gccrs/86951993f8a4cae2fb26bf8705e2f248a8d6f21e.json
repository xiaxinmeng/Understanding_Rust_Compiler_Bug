{"sha": "86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY5NTE5OTNmOGE0Y2FlMmZiMjZiZjg3MDVlMmYyNDhhOGQ2ZjIxZQ==", "commit": {"author": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2011-11-06T14:55:48Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2011-11-06T14:55:48Z"}, "message": "Check in patch/merge from cxx-mem-model  Branch\n\nFrom-SVN: r181031", "tree": {"sha": "c0f499483e35c60c1b9f065f10a630e6fa4345bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0f499483e35c60c1b9f065f10a630e6fa4345bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/comments", "author": null, "committer": null, "parents": [{"sha": "a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8a058f6523f1e0f7b69ec1837848e55cf9f0856"}], "stats": {"total": 12959, "additions": 10102, "deletions": 2857}, "files": [{"sha": "1c2f1bcd86801f93366f0539c1cb53e875cddcd2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -1,3 +1,111 @@\n+2011-11-06  Andrew Macleod  <amacleod@redhat.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tMerged from cxx-mem-model.\n+\n+\t* cppbuiltin.c (define__GNUC__): Define __ATOMIC memory models\n+\t* coretypes.h (enum memmodel): New.  enumerated memory model type.\n+\t* Makefile.in (cppbuiltin.o) Add missing dependency on $(TREE_H)\n+\t* genopinit,c (optabs): Add atomic direct optab handlers.\n+\t* sync-builtins.def (BUILT_IN_ATOMIC_*): New builtins.\n+\t* builtin-types.def (BT_CONST_VOLATILE_PTR,\n+\tBT_FN_I{1,2,4,8,16}_CONST_VPTR_INT, BT_FN_VOID_VPTR_INT,\n+\tBT_FN_BOOL_VPTR_INT, BT_FN_BOOL_SIZE_CONST_VPTR,\n+\tBT_FN_I{1,2,4,8,16}_VPTR_I{1,2,4,8,16}_INT,\n+\tBT_FN_VOID_VPTR_I{1,2,4,8,16}_INT, BT_FN_VOID_SIZE_VPTR_PTR_INT,\n+\tBT_FN_VOID_SIZE_CONST_VPTR_PTR_INT, BT_FN_VOID_SIZE_VPTR_PTR_PTR_INT,\n+\tBT_FN_BOOL_VPTR_PTR_I{1,2,4,8,16}_BOOL_INT_INT): New builtin types.\n+\t* expr.h (expand_atomic_*): Add prototypes.\n+\t(expand_{bool,val}_compare_and_swap): Remove prototypes.\n+\t* c-typeck.c (build_function_call_vec): Don't reprocess __atomic\n+\tparameters.\n+\t* common.opt (Winvalid-memory-model): New warning flag.\n+\t(finline-atomics): New. Flag to disable atomic inlining.\n+\t* params.h (ALLOW_LOAD_DATA_RACES): New.\n+\t(ALLOW_PACKED_LOAD_DATA_RACES): New.\n+\t(ALLOW_PACKED_STORE_DATA_RACES): New.\n+\t* params.def (PARAM_ALLOW_LOAD_DATA_RACES): New.\n+\t(PARAM_ALLOW_PACKED_LOAD_DATA_RACES): New.\n+\t(PARAM_ALLOW_PACKED_STORE_DATA_RACES): New.\n+\t* builtins.c (is_builtin_name): Handle __atomic.\n+\t(get_memmodel): New.  Extract memory model.\n+\t(expand_expr_force_mode): New. Factor out common code for ensuring an\n+\tinteger argument is in the proper mode.\n+\t(expand_builtin_sync_operation): Remove ignore param.  Always call\n+\texpand_atomic_fetch_op instead of the old expanders.\n+\t(expand_builtin_compare_and_swap,\n+\texpand_builtin_sync_lock_test_and_set): Use expand_expr_force_mode,\n+\tcall atomic expanders instead of sync expanders.\n+\t(expand_builtin_sync_lock_release): Call atomic_store expander.\n+\t(expand_builtin_atomic_compare_exchange, expand_builtin_atomic_load,\n+\texpand_builtin_atomic_store, expand_builtin_atomic_fetch_op): New.\n+\t(expand_builtin_atomic_exchange): New.\n+\t(fold_builtin_atomic_always_lock_free,\n+\texpand_builtin_atomic_always_lock_free,\n+\tfold_builtin_atomic_is_lock_free, expand_builtin_atomic_is_lock_free):\n+\tNew.\n+\t(expand_builtin_mem_thread_fence, expand_builtin_atomic_thread_fence,\n+\texpand_builtin_atomic_signal_fence): New.\n+\t(expand_builtin_mem_signal_fence): New.\n+\t(expand_builtin): Add cases for BUILT_IN_ATOMIC_*.\n+\t(fold_builtin_2): Add cases for BUILT_IN_ATOMIC_{IS,ALWAYS}_LOCK_FREE.\n+\t* optabs.h (DOI_atomic_*): Define new atomics.\n+\t(atomic_*_optab): Define.\n+\t(can_compare_and_swap_p, expand_atomic_compare_and_swap): New\n+\tprototypes.\n+\t* optabs.c (expand_sync_operation, expand_sync_fetch_operation): Remove.\n+\t(expand_sync_lock_test_and_set): Remove.\n+\t(expand_atomic_load, expand_atomic_store): New.\n+\t(expand_atomic_exchange): New. \n+\t(expand_atomic_compare_and_swap): New.  Implements\n+\tatomic_compare_exchange via compare and swap.\n+\t(struct atomic_op_functions): Opcode table struct for fetch ops.\n+\t(get_atomic_op_for_code): New.  Return an opcode table entry.\n+\t(maybe_emit_op): New.  Try to emit a fetch op.\n+\t(expand_atomic_fetch_op): New.\n+\t(expand_val_compare_and_swap_1): Remove.\n+\t(expand_val_compare_and_swap, expand_bool_compare_and_swap): Remove.\n+\t(expand_atomic_compare_and_swap): Rename from\n+\texpand_atomic_compare_exchange.  Rewrite to return both success and\n+\toldval return values; expand via both atomic and sync optabs.\n+\t(can_compare_and_swap_p): New.\n+\t(expand_compare_and_swap_loop): Use expand_atomic_compare_and_swap.\n+\t(maybe_gen_insn): Handle 7 and 8 operands.\n+\t* omp-low.c (expand_omp_atomic_fetch_op): Don't test individual\n+\tfetch_op optabs, only test can_compare_and_swap_p.  Use __atomic\n+\tbuiltins instead of __sync builtins.\n+\t(expand_omp_atomic_pipeline): Use can_compare_and_swap_p.\n+\t* doc/extend.texi: Document __atomic built-in functions.\n+\t* doc/invoke.texi: Document data race parameters.\n+\t* doc/md.texi: Document atomic patterns.\n+\t* config/i386/i386.md (UNSPEC_MOVA): New.\n+\t(UNSPECV_CMPXCHG): Split into ...\n+\t(UNSPECV_CMPXCHG_1, UNSPECV_CMPXCHG_2,\n+\tUNSPECV_CMPXCHG_3, UNSPECV_CMPXCHG_4): New.\n+\t* config/i386/sync.md (ATOMIC): New mode iterator.\n+\t(atomic_load<ATOMIC>, atomic_store<ATOMIC>): New.\n+\t(atomic_loaddi_fpu, atomic_storedi_fpu, movdi_via_fpu): New.\n+\t(mem_thread_fence): Rename from memory_barrier.\n+\tHandle the added memory model parameter.\n+\t(mfence_nosse): Rename from memory_barrier_nosse.\n+\t(sync_compare_and_swap<CASMODE>): Split into ...\n+\t(atomic_compare_and_swap<SWI124>): this and ...\n+\t(atomic_compare_and_swap<CASMODE>): this.  Handle the new parameters.\n+\t(atomic_compare_and_swap_single<SWI>): Rename from\n+\tsync_compare_and_swap<SWI>; rewrite to use split unspecs.\n+\t(atomic_compare_and_swap_double<DCASMODE>): Rename from\n+\tsync_double_compare_and_swap<DCASMODE>; rewrite to use split unspecs.\n+\t(*atomic_compare_and_swap_doubledi_pic): Rename from\n+\tsync_double_compare_and_swapdi_pic; rewrite to use split unspecs.\n+\t(atomic_fetch_add<SWI>): Rename from sync_old_add<SWI>; add memory\n+\tmodel parameter.\n+\t(*atomic_fetch_add_cmp<SWI>): Similarly.\n+\t(atomic_add<SWI>, atomic<any_logic><SWI>): Similarly.\n+\t(atomic_sub<SWI>): Similarly.  Use x86_maybe_negate_const_int.\n+\t(sync_lock_test_and_set<SWI>): Merge with ...\n+\t(atomic_exchange<SWI>): ... this.\n+\n 2011-11-6  Richard Guenther  <rguenther@suse.de>\n \n \t* ipa-prop.c (ipa_modify_call_arguments): Re-compute"}, {"sha": "aebd0986b5fce08a64e04363b4fb3365f2fe80cc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -3978,7 +3978,7 @@ PREPROCESSOR_DEFINES = \\\n \n CFLAGS-cppbuiltin.o += $(PREPROCESSOR_DEFINES) -DBASEVER=$(BASEVER_s)\n cppbuiltin.o: cppbuiltin.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-\tcppbuiltin.h Makefile\n+\t$(TREE_H) cppbuiltin.h Makefile\n \n CFLAGS-cppdefault.o += $(PREPROCESSOR_DEFINES)\n cppdefault.o: cppdefault.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\"}, {"sha": "a6d0127dadc89c0bf09e522230f01eadb32d224e", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -95,6 +95,10 @@ DEF_PRIMITIVE_TYPE (BT_VOLATILE_PTR,\n \t\t    build_pointer_type\n \t\t     (build_qualified_type (void_type_node,\n \t\t\t\t\t    TYPE_QUAL_VOLATILE)))\n+DEF_PRIMITIVE_TYPE (BT_CONST_VOLATILE_PTR,\n+\t\t    build_pointer_type\n+\t\t     (build_qualified_type (void_type_node,\n+\t\t\t\t\t  TYPE_QUAL_VOLATILE|TYPE_QUAL_CONST)))\n DEF_PRIMITIVE_TYPE (BT_PTRMODE, (*lang_hooks.types.type_for_mode)(ptr_mode, 0))\n DEF_PRIMITIVE_TYPE (BT_INT_PTR, integer_ptr_type_node)\n DEF_PRIMITIVE_TYPE (BT_FLOAT_PTR, float_ptr_type_node)\n@@ -315,6 +319,20 @@ DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_LONGPTR_LONGPTR,\n \t\t     BT_BOOL, BT_PTR_LONG, BT_PTR_LONG)\n DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR,\n \t\t     BT_BOOL, BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I1_CONST_VPTR_INT, BT_I1, BT_CONST_VOLATILE_PTR,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I2_CONST_VPTR_INT, BT_I2, BT_CONST_VOLATILE_PTR,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I4_CONST_VPTR_INT, BT_I4, BT_CONST_VOLATILE_PTR,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I8_CONST_VPTR_INT, BT_I8, BT_CONST_VOLATILE_PTR,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I16_CONST_VPTR_INT, BT_I16, BT_CONST_VOLATILE_PTR,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_INT, BT_VOID, BT_VOLATILE_PTR, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_VPTR_INT, BT_BOOL, BT_VOLATILE_PTR, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_SIZE_CONST_VPTR, BT_BOOL, BT_SIZE,\n+\t\t     BT_CONST_VOLATILE_PTR)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR_PTR, BT_FN_VOID_PTR_PTR)\n \n@@ -383,6 +401,16 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_OMPFN_PTR_UINT, BT_VOID, BT_PTR_FN_VOID_PTR,\n \t\t     BT_PTR, BT_UINT)\n DEF_FUNCTION_TYPE_3 (BT_FN_PTR_CONST_PTR_INT_SIZE, BT_PTR,\n \t\t     BT_CONST_PTR, BT_INT, BT_SIZE)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I1_VPTR_I1_INT, BT_I1, BT_VOLATILE_PTR, BT_I1, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I2_VPTR_I2_INT, BT_I2, BT_VOLATILE_PTR, BT_I2, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I4_VPTR_I4_INT, BT_I4, BT_VOLATILE_PTR, BT_I4, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I8_VPTR_I8_INT, BT_I8, BT_VOLATILE_PTR, BT_I8, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I16_VPTR_I16_INT, BT_I16, BT_VOLATILE_PTR, BT_I16, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I1_INT, BT_VOID, BT_VOLATILE_PTR, BT_I1, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I2_INT, BT_VOID, BT_VOLATILE_PTR, BT_I2, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I4_INT, BT_VOID, BT_VOLATILE_PTR, BT_I4, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I8_INT, BT_VOID, BT_VOLATILE_PTR, BT_I8, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I16_INT, BT_VOID, BT_VOLATILE_PTR, BT_I16, BT_INT)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_FILEPTR,\n \t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_FILEPTR)\n@@ -402,13 +430,20 @@ DEF_FUNCTION_TYPE_4 (BT_FN_VOID_OMPFN_PTR_UINT_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_PTR_WORD_WORD_PTR,\n \t\t     BT_VOID, BT_PTR, BT_WORD, BT_WORD, BT_PTR)\n+DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_VPTR_PTR_INT, BT_VOID, BT_SIZE,\n+\t\t     BT_VOLATILE_PTR, BT_PTR, BT_INT)\n+DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_CONST_VPTR_PTR_INT, BT_VOID, BT_SIZE,\n+\t\t     BT_CONST_VOLATILE_PTR, BT_PTR, BT_INT)\n \n DEF_FUNCTION_TYPE_5 (BT_FN_INT_STRING_INT_SIZE_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_STRING, BT_INT, BT_SIZE, BT_CONST_STRING,\n \t\t     BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,\n \t\t     BT_BOOL, BT_LONG, BT_LONG, BT_LONG,\n \t\t     BT_PTR_LONG, BT_PTR_LONG)\n+DEF_FUNCTION_TYPE_5 (BT_FN_VOID_SIZE_VPTR_PTR_PTR_INT, BT_VOID, BT_SIZE,\n+\t\t     BT_VOLATILE_PTR, BT_PTR, BT_PTR, BT_INT)\n+\n \n DEF_FUNCTION_TYPE_6 (BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_STRING, BT_SIZE, BT_INT, BT_SIZE,\n@@ -422,6 +457,24 @@ DEF_FUNCTION_TYPE_6 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n \t\t     BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n \t\t     BT_ULONGLONG, BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I1_BOOL_INT_INT, \n+\t\t     BT_BOOL, BT_VOLATILE_PTR, BT_PTR, BT_I1, BT_BOOL, BT_INT,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I2_BOOL_INT_INT, \n+\t\t     BT_BOOL, BT_VOLATILE_PTR, BT_PTR, BT_I2, BT_BOOL, BT_INT,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I4_BOOL_INT_INT, \n+\t\t     BT_BOOL, BT_VOLATILE_PTR, BT_PTR, BT_I4, BT_BOOL, BT_INT,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I8_BOOL_INT_INT, \n+\t\t     BT_BOOL, BT_VOLATILE_PTR, BT_PTR, BT_I8, BT_BOOL, BT_INT,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I16_BOOL_INT_INT, \n+\t\t     BT_BOOL, BT_VOLATILE_PTR, BT_PTR, BT_I16, BT_BOOL, BT_INT,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_SIZE_VPTR_PTR_PTR_INT_INT, BT_BOOL, BT_SIZE,\n+\t\t     BT_VOLATILE_PTR, BT_PTR, BT_PTR, BT_INT, BT_INT)\n+\n \n DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,"}, {"sha": "dc9fe78599cee18b98d0b779647a2439a3ee027a", "filename": "gcc/builtins.c", "status": "modified", "additions": 735, "deletions": 100, "changes": 835, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -223,6 +223,7 @@ static tree do_mpfr_bessel_n (tree, tree, tree,\n \t\t\t      const REAL_VALUE_TYPE *, bool);\n static tree do_mpfr_remquo (tree, tree, tree);\n static tree do_mpfr_lgamma_r (tree, tree, tree);\n+static void expand_builtin_sync_synchronize (void);\n \n /* Return true if NAME starts with __builtin_ or __sync_.  */\n \n@@ -233,6 +234,8 @@ is_builtin_name (const char *name)\n     return true;\n   if (strncmp (name, \"__sync_\", 7) == 0)\n     return true;\n+  if (strncmp (name, \"__atomic_\", 9) == 0)\n+    return true;\n   return false;\n }\n \n@@ -5090,21 +5093,41 @@ get_builtin_sync_mem (tree loc, enum machine_mode mode)\n   return mem;\n }\n \n+/* Make sure an argument is in the right mode.\n+   EXP is the tree argument. \n+   MODE is the mode it should be in.  */\n+\n+static rtx\n+expand_expr_force_mode (tree exp, enum machine_mode mode)\n+{\n+  rtx val;\n+  enum machine_mode old_mode;\n+\n+  val = expand_expr (exp, NULL_RTX, mode, EXPAND_NORMAL);\n+  /* If VAL is promoted to a wider mode, convert it back to MODE.  Take care\n+     of CONST_INTs, where we know the old_mode only from the call argument.  */\n+\n+  old_mode = GET_MODE (val);\n+  if (old_mode == VOIDmode)\n+    old_mode = TYPE_MODE (TREE_TYPE (exp));\n+  val = convert_modes (mode, old_mode, val, 1);\n+  return val;\n+}\n+\n+\n /* Expand the __sync_xxx_and_fetch and __sync_fetch_and_xxx intrinsics.\n    EXP is the CALL_EXPR.  CODE is the rtx code\n    that corresponds to the arithmetic or logical operation from the name;\n    an exception here is that NOT actually means NAND.  TARGET is an optional\n    place for us to store the results; AFTER is true if this is the\n-   fetch_and_xxx form.  IGNORE is true if we don't actually care about\n-   the result of the operation at all.  */\n+   fetch_and_xxx form.  */\n \n static rtx\n expand_builtin_sync_operation (enum machine_mode mode, tree exp,\n \t\t\t       enum rtx_code code, bool after,\n-\t\t\t       rtx target, bool ignore)\n+\t\t\t       rtx target)\n {\n   rtx val, mem;\n-  enum machine_mode old_mode;\n   location_t loc = EXPR_LOCATION (exp);\n \n   if (code == NOT && warn_sync_nand)\n@@ -5151,19 +5174,10 @@ expand_builtin_sync_operation (enum machine_mode mode, tree exp,\n \n   /* Expand the operands.  */\n   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n+  val = expand_expr_force_mode (CALL_EXPR_ARG (exp, 1), mode);\n \n-  val = expand_expr (CALL_EXPR_ARG (exp, 1), NULL_RTX, mode, EXPAND_NORMAL);\n-  /* If VAL is promoted to a wider mode, convert it back to MODE.  Take care\n-     of CONST_INTs, where we know the old_mode only from the call argument.  */\n-  old_mode = GET_MODE (val);\n-  if (old_mode == VOIDmode)\n-    old_mode = TYPE_MODE (TREE_TYPE (CALL_EXPR_ARG (exp, 1)));\n-  val = convert_modes (mode, old_mode, val, 1);\n-\n-  if (ignore)\n-    return expand_sync_operation (mem, val, code);\n-  else\n-    return expand_sync_fetch_operation (mem, val, code, after, target);\n+  return expand_atomic_fetch_op (target, mem, val, code, MEMMODEL_SEQ_CST,\n+\t\t\t\t after);\n }\n \n /* Expand the __sync_val_compare_and_swap and __sync_bool_compare_and_swap\n@@ -5176,34 +5190,19 @@ expand_builtin_compare_and_swap (enum machine_mode mode, tree exp,\n \t\t\t\t bool is_bool, rtx target)\n {\n   rtx old_val, new_val, mem;\n-  enum machine_mode old_mode;\n \n   /* Expand the operands.  */\n   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n+  old_val = expand_expr_force_mode (CALL_EXPR_ARG (exp, 1), mode);\n+  new_val = expand_expr_force_mode (CALL_EXPR_ARG (exp, 2), mode);\n \n+  if (!expand_atomic_compare_and_swap ((is_bool ? &target : NULL),\n+\t\t\t\t       (is_bool ? NULL : &target),\n+\t\t\t\t       mem, old_val, new_val, false,\n+\t\t\t\t       MEMMODEL_SEQ_CST, MEMMODEL_SEQ_CST))\n+    return NULL_RTX;\n \n-  old_val = expand_expr (CALL_EXPR_ARG (exp, 1), NULL_RTX,\n-\t\t\t mode, EXPAND_NORMAL);\n-  /* If VAL is promoted to a wider mode, convert it back to MODE.  Take care\n-     of CONST_INTs, where we know the old_mode only from the call argument.  */\n-  old_mode = GET_MODE (old_val);\n-  if (old_mode == VOIDmode)\n-    old_mode = TYPE_MODE (TREE_TYPE (CALL_EXPR_ARG (exp, 1)));\n-  old_val = convert_modes (mode, old_mode, old_val, 1);\n-\n-  new_val = expand_expr (CALL_EXPR_ARG (exp, 2), NULL_RTX,\n-\t\t\t mode, EXPAND_NORMAL);\n-  /* If VAL is promoted to a wider mode, convert it back to MODE.  Take care\n-     of CONST_INTs, where we know the old_mode only from the call argument.  */\n-  old_mode = GET_MODE (new_val);\n-  if (old_mode == VOIDmode)\n-    old_mode = TYPE_MODE (TREE_TYPE (CALL_EXPR_ARG (exp, 2)));\n-  new_val = convert_modes (mode, old_mode, new_val, 1);\n-\n-  if (is_bool)\n-    return expand_bool_compare_and_swap (mem, old_val, new_val, target);\n-  else\n-    return expand_val_compare_and_swap (mem, old_val, new_val, target);\n+  return target;\n }\n \n /* Expand the __sync_lock_test_and_set intrinsic.  Note that the most\n@@ -5214,22 +5213,461 @@ expand_builtin_compare_and_swap (enum machine_mode mode, tree exp,\n \n static rtx\n expand_builtin_sync_lock_test_and_set (enum machine_mode mode, tree exp,\n-\t\t\t\t  rtx target)\n+\t\t\t\t       rtx target)\n {\n   rtx val, mem;\n-  enum machine_mode old_mode;\n \n   /* Expand the operands.  */\n   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n-  val = expand_expr (CALL_EXPR_ARG (exp, 1), NULL_RTX, mode, EXPAND_NORMAL);\n-  /* If VAL is promoted to a wider mode, convert it back to MODE.  Take care\n-     of CONST_INTs, where we know the old_mode only from the call argument.  */\n-  old_mode = GET_MODE (val);\n-  if (old_mode == VOIDmode)\n-    old_mode = TYPE_MODE (TREE_TYPE (CALL_EXPR_ARG (exp, 1)));\n-  val = convert_modes (mode, old_mode, val, 1);\n+  val = expand_expr_force_mode (CALL_EXPR_ARG (exp, 1), mode);\n+\n+  return expand_atomic_exchange (target, mem, val, MEMMODEL_ACQUIRE);\n+}\n+\n+/* Expand the __sync_lock_release intrinsic.  EXP is the CALL_EXPR.  */\n+\n+static void\n+expand_builtin_sync_lock_release (enum machine_mode mode, tree exp)\n+{\n+  rtx mem;\n+\n+  /* Expand the operands.  */\n+  mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n+\n+  expand_atomic_store (mem, const0_rtx, MEMMODEL_RELEASE);\n+}\n+\n+/* Given an integer representing an ``enum memmodel'', verify its\n+   correctness and return the memory model enum.  */\n+\n+static enum memmodel\n+get_memmodel (tree exp)\n+{\n+  rtx op;\n+\n+  /* If the parameter is not a constant, it's a run time value so we'll just\n+     convert it to MEMMODEL_SEQ_CST to avoid annoying runtime checking.  */\n+  if (TREE_CODE (exp) != INTEGER_CST)\n+    return MEMMODEL_SEQ_CST;\n+\n+  op = expand_normal (exp);\n+  if (INTVAL (op) < 0 || INTVAL (op) >= MEMMODEL_LAST)\n+    {\n+      warning (OPT_Winvalid_memory_model,\n+\t       \"invalid memory model argument to builtin\");\n+      return MEMMODEL_SEQ_CST;\n+    }\n+  return (enum memmodel) INTVAL (op);\n+}\n+\n+/* Expand the __atomic_exchange intrinsic:\n+   \tTYPE __atomic_exchange (TYPE *object, TYPE desired, enum memmodel)\n+   EXP is the CALL_EXPR.\n+   TARGET is an optional place for us to store the results.  */\n+\n+static rtx\n+expand_builtin_atomic_exchange (enum machine_mode mode, tree exp, rtx target)\n+{\n+  rtx val, mem;\n+  enum memmodel model;\n+\n+  model = get_memmodel (CALL_EXPR_ARG (exp, 2));\n+  if (model == MEMMODEL_CONSUME)\n+    {\n+      error (\"invalid memory model for %<__atomic_exchange%>\");\n+      return NULL_RTX;\n+    }\n+\n+  if (!flag_inline_atomics)\n+    return NULL_RTX;\n+\n+  /* Expand the operands.  */\n+  mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n+  val = expand_expr_force_mode (CALL_EXPR_ARG (exp, 1), mode);\n+\n+  return expand_atomic_exchange (target, mem, val, model);\n+}\n+\n+/* Expand the __atomic_compare_exchange intrinsic:\n+   \tbool __atomic_compare_exchange (TYPE *object, TYPE *expect, \n+\t\t\t\t\tTYPE desired, BOOL weak, \n+\t\t\t\t\tenum memmodel success,\n+\t\t\t\t\tenum memmodel failure)\n+   EXP is the CALL_EXPR.\n+   TARGET is an optional place for us to store the results.  */\n+\n+static rtx\n+expand_builtin_atomic_compare_exchange (enum machine_mode mode, tree exp, \n+\t\t\t\t\trtx target)\n+{\n+  rtx expect, desired, mem, oldval;\n+  enum memmodel success, failure;\n+  tree weak;\n+  bool is_weak;\n+\n+  success = get_memmodel (CALL_EXPR_ARG (exp, 4));\n+  failure = get_memmodel (CALL_EXPR_ARG (exp, 5));\n+\n+  if (failure == MEMMODEL_RELEASE || failure == MEMMODEL_ACQ_REL)\n+    {\n+      error (\"invalid failure memory model for %<__atomic_compare_exchange%>\");\n+      return NULL_RTX;\n+    }\n+\n+  if (failure > success)\n+    {\n+      error (\"failure memory model cannot be stronger than success \"\n+\t     \"memory model for %<__atomic_compare_exchange%>\");\n+      return NULL_RTX;\n+    }\n+  \n+  if (!flag_inline_atomics)\n+    return NULL_RTX;\n+\n+  /* Expand the operands.  */\n+  mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n+\n+  expect = expand_normal (CALL_EXPR_ARG (exp, 1));\n+  expect = convert_memory_address (Pmode, expect);\n+  desired = expand_expr_force_mode (CALL_EXPR_ARG (exp, 2), mode);\n+\n+  weak = CALL_EXPR_ARG (exp, 3);\n+  is_weak = false;\n+  if (host_integerp (weak, 0) && tree_low_cst (weak, 0) != 0)\n+    is_weak = true;\n+\n+  oldval = copy_to_reg (gen_rtx_MEM (mode, expect));\n+\n+  if (!expand_atomic_compare_and_swap (&target, &oldval, mem, oldval,\n+\t\t\t\t       desired, is_weak, success, failure))\n+    return NULL_RTX;\n+\n+  emit_move_insn (gen_rtx_MEM (mode, expect), oldval);\n+  return target;\n+}\n+\n+/* Expand the __atomic_load intrinsic:\n+   \tTYPE __atomic_load (TYPE *object, enum memmodel)\n+   EXP is the CALL_EXPR.\n+   TARGET is an optional place for us to store the results.  */\n+\n+static rtx\n+expand_builtin_atomic_load (enum machine_mode mode, tree exp, rtx target)\n+{\n+  rtx mem;\n+  enum memmodel model;\n+\n+  model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n+  if (model == MEMMODEL_RELEASE\n+      || model == MEMMODEL_ACQ_REL)\n+    {\n+      error (\"invalid memory model for %<__atomic_load%>\");\n+      return NULL_RTX;\n+    }\n+\n+  if (!flag_inline_atomics)\n+    return NULL_RTX;\n+\n+  /* Expand the operand.  */\n+  mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n+\n+  return expand_atomic_load (target, mem, model);\n+}\n+\n+\n+/* Expand the __atomic_store intrinsic:\n+   \tvoid __atomic_store (TYPE *object, TYPE desired, enum memmodel)\n+   EXP is the CALL_EXPR.\n+   TARGET is an optional place for us to store the results.  */\n+\n+static rtx\n+expand_builtin_atomic_store (enum machine_mode mode, tree exp)\n+{\n+  rtx mem, val;\n+  enum memmodel model;\n+\n+  model = get_memmodel (CALL_EXPR_ARG (exp, 2));\n+  if (model != MEMMODEL_RELAXED\n+      && model != MEMMODEL_SEQ_CST\n+      && model != MEMMODEL_RELEASE)\n+    {\n+      error (\"invalid memory model for %<__atomic_store%>\");\n+      return NULL_RTX;\n+    }\n+\n+  if (!flag_inline_atomics)\n+    return NULL_RTX;\n+\n+  /* Expand the operands.  */\n+  mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n+  val = expand_expr_force_mode (CALL_EXPR_ARG (exp, 1), mode);\n+\n+  return expand_atomic_store (mem, val, model);\n+}\n+\n+/* Expand the __atomic_fetch_XXX intrinsic:\n+   \tTYPE __atomic_fetch_XXX (TYPE *object, TYPE val, enum memmodel)\n+   EXP is the CALL_EXPR.\n+   TARGET is an optional place for us to store the results.\n+   CODE is the operation, PLUS, MINUS, ADD, XOR, or IOR.\n+   FETCH_AFTER is true if returning the result of the operation.\n+   FETCH_AFTER is false if returning the value before the operation.\n+   IGNORE is true if the result is not used.\n+   EXT_CALL is the correct builtin for an external call if this cannot be\n+   resolved to an instruction sequence.  */\n+\n+static rtx\n+expand_builtin_atomic_fetch_op (enum machine_mode mode, tree exp, rtx target,\n+\t\t\t\tenum rtx_code code, bool fetch_after,\n+\t\t\t\tbool ignore, enum built_in_function ext_call)\n+{\n+  rtx val, mem, ret;\n+  enum memmodel model;\n+  tree fndecl;\n+  tree addr;\n+\n+  model = get_memmodel (CALL_EXPR_ARG (exp, 2));\n+\n+  /* Expand the operands.  */\n+  mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n+  val = expand_expr_force_mode (CALL_EXPR_ARG (exp, 1), mode);\n+\n+  /* Only try generating instructions if inlining is turned on.  */\n+  if (flag_inline_atomics)\n+    {\n+      ret = expand_atomic_fetch_op (target, mem, val, code, model, fetch_after);\n+      if (ret)\n+\treturn ret;\n+    }\n+\n+  /* Return if a different routine isn't needed for the library call.  */\n+  if (ext_call == BUILT_IN_NONE)\n+    return NULL_RTX;\n+\n+  /* Change the call to the specified function.  */\n+  fndecl = get_callee_fndecl (exp);\n+  addr = CALL_EXPR_FN (exp);\n+  STRIP_NOPS (addr);\n+\n+  gcc_assert (TREE_OPERAND (addr, 0) == fndecl);\n+  TREE_OPERAND (addr, 0) = builtin_decl_explicit(ext_call);\n+\n+  /* Expand the call here so we can emit trailing code.  */\n+  ret = expand_call (exp, target, ignore);\n+\n+  /* Replace the original function just in case it matters.  */\n+  TREE_OPERAND (addr, 0) = fndecl;\n+\n+  /* Then issue the arithmetic correction to return the right result.  */\n+  if (!ignore)\n+    ret = expand_simple_binop (mode, code, ret, val, NULL_RTX, true,\n+\t\t\t       OPTAB_LIB_WIDEN);\n+  return ret;\n+}\n+\n+/* Return true if (optional) argument ARG1 of size ARG0 is always lock free on\n+   this architecture.  If ARG1 is NULL, use typical alignment for size ARG0.  */\n+\n+static tree\n+fold_builtin_atomic_always_lock_free (tree arg0, tree arg1)\n+{\n+  int size;\n+  enum machine_mode mode;\n+  unsigned int mode_align, type_align;\n+\n+  if (TREE_CODE (arg0) != INTEGER_CST)\n+    return NULL_TREE;\n+\n+  size = INTVAL (expand_normal (arg0)) * BITS_PER_UNIT;\n+  mode = mode_for_size (size, MODE_INT, 0);\n+  mode_align = GET_MODE_ALIGNMENT (mode);\n+\n+  if (TREE_CODE (arg1) == INTEGER_CST && INTVAL (expand_normal (arg1)) == 0)\n+    type_align = mode_align;\n+  else\n+    {\n+      tree ttype = TREE_TYPE (arg1);\n+\n+      /* This function is usually invoked and folded immediately by the front\n+\t end before anything else has a chance to look at it.  The pointer\n+\t parameter at this point is usually cast to a void *, so check for that\n+\t and look past the cast.  */\n+      if (TREE_CODE (arg1) == NOP_EXPR && POINTER_TYPE_P (ttype)\n+\t  && VOID_TYPE_P (TREE_TYPE (ttype)))\n+\targ1 = TREE_OPERAND (arg1, 0);\n+\n+      ttype = TREE_TYPE (arg1);\n+      gcc_assert (POINTER_TYPE_P (ttype));\n+\n+      /* Get the underlying type of the object.  */\n+      ttype = TREE_TYPE (ttype);\n+      type_align = TYPE_ALIGN (ttype);\n+    }\n+\n+  /* If the object has smaller alignment, the the lock free routines cannot\n+     be used.  */\n+  if (type_align < mode_align)\n+    return integer_zero_node;\n+\n+  /* Check if a compare_and_swap pattern exists for the mode which represents\n+     the required size.  The pattern is not allowed to fail, so the existence\n+     of the pattern indicates support is present.  */\n+  if (can_compare_and_swap_p (mode))\n+    return integer_one_node;\n+  else\n+    return integer_zero_node;\n+}\n+\n+/* Return true if the parameters to call EXP represent an object which will\n+   always generate lock free instructions.  The first argument represents the\n+   size of the object, and the second parameter is a pointer to the object \n+   itself.  If NULL is passed for the object, then the result is based on \n+   typical alignment for an object of the specified size.  Otherwise return \n+   false.  */\n+\n+static rtx\n+expand_builtin_atomic_always_lock_free (tree exp)\n+{\n+  tree size;\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n \n-  return expand_sync_lock_test_and_set (mem, val, target);\n+  if (TREE_CODE (arg0) != INTEGER_CST)\n+    {\n+      error (\"non-constant argument 1 to __atomic_always_lock_free\");\n+      return const0_rtx;\n+    }\n+\n+  size = fold_builtin_atomic_always_lock_free (arg0, arg1);\n+  if (size == integer_one_node)\n+    return const1_rtx;\n+  return const0_rtx;\n+}\n+\n+/* Return a one or zero if it can be determined that object ARG1 of size ARG \n+   is lock free on this architecture.  */\n+\n+static tree\n+fold_builtin_atomic_is_lock_free (tree arg0, tree arg1)\n+{\n+  if (!flag_inline_atomics)\n+    return NULL_TREE;\n+  \n+  /* If it isn't always lock free, don't generate a result.  */\n+  if (fold_builtin_atomic_always_lock_free (arg0, arg1) == integer_one_node)\n+    return integer_one_node;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return true if the parameters to call EXP represent an object which will\n+   always generate lock free instructions.  The first argument represents the\n+   size of the object, and the second parameter is a pointer to the object \n+   itself.  If NULL is passed for the object, then the result is based on \n+   typical alignment for an object of the specified size.  Otherwise return \n+   NULL*/\n+\n+static rtx\n+expand_builtin_atomic_is_lock_free (tree exp)\n+{\n+  tree size;\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n+\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (arg0)))\n+    {\n+      error (\"non-integer argument 1 to __atomic_is_lock_free\");\n+      return NULL_RTX;\n+    }\n+\n+  if (!flag_inline_atomics)\n+    return NULL_RTX; \n+\n+  /* If the value is known at compile time, return the RTX for it.  */\n+  size = fold_builtin_atomic_is_lock_free (arg0, arg1);\n+  if (size == integer_one_node)\n+    return const1_rtx;\n+\n+  return NULL_RTX;\n+}\n+\n+/* This routine will either emit the mem_thread_fence pattern or issue a \n+   sync_synchronize to generate a fence for memory model MEMMODEL.  */\n+\n+#ifndef HAVE_mem_thread_fence\n+# define HAVE_mem_thread_fence 0\n+# define gen_mem_thread_fence(x) (gcc_unreachable (), NULL_RTX)\n+#endif\n+\n+void\n+expand_builtin_mem_thread_fence (enum memmodel model)\n+{\n+  if (HAVE_mem_thread_fence)\n+    emit_insn (gen_mem_thread_fence (GEN_INT (model)));\n+  else if (model != MEMMODEL_RELAXED)\n+    expand_builtin_sync_synchronize ();\n+}\n+\n+/* Expand the __atomic_thread_fence intrinsic:\n+   \tvoid __atomic_thread_fence (enum memmodel)\n+   EXP is the CALL_EXPR.  */\n+\n+static void\n+expand_builtin_atomic_thread_fence (tree exp)\n+{\n+  enum memmodel model;\n+  \n+  model = get_memmodel (CALL_EXPR_ARG (exp, 0));\n+  expand_builtin_mem_thread_fence (model);\n+}\n+\n+/* This routine will either emit the mem_signal_fence pattern or issue a \n+   sync_synchronize to generate a fence for memory model MEMMODEL.  */\n+\n+#ifndef HAVE_mem_signal_fence\n+# define HAVE_mem_signal_fence 0\n+# define gen_mem_signal_fence(x) (gcc_unreachable (), NULL_RTX)\n+#endif\n+\n+static void\n+expand_builtin_mem_signal_fence (enum memmodel model)\n+{\n+  if (HAVE_mem_signal_fence)\n+    emit_insn (gen_mem_signal_fence (GEN_INT (model)));\n+  else if (model != MEMMODEL_RELAXED)\n+    {\n+      rtx asm_op, clob;\n+\n+      /* By default targets are coherent between a thread and the signal\n+\t handler running on the same thread.  Thus this really becomes a\n+\t compiler barrier, in that stores must not be sunk past\n+\t (or raised above) a given point.  */\n+\n+      /* Generate asm volatile(\"\" : : : \"memory\") as the memory barrier.  */\n+      asm_op = gen_rtx_ASM_OPERANDS (VOIDmode, empty_string, empty_string, 0,\n+\t\t\t\t     rtvec_alloc (0), rtvec_alloc (0),\n+\t\t\t\t     rtvec_alloc (0), UNKNOWN_LOCATION);\n+      MEM_VOLATILE_P (asm_op) = 1;\n+\n+      clob = gen_rtx_SCRATCH (VOIDmode);\n+      clob = gen_rtx_MEM (BLKmode, clob);\n+      clob = gen_rtx_CLOBBER (VOIDmode, clob);\n+\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, asm_op, clob)));\n+    }\n+}\n+\n+/* Expand the __atomic_signal_fence intrinsic:\n+   \tvoid __atomic_signal_fence (enum memmodel)\n+   EXP is the CALL_EXPR.  */\n+\n+static void\n+expand_builtin_atomic_signal_fence (tree exp)\n+{\n+  enum memmodel model;\n+\n+  model = get_memmodel (CALL_EXPR_ARG (exp, 0));\n+  expand_builtin_mem_signal_fence (model);\n }\n \n /* Expand the __sync_synchronize intrinsic.  */\n@@ -5264,33 +5702,6 @@ expand_builtin_sync_synchronize (void)\n   expand_asm_stmt (x);\n }\n \n-/* Expand the __sync_lock_release intrinsic.  EXP is the CALL_EXPR.  */\n-\n-static void\n-expand_builtin_sync_lock_release (enum machine_mode mode, tree exp)\n-{\n-  struct expand_operand ops[2];\n-  enum insn_code icode;\n-  rtx mem;\n-\n-  /* Expand the operands.  */\n-  mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n-\n-  /* If there is an explicit operation in the md file, use it.  */\n-  icode = direct_optab_handler (sync_lock_release_optab, mode);\n-  if (icode != CODE_FOR_nothing)\n-    {\n-      create_fixed_operand (&ops[0], mem);\n-      create_input_operand (&ops[1], const0_rtx, mode);\n-      if (maybe_expand_insn (icode, 2, ops))\n-\treturn;\n-    }\n-\n-  /* Otherwise we can implement this operation by emitting a barrier\n-     followed by a store of zero.  */\n-  expand_builtin_sync_synchronize ();\n-  emit_move_insn (mem, const0_rtx);\n-}\n \f\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n@@ -5891,8 +6302,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_SYNC_FETCH_AND_ADD_8:\n     case BUILT_IN_SYNC_FETCH_AND_ADD_16:\n       mode = get_builtin_sync_mode (fcode - BUILT_IN_SYNC_FETCH_AND_ADD_1);\n-      target = expand_builtin_sync_operation (mode, exp, PLUS,\n-\t\t\t\t\t      false, target, ignore);\n+      target = expand_builtin_sync_operation (mode, exp, PLUS, false, target);\n       if (target)\n \treturn target;\n       break;\n@@ -5903,8 +6313,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_SYNC_FETCH_AND_SUB_8:\n     case BUILT_IN_SYNC_FETCH_AND_SUB_16:\n       mode = get_builtin_sync_mode (fcode - BUILT_IN_SYNC_FETCH_AND_SUB_1);\n-      target = expand_builtin_sync_operation (mode, exp, MINUS,\n-\t\t\t\t\t      false, target, ignore);\n+      target = expand_builtin_sync_operation (mode, exp, MINUS, false, target);\n       if (target)\n \treturn target;\n       break;\n@@ -5915,8 +6324,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_SYNC_FETCH_AND_OR_8:\n     case BUILT_IN_SYNC_FETCH_AND_OR_16:\n       mode = get_builtin_sync_mode (fcode - BUILT_IN_SYNC_FETCH_AND_OR_1);\n-      target = expand_builtin_sync_operation (mode, exp, IOR,\n-\t\t\t\t\t      false, target, ignore);\n+      target = expand_builtin_sync_operation (mode, exp, IOR, false, target);\n       if (target)\n \treturn target;\n       break;\n@@ -5927,8 +6335,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_SYNC_FETCH_AND_AND_8:\n     case BUILT_IN_SYNC_FETCH_AND_AND_16:\n       mode = get_builtin_sync_mode (fcode - BUILT_IN_SYNC_FETCH_AND_AND_1);\n-      target = expand_builtin_sync_operation (mode, exp, AND,\n-\t\t\t\t\t      false, target, ignore);\n+      target = expand_builtin_sync_operation (mode, exp, AND, false, target);\n       if (target)\n \treturn target;\n       break;\n@@ -5939,8 +6346,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_SYNC_FETCH_AND_XOR_8:\n     case BUILT_IN_SYNC_FETCH_AND_XOR_16:\n       mode = get_builtin_sync_mode (fcode - BUILT_IN_SYNC_FETCH_AND_XOR_1);\n-      target = expand_builtin_sync_operation (mode, exp, XOR,\n-\t\t\t\t\t      false, target, ignore);\n+      target = expand_builtin_sync_operation (mode, exp, XOR, false, target);\n       if (target)\n \treturn target;\n       break;\n@@ -5951,8 +6357,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_SYNC_FETCH_AND_NAND_8:\n     case BUILT_IN_SYNC_FETCH_AND_NAND_16:\n       mode = get_builtin_sync_mode (fcode - BUILT_IN_SYNC_FETCH_AND_NAND_1);\n-      target = expand_builtin_sync_operation (mode, exp, NOT,\n-\t\t\t\t\t      false, target, ignore);\n+      target = expand_builtin_sync_operation (mode, exp, NOT, false, target);\n       if (target)\n \treturn target;\n       break;\n@@ -5963,8 +6368,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_SYNC_ADD_AND_FETCH_8:\n     case BUILT_IN_SYNC_ADD_AND_FETCH_16:\n       mode = get_builtin_sync_mode (fcode - BUILT_IN_SYNC_ADD_AND_FETCH_1);\n-      target = expand_builtin_sync_operation (mode, exp, PLUS,\n-\t\t\t\t\t      true, target, ignore);\n+      target = expand_builtin_sync_operation (mode, exp, PLUS, true, target);\n       if (target)\n \treturn target;\n       break;\n@@ -5975,8 +6379,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_SYNC_SUB_AND_FETCH_8:\n     case BUILT_IN_SYNC_SUB_AND_FETCH_16:\n       mode = get_builtin_sync_mode (fcode - BUILT_IN_SYNC_SUB_AND_FETCH_1);\n-      target = expand_builtin_sync_operation (mode, exp, MINUS,\n-\t\t\t\t\t      true, target, ignore);\n+      target = expand_builtin_sync_operation (mode, exp, MINUS, true, target);\n       if (target)\n \treturn target;\n       break;\n@@ -5987,8 +6390,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_SYNC_OR_AND_FETCH_8:\n     case BUILT_IN_SYNC_OR_AND_FETCH_16:\n       mode = get_builtin_sync_mode (fcode - BUILT_IN_SYNC_OR_AND_FETCH_1);\n-      target = expand_builtin_sync_operation (mode, exp, IOR,\n-\t\t\t\t\t      true, target, ignore);\n+      target = expand_builtin_sync_operation (mode, exp, IOR, true, target);\n       if (target)\n \treturn target;\n       break;\n@@ -5999,8 +6401,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_SYNC_AND_AND_FETCH_8:\n     case BUILT_IN_SYNC_AND_AND_FETCH_16:\n       mode = get_builtin_sync_mode (fcode - BUILT_IN_SYNC_AND_AND_FETCH_1);\n-      target = expand_builtin_sync_operation (mode, exp, AND,\n-\t\t\t\t\t      true, target, ignore);\n+      target = expand_builtin_sync_operation (mode, exp, AND, true, target);\n       if (target)\n \treturn target;\n       break;\n@@ -6011,8 +6412,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_SYNC_XOR_AND_FETCH_8:\n     case BUILT_IN_SYNC_XOR_AND_FETCH_16:\n       mode = get_builtin_sync_mode (fcode - BUILT_IN_SYNC_XOR_AND_FETCH_1);\n-      target = expand_builtin_sync_operation (mode, exp, XOR,\n-\t\t\t\t\t      true, target, ignore);\n+      target = expand_builtin_sync_operation (mode, exp, XOR, true, target);\n       if (target)\n \treturn target;\n       break;\n@@ -6023,8 +6423,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_SYNC_NAND_AND_FETCH_8:\n     case BUILT_IN_SYNC_NAND_AND_FETCH_16:\n       mode = get_builtin_sync_mode (fcode - BUILT_IN_SYNC_NAND_AND_FETCH_1);\n-      target = expand_builtin_sync_operation (mode, exp, NOT,\n-\t\t\t\t\t      true, target, ignore);\n+      target = expand_builtin_sync_operation (mode, exp, NOT, true, target);\n       if (target)\n \treturn target;\n       break;\n@@ -6082,6 +6481,236 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       expand_builtin_sync_synchronize ();\n       return const0_rtx;\n \n+    case BUILT_IN_ATOMIC_EXCHANGE_1:\n+    case BUILT_IN_ATOMIC_EXCHANGE_2:\n+    case BUILT_IN_ATOMIC_EXCHANGE_4:\n+    case BUILT_IN_ATOMIC_EXCHANGE_8:\n+    case BUILT_IN_ATOMIC_EXCHANGE_16:\n+      mode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_EXCHANGE_1);\n+      target = expand_builtin_atomic_exchange (mode, exp, target);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_1:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_2:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_16:\n+      mode = \n+\t  get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_COMPARE_EXCHANGE_1);\n+      target = expand_builtin_atomic_compare_exchange (mode, exp, target);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_ATOMIC_LOAD_1:\n+    case BUILT_IN_ATOMIC_LOAD_2:\n+    case BUILT_IN_ATOMIC_LOAD_4:\n+    case BUILT_IN_ATOMIC_LOAD_8:\n+    case BUILT_IN_ATOMIC_LOAD_16:\n+      mode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_LOAD_1);\n+      target = expand_builtin_atomic_load (mode, exp, target);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_ATOMIC_STORE_1:\n+    case BUILT_IN_ATOMIC_STORE_2:\n+    case BUILT_IN_ATOMIC_STORE_4:\n+    case BUILT_IN_ATOMIC_STORE_8:\n+    case BUILT_IN_ATOMIC_STORE_16:\n+      mode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_STORE_1);\n+      target = expand_builtin_atomic_store (mode, exp);\n+      if (target)\n+\treturn const0_rtx;\n+      break;\n+\n+    case BUILT_IN_ATOMIC_ADD_FETCH_1:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_2:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_4:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_8:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_16:\n+      {\n+\tenum built_in_function lib;\n+\tmode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_ADD_FETCH_1);\n+\tlib = (enum built_in_function)((int)BUILT_IN_ATOMIC_FETCH_ADD_1 + \n+\t\t\t\t       (fcode - BUILT_IN_ATOMIC_ADD_FETCH_1));\n+\ttarget = expand_builtin_atomic_fetch_op (mode, exp, target, PLUS, true,\n+\t\t\t\t\t\t ignore, lib);\n+\tif (target)\n+\t  return target;\n+\tbreak;\n+      }\n+    case BUILT_IN_ATOMIC_SUB_FETCH_1:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_2:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_4:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_8:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_16:\n+      {\n+\tenum built_in_function lib;\n+\tmode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_SUB_FETCH_1);\n+\tlib = (enum built_in_function)((int)BUILT_IN_ATOMIC_FETCH_SUB_1 + \n+\t\t\t\t       (fcode - BUILT_IN_ATOMIC_SUB_FETCH_1));\n+\ttarget = expand_builtin_atomic_fetch_op (mode, exp, target, MINUS, true,\n+\t\t\t\t\t\t ignore, lib);\n+\tif (target)\n+\t  return target;\n+\tbreak;\n+      }\n+    case BUILT_IN_ATOMIC_AND_FETCH_1:\n+    case BUILT_IN_ATOMIC_AND_FETCH_2:\n+    case BUILT_IN_ATOMIC_AND_FETCH_4:\n+    case BUILT_IN_ATOMIC_AND_FETCH_8:\n+    case BUILT_IN_ATOMIC_AND_FETCH_16:\n+      {\n+\tenum built_in_function lib;\n+\tmode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_AND_FETCH_1);\n+\tlib = (enum built_in_function)((int)BUILT_IN_ATOMIC_FETCH_AND_1 + \n+\t\t\t\t       (fcode - BUILT_IN_ATOMIC_AND_FETCH_1));\n+\ttarget = expand_builtin_atomic_fetch_op (mode, exp, target, AND, true,\n+\t\t\t\t\t\t ignore, lib);\n+\tif (target)\n+\t  return target;\n+\tbreak;\n+      }\n+    case BUILT_IN_ATOMIC_NAND_FETCH_1:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_2:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_4:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_8:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_16:\n+      {\n+\tenum built_in_function lib;\n+\tmode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_NAND_FETCH_1);\n+\tlib = (enum built_in_function)((int)BUILT_IN_ATOMIC_FETCH_NAND_1 + \n+\t\t\t\t       (fcode - BUILT_IN_ATOMIC_NAND_FETCH_1));\n+\ttarget = expand_builtin_atomic_fetch_op (mode, exp, target, NOT, true,\n+\t\t\t\t\t\t ignore, lib);\n+\tif (target)\n+\t  return target;\n+\tbreak;\n+      }\n+    case BUILT_IN_ATOMIC_XOR_FETCH_1:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_2:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_4:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_8:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_16:\n+      {\n+\tenum built_in_function lib;\n+\tmode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_XOR_FETCH_1);\n+\tlib = (enum built_in_function)((int)BUILT_IN_ATOMIC_FETCH_XOR_1 + \n+\t\t\t\t       (fcode - BUILT_IN_ATOMIC_XOR_FETCH_1));\n+\ttarget = expand_builtin_atomic_fetch_op (mode, exp, target, XOR, true,\n+\t\t\t\t\t\t ignore, lib);\n+\tif (target)\n+\t  return target;\n+\tbreak;\n+      }\n+    case BUILT_IN_ATOMIC_OR_FETCH_1:\n+    case BUILT_IN_ATOMIC_OR_FETCH_2:\n+    case BUILT_IN_ATOMIC_OR_FETCH_4:\n+    case BUILT_IN_ATOMIC_OR_FETCH_8:\n+    case BUILT_IN_ATOMIC_OR_FETCH_16:\n+      {\n+\tenum built_in_function lib;\n+\tmode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_OR_FETCH_1);\n+\tlib = (enum built_in_function)((int)BUILT_IN_ATOMIC_FETCH_OR_1 + \n+\t\t\t\t       (fcode - BUILT_IN_ATOMIC_OR_FETCH_1));\n+\ttarget = expand_builtin_atomic_fetch_op (mode, exp, target, IOR, true,\n+\t\t\t\t\t\t ignore, lib);\n+\tif (target)\n+\t  return target;\n+\tbreak;\n+      }\n+    case BUILT_IN_ATOMIC_FETCH_ADD_1:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_2:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_4:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_8:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_16:\n+      mode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_FETCH_ADD_1);\n+      target = expand_builtin_atomic_fetch_op (mode, exp, target, PLUS, false,\n+\t\t\t\t\t       ignore, BUILT_IN_NONE);\n+      if (target)\n+\treturn target;\n+      break;\n+ \n+    case BUILT_IN_ATOMIC_FETCH_SUB_1:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_2:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_4:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_8:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_16:\n+      mode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_FETCH_SUB_1);\n+      target = expand_builtin_atomic_fetch_op (mode, exp, target, MINUS, false,\n+\t\t\t\t\t       ignore, BUILT_IN_NONE);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_ATOMIC_FETCH_AND_1:\n+    case BUILT_IN_ATOMIC_FETCH_AND_2:\n+    case BUILT_IN_ATOMIC_FETCH_AND_4:\n+    case BUILT_IN_ATOMIC_FETCH_AND_8:\n+    case BUILT_IN_ATOMIC_FETCH_AND_16:\n+      mode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_FETCH_AND_1);\n+      target = expand_builtin_atomic_fetch_op (mode, exp, target, AND, false,\n+\t\t\t\t\t       ignore, BUILT_IN_NONE);\n+      if (target)\n+\treturn target;\n+      break;\n+  \n+    case BUILT_IN_ATOMIC_FETCH_NAND_1:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_2:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_4:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_8:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_16:\n+      mode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_FETCH_NAND_1);\n+      target = expand_builtin_atomic_fetch_op (mode, exp, target, NOT, false,\n+\t\t\t\t\t       ignore, BUILT_IN_NONE);\n+      if (target)\n+\treturn target;\n+      break;\n+ \n+    case BUILT_IN_ATOMIC_FETCH_XOR_1:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_2:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_4:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_8:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_16:\n+      mode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_FETCH_XOR_1);\n+      target = expand_builtin_atomic_fetch_op (mode, exp, target, XOR, false,\n+\t\t\t\t\t       ignore, BUILT_IN_NONE);\n+      if (target)\n+\treturn target;\n+      break;\n+ \n+    case BUILT_IN_ATOMIC_FETCH_OR_1:\n+    case BUILT_IN_ATOMIC_FETCH_OR_2:\n+    case BUILT_IN_ATOMIC_FETCH_OR_4:\n+    case BUILT_IN_ATOMIC_FETCH_OR_8:\n+    case BUILT_IN_ATOMIC_FETCH_OR_16:\n+      mode = get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_FETCH_OR_1);\n+      target = expand_builtin_atomic_fetch_op (mode, exp, target, IOR, false,\n+\t\t\t\t\t       ignore, BUILT_IN_NONE);\n+      if (target)\n+\treturn target;\n+      break;\n+ \n+    case BUILT_IN_ATOMIC_ALWAYS_LOCK_FREE:\n+      return expand_builtin_atomic_always_lock_free (exp);\n+\n+    case BUILT_IN_ATOMIC_IS_LOCK_FREE:\n+      target = expand_builtin_atomic_is_lock_free (exp);\n+      if (target)\n+        return target;\n+      break;\n+\n+    case BUILT_IN_ATOMIC_THREAD_FENCE:\n+      expand_builtin_atomic_thread_fence (exp);\n+      return const0_rtx;\n+\n+    case BUILT_IN_ATOMIC_SIGNAL_FENCE:\n+      expand_builtin_atomic_signal_fence (exp);\n+      return const0_rtx;\n+\n     case BUILT_IN_OBJECT_SIZE:\n       return expand_builtin_object_size (exp);\n \n@@ -10121,6 +10750,12 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n       return fold_builtin_fprintf (loc, fndecl, arg0, arg1, NULL_TREE,\n \t\t\t\t   ignore, fcode);\n \n+    case BUILT_IN_ATOMIC_ALWAYS_LOCK_FREE:\n+      return fold_builtin_atomic_always_lock_free (arg0, arg1);\n+\n+    case BUILT_IN_ATOMIC_IS_LOCK_FREE:\n+      return fold_builtin_atomic_is_lock_free (arg0, arg1);\n+\n     default:\n       break;\n     }"}, {"sha": "1c8a6b412f3b275c8d4f51dc46e986ecb3964f2b", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -1,3 +1,24 @@\n+2011-11-06  Andrew MacLeod  <amacleod@redhat.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\tMerged from cxx-mem-model.\n+\n+\t* c-cppbuiltin.c (c_cpp_builtins): Test both atomic and sync patterns.\n+\t* c-common.c (sync_resolve_params, sync_resolve_return): Only tweak \n+\tparameters that are the same type size.\n+\t(get_atomic_generic_size): New.  Find size of generic\n+\tatomic function parameters and do typechecking.\n+\t(add_atomic_size_parameter): New.  Insert size into parameter list.\n+\t(resolve_overloaded_atomic_exchange): Restructure __atomic_exchange to\n+\teither __atomic_exchange_n or external library call.\n+\t(resolve_overloaded_atomic_compare_exchange): Restructure \n+\t__atomic_compare_exchange to either _n variant or external library call.\n+\t(resolve_overloaded_atomic_load): Restructure __atomic_load to either \n+\t__atomic_load_n or an external library call.\n+\t(resolve_overloaded_atomic_store): Restructure __atomic_store to either\n+\t__atomic_store_n or an external library call.\n+\t(resolve_overloaded_builtin): Handle new __atomic builtins.\n+\n 2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR c++/50608"}, {"sha": "aa5f3bf24aaf19513f2381309620b845cd58cf9e", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 494, "deletions": 14, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -9007,7 +9007,8 @@ sync_resolve_size (tree function, VEC(tree,gc) *params)\n    was encountered; true on success.  */\n \n static bool\n-sync_resolve_params (tree orig_function, tree function, VEC(tree, gc) *params)\n+sync_resolve_params (location_t loc, tree orig_function, tree function,\n+\t\t     VEC(tree, gc) *params, bool orig_format)\n {\n   function_args_iterator iter;\n   tree ptype;\n@@ -9035,21 +9036,34 @@ sync_resolve_params (tree orig_function, tree function, VEC(tree, gc) *params)\n       ++parmnum;\n       if (VEC_length (tree, params) <= parmnum)\n \t{\n-\t  error (\"too few arguments to function %qE\", orig_function);\n+\t  error_at (loc, \"too few arguments to function %qE\", orig_function);\n \t  return false;\n \t}\n \n-      /* ??? Ideally for the first conversion we'd use convert_for_assignment\n-\t so that we get warnings for anything that doesn't match the pointer\n-\t type.  This isn't portable across the C and C++ front ends atm.  */\n-      val = VEC_index (tree, params, parmnum);\n-      val = convert (ptype, val);\n-      val = convert (arg_type, val);\n-      VEC_replace (tree, params, parmnum, val);\n+      /* Only convert parameters if the size is appropriate with new format\n+\t sync routines.  */\n+      if (orig_format\n+\t  || tree_int_cst_equal (TYPE_SIZE (ptype), TYPE_SIZE (arg_type)))\n+\t{\n+\t  /* Ideally for the first conversion we'd use convert_for_assignment\n+\t     so that we get warnings for anything that doesn't match the pointer\n+\t     type.  This isn't portable across the C and C++ front ends atm.  */\n+\t  val = VEC_index (tree, params, parmnum);\n+\t  val = convert (ptype, val);\n+\t  val = convert (arg_type, val);\n+\t  VEC_replace (tree, params, parmnum, val);\n+\t}\n \n       function_args_iter_next (&iter);\n     }\n \n+  /* __atomic routines are not variadic.  */\n+  if (!orig_format && VEC_length (tree, params) != parmnum + 1)\n+    {\n+      error_at (loc, \"too many arguments to function %qE\", orig_function);\n+      return false;\n+    }\n+\n   /* The definition of these primitives is variadic, with the remaining\n      being \"an optional list of variables protected by the memory barrier\".\n      No clue what that's supposed to mean, precisely, but we consider all\n@@ -9064,13 +9078,388 @@ sync_resolve_params (tree orig_function, tree function, VEC(tree, gc) *params)\n    PARAMS.  */\n \n static tree\n-sync_resolve_return (tree first_param, tree result)\n+sync_resolve_return (tree first_param, tree result, bool orig_format)\n {\n   tree ptype = TREE_TYPE (TREE_TYPE (first_param));\n+  tree rtype = TREE_TYPE (result);\n   ptype = TYPE_MAIN_VARIANT (ptype);\n-  return convert (ptype, result);\n+\n+  /* New format doesn't require casting unless the types are the same size.  */\n+  if (orig_format || tree_int_cst_equal (TYPE_SIZE (ptype), TYPE_SIZE (rtype)))\n+    return convert (ptype, result);\n+  else\n+    return result;\n+}\n+\n+/* This function verifies the PARAMS to generic atomic FUNCTION.\n+   It returns the size if all the parameters are the same size, otherwise\n+   0 is returned if the parameters are invalid.  */\n+\n+static int\n+get_atomic_generic_size (location_t loc, tree function, VEC(tree,gc) *params)\n+{\n+  unsigned int n_param;\n+  unsigned int n_model;\n+  unsigned int x;\n+  int size_0;\n+  tree type_0;\n+\n+  /* Determine the parameter makeup.  */\n+  switch (DECL_FUNCTION_CODE (function))\n+    {\n+    case BUILT_IN_ATOMIC_EXCHANGE:\n+      n_param = 4;\n+      n_model = 1;\n+      break;\n+    case BUILT_IN_ATOMIC_LOAD:\n+    case BUILT_IN_ATOMIC_STORE:\n+      n_param = 3;\n+      n_model = 1;\n+      break;\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE:\n+      n_param = 6;\n+      n_model = 2;\n+      break;\n+    default:\n+      return 0;\n+    }\n+\n+  if (VEC_length (tree, params) != n_param)\n+    {\n+      error_at (loc, \"incorrect number of arguments to function %qE\", function);\n+      return 0;\n+    }\n+\n+  /* Get type of first parameter, and determine its size.  */\n+  type_0 = TREE_TYPE (VEC_index (tree, params, 0));\n+  if (TREE_CODE (type_0) != POINTER_TYPE)\n+    {\n+      error_at (loc, \"argument 1 of %qE must be a pointer type\", function);\n+      return 0;\n+    }\n+  size_0 = tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (type_0)), 1);\n+\n+  /* Check each other parameter is a pointer and the same size.  */\n+  for (x = 0; x < n_param - n_model; x++)\n+    {\n+      int size;\n+      tree type = TREE_TYPE (VEC_index (tree, params, x));\n+      /* __atomic_compare_exchange has a bool in the 4th postion, skip it.  */\n+      if (n_param == 6 && x == 3)\n+        continue;\n+      if (!POINTER_TYPE_P (type))\n+\t{\n+\t  error_at (loc, \"argument %d of %qE must be a pointer type\", x + 1,\n+\t\t    function);\n+\t  return 0;\n+\t}\n+      size = tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (type)), 1);\n+      if (size != size_0)\n+\t{\n+\t  error_at (loc, \"size mismatch in argument %d of %qE\", x + 1,\n+\t\t    function);\n+\t  return 0;\n+\t}\n+    }\n+\n+  /* Check memory model parameters for validity.  */\n+  for (x = n_param - n_model ; x < n_param; x++)\n+    {\n+      tree p = VEC_index (tree, params, x);\n+      if (TREE_CODE (p) == INTEGER_CST)\n+        {\n+\t  int i = tree_low_cst (p, 1);\n+\t  if (i < 0 || i >= MEMMODEL_LAST)\n+\t    {\n+\t      warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t\t  \"invalid memory model argument %d of %qE\", x + 1,\n+\t\t\t  function);\n+\t      return MEMMODEL_SEQ_CST;\n+\t    }\n+\t}\n+      else\n+\tif (!INTEGRAL_TYPE_P (TREE_TYPE (p)))\n+\t  {\n+\t    error_at (loc, \"non-integer memory model argument %d of %qE\", x + 1,\n+\t\t   function);\n+\t    return 0;\n+\t  }\n+      }\n+\n+  return size_0;\n+}\n+\n+\n+/* This will take an __atomic_ generic FUNCTION call, and add a size parameter N\n+   at the beginning of the parameter list PARAMS representing the size of the\n+   objects.  This is to match the library ABI requirement.  LOC is the location\n+   of the function call.  \n+   The new function is returned if it needed rebuilding, otherwise NULL_TREE is\n+   returned to allow the external call to be constructed.  */\n+\n+static tree\n+add_atomic_size_parameter (unsigned n, location_t loc, tree function, \n+\t\t\t   VEC(tree,gc) *params)\n+{\n+  tree size_node;\n+\n+  /* Insert a SIZE_T parameter as the first param.  If there isn't\n+     enough space, allocate a new vector and recursively re-build with that.  */\n+  if (!VEC_space (tree, params, 1))\n+    {\n+      unsigned int z, len;\n+      VEC(tree,gc) *vec;\n+      tree f;\n+\n+      len = VEC_length (tree, params);\n+      vec = VEC_alloc (tree, gc, len + 1);\n+      for (z = 0; z < len; z++)\n+\tVEC_quick_push (tree, vec, VEC_index (tree, params, z));\n+      f = build_function_call_vec (loc, function, vec, NULL);\n+      VEC_free (tree, gc, vec);\n+      return f;\n+    }\n+\n+  /* Add the size parameter and leave as a function call for processing.  */\n+  size_node = build_int_cst (size_type_node, n);\n+  VEC_quick_insert (tree, params, 0, size_node);\n+  return NULL_TREE;\n+}\n+\n+\n+/* This will process an __atomic_exchange function call, determine whether it\n+   needs to be mapped to the _N variation, or turned into a library call.\n+   LOC is the location of the builtin call.\n+   FUNCTION is the DECL that has been invoked;\n+   PARAMS is the argument list for the call.  The return value is non-null\n+   TRUE is returned if it is translated into the proper format for a call to the\n+   external library, and NEW_RETURN is set the tree for that function.\n+   FALSE is returned if processing for the _N variation is required, and \n+   NEW_RETURN is set to the the return value the result is copied into.  */\n+static bool\n+resolve_overloaded_atomic_exchange (location_t loc, tree function, \n+\t\t\t\t    VEC(tree,gc) *params, tree *new_return)\n+{\t\n+  tree p0, p1, p2, p3;\n+  tree I_type, I_type_ptr;\n+  int n = get_atomic_generic_size (loc, function, params);\n+\n+  /* If not a lock-free size, change to the library generic format.  */\n+  if (n != 1 && n != 2 && n != 4 && n != 8 && n != 16)\n+    {\n+      *new_return = add_atomic_size_parameter (n, loc, function, params);\n+      return true;\n+    }\n+\n+  /* Otherwise there is a lockfree match, transform the call from:\n+       void fn(T* mem, T* desired, T* return, model)\n+     into\n+       *return = (T) (fn (In* mem, (In) *desired, model))  */\n+\n+  p0 = VEC_index (tree, params, 0);\n+  p1 = VEC_index (tree, params, 1);\n+  p2 = VEC_index (tree, params, 2);\n+  p3 = VEC_index (tree, params, 3);\n+  \n+  /* Create pointer to appropriate size.  */\n+  I_type = builtin_type_for_size (BITS_PER_UNIT * n, 1);\n+  I_type_ptr = build_pointer_type (I_type);\n+\n+  /* Convert object pointer to required type.  */\n+  p0 = build1 (VIEW_CONVERT_EXPR, I_type_ptr, p0);\n+  VEC_replace (tree, params, 0, p0);\n+\n+  /* Convert new value to required type, and dereference it.  */\n+  p1 = build_indirect_ref (loc, p1, RO_UNARY_STAR);\n+  p1 = build1 (VIEW_CONVERT_EXPR, I_type, p1);\n+  VEC_replace (tree, params, 1, p1);\n+\n+  /* Move memory model to the 3rd position, and end param list.  */\n+  VEC_replace (tree, params, 2, p3);\n+  VEC_truncate (tree, params, 3);\n+\n+  /* Convert return pointer and dereference it for later assignment.  */\n+  *new_return = build_indirect_ref (loc, p2, RO_UNARY_STAR);\n+\n+  return false;\n }\n \n+\n+/* This will process an __atomic_compare_exchange function call, determine \n+   whether it needs to be mapped to the _N variation, or turned into a lib call.\n+   LOC is the location of the builtin call.\n+   FUNCTION is the DECL that has been invoked;\n+   PARAMS is the argument list for the call.  The return value is non-null\n+   TRUE is returned if it is translated into the proper format for a call to the\n+   external library, and NEW_RETURN is set the tree for that function.\n+   FALSE is returned if processing for the _N variation is required.  */\n+\n+static bool\n+resolve_overloaded_atomic_compare_exchange (location_t loc, tree function, \n+\t\t\t\t\t    VEC(tree,gc) *params, \n+\t\t\t\t\t    tree *new_return)\n+{\t\n+  tree p0, p1, p2;\n+  tree I_type, I_type_ptr;\n+  int n = get_atomic_generic_size (loc, function, params);\n+\n+  /* If not a lock-free size, change to the library generic format.  */\n+  if (n != 1 && n != 2 && n != 4 && n != 8 && n != 16)\n+    {\n+      /* The library generic format does not have the weak parameter, so \n+\t remove it from the param list.  Since a parameter has been removed,\n+\t we can be sure that there is room for the SIZE_T parameter, meaning\n+\t there will not be a recursive rebuilding of the parameter list, so\n+\t there is no danger this will be done twice.  */\n+      if (n > 0)\n+        {\n+\t  VEC_replace (tree, params, 3, VEC_index (tree, params, 4));\n+\t  VEC_replace (tree, params, 4, VEC_index (tree, params, 5));\n+\t  VEC_truncate (tree, params, 5);\n+\t}\n+      *new_return = add_atomic_size_parameter (n, loc, function, params);\n+      return true;\n+    }\n+\n+  /* Otherwise, there is a match, so the call needs to be transformed from:\n+       bool fn(T* mem, T* desired, T* return, weak, success, failure)\n+     into\n+       bool fn ((In *)mem, (In *)expected, (In) *desired, weak, succ, fail)  */\n+\n+  p0 = VEC_index (tree, params, 0);\n+  p1 = VEC_index (tree, params, 1);\n+  p2 = VEC_index (tree, params, 2);\n+  \n+  /* Create pointer to appropriate size.  */\n+  I_type = builtin_type_for_size (BITS_PER_UNIT * n, 1);\n+  I_type_ptr = build_pointer_type (I_type);\n+\n+  /* Convert object pointer to required type.  */\n+  p0 = build1 (VIEW_CONVERT_EXPR, I_type_ptr, p0);\n+  VEC_replace (tree, params, 0, p0);\n+\n+  /* Convert expected pointer to required type.  */\n+  p1 = build1 (VIEW_CONVERT_EXPR, I_type_ptr, p1);\n+  VEC_replace (tree, params, 1, p1);\n+\n+  /* Convert desired value to required type, and dereference it.  */\n+  p2 = build_indirect_ref (loc, p2, RO_UNARY_STAR);\n+  p2 = build1 (VIEW_CONVERT_EXPR, I_type, p2);\n+  VEC_replace (tree, params, 2, p2);\n+\n+  /* The rest of the parameters are fine. NULL means no special return value\n+     processing.*/\n+  *new_return = NULL;\n+  return false;\n+}\n+\n+\n+/* This will process an __atomic_load function call, determine whether it\n+   needs to be mapped to the _N variation, or turned into a library call.\n+   LOC is the location of the builtin call.\n+   FUNCTION is the DECL that has been invoked;\n+   PARAMS is the argument list for the call.  The return value is non-null\n+   TRUE is returned if it is translated into the proper format for a call to the\n+   external library, and NEW_RETURN is set the tree for that function.\n+   FALSE is returned if processing for the _N variation is required, and \n+   NEW_RETURN is set to the the return value the result is copied into.  */\n+\n+static bool\n+resolve_overloaded_atomic_load (location_t loc, tree function, \n+\t\t\t\tVEC(tree,gc) *params, tree *new_return)\n+{\t\n+  tree p0, p1, p2;\n+  tree I_type, I_type_ptr;\n+  int n = get_atomic_generic_size (loc, function, params);\n+\n+  /* If not a lock-free size, change to the library generic format.  */\n+  if (n != 1 && n != 2 && n != 4 && n != 8 && n != 16)\n+    {\n+      *new_return = add_atomic_size_parameter (n, loc, function, params);\n+      return true;\n+    }\n+\n+  /* Otherwise, there is a match, so the call needs to be transformed from:\n+       void fn(T* mem, T* return, model)\n+     into\n+       *return = (T) (fn ((In *) mem, model))  */\n+\n+  p0 = VEC_index (tree, params, 0);\n+  p1 = VEC_index (tree, params, 1);\n+  p2 = VEC_index (tree, params, 2);\n+  \n+  /* Create pointer to appropriate size.  */\n+  I_type = builtin_type_for_size (BITS_PER_UNIT * n, 1);\n+  I_type_ptr = build_pointer_type (I_type);\n+\n+  /* Convert object pointer to required type.  */\n+  p0 = build1 (VIEW_CONVERT_EXPR, I_type_ptr, p0);\n+  VEC_replace (tree, params, 0, p0);\n+\n+  /* Move memory model to the 2nd position, and end param list.  */\n+  VEC_replace (tree, params, 1, p2);\n+  VEC_truncate (tree, params, 2);\n+\n+  /* Convert return pointer and dereference it for later assignment.  */\n+  *new_return = build_indirect_ref (loc, p1, RO_UNARY_STAR);\n+\n+  return false;\n+}\n+\n+\n+/* This will process an __atomic_store function call, determine whether it\n+   needs to be mapped to the _N variation, or turned into a library call.\n+   LOC is the location of the builtin call.\n+   FUNCTION is the DECL that has been invoked;\n+   PARAMS is the argument list for the call.  The return value is non-null\n+   TRUE is returned if it is translated into the proper format for a call to the\n+   external library, and NEW_RETURN is set the tree for that function.\n+   FALSE is returned if processing for the _N variation is required, and \n+   NEW_RETURN is set to the the return value the result is copied into.  */\n+\n+static bool\n+resolve_overloaded_atomic_store (location_t loc, tree function, \n+\t\t\t\t VEC(tree,gc) *params, tree *new_return)\n+{\t\n+  tree p0, p1;\n+  tree I_type, I_type_ptr;\n+  int n = get_atomic_generic_size (loc, function, params);\n+\n+  /* If not a lock-free size, change to the library generic format.  */\n+  if (n != 1 && n != 2 && n != 4 && n != 8 && n != 16)\n+    {\n+      *new_return = add_atomic_size_parameter (n, loc, function, params);\n+      return true;\n+    }\n+\n+  /* Otherwise, there is a match, so the call needs to be transformed from:\n+       void fn(T* mem, T* value, model)\n+     into\n+       fn ((In *) mem, (In) *value, model)  */\n+\n+  p0 = VEC_index (tree, params, 0);\n+  p1 = VEC_index (tree, params, 1);\n+  \n+  /* Create pointer to appropriate size.  */\n+  I_type = builtin_type_for_size (BITS_PER_UNIT * n, 1);\n+  I_type_ptr = build_pointer_type (I_type);\n+\n+  /* Convert object pointer to required type.  */\n+  p0 = build1 (VIEW_CONVERT_EXPR, I_type_ptr, p0);\n+  VEC_replace (tree, params, 0, p0);\n+\n+  /* Convert new value to required type, and dereference it.  */\n+  p1 = build_indirect_ref (loc, p1, RO_UNARY_STAR);\n+  p1 = build1 (VIEW_CONVERT_EXPR, I_type, p1);\n+  VEC_replace (tree, params, 1, p1);\n+  \n+  /* The memory model is in the right spot already. Return is void.  */\n+  *new_return = NULL_TREE;\n+\n+  return false;\n+}\n+\n+\n /* Some builtin functions are placeholders for other expressions.  This\n    function should be called immediately after parsing the call expression\n    before surrounding code has committed to the type of the expression.\n@@ -9086,6 +9475,9 @@ tree\n resolve_overloaded_builtin (location_t loc, tree function, VEC(tree,gc) *params)\n {\n   enum built_in_function orig_code = DECL_FUNCTION_CODE (function);\n+  bool orig_format = true;\n+  tree new_return = NULL_TREE;\n+\n   switch (DECL_BUILT_IN_CLASS (function))\n     {\n     case BUILT_IN_NORMAL:\n@@ -9102,6 +9494,78 @@ resolve_overloaded_builtin (location_t loc, tree function, VEC(tree,gc) *params)\n   /* Handle BUILT_IN_NORMAL here.  */\n   switch (orig_code)\n     {\n+    case BUILT_IN_ATOMIC_EXCHANGE:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE:\n+    case BUILT_IN_ATOMIC_LOAD:\n+    case BUILT_IN_ATOMIC_STORE:\n+      {\n+\t/* Handle these 4 together so that they can fall through to the next\n+\t   case if the call is transformed to an _N variant.  */\n+        switch (orig_code)\n+\t{\n+\t  case BUILT_IN_ATOMIC_EXCHANGE:\n+\t    {\n+\t      if (resolve_overloaded_atomic_exchange (loc, function, params,\n+\t\t\t\t\t\t      &new_return))\n+\t\treturn new_return;\n+\t      /* Change to the _N variant.  */\n+\t      orig_code = BUILT_IN_ATOMIC_EXCHANGE_N;\n+\t      break;\n+\t    }\n+\n+\t  case BUILT_IN_ATOMIC_COMPARE_EXCHANGE:\n+\t    {\n+\t      if (resolve_overloaded_atomic_compare_exchange (loc, function,\n+\t\t\t\t\t\t\t      params,\n+\t\t\t\t\t\t\t      &new_return))\n+\t\treturn new_return;\n+\t      /* Change to the _N variant.  */\n+\t      orig_code = BUILT_IN_ATOMIC_COMPARE_EXCHANGE_N;\n+\t      break;\n+\t    }\n+\t  case BUILT_IN_ATOMIC_LOAD:\n+\t    {\n+\t      if (resolve_overloaded_atomic_load (loc, function, params,\n+\t\t\t\t\t\t  &new_return))\n+\t\treturn new_return;\n+\t      /* Change to the _N variant.  */\n+\t      orig_code = BUILT_IN_ATOMIC_LOAD_N;\n+\t      break;\n+\t    }\n+\t  case BUILT_IN_ATOMIC_STORE:\n+\t    {\n+\t      if (resolve_overloaded_atomic_store (loc, function, params,\n+\t\t\t\t\t\t   &new_return))\n+\t\treturn new_return;\n+\t      /* Change to the _N variant.  */\n+\t      orig_code = BUILT_IN_ATOMIC_STORE_N;\n+\t      break;\n+\t    }\n+\t  default:\n+\t    gcc_unreachable ();\n+\t}\n+\t/* Fallthrough to the normal processing.  */\n+      }\n+    case BUILT_IN_ATOMIC_EXCHANGE_N:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_N:\n+    case BUILT_IN_ATOMIC_LOAD_N:\n+    case BUILT_IN_ATOMIC_STORE_N:\n+    case BUILT_IN_ATOMIC_ADD_FETCH_N:\n+    case BUILT_IN_ATOMIC_SUB_FETCH_N:\n+    case BUILT_IN_ATOMIC_AND_FETCH_N:\n+    case BUILT_IN_ATOMIC_NAND_FETCH_N:\n+    case BUILT_IN_ATOMIC_XOR_FETCH_N:\n+    case BUILT_IN_ATOMIC_OR_FETCH_N:\n+    case BUILT_IN_ATOMIC_FETCH_ADD_N:\n+    case BUILT_IN_ATOMIC_FETCH_SUB_N:\n+    case BUILT_IN_ATOMIC_FETCH_AND_N:\n+    case BUILT_IN_ATOMIC_FETCH_NAND_N:\n+    case BUILT_IN_ATOMIC_FETCH_XOR_N:\n+    case BUILT_IN_ATOMIC_FETCH_OR_N:\n+      {\n+        orig_format = false;\n+\t/* Fallthru for parameter processing.  */\n+      }\n     case BUILT_IN_SYNC_FETCH_AND_ADD_N:\n     case BUILT_IN_SYNC_FETCH_AND_SUB_N:\n     case BUILT_IN_SYNC_FETCH_AND_OR_N:\n@@ -9128,15 +9592,31 @@ resolve_overloaded_builtin (location_t loc, tree function, VEC(tree,gc) *params)\n \n \tfncode = (enum built_in_function)((int)orig_code + exact_log2 (n) + 1);\n \tnew_function = builtin_decl_explicit (fncode);\n-\tif (!sync_resolve_params (function, new_function, params))\n+\tif (!sync_resolve_params (loc, function, new_function, params,\n+\t\t\t\t  orig_format))\n \t  return error_mark_node;\n \n \tfirst_param = VEC_index (tree, params, 0);\n \tresult = build_function_call_vec (loc, new_function, params, NULL);\n+\tif (result == error_mark_node)\n+\t  return result;\n \tif (orig_code != BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_N\n-\t    && orig_code != BUILT_IN_SYNC_LOCK_RELEASE_N)\n-\t  result = sync_resolve_return (first_param, result);\n+\t    && orig_code != BUILT_IN_SYNC_LOCK_RELEASE_N\n+\t    && orig_code != BUILT_IN_ATOMIC_STORE_N)\n+\t  result = sync_resolve_return (first_param, result, orig_format);\n \n+\t/* If new_return is set, assign function to that expr and cast the\n+\t   result to void since the generic interface returned void.  */\n+\tif (new_return)\n+\t  {\n+\t    /* Cast function result from I{1,2,4,8,16} to the required type.  */\n+\t    result = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (new_return), result);\n+\t    result = build2 (MODIFY_EXPR, TREE_TYPE (new_return), new_return,\n+\t\t\t     result);\n+\t    TREE_SIDE_EFFECTS (result) = 1;\n+\t    protected_set_expr_location (result, loc);\n+\t    result = convert (void_type_node, result);\n+\t  }\n \treturn result;\n       }\n "}, {"sha": "bf83c261c20581fa27d829f947fb20f08578e77f", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -758,30 +758,50 @@ c_cpp_builtins (cpp_reader *pfile)\n \n   /* Tell source code if the compiler makes sync_compare_and_swap\n      builtins available.  */\n-#ifdef HAVE_sync_compare_and_swapqi\n-  if (HAVE_sync_compare_and_swapqi)\n-    cpp_define (pfile, \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1\");\n+#ifndef HAVE_sync_compare_and_swapqi\n+#define HAVE_sync_compare_and_swapqi 0\n+#endif\n+#ifndef HAVE_atomic_compare_and_swapqi\n+#define HAVE_atomic_compare_and_swapqi 0\n #endif\n+  if (HAVE_sync_compare_and_swapqi || HAVE_atomic_compare_and_swapqi)\n+    cpp_define (pfile, \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1\");\n \n-#ifdef HAVE_sync_compare_and_swaphi\n-  if (HAVE_sync_compare_and_swaphi)\n-    cpp_define (pfile, \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2\");\n+#ifndef HAVE_sync_compare_and_swaphi\n+#define HAVE_sync_compare_and_swaphi 0\n #endif\n+#ifndef HAVE_atomic_compare_and_swaphi\n+#define HAVE_atomic_compare_and_swaphi 0\n+#endif\n+  if (HAVE_sync_compare_and_swaphi || HAVE_atomic_compare_and_swaphi)\n+    cpp_define (pfile, \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2\");\n \n-#ifdef HAVE_sync_compare_and_swapsi\n-  if (HAVE_sync_compare_and_swapsi)\n-    cpp_define (pfile, \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\");\n+#ifndef HAVE_sync_compare_and_swapsi\n+#define HAVE_sync_compare_and_swapsi 0\n+#endif\n+#ifndef HAVE_atomic_compare_and_swapsi\n+#define HAVE_atomic_compare_and_swapsi 0\n #endif\n+  if (HAVE_sync_compare_and_swapsi || HAVE_atomic_compare_and_swapsi)\n+    cpp_define (pfile, \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\");\n \n-#ifdef HAVE_sync_compare_and_swapdi\n-  if (HAVE_sync_compare_and_swapdi)\n-    cpp_define (pfile, \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8\");\n+#ifndef HAVE_sync_compare_and_swapdi\n+#define HAVE_sync_compare_and_swapdi 0\n #endif\n+#ifndef HAVE_atomic_compare_and_swapdi\n+#define HAVE_atomic_compare_and_swapdi 0\n+#endif\n+  if (HAVE_sync_compare_and_swapdi || HAVE_atomic_compare_and_swapdi)\n+    cpp_define (pfile, \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8\");\n \n-#ifdef HAVE_sync_compare_and_swapti\n-  if (HAVE_sync_compare_and_swapti)\n-    cpp_define (pfile, \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_16\");\n+#ifndef HAVE_sync_compare_and_swapti\n+#define HAVE_sync_compare_and_swapti 0\n+#endif\n+#ifndef HAVE_atomic_compare_and_swapti\n+#define HAVE_atomic_compare_and_swapti 0\n #endif\n+  if (HAVE_sync_compare_and_swapti || HAVE_atomic_compare_and_swapti)\n+    cpp_define (pfile, \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_16\");\n \n #ifdef DWARF2_UNWIND_INFO\n   if (dwarf2out_do_cfi_asm ())"}, {"sha": "392ac652c0a6f8bdab09c15f26ca449f569de6b1", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -2717,6 +2717,10 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n \n       name = DECL_NAME (function);\n       fundecl = function;\n+      /* Atomic functions have type checking/casting already done.  They are \n+\t often rewritten and don't match the original parameter list.  */\n+      if (name && !strncmp (IDENTIFIER_POINTER (name), \"__atomic_\", 9))\n+        origtypes = NULL;\n     }\n   if (TREE_CODE (TREE_TYPE (function)) == FUNCTION_TYPE)\n     function = function_to_pointer_conversion (loc, function);"}, {"sha": "1871054a21c0dc569a126376eb24cc9b73933d33", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -551,6 +551,10 @@ Winline\n Common Var(warn_inline) Warning\n Warn when an inlined function cannot be inlined\n \n+Winvalid-memory-model\n+Common Var(warn_invalid_memory_model) Init(1) Warning\n+Warn when an atomic memory model parameter is known to be outside the valid range.\n+\n Wlarger-than-\n Common RejectNegative Joined Warning Undocumented Alias(Wlarger-than=)\n \n@@ -1266,6 +1270,10 @@ finline-limit=\n Common RejectNegative Joined UInteger\n -finline-limit=<number>\tLimit the size of inlined functions to <number>\n \n+finline-atomics\n+Common Report Var(flag_inline_atomics) Init(1) Optimization\n+Inline __atomic operations when a lock free instruction sequence is available.\n+\n finstrument-functions\n Common Report Var(flag_instrument_function_entry_exit)\n Instrument function entry and exit with profiling calls"}, {"sha": "39c4cd73f69e0a4ba37bbbd261723b4483799e8e", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -248,6 +248,9 @@\n   ;; For BMI2 support\n   UNSPEC_PDEP\n   UNSPEC_PEXT\n+\n+  ;; For __atomic support\n+  UNSPEC_MOVA\n ])\n \n (define_c_enum \"unspecv\" [\n@@ -262,7 +265,10 @@\n   UNSPECV_ALIGN\n   UNSPECV_MONITOR\n   UNSPECV_MWAIT\n-  UNSPECV_CMPXCHG\n+  UNSPECV_CMPXCHG_1\n+  UNSPECV_CMPXCHG_2\n+  UNSPECV_CMPXCHG_3\n+  UNSPECV_CMPXCHG_4\n   UNSPECV_XCHG\n   UNSPECV_LOCK\n   UNSPECV_PROLOGUE_USE"}, {"sha": "0ff17123f27539239309e6d5a6e9a926503feb10", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 326, "deletions": 129, "changes": 455, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -18,159 +18,343 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-(define_mode_iterator CASMODE\n-  [QI HI SI (DI \"TARGET_64BIT || TARGET_CMPXCHG8B\")\n-\t    (TI \"TARGET_64BIT && TARGET_CMPXCHG16B\")])\n-(define_mode_iterator DCASMODE\n-  [(DI \"!TARGET_64BIT && TARGET_CMPXCHG8B && !flag_pic\")\n-   (TI \"TARGET_64BIT && TARGET_CMPXCHG16B\")])\n-(define_mode_attr doublemodesuffix [(DI \"8\") (TI \"16\")])\n-(define_mode_attr DCASHMODE [(DI \"SI\") (TI \"DI\")])\n-\n-(define_expand \"memory_barrier\"\n-  [(set (match_dup 0)\n-\t(unspec:BLK [(match_dup 0)] UNSPEC_MFENCE))]\n+(define_expand \"mem_thread_fence\"\n+  [(match_operand:SI 0 \"const_int_operand\" \"\")]\t\t;; model\n   \"\"\n {\n-  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n-  MEM_VOLATILE_P (operands[0]) = 1;\n+  /* Unless this is a SEQ_CST fence, the i386 memory model is strong\n+     enough not to require barriers of any kind.  */\n+  if (INTVAL (operands[0]) != MEMMODEL_SEQ_CST)\n+    DONE;\n \n-  if (!(TARGET_64BIT || TARGET_SSE2))\n+  if (TARGET_64BIT || TARGET_SSE2)\n+    emit_insn (gen_sse2_mfence ());\n+  else\n     {\n-      emit_insn (gen_memory_barrier_nosse (operands[0]));\n-      DONE;\n+      rtx mem = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+      MEM_VOLATILE_P (mem) = 1;\n+      emit_insn (gen_mfence_nosse (mem));\n     }\n+  DONE;\n })\n \n-(define_insn \"memory_barrier_nosse\"\n+(define_insn \"mfence_nosse\"\n   [(set (match_operand:BLK 0 \"\" \"\")\n \t(unspec:BLK [(match_dup 0)] UNSPEC_MFENCE))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!(TARGET_64BIT || TARGET_SSE2)\"\n   \"lock{%;} or{l}\\t{$0, (%%esp)|DWORD PTR [esp], 0}\"\n   [(set_attr \"memory\" \"unknown\")])\n \n-;; ??? It would be possible to use cmpxchg8b on pentium for DImode\n-;; changes.  It's complicated because the insn uses ecx:ebx as the\n-;; new value; note that the registers are reversed from the order\n-;; that they'd be in with (reg:DI 2 ecx).  Similarly for TImode\n-;; data in 64-bit mode.\n-\n-(define_expand \"sync_compare_and_swap<mode>\"\n-  [(parallel\n-    [(set (match_operand:CASMODE 0 \"register_operand\" \"\")\n-\t  (match_operand:CASMODE 1 \"memory_operand\" \"\"))\n-     (set (match_dup 1)\n-\t  (unspec_volatile:CASMODE\n-\t    [(match_dup 1)\n-\t     (match_operand:CASMODE 2 \"register_operand\" \"\")\n-\t     (match_operand:CASMODE 3 \"register_operand\" \"\")]\n-\t    UNSPECV_CMPXCHG))\n-   (set (reg:CCZ FLAGS_REG)\n-        (compare:CCZ\n-          (unspec_volatile:CASMODE\n-            [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG)\n-          (match_dup 2)))])]\n-  \"TARGET_CMPXCHG\"\n+;; ??? From volume 3 section 7.1.1 Guaranteed Atomic Operations,\n+;; Only beginning at Pentium family processors do we get any guarantee of\n+;; atomicity in aligned 64-bit quantities.  Beginning at P6, we get a\n+;; guarantee for 64-bit accesses that do not cross a cacheline boundary.\n+;;\n+;; Note that the TARGET_CMPXCHG8B test below is a stand-in for \"Pentium\".\n+;;\n+;; Importantly, *no* processor makes atomicity guarantees for larger\n+;; accesses.  In particular, there's no way to perform an atomic TImode\n+;; move, despite the apparent applicability of MOVDQA et al.\n+\n+(define_mode_iterator ATOMIC\n+   [QI HI SI\n+    (DI \"TARGET_64BIT || (TARGET_CMPXCHG8B && (TARGET_80387 || TARGET_SSE))\")\n+   ])\n+\n+(define_expand \"atomic_load<mode>\"\n+  [(set (match_operand:ATOMIC 0 \"register_operand\" \"\")\n+\t(unspec:ATOMIC [(match_operand:ATOMIC 1 \"memory_operand\" \"\")\n+\t\t\t(match_operand:SI 2 \"const_int_operand\" \"\")]\n+\t\t       UNSPEC_MOVA))]\n+  \"\"\n+{\n+  /* For DImode on 32-bit, we can use the FPU to perform the load.  */\n+  if (<MODE>mode == DImode && !TARGET_64BIT)\n+    emit_insn (gen_atomic_loaddi_fpu\n+\t       (operands[0], operands[1],\n+\t        assign_386_stack_local (DImode,\n+\t\t\t\t\t(virtuals_instantiated\n+\t\t\t\t\t ? SLOT_TEMP : SLOT_VIRTUAL))));\n+  else\n+    emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"atomic_loaddi_fpu\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=x,m,?r\")\n+\t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m,m,m\")]\n+\t\t   UNSPEC_MOVA))\n+   (clobber (match_operand:DI 2 \"memory_operand\" \"=X,X,m\"))\n+   (clobber (match_scratch:DF 3 \"=X,xf,xf\"))]\n+  \"!TARGET_64BIT && (TARGET_80387 || TARGET_SSE)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx dst = operands[0], src = operands[1];\n+  rtx mem = operands[2], tmp = operands[3];\n+\n+  if (SSE_REG_P (dst))\n+    emit_move_insn (dst, src);\n+  else\n+    {\n+      if (MEM_P (dst))\n+\tmem = dst;\n+\n+      if (FP_REG_P (tmp))\n+\temit_insn (gen_movdi_via_fpu (mem, src, tmp));\n+      else\n+\t{\n+\t  adjust_reg_mode (tmp, DImode);\n+\t  emit_move_insn (tmp, src);\n+\t  emit_move_insn (mem, tmp);\n+\t}\n+\n+      if (mem != dst)\n+\temit_move_insn (dst, mem);\n+    }\n+  DONE;\n+})\n+\n+(define_expand \"atomic_store<mode>\"\n+  [(set (match_operand:ATOMIC 0 \"memory_operand\" \"\")\n+\t(unspec:ATOMIC [(match_operand:ATOMIC 1 \"register_operand\" \"\")\n+\t\t\t(match_operand:SI 2 \"const_int_operand\" \"\")]\n+\t\t       UNSPEC_MOVA))]\n+  \"\"\n+{\n+  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+\n+  if (<MODE>mode == DImode && !TARGET_64BIT)\n+    {\n+      /* For DImode on 32-bit, we can use the FPU to perform the store.  */\n+      /* Note that while we could perform a cmpxchg8b loop, that turns\n+\t out to be significantly larger than this plus a barrier.  */\n+      emit_insn (gen_atomic_storedi_fpu\n+\t\t (operands[0], operands[1],\n+\t          assign_386_stack_local (DImode,\n+\t\t\t\t\t  (virtuals_instantiated\n+\t\t\t\t\t   ? SLOT_TEMP : SLOT_VIRTUAL))));\n+    }\n+  else\n+    {\n+      /* For seq-cst stores, when we lack MFENCE, use XCHG.  */\n+      if (model == MEMMODEL_SEQ_CST && !(TARGET_64BIT || TARGET_SSE2))\n+\t{\n+\t  emit_insn (gen_atomic_exchange<mode> (gen_reg_rtx (<MODE>mode),\n+\t\t\t\t\t\toperands[0], operands[1],\n+\t\t\t\t\t\toperands[2]));\n+\t  DONE;\n+\t}\n+\n+      /* Otherwise use a normal store.  */\n+      emit_move_insn (operands[0], operands[1]);\n+    }\n+  /* ... followed by an MFENCE, if required.  */\n+  if (model == MEMMODEL_SEQ_CST)\n+    emit_insn (gen_mem_thread_fence (operands[2]));\n+  DONE;\n+})\n+\n+(define_insn_and_split \"atomic_storedi_fpu\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=m,m,m\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"x,m,?r\")]\n+\t\t   UNSPEC_MOVA))\n+   (clobber (match_operand:DI 2 \"memory_operand\" \"=X,X,m\"))\n+   (clobber (match_scratch:DF 3 \"=X,xf,xf\"))]\n+  \"!TARGET_64BIT && (TARGET_80387 || TARGET_SSE)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n {\n-  if ((<MODE>mode == DImode && !TARGET_64BIT) || <MODE>mode == TImode)\n+  rtx dst = operands[0], src = operands[1];\n+  rtx mem = operands[2], tmp = operands[3];\n+\n+  if (!SSE_REG_P (src))\n     {\n-      enum machine_mode hmode = <MODE>mode == DImode ? SImode : DImode;\n-      rtx low = simplify_gen_subreg (hmode, operands[3], <MODE>mode, 0);\n-      rtx high = simplify_gen_subreg (hmode, operands[3], <MODE>mode,\n-\t\t\t\t      GET_MODE_SIZE (hmode));\n-      low = force_reg (hmode, low);\n-      high = force_reg (hmode, high);\n-      if (<MODE>mode == DImode)\n+      if (REG_P (src))\n+\t{\n+\t  emit_move_insn (mem, src);\n+\t  src = mem;\n+\t}\n+\n+      if (FP_REG_P (tmp))\n \t{\n-\t  if (flag_pic && !cmpxchg8b_pic_memory_operand (operands[1], DImode))\n-\t    operands[1] = replace_equiv_address (operands[1],\n-\t\t\t\t\t\t force_reg (Pmode,\n-\t\t\t\t\t\t\t    XEXP (operands[1],\n-\t\t\t\t\t\t\t\t  0)));\n-\t  emit_insn (gen_sync_double_compare_and_swapdi\n-\t\t     (operands[0], operands[1], operands[2], low, high));\n+\t  emit_insn (gen_movdi_via_fpu (dst, src, tmp));\n+\t  DONE;\n \t}\n-      else if (<MODE>mode == TImode)\n-\temit_insn (gen_sync_double_compare_and_swapti\n-\t\t   (operands[0], operands[1], operands[2], low, high));\n       else\n-\tgcc_unreachable ();\n-      DONE;\n+\t{\n+\t  adjust_reg_mode (tmp, DImode);\n+\t  emit_move_insn (tmp, mem);\n+\t  src = tmp;\n+\t}\n     }\n+  emit_move_insn (dst, src);\n+  DONE;\n+})\n+\n+;; ??? You'd think that we'd be able to perform this via FLOAT + FIX_TRUNC\n+;; operations.  But the fix_trunc patterns want way more setup than we want\n+;; to provide.  Note that the scratch is DFmode instead of XFmode in order\n+;; to make it easy to allocate a scratch in either SSE or FP_REGs above.\n+(define_insn \"movdi_via_fpu\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n+\t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")] UNSPEC_MOVA))\n+   (clobber (match_operand:DF 2 \"register_operand\" \"=f\"))]\n+  \"TARGET_80387\"\n+  \"fild\\t%1\\;fistp\\t%0\"\n+  [(set_attr \"type\" \"multi\")\n+   ;; Worst case based on full sib+offset32 addressing modes\n+   (set_attr \"length\" \"14\")])\n+\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:QI 0 \"register_operand\" \"\")\t\t;; bool success output\n+   (match_operand:SWI124 1 \"register_operand\" \"\")\t;; oldval output\n+   (match_operand:SWI124 2 \"memory_operand\" \"\")\t\t;; memory\n+   (match_operand:SWI124 3 \"register_operand\" \"\")\t;; expected input\n+   (match_operand:SWI124 4 \"register_operand\" \"\")\t;; newval input\n+   (match_operand:SI 5 \"const_int_operand\" \"\")\t\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\" \"\")\t\t;; success model\n+   (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t;; failure model\n+  \"TARGET_CMPXCHG\"\n+{\n+  emit_insn (gen_atomic_compare_and_swap_single<mode>\n+\t     (operands[1], operands[2], operands[3], operands[4]));\n+  ix86_expand_setcc (operands[0], EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n+\t\t     const0_rtx);\n+  DONE;\n })\n \n-(define_insn \"*sync_compare_and_swap<mode>\"\n+(define_mode_iterator CASMODE\n+  [(DI \"TARGET_64BIT || TARGET_CMPXCHG8B\")\n+   (TI \"TARGET_64BIT && TARGET_CMPXCHG16B\")])\n+(define_mode_iterator DCASMODE\n+  [(DI \"!TARGET_64BIT && TARGET_CMPXCHG8B && !flag_pic\")\n+   (TI \"TARGET_64BIT && TARGET_CMPXCHG16B\")])\n+(define_mode_attr doublemodesuffix [(DI \"8\") (TI \"16\")])\n+(define_mode_attr DCASHMODE [(DI \"SI\") (TI \"DI\")])\n+\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:QI 0 \"register_operand\" \"\")\t\t;; bool success output\n+   (match_operand:CASMODE 1 \"register_operand\" \"\")\t;; oldval output\n+   (match_operand:CASMODE 2 \"memory_operand\" \"\")\t;; memory\n+   (match_operand:CASMODE 3 \"register_operand\" \"\")\t;; expected input\n+   (match_operand:CASMODE 4 \"register_operand\" \"\")\t;; newval input\n+   (match_operand:SI 5 \"const_int_operand\" \"\")\t\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\" \"\")\t\t;; success model\n+   (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t;; failure model\n+  \"TARGET_CMPXCHG\"\n+{\n+  if (<MODE>mode == DImode && TARGET_64BIT)\n+    {\n+      emit_insn (gen_atomic_compare_and_swap_singledi\n+\t\t (operands[1], operands[2], operands[3], operands[4]));\n+    }\n+  else\n+    {\n+      enum machine_mode hmode = <DCASHMODE>mode;\n+      rtx lo_o, lo_e, lo_n, hi_o, hi_e, hi_n, mem;\n+\n+      lo_o = operands[1];\n+      mem  = operands[2];\n+      lo_e = operands[3];\n+      lo_n = operands[4];\n+      hi_o = gen_highpart (hmode, lo_o);\n+      hi_e = gen_highpart (hmode, lo_e);\n+      hi_n = gen_highpart (hmode, lo_n);\n+      lo_o = gen_lowpart (hmode, lo_o);\n+      lo_e = gen_lowpart (hmode, lo_e);\n+      lo_n = gen_lowpart (hmode, lo_n);\n+\n+      if (<MODE>mode == DImode\n+\t  && !TARGET_64BIT\n+\t  && flag_pic\n+\t  && !cmpxchg8b_pic_memory_operand (mem, DImode))\n+\tmem = replace_equiv_address (mem, force_reg (Pmode, XEXP (mem, 0)));\n+\n+      emit_insn (gen_atomic_compare_and_swap_double<mode>\n+\t\t (lo_o, hi_o, mem, lo_e, hi_e, lo_n, hi_n));\n+    }\n+  ix86_expand_setcc (operands[0], EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n+\t\t     const0_rtx);\n+  DONE;\n+})\n+\n+(define_insn \"atomic_compare_and_swap_single<mode>\"\n   [(set (match_operand:SWI 0 \"register_operand\" \"=a\")\n-\t(match_operand:SWI 1 \"memory_operand\" \"+m\"))\n-   (set (match_dup 1)\n \t(unspec_volatile:SWI\n-\t  [(match_dup 1)\n-\t   (match_operand:SWI 2 \"register_operand\" \"a\")\n+\t  [(match_operand:SWI 1 \"memory_operand\" \"+m\")\n+\t   (match_operand:SWI 2 \"register_operand\" \"0\")\n \t   (match_operand:SWI 3 \"register_operand\" \"<r>\")]\n-\t  UNSPECV_CMPXCHG))\n+\t  UNSPECV_CMPXCHG_1))\n+   (set (match_dup 1)\n+\t(unspec_volatile:SWI [(const_int 0)] UNSPECV_CMPXCHG_2))\n    (set (reg:CCZ FLAGS_REG)\n-        (compare:CCZ\n-          (unspec_volatile:SWI\n-            [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG)\n-          (match_dup 2)))]\n+        (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG_3))]\n   \"TARGET_CMPXCHG\"\n   \"lock{%;} cmpxchg{<imodesuffix>}\\t{%3, %1|%1, %3}\")\n \n-(define_insn \"sync_double_compare_and_swap<mode>\"\n-  [(set (match_operand:DCASMODE 0 \"register_operand\" \"=A\")\n-\t(match_operand:DCASMODE 1 \"memory_operand\" \"+m\"))\n-   (set (match_dup 1)\n-\t(unspec_volatile:DCASMODE\n-\t  [(match_dup 1)\n-\t   (match_operand:DCASMODE 2 \"register_operand\" \"A\")\n-\t   (match_operand:<DCASHMODE> 3 \"register_operand\" \"b\")\n-\t   (match_operand:<DCASHMODE> 4 \"register_operand\" \"c\")]\n-\t  UNSPECV_CMPXCHG))\n+;; For double-word compare and swap, we are obliged to play tricks with\n+;; the input newval (op5:op6) because the Intel register numbering does\n+;; not match the gcc register numbering, so the pair must be CX:BX.\n+;; That said, in order to take advantage of possible lower-subreg opts,\n+;; treat all of the integral operands in the same way.\n+(define_insn \"atomic_compare_and_swap_double<mode>\"\n+  [(set (match_operand:<DCASHMODE> 0 \"register_operand\" \"=a\")\n+\t(unspec_volatile:<DCASHMODE>\n+\t  [(match_operand:DCASMODE 2 \"memory_operand\" \"+m\")\n+\t   (match_operand:<DCASHMODE> 3 \"register_operand\" \"0\")\n+\t   (match_operand:<DCASHMODE> 4 \"register_operand\" \"1\")\n+\t   (match_operand:<DCASHMODE> 5 \"register_operand\" \"b\")\n+\t   (match_operand:<DCASHMODE> 6 \"register_operand\" \"c\")]\n+\t  UNSPECV_CMPXCHG_1))\n+   (set (match_operand:<DCASHMODE> 1 \"register_operand\" \"=d\")\n+\t(unspec_volatile:<DCASHMODE> [(const_int 0)] UNSPECV_CMPXCHG_2))\n+   (set (match_dup 2)\n+\t(unspec_volatile:DCASMODE [(const_int 0)] UNSPECV_CMPXCHG_3))\n    (set (reg:CCZ FLAGS_REG)\n-        (compare:CCZ\n-          (unspec_volatile:DCASMODE\n-            [(match_dup 1) (match_dup 2) (match_dup 3) (match_dup 4)]\n-\t    UNSPECV_CMPXCHG)\n-          (match_dup 2)))]\n+        (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG_4))]\n   \"\"\n-  \"lock{%;} cmpxchg<doublemodesuffix>b\\t%1\")\n-\n-;; Theoretically we'd like to use constraint \"r\" (any reg) for operand\n-;; 3, but that includes ecx.  If operand 3 and 4 are the same (like when\n-;; the input is -1LL) GCC might chose to allocate operand 3 to ecx, like\n-;; operand 4.  This breaks, as the xchg will move the PIC register contents\n-;; to %ecx then --> boom.  Operands 3 and 4 really need to be different\n-;; registers, which in this case means operand 3 must not be ecx.\n-;; Instead of playing tricks with fake early clobbers or the like we\n-;; just enumerate all regs possible here, which (as this is !TARGET_64BIT)\n+  \"lock{%;} cmpxchg<doublemodesuffix>b\\t%2\")\n+\n+;; Theoretically we'd like to use constraint \"r\" (any reg) for op5,\n+;; but that includes ecx.  If op5 and op6 are the same (like when\n+;; the input is -1LL) GCC might chose to allocate op5 to ecx, like\n+;; op6.  This breaks, as the xchg will move the PIC register contents\n+;; to %ecx then --> boom.  Operands 5 and 6 really need to be different\n+;; registers, which in this case means op5 must not be ecx.  Instead\n+;; of playing tricks with fake early clobbers or the like we just\n+;; enumerate all regs possible here, which (as this is !TARGET_64BIT)\n ;; are just esi and edi.\n-(define_insn \"*sync_double_compare_and_swapdi_pic\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=A\")\n-\t(match_operand:DI 1 \"cmpxchg8b_pic_memory_operand\" \"+m\"))\n-   (set (match_dup 1)\n-\t(unspec_volatile:DI\n-\t  [(match_dup 1)\n-\t   (match_operand:DI 2 \"register_operand\" \"A\")\n-\t   (match_operand:SI 3 \"register_operand\" \"SD\")\n-\t   (match_operand:SI 4 \"register_operand\" \"c\")]\n-\t  UNSPECV_CMPXCHG))\n+(define_insn \"*atomic_compare_and_swap_doubledi_pic\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec_volatile:SI\n+\t  [(match_operand:DI 2 \"cmpxchg8b_pic_memory_operand\" \"+m\")\n+\t   (match_operand:SI 3 \"register_operand\" \"0\")\n+\t   (match_operand:SI 4 \"register_operand\" \"1\")\n+\t   (match_operand:SI 5 \"register_operand\" \"SD\")\n+\t   (match_operand:SI 6 \"register_operand\" \"c\")]\n+\t  UNSPECV_CMPXCHG_1))\n+   (set (match_operand:SI 1 \"register_operand\" \"=d\")\n+\t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_2))\n+   (set (match_dup 2)\n+\t(unspec_volatile:DI [(const_int 0)] UNSPECV_CMPXCHG_3))\n    (set (reg:CCZ FLAGS_REG)\n-\t(compare:CCZ\n-\t  (unspec_volatile:DI\n-\t    [(match_dup 1) (match_dup 2) (match_dup 3) (match_dup 4)]\n-\t    UNSPECV_CMPXCHG)\n-\t  (match_dup 2)))]\n+        (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG_4))]\n   \"!TARGET_64BIT && TARGET_CMPXCHG8B && flag_pic\"\n-  \"xchg{l}\\t%%ebx, %3\\;lock{%;} cmpxchg8b\\t%1\\;xchg{l}\\t%%ebx, %3\")\n+  \"xchg{l}\\t%%ebx, %5\\;lock{%;} cmpxchg8b\\t%2\\;xchg{l}\\t%%ebx, %5\")\n \n ;; For operand 2 nonmemory_operand predicate is used instead of\n ;; register_operand to allow combiner to better optimize atomic\n ;; additions of constants.\n-(define_insn \"sync_old_add<mode>\"\n+(define_insn \"atomic_fetch_add<mode>\"\n   [(set (match_operand:SWI 0 \"register_operand\" \"=<r>\")\n \t(unspec_volatile:SWI\n-\t  [(match_operand:SWI 1 \"memory_operand\" \"+m\")] UNSPECV_XCHG))\n+\t  [(match_operand:SWI 1 \"memory_operand\" \"+m\")\n+\t   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; model\n+\t  UNSPECV_XCHG))\n    (set (match_dup 1)\n \t(plus:SWI (match_dup 1)\n \t\t  (match_operand:SWI 2 \"nonmemory_operand\" \"0\")))\n@@ -186,7 +370,9 @@\n \t(match_operand:SWI 2 \"const_int_operand\" \"\"))\n    (parallel [(set (match_dup 0)\n \t\t   (unspec_volatile:SWI\n-\t\t     [(match_operand:SWI 1 \"memory_operand\" \"\")] UNSPECV_XCHG))\n+\t\t     [(match_operand:SWI 1 \"memory_operand\" \"\")\n+\t\t      (match_operand:SI 4 \"const_int_operand\" \"\")]\n+\t\t     UNSPECV_XCHG))\n \t      (set (match_dup 1)\n \t\t   (plus:SWI (match_dup 1)\n \t\t\t     (match_dup 0)))\n@@ -199,17 +385,19 @@\n       == -(unsigned HOST_WIDE_INT) INTVAL (operands[3])\n    && !reg_overlap_mentioned_p (operands[0], operands[1])\"\n   [(parallel [(set (reg:CCZ FLAGS_REG)\n-\t\t   (compare:CCZ (unspec_volatile:SWI [(match_dup 1)]\n-\t\t\t\t\t\t     UNSPECV_XCHG)\n-\t\t\t\t(match_dup 3)))\n+\t\t   (compare:CCZ\n+\t\t     (unspec_volatile:SWI [(match_dup 1) (match_dup 4)]\n+\t\t\t\t\t  UNSPECV_XCHG)\n+\t\t     (match_dup 3)))\n \t      (set (match_dup 1)\n \t\t   (plus:SWI (match_dup 1)\n \t\t\t     (match_dup 2)))])])\n \n-(define_insn \"*sync_old_add_cmp<mode>\"\n+(define_insn \"*atomic_fetch_add_cmp<mode>\"\n   [(set (reg:CCZ FLAGS_REG)\n \t(compare:CCZ (unspec_volatile:SWI\n-\t\t       [(match_operand:SWI 0 \"memory_operand\" \"+m\")]\n+\t\t       [(match_operand:SWI 0 \"memory_operand\" \"+m\")\n+\t\t        (match_operand:SI 3 \"const_int_operand\" \"\")]\n \t\t       UNSPECV_XCHG)\n \t\t     (match_operand:SWI 2 \"const_int_operand\" \"i\")))\n    (set (match_dup 0)\n@@ -233,20 +421,24 @@\n })\n \n ;; Recall that xchg implicitly sets LOCK#, so adding it again wastes space.\n-(define_insn \"sync_lock_test_and_set<mode>\"\n-  [(set (match_operand:SWI 0 \"register_operand\" \"=<r>\")\n+;; In addition, it is always a full barrier, so we can ignore the memory model.\n+(define_insn \"atomic_exchange<mode>\"\n+  [(set (match_operand:SWI 0 \"register_operand\" \"=<r>\")\t\t;; output\n \t(unspec_volatile:SWI\n-\t  [(match_operand:SWI 1 \"memory_operand\" \"+m\")] UNSPECV_XCHG))\n+\t  [(match_operand:SWI 1 \"memory_operand\" \"+m\")\t\t;; memory\n+\t   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; model\n+\t  UNSPECV_XCHG))\n    (set (match_dup 1)\n-\t(match_operand:SWI 2 \"register_operand\" \"0\"))]\n+\t(match_operand:SWI 2 \"register_operand\" \"0\"))]\t\t;; input\n   \"\"\n   \"xchg{<imodesuffix>}\\t{%1, %0|%0, %1}\")\n \n-(define_insn \"sync_add<mode>\"\n+(define_insn \"atomic_add<mode>\"\n   [(set (match_operand:SWI 0 \"memory_operand\" \"+m\")\n \t(unspec_volatile:SWI\n \t  [(plus:SWI (match_dup 0)\n-\t\t     (match_operand:SWI 1 \"nonmemory_operand\" \"<r><i>\"))]\n+\t\t     (match_operand:SWI 1 \"nonmemory_operand\" \"<r><i>\"))\n+\t   (match_operand:SI 2 \"const_int_operand\" \"\")]\t\t;; model\n \t  UNSPECV_LOCK))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n@@ -265,11 +457,12 @@\n   return \"lock{%;} add{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n })\n \n-(define_insn \"sync_sub<mode>\"\n+(define_insn \"atomic_sub<mode>\"\n   [(set (match_operand:SWI 0 \"memory_operand\" \"+m\")\n \t(unspec_volatile:SWI\n \t  [(minus:SWI (match_dup 0)\n-\t\t      (match_operand:SWI 1 \"nonmemory_operand\" \"<r><i>\"))]\n+\t\t      (match_operand:SWI 1 \"nonmemory_operand\" \"<r><i>\"))\n+\t   (match_operand:SI 2 \"const_int_operand\" \"\")]\t\t;; model\n \t  UNSPECV_LOCK))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n@@ -282,14 +475,18 @@\n \treturn \"lock{%;} inc{<imodesuffix>}\\t%0\";\n     }\n \n+  if (x86_maybe_negate_const_int (&operands[1], <MODE>mode))\n+    return \"lock{%;} add{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+\n   return \"lock{%;} sub{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n })\n \n-(define_insn \"sync_<code><mode>\"\n+(define_insn \"atomic_<code><mode>\"\n   [(set (match_operand:SWI 0 \"memory_operand\" \"+m\")\n \t(unspec_volatile:SWI\n \t  [(any_logic:SWI (match_dup 0)\n-\t\t\t  (match_operand:SWI 1 \"nonmemory_operand\" \"<r><i>\"))]\n+\t\t\t  (match_operand:SWI 1 \"nonmemory_operand\" \"<r><i>\"))\n+\t   (match_operand:SI 2 \"const_int_operand\" \"\")]\t\t;; model\n \t  UNSPECV_LOCK))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\""}, {"sha": "1374a98a810752e9cb7179c669ce72fa6458b37d", "filename": "gcc/coretypes.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -181,5 +181,18 @@ union _dont_use_tree_here_;\n \n #endif\n \n+/* Memory model types for the __atomic* builtins. \n+   This must match the order in libstdc++-v3/include/bits/atomic_base.h.  */\n+enum memmodel\n+{\n+  MEMMODEL_RELAXED = 0,\n+  MEMMODEL_CONSUME = 1,\n+  MEMMODEL_ACQUIRE = 2,\n+  MEMMODEL_RELEASE = 3,\n+  MEMMODEL_ACQ_REL = 4,\n+  MEMMODEL_SEQ_CST = 5,\n+  MEMMODEL_LAST = 6\n+};\n+\n #endif /* coretypes.h */\n "}, {"sha": "05d82f5df499d426f29ab49499f9d7ffa1563b72", "filename": "gcc/cppbuiltin.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fcppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fcppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppbuiltin.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -66,6 +66,12 @@ define__GNUC__ (cpp_reader *pfile)\n   cpp_define_formatted (pfile, \"__GNUC_MINOR__=%d\", minor);\n   cpp_define_formatted (pfile, \"__GNUC_PATCHLEVEL__=%d\", patchlevel);\n   cpp_define_formatted (pfile, \"__VERSION__=\\\"%s\\\"\", version_string);\n+  cpp_define_formatted (pfile, \"__ATOMIC_RELAXED=%d\", MEMMODEL_RELAXED);\n+  cpp_define_formatted (pfile, \"__ATOMIC_SEQ_CST=%d\", MEMMODEL_SEQ_CST);\n+  cpp_define_formatted (pfile, \"__ATOMIC_ACQUIRE=%d\", MEMMODEL_ACQUIRE);\n+  cpp_define_formatted (pfile, \"__ATOMIC_RELEASE=%d\", MEMMODEL_RELEASE);\n+  cpp_define_formatted (pfile, \"__ATOMIC_ACQ_REL=%d\", MEMMODEL_ACQ_REL);\n+  cpp_define_formatted (pfile, \"__ATOMIC_CONSUME=%d\", MEMMODEL_CONSUME);\n }\n \n "}, {"sha": "91e4e328f92adb932e8d77d37bbdecdec94b823a", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 236, "deletions": 3, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -79,7 +79,8 @@ extensions, accepted by GCC in C90 mode and in C++.\n * Return Address::      Getting the return or frame address of a function.\n * Vector Extensions::   Using vector instructions through built-in functions.\n * Offsetof::            Special syntax for implementing @code{offsetof}.\n-* Atomic Builtins::     Built-in functions for atomic memory access.\n+* __sync Builtins::     Legacy built-in functions for atomic memory access.\n+* __atomic Builtins::   Atomic built-in functions with memory model.\n * Object Size Checking:: Built-in functions for limited buffer overflow\n                         checking.\n * Other Builtins::      Other built-in functions.\n@@ -6683,8 +6684,8 @@ is a suitable definition of the @code{offsetof} macro.  In C++, @var{type}\n may be dependent.  In either case, @var{member} may consist of a single\n identifier, or a sequence of member accesses and array references.\n \n-@node Atomic Builtins\n-@section Built-in functions for atomic memory access\n+@node __sync Builtins\n+@section Legacy __sync built-in functions for atomic memory access\n \n The following builtins are intended to be compatible with those described\n in the @cite{Intel Itanium Processor-specific Application Binary Interface},\n@@ -6816,6 +6817,238 @@ previous memory loads have been satisfied, but following memory reads\n are not prevented from being speculated to before the barrier.\n @end table\n \n+@node __atomic Builtins\n+@section Built-in functions for memory model aware atomic operations\n+\n+The following built-in functions approximately match the requirements for\n+C++11 memory model. Many are similar to the @samp{__sync} prefixed built-in\n+functions, but all also have a memory model parameter.  These are all\n+identified by being prefixed with @samp{__atomic}, and most are overloaded\n+such that they work with multiple types.\n+\n+GCC will allow any integral scalar or pointer type that is 1, 2, 4, or 8\n+bytes in length. 16-byte integral types are also allowed if\n+@samp{__int128} (@pxref{__int128}) is supported by the architecture.\n+\n+Target architectures are encouraged to provide their own patterns for\n+each of these built-in functions.  If no target is provided, the original \n+non-memory model set of @samp{__sync} atomic built-in functions will be\n+utilized, along with any required synchronization fences surrounding it in\n+order to achieve the proper behaviour.  Execution in this case is subject\n+to the same restrictions as those built-in functions.\n+\n+If there is no pattern or mechanism to provide a lock free instruction\n+sequence, a call is made to an external routine with the same parameters\n+to be resolved at runtime.\n+\n+The four non-arithmetic functions (load, store, exchange, and \n+compare_exchange) all have a generic version as well.  This generic\n+version will work on any data type.  If the data type size maps to one\n+of the integral sizes which may have lock free support, the generic\n+version will utilize the lock free built-in function.  Otherwise an\n+external call is left to be resolved at runtime.  This external call will\n+be the same format with the addition of a @samp{size_t} parameter inserted\n+as the first parameter indicating the size of the object being pointed to.\n+All objects must be the same size.\n+\n+There are 6 different memory models which can be specified.  These map\n+to the same names in the C++11 standard.  Refer there or to the\n+@uref{http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync,GCC wiki on\n+atomic synchronization} for more detailed definitions.  These memory\n+models integrate both barriers to code motion as well as synchronization\n+requirements with other threads. These are listed in approximately\n+ascending order of strength.\n+\n+@table  @code\n+@item __ATOMIC_RELAXED\n+No barriers or synchronization.\n+@item __ATOMIC_CONSUME\n+Data dependency only for both barrier and synchronization with another\n+thread.\n+@item __ATOMIC_ACQUIRE\n+Barrier to hoisting of code and synchronizes with release (or stronger)\n+semantic stores from another thread.\n+@item __ATOMIC_RELEASE\n+Barrier to sinking of code and synchronizes with acquire (or stronger)\n+semantic loads from another thread.\n+@item __ATOMIC_ACQ_REL\n+Full barrier in both directions and synchronizes with acquire loads and\n+release stores in another thread.\n+@item __ATOMIC_SEQ_CST\n+Full barrier in both directions and synchronizes with acquire loads and\n+release stores in all threads.\n+@end table\n+\n+When implementing patterns for these built-in functions , the memory model\n+parameter can be ignored as long as the pattern implements the most\n+restrictive @code{__ATOMIC_SEQ_CST} model.  Any of the other memory models\n+will execute correctly with this memory model but they may not execute as\n+efficiently as they could with a more appropriate implemention of the\n+relaxed requirements.\n+\n+Note that the C++11 standard allows for the memory model parameter to be\n+determined at runtime rather than at compile time.  These built-in\n+functions will map any runtime value to @code{__ATOMIC_SEQ_CST} rather\n+than invoke a runtime library call or inline a switch statement.  This is\n+standard compliant, safe, and the simplest approach for now.\n+\n+@deftypefn {Built-in Function} @var{type} __atomic_load_n (@var{type} *ptr, int memmodel)\n+This built-in function implements an atomic load operation.  It returns the\n+contents of @code{*@var{ptr}}.\n+\n+The valid memory model variants are\n+@code{__ATOMIC_RELAXED}, @code{__ATOMIC_SEQ_CST}, @code{__ATOMIC_ACQUIRE},\n+and @code{__ATOMIC_CONSUME}.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __atomic_load (@var{type} *ptr, @var{type} *ret, int memmodel)\n+This is the generic version of an atomic load.  It will return the\n+contents of @code{*@var{ptr}} in @code{*@var{ret}}.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __atomic_store_n (@var{type} *ptr, @var{type} val, int memmodel)\n+This built-in function implements an atomic store operation.  It writes \n+@code{@var{val}} into @code{*@var{ptr}}.  On targets which are limited,\n+0 may be the only valid value. This mimics the behaviour of\n+@code{__sync_lock_release} on such hardware.\n+\n+The valid memory model variants are\n+@code{__ATOMIC_RELAXED}, @code{__ATOMIC_SEQ_CST}, and @code{__ATOMIC_RELEASE}.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __atomic_store (@var{type} *ptr, @var{type} *val, int memmodel)\n+This is the generic version of an atomic store.  It will store the value\n+of @code{*@var{val}} into @code{*@var{ptr}}.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} @var{type} __atomic_exchange_n (@var{type} *ptr, @var{type} val, int memmodel)\n+This built-in function implements an atomic exchange operation.  It writes\n+@var{val} into @code{*@var{ptr}}, and returns the previous contents of\n+@code{*@var{ptr}}.\n+\n+On targets which are limited, a value of 1 may be the only valid value\n+written.  This mimics the behaviour of @code{__sync_lock_test_and_set} on\n+such hardware.\n+\n+The valid memory model variants are\n+@code{__ATOMIC_RELAXED}, @code{__ATOMIC_SEQ_CST}, @code{__ATOMIC_ACQUIRE},\n+@code{__ATOMIC_RELEASE}, and @code{__ATOMIC_ACQ_REL}.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __atomic_exchange (@var{type} *ptr, @var{type} *val, @var{type} *ret, int memmodel)\n+This is the generic version of an atomic exchange.  It will store the\n+contents of @code{*@var{val}} into @code{*@var{ptr}}. The original value\n+of @code{*@var{ptr}} will be copied into @code{*@var{ret}}.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} bool __atomic_compare_exchange_n (@var{type} *ptr, @var{type} *expected, @var{type} desired, bool weak, int success_memmodel, int failure_memmodel)\n+This built-in function implements an atomic compare and exchange operation.\n+This compares the contents of @code{*@var{ptr}} with the contents of\n+@code{*@var{expected}} and if equal, writes @var{desired} into\n+@code{*@var{ptr}}.  If they are not equal, the current contents of\n+@code{*@var{ptr}} is written into @code{*@var{expected}}.\n+\n+True is returned if @code{*@var{desired}} is written into\n+@code{*@var{ptr}} and the execution is considered to conform to the\n+memory model specified by @var{success_memmodel}.  There are no\n+restrictions on what memory model can be used here.\n+\n+False is returned otherwise, and the execution is considered to conform\n+to @var{failure_memmodel}. This memory model cannot be\n+@code{__ATOMIC_RELEASE} nor @code{__ATOMIC_ACQ_REL}.  It also cannot be a\n+stronger model than that specified by @var{success_memmodel}.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} bool __atomic_compare_exchange (@var{type} *ptr, @var{type} *expected, @var{type} *desired, bool weak, int success_memmodel, int failure_memmodel)\n+This built-in function implements the generic version of\n+@code{__atomic_compare_exchange}.  The function is virtually identical to\n+@code{__atomic_compare_exchange_n}, except the desired value is also a\n+pointer.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} @var{type} __atomic_add_fetch (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefnx {Built-in Function} @var{type} __atomic_sub_fetch (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefnx {Built-in Function} @var{type} __atomic_and_fetch (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefnx {Built-in Function} @var{type} __atomic_xor_fetch (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefnx {Built-in Function} @var{type} __atomic_or_fetch (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefnx {Built-in Function} @var{type} __atomic_nand_fetch (@var{type} *ptr, @var{type} val, int memmodel)\n+These built-in functions perform the operation suggested by the name, and\n+return the result of the operation. That is,\n+\n+@smallexample\n+@{ *ptr @var{op}= val; return *ptr; @}\n+@end smallexample\n+\n+All memory models are valid.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} @var{type} __atomic_fetch_add (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefnx {Built-in Function} @var{type} __atomic_fetch_sub (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefnx {Built-in Function} @var{type} __atomic_fetch_and (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefnx {Built-in Function} @var{type} __atomic_fetch_xor (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefnx {Built-in Function} @var{type} __atomic_fetch_or (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefnx {Built-in Function} @var{type} __atomic_fetch_nand (@var{type} *ptr, @var{type} val, int memmodel)\n+These built-in functions perform the operation suggested by the name, and\n+return the value that had previously been in @code{*@var{ptr}}.  That is,\n+\n+@smallexample\n+@{ tmp = *ptr; *ptr @var{op}= val; return tmp; @}\n+@end smallexample\n+\n+All memory models are valid.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __atomic_thread_fence (int memmodel)\n+\n+This built-in function acts as a synchronization fence between threads\n+based on the specified memory model.\n+\n+All memory orders are valid.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __atomic_signal_fence (int memmodel)\n+\n+This built-in function acts as a synchronization fence between a thread\n+and signal handlers based in the same thread.\n+\n+All memory orders are valid.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} bool __atomic_always_lock_free (size_t size)\n+\n+This built-in function returns true if objects of size bytes will always\n+generate lock free atomic instructions for the target architecture.\n+Otherwise false is returned.\n+\n+size must resolve to a compile time constant.\n+\n+@smallexample\n+if (_atomic_always_lock_free (sizeof (long long)))\n+@end smallexample\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} bool __atomic_is_lock_free (size_t size)\n+\n+This built-in function returns true if objects of size bytes will always\n+generate lock free atomic instructions for the target architecture.  If\n+it is not known to be lock free a call is made to a runtime routine named\n+@code{__atomic_is_lock_free}.\n+\n+@end deftypefn\n+\n @node Object Size Checking\n @section Object Size Checking Builtins\n @findex __builtin_object_size"}, {"sha": "e3fb21b84d750655a45d619d690ef1450040b880", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -9163,11 +9163,26 @@ The maximum number of conditional stores paires that can be sunk.  Set to 0\n if either vectorization (@option{-ftree-vectorize}) or if-conversion\n (@option{-ftree-loop-if-convert}) is disabled.  The default is 2.\n \n+@item allow-load-data-races\n+Allow optimizers to introduce new data races on loads.\n+Set to 1 to allow, otherwise to 0.  This option is enabled by default\n+unless implicitly set by the @option{-fmemory-model=} option.\n+\n @item allow-store-data-races\n Allow optimizers to introduce new data races on stores.\n Set to 1 to allow, otherwise to 0.  This option is enabled by default\n unless implicitly set by the @option{-fmemory-model=} option.\n \n+@item allow-packed-load-data-races\n+Allow optimizers to introduce new data races on packed data loads.\n+Set to 1 to allow, otherwise to 0.  This option is enabled by default\n+unless implicitly set by the @option{-fmemory-model=} option.\n+\n+@item allow-packed-store-data-races\n+Allow optimizers to introduce new data races on packed data stores.\n+Set to 1 to allow, otherwise to 0.  This option is enabled by default\n+unless implicitly set by the @option{-fmemory-model=} option.\n+\n @item case-values-threshold\n The smallest number of different values for which it is best to use a\n jump-table instead of a tree of conditional branches.  If the value is\n@@ -13180,7 +13195,8 @@ This option will enable GCC to use CMPXCHG16B instruction in generated code.\n CMPXCHG16B allows for atomic operations on 128-bit double quadword (or oword)\n data types.  This is useful for high resolution counters that could be updated\n by multiple processors (or cores).  This instruction is generated as part of\n-atomic built-in functions: see @ref{Atomic Builtins} for details.\n+atomic built-in functions: see @ref{__sync Builtins} or\n+@ref{__atomic Builtins} for details.\n \n @item -msahf\n @opindex msahf"}, {"sha": "6b75f2bce2859870cdb1915fe517574e1cbfaba1", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -5699,6 +5699,155 @@ released only after all previous memory operations have completed.\n If this pattern is not defined, then a @code{memory_barrier} pattern\n will be emitted, followed by a store of the value to the memory operand.\n \n+@cindex @code{atomic_compare_and_swap@var{mode}} instruction pattern\n+@item @samp{atomic_compare_and_swap@var{mode}} \n+This pattern, if defined, emits code for an atomic compare-and-swap\n+operation with memory model semantics.  Operand 2 is the memory on which\n+the atomic operation is performed.  Operand 0 is an output operand which\n+is set to true or false based on whether the operation succeeded.  Operand\n+1 is an output operand which is set to the contents of the memory before\n+the operation was attempted.  Operand 3 is the value that is expected to\n+be in memory.  Operand 4 is the value to put in memory if the expected\n+value is found there.  Operand 5 is set to 1 if this compare and swap is to\n+be treated as a weak operation.  Operand 6 is the memory model to be used\n+if the operation is a success.  Operand 7 is the memory model to be used\n+if the operation fails.\n+\n+If memory referred to in operand 2 contains the value in operand 3, then\n+operand 4 is stored in memory pointed to by operand 2 and fencing based on\n+the memory model in operand 6 is issued.  \n+\n+If memory referred to in operand 2 does not contain the value in operand 3,\n+then fencing based on the memory model in operand 7 is issued.\n+\n+If a target does not support weak compare-and-swap operations, or the port\n+elects not to implement weak operations, the argument in operand 5 can be\n+ignored.  Note a strong implementation must be provided.\n+\n+If this pattern is not provided, the @code{__atomic_compare_exchange}\n+built-in functions will utilize the legacy @code{sync_compare_and_swap}\n+pattern with an @code{__ATOMIC_SEQ_CST} memory model.\n+\n+@cindex @code{atomic_load@var{mode}} instruction pattern\n+@item @samp{atomic_load@var{mode}}\n+This pattern implements an atomic load operation with memory model\n+semantics.  Operand 1 is the memory address being loaded from.  Operand 0\n+is the result of the load.  Operand 2 is the memory model to be used for\n+the load operation.\n+\n+If not present, the @code{__atomic_load} built-in function will either\n+resort to a normal load with memory barriers, or a compare-and-swap\n+operation if a normal load would not be atomic.\n+\n+@cindex @code{atomic_store@var{mode}} instruction pattern\n+@item @samp{atomic_store@var{mode}}\n+This pattern implements an atomic store operation with memory model\n+semantics.  Operand 0 is the memory address being stored to.  Operand 1\n+is the value to be written.  Operand 2 is the memory model to be used for\n+the operation.\n+\n+If not present, the @code{__atomic_store} built-in function will attempt to\n+perform a normal store and surround it with any required memory fences.  If\n+the store would not be atomic, then an @code{__atomic_exchange} is\n+attempted with the result being ignored.\n+\n+@cindex @code{atomic_exchange@var{mode}} instruction pattern\n+@item @samp{atomic_exchange@var{mode}}\n+This pattern implements an atomic exchange operation with memory model\n+semantics.  Operand 1 is the memory location the operation is performed on.\n+Operand 0 is an output operand which is set to the original value contained\n+in the memory pointed to by operand 1.  Operand 2 is the value to be\n+stored.  Operand 3 is the memory model to be used.\n+\n+If this pattern is not present, the built-in function\n+@code{__atomic_exchange} will attempt to preform the operation with a\n+compare and swap loop.\n+\n+@cindex @code{atomic_add@var{mode}} instruction pattern\n+@cindex @code{atomic_sub@var{mode}} instruction pattern\n+@cindex @code{atomic_or@var{mode}} instruction pattern\n+@cindex @code{atomic_and@var{mode}} instruction pattern\n+@cindex @code{atomic_xor@var{mode}} instruction pattern\n+@cindex @code{atomic_nand@var{mode}} instruction pattern\n+@item @samp{atomic_add@var{mode}}, @samp{atomic_sub@var{mode}}\n+@itemx @samp{atomic_or@var{mode}}, @samp{atomic_and@var{mode}}\n+@itemx @samp{atomic_xor@var{mode}}, @samp{atomic_nand@var{mode}}\n+\n+These patterns emit code for an atomic operation on memory with memory\n+model semantics. Operand 0 is the memory on which the atomic operation is\n+performed.  Operand 1 is the second operand to the binary operator.\n+Operand 2 is the memory model to be used by the operation.\n+\n+If these patterns are not defined, attempts will be made to use legacy\n+@code{sync} patterns, or equivilent patterns which return a result.  If\n+none of these are available a compare-and-swap loop will be used.\n+\n+@cindex @code{atomic_fetch_add@var{mode}} instruction pattern\n+@cindex @code{atomic_fetch_sub@var{mode}} instruction pattern\n+@cindex @code{atomic_fetch_or@var{mode}} instruction pattern\n+@cindex @code{atomic_fetch_and@var{mode}} instruction pattern\n+@cindex @code{atomic_fetch_xor@var{mode}} instruction pattern\n+@cindex @code{atomic_fetch_nand@var{mode}} instruction pattern\n+@item @samp{atomic_fetch_add@var{mode}}, @samp{atomic_fetch_sub@var{mode}}\n+@itemx @samp{atomic_fetch_or@var{mode}}, @samp{atomic_fetch_and@var{mode}}\n+@itemx @samp{atomic_fetch_xor@var{mode}}, @samp{atomic_fetch_nand@var{mode}}\n+\n+These patterns emit code for an atomic operation on memory with memory\n+model semantics, and return the original value. Operand 0 is an output \n+operand which contains the value of the memory location before the \n+operation was performed.  Operand 1 is the memory on which the atomic \n+operation is performed.  Operand 2 is the second operand to the binary\n+operator.  Operand 3 is the memory model to be used by the operation.\n+\n+If these patterns are not defined, attempts will be made to use legacy\n+@code{sync} patterns.  If none of these are available a compare-and-swap\n+loop will be used.\n+\n+@cindex @code{atomic_add_fetch@var{mode}} instruction pattern\n+@cindex @code{atomic_sub_fetch@var{mode}} instruction pattern\n+@cindex @code{atomic_or_fetch@var{mode}} instruction pattern\n+@cindex @code{atomic_and_fetch@var{mode}} instruction pattern\n+@cindex @code{atomic_xor_fetch@var{mode}} instruction pattern\n+@cindex @code{atomic_nand_fetch@var{mode}} instruction pattern\n+@item @samp{atomic_add_fetch@var{mode}}, @samp{atomic_sub_fetch@var{mode}}\n+@itemx @samp{atomic_or_fetch@var{mode}}, @samp{atomic_and_fetch@var{mode}}\n+@itemx @samp{atomic_xor_fetch@var{mode}}, @samp{atomic_nand_fetch@var{mode}}\n+\n+These patterns emit code for an atomic operation on memory with memory\n+model semantics and return the result after the operation is performed.\n+Operand 0 is an output operand which contains the value after the\n+operation.  Operand 1 is the memory on which the atomic operation is\n+performed.  Operand 2 is the second operand to the binary operator.\n+Operand 3 is the memory model to be used by the operation.\n+\n+If these patterns are not defined, attempts will be made to use legacy\n+@code{sync} patterns, or equivilent patterns which return the result before\n+the operation followed by the arithmetic operation required to produce the\n+result.  If none of these are available a compare-and-swap loop will be\n+used.\n+\n+@cindex @code{mem_thread_fence@var{mode}} instruction pattern\n+@item @samp{mem_thread_fence@var{mode}}\n+This pattern emits code required to implement a thread fence with\n+memory model semantics.  Operand 0 is the memory model to be used.\n+\n+If this pattern is not specified, all memory models except\n+@code{__ATOMIC_RELAXED} will result in issuing a @code{sync_synchronize}\n+barrier pattern.\n+\n+@cindex @code{mem_signal_fence@var{mode}} instruction pattern\n+@item @samp{mem_signal_fence@var{mode}}\n+This pattern emits code required to implement a signal fence with\n+memory model semantics.  Operand 0 is the memory model to be used.\n+\n+This pattern should impact the compiler optimizers the same way that\n+mem_signal_fence does, but it does not need to issue any barrier\n+instructions.\n+\n+If this pattern is not specified, all memory models except\n+@code{__ATOMIC_RELAXED} will result in issuing a @code{sync_synchronize}\n+barrier pattern.\n+\n @cindex @code{stack_protect_set} instruction pattern\n @item @samp{stack_protect_set}\n "}, {"sha": "1623ad97a730128f4b6dd5c72c0e052a3177ab3a", "filename": "gcc/expr.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -212,11 +212,17 @@ int can_conditionally_move_p (enum machine_mode mode);\n rtx emit_conditional_add (rtx, enum rtx_code, rtx, rtx, enum machine_mode,\n \t\t\t  rtx, rtx, enum machine_mode, int);\n \n-rtx expand_val_compare_and_swap (rtx, rtx, rtx, rtx);\n-rtx expand_bool_compare_and_swap (rtx, rtx, rtx, rtx);\n rtx expand_sync_operation (rtx, rtx, enum rtx_code);\n rtx expand_sync_fetch_operation (rtx, rtx, enum rtx_code, bool, rtx);\n-rtx expand_sync_lock_test_and_set (rtx, rtx, rtx);\n+\n+rtx expand_atomic_exchange (rtx, rtx, rtx, enum memmodel);\n+rtx expand_atomic_load (rtx, rtx, enum memmodel);\n+rtx expand_atomic_store (rtx, rtx, enum memmodel);\n+rtx expand_atomic_fetch_op (rtx, rtx, rtx, enum rtx_code, enum memmodel, \n+\t\t\t      bool);\n+void expand_atomic_thread_fence (enum memmodel);\n+void expand_atomic_signal_fence (enum memmodel);\n+\n \f\n /* Functions from expmed.c:  */\n \n@@ -248,6 +254,7 @@ extern void expand_builtin_setjmp_receiver (rtx);\n extern rtx expand_builtin_saveregs (void);\n extern void expand_builtin_trap (void);\n extern rtx builtin_strncpy_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n+extern void expand_builtin_mem_thread_fence (enum memmodel);\n \f\n /* Functions from expr.c:  */\n "}, {"sha": "b5c8bedba284eb8105ccba9ccc17ef35bb087efa", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -1,3 +1,16 @@\n+2011-11-06  Andrew MacLeod  <amacleod@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tMerged from cxx-mem-model.\n+\n+\t* types.def: (BT_SIZE, BT_CONST_VOLATILE_PTR, BT_FN_VOID_INT,\n+\tBT_FN_I{1,2,4,8,16}_CONST_VPTR_INT, BT_FN_VOID_VPTR_INT,\n+\tBT_FN_BOOL_VPTR_INT, BT_FN_BOOL_SIZE_CONST_VPTR,\n+\tBT_FN_VOID_VPTR_I{1,2,4,8,16}_INT, BT_FN_VOID_SIZE_VPTR_PTR_INT,\n+\tBT_FN_VOID_SIZE_CONST_VPTR_PTR_INT, BT_FN_VOID_SIZE_VPTR_PTR_PTR_INT,\n+\tBT_FN_BOOL_VPTR_PTR_I{1,2,4,8,16}_BOOL_INT_INT,\n+\tBT_FN_I{1,2,4,8,16}_VPTR_I{1,2,4,8,16}_INT): New types.\n+\n 2011-11-04  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/43829"}, {"sha": "a2762c6257baccc3a59cf17331d446b112d9f320", "filename": "gcc/fortran/types.def", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ffortran%2Ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ffortran%2Ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftypes.def?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -57,6 +57,7 @@ DEF_PRIMITIVE_TYPE (BT_UINT, unsigned_type_node)\n DEF_PRIMITIVE_TYPE (BT_LONG, long_integer_type_node)\n DEF_PRIMITIVE_TYPE (BT_ULONGLONG, long_long_unsigned_type_node)\n DEF_PRIMITIVE_TYPE (BT_WORD, (*lang_hooks.types.type_for_mode) (word_mode, 1))\n+DEF_PRIMITIVE_TYPE (BT_SIZE, size_type_node)\n \n DEF_PRIMITIVE_TYPE (BT_I1, builtin_type_for_size (BITS_PER_UNIT*1, 1))\n DEF_PRIMITIVE_TYPE (BT_I2, builtin_type_for_size (BITS_PER_UNIT*2, 1))\n@@ -70,7 +71,10 @@ DEF_PRIMITIVE_TYPE (BT_VOLATILE_PTR,\n                     build_pointer_type\n                      (build_qualified_type (void_type_node,\n                                             TYPE_QUAL_VOLATILE)))\n-\n+DEF_PRIMITIVE_TYPE (BT_CONST_VOLATILE_PTR,\n+\t\t    build_pointer_type\n+\t\t     (build_qualified_type (void_type_node,\n+\t\t\t\t\t  TYPE_QUAL_VOLATILE|TYPE_QUAL_CONST)))\n DEF_POINTER_TYPE (BT_PTR_LONG, BT_LONG)\n DEF_POINTER_TYPE (BT_PTR_ULONGLONG, BT_ULONGLONG)\n DEF_POINTER_TYPE (BT_PTR_PTR, BT_PTR)\n@@ -85,6 +89,8 @@ DEF_FUNCTION_TYPE_1 (BT_FN_VOID_PTRPTR, BT_VOID, BT_PTR_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_VPTR, BT_VOID, BT_VOLATILE_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT_UINT, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_1 (BT_FN_PTR_PTR, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_VOID_INT, BT_VOID, BT_INT)\n+\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)\n \n@@ -98,6 +104,21 @@ DEF_FUNCTION_TYPE_2 (BT_FN_I4_VPTR_I4, BT_I4, BT_VOLATILE_PTR, BT_I4)\n DEF_FUNCTION_TYPE_2 (BT_FN_I8_VPTR_I8, BT_I8, BT_VOLATILE_PTR, BT_I8)\n DEF_FUNCTION_TYPE_2 (BT_FN_I16_VPTR_I16, BT_I16, BT_VOLATILE_PTR, BT_I16)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_PTR, BT_VOID, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I1_CONST_VPTR_INT, BT_I1, BT_CONST_VOLATILE_PTR,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I2_CONST_VPTR_INT, BT_I2, BT_CONST_VOLATILE_PTR,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I4_CONST_VPTR_INT, BT_I4, BT_CONST_VOLATILE_PTR,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I8_CONST_VPTR_INT, BT_I8, BT_CONST_VOLATILE_PTR,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I16_CONST_VPTR_INT, BT_I16, BT_CONST_VOLATILE_PTR,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_INT, BT_VOID, BT_VOLATILE_PTR, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_VPTR_INT, BT_BOOL, BT_VOLATILE_PTR, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_SIZE_CONST_VPTR, BT_BOOL, BT_SIZE,\n+\t\t     BT_CONST_VOLATILE_PTR)\n+\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR_PTR, BT_FN_VOID_PTR_PTR)\n \n@@ -119,15 +140,31 @@ DEF_FUNCTION_TYPE_3 (BT_FN_I16_VPTR_I16_I16, BT_I16, BT_VOLATILE_PTR,\n \t\t     BT_I16, BT_I16)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_OMPFN_PTR_UINT, BT_VOID, BT_PTR_FN_VOID_PTR,\n                      BT_PTR, BT_UINT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I1_VPTR_I1_INT, BT_I1, BT_VOLATILE_PTR, BT_I1, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I2_VPTR_I2_INT, BT_I2, BT_VOLATILE_PTR, BT_I2, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I4_VPTR_I4_INT, BT_I4, BT_VOLATILE_PTR, BT_I4, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I8_VPTR_I8_INT, BT_I8, BT_VOLATILE_PTR, BT_I8, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I16_VPTR_I16_INT, BT_I16, BT_VOLATILE_PTR, BT_I16, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I1_INT, BT_VOID, BT_VOLATILE_PTR, BT_I1, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I2_INT, BT_VOID, BT_VOLATILE_PTR, BT_I2, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I4_INT, BT_VOID, BT_VOLATILE_PTR, BT_I4, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I8_INT, BT_VOID, BT_VOLATILE_PTR, BT_I8, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I16_INT, BT_VOID, BT_VOLATILE_PTR, BT_I16, BT_INT)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_OMPFN_PTR_UINT_UINT,\n                      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_PTR_WORD_WORD_PTR,\n \t\t     BT_VOID, BT_PTR, BT_WORD, BT_WORD, BT_PTR)\n+DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_VPTR_PTR_INT, BT_VOID, BT_SIZE,\n+\t\t     BT_VOLATILE_PTR, BT_PTR, BT_INT)\n+DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_CONST_VPTR_PTR_INT, BT_VOID, BT_SIZE,\n+\t\t     BT_CONST_VOLATILE_PTR, BT_PTR, BT_INT)\n \n DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,\n                      BT_BOOL, BT_LONG, BT_LONG, BT_LONG,\n \t\t     BT_PTR_LONG, BT_PTR_LONG)\n+DEF_FUNCTION_TYPE_5 (BT_FN_VOID_SIZE_VPTR_PTR_PTR_INT, BT_VOID, BT_SIZE,\n+\t\t     BT_VOLATILE_PTR, BT_PTR, BT_PTR, BT_INT)\n \n DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n                      BT_BOOL, BT_LONG, BT_LONG, BT_LONG, BT_LONG,\n@@ -138,6 +175,23 @@ DEF_FUNCTION_TYPE_6 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n \t\t     BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n \t\t     BT_ULONGLONG, BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I1_BOOL_INT_INT, \n+\t\t     BT_BOOL, BT_VOLATILE_PTR, BT_PTR, BT_I1, BT_BOOL, BT_INT,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I2_BOOL_INT_INT, \n+\t\t     BT_BOOL, BT_VOLATILE_PTR, BT_PTR, BT_I2, BT_BOOL, BT_INT,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I4_BOOL_INT_INT, \n+\t\t     BT_BOOL, BT_VOLATILE_PTR, BT_PTR, BT_I4, BT_BOOL, BT_INT,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I8_BOOL_INT_INT, \n+\t\t     BT_BOOL, BT_VOLATILE_PTR, BT_PTR, BT_I8, BT_BOOL, BT_INT,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I16_BOOL_INT_INT, \n+\t\t     BT_BOOL, BT_VOLATILE_PTR, BT_PTR, BT_I16, BT_BOOL, BT_INT,\n+\t\t     BT_INT)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_SIZE_VPTR_PTR_PTR_INT_INT, BT_BOOL, BT_SIZE,\n+\t\t     BT_VOLATILE_PTR, BT_PTR, BT_PTR, BT_INT, BT_INT)\n \n DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n                      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,"}, {"sha": "44eba24f11afaf4813e72ad1eef962dc69edb825", "filename": "gcc/genopinit.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -243,6 +243,28 @@ static const char * const optabs[] =\n   \"set_direct_optab_handler (sync_compare_and_swap_optab, $A, CODE_FOR_$(sync_compare_and_swap$I$a$))\",\n   \"set_direct_optab_handler (sync_lock_test_and_set_optab, $A, CODE_FOR_$(sync_lock_test_and_set$I$a$))\",\n   \"set_direct_optab_handler (sync_lock_release_optab, $A, CODE_FOR_$(sync_lock_release$I$a$))\",\n+  \"set_direct_optab_handler (atomic_exchange_optab, $A, CODE_FOR_$(atomic_exchange$I$a$))\",\n+  \"set_direct_optab_handler (atomic_compare_and_swap_optab, $A, CODE_FOR_$(atomic_compare_and_swap$I$a$))\",\n+  \"set_direct_optab_handler (atomic_load_optab, $A, CODE_FOR_$(atomic_load$I$a$))\",\n+  \"set_direct_optab_handler (atomic_store_optab, $A, CODE_FOR_$(atomic_store$I$a$))\",\n+  \"set_direct_optab_handler (atomic_add_fetch_optab, $A, CODE_FOR_$(atomic_add_fetch$I$a$))\",\n+  \"set_direct_optab_handler (atomic_sub_fetch_optab, $A, CODE_FOR_$(atomic_sub_fetch$I$a$))\",\n+  \"set_direct_optab_handler (atomic_and_fetch_optab, $A, CODE_FOR_$(atomic_and_fetch$I$a$))\",\n+  \"set_direct_optab_handler (atomic_nand_fetch_optab, $A, CODE_FOR_$(atomic_nand_fetch$I$a$))\",\n+  \"set_direct_optab_handler (atomic_xor_fetch_optab, $A, CODE_FOR_$(atomic_xor_fetch$I$a$))\",\n+  \"set_direct_optab_handler (atomic_or_fetch_optab, $A, CODE_FOR_$(atomic_or_fetch$I$a$))\",\n+  \"set_direct_optab_handler (atomic_fetch_add_optab, $A, CODE_FOR_$(atomic_fetch_add$I$a$))\",\n+  \"set_direct_optab_handler (atomic_fetch_sub_optab, $A, CODE_FOR_$(atomic_fetch_sub$I$a$))\",\n+  \"set_direct_optab_handler (atomic_fetch_and_optab, $A, CODE_FOR_$(atomic_fetch_and$I$a$))\",\n+  \"set_direct_optab_handler (atomic_fetch_nand_optab, $A, CODE_FOR_$(atomic_fetch_nand$I$a$))\",\n+  \"set_direct_optab_handler (atomic_fetch_xor_optab, $A, CODE_FOR_$(atomic_fetch_xor$I$a$))\",\n+  \"set_direct_optab_handler (atomic_fetch_or_optab, $A, CODE_FOR_$(atomic_fetch_or$I$a$))\",\n+  \"set_direct_optab_handler (atomic_add_optab, $A, CODE_FOR_$(atomic_add$I$a$))\",\n+  \"set_direct_optab_handler (atomic_sub_optab, $A, CODE_FOR_$(atomic_sub$I$a$))\",\n+  \"set_direct_optab_handler (atomic_and_optab, $A, CODE_FOR_$(atomic_and$I$a$))\",\n+  \"set_direct_optab_handler (atomic_nand_optab, $A, CODE_FOR_$(atomic_nand$I$a$))\",\n+  \"set_direct_optab_handler (atomic_xor_optab, $A, CODE_FOR_$(atomic_xor$I$a$))\",\n+  \"set_direct_optab_handler (atomic_or_optab, $A, CODE_FOR_$(atomic_or$I$a$))\",\n   \"set_optab_handler (vec_set_optab, $A, CODE_FOR_$(vec_set$a$))\",\n   \"set_optab_handler (vec_extract_optab, $A, CODE_FOR_$(vec_extract$a$))\",\n   \"set_optab_handler (vec_extract_even_optab, $A, CODE_FOR_$(vec_extract_even$a$))\","}, {"sha": "d8e7ce39a7a74198769c528365d1428274906ee6", "filename": "gcc/omp-low.c", "status": "modified", "additions": 33, "deletions": 56, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -4998,7 +4998,7 @@ expand_omp_atomic_store (basic_block load_bb, tree addr)\n }\n \n /* A subroutine of expand_omp_atomic.  Attempt to implement the atomic\n-   operation as a __sync_fetch_and_op builtin.  INDEX is log2 of the\n+   operation as a __atomic_fetch_op builtin.  INDEX is log2 of the\n    size of the data type, and thus usable to find the index of the builtin\n    decl.  Returns false if the expression is not of the proper form.  */\n \n@@ -5009,13 +5009,14 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n {\n   enum built_in_function oldbase, newbase, tmpbase;\n   tree decl, itype, call;\n-  direct_optab optab, oldoptab, newoptab;\n   tree lhs, rhs;\n   basic_block store_bb = single_succ (load_bb);\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n   location_t loc;\n+  enum tree_code code;\n   bool need_old, need_new;\n+  enum machine_mode imode;\n \n   /* We expect to find the following sequences:\n \n@@ -5047,47 +5048,34 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n     return false;\n \n   /* Check for one of the supported fetch-op operations.  */\n-  switch (gimple_assign_rhs_code (stmt))\n+  code = gimple_assign_rhs_code (stmt);\n+  switch (code)\n     {\n     case PLUS_EXPR:\n     case POINTER_PLUS_EXPR:\n-      oldbase = BUILT_IN_SYNC_FETCH_AND_ADD_N;\n-      newbase = BUILT_IN_SYNC_ADD_AND_FETCH_N;\n-      optab = sync_add_optab;\n-      oldoptab = sync_old_add_optab;\n-      newoptab = sync_new_add_optab;\n+      oldbase = BUILT_IN_ATOMIC_FETCH_ADD_N;\n+      newbase = BUILT_IN_ATOMIC_ADD_FETCH_N;\n       break;\n     case MINUS_EXPR:\n-      oldbase = BUILT_IN_SYNC_FETCH_AND_SUB_N;\n-      newbase = BUILT_IN_SYNC_SUB_AND_FETCH_N;\n-      optab = sync_add_optab;\n-      oldoptab = sync_old_add_optab;\n-      newoptab = sync_new_add_optab;\n+      oldbase = BUILT_IN_ATOMIC_FETCH_SUB_N;\n+      newbase = BUILT_IN_ATOMIC_SUB_FETCH_N;\n       break;\n     case BIT_AND_EXPR:\n-      oldbase = BUILT_IN_SYNC_FETCH_AND_AND_N;\n-      newbase = BUILT_IN_SYNC_AND_AND_FETCH_N;\n-      optab = sync_and_optab;\n-      oldoptab = sync_old_and_optab;\n-      newoptab = sync_new_and_optab;\n+      oldbase = BUILT_IN_ATOMIC_FETCH_AND_N;\n+      newbase = BUILT_IN_ATOMIC_AND_FETCH_N;\n       break;\n     case BIT_IOR_EXPR:\n-      oldbase = BUILT_IN_SYNC_FETCH_AND_OR_N;\n-      newbase = BUILT_IN_SYNC_OR_AND_FETCH_N;\n-      optab = sync_ior_optab;\n-      oldoptab = sync_old_ior_optab;\n-      newoptab = sync_new_ior_optab;\n+      oldbase = BUILT_IN_ATOMIC_FETCH_OR_N;\n+      newbase = BUILT_IN_ATOMIC_OR_FETCH_N;\n       break;\n     case BIT_XOR_EXPR:\n-      oldbase = BUILT_IN_SYNC_FETCH_AND_XOR_N;\n-      newbase = BUILT_IN_SYNC_XOR_AND_FETCH_N;\n-      optab = sync_xor_optab;\n-      oldoptab = sync_old_xor_optab;\n-      newoptab = sync_new_xor_optab;\n+      oldbase = BUILT_IN_ATOMIC_FETCH_XOR_N;\n+      newbase = BUILT_IN_ATOMIC_XOR_FETCH_N;\n       break;\n     default:\n       return false;\n     }\n+\n   /* Make sure the expression is of the proper form.  */\n   if (operand_equal_p (gimple_assign_rhs1 (stmt), loaded_val, 0))\n     rhs = gimple_assign_rhs2 (stmt);\n@@ -5103,37 +5091,25 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n   if (decl == NULL_TREE)\n     return false;\n   itype = TREE_TYPE (TREE_TYPE (decl));\n+  imode = TYPE_MODE (itype);\n \n-  if (need_new)\n-    {\n-      /* expand_sync_fetch_operation can always compensate when interested\n-\t in the new value.  */\n-      if (direct_optab_handler (newoptab, TYPE_MODE (itype))\n-\t  == CODE_FOR_nothing\n-\t  && direct_optab_handler (oldoptab, TYPE_MODE (itype))\n-\t     == CODE_FOR_nothing)\n-\treturn false;\n-    }\n-  else if (need_old)\n-    {\n-      /* When interested in the old value, expand_sync_fetch_operation\n-\t can compensate only if the operation is reversible.  AND and OR\n-\t are not reversible.  */\n-      if (direct_optab_handler (oldoptab, TYPE_MODE (itype))\n-\t  == CODE_FOR_nothing\n-\t  && (oldbase == BUILT_IN_SYNC_FETCH_AND_AND_N\n-\t      || oldbase == BUILT_IN_SYNC_FETCH_AND_OR_N\n-\t      || direct_optab_handler (newoptab, TYPE_MODE (itype))\n-\t\t == CODE_FOR_nothing))\n-\treturn false;\n-    }\n-  else if (direct_optab_handler (optab, TYPE_MODE (itype)) == CODE_FOR_nothing)\n+  /* We could test all of the various optabs involved, but the fact of the\n+     matter is that (with the exception of i486 vs i586 and xadd) all targets\n+     that support any atomic operaton optab also implements compare-and-swap.\n+     Let optabs.c take care of expanding any compare-and-swap loop.  */\n+  if (!can_compare_and_swap_p (imode))\n     return false;\n \n   gsi = gsi_last_bb (load_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_ATOMIC_LOAD);\n-  call = build_call_expr_loc (loc, decl, 2, addr,\n-\t\t\t      fold_convert_loc (loc, itype, rhs));\n+\n+  /* OpenMP does not imply any barrier-like semantics on its atomic ops.\n+     It only requires that the operation happen atomically.  Thus we can\n+     use the RELAXED memory model.  */\n+  call = build_call_expr_loc (loc, decl, 3, addr,\n+\t\t\t      fold_convert_loc (loc, itype, rhs),\n+\t\t\t      build_int_cst (NULL, MEMMODEL_RELAXED));\n+\n   if (need_old || need_new)\n     {\n       lhs = need_old ? loaded_val : stored_val;\n@@ -5182,6 +5158,8 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n   edge e;\n   enum built_in_function fncode;\n \n+  /* ??? We need a non-pointer interface to __atomic_compare_exchange in\n+     order to use the RELAXED memory model effectively.  */\n   fncode = (enum built_in_function)((int)BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_N\n \t\t\t\t    + index + 1);\n   cmpxchg = builtin_decl_explicit (fncode);\n@@ -5190,8 +5168,7 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n   type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (addr)));\n   itype = TREE_TYPE (TREE_TYPE (cmpxchg));\n \n-  if (direct_optab_handler (sync_compare_and_swap_optab, TYPE_MODE (itype))\n-      == CODE_FOR_nothing)\n+  if (!can_compare_and_swap_p (TYPE_MODE (itype)))\n     return false;\n \n   /* Load the initial value, replacing the GIMPLE_OMP_ATOMIC_LOAD.  */"}, {"sha": "163a44972ab2369f298947b78189fd4dff338ffe", "filename": "gcc/optabs.c", "status": "modified", "additions": 477, "deletions": 332, "changes": 809, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -7162,43 +7162,25 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n }\n \n \f\n-/* This is an internal subroutine of the other compare_and_swap expanders.\n-   MEM, OLD_VAL and NEW_VAL are as you'd expect for a compare-and-swap\n-   operation.  TARGET is an optional place to store the value result of\n-   the operation.  ICODE is the particular instruction to expand.  Return\n-   the result of the operation.  */\n+/* Return true if there is a compare_and_swap pattern.  */\n \n-static rtx\n-expand_val_compare_and_swap_1 (rtx mem, rtx old_val, rtx new_val,\n-\t\t\t       rtx target, enum insn_code icode)\n+bool\n+can_compare_and_swap_p (enum machine_mode mode)\n {\n-  struct expand_operand ops[4];\n-  enum machine_mode mode = GET_MODE (mem);\n-\n-  create_output_operand (&ops[0], target, mode);\n-  create_fixed_operand (&ops[1], mem);\n-  /* OLD_VAL and NEW_VAL may have been promoted to a wider mode.\n-     Shrink them if so.  */\n-  create_convert_operand_to (&ops[2], old_val, mode, true);\n-  create_convert_operand_to (&ops[3], new_val, mode, true);\n-  if (maybe_expand_insn (icode, 4, ops))\n-    return ops[0].value;\n-  return NULL_RTX;\n-}\n-\n-/* Expand a compare-and-swap operation and return its value.  */\n+  enum insn_code icode;\n \n-rtx\n-expand_val_compare_and_swap (rtx mem, rtx old_val, rtx new_val, rtx target)\n-{\n-  enum machine_mode mode = GET_MODE (mem);\n-  enum insn_code icode\n-    = direct_optab_handler (sync_compare_and_swap_optab, mode);\n+  /* Check for __sync_compare_and_swap.  */\n+  icode = direct_optab_handler (sync_compare_and_swap_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+      return true;\n \n-  if (icode == CODE_FOR_nothing)\n-    return NULL_RTX;\n+  /* Check for __atomic_compare_and_swap.  */\n+  icode = direct_optab_handler (atomic_compare_and_swap_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+      return true;\n \n-  return expand_val_compare_and_swap_1 (mem, old_val, new_val, target, icode);\n+  /* No inline compare and swap.  */\n+  return false;\n }\n \n /* Helper function to find the MODE_CC set in a sync_compare_and_swap\n@@ -7216,58 +7198,6 @@ find_cc_set (rtx x, const_rtx pat, void *data)\n     }\n }\n \n-/* Expand a compare-and-swap operation and store true into the result if\n-   the operation was successful and false otherwise.  Return the result.\n-   Unlike other routines, TARGET is not optional.  */\n-\n-rtx\n-expand_bool_compare_and_swap (rtx mem, rtx old_val, rtx new_val, rtx target)\n-{\n-  enum machine_mode mode = GET_MODE (mem);\n-  enum insn_code icode;\n-  rtx subtarget, seq, cc_reg;\n-\n-  /* If the target supports a compare-and-swap pattern that simultaneously\n-     sets some flag for success, then use it.  Otherwise use the regular\n-     compare-and-swap and follow that immediately with a compare insn.  */\n-  icode = direct_optab_handler (sync_compare_and_swap_optab, mode);\n-  if (icode == CODE_FOR_nothing)\n-    return NULL_RTX;\n-\n-  do_pending_stack_adjust ();\n-  do\n-    {\n-      start_sequence ();\n-      subtarget = expand_val_compare_and_swap_1 (mem, old_val, new_val,\n-\t\t\t\t\t         NULL_RTX, icode);\n-      cc_reg = NULL_RTX;\n-      if (subtarget == NULL_RTX)\n-\t{\n-\t  end_sequence ();\n-\t  return NULL_RTX;\n-\t}\n-\n-      if (have_insn_for (COMPARE, CCmode))\n-\tnote_stores (PATTERN (get_last_insn ()), find_cc_set, &cc_reg);\n-      seq = get_insns ();\n-      end_sequence ();\n-\n-      /* We might be comparing against an old value.  Try again. :-(  */\n-      if (!cc_reg && MEM_P (old_val))\n-\t{\n-\t  seq = NULL_RTX;\n-\t  old_val = force_reg (mode, old_val);\n-        }\n-    }\n-  while (!seq);\n-\n-  emit_insn (seq);\n-  if (cc_reg)\n-    return emit_store_flag_force (target, EQ, cc_reg, const0_rtx, VOIDmode, 0, 1);\n-  else\n-    return emit_store_flag_force (target, EQ, subtarget, old_val, VOIDmode, 1, 1);\n-}\n-\n /* This is a helper function for the other atomic operations.  This function\n    emits a loop that contains SEQ that iterates until a compare-and-swap\n    operation at the end succeeds.  MEM is the memory to be modified.  SEQ is\n@@ -7281,17 +7211,16 @@ static bool\n expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n {\n   enum machine_mode mode = GET_MODE (mem);\n-  enum insn_code icode;\n-  rtx label, cmp_reg, subtarget, cc_reg;\n+  rtx label, cmp_reg, success, oldval;\n \n   /* The loop we want to generate looks like\n \n \tcmp_reg = mem;\n       label:\n         old_reg = cmp_reg;\n \tseq;\n-\tcmp_reg = compare-and-swap(mem, old_reg, new_reg)\n-\tif (cmp_reg != old_reg)\n+\t(success, cmp_reg) = compare-and-swap(mem, old_reg, new_reg)\n+\tif (success)\n \t  goto label;\n \n      Note that we only do the plain load from memory once.  Subsequent\n@@ -7306,331 +7235,539 @@ expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n   if (seq)\n     emit_insn (seq);\n \n-  /* If the target supports a compare-and-swap pattern that simultaneously\n-     sets some flag for success, then use it.  Otherwise use the regular\n-     compare-and-swap and follow that immediately with a compare insn.  */\n-  icode = direct_optab_handler (sync_compare_and_swap_optab, mode);\n-  if (icode == CODE_FOR_nothing)\n+  success = NULL_RTX;\n+  oldval = cmp_reg;\n+  if (!expand_atomic_compare_and_swap (&success, &oldval, mem, old_reg,\n+\t\t\t\t       new_reg, false, MEMMODEL_SEQ_CST,\n+\t\t\t\t       MEMMODEL_RELAXED))\n     return false;\n \n-  subtarget = expand_val_compare_and_swap_1 (mem, old_reg, new_reg,\n-\t\t\t\t\t     cmp_reg, icode);\n-  if (subtarget == NULL_RTX)\n-    return false;\n+  if (oldval != cmp_reg)\n+    emit_move_insn (cmp_reg, oldval);\n \n-  cc_reg = NULL_RTX;\n-  if (have_insn_for (COMPARE, CCmode))\n-    note_stores (PATTERN (get_last_insn ()), find_cc_set, &cc_reg);\n-  if (cc_reg)\n+  /* ??? Mark this jump predicted not taken?  */\n+  emit_cmp_and_jump_insns (success, const0_rtx, EQ, const0_rtx,\n+\t\t\t   GET_MODE (success), 1, label);\n+  return true;\n+}\n+\n+\n+/* This function expands the atomic exchange operation:\n+   atomically store VAL in MEM and return the previous value in MEM.\n+\n+   MEMMODEL is the memory model variant to use.\n+   TARGET is an option place to stick the return value.  */\n+\n+rtx\n+expand_atomic_exchange (rtx target, rtx mem, rtx val, enum memmodel model)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  enum insn_code icode;\n+  rtx last_insn;\n+\n+  /* If the target supports the exchange directly, great.  */\n+  icode = direct_optab_handler (atomic_exchange_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n     {\n-      cmp_reg = cc_reg;\n-      old_reg = const0_rtx;\n+      struct expand_operand ops[4];\n+\n+      create_output_operand (&ops[0], target, mode);\n+      create_fixed_operand (&ops[1], mem);\n+      /* VAL may have been promoted to a wider mode.  Shrink it if so.  */\n+      create_convert_operand_to (&ops[2], val, mode, true);\n+      create_integer_operand (&ops[3], model);\n+      if (maybe_expand_insn (icode, 4, ops))\n+\treturn ops[0].value;\n     }\n-  else\n+\n+  /* Legacy sync_lock_test_and_set works the same, but is only defined as an \n+     acquire barrier.  If the pattern exists, and the memory model is stronger\n+     than acquire, add a release barrier before the instruction.\n+     The barrier is not needed if sync_lock_test_and_set doesn't exist since\n+     it will expand into a compare-and-swap loop.  */\n+\n+  icode = direct_optab_handler (sync_lock_test_and_set_optab, mode);\n+  last_insn = get_last_insn ();\n+  if ((icode != CODE_FOR_nothing) && (model == MEMMODEL_SEQ_CST || \n+\t\t\t\t      model == MEMMODEL_RELEASE ||\n+\t\t\t\t      model == MEMMODEL_ACQ_REL))\n+    expand_builtin_mem_thread_fence (model);\n+\n+  if (icode != CODE_FOR_nothing)\n     {\n-      if (subtarget != cmp_reg)\n-\temit_move_insn (cmp_reg, subtarget);\n+      struct expand_operand ops[3];\n+\n+      create_output_operand (&ops[0], target, mode);\n+      create_fixed_operand (&ops[1], mem);\n+      /* VAL may have been promoted to a wider mode.  Shrink it if so.  */\n+      create_convert_operand_to (&ops[2], val, mode, true);\n+      if (maybe_expand_insn (icode, 3, ops))\n+\treturn ops[0].value;\n     }\n \n-  /* ??? Mark this jump predicted not taken?  */\n-  emit_cmp_and_jump_insns (cmp_reg, old_reg, NE, const0_rtx, GET_MODE (cmp_reg), 1,\n-\t\t\t   label);\n+  /* Remove any fence we may have inserted since a compare and swap loop is a\n+     full memory barrier.  */\n+  if (last_insn != get_last_insn ())\n+    delete_insns_since (last_insn);\n+\n+  /* Otherwise, use a compare-and-swap loop for the exchange.  */\n+  if (can_compare_and_swap_p (mode))\n+    {\n+      if (!target || !register_operand (target, mode))\n+\ttarget = gen_reg_rtx (mode);\n+      if (GET_MODE (val) != VOIDmode && GET_MODE (val) != mode)\n+\tval = convert_modes (mode, GET_MODE (val), val, 1);\n+      if (expand_compare_and_swap_loop (mem, target, val, NULL_RTX))\n+\treturn target;\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+/* This function expands the atomic compare exchange operation:\n+\n+   *PTARGET_BOOL is an optional place to store the boolean success/failure.\n+   *PTARGET_OVAL is an optional place to store the old value from memory.\n+   Both target parameters may be NULL to indicate that we do not care about\n+   that return value.  Both target parameters are updated on success to\n+   the actual location of the corresponding result.\n+\n+   MEMMODEL is the memory model variant to use.\n+\n+   The return value of the function is true for success.  */\n+\n+bool\n+expand_atomic_compare_and_swap (rtx *ptarget_bool, rtx *ptarget_oval,\n+\t\t\t\trtx mem, rtx expected, rtx desired,\n+\t\t\t\tbool is_weak, enum memmodel succ_model,\n+\t\t\t\tenum memmodel fail_model)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  struct expand_operand ops[8];\n+  enum insn_code icode;\n+  rtx target_bool, target_oval;\n+\n+  /* Load expected into a register for the compare and swap.  */\n+  if (MEM_P (expected))\n+    expected = copy_to_reg (expected);\n+\n+  /* Make sure we always have some place to put the return oldval.\n+     Further, make sure that place is distinct from the input expected,\n+     just in case we need that path down below.  */\n+  if (ptarget_oval == NULL\n+      || (target_oval = *ptarget_oval) == NULL\n+      || reg_overlap_mentioned_p (expected, target_oval))\n+    target_oval = gen_reg_rtx (mode);\n+\n+  icode = direct_optab_handler (atomic_compare_and_swap_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      enum machine_mode bool_mode = insn_data[icode].operand[0].mode;\n+\n+      /* Make sure we always have a place for the bool operand.  */\n+      if (ptarget_bool == NULL\n+\t  || (target_bool = *ptarget_bool) == NULL\n+\t  || GET_MODE (target_bool) != bool_mode)\n+\ttarget_bool = gen_reg_rtx (bool_mode);\n+\n+      /* Emit the compare_and_swap.  */\n+      create_output_operand (&ops[0], target_bool, bool_mode);\n+      create_output_operand (&ops[1], target_oval, mode);\n+      create_fixed_operand (&ops[2], mem);\n+      create_convert_operand_to (&ops[3], expected, mode, true);\n+      create_convert_operand_to (&ops[4], desired, mode, true);\n+      create_integer_operand (&ops[5], is_weak);\n+      create_integer_operand (&ops[6], succ_model);\n+      create_integer_operand (&ops[7], fail_model);\n+      expand_insn (icode, 8, ops);\n+\n+      /* Return success/failure.  */\n+      target_bool = ops[0].value;\n+      target_oval = ops[1].value;\n+      goto success;\n+    }\n+\n+  /* Otherwise fall back to the original __sync_val_compare_and_swap\n+     which is always seq-cst.  */\n+  icode = direct_optab_handler (sync_compare_and_swap_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      rtx cc_reg;\n+\n+      create_output_operand (&ops[0], target_oval, mode);\n+      create_fixed_operand (&ops[1], mem);\n+      create_convert_operand_to (&ops[2], expected, mode, true);\n+      create_convert_operand_to (&ops[3], desired, mode, true);\n+      if (!maybe_expand_insn (icode, 4, ops))\n+\treturn false;\n+\n+      target_oval = ops[0].value;\n+      target_bool = NULL_RTX;\n+\n+      /* If the caller isn't interested in the boolean return value,\n+\t skip the computation of it.  */\n+      if (ptarget_bool == NULL)\n+\tgoto success;\n+\n+      /* Otherwise, work out if the compare-and-swap succeeded.  */\n+      cc_reg = NULL_RTX;\n+      if (have_insn_for (COMPARE, CCmode))\n+\tnote_stores (PATTERN (get_last_insn ()), find_cc_set, &cc_reg);\n+\n+      target_bool\n+\t= (cc_reg\n+\t   ? emit_store_flag_force (target_bool, EQ, cc_reg,\n+\t\t\t\t    const0_rtx, VOIDmode, 0, 1)\n+\t   : emit_store_flag_force (target_bool, EQ, target_oval,\n+\t\t\t\t    expected, VOIDmode, 1, 1));\n+      goto success;\n+    }\n+  return false;\n+\n+ success:\n+  /* Make sure that the oval output winds up where the caller asked.  */\n+  if (ptarget_oval)\n+    *ptarget_oval = target_oval;\n+  if (ptarget_bool)\n+    *ptarget_bool = target_bool;\n   return true;\n }\n \n-/* This function generates the atomic operation MEM CODE= VAL.  In this\n-   case, we do not care about any resulting value.  Returns NULL if we\n-   cannot generate the operation.  */\n+/* This function expands the atomic load operation:\n+   return the atomically loaded value in MEM.\n+\n+   MEMMODEL is the memory model variant to use.\n+   TARGET is an option place to stick the return value.  */\n \n rtx\n-expand_sync_operation (rtx mem, rtx val, enum rtx_code code)\n+expand_atomic_load (rtx target, rtx mem, enum memmodel model)\n {\n   enum machine_mode mode = GET_MODE (mem);\n   enum insn_code icode;\n-  rtx insn;\n \n-  /* Look to see if the target supports the operation directly.  */\n-  switch (code)\n+  /* If the target supports the load directly, great.  */\n+  icode = direct_optab_handler (atomic_load_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n     {\n-    case PLUS:\n-      icode = direct_optab_handler (sync_add_optab, mode);\n-      break;\n-    case IOR:\n-      icode = direct_optab_handler (sync_ior_optab, mode);\n-      break;\n-    case XOR:\n-      icode = direct_optab_handler (sync_xor_optab, mode);\n-      break;\n-    case AND:\n-      icode = direct_optab_handler (sync_and_optab, mode);\n-      break;\n-    case NOT:\n-      icode = direct_optab_handler (sync_nand_optab, mode);\n-      break;\n+      struct expand_operand ops[3];\n \n-    case MINUS:\n-      icode = direct_optab_handler (sync_sub_optab, mode);\n-      if (icode == CODE_FOR_nothing || CONST_INT_P (val))\n-\t{\n-\t  icode = direct_optab_handler (sync_add_optab, mode);\n-\t  if (icode != CODE_FOR_nothing)\n-\t    {\n-\t      val = expand_simple_unop (mode, NEG, val, NULL_RTX, 1);\n-\t      code = PLUS;\n-\t    }\n-\t}\n-      break;\n+      create_output_operand (&ops[0], target, mode);\n+      create_fixed_operand (&ops[1], mem);\n+      create_integer_operand (&ops[2], model);\n+      if (maybe_expand_insn (icode, 3, ops))\n+\treturn ops[0].value;\n+    }\n \n-    default:\n-      gcc_unreachable ();\n+  /* If the size of the object is greater than word size on this target,\n+     then we assume that a load will not be atomic.  */\n+  if (GET_MODE_PRECISION (mode) > BITS_PER_WORD)\n+    {\n+      /* Issue val = compare_and_swap (mem, 0, 0).\n+\t This may cause the occasional harmless store of 0 when the value is\n+\t already 0, but it seems to be OK according to the standards guys.  */\n+      expand_atomic_compare_and_swap (NULL, &target, mem, const0_rtx,\n+\t\t\t\t      const0_rtx, false, model, model);\n+      return target;\n     }\n \n-  /* Generate the direct operation, if present.  */\n+  /* Otherwise assume loads are atomic, and emit the proper barriers.  */\n+  if (!target || target == const0_rtx)\n+    target = gen_reg_rtx (mode);\n+\n+  /* Emit the appropriate barrier before the load.  */\n+  expand_builtin_mem_thread_fence (model);\n+\n+  emit_move_insn (target, mem);\n+\n+  /* For SEQ_CST, also emit a barrier after the load.  */\n+  if (model == MEMMODEL_SEQ_CST)\n+    expand_builtin_mem_thread_fence (model);\n+\n+  return target;\n+}\n+\n+/* This function expands the atomic store operation:\n+   Atomically store VAL in MEM.\n+   MEMMODEL is the memory model variant to use.\n+   function returns const0_rtx if a pattern was emitted.  */\n+\n+rtx\n+expand_atomic_store (rtx mem, rtx val, enum memmodel model)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  enum insn_code icode;\n+  struct expand_operand ops[3];\n+\n+  /* If the target supports the store directly, great.  */\n+  icode = direct_optab_handler (atomic_store_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[2];\n-\n       create_fixed_operand (&ops[0], mem);\n-      /* VAL may have been promoted to a wider mode.  Shrink it if so.  */\n-      create_convert_operand_to (&ops[1], val, mode, true);\n-      if (maybe_expand_insn (icode, 2, ops))\n+      create_input_operand (&ops[1], val, mode);\n+      create_integer_operand (&ops[2], model);\n+      if (maybe_expand_insn (icode, 3, ops))\n \treturn const0_rtx;\n     }\n \n-  /* Failing that, generate a compare-and-swap loop in which we perform the\n-     operation with normal arithmetic instructions.  */\n-  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n-      != CODE_FOR_nothing)\n+  /* If the size of the object is greater than word size on this target,\n+     a default store will not be atomic, Try a mem_exchange and throw away\n+     the result.  If that doesn't work, don't do anything.  */\n+  if (GET_MODE_PRECISION(mode) > BITS_PER_WORD)\n     {\n-      rtx t0 = gen_reg_rtx (mode), t1;\n+      rtx target = expand_atomic_exchange (NULL_RTX, mem, val, model);\n+      if (target)\n+        return const0_rtx;\n+      else\n+        return NULL_RTX;\n+    }\n \n-      start_sequence ();\n+  /* If there is no mem_store, default to a move with barriers */\n+  if (model == MEMMODEL_SEQ_CST || model == MEMMODEL_RELEASE)\n+    expand_builtin_mem_thread_fence (model);\n \n-      t1 = t0;\n-      if (code == NOT)\n-\t{\n-\t  t1 = expand_simple_binop (mode, AND, t1, val, NULL_RTX,\n-\t\t\t\t    true, OPTAB_LIB_WIDEN);\n-\t  t1 = expand_simple_unop (mode, code, t1, NULL_RTX, true);\n-\t}\n-      else\n-\tt1 = expand_simple_binop (mode, code, t1, val, NULL_RTX,\n-\t\t\t\t  true, OPTAB_LIB_WIDEN);\n-      insn = get_insns ();\n-      end_sequence ();\n+  emit_move_insn (mem, val);\n \n-      if (t1 != NULL && expand_compare_and_swap_loop (mem, t0, t1, insn))\n-\treturn const0_rtx;\n-    }\n+  /* For SEQ_CST, also emit a barrier after the load.  */\n+  if (model == MEMMODEL_SEQ_CST)\n+    expand_builtin_mem_thread_fence (model);\n \n-  return NULL_RTX;\n+  return const0_rtx;\n }\n \n-/* This function generates the atomic operation MEM CODE= VAL.  In this\n-   case, we do care about the resulting value: if AFTER is true then\n-   return the value MEM holds after the operation, if AFTER is false\n-   then return the value MEM holds before the operation.  TARGET is an\n-   optional place for the result value to be stored.  */\n \n-rtx\n-expand_sync_fetch_operation (rtx mem, rtx val, enum rtx_code code,\n-\t\t\t     bool after, rtx target)\n+/* Structure containing the pointers and values required to process the\n+   various forms of the atomic_fetch_op and atomic_op_fetch builtins.  */\n+\n+struct atomic_op_functions\n {\n-  enum machine_mode mode = GET_MODE (mem);\n-  enum insn_code old_code, new_code, icode;\n-  bool compensate;\n-  rtx insn;\n+  struct direct_optab_d *mem_fetch_before;\n+  struct direct_optab_d *mem_fetch_after;\n+  struct direct_optab_d *mem_no_result;\n+  struct direct_optab_d *fetch_before;\n+  struct direct_optab_d *fetch_after;\n+  struct direct_optab_d *no_result;\n+  enum rtx_code reverse_code;\n+};\n+\n+static const struct atomic_op_functions *\n+get_atomic_op_for_code (enum rtx_code code)\n+{\n+  static const struct atomic_op_functions add_op = {\n+    atomic_fetch_add_optab, atomic_add_fetch_optab, atomic_add_optab,\n+    sync_old_add_optab, sync_new_add_optab, sync_add_optab, MINUS\n+  }, sub_op = {\n+    atomic_fetch_sub_optab, atomic_sub_fetch_optab, atomic_sub_optab,\n+    sync_old_sub_optab, sync_new_sub_optab, sync_sub_optab, PLUS\n+  }, xor_op = {\n+    atomic_fetch_xor_optab, atomic_xor_fetch_optab, atomic_xor_optab,\n+    sync_old_xor_optab, sync_new_xor_optab, sync_xor_optab, XOR\n+  }, and_op = {\n+    atomic_fetch_and_optab, atomic_and_fetch_optab, atomic_and_optab,\n+    sync_old_and_optab, sync_new_and_optab, sync_and_optab, UNKNOWN\n+  }, nand_op = {\n+    atomic_fetch_nand_optab, atomic_nand_fetch_optab, atomic_nand_optab,\n+    sync_old_nand_optab, sync_new_nand_optab, sync_nand_optab, UNKNOWN\n+  }, ior_op = {\n+    atomic_fetch_or_optab, atomic_or_fetch_optab, atomic_or_optab,\n+    sync_old_ior_optab, sync_new_ior_optab, sync_ior_optab, UNKNOWN\n+  };\n \n-  /* Look to see if the target supports the operation directly.  */\n   switch (code)\n     {\n     case PLUS:\n-      old_code = direct_optab_handler (sync_old_add_optab, mode);\n-      new_code = direct_optab_handler (sync_new_add_optab, mode);\n-      break;\n-    case IOR:\n-      old_code = direct_optab_handler (sync_old_ior_optab, mode);\n-      new_code = direct_optab_handler (sync_new_ior_optab, mode);\n-      break;\n+      return &add_op;\n+    case MINUS:\n+      return &sub_op;\n     case XOR:\n-      old_code = direct_optab_handler (sync_old_xor_optab, mode);\n-      new_code = direct_optab_handler (sync_new_xor_optab, mode);\n-      break;\n+      return &xor_op;\n     case AND:\n-      old_code = direct_optab_handler (sync_old_and_optab, mode);\n-      new_code = direct_optab_handler (sync_new_and_optab, mode);\n-      break;\n+      return &and_op;\n+    case IOR:\n+      return &ior_op;\n     case NOT:\n-      old_code = direct_optab_handler (sync_old_nand_optab, mode);\n-      new_code = direct_optab_handler (sync_new_nand_optab, mode);\n-      break;\n-\n-    case MINUS:\n-      old_code = direct_optab_handler (sync_old_sub_optab, mode);\n-      new_code = direct_optab_handler (sync_new_sub_optab, mode);\n-      if ((old_code == CODE_FOR_nothing && new_code == CODE_FOR_nothing)\n-          || CONST_INT_P (val))\n-\t{\n-\t  old_code = direct_optab_handler (sync_old_add_optab, mode);\n-\t  new_code = direct_optab_handler (sync_new_add_optab, mode);\n-\t  if (old_code != CODE_FOR_nothing || new_code != CODE_FOR_nothing)\n-\t    {\n-\t      val = expand_simple_unop (mode, NEG, val, NULL_RTX, 1);\n-\t      code = PLUS;\n-\t    }\n-\t}\n-      break;\n-\n+      return &nand_op;\n     default:\n       gcc_unreachable ();\n     }\n+}\n+\n+/* Try to emit an instruction for a specific operation varaition. \n+   OPTAB contains the OP functions.\n+   TARGET is an optional place to return the result. const0_rtx means unused.\n+   MEM is the memory location to operate on.\n+   VAL is the value to use in the operation.\n+   USE_MEMMODEL is TRUE if the variation with a memory model should be tried.\n+   MODEL is the memory model, if used.\n+   AFTER is true if the returned result is the value after the operation.  */\n+\n+static rtx \n+maybe_emit_op (const struct atomic_op_functions *optab, rtx target, rtx mem,\n+\t       rtx val, bool use_memmodel, enum memmodel model, bool after)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  struct direct_optab_d *this_optab;\n+  struct expand_operand ops[4];\n+  enum insn_code icode;\n+  int op_counter = 0;\n+  int num_ops;\n \n-  /* If the target does supports the proper new/old operation, great.  But\n-     if we only support the opposite old/new operation, check to see if we\n-     can compensate.  In the case in which the old value is supported, then\n-     we can always perform the operation again with normal arithmetic.  In\n-     the case in which the new value is supported, then we can only handle\n-     this in the case the operation is reversible.  */\n-  compensate = false;\n-  if (after)\n+  /* Check to see if there is a result returned.  */\n+  if (target == const0_rtx)\n     {\n-      icode = new_code;\n-      if (icode == CODE_FOR_nothing)\n-\t{\n-\t  icode = old_code;\n-\t  if (icode != CODE_FOR_nothing)\n-\t    compensate = true;\n+      if (use_memmodel)\n+        {\n+\t  this_optab = optab->mem_no_result;\n+\t  create_integer_operand (&ops[2], model);\n+\t  num_ops = 3;\n+\t}\n+      else\n+        {\n+\t  this_optab = optab->no_result;\n+\t  num_ops = 2;\n \t}\n     }\n+  /* Otherwise, we need to generate a result.  */\n   else\n     {\n-      icode = old_code;\n-      if (icode == CODE_FOR_nothing\n-\t  && (code == PLUS || code == MINUS || code == XOR))\n+      if (use_memmodel)\n+        {\n+\t  this_optab = after ? optab->mem_fetch_after : optab->mem_fetch_before;\n+\t  create_integer_operand (&ops[3], model);\n+\t  num_ops= 4;\n+\t}\n+      else\n \t{\n-\t  icode = new_code;\n-\t  if (icode != CODE_FOR_nothing)\n-\t    compensate = true;\n+\t  this_optab = after ? optab->fetch_after : optab->fetch_before;\n+\t  num_ops = 3;\n \t}\n+      create_output_operand (&ops[op_counter++], target, mode);\n     }\n \n-  /* If we found something supported, great.  */\n-  if (icode != CODE_FOR_nothing)\n+  icode = direct_optab_handler (this_optab, mode);\n+  if (icode == CODE_FOR_nothing)\n+    return NULL_RTX;\n+\n+  create_fixed_operand (&ops[op_counter++], mem);\n+  /* VAL may have been promoted to a wider mode.  Shrink it if so.  */\n+  create_convert_operand_to (&ops[op_counter++], val, mode, true);\n+\n+  if (maybe_expand_insn (icode, num_ops, ops))\n+    return ((target == const0_rtx) ? const0_rtx : ops[0].value);\n+\n+  return NULL_RTX;\n+} \n+\n+\n+/* This function expands an atomic fetch_OP or OP_fetch operation:\n+   TARGET is an option place to stick the return value.  const0_rtx indicates\n+   the result is unused. \n+   atomically fetch MEM, perform the operation with VAL and return it to MEM.\n+   CODE is the operation being performed (OP)\n+   MEMMODEL is the memory model variant to use.\n+   AFTER is true to return the result of the operation (OP_fetch).\n+   AFTER is false to return the value before the operation (fetch_OP).  */\n+rtx\n+expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n+\t\t\tenum memmodel model, bool after)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  const struct atomic_op_functions *optab;\n+  rtx result;\n+  bool unused_result = (target == const0_rtx);\n+\n+  optab = get_atomic_op_for_code (code);\n+\n+  /* Check for the case where the result isn't used and try those patterns.  */\n+  if (unused_result)\n     {\n-      struct expand_operand ops[3];\n+      /* Try the memory model variant first.  */\n+      result = maybe_emit_op (optab, target, mem, val, true, model, true);\n+      if (result)\n+        return result;\n \n-      create_output_operand (&ops[0], target, mode);\n-      create_fixed_operand (&ops[1], mem);\n-      /* VAL may have been promoted to a wider mode.  Shrink it if so.  */\n-      create_convert_operand_to (&ops[2], val, mode, true);\n-      if (maybe_expand_insn (icode, 3, ops))\n-\t{\n-\t  target = ops[0].value;\n-\t  val = ops[2].value;\n-\t  /* If we need to compensate for using an operation with the\n-\t     wrong return value, do so now.  */\n-\t  if (compensate)\n-\t    {\n-\t      if (!after)\n-\t\t{\n-\t\t  if (code == PLUS)\n-\t\t    code = MINUS;\n-\t\t  else if (code == MINUS)\n-\t\t    code = PLUS;\n-\t\t}\n+      /* Next try the old style withuot a memory model.  */\n+      result = maybe_emit_op (optab, target, mem, val, false, model, true);\n+      if (result)\n+        return result;\n \n-\t      if (code == NOT)\n-\t\t{\n-\t\t  target = expand_simple_binop (mode, AND, target, val,\n-\t\t\t\t\t\tNULL_RTX, true,\n-\t\t\t\t\t\tOPTAB_LIB_WIDEN);\n-\t\t  target = expand_simple_unop (mode, code, target,\n-\t\t\t\t\t       NULL_RTX, true);\n-\t\t}\n-\t      else\n-\t\ttarget = expand_simple_binop (mode, code, target, val,\n-\t\t\t\t\t      NULL_RTX, true,\n-\t\t\t\t\t      OPTAB_LIB_WIDEN);\n-\t    }\n+      /* There is no no-result pattern, so try patterns with a result.  */\n+      target = NULL_RTX;\n+    }\n \n-\t  return target;\n+  /* Try the __atomic version.  */\n+  result = maybe_emit_op (optab, target, mem, val, true, model, after);\n+  if (result)\n+    return result;\n+\n+  /* Try the older __sync version.  */\n+  result = maybe_emit_op (optab, target, mem, val, false, model, after);\n+  if (result)\n+    return result;\n+\n+  /* If the fetch value can be calculated from the other variation of fetch,\n+     try that operation.  */\n+  if (after || optab->reverse_code != UNKNOWN || target == const0_rtx) \n+    {\n+      /* Try the __atomic version, then the older __sync version.  */\n+      result = maybe_emit_op (optab, target, mem, val, true, model, !after);\n+      if (!result)\n+\tresult = maybe_emit_op (optab, target, mem, val, false, model, !after);\n+\n+      if (result)\n+\t{\n+\t  /* If the result isn't used, no need to do compensation code.  */\n+\t  if (unused_result)\n+\t    return target;\n+\n+\t  /* Issue compensation code.  Fetch_after  == fetch_before OP val.\n+\t     Fetch_before == after REVERSE_OP val.  */\n+\t  if (!after)\n+\t    code = optab->reverse_code;\n+\t  result = expand_simple_binop (mode, code, result, val, NULL_RTX, true,\n+\t\t\t\t\tOPTAB_LIB_WIDEN);\n+\t  return result;\n \t}\n     }\n \n-  /* Failing that, generate a compare-and-swap loop in which we perform the\n-     operation with normal arithmetic instructions.  */\n-  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n-      != CODE_FOR_nothing)\n+  /* If nothing else has succeeded, default to a compare and swap loop.  */\n+  if (can_compare_and_swap_p (mode))\n     {\n+      rtx insn;\n       rtx t0 = gen_reg_rtx (mode), t1;\n \n-      if (!target || !register_operand (target, mode))\n-\ttarget = gen_reg_rtx (mode);\n-\n       start_sequence ();\n \n-      if (!after)\n-\temit_move_insn (target, t0);\n+      /* If the result is used, get a register for it.  */\n+      if (!unused_result) \n+        {\n+\t  if (!target || !register_operand (target, mode))\n+\t    target = gen_reg_rtx (mode);\n+\t  /* If fetch_before, copy the value now.  */\n+\t  if (!after)\n+\t    emit_move_insn (target, t0);\n+\t}\n+      else\n+        target = const0_rtx;\n+\n       t1 = t0;\n       if (code == NOT)\n-\t{\n+        {\n \t  t1 = expand_simple_binop (mode, AND, t1, val, NULL_RTX,\n \t\t\t\t    true, OPTAB_LIB_WIDEN);\n \t  t1 = expand_simple_unop (mode, code, t1, NULL_RTX, true);\n \t}\n       else\n-\tt1 = expand_simple_binop (mode, code, t1, val, NULL_RTX,\n-\t\t\t\t  true, OPTAB_LIB_WIDEN);\n-      if (after)\n-\temit_move_insn (target, t1);\n+\tt1 = expand_simple_binop (mode, code, t1, val, NULL_RTX, true, \n+\t\t\t\t  OPTAB_LIB_WIDEN);\n \n+      /* For after, copy the value now.  */\n+      if (!unused_result && after)\n+        emit_move_insn (target, t1);\n       insn = get_insns ();\n       end_sequence ();\n \n       if (t1 != NULL && expand_compare_and_swap_loop (mem, t0, t1, insn))\n-\treturn target;\n-    }\n-\n-  return NULL_RTX;\n-}\n-\n-/* This function expands a test-and-set operation.  Ideally we atomically\n-   store VAL in MEM and return the previous value in MEM.  Some targets\n-   may not support this operation and only support VAL with the constant 1;\n-   in this case while the return value will be 0/1, but the exact value\n-   stored in MEM is target defined.  TARGET is an option place to stick\n-   the return value.  */\n-\n-rtx\n-expand_sync_lock_test_and_set (rtx mem, rtx val, rtx target)\n-{\n-  enum machine_mode mode = GET_MODE (mem);\n-  enum insn_code icode;\n-\n-  /* If the target supports the test-and-set directly, great.  */\n-  icode = direct_optab_handler (sync_lock_test_and_set_optab, mode);\n-  if (icode != CODE_FOR_nothing)\n-    {\n-      struct expand_operand ops[3];\n-\n-      create_output_operand (&ops[0], target, mode);\n-      create_fixed_operand (&ops[1], mem);\n-      /* VAL may have been promoted to a wider mode.  Shrink it if so.  */\n-      create_convert_operand_to (&ops[2], val, mode, true);\n-      if (maybe_expand_insn (icode, 3, ops))\n-\treturn ops[0].value;\n-    }\n-\n-  /* Otherwise, use a compare-and-swap loop for the exchange.  */\n-  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n-      != CODE_FOR_nothing)\n-    {\n-      if (!target || !register_operand (target, mode))\n-\ttarget = gen_reg_rtx (mode);\n-      if (GET_MODE (val) != VOIDmode && GET_MODE (val) != mode)\n-\tval = convert_modes (mode, GET_MODE (val), val, 1);\n-      if (expand_compare_and_swap_loop (mem, target, val, NULL_RTX))\n-\treturn target;\n+        return target;\n     }\n \n   return NULL_RTX;\n@@ -7838,6 +7975,14 @@ maybe_gen_insn (enum insn_code icode, unsigned int nops,\n     case 6:\n       return GEN_FCN (icode) (ops[0].value, ops[1].value, ops[2].value,\n \t\t\t      ops[3].value, ops[4].value, ops[5].value);\n+    case 7:\n+      return GEN_FCN (icode) (ops[0].value, ops[1].value, ops[2].value,\n+\t\t\t      ops[3].value, ops[4].value, ops[5].value,\n+\t\t\t      ops[6].value);\n+    case 8:\n+      return GEN_FCN (icode) (ops[0].value, ops[1].value, ops[2].value,\n+\t\t\t      ops[3].value, ops[4].value, ops[5].value,\n+\t\t\t      ops[6].value, ops[7].value);\n     }\n   gcc_unreachable ();\n }"}, {"sha": "d70b3fa0f9183bf66036faba6123a1d7e57a3db0", "filename": "gcc/optabs.h", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -695,6 +695,34 @@ enum direct_optab_index\n   /* Atomic clear with release semantics.  */\n   DOI_sync_lock_release,\n \n+  /* Atomic operations with memory model parameters. */\n+  DOI_atomic_exchange,\n+  DOI_atomic_compare_and_swap,\n+  DOI_atomic_load,\n+  DOI_atomic_store,\n+  DOI_atomic_add_fetch,\n+  DOI_atomic_sub_fetch,\n+  DOI_atomic_and_fetch,\n+  DOI_atomic_nand_fetch,\n+  DOI_atomic_xor_fetch,\n+  DOI_atomic_or_fetch,\n+  DOI_atomic_fetch_add,\n+  DOI_atomic_fetch_sub,\n+  DOI_atomic_fetch_and,\n+  DOI_atomic_fetch_nand,\n+  DOI_atomic_fetch_xor,\n+  DOI_atomic_fetch_or,\n+  DOI_atomic_add,\n+  DOI_atomic_sub,\n+  DOI_atomic_and,\n+  DOI_atomic_nand,\n+  DOI_atomic_xor,\n+  DOI_atomic_or,\n+  DOI_atomic_always_lock_free,\n+  DOI_atomic_is_lock_free,\n+  DOI_atomic_thread_fence,\n+  DOI_atomic_signal_fence,\n+\n   /* Vector permutation.  */\n   DOI_vec_perm,\n   DOI_vec_perm_const,\n@@ -744,6 +772,60 @@ typedef struct direct_optab_d *direct_optab;\n   (&direct_optab_table[(int) DOI_sync_lock_test_and_set])\n #define sync_lock_release_optab \\\n   (&direct_optab_table[(int) DOI_sync_lock_release])\n+\n+#define atomic_exchange_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_exchange])\n+#define atomic_compare_and_swap_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_compare_and_swap])\n+#define atomic_load_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_load])\n+#define atomic_store_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_store])\n+#define atomic_add_fetch_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_add_fetch])\n+#define atomic_sub_fetch_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_sub_fetch])\n+#define atomic_and_fetch_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_and_fetch])\n+#define atomic_nand_fetch_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_nand_fetch])\n+#define atomic_xor_fetch_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_xor_fetch])\n+#define atomic_or_fetch_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_or_fetch])\n+#define atomic_fetch_add_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_fetch_add])\n+#define atomic_fetch_sub_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_fetch_sub])\n+#define atomic_fetch_and_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_fetch_and])\n+#define atomic_fetch_nand_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_fetch_nand])\n+#define atomic_fetch_xor_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_fetch_xor])\n+#define atomic_fetch_or_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_fetch_or])\n+#define atomic_add_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_add])\n+#define atomic_sub_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_sub])\n+#define atomic_and_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_and])\n+#define atomic_nand_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_nand])\n+#define atomic_xor_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_xor])\n+#define atomic_or_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_or])\n+#define atomic_always_lock_free_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_always_lock_free])\n+#define atomic_is_lock_free_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_is_lock_free])\n+#define atomic_thread_fence_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_thread_fence])\n+#define atomic_signal_fence_optab \\\n+  (&direct_optab_table[(int) DOI_atomic_signal_fence])\n+\n #define vec_perm_optab (&direct_optab_table[DOI_vec_perm])\n #define vec_perm_const_optab (&direct_optab_table[(int) DOI_vec_perm_const])\n \f\n@@ -883,6 +965,13 @@ extern void expand_float (rtx, rtx, int);\n /* Return the insn_code for a FLOAT_EXPR.  */\n enum insn_code can_float_p (enum machine_mode, enum machine_mode, int);\n \n+/* Return true if there is an inline compare and swap pattern.  */\n+extern bool can_compare_and_swap_p (enum machine_mode);\n+\n+/* Generate code for a compare and swap.  */\n+extern bool expand_atomic_compare_and_swap (rtx *, rtx *, rtx, rtx, rtx, bool,\n+\t\t\t\t\t    enum memmodel, enum memmodel);\n+\n /* Check whether an operation represented by the code CODE is a\n    convert operation that is supported by the target platform in\n    vector form */"}, {"sha": "a7ae09185798a9bb2ae70396342f38d509c49128", "filename": "gcc/params.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -921,11 +921,26 @@ DEFPARAM (PARAM_CASE_VALUES_THRESHOLD,\n           0, 0, 0)\n \n /* Data race flags for C++0x memory model compliance.  */\n+DEFPARAM (PARAM_ALLOW_LOAD_DATA_RACES,\n+\t  \"allow-load-data-races\",\n+\t  \"Allow new data races on loads to be introduced\",\n+\t  1, 0, 1)\n+\n DEFPARAM (PARAM_ALLOW_STORE_DATA_RACES,\n \t  \"allow-store-data-races\",\n \t  \"Allow new data races on stores to be introduced\",\n \t  1, 0, 1)\n \n+DEFPARAM (PARAM_ALLOW_PACKED_LOAD_DATA_RACES,\n+\t  \"allow-packed-load-data-races\",\n+\t  \"Allow new data races on packed data loads to be introduced\",\n+\t  1, 0, 1)\n+\n+DEFPARAM (PARAM_ALLOW_PACKED_STORE_DATA_RACES,\n+\t  \"allow-packed-store-data-races\",\n+\t  \"Allow new data races on packed data stores to be introduced\",\n+\t  1, 0, 1)\n+\n /* Reassociation width to be used by tree reassoc optimization.  */\n DEFPARAM (PARAM_TREE_REASSOC_WIDTH,\n \t  \"tree-reassoc-width\","}, {"sha": "0bf8961fd0e3e8e866e40e6bc9c60fd170ca3c52", "filename": "gcc/params.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -211,6 +211,13 @@ extern void init_param_values (int *params);\n   PARAM_VALUE (PARAM_MIN_NONDEBUG_INSN_UID)\n #define MAX_STORES_TO_SINK \\\n   PARAM_VALUE (PARAM_MAX_STORES_TO_SINK)\n+#define ALLOW_LOAD_DATA_RACES \\\n+  PARAM_VALUE (PARAM_ALLOW_LOAD_DATA_RACES)\n #define ALLOW_STORE_DATA_RACES \\\n   PARAM_VALUE (PARAM_ALLOW_STORE_DATA_RACES)\n+#define ALLOW_PACKED_LOAD_DATA_RACES \\\n+  PARAM_VALUE (PARAM_ALLOW_PACKED_LOAD_DATA_RACES)\n+#define ALLOW_PACKED_STORE_DATA_RACES \\\n+  PARAM_VALUE (PARAM_ALLOW_PACKED_STORE_DATA_RACES)\n+\n #endif /* ! GCC_PARAMS_H */"}, {"sha": "1a2df9ac01845d986870666f70f3a2f5f9eb331a", "filename": "gcc/sync-builtins.def", "status": "modified", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fsync-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Fsync-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsync-builtins.def?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -256,3 +256,341 @@ DEF_SYNC_BUILTIN (BUILT_IN_SYNC_LOCK_RELEASE_16, \"__sync_lock_release_16\",\n \n DEF_SYNC_BUILTIN (BUILT_IN_SYNC_SYNCHRONIZE, \"__sync_synchronize\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+\n+/* __sync* builtins for the C++ memory model.  */\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_EXCHANGE,\n+\t\t  \"__atomic_exchange\",\n+\t\t  BT_FN_VOID_SIZE_VPTR_PTR_PTR_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_EXCHANGE_N,\n+\t\t  \"__atomic_exchange_n\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_EXCHANGE_1,\n+\t\t  \"__atomic_exchange_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_EXCHANGE_2,\n+\t\t  \"__atomic_exchange_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_EXCHANGE_4,\n+\t\t  \"__atomic_exchange_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_EXCHANGE_8,\n+\t\t  \"__atomic_exchange_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_EXCHANGE_16,\n+\t\t  \"__atomic_exchange_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_LOAD,\n+\t\t  \"__atomic_load\",\n+\t\t  BT_FN_VOID_SIZE_CONST_VPTR_PTR_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_LOAD_N,\n+\t\t  \"__atomic_load_n\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_LOAD_1,\n+\t\t  \"__atomic_load_1\",\n+\t\t  BT_FN_I1_CONST_VPTR_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_LOAD_2,\n+\t\t  \"__atomic_load_2\",\n+\t\t  BT_FN_I2_CONST_VPTR_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_LOAD_4,\n+\t\t  \"__atomic_load_4\",\n+\t\t  BT_FN_I4_CONST_VPTR_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_LOAD_8,\n+\t\t  \"__atomic_load_8\",\n+\t\t  BT_FN_I8_CONST_VPTR_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_LOAD_16,\n+\t\t  \"__atomic_load_16\",\n+\t\t  BT_FN_I16_CONST_VPTR_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_COMPARE_EXCHANGE,\n+\t\t  \"__atomic_compare_exchange\",\n+\t\t  BT_FN_BOOL_SIZE_VPTR_PTR_PTR_INT_INT,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_N,\n+\t\t  \"__atomic_compare_exchange_n\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_1,\n+\t\t  \"__atomic_compare_exchange_1\",\n+\t\t  BT_FN_BOOL_VPTR_PTR_I1_BOOL_INT_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_2,\n+\t\t  \"__atomic_compare_exchange_2\",\n+\t\t  BT_FN_BOOL_VPTR_PTR_I2_BOOL_INT_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4,\n+\t\t  \"__atomic_compare_exchange_4\",\n+\t\t  BT_FN_BOOL_VPTR_PTR_I4_BOOL_INT_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8,\n+\t\t  \"__atomic_compare_exchange_8\",\n+\t\t  BT_FN_BOOL_VPTR_PTR_I8_BOOL_INT_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_16,\n+\t\t  \"__atomic_compare_exchange_16\",\n+\t\t  BT_FN_BOOL_VPTR_PTR_I16_BOOL_INT_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_STORE,\n+\t\t  \"__atomic_store\",\n+\t\t  BT_FN_VOID_SIZE_VPTR_PTR_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_STORE_N,\n+\t\t  \"__atomic_store_n\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_STORE_1,\n+\t\t  \"__atomic_store_1\",\n+\t\t  BT_FN_VOID_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_STORE_2,\n+\t\t  \"__atomic_store_2\",\n+\t\t  BT_FN_VOID_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_STORE_4,\n+\t\t  \"__atomic_store_4\",\n+\t\t  BT_FN_VOID_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_STORE_8,\n+\t\t  \"__atomic_store_8\",\n+\t\t  BT_FN_VOID_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_STORE_16,\n+\t\t  \"__atomic_store_16\",\n+\t\t  BT_FN_VOID_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_ADD_FETCH_N,\n+\t\t  \"__atomic_add_fetch\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_ADD_FETCH_1,\n+\t\t  \"__atomic_add_fetch_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_ADD_FETCH_2,\n+\t\t  \"__atomic_add_fetch_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_ADD_FETCH_4,\n+\t\t  \"__atomic_add_fetch_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_ADD_FETCH_8,\n+\t\t  \"__atomic_add_fetch_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_ADD_FETCH_16,\n+\t\t  \"__atomic_add_fetch_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_SUB_FETCH_N,\n+\t\t  \"__atomic_sub_fetch\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_SUB_FETCH_1,\n+\t\t  \"__atomic_sub_fetch_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_SUB_FETCH_2,\n+\t\t  \"__atomic_sub_fetch_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_SUB_FETCH_4,\n+\t\t  \"__atomic_sub_fetch_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_SUB_FETCH_8,\n+\t\t  \"__atomic_sub_fetch_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_SUB_FETCH_16,\n+\t\t  \"__atomic_sub_fetch_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_AND_FETCH_N,\n+\t\t  \"__atomic_and_fetch\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_AND_FETCH_1,\n+\t\t  \"__atomic_and_fetch_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_AND_FETCH_2,\n+\t\t  \"__atomic_and_fetch_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_AND_FETCH_4,\n+\t\t  \"__atomic_and_fetch_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_AND_FETCH_8,\n+\t\t  \"__atomic_and_fetch_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_AND_FETCH_16,\n+\t\t  \"__atomic_and_fetch_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_NAND_FETCH_N,\n+\t\t  \"__atomic_nand_fetch\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_NAND_FETCH_1,\n+\t\t  \"__atomic_nand_fetch_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_NAND_FETCH_2,\n+\t\t  \"__atomic_nand_fetch_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_NAND_FETCH_4,\n+\t\t  \"__atomic_nand_fetch_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_NAND_FETCH_8,\n+\t\t  \"__atomic_nand_fetch_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_NAND_FETCH_16,\n+\t\t  \"__atomic_nand_fetch_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_XOR_FETCH_N,\n+\t\t  \"__atomic_xor_fetch\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_XOR_FETCH_1,\n+\t\t  \"__atomic_xor_fetch_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_XOR_FETCH_2,\n+\t\t  \"__atomic_xor_fetch_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_XOR_FETCH_4,\n+\t\t  \"__atomic_xor_fetch_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_XOR_FETCH_8,\n+\t\t  \"__atomic_xor_fetch_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_XOR_FETCH_16,\n+\t\t  \"__atomic_xor_fetch_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_OR_FETCH_N,\n+\t\t  \"__atomic_or_fetch\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_OR_FETCH_1,\n+\t\t  \"__atomic_or_fetch_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_OR_FETCH_2,\n+\t\t  \"__atomic_or_fetch_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_OR_FETCH_4,\n+\t\t  \"__atomic_or_fetch_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_OR_FETCH_8,\n+\t\t  \"__atomic_or_fetch_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_OR_FETCH_16,\n+\t\t  \"__atomic_or_fetch_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_ADD_N,\n+\t\t  \"__atomic_fetch_add\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_ADD_1,\n+\t\t  \"__atomic_fetch_add_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_ADD_2,\n+\t\t  \"__atomic_fetch_add_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_ADD_4,\n+\t\t  \"__atomic_fetch_add_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_ADD_8,\n+\t\t  \"__atomic_fetch_add_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_ADD_16,\n+\t\t  \"__atomic_fetch_add_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_SUB_N,\n+\t\t  \"__atomic_fetch_sub\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_SUB_1,\n+\t\t  \"__atomic_fetch_sub_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_SUB_2,\n+\t\t  \"__atomic_fetch_sub_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_SUB_4,\n+\t\t  \"__atomic_fetch_sub_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_SUB_8,\n+\t\t  \"__atomic_fetch_sub_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_SUB_16,\n+\t\t  \"__atomic_fetch_sub_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_AND_N,\n+\t\t  \"__atomic_fetch_and\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_AND_1,\n+\t\t  \"__atomic_fetch_and_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_AND_2,\n+\t\t  \"__atomic_fetch_and_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_AND_4,\n+\t\t  \"__atomic_fetch_and_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_AND_8,\n+\t\t  \"__atomic_fetch_and_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_AND_16,\n+\t\t  \"__atomic_fetch_and_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_NAND_N,\n+\t\t  \"__atomic_fetch_nand\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_NAND_1,\n+\t\t  \"__atomic_fetch_nand_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_NAND_2,\n+\t\t  \"__atomic_fetch_nand_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_NAND_4,\n+\t\t  \"__atomic_fetch_nand_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_NAND_8,\n+\t\t  \"__atomic_fetch_nand_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_NAND_16,\n+\t\t  \"__atomic_fetch_nand_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_XOR_N,\n+\t\t  \"__atomic_fetch_xor\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_XOR_1,\n+\t\t  \"__atomic_fetch_xor_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_XOR_2,\n+\t\t  \"__atomic_fetch_xor_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_XOR_4,\n+\t\t  \"__atomic_fetch_xor_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_XOR_8,\n+\t\t  \"__atomic_fetch_xor_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_XOR_16,\n+\t\t  \"__atomic_fetch_xor_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_OR_N,\n+\t\t  \"__atomic_fetch_or\",\n+\t\t  BT_FN_VOID_VAR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_OR_1,\n+\t\t  \"__atomic_fetch_or_1\",\n+\t\t  BT_FN_I1_VPTR_I1_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_OR_2,\n+\t\t  \"__atomic_fetch_or_2\",\n+\t\t  BT_FN_I2_VPTR_I2_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_OR_4,\n+\t\t  \"__atomic_fetch_or_4\",\n+\t\t  BT_FN_I4_VPTR_I4_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_OR_8,\n+\t\t  \"__atomic_fetch_or_8\",\n+\t\t  BT_FN_I8_VPTR_I8_INT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FETCH_OR_16,\n+\t\t  \"__atomic_fetch_or_16\",\n+\t\t  BT_FN_I16_VPTR_I16_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_ALWAYS_LOCK_FREE,\n+\t\t  \"__atomic_always_lock_free\",\n+\t\t  BT_FN_BOOL_SIZE_CONST_VPTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_IS_LOCK_FREE,\n+\t\t  \"__atomic_is_lock_free\",\n+\t\t  BT_FN_BOOL_SIZE_CONST_VPTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n+\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_THREAD_FENCE,\n+\t\t  \"__atomic_thread_fence\",\n+\t\t  BT_FN_VOID_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_SIGNAL_FENCE,\n+\t\t  \"__atomic_signal_fence\",\n+\t\t  BT_FN_VOID_INT, ATTR_NOTHROW_LEAF_LIST)\n+"}, {"sha": "aa0b7b610e349101f418e2a851f922699b9a00e0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -1,3 +1,67 @@\n+2011-11-06  Andrew MacLeod  <amacleod@redhat.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tMerged from cxx-mem-model.\n+\n+\t* lib/target-supports.exp (check_effective_target_sync_int_128,\n+\tcheck_effective_target_sync_long_long): Check whether the target\n+\tsupports 64 and 128 bit __sync builtins.\n+\t(check_effective_target_cas_char): New.\n+\t(check_effective_target_cas_int): New.\n+\t* gcc.dg/dg.exp: Exclude simulate-thread tests.\n+\t* gcc.dg/atomic-noinline[-aux].c: New.  Make a variety of atomics calls.\n+\t* gcc.dg/atomic-generic[-aux].c: New. Test that generic functions\n+\tproduce the expected library calls.\n+\t* gcc.dg/atomic-fence.c: New functional tests.\n+\t* gcc.dg/atomic-param.c: New.  Checl for illegal number of parameters.\n+\t* gcc.dg/atomic-invalid.c: New.  Test invalid parameters.\n+\t* gcc.dg/atomic-lockfree[-aux].c: New tests.\n+\t* gcc.dg/atomic-compare-exchange-{1-5}.c: New functional tests.\n+\t* gcc.dg/atomic-op-[1-5].c: New.  Test atomic fetch functionality.\n+\t* gcc.dg/atomic-exchange-{1-5}.c: New functional tests.\n+\t* gcc.dg/atomic-load-{1-5}.c: New functional tests.\n+\t* gcc.dg/atomic-store-{1-5}.c: New functional tests.\n+\t* gcc.dg/simulate-thread/atomic-load-int128.c: New. Verify int128 loads\n+\tare atomic.\n+\t* gcc.dg/simulate-thread/atomic-load-longlong.c: New. Verify 8 byte\n+\tloads are atomic.\n+\t* gcc.dg/simulate-thread/atomic-load-int.c: New. Verify 4 byte loads\n+\tare atomic.\n+\t* gcc.dg/simulate-thread/atomic-load-short.c: New. Verify 2 byte loads\n+\tare atomic.\n+\t* gcc.dg/simulate-thread/atomic-other-int128.c: New. Verify other\n+\tint128 operations are atomic.\n+\t* gcc.dg/simulate-thread/atomic-other-int.c: New. Verify other 4 byte\n+\toperations are atomic.\n+\t* gcc.dg/simulate-thread/atomic-other-longlong.c: New. Verify 8 byte\n+\toperations are atomic.\n+\t* gcc.dg/simulate-thread/atomic-other-short.c: New. Verify other 2 byte\n+\toperations are atomic.\n+\t* gcc.dg/simulate-thread/speculative-store.c: New. Verify speculative\n+\tstores aren't moved out of a loop.\n+\t* gcc.dg/simulate-thread/strict-align-global.c: New. Verify small\n+\tglobals don't overwrite neighbouring globals.\n+\t* gcc.dg/simulate-thread/subfields.c: New. Verify struct component\n+\twrites dont overwrite neighbouring components.\n+\t* c-c++-common/gomp/atomic-10.c: Use cas_int; match __atomic builtin.\n+\t* c-c++-common/gomp/atomic-3.c: Likewise.\n+\t* c-c++-common/gomp/atomic-9.c: Likewise.\n+\t* gcc.dg/gomp/atomic-1.c, gcc.dg/gomp/atomic-2.c,\n+\tgcc.dg/gomp/atomic-3.c, gcc.dg/gomp/atomic-4.c, gcc.dg/gomp/atomic-7.c,\n+\tgcc.dg/gomp/atomic-8.c, gcc.dg/gomp/atomic-9.c,\n+\tgcc.dg/gomp/atomic-10.c, gcc.dg/gomp/atomic-12.c,\n+\tgcc.dg/gomp/atomic-13.c, gcc.dg/gomp/atomic-14.c,\n+\tgcc.dg/gomp/atomic-15.c: Move to c-c++-common/gomp/.\n+\t* g++.dg/gomp/atomic-1.C, g++.dg/gomp/atomic-2.C,\n+\tg++.dg/gomp/atomic-3.C, g++.dg/gomp/atomic-4.C, g++.dg/gomp/atomic-7.C,\n+\tg++.dg/gomp/atomic-8.C, g++.dg/gomp/atomic-9.C,\n+\tg++.dg/gomp/atomic-10.C, g++.dg/gomp/atomic-11.C,\n+\tg++.dg/gomp/atomic-12.C, g++.dg/gomp/atomic-13.C,\n+\tg++.dg/gomp/atomic-15.C: Remove.\n+\t* gcc.dg/gomp/gomp.exp, g++.dg/gomp/gomp.exp: Run c-c++-common tests.\n+\t* gcc.dg/gomp/atomic-11.c: Remove test.\n+\n 2011-11-06  Ira Rosen  <ira.rosen@linaro.org>\n \n \t* gcc.dg/vect/bb-slp-cond-1.c: New test."}, {"sha": "3e4bc569ba7fdb1db0fa101d110efe43238fe2db", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-1.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-1.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "previous_filename": "gcc/testsuite/gcc.dg/gomp/atomic-1.c"}, {"sha": "21d035e15c972b5cd00bf6398eab2feac86b4759", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-10.c", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-10.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -1,6 +1,7 @@\n /* PR middle-end/28046 */\n /* { dg-do compile } */\n /* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+/* { dg-require-effective-target cas_int } */\n \n int a[3], b;\n struct C { int x; int y; } c;\n@@ -20,5 +21,5 @@ foo (void)\n   *baz () += bar ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"__sync_fetch_and_add\" 4 \"ompexp\" { target i?86-*-* x86_64-*-* ia64-*-* powerpc*-*-* alpha*-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"__atomic_fetch_add\" 4 \"ompexp\" } } */\n /* { dg-final { cleanup-tree-dump \"ompexp\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/gomp/atomic-10.c"}, {"sha": "618c4c8e6480774acf00df6310967c44eb7e3444", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-12.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-12.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "previous_filename": "gcc/testsuite/gcc.dg/gomp/atomic-12.c"}, {"sha": "0146825f2bb285e6b28170be5c7b58d2a74661f1", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-13.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-13.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "previous_filename": "gcc/testsuite/gcc.dg/gomp/atomic-13.c"}, {"sha": "f8fc9d87257ab5a2c38a09fad6146009d93b5cb2", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-14.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-14.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "previous_filename": "gcc/testsuite/gcc.dg/gomp/atomic-14.c"}, {"sha": "13a9e0ce48a15a8d911fd26648968b55f7e213a7", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-15.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-15.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "previous_filename": "gcc/testsuite/gcc.dg/gomp/atomic-15.c"}, {"sha": "720ec9e8ba0dc1690e733af9a451f42f3a0a1505", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-2.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-2.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "previous_filename": "gcc/testsuite/gcc.dg/gomp/atomic-2.c"}, {"sha": "5b9e60cde8b35407dd560f27c99f338717e137ed", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-3.c", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-3.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile } */\n /* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+/* { dg-require-effective-target cas_int } */\n \n int *xyzzy;\n \n@@ -9,5 +10,5 @@ void f1(void)\n     xyzzy++;\n }\n \n-/* { dg-final { scan-tree-dump-times \"xyzzy, 4\" 1 \"ompexp\" { target i?86-*-* x86_64-*-* ia64-*-* powerpc*-*-* alpha*-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"xyzzy, 4\" 1 \"ompexp\" } } */\n /* { dg-final { cleanup-tree-dump \"ompexp\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/gomp/atomic-3.c"}, {"sha": "7f27370d535b6f1f1c360d25195ee1e6b2631395", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-4.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-4.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "previous_filename": "gcc/testsuite/gcc.dg/gomp/atomic-4.c"}, {"sha": "612e97f453039bfcadd32e28f95ffdb84379edfa", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-7.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-7.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "previous_filename": "gcc/testsuite/gcc.dg/gomp/atomic-7.c"}, {"sha": "2f04151f0ed854ca5fa89e898978cb141c4df15d", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-8.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-8.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "previous_filename": "gcc/testsuite/gcc.dg/gomp/atomic-8.c"}, {"sha": "ff5cb4091f929d9d30a452545f7decbc32e9b884", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-9.c", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-9.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile } */\n /* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+/* { dg-require-effective-target cas_int } */\n \n volatile int *bar(void);\n \n@@ -9,5 +10,5 @@ void f1(void)\n     *bar() += 1;\n }\n \n-/* { dg-final { scan-tree-dump-times \"__sync_fetch_and_add\" 1 \"ompexp\" { target i?86-*-* x86_64-*-* ia64-*-* powerpc*-*-* alpha*-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"__atomic_fetch_add\" 1 \"ompexp\" } } */\n /* { dg-final { cleanup-tree-dump \"ompexp\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/gomp/atomic-9.c"}, {"sha": "cee19d68029bea58079aa204fdc20c0efbf3ae9a", "filename": "gcc/testsuite/g++.dg/dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -48,6 +48,7 @@ set tests [prune $tests $srcdir/$subdir/tree-prof/*]\n set tests [prune $tests $srcdir/$subdir/torture/*]\n set tests [prune $tests $srcdir/$subdir/graphite/*]\n set tests [prune $tests $srcdir/$subdir/guality/*]\n+set tests [prune $tests $srcdir/$subdir/simulate-thread/*]\n \n # Main loop.\n dg-runtest $tests \"\" $DEFAULT_CXXFLAGS"}, {"sha": "3e4bc569ba7fdb1db0fa101d110efe43238fe2db", "filename": "gcc/testsuite/g++.dg/gomp/atomic-1.C", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-1.C?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,99 +0,0 @@\n-/* { dg-do compile } */\n-\n-int x;\n-volatile int y;\n-volatile unsigned char z;\n-\n-void f1(void)\n-{\n-  #pragma omp atomic\n-    x++;\n-  #pragma omp atomic\n-    x--;\n-  #pragma omp atomic\n-    ++x;\n-  #pragma omp atomic\n-    --x;\n-  #pragma omp atomic\n-    x += 1;\n-  #pragma omp atomic\n-    x -= y;\n-  #pragma omp atomic\n-    x |= 1;\n-  #pragma omp atomic\n-    x &= 1;\n-  #pragma omp atomic\n-    x ^= 1;\n-  #pragma omp atomic\n-    x *= 3;\n-  #pragma omp atomic\n-    x /= 3;\n-  #pragma omp atomic\n-    x /= 3;\n-  #pragma omp atomic\n-    x <<= 3;\n-  #pragma omp atomic\n-    x >>= 3;\n-}\n-\n-void f2(void)\n-{\n-  #pragma omp atomic\n-    y++;\n-  #pragma omp atomic\n-    y--;\n-  #pragma omp atomic\n-    ++y;\n-  #pragma omp atomic\n-    --y;\n-  #pragma omp atomic\n-    y += 1;\n-  #pragma omp atomic\n-    y -= x;\n-  #pragma omp atomic\n-    y |= 1;\n-  #pragma omp atomic\n-    y &= 1;\n-  #pragma omp atomic\n-    y ^= 1;\n-  #pragma omp atomic\n-    y *= 3;\n-  #pragma omp atomic\n-    y /= 3;\n-  #pragma omp atomic\n-    y /= 3;\n-  #pragma omp atomic\n-    y <<= 3;\n-  #pragma omp atomic\n-    y >>= 3;\n-}\n-\n-void f3(void)\n-{\n-  #pragma omp atomic\n-    z++;\n-  #pragma omp atomic\n-    z--;\n-  #pragma omp atomic\n-    ++z;\n-  #pragma omp atomic\n-    --z;\n-  #pragma omp atomic\n-    z += 1;\n-  #pragma omp atomic\n-    z |= 1;\n-  #pragma omp atomic\n-    z &= 1;\n-  #pragma omp atomic\n-    z ^= 1;\n-  #pragma omp atomic\n-    z *= 3;\n-  #pragma omp atomic\n-    z /= 3;\n-  #pragma omp atomic\n-    z /= 3;\n-  #pragma omp atomic\n-    z <<= 3;\n-  #pragma omp atomic\n-    z >>= 3;\n-}"}, {"sha": "fe64f0f06313d483d3a9315bb0628f75d29c2056", "filename": "gcc/testsuite/g++.dg/gomp/atomic-10.C", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-10.C?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,24 +0,0 @@\n-// PR middle-end/28046\n-// { dg-do compile }\n-// { dg-options \"-fopenmp -fdump-tree-ompexp\" }\n-\n-int a[3], b;\n-struct C { int x; int y; } c;\n-\n-int bar (void), *baz (void);\n-\n-void\n-foo (void)\n-{\n-#pragma omp atomic\n-  a[2] += bar ();\n-#pragma omp atomic\n-  b += bar ();\n-#pragma omp atomic\n-  c.y += bar ();\n-#pragma omp atomic\n-  *baz () += bar ();\n-}\n-\n-// { dg-final { scan-tree-dump-times \"__sync_fetch_and_add\" 4 \"ompexp\" { target i?86-*-* x86_64-*-* ia64-*-* powerpc*-*-* alpha*-*-* } } }\n-// { dg-final { cleanup-tree-dump \"ompexp\" } }"}, {"sha": "618c4c8e6480774acf00df6310967c44eb7e3444", "filename": "gcc/testsuite/g++.dg/gomp/atomic-11.C", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-11.C?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,306 +0,0 @@\n-/* PR middle-end/45423 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-gimple -g0\" } */\n-/* atomicvar should never be referenced in between the barrier and\n-   following #pragma omp atomic_load.  */\n-/* { dg-final { scan-tree-dump-not \"barrier\\[^#\\]*atomicvar\" \"gimple\" } } */\n-/* { dg-final { cleanup-tree-dump \"gimple\" } } */\n-\n-#ifdef __cplusplus\n-bool atomicvar, c;\n-#else\n-_Bool atomicvar, c;\n-#endif\n-int i, atomicvar2, c2;\n-\n-int\n-foo (void)\n-{\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar |= -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar |= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar |= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar |= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar |= c;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar ^= -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar ^= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar ^= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar ^= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar ^= c;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar &= -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar &= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar &= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar &= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar &= c;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar += -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar += 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar += 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar += 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar += c;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar -= -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar -= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar -= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar -= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar -= c;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar *= -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar *= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar *= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar *= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar *= c;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar /= -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar /= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar /= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar /= c;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar <<= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar <<= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar <<= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar <<= i;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar >>= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar >>= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar >>= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar >>= i;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar++;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    ++atomicvar;\n-  #pragma omp barrier\n-#ifndef __cplusplus\n-  #pragma omp atomic\n-    atomicvar--;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    --atomicvar;\n-  #pragma omp barrier\n-#endif\n-  return 0;\n-}\n-\n-int\n-bar (void)\n-{\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 |= -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 |= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 |= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 |= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 |= c2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 ^= -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 ^= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 ^= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 ^= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 ^= c2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 &= -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 &= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 &= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 &= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 &= c2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 += -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 += 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 += 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 += 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 += c2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 -= -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 -= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 -= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 -= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 -= c2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 *= -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 *= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 *= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 *= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 *= c2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 /= -1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 /= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 /= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 /= c2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 <<= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 <<= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 <<= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 <<= i;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 >>= 0;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 >>= 1;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 >>= 2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2 >>= i;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2++;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    ++atomicvar2;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    atomicvar2--;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    --atomicvar2;\n-  #pragma omp barrier\n-  return 0;\n-}"}, {"sha": "6c1f965021dd8bd3b5a667e1c27b49d5a4d23309", "filename": "gcc/testsuite/g++.dg/gomp/atomic-12.C", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-12.C?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,9 +0,0 @@\n-/* PR middle-end/45423 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-gimple -g0 -O2\" } */\n-/* atomicvar should never be referenced in between the barrier and\n-   following #pragma omp atomic_load.  */\n-/* { dg-final { scan-tree-dump-not \"barrier\\[^#\\]*atomicvar\" \"gimple\" } } */\n-/* { dg-final { cleanup-tree-dump \"gimple\" } } */\n-\n-#include \"atomic-11.C\""}, {"sha": "f8fc9d87257ab5a2c38a09fad6146009d93b5cb2", "filename": "gcc/testsuite/g++.dg/gomp/atomic-13.C", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-13.C?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,43 +0,0 @@\n-/* PR middle-end/45423 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fopenmp\" } */\n-\n-#ifdef __cplusplus\n-bool *baz ();\n-#else\n-_Bool *baz ();\n-#endif\n-int *bar ();\n-\n-int\n-foo (void)\n-{\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    (*bar ())++;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    ++(*bar ());\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    (*bar ())--;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    --(*bar ());\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    (*baz ())++;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    ++(*baz ());\n-#ifndef __cplusplus\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    (*baz ())--;\n-  #pragma omp barrier\n-  #pragma omp atomic\n-    --(*baz ());\n-  #pragma omp barrier\n-#endif\n-  return 0;\n-}"}, {"sha": "95eb8b4534d31db5ea4e71b60e90f9783cf29da4", "filename": "gcc/testsuite/g++.dg/gomp/atomic-15.C", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-15.C?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,46 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-fopenmp\" }\n-\n-int x = 6;\n-\n-int\n-main ()\n-{\n-  int v;\n-  #pragma omp atomic\n-    x = x * 7 + 6;\t// { dg-error \"expected\" }\n-  #pragma omp atomic\n-    x = x * 7 ^ 6;\t// { dg-error \"expected\" }\n-  #pragma omp atomic update\n-    x = x - 8 + 6;\t// { dg-error \"expected\" }\n-  #pragma omp atomic\n-    x = x ^ 7 | 2;\t// { dg-error \"expected\" }\n-  #pragma omp atomic\n-    x = x / 7 * 2;\t// { dg-error \"expected\" }\n-  #pragma omp atomic\n-    x = x / 7 / 2;\t// { dg-error \"expected\" }\n-  #pragma omp atomic capture\n-    v = x = x | 6;\t// { dg-error \"invalid operator\" }\n-  #pragma omp atomic capture\n-    { v = x; x = x * 7 + 6; }\t// { dg-error \"expected\" }\n-  #pragma omp atomic capture\n-    { v = x; x = x * 7 ^ 6; }\t// { dg-error \"expected\" }\n-  #pragma omp atomic capture\n-    { v = x; x = x - 8 + 6; }\t// { dg-error \"expected\" }\n-  #pragma omp atomic capture\n-    { v = x; x = x ^ 7 | 2; }\t// { dg-error \"expected\" }\n-  #pragma omp atomic capture\n-    { v = x; x = x / 7 * 2; }\t// { dg-error \"expected\" }\n-  #pragma omp atomic capture\n-    { v = x; x = x / 7 / 2; }\t// { dg-error \"expected\" }\n-  #pragma omp atomic capture\n-    { x = x * 7 + 6; v = x; }\t// { dg-error \"expected\" }\n-  #pragma omp atomic capture\n-    { x = x * 7 ^ 6; v = x; }\t// { dg-error \"expected\" }\n-  #pragma omp atomic capture\n-    { x = x - 8 + 6; v = x; }\t// { dg-error \"expected\" }\n-  #pragma omp atomic capture\n-    { x = x ^ 7 | 2; v = x; }\t// { dg-error \"expected\" }\n-  (void) v;\n-  return 0;\n-}"}, {"sha": "720ec9e8ba0dc1690e733af9a451f42f3a0a1505", "filename": "gcc/testsuite/g++.dg/gomp/atomic-2.C", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-2.C?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,23 +0,0 @@\n-/* { dg-do compile } */\n-\n-float x, y;\n-\n-void f1(void)\n-{\n-  #pragma omp atomic\n-    x++;\n-  #pragma omp atomic\n-    x--;\n-  #pragma omp atomic\n-    ++x;\n-  #pragma omp atomic\n-    --x;\n-  #pragma omp atomic\n-    x += 1;\n-  #pragma omp atomic\n-    x -= y;\n-  #pragma omp atomic\n-    x *= 3;\n-  #pragma omp atomic\n-    x /= 3;\n-}"}, {"sha": "7ea792d3457ff252fa88a1ae3164c9d8f9ed572f", "filename": "gcc/testsuite/g++.dg/gomp/atomic-3.C", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-3.C?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,13 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n-\n-int *xyzzy;\n-\n-void f1(void)\n-{\n-  #pragma omp atomic\n-    xyzzy++;\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"xyzzy, 4\" 1 \"ompexp\" { target i?86-*-* x86_64-*-* ia64-*-* powerpc*-*-* alpha*-*-* } } } */\n-/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "7f27370d535b6f1f1c360d25195ee1e6b2631395", "filename": "gcc/testsuite/g++.dg/gomp/atomic-4.C", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-4.C?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,24 +0,0 @@\n-/* { dg-do compile } */\n-\n-int a[4];\n-int *p;\n-struct S { int x; int y[4]; } s;\n-int *bar(void);\n-\n-void f1(void)\n-{\n-  #pragma omp atomic\n-    a[4] += 1;\n-  #pragma omp atomic\n-    *p += 1;\n-  #pragma omp atomic\n-    s.x += 1;\n-  #pragma omp atomic\n-    s.y[*p] += 1;\n-  #pragma omp atomic\n-    s.y[*p] *= 42;\n-  #pragma omp atomic\n-    *bar() += 1;\n-  #pragma omp atomic\n-    *bar() *= 42;\n-}"}, {"sha": "612e97f453039bfcadd32e28f95ffdb84379edfa", "filename": "gcc/testsuite/g++.dg/gomp/atomic-7.C", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-7.C?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,23 +0,0 @@\n-/* { dg-do compile } */\n-\n-double x, y;\n-\n-void f2(void)\n-{\n-  #pragma omp atomic\n-    y++;\n-  #pragma omp atomic\n-    y--;\n-  #pragma omp atomic\n-    ++y;\n-  #pragma omp atomic\n-    --y;\n-  #pragma omp atomic\n-    y += 1;\n-  #pragma omp atomic\n-    y -= x;\n-  #pragma omp atomic\n-    y *= 3;\n-  #pragma omp atomic\n-    y /= 3;\n-}"}, {"sha": "2f04151f0ed854ca5fa89e898978cb141c4df15d", "filename": "gcc/testsuite/g++.dg/gomp/atomic-8.C", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-8.C?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,21 +0,0 @@\n-/* { dg-do compile } */\n-\n-long double z;\n-\n-void f3(void)\n-{\n-  #pragma omp atomic\n-    z++;\n-  #pragma omp atomic\n-    z--;\n-  #pragma omp atomic\n-    ++z;\n-  #pragma omp atomic\n-    --z;\n-  #pragma omp atomic\n-    z += 1;\n-  #pragma omp atomic\n-    z *= 3;\n-  #pragma omp atomic\n-    z /= 3;\n-}"}, {"sha": "2fafbd4097a11defd370a2f1d8bda4fb6b777079", "filename": "gcc/testsuite/g++.dg/gomp/atomic-9.C", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-9.C?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,13 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n-\n-volatile int *bar(void);\n-\n-void f1(void)\n-{\n-  #pragma omp atomic\n-    *bar() += 1;\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"__sync_fetch_and_add\" 1 \"ompexp\" { target i?86-*-* x86_64-*-* ia64-*-* powerpc*-*-* alpha*-*-* } } } */\n-/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "b99d302ddf56894aaba6123f22e44bf924d0d866", "filename": "gcc/testsuite/g++.dg/gomp/gomp.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fgomp.exp?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -27,7 +27,7 @@ if ![check_effective_target_fopenmp] {\n dg-init\n \n # Main loop.\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C]] \"\" \"-fopenmp\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C $srcdir/c-c++-common/gomp/*.c]] \"\" \"-fopenmp\"\n \n # All done.\n dg-finish"}, {"sha": "7e0041ee3824d72552fbc9d71b5632008f27cc1f", "filename": "gcc/testsuite/g++.dg/simulate-thread/atomics-1.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fatomics-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fatomics-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fatomics-1.C?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do link } */\n+/* { dg-options \"-std=c++0x\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+/* Test that atomic int and atomic char work properly.  */\n+\n+using namespace std;\n+\n+#include <atomic>\n+#include <limits.h>\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+atomic<int> atomi;\n+atomic<char> atomc;\n+\n+/* No need for parallel threads to do anything */\n+void simulate_thread_other_threads()\n+{\n+}\n+\n+/* Verify after every instruction is executed, that the atmoic int and\n+   char have one of the 2 legitimate values. */\n+int simulate_thread_step_verify()\n+{\n+  if (atomi != 0 && atomi != INT_MAX)\n+    {\n+      printf (\"FAIL: invalid intermediate result for atomi (%d).\\n\",\n+\t      (int)atomi);\n+      return 1;\n+    }\n+  if (atomc != 0 && atomc != CHAR_MAX)\n+    {\n+      printf (\"FAIL: invalid intermediate result for atomc (%d).\\n\",\n+\t      (int)atomc);\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+\n+/* Verify that both atmoics have the corerct value.  */\n+int simulate_thread_final_verify()\n+{\n+  if (atomi != INT_MAX)\n+    {\n+      printf (\"FAIL: invalid final result for atomi (%d).\\n\",\n+\t      (int)atomi);\n+      return 1;\n+    }\n+  if (atomc != CHAR_MAX)\n+    {\n+      printf (\"FAIL: invalid final result for atomc (%d).\\n\",\n+\t      (int)atomc);\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Test a store to an atomic int and an atomic char. */\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  atomi = INT_MAX;\n+  atomc = CHAR_MAX;\n+}\n+\n+int main ()\n+{\n+  simulate_thread_main();\n+  simulate_thread_done();\n+  return 0;\n+}"}, {"sha": "be3232d708735162222b7a70e935655b32aa0fa9", "filename": "gcc/testsuite/g++.dg/simulate-thread/atomics-2.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fatomics-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fatomics-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fatomics-2.C?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do link } */\n+/* { dg-options \"-std=c++0x\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+using namespace std;\n+\n+#include <atomic>\n+#include <limits.h>\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+atomic_int atomi;\n+\n+/* Non-atomic.  Use a type wide enough to possibly coerce GCC into\n+   moving things around.  */\n+long double j;\n+\n+\n+/* Test that an atomic store synchronizes with an atomic load.\n+\n+   In this case, test that the store to <j> happens-before the atomic\n+   store to <atomi>.  Make sure the compiler does not reorder the\n+   stores.  */\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  j = 13.0;\n+  atomi.store(1);\n+}\n+\n+int main ()\n+{\n+  simulate_thread_main();\n+  simulate_thread_done();\n+  return 0;\n+}\n+\n+void simulate_thread_other_threads()\n+{\n+}\n+\n+/* Verify that side-effects before an atomic store are correctly\n+   synchronized with the an atomic load to the same location.  */\n+int simulate_thread_step_verify()\n+{\n+  if (atomi.load() == 1 && j != 13.0)\n+    {\n+      printf (\"FAIL: invalid synchronization for atomic load/store.\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+\n+int simulate_thread_final_verify()\n+{\n+  return simulate_thread_step_verify();\n+}"}, {"sha": "077514a3ff586c3ed46b7c6e30a8f33e317429b5", "filename": "gcc/testsuite/g++.dg/simulate-thread/bitfields-2.C", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fbitfields-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fbitfields-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fbitfields-2.C?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-do link } */\n+/* { dg-options \"--param allow-load-data-races=0 --param allow-store-data-races=0\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+/* Test that setting <var.a> does not touch either <var.b> or <var.c>.\n+   In the C++ memory model, non contiguous bitfields (\"a\" and \"c\"\n+   here) should be considered as distinct memory locations, so we\n+   can't use bit twiddling to set either one.  */\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+#define CONSTA 12\n+\n+static int global;\n+struct S\n+{\n+  unsigned int a : 4;\n+  unsigned char b;\n+  unsigned int c : 6;\n+} var;\n+\n+__attribute__((noinline))\n+void set_a()\n+{\n+  var.a = CONSTA;\n+}\n+\n+void simulate_thread_other_threads()\n+{\n+  ++global;\n+  var.b = global;\n+  var.c = global;\n+}\n+\n+int simulate_thread_step_verify()\n+{\n+  int ret = 0;\n+  if (var.b != global)\n+    {\n+      printf (\"FAIL: Unexpected value: var.b is %d, should be %d\\n\",\n+\t      var.b, global);\n+      ret = 1;\n+    }\n+  if (var.c != global)\n+    {\n+      printf (\"FAIL: Unexpected value: var.c is %d, should be %d\\n\",\n+\t      var.c, global);\n+      ret = 1;\n+    }\n+  return ret;\n+}\n+\n+int simulate_thread_final_verify()\n+{\n+  int ret = simulate_thread_step_verify();\n+  if (var.a != CONSTA)\n+    {\n+      printf (\"FAIL: Unexpected value: var.a is %d, should be %d\\n\",\n+\t      var.a, CONSTA);\n+      ret = 1;\n+    }\n+  return ret;\n+}\n+\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  set_a();\n+}\n+\n+int main()\n+{\n+  simulate_thread_main();\n+  simulate_thread_done();\n+  return 0;\n+}"}, {"sha": "3acf21f876f08ed4bf7482d677702e6b9dc6ff7c", "filename": "gcc/testsuite/g++.dg/simulate-thread/bitfields.C", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fbitfields.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fbitfields.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsimulate-thread%2Fbitfields.C?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do link } */\n+/* { dg-options \"--param allow-load-data-races=0 --param allow-store-data-races=0\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+/* Test that setting <var.a> does not touch either <var.b> or <var.c>.\n+   In the C++ memory model, non contiguous bitfields (\"a\" and \"c\"\n+   here) should be considered as distinct memory locations, so we\n+   can't use bit twiddling to set either one.  */\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+#define CONSTA 12\n+\n+static int global;\n+struct S\n+{\n+  /* On x86-64, the volatile causes us to access <a> with a 32-bit\n+     access, and thus trigger this test.  */\n+  volatile unsigned int a : 4;\n+\n+  unsigned char b;\n+  unsigned int c : 6;\n+} var;\n+\n+__attribute__((noinline))\n+void set_a()\n+{\n+  var.a = CONSTA;\n+}\n+\n+void simulate_thread_other_threads()\n+{\n+  ++global;\n+  var.b = global;\n+  var.c = global;\n+}\n+\n+int simulate_thread_step_verify()\n+{\n+  int ret = 0;\n+  if (var.b != global)\n+    {\n+      printf (\"FAIL: Unexpected value: var.b is %d, should be %d\\n\",\n+\t      var.b, global);\n+      ret = 1;\n+    }\n+  if (var.c != global)\n+    {\n+      printf (\"FAIL: Unexpected value: var.c is %d, should be %d\\n\",\n+\t      var.c, global);\n+      ret = 1;\n+    }\n+  return ret;\n+}\n+\n+int simulate_thread_final_verify()\n+{\n+  int ret = simulate_thread_step_verify();\n+  if (var.a != CONSTA)\n+    {\n+      printf (\"FAIL: Unexpected value: var.a is %d, should be %d\\n\",\n+\t      var.a, CONSTA);\n+      ret = 1;\n+    }\n+  return ret;\n+}\n+\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  set_a();\n+}\n+\n+int main ()\n+{\n+  simulate_thread_main();\n+  simulate_thread_done();\n+  return 0;\n+}"}, {"sha": "2ac54e80887f55a57ccc94333460d9f65e3d6c32", "filename": "gcc/testsuite/gcc.dg/atomic-compare-exchange-1.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-1.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,85 @@\n+/* Test __atomic routines for existence and proper execution on 1 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_compare_exchange_n builtin for a char.  */\n+\n+extern void abort(void);\n+\n+char v = 0;\n+char expected = 0;\n+char max = ~0;\n+char desired = ~0;\n+char zero = 0;\n+\n+#define STRONG 0\n+#define WEAK 1\n+\n+main ()\n+{\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, max, STRONG , __ATOMIC_RELAXED, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  v = 0;\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &max, STRONG, __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "73b259777480cc8a66afd2c7c97d12e6561482a3", "filename": "gcc/testsuite/gcc.dg/atomic-compare-exchange-2.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-2.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,85 @@\n+/* Test __atomic routines for existence and proper execution on 2 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_compare_exchange_n builtin for a short.  */\n+\n+extern void abort(void);\n+\n+short v = 0;\n+short expected = 0;\n+short max = ~0;\n+short desired = ~0;\n+short zero = 0;\n+\n+#define STRONG 0\n+#define WEAK 1\n+\n+main ()\n+{\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, max, STRONG , __ATOMIC_RELAXED, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  v = 0;\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &max, STRONG, __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "26097288c9d3ebc766946f0bbe2f03ee49c3e2be", "filename": "gcc/testsuite/gcc.dg/atomic-compare-exchange-3.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-3.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,85 @@\n+/* Test __atomic routines for existence and proper execution on 4 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+/* Test the execution of the __atomic_compare_exchange_n builtin for an int.  */\n+\n+extern void abort(void);\n+\n+int v = 0;\n+int expected = 0;\n+int max = ~0;\n+int desired = ~0;\n+int zero = 0;\n+\n+#define STRONG 0\n+#define WEAK 1\n+\n+main ()\n+{\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, max, STRONG , __ATOMIC_RELAXED, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  v = 0;\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &max, STRONG, __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "d89e72f81713d087f7d494c5b38ede20bfbfd653", "filename": "gcc/testsuite/gcc.dg/atomic-compare-exchange-4.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-4.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,86 @@\n+/* Test __atomic routines for existence and proper execution on 8 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_long_long } */\n+/* { dg-options \"\" } */\n+\n+/* Test the execution of __atomic_compare_exchange_n builtin for a long_long.  */\n+\n+extern void abort(void);\n+\n+long long v = 0;\n+long long expected = 0;\n+long long max = ~0;\n+long long desired = ~0;\n+long long zero = 0;\n+\n+#define STRONG 0\n+#define WEAK 1\n+\n+main ()\n+{\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, max, STRONG , __ATOMIC_RELAXED, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  v = 0;\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &max, STRONG, __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "e716dcb350c2f6d935f6cb522a45a642472a5a7c", "filename": "gcc/testsuite/gcc.dg/atomic-compare-exchange-5.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-compare-exchange-5.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,86 @@\n+/* Test __atomic routines for existence and proper execution on 16 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_128 } */\n+/* { dg-options \"-mcx16\" { target { x86_64-*-* } } } */\n+\n+/* Test the execution of __atomic_compare_exchange_n builtin for an int_128.  */\n+\n+extern void abort(void);\n+\n+__int128_t v = 0;\n+__int128_t expected = 0;\n+__int128_t max = ~0;\n+__int128_t desired = ~0;\n+__int128_t zero = 0;\n+\n+#define STRONG 0\n+#define WEAK 1\n+\n+main ()\n+{\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, max, STRONG , __ATOMIC_RELAXED, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  v = 0;\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &max, STRONG, __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "fb78cdbca544f36f210090eb3d97fcc6ee8f8573", "filename": "gcc/testsuite/gcc.dg/atomic-exchange-1.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-1.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,62 @@\n+/* Test __atomic routines for existence and proper execution on 1 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_exchange_n builtin for a char.  */\n+\n+extern void abort(void);\n+\n+char v, count, ret;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELAXED) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQUIRE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELEASE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQ_REL) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_SEQ_CST) !=  count++) \n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELAXED);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQUIRE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELEASE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQ_REL);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_SEQ_CST);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  return 0;\n+}"}, {"sha": "153771a2cdc6c97525b0e64041c6d68e907c1025", "filename": "gcc/testsuite/gcc.dg/atomic-exchange-2.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-2.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,62 @@\n+/* Test __atomic routines for existence and proper execution on 2 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_X builtin for a short.  */\n+\n+extern void abort(void);\n+\n+short v, count, ret;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELAXED) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQUIRE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELEASE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQ_REL) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_SEQ_CST) !=  count++) \n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELAXED);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQUIRE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELEASE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQ_REL);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_SEQ_CST);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  return 0;\n+}"}, {"sha": "fbf8f6b966c08412199c919715466f7c96ec7a96", "filename": "gcc/testsuite/gcc.dg/atomic-exchange-3.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-3.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,62 @@\n+/* Test __atomic routines for existence and proper execution on 4 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+/* Test the execution of the __atomic_X builtin for an int.  */\n+\n+extern void abort(void);\n+\n+int v, count, ret;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELAXED) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQUIRE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELEASE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQ_REL) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_SEQ_CST) !=  count++) \n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELAXED);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQUIRE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELEASE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQ_REL);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_SEQ_CST);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  return 0;\n+}"}, {"sha": "f0530fc462ce09a59f598acdd9ca378e4bf61bb4", "filename": "gcc/testsuite/gcc.dg/atomic-exchange-4.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-4.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,63 @@\n+/* Test __atomic routines for existence and proper execution on 8 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_long_long } */\n+/* { dg-options \"\" } */\n+\n+/* Test the execution of the __atomic_X builtin for a long_long.  */\n+\n+extern void abort(void);\n+\n+long long v, count, ret;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELAXED) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQUIRE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELEASE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQ_REL) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_SEQ_CST) !=  count++) \n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELAXED);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQUIRE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELEASE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQ_REL);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_SEQ_CST);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  return 0;\n+}"}, {"sha": "13fd6d1b8ec8b634cef460cb4037eb18f5fad333", "filename": "gcc/testsuite/gcc.dg/atomic-exchange-5.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-exchange-5.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,63 @@\n+/* Test __atomic routines for existence and proper execution on 16 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_128 } */\n+/* { dg-options \"-mcx16\" { target { x86_64-*-* } } } */\n+\n+/* Test the execution of the __atomic_X builtin for a 16 byte value.  */\n+\n+extern void abort(void);\n+\n+__int128_t v, count, ret;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELAXED) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQUIRE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELEASE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQ_REL) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_SEQ_CST) !=  count++) \n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELAXED);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQUIRE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELEASE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQ_REL);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_SEQ_CST);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  return 0;\n+}"}, {"sha": "1f6d1871a0b63d5156da5049d7f555b68668f866", "filename": "gcc/testsuite/gcc.dg/atomic-fence.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-fence.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-fence.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-fence.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,27 @@\n+/* Test __atomic routines for existence and execution with each valid \n+   memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+\n+/* Test that __atomic_{thread,signal}_fence builtins execute.  */\n+\n+main ()\n+{\n+  __atomic_thread_fence (__ATOMIC_RELAXED);\n+  __atomic_thread_fence (__ATOMIC_CONSUME);\n+  __atomic_thread_fence (__ATOMIC_ACQUIRE);\n+  __atomic_thread_fence (__ATOMIC_RELEASE);\n+  __atomic_thread_fence (__ATOMIC_ACQ_REL);\n+  __atomic_thread_fence (__ATOMIC_SEQ_CST);\n+\n+  __atomic_signal_fence (__ATOMIC_RELAXED);\n+  __atomic_signal_fence (__ATOMIC_CONSUME);\n+  __atomic_signal_fence (__ATOMIC_ACQUIRE);\n+  __atomic_signal_fence (__ATOMIC_RELEASE);\n+  __atomic_signal_fence (__ATOMIC_ACQ_REL);\n+  __atomic_signal_fence (__ATOMIC_SEQ_CST);\n+\n+  return 0;\n+}\n+"}, {"sha": "a6b552a5dfdd087dcae5f06a7a1bbd3e3a1fe8e7", "filename": "gcc/testsuite/gcc.dg/atomic-generic-aux.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-generic-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-generic-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-generic-aux.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,45 @@\n+/* Supply a set of generic atomic functions to test the compiler make the\n+   calls properly.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-w\" } */\n+\n+/* Test that the generic builtins make calls as expected.  */\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <string.h>\n+\n+void\n+__atomic_exchange (size_t size, void *obj, void *val, void *ret, int model)\n+{\n+  /* Copy old value into *ret.  */\n+  memcpy (ret, obj, size);\n+  /* Copy val into object.  */\n+  memcpy (obj, val, size);\n+}\n+\n+\n+bool\n+__atomic_compare_exchange (size_t size, void *obj, void *expected, \n+\t\t\t   void *desired, int model1, int model2)\n+{\n+  if (!memcmp (obj, expected, size))\n+    {\n+      memcpy (obj, desired, size);\n+      return true;\n+    }\n+  memcpy (expected, obj, size);\n+  return false;\n+}\n+\n+\n+void __atomic_load (size_t size, void *obj, void *ret, int model)\n+{\n+  memcpy (ret, obj, size);\n+}\n+\n+\n+void __atomic_store (size_t size, void *obj, void *val, int model)\n+{\n+  memcpy (obj, val, size);\n+}"}, {"sha": "8a5528c36539b205f622132b08d2b787fe5ec76d", "filename": "gcc/testsuite/gcc.dg/atomic-generic.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-generic.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,56 @@\n+/* Test generic __atomic routines for proper function calling.\n+   memory model.  */\n+/* { dg-options \"-w\" } */\n+/* { dg-do run } */\n+/* { dg-additional-sources \"atomic-generic-aux.c\" } */\n+\n+/* Test that the generioc atomic builtins execute as expected..\n+   sync-mem-generic-aux.c supplies a functional external entry point for \n+   the 4 generic functions.  */\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+extern void abort();\n+\n+typedef struct test {\n+  int array[10];\n+} test_struct;\n+\n+test_struct zero = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+test_struct ones = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };\n+test_struct a,b;\n+\n+int size = sizeof (test_struct);\n+/* Test for consistency on sizes 1, 2, 4, 8, 16 and 32.  */\n+main ()\n+{\n+  test_struct c;\n+\n+  __atomic_store (&a, &zero, __ATOMIC_RELAXED);\n+  if (memcmp (&a, &zero, size))\n+    abort ();\n+\n+  __atomic_exchange (&a, &ones, &c, __ATOMIC_SEQ_CST);\n+  if (memcmp (&c, &zero, size))\n+    abort ();\n+  if (memcmp (&a, &ones, size))\n+    abort ();\n+\n+  __atomic_load (&a, &b, __ATOMIC_RELAXED);\n+  if (memcmp (&b, &ones, size))\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&a, &b, &zero, false, __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    abort();\n+  if (memcmp (&a, &zero, size))\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&a, &b, &ones, false, __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    abort();\n+  if (memcmp (&b, &zero, size))\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "2b73c91e7c09627cd5eb57c9a66bde6533055226", "filename": "gcc/testsuite/gcc.dg/atomic-invalid.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-invalid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-invalid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-invalid.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,29 @@\n+/* Test __atomic routines for invalid memory model errors. This only needs\n+   to be tested on a single size.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+#include <stddef.h>\n+\n+int i, e, b;\n+size_t s;\n+\n+main ()\n+{\n+  __atomic_compare_exchange_n (&i, &e, 1, 0, __ATOMIC_RELAXED, __ATOMIC_SEQ_CST); /* { dg-error \"failure memory model cannot be stronger\" } */\n+  __atomic_compare_exchange_n (&i, &e, 1, 0, __ATOMIC_SEQ_CST, __ATOMIC_RELEASE); /* { dg-error \"invalid failure memory\" } */\n+  __atomic_compare_exchange_n (&i, &e, 1, 1, __ATOMIC_SEQ_CST, __ATOMIC_ACQ_REL); /* { dg-error \"invalid failure memory\" } */\n+\n+  __atomic_exchange_n (&i, 1, __ATOMIC_CONSUME); /* { dg-error \"invalid memory model\" } */\n+\n+  __atomic_load_n (&i, __ATOMIC_RELEASE); /* { dg-error \"invalid memory model\" } */\n+  __atomic_load_n (&i, __ATOMIC_ACQ_REL); /* { dg-error \"invalid memory model\" } */\n+\n+  __atomic_store_n (&i, 1, __ATOMIC_ACQUIRE); /* { dg-error \"invalid memory model\" } */\n+  __atomic_store_n (&i, 1, __ATOMIC_CONSUME); /* { dg-error \"invalid memory model\" } */\n+  __atomic_store_n (&i, 1, __ATOMIC_ACQ_REL); /* { dg-error \"invalid memory model\" } */\n+\n+  i = __atomic_always_lock_free (s, NULL); /* { dg-error \"non-constant argument\" } */\n+\n+  __atomic_load_n (&i, 44); /* { dg-warning \"invalid memory model\" } */\n+}"}, {"sha": "928f9b0f10b3c8504672b456bb2247d4ea762d5e", "filename": "gcc/testsuite/gcc.dg/atomic-load-1.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-1.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,66 @@\n+/* Test __atomic routines for existence and proper execution on 1 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+\n+/* Test the execution of the __atomic_load_n builtin for a char.  */\n+\n+extern void abort(void);\n+\n+char v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_RELAXED) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_ACQUIRE) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_CONSUME) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_SEQ_CST) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  /* Now test the generic variants.  */\n+\n+  __atomic_load (&v, &count, __ATOMIC_RELAXED);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_ACQUIRE);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_CONSUME);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_SEQ_CST);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  return 0;\n+}\n+"}, {"sha": "3d1df1cfffa96c90b67c408dcff667a7f86a100e", "filename": "gcc/testsuite/gcc.dg/atomic-load-2.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-2.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,68 @@\n+/* Test __atomic routines for existence and proper execution on 2 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+\n+/* Test the execution of the __atomic_load_n builtin for a short.  */\n+\n+extern void abort(void);\n+\n+short v, count;\n+\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_RELAXED) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_ACQUIRE) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_CONSUME) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_SEQ_CST) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  /* Now test the generic variants.  */\n+\n+  __atomic_load (&v, &count, __ATOMIC_RELAXED);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_ACQUIRE);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_CONSUME);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_SEQ_CST);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "ec238be9e517b4666bb4adf70fa79c6d0db3cb9f", "filename": "gcc/testsuite/gcc.dg/atomic-load-3.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-3.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,65 @@\n+/* Test __atomic routines for existence and proper execution on 4 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+extern void abort(void);\n+\n+int v, count;\n+\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_RELAXED) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_ACQUIRE) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_CONSUME) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_SEQ_CST) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  /* Now test the generic variants.  */\n+\n+  __atomic_load (&v, &count, __ATOMIC_RELAXED);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_ACQUIRE);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_CONSUME);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_SEQ_CST);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "5cb7659da70b023abf03a9e3501fc91c2c4c3bff", "filename": "gcc/testsuite/gcc.dg/atomic-load-4.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-4.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,65 @@\n+/* Test __atomic routines for existence and proper execution on 8 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_long_long } */\n+/* { dg-options \"\" } */\n+\n+extern void abort(void);\n+\n+long long v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_RELAXED) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_ACQUIRE) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_CONSUME) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_SEQ_CST) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  /* Now test the generic variants.  */\n+\n+  __atomic_load (&v, &count, __ATOMIC_RELAXED);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_ACQUIRE);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_CONSUME);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_SEQ_CST);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "2991e4d6c7a507ef6bfd6e81b3908f8a828e0612", "filename": "gcc/testsuite/gcc.dg/atomic-load-5.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-load-5.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,65 @@\n+/* Test __atomic routines for existence and proper execution on 16 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_128 } */\n+/* { dg-options \"-mcx16\" { target { x86_64-*-* } } } */\n+\n+extern void abort(void);\n+\n+__int128_t v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_RELAXED) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_ACQUIRE) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_CONSUME) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_SEQ_CST) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  /* Now test the generic variants.  */\n+\n+  __atomic_load (&v, &count, __ATOMIC_RELAXED);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_ACQUIRE);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_CONSUME);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_SEQ_CST);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "0ea872c302bc3008fb37af9cbe45e6e467b1dbd2", "filename": "gcc/testsuite/gcc.dg/atomic-lockfree-aux.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-lockfree-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-lockfree-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-lockfree-aux.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,17 @@\n+/* Test supply a __atomic_is_lock_free routine for lock-free tests.  */\n+/* Just compile it on its own.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-w\" } */\n+\n+/* Test that __atomic_{is,always}_lock_free builtins execute.  */\n+\n+#include <stdlib.h>\n+\n+/* Supply a builtin external function which returns a non-standard value so\n+   it can be detected that it was called.  */\n+int \n+__atomic_is_lock_free (size_t s, void *p)\n+{\n+  return 2;\n+}\n+"}, {"sha": "225428223eaa9e9c35cc8d5debbc5ede5b98c8f4", "filename": "gcc/testsuite/gcc.dg/atomic-lockfree.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-lockfree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-lockfree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-lockfree.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,120 @@\n+/* Test __atomic routines for existence and execution with each valid \n+   memory model.  */\n+/* { dg-options \"-w\" } */\n+/* { dg-do run } */\n+/* { dg-additional-sources \"atomic-lockfree-aux.c\" } */\n+\n+/* Test that __atomic_{is,always}_lock_free builtins execute.\n+   sync-mem-lockfree-aux.c supplies and external entry point for \n+   __atomic_is_lock_free which always returns a 2. We can detect the \n+   external routine was called if 2 is returned since that is not a valid\n+   result normally.  */\n+\n+#include <stdlib.h>\n+\n+extern void abort();\n+\n+int r1, r2;\n+\n+/* Test for consistency on sizes 1, 2, 4, 8, 16 and 32.  */\n+main ()\n+{\n+  \n+  r1 = __atomic_always_lock_free (sizeof(char), 0);\n+  r2 = __atomic_is_lock_free (sizeof(char), 0);\n+  /* If always lock free, then is_lock_free must also be true.  */\n+  if (r1)\n+    { \n+      if (r2 != 1)  \n+\tabort ();\n+    }\n+  else\n+    {\n+      /* If it is not lock free, then the external routine must be called.  */\n+      if (r2 != 2) \n+\tabort ();\n+    }\n+  \n+  r1 = __atomic_always_lock_free (2, 0);\n+  r2 = __atomic_is_lock_free (2, 0);\n+  /* If always lock free, then is_lock_free must also be true.  */\n+  if (r1)\n+    { \n+      if (r2 != 1)  \n+\tabort ();\n+    }\n+  else\n+    {\n+      /* If it is not lock free, then the external routine must be called.  */\n+      if (r2 != 2) \n+\tabort ();\n+    }\n+\n+   \n+  r1 = __atomic_always_lock_free (4, 0);\n+  r2 = __atomic_is_lock_free (4, 0);     /* Try passing in a variable.  */\n+  /* If always lock free, then is_lock_free must also be true.  */\n+  if (r1)\n+    { \n+      if (r2 != 1)  \n+\tabort ();\n+    }\n+  else\n+    {\n+      /* If it is not lock free, then the external routine must be called.  */\n+      if (r2 != 2) \n+\tabort ();\n+    }\n+\n+   \n+  r1 = __atomic_always_lock_free (8, 0);\n+  r2 = __atomic_is_lock_free (8, 0);\n+  /* If always lock free, then is_lock_free must also be true.  */\n+  if (r1)\n+    { \n+      if (r2 != 1)  \n+\tabort ();\n+    }\n+  else\n+    {\n+      /* If it is not lock free, then the external routine must be called.  */\n+      if (r2 != 2) \n+\tabort ();\n+    }\n+\n+   \n+  r1 = __atomic_always_lock_free (16, 0);\n+  r2 = __atomic_is_lock_free (16, 0);\n+  /* If always lock free, then is_lock_free must also be true.  */\n+  if (r1)\n+    { \n+      if (r2 != 1)  \n+\tabort ();\n+    }\n+  else\n+    {\n+      /* If it is not lock free, then the external routine must be called.  */\n+      if (r2 != 2) \n+\tabort ();\n+    }\n+\n+   \n+  r1 = __atomic_always_lock_free (32, 0);\n+  r2 = __atomic_is_lock_free (32, 0);\n+  /* If always lock free, then is_lock_free must also be true.  */\n+  if (r1)\n+    { \n+      if (r2 != 1)  \n+\tabort ();\n+    }\n+  else\n+    {\n+      /* If it is not lock free, then the external routine must be called.  */\n+      if (r2 != 2) \n+\tabort ();\n+    }\n+\n+ \n+  return 0;\n+}\n+"}, {"sha": "b92fcfcd60fc16ac86c1505032bada3b99b56315", "filename": "gcc/testsuite/gcc.dg/atomic-noinline-aux.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-noinline-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-noinline-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-noinline-aux.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,51 @@\n+/* Supply a set of generic atomic functions to test the compiler make the\n+   calls properly.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-w\" } */\n+\n+/* Test that the generic builtins make calls as expected.  This file provides\n+   the exact entry points the test file will require.  All these routines\n+   simply set the first parameter to 1, and the caller will test for that.  */\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <string.h>\n+\n+\n+char \n+__atomic_exchange_1 (char *p, char t, int i)\n+{\n+  *p = 1;\n+}\n+\n+short\n+__atomic_load_2 (short *p, int i)\n+{ \n+  *p = 1;\n+}\n+\n+void\n+__atomic_store_1 (char *p, char v, int i)\n+{\n+  *p = 1;\n+}\n+\n+int __atomic_compare_exchange_2 (short *p, short *a, short b, int x, int y, int z)\n+{\n+  *p = 1;\n+}\n+\n+char __atomic_fetch_add_1 (char *p, char v, int i)\n+{\n+  *p = 1;\n+}\n+\n+short __atomic_fetch_add_2 (short *p, short v, short i)\n+{\n+  *p = 1;\n+}\n+\n+int __atomic_is_lock_free (int i, void *p)\n+{\n+  return 10;\n+}"}, {"sha": "06a93e0058ee9eabbd54c64b663d6c873ea00182", "filename": "gcc/testsuite/gcc.dg/atomic-noinline.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-noinline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-noinline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-noinline.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,56 @@\n+/* Test generic __atomic routines for proper function calling.\n+   memory model.  */\n+/* { dg-options \"-w -fno-inline-atomics\" } */\n+/* { dg-do run } */\n+/* { dg-additional-sources \"atomic-noinline-aux.c\" } */\n+\n+/* Test that -fno-inline-atomics works as expected.  \n+   atomic-generic-aux provide the expected routines which simply set the\n+   value of the first parameter to */\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+extern void abort();\n+\n+short as,bs,cs;\n+char ac,bc,cc;\n+\n+main ()\n+{\n+\n+  ac = __atomic_exchange_n (&bc, cc, __ATOMIC_RELAXED);\n+  if (bc != 1)\n+    abort ();\n+\n+  as = __atomic_load_n (&bs, __ATOMIC_SEQ_CST);\n+  if (bs != 1)\n+    abort ();\n+\n+  __atomic_store_n (&ac, bc, __ATOMIC_RELAXED);\n+  if (ac != 1)\n+    abort ();\n+\n+  __atomic_compare_exchange_n (&as, &bs, cs, 0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);\n+  if (as != 1)\n+    abort ();\n+\n+  ac = __atomic_fetch_add (&cc, 15, __ATOMIC_SEQ_CST);\n+  if (cc != 1)\n+    abort ();\n+\n+  /* This should be translated to __atomic_fetch_add for the library */\n+  as = __atomic_add_fetch (&cs, 10, __ATOMIC_RELAXED);\n+\n+  if (cs != 1)\n+    abort ();\n+\n+  /* The fake external function should return 10.  */\n+  if (__atomic_is_lock_free (4, 0) != 10)\n+    abort ();\n+   \n+  return 0;\n+}\n+\n+\n+"}, {"sha": "bc1716f7799916a0f9162d052f326bdc2507e854", "filename": "gcc/testsuite/gcc.dg/atomic-op-1.c", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-1.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,554 @@\n+/* Test __atomic routines for existence and proper execution on 1 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_*OP builtin routines for a char.  */\n+\n+extern void abort(void);\n+\n+char v, count, res;\n+const char init = ~0;\n+\n+/* The fetch_op routines return the original value before the operation.  */\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_RELAXED) != 0)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_CONSUME) != 1) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQUIRE) != 2)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_RELEASE) != 3) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQ_REL) != 4) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_SEQ_CST) != 5) \n+    abort ();\n+}\n+\n+\n+void\n+test_fetch_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_RELAXED) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_CONSUME) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQUIRE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQ_REL) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_SEQ_CST) !=  res--) \n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQUIRE) !=  0)\n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_fetch_nand ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_ACQUIRE) !=  0 ) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_fetch_xor (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 2, __ATOMIC_CONSUME) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQUIRE) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 8, __ATOMIC_RELEASE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQ_REL) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST) !=  31) \n+    abort ();\n+}\n+\n+/* The OP_fetch routines return the new value after the operation.  */\n+\n+void\n+test_add_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_RELAXED) != 1)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_CONSUME) != 2) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQUIRE) != 3)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_RELEASE) != 4) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL) != 5) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_SEQ_CST) != 6) \n+    abort ();\n+}\n+\n+\n+void\n+test_sub_fetch ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED) !=  --res) \n+    abort ();\n+\n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_CONSUME) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQUIRE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_RELEASE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_SEQ_CST) !=  --res) \n+    abort ();\n+}\n+\n+void\n+test_and_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  v = init;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_nand_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_RELEASE) !=  0)\n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor_fetch ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_xor_fetch (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_RELEASE) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_or_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_RELAXED) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 2, __ATOMIC_CONSUME) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQUIRE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 8, __ATOMIC_RELEASE) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL) !=  31) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_SEQ_CST) !=  63) \n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used. Use both variations\n+   within each function.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_CONSUME);\n+  if (v != 2)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, 1 , __ATOMIC_ACQUIRE);\n+  if (v != 3)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, 1, __ATOMIC_RELEASE);\n+  if (v != 4)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 5)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+\n+void\n+test_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != --res)\n+    abort ();\n+\n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_CONSUME);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, 1, __ATOMIC_ACQUIRE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_RELAXED);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  __atomic_fetch_and (&v, init, __ATOMIC_CONSUME);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, init, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_nand ()\n+{\n+  v = init;\n+\n+  __atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, init, __ATOMIC_RELEASE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != init)\n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  __atomic_xor_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_or_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_CONSUME);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, 4, __ATOMIC_ACQUIRE);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, 8, __ATOMIC_RELEASE);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_nand ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add_fetch ();\n+  test_sub_fetch ();\n+  test_and_fetch ();\n+  test_nand_fetch ();\n+  test_xor_fetch ();\n+  test_or_fetch ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_nand ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "8755340cca2218cb27b51ecb601e31b04837d057", "filename": "gcc/testsuite/gcc.dg/atomic-op-2.c", "status": "added", "additions": 555, "deletions": 0, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-2.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,555 @@\n+/* Test __atomic routines for existence and proper execution on 2 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+\n+/* Test the execution of the __atomic_*OP builtin routines for a short.  */\n+\n+extern void abort(void);\n+\n+short v, count, res;\n+const short init = ~0;\n+\n+/* The fetch_op routines return the original value before the operation.  */\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_RELAXED) != 0)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_CONSUME) != 1) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQUIRE) != 2)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_RELEASE) != 3) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQ_REL) != 4) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_SEQ_CST) != 5) \n+    abort ();\n+}\n+\n+\n+void\n+test_fetch_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_RELAXED) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_CONSUME) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQUIRE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQ_REL) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_SEQ_CST) !=  res--) \n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQUIRE) !=  0)\n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_fetch_nand ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_ACQUIRE) !=  0 ) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_fetch_xor (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 2, __ATOMIC_CONSUME) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQUIRE) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 8, __ATOMIC_RELEASE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQ_REL) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST) !=  31) \n+    abort ();\n+}\n+\n+/* The OP_fetch routines return the new value after the operation.  */\n+\n+void\n+test_add_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_RELAXED) != 1)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_CONSUME) != 2) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQUIRE) != 3)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_RELEASE) != 4) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL) != 5) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_SEQ_CST) != 6) \n+    abort ();\n+}\n+\n+\n+void\n+test_sub_fetch ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED) !=  --res) \n+    abort ();\n+\n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_CONSUME) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQUIRE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_RELEASE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_SEQ_CST) !=  --res) \n+    abort ();\n+}\n+\n+void\n+test_and_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  v = init;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_nand_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_RELEASE) !=  0)\n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor_fetch ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_xor_fetch (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_RELEASE) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_or_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_RELAXED) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 2, __ATOMIC_CONSUME) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQUIRE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 8, __ATOMIC_RELEASE) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL) !=  31) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_SEQ_CST) !=  63) \n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used. Use both variations\n+   within each function.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_CONSUME);\n+  if (v != 2)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, 1 , __ATOMIC_ACQUIRE);\n+  if (v != 3)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, 1, __ATOMIC_RELEASE);\n+  if (v != 4)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 5)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+\n+void\n+test_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != --res)\n+    abort ();\n+\n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_CONSUME);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, 1, __ATOMIC_ACQUIRE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_RELAXED);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  __atomic_fetch_and (&v, init, __ATOMIC_CONSUME);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, init, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_nand ()\n+{\n+  v = init;\n+\n+  __atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, init, __ATOMIC_RELEASE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != init)\n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  __atomic_xor_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_or_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_CONSUME);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, 4, __ATOMIC_ACQUIRE);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, 8, __ATOMIC_RELEASE);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_nand ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add_fetch ();\n+  test_sub_fetch ();\n+  test_and_fetch ();\n+  test_nand_fetch ();\n+  test_xor_fetch ();\n+  test_or_fetch ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_nand ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "69db4894b638a4096595e794d7da7435b4fb01b9", "filename": "gcc/testsuite/gcc.dg/atomic-op-3.c", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-3.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,554 @@\n+/* Test __atomic routines for existence and proper execution on 4 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+/* Test the execution of the __atomic_*OP builtin routines for an int.  */\n+\n+extern void abort(void);\n+\n+int v, count, res;\n+const int init = ~0;\n+\n+/* The fetch_op routines return the original value before the operation.  */\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_RELAXED) != 0)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_CONSUME) != 1) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQUIRE) != 2)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_RELEASE) != 3) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQ_REL) != 4) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_SEQ_CST) != 5) \n+    abort ();\n+}\n+\n+\n+void\n+test_fetch_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_RELAXED) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_CONSUME) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQUIRE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQ_REL) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_SEQ_CST) !=  res--) \n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQUIRE) !=  0)\n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_fetch_nand ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_ACQUIRE) !=  0 ) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_fetch_xor (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 2, __ATOMIC_CONSUME) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQUIRE) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 8, __ATOMIC_RELEASE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQ_REL) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST) !=  31) \n+    abort ();\n+}\n+\n+/* The OP_fetch routines return the new value after the operation.  */\n+\n+void\n+test_add_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_RELAXED) != 1)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_CONSUME) != 2) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQUIRE) != 3)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_RELEASE) != 4) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL) != 5) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_SEQ_CST) != 6) \n+    abort ();\n+}\n+\n+\n+void\n+test_sub_fetch ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED) !=  --res) \n+    abort ();\n+\n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_CONSUME) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQUIRE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_RELEASE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_SEQ_CST) !=  --res) \n+    abort ();\n+}\n+\n+void\n+test_and_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  v = init;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_nand_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_RELEASE) !=  0)\n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor_fetch ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_xor_fetch (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_RELEASE) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_or_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_RELAXED) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 2, __ATOMIC_CONSUME) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQUIRE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 8, __ATOMIC_RELEASE) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL) !=  31) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_SEQ_CST) !=  63) \n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used. Use both variations\n+   within each function.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_CONSUME);\n+  if (v != 2)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, 1 , __ATOMIC_ACQUIRE);\n+  if (v != 3)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, 1, __ATOMIC_RELEASE);\n+  if (v != 4)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 5)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+\n+void\n+test_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != --res)\n+    abort ();\n+\n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_CONSUME);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, 1, __ATOMIC_ACQUIRE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_RELAXED);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  __atomic_fetch_and (&v, init, __ATOMIC_CONSUME);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, init, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_nand ()\n+{\n+  v = init;\n+\n+  __atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, init, __ATOMIC_RELEASE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != init)\n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  __atomic_xor_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_or_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_CONSUME);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, 4, __ATOMIC_ACQUIRE);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, 8, __ATOMIC_RELEASE);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_nand ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add_fetch ();\n+  test_sub_fetch ();\n+  test_and_fetch ();\n+  test_nand_fetch ();\n+  test_xor_fetch ();\n+  test_or_fetch ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_nand ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "39650213edf018aa53d05589901bfdfb00265691", "filename": "gcc/testsuite/gcc.dg/atomic-op-4.c", "status": "added", "additions": 555, "deletions": 0, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-4.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,555 @@\n+/* Test __atomic routines for existence and proper execution on 8 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_long_long } */\n+/* { dg-options \"\" } */\n+\n+/* Test the execution of the __atomic_*OP builtin routines for long long.  */\n+\n+extern void abort(void);\n+\n+long long v, count, res;\n+const long long init = ~0;\n+\n+/* The fetch_op routines return the original value before the operation.  */\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_RELAXED) != 0)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_CONSUME) != 1) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQUIRE) != 2)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_RELEASE) != 3) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQ_REL) != 4) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_SEQ_CST) != 5) \n+    abort ();\n+}\n+\n+\n+void\n+test_fetch_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_RELAXED) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_CONSUME) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQUIRE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQ_REL) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_SEQ_CST) !=  res--) \n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQUIRE) !=  0)\n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_fetch_nand ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_ACQUIRE) !=  0 ) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_fetch_xor (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 2, __ATOMIC_CONSUME) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQUIRE) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 8, __ATOMIC_RELEASE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQ_REL) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST) !=  31) \n+    abort ();\n+}\n+\n+/* The OP_fetch routines return the new value after the operation.  */\n+\n+void\n+test_add_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_RELAXED) != 1)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_CONSUME) != 2) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQUIRE) != 3)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_RELEASE) != 4) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL) != 5) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_SEQ_CST) != 6) \n+    abort ();\n+}\n+\n+\n+void\n+test_sub_fetch ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED) !=  --res) \n+    abort ();\n+\n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_CONSUME) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQUIRE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_RELEASE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_SEQ_CST) !=  --res) \n+    abort ();\n+}\n+\n+void\n+test_and_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  v = init;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_nand_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_RELEASE) !=  0)\n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor_fetch ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_xor_fetch (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_RELEASE) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_or_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_RELAXED) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 2, __ATOMIC_CONSUME) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQUIRE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 8, __ATOMIC_RELEASE) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL) !=  31) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_SEQ_CST) !=  63) \n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used. Use both variations\n+   within each function.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_CONSUME);\n+  if (v != 2)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, 1 , __ATOMIC_ACQUIRE);\n+  if (v != 3)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, 1, __ATOMIC_RELEASE);\n+  if (v != 4)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 5)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+\n+void\n+test_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != --res)\n+    abort ();\n+\n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_CONSUME);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, 1, __ATOMIC_ACQUIRE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_RELAXED);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  __atomic_fetch_and (&v, init, __ATOMIC_CONSUME);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, init, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_nand ()\n+{\n+  v = init;\n+\n+  __atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, init, __ATOMIC_RELEASE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != init)\n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  __atomic_xor_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_or_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_CONSUME);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, 4, __ATOMIC_ACQUIRE);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, 8, __ATOMIC_RELEASE);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_nand ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add_fetch ();\n+  test_sub_fetch ();\n+  test_and_fetch ();\n+  test_nand_fetch ();\n+  test_xor_fetch ();\n+  test_or_fetch ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_nand ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "2ca71adc8f1a9df3f466cd599f0f8854e5db2fa3", "filename": "gcc/testsuite/gcc.dg/atomic-op-5.c", "status": "added", "additions": 555, "deletions": 0, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-5.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,555 @@\n+/* Test __atomic routines for existence and proper execution on 16 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_128 } */\n+/* { dg-options \"-mcx16\" { target { x86_64-*-* } } } */\n+\n+/* Test the execution of the __atomic_*OP builtin routines for an int_128.  */\n+\n+extern void abort(void);\n+\n+__int128_t v, count, res;\n+const __int128_t init = ~0;\n+\n+/* The fetch_op routines return the original value before the operation.  */\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_RELAXED) != 0)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_CONSUME) != 1) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQUIRE) != 2)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_RELEASE) != 3) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQ_REL) != 4) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_SEQ_CST) != 5) \n+    abort ();\n+}\n+\n+\n+void\n+test_fetch_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_RELAXED) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_CONSUME) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQUIRE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQ_REL) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_SEQ_CST) !=  res--) \n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQUIRE) !=  0)\n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_fetch_nand ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_ACQUIRE) !=  0 ) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_fetch_xor (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 2, __ATOMIC_CONSUME) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQUIRE) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 8, __ATOMIC_RELEASE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQ_REL) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST) !=  31) \n+    abort ();\n+}\n+\n+/* The OP_fetch routines return the new value after the operation.  */\n+\n+void\n+test_add_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_RELAXED) != 1)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_CONSUME) != 2) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQUIRE) != 3)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_RELEASE) != 4) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL) != 5) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_SEQ_CST) != 6) \n+    abort ();\n+}\n+\n+\n+void\n+test_sub_fetch ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED) !=  --res) \n+    abort ();\n+\n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_CONSUME) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQUIRE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_RELEASE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_SEQ_CST) !=  --res) \n+    abort ();\n+}\n+\n+void\n+test_and_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  v = init;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_nand_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_RELEASE) !=  0)\n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor_fetch ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_xor_fetch (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_RELEASE) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_or_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_RELAXED) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 2, __ATOMIC_CONSUME) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQUIRE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 8, __ATOMIC_RELEASE) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL) !=  31) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_SEQ_CST) !=  63) \n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used. Use both variations\n+   within each function.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_CONSUME);\n+  if (v != 2)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, 1 , __ATOMIC_ACQUIRE);\n+  if (v != 3)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, 1, __ATOMIC_RELEASE);\n+  if (v != 4)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 5)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+\n+void\n+test_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != --res)\n+    abort ();\n+\n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_CONSUME);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, 1, __ATOMIC_ACQUIRE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_RELAXED);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  __atomic_fetch_and (&v, init, __ATOMIC_CONSUME);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, init, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_nand ()\n+{\n+  v = init;\n+\n+  __atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, init, __ATOMIC_RELEASE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != init)\n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  __atomic_xor_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_or_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_CONSUME);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, 4, __ATOMIC_ACQUIRE);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, 8, __ATOMIC_RELEASE);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_nand ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add_fetch ();\n+  test_sub_fetch ();\n+  test_and_fetch ();\n+  test_nand_fetch ();\n+  test_xor_fetch ();\n+  test_or_fetch ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_nand ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "a1bfc6be87ced9ce75604d4e347d2c476b198983", "filename": "gcc/testsuite/gcc.dg/atomic-param.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-param.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-param.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-param.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,13 @@\n+/* Test __atomic routines for invalid memory model errors. This only needs\n+   to be tested on a single size.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+int i;\n+\n+main ()\n+{\n+\n+  __atomic_exchange_n (&i, 1); /* { dg-error \"too few arguments\" } */\n+  __atomic_exchange_n (&i, 1, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); /* { dg-error \"too many arguments\" } */\n+}"}, {"sha": "f99eb9c844f6a79eb026fe02d26921d21251ca0e", "filename": "gcc/testsuite/gcc.dg/atomic-store-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-1.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,47 @@\n+/* Test __atomic routines for existence and proper execution on 1 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_store_n builtin for a char.  */\n+\n+extern void abort(void);\n+\n+char v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELEASE);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != ++count)\n+    abort ();\n+\n+  /* Now test the generic variant.  */\n+  count++;\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELAXED);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELEASE);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_SEQ_CST);\n+  if (v != count)\n+    abort ();\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "da346fd7de43e97844ca0bf58bc7eb9ba9229f30", "filename": "gcc/testsuite/gcc.dg/atomic-store-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-2.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,46 @@\n+/* Test __atomic routines for existence and proper execution on 2 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_store_n builtin for a short.  */\n+\n+extern void abort(void);\n+\n+short v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELEASE);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != ++count)\n+    abort ();\n+\n+  /* Now test the generic variant.  */\n+  count++;\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELAXED);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELEASE);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_SEQ_CST);\n+  if (v != count)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "b691da4592fbeab665c454a8ff3eebc0508f3a22", "filename": "gcc/testsuite/gcc.dg/atomic-store-3.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-3.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,47 @@\n+/* Test __atomic routines for existence and proper execution on 4 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+/* Test the execution of the __atomic_store_n builtin for an int.  */\n+\n+extern void abort(void);\n+\n+int v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELEASE);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != ++count)\n+    abort ();\n+\n+  /* Now test the generic variant.  */\n+  count++;\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELAXED);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELEASE);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_SEQ_CST);\n+  if (v != count)\n+    abort ();\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "f77e1831ad8f27440fb1ee52a35ff5b9f27d8f8c", "filename": "gcc/testsuite/gcc.dg/atomic-store-4.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-4.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,48 @@\n+/* Test __atomic routines for existence and proper execution on 8 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_long_long } */\n+/* { dg-options \"\" } */\n+\n+/* Test the execution of the __atomic_store_n builtin for a long long.  */\n+\n+extern void abort(void);\n+\n+long long v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELEASE);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != ++count)\n+    abort ();\n+\n+  /* Now test the generic variant.  */\n+  count++;\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELAXED);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELEASE);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_SEQ_CST);\n+  if (v != count)\n+    abort ();\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "f976a052c7cc8926bef6eb1a86d9ffb224f27f19", "filename": "gcc/testsuite/gcc.dg/atomic-store-5.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-store-5.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,48 @@\n+/* Test __atomic routines for existence and proper execution on 16 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_128 } */\n+/* { dg-options \"-mcx16\" { target { x86_64-*-* } } } */\n+\n+/* Test the execution of the __atomic_store_n builtin for a 16 byte value.  */\n+\n+extern void abort(void);\n+\n+__int128_t v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELEASE);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != ++count)\n+    abort ();\n+\n+  /* Now test the generic variant.  */\n+  count++;\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELAXED);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELEASE);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_SEQ_CST);\n+  if (v != count)\n+    abort ();\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "b5647b0bd81747b23e3652864bfbb6ab26bd3f34", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-11.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-11.c?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,17 +0,0 @@\n-/* PR middle-end/36877 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fopenmp\" } */\n-/* { dg-options \"-fopenmp -march=i386\" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */\n-\n-int i;\n-float f;\n-\n-void foo (void)\n-{\n-#pragma omp atomic\n-  i++;\n-#pragma omp atomic\n-  f += 1.0;\n-}\n-\n-/* { dg-final { scan-assembler-not \"__sync_(fetch|add|bool|val)\" { target i?86-*-* x86_64-*-* powerpc*-*-* ia64-*-* s390*-*-* sparc*-*-* } } } */"}, {"sha": "4cb4cafa40068fa45e0bc2656722d66b3455d93d", "filename": "gcc/testsuite/gcc.dg/gomp/gomp.exp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fgomp.exp?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -29,8 +29,7 @@ if ![check_effective_target_fopenmp] {\n dg-init\n \n # Main loop.\n-dg-runtest [lsort [find $srcdir/$subdir *.c]] \\\n-\t\"\" \"-fopenmp\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c $srcdir/c-c++-common/gomp/*.c]] \"\" \"-fopenmp\"\n \n # All done.\n dg-finish"}, {"sha": "d03e831810834b3e705310e92ec12675b15221b0", "filename": "gcc/testsuite/gcc.dg/simulate-thread/atomic-load-int.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-load-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-load-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-load-int.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,116 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target sync_int_long } */\n+/* { dg-final { simulate-thread } } */\n+\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+\n+/* Testing load for atomicity is a little trickier.  \n+\n+   Set up the atomic value so that it changes value after every instruction \n+   is executed.\n+\n+   Simply alternating between 2 values wouldn't be sufficient since a load of\n+   one part, followed by the load of the second part 2 instructions later would\n+   appear to be valid.\n+\n+   set up a table of 16 values which change a bit in every byte of the value \n+   each time, this will give us a 16 instruction cycle before repetition\n+   kicks in, which should be sufficient to detect any issues.  Just to be sure,\n+   we also change the table cycle size during execution. \n+   \n+   The end result is that all loads should always get one of the values from\n+   the table. Any other pattern means the load failed.  */\n+\n+unsigned int ret;\n+unsigned int value = 0;\n+unsigned int result = 0;\n+unsigned int table[16] = {\n+0x00000000, \n+0x11111111, \n+0x22222222, \n+0x33333333,\n+0x44444444,\n+0x55555555,\n+0x66666666,\n+0x77777777,\n+0x88888888,\n+0x99999999,\n+0xAAAAAAAA,\n+0xBBBBBBBB,\n+0xCCCCCCCC,\n+0xDDDDDDDD,\n+0xEEEEEEEE,\n+0xFFFFFFFF\n+};\n+\n+int table_cycle_size = 16;\n+\n+/* Return 0 if 'result' is a valid value to have loaded.  */\n+int verify_result ()\n+{\n+  int x;\n+  int found = 0;\n+\n+  /* Check entire table for valid values.  */\n+  for (x = 0; x < 16 ; x++)\n+    if (result == table[x])\n+      {\n+\tfound = 1;\n+\tbreak;\n+      }\n+\n+  if (!found)\n+    printf(\"FAIL: Invalid result returned from fetch\\n\");\n+\n+  return !found;\n+}\n+\n+/* Iterate VALUE through the different valid values. */\n+void simulate_thread_other_threads ()\n+{\n+  static int current = 0;\n+\n+  if (++current >= table_cycle_size)\n+    current = 0;\n+  value = table[current];\n+}\n+\n+int simulate_thread_step_verify ()\n+{\n+  return verify_result ();\n+}\n+\n+int simulate_thread_final_verify ()\n+{\n+  return verify_result ();\n+}\n+\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  int x;\n+\n+  /* Execute loads with value changing at various cyclic values.  */\n+  for (table_cycle_size = 16; table_cycle_size > 4 ; table_cycle_size--)\n+    {\n+      ret = __atomic_load_n (&value, __ATOMIC_SEQ_CST);\n+      /* In order to verify the returned value (which is not atomic), it needs\n+\t to be atomically stored into another variable and check that.  */\n+      __atomic_store_n (&result, ret, __ATOMIC_SEQ_CST);\n+\n+      /* Execute the fetch/store a couple of times just to ensure the cycles\n+         have a chance to be interesting.  */\n+      ret = __atomic_load_n (&value, __ATOMIC_SEQ_CST);\n+      __atomic_store_n (&result, ret, __ATOMIC_SEQ_CST);\n+    }\n+}\n+\n+main()\n+{\n+  simulate_thread_main ();\n+  simulate_thread_done ();\n+  return 0;\n+}"}, {"sha": "3ade0d6fad39ef0a9eb485032ec4058bcf096529", "filename": "gcc/testsuite/gcc.dg/simulate-thread/atomic-load-int128.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-load-int128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-load-int128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-load-int128.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,132 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target sync_int_128 } */\n+/* { dg-options \"-mcx16\" { target { x86_64-*-* i?86-*-* } } } */\n+/* { dg-final { simulate-thread } } */\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+\n+/* Testing load for atomicity is a little trickier.  \n+\n+   Set up the atomic value so that it changes value after every instruction \n+   is executed.\n+\n+   Simply alternating between 2 values wouldn't be sufficient since a load of\n+   one part, followed by the load of the second part 2 instructions later would\n+   appear to be valid.\n+\n+   set up a table of 16 values which change a bit in every byte of the value \n+   each time, this will give us a 16 instruction cycle before repetition\n+   kicks in, which should be sufficient to detect any issues.  Just to be sure,\n+   we also change the table cycle size during execution. \n+   \n+   The end result is that all loads should always get one of the values from\n+   the table. Any other pattern means the load failed.  */\n+\n+__int128_t ret;\n+__int128_t value = 0;\n+__int128_t result = 0;\n+__int128_t table[16] = {\n+0x0000000000000000, \n+0x1111111111111111, \n+0x2222222222222222, \n+0x3333333333333333,\n+0x4444444444444444,\n+0x5555555555555555,\n+0x6666666666666666,\n+0x7777777777777777,\n+0x8888888888888888,\n+0x9999999999999999,\n+0xAAAAAAAAAAAAAAAA,\n+0xBBBBBBBBBBBBBBBB,\n+0xCCCCCCCCCCCCCCCC,\n+0xDDDDDDDDDDDDDDDD,\n+0xEEEEEEEEEEEEEEEE,\n+0xFFFFFFFFFFFFFFFF\n+};\n+\n+int table_cycle_size = 16;\n+\n+/* Since we don't have 128 bit constants, we have to properly pad the table.  */\n+void fill_table()\n+{\n+  int x;\n+  for (x = 0; x < 16; x++)\n+    {\n+      ret = table[x];\n+      ret = (ret << 64) | ret;\n+      table[x] = ret;\n+    }\n+}\n+\n+/* Return 0 if 'result' is a valid value to have loaded.  */\n+int verify_result ()\n+{\n+  int x;\n+  int found = 0;\n+\n+  /* Check entire table for valid values.  */\n+  for (x = 0; x < 16; x++)\n+    if (result == table[x])\n+      {\n+\tfound = 1;\n+\tbreak;\n+      }\n+\n+  if (!found)\n+    printf(\"FAIL: Invalid result returned from fetch\\n\");\n+\n+  return !found;\n+}\n+\n+/* Iterate VALUE through the different valid values. */\n+void simulate_thread_other_threads ()\n+{\n+  static int current = 0;\n+\n+  if (++current >= table_cycle_size)\n+    current = 0;\n+  value = table[current];\n+}\n+\n+int simulate_thread_step_verify ()\n+{\n+  return verify_result ();\n+}\n+\n+int simulate_thread_final_verify ()\n+{\n+  return verify_result ();\n+}\n+\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  int x;\n+\n+  /* Make sure value starts with an atomic value now.  */\n+  __atomic_store_n (&value, ret, __ATOMIC_SEQ_CST);\n+\n+  /* Execute loads with value changing at various cyclic values.  */\n+  for (table_cycle_size = 16; table_cycle_size > 4 ; table_cycle_size--)\n+    {\n+      ret = __atomic_load_n (&value, __ATOMIC_SEQ_CST);\n+      /* In order to verify the returned value (which is not atomic), it needs\n+\t to be atomically stored into another variable and check that.  */\n+      __atomic_store_n (&result, ret, __ATOMIC_SEQ_CST);\n+\n+      /* Execute the fetch/store a couple of times just to ensure the cycles\n+         have a chance to be interesting.  */\n+      ret = __atomic_load_n (&value, __ATOMIC_SEQ_CST);\n+      __atomic_store_n (&result, ret, __ATOMIC_SEQ_CST);\n+    }\n+}\n+\n+main()\n+{\n+  fill_table ();\n+  simulate_thread_main ();\n+  simulate_thread_done ();\n+  return 0;\n+}"}, {"sha": "8bc2eaace651dc90ed5580445229bfdc038d9377", "filename": "gcc/testsuite/gcc.dg/simulate-thread/atomic-load-longlong.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-load-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-load-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-load-longlong.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,117 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target sync_long_long } */\n+/* { dg-options \"\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+\n+/* Testing load for atomicity is a little trickier.  \n+\n+   Set up the atomic value so that it changes value after every instruction \n+   is executed.\n+\n+   Simply alternating between 2 values wouldn't be sufficient since a load of\n+   one part, followed by the load of the second part 2 instructions later would\n+   appear to be valid.\n+\n+   set up a table of 16 values which change a bit in every byte of the value \n+   each time, this will give us a 16 instruction cycle before repetition\n+   kicks in, which should be sufficient to detect any issues.  Just to be sure,\n+   we also change the table cycle size during execution. \n+   \n+   The end result is that all loads should always get one of the values from\n+   the table. Any other pattern means the load failed.  */\n+\n+unsigned long long ret;\n+unsigned long long value = 0;\n+unsigned long long result = 0;\n+unsigned long long table[16] = {\n+0x0000000000000000, \n+0x1111111111111111, \n+0x2222222222222222, \n+0x3333333333333333,\n+0x4444444444444444,\n+0x5555555555555555,\n+0x6666666666666666,\n+0x7777777777777777,\n+0x8888888888888888,\n+0x9999999999999999,\n+0xAAAAAAAAAAAAAAAA,\n+0xBBBBBBBBBBBBBBBB,\n+0xCCCCCCCCCCCCCCCC,\n+0xDDDDDDDDDDDDDDDD,\n+0xEEEEEEEEEEEEEEEE,\n+0xFFFFFFFFFFFFFFFF\n+};\n+\n+int table_cycle_size = 16;\n+\n+/* Return 0 if 'result' is a valid value to have loaded.  */\n+int verify_result ()\n+{\n+  int x;\n+  int found = 0;\n+\n+  /* Check entire table for valid values.  */\n+  for (x = 0; x < 16 ; x++)\n+    if (result == table[x])\n+      {\n+\tfound = 1;\n+\tbreak;\n+      }\n+\n+  if (!found)\n+    printf(\"FAIL: Invalid result returned from fetch\\n\");\n+\n+  return !found;\n+}\n+\n+/* Iterate VALUE through the different valid values. */\n+void simulate_thread_other_threads ()\n+{\n+  static int current = 0;\n+\n+  if (++current >= table_cycle_size)\n+    current = 0;\n+  value = table[current];\n+}\n+\n+int simulate_thread_step_verify ()\n+{\n+  return verify_result ();\n+}\n+\n+int simulate_thread_final_verify ()\n+{\n+  return verify_result ();\n+}\n+\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  int x;\n+\n+  /* Execute loads with value changing at various cyclic values.  */\n+  for (table_cycle_size = 16; table_cycle_size > 4 ; table_cycle_size--)\n+    {\n+      ret = __atomic_load_n (&value, __ATOMIC_SEQ_CST);\n+      /* In order to verify the returned value (which is not atomic), it needs\n+\t to be atomically stored into another variable and check that.  */\n+      __atomic_store_n (&result, ret, __ATOMIC_SEQ_CST);\n+\n+      /* Execute the fetch/store a couple of times just to ensure the cycles\n+         have a chance to be interesting.  */\n+      ret = __atomic_load_n (&value, __ATOMIC_SEQ_CST);\n+      __atomic_store_n (&result, ret, __ATOMIC_SEQ_CST);\n+    }\n+}\n+\n+main()\n+{\n+  simulate_thread_main ();\n+  simulate_thread_done ();\n+  return 0;\n+}"}, {"sha": "e7b54c46bef27e90e95b785775d51553c493e2b8", "filename": "gcc/testsuite/gcc.dg/simulate-thread/atomic-load-short.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-load-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-load-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-load-short.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,116 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target sync_char_short } */\n+/* { dg-final { simulate-thread } } */\n+\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+\n+/* Testing load for atomicity is a little trickier.  \n+\n+   Set up the atomic value so that it changes value after every instruction \n+   is executed.\n+\n+   Simply alternating between 2 values wouldn't be sufficient since a load of\n+   one part, followed by the load of the second part 2 instructions later would\n+   appear to be valid.\n+\n+   set up a table of 16 values which change a bit in every byte of the value \n+   each time, this will give us a 16 instruction cycle before repetition\n+   kicks in, which should be sufficient to detect any issues.  Just to be sure,\n+   we also change the table cycle size during execution. \n+   \n+   The end result is that all loads should always get one of the values from\n+   the table. Any other pattern means the load failed.  */\n+\n+unsigned short ret;\n+unsigned short value = 0;\n+unsigned short result = 0;\n+unsigned short table[16] = {\n+0x0000, \n+0x1111, \n+0x2222, \n+0x3333,\n+0x4444,\n+0x5555,\n+0x6666,\n+0x7777,\n+0x8888,\n+0x9999,\n+0xAAAA,\n+0xBBBB,\n+0xCCCC,\n+0xDDDD,\n+0xEEEE,\n+0xFFFF\n+};\n+\n+int table_cycle_size = 16;\n+\n+/* Return 0 if 'result' is a valid value to have loaded.  */\n+int verify_result ()\n+{\n+  int x;\n+  int found = 0;\n+\n+  /* Check entire table for valid values.  */\n+  for (x = 0; x < 16 ; x++)\n+    if (result == table[x])\n+      {\n+\tfound = 1;\n+\tbreak;\n+      }\n+\n+  if (!found)\n+    printf(\"FAIL: Invalid result returned from fetch\\n\");\n+\n+  return !found;\n+}\n+\n+/* Iterate VALUE through the different valid values. */\n+void simulate_thread_other_threads ()\n+{\n+  static int current = 0;\n+\n+  if (++current >= table_cycle_size)\n+    current = 0;\n+  value = table[current];\n+}\n+\n+int simulate_thread_step_verify ()\n+{\n+  return verify_result ();\n+}\n+\n+int simulate_thread_final_verify ()\n+{\n+  return verify_result ();\n+}\n+\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  int x;\n+\n+  /* Execute loads with value changing at various cyclic values.  */\n+  for (table_cycle_size = 16; table_cycle_size > 4 ; table_cycle_size--)\n+    {\n+      ret = __atomic_load_n (&value, __ATOMIC_SEQ_CST);\n+      /* In order to verify the returned value (which is not atomic), it needs\n+\t to be atomically stored into another variable and check that.  */\n+      __atomic_store_n (&result, ret, __ATOMIC_SEQ_CST);\n+\n+      /* Execute the fetch/store a couple of times just to ensure the cycles\n+         have a chance to be interesting.  */\n+      ret = __atomic_load_n (&value, __ATOMIC_SEQ_CST);\n+      __atomic_store_n (&result, ret, __ATOMIC_SEQ_CST);\n+    }\n+}\n+\n+main()\n+{\n+  simulate_thread_main ();\n+  simulate_thread_done ();\n+  return 0;\n+}"}, {"sha": "990310c0f0ede7da5c366398d5963de49fe9fda8", "filename": "gcc/testsuite/gcc.dg/simulate-thread/atomic-other-int.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-other-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-other-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-other-int.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,118 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target sync_int_long } */\n+/* { dg-final { simulate-thread } } */\n+\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+/* Test all the __sync routines for proper atomicity on 4 byte values.  */\n+\n+unsigned int zero = 0;\n+unsigned int max = ~0;\n+\n+unsigned int changing_value = 0;\n+unsigned int value = 0;\n+unsigned int ret;\n+\n+void test_abort()\n+{\n+  static int reported = 0;\n+  if (!reported)\n+    {\n+      printf (\"FAIL: improper execution of __sync builtin.\\n\");\n+      reported = 1;\n+    }\n+}\n+\n+void simulate_thread_other_threads ()\n+{\n+}\n+\n+int simulate_thread_step_verify ()\n+{\n+  if (value != zero && value != max)\n+    {\n+      printf (\"FAIL: invalid intermediate result for value.\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int simulate_thread_final_verify ()\n+{\n+  if (value != 0)\n+    {\n+      printf (\"FAIL: invalid final result for value.\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* All values written to 'value' alternate between 'zero' and\n+   'max'. Any other value detected by simulate_thread_step_verify()\n+   between instructions would indicate that the value was only\n+   partially written, and would thus fail this atomicity test.\n+\n+   This function tests each different __atomic routine once, with\n+   the exception of the load instruction which requires special\n+   testing.  */\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  \n+  ret = __atomic_exchange_n (&value, max, __ATOMIC_SEQ_CST);\n+  if (ret != zero || value != max)\n+    test_abort();\n+\n+  __atomic_store_n (&value, zero, __ATOMIC_SEQ_CST);\n+  if (value != zero)\n+    test_abort();\n+\n+  ret = __atomic_fetch_add (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != zero)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_sub (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_or (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != zero)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_and (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_xor (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_add_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_sub_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != zero)\n+    test_abort ();\n+\n+  ret = __atomic_or_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_and_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_xor_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != zero)\n+    test_abort ();\n+}\n+\n+main ()\n+{\n+  simulate_thread_main ();\n+  simulate_thread_done ();\n+  return 0;\n+}"}, {"sha": "67f84a14a000e8d9ee00915dabfa55fbccceacca", "filename": "gcc/testsuite/gcc.dg/simulate-thread/atomic-other-int128.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-other-int128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-other-int128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-other-int128.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,116 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target sync_int_128 } */\n+/* { dg-options \"-mcx16\" { target { x86_64-*-* i?86-*-*] } } } */\n+/* { dg-final { simulate-thread } } */\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+/* Test all the __sync routines for proper atomicity on 16 byte values.  */\n+\n+__int128_t zero = 0;\n+__int128_t max = ~0;\n+__int128_t changing_value = 0;\n+__int128_t value = 0;\n+__int128_t ret;\n+\n+void test_abort()\n+{\n+  static int reported = 0;\n+  if (!reported)\n+    {\n+      printf (\"FAIL: improper execution of __sync builtin.\\n\");\n+      reported = 1;\n+    }\n+}\n+\n+void simulate_thread_other_threads ()\n+{\n+}\n+\n+int simulate_thread_step_verify ()\n+{\n+  if (value != zero && value != max)\n+    {\n+      printf (\"FAIL: invalid intermediate result for value.\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int simulate_thread_final_verify ()\n+{\n+  if (value != 0)\n+    {\n+      printf (\"FAIL: invalid final result for value.\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* All values written to 'value' alternate between 'zero' and 'max'. Any other\n+   value detected by simulate_thread_step_verify() between instructions would indicate\n+   that the value was only partially written, and would thus fail this \n+   atomicity test.  \n+\n+   This function tests each different __atomic routine once, with the\n+   exception of the load instruction which requires special testing.  */\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  \n+  ret = __atomic_exchange_n (&value, max, __ATOMIC_SEQ_CST);\n+  if (ret != zero || value != max)\n+    test_abort();\n+\n+  __atomic_store_n (&value, zero, __ATOMIC_SEQ_CST);\n+  if (value != zero)\n+    test_abort();\n+\n+  ret = __atomic_fetch_add (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != zero)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_sub (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_or (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != zero)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_and (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_xor (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_add_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_sub_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != zero)\n+    test_abort ();\n+\n+  ret = __atomic_or_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_and_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_xor_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != zero)\n+    test_abort ();\n+}\n+\n+int main()\n+{\n+  simulate_thread_main ();\n+  simulate_thread_done ();\n+  return 0;\n+}"}, {"sha": "ac4330bd8a45471fad24fa506fcee67ecf195f27", "filename": "gcc/testsuite/gcc.dg/simulate-thread/atomic-other-longlong.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-other-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-other-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-other-longlong.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,117 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target sync_long_long } */\n+/* { dg-options \"\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+/* Test all the __sync routines for proper atomicity on 8 byte values.  */\n+\n+unsigned long long zero = 0;\n+unsigned long long max = ~0;\n+\n+unsigned long long changing_value = 0;\n+unsigned long long value = 0;\n+unsigned long long ret;\n+\n+void test_abort()\n+{\n+  static int reported = 0;\n+  if (!reported)\n+    {\n+      printf (\"FAIL: improper execution of __sync builtin.\\n\");\n+      reported = 1;\n+    }\n+}\n+\n+void simulate_thread_other_threads ()\n+{\n+}\n+\n+int simulate_thread_step_verify ()\n+{\n+  if (value != zero && value != max)\n+    {\n+      printf (\"FAIL: invalid intermediate result for value.\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int simulate_thread_final_verify ()\n+{\n+  if (value != 0)\n+    {\n+      printf (\"FAIL: invalid final result for value.\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* All values written to 'value' alternate between 'zero' and 'max'. Any other\n+   value detected by simulate_thread_step_verify() between instructions would indicate\n+   that the value was only partially written, and would thus fail this \n+   atomicity test.  \n+\n+   This function tests each different __atomic routine once, with the\n+   exception of the load instruction which requires special testing.  */\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  ret = __atomic_exchange_n (&value, max, __ATOMIC_SEQ_CST);\n+  if (ret != zero || value != max)\n+    test_abort();\n+\n+  __atomic_store_n (&value, zero, __ATOMIC_SEQ_CST);\n+  if (value != zero)\n+    test_abort();\n+\n+  ret = __atomic_fetch_add (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != zero)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_sub (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_or (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != zero)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_and (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_xor (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_add_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_sub_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != zero)\n+    test_abort ();\n+\n+  ret = __atomic_or_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_and_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_xor_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != zero)\n+    test_abort ();\n+}\n+\n+int main ()\n+{\n+  simulate_thread_main ();\n+  simulate_thread_done ();\n+  return 0;\n+}"}, {"sha": "d823e02fb474b1cc70141b24d73e21e868e5ab12", "filename": "gcc/testsuite/gcc.dg/simulate-thread/atomic-other-short.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-other-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-other-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fatomic-other-short.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,117 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target sync_char_short } */\n+/* { dg-final { simulate-thread } } */\n+\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+/* Test all the __sync routines for proper atomicity on 2 byte values.  */\n+\n+unsigned short zero = 0;\n+unsigned short max = ~0;\n+\n+unsigned short changing_value = 0;\n+unsigned short value = 0;\n+unsigned short ret;\n+\n+void test_abort()\n+{\n+  static int reported = 0;\n+  if (!reported)\n+    {\n+      printf (\"FAIL: improper execution of __sync builtin.\\n\");\n+      reported = 1;\n+    }\n+}\n+\n+void simulate_thread_other_threads ()\n+{\n+}\n+\n+int simulate_thread_step_verify ()\n+{\n+  if (value != zero && value != max)\n+    {\n+      printf (\"FAIL: invalid intermediate result for value.\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int simulate_thread_final_verify ()\n+{\n+  if (value != 0)\n+    {\n+      printf (\"FAIL: invalid final result for value.\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* All values written to 'value' alternate between 'zero' and\n+   'max'. Any other value detected by simulate_thread_step_verify()\n+   between instructions would indicate that the value was only\n+   partially written, and would thus fail this atomicity test.\n+\n+   This function tests each different __atomic routine once, with\n+   the exception of the load instruction which requires special\n+   testing.  */\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  ret = __atomic_exchange_n (&value, max, __ATOMIC_SEQ_CST);\n+  if (ret != zero || value != max)\n+    test_abort();\n+\n+  __atomic_store_n (&value, zero, __ATOMIC_SEQ_CST);\n+  if (value != zero)\n+    test_abort();\n+\n+  ret = __atomic_fetch_add (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != zero)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_sub (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_or (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != zero)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_and (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_fetch_xor (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_add_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_sub_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != zero)\n+    test_abort ();\n+\n+  ret = __atomic_or_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_and_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != max || ret != max)\n+    test_abort ();\n+\n+  ret = __atomic_xor_fetch (&value, max, __ATOMIC_SEQ_CST);\n+  if (value != zero || ret != zero)\n+    test_abort ();\n+}\n+\n+int main ()\n+{\n+  simulate_thread_main ();\n+  simulate_thread_done ();\n+  return 0;\n+}"}, {"sha": "71d1cca9ddadc6be401257c32d24bb76fb3841e8", "filename": "gcc/testsuite/gcc.dg/simulate-thread/speculative-store.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fspeculative-store.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fspeculative-store.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fspeculative-store.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do link } */\n+/* { dg-options \"--param allow-store-data-races=0\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+/* This file tests that speculative store movement out of a loop doesn't \n+   happen.  This is disallowed when --param allow-store-data-races is 0.  */\n+\n+int global = 100;\n+\n+/* Other thread makes sure global is 100 before the next instruction is\n+ * exceuted.  */\n+void simulate_thread_other_threads() \n+{\n+  global = 100;\n+}\n+\n+int simulate_thread_step_verify()\n+{\n+  if (global != 100)\n+    {\n+      printf(\"FAIL: global variable was assigned to.  \\n\");\n+      return 1;\n+    }\n+}\n+\n+int simulate_thread_final_verify()\n+{\n+  return 0;\n+}\n+\n+/* The variable global should never be assigned if func(0) is called.\n+   This tests store movement out of loop thats never executed. */\n+void test (int y)\n+{\n+  int x;\n+  for (x=0; x< y; x++)\n+    {\n+       global = y;   /* This should never speculatively execute.  */\n+    }\n+}\n+\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  test(0);\n+  simulate_thread_done();\n+}\n+\n+__attribute__((noinline))\n+int main()\n+{\n+  simulate_thread_main();\n+  return 0;\n+}"}, {"sha": "fdcd7f46af721d469c9c193b32d2c58ee0a54584", "filename": "gcc/testsuite/gcc.dg/simulate-thread/strict-align-global.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fstrict-align-global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fstrict-align-global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fstrict-align-global.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do link } */\n+/* { dg-options \"--param allow-packed-store-data-races=0\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+/* This test verifies writes to globals do not write to adjacent\n+   globals.  This mostly happens on strict-align targets that are not\n+   byte addressable (old Alphas, etc).  */\n+\n+char a = 0;\n+char b = 77;\n+\n+void simulate_thread_other_threads() \n+{\n+}\n+\n+int simulate_thread_step_verify()\n+{\n+  if (b != 77)\n+    {\n+      printf(\"FAIL: Unexpected value.  <b> is %d, should be 77\\n\", b);\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Verify that every variable has the correct value.  */\n+int simulate_thread_final_verify()\n+{\n+  int ret = simulate_thread_step_verify ();\n+  if (a != 66)\n+    {\n+      printf(\"FAIL: Unexpected value.  <a> is %d, should be 66\\n\", a);\n+      return 1;\n+    }\n+  return ret;\n+}\n+\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  a = 66;\n+}\n+\n+int main ()\n+{\n+  simulate_thread_main();\n+  simulate_thread_done();\n+  return 0;\n+}"}, {"sha": "2d931176e7d214536a0cfcbf8eb6c2fcf6ff0e96", "filename": "gcc/testsuite/gcc.dg/simulate-thread/subfields.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsubfields.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsubfields.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsubfields.c?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -0,0 +1,93 @@\n+/* { dg-do link } */\n+/* { dg-options \"--param allow-packed-store-data-races=0\" } */\n+/* { dg-final { simulate-thread } } */\n+\n+#include <stdio.h>\n+#include \"simulate-thread.h\"\n+\n+/* This test verifies that data races aren't introduced by structure subfield \n+   stores. */\n+\n+struct test_struct {\n+  char a;\n+  char b;\n+  char c;\n+  char d;\n+} var = {0,0,0,0};\n+\n+\n+/* This routine sets field a to 'x'.  If executed properly, it will\n+   not affect any of the other fields in the structure.  An improper\n+   implementation may load an entire word, change the 8 bits for field\n+   'a' and write the entire word back out. */\n+__attribute__((noinline))\n+void set_a(char x)\n+{\n+  var.a = x;\n+}\n+\n+static int global = 0;\n+\n+/* The other thread increments the value of each of the other fields\n+   in the structure every cycle.  If the store to the 'a' field does\n+   an incorrect full or partial word load, mask and store, it will\n+   write back an incorrect value to one or more of the other\n+   fields.  */\n+void simulate_thread_other_threads() \n+{\n+  global++;\n+  var.b = global;\n+  var.c = global;\n+  var.d = global;\n+}\n+\n+\n+/* Make sure that none of the other fields have been changed.  */\n+int simulate_thread_step_verify()\n+{\n+  int ret = 0;\n+  if (var.b != global)\n+    {\n+      printf(\"FAIL: Unexpected value. var.b is %d, should be %d\\n\",\n+\t     var.b, global);\n+      ret = 1;\n+    }\n+  if (var.c != global)\n+    {\n+      printf(\"FAIL: Unexpected value. var.c is %d, should be %d\\n\",\n+\t     var.c, global);\n+      ret = 1;\n+    }\n+  if (var.d != global)\n+    {\n+      printf(\"FAIL: Unexpected value. var.d is %d, should be %d\\n\",\n+\t     var.d, global);\n+      ret = 1;\n+    }\n+  return ret;\n+}\n+\n+/* Verify that every variable has the correct value.  */\n+int simulate_thread_final_verify()\n+{\n+  int ret = simulate_thread_step_verify();\n+  if (var.a != 1)\n+    {\n+      printf(\"FAIL: Unexpected value. var.a is %d, should be %d\\n\", var.a, 1);\n+      ret = 1;\n+    }\n+  return ret;\n+}\n+\n+__attribute__((noinline))\n+void simulate_thread_main()\n+{\n+  set_a(1);\n+}\n+\n+int main ()\n+{\n+  simulate_thread_main();\n+  simulate_thread_done();\n+  return 0;\n+}"}, {"sha": "74a4c951803669c4f4ef40c72124e63773ebe1d9", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -655,6 +655,28 @@ proc check_effective_target_tls_runtime {} {\n     } [add_options_for_tls \"\"]]\n }\n \n+# Return 1 if atomic compare-and-swap is supported on 'int'\n+\n+proc check_effective_target_cas_char {} {\n+    return [check_no_compiler_messages cas_char assembly {\n+\t#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1\n+\t#error unsupported\n+\t#endif\n+    } \"\"]\n+}\n+\n+proc check_effective_target_cas_int {} {\n+    return [check_no_compiler_messages cas_int assembly {\n+\t#if __INT_MAX__ == 0x7fff && __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2\n+        /* ok */\n+        #elif __INT_MAX__ == 0x7fffffff && __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\n+\t/* ok */\n+\t#else\n+\t#error unsupported\n+\t#endif\n+    } \"\"]\n+}\n+\n # Return 1 if -ffunction-sections is supported, 0 otherwise.\n \n proc check_effective_target_function_sections {} {\n@@ -3517,6 +3539,44 @@ proc check_effective_target_section_anchors { } {\n     return $et_section_anchors_saved\n }\n \n+# Return 1 if the target supports atomic operations on \"int_128\" values.\n+\n+proc check_effective_target_sync_int_128 { } {\n+    global et_sync_int_128_saved\n+\n+    if [info exists et_sync_int_128_saved] {\n+        verbose \"check_effective_target_sync_int_128: using cached result\" 2\n+    } else {\n+        set et_sync_int_128_saved 0\n+        if { ([istarget x86_64-*-*] || [istarget i?86-*-*])\n+\t     && ![is-effective-target ia32] } {\n+           set et_sync_int_128_saved 1\n+        }\n+    }\n+\n+    verbose \"check_effective_target_sync_int_128: returning $et_sync_int_128_saved\" 2\n+    return $et_sync_int_128_saved\n+}\n+\n+# Return 1 if the target supports atomic operations on \"long long\".\n+\n+proc check_effective_target_sync_long_long { } {\n+    global et_sync_long_long_saved\n+\n+    if [info exists et_sync_long_long_saved] {\n+        verbose \"check_effective_target_sync_long_long: using cached result\" 2\n+    } else {\n+        set et_sync_long_long_saved 0\n+        if { ([istarget x86_64-*-*] || [istarget i?86-*-*])\n+\t     && ![is-effective-target ia32] } {\n+           set et_sync_long_long_saved 1\n+        }\n+    }\n+\n+    verbose \"check_effective_target_sync_long_long: returning $et_sync_long_long_saved\" 2\n+    return $et_sync_long_long_saved\n+}\n+\n # Return 1 if the target supports atomic operations on \"int\" and \"long\".\n \n proc check_effective_target_sync_int_long { } {"}, {"sha": "dd1bd56d97927e0418c668b1893c0c35b7866991", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -1,3 +1,25 @@\n+2011-11-06  Benjamin Kosnik  <bkoz@redhat.com>\n+\t    Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tMerged from cxx-mem-model.\n+\n+\t* include/Makefile.am (bits_headers): Remove atomic_0.h, atomic_2.h.\n+\t* include/Makefile.in: Regenerate.\n+\t* src/Makefile.am (sources): Rename atomic.cc to\n+\tcompatibility-atomic-c++0x.cc.\n+\t* src/Makefile.in: Regenerate.\n+\t* include/bits/atomic_0.h: Remove.\n+\t* include/bits/atomic_2.h: Incorporate into...\n+\t* include/bits/atomic_base.h: ...this.  Use new __atomic routines.\n+\t* include/std/atomic: Add generic atomic calls to basic atomic class.\n+\t* src/atomic.cc: Move...\n+\t* src/compatibility-atomic-c++0x.cc: ...here.\n+\t* src/compatibility-c++0x.cc: Tweak.\n+\t* testsuite/29_atomics/atomic/cons/user_pod.cc: Fix.\n+\t* testsuite/29_atomics/atomic/requirements/explicit_instantiation/1.cc:\n+\t  Same.\n+\t* testsuite/29_atomics/headers/atomic/macros.cc: Same.\n+\n 2011-11-06  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* doc/xml/manual/test.xml: Fix dg-warning examples."}, {"sha": "bc4594db4a35c15f8f713413614c855b1a83efee", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -83,8 +83,6 @@ bits_headers = \\\n \t${bits_srcdir}/alloc_traits.h \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/atomic_base.h \\\n-\t${bits_srcdir}/atomic_0.h \\\n-\t${bits_srcdir}/atomic_2.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\"}, {"sha": "3b31e8a2c5d19f1ff9dd151c0fc1d7fe10172cd8", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -335,8 +335,6 @@ bits_headers = \\\n \t${bits_srcdir}/alloc_traits.h \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/atomic_base.h \\\n-\t${bits_srcdir}/atomic_0.h \\\n-\t${bits_srcdir}/atomic_2.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\"}, {"sha": "4f8b0929f16184b3264aaf53099fe35fa4301982", "filename": "libstdc++-v3/include/bits/atomic_0.h", "status": "removed", "additions": 0, "deletions": 677, "changes": 677, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_0.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_0.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_0.h?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,677 +0,0 @@\n-// -*- C++ -*- header.\n-\n-// Copyright (C) 2008, 2009, 2010, 2011\n-// Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file bits/atomic_0.h\n- *  This is an internal header file, included by other library headers.\n- *  Do not attempt to use it directly. @headername{atomic}\n- */\n-\n-#ifndef _GLIBCXX_ATOMIC_0_H\n-#define _GLIBCXX_ATOMIC_0_H 1\n-\n-#pragma GCC system_header\n-\n-namespace std _GLIBCXX_VISIBILITY(default)\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-// 0 == __atomic0 == Never lock-free\n-namespace __atomic0\n-{\n-  _GLIBCXX_BEGIN_EXTERN_C\n-\n-  void\n-  atomic_flag_clear_explicit(__atomic_flag_base*, memory_order)\n-  _GLIBCXX_NOTHROW;\n-\n-  void\n-  __atomic_flag_wait_explicit(__atomic_flag_base*, memory_order)\n-  _GLIBCXX_NOTHROW;\n-\n-  _GLIBCXX_CONST __atomic_flag_base*\n-  __atomic_flag_for_address(const volatile void* __z) _GLIBCXX_NOTHROW;\n-\n-  _GLIBCXX_END_EXTERN_C\n-\n-  // Implementation specific defines.\n-#define _ATOMIC_MEMBER_ _M_i\n-\n-  // Implementation specific defines.\n-#define _ATOMIC_LOAD_(__a, __x)\t\t\t\t\t\t   \\\n-  ({typedef __typeof__(_ATOMIC_MEMBER_) __i_type;                          \\\n-    __i_type* __p = &_ATOMIC_MEMBER_;\t   \t\t\t\t   \\\n-    __atomic_flag_base* __g = __atomic_flag_for_address(__p);\t  \t   \\\n-    __atomic_flag_wait_explicit(__g, __x);\t\t\t\t   \\\n-    __i_type __r = *__p;\t\t\t\t\t\t   \\\n-    atomic_flag_clear_explicit(__g, __x);\t\t       \t\t   \\\n-    __r; })\n-\n-#define _ATOMIC_STORE_(__a, __n, __x)\t\t\t\t\t   \\\n-  ({typedef __typeof__(_ATOMIC_MEMBER_) __i_type;                          \\\n-    __i_type* __p = &_ATOMIC_MEMBER_;\t   \t\t\t\t   \\\n-    __typeof__(__n) __w = (__n);\t\t\t       \t\t   \\\n-    __atomic_flag_base* __g = __atomic_flag_for_address(__p);\t  \t   \\\n-    __atomic_flag_wait_explicit(__g, __x);\t\t\t\t   \\\n-    *__p = __w;\t\t\t\t\t\t\t\t   \\\n-    atomic_flag_clear_explicit(__g, __x);\t\t       \t\t   \\\n-    __w; })\n-\n-#define _ATOMIC_MODIFY_(__a, __o, __n, __x)\t\t\t\t   \\\n-  ({typedef __typeof__(_ATOMIC_MEMBER_) __i_type;                          \\\n-    __i_type* __p = &_ATOMIC_MEMBER_;\t   \t\t\t\t   \\\n-    __typeof__(__n) __w = (__n);\t\t\t       \t\t   \\\n-    __atomic_flag_base* __g = __atomic_flag_for_address(__p);\t  \t   \\\n-    __atomic_flag_wait_explicit(__g, __x);\t\t\t\t   \\\n-    __i_type __r = *__p;\t\t       \t\t\t\t   \\\n-    *__p __o __w;\t\t\t\t\t       \t\t   \\\n-    atomic_flag_clear_explicit(__g, __x);\t\t       \t\t   \\\n-    __r; })\n-\n-#define _ATOMIC_CMPEXCHNG_(__a, __e, __n, __x)\t\t\t\t   \\\n-  ({typedef __typeof__(_ATOMIC_MEMBER_) __i_type;                          \\\n-    __i_type* __p = &_ATOMIC_MEMBER_;\t   \t\t\t\t   \\\n-    __typeof__(__e) __q = (__e);\t\t\t       \t\t   \\\n-    __typeof__(__n) __w = (__n);\t\t\t       \t\t   \\\n-    bool __r;\t\t\t\t\t\t       \t\t   \\\n-    __atomic_flag_base* __g = __atomic_flag_for_address(__p);\t   \t   \\\n-    __atomic_flag_wait_explicit(__g, __x);\t\t\t\t   \\\n-    __i_type __t = *__p;\t\t       \t\t\t\t   \\\n-    if (*__q == __t) \t\t\t\t\t\t\t   \\\n-      {\t\t\t\t\t\t\t\t\t   \\\n-\t*__p = (__i_type)__w;\t\t\t\t\t\t   \\\n-\t__r = true;\t\t\t\t\t\t\t   \\\n-      }\t\t\t\t\t\t\t\t\t   \\\n-    else { *__q = __t; __r = false; }\t\t       \t\t\t   \\\n-    atomic_flag_clear_explicit(__g, __x);\t\t       \t\t   \\\n-    __r; })\n-\n-\n-  /// atomic_flag\n-  struct atomic_flag : public __atomic_flag_base\n-  {\n-    atomic_flag() noexcept = default;\n-    ~atomic_flag() noexcept = default;\n-    atomic_flag(const atomic_flag&) = delete;\n-    atomic_flag& operator=(const atomic_flag&) = delete;\n-    atomic_flag& operator=(const atomic_flag&) volatile = delete;\n-\n-    // Conversion to ATOMIC_FLAG_INIT.\n-    atomic_flag(bool __i) noexcept : __atomic_flag_base({ __i }) { }\n-\n-    bool\n-    test_and_set(memory_order __m = memory_order_seq_cst) noexcept;\n-\n-    bool\n-    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept;\n-\n-    void\n-    clear(memory_order __m = memory_order_seq_cst) noexcept;\n-\n-    void\n-    clear(memory_order __m = memory_order_seq_cst) volatile noexcept;\n-  };\n-\n-\n-  /// Base class for atomic integrals.\n-  //\n-  // For each of the integral types, define atomic_[integral type] struct\n-  //\n-  // atomic_bool     bool\n-  // atomic_char     char\n-  // atomic_schar    signed char\n-  // atomic_uchar    unsigned char\n-  // atomic_short    short\n-  // atomic_ushort   unsigned short\n-  // atomic_int      int\n-  // atomic_uint     unsigned int\n-  // atomic_long     long\n-  // atomic_ulong    unsigned long\n-  // atomic_llong    long long\n-  // atomic_ullong   unsigned long long\n-  // atomic_char16_t char16_t\n-  // atomic_char32_t char32_t\n-  // atomic_wchar_t  wchar_t\n-\n-  // Base type.\n-  // NB: Assuming _ITp is an integral scalar type that is 1, 2, 4, or 8 bytes,\n-  // since that is what GCC built-in functions for atomic memory access work on.\n-  template<typename _ITp>\n-    struct __atomic_base\n-    {\n-    private:\n-      typedef _ITp \t__int_type;\n-\n-      __int_type \t_M_i;\n-\n-    public:\n-      __atomic_base() noexcept = default;\n-      ~__atomic_base() noexcept = default;\n-      __atomic_base(const __atomic_base&) = delete;\n-      __atomic_base& operator=(const __atomic_base&) = delete;\n-      __atomic_base& operator=(const __atomic_base&) volatile = delete;\n-\n-      // Requires __int_type convertible to _M_base._M_i.\n-      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }\n-\n-      operator __int_type() const noexcept\n-      { return load(); }\n-\n-      operator __int_type() const volatile noexcept\n-      { return load(); }\n-\n-      __int_type\n-      operator=(__int_type __i) noexcept\n-      {\n-\tstore(__i);\n-\treturn __i;\n-      }\n-\n-      __int_type\n-      operator=(__int_type __i) volatile noexcept\n-      {\n-\tstore(__i);\n-\treturn __i;\n-      }\n-\n-      __int_type\n-      operator++(int) noexcept\n-      { return fetch_add(1); }\n-\n-      __int_type\n-      operator++(int) volatile noexcept\n-      { return fetch_add(1); }\n-\n-      __int_type\n-      operator--(int) noexcept\n-      { return fetch_sub(1); }\n-\n-      __int_type\n-      operator--(int) volatile noexcept\n-      { return fetch_sub(1); }\n-\n-      __int_type\n-      operator++() noexcept\n-      { return fetch_add(1) + 1; }\n-\n-      __int_type\n-      operator++() volatile noexcept\n-      { return fetch_add(1) + 1; }\n-\n-      __int_type\n-      operator--() noexcept\n-      { return fetch_sub(1) - 1; }\n-\n-      __int_type\n-      operator--() volatile noexcept\n-      { return fetch_sub(1) - 1; }\n-\n-      __int_type\n-      operator+=(__int_type __i) noexcept\n-      { return fetch_add(__i) + __i; }\n-\n-      __int_type\n-      operator+=(__int_type __i) volatile noexcept\n-      { return fetch_add(__i) + __i; }\n-\n-      __int_type\n-      operator-=(__int_type __i) noexcept\n-      { return fetch_sub(__i) - __i; }\n-\n-      __int_type\n-      operator-=(__int_type __i) volatile noexcept\n-      { return fetch_sub(__i) - __i; }\n-\n-      __int_type\n-      operator&=(__int_type __i) noexcept\n-      { return fetch_and(__i) & __i; }\n-\n-      __int_type\n-      operator&=(__int_type __i) volatile noexcept\n-      { return fetch_and(__i) & __i; }\n-\n-      __int_type\n-      operator|=(__int_type __i) noexcept\n-      { return fetch_or(__i) | __i; }\n-\n-      __int_type\n-      operator|=(__int_type __i) volatile noexcept\n-      { return fetch_or(__i) | __i; }\n-\n-      __int_type\n-      operator^=(__int_type __i) noexcept\n-      { return fetch_xor(__i) ^ __i; }\n-\n-      __int_type\n-      operator^=(__int_type __i) volatile noexcept\n-      { return fetch_xor(__i) ^ __i; }\n-\n-      bool\n-      is_lock_free() const noexcept\n-      { return false; }\n-\n-      bool\n-      is_lock_free() const volatile noexcept\n-      { return false; }\n-\n-      void\n-      store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_acquire);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\t__glibcxx_assert(__m != memory_order_consume);\n-\t_ATOMIC_STORE_(this, __i, __m);\n-      }\n-\n-      void\n-      store(__int_type __i,\n-\t    memory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_acquire);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\t__glibcxx_assert(__m != memory_order_consume);\n-\t_ATOMIC_STORE_(this, __i, __m);\n-      }\n-\n-      __int_type\n-      load(memory_order __m = memory_order_seq_cst) const noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_release);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\treturn _ATOMIC_LOAD_(this, __m);\n-      }\n-\n-      __int_type\n-      load(memory_order __m = memory_order_seq_cst) const volatile noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_release);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\treturn _ATOMIC_LOAD_(this, __m);\n-      }\n-\n-      __int_type\n-      exchange(__int_type __i,\n-\t       memory_order __m = memory_order_seq_cst) noexcept\n-      { return _ATOMIC_MODIFY_(this, =, __i, __m); }\n-\n-      __int_type\n-      exchange(__int_type __i,\n-\t       memory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return _ATOMIC_MODIFY_(this, =, __i, __m); }\n-\n-      bool\n-      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n-\t\t\t    memory_order __m1, memory_order __m2) noexcept\n-      {\n-\t__glibcxx_assert(__m2 != memory_order_release);\n-\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n-\t__glibcxx_assert(__m2 <= __m1);\n-\treturn _ATOMIC_CMPEXCHNG_(this, &__i1, __i2, __m1);\n-      }\n-\n-      bool\n-      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n-\t\t\t    memory_order __m1,\n-\t\t\t    memory_order __m2) volatile noexcept\n-      {\n-\t__glibcxx_assert(__m2 != memory_order_release);\n-\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n-\t__glibcxx_assert(__m2 <= __m1);\n-\treturn _ATOMIC_CMPEXCHNG_(this, &__i1, __i2, __m1);\n-      }\n-\n-      bool\n-      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n-\t\t\t    memory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\treturn compare_exchange_weak(__i1, __i2, __m,\n-\t\t\t\t     __calculate_memory_order(__m));\n-      }\n-\n-      bool\n-      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n-\t\t    memory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\treturn compare_exchange_weak(__i1, __i2, __m,\n-\t\t\t\t     __calculate_memory_order(__m));\n-      }\n-\n-      bool\n-      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n-\t\t\t      memory_order __m1, memory_order __m2) noexcept\n-      {\n-\t__glibcxx_assert(__m2 != memory_order_release);\n-\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n-\t__glibcxx_assert(__m2 <= __m1);\n-\treturn _ATOMIC_CMPEXCHNG_(this, &__i1, __i2, __m1);\n-      }\n-\n-      bool\n-      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n-\t\t\t      memory_order __m1,\n-\t\t\t      memory_order __m2) volatile noexcept\n-      {\n-\t__glibcxx_assert(__m2 != memory_order_release);\n-\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n-\t__glibcxx_assert(__m2 <= __m1);\n-\treturn _ATOMIC_CMPEXCHNG_(this, &__i1, __i2, __m1);\n-      }\n-\n-      bool\n-      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n-\t\t\t      memory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\treturn compare_exchange_strong(__i1, __i2, __m,\n-\t\t\t\t       __calculate_memory_order(__m));\n-      }\n-\n-      bool\n-      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n-\t\t    memory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\treturn compare_exchange_strong(__i1, __i2, __m,\n-\t\t\t\t       __calculate_memory_order(__m));\n-      }\n-\n-      __int_type\n-      fetch_add(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return _ATOMIC_MODIFY_(this, +=, __i, __m); }\n-\n-      __int_type\n-      fetch_add(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return _ATOMIC_MODIFY_(this, +=, __i, __m); }\n-\n-      __int_type\n-      fetch_sub(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return _ATOMIC_MODIFY_(this, -=, __i, __m); }\n-\n-      __int_type\n-      fetch_sub(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return _ATOMIC_MODIFY_(this, -=, __i, __m); }\n-\n-      __int_type\n-      fetch_and(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return _ATOMIC_MODIFY_(this, &=, __i, __m); }\n-\n-      __int_type\n-      fetch_and(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return _ATOMIC_MODIFY_(this, &=, __i, __m); }\n-\n-      __int_type\n-      fetch_or(__int_type __i,\n-\t       memory_order __m = memory_order_seq_cst) noexcept\n-      { return _ATOMIC_MODIFY_(this, |=, __i, __m); }\n-\n-      __int_type\n-      fetch_or(__int_type __i,\n-\t       memory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return _ATOMIC_MODIFY_(this, |=, __i, __m); }\n-\n-      __int_type\n-      fetch_xor(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return _ATOMIC_MODIFY_(this, ^=, __i, __m); }\n-\n-      __int_type\n-      fetch_xor(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return _ATOMIC_MODIFY_(this, ^=, __i, __m); }\n-    };\n-\n-\n-  /// Partial specialization for pointer types.\n-  template<typename _PTp>\n-    struct __atomic_base<_PTp*>\n-    {\n-    private:\n-      typedef _PTp* \t__return_pointer_type;\n-      typedef void* \t__pointer_type;\n-      __pointer_type \t_M_i;\n-\n-    public:\n-      __atomic_base() noexcept = default;\n-      ~__atomic_base() noexcept = default;\n-      __atomic_base(const __atomic_base&) = delete;\n-      __atomic_base& operator=(const __atomic_base&) = delete;\n-      __atomic_base& operator=(const __atomic_base&) volatile = delete;\n-\n-      // Requires __pointer_type convertible to _M_i.\n-      constexpr __atomic_base(__return_pointer_type __p) noexcept\n-      : _M_i (__p) { }\n-\n-      operator __return_pointer_type() const noexcept\n-      { return reinterpret_cast<__return_pointer_type>(load()); }\n-\n-      operator __return_pointer_type() const volatile noexcept\n-      { return reinterpret_cast<__return_pointer_type>(load()); }\n-\n-      __return_pointer_type\n-      operator=(__pointer_type __p) noexcept\n-      {\n-\tstore(__p);\n-\treturn reinterpret_cast<__return_pointer_type>(__p);\n-      }\n-\n-      __return_pointer_type\n-      operator=(__pointer_type __p) volatile noexcept\n-      {\n-\tstore(__p);\n-\treturn reinterpret_cast<__return_pointer_type>(__p);\n-      }\n-\n-      __return_pointer_type\n-      operator++(int) noexcept\n-      { return reinterpret_cast<__return_pointer_type>(fetch_add(1)); }\n-\n-      __return_pointer_type\n-      operator++(int) volatile noexcept\n-      { return reinterpret_cast<__return_pointer_type>(fetch_add(1)); }\n-\n-      __return_pointer_type\n-      operator--(int) noexcept\n-      { return reinterpret_cast<__return_pointer_type>(fetch_sub(1)); }\n-\n-      __return_pointer_type\n-      operator--(int) volatile noexcept\n-      { return reinterpret_cast<__return_pointer_type>(fetch_sub(1)); }\n-\n-      __return_pointer_type\n-      operator++() noexcept\n-      { return reinterpret_cast<__return_pointer_type>(fetch_add(1) + 1); }\n-\n-      __return_pointer_type\n-      operator++() volatile noexcept\n-      { return reinterpret_cast<__return_pointer_type>(fetch_add(1) + 1); }\n-\n-      __return_pointer_type\n-      operator--() noexcept\n-      { return reinterpret_cast<__return_pointer_type>(fetch_sub(1) - 1); }\n-\n-      __return_pointer_type\n-      operator--() volatile noexcept\n-      { return reinterpret_cast<__return_pointer_type>(fetch_sub(1) - 1); }\n-\n-      __return_pointer_type\n-      operator+=(ptrdiff_t __d) noexcept\n-      { return reinterpret_cast<__return_pointer_type>(fetch_add(__d) + __d); }\n-\n-      __return_pointer_type\n-      operator+=(ptrdiff_t __d) volatile noexcept\n-      { return reinterpret_cast<__return_pointer_type>(fetch_add(__d) + __d); }\n-\n-      __return_pointer_type\n-      operator-=(ptrdiff_t __d) noexcept\n-      { return reinterpret_cast<__return_pointer_type>(fetch_sub(__d) - __d); }\n-\n-      __return_pointer_type\n-      operator-=(ptrdiff_t __d) volatile noexcept\n-      { return reinterpret_cast<__return_pointer_type>(fetch_sub(__d) - __d); }\n-\n-      bool\n-      is_lock_free() const noexcept\n-      { return true; }\n-\n-      bool\n-      is_lock_free() const volatile noexcept\n-      { return true; }\n-\n-      void\n-      store(__pointer_type __p,\n-\t    memory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_acquire);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\t__glibcxx_assert(__m != memory_order_consume);\n-\t_ATOMIC_STORE_(this, __p, __m);\n-      }\n-\n-      void\n-      store(__pointer_type __p,\n-\t    memory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_acquire);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\t__glibcxx_assert(__m != memory_order_consume);\n-\tvolatile __pointer_type* __p2 = &_M_i;\n-\t__typeof__(__p) __w = (__p);\n-\t__atomic_flag_base* __g = __atomic_flag_for_address(__p2);\n-\t__atomic_flag_wait_explicit(__g, __m);\n-\t*__p2 = reinterpret_cast<__pointer_type>(__w);\n-\tatomic_flag_clear_explicit(__g, __m);\n-\t__w;\n-      }\n-\n-      __return_pointer_type\n-      load(memory_order __m = memory_order_seq_cst) const noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_release);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\tvoid* __v = _ATOMIC_LOAD_(this, __m);\n-\treturn reinterpret_cast<__return_pointer_type>(__v);\n-      }\n-\n-      __return_pointer_type\n-      load(memory_order __m = memory_order_seq_cst) const volatile noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_release);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\tvoid* __v = _ATOMIC_LOAD_(this, __m);\n-\treturn reinterpret_cast<__return_pointer_type>(__v);\n-      }\n-\n-      __return_pointer_type\n-      exchange(__pointer_type __p,\n-\t       memory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\tvoid* __v = _ATOMIC_MODIFY_(this, =, __p, __m);\n-\treturn reinterpret_cast<__return_pointer_type>(__v);\n-      }\n-\n-      __return_pointer_type\n-      exchange(__pointer_type __p,\n-\t       memory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\tvolatile __pointer_type* __p2 = &_M_i;\n-\t__typeof__(__p) __w = (__p);\n-\t__atomic_flag_base* __g = __atomic_flag_for_address(__p2);\n-\t__atomic_flag_wait_explicit(__g, __m);\n-\t__pointer_type __r = *__p2;\n-\t*__p2 = __w;\n-\tatomic_flag_clear_explicit(__g, __m);\n-\t__r;\n-\treturn reinterpret_cast<__return_pointer_type>(_M_i);\n-      }\n-\n-      bool\n-      compare_exchange_strong(__return_pointer_type& __rp1, __pointer_type __p2,\n-\t\t\t      memory_order __m1, memory_order __m2) noexcept\n-      {\n-\t__glibcxx_assert(__m2 != memory_order_release);\n-\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n-\t__glibcxx_assert(__m2 <= __m1);\n-\t__pointer_type& __p1 = reinterpret_cast<void*&>(__rp1);\n-\treturn _ATOMIC_CMPEXCHNG_(this, &__p1, __p2, __m1);\n-      }\n-\n-      bool\n-      compare_exchange_strong(__return_pointer_type& __rp1, __pointer_type __p2,\n-\t\t\t      memory_order __m1,\n-\t\t\t      memory_order __m2) volatile noexcept\n-      {\n-\t__glibcxx_assert(__m2 != memory_order_release);\n-\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n-\t__glibcxx_assert(__m2 <= __m1);\n-\t__pointer_type& __p1 = reinterpret_cast<void*&>(__rp1);\n-\treturn _ATOMIC_CMPEXCHNG_(this, &__p1, __p2, __m1);\n-      }\n-\n-      __return_pointer_type\n-      fetch_add(ptrdiff_t __d,\n-\t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\tvoid* __v = _ATOMIC_MODIFY_(this, +=, __d, __m);\n-\treturn reinterpret_cast<__return_pointer_type>(__v);\n-      }\n-\n-      __return_pointer_type\n-      fetch_add(ptrdiff_t __d,\n-\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\tvoid* __v = _ATOMIC_MODIFY_(this, +=, __d, __m);\n-\treturn reinterpret_cast<__return_pointer_type>(__v);\n-      }\n-\n-      __return_pointer_type\n-      fetch_sub(ptrdiff_t __d,\n-\t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\tvoid* __v = _ATOMIC_MODIFY_(this, -=, __d, __m);\n-\treturn reinterpret_cast<__return_pointer_type>(__v);\n-      }\n-\n-      __return_pointer_type\n-      fetch_sub(ptrdiff_t __d,\n-\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\tvoid* __v = _ATOMIC_MODIFY_(this, -=, __d, __m);\n-\treturn reinterpret_cast<__return_pointer_type>(__v);\n-      }\n-    };\n-\n-#undef _ATOMIC_LOAD_\n-#undef _ATOMIC_STORE_\n-#undef _ATOMIC_MODIFY_\n-#undef _ATOMIC_CMPEXCHNG_\n-} // namespace __atomic0\n-\n-_GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace std\n-\n-#endif"}, {"sha": "072e82a0a9f6977aa587e65048dcdcb676401e07", "filename": "libstdc++-v3/include/bits/atomic_2.h", "status": "removed", "additions": 0, "deletions": 685, "changes": 685, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a058f6523f1e0f7b69ec1837848e55cf9f0856/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_2.h?ref=a8a058f6523f1e0f7b69ec1837848e55cf9f0856", "patch": "@@ -1,685 +0,0 @@\n-// -*- C++ -*- header.\n-\n-// Copyright (C) 2008, 2009, 2010, 2011\n-// Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file bits/atomic_2.h\n- *  This is an internal header file, included by other library headers.\n- *  Do not attempt to use it directly. @headername{atomic}\n- */\n-\n-#ifndef _GLIBCXX_ATOMIC_2_H\n-#define _GLIBCXX_ATOMIC_2_H 1\n-\n-#pragma GCC system_header\n-\n-namespace std _GLIBCXX_VISIBILITY(default)\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-// 2 == __atomic2 == Always lock-free\n-// Assumed:\n-// _GLIBCXX_ATOMIC_BUILTINS_1\n-// _GLIBCXX_ATOMIC_BUILTINS_2\n-// _GLIBCXX_ATOMIC_BUILTINS_4\n-// _GLIBCXX_ATOMIC_BUILTINS_8\n-namespace __atomic2\n-{\n-  /// atomic_flag\n-  struct atomic_flag : public __atomic_flag_base\n-  {\n-    atomic_flag() noexcept = default;\n-    ~atomic_flag() noexcept = default;\n-    atomic_flag(const atomic_flag&) = delete;\n-    atomic_flag& operator=(const atomic_flag&) = delete;\n-    atomic_flag& operator=(const atomic_flag&) volatile = delete;\n-\n-    // Conversion to ATOMIC_FLAG_INIT.\n-    atomic_flag(bool __i) noexcept : __atomic_flag_base({ __i }) { }\n-\n-    bool\n-    test_and_set(memory_order __m = memory_order_seq_cst) noexcept\n-    {\n-      // Redundant synchronize if built-in for lock is a full barrier.\n-      if (__m != memory_order_acquire && __m != memory_order_acq_rel)\n-\t__sync_synchronize();\n-      return __sync_lock_test_and_set(&_M_i, 1);\n-    }\n-\n-    bool\n-    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept\n-    {\n-      // Redundant synchronize if built-in for lock is a full barrier.\n-      if (__m != memory_order_acquire && __m != memory_order_acq_rel)\n-\t__sync_synchronize();\n-      return __sync_lock_test_and_set(&_M_i, 1);\n-    }\n-\n-    void\n-    clear(memory_order __m = memory_order_seq_cst) noexcept\n-    {\n-      __glibcxx_assert(__m != memory_order_consume);\n-      __glibcxx_assert(__m != memory_order_acquire);\n-      __glibcxx_assert(__m != memory_order_acq_rel);\n-\n-      __sync_lock_release(&_M_i);\n-      if (__m != memory_order_acquire && __m != memory_order_acq_rel)\n-\t__sync_synchronize();\n-    }\n-\n-    void\n-    clear(memory_order __m = memory_order_seq_cst) volatile noexcept\n-    {\n-      __glibcxx_assert(__m != memory_order_consume);\n-      __glibcxx_assert(__m != memory_order_acquire);\n-      __glibcxx_assert(__m != memory_order_acq_rel);\n-\n-      __sync_lock_release(&_M_i);\n-      if (__m != memory_order_acquire && __m != memory_order_acq_rel)\n-\t__sync_synchronize();\n-    }\n-  };\n-\n-\n-  /// Base class for atomic integrals.\n-  //\n-  // For each of the integral types, define atomic_[integral type] struct\n-  //\n-  // atomic_bool     bool\n-  // atomic_char     char\n-  // atomic_schar    signed char\n-  // atomic_uchar    unsigned char\n-  // atomic_short    short\n-  // atomic_ushort   unsigned short\n-  // atomic_int      int\n-  // atomic_uint     unsigned int\n-  // atomic_long     long\n-  // atomic_ulong    unsigned long\n-  // atomic_llong    long long\n-  // atomic_ullong   unsigned long long\n-  // atomic_char16_t char16_t\n-  // atomic_char32_t char32_t\n-  // atomic_wchar_t  wchar_t\n-  //\n-  // NB: Assuming _ITp is an integral scalar type that is 1, 2, 4, or\n-  // 8 bytes, since that is what GCC built-in functions for atomic\n-  // memory access expect.\n-  template<typename _ITp>\n-    struct __atomic_base\n-    {\n-    private:\n-      typedef _ITp \t__int_type;\n-\n-      __int_type \t_M_i;\n-\n-    public:\n-      __atomic_base() noexcept = default;\n-      ~__atomic_base() noexcept = default;\n-      __atomic_base(const __atomic_base&) = delete;\n-      __atomic_base& operator=(const __atomic_base&) = delete;\n-      __atomic_base& operator=(const __atomic_base&) volatile = delete;\n-\n-      // Requires __int_type convertible to _M_i.\n-      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }\n-\n-      operator __int_type() const noexcept\n-      { return load(); }\n-\n-      operator __int_type() const volatile noexcept\n-      { return load(); }\n-\n-      __int_type\n-      operator=(__int_type __i) noexcept\n-      {\n-\tstore(__i);\n-\treturn __i;\n-      }\n-\n-      __int_type\n-      operator=(__int_type __i) volatile noexcept\n-      {\n-\tstore(__i);\n-\treturn __i;\n-      }\n-\n-      __int_type\n-      operator++(int) noexcept\n-      { return fetch_add(1); }\n-\n-      __int_type\n-      operator++(int) volatile noexcept\n-      { return fetch_add(1); }\n-\n-      __int_type\n-      operator--(int) noexcept\n-      { return fetch_sub(1); }\n-\n-      __int_type\n-      operator--(int) volatile noexcept\n-      { return fetch_sub(1); }\n-\n-      __int_type\n-      operator++() noexcept\n-      { return __sync_add_and_fetch(&_M_i, 1); }\n-\n-      __int_type\n-      operator++() volatile noexcept\n-      { return __sync_add_and_fetch(&_M_i, 1); }\n-\n-      __int_type\n-      operator--() noexcept\n-      { return __sync_sub_and_fetch(&_M_i, 1); }\n-\n-      __int_type\n-      operator--() volatile noexcept\n-      { return __sync_sub_and_fetch(&_M_i, 1); }\n-\n-      __int_type\n-      operator+=(__int_type __i) noexcept\n-      { return __sync_add_and_fetch(&_M_i, __i); }\n-\n-      __int_type\n-      operator+=(__int_type __i) volatile noexcept\n-      { return __sync_add_and_fetch(&_M_i, __i); }\n-\n-      __int_type\n-      operator-=(__int_type __i) noexcept\n-      { return __sync_sub_and_fetch(&_M_i, __i); }\n-\n-      __int_type\n-      operator-=(__int_type __i) volatile noexcept\n-      { return __sync_sub_and_fetch(&_M_i, __i); }\n-\n-      __int_type\n-      operator&=(__int_type __i) noexcept\n-      { return __sync_and_and_fetch(&_M_i, __i); }\n-\n-      __int_type\n-      operator&=(__int_type __i) volatile noexcept\n-      { return __sync_and_and_fetch(&_M_i, __i); }\n-\n-      __int_type\n-      operator|=(__int_type __i) noexcept\n-      { return __sync_or_and_fetch(&_M_i, __i); }\n-\n-      __int_type\n-      operator|=(__int_type __i) volatile noexcept\n-      { return __sync_or_and_fetch(&_M_i, __i); }\n-\n-      __int_type\n-      operator^=(__int_type __i) noexcept\n-      { return __sync_xor_and_fetch(&_M_i, __i); }\n-\n-      __int_type\n-      operator^=(__int_type __i) volatile noexcept\n-      { return __sync_xor_and_fetch(&_M_i, __i); }\n-\n-      bool\n-      is_lock_free() const noexcept\n-      { return true; }\n-\n-      bool\n-      is_lock_free() const volatile noexcept\n-      { return true; }\n-\n-      void\n-      store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_acquire);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\t__glibcxx_assert(__m != memory_order_consume);\n-\n-\tif (__m == memory_order_relaxed)\n-\t  _M_i = __i;\n-\telse\n-\t  {\n-\t    // write_mem_barrier();\n-\t    _M_i = __i;\n-\t    if (__m == memory_order_seq_cst)\n-\t      __sync_synchronize();\n-\t  }\n-      }\n-\n-      void\n-      store(__int_type __i,\n-\t    memory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_acquire);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\t__glibcxx_assert(__m != memory_order_consume);\n-\n-\tif (__m == memory_order_relaxed)\n-\t  _M_i = __i;\n-\telse\n-\t  {\n-\t    // write_mem_barrier();\n-\t    _M_i = __i;\n-\t    if (__m == memory_order_seq_cst)\n-\t      __sync_synchronize();\n-\t  }\n-      }\n-\n-      __int_type\n-      load(memory_order __m = memory_order_seq_cst) const noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_release);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\n-\t__sync_synchronize();\n-\t__int_type __ret = _M_i;\n-\t__sync_synchronize();\n-\treturn __ret;\n-      }\n-\n-      __int_type\n-      load(memory_order __m = memory_order_seq_cst) const volatile noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_release);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\n-\t__sync_synchronize();\n-\t__int_type __ret = _M_i;\n-\t__sync_synchronize();\n-\treturn __ret;\n-      }\n-\n-      __int_type\n-      exchange(__int_type __i,\n-\t       memory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\t// XXX built-in assumes memory_order_acquire.\n-\treturn __sync_lock_test_and_set(&_M_i, __i);\n-      }\n-\n-\n-      __int_type\n-      exchange(__int_type __i,\n-\t       memory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\t// XXX built-in assumes memory_order_acquire.\n-\treturn __sync_lock_test_and_set(&_M_i, __i);\n-      }\n-\n-      bool\n-      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n-\t\t\t    memory_order __m1, memory_order __m2) noexcept\n-      { return compare_exchange_strong(__i1, __i2, __m1, __m2); }\n-\n-      bool\n-      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n-\t\t\t    memory_order __m1,\n-\t\t\t    memory_order __m2) volatile noexcept\n-      { return compare_exchange_strong(__i1, __i2, __m1, __m2); }\n-\n-      bool\n-      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n-\t\t\t    memory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\treturn compare_exchange_weak(__i1, __i2, __m,\n-\t\t\t\t     __calculate_memory_order(__m));\n-      }\n-\n-      bool\n-      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n-\t\t   memory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\treturn compare_exchange_weak(__i1, __i2, __m,\n-\t\t\t\t     __calculate_memory_order(__m));\n-      }\n-\n-      bool\n-      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n-\t\t\t      memory_order __m1, memory_order __m2) noexcept\n-      {\n-\t__glibcxx_assert(__m2 != memory_order_release);\n-\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n-\t__glibcxx_assert(__m2 <= __m1);\n-\n-\t__int_type __i1o = __i1;\n-\t__int_type __i1n = __sync_val_compare_and_swap(&_M_i, __i1o, __i2);\n-\n-\t// Assume extra stores (of same value) allowed in true case.\n-\t__i1 = __i1n;\n-\treturn __i1o == __i1n;\n-      }\n-\n-      bool\n-      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n-\t\t\t      memory_order __m1,\n-\t\t\t      memory_order __m2) volatile noexcept\n-      {\n-\t__glibcxx_assert(__m2 != memory_order_release);\n-\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n-\t__glibcxx_assert(__m2 <= __m1);\n-\n-\t__int_type __i1o = __i1;\n-\t__int_type __i1n = __sync_val_compare_and_swap(&_M_i, __i1o, __i2);\n-\n-\t// Assume extra stores (of same value) allowed in true case.\n-\t__i1 = __i1n;\n-\treturn __i1o == __i1n;\n-      }\n-\n-      bool\n-      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n-\t\t\t      memory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\treturn compare_exchange_strong(__i1, __i2, __m,\n-\t\t\t\t       __calculate_memory_order(__m));\n-      }\n-\n-      bool\n-      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n-\t\t memory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\treturn compare_exchange_strong(__i1, __i2, __m,\n-\t\t\t\t       __calculate_memory_order(__m));\n-      }\n-\n-      __int_type\n-      fetch_add(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return __sync_fetch_and_add(&_M_i, __i); }\n-\n-      __int_type\n-      fetch_add(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __sync_fetch_and_add(&_M_i, __i); }\n-\n-      __int_type\n-      fetch_sub(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return __sync_fetch_and_sub(&_M_i, __i); }\n-\n-      __int_type\n-      fetch_sub(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __sync_fetch_and_sub(&_M_i, __i); }\n-\n-      __int_type\n-      fetch_and(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return __sync_fetch_and_and(&_M_i, __i); }\n-\n-      __int_type\n-      fetch_and(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __sync_fetch_and_and(&_M_i, __i); }\n-\n-      __int_type\n-      fetch_or(__int_type __i,\n-\t       memory_order __m = memory_order_seq_cst) noexcept\n-      { return __sync_fetch_and_or(&_M_i, __i); }\n-\n-      __int_type\n-      fetch_or(__int_type __i,\n-\t       memory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __sync_fetch_and_or(&_M_i, __i); }\n-\n-      __int_type\n-      fetch_xor(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return __sync_fetch_and_xor(&_M_i, __i); }\n-\n-      __int_type\n-      fetch_xor(__int_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __sync_fetch_and_xor(&_M_i, __i); }\n-    };\n-\n-\n-  /// Partial specialization for pointer types.\n-  template<typename _PTp>\n-    struct __atomic_base<_PTp*>\n-    {\n-    private:\n-      typedef _PTp* \t__pointer_type;\n-\n-      __pointer_type \t_M_p;\n-\n-    public:\n-      __atomic_base() noexcept = default;\n-      ~__atomic_base() noexcept = default;\n-      __atomic_base(const __atomic_base&) = delete;\n-      __atomic_base& operator=(const __atomic_base&) = delete;\n-      __atomic_base& operator=(const __atomic_base&) volatile = delete;\n-\n-      // Requires __pointer_type convertible to _M_p.\n-      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }\n-\n-      operator __pointer_type() const noexcept\n-      { return load(); }\n-\n-      operator __pointer_type() const volatile noexcept\n-      { return load(); }\n-\n-      __pointer_type\n-      operator=(__pointer_type __p) noexcept\n-      {\n-\tstore(__p);\n-\treturn __p;\n-      }\n-\n-      __pointer_type\n-      operator=(__pointer_type __p) volatile noexcept\n-      {\n-\tstore(__p);\n-\treturn __p;\n-      }\n-\n-      __pointer_type\n-      operator++(int) noexcept\n-      { return fetch_add(1); }\n-\n-      __pointer_type\n-      operator++(int) volatile noexcept\n-      { return fetch_add(1); }\n-\n-      __pointer_type\n-      operator--(int) noexcept\n-      { return fetch_sub(1); }\n-\n-      __pointer_type\n-      operator--(int) volatile noexcept\n-      { return fetch_sub(1); }\n-\n-      __pointer_type\n-      operator++() noexcept\n-      { return fetch_add(1) + 1; }\n-\n-      __pointer_type\n-      operator++() volatile noexcept\n-      { return fetch_add(1) + 1; }\n-\n-      __pointer_type\n-      operator--() noexcept\n-      { return fetch_sub(1) -1; }\n-\n-      __pointer_type\n-      operator--() volatile noexcept\n-      { return fetch_sub(1) -1; }\n-\n-      __pointer_type\n-      operator+=(ptrdiff_t __d) noexcept\n-      { return fetch_add(__d) + __d; }\n-\n-      __pointer_type\n-      operator+=(ptrdiff_t __d) volatile noexcept\n-      { return fetch_add(__d) + __d; }\n-\n-      __pointer_type\n-      operator-=(ptrdiff_t __d) noexcept\n-      { return fetch_sub(__d) - __d; }\n-\n-      __pointer_type\n-      operator-=(ptrdiff_t __d) volatile noexcept\n-      { return fetch_sub(__d) - __d; }\n-\n-      bool\n-      is_lock_free() const noexcept\n-      { return true; }\n-\n-      bool\n-      is_lock_free() const volatile noexcept\n-      { return true; }\n-\n-      void\n-      store(__pointer_type __p,\n-\t    memory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_acquire);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\t__glibcxx_assert(__m != memory_order_consume);\n-\n-\tif (__m == memory_order_relaxed)\n-\t  _M_p = __p;\n-\telse\n-\t  {\n-\t    // write_mem_barrier();\n-\t    _M_p = __p;\n-\t    if (__m == memory_order_seq_cst)\n-\t      __sync_synchronize();\n-\t  }\n-      }\n-\n-      void\n-      store(__pointer_type __p,\n-\t    memory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_acquire);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\t__glibcxx_assert(__m != memory_order_consume);\n-\n-\tif (__m == memory_order_relaxed)\n-\t  _M_p = __p;\n-\telse\n-\t  {\n-\t    // write_mem_barrier();\n-\t    _M_p = __p;\n-\t    if (__m == memory_order_seq_cst)\n-\t      __sync_synchronize();\n-\t  }\n-      }\n-\n-      __pointer_type\n-      load(memory_order __m = memory_order_seq_cst) const noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_release);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\n-\t__sync_synchronize();\n-\t__pointer_type __ret = _M_p;\n-\t__sync_synchronize();\n-\treturn __ret;\n-      }\n-\n-      __pointer_type\n-      load(memory_order __m = memory_order_seq_cst) const volatile noexcept\n-      {\n-\t__glibcxx_assert(__m != memory_order_release);\n-\t__glibcxx_assert(__m != memory_order_acq_rel);\n-\n-\t__sync_synchronize();\n-\t__pointer_type __ret = _M_p;\n-\t__sync_synchronize();\n-\treturn __ret;\n-      }\n-\n-      __pointer_type\n-      exchange(__pointer_type __p,\n-\t       memory_order __m = memory_order_seq_cst) noexcept\n-      {\n-\t// XXX built-in assumes memory_order_acquire.\n-\treturn __sync_lock_test_and_set(&_M_p, __p);\n-      }\n-\n-\n-      __pointer_type\n-      exchange(__pointer_type __p,\n-\t       memory_order __m = memory_order_seq_cst) volatile noexcept\n-      {\n-\t// XXX built-in assumes memory_order_acquire.\n-\treturn __sync_lock_test_and_set(&_M_p, __p);\n-      }\n-\n-      bool\n-      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,\n-\t\t\t      memory_order __m1,\n-\t\t\t      memory_order __m2) noexcept\n-      {\n-\t__glibcxx_assert(__m2 != memory_order_release);\n-\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n-\t__glibcxx_assert(__m2 <= __m1);\n-\n-\t__pointer_type __p1o = __p1;\n-\t__pointer_type __p1n = __sync_val_compare_and_swap(&_M_p, __p1o, __p2);\n-\n-\t// Assume extra stores (of same value) allowed in true case.\n-\t__p1 = __p1n;\n-\treturn __p1o == __p1n;\n-      }\n-\n-      bool\n-      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,\n-\t\t\t      memory_order __m1,\n-\t\t\t      memory_order __m2) volatile noexcept\n-      {\n-\t__glibcxx_assert(__m2 != memory_order_release);\n-\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n-\t__glibcxx_assert(__m2 <= __m1);\n-\n-\t__pointer_type __p1o = __p1;\n-\t__pointer_type __p1n = __sync_val_compare_and_swap(&_M_p, __p1o, __p2);\n-\n-\t// Assume extra stores (of same value) allowed in true case.\n-\t__p1 = __p1n;\n-\treturn __p1o == __p1n;\n-      }\n-\n-      __pointer_type\n-      fetch_add(ptrdiff_t __d,\n-\t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return __sync_fetch_and_add(&_M_p, __d); }\n-\n-      __pointer_type\n-      fetch_add(ptrdiff_t __d,\n-\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __sync_fetch_and_add(&_M_p, __d); }\n-\n-      __pointer_type\n-      fetch_sub(ptrdiff_t __d,\n-\t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return __sync_fetch_and_sub(&_M_p, __d); }\n-\n-      __pointer_type\n-      fetch_sub(ptrdiff_t __d,\n-\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __sync_fetch_and_sub(&_M_p, __d); }\n-    };\n-\n-} // namespace __atomic2\n-\n-_GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace std\n-\n-#endif"}, {"sha": "2e4a6a1894a9689b0d144e69dcae89d28cc0470a", "filename": "libstdc++-v3/include/bits/atomic_base.h", "status": "modified", "additions": 600, "deletions": 75, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -83,86 +83,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __ret;\n     }\n \n-  /**\n-   *  @brief Base type for atomic_flag.\n-   *\n-   *  Base type is POD with data, allowing atomic_flag to derive from\n-   *  it and meet the standard layout type requirement. In addition to\n-   *  compatibilty with a C interface, this allows different\n-   *  implementations of atomic_flag to use the same atomic operation\n-   *  functions, via a standard conversion to the __atomic_flag_base\n-   *  argument.\n-  */\n-  _GLIBCXX_BEGIN_EXTERN_C\n+  /// Lock-free Property\n \n-  struct __atomic_flag_base\n-  {\n-    bool _M_i;\n-  };\n+#define LOCKFREE_PROP(T) (__atomic_always_lock_free (sizeof (T), 0) ? 2 : 1)\n \n-  _GLIBCXX_END_EXTERN_C\n-\n-#define ATOMIC_FLAG_INIT { false }\n+#define ATOMIC_CHAR_LOCK_FREE \t\tLOCKFREE_PROP (char)\n+#define ATOMIC_CHAR16_T_LOCK_FREE\tLOCKFREE_PROP (char16_t)\n+#define ATOMIC_CHAR32_T_LOCK_FREE\tLOCKFREE_PROP (char32_t)\n+#define ATOMIC_WCHAR_T_LOCK_FREE\tLOCKFREE_PROP (wchar_t)\n+#define ATOMIC_SHORT_LOCK_FREE\t\tLOCKFREE_PROP (short)\n+#define ATOMIC_INT_LOCK_FREE\t\tLOCKFREE_PROP (int)\n+#define ATOMIC_LONG_LOCK_FREE\t\tLOCKFREE_PROP (long)\n+#define ATOMIC_LLONG_LOCK_FREE\t\tLOCKFREE_PROP (long long)\n \n \n   // Base types for atomics.\n-  //\n-  // Three nested namespaces for atomic implementation details.\n-  //\n-  // The nested namespace inlined into std:: is determined by the value\n-  // of the _GLIBCXX_ATOMIC_PROPERTY macro and the resulting\n-  // ATOMIC_*_LOCK_FREE macros.\n-  //\n-  // 0 == __atomic0 == Never lock-free\n-  // 1 == __atomic1 == Best available, sometimes lock-free\n-  // 2 == __atomic2 == Always lock-free\n-\n-  namespace __atomic0\n-  {\n-    struct atomic_flag;\n-\n-    template<typename _IntTp>\n-      struct __atomic_base;\n-  }\n-\n-  namespace __atomic2\n-  {\n-    struct atomic_flag;\n-\n-    template<typename _IntTp>\n-      struct __atomic_base;\n-  }\n-\n-  namespace __atomic1\n-  {\n-    using __atomic2::atomic_flag;\n-    using __atomic0::__atomic_base;\n-  }\n-\n-  /// Lock-free Property\n-#if defined(_GLIBCXX_ATOMIC_BUILTINS_1) && defined(_GLIBCXX_ATOMIC_BUILTINS_2) \\\n-  && defined(_GLIBCXX_ATOMIC_BUILTINS_4) && defined(_GLIBCXX_ATOMIC_BUILTINS_8)\n-# define _GLIBCXX_ATOMIC_PROPERTY 2\n-# define _GLIBCXX_ATOMIC_NAMESPACE __atomic2\n-#elif defined(_GLIBCXX_ATOMIC_BUILTINS_1)\n-# define _GLIBCXX_ATOMIC_PROPERTY 1\n-# define _GLIBCXX_ATOMIC_NAMESPACE __atomic1\n-#else\n-# define _GLIBCXX_ATOMIC_PROPERTY 0\n-# define _GLIBCXX_ATOMIC_NAMESPACE __atomic0\n-#endif\n-\n-#define ATOMIC_CHAR_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n-#define ATOMIC_CHAR16_T_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n-#define ATOMIC_CHAR32_T_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n-#define ATOMIC_WCHAR_T_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n-#define ATOMIC_SHORT_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n-#define ATOMIC_INT_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n-#define ATOMIC_LONG_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n-#define ATOMIC_LLONG_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n-\n-  inline namespace _GLIBCXX_ATOMIC_NAMESPACE { }\n-\n+  template<typename _IntTp>\n+    struct __atomic_base;\n \n   /// atomic_char\n   typedef __atomic_base<char>  \t       \t\tatomic_char;\n@@ -287,6 +224,594 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     struct atomic<_Tp*>;\n \n+\n+  /**\n+   *  @brief Base type for atomic_flag.\n+   *\n+   *  Base type is POD with data, allowing atomic_flag to derive from\n+   *  it and meet the standard layout type requirement. In addition to\n+   *  compatibilty with a C interface, this allows different\n+   *  implementations of atomic_flag to use the same atomic operation\n+   *  functions, via a standard conversion to the __atomic_flag_base\n+   *  argument.\n+  */\n+  _GLIBCXX_BEGIN_EXTERN_C\n+\n+  struct __atomic_flag_base\n+  {\n+    bool _M_i;\n+  };\n+\n+  _GLIBCXX_END_EXTERN_C\n+\n+#define ATOMIC_FLAG_INIT { false }\n+\n+  /// atomic_flag\n+  struct atomic_flag : public __atomic_flag_base\n+  {\n+    atomic_flag() noexcept = default;\n+    ~atomic_flag() noexcept = default;\n+    atomic_flag(const atomic_flag&) = delete;\n+    atomic_flag& operator=(const atomic_flag&) = delete;\n+    atomic_flag& operator=(const atomic_flag&) volatile = delete;\n+\n+    // Conversion to ATOMIC_FLAG_INIT.\n+    atomic_flag(bool __i) noexcept : __atomic_flag_base({ __i }) { }\n+\n+    bool\n+    test_and_set(memory_order __m = memory_order_seq_cst) noexcept\n+    {\n+      return __atomic_exchange_n(&_M_i, 1, __m);\n+    }\n+\n+    bool\n+    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept\n+    {\n+      return __atomic_exchange_n(&_M_i, 1, __m);\n+    }\n+\n+    void\n+    clear(memory_order __m = memory_order_seq_cst) noexcept\n+    {\n+      __glibcxx_assert(__m != memory_order_consume);\n+      __glibcxx_assert(__m != memory_order_acquire);\n+      __glibcxx_assert(__m != memory_order_acq_rel);\n+\n+      __atomic_store_n(&_M_i, 0, __m);\n+    }\n+\n+    void\n+    clear(memory_order __m = memory_order_seq_cst) volatile noexcept\n+    {\n+      __glibcxx_assert(__m != memory_order_consume);\n+      __glibcxx_assert(__m != memory_order_acquire);\n+      __glibcxx_assert(__m != memory_order_acq_rel);\n+\n+      __atomic_store_n(&_M_i, 0, __m);\n+    }\n+  };\n+\n+\n+  /// Base class for atomic integrals.\n+  //\n+  // For each of the integral types, define atomic_[integral type] struct\n+  //\n+  // atomic_bool     bool\n+  // atomic_char     char\n+  // atomic_schar    signed char\n+  // atomic_uchar    unsigned char\n+  // atomic_short    short\n+  // atomic_ushort   unsigned short\n+  // atomic_int      int\n+  // atomic_uint     unsigned int\n+  // atomic_long     long\n+  // atomic_ulong    unsigned long\n+  // atomic_llong    long long\n+  // atomic_ullong   unsigned long long\n+  // atomic_char16_t char16_t\n+  // atomic_char32_t char32_t\n+  // atomic_wchar_t  wchar_t\n+  //\n+  // NB: Assuming _ITp is an integral scalar type that is 1, 2, 4, or\n+  // 8 bytes, since that is what GCC built-in functions for atomic\n+  // memory access expect.\n+  template<typename _ITp>\n+    struct __atomic_base\n+    {\n+    private:\n+      typedef _ITp \t__int_type;\n+\n+      __int_type \t_M_i;\n+\n+    public:\n+      __atomic_base() noexcept = default;\n+      ~__atomic_base() noexcept = default;\n+      __atomic_base(const __atomic_base&) = delete;\n+      __atomic_base& operator=(const __atomic_base&) = delete;\n+      __atomic_base& operator=(const __atomic_base&) volatile = delete;\n+\n+      // Requires __int_type convertible to _M_i.\n+      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }\n+\n+      operator __int_type() const noexcept\n+      { return load(); }\n+\n+      operator __int_type() const volatile noexcept\n+      { return load(); }\n+\n+      __int_type\n+      operator=(__int_type __i) noexcept\n+      {\n+\tstore(__i);\n+\treturn __i;\n+      }\n+\n+      __int_type\n+      operator=(__int_type __i) volatile noexcept\n+      {\n+\tstore(__i);\n+\treturn __i;\n+      }\n+\n+      __int_type\n+      operator++(int) noexcept\n+      { return fetch_add(1); }\n+\n+      __int_type\n+      operator++(int) volatile noexcept\n+      { return fetch_add(1); }\n+\n+      __int_type\n+      operator--(int) noexcept\n+      { return fetch_sub(1); }\n+\n+      __int_type\n+      operator--(int) volatile noexcept\n+      { return fetch_sub(1); }\n+\n+      __int_type\n+      operator++() noexcept\n+      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator++() volatile noexcept\n+      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator--() noexcept\n+      { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator--() volatile noexcept\n+      { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator+=(__int_type __i) noexcept\n+      { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator+=(__int_type __i) volatile noexcept\n+      { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator-=(__int_type __i) noexcept\n+      { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator-=(__int_type __i) volatile noexcept\n+      { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator&=(__int_type __i) noexcept\n+      { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator&=(__int_type __i) volatile noexcept\n+      { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator|=(__int_type __i) noexcept\n+      { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator|=(__int_type __i) volatile noexcept\n+      { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator^=(__int_type __i) noexcept\n+      { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }\n+\n+      __int_type\n+      operator^=(__int_type __i) volatile noexcept\n+      { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }\n+\n+      bool\n+      is_lock_free() const noexcept\n+      { return __atomic_is_lock_free (sizeof (_M_i), &_M_i); }\n+\n+      bool\n+      is_lock_free() const volatile noexcept\n+      { return __atomic_is_lock_free (sizeof (_M_i), &_M_i); }\n+\n+      void\n+      store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept\n+      {\n+\t__glibcxx_assert(__m != memory_order_acquire);\n+\t__glibcxx_assert(__m != memory_order_acq_rel);\n+\t__glibcxx_assert(__m != memory_order_consume);\n+\n+\t__atomic_store_n(&_M_i, __i, __m);\n+      }\n+\n+      void\n+      store(__int_type __i,\n+\t    memory_order __m = memory_order_seq_cst) volatile noexcept\n+      {\n+\t__glibcxx_assert(__m != memory_order_acquire);\n+\t__glibcxx_assert(__m != memory_order_acq_rel);\n+\t__glibcxx_assert(__m != memory_order_consume);\n+\n+\t__atomic_store_n(&_M_i, __i, __m);\n+      }\n+\n+      __int_type\n+      load(memory_order __m = memory_order_seq_cst) const noexcept\n+      {\n+\t__glibcxx_assert(__m != memory_order_release);\n+\t__glibcxx_assert(__m != memory_order_acq_rel);\n+\n+\treturn __atomic_load_n(&_M_i, __m);\n+      }\n+\n+      __int_type\n+      load(memory_order __m = memory_order_seq_cst) const volatile noexcept\n+      {\n+\t__glibcxx_assert(__m != memory_order_release);\n+\t__glibcxx_assert(__m != memory_order_acq_rel);\n+\n+\treturn __atomic_load_n(&_M_i, __m);\n+      }\n+\n+      __int_type\n+      exchange(__int_type __i,\n+\t       memory_order __m = memory_order_seq_cst) noexcept\n+      {\n+\treturn __atomic_exchange_n(&_M_i, __i, __m);\n+      }\n+\n+\n+      __int_type\n+      exchange(__int_type __i,\n+\t       memory_order __m = memory_order_seq_cst) volatile noexcept\n+      {\n+\treturn __atomic_exchange_n(&_M_i, __i, __m);\n+      }\n+\n+      bool\n+      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n+\t\t\t    memory_order __m1, memory_order __m2) noexcept\n+      {\n+\t__glibcxx_assert(__m2 != memory_order_release);\n+\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n+\t__glibcxx_assert(__m2 <= __m1);\n+\n+\treturn __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);\n+      }\n+\n+      bool\n+      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n+\t\t\t    memory_order __m1,\n+\t\t\t    memory_order __m2) volatile noexcept\n+      {\n+\t__glibcxx_assert(__m2 != memory_order_release);\n+\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n+\t__glibcxx_assert(__m2 <= __m1);\n+\n+\treturn __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);\n+      }\n+\n+      bool\n+      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n+\t\t\t    memory_order __m = memory_order_seq_cst) noexcept\n+      {\n+\treturn compare_exchange_weak(__i1, __i2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+      }\n+\n+      bool\n+      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n+\t\t   memory_order __m = memory_order_seq_cst) volatile noexcept\n+      {\n+\treturn compare_exchange_weak(__i1, __i2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+      }\n+\n+      bool\n+      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n+\t\t\t      memory_order __m1, memory_order __m2) noexcept\n+      {\n+\t__glibcxx_assert(__m2 != memory_order_release);\n+\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n+\t__glibcxx_assert(__m2 <= __m1);\n+\n+\treturn __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);\n+      }\n+\n+      bool\n+      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n+\t\t\t      memory_order __m1,\n+\t\t\t      memory_order __m2) volatile noexcept\n+      {\n+\t__glibcxx_assert(__m2 != memory_order_release);\n+\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n+\t__glibcxx_assert(__m2 <= __m1);\n+\n+\treturn __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);\n+      }\n+\n+      bool\n+      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n+\t\t\t      memory_order __m = memory_order_seq_cst) noexcept\n+      {\n+\treturn compare_exchange_strong(__i1, __i2, __m,\n+\t\t\t\t       __calculate_memory_order(__m));\n+      }\n+\n+      bool\n+      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n+\t\t memory_order __m = memory_order_seq_cst) volatile noexcept\n+      {\n+\treturn compare_exchange_strong(__i1, __i2, __m,\n+\t\t\t\t       __calculate_memory_order(__m));\n+      }\n+\n+      __int_type\n+      fetch_add(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) noexcept\n+      { return __atomic_fetch_add(&_M_i, __i, __m); }\n+\n+      __int_type\n+      fetch_add(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n+      { return __atomic_fetch_add(&_M_i, __i, __m); }\n+\n+      __int_type\n+      fetch_sub(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) noexcept\n+      { return __atomic_fetch_sub(&_M_i, __i, __m); }\n+\n+      __int_type\n+      fetch_sub(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n+      { return __atomic_fetch_sub(&_M_i, __i, __m); }\n+\n+      __int_type\n+      fetch_and(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) noexcept\n+      { return __atomic_fetch_and(&_M_i, __i, __m); }\n+\n+      __int_type\n+      fetch_and(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n+      { return __atomic_fetch_and(&_M_i, __i, __m); }\n+\n+      __int_type\n+      fetch_or(__int_type __i,\n+\t       memory_order __m = memory_order_seq_cst) noexcept\n+      { return __atomic_fetch_or(&_M_i, __i, __m); }\n+\n+      __int_type\n+      fetch_or(__int_type __i,\n+\t       memory_order __m = memory_order_seq_cst) volatile noexcept\n+      { return __atomic_fetch_or(&_M_i, __i, __m); }\n+\n+      __int_type\n+      fetch_xor(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) noexcept\n+      { return __atomic_fetch_xor(&_M_i, __i, __m); }\n+\n+      __int_type\n+      fetch_xor(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n+      { return __atomic_fetch_xor(&_M_i, __i, __m); }\n+    };\n+\n+\n+  /// Partial specialization for pointer types.\n+  template<typename _PTp>\n+    struct __atomic_base<_PTp*>\n+    {\n+    private:\n+      typedef _PTp* \t__pointer_type;\n+\n+      __pointer_type \t_M_p;\n+\n+    public:\n+      __atomic_base() noexcept = default;\n+      ~__atomic_base() noexcept = default;\n+      __atomic_base(const __atomic_base&) = delete;\n+      __atomic_base& operator=(const __atomic_base&) = delete;\n+      __atomic_base& operator=(const __atomic_base&) volatile = delete;\n+\n+      // Requires __pointer_type convertible to _M_p.\n+      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }\n+\n+      operator __pointer_type() const noexcept\n+      { return load(); }\n+\n+      operator __pointer_type() const volatile noexcept\n+      { return load(); }\n+\n+      __pointer_type\n+      operator=(__pointer_type __p) noexcept\n+      {\n+\tstore(__p);\n+\treturn __p;\n+      }\n+\n+      __pointer_type\n+      operator=(__pointer_type __p) volatile noexcept\n+      {\n+\tstore(__p);\n+\treturn __p;\n+      }\n+\n+      __pointer_type\n+      operator++(int) noexcept\n+      { return fetch_add(1); }\n+\n+      __pointer_type\n+      operator++(int) volatile noexcept\n+      { return fetch_add(1); }\n+\n+      __pointer_type\n+      operator--(int) noexcept\n+      { return fetch_sub(1); }\n+\n+      __pointer_type\n+      operator--(int) volatile noexcept\n+      { return fetch_sub(1); }\n+\n+      __pointer_type\n+      operator++() noexcept\n+      { return __atomic_add_fetch(&_M_p, 1, memory_order_seq_cst); }\n+\n+      __pointer_type\n+      operator++() volatile noexcept\n+      { return __atomic_add_fetch(&_M_p, 1, memory_order_seq_cst); }\n+\n+      __pointer_type\n+      operator--() noexcept\n+      { return __atomic_sub_fetch(&_M_p, 1, memory_order_seq_cst); }\n+\n+      __pointer_type\n+      operator--() volatile noexcept\n+      { return __atomic_sub_fetch(&_M_p, 1, memory_order_seq_cst); }\n+\n+      __pointer_type\n+      operator+=(ptrdiff_t __d) noexcept\n+      { return __atomic_add_fetch(&_M_p, __d, memory_order_seq_cst); }\n+\n+      __pointer_type\n+      operator+=(ptrdiff_t __d) volatile noexcept\n+      { return __atomic_add_fetch(&_M_p, __d, memory_order_seq_cst); }\n+\n+      __pointer_type\n+      operator-=(ptrdiff_t __d) noexcept\n+      { return __atomic_sub_fetch(&_M_p, __d, memory_order_seq_cst); }\n+\n+      __pointer_type\n+      operator-=(ptrdiff_t __d) volatile noexcept\n+      { return __atomic_sub_fetch(&_M_p, __d, memory_order_seq_cst); }\n+\n+      bool\n+      is_lock_free() const noexcept\n+      { return __atomic_is_lock_free (sizeof (_M_p), &_M_p); }\n+\n+      bool\n+      is_lock_free() const volatile noexcept\n+      { return __atomic_is_lock_free (sizeof (_M_p), &_M_p); }\n+\n+      void\n+      store(__pointer_type __p,\n+\t    memory_order __m = memory_order_seq_cst) noexcept\n+      {\n+\t__glibcxx_assert(__m != memory_order_acquire);\n+\t__glibcxx_assert(__m != memory_order_acq_rel);\n+\t__glibcxx_assert(__m != memory_order_consume);\n+\n+\t__atomic_store_n(&_M_p, __p, __m);\n+      }\n+\n+      void\n+      store(__pointer_type __p,\n+\t    memory_order __m = memory_order_seq_cst) volatile noexcept\n+      {\n+\t__glibcxx_assert(__m != memory_order_acquire);\n+\t__glibcxx_assert(__m != memory_order_acq_rel);\n+\t__glibcxx_assert(__m != memory_order_consume);\n+\n+\t__atomic_store_n(&_M_p, __p, __m);\n+      }\n+\n+      __pointer_type\n+      load(memory_order __m = memory_order_seq_cst) const noexcept\n+      {\n+\t__glibcxx_assert(__m != memory_order_release);\n+\t__glibcxx_assert(__m != memory_order_acq_rel);\n+\n+\treturn __atomic_load_n(&_M_p, __m);\n+      }\n+\n+      __pointer_type\n+      load(memory_order __m = memory_order_seq_cst) const volatile noexcept\n+      {\n+\t__glibcxx_assert(__m != memory_order_release);\n+\t__glibcxx_assert(__m != memory_order_acq_rel);\n+\n+\treturn __atomic_load_n(&_M_p, __m);\n+      }\n+\n+      __pointer_type\n+      exchange(__pointer_type __p,\n+\t       memory_order __m = memory_order_seq_cst) noexcept\n+      {\n+\treturn __atomic_exchange_n(&_M_p, __p, __m);\n+      }\n+\n+\n+      __pointer_type\n+      exchange(__pointer_type __p,\n+\t       memory_order __m = memory_order_seq_cst) volatile noexcept\n+      {\n+\treturn __atomic_exchange_n(&_M_p, __p, __m);\n+      }\n+\n+      bool\n+      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,\n+\t\t\t      memory_order __m1,\n+\t\t\t      memory_order __m2) noexcept\n+      {\n+\t__glibcxx_assert(__m2 != memory_order_release);\n+\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n+\t__glibcxx_assert(__m2 <= __m1);\n+\n+\treturn __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);\n+      }\n+\n+      bool\n+      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,\n+\t\t\t      memory_order __m1,\n+\t\t\t      memory_order __m2) volatile noexcept\n+      {\n+\t__glibcxx_assert(__m2 != memory_order_release);\n+\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n+\t__glibcxx_assert(__m2 <= __m1);\n+\n+\treturn __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);\n+      }\n+\n+      __pointer_type\n+      fetch_add(ptrdiff_t __d,\n+\t\tmemory_order __m = memory_order_seq_cst) noexcept\n+      { return __atomic_fetch_add(&_M_p, __d, __m); }\n+\n+      __pointer_type\n+      fetch_add(ptrdiff_t __d,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n+      { return __atomic_fetch_add(&_M_p, __d, __m); }\n+\n+      __pointer_type\n+      fetch_sub(ptrdiff_t __d,\n+\t\tmemory_order __m = memory_order_seq_cst) noexcept\n+      { return __atomic_fetch_sub(&_M_p, __d, __m); }\n+\n+      __pointer_type\n+      fetch_sub(ptrdiff_t __d,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n+      { return __atomic_fetch_sub(&_M_p, __d, __m); }\n+    };\n+\n   // @} group atomics\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "70f613f5c5013ee33ffe4e9559f72e3212f91323", "filename": "libstdc++-v3/include/std/atomic", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -39,8 +39,6 @@\n #endif\n \n #include <bits/atomic_base.h>\n-#include <bits/atomic_0.h>\n-#include <bits/atomic_2.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -167,69 +165,116 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }\n \n-      operator _Tp() const noexcept;\n+      operator _Tp() const noexcept\n+      { return load(); }\n \n-      operator _Tp() const volatile noexcept;\n+      operator _Tp() const volatile noexcept\n+      { return load(); }\n \n       _Tp\n-      operator=(_Tp __i) noexcept { store(__i); return __i; }\n+      operator=(_Tp __i) noexcept \n+      { store(__i); return __i; }\n \n       _Tp\n-      operator=(_Tp __i) volatile noexcept { store(__i); return __i; }\n+      operator=(_Tp __i) volatile noexcept \n+      { store(__i); return __i; }\n \n       bool\n-      is_lock_free() const noexcept;\n+      is_lock_free() const noexcept\n+      { return __atomic_is_lock_free(sizeof(_M_i), &_M_i); }\n \n       bool\n-      is_lock_free() const volatile noexcept;\n+      is_lock_free() const volatile noexcept\n+      { return __atomic_is_lock_free(sizeof(_M_i), &_M_i); }\n \n       void\n-      store(_Tp, memory_order = memory_order_seq_cst) noexcept;\n+      store(_Tp __i, memory_order _m = memory_order_seq_cst) noexcept\n+      { __atomic_store(&_M_i, &__i, _m); }\n \n       void\n-      store(_Tp, memory_order = memory_order_seq_cst) volatile noexcept;\n+      store(_Tp __i, memory_order _m = memory_order_seq_cst) volatile noexcept\n+      { __atomic_store(&_M_i, &__i, _m); }\n \n       _Tp\n-      load(memory_order = memory_order_seq_cst) const noexcept;\n+      load(memory_order _m = memory_order_seq_cst) const noexcept\n+      { \n+        _Tp tmp;\n+\t__atomic_load(&_M_i, &tmp, _m); \n+\treturn tmp;\n+      }\n \n       _Tp\n-      load(memory_order = memory_order_seq_cst) const volatile noexcept;\n+      load(memory_order _m = memory_order_seq_cst) const volatile noexcept\n+      { \n+        _Tp tmp;\n+\t__atomic_load(&_M_i, &tmp, _m); \n+\treturn tmp;\n+      }\n \n       _Tp\n-      exchange(_Tp __i, memory_order = memory_order_seq_cst) noexcept;\n+      exchange(_Tp __i, memory_order _m = memory_order_seq_cst) noexcept\n+      { \n+        _Tp tmp;\n+\t__atomic_exchange(&_M_i, &__i, &tmp, _m); \n+\treturn tmp;\n+      }\n \n       _Tp\n-      exchange(_Tp __i, memory_order = memory_order_seq_cst) volatile noexcept;\n+      exchange(_Tp __i, \n+\t       memory_order _m = memory_order_seq_cst) volatile noexcept\n+      { \n+        _Tp tmp;\n+\t__atomic_exchange(&_M_i, &__i, &tmp, _m); \n+\treturn tmp;\n+      }\n \n       bool\n-      compare_exchange_weak(_Tp&, _Tp, memory_order, memory_order) noexcept;\n+      compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s, \n+\t\t\t    memory_order __f) noexcept\n+      {\n+\treturn __atomic_compare_exchange(&_M_i, &__e, &__i, true, __s, __f); \n+      }\n \n       bool\n-      compare_exchange_weak(_Tp&, _Tp, memory_order,\n-\t\t\t    memory_order) volatile noexcept;\n+      compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s, \n+\t\t\t    memory_order __f) volatile noexcept\n+      {\n+\treturn __atomic_compare_exchange(&_M_i, &__e, &__i, true, __s, __f); \n+      }\n \n       bool\n-      compare_exchange_weak(_Tp&, _Tp,\n-\t\t\t    memory_order = memory_order_seq_cst) noexcept;\n+      compare_exchange_weak(_Tp& __e, _Tp __i,\n+\t\t\t    memory_order __m = memory_order_seq_cst) noexcept\n+      { return compare_exchange_weak(__e, __i, __m, __m); }\n \n       bool\n-      compare_exchange_weak(_Tp&, _Tp,\n-\t\t       memory_order = memory_order_seq_cst) volatile noexcept;\n+      compare_exchange_weak(_Tp& __e, _Tp __i,\n+\t\t     memory_order __m = memory_order_seq_cst) volatile noexcept\n+      { return compare_exchange_weak(__e, __i, __m, __m); }\n \n       bool\n-      compare_exchange_strong(_Tp&, _Tp, memory_order, memory_order) noexcept;\n+      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, \n+\t\t\t      memory_order __f) noexcept\n+      {\n+\treturn __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f); \n+      }\n \n       bool\n-      compare_exchange_strong(_Tp&, _Tp, memory_order,\n-\t\t\t      memory_order) volatile noexcept;\n+      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, \n+\t\t\t      memory_order __f) volatile noexcept\n+      {\n+\treturn __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f); \n+      }\n \n       bool\n-      compare_exchange_strong(_Tp&, _Tp,\n-\t\t\t      memory_order = memory_order_seq_cst) noexcept;\n+      compare_exchange_strong(_Tp& __e, _Tp __i,\n+\t\t\t       memory_order __m = memory_order_seq_cst) noexcept\n+      { return compare_exchange_strong(__e, __i, __m, __m); }\n \n       bool\n-      compare_exchange_strong(_Tp&, _Tp,\n-\t\t       memory_order = memory_order_seq_cst) volatile noexcept;\n+      compare_exchange_strong(_Tp& __e, _Tp __i,\n+\t\t     memory_order __m = memory_order_seq_cst) volatile noexcept\n+      { return compare_exchange_strong(__e, __i, __m, __m); }\n     };\n \n "}, {"sha": "eefa6e269a0f6b3ecba1518059aec6df6c2b6770", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -190,13 +190,13 @@ endif\n \n # Sources present in the src directory, always present.\n sources = \\\n-\tatomic.cc \\\n \tbitmap_allocator.cc \\\n \tpool_allocator.cc \\\n \tmt_allocator.cc \\\n \tcodecvt.cc \\\n \tcompatibility.cc \\\n \tcompatibility-c++0x.cc \\\n+\tcompatibility-atomic-c++0x.cc \\\n \tcompatibility-debug_list.cc \\\n \tcompatibility-debug_list-2.cc \\\n \tcompatibility-list.cc \\\n@@ -323,6 +323,11 @@ compatibility-c++0x.lo: compatibility-c++0x.cc\n compatibility-c++0x.o: compatibility-c++0x.cc\n \t$(CXXCOMPILE) -std=gnu++0x -c $<\n \n+compatibility-atomic-c++0x.lo: compatibility-atomic-c++0x.cc\n+\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n+compatibility-atomic-c++0x.o: compatibility-atomic-c++0x.cc\n+\t$(CXXCOMPILE) -std=gnu++0x -c $<\n+\n functional.lo: functional.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n functional.o: functional.cc\n@@ -343,11 +348,6 @@ limits.lo: limits.cc\n limits.o: limits.cc\n \t$(CXXCOMPILE) -std=gnu++0x -c $<\n \n-atomic.lo: atomic.cc\n-\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n-atomic.o: atomic.cc\n-\t$(CXXCOMPILE) -std=gnu++0x -c $<\n-\n fstream-inst.lo: fstream-inst.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n fstream-inst.o: fstream-inst.cc"}, {"sha": "4b2646e4a05679a300aa877c60c74dca0aa2bcef", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -105,9 +105,9 @@ am__objects_1 = atomicity.lo codecvt_members.lo collate_members.lo \\\n @ENABLE_PARALLEL_TRUE@\tcompatibility-parallel_list-2.lo\n am__objects_5 = basic_file.lo c++locale.lo $(am__objects_2) \\\n \t$(am__objects_3) $(am__objects_4)\n-am__objects_6 = atomic.lo bitmap_allocator.lo pool_allocator.lo \\\n-\tmt_allocator.lo codecvt.lo compatibility.lo \\\n-\tcompatibility-c++0x.lo compatibility-debug_list.lo \\\n+am__objects_6 = bitmap_allocator.lo pool_allocator.lo mt_allocator.lo \\\n+\tcodecvt.lo compatibility.lo compatibility-c++0x.lo \\\n+\tcompatibility-atomic-c++0x.lo compatibility-debug_list.lo \\\n \tcompatibility-debug_list-2.lo compatibility-list.lo \\\n \tcompatibility-list-2.lo complex_io.lo ctype.lo debug.lo \\\n \tfunctexcept.lo functional.lo globals_io.lo hash_c++0x.lo \\\n@@ -407,13 +407,13 @@ host_sources_extra = \\\n \n # Sources present in the src directory, always present.\n sources = \\\n-\tatomic.cc \\\n \tbitmap_allocator.cc \\\n \tpool_allocator.cc \\\n \tmt_allocator.cc \\\n \tcodecvt.cc \\\n \tcompatibility.cc \\\n \tcompatibility-c++0x.cc \\\n+\tcompatibility-atomic-c++0x.cc \\\n \tcompatibility-debug_list.cc \\\n \tcompatibility-debug_list-2.cc \\\n \tcompatibility-list.cc \\\n@@ -917,6 +917,11 @@ compatibility-c++0x.lo: compatibility-c++0x.cc\n compatibility-c++0x.o: compatibility-c++0x.cc\n \t$(CXXCOMPILE) -std=gnu++0x -c $<\n \n+compatibility-atomic-c++0x.lo: compatibility-atomic-c++0x.cc\n+\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n+compatibility-atomic-c++0x.o: compatibility-atomic-c++0x.cc\n+\t$(CXXCOMPILE) -std=gnu++0x -c $<\n+\n functional.lo: functional.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n functional.o: functional.cc\n@@ -937,11 +942,6 @@ limits.lo: limits.cc\n limits.o: limits.cc\n \t$(CXXCOMPILE) -std=gnu++0x -c $<\n \n-atomic.lo: atomic.cc\n-\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n-atomic.o: atomic.cc\n-\t$(CXXCOMPILE) -std=gnu++0x -c $<\n-\n fstream-inst.lo: fstream-inst.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n fstream-inst.o: fstream-inst.cc"}, {"sha": "1ee0d7e35a8c82fd3209b913aadced77c35d6bef", "filename": "libstdc++-v3/src/compatibility-atomic-c++0x.cc", "status": "renamed", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Fsrc%2Fcompatibility-atomic-c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Fsrc%2Fcompatibility-atomic-c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fcompatibility-atomic-c%2B%2B0x.cc?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -1,4 +1,4 @@\n-// Support for atomic operations -*- C++ -*-\n+// <atomic> compatibility -*- C++ -*-\n \n // Copyright (C) 2008, 2009, 2010, 2011\n // Free Software Foundation, Inc.\n@@ -27,6 +27,9 @@\n #include <atomic>\n #include <mutex>\n \n+// XXX GLIBCXX_ABI Deprecated\n+// gcc-4.7.0\n+\n #define LOGSIZE 4\n \n namespace\n@@ -55,6 +58,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   namespace __atomic0\n   {\n+\n+    struct atomic_flag : public __atomic_flag_base\n+    {\n+     bool\n+     test_and_set(memory_order) noexcept;\n+     \n+     void\n+     clear(memory_order) noexcept;\n+    };\n+\n     bool\n     atomic_flag::test_and_set(memory_order) noexcept\n     {\n@@ -74,6 +87,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n       _M_i = false;\n     }\n+  } // namespace __atomic0\n \n   _GLIBCXX_BEGIN_EXTERN_C\n \n@@ -116,10 +130,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   _GLIBCXX_END_EXTERN_C\n \n-  } // namespace __atomic0\n-\n _GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace\n+} // namespace std\n \n \n // XXX GLIBCXX_ABI Deprecated", "previous_filename": "libstdc++-v3/src/atomic.cc"}, {"sha": "6053efca90219761fdadc4eaa88b690ade7e0508", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fuser_pod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fuser_pod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fuser_pod.cc?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n-// { dg-do link { xfail *-*-* } }\n+// { dg-do link }\n \n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -29,7 +29,7 @@ struct dwordp\n void atomics()\n {\n   std::atomic<dwordp> a;\n-  bool b = a.is_lock_free(); // { dg-excess-errors \"undefined reference to\" }\n+  bool b = a.is_lock_free();\n }\n \n int main()"}, {"sha": "690f1215352f2f0dd92004f686dd2f5d30f21d5a", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/requirements/explicit_instantiation/1.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Frequirements%2Fexplicit_instantiation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Frequirements%2Fexplicit_instantiation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Frequirements%2Fexplicit_instantiation%2F1.cc?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -23,5 +23,5 @@\n #include <atomic>\n #include <testsuite_character.h>\n \n-template class std::atomic<__gnu_test::pod_char>;\n+template class std::atomic<__gnu_test::pod_state>;\n template class std::atomic<__gnu_test::pod_char*>;"}, {"sha": "450fb6c2cc7e0657422bc57aa927ce943de7a3fa", "filename": "libstdc++-v3/testsuite/29_atomics/headers/atomic/macros.cc", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Fmacros.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86951993f8a4cae2fb26bf8705e2f248a8d6f21e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Fmacros.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Fmacros.cc?ref=86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "patch": "@@ -20,78 +20,36 @@\n \n #include <atomic>\n \n-namespace gnu\n-{\n #ifndef ATOMIC_CHAR_LOCK_FREE \n # error \"ATOMIC_CHAR_LOCK_FREE must be a macro\"\n-#else\n-# if ATOMIC_CHAR_LOCK_FREE != 0 \\\n-    && ATOMIC_CHAR_LOCK_FREE != 1 && ATOMIC_CHAR_LOCK_FREE != 2\n-# error \"ATOMIC_CHAR_LOCK_FREE must be 0, 1, or 2\"\n-# endif\n #endif\n \n #ifndef ATOMIC_CHAR16_T_LOCK_FREE \n # error \"ATOMIC_CHAR16_T_LOCK_FREE must be a macro\"\n-#else\n-# if ATOMIC_CHAR16_T_LOCK_FREE != 0 \\\n-    && ATOMIC_CHAR16_T_LOCK_FREE != 1 && ATOMIC_CHAR16_T_LOCK_FREE != 2\n-# error \"ATOMIC_CHAR16_T_LOCK_FREE must be 0, 1, or 2\"\n-# endif\n #endif\n \n #ifndef ATOMIC_CHAR32_T_LOCK_FREE \n # error \"ATOMIC_CHAR32_T_LOCK_FREE must be a macro\"\n-#else\n-# if ATOMIC_CHAR32_T_LOCK_FREE != 0 \\\n-    && ATOMIC_CHAR32_T_LOCK_FREE != 1 && ATOMIC_CHAR32_T_LOCK_FREE != 2\n-# error \"ATOMIC_CHAR32_T_LOCK_FREE must be 0, 1, or 2\"\n-# endif\n #endif\n \n #ifndef ATOMIC_WCHAR_T_LOCK_FREE \n # error \"ATOMIC_WCHAR_T_LOCK_FREE must be a macro\"\n-#else\n-# if ATOMIC_WCHAR_T_LOCK_FREE != 0 \\\n-    && ATOMIC_WCHAR_T_LOCK_FREE != 1 && ATOMIC_WCHAR_T_LOCK_FREE != 2\n-# error \"ATOMIC_WCHAR_T_LOCK_FREE must be 0, 1, or 2\"\n-# endif\n #endif\n \n #ifndef ATOMIC_SHORT_LOCK_FREE \n # error \"ATOMIC_SHORT_LOCK_FREE must be a macro\"\n-#else\n-# if ATOMIC_SHORT_LOCK_FREE != 0 \\\n-    && ATOMIC_SHORT_LOCK_FREE != 1 && ATOMIC_SHORT_LOCK_FREE != 2\n-# error \"ATOMIC_SHORT_LOCK_FREE must be 0, 1, or 2\"\n-# endif\n #endif\n \n #ifndef ATOMIC_INT_LOCK_FREE \n # error \"ATOMIC_INT_LOCK_FREE must be a macro\"\n-#else\n-# if ATOMIC_INT_LOCK_FREE != 0 \\\n-    && ATOMIC_INT_LOCK_FREE != 1 && ATOMIC_INT_LOCK_FREE != 2\n-# error \"ATOMIC_INT_LOCK_FREE must be 0, 1, or 2\"\n-# endif\n #endif\n \n #ifndef ATOMIC_LONG_LOCK_FREE \n # error \"ATOMIC_LONG_LOCK_FREE must be a macro\"\n-#else\n-# if ATOMIC_LONG_LOCK_FREE != 0 \\\n-    && ATOMIC_LONG_LOCK_FREE != 1 && ATOMIC_LONG_LOCK_FREE != 2\n-# error \"ATOMIC_LONG_LOCK_FREE must be 0, 1, or 2\"\n-# endif\n #endif\n \n #ifndef ATOMIC_LLONG_LOCK_FREE \n # error \"ATOMIC_LLONG_LOCK_FREE must be a macro\"\n-#else\n-# if ATOMIC_LLONG_LOCK_FREE != 0 \\\n-    && ATOMIC_LLONG_LOCK_FREE != 1 && ATOMIC_LLONG_LOCK_FREE != 2\n-# error \"ATOMIC_LLONG_LOCK_FREE must be 0, 1, or 2\"\n-# endif\n #endif\n \n #ifndef ATOMIC_FLAG_INIT\n@@ -101,4 +59,41 @@ namespace gnu\n #ifndef ATOMIC_VAR_INIT\n     #error \"ATOMIC_VAR_INIT_must_be_a_macro\"\n #endif\n+\n+\n+extern void abort(void);\n+\n+main ()\n+{\n+ if (ATOMIC_CHAR_LOCK_FREE != 0 && ATOMIC_CHAR_LOCK_FREE != 1\n+     && ATOMIC_CHAR_LOCK_FREE != 2)\n+   abort ();\n+\n+ if (ATOMIC_CHAR16_T_LOCK_FREE != 0 && ATOMIC_CHAR16_T_LOCK_FREE != 1\n+     && ATOMIC_CHAR16_T_LOCK_FREE != 2)\n+   abort ();\n+\n+ if (ATOMIC_CHAR32_T_LOCK_FREE != 0 && ATOMIC_CHAR32_T_LOCK_FREE != 1\n+     && ATOMIC_CHAR32_T_LOCK_FREE != 2)\n+   abort ();\n+\n+ if (ATOMIC_WCHAR_T_LOCK_FREE != 0 && ATOMIC_WCHAR_T_LOCK_FREE != 1\n+     && ATOMIC_WCHAR_T_LOCK_FREE != 2)\n+   abort ();\n+\n+ if (ATOMIC_SHORT_LOCK_FREE != 0 && ATOMIC_SHORT_LOCK_FREE != 1\n+     && ATOMIC_SHORT_LOCK_FREE != 2)\n+   abort ();\n+\n+ if (ATOMIC_INT_LOCK_FREE != 0 && ATOMIC_INT_LOCK_FREE != 1\n+     && ATOMIC_INT_LOCK_FREE != 2)\n+   abort ();\n+\n+ if (ATOMIC_LONG_LOCK_FREE != 0 && ATOMIC_LONG_LOCK_FREE != 1\n+     && ATOMIC_LONG_LOCK_FREE != 2)\n+   abort ();\n+\n+ if (ATOMIC_LLONG_LOCK_FREE != 0 && ATOMIC_LLONG_LOCK_FREE != 1\n+     && ATOMIC_LLONG_LOCK_FREE != 2)\n+   abort ();\n }"}]}