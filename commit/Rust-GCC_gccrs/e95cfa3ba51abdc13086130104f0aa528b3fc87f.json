{"sha": "e95cfa3ba51abdc13086130104f0aa528b3fc87f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk1Y2ZhM2JhNTFhYmRjMTMwODYxMzAxMDRmMGFhNTI4YjNmYzg3Zg==", "commit": {"author": {"name": "Paul Woegerer", "email": "woepaul@gcc.gnu.org", "date": "2005-08-19T07:47:34Z"}, "committer": {"name": "Paul Woegerer", "email": "woepaul@gcc.gnu.org", "date": "2005-08-19T07:47:34Z"}, "message": "crx.c: Implemented crx_decompose_address (like in the i386 port) so that...\n\n\t* config/crx/crx.c: Implemented crx_decompose_address (like in the\n\t  i386 port) so that crx_legitimate_address_p, crx_address_cost\n\t  and crx_print_operand_address are using the same code for adress\n\t  handling. Using symbolic displacements now gets rejected since\n\t  the CRX register relative adressing mode can't handle unsigned\n\t  32-bit values as displacements.\n\t* config/crx/crx.h: Simplified definitions for REG_OK_FOR_BASE_P,\n\t  removed redundant parenthesis and obsolete macros.\n\t* config/crx/crx.opt: Added a new switch for debugging of address\n\t  handling.\n\t* config/crx/crx-protos.h: Added new declarations for above.\n\nFrom-SVN: r103269", "tree": {"sha": "c6db8c7cbae2edb4c37db7bdcd132d6ac8fc60af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6db8c7cbae2edb4c37db7bdcd132d6ac8fc60af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e95cfa3ba51abdc13086130104f0aa528b3fc87f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95cfa3ba51abdc13086130104f0aa528b3fc87f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e95cfa3ba51abdc13086130104f0aa528b3fc87f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95cfa3ba51abdc13086130104f0aa528b3fc87f/comments", "author": null, "committer": null, "parents": [{"sha": "1581a9a177e82ba05a1769eebcf55a038569d6d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1581a9a177e82ba05a1769eebcf55a038569d6d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1581a9a177e82ba05a1769eebcf55a038569d6d3"}], "stats": {"total": 758, "additions": 369, "deletions": 389}, "files": [{"sha": "1a598aa650a63c16b5dceb983aa5b047376ca028", "filename": "gcc/config/crx/crx-protos.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95cfa3ba51abdc13086130104f0aa528b3fc87f/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95cfa3ba51abdc13086130104f0aa528b3fc87f/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h?ref=e95cfa3ba51abdc13086130104f0aa528b3fc87f", "patch": "@@ -42,6 +42,18 @@ extern rtx crx_function_arg (struct cumulative_args *, enum machine_mode, tree,\n \n #ifdef RTX_CODE\n /* Addressing Modes.  */\n+struct crx_address\n+{\n+  rtx base, index, disp, side_effect;\n+  int scale;\n+};\n+\n+enum crx_addrtype\n+{\n+  CRX_INVALID, CRX_REG_REL, CRX_POST_INC, CRX_SCALED_INDX, CRX_ABSOLUTE\n+};\n+\n+extern enum crx_addrtype crx_decompose_address (rtx addr, struct crx_address *out);\n extern int crx_legitimate_address_p (enum machine_mode, rtx, int);\n \n extern int crx_const_double_ok (rtx op);"}, {"sha": "6008f8dbd4a9899d1ccd824d6c5c8e8f2d9b2fe2", "filename": "gcc/config/crx/crx.c", "status": "modified", "additions": 348, "deletions": 370, "changes": 718, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95cfa3ba51abdc13086130104f0aa528b3fc87f/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95cfa3ba51abdc13086130104f0aa528b3fc87f/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=e95cfa3ba51abdc13086130104f0aa528b3fc87f", "patch": "@@ -65,32 +65,29 @@\n \n /* Predicate is true if the current function is a 'noreturn' function, i.e. it\n  * is qualified as volatile.  */\n-#define FUNC_IS_NORETURN_P(decl)  (TREE_THIS_VOLATILE (decl))\n+#define FUNC_IS_NORETURN_P(decl) (TREE_THIS_VOLATILE (decl))\n \n-/* The following 3 macros are used in crx_legitimate_address_p() */\n+/* The following macros are used in crx_decompose_address () */\n \n-/* Returns 1 if the scale factor of an index address is valid.  */\n-#define SCALE_FOR_INDEX_P(X)\t\t\t\t\t\\\n-  (GET_CODE (X) == CONST_INT\t\t\t\t\t\\\n-   && (INTVAL (X) == 1 || INTVAL (X) == 2\t\t\t\\\n-       || INTVAL(X) == 4 || INTVAL (X) == 8))\n+/* Returns the factor of a scaled index address or -1 if invalid. */\n+#define SCALE_FOR_INDEX_P(X)\t\\\n+ (GET_CODE (X) == CONST_INT ?\t\\\n+  (INTVAL (X) == 1 ? 1 :\t\\\n+   INTVAL (X) == 2 ? 2 :\t\\\n+   INTVAL (X) == 4 ? 4 :\t\\\n+   INTVAL (X) == 8 ? 8 :\t\\\n+   -1) :\t\t\t\\\n+  -1)\n \n /* Nonzero if the rtx X is a signed const int of n bits */\n #define RTX_SIGNED_INT_FITS_N_BITS(X,n)\t\t\t\\\n-  ((GET_CODE(X) == CONST_INT\t\t\t\t\\\n-    && SIGNED_INT_FITS_N_BITS(INTVAL(X),n)) ? 1 : 0)\n+ ((GET_CODE (X) == CONST_INT\t\t\t\t\\\n+   && SIGNED_INT_FITS_N_BITS (INTVAL (X), n)) ? 1 : 0)\n \n /* Nonzero if the rtx X is an unsigned const int of n bits.  */\n-#define RTX_UNSIGNED_INT_FITS_N_BITS(X,n)\t\t\\\n-  ((GET_CODE(X) == CONST_INT\t\t\t\t\\\n-    && UNSIGNED_INT_FITS_N_BITS(INTVAL(X),n)) ? 1 : 0)\n-\n-\n-/* Register relative legal displacement */\n-#define CRX_REGISTER_RELATIVE_DISP_P(X)\t\t\t\t\\\n- (CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n-  && (GET_CODE (X) != CONST_INT\t\t\t\t\t\\\n-      || RTX_SIGNED_INT_FITS_N_BITS(X, GET_MODE_BITSIZE (Pmode))))\n+#define RTX_UNSIGNED_INT_FITS_N_BITS(X, n)\t\t\\\n+ ((GET_CODE (X) == CONST_INT\t\t\t\t\\\n+   && UNSIGNED_INT_FITS_N_BITS (INTVAL (X), n)) ? 1 : 0)\n \n /*****************************************************************************/\n /* STATIC VARIABLES\t\t\t\t\t\t\t     */\n@@ -114,7 +111,7 @@ static int sum_regs = 0;\n static int local_vars_size;\n \n /* The sum of 2 sizes: locals vars and padding byte for saving the registers.\n- * Used in expand_prologue() and expand_epilogue().  */\n+ * Used in expand_prologue () and expand_epilogue ().  */\n static int size_for_adjusting_sp;\n \n /* In case of a POST_INC or POST_DEC memory reference, we must report the mode\n@@ -140,6 +137,7 @@ static bool crx_fixed_condition_code_regs (unsigned int *, unsigned int *);\n static rtx crx_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n \t\t\t\t int incoming ATTRIBUTE_UNUSED);\n static bool crx_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED);\n+static int crx_address_cost (rtx);\n \n /*****************************************************************************/\n /* STACK LAYOUT AND CALLING CONVENTIONS\t\t\t\t\t     */\n@@ -154,6 +152,13 @@ static bool crx_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED);\n #undef\tTARGET_RETURN_IN_MEMORY\n #define\tTARGET_RETURN_IN_MEMORY\t\tcrx_return_in_memory\n \n+/*****************************************************************************/\n+/* RELATIVE COSTS OF OPERATIONS\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#undef\tTARGET_ADDRESS_COST\n+#define\tTARGET_ADDRESS_COST\t\tcrx_address_cost\n+\n /*****************************************************************************/\n /* TARGET-SPECIFIC USES OF `__attribute__'\t\t\t\t     */\n /*****************************************************************************/\n@@ -260,7 +265,7 @@ crx_compute_save_regs (void)\n \t}\n \n       /* If this reg is used and not call-used (except RA), save it. */\n-      if (crx_interrupt_function_p())\n+      if (crx_interrupt_function_p ())\n \t{\n \t  if (!current_function_is_leaf && call_used_regs[regno])\n \t    /* this is a volatile reg in a non-leaf interrupt routine - save it\n@@ -353,10 +358,13 @@ crx_regno_reg_class (int regno)\n   if (regno >= 0 && regno < SP_REGNUM)\n     return NOSP_REGS;\n \n-  if (regno == SP_REGNUM) return GENERAL_REGS;\n+  if (regno == SP_REGNUM)\n+    return GENERAL_REGS;\n \n-  if (regno == LO_REGNUM) return LO_REGS;\n-  if (regno == HI_REGNUM) return HI_REGS;\n+  if (regno == LO_REGNUM)\n+    return LO_REGS;\n+  if (regno == HI_REGNUM)\n+    return HI_REGS;\n \n   return NO_REGS;\n }\n@@ -429,7 +437,7 @@ crx_function_arg (CUMULATIVE_ARGS * cum, enum machine_mode mode, tree type,\n {\n   last_parm_in_reg = 0;\n \n-  /* Function_arg() is called with this type just after all the args have had\n+  /* Function_arg () is called with this type just after all the args have had\n    * their registers assigned. The rtx that function_arg returns from this type\n    * is supposed to pass to 'gen_call' but currently it is not implemented (see\n    * macro GEN_CALL).  */\n@@ -535,7 +543,7 @@ crx_function_arg_regno_p (int n)\n /* ---------------- */\n \n /* Implements the macro GO_IF_LEGITIMATE_ADDRESS defined in crx.h.\n- * The legitimate addressing modes for the CRX are:\n+ * The following addressing modes are supported on CRX:\n  *\n  * Relocations\t\t--> const | symbol_ref | label_ref\n  * Absolute address\t--> 32 bit absolute\n@@ -545,125 +553,283 @@ crx_function_arg_regno_p (int n)\n  * Scaled index\t\t--> reg + reg | 22 bit disp. + reg + reg |\n  *\t\t\t    22 disp. + reg + reg + (2 | 4 | 8) */\n \n-int\n-crx_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t  rtx x, int strict)\n+static int crx_addr_reg_p (rtx addr_reg)\n {\n-  /* Absolute address */\n-  if (RTX_UNSIGNED_INT_FITS_N_BITS(x, GET_MODE_BITSIZE(Pmode)))\n-    return 1;\n-\n-  /* Label */\n-  if (GET_CODE (x) == CONST\n-      || GET_CODE (x) == SYMBOL_REF\n-      || GET_CODE (x) == LABEL_REF\n-      || (GET_CODE (x) == REG && (strict ? STRICT_REG_OK_FOR_BASE_P (x)\n-\t\t\t\t  : NONSTRICT_REG_OK_FOR_BASE_P (x))))\n-    return 1;\n-\n-  /* Post increment - The first argument is a register and the second is\n-   * 12-bit long int. */\n-  if (GET_CODE (x) == POST_INC || GET_CODE (x) == POST_DEC)\n+  rtx reg;\n+\n+  if (REG_P (addr_reg))\n     {\n-      /* Don't allow modes to be referenced through post autoinc/dec that\n-       * cannot be loaded/stored with a single instruction */\n-      if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n-\treturn 0;\n+      reg = addr_reg;\n+    }\n+  else if ((GET_CODE (addr_reg) == SUBREG\n+\t   && REG_P (SUBREG_REG (addr_reg))\n+\t   && GET_MODE_SIZE (GET_MODE (SUBREG_REG (addr_reg)))\n+\t   <= UNITS_PER_WORD))\n+    {\n+      reg = SUBREG_REG (addr_reg);\n+    }\n+  else\n+    return FALSE;\n \n-      if((GET_CODE (XEXP (x, 0)) == REG)\n-\t && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))\n-\t     : NONSTRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))))\n-\treturn 1;\n+  if (GET_MODE (addr_reg) != Pmode)\n+    {\n+      return FALSE;\n     }\n \n-  /* Post modify */\n-  if (GET_CODE (x) == POST_MODIFY)\n+  return TRUE;\n+}\n+\n+enum crx_addrtype\n+crx_decompose_address (rtx addr, struct crx_address *out)\n+{\n+  rtx base = NULL_RTX, index = NULL_RTX, disp = NULL_RTX;\n+  rtx scale_rtx = NULL_RTX, side_effect = NULL_RTX;\n+  int scale = -1;\n+  \n+  enum crx_addrtype retval = CRX_INVALID;\n+\n+  switch (GET_CODE (addr))\n     {\n-      /* Don't allow modes to be referenced through post autoinc/dec that\n-       * cannot be loaded/stored with a single instruction */\n-      if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n-\treturn 0;\n+    case CONST_INT:\n+      /* Absolute address (known at compile time) */\n+      retval = CRX_ABSOLUTE;\n+      disp = addr;\n+      if (!UNSIGNED_INT_FITS_N_BITS (INTVAL (disp), GET_MODE_BITSIZE (Pmode)))\n+\treturn CRX_INVALID;\n+      break;\n+      \n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      /* Absolute address (known at link time) */\n+      retval = CRX_ABSOLUTE;\n+      disp = addr;\n+      break;\n \n-      if (!(GET_CODE (XEXP (x, 0)) == REG\n-\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))\n-\t      : NONSTRICT_REG_OK_FOR_BASE_P (XEXP (x, 0)))\n-\t  && RTX_SIGNED_INT_FITS_N_BITS(XEXP (XEXP (x, 1), 1), 12)))\n-\treturn 0;\n+    case REG:\n+    case SUBREG:\n+      /* Register relative address */\n+      retval = CRX_REG_REL;\n+      base = addr;\n+      break;\n \n-      if(!(GET_CODE (XEXP (x, 1)) == PLUS || GET_CODE (XEXP (x, 1)) == MINUS))\n-\treturn 0;\n+    case PLUS:\n+      switch (GET_CODE (XEXP (addr, 0)))\n+\t{\n+\tcase REG:\n+\tcase SUBREG:\n+\t  if (REG_P (XEXP (addr, 1)))\n+\t    {\n+\t      /* Scaled index with scale = 1 and disp. = 0 */\n+\t      retval = CRX_SCALED_INDX;\n+\t      base = XEXP (addr, 1);\n+\t      index = XEXP (addr, 0); \n+\t      scale = 1;\n+\t    }\n+\t  else if (RTX_SIGNED_INT_FITS_N_BITS (XEXP (addr, 1), 28))\n+\t    {\n+\t      /* Register relative address and <= 28-bit disp. */\n+\t      retval = CRX_REG_REL;\n+\t      base = XEXP (addr, 0);\n+\t      disp = XEXP (addr, 1);\n+\t    }\n+\t  else\n+\t    return CRX_INVALID;\n+\t  break;\n \n-      if(!rtx_equal_p(XEXP (x, 0), XEXP (XEXP (x, 1), 0)))\n-\treturn 0;\n+\tcase PLUS:\n+\t  /* Scaled index and <= 22-bit disp. */\n+\t  retval = CRX_SCALED_INDX;\n+\t  base = XEXP (XEXP (addr, 0), 1); \n+\t  disp = XEXP (addr, 1);\n+\t  if (!RTX_SIGNED_INT_FITS_N_BITS (disp, 22))\n+\t    return CRX_INVALID;\n+\t  switch (GET_CODE (XEXP (XEXP (addr, 0), 0)))\n+\t    {\n+\t    case REG:\n+\t      /* Scaled index with scale = 0 and <= 22-bit disp. */\n+\t      index = XEXP (XEXP (addr, 0), 0); \n+\t      scale = 1;\n+\t      break;\n+\t      \n+\t    case MULT:\n+\t      /* Scaled index with scale >= 0 and <= 22-bit disp. */\n+\t      index = XEXP (XEXP (XEXP (addr, 0), 0), 0); \n+\t      scale_rtx = XEXP (XEXP (XEXP (addr, 0), 0), 1); \n+\t      if ((scale = SCALE_FOR_INDEX_P (scale_rtx)) == -1)\n+\t\treturn CRX_INVALID;\n+\t      break;\n \n-      return 1;\n+\t    default:\n+\t      return CRX_INVALID;\n+\t    }\n+\t  break;\n+\t  \n+\tcase MULT:\n+\t  /* Scaled index with scale >= 0 */\n+\t  retval = CRX_SCALED_INDX;\n+\t  base = XEXP (addr, 1); \n+\t  index = XEXP (XEXP (addr, 0), 0); \n+\t  scale_rtx = XEXP (XEXP (addr, 0), 1); \n+\t  /* Scaled index with scale >= 0 and <= 22-bit disp. */\n+\t  if ((scale = SCALE_FOR_INDEX_P (scale_rtx)) == -1)\n+\t    return CRX_INVALID;\n+\t  break;\n+\n+\tdefault:\n+\t  return CRX_INVALID;\n+\t}\n+      break;\n+\n+    case POST_INC:\n+    case POST_DEC:\n+      /* Simple post-increment */\n+      retval = CRX_POST_INC;\n+      base = XEXP (addr, 0);\n+      side_effect = addr;\n+      break;\n+\n+    case POST_MODIFY:\n+      /* Generic post-increment with <= 12-bit disp. */\n+      retval = CRX_POST_INC;\n+      base = XEXP (addr, 0);\n+      side_effect = XEXP (addr, 1);\n+      if (base != XEXP (side_effect, 0))\n+\treturn CRX_INVALID;\n+      switch (GET_CODE (side_effect))\n+\t{\n+\tcase PLUS:\n+\tcase MINUS:\n+\t  disp = XEXP (side_effect, 1);\n+\t  if (!RTX_SIGNED_INT_FITS_N_BITS (disp, 12))\n+\t    return CRX_INVALID;\n+\t  break;\n+\n+\tdefault:\n+\t  /* CRX only supports PLUS and MINUS */\n+\t  return CRX_INVALID;\n+\t}\n+      break;\n+\n+    default:\n+      return CRX_INVALID;\n     }\n \n-  if (GET_CODE (x) == PLUS)\n+  if (base && !crx_addr_reg_p (base)) return CRX_INVALID;\n+  if (index && !crx_addr_reg_p (index)) return CRX_INVALID;\n+  \n+  out->base = base;\n+  out->index = index;\n+  out->disp = disp;\n+  out->scale = scale;\n+  out->side_effect = side_effect;\n+\n+  return retval;\n+}\n+\n+int\n+crx_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t  rtx addr, int strict)\n+{\n+  enum crx_addrtype addrtype;\n+  struct crx_address address;\n+\t\t\t\t\t\t \n+  if (TARGET_DEBUG_ADDR)\n+    {\n+      fprintf (stderr,\n+               \"\\n======\\nGO_IF_LEGITIMATE_ADDRESS, mode = %s, strict = %d\\n\",\n+               GET_MODE_NAME (mode), strict);\n+      debug_rtx (addr);\n+    }\n+  \n+  addrtype = crx_decompose_address (addr, &address);\n+\n+  if (addrtype == CRX_POST_INC && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+    return FALSE;\n+\n+  if (TARGET_DEBUG_ADDR)\n     {\n-      /* Register relative */\n-      if (GET_CODE (XEXP (x, 0)) == REG\n-\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))\n-\t      : NONSTRICT_REG_OK_FOR_BASE_P (XEXP (x, 0)))\n-\t  && (CRX_REGISTER_RELATIVE_DISP_P (XEXP (x, 1))))\n-\treturn 1;\n-\n-      /* Scaled index with factor 1 */\n-      /* 1a. reg + reg */\n-      if (GET_CODE (XEXP (x, 0)) == REG\n-\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))\n-\t      : REG_OK_FOR_INDEX_P (XEXP (x, 0)))\n-\t  && GET_CODE (XEXP (x, 1)) == REG\n-\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 1))\n-\t      : REG_OK_FOR_INDEXED_BASE_P (XEXP (x, 1))))\n-\treturn 1;\n-\n-      /* Scaled index with different factor */\n-      /* 1b. reg * scale + reg */\n-      if (GET_CODE (XEXP (x, 0)) == MULT\n-\t  && GET_CODE (XEXP( XEXP (x, 0), 0)) == REG\n-\t  && (strict ? STRICT_REG_OK_FOR_INDEX_P (XEXP( XEXP (x, 0), 0))\n-\t      : NONSTRICT_REG_OK_FOR_INDEX_P (XEXP( XEXP (x, 0), 0)))\n-\t  && (SCALE_FOR_INDEX_P (XEXP( XEXP (x, 0), 1)))\n-\t  && GET_CODE (XEXP (x, 1)) == REG\n-\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 1))\n-\t      : NONSTRICT_REG_OK_FOR_BASE_P (XEXP (x, 1))))\n-\treturn 1;\n-\n-      if (GET_CODE (XEXP (x, 0)) == PLUS)\n+      const char *typestr;\n+      switch (addrtype)\n \t{\n-\t  /* 2. reg + reg + 22 bit disp.  */\n-\t  if (GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n-\t      && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (XEXP (x, 0), 0))\n-\t\t  : REG_OK_FOR_INDEX_P (XEXP (XEXP (x, 0), 0)))\n-\t      && GET_CODE (XEXP (XEXP (x, 0), 1)) == REG\n-\t      && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (XEXP (x, 0), 1))\n-\t\t  : REG_OK_FOR_INDEXED_BASE_P (XEXP (XEXP (x, 0), 1)))\n-\t      && (RTX_SIGNED_INT_FITS_N_BITS(XEXP (x, 1), 22)))\n-\t    return 1;\n-\n-\t  /* 3. reg * scale + reg + 22 bit disp. */\n-\t  if ((GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT)\n-\t      && (GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0)) == REG)\n-\t      && (strict ?\n-\t\t  STRICT_REG_OK_FOR_BASE_P (XEXP (XEXP (XEXP (x, 0), 0), 0))\n-\t\t  :\n-\t\t  REG_OK_FOR_INDEXED_BASE_P (XEXP (XEXP (XEXP (x, 0), 0), 0)))\n-\t      && (SCALE_FOR_INDEX_P (XEXP (XEXP (XEXP (x, 0), 0), 1)))\n-\t      && (GET_CODE (XEXP (XEXP (x, 0), 1)) == REG)\n-\t      && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (XEXP (x, 0), 1)) :\n-\t\t  REG_OK_FOR_INDEX_P (XEXP (XEXP (x, 0), 1)))\n-\t      && (RTX_SIGNED_INT_FITS_N_BITS(XEXP (x, 1), 22)))\n-\t    return 1;\n+\tcase CRX_INVALID:\n+\t  typestr = \"Invalid\";\n+\t  break;\n+\tcase CRX_REG_REL:\n+\t  typestr = \"Register relative\";\n+\t  break;\n+\tcase CRX_POST_INC:\n+\t  typestr = \"Post-increment\";\n+\t  break;\n+\tcase CRX_SCALED_INDX:\n+\t  typestr = \"Scaled index\";\n+\t  break;\n+\tcase CRX_ABSOLUTE:\n+\t  typestr = \"Absolute\";\n+\t  break;\n+\tdefault:\n+\t  abort ();\n \t}\n+      fprintf (stderr, \"CRX Address type: %s\\n\", typestr);\n     }\n+  \n+  if (addrtype == CRX_INVALID)\n+    return FALSE;\n \n-  return 0;\n+  if (strict)\n+    {\n+      if (address.base && !REGNO_OK_FOR_BASE_P (REGNO (address.base)))\n+\t{\n+\t  if (TARGET_DEBUG_ADDR)\n+\t    fprintf (stderr, \"Base register not strict\\n\");\n+\t  return FALSE;\n+\t}\n+      if (address.index && !REGNO_OK_FOR_INDEX_P (REGNO (address.index)))\n+\t{\n+\t  if (TARGET_DEBUG_ADDR)\n+\t    fprintf (stderr, \"Index register not strict\\n\");\n+\t  return FALSE;\n+\t}\n+    }\n+\n+  return TRUE;\n }\n \n /* ROUTINES TO COMPUTE COSTS */\n /* ------------------------- */\n \n+/* Return cost of the memory address x. */\n+\n+static int\n+crx_address_cost (rtx addr)\n+{\n+  enum crx_addrtype addrtype;\n+  struct crx_address address;\n+\t\t\t\t\t\t \n+  int cost = 2;\n+  \n+  addrtype = crx_decompose_address (addr, &address);\n+  \n+  gcc_assert (addrtype != CRX_INVALID);\n+\n+  /* An absolute address causes a 3-word instruction */\n+  if (addrtype == CRX_ABSOLUTE)\n+    cost+=2;\n+  \n+  /* Post-modifying addresses are more powerfull. */\n+  if (addrtype == CRX_POST_INC)\n+    cost-=2;\n+\n+  /* Attempt to minimize number of registers in the address. */\n+  if (address.base)\n+    cost++;\n+  \n+  if (address.index && address.scale == 1)\n+    cost+=5;\n+\n+  return cost;\n+}\n+\n /* Return the cost of moving data of mode MODE between a register of class\n  * CLASS and memory; IN is zero if the value is to be written to memory,\n  * nonzero if it is to be read in. This cost is relative to those in\n@@ -677,106 +843,32 @@ crx_memory_move_cost (enum machine_mode mode,\n   /* One LD or ST takes twice the time of a simple reg-reg move */\n   if (reg_classes_intersect_p (class, GENERAL_REGS))\n     {\n-      /* printf(\"GENERAL_REGS LD/ST = %d\\n\", 4 * HARD_REGNO_NREGS (0, mode));*/\n+      /* printf (\"GENERAL_REGS LD/ST = %d\\n\", 4 * HARD_REGNO_NREGS (0, mode));*/\n       return 4 * HARD_REGNO_NREGS (0, mode);\n     }\t\n   else if (reg_classes_intersect_p (class, HILO_REGS))\n     {\n       /* HILO to memory and vice versa */\n-      /* printf(\"HILO_REGS %s = %d\\n\",in ? \"LD\" : \"ST\",\n-\t     (REGISTER_MOVE_COST(mode,\n+      /* printf (\"HILO_REGS %s = %d\\n\", in ? \"LD\" : \"ST\",\n+\t     (REGISTER_MOVE_COST (mode,\n \t\t\t\t in ? GENERAL_REGS : HILO_REGS,\n \t\t\t\t in ? HILO_REGS : GENERAL_REGS) + 4)\n \t* HARD_REGNO_NREGS (0, mode)); */\n-      return (REGISTER_MOVE_COST(mode,\n+      return (REGISTER_MOVE_COST (mode,\n \t\t\t\t in ? GENERAL_REGS : HILO_REGS,\n \t\t\t\t in ? HILO_REGS : GENERAL_REGS) + 4)\n \t* HARD_REGNO_NREGS (0, mode);\n     }\n   else /* default (like in i386) */\n     {\n-      /* printf(\"ANYREGS = 100\\n\"); */\n+      /* printf (\"ANYREGS = 100\\n\"); */\n       return 100;\n     }\n }\n \n /* INSTRUCTION OUTPUT */\n /* ------------------ */\n \n-/* Print to FILE addr expression of the form post_inc/dec (in this case\n- * post_offset is zero) or post_inc/dec + post_offset */\n-\n-static void\n-print_post_operand_address (FILE * file, rtx addr, int post_offset)\n-{\n-  int displmnt;\n-\n-  if (GET_CODE (addr) == POST_MODIFY)\n-    {\n-      displmnt = INTVAL(XEXP( XEXP (addr, 1), 1));\n-      if (GET_CODE (XEXP (addr, 1)) == MINUS) displmnt = (-1) * displmnt;\n-    }\n-  else\n-    {\n-      displmnt = GET_MODE_SIZE (output_memory_reference_mode);\n-      /* Make the displacement negative for POST_DEC */\n-      if (GET_CODE (addr) == POST_DEC) displmnt = (-1) * displmnt;\n-    }\n-\n-  if (GET_CODE (XEXP (addr, 0)) != REG)\n-    abort ();\n-\n-  displmnt += post_offset;\n-\n-  fprintf (file, \"%d(%s)+\", displmnt, reg_names[REGNO (XEXP (addr, 0))]);\n-}\n-\n-/* Check if constant rtx contains label_ref.  */\n-\n-static rtx\n-const_and_contains_label_ref (rtx x)\n-{\n-  if (!x)\n-    return NULL_RTX;\n-\n-  if (GET_CODE (x) == LABEL_REF)\n-    return x;\n-\n-  /* Check within enclosing const.  */\n-  if (GET_CODE (x) == CONST)\n-    x = XEXP (x, 0);\n-\n-  if ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS)\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n-      && GET_CODE (XEXP (x, 0)) == LABEL_REF)\n-    return XEXP (x, 0);\n-\n-  return NULL_RTX;\n-}\n-\n-/* Check if rtx contains symbol_ref. */\n-\n-static rtx\n-const_and_contains_symbol_ref (rtx x)\n-{\n-  if (!x)\n-    return NULL_RTX;\n-\n-  if (GET_CODE (x) == SYMBOL_REF)\n-    return x;\n-\n-  /* Check within enclosing const.  */\n-  if (GET_CODE (x) == CONST)\n-    x = XEXP (x, 0);\n-\n-  if ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS)\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n-      && GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n-    return XEXP (x, 0);\n-\n-  return NULL_RTX;\n-}\n-\n /* Check if a const_double is ok for crx store-immediate instructions */\n \n int\n@@ -788,8 +880,8 @@ crx_const_double_ok (rtx op)\n     long l[2];\n     REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n     REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n-    return (UNSIGNED_INT_FITS_N_BITS(l[0], 4) &&\n-\t    UNSIGNED_INT_FITS_N_BITS(l[1], 4)) ? 1 : 0;\n+    return (UNSIGNED_INT_FITS_N_BITS (l[0], 4) &&\n+\t    UNSIGNED_INT_FITS_N_BITS (l[1], 4)) ? 1 : 0;\n   }\n \n   if (GET_MODE (op) == SFmode)\n@@ -798,7 +890,7 @@ crx_const_double_ok (rtx op)\n     long l;\n     REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n     REAL_VALUE_TO_TARGET_SINGLE (r, l);\n-    return UNSIGNED_INT_FITS_N_BITS(l, 4) ? 1 : 0;\n+    return UNSIGNED_INT_FITS_N_BITS (l, 4) ? 1 : 0;\n   }\n \n   return (UNSIGNED_INT_FITS_N_BITS (CONST_DOUBLE_LOW (op), 4) &&\n@@ -833,7 +925,7 @@ crx_print_operand (FILE * file, rtx x, int code)\n \t{\n \t  const char *crx_cmp_str;\n \t  switch (GET_CODE (x))\n-\t    { /* MD: compare(reg, reg or imm) but CRX: cmp(reg or imm, reg)\n+\t    { /* MD: compare (reg, reg or imm) but CRX: cmp (reg or imm, reg)\n \t       * -> swap all non symmetric ops */\n \t    case EQ  : crx_cmp_str = \"eq\"; break;\n \t    case NE  : crx_cmp_str = \"ne\"; break;\n@@ -945,7 +1037,7 @@ crx_print_operand (FILE * file, rtx x, int code)\n \t}\n \n     case 0 : /* default */\n-      switch (GET_CODE(x))\n+      switch (GET_CODE (x))\n \t{\n \tcase REG:\n \t  fprintf (file, \"%s\", reg_names[REGNO (x)]);\n@@ -962,7 +1054,7 @@ crx_print_operand (FILE * file, rtx x, int code)\n \t      long l;\n \n \t      /* Always use H and L for double precision - see above */\n-\t      gcc_assert(GET_MODE (x) == SFmode);\n+\t      gcc_assert (GET_MODE (x) == SFmode);\n \n \t      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n \t      REAL_VALUE_TO_TARGET_SINGLE (r, l);\n@@ -989,172 +1081,56 @@ crx_print_operand (FILE * file, rtx x, int code)\n void\n crx_print_operand_address (FILE * file, rtx addr)\n {\n-  rtx breg = 0, ireg = 0;\n-  rtx offset = 0;\n-  rtx post_offset = 0;\n-  rtx scale = 0;\n-  int mem = 0;\n+  enum crx_addrtype addrtype;\n+  struct crx_address address;\n+\n+  int offset;\n+  \n+  addrtype = crx_decompose_address (addr, &address);\n+  \n+  if (address.disp)\n+    offset = INTVAL (address.disp);\n+  else\n+    offset = 0;\n \n-retry:\n-  switch (GET_CODE (addr))\n+  switch (addrtype)\n     {\n-    case MEM:\n-      fprintf (file, \"0(\");\n-      addr = XEXP (addr, 0);\n-      mem = 1;\n-      goto retry;\n-    case REG:\n-      fprintf (file, \"0(%s)\", reg_names[REGNO (addr)]);\n-      break;\n-    case MULT:\n-      abort ();\n-      break;\n-    case PLUS:\n-      switch (GET_CODE (XEXP (addr, 0)))\n+    case CRX_REG_REL:\n+      fprintf (file, \"%d(%s)\", offset, reg_names[REGNO (address.base)]);\n+      return;\n+      \n+    case CRX_POST_INC:\n+      switch (GET_CODE (address.side_effect))\n \t{\n-\tcase REG:\n-\t  if (GET_CODE (XEXP (addr, 1)) == REG)\n-\t    {\n-\t      ireg = XEXP (addr, 0);\n-\t      breg = XEXP (addr, 1);\n-\t    }\n-\t  else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\n-\t    {\n-\t      if (REG_OK_FOR_BASE_P (XEXP (addr, 0))\n-\t\t  && ((GET_CODE (XEXP (addr, 1)) == CONST_INT)\n-\t\t      || (const_and_contains_symbol_ref (XEXP (addr, 1)))\n-\t\t      || (const_and_contains_label_ref (XEXP (addr, 1)))))\n-\t\tireg = XEXP (addr, 0);\n-\t      else\n-\t\tbreg = XEXP (addr, 0);\n-\n-\t      offset = XEXP (addr, 1);\n-\t    }\n-\t  else\n-\t    abort ();\n+\tcase PLUS:\n \t  break;\n-\tcase MULT:\n-\t  ireg = XEXP (XEXP (addr, 0), 0);\n-\t  scale = XEXP (XEXP (addr, 0), 1);\n-\t  breg = XEXP (addr, 1);\n+\tcase MINUS:\n+\t  offset = -offset;\n \t  break;\n-\tcase PLUS:\n-\t  if ((GET_CODE (XEXP (XEXP (addr, 0), 0)) == MULT)\n-\t      && (GET_CODE (XEXP (XEXP (XEXP (addr, 0), 0), 0)) == REG)\n-\t      && (SCALE_FOR_INDEX_P (XEXP (XEXP (XEXP (addr, 0), 0), 1)))\n-\t      && (GET_CODE (XEXP (XEXP (addr, 0), 1)) == REG)\n-\t      && (GET_CODE (XEXP (addr, 1)) == CONST_INT))\n-\t    {\n-\t      ireg = XEXP (XEXP (XEXP (addr, 0), 0), 0);\n-\t      breg = XEXP (XEXP (addr, 0), 1);\n-\t      scale = (XEXP (XEXP (XEXP (addr, 0), 0), 1));\n-\t      offset = XEXP (addr, 1);\n-\t    }\n-\t  else if (GET_CODE (XEXP (XEXP (addr, 0), 0)) == REG\n-\t\t   && GET_CODE (XEXP (XEXP (addr, 0), 1)) == REG\n-\t\t   && CONSTANT_ADDRESS_P (XEXP (addr, 1)))\n-\t    {\n-\t      ireg = XEXP (XEXP (addr, 0), 0);\n-\t      breg = XEXP (XEXP (addr, 0), 1);\n-\t      offset = XEXP (addr, 1);\n-\t    }\n-\t  else if (GET_CODE (XEXP (XEXP (addr, 0), 0)) == REG\n-\t\t   && GET_CODE (XEXP (addr, 1)) == REG\n-\t\t   && CONSTANT_ADDRESS_P (XEXP (XEXP (addr, 0), 1)))\n-\t    {\n-\t      ireg = XEXP (XEXP (addr, 0), 0);\n-\t      breg = XEXP (addr, 1);\n-\t      offset = XEXP (XEXP (addr, 0), 1);\n-\t    }\n-\t  else\n-\t    abort ();\n+\tcase POST_INC:\n+\t  offset = GET_MODE_SIZE (output_memory_reference_mode);\n \t  break;\n-\tdefault:\n-\t  if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\n-\t    {\n-\t      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\n-\t\toffset = addr;\n-\t      else if (GET_CODE (XEXP (addr, 0)) == POST_INC\n-\t\t       || GET_CODE (XEXP (addr, 0)) == POST_DEC)\n-\t\tpost_offset = XEXP (addr, 1);\n-\t      else\n-\t\tabort ();\n-\t    }\n-\n+\tcase POST_DEC:\n+\t  offset = -GET_MODE_SIZE (output_memory_reference_mode);\n \t  break;\n+\tdefault:\n+\t  abort ();\n \t}\n-\n-      if (scale)\n-\t{\n-\t  fprintf (file, \"%ld(%s,%s,%ld)\", offset ? INTVAL (offset) : 0,\n-\t\t   reg_names[REGNO (breg)], reg_names[REGNO (ireg)],\n-\t\t   INTVAL (scale));\n-\t}\n-      else\n-\t{\n-\t  /* If this is (POST_DEC/INC expression + post_offset) make addr =\n-\t   * POST_DEC/INC expression  */\n-\t  if (post_offset != 0)\n-\t    {\n-\t      addr = XEXP (addr, 0);\n-\t      print_post_operand_address (file, addr, INTVAL (post_offset));\n-\t      break;\n-\t    }\n-\n-\t  if (ireg != 0)\n-\t    {\n-\t      if (offset != 0)\n-\t\t{\n-\t\t  output_addr_const (file, offset);\n-\t\t  /* Print modifier if relevant.  */\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  fprintf (file, \"0\");\n-\t\t}\n-\t      /* Print address string */\n-\t      if (breg != 0)\n-\t\t{\n-\t\t  fprintf (file, \"(%s,%s)\", reg_names[REGNO (breg)],\n-\t\t\t   reg_names[REGNO (ireg)]);\n-\t\t}\n-\t      else\n-\t\tfprintf (file, \"(%s)\", reg_names[REGNO (ireg)]);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (offset != 0)\n-\t\t{\n-\t\t  output_addr_const (file, offset);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  fprintf (file, \"0\");\n-\t\t}\n-\n-\t      if (breg != 0)\n-\t\t{\n-\t\t  if (offset == 0)\n-\t\t    fprintf (file, \"0\");\n-\t\t  fprintf (file, \"(%s)\", reg_names[REGNO (breg)]);\n-\t\t}\n-\t    }\n-\t}\n-      break;\n-\n-    case POST_DEC:\n-    case POST_INC:\n-    case POST_MODIFY:\n-      print_post_operand_address (file, addr, 0);\n-      break;\n-\n+\tfprintf (file, \"%d(%s)+\", offset, reg_names[REGNO (address.base)]);\n+      return;\n+      \n+    case CRX_SCALED_INDX:\n+      fprintf (file, \"%d(%s, %s, %d)\", offset, reg_names[REGNO (address.base)],\n+\t       reg_names[REGNO (address.index)], address.scale);\n+      return;\n+      \n+    case CRX_ABSOLUTE:\n+      output_addr_const (file, address.disp);\n+      return;\n+      \n     default:\n-\n-      output_addr_const (file, addr);\n+      abort ();\n     }\n-\n-  if (mem)\n-    fprintf (file, \")\");\n }\n \n \n@@ -1193,16 +1169,18 @@ crx_expand_movmem (rtx dstbase, rtx srcbase, rtx count_exp, rtx align_exp)\n   if (GET_CODE (align_exp) == CONST_INT)\n     { /* Only if aligned */\n       align = INTVAL (align_exp);\n-      if (align & 3) return 0;\n+      if (align & 3)\n+\treturn 0;\n     }\n \n   if (GET_CODE (count_exp) == CONST_INT)\n     { /* No more than 16 SImode moves */\n       count = INTVAL (count_exp);\n-      if (count > 64) return 0;\n+      if (count > 64)\n+\treturn 0;\n     }\n \n-  tmp_reg = gen_reg_rtx(SImode);\n+  tmp_reg = gen_reg_rtx (SImode);\n \n   /* Create psrs for the src and dest pointers */\n   dst = copy_to_mode_reg (Pmode, XEXP (dstbase, 0));\n@@ -1271,7 +1249,7 @@ crx_expand_scond (enum rtx_code code, rtx dest)\n static void\n mpushpop_str (char *stringbuffer, const char *mnemonic, char *mask)\n {\n-  if(strlen(mask) > 2 || crx_interrupt_function_p ()) /* needs 2-word instr. */\n+  if (strlen (mask) > 2 || crx_interrupt_function_p ()) /* needs 2-word instr. */\n     sprintf (stringbuffer, \"\\n\\t%s\\tsp, {%s}\", mnemonic, mask);\n   else /* single word instruction */\n     sprintf (stringbuffer, \"\\n\\t%s\\t%s\", mnemonic, mask);\n@@ -1346,7 +1324,7 @@ crx_prepare_push_pop_string (int push_or_pop)\n \t    }\n \t}\n \n-      if (strlen(mask_str) == 0) continue;\n+      if (strlen (mask_str) == 0) continue;\n        \t\n       if (push_or_pop == 1)\n \t{\n@@ -1438,7 +1416,7 @@ crx_expand_prologue (void)\n \n   if (size_for_adjusting_sp > 0)\n     emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t   GEN_INT (-(size_for_adjusting_sp))));\n+\t\t\t   GEN_INT (-size_for_adjusting_sp)));\n \n   if (frame_pointer_needed)\n     /* Initialize the frame pointer with the value of the stack pointer"}, {"sha": "9277a28d8919662e4b1961570974e0f22a21d790", "filename": "gcc/config/crx/crx.h", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95cfa3ba51abdc13086130104f0aa528b3fc87f/gcc%2Fconfig%2Fcrx%2Fcrx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95cfa3ba51abdc13086130104f0aa528b3fc87f/gcc%2Fconfig%2Fcrx%2Fcrx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.h?ref=e95cfa3ba51abdc13086130104f0aa528b3fc87f", "patch": "@@ -223,7 +223,6 @@ enum reg_class\n    || (reg_renumber && (unsigned)reg_renumber[REGNO] < 16))\n \n #define REGNO_OK_FOR_INDEX_P(REGNO)\t   REGNO_OK_FOR_BASE_P(REGNO)\n-#define REGNO_OK_FOR_INDEXED_BASE_P(REGNO) REGNO_OK_FOR_BASE_P(REGNO)\n \n #define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n \n@@ -329,7 +328,7 @@ struct cumulative_args\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n   crx_function_arg_advance(&(CUM), (MODE), (TYPE), (NAMED))\n \n-#define FUNCTION_ARG_REGNO_P(REGNO)  crx_function_arg_regno_p((REGNO))\n+#define FUNCTION_ARG_REGNO_P(REGNO)  crx_function_arg_regno_p(REGNO)\n \n /*****************************************************************************/\n /* RETURNING FUNCTION VALUE\t\t\t\t\t\t     */\n@@ -384,22 +383,12 @@ struct cumulative_args\n #define HAVE_POST_MODIFY_DISP 1\n #define HAVE_POST_MODIFY_REG 0\n \n-#define STRICT_REG_OK_FOR_BASE_P(X)\t    REGNO_OK_FOR_BASE_P (REGNO (X))\n-#define STRICT_REG_OK_FOR_INDEX_P(X)\t    REGNO_OK_FOR_INDEX_P(REGNO(X))\n-#define STRICT_REG_OK_FOR_INDEXED_BASE_P(X) REGNO_OK_FOR_INDEXED_BASE_P(REGNO(X))\n-\n-#define NONSTRICT_REG_OK_FOR_BASE_P(X)\t\t1\n-#define NONSTRICT_REG_OK_FOR_INDEX_P(X)\t\t1\n-#define NONSTRICT_REG_OK_FOR_INDEXED_BASE_P(X)\t1\n-\n #ifdef REG_OK_STRICT\n-#define REG_OK_FOR_BASE_P(X)\t\tSTRICT_REG_OK_FOR_BASE_P(X)\n-#define REG_OK_FOR_INDEX_P(X)\t\tSTRICT_REG_OK_FOR_INDEX_P(X)\n-#define REG_OK_FOR_INDEXED_BASE_P(X)\tSTRICT_REG_OK_FOR_INDEXED_BASE_P(X)\n+#define REG_OK_FOR_BASE_P(X)\tREGNO_OK_FOR_BASE_P (REGNO (X))\n+#define REG_OK_FOR_INDEX_P(X)\tREGNO_OK_FOR_INDEX_P (REGNO (X))\n #else\n-#define REG_OK_FOR_BASE_P(X)\t\tNONSTRICT_REG_OK_FOR_BASE_P(X)\n-#define REG_OK_FOR_INDEX_P(X)\t\tNONSTRICT_REG_OK_FOR_INDEX_P(X)\n-#define REG_OK_FOR_INDEXED_BASE_P(X)\tNONSTRICT_REG_OK_FOR_INDEXED_BASE_P(X)\n+#define REG_OK_FOR_BASE_P(X)\t1\n+#define REG_OK_FOR_INDEX_P(X)\t1\n #endif /* REG_OK_STRICT */\n \n #ifdef REG_OK_STRICT\n@@ -414,9 +403,7 @@ struct cumulative_args\n   if (crx_legitimate_address_p (MODE, X, 0))\t\t\t\t\\\n       goto LABEL;\t\t\t\t\t\t\t\\\n }\n-#endif\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t{}\n+#endif /* REG_OK_STRICT */\n \n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "bbca45f760fe348cd21af300e9f37034322f5fc5", "filename": "gcc/config/crx/crx.opt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95cfa3ba51abdc13086130104f0aa528b3fc87f/gcc%2Fconfig%2Fcrx%2Fcrx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95cfa3ba51abdc13086130104f0aa528b3fc87f/gcc%2Fconfig%2Fcrx%2Fcrx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.opt?ref=e95cfa3ba51abdc13086130104f0aa528b3fc87f", "patch": "@@ -26,3 +26,6 @@ Support multiply accumulate instructions\n mno-push-args\n Target Report RejectNegative Mask(NO_PUSH_ARGS)\n Do not use push to store function arguments\n+\n+mdebug-addr\n+Target RejectNegative Var(TARGET_DEBUG_ADDR) Undocumented"}]}