{"sha": "8a7228ee9249a99641a064ae2be3e5afa3590c25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE3MjI4ZWU5MjQ5YTk5NjQxYTA2NGFlMmJlM2U1YWZhMzU5MGMyNQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2004-11-24T15:08:13Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-11-24T15:08:13Z"}, "message": "PolicyFile.java: New file.\n\n2004-11-24  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/security/PolicyFile.java: New file.\n\t* Makefile.am: Added gnu/java/security/PolicyFile.java.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r91165", "tree": {"sha": "6314c250b9b4babf38ae81cf4ce4479a5fadebbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6314c250b9b4babf38ae81cf4ce4479a5fadebbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a7228ee9249a99641a064ae2be3e5afa3590c25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a7228ee9249a99641a064ae2be3e5afa3590c25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a7228ee9249a99641a064ae2be3e5afa3590c25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a7228ee9249a99641a064ae2be3e5afa3590c25/comments", "author": null, "committer": null, "parents": [{"sha": "3eebae0bb1d8b63654facfd9fbad7bbe69e49ba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eebae0bb1d8b63654facfd9fbad7bbe69e49ba5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eebae0bb1d8b63654facfd9fbad7bbe69e49ba5"}], "stats": {"total": 681, "additions": 680, "deletions": 1}, "files": [{"sha": "3b7d530006ed2e7c9d5355a453cfd58c8aa60758", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7228ee9249a99641a064ae2be3e5afa3590c25/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7228ee9249a99641a064ae2be3e5afa3590c25/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8a7228ee9249a99641a064ae2be3e5afa3590c25", "patch": "@@ -1,3 +1,9 @@\n+2004-11-24  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/security/PolicyFile.java: New file.\n+\t* Makefile.am: Added gnu/java/security/PolicyFile.java.\n+\t* Makefile.in: Regenerated.\n+\n 2004-11-24  Michael Koch  <konqueror@gmx.de>\n \n \t* java/lang/Character.java, scripts/unicode-blocks.pl:"}, {"sha": "192845f2cc5e4443630d254a5b987638963b7aa4", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7228ee9249a99641a064ae2be3e5afa3590c25/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7228ee9249a99641a064ae2be3e5afa3590c25/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=8a7228ee9249a99641a064ae2be3e5afa3590c25", "patch": "@@ -2770,6 +2770,7 @@ gnu/java/nio/charset/UTF_16LE.java \\\n gnu/java/nio/charset/UTF_8.java \\\n gnu/java/security/Engine.java \\\n gnu/java/security/OID.java \\\n+gnu/java/security/PolicyFile.java \\\n gnu/java/security/action/GetPropertyAction.java \\\n gnu/java/security/action/GetSecurityPropertyAction.java \\\n gnu/java/security/action/SetAccessibleAction.java \\"}, {"sha": "31032fc6f021f97fc7c7bde997983ed6251aa6f2", "filename": "libjava/Makefile.in", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7228ee9249a99641a064ae2be3e5afa3590c25/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7228ee9249a99641a064ae2be3e5afa3590c25/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=8a7228ee9249a99641a064ae2be3e5afa3590c25", "patch": "@@ -793,7 +793,7 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc exception.cc resolve.cc \\\n \tgnu/java/nio/charset/UTF_16Encoder.java \\\n \tgnu/java/nio/charset/UTF_16LE.java \\\n \tgnu/java/nio/charset/UTF_8.java gnu/java/security/Engine.java \\\n-\tgnu/java/security/OID.java \\\n+\tgnu/java/security/OID.java gnu/java/security/PolicyFile.java \\\n \tgnu/java/security/action/GetPropertyAction.java \\\n \tgnu/java/security/action/GetSecurityPropertyAction.java \\\n \tgnu/java/security/action/SetAccessibleAction.java \\\n@@ -3776,6 +3776,7 @@ am__objects_14 = $(am__objects_9) gnu/classpath/ServiceFactory.lo \\\n \tgnu/java/nio/charset/UTF_16Encoder.lo \\\n \tgnu/java/nio/charset/UTF_16LE.lo gnu/java/nio/charset/UTF_8.lo \\\n \tgnu/java/security/Engine.lo gnu/java/security/OID.lo \\\n+\tgnu/java/security/PolicyFile.lo \\\n \tgnu/java/security/action/GetPropertyAction.lo \\\n \tgnu/java/security/action/GetSecurityPropertyAction.lo \\\n \tgnu/java/security/action/SetAccessibleAction.lo \\\n@@ -6639,6 +6640,7 @@ gnu/java/nio/charset/UTF_16LE.java \\\n gnu/java/nio/charset/UTF_8.java \\\n gnu/java/security/Engine.java \\\n gnu/java/security/OID.java \\\n+gnu/java/security/PolicyFile.java \\\n gnu/java/security/action/GetPropertyAction.java \\\n gnu/java/security/action/GetSecurityPropertyAction.java \\\n gnu/java/security/action/SetAccessibleAction.java \\\n@@ -9475,6 +9477,8 @@ gnu/java/security/Engine.lo: gnu/java/security/$(am__dirstamp) \\\n \tgnu/java/security/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/OID.lo: gnu/java/security/$(am__dirstamp) \\\n \tgnu/java/security/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/PolicyFile.lo: gnu/java/security/$(am__dirstamp) \\\n+\tgnu/java/security/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/action/$(am__dirstamp):\n \t@$(mkdir_p) gnu/java/security/action\n \t@: > gnu/java/security/action/$(am__dirstamp)\n@@ -15271,6 +15275,8 @@ mostlyclean-compile:\n \t-rm -f gnu/java/security/Engine.lo\n \t-rm -f gnu/java/security/OID.$(OBJEXT)\n \t-rm -f gnu/java/security/OID.lo\n+\t-rm -f gnu/java/security/PolicyFile.$(OBJEXT)\n+\t-rm -f gnu/java/security/PolicyFile.lo\n \t-rm -f gnu/java/security/action/GetPropertyAction.$(OBJEXT)\n \t-rm -f gnu/java/security/action/GetPropertyAction.lo\n \t-rm -f gnu/java/security/action/GetSecurityPropertyAction.$(OBJEXT)\n@@ -19921,6 +19927,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/rmi/server/$(DEPDIR)/UnicastServerRef.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/$(DEPDIR)/Engine.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/$(DEPDIR)/OID.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/$(DEPDIR)/PolicyFile.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/action/$(DEPDIR)/GetPropertyAction.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/action/$(DEPDIR)/GetSecurityPropertyAction.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/action/$(DEPDIR)/SetAccessibleAction.Plo@am__quote@"}, {"sha": "d5c14dc7a1726a0d9dc3315ea08c21f4de5c2cc1", "filename": "libjava/gnu/java/security/PolicyFile.java", "status": "added", "additions": 665, "deletions": 0, "changes": 665, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7228ee9249a99641a064ae2be3e5afa3590c25/libjava%2Fgnu%2Fjava%2Fsecurity%2FPolicyFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7228ee9249a99641a064ae2be3e5afa3590c25/libjava%2Fgnu%2Fjava%2Fsecurity%2FPolicyFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2FPolicyFile.java?ref=8a7228ee9249a99641a064ae2be3e5afa3590c25", "patch": "@@ -0,0 +1,665 @@\n+/* PolicyFile.java -- policy file reader.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.StreamTokenizer;\n+import java.lang.reflect.Constructor;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.CodeSource;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.Permission;\n+import java.security.PermissionCollection;\n+import java.security.Permissions;\n+import java.security.Policy;\n+import java.security.Principal;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.security.Security;\n+import java.security.UnresolvedPermission;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * An implementation of a {@link java.security.Policy} object whose\n+ * permissions are specified by a <em>policy file</em>.\n+ *\n+ * <p>The approximate syntax of policy files is:</p>\n+ *\n+ * <pre>\n+ * policyFile ::= keystoreOrGrantEntries ;\n+ *\n+ * keystoreOrGrantEntries ::= keystoreOrGrantEntry |\n+ *                            keystoreOrGrantEntries keystoreOrGrantEntry |\n+ *                            EMPTY ;\n+ *\n+ * keystoreOrGrantEntry ::= keystoreEntry | grantEntry ;\n+ *\n+ * keystoreEntry ::= \"keystore\" keystoreUrl ';' |\n+ *                   \"keystore\" keystoreUrl ',' keystoreAlgorithm ';' ;\n+ *\n+ * keystoreUrl ::= URL ;\n+ * keystoreAlgorithm ::= STRING ;\n+ *\n+ * grantEntry ::= \"grant\" domainParameters '{' permissions '}' ';'\n+ *\n+ * domainParameters ::= domainParameter |\n+ *                      domainParameter ',' domainParameters ;\n+ *\n+ * domainParameter ::= \"signedBy\" signerNames |\n+ *                     \"codeBase\" codeBaseUrl |\n+ *                     \"principal\" principalClassName principalName |\n+ *                     \"principal\" principalName ;\n+ *\n+ * signerNames ::= quotedString ;\n+ * codeBaseUrl ::= URL ;\n+ * principalClassName ::= STRING ;\n+ * principalName ::= quotedString ;\n+ *\n+ * quotedString ::= quoteChar STRING quoteChar ;\n+ * quoteChar ::= '\"' | '\\'';\n+ *\n+ * permissions ::= permission | permissions permission ;\n+ *\n+ * permission ::= \"permission\" permissionClassName permissionTarget permissionAction |\n+ *                \"permission\" permissionClassName permissionTarget |\n+ *                \"permission\" permissionClassName;\n+ * </pre>\n+ *\n+ * <p>Comments are either form of Java comments. Keystore entries only\n+ * affect subsequent grant entries, so if a grant entry preceeds a\n+ * keystore entry, that grant entry is not affected by that keystore\n+ * entry. Certian instances of <code>${property-name}</code> will be\n+ * replaced with <code>System.getProperty(\"property-name\")</code> in\n+ * quoted strings.</p>\n+ *\n+ * <p>This class will load the following files when created or\n+ * refreshed, in order:</p>\n+ *\n+ * <ol>\n+ * <li>The file <code>${java.home}/lib/security/java.policy</code>.</li>\n+ * <li>All URLs specified by security properties\n+ * <code>\"policy.file.<i>n</i>\"</code>, for increasing <i>n</i>\n+ * starting from 1. The sequence stops at the first undefined\n+ * property, so you must set <code>\"policy.file.1\"</code> if you also\n+ * set <code>\"policy.file.2\"</code>, and so on.</li>\n+ * <li>The URL specified by the property\n+ * <code>\"java.security.policy\"</code>.</li>\n+ * </ol>\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ * @see java.security.Policy\n+ */\n+public final class PolicyFile extends Policy\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  private static final boolean DEBUG = true;\n+  private static void debug(String msg)\n+  {\n+    System.err.print(\">> PolicyFile: \");\n+    System.err.println(msg);\n+  }\n+\n+  private static void debug(Throwable t)\n+  {\n+    System.err.println(\">> PolicyFile\");\n+    t.printStackTrace(System.err);\n+  }\n+\n+  private static final String DEFAULT_POLICY = System.getProperty(\"java.home\")\n+    + System.getProperty(\"file.separator\") + \"lib\"\n+    + System.getProperty(\"file.separator\") + \"security\"\n+    + System.getProperty(\"file.separator\") + \"java.policy\";\n+\n+  private final Map cs2pc;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  public PolicyFile()\n+  {\n+    cs2pc = new HashMap();\n+    refresh();\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public PermissionCollection getPermissions(CodeSource codeSource)\n+  {\n+    Permissions perms = new Permissions();\n+    for (Iterator it = cs2pc.entrySet().iterator(); it.hasNext(); )\n+      {\n+        Map.Entry e = (Map.Entry) it.next();\n+        CodeSource cs = (CodeSource) e.getKey();\n+        if (cs.implies(codeSource))\n+          {\n+            if (DEBUG) debug(cs+\" -> \"+codeSource);\n+            PermissionCollection pc = (PermissionCollection) e.getValue();\n+            for (Enumeration ee = pc.elements(); ee.hasMoreElements(); )\n+              {\n+                perms.add((Permission) ee.nextElement());\n+              }\n+          }\n+        else\n+          if (DEBUG) debug(cs+\" !-> \"+codeSource);\n+      }\n+    if (DEBUG) debug (\"returning permissions \" + perms + \" for \" + codeSource);\n+    return perms;\n+  }\n+\n+  public void refresh()\n+  {\n+    cs2pc.clear();\n+    List policyFiles = new LinkedList();\n+    try\n+      {\n+        policyFiles.add(new File(DEFAULT_POLICY).toURL());\n+        if (DEBUG) debug (\"defualt policy is \" + DEFAULT_POLICY);\n+        policyFiles.addAll((List) AccessController.doPrivileged(\n+          new PrivilegedExceptionAction()\n+          {\n+            public Object run() throws Exception\n+            {\n+              LinkedList l = new LinkedList();\n+              for (int i = 1; ; i++)\n+                {\n+                  String s = Security.getProperty(\"policy.file.\"+i);\n+                  if (DEBUG) debug(\"policy.file.\"+i+\"=\"+s);\n+                  if (s == null)\n+                    break;\n+                  l.add(new URL(s));\n+                }\n+              String s = System.getProperty(\"java.security.policy\");\n+              if (DEBUG) debug(\"java.security.policy=\"+s);\n+              if (s != null)\n+                l.add(new URL(s));\n+              return l;\n+            }\n+          }));\n+      }\n+    catch (PrivilegedActionException pae)\n+      {\n+        if (DEBUG) debug(pae);\n+      }\n+    catch (MalformedURLException mue)\n+      {\n+        if (DEBUG) debug(mue);\n+      }\n+    for (Iterator it = policyFiles.iterator(); it.hasNext(); )\n+      {\n+        try\n+          {\n+            URL url = (URL) it.next();\n+            parse(url);\n+          }\n+        catch (IOException ioe)\n+          {\n+            if (DEBUG) debug(ioe);\n+          }\n+      }\n+  }\n+\n+  public String toString()\n+  {\n+    return super.toString() + \" [ \" + cs2pc.toString() + \" ]\";\n+  }\n+\n+  // Own methods.\n+  // -------------------------------------------------------------------------\n+\n+  private static final int STATE_BEGIN = 0;\n+  private static final int STATE_GRANT = 1;\n+  private static final int STATE_PERMS = 2;\n+\n+  /**\n+   * Parse a policy file, incorporating the permission definitions\n+   * described therein.\n+   *\n+   * @param url The URL of the policy file to read.\n+   * @throws IOException if an I/O error occurs, or if the policy file\n+   * cannot be parsed.\n+   */\n+  private void parse(final URL url) throws IOException\n+  {\n+    if (DEBUG) debug (\"reading policy file from \" + url);\n+    final StreamTokenizer in = new StreamTokenizer(new InputStreamReader(url.openStream()));\n+    in.resetSyntax();\n+    in.slashSlashComments(true);\n+    in.slashStarComments(true);\n+    in.wordChars('A', 'Z');\n+    in.wordChars('a', 'z');\n+    in.wordChars('0', '9');\n+    in.wordChars('.', '.');\n+    in.wordChars('_', '_');\n+    in.wordChars('$', '$');\n+    in.whitespaceChars(' ', ' ');\n+    in.whitespaceChars('\\t', '\\t');\n+    in.whitespaceChars('\\f', '\\f');\n+    in.whitespaceChars('\\n', '\\n');\n+    in.whitespaceChars('\\r', '\\r');\n+    in.quoteChar('\\'');\n+    in.quoteChar('\"');\n+\n+    int tok;\n+    int state = STATE_BEGIN;\n+    List keystores = new LinkedList();\n+    URL currentBase = null;\n+    List currentCerts = new LinkedList();\n+    Permissions currentPerms = new Permissions();\n+    while ((tok = in.nextToken()) != StreamTokenizer.TT_EOF)\n+      {\n+        switch (tok)\n+          {\n+          case '{':\n+            if (state != STATE_GRANT)\n+              error(url, in, \"spurious '{'\");\n+            state = STATE_PERMS;\n+            tok = in.nextToken();\n+            break;\n+          case '}':\n+            if (state != STATE_PERMS)\n+              error(url, in, \"spurious '}'\");\n+            state = STATE_BEGIN;\n+            currentPerms.setReadOnly();\n+            Certificate[] c = null;\n+            if (!currentCerts.isEmpty())\n+              c = (Certificate[]) currentCerts.toArray(new Certificate[currentCerts.size()]);\n+            cs2pc.put(new CodeSource(currentBase, c), currentPerms);\n+            currentCerts.clear();\n+            currentPerms = new Permissions();\n+            currentBase = null;\n+            tok = in.nextToken();\n+            if (tok != ';')\n+              in.pushBack();\n+            continue;\n+          }\n+        if (tok != StreamTokenizer.TT_WORD)\n+          {\n+            error(url, in, \"expecting word token\");\n+          }\n+\n+        // keystore \"<keystore-path>\" [',' \"<keystore-type>\"] ';'\n+        if (in.sval.equalsIgnoreCase(\"keystore\"))\n+          {\n+            String alg = KeyStore.getDefaultType();\n+            tok = in.nextToken();\n+            if (tok != '\"' && tok != '\\'')\n+              error(url, in, \"expecting key store URL\");\n+            String store = in.sval;\n+            tok = in.nextToken();\n+            if (tok == ',')\n+              {\n+                tok = in.nextToken();\n+                if (tok != '\"' && tok != '\\'')\n+                  error(url, in, \"expecting key store type\");\n+                alg = in.sval;\n+                tok = in.nextToken();\n+              }\n+            if (tok != ';')\n+              error(url, in, \"expecting semicolon\");\n+            try\n+              {\n+                KeyStore keystore = KeyStore.getInstance(alg);\n+                keystore.load(new URL(url, store).openStream(), null);\n+                keystores.add(keystore);\n+              }\n+            catch (Exception x)\n+              {\n+                error(url, in, x.toString());\n+              }\n+          }\n+        else if (in.sval.equalsIgnoreCase(\"grant\"))\n+          {\n+            if (state != STATE_BEGIN)\n+              error(url, in, \"extraneous grant keyword\");\n+            state = STATE_GRANT;\n+          }\n+        else if (in.sval.equalsIgnoreCase(\"signedBy\"))\n+          {\n+            if (state != STATE_GRANT && state != STATE_PERMS)\n+              error(url, in, \"spurious 'signedBy'\");\n+            if (keystores.isEmpty())\n+              error(url, in, \"'signedBy' with no keystores\");\n+            tok = in.nextToken();\n+            if (tok != '\"' && tok != '\\'')\n+              error(url, in, \"expecting signedBy name\");\n+            StringTokenizer st = new StringTokenizer(in.sval, \",\");\n+            while (st.hasMoreTokens())\n+              {\n+                String alias = st.nextToken();\n+                for (Iterator it = keystores.iterator(); it.hasNext(); )\n+                  {\n+                    KeyStore keystore = (KeyStore) it.next();\n+                    try\n+                      {\n+                        if (keystore.isCertificateEntry(alias))\n+                          currentCerts.add(keystore.getCertificate(alias));\n+                      }\n+                    catch (KeyStoreException kse)\n+                      {\n+                        error(url, in, kse.toString());\n+                      }\n+                  }\n+              }\n+            tok = in.nextToken();\n+            if (tok != ',')\n+              {\n+                if (state != STATE_GRANT)\n+                  error(url, in, \"spurious ','\");\n+                in.pushBack();\n+              }\n+          }\n+        else if (in.sval.equalsIgnoreCase(\"codeBase\"))\n+          {\n+            if (state != STATE_GRANT)\n+              error(url, in, \"spurious 'codeBase'\");\n+            tok = in.nextToken();\n+            if (tok != '\"' && tok != '\\'')\n+              error(url, in, \"expecting code base URL\");\n+            String base = expand(in.sval);\n+            if (File.separatorChar != '/')\n+              base = base.replace(File.separatorChar, '/');\n+            try\n+              {\n+                currentBase = new URL(base);\n+              }\n+            catch (MalformedURLException mue)\n+              {\n+                error(url, in, mue.toString());\n+              }\n+            tok = in.nextToken();\n+            if (tok != ',')\n+              in.pushBack();\n+          }\n+        else if (in.sval.equalsIgnoreCase(\"principal\"))\n+          {\n+            if (state != STATE_GRANT)\n+              error(url, in, \"spurious 'principal'\");\n+            tok = in.nextToken();\n+            if (tok == StreamTokenizer.TT_WORD)\n+              {\n+                tok = in.nextToken();\n+                if (tok != '\"' && tok != '\\'')\n+                  error(url, in, \"expecting principal name\");\n+                String name = in.sval;\n+                Principal p = null;\n+                try\n+                  {\n+                    Class pclass = Class.forName(in.sval);\n+                    Constructor c =\n+                      pclass.getConstructor(new Class[] { String.class });\n+                    p = (Principal) c.newInstance(new Object[] { name });\n+                  }\n+                catch (Exception x)\n+                  {\n+                    error(url, in, x.toString());\n+                  }\n+                for (Iterator it = keystores.iterator(); it.hasNext(); )\n+                  {\n+                    KeyStore ks = (KeyStore) it.next();\n+                    try\n+                      {\n+                        for (Enumeration e = ks.aliases(); e.hasMoreElements(); )\n+                          {\n+                            String alias = (String) e.nextElement();\n+                            if (ks.isCertificateEntry(alias))\n+                              {\n+                                Certificate cert = ks.getCertificate(alias);\n+                                if (!(cert instanceof X509Certificate))\n+                                  continue;\n+                                if (p.equals(((X509Certificate) cert).getSubjectDN()) ||\n+                                    p.equals(((X509Certificate) cert).getSubjectX500Principal()))\n+                                  currentCerts.add(cert);\n+                              }\n+                          }\n+                      }\n+                    catch (KeyStoreException kse)\n+                      {\n+                        error(url, in, kse.toString());\n+                      }\n+                  }\n+              }\n+            else if (tok == '\"' || tok == '\\'')\n+              {\n+                String alias = in.sval;\n+                for (Iterator it = keystores.iterator(); it.hasNext(); )\n+                  {\n+                    KeyStore ks = (KeyStore) it.next();\n+                    try\n+                      {\n+                        if (ks.isCertificateEntry(alias))\n+                          currentCerts.add(ks.getCertificate(alias));\n+                      }\n+                    catch (KeyStoreException kse)\n+                      {\n+                        error(url, in, kse.toString());\n+                      }\n+                  }\n+              }\n+            else\n+              error(url, in, \"expecting principal\");\n+            tok = in.nextToken();\n+            if (tok != ',')\n+              in.pushBack();\n+          }\n+        else if (in.sval.equalsIgnoreCase(\"permission\"))\n+          {\n+            if (state != STATE_PERMS)\n+              error(url, in, \"spurious 'permission'\");\n+            tok = in.nextToken();\n+            if (tok != StreamTokenizer.TT_WORD)\n+              error(url, in, \"expecting permission class name\");\n+            String className = in.sval;\n+            Class clazz = null;\n+            try\n+              {\n+                clazz = Class.forName(className);\n+              }\n+            catch (ClassNotFoundException cnfe)\n+              {\n+              }\n+            tok = in.nextToken();\n+            if (tok == ';')\n+              {\n+                if (clazz == null)\n+                  {\n+                    currentPerms.add(new UnresolvedPermission(className,\n+                      null, null, (Certificate[]) currentCerts.toArray(new Certificate[0])));\n+                    continue;\n+                  }\n+                try\n+                  {\n+                    currentPerms.add((Permission) clazz.newInstance());\n+                  }\n+                catch (Exception x)\n+                  {\n+                    error(url, in, x.toString());\n+                  }\n+                continue;\n+              }\n+            if (tok != '\"' && tok != '\\'')\n+              error(url, in, \"expecting permission target\");\n+            String target = expand(in.sval);\n+            tok = in.nextToken();\n+            if (tok == ';')\n+              {\n+                if (clazz == null)\n+                  {\n+                    currentPerms.add(new UnresolvedPermission(className,\n+                      target, null, (Certificate[]) currentCerts.toArray(new Certificate[0])));\n+                    continue;\n+                  }\n+                try\n+                  {\n+                    Constructor c =\n+                      clazz.getConstructor(new Class[] { String.class });\n+                    currentPerms.add((Permission) c.newInstance(\n+                      new Object[] { target }));\n+                  }\n+                catch (Exception x)\n+                  {\n+                    error(url, in, x.toString());\n+                  }\n+                continue;\n+              }\n+            if (tok != ',')\n+              error(url, in, \"expecting ','\");\n+            tok = in.nextToken();\n+            if (tok == StreamTokenizer.TT_WORD)\n+              {\n+                if (!in.sval.equalsIgnoreCase(\"signedBy\"))\n+                  error(url, in, \"expecting 'signedBy'\");\n+                try\n+                  {\n+                    Constructor c =\n+                      clazz.getConstructor(new Class[] { String.class });\n+                    currentPerms.add((Permission) c.newInstance(\n+                      new Object[] { target }));\n+                  }\n+                catch (Exception x)\n+                  {\n+                    error(url, in, x.toString());\n+                  }\n+                in.pushBack();\n+                continue;\n+              }\n+            if (tok != '\"' && tok != '\\'')\n+              error(url, in, \"expecting permission action\");\n+            String action = in.sval;\n+            if (clazz == null)\n+              {\n+                currentPerms.add(new UnresolvedPermission(className,\n+                  target, action, (Certificate[]) currentCerts.toArray(new Certificate[0])));\n+                continue;\n+              }\n+            else\n+              {\n+                try\n+                  {\n+                    Constructor c = clazz.getConstructor(\n+                      new Class[] { String.class, String.class });\n+                    currentPerms.add((Permission) c.newInstance(\n+                      new Object[] { target, action }));\n+                  }\n+                catch (Exception x)\n+                  {\n+                    error(url, in, x.toString());\n+                  }\n+              }\n+            tok = in.nextToken();\n+            if (tok != ';' && tok != ',')\n+              error(url, in, \"expecting ';' or ','\");\n+          }\n+      }\n+  }\n+\n+  /**\n+   * Expand all instances of <code>\"${property-name}\"</code> into\n+   * <code>System.getProperty(\"property-name\")</code>.\n+   */\n+  private static String expand(final String s)\n+  {\n+    final StringBuffer result = new StringBuffer();\n+    final StringBuffer prop = new StringBuffer();\n+    int state = 0;\n+    for (int i = 0; i < s.length(); i++)\n+      {\n+        switch (state)\n+          {\n+          case 0:\n+            if (s.charAt(i) == '$')\n+              state = 1;\n+            else\n+              result.append(s.charAt(i));\n+            break;\n+          case 1:\n+            if (s.charAt(i) == '{')\n+              state = 2;\n+            else\n+              {\n+                state = 0;\n+                result.append('$').append(s.charAt(i));\n+              }\n+            break;\n+          case 2:\n+            if (s.charAt(i) == '}')\n+              {\n+                String p = prop.toString();\n+                if (p.equals(\"/\"))\n+                  p = \"file.separator\";\n+                p = System.getProperty(p);\n+                if (p == null)\n+                  p = \"\";\n+                result.append(p);\n+                prop.setLength(0);\n+                state = 0;\n+              }\n+            else\n+              prop.append(s.charAt(i));\n+            break;\n+          }\n+      }\n+    if (state != 0)\n+      result.append('$').append('{').append(prop);\n+    return result.toString();\n+  }\n+\n+  /**\n+   * I miss macros.\n+   */\n+  private static void error(URL base, StreamTokenizer in, String msg)\n+    throws IOException\n+  {\n+    throw new IOException(base+\":\"+in.lineno()+\": \"+msg);\n+  }\n+}"}]}