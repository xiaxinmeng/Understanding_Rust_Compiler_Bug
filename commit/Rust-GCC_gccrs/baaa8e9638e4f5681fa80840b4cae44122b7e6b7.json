{"sha": "baaa8e9638e4f5681fa80840b4cae44122b7e6b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFhYThlOTYzOGU0ZjU2ODFmYTgwODQwYjRjYWU0NDEyMmI3ZTZiNw==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-04-07T06:33:45Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-04-07T06:33:45Z"}, "message": "Sort static functions in topological order.\n\n2010-04-07  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* tree-if-conv.c: Sort static functions in topological order.\n\nFrom-SVN: r158040", "tree": {"sha": "90f4d6da57ba238c52414e74670dea987d11e058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90f4d6da57ba238c52414e74670dea987d11e058"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/baaa8e9638e4f5681fa80840b4cae44122b7e6b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baaa8e9638e4f5681fa80840b4cae44122b7e6b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baaa8e9638e4f5681fa80840b4cae44122b7e6b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baaa8e9638e4f5681fa80840b4cae44122b7e6b7/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6779d815b9ecbd5e1726b222901222e083e2047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6779d815b9ecbd5e1726b222901222e083e2047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6779d815b9ecbd5e1726b222901222e083e2047"}], "stats": {"total": 601, "additions": 285, "deletions": 316}, "files": [{"sha": "32a4bed2e173090323fb2185b8c3bc992f53926b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baaa8e9638e4f5681fa80840b4cae44122b7e6b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baaa8e9638e4f5681fa80840b4cae44122b7e6b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=baaa8e9638e4f5681fa80840b4cae44122b7e6b7", "patch": "@@ -1,3 +1,7 @@\n+2010-04-07  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-if-conv.c: Sort static functions in topological order.\n+\n 2010-04-07  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* tree-if-conv.c: Fix indentation and comments."}, {"sha": "3b2386aa329a620a0322dbb053860f836e11b4a7", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 281, "deletions": 316, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baaa8e9638e4f5681fa80840b4cae44122b7e6b7/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baaa8e9638e4f5681fa80840b4cae44122b7e6b7/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=baaa8e9638e4f5681fa80840b4cae44122b7e6b7", "patch": "@@ -100,119 +100,150 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"target.h\"\n \n-\n-/* local function prototypes */\n-static unsigned int main_tree_if_conversion (void);\n-static tree tree_if_convert_stmt (struct loop *loop, gimple, tree,\n-\t\t\t\t  gimple_stmt_iterator *);\n-static void tree_if_convert_cond_stmt (struct loop *, gimple, tree,\n-\t\t\t\t       gimple_stmt_iterator *);\n-static bool if_convertible_phi_p (struct loop *, basic_block, gimple);\n-static bool if_convertible_gimple_assign_stmt_p (struct loop *, basic_block,\n-    \t\t\t\t\t\t gimple);\n-static bool if_convertible_stmt_p (struct loop *, basic_block, gimple);\n-static bool if_convertible_bb_p (struct loop *, basic_block, basic_block);\n-static bool if_convertible_loop_p (struct loop *, bool);\n-static void add_to_predicate_list (basic_block, tree);\n-static tree add_to_dst_predicate_list (struct loop * loop, edge,\n-\t\t\t\t       tree, tree,\n-\t\t\t\t       gimple_stmt_iterator *);\n-static void clean_predicate_lists (struct loop *loop);\n-static basic_block find_phi_replacement_condition (struct loop *loop,\n-\t\t\t\t\t\t   basic_block, tree *,\n-\t\t\t\t\t\t   gimple_stmt_iterator *);\n-static void replace_phi_with_cond_gimple_assign_stmt (gimple, tree,\n-\t\t\t\t\t\t      basic_block,\n-\t\t\t\t\t\t      gimple_stmt_iterator *);\n-static void process_phi_nodes (struct loop *);\n-static void combine_blocks (struct loop *);\n-static gimple ifc_temp_var (tree, tree);\n-static bool pred_blocks_visited_p (basic_block, bitmap *);\n-static basic_block * get_loop_body_in_if_conv_order (const struct loop *loop);\n-static bool bb_with_exit_edge_p (struct loop *, basic_block);\n-\n /* List of basic blocks in if-conversion-suitable order.  */\n static basic_block *ifc_bbs;\n \n-/* Main entry point.  Apply if-conversion to the LOOP.  Return true if\n-   successful otherwise return false.  If false is returned then loop\n-   remains unchanged.  FOR_VECTORIZER is a boolean flag.  It indicates\n-   whether if-conversion is used for vectorizer or not.  If it is used\n-   for vectorizer, additional checks are used. (Vectorization checks\n-   are not yet implemented).  */\n+/* Make a new temp variable of type TYPE.  Add GIMPLE_ASSIGN to assign EXP\n+   to the new variable.  */\n \n-static bool\n-tree_if_conversion (struct loop *loop, bool for_vectorizer)\n+static gimple\n+ifc_temp_var (tree type, tree exp)\n {\n-  basic_block bb;\n-  gimple_stmt_iterator itr;\n-  unsigned int i;\n+  const char *name = \"_ifc_\";\n+  tree var, new_name;\n+  gimple stmt;\n \n-  ifc_bbs = NULL;\n+  /* Create new temporary variable.  */\n+  var = create_tmp_var (type, name);\n+  add_referenced_var (var);\n \n-  /* If-conversion is not appropriate for all loops.  First, check if\n-     loop is if-convertible or not.  */\n-  if (!if_convertible_loop_p (loop, for_vectorizer))\n+  /* Build new statement to assign EXP to new variable.  */\n+  stmt = gimple_build_assign (var, exp);\n+\n+  /* Get SSA name for the new variable and set make new statement\n+     its definition statement.  */\n+  new_name = make_ssa_name (var, stmt);\n+  gimple_assign_set_lhs (stmt, new_name);\n+  SSA_NAME_DEF_STMT (new_name) = stmt;\n+  update_stmt (stmt);\n+\n+  return stmt;\n+}\n+\n+/* Add condition COND into predicate list of basic block BB.  */\n+\n+static void\n+add_to_predicate_list (basic_block bb, tree new_cond)\n+{\n+  tree cond = (tree) bb->aux;\n+\n+  if (cond)\n+    cond = fold_build2_loc (EXPR_LOCATION (cond),\n+\t\t\tTRUTH_OR_EXPR, boolean_type_node,\n+\t\t\tunshare_expr (cond), new_cond);\n+  else\n+    cond = new_cond;\n+\n+  bb->aux = cond;\n+}\n+\n+/* Add condition COND into BB's predicate list.  PREV_COND is\n+   existing condition.  */\n+\n+static tree\n+add_to_dst_predicate_list (struct loop *loop, edge e,\n+\t\t\t   tree prev_cond, tree cond,\n+\t\t\t   gimple_stmt_iterator *gsi)\n+{\n+  tree new_cond = NULL_TREE;\n+\n+  if (!flow_bb_inside_loop_p (loop, e->dest))\n+    return NULL_TREE;\n+\n+  if (prev_cond == boolean_true_node || !prev_cond)\n+    new_cond = unshare_expr (cond);\n+  else\n     {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\"-------------------------\\n\");\n-      if (ifc_bbs)\n-\t{\n-\t  free (ifc_bbs);\n-\t  ifc_bbs = NULL;\n-\t}\n-      free_dominance_info (CDI_POST_DOMINATORS);\n-      return false;\n+      tree tmp;\n+      gimple tmp_stmt = NULL;\n+\n+      prev_cond = force_gimple_operand_gsi (gsi, unshare_expr (prev_cond),\n+\t\t\t\t\t    true, NULL, true, GSI_SAME_STMT);\n+\n+      cond = force_gimple_operand_gsi (gsi, unshare_expr (cond),\n+\t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n+\n+      /* Add the condition to aux field of the edge.  In case edge\n+\t destination is a PHI node, this condition will be ANDed with\n+\t block predicate to construct complete condition.  */\n+      e->aux = cond;\n+\n+      tmp = build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t    unshare_expr (prev_cond), cond);\n+      tmp_stmt = ifc_temp_var (boolean_type_node, tmp);\n+      gsi_insert_before (gsi, tmp_stmt, GSI_SAME_STMT);\n+      new_cond = gimple_assign_lhs (tmp_stmt);\n     }\n \n-  /* Do actual work now.  */\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      tree cond;\n+  add_to_predicate_list (e->dest, new_cond);\n+  return new_cond;\n+}\n \n-      bb = ifc_bbs [i];\n+/* Return true if one of the basic block BB edge is exit of LOOP.  */\n \n-      /* Update condition using predicate list.  */\n-      cond = (tree) bb->aux;\n+static bool\n+bb_with_exit_edge_p (struct loop *loop, basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  bool exit_edge_found = false;\n \n-      /* Process all statements in this basic block.\n-\t Remove conditional expression, if any, and annotate\n-\t destination basic block(s) appropriately.  */\n-      for (itr = gsi_start_bb (bb); !gsi_end_p (itr); /* empty */)\n-\t{\n-\t  gimple t = gsi_stmt (itr);\n-\t  cond = tree_if_convert_stmt (loop, t, cond, &itr);\n-\t  if (!gsi_end_p (itr))\n-\t    gsi_next (&itr);\n-\t}\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (loop_exit_edge_p (loop, e))\n+      {\n+\texit_edge_found = true;\n+\tbreak;\n+      }\n \n-      /* If current bb has only one successor, then consider it as an\n-\t unconditional goto.  */\n-      if (single_succ_p (bb))\n-\t{\n-\t  basic_block bb_n = single_succ (bb);\n+  return exit_edge_found;\n+}\n \n-\t  /* Successor bb inherits predicate of its predecessor.  If there\n-\t     is no predicate in predecessor bb, then consider successor bb\n-\t     as always executed.  */\n-\t  if (cond == NULL_TREE)\n-\t    cond = boolean_true_node;\n+/* STMT is a GIMPLE_COND.  Update two destination's predicate list.\n+   Remove COND_EXPR, if it is not the loop exit condition.  Otherwise\n+   update loop exit condition appropriately.  GSI is the iterator\n+   used to traverse statement list.  STMT is part of loop LOOP.  */\n \n-\t  add_to_predicate_list (bb_n, cond);\n-\t}\n-    }\n+static void\n+tree_if_convert_cond_stmt (struct loop *loop, gimple stmt, tree cond,\n+\t\t\t   gimple_stmt_iterator *gsi)\n+{\n+  tree c2;\n+  edge true_edge, false_edge;\n+  location_t loc = gimple_location (stmt);\n+  tree c = fold_build2_loc (loc, gimple_cond_code (stmt), boolean_type_node,\n+\t\t\t    gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n \n-  /* Now, all statements are if-converted and basic blocks are\n-     annotated appropriately.  Combine all basic block into one huge\n-     basic block.  */\n-  combine_blocks (loop);\n+  extract_true_false_edges_from_block (gimple_bb (stmt),\n+ \t\t\t\t       &true_edge, &false_edge);\n \n-  /* clean up */\n-  clean_predicate_lists (loop);\n-  free (ifc_bbs);\n-  ifc_bbs = NULL;\n+  /* Add new condition into destination's predicate list.  */\n \n-  return true;\n+  /* If C is true, then TRUE_EDGE is taken.  */\n+  add_to_dst_predicate_list (loop, true_edge, cond, c, gsi);\n+\n+  /* If C is false, then FALSE_EDGE is taken.  */\n+  c2 = invert_truthvalue_loc (loc, unshare_expr (c));\n+  add_to_dst_predicate_list (loop, false_edge, cond, c2, gsi);\n+\n+  /* Now this conditional statement is redundant.  Remove it.\n+     But, do not remove exit condition!  Update exit condition\n+     using new condition.  */\n+  if (!bb_with_exit_edge_p (loop, gimple_bb (stmt)))\n+    {\n+      gsi_remove (gsi, true);\n+      cond = NULL_TREE;\n+    }\n+  return;\n }\n \n /* If-convert stmt T which is part of LOOP.\n@@ -269,47 +300,6 @@ tree_if_convert_stmt (struct loop *  loop, gimple t, tree cond,\n   return cond;\n }\n \n-/* STMT is a GIMPLE_COND.  Update two destination's predicate list.\n-   Remove COND_EXPR, if it is not the loop exit condition.  Otherwise\n-   update loop exit condition appropriately.  GSI is the iterator\n-   used to traverse statement list.  STMT is part of loop LOOP.  */\n-\n-static void\n-tree_if_convert_cond_stmt (struct loop *loop, gimple stmt, tree cond,\n-\t\t\t   gimple_stmt_iterator *gsi)\n-{\n-  tree c, c2;\n-  edge true_edge, false_edge;\n-  location_t loc = gimple_location (stmt);\n-\n-  gcc_assert (gimple_code (stmt) == GIMPLE_COND);\n-\n-  c = fold_build2_loc (loc, gimple_cond_code (stmt), boolean_type_node,\n-\t\t   gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n-\n-  extract_true_false_edges_from_block (gimple_bb (stmt),\n- \t\t\t\t       &true_edge, &false_edge);\n-\n-  /* Add new condition into destination's predicate list.  */\n-\n-  /* If C is true, then TRUE_EDGE is taken.  */\n-  add_to_dst_predicate_list (loop, true_edge, cond, c, gsi);\n-\n-  /* If C is false, then FALSE_EDGE is taken.  */\n-  c2 = invert_truthvalue_loc (loc, unshare_expr (c));\n-  add_to_dst_predicate_list (loop, false_edge, cond, c2, gsi);\n-\n-  /* Now this conditional statement is redundant.  Remove it.\n-     But, do not remove exit condition!  Update exit condition\n-     using new condition.  */\n-  if (!bb_with_exit_edge_p (loop, gimple_bb (stmt)))\n-    {\n-      gsi_remove (gsi, true);\n-      cond = NULL_TREE;\n-    }\n-  return;\n-}\n-\n /* Return true, iff PHI is if-convertible.  PHI is part of loop LOOP\n    and it belongs to basic block BB.\n    PHI is not if-convertible\n@@ -485,31 +475,105 @@ if_convertible_bb_p (struct loop *loop, basic_block bb, basic_block exit_bb)\n \t}\n       else if (!empty_block_p (bb))\n \t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"non empty basic block after exit bb\\n\");\n-\t  return false;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"non empty basic block after exit bb\\n\");\n+\t  return false;\n+\t}\n+      else if (bb == loop->latch\n+\t       && bb != exit_bb\n+\t       && !dominated_by_p (CDI_DOMINATORS, bb, exit_bb))\n+\t  {\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      fprintf (dump_file, \"latch is not dominated by exit_block\\n\");\n+\t    return false;\n+\t  }\n+    }\n+\n+  /* Be less adventurous and handle only normal edges.  */\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e->flags &\n+\t(EDGE_ABNORMAL_CALL | EDGE_EH | EDGE_ABNORMAL | EDGE_IRREDUCIBLE_LOOP))\n+      {\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file,\"Difficult to handle edges\\n\");\n+\treturn false;\n+      }\n+\n+  return true;\n+}\n+\n+/* Return TRUE iff, all pred blocks of BB are visited.\n+   Bitmap VISITED keeps history of visited blocks.  */\n+\n+static bool\n+pred_blocks_visited_p (basic_block bb, bitmap *visited)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (!bitmap_bit_p (*visited, e->src->index))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Get body of a LOOP in suitable order for if-conversion.  It is\n+   caller's responsibility to deallocate basic block list.\n+   If-conversion suitable order is, breadth first sort (BFS) order\n+   with an additional constraint: select a block only if all its\n+   predecessors are already selected.  */\n+\n+static basic_block *\n+get_loop_body_in_if_conv_order (const struct loop *loop)\n+{\n+  basic_block *blocks, *blocks_in_bfs_order;\n+  basic_block bb;\n+  bitmap visited;\n+  unsigned int index = 0;\n+  unsigned int visited_count = 0;\n+\n+  gcc_assert (loop->num_nodes);\n+  gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n+\n+  blocks = XCNEWVEC (basic_block, loop->num_nodes);\n+  visited = BITMAP_ALLOC (NULL);\n+\n+  blocks_in_bfs_order = get_loop_body_in_bfs_order (loop);\n+\n+  index = 0;\n+  while (index < loop->num_nodes)\n+    {\n+      bb = blocks_in_bfs_order [index];\n+\n+      if (bb->flags & BB_IRREDUCIBLE_LOOP)\n+\t{\n+\t  free (blocks_in_bfs_order);\n+\t  BITMAP_FREE (visited);\n+\t  free (blocks);\n+\t  return NULL;\n+\t}\n+\n+      if (!bitmap_bit_p (visited, bb->index))\n+\t{\n+\t  if (pred_blocks_visited_p (bb, &visited)\n+\t      || bb == loop->header)\n+\t    {\n+\t      /* This block is now visited.  */\n+\t      bitmap_set_bit (visited, bb->index);\n+\t      blocks[visited_count++] = bb;\n+\t    }\n \t}\n-      else if (bb == loop->latch\n-\t       && bb != exit_bb\n-\t       && !dominated_by_p (CDI_DOMINATORS, bb, exit_bb))\n-\t  {\n-\t    if (dump_file && (dump_flags & TDF_DETAILS))\n-\t      fprintf (dump_file, \"latch is not dominated by exit_block\\n\");\n-\t    return false;\n-\t  }\n-    }\n \n-  /* Be less adventurous and handle only normal edges.  */\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->flags &\n-\t(EDGE_ABNORMAL_CALL | EDGE_EH | EDGE_ABNORMAL | EDGE_IRREDUCIBLE_LOOP))\n-      {\n-\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t  fprintf (dump_file,\"Difficult to handle edges\\n\");\n-\treturn false;\n-      }\n+      index++;\n \n-  return true;\n+      if (index == loop->num_nodes\n+\t  && visited_count != loop->num_nodes)\n+\t/* Not done yet.  */\n+\tindex = 0;\n+    }\n+  free (blocks_in_bfs_order);\n+  BITMAP_FREE (visited);\n+  return blocks;\n }\n \n /* Return true, iff LOOP is if-convertible.\n@@ -613,65 +677,6 @@ if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n   return true;\n }\n \n-/* Add condition COND into predicate list of basic block BB.  */\n-\n-static void\n-add_to_predicate_list (basic_block bb, tree new_cond)\n-{\n-  tree cond = (tree) bb->aux;\n-\n-  if (cond)\n-    cond = fold_build2_loc (EXPR_LOCATION (cond),\n-\t\t\tTRUTH_OR_EXPR, boolean_type_node,\n-\t\t\tunshare_expr (cond), new_cond);\n-  else\n-    cond = new_cond;\n-\n-  bb->aux = cond;\n-}\n-\n-/* Add condition COND into BB's predicate list.  PREV_COND is\n-   existing condition.  */\n-\n-static tree\n-add_to_dst_predicate_list (struct loop * loop, edge e,\n-\t\t\t   tree prev_cond, tree cond,\n-\t\t\t   gimple_stmt_iterator *gsi)\n-{\n-  tree new_cond = NULL_TREE;\n-\n-  if (!flow_bb_inside_loop_p (loop, e->dest))\n-    return NULL_TREE;\n-\n-  if (prev_cond == boolean_true_node || !prev_cond)\n-    new_cond = unshare_expr (cond);\n-  else\n-    {\n-      tree tmp;\n-      gimple tmp_stmt = NULL;\n-\n-      prev_cond = force_gimple_operand_gsi (gsi, unshare_expr (prev_cond),\n-\t\t\t\t\t    true, NULL, true, GSI_SAME_STMT);\n-\n-      cond = force_gimple_operand_gsi (gsi, unshare_expr (cond),\n-\t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n-\n-      /* Add the condition to aux field of the edge.  In case edge\n-\t destination is a PHI node, this condition will be ANDed with\n-\t block predicate to construct complete condition.  */\n-      e->aux = cond;\n-\n-      /* new_cond == prev_cond AND cond */\n-      tmp = build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t    unshare_expr (prev_cond), cond);\n-      tmp_stmt = ifc_temp_var (boolean_type_node, tmp);\n-      gsi_insert_before (gsi, tmp_stmt, GSI_SAME_STMT);\n-      new_cond = gimple_assign_lhs (tmp_stmt);\n-    }\n-  add_to_predicate_list (e->dest, new_cond);\n-  return new_cond;\n-}\n-\n /* During if-conversion aux field from basic block structure is used to hold\n    predicate list.  Clean each basic block's predicate list for the given LOOP.\n    Also clean aux field of successor edges, used to hold true and false\n@@ -1015,125 +1020,85 @@ combine_blocks (struct loop *loop)\n     merge_blocks (loop->header, exit_bb);\n }\n \n-/* Make a new temp variable of type TYPE.  Add GIMPLE_ASSIGN to assign EXP\n-   to the new variable.  */\n-\n-static gimple\n-ifc_temp_var (tree type, tree exp)\n-{\n-  const char *name = \"_ifc_\";\n-  tree var, new_name;\n-  gimple stmt;\n-\n-  /* Create new temporary variable.  */\n-  var = create_tmp_var (type, name);\n-  add_referenced_var (var);\n-\n-  /* Build new statement to assign EXP to new variable.  */\n-  stmt = gimple_build_assign (var, exp);\n-\n-  /* Get SSA name for the new variable and set make new statement\n-     its definition statement.  */\n-  new_name = make_ssa_name (var, stmt);\n-  gimple_assign_set_lhs (stmt, new_name);\n-  SSA_NAME_DEF_STMT (new_name) = stmt;\n-  update_stmt (stmt);\n-\n-  return stmt;\n-}\n-\n-\n-/* Return TRUE iff, all pred blocks of BB are visited.\n-   Bitmap VISITED keeps history of visited blocks.  */\n+/* Main entry point.  Apply if-conversion to the LOOP.  Return true if\n+   successful otherwise return false.  If false is returned then loop\n+   remains unchanged.  FOR_VECTORIZER is a boolean flag.  It indicates\n+   whether if-conversion is used for vectorizer or not.  If it is used\n+   for vectorizer, additional checks are used. (Vectorization checks\n+   are not yet implemented).  */\n \n static bool\n-pred_blocks_visited_p (basic_block bb, bitmap *visited)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (!bitmap_bit_p (*visited, e->src->index))\n-      return false;\n-\n-  return true;\n-}\n-\n-/* Get body of a LOOP in suitable order for if-conversion.  It is\n-   caller's responsibility to deallocate basic block list.\n-   If-conversion suitable order is, breadth first sort (BFS) order\n-   with an additional constraint: select a block only if all its\n-   predecessors are already selected.  */\n-\n-static basic_block *\n-get_loop_body_in_if_conv_order (const struct loop *loop)\n+tree_if_conversion (struct loop *loop, bool for_vectorizer)\n {\n-  basic_block *blocks, *blocks_in_bfs_order;\n   basic_block bb;\n-  bitmap visited;\n-  unsigned int index = 0;\n-  unsigned int visited_count = 0;\n-\n-  gcc_assert (loop->num_nodes);\n-  gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n+  gimple_stmt_iterator itr;\n+  unsigned int i;\n \n-  blocks = XCNEWVEC (basic_block, loop->num_nodes);\n-  visited = BITMAP_ALLOC (NULL);\n+  ifc_bbs = NULL;\n \n-  blocks_in_bfs_order = get_loop_body_in_bfs_order (loop);\n+  /* If-conversion is not appropriate for all loops.  First, check if\n+     loop is if-convertible or not.  */\n+  if (!if_convertible_loop_p (loop, for_vectorizer))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\"-------------------------\\n\");\n+      if (ifc_bbs)\n+\t{\n+\t  free (ifc_bbs);\n+\t  ifc_bbs = NULL;\n+\t}\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+      return false;\n+    }\n \n-  index = 0;\n-  while (index < loop->num_nodes)\n+  /* Do actual work now.  */\n+  for (i = 0; i < loop->num_nodes; i++)\n     {\n-      bb = blocks_in_bfs_order [index];\n+      tree cond;\n \n-      if (bb->flags & BB_IRREDUCIBLE_LOOP)\n+      bb = ifc_bbs [i];\n+\n+      /* Update condition using predicate list.  */\n+      cond = (tree) bb->aux;\n+\n+      /* Process all statements in this basic block.\n+\t Remove conditional expression, if any, and annotate\n+\t destination basic block(s) appropriately.  */\n+      for (itr = gsi_start_bb (bb); !gsi_end_p (itr); /* empty */)\n \t{\n-\t  free (blocks_in_bfs_order);\n-\t  BITMAP_FREE (visited);\n-\t  free (blocks);\n-\t  return NULL;\n+\t  gimple t = gsi_stmt (itr);\n+\t  cond = tree_if_convert_stmt (loop, t, cond, &itr);\n+\t  if (!gsi_end_p (itr))\n+\t    gsi_next (&itr);\n \t}\n \n-      if (!bitmap_bit_p (visited, bb->index))\n+      /* If current bb has only one successor, then consider it as an\n+\t unconditional goto.  */\n+      if (single_succ_p (bb))\n \t{\n-\t  if (pred_blocks_visited_p (bb, &visited)\n-\t      || bb == loop->header)\n-\t    {\n-\t      /* This block is now visited.  */\n-\t      bitmap_set_bit (visited, bb->index);\n-\t      blocks[visited_count++] = bb;\n-\t    }\n-\t}\n+\t  basic_block bb_n = single_succ (bb);\n \n-      index++;\n+\t  /* Successor bb inherits predicate of its predecessor.  If there\n+\t     is no predicate in predecessor bb, then consider successor bb\n+\t     as always executed.  */\n+\t  if (cond == NULL_TREE)\n+\t    cond = boolean_true_node;\n \n-      if (index == loop->num_nodes\n-\t  && visited_count != loop->num_nodes)\n-\t/* Not done yet.  */\n-\tindex = 0;\n+\t  add_to_predicate_list (bb_n, cond);\n+\t}\n     }\n-  free (blocks_in_bfs_order);\n-  BITMAP_FREE (visited);\n-  return blocks;\n-}\n \n-/* Return true if one of the basic block BB edge is exit of LOOP.  */\n-\n-static bool\n-bb_with_exit_edge_p (struct loop *loop, basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  bool exit_edge_found = false;\n+  /* Now, all statements are if-converted and basic blocks are\n+     annotated appropriately.  Combine all basic block into one huge\n+     basic block.  */\n+  combine_blocks (loop);\n \n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (loop_exit_edge_p (loop, e))\n-      {\n-\texit_edge_found = true;\n-\tbreak;\n-      }\n+  /* clean up */\n+  clean_predicate_lists (loop);\n+  free (ifc_bbs);\n+  ifc_bbs = NULL;\n \n-  return exit_edge_found;\n+  return true;\n }\n \n /* Tree if-conversion pass management.  */"}]}