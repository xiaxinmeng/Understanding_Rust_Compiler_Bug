{"sha": "d0047a2538bc3381a7cf94e714f05b4b96799f6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDAwNDdhMjUzOGJjMzM4MWE3Y2Y5NGU3MTRmMDViNGI5Njc5OWY2ZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-07-30T22:31:16Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-07-30T22:31:16Z"}, "message": "rs6000-protos.h (rs6000_adjust_vec_address): New function that takes a vector memory address...\n\n[gcc]\n2016-07-30  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-protos.h (rs6000_adjust_vec_address): New\n\tfunction that takes a vector memory address, a hard register, an\n\telement number and a temporary base register, and recreates an\n\taddress that points to the appropriate element within the vector.\n\t* config/rs6000/rs6000.c (rs6000_adjust_vec_address): Likewise.\n\t(rs6000_split_vec_extract_var): Add support for the target of a\n\tvec_extract with variable element number being a scalar memory\n\tlocation.\n\t(rtx_is_swappable_p): VLSO insns (UNSPEC_VSX_VSLOW) are not\n\tswappable.\n\t* config/rs6000/vsx.md (vsx_extract_<mode>_load): Replace\n\tvsx_extract_<mode>_load insn with a new insn that optimizes\n\tstoring either element to a memory location, using scratch\n\tregisters to pick apart the vector and reconstruct the address.\n\t(vsx_extract_<P:mode>_<VSX_D:mode>_load): Likewise.\n\t(vsx_extract_<mode>_store): Rework alternatives to more correctly\n\tsupport Altivec registers.  Add support for ISA 3.0 Altivec d-form\n\tstore instruction.\n\t(vsx_extract_<mode>_var): Add support for extracting a variable\n\telement number from memory.\n\n[gcc/testsuite]\n2016-07-30  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/vec-extract-2.c: New tests for vec_extract of\n\tvector double or vector long where the vector is in memory.\n\t* gcc.target/powerpc/vec-extract-3.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-4.c: Likewise.\n\nFrom-SVN: r238908", "tree": {"sha": "ce2e857add0d8aafaac59fbb99998feafea30d1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce2e857add0d8aafaac59fbb99998feafea30d1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0047a2538bc3381a7cf94e714f05b4b96799f6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0047a2538bc3381a7cf94e714f05b4b96799f6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0047a2538bc3381a7cf94e714f05b4b96799f6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0047a2538bc3381a7cf94e714f05b4b96799f6d/comments", "author": null, "committer": null, "parents": [{"sha": "e4f7a5dffe280edf9dcc57f50005fac5f71fcccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4f7a5dffe280edf9dcc57f50005fac5f71fcccb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4f7a5dffe280edf9dcc57f50005fac5f71fcccb"}], "stats": {"total": 336, "additions": 313, "deletions": 23}, "files": [{"sha": "a394f345e4211f799aa8929db633302da37e3656", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0047a2538bc3381a7cf94e714f05b4b96799f6d", "patch": "@@ -1,3 +1,26 @@\n+2016-07-30  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_adjust_vec_address): New\n+\tfunction that takes a vector memory address, a hard register, an\n+\telement number and a temporary base register, and recreates an\n+\taddress that points to the appropriate element within the vector.\n+\t* config/rs6000/rs6000.c (rs6000_adjust_vec_address): Likewise.\n+\t(rs6000_split_vec_extract_var): Add support for the target of a\n+\tvec_extract with variable element number being a scalar memory\n+\tlocation.\n+\t(rtx_is_swappable_p): VLSO insns (UNSPEC_VSX_VSLOW) are not\n+\tswappable.\n+\t* config/rs6000/vsx.md (vsx_extract_<mode>_load): Replace\n+\tvsx_extract_<mode>_load insn with a new insn that optimizes\n+\tstoring either element to a memory location, using scratch\n+\tregisters to pick apart the vector and reconstruct the address.\n+\t(vsx_extract_<P:mode>_<VSX_D:mode>_load): Likewise.\n+\t(vsx_extract_<mode>_store): Rework alternatives to more correctly\n+\tsupport Altivec registers.  Add support for ISA 3.0 Altivec d-form\n+\tstore instruction.\n+\t(vsx_extract_<mode>_var): Add support for extracting a variable\n+\telement number from memory.\n+\n 2016-07-29  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr/avr.c (avr_out_compare): Use const0_rtx instead of 0"}, {"sha": "8a307a85e6f270069eb95532eecead55551f9678", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=d0047a2538bc3381a7cf94e714f05b4b96799f6d", "patch": "@@ -63,6 +63,7 @@ extern void paired_expand_vector_init (rtx, rtx);\n extern void rs6000_expand_vector_set (rtx, rtx, int);\n extern void rs6000_expand_vector_extract (rtx, rtx, rtx);\n extern void rs6000_split_vec_extract_var (rtx, rtx, rtx, rtx, rtx);\n+extern rtx rs6000_adjust_vec_address (rtx, rtx, rtx, rtx, machine_mode);\n extern bool altivec_expand_vec_perm_const (rtx op[4]);\n extern void altivec_expand_vec_perm_le (rtx op[4]);\n extern bool rs6000_expand_vec_perm_const (rtx op[4]);"}, {"sha": "567749c5cb1c5965c2576b307e1a1e9b01e23c5e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 171, "deletions": 1, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d0047a2538bc3381a7cf94e714f05b4b96799f6d", "patch": "@@ -7001,6 +7001,164 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n   emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));\n }\n \n+/* Adjust a memory address (MEM) of a vector type to point to a scalar field\n+   within the vector (ELEMENT) with a mode (SCALAR_MODE).  Use a base register\n+   temporary (BASE_TMP) to fixup the address.  Return the new memory address\n+   that is valid for reads or writes to a given register (SCALAR_REG).  */\n+\n+rtx\n+rs6000_adjust_vec_address (rtx scalar_reg,\n+\t\t\t   rtx mem,\n+\t\t\t   rtx element,\n+\t\t\t   rtx base_tmp,\n+\t\t\t   machine_mode scalar_mode)\n+{\n+  unsigned scalar_size = GET_MODE_SIZE (scalar_mode);\n+  rtx addr = XEXP (mem, 0);\n+  rtx element_offset;\n+  rtx new_addr;\n+  bool valid_addr_p;\n+\n+  /* Vector addresses should not have PRE_INC, PRE_DEC, or PRE_MODIFY.  */\n+  gcc_assert (GET_RTX_CLASS (GET_CODE (addr)) != RTX_AUTOINC);\n+\n+  /* Calculate what we need to add to the address to get the element\n+     address.  */\n+  if (CONST_INT_P (element))\n+    element_offset = GEN_INT (INTVAL (element) * scalar_size);\n+  else\n+    {\n+      int byte_shift = exact_log2 (scalar_size);\n+      gcc_assert (byte_shift >= 0);\n+\n+      if (byte_shift == 0)\n+\telement_offset = element;\n+\n+      else\n+\t{\n+\t  if (TARGET_POWERPC64)\n+\t    emit_insn (gen_ashldi3 (base_tmp, element, GEN_INT (byte_shift)));\n+\t  else\n+\t    emit_insn (gen_ashlsi3 (base_tmp, element, GEN_INT (byte_shift)));\n+\n+\t  element_offset = base_tmp;\n+\t}\n+    }\n+\n+  /* Create the new address pointing to the element within the vector.  If we\n+     are adding 0, we don't have to change the address.  */\n+  if (element_offset == const0_rtx)\n+    new_addr = addr;\n+\n+  /* A simple indirect address can be converted into a reg + offset\n+     address.  */\n+  else if (REG_P (addr) || SUBREG_P (addr))\n+    new_addr = gen_rtx_PLUS (Pmode, addr, element_offset);\n+\n+  /* Optimize D-FORM addresses with constant offset with a constant element, to\n+     include the element offset in the address directly.  */\n+  else if (GET_CODE (addr) == PLUS)\n+    {\n+      rtx op0 = XEXP (addr, 0);\n+      rtx op1 = XEXP (addr, 1);\n+      rtx insn;\n+\n+      gcc_assert (REG_P (op0) || SUBREG_P (op0));\n+      if (CONST_INT_P (op1) && CONST_INT_P (element_offset))\n+\t{\n+\t  HOST_WIDE_INT offset = INTVAL (op1) + INTVAL (element_offset);\n+\t  rtx offset_rtx = GEN_INT (offset);\n+\n+\t  if (IN_RANGE (offset, -32768, 32767)\n+\t      && (scalar_size < 8 || (offset & 0x3) == 0))\n+\t    new_addr = gen_rtx_PLUS (Pmode, op0, offset_rtx);\n+\t  else\n+\t    {\n+\t      emit_move_insn (base_tmp, offset_rtx);\n+\t      new_addr = gen_rtx_PLUS (Pmode, op0, base_tmp);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (REG_P (op1) || SUBREG_P (op1))\n+\t    {\n+\t      insn = gen_add3_insn (base_tmp, op1, element_offset);\n+\t      gcc_assert (insn != NULL_RTX);\n+\t      emit_insn (insn);\n+\t    }\n+\n+\t  else if (REG_P (element_offset) || SUBREG_P (element_offset))\n+\t    {\n+\t      insn = gen_add3_insn (base_tmp, element_offset, op1);\n+\t      gcc_assert (insn != NULL_RTX);\n+\t      emit_insn (insn);\n+\t    }\n+\n+\t  else\n+\t    {\n+\t      emit_move_insn (base_tmp, op1);\n+\t      emit_insn (gen_add2_insn (base_tmp, element_offset));\n+\t    }\n+\n+\t  new_addr = gen_rtx_PLUS (Pmode, op0, base_tmp);\n+\t}\n+    }\n+\n+  else\n+    {\n+      emit_move_insn (base_tmp, addr);\n+      new_addr = gen_rtx_PLUS (Pmode, base_tmp, element_offset);\n+    }\n+\n+  /* If we have a PLUS, we need to see whether the particular register class\n+     allows for D-FORM or X-FORM addressing.  */\n+  if (GET_CODE (new_addr) == PLUS)\n+    {\n+      rtx op1 = XEXP (new_addr, 1);\n+      addr_mask_type addr_mask;\n+      int scalar_regno;\n+\n+      if (REG_P (scalar_reg))\n+\tscalar_regno = REGNO (scalar_reg);\n+      else if (SUBREG_P (scalar_reg))\n+\tscalar_regno = subreg_regno (scalar_reg);\n+      else\n+\tgcc_unreachable ();\n+\n+      gcc_assert (scalar_regno < FIRST_PSEUDO_REGISTER);\n+      if (INT_REGNO_P (scalar_regno))\n+\taddr_mask = reg_addr[scalar_mode].addr_mask[RELOAD_REG_GPR];\n+\n+      else if (FP_REGNO_P (scalar_regno))\n+\taddr_mask = reg_addr[scalar_mode].addr_mask[RELOAD_REG_FPR];\n+\n+      else if (ALTIVEC_REGNO_P (scalar_regno))\n+\taddr_mask = reg_addr[scalar_mode].addr_mask[RELOAD_REG_VMX];\n+\n+      else\n+\tgcc_unreachable ();\n+\n+      if (REG_P (op1) || SUBREG_P (op1))\n+\tvalid_addr_p = (addr_mask & RELOAD_REG_INDEXED) != 0;\n+      else\n+\tvalid_addr_p = (addr_mask & RELOAD_REG_OFFSET) != 0;\n+    }\n+\n+  else if (REG_P (new_addr) || SUBREG_P (new_addr))\n+    valid_addr_p = true;\n+\n+  else\n+    valid_addr_p = false;\n+\n+  if (!valid_addr_p)\n+    {\n+      emit_move_insn (base_tmp, new_addr);\n+      new_addr = base_tmp;\n+    }\n+\n+  return change_address (mem, scalar_mode, new_addr);\n+}\n+\n /* Split a variable vec_extract operation into the component instructions.  */\n \n void\n@@ -7014,7 +7172,18 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n \n   gcc_assert (byte_shift >= 0);\n \n-  if (REG_P (src) || SUBREG_P (src))\n+  /* If we are given a memory address, optimize to load just the element.  We\n+     don't have to adjust the vector element number on little endian\n+     systems.  */\n+  if (MEM_P (src))\n+    {\n+      gcc_assert (REG_P (tmp_gpr));\n+      emit_move_insn (dest, rs6000_adjust_vec_address (dest, src, element,\n+\t\t\t\t\t\t       tmp_gpr, scalar_mode));\n+      return;\n+    }\n+\n+  else if (REG_P (src) || SUBREG_P (src))\n     {\n       int bit_shift = byte_shift + 3;\n       rtx element2;\n@@ -38759,6 +38928,7 @@ rtx_is_swappable_p (rtx op, unsigned int *special)\n \t  case UNSPEC_VSX_CVSPDP:\n \t  case UNSPEC_VSX_CVSPDPN:\n \t  case UNSPEC_VSX_EXTRACT:\n+\t  case UNSPEC_VSX_VSLO:\n \t    return 0;\n \t  case UNSPEC_VSPLT_DIRECT:\n \t    *special = SH_SPLAT;"}, {"sha": "b66b1affd7ced8a61ca3cda4ad22b89bea7299eb", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=d0047a2538bc3381a7cf94e714f05b4b96799f6d", "patch": "@@ -2174,33 +2174,36 @@\n }\n   [(set_attr \"type\" \"veclogical,mftgpr,mftgpr,vecperm\")])\n \n-;; Optimize extracting a single scalar element from memory if the scalar is in\n-;; the correct location to use a single load.\n-(define_insn \"*vsx_extract_<mode>_load\"\n-  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"=d,wv,wr\")\n-\t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_D 1 \"memory_operand\" \"m,Z,m\")\n-\t (parallel [(const_int 0)])))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"@\n-   lfd%U1%X1 %0,%1\n-   lxsd%U1x %x0,%y1\n-   ld%U1%X1 %0,%1\"\n-  [(set_attr \"type\" \"fpload,fpload,load\")\n-   (set_attr \"length\" \"4\")])\n+;; Optimize extracting a single scalar element from memory.\n+(define_insn_and_split \"*vsx_extract_<P:mode>_<VSX_D:mode>_load\"\n+  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"=<VSX_D:VS_64reg>,wr\")\n+\t(vec_select:<VSX_D:VS_scalar>\n+\t (match_operand:VSX_D 1 \"memory_operand\" \"m,m\")\n+\t (parallel [(match_operand:QI 2 \"const_0_to_1_operand\" \"n,n\")])))\n+   (clobber (match_scratch:P 3 \"=&b,&b\"))]\n+  \"VECTOR_MEM_VSX_P (<VSX_D:MODE>mode)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 4))]\n+{\n+  operands[4] = rs6000_adjust_vec_address (operands[0], operands[1], operands[2],\n+\t\t\t\t\t   operands[3], <VSX_D:VS_scalar>mode);\n+}\n+  [(set_attr \"type\" \"fpload,load\")\n+   (set_attr \"length\" \"8\")])\n \n ;; Optimize storing a single scalar element that is the right location to\n ;; memory\n (define_insn \"*vsx_extract_<mode>_store\"\n-  [(set (match_operand:<VS_scalar> 0 \"memory_operand\" \"=m,Z,?Z\")\n+  [(set (match_operand:<VS_scalar> 0 \"memory_operand\" \"=m,Z,o\")\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_D 1 \"register_operand\" \"d,wd,<VSa>\")\n+\t (match_operand:VSX_D 1 \"register_operand\" \"d,wv,wb\")\n \t (parallel [(match_operand:QI 2 \"vsx_scalar_64bit\" \"wD,wD,wD\")])))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"@\n    stfd%U0%X0 %1,%0\n    stxsd%U0x %x1,%y0\n-   stxsd%U0x %x1,%y0\"\n+   stxsd %1,%0\"\n   [(set_attr \"type\" \"fpstore\")\n    (set_attr \"length\" \"4\")])\n \n@@ -2216,12 +2219,12 @@\n \n ;; Variable V2DI/V2DF extract\n (define_insn_and_split \"vsx_extract_<mode>_var\"\n-  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=v\")\n-\t(unspec:<VS_scalar> [(match_operand:VSX_D 1 \"input_operand\" \"v\")\n-\t\t\t     (match_operand:DI 2 \"gpc_reg_operand\" \"r\")]\n+  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=v,<VSa>,r\")\n+\t(unspec:<VS_scalar> [(match_operand:VSX_D 1 \"input_operand\" \"v,m,m\")\n+\t\t\t     (match_operand:DI 2 \"gpc_reg_operand\" \"r,r,r\")]\n \t\t\t    UNSPEC_VSX_EXTRACT))\n-   (clobber (match_scratch:DI 3 \"=r\"))\n-   (clobber (match_scratch:V2DI 4 \"=&v\"))]\n+   (clobber (match_scratch:DI 3 \"=r,&b,&b\"))\n+   (clobber (match_scratch:V2DI 4 \"=&v,X,X\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n   \"#\"\n   \"&& reload_completed\""}, {"sha": "8a2d5c8850b00077f1e5d0739502e84dfd371556", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d0047a2538bc3381a7cf94e714f05b4b96799f6d", "patch": "@@ -1,3 +1,10 @@\n+2016-07-30  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/vec-extract-2.c: New tests for vec_extract of\n+\tvector double or vector long where the vector is in memory.\n+\t* gcc.target/powerpc/vec-extract-3.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-4.c: Likewise.\n+\n 2016-07-30  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/69867"}, {"sha": "efad62cca9fdd37b3c084f43c9ccb4cd5f74d027", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-2.c?ref=d0047a2538bc3381a7cf94e714f05b4b96799f6d", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#include <altivec.h>\n+\n+double\n+add_double_0 (vector double *p, double x)\n+{\n+  return vec_extract (*p, 0) + x;\n+}\n+\n+double\n+add_double_1 (vector double *p, double x)\n+{\n+  return vec_extract (*p, 1) + x;\n+}\n+\n+long\n+add_long_0 (vector long *p, long x)\n+{\n+  return vec_extract (*p, 0) + x;\n+}\n+\n+long\n+add_long_1 (vector long *p, long x)\n+{\n+  return vec_extract (*p, 1) + x;\n+}\n+\n+/* { dg-final { scan-assembler-not \"lxvd2x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvx\"     } } */\n+/* { dg-final { scan-assembler-not \"lxv\"      } } */\n+/* { dg-final { scan-assembler-not \"lvx\"      } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */"}, {"sha": "62649ce9e42e1fd907b9810c4e46a45fd5020acf", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-3.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-3.c?ref=d0047a2538bc3381a7cf94e714f05b4b96799f6d", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+double\n+add_double_n (vector double *p, double x, long n)\n+{\n+  return vec_extract (*p, n) + x;\n+}\n+\n+long\n+add_long_n (vector long *p, long x, long n)\n+{\n+  return vec_extract (*p, n) + x;\n+}\n+\n+/* { dg-final { scan-assembler-not \"lxvd2x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvx\"     } } */\n+/* { dg-final { scan-assembler-not \"lxv\"      } } */\n+/* { dg-final { scan-assembler-not \"lvx\"      } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */"}, {"sha": "6380fef9bc8707ad2362fa53137671276a034722", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-4.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0047a2538bc3381a7cf94e714f05b4b96799f6d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-4.c?ref=d0047a2538bc3381a7cf94e714f05b4b96799f6d", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-O2 -mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+#ifdef __LITTLE_ENDIAN__\n+#define ELEMENT 1\n+#else\n+#define ELEMENT 0\n+#endif\n+\n+void foo (double *p, vector double v)\n+{\n+  p[10] = vec_extract (v, ELEMENT);\n+}\n+\n+/* { dg-final { scan-assembler     \"stxsd \"   } } */\n+/* { dg-final { scan-assembler-not \"stxsdx\"   } } */\n+/* { dg-final { scan-assembler-not \"stfd\"     } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */"}]}