{"sha": "42a10bb884c0d5af2583b8bfe4d239ce95bf9e43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJhMTBiYjg4NGMwZDVhZjI1ODNiOGJmZTRkMjM5Y2U5NWJmOWU0Mw==", "commit": {"author": {"name": "Alex Coplan", "email": "alex.coplan@arm.com", "date": "2021-04-27T13:56:15Z"}, "committer": {"name": "Alex Coplan", "email": "alex.coplan@arm.com", "date": "2021-04-27T13:56:15Z"}, "message": "arm: Fix ICEs with compare-and-swap and -march=armv8-m.base [PR99977]\n\nThe PR shows two ICEs with __sync_bool_compare_and_swap and\n-mcpu=cortex-m23 (equivalently, -march=armv8-m.base): one in LRA and one\nlater on, after the CAS insn is split.\n\nThe LRA ICE occurs because the\n@atomic_compare_and_swap<CCSI:arch><SIDI:mode>_1 pattern attempts to tie\ntwo output operands together (operands 0 and 1 in the third\nalternative). LRA can't handle this, since it doesn't make sense for an\ninsn to assign to the same operand twice.\n\nThe later (post-splitting) ICE occurs because the expansion of the\ncbranchsi4_scratch insn doesn't quite go according to plan. As it\nstands, arm_split_compare_and_swap calls gen_cbranchsi4_scratch,\nattempting to pass a register (neg_bval) to use as a scratch register.\nHowever, since the RTL template has a match_scratch here,\ngen_cbranchsi4_scratch ignores this argument and produces a scratch rtx.\nSince this is all happening after RA, this is doomed to fail (and we get\nan ICE about the insn not matching its constraints).\n\nIt seems that the motivation for the choice of constraints in the\natomic_compare_and_swap pattern comes from an attempt to satisfy the\nconstraints of the cbranchsi4_scratch insn. This insn requires the\nscratch register to be the same as the input register in the case that\nwe use a larger negative immediate (one that satisfies J, but not L).\n\nOf course, as noted above, LRA refuses to assign two output operands to\nthe same register, so this was never going to work.\n\nThe solution I'm proposing here is to collapse the alternatives to the\nCAS insn (allowing the two output register operands to be matched to\ndifferent registers) and to ensure that the constraints for\ncbranchsi4_scratch are met in arm_split_compare_and_swap. We do this by\ninserting a move to ensure the source and destination registers match if\nnecessary (i.e. in the case of large negative immediates).\n\nAnother notable change here is that we only do:\n\n  emit_move_insn (neg_bval, const1_rtx);\n\nfor non-negative immediates. This is because the ADDS instruction used in\nthe negative case suffices to leave a suitable value in neg_bval: if the\noperands compare equal, we don't take the branch (so neg_bval will be\nset by the load exclusive). Otherwise, the ADDS will leave a nonzero\nvalue in neg_bval, which will correctly signal that the CAS has failed\nwhen it is later negated.\n\ngcc/ChangeLog:\n\n\tPR target/99977\n\t* config/arm/arm.c (arm_split_compare_and_swap): Fix up codegen\n\twith negative immediates: ensure we expand cbranchsi4_scratch\n\tcorrectly and ensure we satisfy its constraints.\n\t* config/arm/sync.md\n\t(@atomic_compare_and_swap<CCSI:arch><NARROW:mode>_1): Don't\n\tattempt to tie two output operands together with constraints;\n\tcollapse two alternatives.\n\t(@atomic_compare_and_swap<CCSI:arch><SIDI:mode>_1): Likewise.\n\t* config/arm/thumb1.md (cbranchsi4_neg_late): New.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/99977\n\t* gcc.target/arm/pr99977.c: New test.", "tree": {"sha": "fff58d15ae0ec2949332981182c47513b41546b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fff58d15ae0ec2949332981182c47513b41546b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43/comments", "author": {"login": "acoplan-arm", "id": 86676934, "node_id": "MDQ6VXNlcjg2Njc2OTM0", "avatar_url": "https://avatars.githubusercontent.com/u/86676934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acoplan-arm", "html_url": "https://github.com/acoplan-arm", "followers_url": "https://api.github.com/users/acoplan-arm/followers", "following_url": "https://api.github.com/users/acoplan-arm/following{/other_user}", "gists_url": "https://api.github.com/users/acoplan-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/acoplan-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acoplan-arm/subscriptions", "organizations_url": "https://api.github.com/users/acoplan-arm/orgs", "repos_url": "https://api.github.com/users/acoplan-arm/repos", "events_url": "https://api.github.com/users/acoplan-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/acoplan-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "acoplan-arm", "id": 86676934, "node_id": "MDQ6VXNlcjg2Njc2OTM0", "avatar_url": "https://avatars.githubusercontent.com/u/86676934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acoplan-arm", "html_url": "https://github.com/acoplan-arm", "followers_url": "https://api.github.com/users/acoplan-arm/followers", "following_url": "https://api.github.com/users/acoplan-arm/following{/other_user}", "gists_url": "https://api.github.com/users/acoplan-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/acoplan-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acoplan-arm/subscriptions", "organizations_url": "https://api.github.com/users/acoplan-arm/orgs", "repos_url": "https://api.github.com/users/acoplan-arm/repos", "events_url": "https://api.github.com/users/acoplan-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/acoplan-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "618ae596ebcd1de03857d20485d1324931852569", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/618ae596ebcd1de03857d20485d1324931852569", "html_url": "https://github.com/Rust-GCC/gccrs/commit/618ae596ebcd1de03857d20485d1324931852569"}], "stats": {"total": 75, "additions": 57, "deletions": 18}, "files": [{"sha": "6641e3fb4dcb0e66b386439792274b650c537691", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=42a10bb884c0d5af2583b8bfe4d239ce95bf9e43", "patch": "@@ -30743,13 +30743,31 @@ arm_split_compare_and_swap (rtx operands[])\n     }\n   else\n     {\n-      emit_move_insn (neg_bval, const1_rtx);\n       cond = gen_rtx_NE (VOIDmode, rval, oldval);\n       if (thumb1_cmpneg_operand (oldval, SImode))\n-\temit_unlikely_jump (gen_cbranchsi4_scratch (neg_bval, rval, oldval,\n-\t\t\t\t\t\t    label2, cond));\n+\t{\n+\t  rtx src = rval;\n+\t  if (!satisfies_constraint_L (oldval))\n+\t    {\n+\t      gcc_assert (satisfies_constraint_J (oldval));\n+\n+\t      /* For such immediates, ADDS needs the source and destination regs\n+\t\t to be the same.\n+\n+\t\t Normally this would be handled by RA, but this is all happening\n+\t\t after RA.  */\n+\t      emit_move_insn (neg_bval, rval);\n+\t      src = neg_bval;\n+\t    }\n+\n+\t  emit_unlikely_jump (gen_cbranchsi4_neg_late (neg_bval, src, oldval,\n+\t\t\t\t\t\t       label2, cond));\n+\t}\n       else\n-\temit_unlikely_jump (gen_cbranchsi4_insn (cond, rval, oldval, label2));\n+\t{\n+\t  emit_move_insn (neg_bval, const1_rtx);\n+\t  emit_unlikely_jump (gen_cbranchsi4_insn (cond, rval, oldval, label2));\n+\t}\n     }\n \n   arm_emit_store_exclusive (mode, neg_bval, mem, newval, use_release);"}, {"sha": "b9fa870260652a274651d1ffe4bbc2528f11c97f", "filename": "gcc/config/arm/sync.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43/gcc%2Fconfig%2Farm%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43/gcc%2Fconfig%2Farm%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsync.md?ref=42a10bb884c0d5af2583b8bfe4d239ce95bf9e43", "patch": "@@ -187,20 +187,20 @@\n ;; Constraints of this pattern must be at least as strict as those of the\n ;; cbranchsi operations in thumb1.md and aim to be as permissive.\n (define_insn_and_split \"@atomic_compare_and_swap<CCSI:arch><NARROW:mode>_1\"\n-  [(set (match_operand:CCSI 0 \"cc_register_operand\" \"=&c,&l,&l,&l\")\t;; bool out\n+  [(set (match_operand:CCSI 0 \"cc_register_operand\" \"=&c,&l,&l\")\t;; bool out\n \t(unspec_volatile:CCSI [(const_int 0)] VUNSPEC_ATOMIC_CAS))\n-   (set (match_operand:SI 1 \"s_register_operand\" \"=&r,&l,&0,&l*h\")\t;; val out\n+   (set (match_operand:SI 1 \"s_register_operand\" \"=&r,&l,&l*h\")\t;; val out\n \t(zero_extend:SI\n-\t  (match_operand:NARROW 2 \"mem_noofs_operand\" \"+Ua,Ua,Ua,Ua\")))\t;; memory\n+\t  (match_operand:NARROW 2 \"mem_noofs_operand\" \"+Ua,Ua,Ua\")))\t;; memory\n    (set (match_dup 2)\n \t(unspec_volatile:NARROW\n-\t  [(match_operand:SI 3 \"arm_add_operand\" \"rIL,lIL*h,J,*r\")\t;; expected\n-\t   (match_operand:NARROW 4 \"s_register_operand\" \"r,r,r,r\")\t;; desired\n+\t  [(match_operand:SI 3 \"arm_add_operand\" \"rIL,lILJ*h,*r\")\t;; expected\n+\t   (match_operand:NARROW 4 \"s_register_operand\" \"r,r,r\")\t;; desired\n \t   (match_operand:SI 5 \"const_int_operand\")\t\t;; is_weak\n \t   (match_operand:SI 6 \"const_int_operand\")\t\t;; mod_s\n \t   (match_operand:SI 7 \"const_int_operand\")]\t\t;; mod_f\n \t  VUNSPEC_ATOMIC_CAS))\n-   (clobber (match_scratch:SI 8 \"=&r,X,X,X\"))]\n+   (clobber (match_scratch:SI 8 \"=&r,X,X\"))]\n   \"<NARROW:sync_predtab>\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -209,7 +209,7 @@\n     arm_split_compare_and_swap (operands);\n     DONE;\n   }\n-  [(set_attr \"arch\" \"32,v8mb,v8mb,v8mb\")])\n+  [(set_attr \"arch\" \"32,v8mb,v8mb\")])\n \n (define_mode_attr cas_cmp_operand\n   [(SI \"arm_add_operand\") (DI \"cmpdi_operand\")])\n@@ -219,19 +219,19 @@\n ;; Constraints of this pattern must be at least as strict as those of the\n ;; cbranchsi operations in thumb1.md and aim to be as permissive.\n (define_insn_and_split \"@atomic_compare_and_swap<CCSI:arch><SIDI:mode>_1\"\n-  [(set (match_operand:CCSI 0 \"cc_register_operand\" \"=&c,&l,&l,&l\")\t;; bool out\n+  [(set (match_operand:CCSI 0 \"cc_register_operand\" \"=&c,&l,&l\")\t;; bool out\n \t(unspec_volatile:CCSI [(const_int 0)] VUNSPEC_ATOMIC_CAS))\n-   (set (match_operand:SIDI 1 \"s_register_operand\" \"=&r,&l,&0,&l*h\")\t;; val out\n-\t(match_operand:SIDI 2 \"mem_noofs_operand\" \"+Ua,Ua,Ua,Ua\"))\t;; memory\n+   (set (match_operand:SIDI 1 \"s_register_operand\" \"=&r,&l,&l*h\")\t;; val out\n+\t(match_operand:SIDI 2 \"mem_noofs_operand\" \"+Ua,Ua,Ua\"))\t;; memory\n    (set (match_dup 2)\n \t(unspec_volatile:SIDI\n-\t  [(match_operand:SIDI 3 \"<SIDI:cas_cmp_operand>\" \"<SIDI:cas_cmp_str>,lIL*h,J,*r\") ;; expect\n-\t   (match_operand:SIDI 4 \"s_register_operand\" \"r,r,r,r\")\t;; desired\n+\t  [(match_operand:SIDI 3 \"<SIDI:cas_cmp_operand>\" \"<SIDI:cas_cmp_str>,lILJ*h,*r\") ;; expect\n+\t   (match_operand:SIDI 4 \"s_register_operand\" \"r,r,r\")\t;; desired\n \t   (match_operand:SI 5 \"const_int_operand\")\t\t;; is_weak\n \t   (match_operand:SI 6 \"const_int_operand\")\t\t;; mod_s\n \t   (match_operand:SI 7 \"const_int_operand\")]\t\t;; mod_f\n \t  VUNSPEC_ATOMIC_CAS))\n-   (clobber (match_scratch:SI 8 \"=&r,X,X,X\"))]\n+   (clobber (match_scratch:SI 8 \"=&r,X,X\"))]\n   \"<SIDI:sync_predtab>\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -240,7 +240,7 @@\n     arm_split_compare_and_swap (operands);\n     DONE;\n   }\n-  [(set_attr \"arch\" \"32,v8mb,v8mb,v8mb\")])\n+  [(set_attr \"arch\" \"32,v8mb,v8mb\")])\n \n (define_insn_and_split \"atomic_exchange<mode>\"\n   [(set (match_operand:QHSD 0 \"s_register_operand\" \"=&r,&r\")\t;; output"}, {"sha": "084ed6597e0e28bb555ede3eec458357390d0c6c", "filename": "gcc/config/arm/thumb1.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43/gcc%2Fconfig%2Farm%2Fthumb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43/gcc%2Fconfig%2Farm%2Fthumb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb1.md?ref=42a10bb884c0d5af2583b8bfe4d239ce95bf9e43", "patch": "@@ -1206,6 +1206,21 @@\n    (set_attr \"type\" \"multiple\")]\n )\n \n+;; An expander which makes use of the cbranchsi4_scratch insn, but can\n+;; be used safely after RA.\n+(define_expand \"cbranchsi4_neg_late\"\n+  [(parallel [\n+     (set (pc) (if_then_else\n+\t\t(match_operator 4 \"arm_comparison_operator\"\n+\t\t [(match_operand:SI 1 \"s_register_operand\")\n+\t\t  (match_operand:SI 2 \"thumb1_cmpneg_operand\")])\n+\t\t(label_ref (match_operand 3 \"\" \"\"))\n+\t\t(pc)))\n+     (clobber (match_operand:SI 0 \"s_register_operand\"))\n+  ])]\n+  \"TARGET_THUMB1\"\n+)\n+\n ;; Changes to the constraints of this pattern must be propagated to those of\n ;; atomic compare_and_swap splitters in sync.md.  These must be at least as\n ;; strict as the constraints here and aim to be as permissive."}, {"sha": "7911899d928467b03c1116a878e617baa94382c5", "filename": "gcc/testsuite/gcc.target/arm/pr99977.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr99977.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr99977.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr99977.c?ref=42a10bb884c0d5af2583b8bfe4d239ce95bf9e43", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=armv8-m.base -mfloat-abi=soft -O2\" } */\n+_Bool f1(int *p) { return __sync_bool_compare_and_swap (p, -1, 2); }\n+_Bool f2(int *p) { return __sync_bool_compare_and_swap (p, -8, 2); }\n+int g1(int *p) { return __sync_val_compare_and_swap (p, -1, 2); }\n+int g2(int *p) { return __sync_val_compare_and_swap (p, -8, 3); }"}]}