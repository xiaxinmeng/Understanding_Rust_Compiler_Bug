{"sha": "fb3821f7b217dc72d9792d4c4f62095273a5fac7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIzODIxZjdiMjE3ZGM3MmQ5NzkyZDRjNGY2MjA5NTI3M2E1ZmFjNw==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T20:11:22Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T20:11:22Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1474", "tree": {"sha": "658edde9c379eb4f3074bd814bc09eae2a04f870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/658edde9c379eb4f3074bd814bc09eae2a04f870"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb3821f7b217dc72d9792d4c4f62095273a5fac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3821f7b217dc72d9792d4c4f62095273a5fac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb3821f7b217dc72d9792d4c4f62095273a5fac7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3821f7b217dc72d9792d4c4f62095273a5fac7/comments", "author": null, "committer": null, "parents": [{"sha": "906c4e36c6f418550a1040e1e61d989aa72f3b3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/906c4e36c6f418550a1040e1e61d989aa72f3b3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/906c4e36c6f418550a1040e1e61d989aa72f3b3c"}], "stats": {"total": 254, "additions": 144, "deletions": 110}, "files": [{"sha": "b6bcbb2f6934fe4fa6e3443e8b33886e4795b6d8", "filename": "gcc/reload.c", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3821f7b217dc72d9792d4c4f62095273a5fac7/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3821f7b217dc72d9792d4c4f62095273a5fac7/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=fb3821f7b217dc72d9792d4c4f62095273a5fac7", "patch": "@@ -709,8 +709,8 @@ push_reload (in, out, inloc, outloc, class,\n \t      || secondary_icode != CODE_FOR_nothing\n \t      || secondary_out_icode != CODE_FOR_nothing))\n \t{\n-\t  push_reload (0, out, 0, outloc, class, VOIDmode, outmode,\n-\t\t       strict_low, optional, needed_for);\n+\t  push_reload (NULL_RTX, out, NULL_PTR, outloc, class,\n+\t\t       VOIDmode, outmode, strict_low, optional, needed_for);\n \t  out = 0;\n \t  outloc = 0;\n \t  outmode = VOIDmode;\n@@ -1292,7 +1292,7 @@ find_dummy_reload (real_in, real_out, inloc, outloc, class, for_real)\n       register int regno = REGNO (in) + in_offset;\n       int nwords = HARD_REGNO_NREGS (regno, GET_MODE (real_in));\n \n-      if (! refers_to_regno_for_reload_p (regno, regno + nwords, out, 0)\n+      if (! refers_to_regno_for_reload_p (regno, regno + nwords, out, NULL_PTR)\n \t  && ! hard_reg_set_here_p (regno, regno + nwords,\n \t\t\t\t    PATTERN (this_insn)))\n \t{\n@@ -1472,6 +1472,11 @@ operands_match_p (x, y)\n       int val;\n       switch (fmt[i])\n \t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n \tcase 'i':\n \t  if (XINT (x, i) != XINT (y, i))\n \t    return 0;\n@@ -1518,8 +1523,8 @@ struct decomposition\n   int reg_flag;\n   int safe;\n   rtx base;\n-  int start;\n-  int end;\n+  HOST_WIDE_INT start;\n+  HOST_WIDE_INT end;\n };\n \n /* Describe the range of registers or memory referenced by X.\n@@ -1662,7 +1667,7 @@ immune_p (x, y, ydata)\n   struct decomposition xdata;\n \n   if (ydata.reg_flag)\n-    return !refers_to_regno_for_reload_p (ydata.start, ydata.end, x, 0);\n+    return !refers_to_regno_for_reload_p (ydata.start, ydata.end, x, NULL_PTR);\n   if (ydata.safe)\n     return 1;\n \n@@ -1970,7 +1975,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n       if (constraints[i][0] == 'p')\n \t{\n-\t  find_reloads_address (VOIDmode, 0,\n+\t  find_reloads_address (VOIDmode, NULL_PTR,\n \t\t\t\trecog_operand[i], recog_operand_loc[i],\n \t\t\t\trecog_operand[i], ind_levels);\n \t  substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n@@ -2343,7 +2348,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t/* Match any floating double constant, but only if\n \t\t   we can examine the bits of it reliably.  */\n \t\tif ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-\t\t     || HOST_BITS_PER_INT != BITS_PER_WORD)\n+\t\t     || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n \t\t    && GET_MODE (operand) != VOIDmode && ! flag_pretend_float)\n \t\t  break;\n \t\tif (GET_CODE (operand) == CONST_DOUBLE)\n@@ -2790,10 +2795,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t && GET_CODE (recog_operand[i]) == MEM)\n \t  {\n \t    operand_reloadnum[i]\n-\t      = push_reload (XEXP (recog_operand[i], 0), 0,\n-\t\t\t     &XEXP (recog_operand[i], 0), 0,\n+\t      = push_reload (XEXP (recog_operand[i], 0), NULL_RTX,\n+\t\t\t     &XEXP (recog_operand[i], 0), NULL_PTR,\n \t\t\t     BASE_REG_CLASS, GET_MODE (XEXP (recog_operand[i], 0)),\n-\t\t\t     VOIDmode, 0, 0, 0);\n+\t\t\t     VOIDmode, 0, 0, NULL_RTX);\n \t    reload_inc[operand_reloadnum[i]]\n \t      = GET_MODE_SIZE (GET_MODE (recog_operand[i]));\n \t  }\n@@ -2808,7 +2813,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t (modified[i] == RELOAD_READ ? VOIDmode : operand_mode[i]),\n \t\t\t (insn_code_number < 0 ? 0\n \t\t\t  : insn_operand_strict_low[insn_code_number][i]),\n-\t\t\t 0, 0);\n+\t\t\t 0, NULL_RTX);\n \t/* In a matching pair of operands, one must be input only\n \t   and the other must be output only.\n \t   Pass the input operand as IN and the other as OUT.  */\n@@ -2823,7 +2828,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t     (enum reg_class) goal_alternative[i],\n \t\t\t     operand_mode[i],\n \t\t\t     operand_mode[goal_alternative_matched[i]],\n-\t\t\t     0, 0, 0);\n+\t\t\t     0, 0, NULL_RTX);\n \t    operand_reloadnum[goal_alternative_matched[i]] = output_reloadnum;\n \t  }\n \telse if (modified[i] == RELOAD_WRITE\n@@ -2837,7 +2842,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t     (enum reg_class) goal_alternative[i],\n \t\t\t     operand_mode[goal_alternative_matched[i]],\n \t\t\t     operand_mode[i],\n-\t\t\t     0, 0, 0);\n+\t\t\t     0, 0, NULL_RTX);\n \t    operand_reloadnum[i] = output_reloadnum;\n \t  }\n \telse if (insn_code_number >= 0)\n@@ -2881,7 +2886,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t   (modified[i] == RELOAD_READ ? VOIDmode : operand_mode[i]),\n \t\t\t   (insn_code_number < 0 ? 0\n \t\t\t    : insn_operand_strict_low[insn_code_number][i]),\n-\t\t\t   1, 0);\n+\t\t\t   1, NULL_RTX);\n \t/* Make an optional reload for an explicit mem ref.  */\n \telse if (GET_CODE (operand) == MEM\n \t\t && (enum reg_class) goal_alternative[i] != NO_REGS\n@@ -2899,7 +2904,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t   (modified[i] == RELOAD_READ ? VOIDmode : operand_mode[i]),\n \t\t\t   (insn_code_number < 0 ? 0\n \t\t\t    : insn_operand_strict_low[insn_code_number][i]),\n-\t\t\t   1, 0);\n+\t\t\t   1, NULL_RTX);\n \telse\n \t  non_reloaded_operands[n_non_reloaded_operands++] = recog_operand[i];\n       }\n@@ -3000,7 +3005,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n \t  /* Now get the operand values out of the insn.  */\n \n-\t  decode_asm_operands (body, recog_operand, recog_operand_loc, 0, 0);\n+\t  decode_asm_operands (body, recog_operand, recog_operand_loc,\n+\t\t\t       NULL_PTR, NULL_PTR);\n \t  break;\n \t}\n \n@@ -3023,7 +3029,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n       if (insn_code_number >= 0)\n \tif (insn_operand_address_p[insn_code_number][i])\n-\t  find_reloads_address (VOIDmode, 0,\n+\t  find_reloads_address (VOIDmode, NULL_PTR,\n \t\t\t\trecog_operand[i], recog_operand_loc[i],\n \t\t\t\trecog_operand[i], ind_levels);\n       if (code == MEM)\n@@ -3191,7 +3197,7 @@ find_reloads_toplev (x, ind_levels, is_set_dest)\n \n \t  x = gen_rtx (MEM, GET_MODE (x), addr);\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n-\t  find_reloads_address (GET_MODE (x), 0,\n+\t  find_reloads_address (GET_MODE (x), NULL_PTR,\n \t\t\t\tXEXP (x, 0),\n \t\t\t\t&XEXP (x, 0), x, ind_levels);\n \t}\n@@ -3274,7 +3280,7 @@ find_reloads_toplev (x, ind_levels, is_set_dest)\n \t  addr = plus_constant (addr, offset);\n \t  x = gen_rtx (MEM, GET_MODE (x), addr);\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n-\t  find_reloads_address (GET_MODE (x), 0,\n+\t  find_reloads_address (GET_MODE (x), NULL_PTR,\n \t\t\t\tXEXP (x, 0),\n \t\t\t\t&XEXP (x, 0), x, ind_levels);\n \t}\n@@ -3362,9 +3368,9 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n       else if (reg_equiv_address[regno] != 0)\n \t{\n \t  tem = make_memloc (ad, regno);\n-\t  find_reloads_address (GET_MODE (tem), 0, XEXP (tem, 0),\n+\t  find_reloads_address (GET_MODE (tem), NULL_PTR, XEXP (tem, 0),\n \t\t\t\t&XEXP (tem, 0), operand, ind_levels);\n-\t  push_reload (tem, 0, loc, 0, BASE_REG_CLASS,\n+\t  push_reload (tem, NULL_RTX, loc, NULL_PTR, BASE_REG_CLASS,\n \t\t       GET_MODE (ad), VOIDmode, 0, 0,\n \t\t       operand);\n \t  return 1;\n@@ -3399,7 +3405,7 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n \treturn 0;\n \n       /* If we do not have one of the cases above, we must do the reload.  */\n-      push_reload (ad, 0, loc, 0, BASE_REG_CLASS,\n+      push_reload (ad, NULL_RTX, loc, NULL_PTR, BASE_REG_CLASS,\n \t\t   GET_MODE (ad), VOIDmode, 0, 0, operand);\n       return 1;\n     }\n@@ -3458,7 +3464,7 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n \t{\n \t  /* Must use TEM here, not AD, since it is the one that will\n \t     have any subexpressions reloaded, if needed.  */\n-\t  push_reload (tem, 0, loc, 0,\n+\t  push_reload (tem, NULL_RTX, loc, NULL_PTR,\n \t\t       BASE_REG_CLASS, GET_MODE (tem), VOIDmode, 0,\n \t\t       0, operand);\n \t  return 1;\n@@ -3913,7 +3919,7 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t      register rtx link;\n \n \t      int reloadnum\n-\t\t= push_reload (x, 0, loc, 0,\n+\t\t= push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n \t\t\t       GET_MODE (x), GET_MODE (x), VOIDmode, 0, operand);\n \t      reload_inc[reloadnum]\n@@ -3953,7 +3959,7 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t\t\t\tXEXP (XEXP (x, 0), 0), &XEXP (XEXP (x, 0), 0),\n \t\t\t\toperand, ind_levels);\n \n-\t  reloadnum = push_reload (x, 0, loc, 0,\n+\t  reloadnum = push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t\t\t   context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n \t\t\t\t   GET_MODE (x), VOIDmode, 0, 0, operand);\n \t  reload_inc[reloadnum]\n@@ -3983,7 +3989,7 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n       find_reloads_address (GET_MODE (x), loc, XEXP (x, 0), &XEXP (x, 0),\n \t\t\t    operand, ind_levels);\n \n-      push_reload (*loc, 0, loc, 0,\n+      push_reload (*loc, NULL_RTX, loc, NULL_PTR,\n \t\t   context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n \t\t   GET_MODE (x), VOIDmode, 0, 0, operand);\n       return 1;\n@@ -3994,7 +4000,7 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \n       if (reg_equiv_constant[regno] != 0)\n \t{\n-\t  push_reload (reg_equiv_constant[regno], 0, loc, 0,\n+\t  push_reload (reg_equiv_constant[regno], NULL_RTX, loc, NULL_PTR,\n \t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n \t\t       GET_MODE (x), VOIDmode, 0, 0, operand);\n \t  return 1;\n@@ -4004,7 +4010,7 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t that feeds this insn.  */\n       if (reg_equiv_mem[regno] != 0)\n \t{\n-\t  push_reload (reg_equiv_mem[regno], 0, loc, 0,\n+\t  push_reload (reg_equiv_mem[regno], NULL_RTX, loc, NULL_PTR,\n \t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n \t\t       GET_MODE (x), VOIDmode, 0, 0, operand);\n \t  return 1;\n@@ -4023,7 +4029,7 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t   || !(context ? REGNO_OK_FOR_INDEX_P (regno)\n \t\t: REGNO_OK_FOR_BASE_P (regno))))\n \t{\n-\t  push_reload (x, 0, loc, 0,\n+\t  push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n \t\t       GET_MODE (x), VOIDmode, 0, 0, operand);\n \t  return 1;\n@@ -4035,7 +4041,7 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t from before this insn to after it.  */\n       if (regno_clobbered_p (regno, this_insn))\n \t{\n-\t  push_reload (x, 0, loc, 0,\n+\t  push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n \t\t       GET_MODE (x), VOIDmode, 0, 0, operand);\n \t  return 1;\n@@ -4101,7 +4107,8 @@ find_reloads_address_part (x, loc, class, mode, needed_for, ind_levels)\n \t\t\t    needed_for, ind_levels);\n     }\n \n-  push_reload (x, 0, loc, 0, class, mode, VOIDmode, 0, 0, needed_for);\n+  push_reload (x, NULL_RTX, loc, NULL_PTR, class,\n+\t       mode, VOIDmode, 0, 0, needed_for);\n }\n \f\n /* Substitute into X the registers into which we have reloaded\n@@ -4270,7 +4277,8 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n \t{\n \t  if (reg_equiv_memory_loc[i])\n \t    return refers_to_regno_for_reload_p (regno, endregno,\n-\t\t\t\t\t\t reg_equiv_memory_loc[i], 0);\n+\t\t\t\t\t\t reg_equiv_memory_loc[i],\n+\t\t\t\t\t\t NULL_PTR);\n \n \t  if (reg_equiv_constant[i])\n \t    return 0;\n@@ -4402,7 +4410,7 @@ reg_overlap_mentioned_for_reload_p (x, in)\n   endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n \t\t      ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n \n-  return refers_to_regno_for_reload_p (regno, endregno, in, 0);\n+  return refers_to_regno_for_reload_p (regno, endregno, in, NULL_PTR);\n }\n \n /* Return nonzero if anything in X contains a MEM.  Look also for pseudo\n@@ -4624,10 +4632,12 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t\t  /* If we are looking for a constant,\n \t\t     and something equivalent to that constant was copied\n \t\t     into a reg, we can use that reg.  */\n-\t\t  || (goal_const && (tem = find_reg_note (p, REG_EQUIV, 0))\n+\t\t  || (goal_const && (tem = find_reg_note (p, REG_EQUIV,\n+\t\t\t\t\t\t\t  NULL_RTX))\n \t\t      && rtx_equal_p (XEXP (tem, 0), goal)\n \t\t      && (valueno = true_regnum (valtry = SET_DEST (pat))) >= 0)\n-\t\t  || (goal_const && (tem = find_reg_note (p, REG_EQUIV, 0))\n+\t\t  || (goal_const && (tem = find_reg_note (p, REG_EQUIV,\n+\t\t\t\t\t\t\t  NULL_RTX))\n \t\t      && GET_CODE (SET_DEST (pat)) == REG\n \t\t      && GET_CODE (XEXP (tem, 0)) == CONST_DOUBLE\n \t\t      && GET_MODE_CLASS (GET_MODE (XEXP (tem, 0))) == MODE_FLOAT\n@@ -4636,7 +4646,8 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t\t      && (valtry = operand_subword (SET_DEST (pat), 0, 0,\n \t\t\t\t\t\t    VOIDmode))\n \t\t      && (valueno = true_regnum (valtry)) >= 0)\n-\t\t  || (goal_const && (tem = find_reg_note (p, REG_EQUIV, 0))\n+\t\t  || (goal_const && (tem = find_reg_note (p, REG_EQUIV,\n+\t\t\t\t\t\t\t  NULL_RTX))\n \t\t      && GET_CODE (SET_DEST (pat)) == REG\n \t\t      && GET_CODE (XEXP (tem, 0)) == CONST_DOUBLE\n \t\t      && GET_MODE_CLASS (GET_MODE (XEXP (tem, 0))) == MODE_FLOAT\n@@ -4687,7 +4698,7 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n       && refers_to_regno_for_reload_p (valueno,\n \t\t\t\t       (valueno\n \t\t\t\t\t+ HARD_REGNO_NREGS (valueno, mode)),\n-\t\t\t\t       goal, 0))\n+\t\t\t\t       goal, NULL_PTR))\n     return 0;\n \n   /* Reject registers that overlap GOAL.  */"}, {"sha": "35c37883e21d8c5d1bf3bbfd9ac17ad5bcbbd3f9", "filename": "gcc/reload1.c", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3821f7b217dc72d9792d4c4f62095273a5fac7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3821f7b217dc72d9792d4c4f62095273a5fac7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=fb3821f7b217dc72d9792d4c4f62095273a5fac7", "patch": "@@ -348,7 +348,7 @@ init_reload ()\n     = gen_rtx (MEM, Pmode,\n \t       gen_rtx (PLUS, Pmode,\n \t\t\tgen_rtx (REG, Pmode, LAST_VIRTUAL_REGISTER + 1),\n-\t\t\tgen_rtx (CONST_INT, VOIDmode, 4)));\n+\t\t\tGEN_INT (4)));\n   spill_indirect_levels = 0;\n \n   while (memory_address_p (QImode, tem))\n@@ -536,7 +536,7 @@ reload (first, global, dumpfile)\n \n   /* Make sure that the last insn in the chain\n      is not something that needs reloading.  */\n-  emit_note (0, NOTE_INSN_DELETED);\n+  emit_note (NULL_PTR, NOTE_INSN_DELETED);\n \n   /* Find all the pseudo registers that didn't get hard regs\n      but do have known equivalent constants or memory slots.\n@@ -571,7 +571,7 @@ reload (first, global, dumpfile)\n \n       if (set != 0 && GET_CODE (SET_DEST (set)) == REG)\n \t{\n-\t  rtx note = find_reg_note (insn, REG_EQUIV, 0);\n+\t  rtx note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n \t  if (note\n #ifdef LEGITIMATE_PIC_OPERAND_P\n \t      && (! CONSTANT_P (XEXP (note, 0)) || ! flag_pic\n@@ -836,7 +836,7 @@ reload (first, global, dumpfile)\n \n       for (x = forced_labels; x; x = XEXP (x, 1))\n \tif (XEXP (x, 0))\n-\t  set_label_offsets (XEXP (x, 0), 0, 1);\n+\t  set_label_offsets (XEXP (x, 0), NULL_RTX, 1);\n \n       /* For each pseudo register that has an equivalent location defined,\n \t try to eliminate any eliminable registers (such as the frame pointer)\n@@ -864,7 +864,7 @@ reload (first, global, dumpfile)\n       for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n \tif (reg_renumber[i] < 0 && reg_equiv_memory_loc[i])\n \t  {\n-\t    rtx x = eliminate_regs (reg_equiv_memory_loc[i], 0, 0);\n+\t    rtx x = eliminate_regs (reg_equiv_memory_loc[i], 0, NULL_RTX);\n \n \t    if (strict_memory_address_p (GET_MODE (regno_reg_rtx[i]),\n \t\t\t\t\t XEXP (x, 0)))\n@@ -1596,7 +1596,7 @@ reload (first, global, dumpfile)\n \t\t    }\n \t\t  else\n \t\t    something_changed\n-\t\t      |= new_spill_reg (i, class, max_needs, 0,\n+\t\t      |= new_spill_reg (i, class, max_needs, NULL_PTR,\n \t\t\t\t\tglobal, dumpfile);\n \t\t}\n \t      else\n@@ -1637,7 +1637,8 @@ reload (first, global, dumpfile)\n \t\t\t\t      }\n \t\t\t\t    else\n \t\t\t\t      something_changed\n-\t\t\t\t\t|= new_spill_reg (idx, class, max_needs, 0,\n+\t\t\t\t\t|= new_spill_reg (idx, class,\n+\t\t\t\t\t\t\t  max_needs, NULL_PTR,\n \t\t\t\t\t\t\t  global, dumpfile);\n \t\t\t\t}\n \n@@ -2452,7 +2453,8 @@ eliminate_regs (x, mem_mode, insn)\n \t     elimination) and ignore the fact that this is actually a\n \t     reference to the pseudo.  Ensure we make a copy of the\n \t     address in case it is shared.  */\n-\t  new = eliminate_regs (reg_equiv_memory_loc[regno], mem_mode, 0);\n+\t  new = eliminate_regs (reg_equiv_memory_loc[regno],\n+\t\t\t\tmem_mode, NULL_RTX);\n \t  if (new != reg_equiv_memory_loc[regno])\n \t    return copy_rtx (new);\n \t}\n@@ -2508,8 +2510,8 @@ eliminate_regs (x, mem_mode, insn)\n \t reload.  This is the desired action.  */\n \n       {\n-\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, 0);\n-\trtx new1 = eliminate_regs (XEXP (x, 1), mem_mode, 0);\n+\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, NULL_RTX);\n+\trtx new1 = eliminate_regs (XEXP (x, 1), mem_mode, NULL_RTX);\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  {\n@@ -2546,7 +2548,7 @@ eliminate_regs (x, mem_mode, insn)\n       /* If we have something in XEXP (x, 0), the usual case, eliminate it.  */\n       if (XEXP (x, 0))\n \t{\n-\t  new = eliminate_regs (XEXP (x, 0), mem_mode, 0);\n+\t  new = eliminate_regs (XEXP (x, 0), mem_mode, NULL_RTX);\n \t  if (new != XEXP (x, 0))\n \t    x = gen_rtx (EXPR_LIST, REG_NOTE_KIND (x), new, XEXP (x, 1));\n \t}\n@@ -2559,7 +2561,7 @@ eliminate_regs (x, mem_mode, insn)\n \t strictly needed, but it simplifies the code.  */\n       if (XEXP (x, 1))\n \t{\n-\t  new = eliminate_regs (XEXP (x, 1), mem_mode, 0);\n+\t  new = eliminate_regs (XEXP (x, 1), mem_mode, NULL_RTX);\n \t  if (new != XEXP (x, 1))\n \t    return gen_rtx (INSN_LIST, GET_MODE (x), XEXP (x, 0), new);\n \t}\n@@ -2578,8 +2580,9 @@ eliminate_regs (x, mem_mode, insn)\n     case GE:       case GT:       case GEU:    case GTU:\n     case LE:       case LT:       case LEU:    case LTU:\n       {\n-\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, 0);\n-\trtx new1 = XEXP (x, 1) ? eliminate_regs (XEXP (x, 1), mem_mode, 0) : 0;\n+\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, NULL_RTX);\n+\trtx new1\n+\t  = XEXP (x, 1) ? eliminate_regs (XEXP (x, 1), mem_mode, NULL_RTX) : 0;\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  return gen_rtx (code, GET_MODE (x), new0, new1);\n@@ -2610,7 +2613,7 @@ eliminate_regs (x, mem_mode, insn)\n     case ABS:\n     case SQRT:\n     case FFS:\n-      new = eliminate_regs (XEXP (x, 0), mem_mode, 0);\n+      new = eliminate_regs (XEXP (x, 0), mem_mode, NULL_RTX);\n       if (new != XEXP (x, 0))\n \treturn gen_rtx (code, GET_MODE (x), new);\n       return x;\n@@ -2629,7 +2632,7 @@ eliminate_regs (x, mem_mode, insn)\n \t  && reg_equiv_memory_loc[REGNO (SUBREG_REG (x))] != 0)\n \t{\n \t  new = eliminate_regs (reg_equiv_memory_loc[REGNO (SUBREG_REG (x))],\n-\t\t\t\tmem_mode, 0);\n+\t\t\t\tmem_mode, NULL_RTX);\n \n \t  /* If we didn't change anything, we must retain the pseudo.  */\n \t  if (new == reg_equiv_memory_loc[REGNO (SUBREG_REG (x))])\n@@ -2640,7 +2643,7 @@ eliminate_regs (x, mem_mode, insn)\n \t    new = copy_rtx (new);\n \t}\n       else\n-\tnew = eliminate_regs (SUBREG_REG (x), mem_mode, 0);\n+\tnew = eliminate_regs (SUBREG_REG (x), mem_mode, NULL_RTX);\n \n       if (new != XEXP (x, 0))\n \t{\n@@ -2690,7 +2693,7 @@ eliminate_regs (x, mem_mode, insn)\n \t    temp_vec = (rtx *) alloca (XVECLEN (x, 3) * sizeof (rtx));\n \t    for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n \t      temp_vec[i] = eliminate_regs (ASM_OPERANDS_INPUT (x, i),\n-\t\t\t\t\t    mem_mode, 0);\n+\t\t\t\t\t    mem_mode, NULL_RTX);\n \n \t    for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n \t      if (temp_vec[i] != ASM_OPERANDS_INPUT (x, i))\n@@ -2760,8 +2763,8 @@ eliminate_regs (x, mem_mode, insn)\n \n       /* Now avoid the loop below in this common case.  */\n       {\n-\trtx new0 = eliminate_regs (SET_DEST (x), 0, 0);\n-\trtx new1 = eliminate_regs (SET_SRC (x), 0, 0);\n+\trtx new0 = eliminate_regs (SET_DEST (x), 0, NULL_RTX);\n+\trtx new1 = eliminate_regs (SET_SRC (x), 0, NULL_RTX);\n \n \t/* If SET_DEST changed from a REG to a MEM and INSN is non-zero,\n \t   write a CLOBBER insn.  */\n@@ -2779,7 +2782,7 @@ eliminate_regs (x, mem_mode, insn)\n       /* Our only special processing is to pass the mode of the MEM to our\n \t recursive call and copy the flags.  While we are here, handle this\n \t case more efficiently.  */\n-      new = eliminate_regs (XEXP (x, 0), GET_MODE (x), 0);\n+      new = eliminate_regs (XEXP (x, 0), GET_MODE (x), NULL_RTX);\n       if (new != XEXP (x, 0))\n \t{\n \t  new = gen_rtx (MEM, GET_MODE (x), new);\n@@ -2799,7 +2802,7 @@ eliminate_regs (x, mem_mode, insn)\n     {\n       if (*fmt == 'e')\n \t{\n-\t  new = eliminate_regs (XEXP (x, i), mem_mode, 0);\n+\t  new = eliminate_regs (XEXP (x, i), mem_mode, NULL_RTX);\n \t  if (new != XEXP (x, i) && ! copied)\n \t    {\n \t      rtx new_x = rtx_alloc (code);\n@@ -2921,15 +2924,15 @@ eliminate_regs_in_insn (insn, replace)\n      but now can do this as a load-address.  This saves an insn in this\n      common case. */\n \n-  new_body = eliminate_regs (old_body, 0, replace ? insn : 0);\n+  new_body = eliminate_regs (old_body, 0, replace ? insn : NULL_RTX);\n   if (new_body != old_body)\n     {\n       if (GET_CODE (old_body) != SET || GET_CODE (SET_SRC (old_body)) != PLUS\n \t  || ! validate_change (insn, &PATTERN (insn), new_body, 0))\n \tPATTERN (insn) = new_body;\n \n       if (replace && REG_NOTES (insn))\n-\tREG_NOTES (insn) = eliminate_regs (REG_NOTES (insn), 0, 0);\n+\tREG_NOTES (insn) = eliminate_regs (REG_NOTES (insn), 0, NULL_RTX);\n       val = 1;\n     }\n \n@@ -3376,7 +3379,7 @@ reload_as_needed (first, live_known)\n \t      && GET_CODE (XEXP (PATTERN (insn), 0)) == MEM)\n \t    XEXP (XEXP (PATTERN (insn), 0), 0)\n \t      = eliminate_regs (XEXP (XEXP (PATTERN (insn), 0), 0),\n-\t\t\t\tGET_MODE (XEXP (PATTERN (insn), 0)), 0);\n+\t\t\t\tGET_MODE (XEXP (PATTERN (insn), 0)), NULL_RTX);\n \n \t  /* If we need to do register elimination processing, do so.\n \t     This might delete the insn, in which case we are done.  */\n@@ -4347,7 +4350,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \t    {\n \t      register rtx equiv\n \t\t= find_equiv_reg (reload_in[r], insn, reload_reg_class[r],\n-\t\t\t\t  -1, 0, 0, reload_mode[r]);\n+\t\t\t\t  -1, NULL_PTR, 0, reload_mode[r]);\n \t      int regno;\n \n \t      if (equiv != 0)\n@@ -4677,7 +4680,7 @@ emit_reload_insns (insn)\n \t    oldequiv\n \t      = find_equiv_reg (old, insn,\n \t\t\t\treload_reg_class[reload_secondary_reload[j]],\n-\t\t\t\t-1, 0, 0, mode);\n+\t\t\t\t-1, NULL_PTR, 0, mode);\n #endif\n \n \t  /* If reloading from memory, see if there is a register\n@@ -4694,7 +4697,7 @@ emit_reload_insns (insn)\n \t\t      && REGNO (old) >= FIRST_PSEUDO_REGISTER\n \t\t      && reg_renumber[REGNO (old)] < 0)))\n \t    oldequiv = find_equiv_reg (old, insn, GENERAL_REGS,\n-\t\t\t\t       -1, 0, 0, mode);\n+\t\t\t\t       -1, NULL_PTR, 0, mode);\n \n \t  if (oldequiv)\n \t    {\n@@ -5759,7 +5762,7 @@ inc_for_reload (reloadreg, value, inc_amount, insn)\n   if (GET_CODE (value) == PRE_DEC || GET_CODE (value) == POST_DEC)\n     inc_amount = - inc_amount;\n \n-  inc = gen_rtx (CONST_INT, VOIDmode, inc_amount);\n+  inc = GEN_INT (inc_amount);\n \n   /* If this is post-increment, first copy the location to the reload reg.  */\n   if (post)\n@@ -5817,9 +5820,7 @@ inc_for_reload (reloadreg, value, inc_amount, insn)\n \n       emit_insn_before (gen_add2_insn (reloadreg, inc), insn);\n       emit_insn_before (gen_move_insn (incloc, reloadreg), insn);\n-      emit_insn_before (gen_add2_insn (reloadreg,\n-\t\t\t\t       gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t-inc_amount)),\n+      emit_insn_before (gen_add2_insn (reloadreg, GEN_INT (-inc_amount)),\n \t\t\tinsn);\n     }\n "}, {"sha": "4649d1dc9629a4fe4baab8ccc7ed1d6711cceac9", "filename": "gcc/reorg.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3821f7b217dc72d9792d4c4f62095273a5fac7/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3821f7b217dc72d9792d4c4f62095273a5fac7/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=fb3821f7b217dc72d9792d4c4f62095273a5fac7", "patch": "@@ -766,7 +766,7 @@ add_to_delay_list (insn, delay_list)\n {\n   /* If we have an empty list, just make a new list element.  */\n   if (delay_list == 0)\n-    return gen_rtx (INSN_LIST, VOIDmode, insn, 0);\n+    return gen_rtx (INSN_LIST, VOIDmode, insn, NULL_RTX);\n \n   /* Otherwise this must be an INSN_LIST.  Add INSN to the end of the\n      list.  */\n@@ -845,14 +845,14 @@ delete_scheduled_jump (insn)\n #ifdef HAVE_cc0\n   if (reg_mentioned_p (cc0_rtx, insn))\n     {\n-      rtx note = find_reg_note (insn, REG_CC_SETTER, 0);\n+      rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n \n       /* If a reg-note was found, it points to an insn to set CC0.  This\n \t insn is in the delay list of some other insn.  So delete it from\n \t the delay list it was in.  */\n       if (note)\n \t{\n-\t  if (! FIND_REG_INC_NOTE (XEXP (note, 0), 0)\n+\t  if (! FIND_REG_INC_NOTE (XEXP (note, 0), NULL_RTX)\n \t      && sets_cc0_p (PATTERN (XEXP (note, 0))) == 1)\n \t    delete_from_delay_slot (XEXP (note, 0));\n \t}\n@@ -972,7 +972,7 @@ optimize_skip (insn)\n \t    return 0;\n \t}\n \n-      delay_list = add_to_delay_list (trial, 0);\n+      delay_list = add_to_delay_list (trial, NULL_RTX);\n       next_trial = next_active_insn (trial);\n       update_block (trial, trial);\n       delete_insn (trial);\n@@ -1201,7 +1201,7 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n #ifdef HAVE_cc0\n \t  /* If TRIAL sets CC0, we can't copy it, so we can't steal this\n \t     delay list.  */\n-\t  || find_reg_note (trial, REG_CC_USER, 0)\n+\t  || find_reg_note (trial, REG_CC_USER, NULL_RTX)\n #endif\n \t  /* If TRIAL is from the fallthrough code of an annulled branch insn\n \t     in SEQ, we cannot use it.  */\n@@ -1942,7 +1942,8 @@ mark_target_live_regs (target, res)\n   if (b != -1)\n     {\n       regset regs_live = basic_block_live_at_start[b];\n-      int offset, bit, j;\n+      int offset, j;\n+      REGSET_ELT_TYPE bit;\n       int regno;\n       rtx start_insn, stop_insn;\n \n@@ -1959,7 +1960,7 @@ mark_target_live_regs (target, res)\n       for (offset = 0, i = 0; offset < regset_size; offset++)\n \t{\n \t  if (regs_live[offset] == 0)\n-\t    i += HOST_BITS_PER_INT;\n+\t    i += REGSET_ELT_BITS;\n \t  else\n \t    for (bit = 1; bit && i < max_regno; bit <<= 1, i++)\n \t      if ((regs_live[offset] & bit)\n@@ -2901,7 +2902,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t  if (thread_if_true)\n \t    INSN_FROM_TARGET_P (ninsn) = 1;\n \n-\t  delay_list = add_to_delay_list (ninsn, 0);\n+\t  delay_list = add_to_delay_list (ninsn, NULL_RTX);\n \t  (*pslots_filled)++;\n \t}\n     }\n@@ -2998,7 +2999,7 @@ fill_eager_delay_slots (first)\n       else\n \t{\n \t  fallthrough_insn = next_active_insn (insn);\n-\t  own_fallthrough = own_thread_p (NEXT_INSN (insn), 0, 1);\n+\t  own_fallthrough = own_thread_p (NEXT_INSN (insn), NULL_RTX, 1);\n \t  prediction = mostly_true_jump (insn, condition);\n \t}\n \n@@ -3248,7 +3249,7 @@ relax_delay_slots (first)\n \t     put it back where it belonged and delete the register notes,\n \t     but it doesn't seem worthwhile in this uncommon case.  */\n \t  && ! find_reg_note (XVECEXP (pat, 0, XVECLEN (pat, 0) - 1),\n-\t\t\t      REG_CC_USER, 0)\n+\t\t\t      REG_CC_USER, NULL_RTX)\n #endif\n \t  )\n \t{\n@@ -3369,7 +3370,7 @@ make_return_insns (first)\n \n       /* If we can't make the jump into a RETURN, redirect it to the best\n \t RETURN and go on to the next insn.  */\n-      if (! redirect_jump (jump_insn, 0))\n+      if (! redirect_jump (jump_insn, NULL_RTX))\n \t{\n \t  redirect_jump (jump_insn, real_return_label);\n \t  continue;"}, {"sha": "80752467a03dc910c19c499f9d07f4f5447686f7", "filename": "gcc/sched.c", "status": "modified", "additions": 50, "deletions": 29, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3821f7b217dc72d9792d4c4f62095273a5fac7/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3821f7b217dc72d9792d4c4f62095273a5fac7/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=fb3821f7b217dc72d9792d4c4f62095273a5fac7", "patch": "@@ -284,7 +284,7 @@ init_alias_analysis ()\n \t&& REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n \t&& (((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n \t     && reg_n_sets[REGNO (SET_DEST (set))] == 1)\n-\t    || (note = find_reg_note (insn, REG_EQUIV, 0)) != 0)\n+\t    || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n \t&& GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n       reg_known_value[REGNO (SET_DEST (set))] = XEXP (note, 0);\n \n@@ -346,6 +346,11 @@ rtx_equal_for_memref_p (x, y)\n     {\n       switch (fmt[i])\n \t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n \tcase 'n':\n \tcase 'i':\n \t  if (XINT (x, i) != XINT (y, i))\n@@ -449,7 +454,7 @@ static int\n memrefs_conflict_p (xsize, x, ysize, y, c)\n      rtx x, y;\n      int xsize, ysize;\n-     int c;\n+     HOST_WIDE_INT c;\n {\n   if (GET_CODE (x) == HIGH)\n     x = XEXP (x, 0);\n@@ -1670,7 +1675,8 @@ sched_note_set (b, x, death)\n   if (regno >= FIRST_PSEUDO_REGISTER || ! global_regs[regno])\n     {\n       register int offset = regno / REGSET_ELT_BITS;\n-      register int bit = 1 << (regno % REGSET_ELT_BITS);\n+      register REGSET_ELT_TYPE bit\n+\t= (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n \n       if (death)\n \t{\n@@ -1686,7 +1692,7 @@ sched_note_set (b, x, death)\n \t      while (--j >= 0)\n \t\t{\n \t\t  offset = (regno + j) / REGSET_ELT_BITS;\n-\t\t  bit = 1 << ((regno + j) % REGSET_ELT_BITS);\n+\t\t  bit = (REGSET_ELT_TYPE) 1 << ((regno + j) % REGSET_ELT_BITS);\n \t\t  \n \t\t  bb_live_regs[offset] &= ~bit;\n \t\t  bb_dead_regs[offset] |= bit;\n@@ -1707,7 +1713,7 @@ sched_note_set (b, x, death)\n \t      while (--j >= 0)\n \t\t{\n \t\t  offset = (regno + j) / REGSET_ELT_BITS;\n-\t\t  bit = 1 << ((regno + j) % REGSET_ELT_BITS);\n+\t\t  bit = (REGSET_ELT_TYPE) 1 << ((regno + j) % REGSET_ELT_BITS);\n \t\t  \n \t\t  bb_live_regs[offset] |= bit;\n \t\t  bb_dead_regs[offset] &= ~bit;\n@@ -1835,7 +1841,7 @@ birthing_insn_p (pat)\n       rtx dest = SET_DEST (pat);\n       int i = REGNO (dest);\n       int offset = i / REGSET_ELT_BITS;\n-      int bit = 1 << (i % REGSET_ELT_BITS);\n+      REGSET_ELT_TYPE bit = (REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS);\n \n       /* It would be more accurate to use refers_to_regno_p or\n \t reg_mentioned_p to determine when the dest is not live before this\n@@ -2015,9 +2021,10 @@ attach_deaths (x, insn, set_p)\n \n \tregister int regno = REGNO (x);\n \tregister int offset = regno / REGSET_ELT_BITS;\n-\tregister int bit = 1 << (regno % REGSET_ELT_BITS);\n-\tint all_needed = (old_live_regs[offset] & bit);\n-\tint some_needed = (old_live_regs[offset] & bit);\n+\tregister REGSET_ELT_TYPE bit\n+\t  = (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n+\tREGSET_ELT_TYPE all_needed = (old_live_regs[offset] & bit);\n+\tREGSET_ELT_TYPE some_needed = (old_live_regs[offset] & bit);\n \n \tif (set_p)\n \t  return;\n@@ -2030,9 +2037,11 @@ attach_deaths (x, insn, set_p)\n \t    while (--n > 0)\n \t      {\n \t\tsome_needed |= (old_live_regs[(regno + n) / REGSET_ELT_BITS]\n-\t\t\t\t& 1 << ((regno + n) % REGSET_ELT_BITS));\n+\t\t\t\t& ((REGSET_ELT_TYPE) 1\n+\t\t\t\t   << ((regno + n) % REGSET_ELT_BITS)));\n \t\tall_needed &= (old_live_regs[(regno + n) / REGSET_ELT_BITS]\n-\t\t\t       & 1 << ((regno + n) % REGSET_ELT_BITS));\n+\t\t\t       & ((REGSET_ELT_TYPE) 1\n+\t\t\t\t  << ((regno + n) % REGSET_ELT_BITS)));\n \t      }\n \t  }\n \n@@ -2077,7 +2086,8 @@ attach_deaths (x, insn, set_p)\n \t\t\tfor (i = HARD_REGNO_NREGS (regno, GET_MODE (x)) - 1;\n \t\t\t     i >= 0; i--)\n \t\t\t  if ((old_live_regs[(regno + i) / REGSET_ELT_BITS]\n-\t\t\t       & 1 << ((regno +i) % REGSET_ELT_BITS)) == 0\n+\t\t\t       & ((REGSET_ELT_TYPE) 1\n+\t\t\t\t  << ((regno +i) % REGSET_ELT_BITS))) == 0\n \t\t\t      && ! dead_or_set_regno_p (insn, regno + i))\n \t\t\t    create_reg_dead_note (gen_rtx (REG, word_mode,\n \t\t\t\t\t\t\t   regno + i),\n@@ -2092,7 +2102,8 @@ attach_deaths (x, insn, set_p)\n \t\twhile (--j >= 0)\n \t\t  {\n \t\t    offset = (regno + j) / REGSET_ELT_BITS;\n-\t\t    bit = 1 << ((regno + j) % REGSET_ELT_BITS);\n+\t\t    bit\n+\t\t      = (REGSET_ELT_TYPE) 1 << ((regno + j) % REGSET_ELT_BITS);\n \n \t\t    bb_dead_regs[offset] &= ~bit;\n \t\t    bb_live_regs[offset] |= bit;\n@@ -2623,7 +2634,8 @@ schedule_block (b, file)\n \t\t      {\n \t\t\tregister int regno = REGNO (XEXP (link, 0));\n \t\t\tregister int offset = regno / REGSET_ELT_BITS;\n-\t\t\tregister int bit = 1 << (regno % REGSET_ELT_BITS);\n+\t\t\tregister REGSET_ELT_TYPE bit\n+\t\t\t  = (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n \n \t\t\tif (regno < FIRST_PSEUDO_REGISTER)\n \t\t\t  {\n@@ -2632,7 +2644,8 @@ schedule_block (b, file)\n \t\t\t    while (--j >= 0)\n \t\t\t      {\n \t\t\t\toffset = (regno + j) / REGSET_ELT_BITS;\n-\t\t\t\tbit = 1 << ((regno + j) % REGSET_ELT_BITS);\n+\t\t\t\tbit = ((REGSET_ELT_TYPE) 1\n+\t\t\t\t       << ((regno + j) % REGSET_ELT_BITS));\n \n \t\t\t\tbb_live_regs[offset] &= ~bit;\n \t\t\t\tbb_dead_regs[offset] |= bit;\n@@ -2726,7 +2739,8 @@ schedule_block (b, file)\n \t\t{\n \t\t  register int regno = REGNO (XEXP (link, 0));\n \t\t  register int offset = regno / REGSET_ELT_BITS;\n-\t\t  register int bit = 1 << (regno % REGSET_ELT_BITS);\n+\t\t  register REGSET_ELT_TYPE bit\n+\t\t    = (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n \n \t\t  /* Only unlink REG_DEAD notes; leave REG_UNUSED notes\n \t\t     alone.  */\n@@ -2749,7 +2763,8 @@ schedule_block (b, file)\n \t\t      while (--j >= 0)\n \t\t\t{\n \t\t\t  offset = (regno + j) / REGSET_ELT_BITS;\n-\t\t\t  bit = 1 << ((regno + j) % REGSET_ELT_BITS);\n+\t\t\t  bit = ((REGSET_ELT_TYPE) 1\n+\t\t\t\t << ((regno + j) % REGSET_ELT_BITS));\n \n \t\t\t  bb_live_regs[offset] &= ~bit;\n \t\t\t  bb_dead_regs[offset] |= bit;\n@@ -2778,13 +2793,13 @@ schedule_block (b, file)\n       /* Start with registers live at end.  */\n       for (j = 0; j < regset_size; j++)\n \t{\n-\t  int live = bb_live_regs[j];\n+\t  REGSET_ELT_TYPE live = bb_live_regs[j];\n \t  old_live_regs[j] = live;\n \t  if (live)\n \t    {\n-\t      register int bit;\n+\t      register REGSET_ELT_TYPE bit;\n \t      for (bit = 0; bit < REGSET_ELT_BITS; bit++)\n-\t\tif (live & (1 << bit))\n+\t\tif (live & ((REGSET_ELT_TYPE) 1 << bit))\n \t\t  sometimes_max = new_sometimes_live (regs_sometimes_live, j,\n \t\t\t\t\t\t      bit, sometimes_max);\n \t    }\n@@ -2926,7 +2941,8 @@ schedule_block (b, file)\n \t\t    if (call_used_regs[i] || global_regs[i])\n \t\t      {\n \t\t\tregister int offset = i / REGSET_ELT_BITS;\n-\t\t\tregister int bit = 1 << (i % REGSET_ELT_BITS);\n+\t\t\tregister REGSET_ELT_TYPE bit\n+\t\t\t  = (REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS);\n \n \t\t\tbb_live_regs[offset] &= ~bit;\n \t\t\tbb_dead_regs[offset] |= bit;\n@@ -2940,7 +2956,8 @@ schedule_block (b, file)\n \t\t     (below).  */\n \t\t  p = regs_sometimes_live;\n \t\t  for (i = 0; i < sometimes_max; i++, p++)\n-\t\t    if (bb_live_regs[p->offset] & (1 << p->bit))\n+\t\t    if (bb_live_regs[p->offset]\n+\t\t\t& ((REGSET_ELT_TYPE) 1 << p->bit))\n \t\t      p->calls_crossed += 1;\n \t\t}\n \n@@ -2951,13 +2968,13 @@ schedule_block (b, file)\n \t      /* Find registers now made live by that instruction.  */\n \t      for (i = 0; i < regset_size; i++)\n \t\t{\n-\t\t  int diff = bb_live_regs[i] & ~old_live_regs[i];\n+\t\t  REGSET_ELT_TYPE diff = bb_live_regs[i] & ~old_live_regs[i];\n \t\t  if (diff)\n \t\t    {\n \t\t      register int bit;\n \t\t      old_live_regs[i] |= diff;\n \t\t      for (bit = 0; bit < REGSET_ELT_BITS; bit++)\n-\t\t\tif (diff & (1 << bit))\n+\t\t\tif (diff & ((REGSET_ELT_TYPE) 1 << bit))\n \t\t\t  sometimes_max\n \t\t\t    = new_sometimes_live (regs_sometimes_live, i, bit,\n \t\t\t\t\t\t  sometimes_max);\n@@ -2974,14 +2991,16 @@ schedule_block (b, file)\n \n \t\t  p->live_length += 1;\n \n-\t\t  if ((bb_live_regs[p->offset] & (1 << p->bit)) == 0)\n+\t\t  if ((bb_live_regs[p->offset]\n+\t\t       & ((REGSET_ELT_TYPE) 1 << p->bit)) == 0)\n \t\t    {\n \t\t      /* This is the end of one of this register's lifetime\n \t\t\t segments.  Save the lifetime info collected so far,\n \t\t\t and clear its bit in the old_live_regs entry.  */\n \t\t      sched_reg_live_length[regno] += p->live_length;\n \t\t      sched_reg_n_calls_crossed[regno] += p->calls_crossed;\n-\t\t      old_live_regs[p->offset] &= ~(1 << p->bit);\n+\t\t      old_live_regs[p->offset]\n+\t\t\t&= ~((REGSET_ELT_TYPE) 1 << p->bit);\n \n \t\t      /* Delete the reg_sometimes_live entry for this reg by\n \t\t\t copying the last entry over top of it.  */\n@@ -3517,7 +3536,7 @@ update_flow_info (notes, first, last, orig_insn)\n \t  REG_NOTES (first) = note;\n \n \t  insn = XEXP (note, 0);\n-\t  note = find_reg_note (insn, REG_RETVAL, 0);\n+\t  note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n \t  if (note)\n \t    XEXP (note, 0) = first;\n \t  break;\n@@ -3529,7 +3548,7 @@ update_flow_info (notes, first, last, orig_insn)\n \t  REG_NOTES (last) = note;\n \n \t  insn = XEXP (note, 0);\n-\t  note = find_reg_note (insn, REG_LIBCALL, 0);\n+\t  note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n \t  if (note)\n \t    XEXP (note, 0) = last;\n \t  break;\n@@ -3783,7 +3802,9 @@ schedule_insns (dump_file)\n     return;\n \n   /* Create an insn here so that we can hang dependencies off of it later.  */\n-  sched_before_next_call = gen_rtx (INSN, VOIDmode, 0, 0, 0, 0, 0, 0, 0);\n+  sched_before_next_call\n+    = gen_rtx (INSN, VOIDmode, 0, NULL_RTX, NULL_RTX,\n+\t       NULL_RTX, 0, NULL_RTX, 0);\n \n   /* Initialize the unused_*_lists.  We can't use the ones left over from\n      the previous function, because gcc has freed that memory.  We can use"}]}