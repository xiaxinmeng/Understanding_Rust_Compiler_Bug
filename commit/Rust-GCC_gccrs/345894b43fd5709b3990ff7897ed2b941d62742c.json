{"sha": "345894b43fd5709b3990ff7897ed2b941d62742c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ1ODk0YjQzZmQ1NzA5YjM5OTBmZjc4OTdlZDJiOTQxZDYyNzQyYw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-09-16T13:44:29Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-09-16T13:44:29Z"}, "message": "cpphash.h (_cpp_lex_token): Update prototype.\n\n\t* cpphash.h (_cpp_lex_token): Update prototype.\n\t* cpplex.c (_cpp_lex_token): New prototype.\n\t* cpplib.c (skip_rest_of_line, check_eol, _cpp_handle_directive,\n\tlex_macro_node, read_flag, do_pragma_poison): Update.\n\t* cppmacro.c (cpp_get_token, parse_params,\n\tlex_expansion_token): Update.\n\nFrom-SVN: r45646", "tree": {"sha": "b0d12b8ccfd049f7327ee01b7ef6f9fc687e6a3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0d12b8ccfd049f7327ee01b7ef6f9fc687e6a3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/345894b43fd5709b3990ff7897ed2b941d62742c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/345894b43fd5709b3990ff7897ed2b941d62742c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/345894b43fd5709b3990ff7897ed2b941d62742c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/345894b43fd5709b3990ff7897ed2b941d62742c/comments", "author": null, "committer": null, "parents": [{"sha": "18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8"}], "stats": {"total": 106, "additions": 51, "deletions": 55}, "files": [{"sha": "934d0b1dcb1e0342e53b567e5c3d6de6f27eea72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345894b43fd5709b3990ff7897ed2b941d62742c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345894b43fd5709b3990ff7897ed2b941d62742c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=345894b43fd5709b3990ff7897ed2b941d62742c", "patch": "@@ -1,3 +1,12 @@\n+2001-09-16  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (_cpp_lex_token): Update prototype.\n+\t* cpplex.c (_cpp_lex_token): New prototype.\n+\t* cpplib.c (skip_rest_of_line, check_eol, _cpp_handle_directive,\n+\tlex_macro_node, read_flag, do_pragma_poison): Update.\n+\t* cppmacro.c (cpp_get_token, parse_params,\n+\tlex_expansion_token): Update.\n+\n 2001-09-16  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cppmain.c (scan_translation_unit): Don't worry about"}, {"sha": "e6772b2d5d6f53da2876a6d3f5762cc0941bbecc", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345894b43fd5709b3990ff7897ed2b941d62742c/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345894b43fd5709b3990ff7897ed2b941d62742c/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=345894b43fd5709b3990ff7897ed2b941d62742c", "patch": "@@ -398,7 +398,7 @@ extern void _cpp_pop_file_buffer\tPARAMS ((cpp_reader *,\n extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n \n /* In cpplex.c */\n-extern void _cpp_lex_token\t\tPARAMS ((cpp_reader *, cpp_token *));\n+extern const cpp_token *_cpp_lex_token\tPARAMS ((cpp_reader *));\n extern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n \t\t\t\t\t\t const cpp_token *));\n extern void _cpp_init_tokenrun\t\tPARAMS ((tokenrun *, unsigned int));"}, {"sha": "1bfca20092c41b5780277fe0cd224171108af91a", "filename": "gcc/cpplex.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345894b43fd5709b3990ff7897ed2b941d62742c/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345894b43fd5709b3990ff7897ed2b941d62742c/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=345894b43fd5709b3990ff7897ed2b941d62742c", "patch": "@@ -933,10 +933,9 @@ next_tokenrun (run)\n }\n \n /* Lex a token into RESULT (external interface).  */\n-void\n-_cpp_lex_token (pfile, dest)\n+const cpp_token *\n+_cpp_lex_token (pfile)\n      cpp_reader *pfile;\n-     cpp_token *dest;\n {\n   cpp_token *result;\n \n@@ -979,7 +978,7 @@ _cpp_lex_token (pfile, dest)\n \tbreak;\n     }\n \n-  *dest = *result;\n+  return result;\n }\n \n /* Lex a token into RESULT.  When meeting a newline, returns CPP_EOF"}, {"sha": "63d0c174a8386f27cf97829178faaa719273b8dc", "filename": "gcc/cpplib.c", "status": "modified", "additions": 30, "deletions": 41, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345894b43fd5709b3990ff7897ed2b941d62742c/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345894b43fd5709b3990ff7897ed2b941d62742c/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=345894b43fd5709b3990ff7897ed2b941d62742c", "patch": "@@ -185,31 +185,24 @@ static void\n skip_rest_of_line (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_token token;\n-\n   /* Discard all stacked contexts.  */\n   while (pfile->context != &pfile->base_context)\n     _cpp_pop_context (pfile);\n \n   /* Sweep up all tokens remaining on the line.  */\n-  while (! SEEN_EOL ())\n-    _cpp_lex_token (pfile, &token);\n+  if (! SEEN_EOL ())\n+    while (_cpp_lex_token (pfile)->type != CPP_EOF)\n+      ;\n }\n \n /* Ensure there are no stray tokens at the end of a directive.  */\n static void\n check_eol (pfile)\n      cpp_reader *pfile;\n {\n-  if (! SEEN_EOL ())\n-    {\n-      cpp_token token;\n-\n-      _cpp_lex_token (pfile, &token);\n-      if (token.type != CPP_EOF)\n-\tcpp_pedwarn (pfile, \"extra tokens at end of #%s directive\",\n-\t\t     pfile->directive->name);\n-    }\n+  if (! SEEN_EOL () && _cpp_lex_token (pfile)->type != CPP_EOF)\n+    cpp_pedwarn (pfile, \"extra tokens at end of #%s directive\",\n+\t\t pfile->directive->name);\n }\n \n /* Called when entering a directive, _Pragma or command-line directive.  */\n@@ -307,20 +300,20 @@ _cpp_handle_directive (pfile, indented)\n      int indented;\n {\n   const directive *dir = 0;\n-  cpp_token dname;\n+  const cpp_token *dname;\n   int skip = 1;\n \n   start_directive (pfile);\n-  _cpp_lex_token (pfile, &dname);\n+  dname = _cpp_lex_token (pfile);\n \n-  if (dname.type == CPP_NAME)\n+  if (dname->type == CPP_NAME)\n     {\n-      if (dname.val.node->directive_index)\n-\tdir = &dtable[dname.val.node->directive_index - 1];\n+      if (dname->val.node->directive_index)\n+\tdir = &dtable[dname->val.node->directive_index - 1];\n     }\n   /* We do not recognise the # followed by a number extension in\n      assembler code.  */\n-  else if (dname.type == CPP_NUMBER && CPP_OPTION (pfile, lang) != CLK_ASM)\n+  else if (dname->type == CPP_NUMBER && CPP_OPTION (pfile, lang) != CLK_ASM)\n     {\n       dir = &dtable[T_LINE];\n       pfile->state.line_extension = 1;\n@@ -361,7 +354,7 @@ _cpp_handle_directive (pfile, indented)\n \t    dir = 0;\n \t}\n     }\n-  else if (dname.type == CPP_EOF)\n+  else if (dname->type == CPP_EOF)\n     ;\t/* CPP_EOF is the \"null directive\".  */\n   else\n     {\n@@ -373,7 +366,7 @@ _cpp_handle_directive (pfile, indented)\n \tskip = 0;\n       else if (!pfile->state.skipping)\n \tcpp_error (pfile, \"invalid preprocessing directive #%s\",\n-\t\t   cpp_token_as_text (pfile, &dname));\n+\t\t   cpp_token_as_text (pfile, dname));\n     }\n \n   if (dir)\n@@ -414,11 +407,8 @@ static cpp_hashnode *\n lex_macro_node (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_token token;\n   cpp_hashnode *node;\n-\n-  /* Lex the macro name directly.  */\n-  _cpp_lex_token (pfile, &token);\n+  const cpp_token *token = _cpp_lex_token (pfile);\n \n   /* The token immediately after #define must be an identifier.  That\n      identifier may not be \"defined\", per C99 6.10.8p4.\n@@ -427,22 +417,22 @@ lex_macro_node (pfile)\n      Finally, the identifier may not have been poisoned.  (In that case\n      the lexer has issued the error message for us.)  */\n \n-  if (token.type != CPP_NAME)\n+  if (token->type != CPP_NAME)\n     {\n-      if (token.type == CPP_EOF)\n+      if (token->type == CPP_EOF)\n \tcpp_error (pfile, \"no macro name given in #%s directive\",\n \t\t   pfile->directive->name);\n-      else if (token.flags & NAMED_OP)\n+      else if (token->flags & NAMED_OP)\n \tcpp_error (pfile,\n \t   \"\\\"%s\\\" cannot be used as a macro name as it is an operator in C++\",\n-\t\t   NODE_NAME (token.val.node));\n+\t\t   NODE_NAME (token->val.node));\n       else\n \tcpp_error (pfile, \"macro names must be identifiers\");\n \n       return 0;\n     }\n \n-  node = token.val.node;\n+  node = token->val.node;\n   if (node->flags & NODE_POISONED)\n     return 0;\n \n@@ -654,22 +644,21 @@ read_flag (pfile, last)\n      cpp_reader *pfile;\n      unsigned int last;\n {\n-  cpp_token token;\n+  const cpp_token *token = _cpp_lex_token (pfile);\n \n-  _cpp_lex_token (pfile, &token);\n-  if (token.type == CPP_NUMBER && token.val.str.len == 1)\n+  if (token->type == CPP_NUMBER && token->val.str.len == 1)\n     {\n-      unsigned int flag = token.val.str.text[0] - '0';\n+      unsigned int flag = token->val.str.text[0] - '0';\n \n       if (flag > last && flag <= 4\n \t  && (flag != 4 || last == 3)\n \t  && (flag != 2 || last == 0))\n \treturn flag;\n     }\n \n-  if (token.type != CPP_EOF)\n+  if (token->type != CPP_EOF)\n     cpp_error (pfile, \"invalid flag \\\"%s\\\" in line directive\",\n-\t       cpp_token_as_text (pfile, &token));\n+\t       cpp_token_as_text (pfile, token));\n   return 0;\n }\n \n@@ -1033,22 +1022,22 @@ do_pragma_poison (pfile)\n {\n   /* Poison these symbols so that all subsequent usage produces an\n      error message.  */\n-  cpp_token tok;\n+  const cpp_token *tok;\n   cpp_hashnode *hp;\n \n   pfile->state.poisoned_ok = 1;\n   for (;;)\n     {\n-      _cpp_lex_token (pfile, &tok);\n-      if (tok.type == CPP_EOF)\n+      tok = _cpp_lex_token (pfile);\n+      if (tok->type == CPP_EOF)\n \tbreak;\n-      if (tok.type != CPP_NAME)\n+      if (tok->type != CPP_NAME)\n \t{\n \t  cpp_error (pfile, \"invalid #pragma GCC poison directive\");\n \t  break;\n \t}\n \n-      hp = tok.val.node;\n+      hp = tok->val.node;\n       if (hp->flags & NODE_POISONED)\n \tcontinue;\n "}, {"sha": "e2014712467f07eb68d40b071bb77031dc6eae1b", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345894b43fd5709b3990ff7897ed2b941d62742c/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345894b43fd5709b3990ff7897ed2b941d62742c/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=345894b43fd5709b3990ff7897ed2b941d62742c", "patch": "@@ -912,7 +912,7 @@ cpp_get_token (pfile, token)\n \n       /* Context->prev == 0 <=> base context.  */\n       if (!context->prev)\n-\t_cpp_lex_token (pfile, token);\n+\t*token = *_cpp_lex_token (pfile);\n       else if (context->list.first != context->list.limit)\n \t{\n \t  *token = *context->list.first++;\n@@ -1124,19 +1124,18 @@ parse_params (pfile, macro)\n      cpp_reader *pfile;\n      cpp_macro *macro;\n {\n-  cpp_token token;\n   unsigned int prev_ident = 0;\n \n   macro->params = (cpp_hashnode **) POOL_FRONT (&pfile->macro_pool);\n   for (;;)\n     {\n-      _cpp_lex_token (pfile, &token);\n+      const cpp_token *token = _cpp_lex_token (pfile);\n \n-      switch (token.type)\n+      switch (token->type)\n \t{\n \tdefault:\n \t  cpp_error (pfile, \"\\\"%s\\\" may not appear in macro parameter list\",\n-\t\t     cpp_token_as_text (pfile, &token));\n+\t\t     cpp_token_as_text (pfile, token));\n \t  return 0;\n \n \tcase CPP_NAME:\n@@ -1147,7 +1146,7 @@ parse_params (pfile, macro)\n \t    }\n \t  prev_ident = 1;\n \n-\t  if (save_parameter (pfile, macro, token.val.node))\n+\t  if (save_parameter (pfile, macro, token->val.node))\n \t    return 0;\n \t  continue;\n \n@@ -1179,8 +1178,8 @@ parse_params (pfile, macro)\n \t    cpp_pedwarn (pfile, \"ISO C does not permit named variadic macros\");\n \n \t  /* We're at the end, and just expect a closing parenthesis.  */\n-\t  _cpp_lex_token (pfile, &token);\n-\t  if (token.type == CPP_CLOSE_PAREN)\n+\t  token = _cpp_lex_token (pfile);\n+\t  if (token->type == CPP_CLOSE_PAREN)\n \t    break;\n \t  /* Fall through.  */\n \n@@ -1214,7 +1213,7 @@ lex_expansion_token (pfile, macro)\n     }\n \n   macro->count++;\n-  _cpp_lex_token (pfile, token);\n+  *token = *_cpp_lex_token (pfile);\n \n   /* Is this an argument?  */\n   if (token->type == CPP_NAME && token->val.node->arg_index)"}]}