{"sha": "51891abe62c625f17598bd4d64a71c6169693bb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE4OTFhYmU2MmM2MjVmMTc1OThiZDRkNjRhNzFjNjE2OTY5M2JiNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-05-19T20:51:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-19T20:51:49Z"}, "message": "basic-block.h (struct edge_def): New field \"count\".\n\n\t* basic-block.h (struct edge_def): New field \"count\".\n\t(struct basic_block_def): Likewise.\n\t* flow.c (entry_exit_blocks): Add count fileds.\n\t(split_edge): Keep count information up-to-date.\n        (dump_edge_info, dump_flow_info): Dump count fields.\n\n\t* final.c (count_instrumented_edges): Rename to edge from arc.\n\t(end_final): Update users.\n\t* profile.c: Include expr.h, basic-block.h.\n\t(struct adj_list, ARC_TARGET, ARC_SOURCE, ARC_COUNT): Kill.\n        (struct bb_info, label_to_bb, label_to_bb_size, bb_graph): Kill.\n        (ignore_next_note, return_label_execution_count): Kill.\n\t(bbg_file_name, da_file_name): Kill.\n        (edge_info, bb_info): New structures.\n        (EDGE_INFO, BB_INFO, GCOV_INDEX_TO_BB, BB_TO_GCOV_INDEX): New macros.\n\t(count_instrumented_edges, total_num_edges): Rename to edge from arc.\n\t(total_num_edges_instrumented): Likewise.\n\t(init_arc, expand_spanning_tree): Kill.\n\t(fill_spanning_tree, tablejump_entry_p): Kill.\n\t(instrument_edges):  Rewrite from instrument_arcs to use\n\tcommit_edge_insertions infrastructure.\n\t(compute_branch_probabilities): Remove arguments; rewrite for\n\tCFG infrastructure; use rtl_dump_file directly.\n\t(branch_prob, find_spanning_tree): Likewise.\n\t(union_groups, find_group): New.\n\t(init_branch_prob): Make bbg_file_name and da_file_name local.\n\t(end_branch_prob): Use rtl_dump_file directly.\n\t(init_edge_profiler): Rename to edge from arc.\n\t(output_arc_profiler): Kill.\n\t(gen_edge_profiler): New.\n\t(output_func_start_profiler): Turn off profiling.  Make the\n\tconstructor static when we can.\n\t* rtl.h (branch_prob, end_branch_prob): Update prototypes.\n\n\t* toplev.c (DFI_flow): Remove.\n\t(DFI_cfg, DFI_life): New.\n\t(dump_file): Update accordingly.\n\t(compile_file): Call end_branch_prob if profile_arc_flag too.\n\t(rest_of_compilation): Move flow1 cfg creation to DFI_cfg.  Do edge\n\tprofiling after the CFG is built.  Move flow1 life analysis to\n\tDFI_life.  Always estimate remaining probabilities.\n\nCo-Authored-By: Richard Henderson <rth@cygnus.com>\n\nFrom-SVN: r34037", "tree": {"sha": "e57f4f516ce5ccbed54f9a6d32436cb91fcba1c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e57f4f516ce5ccbed54f9a6d32436cb91fcba1c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51891abe62c625f17598bd4d64a71c6169693bb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51891abe62c625f17598bd4d64a71c6169693bb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51891abe62c625f17598bd4d64a71c6169693bb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51891abe62c625f17598bd4d64a71c6169693bb6/comments", "author": null, "committer": null, "parents": [{"sha": "b6cfd26443d6161c71b6069346cbe805f86774a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6cfd26443d6161c71b6069346cbe805f86774a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6cfd26443d6161c71b6069346cbe805f86774a4"}], "stats": {"total": 1909, "additions": 699, "deletions": 1210}, "files": [{"sha": "b8166ac00c214f8ce14cae16d5e4bd2b7696adb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51891abe62c625f17598bd4d64a71c6169693bb6", "patch": "@@ -1,3 +1,48 @@\n+2000-05-19  Jan Hubicka  <jh@suse.cz>\n+\t    Richard Henderson  <rth@cygnus.com>\n+\n+\t* basic-block.h (struct edge_def): New field \"count\".\n+\t(struct basic_block_def): Likewise.\n+\t* flow.c (entry_exit_blocks): Add count fileds.\n+\t(split_edge): Keep count information up-to-date.\n+\t(dump_edge_info, dump_flow_info): Dump count fields.\n+\n+\t* final.c (count_instrumented_edges): Rename to edge from arc.\n+\t(end_final): Update users.\n+\t* profile.c: Include expr.h, basic-block.h.\n+\t(struct adj_list, ARC_TARGET, ARC_SOURCE, ARC_COUNT): Kill.\n+\t(struct bb_info, label_to_bb, label_to_bb_size, bb_graph): Kill.\n+\t(ignore_next_note, return_label_execution_count): Kill.\n+\t(bbg_file_name, da_file_name): Kill.\n+\t(edge_info, bb_info): New structures.\n+\t(EDGE_INFO, BB_INFO, GCOV_INDEX_TO_BB, BB_TO_GCOV_INDEX): New macros.\n+\t(count_instrumented_edges, total_num_edges): Rename to edge from arc.\n+\t(total_num_edges_instrumented): Likewise.\n+\t(init_arc, expand_spanning_tree): Kill.\n+\t(fill_spanning_tree, tablejump_entry_p): Kill.\n+\t(instrument_edges):  Rewrite from instrument_arcs to use\n+\tcommit_edge_insertions infrastructure.\n+\t(compute_branch_probabilities): Remove arguments; rewrite for\n+\tCFG infrastructure; use rtl_dump_file directly.\n+\t(branch_prob, find_spanning_tree): Likewise.\n+\t(union_groups, find_group): New.\n+\t(init_branch_prob): Make bbg_file_name and da_file_name local.\n+\t(end_branch_prob): Use rtl_dump_file directly.\n+\t(init_edge_profiler): Rename to edge from arc.\n+\t(output_arc_profiler): Kill.\n+\t(gen_edge_profiler): New.\n+\t(output_func_start_profiler): Turn off profiling.  Make the\n+\tconstructor static when we can.\n+\t* rtl.h (branch_prob, end_branch_prob): Update prototypes.\n+\n+\t* toplev.c (DFI_flow): Remove.\n+\t(DFI_cfg, DFI_life): New.\n+\t(dump_file): Update accordingly.\n+\t(compile_file): Call end_branch_prob if profile_arc_flag too.\n+\t(rest_of_compilation): Move flow1 cfg creation to DFI_cfg.  Do edge\n+\tprofiling after the CFG is built.  Move flow1 life analysis to\n+\tDFI_life.  Always estimate remaining probabilities.\n+\n 2000-05-19  Richard Henderson  <rth@cygnus.com>\n \n \t* ifcvt.c (find_if_case_2): Don't allow THEN to be EXIT."}, {"sha": "dec7707b43679e9e49c6435d763cc63b197b7c53", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=51891abe62c625f17598bd4d64a71c6169693bb6", "patch": "@@ -129,6 +129,8 @@ typedef struct edge_def {\n \n   int flags;\t\t\t/* see EDGE_* below  */\n   int probability;\t\t/* biased by REG_BR_PROB_BASE */\n+  int count;\t\t\t/* Expected number of executions calculated\n+\t\t\t\t   in profile.c  */\n } *edge;\n \n #define EDGE_FALLTHRU\t\t1\n@@ -164,6 +166,8 @@ typedef struct basic_block_def {\n \n   /* The active eh region before head and after end.  */\n   int eh_beg, eh_end;\n+\n+  int count;\t\t/* Expected number of executions calculated in profile.c  */\n } *basic_block;\n \n /* Number of basic blocks in the current function.  */"}, {"sha": "1aedfa388448c5871234dc47e1b5509ed6baf164", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=51891abe62c625f17598bd4d64a71c6169693bb6", "patch": "@@ -159,7 +159,7 @@ static const char *last_filename;\n static int count_basic_blocks;\n \n /* Number of instrumented arcs when profile_arc_flag is set.  */\n-extern int count_instrumented_arcs;\n+extern int count_instrumented_edges;\n \n extern int length_unit_log; /* This is defined in insn-attrtab.c.  */\n \n@@ -333,7 +333,7 @@ end_final (filename)\n       if (profile_block_flag)\n \tsize = long_bytes * count_basic_blocks;\n       else\n-\tsize = long_bytes * count_instrumented_arcs;\n+\tsize = long_bytes * count_instrumented_edges;\n       rounded = size;\n \n       rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;\n@@ -376,8 +376,7 @@ end_final (filename)\n       if (profile_block_flag)\n \tassemble_integer (GEN_INT (count_basic_blocks), long_bytes, 1);\n       else\n-\tassemble_integer (GEN_INT (count_instrumented_arcs), long_bytes,\n-\t\t\t  1);\n+\tassemble_integer (GEN_INT (count_instrumented_edges), long_bytes, 1);\n \n       /* zero word (link field) */\n       assemble_integer (const0_rtx, pointer_bytes, 1);"}, {"sha": "08d61b1540950e94b60de487e9b4c7376eac3690", "filename": "gcc/flow.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=51891abe62c625f17598bd4d64a71c6169693bb6", "patch": "@@ -194,7 +194,8 @@ struct basic_block_def entry_exit_blocks[2]\n     NULL,\t\t\t/* aux */\n     ENTRY_BLOCK,\t\t/* index */\n     0,\t\t\t\t/* loop_depth */\n-    -1, -1\t\t\t/* eh_beg, eh_end */\n+    -1, -1,\t\t\t/* eh_beg, eh_end */\n+    0\t\t\t\t/* count */\n   },\n   {\n     NULL,\t\t\t/* head */\n@@ -207,7 +208,8 @@ struct basic_block_def entry_exit_blocks[2]\n     NULL,\t\t\t/* aux */\n     EXIT_BLOCK,\t\t\t/* index */\n     0,\t\t\t\t/* loop_depth */\n-    -1, -1\t\t\t/* eh_beg, eh_end */\n+    -1, -1,\t\t\t/* eh_beg, eh_end */\n+    0\t\t\t\t/* count */\n   }\n };\n \n@@ -1382,6 +1384,7 @@ split_edge (edge_in)\n   /* Wire them up.  */\n   bb->pred = edge_in;\n   bb->succ = edge_out;\n+  bb->count = edge_in->count;\n \n   edge_in->dest = bb;\n   edge_in->flags &= ~EDGE_CRITICAL;\n@@ -1392,6 +1395,7 @@ split_edge (edge_in)\n   edge_out->dest = old_succ;\n   edge_out->flags = EDGE_FALLTHRU;\n   edge_out->probability = REG_BR_PROB_BASE;\n+  edge_out->count = edge_in->count;\n \n   old_succ->pred = edge_out;\n \n@@ -3809,7 +3813,7 @@ insn_dead_p (pbi, x, call_ok, notes)\n \t  /* Walk the set of memory locations we are currently tracking\n \t     and see if one is an identical match to this memory location.\n \t     If so, this memory write is dead (remember, we're walking\n-\t     backwards from the end of the block to the start.  */\n+\t     backwards from the end of the block to the start).  */\n \t  temp = pbi->mem_set_list;\n \t  while (temp)\n \t    {\n@@ -5608,8 +5612,8 @@ dump_flow_info (file)\n       register basic_block bb = BASIC_BLOCK (i);\n       register edge e;\n \n-      fprintf (file, \"\\nBasic block %d: first insn %d, last %d, loop_depth %d.\\n\",\n-\t       i, INSN_UID (bb->head), INSN_UID (bb->end), bb->loop_depth);\n+      fprintf (file, \"\\nBasic block %d: first insn %d, last %d, loop_depth %d, count %d.\\n\",\n+\t       i, INSN_UID (bb->head), INSN_UID (bb->end), bb->loop_depth, bb->count);\n \n       fprintf (file, \"Predecessors: \");\n       for (e = bb->pred; e ; e = e->pred_next)\n@@ -5652,6 +5656,9 @@ dump_edge_info (file, e, do_succ)\n   else\n     fprintf (file, \" %d\", side->index);\n \n+  if (e->count)\n+    fprintf (file, \" count:%d\", e->count);\n+\n   if (e->flags)\n     {\n       static const char * const bitnames[] = {\n@@ -5690,8 +5697,8 @@ dump_bb (bb, outf)\n   rtx last;\n   edge e;\n \n-  fprintf (outf, \";; Basic block %d, loop depth %d\",\n-\t   bb->index, bb->loop_depth);\n+  fprintf (outf, \";; Basic block %d, loop depth %d, count %d\",\n+\t   bb->index, bb->loop_depth, bb->count);\n   if (bb->eh_beg != -1 || bb->eh_end != -1)\n     fprintf (outf, \", eh regions %d/%d\", bb->eh_beg, bb->eh_end);\n   putc ('\\n', outf);"}, {"sha": "960fbecb2c62d6d946304046c8b544fe4cc82410", "filename": "gcc/profile.c", "status": "modified", "additions": 604, "deletions": 1170, "changes": 1774, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=51891abe62c625f17598bd4d64a71c6169693bb6", "patch": "@@ -21,10 +21,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* ??? Really should not put insns inside of LIBCALL sequences, when putting\n-   insns after a call, should look for the insn setting the retval, and\n-   insert the insns after that one.  */\n-\n /* ??? Register allocation should use basic block execution counts to\n    give preference to the most commonly executed blocks.  */\n \n@@ -36,11 +32,6 @@ Boston, MA 02111-1307, USA.  */\n /* ??? Should calculate branch probabilities before instrumenting code, since\n    then we can use arc counts to help decide which arcs to instrument.  */\n \n-/* ??? Rearrange code so that the most frequently executed arcs become from\n-   one block to the next block (i.e. a fall through), move seldom executed\n-   code outside of loops even at the expense of adding a few branches to\n-   achieve this, see Dain Sample's UC Berkeley thesis.  */\n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"rtl.h\"\n@@ -50,68 +41,46 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"output.h\"\n #include \"regs.h\"\n+#include \"expr.h\"\n #include \"function.h\"\n #include \"gcov-io.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n+#include \"basic-block.h\"\n \n-/* One of these is dynamically created whenever we identify an arc in the\n-   function.  */\n-\n-struct adj_list\n-{\n-  int source;\n-  int target;\n-  int arc_count;\n-  unsigned int count_valid : 1;\n-  unsigned int on_tree : 1;\n-  unsigned int fake : 1;\n-  unsigned int fall_through : 1;\n-  rtx branch_insn;\n-  struct adj_list *pred_next;\n-  struct adj_list *succ_next;\n-};\n-\n-#define ARC_TARGET(ARCPTR) (ARCPTR->target)\n-#define ARC_SOURCE(ARCPTR) (ARCPTR->source)\n-#define ARC_COUNT(ARCPTR)  (ARCPTR->arc_count)\n-\n-/* Count the number of basic blocks, and create an array of these structures,\n-   one for each bb in the function.  */\n \n+/* Additional information about the edges we need.  */\n+struct edge_info\n+  {\n+    unsigned int count_valid : 1;\n+    unsigned int on_tree : 1;\n+    unsigned int ignore : 1;\n+  };\n struct bb_info\n-{\n-  struct adj_list *succ;\n-  struct adj_list *pred;\n-  int succ_count;\n-  int pred_count;\n-  int exec_count;\n-  unsigned int count_valid : 1;\n-  unsigned int on_tree : 1;\n-  rtx first_insn;\n-};\n-\n-/* Indexed by label number, gives the basic block number containing that\n-   label.  */\n-\n-static int *label_to_bb;\n-\n-/* Number of valid entries in the label_to_bb array.  */\n-\n-static int label_to_bb_size;\n-\n-/* Indexed by block index, holds the basic block graph.  */\n-\n-static struct bb_info *bb_graph;\n+  {\n+    unsigned int count_valid : 1;\n+    int succ_count;\n+    int pred_count;\n+  };\n+\n+#define EDGE_INFO(e)  ((struct edge_info *) (e)->aux)\n+#define BB_INFO(b)  ((struct bb_info *) (b)->aux)\n+\n+/* Keep all basic block indexes nonnegative in the gcov output.  Index 0\n+   is used for entry block, last block exit block.   */\n+#define GCOV_INDEX_TO_BB(i)  ((i) == 0 ? ENTRY_BLOCK_PTR\t\t\\\n+    \t\t\t      : (((i) == n_basic_blocks + 1)\t\t\\\n+\t\t\t         ? EXIT_BLOCK_PTR : BASIC_BLOCK ((i)-1)))\n+#define BB_TO_GCOV_INDEX(bb)  ((bb) == ENTRY_BLOCK_PTR ? 0 \t\t\\\n+  \t\t\t       : ((bb) == EXIT_BLOCK_PTR\t\t\\\n+\t\t\t\t  ? n_basic_blocks + 1 : (bb)->index + 1))\n \n /* Name and file pointer of the output file for the basic block graph.  */\n \n-static char *bbg_file_name;\n static FILE *bbg_file;\n \n /* Name and file pointer of the input file for the arc count data.  */\n \n-static char *da_file_name;\n static FILE *da_file;\n \n /* Pointer of the output file for the basic block/line number map. */\n@@ -121,27 +90,17 @@ static FILE *bb_file;\n \n static char *last_bb_file_name;\n \n-/* Indicates whether the next line number note should be output to\n-   bb_file or not.  Used to eliminate a redundant note after an\n-   expanded inline function call.  */\n-\n-static int ignore_next_note;\n-\n /* Used by final, for allocating the proper amount of storage for the\n    instrumented arc execution counts.  */\n \n-int count_instrumented_arcs;\n-\n-/* Number of executions for the return label.  */\n-\n-int return_label_execution_count;\n+int count_instrumented_edges;\n \n /* Collect statistics on the performance of this pass for the entire source\n    file.  */\n \n static int total_num_blocks;\n-static int total_num_arcs;\n-static int total_num_arcs_instrumented;\n+static int total_num_edges;\n+static int total_num_edges_instrumented;\n static int total_num_blocks_created;\n static int total_num_passes;\n static int total_num_times_called;\n@@ -150,16 +109,14 @@ static int total_num_never_executed;\n static int total_num_branches;\n \n /* Forward declarations.  */\n-static void init_arc PARAMS ((struct adj_list *, int, int, rtx));\n-static void find_spanning_tree PARAMS ((int));\n-static void expand_spanning_tree PARAMS ((int));\n-static void fill_spanning_tree PARAMS ((int));\n-static void init_arc_profiler PARAMS ((void));\n-static void output_arc_profiler PARAMS ((int, rtx));\n-static void instrument_arcs PARAMS ((rtx, int, FILE *));\n+static void find_spanning_tree PARAMS ((struct edge_list *));\n+static void init_edge_profiler PARAMS ((void));\n+static rtx gen_edge_profiler PARAMS ((int));\n+static void instrument_edges PARAMS ((struct edge_list *));\n static void output_gcov_string PARAMS ((const char *, long));\n-static int tablejump_entry_p PARAMS ((rtx, rtx));\n-static void compute_branch_probabilities PARAMS ((int, FILE *));\n+static void compute_branch_probabilities PARAMS ((void));\n+static basic_block find_group PARAMS ((basic_block));\n+static void union_groups PARAMS ((basic_block, basic_block));\n \n #ifndef LONG_TYPE_SIZE\n #define LONG_TYPE_SIZE BITS_PER_WORD\n@@ -168,223 +125,53 @@ static void compute_branch_probabilities PARAMS ((int, FILE *));\n /* If non-zero, we need to output a constructor to set up the\n    per-object-file data. */\n static int need_func_profiler = 0;\n-\n \f\n-/* Add arc instrumentation code to the entire insn chain.\n+/* Add edge instrumentation code to the entire insn chain.\n \n    F is the first insn of the chain.\n-   NUM_BLOCKS is the number of basic blocks found in F.\n-   DUMP_FILE, if nonzero, is an rtl dump file we can write to.  */\n+   NUM_BLOCKS is the number of basic blocks found in F.  */\n \n static void\n-instrument_arcs (f, num_blocks, dump_file)\n-     rtx f;\n-     int num_blocks;\n-     FILE *dump_file;\n+instrument_edges (el)\n+     struct edge_list *el;\n {\n-  register int i;\n-  register struct adj_list *arcptr, *backptr;\n-  int num_arcs = 0;\n-  int num_instr_arcs = 0;\n-  rtx insn;\n-\n-  /* Instrument the program start.  */\n-  /* Handle block 0 specially, since it will always be instrumented,\n-     but it doesn't have a valid first_insn or branch_insn.  We must\n-     put the instructions before the NOTE_INSN_FUNCTION_BEG note, so\n-     that they don't clobber any of the parameters of the current\n-     function.  */\n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == NOTE\n-\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n-      break;\n-  insn = PREV_INSN (insn);\n-  need_func_profiler = 1;\n-  output_arc_profiler (total_num_arcs_instrumented + num_instr_arcs++, insn);\n-\n-  for (i = 1; i < num_blocks; i++)\n-    for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n-      if (! arcptr->on_tree)\n+  int i;\n+  int num_instr_edges = 0;\n+  int num_edges = NUM_EDGES (el);\n+  remove_fake_edges ();\n+\n+  for (i = 0; i < n_basic_blocks + 2; i++)\n+    {\n+      basic_block bb = GCOV_INDEX_TO_BB (i);\n+      edge e = bb->succ;\n+      while (e)\n \t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Arc %d to %d instrumented\\n\", i,\n-\t\t     ARC_TARGET (arcptr));\n-\n-\t  /* Check to see if this arc is the only exit from its source block,\n-\t     or the only entrance to its target block.  In either case,\n-\t     we don't need to create a new block to instrument the arc.  */\n-\t  \n-\t  if (bb_graph[i].succ == arcptr && arcptr->succ_next == 0)\n-\t    {\n-\t      /* Instrument the source block.  */\n-\t      output_arc_profiler (total_num_arcs_instrumented\n-\t\t\t\t   + num_instr_arcs++,\n-\t\t\t\t   PREV_INSN (bb_graph[i].first_insn));\n-\t    }\n-\t  else if (arcptr == bb_graph[ARC_TARGET (arcptr)].pred\n-\t\t   && arcptr->pred_next == 0)\n+\t  struct edge_info *inf = EDGE_INFO (e);\n+\t  if (!inf->ignore && !inf->on_tree)\n \t    {\n-\t      /* Instrument the target block.  */\n-\t      output_arc_profiler (total_num_arcs_instrumented\n-\t\t\t\t   + num_instr_arcs++, \n-\t\t\t\t   PREV_INSN (bb_graph[ARC_TARGET (arcptr)].first_insn));\n-\t    }\n-\t  else if (arcptr->fall_through)\n-\t    {\n-\t      /* This is a fall-through; put the instrumentation code after\n-\t\t the branch that ends this block.  */\n-\t      \n-\t      for (backptr = bb_graph[i].succ; backptr;\n-\t\t   backptr = backptr->succ_next)\n-\t\tif (backptr != arcptr)\n-\t\t  break;\n-\t      \n-\t      output_arc_profiler (total_num_arcs_instrumented\n-\t\t\t\t   + num_instr_arcs++,\n-\t\t\t\t   backptr->branch_insn);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Must emit a new basic block to hold the arc counting code.  */\n-\t      enum rtx_code code = GET_CODE (PATTERN (arcptr->branch_insn));\n-\n-\t      if (code == SET)\n-\t\t{\n-\t\t  /* Create the new basic block right after the branch.\n-\t\t     Invert the branch so that it jumps past the end of the new\n-\t\t     block.  The new block will consist of the instrumentation\n-\t\t     code, and a jump to the target of this arc.  */\n-\t\t  int this_is_simplejump = simplejump_p (arcptr->branch_insn);\n-\t\t  rtx new_label = gen_label_rtx ();\n-\t\t  rtx old_label, set_src;\n-\t\t  rtx after = arcptr->branch_insn;\n-\t\t  \n-\t\t  /* Simplejumps can't reach here.  */\n-\t\t  if (this_is_simplejump)\n-\t\t    abort ();\n-\n-\t\t  /* We can't use JUMP_LABEL, because it won't be set if we\n-\t\t     are compiling without optimization.  */\n-\n-\t\t  set_src = SET_SRC (single_set (arcptr->branch_insn));\n-\t\t  if (GET_CODE (set_src) == LABEL_REF)\n-\t\t    old_label = set_src;\n-\t\t  else if (GET_CODE (set_src) != IF_THEN_ELSE)\n-\t\t    abort ();\n-\t\t  else if (XEXP (set_src, 1) == pc_rtx)\n-\t\t    old_label = XEXP (XEXP (set_src, 2), 0);\n-\t\t  else\n-\t\t    old_label = XEXP (XEXP (set_src, 1), 0);\n-\n-\t\t  /* Set the JUMP_LABEL so that redirect_jump will work.  */\n-\t\t  JUMP_LABEL (arcptr->branch_insn) = old_label;\n-\n-\t\t  /* Add a use for OLD_LABEL that will be needed when we emit\n-\t\t     the JUMP_INSN below.  If we don't do this here,\n-\t\t     `invert_jump' might delete it for us.  We must add two\n-\t\t     when not optimizing, because the NUSES is zero now,\n-\t\t     but must be at least two to prevent the label from being\n-\t\t     deleted.  */\n-\t\t  LABEL_NUSES (old_label) += 2;\n-\t\t  \n-\t\t  /* Emit the insns for the new block in reverse order,\n-\t\t     since that is most convenient.  */\n-\n-\t\t  if (this_is_simplejump)\n-\t\t    {\n-\t\t      after = NEXT_INSN (arcptr->branch_insn);\n-\t\t      if (! redirect_jump (arcptr->branch_insn, new_label, 1))\n-\t\t\t/* Don't know what to do if this branch won't\n-\t\t\t   redirect.  */\n-\t\t\tabort ();\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (! invert_jump (arcptr->branch_insn, new_label, 1))\n-\t\t\t/* Don't know what to do if this branch won't invert.  */\n-\t\t\tabort ();\n-\n-\t\t      emit_label_after (new_label, after);\n-\t\t      LABEL_NUSES (new_label)++;\n-\t\t    }\n-\t\t  emit_barrier_after (after);\n-\t\t  emit_jump_insn_after (gen_jump (old_label), after);\n-\t\t  JUMP_LABEL (NEXT_INSN (after)) = old_label;\n-\t\t  \n-\t\t  /* Instrument the source arc.  */\n-\t\t  output_arc_profiler (total_num_arcs_instrumented\n-\t\t\t\t       + num_instr_arcs++,\n-\t\t\t\t       after);\n-\t\t  if (this_is_simplejump)\n-\t\t    {\n-\t\t      emit_label_after (new_label, after);\n-\t\t      LABEL_NUSES (new_label)++;\n-\t\t    }\n-\t\t}\n-\t      else if (code == ADDR_VEC || code == ADDR_DIFF_VEC)\n-\t\t{\n-\t\t  /* A table jump.  Create a new basic block immediately\n-\t\t     after the table, by emitting a barrier, a label, a\n-\t\t     counting note, and a jump to the old label.  Put the\n-\t\t     new label in the table.  */\n-\t\t  \n-\t\t  rtx new_label = gen_label_rtx ();\n-\t\t  rtx old_lref, new_lref;\n-\t\t  int index;\n-\t\t  \n-\t\t  /* Must determine the old_label reference, do this\n-\t\t     by counting the arcs after this one, which will\n-\t\t     give the index of our label in the table.  */\n-\t\t  \n-\t\t  index = 0;\n-\t\t  for (backptr = arcptr->succ_next; backptr;\n-\t\t       backptr = backptr->succ_next)\n-\t\t    index++;\n-\t\t  \n-\t\t  old_lref = XVECEXP (PATTERN (arcptr->branch_insn),\n-\t\t\t\t      (code == ADDR_DIFF_VEC), index);\n-\t\t  \n-\t\t  /* Emit the insns for the new block in reverse order,\n-\t\t     since that is most convenient.  */\n-\t\t  emit_jump_insn_after (gen_jump (XEXP (old_lref, 0)),\n-\t\t\t\t\tarcptr->branch_insn);\n-\t\t  JUMP_LABEL (NEXT_INSN (arcptr->branch_insn))\n-\t\t    = XEXP (old_lref, 0);\n-\n-\t\t  /* Instrument the source arc.  */\n-\t\t  output_arc_profiler (total_num_arcs_instrumented\n-\t\t\t\t       + num_instr_arcs++,\n-\t\t\t\t       arcptr->branch_insn);\n-\n-\t\t  emit_label_after (new_label, arcptr->branch_insn);\n-\t\t  LABEL_NUSES (NEXT_INSN (arcptr->branch_insn))++;\n-\t\t  emit_barrier_after (arcptr->branch_insn);\n-\t\t  \n-\t\t  /* Fix up the table jump.  */\n-\t\t  new_lref = gen_rtx_LABEL_REF (Pmode, new_label);\n-\t\t  XVECEXP (PATTERN (arcptr->branch_insn),\n-\t\t\t   (code == ADDR_DIFF_VEC), index) = new_lref;\n-\t\t}\n-\t      else\n+\t      if (e->flags & EDGE_ABNORMAL)\n \t\tabort ();\n-\n-\t      num_arcs += 1;\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Arc %d to %d needed new basic block\\n\", i,\n-\t\t\t ARC_TARGET (arcptr));\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file, \"Edge %d to %d instrumented%s\\n\",\n+\t\t\t e->src->index, e->dest->index,\n+\t\t\t e->flags & EDGE_CRITICAL ? \" (and split)\" : \"\");\n+\t      need_func_profiler = 1;\n+\t      insert_insn_on_edge (\n+\t\t\t gen_edge_profiler (total_num_edges_instrumented\n+\t\t\t\t\t    + num_instr_edges++), e);\n \t    }\n+\t  e = e->succ_next;\n \t}\n-  \n-  total_num_arcs_instrumented += num_instr_arcs;\n-  count_instrumented_arcs = total_num_arcs_instrumented;\n-\n-  total_num_blocks_created += num_arcs;\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"%d arcs instrumented\\n\", num_instr_arcs);\n-      fprintf (dump_file, \"%d extra basic blocks created\\n\", num_arcs);\n     }\n+\n+  total_num_edges_instrumented += num_instr_edges;\n+  count_instrumented_edges = total_num_edges_instrumented;\n+\n+  total_num_blocks_created += num_edges;\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"%d edges instrumented\\n\", num_instr_edges);\n+\n+  commit_edge_insertions ();\n }\n \n /* Output STRING to bb_file, surrounded by DELIMITER.  */\n@@ -413,93 +200,96 @@ output_gcov_string (string, delimiter)\n       fwrite (c, sizeof (char), 4 - temp, bb_file);\n     }\n \n-  /* Store another delimiter in the .bb file, just to make it easy to find the\n-     end of the file name.  */\n+  /* Store another delimiter in the .bb file, just to make it easy to find\n+     the end of the file name.  */\n   __write_long (delimiter, bb_file, 4);\n }\n \f\n-/* Return TRUE if this insn must be a tablejump entry insn.  This works for\n-   the MIPS port, but may give false negatives for some targets.  */\n-\n-static int\n-tablejump_entry_p (insn, label)\n-     rtx insn, label;\n-{\n-  rtx next = next_active_insn (insn);\n-  enum rtx_code code = GET_CODE (PATTERN (next));\n-\n-  if (code != ADDR_DIFF_VEC && code != ADDR_VEC)\n-    return 0;\n-\n-  if (PREV_INSN (next) == XEXP (label, 0))\n-    return 1;\n-\n-  return 0;\n-}\n \n /* Compute the branch probabilities for the various branches.\n    Annotate them accordingly.  */\n \n static void\n-compute_branch_probabilities (num_blocks, dump_file)\n-     int num_blocks;\n-     FILE *dump_file;\n+compute_branch_probabilities ()\n {\n   int i;\n-  int bad_counts = 0;\n-  int num_arcs;\n+  int num_edges = 0;\n   int changes;\n   int passes;\n-  int prob;\n-  int total;\n-  int num_branches;\n-  int num_never_executed;\n   int hist_br_prob[20];\n-  struct adj_list *arcptr;\n+  int num_never_executed;\n+  int num_branches;\n+  int bad_counts = 0;\n+  struct bb_info *bb_infos;\n \n-  /* For each arc not on the spanning tree, set its execution count from\n+  /* Attach extra info block to each bb.  */\n+\n+  bb_infos = (struct bb_info *)\n+    xcalloc (n_basic_blocks + 2, sizeof (struct bb_info));\n+  for (i = 0; i < n_basic_blocks + 2; i++)\n+    {\n+      basic_block bb = GCOV_INDEX_TO_BB (i);\n+      edge e;\n+\n+      bb->aux = &bb_infos[i];\n+      for (e = bb->succ; e; e = e->succ_next)\n+\tif (!EDGE_INFO (e)->ignore)\n+\t  BB_INFO (bb)->succ_count++;\n+      for (e = bb->pred; e; e = e->pred_next)\n+\tif (!EDGE_INFO (e)->ignore)\n+\t  BB_INFO (bb)->pred_count++;\n+    }\n+\n+  /* Avoid predicting entry on exit nodes.  */\n+  BB_INFO (EXIT_BLOCK_PTR)->succ_count = 2;\n+  BB_INFO (ENTRY_BLOCK_PTR)->pred_count = 2;\n+\n+  /* For each edge not on the spanning tree, set its execution count from\n      the .da file.  */\n \n   /* The first count in the .da file is the number of times that the function\n      was entered.  This is the exec_count for block zero.  */\n \n-  num_arcs = 0;\n-  for (i = 0; i < num_blocks; i++)\n-    for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n-      if (! arcptr->on_tree)\n-\t{\n-\t  num_arcs++;\n-\t  if (da_file)\n-\t    {\n-\t      long value;\n-\t      __read_long (&value, da_file, 8);\n-\t      ARC_COUNT (arcptr) = value;\n-\t    }\n-\t  else\n-\t    ARC_COUNT (arcptr) = 0;\n-\t  arcptr->count_valid = 1;\n-\t  bb_graph[i].succ_count--;\n-\t  bb_graph[ARC_TARGET (arcptr)].pred_count--;\n-\t}\n+  for (i = 0; i < n_basic_blocks + 2; i++)\n+    {\n+      basic_block bb = GCOV_INDEX_TO_BB (i);\n+      edge e;\n+      for (e = bb->succ; e; e = e->succ_next)\n+\tif (!EDGE_INFO (e)->ignore && !EDGE_INFO (e)->on_tree)\n+\t  {\n+\t    num_edges++;\n+\t    if (da_file)\n+\t      {\n+\t\tlong value;\n+\t\t__read_long (&value, da_file, 8);\n+\t\te->count = value;\n+\t      }\n+\t    else\n+\t      e->count = 0;\n+\t    EDGE_INFO (e)->count_valid = 1;\n+\t    BB_INFO (bb)->succ_count--;\n+\t    BB_INFO (e->dest)->pred_count--;\n+\t  }\n+    }\n \n-  if (dump_file)\n-    fprintf (dump_file, \"%d arc counts read\\n\", num_arcs);\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"%d edge counts read\\n\", num_edges);\n \n   /* For every block in the file,\n-     - if every exit/entrance arc has a known count, then set the block count\n-     - if the block count is known, and every exit/entrance arc but one has\n-       a known execution count, then set the count of the remaining arc\n+     - if every exit/entrance edge has a known count, then set the block count\n+     - if the block count is known, and every exit/entrance edge but one has\n+     a known execution count, then set the count of the remaining edge\n \n-     As arc counts are set, decrement the succ/pred count, but don't delete\n-     the arc, that way we can easily tell when all arcs are known, or only\n-     one arc is unknown.  */\n+     As edge counts are set, decrement the succ/pred count, but don't delete\n+     the edge, that way we can easily tell when all edges are known, or only\n+     one edge is unknown.  */\n \n   /* The order that the basic blocks are iterated through is important.\n      Since the code that finds spanning trees starts with block 0, low numbered\n-     arcs are put on the spanning tree in preference to high numbered arcs.\n-     Hence, most instrumented arcs are at the end.  Graph solving works much\n+     edges are put on the spanning tree in preference to high numbered edges.\n+     Hence, most instrumented edges are at the end.  Graph solving works much\n      faster if we propagate numbers from the end to the start.\n-     \n+\n      This takes an average of slightly more than 3 passes.  */\n \n   changes = 1;\n@@ -508,159 +298,159 @@ compute_branch_probabilities (num_blocks, dump_file)\n     {\n       passes++;\n       changes = 0;\n-\n-      for (i = num_blocks - 1; i >= 0; i--)\n+      for (i = n_basic_blocks + 1; i >= 0; i--)\n \t{\n-\t  struct bb_info *binfo = &bb_graph[i];\n-\t  if (! binfo->count_valid)\n+\t  basic_block bb = GCOV_INDEX_TO_BB (i);\n+\t  struct bb_info *bi = BB_INFO (bb);\n+\t  if (! bi->count_valid)\n \t    {\n-\t      if (binfo->succ_count == 0)\n+\t      if (bi->succ_count == 0)\n \t\t{\n-\t\t  total = 0;\n-\t\t  for (arcptr = binfo->succ; arcptr;\n-\t\t       arcptr = arcptr->succ_next)\n-\t\t    total += ARC_COUNT (arcptr);\n-\t\t  binfo->exec_count = total;\n-\t\t  binfo->count_valid = 1;\n+\t\t  edge e;\n+\t\t  int total = 0;\n+\n+\t\t  for (e = bb->succ; e; e = e->succ_next)\n+\t\t    total += e->count;\n+\t\t  bb->count = total;\n+\t\t  bi->count_valid = 1;\n \t\t  changes = 1;\n \t\t}\n-\t      else if (binfo->pred_count == 0)\n+\t      else if (bi->pred_count == 0)\n \t\t{\n-\t\t  total = 0;\n-\t\t  for (arcptr = binfo->pred; arcptr;\n-\t\t       arcptr = arcptr->pred_next)\n-\t\t    total += ARC_COUNT (arcptr);\n-\t\t  binfo->exec_count = total;\n-\t\t  binfo->count_valid = 1;\n+\t\t  edge e;\n+\t\t  int total = 0;\n+\n+\t\t  for (e = bb->pred; e; e = e->pred_next)\n+\t\t    total += e->count;\n+\t\t  bb->count = total;\n+\t\t  bi->count_valid = 1;\n \t\t  changes = 1;\n \t\t}\n \t    }\n-\t  if (binfo->count_valid)\n+\t  if (bi->count_valid)\n \t    {\n-\t      if (binfo->succ_count == 1)\n+\t      if (bi->succ_count == 1)\n \t\t{\n-\t\t  total = 0;\n+\t\t  edge e;\n+\t\t  int total = 0;\n+\n \t\t  /* One of the counts will be invalid, but it is zero,\n \t\t     so adding it in also doesn't hurt.  */\n-\t\t  for (arcptr = binfo->succ; arcptr;\n-\t\t       arcptr = arcptr->succ_next)\n-\t\t    total += ARC_COUNT (arcptr);\n-\t\t  /* Calculate count for remaining arc by conservation.  */\n-\t\t  total = binfo->exec_count - total;\n-\t\t  /* Search for the invalid arc, and set its count.  */\n-\t\t  for (arcptr = binfo->succ; arcptr;\n-\t\t       arcptr = arcptr->succ_next)\n-\t\t    if (! arcptr->count_valid)\n+\t\t  for (e = bb->succ; e; e = e->succ_next)\n+\t\t    total += e->count;\n+\n+\t\t  /* Seedgeh for the invalid edge, and set its count.  */\n+\t\t  for (e = bb->succ; e; e = e->succ_next)\n+\t\t    if (! EDGE_INFO (e)->count_valid && ! EDGE_INFO (e)->ignore)\n \t\t      break;\n-\t\t  if (! arcptr)\n+\n+\t\t  /* Calculate count for remaining edge by conservation.  */\n+\t\t  total = bb->count - total;\n+\n+\t\t  if (! e)\n \t\t    abort ();\n-\t\t  arcptr->count_valid = 1;\n-\t\t  ARC_COUNT (arcptr) = total;\n-\t\t  binfo->succ_count--;\n+\t\t  EDGE_INFO (e)->count_valid = 1;\n+\t\t  e->count = total;\n+\t\t  bi->succ_count--;\n \t\t  \n-\t\t  bb_graph[ARC_TARGET (arcptr)].pred_count--;\n+\t\t  BB_INFO (e->dest)->pred_count--;\n \t\t  changes = 1;\n \t\t}\n-\t      if (binfo->pred_count == 1)\n+\t      if (bi->pred_count == 1)\n \t\t{\n-\t\t  total = 0;\n+\t\t  edge e;\n+\t\t  int total = 0;\n+\n \t\t  /* One of the counts will be invalid, but it is zero,\n \t\t     so adding it in also doesn't hurt.  */\n-\t\t  for (arcptr = binfo->pred; arcptr;\n-\t\t       arcptr = arcptr->pred_next)\n-\t\t    total += ARC_COUNT (arcptr);\n-\t\t  /* Calculate count for remaining arc by conservation.  */\n-\t\t  total = binfo->exec_count - total;\n-\t\t  /* Search for the invalid arc, and set its count.  */\n-\t\t  for (arcptr = binfo->pred; arcptr;\n-\t\t       arcptr = arcptr->pred_next)\n-\t\t    if (! arcptr->count_valid)\n+\t\t  for (e = bb->pred; e; e = e->pred_next)\n+\t\t    total += e->count;\n+\n+\t\t  /* Seedgeh for the invalid edge, and set its count.  */\n+\t\t  for (e = bb->pred; e; e = e->pred_next)\n+\t\t    if (! EDGE_INFO (e)->count_valid && ! EDGE_INFO (e)->ignore)\n \t\t      break;\n-\t\t  if (! arcptr)\n+\n+\t\t  /* Calculate count for remaining edge by conservation.  */\n+\t\t  total = bb->count - total + e->count;\n+\n+\t\t  if (! e)\n \t\t    abort ();\n-\t\t  arcptr->count_valid = 1;\n-\t\t  ARC_COUNT (arcptr) = total;\n-\t\t  binfo->pred_count--;\n+\t\t  EDGE_INFO (e)->count_valid = 1;\n+\t\t  e->count = total;\n+\t\t  bi->pred_count--;\n \t\t  \n-\t\t  bb_graph[ARC_SOURCE (arcptr)].succ_count--;\n+\t\t  BB_INFO (e->src)->succ_count--;\n \t\t  changes = 1;\n \t\t}\n \t    }\n \t}\n     }\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n \n   total_num_passes += passes;\n-  if (dump_file)\n-    fprintf (dump_file, \"Graph solving took %d passes.\\n\\n\", passes);\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Graph solving took %d passes.\\n\\n\", passes);\n \n   /* If the graph has been correctly solved, every block will have a\n      succ and pred count of zero.  */\n-  for (i = 0; i < num_blocks; i++)\n+  for (i = 0; i < n_basic_blocks; i++)\n     {\n-      struct bb_info *binfo = &bb_graph[i];\n-      if (binfo->succ_count || binfo->pred_count)\n+      basic_block bb = BASIC_BLOCK (i);\n+      if (BB_INFO (bb)->succ_count || BB_INFO (bb)->pred_count)\n \tabort ();\n     }\n \n-  /* For every arc, calculate its branch probability and add a reg_note\n+  /* For every edge, calculate its branch probability and add a reg_note\n      to the branch insn to indicate this.  */\n \n   for (i = 0; i < 20; i++)\n     hist_br_prob[i] = 0;\n   num_never_executed = 0;\n   num_branches = 0;\n \n-  for (i = 0; i < num_blocks; i++)\n+  for (i = 0; i < n_basic_blocks; i++)\n     {\n-      struct bb_info *binfo = &bb_graph[i];\n-\n-      total = binfo->exec_count;\n-      for (arcptr = binfo->succ; arcptr; arcptr = arcptr->succ_next)\n+      basic_block bb = BASIC_BLOCK (i);\n+      edge e;\n+      rtx insn;\n+      int total;\n+      rtx note;\n+\n+      total = bb->count;\n+      if (!total)\n+\tcontinue;\n+      for (e = bb->succ; e; e = e->succ_next)\n \t{\n-\t  if (arcptr->branch_insn)\n+\t  if (any_condjump_p (e->src->end)\n+\t      && !EDGE_INFO (e)->ignore\n+\t      && !(e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_FAKE)))\n \t    {\n+\t      int prob;\n \t      /* This calculates the branch probability as an integer between\n \t\t 0 and REG_BR_PROB_BASE, properly rounded to the nearest\n \t\t integer.  Perform the arithmetic in double to avoid\n \t\t overflowing the range of ints.  */\n-\n \t      if (total == 0)\n \t\tprob = -1;\n \t      else\n \t\t{\n-\t\t  rtx pat = PATTERN (arcptr->branch_insn);\n-\t\t  \n-\t\t  prob = (((double)ARC_COUNT (arcptr) * REG_BR_PROB_BASE)\n+\t\t  prob = (((double)e->count * REG_BR_PROB_BASE)\n \t\t\t  + (total >> 1)) / total;\n \t\t  if (prob < 0 || prob > REG_BR_PROB_BASE)\n \t\t    {\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"bad count: prob for %d-%d thought to be %d (forcibly normalized)\\n\",\n-\t\t\t\t ARC_SOURCE (arcptr), ARC_TARGET (arcptr),\n-\t\t\t\t prob);\n+\t\t      if (rtl_dump_file)\n+\t\t\tfprintf (rtl_dump_file, \"bad count: prob for %d-%d thought to be %d (forcibly normalized)\\n\",\n+\t\t\t\t e->src->index, e->dest->index, prob);\n \n \t\t      bad_counts = 1;\n \t\t      prob = REG_BR_PROB_BASE / 2;\n \t\t    }\n \t\t  \n \t\t  /* Match up probability with JUMP pattern.  */\n-\n-\t\t  if (GET_CODE (pat) == SET\n-\t\t      && GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE)\n-\t\t    {\n-\t\t      if (ARC_TARGET (arcptr) == ARC_SOURCE (arcptr) + 1)\n-\t\t\t{\n-\t\t\t  /* A fall through arc should never have a\n-\t\t\t     branch insn.  */\n-\t\t\t  abort ();\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  /* This is the arc for the taken branch.  */\n-\t\t\t  if (GET_CODE (XEXP (SET_SRC (pat), 2)) != PC)\n-\t\t\t    prob = REG_BR_PROB_BASE - prob;\n-\t\t\t}\n-\t\t    }\n+\t\t  if (e->flags & EDGE_FALLTHRU)\n+\t\t    prob = REG_BR_PROB_BASE - prob;\n \t\t}\n \t      \n \t      if (prob == -1)\n@@ -674,755 +464,427 @@ compute_branch_probabilities (num_blocks, dump_file)\n \t\t}\n \t      num_branches++;\n \t      \n-\t      REG_NOTES (arcptr->branch_insn)\n-\t\t= gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n-\t\t\t\t     REG_NOTES (arcptr->branch_insn));\n+\t      note = find_reg_note (e->src->end, REG_BR_PROB, 0);\n+\t      /* There may be already note put by some other pass, such\n+\t         as builtin_expect expander.  */\n+\t      if (note)\n+\t\tXEXP (note, 0) = GEN_INT (prob);\n+\t      else\n+\t\tREG_NOTES (e->src->end)\n+\t\t  = gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n+\t\t\t\t       REG_NOTES (e->src->end));\n \t    }\n \t}\n \n       /* Add a REG_EXEC_COUNT note to the first instruction of this block.  */\n-      if (! binfo->first_insn \n-\t  || GET_RTX_CLASS (GET_CODE (binfo->first_insn)) != 'i')\n-\t{\n-\t  /* Block 0 is a fake block representing function entry, and does\n-\t     not have a real first insn.  The second last block might not\n-\t     begin with a real insn.  */\n-\t  if (i == num_blocks - 1)\n-\t    return_label_execution_count = total;\n-\t  else if (i != 0 && i != num_blocks - 2)\n-\t    abort ();\n-\t}\n-      else\n-\t{\n-\t  REG_NOTES (binfo->first_insn)\n-\t    = gen_rtx_EXPR_LIST (REG_EXEC_COUNT, GEN_INT (total),\n-\t\t\t\t REG_NOTES (binfo->first_insn));\n-\t  if (i == num_blocks - 1)\n-\t    return_label_execution_count = total;\n-\t}\n+      insn = next_nonnote_insn (bb->head);\n+\n+      if (GET_CODE (bb->head) == CODE_LABEL)\n+\tinsn = next_nonnote_insn (insn);\n+\n+      /* Avoid crash on empty basic blocks.  */\n+      if (insn && INSN_P (insn))\n+\tREG_NOTES (insn)\n+\t  = gen_rtx_EXPR_LIST (REG_EXEC_COUNT, GEN_INT (total),\n+\t\t\t       REG_NOTES (insn));\n     }\n   \n   /* This should never happen.  */\n   if (bad_counts)\n-    warning (\"Arc profiling: some arc counts were bad.\");\n+    warning (\"Arc profiling: some edge counts were bad.\");\n \n-  if (dump_file)\n+  if (rtl_dump_file)\n     {\n-      fprintf (dump_file, \"%d branches\\n\", num_branches);\n-      fprintf (dump_file, \"%d branches never executed\\n\",\n+      fprintf (rtl_dump_file, \"%d branches\\n\", num_branches);\n+      fprintf (rtl_dump_file, \"%d branches never executed\\n\",\n \t       num_never_executed);\n       if (num_branches)\n \tfor (i = 0; i < 10; i++)\n-\t  fprintf (dump_file, \"%d%% branches in range %d-%d%%\\n\",\n-\t\t   (hist_br_prob[i]+hist_br_prob[19-i])*100/num_branches,\n-\t\t   5*i, 5*i+5);\n+\t  fprintf (rtl_dump_file, \"%d%% branches in range %d-%d%%\\n\",\n+\t\t   (hist_br_prob[i] + hist_br_prob[19-i]) * 100 / num_branches,\n+\t\t   5 * i, 5 * i + 5);\n \n       total_num_branches += num_branches;\n       total_num_never_executed += num_never_executed;\n       for (i = 0; i < 20; i++)\n \ttotal_hist_br_prob[i] += hist_br_prob[i];\n+\n+      fputc ('\\n', rtl_dump_file);\n+      fputc ('\\n', rtl_dump_file);\n     }\n+\n+  free (bb_infos);\n }\n \n /* Instrument and/or analyze program behavior based on program flow graph.\n    In either case, this function builds a flow graph for the function being\n    compiled.  The flow graph is stored in BB_GRAPH.\n \n-   When FLAG_PROFILE_ARCS is nonzero, this function instruments the arcs in\n+   When FLAG_PROFILE_ARCS is nonzero, this function instruments the edges in\n    the flow graph that are needed to reconstruct the dynamic behavior of the\n    flow graph.\n \n    When FLAG_BRANCH_PROBABILITIES is nonzero, this function reads auxiliary\n-   information from a data file containing arc count information from previous\n+   information from a data file containing edge count information from previous\n    executions of the function being compiled.  In this case, the flow graph is\n    annotated with actual execution counts, which are later propagated into the\n    rtl for optimization purposes.\n \n    Main entry point of this file.  */\n \n void\n-branch_prob (f, dump_file)\n-     rtx f;\n-     FILE *dump_file;\n+branch_prob ()\n {\n-  int i, num_blocks;\n-  struct adj_list *arcptr;\n-  int num_arcs;\n+  int i;\n+  int num_edges;\n+  struct edge_info *edge_infos;\n+  struct edge_list *el;\n \n-  /* start of a function.  */\n+  /* Start of a function.  */\n   if (flag_test_coverage)\n     output_gcov_string (current_function_name, (long) -2);\n \n-  /* Execute this only if doing arc profiling or branch probabilities.  */\n-  if (! profile_arc_flag && ! flag_branch_probabilities\n-      && ! flag_test_coverage)\n-    abort ();\n-\n   total_num_times_called++;\n \n-  /* Create an array label_to_bb of ints of size max_label_num.  */\n-  label_to_bb_size = max_label_num ();\n-  label_to_bb = (int *) oballoc (label_to_bb_size * sizeof (int));\n-  bzero ((char *) label_to_bb, label_to_bb_size * sizeof (int));\n-\n-  /* Scan the insns in the function, count the number of basic blocks\n-     present.  When a code label is passed, set label_to_bb[label] = bb\n-     number.  */\n+  /* We can't handle cyclic regions constructed using abnormal edges.\n+     To avoid these we replace every source of abnormal edge by a fake\n+     edge from entry node and every destination by fake edge to exit.\n+     This keeps graph acyclic and our calculation exact for all normal\n+     edges except for exit and entrance ones.\n+   \n+     We also add fake exit edges for each call and asm statement in the\n+     basic, since it may not return.  */\n \n-  /* The first block found will be block 1, so that function entry can be\n-     block 0.  */\n-\n-  {\n-    register RTX_CODE prev_code = JUMP_INSN;\n-    register RTX_CODE code;\n-    register rtx insn;\n-    register int i;\n-    int block_separator_emitted = 0;\n-\n-    ignore_next_note = 0;\n-\n-    for (insn = NEXT_INSN (f), i = 0; insn; insn = NEXT_INSN (insn))\n-      {\n-\tcode = GET_CODE (insn);\n-\n-\tif (code == BARRIER)\n-\t  ;\n-\telse if (code == CODE_LABEL)\n-\t  /* This label is part of the next block, but we can't increment\n-\t     block number yet since there might be multiple labels.  */\n-\t  label_to_bb[CODE_LABEL_NUMBER (insn)] = i + 1;\n-\t/* We make NOTE_INSN_SETJMP notes into a block of their own, so that\n-\t   they can be the target of the fake arc for the setjmp call.\n-\t   This avoids creating cycles of fake arcs, which would happen if\n-\t   the block after the setjmp call contained a call insn.  */\n-\telse if ((prev_code == JUMP_INSN || prev_code == CALL_INSN\n-\t\t  || prev_code == CODE_LABEL || prev_code == BARRIER)\n-\t\t && (GET_RTX_CLASS (code) == 'i'\n-\t\t     || (code == NOTE\n-\t\t\t && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)))\n-\t  {\n-\t    i += 1;\n-\n-\t    /* Emit the block separator if it hasn't already been emitted.  */\n-\t    if (flag_test_coverage && ! block_separator_emitted)\n-\t      {\n-\t\t/* Output a zero to the .bb file to indicate that a new\n-\t\t   block list is starting.  */\n-\t\t__write_long (0, bb_file, 4);\n-\t      }\n-\t    block_separator_emitted = 0;\n-\t  }\n-\t/* If flag_test_coverage is true, then we must add an entry to the\n-\t   .bb file for every note.  */\n-\telse if (code == NOTE && flag_test_coverage)\n-\t  {\n-\t    /* Must ignore the line number notes that immediately follow the\n-\t       end of an inline function to avoid counting it twice.  There\n-\t       is a note before the call, and one after the call.  */\n-\t    if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_REPEATED_LINE_NUMBER)\n-\t      ignore_next_note = 1;\n-\t    else if (NOTE_LINE_NUMBER (insn) > 0)\n-\t      {\n-\t\tif (ignore_next_note)\n-\t\t  ignore_next_note = 0;\n-\t\telse\n-\t\t  {\n-\t\t    /* Emit a block separator here to ensure that a NOTE\n-\t\t       immediately following a JUMP_INSN or CALL_INSN will end\n-\t\t       up in the right basic block list.  */\n-\t\t    if ((prev_code == JUMP_INSN || prev_code == CALL_INSN\n-\t\t\t || prev_code == CODE_LABEL || prev_code == BARRIER)\n-\t\t\t&& ! block_separator_emitted)\n-\t\t      {\n-\t\t\t/* Output a zero to the .bb file to indicate that\n-\t\t\t   a new block list is starting.  */\n-\t\t\t__write_long (0, bb_file, 4);\n-\n-\t\t\tblock_separator_emitted = 1;\n-\t\t      }\n-\t\t    \n-\t\t    /* If this is a new source file, then output the file's\n-\t\t       name to the .bb file.  */\n-\t\t    if (! last_bb_file_name\n-\t\t\t|| strcmp (NOTE_SOURCE_FILE (insn),\n-\t\t\t\t   last_bb_file_name))\n-\t\t      {\n-\t\t\tif (last_bb_file_name)\n-\t\t\t  free (last_bb_file_name);\n-\t\t\tlast_bb_file_name = xstrdup (NOTE_SOURCE_FILE (insn));\n-\t\t\toutput_gcov_string (NOTE_SOURCE_FILE (insn), (long)-1);\n-\t\t      }\n-\n-\t\t    /* Output the line number to the .bb file.  Must be done\n-\t\t       after the output_bb_profile_data() call, and after the\n-\t\t       file name is written, to ensure that it is correctly\n-\t\t       handled by gcov.  */\n-\t\t    __write_long (NOTE_LINE_NUMBER (insn), bb_file, 4);\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\tif (code != NOTE)\n-\t  prev_code = code;\n-\telse if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n-\t  prev_code = CALL_INSN;\n-      }\n-\n-    /* Allocate last `normal' entry for bb_graph.  */\n-\n-    /* The last insn was a jump, call, or label.  In that case we have\n-       a block at the end of the function with no insns.  */\n-    if (prev_code == JUMP_INSN || prev_code == CALL_INSN\n-\t|| prev_code == CODE_LABEL || prev_code == BARRIER)\n-      {\n-\ti++;\n-\n-\t/* Emit the block separator if it hasn't already been emitted.  */\n-\tif (flag_test_coverage && ! block_separator_emitted)\n-\t  {\n-\t    /* Output a zero to the .bb file to indicate that a new\n-\t       block list is starting.  */\n-\t    __write_long (0, bb_file, 4);\n-\t  }\n-      }\n-\n-    /* Create another block to stand for EXIT, and make all return insns, and\n-       the last basic block point here.  Add one more to account for block\n-       zero.  */\n-    num_blocks = i + 2;\n-  }\n-\n-  total_num_blocks += num_blocks;\n-  if (dump_file)\n-    fprintf (dump_file, \"%d basic blocks\\n\", num_blocks);\n-\n-  /* If we are only doing test coverage here, then return now.  */\n-  if (! profile_arc_flag && ! flag_branch_probabilities)\n-    return;\n-\n-  /* Create and initialize the arrays that will hold bb_graph\n-     and execution count info.  */\n-\n-  bb_graph = (struct bb_info *) xcalloc (num_blocks, \n-\t\t\t\t\t sizeof (struct bb_info));\n+  for (i = 0; i < n_basic_blocks ; i++)\n+    {\n+      rtx insn;\n+      int need_exit_edge = 0, need_entry_edge = 0;\n+      int have_exit_edge = 0, have_entry_edge = 0;\n+      basic_block bb = BASIC_BLOCK (i);\n+      edge e;\n \n-  {\n-    /* Scan the insns again:\n-       - at the entry to each basic block, increment the predecessor count\n-       (and successor of previous block) if it is a fall through entry,\n-       create adj_list entries for this and the previous block\n-       - at each jump insn, increment predecessor/successor counts for\n-       target/source basic blocks, add this insn to pred/succ lists.\n-\n-       This also cannot be broken out as a separate subroutine\n-       because it uses `alloca'.  */\n-\n-    register RTX_CODE prev_code = JUMP_INSN;\n-    register RTX_CODE code;\n-    register rtx insn;\n-    register int i;\n-    int fall_through = 0;\n-    struct adj_list *arcptr;\n-    int dest = 0;\n-\n-    /* Block 0 always falls through to block 1.  */\n-    num_arcs = 0;\n-    arcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n-    init_arc (arcptr, 0, 1, 0);\n-    arcptr->fall_through = 1;\n-    num_arcs++;\n-\n-    /* Add a fake fall through arc from the last block to block 0, to make the\n-       graph complete.  */\n-    arcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n-    init_arc (arcptr, num_blocks - 1, 0, 0);\n-    arcptr->fake = 1;\n-    num_arcs++;\n-\n-    /* Exit must be one node of the graph, and all exits from the function\n-       must point there.  When see a return branch, must point the arc to the\n-       exit node.  */\n-\n-    /* Must start scan with second insn in function as above.  */\n-    for (insn = NEXT_INSN (f), i = 0; insn; insn = NEXT_INSN (insn))\n-      {\n-\tcode = GET_CODE (insn);\n-\n-\tif (code == BARRIER)\n-\t  fall_through = 0;\n-\telse if (code == CODE_LABEL)\n-\t  ;\n-\t/* We make NOTE_INSN_SETJMP notes into a block of their own, so that\n-\t   they can be the target of the fake arc for the setjmp call.\n-\t   This avoids creating cycles of fake arcs, which would happen if\n-\t   the block after the setjmp call ended with a call.  */\n-\telse if ((prev_code == JUMP_INSN || prev_code == CALL_INSN\n-\t\t  || prev_code == CODE_LABEL || prev_code == BARRIER)\n-\t\t && (GET_RTX_CLASS (code) == 'i'\n-\t\t     || (code == NOTE\n-\t\t\t && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)))\n-\t  {\n-\t    /* This is the first insn of the block.  */\n-\t    i += 1;\n-\t    if (fall_through)\n-\t      {\n-\t\tarcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n-\t\tinit_arc (arcptr, i - 1, i, 0);\n-\t\tarcptr->fall_through = 1;\n+      for (e = bb->succ; e; e = e->succ_next)\n+\t{\n+\t  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n+\t       && e->dest != EXIT_BLOCK_PTR)\n+\t    need_exit_edge = 1;\n+\t  if (e->dest == EXIT_BLOCK_PTR)\n+\t    have_exit_edge = 1;\n+\t}\n+      for (e = bb->pred; e; e = e->pred_next)\n+\t{\n+\t  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n+\t       && e->src != ENTRY_BLOCK_PTR)\n+\t    need_entry_edge = 1;\n+\t  if (e->src == ENTRY_BLOCK_PTR)\n+\t    have_entry_edge = 1;\n+\t}\n \n-\t\tnum_arcs++;\n-\t      }\n-\t    fall_through = 1;\n-\t    bb_graph[i].first_insn = insn;\n-\t  }\n-\telse if (code == NOTE)\n-\t  {;}\n+      /* ??? Not strictly needed unless flag_test_coverage, but adding\n+\t them anyway keeps the .da file consistent.  */\n+      /* ??? Currently inexact for basic blocks with multiple calls. \n+\t We need to split blocks here.  */\n+      for (insn = bb->head;\n+\t   insn != NEXT_INSN (bb->end);\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  rtx set;\n+\t  if (GET_CODE (insn) == CALL_INSN && !CONST_CALL_P (insn))\n+\t    need_exit_edge = 1;\n+\t  else if (GET_CODE (insn) == INSN)\n+\t    {\n+\t      set = PATTERN (insn);\n+\t      if (GET_CODE (set) == PARALLEL)\n+\t\tset = XVECEXP (set, 0, 0);\n+\t      if ((GET_CODE (set) == ASM_OPERANDS && MEM_VOLATILE_P (set))\n+\t\t  || GET_CODE (set) == ASM_INPUT)\n+\t\tneed_exit_edge = 1;\n+\t    }\n+\t}\n \n-\tif (code == CALL_INSN)\n-\t  {\n-\t    /* In the normal case, the call returns, and this is just like\n-\t       a branch fall through.  */\n-\t    fall_through = 1;\n-\n-\t    /* Setjmp may return more times than called, so to make the graph\n-\t       solvable, add a fake arc from the function entrance to the\n-\t       next block.\n-\n-\t       All other functions may return fewer times than called (if\n-\t       a descendent call longjmp or exit), so to make the graph\n-\t       solvable, add a fake arc to the function exit from the\n-\t       current block.\n-\n-\t       Distinguish the cases by checking for a SETJUMP note.\n-\t       A call_insn can be the last ins of a function, so must check\n-\t       to see if next insn actually exists.  */\n-\t    arcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n-\t    if (NEXT_INSN (insn)\n-\t\t&& GET_CODE (NEXT_INSN (insn)) == NOTE\n-\t\t&& NOTE_LINE_NUMBER (NEXT_INSN (insn)) == NOTE_INSN_SETJMP)\n-\t      init_arc (arcptr, 0, i+1, insn);\n-\t    else\n-\t      init_arc (arcptr, i, num_blocks-1, insn);\n-\t    arcptr->fake = 1;\n-\t    num_arcs++;\n-\t  }\n-\telse if (code == JUMP_INSN)\n-\t  {\n-\t    rtx tem, pattern = PATTERN (insn);\n-\t    rtx tablejump = 0;\n-\n-\t    /* If running without optimization, then jump label won't be valid,\n-\t       so we must search for the destination label in that case.\n-\t       We have to handle tablejumps and returns specially anyways, so\n-\t       we don't check the JUMP_LABEL at all here.  */\n-\n-\t    /* ??? This code should be rewritten.  We need a more elegant way\n-\t       to find the LABEL_REF.  We need a more elegant way to\n-\t       differentiate tablejump entries from computed gotos.\n-\t       We should perhaps reuse code from flow to compute the CFG\n-\t       instead of trying to compute it here.\n-\n-\t       We can't use current_function_has_computed_jump, because that\n-\t       is calculated later by flow.  We can't use computed_jump_p,\n-\t       because that returns true for tablejump entry insns for some\n-\t       targets, e.g. HPPA and MIPS.  */\n-\n-\t    if (GET_CODE (pattern) == PARALLEL)\n-\t      {\n-\t\t/* This assumes that PARALLEL jumps with a USE are\n-\t\t   tablejump entry jumps.  The same assumption can be found\n-\t\t   in computed_jump_p.  */\n-\t\t/* Make an arc from this jump to the label of the\n-\t\t   jump table.  This will instrument the number of\n-\t\t   times the switch statement is executed.  */\n-\t\tif (GET_CODE (XVECEXP (pattern, 0, 1)) == USE)\n-\t\t  {\n-\t\t    tem = XEXP (XVECEXP (pattern, 0, 1), 0);\n-\t\t    if (GET_CODE (tem) != LABEL_REF)\n-\t\t      abort ();\n-\t\t    dest = label_to_bb[CODE_LABEL_NUMBER (XEXP (tem, 0))];\n-\t\t  }\n-\t\telse if (GET_CODE (XVECEXP (pattern, 0, 0)) == SET\n-\t\t\t && SET_DEST (XVECEXP (pattern, 0, 0)) == pc_rtx)\n-\t\t  {\n-\t\t    tem = SET_SRC (XVECEXP (pattern, 0, 0));\n-\t\t    if (GET_CODE (tem) == PLUS\n-\t\t\t&& GET_CODE (XEXP (tem, 1)) == LABEL_REF)\n-\t\t      {\n-\t\t\ttem = XEXP (tem, 1);\n-\t\t\tdest = label_to_bb [CODE_LABEL_NUMBER (XEXP (tem, 0))];\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  abort ();\n-\t      }\n-\t    else if (GET_CODE (pattern) == ADDR_VEC\n-\t\t     || GET_CODE (pattern) == ADDR_DIFF_VEC)\n-\t      tablejump = pattern;\n-\t    else if (GET_CODE (pattern) == RETURN)\n-\t      dest = num_blocks - 1;\n-\t    else if (GET_CODE (pattern) != SET)\n-\t      abort ();\n-\t    else if ((tem = SET_SRC (pattern))\n-\t\t     && GET_CODE (tem) == LABEL_REF)\n-\t      dest = label_to_bb[CODE_LABEL_NUMBER (XEXP (tem, 0))];\n-\t    /* Recognize HPPA table jump entry.  This code is similar to\n-\t       the code above in the PARALLEL case.  */\n-\t    else if (GET_CODE (tem) == PLUS\n-\t\t     && GET_CODE (XEXP (tem, 0)) == MEM\n-\t\t     && GET_CODE (XEXP (XEXP (tem, 0), 0)) == PLUS\n-\t\t     && GET_CODE (XEXP (XEXP (XEXP (tem, 0), 0), 0)) == PC\n-\t\t     && GET_CODE (XEXP (tem, 1)) == LABEL_REF\n-\t\t     && tablejump_entry_p (insn, XEXP (tem, 1)))\n-\t      dest = label_to_bb[CODE_LABEL_NUMBER (XEXP (XEXP (tem, 1), 0))];\n-\t    /* Recognize the MIPS table jump entry.  */\n-\t    else if (GET_CODE (tem) == PLUS\n-\t\t     && GET_CODE (XEXP (tem, 0)) == REG\n-\t\t     && GET_CODE (XEXP (tem, 1)) == LABEL_REF\n-\t\t     && tablejump_entry_p (insn, XEXP (tem, 1)))\n-\t      dest = label_to_bb[CODE_LABEL_NUMBER (XEXP (XEXP (tem, 1), 0))];\n-\t    else\n-\t      {\n-\t\trtx label_ref;\n-\n-\t\t/* Must be an IF_THEN_ELSE branch.  If it isn't, assume it\n-\t\t   is a computed goto, which aren't supported yet.  */\n-\t\tif (GET_CODE (tem) != IF_THEN_ELSE)\n-\t\t  fatal (\"-fprofile-arcs does not support computed gotos\");\n-\t\tif (XEXP (tem, 1) != pc_rtx)\n-\t\t  label_ref = XEXP (tem, 1);\n-\t\telse\n-\t\t  label_ref = XEXP (tem, 2);\n-\t\tdest = label_to_bb[CODE_LABEL_NUMBER (XEXP (label_ref, 0))];\n-\t      }\n+      if (need_exit_edge && !have_exit_edge)\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"Adding fake exit edge to bb %i\\n\",\n+\t\t     bb->index);\n+          make_edge (NULL, bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n+\t}\n+      if (need_entry_edge && !have_entry_edge)\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"Adding fake entry edge to bb %i\\n\",\n+\t\t     bb->index);\n+          make_edge (NULL, ENTRY_BLOCK_PTR, bb, EDGE_FAKE);\n+\t}\n+    }\n \n-\t    if (tablejump)\n-\t      {\n-\t\tint diff_vec_p = GET_CODE (tablejump) == ADDR_DIFF_VEC;\n-\t\tint len = XVECLEN (tablejump, diff_vec_p);\n-\t\tint k;\n+  el = create_edge_list ();\n+  num_edges = NUM_EDGES (el);\n+  edge_infos = (struct edge_info *)\n+    xcalloc (num_edges, sizeof (struct edge_info));\n \n-\t\tfor (k = 0; k < len; k++)\n-\t\t  {\n-\t\t    rtx tem = XEXP (XVECEXP (tablejump, diff_vec_p, k), 0);\n-\t\t    dest = label_to_bb[CODE_LABEL_NUMBER (tem)];\n+  for (i = 0 ; i < num_edges ; i++)\n+    {\n+      edge e = INDEX_EDGE (el, i);\n+      e->count = 0;\n+      e->aux = &edge_infos[i];\n+\n+      /* Mark edges we've replaced by fake edges above as ignored.  */\n+      if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n+\t  && e->src != ENTRY_BLOCK_PTR && e->dest != EXIT_BLOCK_PTR)\n+\tEDGE_INFO (e)->ignore = 1;\n+    }\n \n-\t\t    arcptr = (struct adj_list *) alloca (sizeof(struct adj_list));\n-\t\t    init_arc (arcptr, i, dest, insn);\n+  total_num_blocks += n_basic_blocks + 2;\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"%d basic blocks\\n\", n_basic_blocks);\n \n-\t\t    num_arcs++;\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\tarcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n-\t\tinit_arc (arcptr, i, dest, insn);\n+  total_num_edges += num_edges;\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"%d edges\\n\", num_edges);\n \n-\t\tnum_arcs++;\n-\t      }\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n \n-\t    /* Determine whether or not this jump will fall through.\n-\t       Unconditional jumps and returns are not always followed by\n-\t       barriers.  */\n-\t    pattern = PATTERN (insn);\n-\t    if (GET_CODE (pattern) == PARALLEL\n-\t\t|| GET_CODE (pattern) == RETURN)\n-\t      fall_through = 0;\n-\t    else if (GET_CODE (pattern) == ADDR_VEC\n-\t\t     || GET_CODE (pattern) == ADDR_DIFF_VEC)\n-\t      /* These aren't actually jump insns, but they never fall\n-\t\t through, so...  */\n-\t      fall_through = 0;\n-\t    else\n-\t      {\n-\t\tif (GET_CODE (pattern) != SET || SET_DEST (pattern) != pc_rtx)\n-\t\t  abort ();\n-\t\tif (GET_CODE (SET_SRC (pattern)) != IF_THEN_ELSE)\n-\t\t  fall_through = 0;\n-\t      }\n-\t  }\n+  /* Output line number information about each basic block for\n+     GCOV utility.  */\n+  if (flag_test_coverage)\n+    {\n+      int i = 0;\n+      for (i = 0 ; i < n_basic_blocks; i++)\n+        {\n+\t  basic_block bb = BASIC_BLOCK (i);\n+\t  rtx insn = bb->head;\n+          static int ignore_next_note = 0;\n+\n+\t  /* We are looking for line number notes.  Search backward before\n+\t     basic block to find correct ones.  */\n+\t  insn = prev_nonnote_insn (insn);\n+\t  if (!insn)\n+\t    insn = get_insns ();\n+\t  else\n+\t    insn = NEXT_INSN (insn);\n \n-\tif (code != NOTE)\n-\t  prev_code = code;\n-\telse if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n-\t  {\n-\t    /* Make a fake insn to tag our notes on.  */\n-\t    bb_graph[i].first_insn = insn\n-\t      = emit_insn_after (gen_rtx_USE (VOIDmode, stack_pointer_rtx),\n-\t\t\t\t insn);\n-\t    prev_code = CALL_INSN;\n-\t  }\n-      }\n+\t  /* Output a zero to the .bb file to indicate that a new\n+\t     block list is starting.  */\n+\t  __write_long (0, bb_file, 4);\n \n-    /* If the code at the end of the function would give a new block, then\n-       do the following.  */\n+\t  while (insn != bb->end)\n+\t    {\n+\t      if (GET_CODE (insn) == NOTE)\n+\t\t{\n+\t\t  /* Must ignore the line number notes that immediately\n+\t\t     follow the end of an inline function to avoid counting\n+\t\t     it twice.  There is a note before the call, and one\n+\t\t     after the call.  */\n+\t\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_REPEATED_LINE_NUMBER)\n+\t\t    ignore_next_note = 1;\n+\t\t  else if (NOTE_LINE_NUMBER (insn) > 0)\n+\t\t    {\n+\t\t      if (ignore_next_note)\n+\t\t\tignore_next_note = 0;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* If this is a new source file, then output the\n+\t\t\t     file's name to the .bb file.  */\n+\t\t\t  if (! last_bb_file_name\n+\t\t\t      || strcmp (NOTE_SOURCE_FILE (insn),\n+\t\t\t\t\t last_bb_file_name))\n+\t\t\t    {\n+\t\t\t      if (last_bb_file_name)\n+\t\t\t\tfree (last_bb_file_name);\n+\t\t\t      last_bb_file_name\n+\t\t\t\t= xstrdup (NOTE_SOURCE_FILE (insn));\n+\t\t\t      output_gcov_string (NOTE_SOURCE_FILE (insn),\n+\t\t\t\t\t\t  (long)-1);\n+\t\t\t    }\n+\t\t\t  /* Output the line number to the .bb file.  Must be\n+\t\t\t     done after the output_bb_profile_data() call, and\n+\t\t\t     after the file name is written, to ensure that it\n+\t\t\t     is correctly handled by gcov.  */\n+\t\t\t  __write_long (NOTE_LINE_NUMBER (insn), bb_file, 4);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      insn = NEXT_INSN (insn);\n+\t    }\n+        }\n+      __write_long (0, bb_file, 4);\n+    }\n \n-    if (prev_code == JUMP_INSN || prev_code == CALL_INSN\n-\t|| prev_code == CODE_LABEL || prev_code == BARRIER)\n-      {\n-\tif (fall_through)\n-\t  {\n-\t    arcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n-\t    init_arc (arcptr, i, i + 1, 0);\n-\t    arcptr->fall_through = 1;\n+  /* Create spanning tree from basic block graph, mark each edge that is\n+     on the spanning tree.  We insert as many abnormal and critical edges\n+     as possible to minimize number of edge splits necesary. */\n \n-\t    num_arcs++;\n-\t  }\n-\t  \n-\t/* This may not be a real insn, but that should not cause a problem.  */\n-\tbb_graph[i+1].first_insn = get_last_insn ();\n-      }\n-\n-    /* There is always a fake arc from the last block of the function\n-       to the function exit block.  */\n-    arcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n-    init_arc (arcptr, num_blocks-2, num_blocks-1, 0);\n-    arcptr->fake = 1;\n-    num_arcs++;\n-  }\n-\n-  total_num_arcs += num_arcs;\n-  if (dump_file)\n-    fprintf (dump_file, \"%d arcs\\n\", num_arcs);\n-\n-  /* Create spanning tree from basic block graph, mark each arc that is\n-     on the spanning tree.  */\n-\n-  /* To reduce the instrumentation cost, make two passes over the tree.\n-     First, put as many must-split (crowded and fake) arcs on the tree as\n-     possible, then on the second pass fill in the rest of the tree.\n-     Note that the spanning tree is considered undirected, so that as many\n-     must-split arcs as possible can be put on it.\n-\n-     Fallthrough arcs which are crowded should not be chosen on the first\n-     pass, since they do not require creating a new basic block.  These\n-     arcs will have fall_through set.  */\n-\n-  find_spanning_tree (num_blocks);\n+  find_spanning_tree (el);\n \n   /* Create a .bbg file from which gcov can reconstruct the basic block\n      graph.  First output the number of basic blocks, and then for every\n-     arc output the source and target basic block numbers.\n+     edge output the source and target basic block numbers.\n      NOTE: The format of this file must be compatible with gcov.  */\n \n   if (flag_test_coverage)\n     {\n       int flag_bits;\n \n-      __write_long (num_blocks, bbg_file, 4);\n-      __write_long (num_arcs, bbg_file, 4);\n+      /* The plus 2 stands for entry and exit block.  */\n+      __write_long (n_basic_blocks + 2, bbg_file, 4);\n+      __write_long (num_edges + 1, bbg_file, 4);\n \n-      for (i = 0; i < num_blocks; i++)\n+      for (i = 0; i < n_basic_blocks + 1; i++)\n \t{\n+\t  basic_block bb = GCOV_INDEX_TO_BB (i);\n+\t  edge e;\n \t  long count = 0;\n-\t  for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n-\t    count++;\n+\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    if (!EDGE_INFO (e)->ignore)\n+\t      count++;\n \t  __write_long (count, bbg_file, 4);\n \n-\t  for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n+\t  for (e = bb->succ; e; e = e->succ_next)\n \t    {\n-\t      flag_bits = 0;\n-\t      if (arcptr->on_tree)\n-\t\tflag_bits |= 0x1;\n-\t      if (arcptr->fake)\n-\t\tflag_bits |= 0x2;\n-\t      if (arcptr->fall_through)\n-\t\tflag_bits |= 0x4;\n-\n-\t      __write_long (ARC_TARGET (arcptr), bbg_file, 4);\n-\t      __write_long (flag_bits, bbg_file, 4);\n+\t      struct edge_info *i = EDGE_INFO (e);\n+\t      if (!i->ignore)\n+\t\t{\n+\t\t  flag_bits = 0;\n+\t\t  if (i->on_tree)\n+\t\t    flag_bits |= 0x1;\n+\t\t  if (e->flags & EDGE_ABNORMAL)\n+\t\t    flag_bits |= 0x2;\n+\t\t  if (e->flags & EDGE_FALLTHRU)\n+\t\t    flag_bits |= 0x4;\n+\n+\t\t  __write_long (BB_TO_GCOV_INDEX (e->dest), bbg_file, 4);\n+\t\t  __write_long (flag_bits, bbg_file, 4);\n+\t        }\n \t    }\n \t}\n+      /* Emit fake loopback edge for EXIT block to maitain compatibility with\n+         old gcov format.  */\n+      __write_long (1, bbg_file, 4);\n+      __write_long (0, bbg_file, 4);\n+      __write_long (0x1, bbg_file, 4);\n \n-      /* Emit a -1 to separate the list of all arcs from the list of\n+      /* Emit a -1 to separate the list of all edges from the list of\n \t loop back edges that follows.  */\n       __write_long (-1, bbg_file, 4);\n     }\n \n-  /* For each arc not on the spanning tree, add counting code as rtl.  */\n+  if (flag_branch_probabilities)\n+    compute_branch_probabilities ();\n+\n+  /* For each edge not on the spanning tree, add counting code as rtl.  */\n \n   if (profile_arc_flag)\n     {\n-      instrument_arcs (f, num_blocks, dump_file);\n+      instrument_edges (el);\n       allocate_reg_info (max_reg_num (), FALSE, FALSE);\n     }\n \n-  /* Execute the rest only if doing branch probabilities.  */\n-  if (flag_branch_probabilities)\n-    compute_branch_probabilities (num_blocks, dump_file);\n-\n-  /* Clean up.  */\n-  free (bb_graph);\n+  remove_fake_edges ();\n+  free (edge_infos);\n+  free_edge_list (el);\n }\n \f\n-/* Initialize a new arc.\n-   ARCPTR is the empty adj_list this function fills in.\n-   SOURCE is the block number of the source block.\n-   TARGET is the block number of the target block.\n-   INSN is the insn which transfers control from SOURCE to TARGET,\n-   or zero if the transfer is implicit.  */\n+/* Union find algorithm implementation for the basic blocks using\n+   aux fields. */\n \n-static void\n-init_arc (arcptr, source, target, insn)\n-     struct adj_list *arcptr;\n-     int source, target;\n-     rtx insn;\n+static basic_block\n+find_group (bb)\n+     basic_block bb;\n {\n-  ARC_TARGET (arcptr) = target;\n-  ARC_SOURCE (arcptr) = source;\n-\n-  ARC_COUNT (arcptr) = 0;\n-  arcptr->count_valid = 0;\n-  arcptr->on_tree = 0;\n-  arcptr->fake = 0;\n-  arcptr->fall_through = 0;\n-  arcptr->branch_insn = insn;\n-\n-  arcptr->succ_next = bb_graph[source].succ;\n-  bb_graph[source].succ = arcptr;\n-  bb_graph[source].succ_count++;\n-\n-  arcptr->pred_next = bb_graph[target].pred;\n-  bb_graph[target].pred = arcptr;\n-  bb_graph[target].pred_count++;\n-}\n+  basic_block group = bb, bb1;\n \n-/* This function searches all of the arcs in the program flow graph, and puts\n-   as many bad arcs as possible onto the spanning tree.  Bad arcs include\n-   fake arcs (needed for setjmp(), longjmp(), exit()) which MUST be on the\n-   spanning tree as they can't be instrumented.  Also, arcs which must be\n-   split when instrumented should be part of the spanning tree if possible.  */\n+  while ((basic_block) group->aux != group)\n+    group = (basic_block) group->aux;\n \n-static void\n-find_spanning_tree (num_blocks)\n-     int num_blocks;\n-{\n-  int i;\n-  struct adj_list *arcptr;\n-  struct bb_info *binfo = &bb_graph[0];\n-\n-  /* Fake arcs must be part of the spanning tree, and are always safe to put\n-     on the spanning tree.  Fake arcs will either be a successor of node 0,\n-     a predecessor of the last node, or from the last node to node 0.  */\n-\n-  for (arcptr = bb_graph[0].succ; arcptr; arcptr = arcptr->succ_next)\n-    if (arcptr->fake)\n-      {\n-\t/* Adding this arc should never cause a cycle.  This is a fatal \n-\t   error if it would.  */\n-\tif (bb_graph[ARC_TARGET (arcptr)].on_tree && binfo->on_tree)\n-\t  abort();\n-\telse\n-\t  {\n-\t    arcptr->on_tree = 1;\n-\t    bb_graph[ARC_TARGET (arcptr)].on_tree = 1;\n-\t    binfo->on_tree = 1;\n-\t  }\n-      }\n-\n-  binfo = &bb_graph[num_blocks-1];\n-  for (arcptr = binfo->pred; arcptr; arcptr = arcptr->pred_next)\n-    if (arcptr->fake)\n-      {\n-\t/* Adding this arc should never cause a cycle.  This is a fatal \n-\t   error if it would.  */\n-\tif (bb_graph[ARC_SOURCE (arcptr)].on_tree && binfo->on_tree)\n-\t  abort();\n-\telse\n-\t  {\n-\t    arcptr->on_tree = 1;\n-\t    bb_graph[ARC_SOURCE (arcptr)].on_tree = 1;\n-\t    binfo->on_tree = 1;\n-\t  }\n-      }\n-  /* The only entrace to node zero is a fake arc.  */\n-  bb_graph[0].pred->on_tree = 1;\n-  \n-  /* Arcs which are crowded at both the source and target should be put on\n-     the spanning tree if possible, except for fall_throuch arcs which never\n-     require adding a new block even if crowded, add arcs with the same source\n-     and dest which must always be instrumented.  */\n-  for (i = 0; i < num_blocks; i++)\n+  /* Compress path.  */\n+  while ((basic_block) bb->aux != group)\n     {\n-      binfo = &bb_graph[i];\n-\n-      for (arcptr = binfo->succ; arcptr; arcptr = arcptr->succ_next)\n-\tif (! ((binfo->succ == arcptr && arcptr->succ_next == 0)\n-\t       || (bb_graph[ARC_TARGET (arcptr)].pred\n-\t\t   && arcptr->pred_next == 0))\n-\t    && ! arcptr->fall_through\n-\t    && ARC_TARGET (arcptr) != i)\n-\t  {\n-\t    /* This is a crowded arc at both source and target.  Try to put\n-\t       in on the spanning tree.  Can do this if either the source or\n-\t       target block is not yet on the tree.  */\n-\t    if (! bb_graph[ARC_TARGET (arcptr)].on_tree\t|| ! binfo->on_tree)\n-\t      {\n-\t\tarcptr->on_tree = 1;\n-\t\tbb_graph[ARC_TARGET (arcptr)].on_tree = 1;\n-\t\tbinfo->on_tree = 1;\n-\t      }\n-\t  }\n+      bb1 = (basic_block) bb->aux;\n+      bb->aux = (void *) group;\n+      bb = bb1;\n     }\n+  return group;\n+}\n \n-  /* Clear all of the basic block on_tree bits, so that we can use them to\n-     create the spanning tree.  */\n-  for (i = 0; i < num_blocks; i++)\n-    bb_graph[i].on_tree = 0;\n+static void\n+union_groups (bb1, bb2)\n+     basic_block bb1, bb2;\n+{\n+  basic_block bb1g = find_group (bb1);\n+  basic_block bb2g = find_group (bb2);\n \n-  /* Now fill in the spanning tree until every basic block is on it.\n-     Don't put the 0 to 1 fall through arc on the tree, since it is \n-     always cheap to instrument, so start filling the tree from node 1.  */\n+  /* ??? I don't have a place for the rank field.  OK.  Lets go w/o it,\n+     this code is unlikely going to be performance problem anyway.  */\n+  if (bb1g == bb2g)\n+    abort ();\n \n-  for (i = 1; i < num_blocks; i++)\n-    for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n-      if (! arcptr->on_tree\n-\t  && ! bb_graph[ARC_TARGET (arcptr)].on_tree)\n-\t{\n-\t  fill_spanning_tree (i);\n-\t  break;\n-\t}\n+  bb1g->aux = bb2g;\n }\n-\n-/* Add arcs reached from BLOCK to the spanning tree if they are needed and\n-   not already there.  */\n+\f\n+/* This function searches all of the edges in the program flow graph, and puts\n+   as many bad edges as possible onto the spanning tree.  Bad edges include\n+   abnormals edges, which can't be instrumented at the moment.  Since it is\n+   possible for fake edges to form an cycle, we will have to develop some\n+   better way in the future.  Also put critical edges to the tree, since they\n+   are more expensive to instrument.  */\n \n static void\n-fill_spanning_tree (block)\n-     int block;\n+find_spanning_tree (el)\n+     struct edge_list *el;\n {\n-  struct adj_list *arcptr;\n-  \n-  expand_spanning_tree (block);\n-\n-  for (arcptr = bb_graph[block].succ; arcptr; arcptr = arcptr->succ_next)\n-    if (! arcptr->on_tree\n-\t&& ! bb_graph[ARC_TARGET (arcptr)].on_tree)\n-      {\n-\tarcptr->on_tree = 1;\n-\tfill_spanning_tree (ARC_TARGET (arcptr));\n-      }\n-}\n+  int i;\n+  int num_edges = NUM_EDGES (el);\n \n-/* When first visit a block, must add all blocks that are already connected\n-   to this block via tree arcs to the spanning tree.  */\n+  /* We use aux field for standard union-find algorithm.  */\n+  EXIT_BLOCK_PTR->aux = EXIT_BLOCK_PTR;\n+  ENTRY_BLOCK_PTR->aux = ENTRY_BLOCK_PTR;\n+  for (i = 0; i < n_basic_blocks; i++)\n+    BASIC_BLOCK (i)->aux = BASIC_BLOCK (i);\n \n-static void\n-expand_spanning_tree (block)\n-     int block;\n-{\n-  struct adj_list *arcptr;\n-\n-  bb_graph[block].on_tree = 1;\n-\n-  for (arcptr = bb_graph[block].succ; arcptr; arcptr = arcptr->succ_next)\n-    if (arcptr->on_tree && ! bb_graph[ARC_TARGET (arcptr)].on_tree)\n-      expand_spanning_tree (ARC_TARGET (arcptr));\n-    \n-  for (arcptr = bb_graph[block].pred;\n-       arcptr; arcptr = arcptr->pred_next)\n-    if (arcptr->on_tree && ! bb_graph[ARC_SOURCE (arcptr)].on_tree)\n-      expand_spanning_tree (ARC_SOURCE (arcptr));\n+  /* Add fake edge exit to entry we can't instrument.  */\n+  union_groups (EXIT_BLOCK_PTR, ENTRY_BLOCK_PTR);\n+\n+  /* First add all abnormal edges to the tree unless they form an cycle.  */\n+  for (i = 0; i < num_edges; i++)\n+    {\n+      edge e = INDEX_EDGE (el, i);\n+      if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_FAKE))\n+\t  && !EDGE_INFO (e)->ignore\n+\t  && (find_group (e->src) != find_group (e->dest)))\n+\t{\n+\t  EDGE_INFO (e)->on_tree = 1;\n+\t  union_groups (e->src, e->dest);\n+\t}\n+    }\n+\n+  /* Now insert all critical edges to the tree unless they form an cycle.  */\n+  for (i = 0; i < num_edges; i++)\n+    {\n+      edge e = INDEX_EDGE (el, i);\n+      if ((e->flags & EDGE_CRITICAL)\n+\t  && !EDGE_INFO (e)->ignore\n+\t  && (find_group (e->src) != find_group (e->dest)))\n+\t{\n+\t  EDGE_INFO (e)->on_tree = 1;\n+\t  union_groups (e->src, e->dest);\n+\t}\n+    }\n+\n+  /* And now the rest.  */\n+  for (i = 0; i < num_edges; i++)\n+    {\n+      edge e = INDEX_EDGE (el, i);\n+      if (find_group (e->src) != find_group (e->dest)\n+\t  && !EDGE_INFO (e)->ignore)\n+\t{\n+\t  EDGE_INFO (e)->on_tree = 1;\n+\t  union_groups (e->src, e->dest);\n+\t}\n+    }\n }\n \f\n /* Perform file-level initialization for branch-prob processing.  */\n@@ -1436,17 +898,18 @@ init_branch_prob (filename)\n \n   if (flag_test_coverage)\n     {\n-      /* Open an output file for the basic block/line number map.  */\n       int len = strlen (filename);\n-      char *data_file = (char *) alloca (len + 4);\n+      char *data_file, *bbg_file_name;\n+\n+      /* Open an output file for the basic block/line number map.  */\n+      data_file = (char *) alloca (len + 4);\n       strcpy (data_file, filename);\n       strip_off_ending (data_file, len);\n       strcat (data_file, \".bb\");\n       if ((bb_file = fopen (data_file, \"wb\")) == 0)\n \tpfatal_with_name (data_file);\n \n       /* Open an output file for the program flow graph.  */\n-      len = strlen (filename);\n       bbg_file_name = (char *) alloca (len + 5);\n       strcpy (bbg_file_name, filename);\n       strip_off_ending (bbg_file_name, len);\n@@ -1461,6 +924,8 @@ init_branch_prob (filename)\n \n   if (flag_branch_probabilities)\n     {\n+      char *da_file_name;\n+\n       len = strlen (filename);\n       da_file_name = (char *) alloca (len + 4);\n       strcpy (da_file_name, filename);\n@@ -1470,19 +935,19 @@ init_branch_prob (filename)\n \twarning (\"file %s not found, execution counts assumed to be zero.\",\n \t\t da_file_name);\n \n-      /* The first word in the .da file gives the number of instrumented arcs,\n-\t which is not needed for our purposes.  */\n+      /* The first word in the .da file gives the number of instrumented\n+\t edges, which is not needed for our purposes.  */\n \n       if (da_file)\n \t__read_long (&len, da_file, 8);\n     }\n \n   if (profile_arc_flag)\n-    init_arc_profiler ();\n+    init_edge_profiler ();\n \n   total_num_blocks = 0;\n-  total_num_arcs = 0;\n-  total_num_arcs_instrumented = 0;\n+  total_num_edges = 0;\n+  total_num_edges_instrumented = 0;\n   total_num_blocks_created = 0;\n   total_num_passes = 0;\n   total_num_times_called = 0;\n@@ -1496,8 +961,7 @@ init_branch_prob (filename)\n    is completed.  */\n \n void\n-end_branch_prob (dump_file)\n-     FILE *dump_file;\n+end_branch_prob ()\n {\n   if (flag_test_coverage)\n     {\n@@ -1522,44 +986,46 @@ end_branch_prob (dump_file)\n \t}\n     }\n \n-  if (dump_file)\n+  if (rtl_dump_file)\n     {\n-      fprintf (dump_file, \"\\n\");\n-      fprintf (dump_file, \"Total number of blocks: %d\\n\", total_num_blocks);\n-      fprintf (dump_file, \"Total number of arcs: %d\\n\", total_num_arcs);\n-      fprintf (dump_file, \"Total number of instrumented arcs: %d\\n\",\n-\t       total_num_arcs_instrumented);\n-      fprintf (dump_file, \"Total number of blocks created: %d\\n\",\n+      fprintf (rtl_dump_file, \"\\n\");\n+      fprintf (rtl_dump_file, \"Total number of blocks: %d\\n\",\n+\t       total_num_blocks);\n+      fprintf (rtl_dump_file, \"Total number of edges: %d\\n\", total_num_edges);\n+      fprintf (rtl_dump_file, \"Total number of instrumented edges: %d\\n\",\n+\t       total_num_edges_instrumented);\n+      fprintf (rtl_dump_file, \"Total number of blocks created: %d\\n\",\n \t       total_num_blocks_created);\n-      fprintf (dump_file, \"Total number of graph solution passes: %d\\n\",\n+      fprintf (rtl_dump_file, \"Total number of graph solution passes: %d\\n\",\n \t       total_num_passes);\n       if (total_num_times_called != 0)\n-\tfprintf (dump_file, \"Average number of graph solution passes: %d\\n\",\n+\tfprintf (rtl_dump_file, \"Average number of graph solution passes: %d\\n\",\n \t\t (total_num_passes + (total_num_times_called  >> 1))\n \t\t / total_num_times_called);\n-      fprintf (dump_file, \"Total number of branches: %d\\n\", total_num_branches);\n-      fprintf (dump_file, \"Total number of branches never executed: %d\\n\",\n+      fprintf (rtl_dump_file, \"Total number of branches: %d\\n\",\n+\t       total_num_branches);\n+      fprintf (rtl_dump_file, \"Total number of branches never executed: %d\\n\",\n \t       total_num_never_executed);\n       if (total_num_branches)\n \t{\n \t  int i;\n \n \t  for (i = 0; i < 10; i++)\n-\t    fprintf (dump_file, \"%d%% branches in range %d-%d%%\\n\",\n+\t    fprintf (rtl_dump_file, \"%d%% branches in range %d-%d%%\\n\",\n \t\t     (total_hist_br_prob[i] + total_hist_br_prob[19-i]) * 100\n \t\t     / total_num_branches, 5*i, 5*i+5);\n \t}\n     }\n }\n \f\n-/* The label used by the arc profiling code.  */\n+/* The label used by the edge profiling code.  */\n \n static rtx profiler_label;\n \n /* Initialize the profiler_label.  */\n \n static void\n-init_arc_profiler ()\n+init_edge_profiler ()\n {\n   /* Generate and save a copy of this so it can be shared.  */\n   char *name = ggc_alloc_string (NULL, 20);\n@@ -1568,84 +1034,31 @@ init_arc_profiler ()\n   ggc_add_rtx_root (&profiler_label, 1);\n }\n \n-/* Output instructions as RTL to increment the arc execution count.  */\n+/* Output instructions as RTL to increment the edge execution count.  */\n \n-static void\n-output_arc_profiler (arcno, insert_after)\n-     int arcno;\n-     rtx insert_after;\n+static rtx\n+gen_edge_profiler (edgeno)\n+     int edgeno;\n {\n-  rtx profiler_target_addr\n-    = (arcno ? plus_constant (profiler_label,\n-\t\t\t      LONG_TYPE_SIZE / BITS_PER_UNIT * arcno)\n-       : profiler_label);\n   enum machine_mode mode = mode_for_size (LONG_TYPE_SIZE, MODE_INT, 0);\n-  rtx profiler_reg = gen_reg_rtx (mode);\n-  rtx address_reg = gen_reg_rtx (Pmode);\n-  rtx mem_ref, add_ref;\n+  rtx mem_ref, tmp;\n   rtx sequence;\n \n-  /* In this case, reload can use explicitly mentioned hard registers for\n-     reloads.  It is not safe to output profiling code between a call\n-     and the instruction that copies the result to a pseudo-reg.  This\n-     is because reload may allocate one of the profiling code pseudo-regs\n-     to the return value reg, thus clobbering the return value.  So we\n-     must check for calls here, and emit the profiling code after the\n-     instruction that uses the return value, if any.\n-\n-     ??? The code here performs the same tests that reload does so hopefully\n-     all the bases are covered.  */\n-\n-  if (SMALL_REGISTER_CLASSES\n-      && GET_CODE (insert_after) == CALL_INSN\n-      && (GET_CODE (PATTERN (insert_after)) == SET\n-\t  || (GET_CODE (PATTERN (insert_after)) == PARALLEL\n-\t      && GET_CODE (XVECEXP (PATTERN (insert_after), 0, 0)) == SET)))\n-    {\n-      rtx return_reg;\n-      rtx next_insert_after = next_nonnote_insn (insert_after);\n-\n-      /* The first insn after the call may be a stack pop, skip it.  */\n-      if (next_insert_after\n-\t  && GET_CODE (next_insert_after) == INSN\n-\t  && GET_CODE (PATTERN (next_insert_after)) == SET\n-\t  && SET_DEST (PATTERN (next_insert_after)) == stack_pointer_rtx)\n-\tnext_insert_after = next_nonnote_insn (next_insert_after);\n-\n-      if (next_insert_after\n-\t  && GET_CODE (next_insert_after) == INSN)\n-\t{\n-\t  if (GET_CODE (PATTERN (insert_after)) == SET)\n-\t    return_reg = SET_DEST (PATTERN (insert_after));\n-\t  else\n-\t    return_reg = SET_DEST (XVECEXP (PATTERN (insert_after), 0, 0));\n-\n-\t  /* Now, NEXT_INSERT_AFTER may be an instruction that uses the\n-\t     return value.  However, it could also be something else,\n-\t     like a CODE_LABEL, so check that the code is INSN.  */\n-\t  if (next_insert_after != 0\n-\t      && GET_RTX_CLASS (GET_CODE (next_insert_after)) == 'i'\n-\t      && reg_referenced_p (return_reg, PATTERN (next_insert_after)))\n-\t    insert_after = next_insert_after;\n-\t}\n-    }\n-\n   start_sequence ();\n \n-  emit_move_insn (address_reg, profiler_target_addr);\n-  mem_ref = gen_rtx_MEM (mode, address_reg);\n-  emit_move_insn (profiler_reg, mem_ref);\n+  tmp = force_reg (Pmode, profiler_label);\n+  tmp = plus_constant (tmp, LONG_TYPE_SIZE / BITS_PER_UNIT * edgeno);\n+  mem_ref = validize_mem (gen_rtx_MEM (mode, tmp));\n \n-  add_ref = gen_rtx_PLUS (mode, profiler_reg, GEN_INT (1));\n-  emit_move_insn (profiler_reg, add_ref);\n+  tmp = expand_binop (mode, add_optab, mem_ref, const1_rtx,\n+\t\t      mem_ref, 0, OPTAB_WIDEN);\n \n-  /* This is the same rtx as above, but it is not legal to share this rtx.  */\n-  mem_ref = gen_rtx_MEM (mode, address_reg);\n-  emit_move_insn (mem_ref, profiler_reg);\n+  if (tmp != mem_ref)\n+    emit_move_insn (copy_rtx (mem_ref), tmp);\n \n   sequence = gen_sequence ();\n   end_sequence ();\n-  emit_insn_after (sequence, insert_after);\n+  return sequence;\n }\n \n /* Output code for a constructor that will invoke __bb_init_func, if\n@@ -1659,9 +1072,12 @@ output_func_start_profiler ()\n   rtx table_address;\n   enum machine_mode mode = mode_for_size (LONG_TYPE_SIZE, MODE_INT, 0);\n   int save_flag_inline_functions = flag_inline_functions;\n+  int save_flag_test_coverage = flag_test_coverage;\n+  int save_profile_arc_flag = profile_arc_flag;\n+  int save_flag_branch_probabilities = flag_branch_probabilities;\n \n   /* It's either already been output, or we don't need it because we're\n-     not doing profile-arcs. */\n+     not doing profile-edges. */\n   if (! need_func_profiler)\n     return;\n \n@@ -1684,7 +1100,15 @@ output_func_start_profiler ()\n   fndecl = build_decl (FUNCTION_DECL, fnname,\n \t\t       build_function_type (void_type_node, NULL_TREE));\n   DECL_EXTERNAL (fndecl) = 0;\n+\n+#if defined(ASM_OUTPUT_CONSTRUCTOR) && defined(ASM_OUTPUT_DESTRUCTOR)\n+  /* It can be a static function as long as collect2 does not have\n+     to scan the object file to find its ctor/dtor routine.  */\n+  TREE_PUBLIC (fndecl) = 0;\n+#else\n   TREE_PUBLIC (fndecl) = 1;\n+#endif\n+\n   DECL_ASSEMBLER_NAME (fndecl) = fnname;\n   DECL_RESULT (fndecl) = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n \n@@ -1715,10 +1139,20 @@ output_func_start_profiler ()\n      flag_inline_functions.  */\n   flag_inline_functions = 0;\n \n+  /* Don't instrument the function that turns on instrumentation.  Which\n+     is also handy since we'd get silly warnings about not consuming all\n+     of our da_file input.  */\n+  flag_test_coverage = 0;\n+  profile_arc_flag = 0;\n+  flag_branch_probabilities = 0;\n+\n   rest_of_compilation (fndecl);\n \n   /* Reset flag_inline_functions to its original value.  */\n   flag_inline_functions = save_flag_inline_functions;\n+  flag_test_coverage = save_flag_test_coverage;\n+  profile_arc_flag = save_profile_arc_flag;\n+  flag_branch_probabilities = save_flag_branch_probabilities;\n \n   if (! quiet_flag)\n     fflush (asm_out_file);"}, {"sha": "853fd391d2a2c69021b6bee1b23ad97c22260132", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=51891abe62c625f17598bd4d64a71c6169693bb6", "patch": "@@ -1730,10 +1730,8 @@ extern void init_caller_save\t\tPARAMS ((void));\n \n /* In profile.c */\n extern void init_branch_prob\t\tPARAMS ((const char *));\n-#ifdef BUFSIZ\n-extern void branch_prob\t\t\tPARAMS ((rtx, FILE *));\n-extern void end_branch_prob\t\tPARAMS ((FILE *));\n-#endif\n+extern void branch_prob\t\t\tPARAMS ((void));\n+extern void end_branch_prob\t\tPARAMS ((void));\n extern void output_func_start_profiler\tPARAMS ((void));\n \n /* In reg-stack.c */"}, {"sha": "e70188901da5984b69d445abbeaa1cbb062b18d7", "filename": "gcc/toplev.c", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51891abe62c625f17598bd4d64a71c6169693bb6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=51891abe62c625f17598bd4d64a71c6169693bb6", "patch": "@@ -261,8 +261,9 @@ enum dump_file_index\n   DFI_gcse,\n   DFI_loop,\n   DFI_cse2,\n+  DFI_cfg,\n   DFI_bp,\n-  DFI_flow,\n+  DFI_life,\n   DFI_combine,\n   DFI_ce,\n   DFI_regmove,\n@@ -303,8 +304,9 @@ struct dump_file_info dump_file[DFI_MAX] =\n   { \"gcse\",\t'G', 1, 0, 0 },\n   { \"loop\",\t'L', 1, 0, 0 },\n   { \"cse2\",\t't', 1, 0, 0 },\n+  { \"cfg\",\t'f', 1, 0, 0 },\n   { \"bp\",\t'b', 1, 0, 0 },\n-  { \"flow\",\t'f', 1, 0, 0 },\n+  { \"life\",\t'f', 1, 0, 0 },\t/* Yes, duplicate enable switch.  */\n   { \"combine\",\t'c', 1, 0, 0 },\n   { \"ce\",\t'C', 1, 0, 0 },\n   { \"regmove\",\t'N', 1, 0, 0 },\n@@ -2372,11 +2374,13 @@ compile_file (name)\n \n   end_final (dump_base_name);\n    \n-  if (flag_test_coverage || flag_branch_probabilities)\n+  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n       timevar_push (TV_DUMP);\n       open_dump_file (DFI_bp, NULL);\n-      end_branch_prob (rtl_dump_file);\n+\n+      end_branch_prob ();\n+\n       close_dump_file (DFI_bp, NULL, NULL_RTX);\n       timevar_pop (TV_DUMP);\n     }\n@@ -3101,33 +3105,32 @@ rest_of_compilation (decl)\n \n   cse_not_expected = 1;\n \n-  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-    {\n-      timevar_push (TV_BRANCH_PROB);\n-      open_dump_file (DFI_bp, decl);\n-\n-      branch_prob (insns, rtl_dump_file);\n-\n-      close_dump_file (DFI_bp, print_rtl, insns);\n-      timevar_pop (TV_BRANCH_PROB);\n-\n-      if (ggc_p)\n-\tggc_collect ();\n-    }\n-\n   regclass_init ();\n \n-  /* Print function header into flow dump now\n-     because doing the flow analysis makes some of the dump.  */\n-\n-  open_dump_file (DFI_flow, decl);\n   \n   /* Do control and data flow analysis; wrote some of the results to\n      the dump file.  */\n \n   timevar_push (TV_FLOW);\n+  open_dump_file (DFI_cfg, decl);\n+\n   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n   cleanup_cfg (insns);\n+\n+  close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n+ \n+  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n+    {\n+      timevar_push (TV_BRANCH_PROB);\n+      open_dump_file (DFI_bp, decl);\n+\n+      branch_prob ();\n+\n+      close_dump_file (DFI_bp, print_rtl_with_bb, insns);\n+      timevar_pop (TV_BRANCH_PROB);\n+    }\n+\n+  open_dump_file (DFI_life, decl);\n   if (optimize)\n     {\n       struct loops loops;\n@@ -3137,8 +3140,7 @@ rest_of_compilation (decl)\n       flow_loops_find (&loops);\n \n       /* Estimate using heuristics if no profiling info is available.  */\n-      if (! flag_branch_probabilities)\n-\testimate_probability (&loops);\n+      estimate_probability (&loops);\n \n       if (rtl_dump_file)\n \tflow_loops_dump (&loops, rtl_dump_file, 0);\n@@ -3156,7 +3158,7 @@ rest_of_compilation (decl)\n \tsetjmp_args_warning ();\n     }\n \n-  close_dump_file (DFI_flow, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_life, print_rtl_with_bb, insns);\n \n   if (ggc_p)\n     ggc_collect ();"}]}