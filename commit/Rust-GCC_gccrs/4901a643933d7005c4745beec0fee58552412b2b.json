{"sha": "4901a643933d7005c4745beec0fee58552412b2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkwMWE2NDM5MzNkNzAwNWM0NzQ1YmVlYzBmZWU1ODU1MjQxMmIyYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-04-02T01:33:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-04-02T01:33:22Z"}, "message": "emit-rtl.c (gen_lowpart_common): Skip count by HARD_REGNO_NREGS.\n\n* emit-rtl.c (gen_lowpart_common): Skip count by HARD_REGNO_NREGS.\n(gen_highpart): Likewise.\n\nFrom-SVN: r18945", "tree": {"sha": "db879bb0cbd7705231be9699bf8bea0a63c36112", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db879bb0cbd7705231be9699bf8bea0a63c36112"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4901a643933d7005c4745beec0fee58552412b2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4901a643933d7005c4745beec0fee58552412b2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4901a643933d7005c4745beec0fee58552412b2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4901a643933d7005c4745beec0fee58552412b2b/comments", "author": null, "committer": null, "parents": [{"sha": "79363e2fa5721e0f2be637519bb7e40881fb98a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79363e2fa5721e0f2be637519bb7e40881fb98a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79363e2fa5721e0f2be637519bb7e40881fb98a1"}], "stats": {"total": 35, "additions": 24, "deletions": 11}, "files": [{"sha": "9eea255533b131969aa42b461041b77c2c099153", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4901a643933d7005c4745beec0fee58552412b2b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4901a643933d7005c4745beec0fee58552412b2b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4901a643933d7005c4745beec0fee58552412b2b", "patch": "@@ -3,6 +3,9 @@ Thu Apr  2 01:01:34 1998  Richard Henderson  <rth@cygnus.com>\n \t* configure (alpha-*-linuxecoff, alpha-*-linux-gnulibc1):\n \tRun fixincludes.\n \n+\t* emit-rtl.c (gen_lowpart_common): Skip count by HARD_REGNO_NREGS.\n+\t(gen_highpart): Likewise.\n+\t\n Wed Apr  1 22:26:22 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* fold-const.c optimze_bit_field_compare): Initialize rnbitpos,"}, {"sha": "fe99e8e6866261f977b423b87f319ba8b5c81ff7", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4901a643933d7005c4745beec0fee58552412b2b/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4901a643933d7005c4745beec0fee58552412b2b/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=4901a643933d7005c4745beec0fee58552412b2b", "patch": "@@ -652,6 +652,17 @@ gen_lowpart_common (mode, x)\n \t    : gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_WORD (x) + word));\n   else if (GET_CODE (x) == REG)\n     {\n+      /* Let the backend decide how many registers to skip.  This is needed\n+         in particular for Sparc64 where fp regs are smaller than a word.  */\n+      /* ??? Note that subregs are now ambiguous, in that those against\n+\t pseudos are sized by the Word Size, while those against hard\n+\t regs are sized by the underlying register size.  Better would be\n+\t to always interpret the subreg offset parameter as bytes or bits.  */\n+\n+      if (WORDS_BIG_ENDIAN && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\tword = (HARD_REGNO_NREGS (REGNO (x), GET_MODE (x))\n+\t\t- HARD_REGNO_NREGS (REGNO (x), mode));\n+\n       /* If the register is not valid for MODE, return 0.  If we don't\n \t do this, there is no way to fix up the resulting REG later.  \n \t But we do do this if the current REG is not valid for its\n@@ -1002,17 +1013,16 @@ gen_highpart (mode, x)\n     {\n       int word = 0;\n \n-      if (! WORDS_BIG_ENDIAN\n-\t  && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n-\tword = ((GET_MODE_SIZE (GET_MODE (x))\n-\t\t - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD))\n-\t\t/ UNITS_PER_WORD);\n-\n-      /*\n-       * ??? This fails miserably for complex values being passed in registers\n-       * where the sizeof the real and imaginary part are not equal to the\n-       * sizeof SImode.  FIXME\n-       */\n+      /* Let the backend decide how many registers to skip.  This is needed\n+         in particular for sparc64 where fp regs are smaller than a word.  */\n+      /* ??? Note that subregs are now ambiguous, in that those against\n+\t pseudos are sized by the Word Size, while those against hard\n+\t regs are sized by the underlying register size.  Better would be\n+\t to always interpret the subreg offset parameter as bytes or bits.  */\n+\n+      if (! WORDS_BIG_ENDIAN && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\tword = (HARD_REGNO_NREGS (REGNO (x), GET_MODE (x))\n+\t\t- HARD_REGNO_NREGS (REGNO (x), mode));\n \n       if (REGNO (x) < FIRST_PSEUDO_REGISTER\n \t  /* integrate.c can't handle parts of a return value register.  */"}]}