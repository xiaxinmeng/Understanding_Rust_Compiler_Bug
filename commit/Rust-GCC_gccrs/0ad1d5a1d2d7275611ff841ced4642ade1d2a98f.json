{"sha": "0ad1d5a1d2d7275611ff841ced4642ade1d2a98f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFkMWQ1YTFkMmQ3Mjc1NjExZmY4NDFjZWQ0NjQyYWRlMWQyYTk4Zg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-06-15T09:42:03Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-06-15T09:42:03Z"}, "message": "tree-ssa-loop-niter.c (implies_nonnegative_p): New function.\n\n\t* tree-ssa-loop-niter.c (implies_nonnegative_p): New function.\n\t(derive_constant_upper_bound): Derive more precise upper bound in\n\tcommon cases.  Return type changed to double_int.\n\t(record_estimate): Reflect the changed return type of\n\tderive_constant_upper_bound.\n\t* double-int.c (double_int_zext, double_int_sext): Fix.\n\n\t* gcc.dg/tree-ssa/loop-18.c: New test.\n\nFrom-SVN: r114674", "tree": {"sha": "85c42d4a341bc337e0b43abae07320d96c49e60f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85c42d4a341bc337e0b43abae07320d96c49e60f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f/comments", "author": null, "committer": null, "parents": [{"sha": "ec6c73926468e6de525d3be6810508990959c2b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6c73926468e6de525d3be6810508990959c2b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec6c73926468e6de525d3be6810508990959c2b8"}], "stats": {"total": 190, "additions": 172, "deletions": 18}, "files": [{"sha": "d4040849dfef899c50c71dd5ffb879bf64f06bc8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ad1d5a1d2d7275611ff841ced4642ade1d2a98f", "patch": "@@ -1,3 +1,12 @@\n+2006-06-15  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-niter.c (implies_nonnegative_p): New function.\n+\t(derive_constant_upper_bound): Derive more precise upper bound in\n+\tcommon cases.  Return type changed to double_int.\n+\t(record_estimate): Reflect the changed return type of\n+\tderive_constant_upper_bound.\n+\t* double-int.c (double_int_zext, double_int_sext): Fix.\n+\n 2006-06-15  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* configure.ac (CFLAGS): Get them from the toplevel or from the"}, {"sha": "5a7b51dbe318d7652ffe86be3a81c44ac669e3ed", "filename": "gcc/double-int.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=0ad1d5a1d2d7275611ff841ced4642ade1d2a98f", "patch": "@@ -72,8 +72,8 @@ double_int_zext (double_int cst, unsigned prec)\n   double_int mask = double_int_mask (prec);\n   double_int r;\n \n-  r.low = cst.low & ~mask.low;\n-  r.high = cst.high & ~mask.high;\n+  r.low = cst.low & mask.low;\n+  r.high = cst.high & mask.high;\n \n   return r;\n }\n@@ -96,13 +96,13 @@ double_int_sext (double_int cst, unsigned prec)\n     }\n   if (((snum >> (prec - 1)) & 1) == 1)\n     {\n-      r.low = cst.low | mask.low;\n-      r.high = cst.high | mask.high;\n+      r.low = cst.low | ~mask.low;\n+      r.high = cst.high | ~mask.high;\n     }\n   else\n     {\n-      r.low = cst.low & ~mask.low;\n-      r.high = cst.high & ~mask.high;\n+      r.low = cst.low & mask.low;\n+      r.high = cst.high & mask.high;\n     } \n \n   return r;"}, {"sha": "7f16d28684d61e1e9044ad99d9e635bba0e1dfee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ad1d5a1d2d7275611ff841ced4642ade1d2a98f", "patch": "@@ -1,3 +1,7 @@\n+2006-06-15  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-18.c: New test.\n+\n 2006-06-14  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/27665"}, {"sha": "ca75db941e57fab18590b0e4eefb1c9484df53c0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-18.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-18.c?ref=0ad1d5a1d2d7275611ff841ced4642ade1d2a98f", "patch": "@@ -0,0 +1,24 @@\n+/* A test for # of iterations estimation.  We know that I does not overflow,\n+   thus we can perform strength reduction (even though the 32-bit variable\n+   i is first extended to 64-bit type).  */\n+\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-do compile { target x86_64-*-* } } */\n+\n+unsigned bar(void);\n+\n+void foo(unsigned *p, unsigned n)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < n; i++)\n+    p[i] = bar ();\n+}\n+\n+/* Check that the memory reference was replaced with MEM, and that there is no\n+   multiplication.  */\n+\n+/* { dg-final { scan-tree-dump-times \"MEM\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\[^\\\\n\\\\r\\]*= \\\\* \" 0 \"optimized\" } } */\n+\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "e16065602bea2e430f30e5a44a74bde0a1259726", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 129, "deletions": 12, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ad1d5a1d2d7275611ff841ced4642ade1d2a98f/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=0ad1d5a1d2d7275611ff841ced4642ade1d2a98f", "patch": "@@ -1470,22 +1470,137 @@ find_loop_niter_by_eval (struct loop *loop, edge *exit)\n \n */\n \n-/* Returns a constant upper bound on the value of expression VAL.  The\n-   condition ADDITIONAL must be satisfied (for example, if VAL is\n+/* Returns true if we can prove that COND ==> VAL >= 0.  */\n+\n+static bool\n+implies_nonnegative_p (tree cond, tree val)\n+{\n+  tree type = TREE_TYPE (val);\n+  tree compare;\n+\n+  if (tree_expr_nonnegative_p (val))\n+    return true;\n+\n+  if (nonzero_p (cond))\n+    return false;\n+\n+  compare = fold_build2 (GE_EXPR,\n+\t\t\t boolean_type_node, val, build_int_cst (type, 0));\n+  compare = tree_simplify_using_condition_1 (cond, compare);\n+\n+  return nonzero_p (compare);\n+}\n+\n+/* Returns a constant upper bound on the value of expression VAL.  VAL\n+   is considered to be unsigned.  If its type is signed, its value must\n+   be nonnegative.\n+   \n+   The condition ADDITIONAL must be satisfied (for example, if VAL is\n    \"(unsigned) n\" and ADDITIONAL is \"n > 0\", then we can derive that\n-   VAL is at most (unsigned) MAX_INT).\n+   VAL is at most (unsigned) MAX_INT).  */\n  \n-   TODO -- actually do something nontrivial here.  */\n-\n-static tree\n-derive_constant_upper_bound (tree val, tree additional ATTRIBUTE_UNUSED)\n+static double_int\n+derive_constant_upper_bound (tree val, tree additional)\n {\n   tree type = TREE_TYPE (val);\n-  tree unsigned_type = unsigned_type_for (type);\n+  tree op0, op1, subtype, maxt;\n+  double_int bnd, max, mmax, cst;\n+\n+  if (INTEGRAL_TYPE_P (type))\n+    maxt = TYPE_MAX_VALUE (type);\n+  else\n+    maxt = upper_bound_in_type (type, type);\n+\n+  max = tree_to_double_int (maxt);\n+\n+  switch (TREE_CODE (val))\n+    {\n+    case INTEGER_CST:\n+      return tree_to_double_int (val);\n+\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+      op0 = TREE_OPERAND (val, 0);\n+      subtype = TREE_TYPE (op0);\n+      if (!TYPE_UNSIGNED (subtype)\n+\t  /* If TYPE is also signed, the fact that VAL is nonnegative implies\n+\t     that OP0 is nonnegative.  */\n+\t  && TYPE_UNSIGNED (type)\n+\t  && !implies_nonnegative_p (additional, op0))\n+\t{\n+\t  /* If we cannot prove that the casted expression is nonnegative,\n+\t     we cannot establish more useful upper bound than the precision\n+\t     of the type gives us.  */\n+\t  return max;\n+\t}\n \n-  if (TREE_CODE (val) != INTEGER_CST)\n-    val = upper_bound_in_type (type, type);\n-  return fold_convert (unsigned_type, val);\n+      /* We now know that op0 is an nonnegative value.  Try deriving an upper\n+\t bound for it.  */\n+      bnd = derive_constant_upper_bound (op0, additional);\n+\n+      /* If the bound does not fit in TYPE, max. value of TYPE could be\n+\t attained.  */\n+      if (double_int_ucmp (max, bnd) < 0)\n+\treturn max;\n+\n+      return bnd;\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      op0 = TREE_OPERAND (val, 0);\n+      op1 = TREE_OPERAND (val, 1);\n+\n+      if (TREE_CODE (op1) != INTEGER_CST\n+\t  || !implies_nonnegative_p (additional, op0))\n+\treturn max;\n+\n+      /* Canonicalize to OP0 - CST.  */\n+      cst = tree_to_double_int (op1);\n+      if (TREE_CODE (val) == PLUS_EXPR)\n+\tcst = double_int_neg (cst);\n+\n+      bnd = derive_constant_upper_bound (op0, additional);\n+\n+      if (double_int_negative_p (cst))\n+\t{\n+\t  cst = double_int_neg (cst);\n+\t  /* Avoid CST == 0x80000...  */\n+\t  if (double_int_negative_p (cst))\n+\t    return max;;\n+\n+\t  /* Case OP0 + CST.  We need to check that\n+\t     BND <= MAX (type) - CST.  */\n+\n+\t  mmax = double_int_add (max, double_int_neg (cst));\n+\t  if (double_int_ucmp (bnd, mmax) > 0)\n+\t    return max;\n+\n+\t  return double_int_add (bnd, cst);\n+\t}\n+      else\n+\t{\n+\t  if (double_int_ucmp (bnd, cst) < 0)\n+\t    return max;\n+\n+\t  bnd = double_int_add (bnd, double_int_neg (cst));\n+\t}\n+\n+      return bnd;\n+\n+    case FLOOR_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+      op0 = TREE_OPERAND (val, 0);\n+      op1 = TREE_OPERAND (val, 1);\n+      if (TREE_CODE (op1) != INTEGER_CST\n+\t  || tree_int_cst_sign_bit (op1))\n+\treturn max;\n+\n+      bnd = derive_constant_upper_bound (op0, additional);\n+      return double_int_udiv (bnd, tree_to_double_int (op1), FLOOR_DIV_EXPR);\n+\n+    default: \n+      return max;\n+    }\n }\n \n /* Records that AT_STMT is executed at most BOUND times in LOOP.  The\n@@ -1495,7 +1610,9 @@ void\n record_estimate (struct loop *loop, tree bound, tree additional, tree at_stmt)\n {\n   struct nb_iter_bound *elt = xmalloc (sizeof (struct nb_iter_bound));\n-  tree c_bound = derive_constant_upper_bound (bound, additional);\n+  double_int i_bound = derive_constant_upper_bound (bound, additional);\n+  tree c_bound = double_int_to_tree (unsigned_type_for (TREE_TYPE (bound)),\n+\t\t\t\t     i_bound);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {"}]}