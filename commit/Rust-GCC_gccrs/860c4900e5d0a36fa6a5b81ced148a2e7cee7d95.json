{"sha": "860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYwYzQ5MDBlNWQwYTM2ZmE2YTViODFjZWQxNDhhMmU3Y2VlN2Q5NQ==", "commit": {"author": {"name": "Bernardo Innocenti", "email": "bernie@develer.com", "date": "2003-09-09T06:47:19Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2003-09-09T06:47:19Z"}, "message": "coff.h (REGISTER_NAMES): Add fake register `argptr'\n\n\t* config/m68k/coff.h (REGISTER_NAMES): Add fake register `argptr'\n\t* config/m68k/hp320.h (REGISTER_NAMES): Likewise.\n\t* config/m68k/linux.h (REGISTER_NAMES): Likewise.\n\t* config/m68k/m68kelf.h (REGISTER_NAMES): Likewise.\n\t* gcc/config/m68k/sgs.h (REGISTER_NAMES): Likewise.\n\t* config/m68k/m68k-protos.h (m68k_initial_elimination_offset): Add prototype.\n\t* config/m68k/m68k.c (m68k_frame): New struct, simular to ix86 back-end.\n\t(m68k_compute_frame_layout): New function.\n\t(m68k_initial_elimination_offset): New function.\n\t(m68k_output_function_prologue): ColdFire-specific movem handling.\n\t(m68k_output_function_epilogue): Likewise.\n\t* config/m68k/m68k.h (FIRST_PSEOUDO_REGISTER): Make room for argptr reg.\n\t(ARG_POINTER_REGNUM): Add new definition.\n\t(INITIAL_FRAME_POINTER_OFFSET): Remove macro.\n\t(ELIMINABLE_REGS): Define new macro, like in ix86 back-end.\n\t(CAN_ELIMINATE): Likewise.\n\t(INITIAL_ELIMINATION_OFFSET): Likewise.\n\nCo-Authored-By: Peter Barada <peter@baradas.org>\n\nFrom-SVN: r71231", "tree": {"sha": "c5dc3a68e0f14ff0d7a84f28b088e5b5bc1af94f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5dc3a68e0f14ff0d7a84f28b088e5b5bc1af94f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/comments", "author": {"login": "codewiz", "id": 1184492, "node_id": "MDQ6VXNlcjExODQ0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1184492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/codewiz", "html_url": "https://github.com/codewiz", "followers_url": "https://api.github.com/users/codewiz/followers", "following_url": "https://api.github.com/users/codewiz/following{/other_user}", "gists_url": "https://api.github.com/users/codewiz/gists{/gist_id}", "starred_url": "https://api.github.com/users/codewiz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/codewiz/subscriptions", "organizations_url": "https://api.github.com/users/codewiz/orgs", "repos_url": "https://api.github.com/users/codewiz/repos", "events_url": "https://api.github.com/users/codewiz/events{/privacy}", "received_events_url": "https://api.github.com/users/codewiz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ed311a33ac239b2a754e1adbbde6479c6b148f20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed311a33ac239b2a754e1adbbde6479c6b148f20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed311a33ac239b2a754e1adbbde6479c6b148f20"}], "stats": {"total": 415, "additions": 302, "deletions": 113}, "files": [{"sha": "0a15e1d8c0c2795da0f873c21aded5cc516b12e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "patch": "@@ -1,3 +1,24 @@\n+2003-09-08  Bernardo Innocenti  <bernie@develer.com>\n+            Peter Barada <peter@baradas.org>\n+\n+\t* config/m68k/coff.h (REGISTER_NAMES): Add fake register `argptr'\n+\t* config/m68k/hp320.h (REGISTER_NAMES): Likewise.\n+\t* config/m68k/linux.h (REGISTER_NAMES): Likewise.\n+\t* config/m68k/m68kelf.h (REGISTER_NAMES): Likewise.\n+\t* gcc/config/m68k/sgs.h (REGISTER_NAMES): Likewise.\n+\t* config/m68k/m68k-protos.h (m68k_initial_elimination_offset): Add prototype.\n+\t* config/m68k/m68k.c (m68k_frame): New struct, simular to ix86 back-end.\n+\t(m68k_compute_frame_layout): New function.\n+\t(m68k_initial_elimination_offset): New function.\n+\t(m68k_output_function_prologue): ColdFire-specific movem handling.\n+\t(m68k_output_function_epilogue): Likewise.\n+\t* config/m68k/m68k.h (FIRST_PSEOUDO_REGISTER): Make room for argptr reg.\n+\t(ARG_POINTER_REGNUM): Add new definition.\n+\t(INITIAL_FRAME_POINTER_OFFSET): Remove macro.\n+\t(ELIMINABLE_REGS): Define new macro, like in ix86 back-end.\n+\t(CAN_ELIMINATE): Likewise.\n+\t(INITIAL_ELIMINATION_OFFSET): Likewise.\n+\n 2003-09-08  Bernardo Innocenti  <bernie@develer.com>\n \n \t* config/m68k/m68k.c (m68k_output_function_prologue): Simplify"}, {"sha": "21699a60c78be50a176fd8b28653e5e319b0fe7c", "filename": "gcc/config/m68k/coff.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fcoff.h?ref=860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "patch": "@@ -74,7 +74,7 @@ Boston, MA 02111-1307, USA.  */\n #define REGISTER_NAMES \\\n {\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",\t\\\n  \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%a6\", \"%sp\",\t\\\n- \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\" }\n+ \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\", \"argptr\" }\n \n #define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n "}, {"sha": "edfe3b9b17424048a2c90b61fcd53ec19afe0fac", "filename": "gcc/config/m68k/hp320.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fhp320.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fhp320.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp320.h?ref=860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "patch": "@@ -158,7 +158,7 @@ Boston, MA 02111-1307, USA.  */\n #define REGISTER_NAMES \\\n {\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",\t\\\n  \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%fp\", \"%sp\",\t\\\n- \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\"}\n+ \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\", \"argptr\"}\n \n #define IMMEDIATE_PREFIX        \"&\"\n #define REGISTER_PREFIX         \"%\""}, {"sha": "8178d5274599432cc1bac24abff7ae9e59cb0f37", "filename": "gcc/config/m68k/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux.h?ref=860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "patch": "@@ -68,7 +68,7 @@ Boston, MA 02111-1307, USA.  */\n #define REGISTER_NAMES \\\n {\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\", \\\n  \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%a6\", \"%sp\", \\\n- \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\" }\n+ \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\", \"argptr\" }\n \n #undef SIZE_TYPE\n #define SIZE_TYPE \"unsigned int\""}, {"sha": "955cbf576f0a65082707f104bc15d68a08734ed9", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "patch": "@@ -21,6 +21,7 @@ Boston, MA 02111-1307, USA.  */\n /* Define functions defined in aux-output.c and used in templates.  */\n \n #ifdef RTX_CODE\n+extern HOST_WIDE_INT m68k_initial_elimination_offset (int from, int to);\n extern const char *output_move_const_into_data_reg (rtx *);\n extern const char *output_move_simode_const (rtx *);\n extern const char *output_move_simode (rtx *);"}, {"sha": "1c3d8cc6a6e88cccdd0adc64414b6ccfd9270766", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 236, "deletions": 78, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "patch": "@@ -215,6 +215,84 @@ override_options (void)\n   real_format_for_mode[XFmode - QFmode] = &ieee_extended_motorola_format;\n }\n \f\n+/* Structure describing stack frame layout. */\n+struct m68k_frame {\n+  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT size;\n+  /* data and address register */\n+  int reg_no;\n+  unsigned int reg_mask;\n+  unsigned int reg_rev_mask;\n+  /* fpu registers */\n+  int fpu_no;\n+  unsigned int fpu_mask;\n+  unsigned int fpu_rev_mask;\n+  /* fpa registers */\n+  int fpa_no;\n+  /* offsets relative to ARG_POINTER.  */\n+  HOST_WIDE_INT frame_pointer_offset;\n+  HOST_WIDE_INT stack_pointer_offset;\n+};\n+\n+static void\n+m68k_compute_frame_layout (struct m68k_frame *frame)\n+{\n+  int regno, saved;\n+  unsigned int mask, rmask;\n+\n+  frame->size = (get_frame_size () + 3) & -4;\n+\n+  mask = rmask = saved = 0;\n+  for (regno = 0; regno < 16; regno++)\n+    if (m68k_save_reg (regno))\n+      {\n+\tmask |= 1 << regno;\n+\trmask |= 1 << (15 - regno);\n+\tsaved++;\n+      }\n+  frame->offset = saved * 4;\n+  frame->reg_no = saved;\n+  frame->reg_mask = mask;\n+  frame->reg_rev_mask = rmask;\n+\n+  if (TARGET_68881 /* || TARGET_CFV4E */)\n+    {\n+      mask = rmask = saved = 0;\n+      for (regno = 16; regno < 24; regno++)\n+\tif (regs_ever_live[regno] && ! call_used_regs[regno])\n+\t  {\n+\t    mask |= 1 << (23 - regno);\n+\t    rmask |= 1 << (regno - 16);\n+\t    saved++;\n+\t  }\n+      frame->offset += saved * 12 /* (TARGET_CFV4E ? 8 : 12) */;\n+      frame->fpu_no = saved;\n+      frame->fpu_mask = mask;\n+      frame->fpu_rev_mask = rmask;\n+    }\n+}\n+\n+HOST_WIDE_INT\n+m68k_initial_elimination_offset (int from, int to)\n+{\n+  struct m68k_frame frame;\n+\n+  /* FIXME: The correct offset to compute here would appear to be\n+       (frame_pointer_needed ? -UNITS_PER_WORD * 2 : -UNITS_PER_WORD);\n+     but for some obscure reason, this must be 0 to get correct code.  */\n+  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n+    return 0;\n+\n+  m68k_compute_frame_layout (&frame);\n+\n+  if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    return frame.offset + frame.size + (frame_pointer_needed ? -UNITS_PER_WORD * 2 : -UNITS_PER_WORD);\n+  else if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    return frame.offset + frame.size;\n+\n+  abort();\n+}\n+\n /* Return 1 if we need to save REGNO.  */\n static int\n m68k_save_reg (unsigned int regno)\n@@ -261,6 +339,7 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n   register int mask = 0;\n   int num_saved_regs = 0;\n   HOST_WIDE_INT fsize = (size + 3) & -4;\n+  HOST_WIDE_INT fsize_with_regs;\n   HOST_WIDE_INT cfa_offset = INCOMING_FRAME_SP_OFFSET;\n   \n   /* If the stack limit is a symbol, we can check it here,\n@@ -277,6 +356,21 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n #endif\n     }\n \n+  if (TARGET_COLDFIRE)\n+    {\n+      /* on Coldfire add register save into initial stack frame setup, if possible */\n+      for (regno = 0; regno < 16; regno++)\n+        if (m68k_save_reg (regno))\n+          num_saved_regs++;\n+\n+      if (num_saved_regs <= 2)\n+        num_saved_regs = 0;\n+    }\n+  else\n+      num_saved_regs = 0;\n+\n+  fsize_with_regs = fsize + num_saved_regs * 4;\n+  \n   if (frame_pointer_needed)\n     {\n       if (fsize == 0 && TARGET_68040)\n@@ -294,35 +388,35 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n \t\t   reg_names[FRAME_POINTER_REGNUM]);\n #endif\n \t}\n-      else if (fsize < 0x8000)\n+      else if (fsize_with_regs < 0x8000)\n \t{\n #ifdef MOTOROLA\n-\t  asm_fprintf (stream, \"\\tlink.w %s,%I%wd\\n\",\n-\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);\n+\t      asm_fprintf (stream, \"\\tlink.w %s,%I%wd\\n\",\n+\t\treg_names[FRAME_POINTER_REGNUM], -fsize_with_regs);\n #else\n-\t  asm_fprintf (stream, \"\\tlink %s,%I%wd\\n\",\n-\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);\n+\t      asm_fprintf (stream, \"\\tlink %s,%I%wd\\n\",\n+\t\treg_names[FRAME_POINTER_REGNUM], -fsize_with_regs);\n #endif\n \t}\n       else if (TARGET_68020)\n \t{\n #ifdef MOTOROLA\n \t  asm_fprintf (stream, \"\\tlink.l %s,%I%wd\\n\",\n-\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize_with_regs);\n #else\n \t  asm_fprintf (stream, \"\\tlink %s,%I%wd\\n\",\n-\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize_with_regs);\n #endif\n \t}\n       else\n \t{\n-      /* Adding negative number is faster on the 68040.  */\n+          /* Adding negative number is faster on the 68040.  */\n #ifdef MOTOROLA\n \t  asm_fprintf (stream, \"\\tlink.w %s,%I0\\n\\tadd.l %I%wd,%Rsp\\n\",\n-\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize_with_regs);\n #else\n \t  asm_fprintf (stream, \"\\tlink %s,%I0\\n\\taddl %I%wd,%Rsp\\n\",\n-\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize_with_regs);\n #endif\n \t}\n       if (dwarf2out_do_frame ())\n@@ -335,79 +429,81 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n \t  cfa_offset += fsize;\n \t}\n     }\n-  else if (fsize)\n+  else if (fsize_with_regs) /* !frame_pointer_needed */\n     {\n-      if (fsize + 4 < 0x8000)\n+      if (fsize_with_regs < 0x8000)\n \t{\n-\t  if (fsize + 4 <= 8)\n+\t  if (fsize_with_regs <= 8)\n \t    {\n \t      if (!TARGET_COLDFIRE)\n \t\t{\n \t\t  /* asm_fprintf() cannot handle %.  */\n #ifdef MOTOROLA\n-\t\t  asm_fprintf (stream, \"\\tsubq.w %I%wd,%Rsp\\n\", fsize + 4);\n+\t\t  asm_fprintf (stream, \"\\tsubq.w %I%wd,%Rsp\\n\", fsize_with_regs);\n #else\n-\t\t  asm_fprintf (stream, \"\\tsubqw %I%wd,%Rsp\\n\", fsize + 4);\n+\t\t  asm_fprintf (stream, \"\\tsubqw %I%wd,%Rsp\\n\", fsize_with_regs);\n #endif\n \t\t}\n \t      else\n \t\t{\n \t\t  /* asm_fprintf() cannot handle %.  */\n #ifdef MOTOROLA\n-\t\t  asm_fprintf (stream, \"\\tsubq.l %I%wd,%Rsp\\n\", fsize + 4);\n+\t\t  asm_fprintf (stream, \"\\tsubq.l %I%wd,%Rsp\\n\", fsize_with_regs);\n #else\n-\t\t  asm_fprintf (stream, \"\\tsubql %I%wd,%Rsp\\n\", fsize + 4);\n+\t\t  asm_fprintf (stream, \"\\tsubql %I%wd,%Rsp\\n\", fsize_with_regs);\n #endif\n \t\t}\n \t    }\n-\t  else if (fsize + 4 <= 16 && TARGET_CPU32)\n+\t  else if (fsize_with_regs <= 16 && TARGET_CPU32)\n \t    {\n \t      /* On the CPU32 it is faster to use two subqw instructions to\n \t\t subtract a small integer (8 < N <= 16) to a register.  */\n \t      /* asm_fprintf() cannot handle %.  */\n #ifdef MOTOROLA\n \t      asm_fprintf (stream,\n \t\t\t   \"\\tsubq.w %I8,%Rsp\\n\\tsubq.w %I%wd,%Rsp\\n\",\n-\t\t\t   fsize + 4 - 8);\n+\t\t\t   fsize_with_regs - 8);\n #else\n \t      asm_fprintf (stream, \"\\tsubqw %I8,%Rsp\\n\\tsubqw %I%wd,%Rsp\\n\",\n-\t\t\t   fsize + 4 - 8);\n+\t\t\t   fsize_with_regs - 8);\n #endif\n \t    }\n \t  else if (TARGET_68040)\n \t    {\n \t      /* Adding negative number is faster on the 68040.  */\n \t      /* asm_fprintf() cannot handle %.  */\n #ifdef MOTOROLA\n-\t      asm_fprintf (stream, \"\\tadd.w %I%wd,%Rsp\\n\", - (fsize + 4));\n+\t      asm_fprintf (stream, \"\\tadd.w %I%wd,%Rsp\\n\", -fsize_with_regs);\n #else\n-\t      asm_fprintf (stream, \"\\taddw %I%wd,%Rsp\\n\", - (fsize + 4));\n+\t      asm_fprintf (stream, \"\\taddw %I%wd,%Rsp\\n\", -fsize_with_regs);\n #endif\n \t    }\n \t  else\n \t    {\n #ifdef MOTOROLA\n-\t      asm_fprintf (stream, \"\\tlea (%wd,%Rsp),%Rsp\\n\", - (fsize + 4));\n+\t      asm_fprintf (stream, \"\\tlea (%wd,%Rsp),%Rsp\\n\", -fsize_with_regs);\n #else\n-\t      asm_fprintf (stream, \"\\tlea %Rsp@(%wd),%Rsp\\n\", - (fsize + 4));\n+\t      asm_fprintf (stream, \"\\tlea %Rsp@(%wd),%Rsp\\n\", -fsize_with_regs);\n #endif\n \t    }\n \t}\n-      else\n+      else /* fsize_with_regs >= 0x8000 */\n \t{\n-\t/* asm_fprintf() cannot handle %.  */\n #ifdef MOTOROLA\n-\t  asm_fprintf (stream, \"\\tadd.l %I%wd,%Rsp\\n\", - (fsize + 4));\n+\t  asm_fprintf (stream, \"\\tadd.l %I%wd,%Rsp\\n\", -fsize_with_regs);\n #else\n-\t  asm_fprintf (stream, \"\\taddl %I%wd,%Rsp\\n\", - (fsize + 4));\n+\t  asm_fprintf (stream, \"\\taddl %I%wd,%Rsp\\n\", -fsize_with_regs);\n #endif\n \t}\n       if (dwarf2out_do_frame ())\n \t{\n \t  cfa_offset += fsize + 4;\n \t  dwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM, cfa_offset);\n \t}\n-    }\n+    } /* !frame_pointer_needed */\n+\n+  num_saved_regs = 0;\n+\n   if (TARGET_68881)\n     {\n       for (regno = 16; regno < 24; regno++)\n@@ -505,10 +601,8 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n \t     then use the plain address register indirect mode.  We also\n \t     have to invert the register save mask to use the new mode.\n \n-\t     FIXME: if num_saved_regs was calculated earlier, we could\n-\t     combine the stack pointer adjustment with any adjustment\n-\t     done when the initial stack frame is created.  This would\n-\t     save an instruction */\n+\t     The required register save space was combined earlier with\n+\t     the fsize amount.  Don't add it again.  */\n \t     \n \t  int newmask = 0;\n \t  int i;\n@@ -518,10 +612,8 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n \t\tnewmask |= (1 << (15-i));\n \n #ifdef MOTOROLA\n-\t  asm_fprintf (stream, \"\\tlea (%d,%Rsp),%Rsp\\n\", -num_saved_regs*4);\n \t  asm_fprintf (stream, \"\\tmovm.l %I0x%x,(%Rsp)\\n\", newmask);\n #else\n-\t  asm_fprintf (stream, \"\\tlea %Rsp@(%d),%Rsp\\n\", -num_saved_regs*4);\n \t  asm_fprintf (stream, \"\\tmoveml %I0x%x,%Rsp@\\n\", newmask);\n #endif\n \t}\n@@ -595,6 +687,7 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n   register int nregs;\n   HOST_WIDE_INT offset, foffset;\n   HOST_WIDE_INT fsize = (size + 3) & -4;\n+  HOST_WIDE_INT fsize_with_regs;\n   int big = 0;\n   rtx insn = get_last_insn ();\n   int restore_from_sp = 0;\n@@ -637,18 +730,45 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n      stack adjustment needed at that point.  */\n   restore_from_sp = ! frame_pointer_needed\n \t     || (! current_function_calls_alloca && leaf_function_p ());\n+\n+  /* fsize_with_regs is the size we need to adjust the sp when\n+     popping the frame */\n+  fsize_with_regs = fsize;\n+\n+  /* Because the ColdFire doesn't support moveml with\n+     complex address modes, we must adjust the stack manually\n+     after restoring registers. When the frame pointer isn't used,\n+     we can merge movem adjustment into frame unlinking\n+     made immediately after it. */\n+  if (TARGET_COLDFIRE && restore_from_sp && (nregs > 2))\n+    fsize_with_regs += nregs * 4;\n+\n   if (offset + fsize >= 0x8000\n       && ! restore_from_sp\n       && (mask || fmask))\n     {\n+      /* Because the ColdFire doesn't support moveml with\n+         complex address modes we make an extra correction here */\n+      if (TARGET_COLDFIRE)\n+        {\n #ifdef MOTOROLA\n-      asm_fprintf (stream, \"\\t%Omove.l %I%wd,%Ra1\\n\", -fsize);\n+          asm_fprintf (stream, \"\\t%Omove.l %I%d,%Ra1\\n\", -fsize - offset);\n #else\n-      asm_fprintf (stream, \"\\tmovel %I%wd,%Ra1\\n\", -fsize);\n+          asm_fprintf (stream, \"\\tmovel %I%d,%Ra1\\n\", -fsize - offset);\n #endif\n+        }\n+      else\n+        {\n+#ifdef MOTOROLA\n+          asm_fprintf (stream, \"\\t%Omove.l %I%wd,%Ra1\\n\", -fsize);\n+#else\n+          asm_fprintf (stream, \"\\tmovel %I%wd,%Ra1\\n\", -fsize);\n+#endif\n+        }\n+\n       fsize = 0, big = 1;\n     }\n-  if (TARGET_COLDFIRE || nregs <= 2)\n+  if (nregs <= 2)\n     {\n       /* Restore each separately in the same order moveml does.\n          Using two movel instructions instead of a single moveml\n@@ -702,39 +822,77 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n     }\n   else if (mask)\n     {\n-      if (big)\n-\t{\n+      /* The ColdFire requires special handling due to its limited moveml insn */\n+      if (TARGET_COLDFIRE)\n+        {\n+          if (big)\n+            {\n #ifdef MOTOROLA\n-\t  asm_fprintf (stream, \"\\tmovm.l -%wd(%s,%Ra1.l),%I0x%x\\n\",\n-\t\t       offset + fsize,\n-\t\t       reg_names[FRAME_POINTER_REGNUM],\n-\t\t       mask);\n+              asm_fprintf (stream, \"\\tadd.l %s,%Ra1\\n\", reg_names[FRAME_POINTER_REGNUM]);\n+              asm_fprintf (stream, \"\\tmovm.l (%Ra1),%I0x%x\\n\", mask);\n #else\n-\t  asm_fprintf (stream, \"\\tmoveml %s@(-%wd,%Ra1:l),%I0x%x\\n\",\n-\t\t       reg_names[FRAME_POINTER_REGNUM],\n-\t\t       offset + fsize, mask);\n+              asm_fprintf (stream, \"\\taddl %s,%Ra1\\n\", reg_names[FRAME_POINTER_REGNUM]);\n+              asm_fprintf (stream, \"\\tmoveml %Ra1@,%I0x%x\\n\", mask);\n #endif\n-\t}\n-      else if (restore_from_sp)\n-\t{\n+\t     }\n+\t   else if (restore_from_sp)\n+\t     {\n #ifdef MOTOROLA\n-\t  asm_fprintf (stream, \"\\tmovm.l (%Rsp)+,%I0x%x\\n\", mask);\n+\t       asm_fprintf (stream, \"\\tmovm.l (%Rsp),%I0x%x\\n\", mask);\n #else\n-\t  asm_fprintf (stream, \"\\tmoveml %Rsp@+,%I0x%x\\n\", mask);\n+\t       asm_fprintf (stream, \"\\tmoveml %Rsp@,%I0x%x\\n\", mask);\n #endif\n-\t}\n-      else\n+            }\n+          else\n+            {\n+#ifdef MOTOROLA\n+              asm_fprintf (stream, \"\\tmovm.l -%wd(%s),%I0x%x\\n\",\n+                           offset + fsize,\n+                           reg_names[FRAME_POINTER_REGNUM],\n+                           mask);\n+#else\n+              asm_fprintf (stream, \"\\tmoveml %s@(-%wd),%I0x%x\\n\",\n+                           reg_names[FRAME_POINTER_REGNUM],\n+                           offset + fsize, mask);\n+#endif\n+\t    }\n+        }\n+      else /* !TARGET_COLDFIRE */\n \t{\n+\t  if (big)\n+\t    {\n #ifdef MOTOROLA\n-\t  asm_fprintf (stream, \"\\tmovm.l -%wd(%s),%I0x%x\\n\",\n-\t\t       offset + fsize,\n-\t\t       reg_names[FRAME_POINTER_REGNUM],\n-\t\t       mask);\n+\t      asm_fprintf (stream, \"\\tmovm.l -%wd(%s,%Ra1.l),%I0x%x\\n\",\n+\t\t\t   offset + fsize,\n+\t\t\t   reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t   mask);\n #else\n-\t  asm_fprintf (stream, \"\\tmoveml %s@(-%wd),%I0x%x\\n\",\n-\t\t       reg_names[FRAME_POINTER_REGNUM],\n-\t\t       offset + fsize, mask);\n+\t      asm_fprintf (stream, \"\\tmoveml %s@(-%wd,%Ra1:l),%I0x%x\\n\",\n+\t\t\t   reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t   offset + fsize, mask);\n #endif\n+\t    }\n+\t  else if (restore_from_sp)\n+\t    {\n+#ifdef MOTOROLA\n+\t      asm_fprintf (stream, \"\\tmovm.l (%Rsp)+,%I0x%x\\n\", mask);\n+#else\n+\t      asm_fprintf (stream, \"\\tmoveml %Rsp@+,%I0x%x\\n\", mask);\n+#endif\n+\t    }\n+\t  else\n+\t    {\n+#ifdef MOTOROLA\n+\t      asm_fprintf (stream, \"\\tmovm.l -%wd(%s),%I0x%x\\n\",\n+\t\t\t   offset + fsize,\n+\t\t\t   reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t   mask);\n+#else\n+\t      asm_fprintf (stream, \"\\tmoveml %s@(-%wd),%I0x%x\\n\",\n+\t\t\t   reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t   offset + fsize, mask);\n+#endif\n+\t    }\n \t}\n     }\n   if (fmask)\n@@ -777,67 +935,67 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n   if (frame_pointer_needed)\n     fprintf (stream, \"\\tunlk %s\\n\",\n \t     reg_names[FRAME_POINTER_REGNUM]);\n-  else if (fsize)\n+  else if (fsize_with_regs)\n     {\n-      if (fsize + 4 <= 8) \n+      if (fsize_with_regs <= 8)\n \t{\n \t  if (!TARGET_COLDFIRE)\n \t    {\n #ifdef MOTOROLA\n-\t      asm_fprintf (stream, \"\\taddq.w %I%wd,%Rsp\\n\", fsize + 4);\n+\t      asm_fprintf (stream, \"\\taddq.w %I%wd,%Rsp\\n\", fsize_with_regs);\n #else\n-\t      asm_fprintf (stream, \"\\taddqw %I%wd,%Rsp\\n\", fsize + 4);\n+\t      asm_fprintf (stream, \"\\taddqw %I%wd,%Rsp\\n\", fsize_with_regs);\n #endif\n \t    }\n-\t  else\n+\t  else /* TARGET_COLDFIRE */\n \t    {\n #ifdef MOTOROLA\n-\t      asm_fprintf (stream, \"\\taddq.l %I%wd,%Rsp\\n\", fsize + 4);\n+\t      asm_fprintf (stream, \"\\taddq.l %I%wd,%Rsp\\n\", fsize_with_regs);\n #else\n-\t      asm_fprintf (stream, \"\\taddql %I%wd,%Rsp\\n\", fsize + 4);\n+\t      asm_fprintf (stream, \"\\taddql %I%wd,%Rsp\\n\", fsize_with_regs);\n #endif\n \t    }\n \t}\n-      else if (fsize + 4 <= 16 && TARGET_CPU32)\n+      else if (fsize_with_regs <= 16 && TARGET_CPU32)\n \t{\n \t  /* On the CPU32 it is faster to use two addqw instructions to\n \t     add a small integer (8 < N <= 16) to a register.  */\n \t  /* asm_fprintf() cannot handle %.  */\n #ifdef MOTOROLA\n \t  asm_fprintf (stream, \"\\taddq.w %I8,%Rsp\\n\\taddq.w %I%wd,%Rsp\\n\",\n-\t\t       fsize + 4 - 8);\n+\t\t       fsize_with_regs - 8);\n #else\n \t  asm_fprintf (stream, \"\\taddqw %I8,%Rsp\\n\\taddqw %I%wd,%Rsp\\n\",\n-\t\t       fsize + 4 - 8);\n+\t\t       fsize_with_regs - 8);\n #endif\n \t}\n-      else if (fsize + 4 < 0x8000)\n+      else if (fsize_with_regs < 0x8000)\n \t{\n \t  if (TARGET_68040)\n \t    { \n \t      /* asm_fprintf() cannot handle %.  */\n #ifdef MOTOROLA\n-\t      asm_fprintf (stream, \"\\tadd.w %I%wd,%Rsp\\n\", fsize + 4);\n+\t      asm_fprintf (stream, \"\\tadd.w %I%wd,%Rsp\\n\", fsize_with_regs);\n #else\n-\t      asm_fprintf (stream, \"\\taddw %I%wd,%Rsp\\n\", fsize + 4);\n+\t      asm_fprintf (stream, \"\\taddw %I%wd,%Rsp\\n\", fsize_with_regs);\n #endif\n \t    }\n \t  else\n \t    {\n #ifdef MOTOROLA\n-\t      asm_fprintf (stream, \"\\tlea (%wd,%Rsp),%Rsp\\n\", fsize + 4);\n+\t      asm_fprintf (stream, \"\\tlea (%wd,%Rsp),%Rsp\\n\", fsize_with_regs);\n #else\n-\t      asm_fprintf (stream, \"\\tlea %Rsp@(%wd),%Rsp\\n\", fsize + 4);\n+\t      asm_fprintf (stream, \"\\tlea %Rsp@(%wd),%Rsp\\n\", fsize_with_regs);\n #endif\n \t    }\n \t}\n       else\n \t{\n \t/* asm_fprintf() cannot handle %.  */\n #ifdef MOTOROLA\n-\t  asm_fprintf (stream, \"\\tadd.l %I%wd,%Rsp\\n\", fsize + 4);\n+\t  asm_fprintf (stream, \"\\tadd.l %I%wd,%Rsp\\n\", fsize_with_regs);\n #else\n-\t  asm_fprintf (stream, \"\\taddl %I%wd,%Rsp\\n\", fsize + 4);\n+\t  asm_fprintf (stream, \"\\taddl %I%wd,%Rsp\\n\", fsize_with_regs);\n #endif\n \t}\n     }"}, {"sha": "b82dbc7718b3d84b6edc2e4db6801004aea66538", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "patch": "@@ -386,7 +386,7 @@ extern int target_flags;\n    For the 68000, we give the data registers numbers 0-7,\n    the address registers numbers 010-017,\n    and the 68881 floating point registers numbers 020-027.  */\n-#define FIRST_PSEUDO_REGISTER 24\n+#define FIRST_PSEUDO_REGISTER 25\n \n /* This defines the register which is used to hold the offset table for PIC.  */\n #define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 13 : INVALID_REGNUM)\n@@ -493,8 +493,11 @@ extern int target_flags;\n    This is computed in `reload', in reload1.c.  */\n #define FRAME_POINTER_REQUIRED 0\n \n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 14\n+/* Base register for access to arguments of the function.\n+ * This isn't a hardware register. It will be eliminated to the\n+ * stack pointer or frame pointer.\n+ */\n+#define ARG_POINTER_REGNUM 24\n \n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM 8\n@@ -879,32 +882,6 @@ enum reg_class {\n    You should override this if you define FUNCTION_EXTRA_EPILOGUE.  */\n #define USE_RETURN_INSN use_return_insn ()\n \n-/* Store in the variable DEPTH the initial difference between the\n-   frame pointer reg contents and the stack pointer reg contents,\n-   as of the start of the function body.  This depends on the layout\n-   of the fixed parts of the stack frame and on how registers are saved.\n-\n-   On the 68k, if we have a frame, we must add one word to its length\n-   to allow for the place that a6 is stored when we do have a frame pointer.\n-   Otherwise, we would need to compute the offset from the frame pointer\n-   of a local variable as a function of frame_pointer_needed, which\n-   is hard.  */\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\t\t\\\n-{ int regno;\t\t\t\t\t\t\t\\\n-  int offset = -4;\t\t\t\t\t\t\\\n-  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      offset += 12;\t\t\t\t\t\t\\\n-  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      offset += 4;\t\t\t\t\t\t\\\n-  if (flag_pic && current_function_uses_pic_offset_table)\t\\\n-    offset += 4;\t\t\t\t\t\t\\\n-  (DEPTH) = (offset + ((get_frame_size () + 3) & -4)\t\t\\\n-\t     + (get_frame_size () == 0 ? 0 : 4));\t\t\\\n-}\n-\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.  */\n \n@@ -982,6 +959,38 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n   asm (\"rts\":);\t\t\t\t\t\t\t\\\n }\n \f\n+/* Definitions for register eliminations.\n+\n+   This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.\n+\n+   There are two registers that can always be eliminated on the m68k.\n+   The frame pointer and the arg pointer can be replaced by either the\n+   hard frame pointer or to the stack pointer, depending upon the\n+   circumstances.  The hard frame pointer is not used before reload and\n+   so it is not eligible for elimination.  */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM },\t\t\\\n+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM },\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM }}\n+\n+/* Given FROM and TO register numbers, say whether this elimination is\n+   allowed.  Frame pointer elimination is automatically handled.\n+\n+   All other eliminations are valid.  */\n+\n+#define CAN_ELIMINATE(FROM, TO) \\\n+  ((TO) == STACK_POINTER_REGNUM ? ! frame_pointer_needed : 1)\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+  (OFFSET) = m68k_initial_elimination_offset(FROM, TO)\n+\f\n /* Addressing modes, and classification of registers for them.  */\n \n #define HAVE_POST_INCREMENT 1\n@@ -1381,7 +1390,7 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n #define REGISTER_NAMES \\\n {\"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\",\t\\\n  \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"sp\",\t\\\n- \"fp0\", \"fp1\", \"fp2\", \"fp3\", \"fp4\", \"fp5\", \"fp6\", \"fp7\" }\n+ \"fp0\", \"fp1\", \"fp2\", \"fp3\", \"fp4\", \"fp5\", \"fp6\", \"fp7\", \"argptr\" }\n \n /* How to renumber registers for dbx and gdb.\n    On the Sun-3, the floating point registers have numbers"}, {"sha": "585b24f11bb2f0752d9b34098c37cdaac8803254", "filename": "gcc/config/m68k/m68kelf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kelf.h?ref=860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "patch": "@@ -94,7 +94,7 @@ Boston, MA 02111-1307, USA.  */\n #define REGISTER_NAMES \\\n {\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t     \\\n  \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%a6\",   \"%sp\",\t     \\\n- \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\" }\n+ \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\", \"argptr\" }\n \n /* This is how to output an assembler line that says to advance the\n    location counter to a multiple of 2**LOG bytes.  */"}, {"sha": "1dc44c7735c0644a7c5bad6a7b2384b75d6859f2", "filename": "gcc/config/m68k/sgs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fsgs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860c4900e5d0a36fa6a5b81ced148a2e7cee7d95/gcc%2Fconfig%2Fm68k%2Fsgs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsgs.h?ref=860c4900e5d0a36fa6a5b81ced148a2e7cee7d95", "patch": "@@ -72,7 +72,7 @@ Boston, MA 02111-1307, USA.  */\n #define REGISTER_NAMES \\\n {\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t     \\\n  \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%fp\",   \"%sp\",\t     \\\n- \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\" }\n+ \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\", \"argptr\" }\n \n /* This is how to output an assembler line that says to advance the\n    location counter to a multiple of 2**LOG bytes.  */"}]}