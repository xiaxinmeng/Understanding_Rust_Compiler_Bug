{"sha": "e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgwOGVjOWM3MWU1MmFhNjRiZGI0NTc5YWQyZWY3NTgwMmI3YmNiNQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-02-27T07:24:53Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-02-27T07:24:53Z"}, "message": "cpplex.c (_cpp_lex_token): Handle directives in macro arguments.\n\n\t* cpplex.c (_cpp_lex_token): Handle directives in macro\n\targuments.\n\t* cpplib.c (_cpp_handle_directive): Save and restore state\n\tif parsing macro args when entering a directive.\n\t* cppmacro.c (collect_args): No need to handle directives\n\tin macro arguments.\n\t(enter_macro_context, replace_args): Use the original macro\n\tdefinition in case it was redefined whilst collecting arguments.\ndoc:\n\t* cpp.texi: Update.\ntestsuite:\n\t* gcc.dg/cpp/undef1.c: Remove.\n\t* gcc.dg/cpp/directiv.c: Update.\n\t* gcc.dg/cpp/mac-dir-1.c, mac-dir-2.c: New tests.\n\nFrom-SVN: r50091", "tree": {"sha": "7ffd19f1f5d3104b1545c9af4c64c746cda65cbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ffd19f1f5d3104b1545c9af4c64c746cda65cbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/comments", "author": null, "committer": null, "parents": [{"sha": "f585a35687df424814b57fd201253c11a19795f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f585a35687df424814b57fd201253c11a19795f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f585a35687df424814b57fd201253c11a19795f5"}], "stats": {"total": 192, "additions": 143, "deletions": 49}, "files": [{"sha": "ee24ef77f204f0d60451f93162d0ed44ffc7c7a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "patch": "@@ -1,3 +1,16 @@\n+2002-02-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpplex.c (_cpp_lex_token): Handle directives in macro\n+\targuments.\n+\t* cpplib.c (_cpp_handle_directive): Save and restore state\n+\tif parsing macro args when entering a directive.\n+\t* cppmacro.c (collect_args): No need to handle directives\n+\tin macro arguments.\n+\t(enter_macro_context, replace_args): Use the original macro\n+\tdefinition in case it was redefined whilst collecting arguments.\n+doc:\n+\t* cpp.texi: Update.\n+\n 2002-02-26  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/aix43.h (THREAD_MODEL_SPEC): Delete."}, {"sha": "a5a20db73d10c829b68ee673bbdd16df026fe6a4", "filename": "gcc/cpplex.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "patch": "@@ -828,7 +828,10 @@ _cpp_lex_token (pfile)\n \t  /* Is this a directive.  If _cpp_handle_directive returns\n \t     false, it is an assembler #.  */\n \t  if (result->type == CPP_HASH\n-\t      && !pfile->state.parsing_args\n+\t      /* 6.10.3 p 11: Directives in a list of macro arguments\n+\t\t gives undefined behavior.  This implementation\n+\t\t handles the directive as normal.  */\n+\t      && pfile->state.parsing_args != 1\n \t      && _cpp_handle_directive (pfile, result->flags & PREV_WHITE))\n \t    continue;\n \t  if (pfile->cb.line_change && !pfile->state.skipping)"}, {"sha": "d9f95bd216d196decc374781570a3ce0ac88541d", "filename": "gcc/cpplib.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "patch": "@@ -316,8 +316,17 @@ _cpp_handle_directive (pfile, indented)\n {\n   const directive *dir = 0;\n   const cpp_token *dname;\n+  bool was_parsing_args = pfile->state.parsing_args;\n   int skip = 1;\n \n+  if (was_parsing_args)\n+    {\n+      if (CPP_OPTION (pfile, pedantic))\n+\tcpp_pedwarn (pfile,\n+\t     \"embedding a directive within macro arguments is not portable\");\n+      pfile->state.parsing_args = 0;\n+      pfile->state.prevent_expansion = 0;\n+    }\n   start_directive (pfile);\n   dname = _cpp_lex_token (pfile);\n \n@@ -393,6 +402,13 @@ _cpp_handle_directive (pfile, indented)\n     _cpp_backup_tokens (pfile, 1);\n \n   end_directive (pfile, skip);\n+  if (was_parsing_args)\n+    {\n+      /* Restore state when within macro args.  */\n+      pfile->state.parsing_args = 2;\n+      pfile->state.prevent_expansion = 1;\n+      pfile->buffer->saved_flags |= PREV_WHITE;\n+    }\n   return skip;\n }\n "}, {"sha": "d44ac498658d2c7848f067ea92a59e7a5458c59a", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "patch": "@@ -74,7 +74,8 @@ static const cpp_token *stringify_arg PARAMS ((cpp_reader *, macro_arg *));\n static void paste_all_tokens PARAMS ((cpp_reader *, const cpp_token *));\n static bool paste_tokens PARAMS ((cpp_reader *, const cpp_token **,\n \t\t\t\t  const cpp_token *));\n-static void replace_args PARAMS ((cpp_reader *, cpp_hashnode *, macro_arg *));\n+static void replace_args PARAMS ((cpp_reader *, cpp_hashnode *, cpp_macro *,\n+\t\t\t\t  macro_arg *));\n static _cpp_buff *funlike_invocation_p PARAMS ((cpp_reader *, cpp_hashnode *));\n \n /* #define directive parsing and handling.  */\n@@ -546,34 +547,15 @@ collect_args (pfile, node)\n \t    arg++;\n \t}\n     }\n-  while (token->type != CPP_CLOSE_PAREN\n-\t && token->type != CPP_EOF\n-\t && token->type != CPP_HASH);\n+  while (token->type != CPP_CLOSE_PAREN && token->type != CPP_EOF);\n \n-  if (token->type == CPP_EOF || token->type == CPP_HASH)\n+  if (token->type == CPP_EOF)\n     {\n-      bool step_back = false;\n-\n-      /* 6.10.3 paragraph 11: If there are sequences of preprocessing\n-\t tokens within the list of arguments that would otherwise act\n-\t as preprocessing directives, the behavior is undefined.\n-\n-\t This implementation will report a hard error, terminate the\n-\t macro invocation, and proceed to process the directive.  */\n-      if (token->type == CPP_HASH)\n-\t{\n-\t  cpp_error (pfile,\n-\t\t     \"directives may not be used inside a macro argument\");\n-\t  step_back = true;\n-\t}\n-      else\n-\tstep_back = (pfile->context->prev || pfile->state.in_directive);\n-\n       /* We still need the CPP_EOF to end directives, and to end\n \t pre-expansion of a macro argument.  Step back is not\n \t unconditional, since we don't want to return a CPP_EOF to our\n \t callers at the end of an -include-d file.  */\n-      if (step_back)\n+      if (pfile->context->prev || pfile->state.in_directive)\n \t_cpp_backup_tokens (pfile, 1);\n       cpp_error (pfile, \"unterminated argument list invoking macro \\\"%s\\\"\",\n \t\t NODE_NAME (node));\n@@ -697,8 +679,8 @@ enter_macro_context (pfile, node)\n \t      return 0;\n \t    }\n \n-\t  if (node->value.macro->paramc > 0)\n-\t    replace_args (pfile, node, (macro_arg *) buff->base);\n+\t  if (macro->paramc > 0)\n+\t    replace_args (pfile, node, macro, (macro_arg *) buff->base);\n \t  _cpp_release_buff (pfile, buff);\n \t}\n \n@@ -720,23 +702,22 @@ enter_macro_context (pfile, node)\n    Expand each argument before replacing, unless it is operated upon\n    by the # or ## operators.  */\n static void\n-replace_args (pfile, node, args)\n+replace_args (pfile, node, macro, args)\n      cpp_reader *pfile;\n      cpp_hashnode *node;\n+     cpp_macro *macro;\n      macro_arg *args;\n {\n   unsigned int i, total;\n   const cpp_token *src, *limit;\n   const cpp_token **dest, **first;\n   macro_arg *arg;\n   _cpp_buff *buff;\n-  cpp_macro *macro;\n \n   /* First, fully macro-expand arguments, calculating the number of\n      tokens in the final expansion as we go.  The ordering of the if\n      statements below is subtle; we must handle stringification before\n      pasting.  */\n-  macro = node->value.macro;\n   total = macro->count;\n   limit = macro->expansion + macro->count;\n "}, {"sha": "9e28e92e8005689d845dc466d0f3a96781495670", "filename": "gcc/doc/cpp.texi", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Fdoc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Fdoc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcpp.texi?ref=e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "patch": "@@ -121,6 +121,7 @@ Macros\n * Variadic Macros::\n * Predefined Macros::\n * Undefining and Redefining Macros::\n+* Directives Within Macro Arguments::\n * Macro Pitfalls::\n \n Predefined Macros\n@@ -1115,6 +1116,7 @@ macros when you are compiling C++.\n * Variadic Macros::\n * Predefined Macros::\n * Undefining and Redefining Macros::\n+* Directives Within Macro Arguments::\n * Macro Pitfalls::\n @end menu\n \n@@ -2116,6 +2118,48 @@ the same, the redefinition is silently ignored.  This allows, for\n instance, two different headers to define a common macro.  The\n preprocessor will only complain if the definitions do not match.\n \n+@node Directives Within Macro Arguments\n+@section Directives Within Macro Arguments\n+@cindex macro arguments and directives\n+\n+Occasionally it is convenient to use preprocessor directives within\n+the arguments of a macro.  The C and C++ standards declare that\n+behavior in these cases is undefined.\n+\n+Versions of GNU CPP prior to 3.2 would reject such constructs with an\n+error message.  This was the only syntactic difference between normal\n+functions and function-like macros, so it seemed attractive to remove\n+this limitation, and people would often be surprised that they could\n+not use macros in this way.  Moreover, sometimes people would use\n+conditional compilation in the argument list to a normal library\n+function like @samp{printf}, only to find that after a library upgrade\n+@samp{printf} had changed to be a function-like macro, and their code\n+would no longer compile.  So from version 3.2 we changed CPP to\n+successfully process arbitrary directives within macro arguments in\n+exactly the same way as it would have processed the directive were the\n+function-like macro invocation not present.\n+\n+If, within a macro invocation, that macro is redefined, then the new\n+definition takes effect in time for argument pre-expansion, but the\n+original definition is still used for argument replacement.  Here is a\n+pathological example:\n+\n+@smallexample\n+#define f(x) x x\n+f (1\n+#undef f\n+#define f 2\n+f)\n+@end smallexample\n+\n+@noindent which expands to\n+\n+@smallexample\n+1 2 1 2\n+@end smallexample\n+\n+@noindent with the semantics described above.\n+\n @node Macro Pitfalls\n @section Macro Pitfalls\n @cindex problems with macros"}, {"sha": "ae4efb8fa76d139c848565564ac6400e5693358e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "patch": "@@ -1,3 +1,9 @@\n+2002-02-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/undef1.c: Remove.\n+\t* gcc.dg/cpp/directiv.c: Update.\n+\t* gcc.dg/cpp/mac-dir-1.c, mac-dir-2.c: New tests.\n+\n 2002-02-27  Michael Meissner  <meissner@redhat.com>\n \n \t* gcc.c-torture/execute/20020226-1.c: New test."}, {"sha": "aafe2ec109d41733653dbeb58b324cbd7b33456a", "filename": "gcc/testsuite/gcc.dg/cpp/directiv.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fdirectiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fdirectiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fdirectiv.c?ref=e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "patch": "@@ -25,16 +25,11 @@ EMPTY #define bar\n /* Our friend the null directive OK?  */\n #\n \n-/* Check that directives always start a line, even if in middle of\n-   macro expansion.  */\n-#define func(x) x\n-func (2\t\t/* { dg-error \"unterminated\" \"\" } */\n-#define foobar\t/* { dg-error \"directives may not\" } */\n-\n /* Check newlines end directives, even in function-like macro\n    invocations.  6.10 paragraph 1.\n \n    Note that the #if is still treated as a conditional, so there\n    should be no errors about #endif without #if.  */\n+#define func(x) x\n #if func (\t\t\t/* { dg-error \"unterminated argument\" } */\n #endif"}, {"sha": "002c47f5f2bf05c66c9f3da3fca2799ef7b65985", "filename": "gcc/testsuite/gcc.dg/cpp/mac-dir-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmac-dir-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmac-dir-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmac-dir-1.c?ref=e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "patch": "@@ -0,0 +1,34 @@\n+/* Copyright (C) 2002 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess } */\n+\n+/* Source: Neil Booth, 26 Feb 2002.\n+\n+   Test that we allow directives in macro arguments.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+\n+#define f(x) x\n+extern void abort (void);\n+\n+int main ()\n+{\n+  if (f (\n+#if f(1)\t\t\t/* True.  */\n+\t0))\t\t\t/* False. */\n+#else\n+    \t1))\n+#endif\n+     abort ();\n+\n+     /* Outer f expands to original definition, f in argument expands\n+\tto new definition, so result is: if (1 != 2 - 1).  */\n+     if (1 != f(2\n+#undef f\n+#define f - 1\n+     f))\n+     abort ();\n+\n+     return 0;\n+}"}, {"sha": "b574cfd71cf758a76f0027f2e243f73a6ec327ac", "filename": "gcc/testsuite/gcc.dg/cpp/mac-dir-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmac-dir-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmac-dir-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmac-dir-2.c?ref=e808ec9c71e52aa64bdb4579ad2ef75802b7bcb5", "patch": "@@ -0,0 +1,16 @@\n+/* Copyright (C) 2002 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess } */\n+\n+/* Source: Neil Booth, 26 Feb 2002.\n+\n+   Test that we allow directives in macro arguments.  */\n+\n+/* { dg-do preprocess } */\n+\n+#define f(x) x\n+\n+f (\n+#if 1\t\t/* { dg-warning \"not portable\" } */\n+1)\n+#endif"}, {"sha": "446fc93117dd4a8be4001946e9f79f6603e6fe89", "filename": "gcc/testsuite/gcc.dg/cpp/undef1.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f585a35687df424814b57fd201253c11a19795f5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fundef1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f585a35687df424814b57fd201253c11a19795f5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fundef1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fundef1.c?ref=f585a35687df424814b57fd201253c11a19795f5", "patch": "@@ -1,14 +0,0 @@\n-/* { dg-do preprocess } */\n-\n-/* 6.9.3.11: ...If there  are sequences of preprocessing tokens within\n-   the list of arguments  that  would  otherwise  act  as  preprocessing\n-   directives, the behavior is undefined.\n-\n-   I choose to make this a hard error.  It definitely should not cause\n-   a core dump.  */\n-\n-#define foo(bar) bar\n-\n-foo( blah\t/* { dg-error \"unterminated\" \"\" } */\n-#undef foo\t/* { dg-error \"may not be used inside\" \"foo(#undef foo)\" } */\n-     blah )"}]}