{"sha": "1f84ec231e3abac2f8fc874a6231d337cd03897b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY4NGVjMjMxZTNhYmFjMmY4ZmM4NzRhNjIzMWQzMzdjZDAzODk3Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-02-12T09:58:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-02-12T09:58:18Z"}, "message": "Remove old ABI support.\n\nFrom-SVN: r39599", "tree": {"sha": "1ceebcb928abd0eff2f89a79f7f7fa861efccbc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ceebcb928abd0eff2f89a79f7f7fa861efccbc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f84ec231e3abac2f8fc874a6231d337cd03897b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f84ec231e3abac2f8fc874a6231d337cd03897b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f84ec231e3abac2f8fc874a6231d337cd03897b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f84ec231e3abac2f8fc874a6231d337cd03897b/comments", "author": null, "committer": null, "parents": [{"sha": "11662aaaa54c005e951850b36f7c6b53f6c6d709", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11662aaaa54c005e951850b36f7c6b53f6c6d709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11662aaaa54c005e951850b36f7c6b53f6c6d709"}], "stats": {"total": 3441, "additions": 247, "deletions": 3194}, "files": [{"sha": "6e1cb900c637d42a3e71b80dab52e568facbdfe2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -1,3 +1,7 @@\n+2001-02-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tRemove old ABI support.\n+\n 2001-02-11  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl2.c (flag_vtable_thunks): Always set it to 1."}, {"sha": "7cb34bd17249b72aa7d300cf4617ac3842bc5ef0", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -2355,9 +2355,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n \n   if (IS_AGGR_TYPE (totype))\n     ctors = lookup_fnfields (TYPE_BINFO (totype),\n-\t\t\t     (flag_new_abi \n-\t\t\t      ? complete_ctor_identifier\n-\t\t\t      : ctor_identifier),\n+\t\t\t     complete_ctor_identifier,\n \t\t\t     0);\n \n   if (IS_AGGR_TYPE (fromtype))\n@@ -4415,25 +4413,12 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       pretty_name = (constructor_p \n \t\t     ? constructor_name (basetype) : dtor_identifier);\n \n-      if (!flag_new_abi)\n-\t{\n-\t  /* Add the in-charge parameter as an implicit first argument.  */\n-\t  if (!constructor_p\n-\t      || TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n-\t    args = tree_cons (NULL_TREE,\n-\t\t\t      in_charge_arg_for_name (name),\n-\t\t\t      args);\n-\n-\t  /* We want to call the normal constructor function under the\n-\t     old ABI.  */\n-\t  name = constructor_p ? ctor_identifier : dtor_identifier;\n-\t}\n       /* If we're a call to a constructor or destructor for a\n \t subobject that uses virtual base classes, then we need to\n \t pass down a pointer to a VTT for the subobject.  */\n-      else if ((name == base_ctor_identifier\n-\t\t|| name == base_dtor_identifier)\n-\t       && TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n+      if ((name == base_ctor_identifier\n+\t   || name == base_dtor_identifier)\n+\t  && TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n \t{\n \t  tree vtt;\n \t  tree sub_vtt;"}, {"sha": "3f50da33108463c210e0e7f98aa829dee55dc395", "filename": "gcc/cp/class.c", "status": "modified", "additions": 54, "deletions": 168, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -143,7 +143,7 @@ static void check_field_decl PARAMS ((tree, tree, int *, int *, int *, int *));\n static void check_field_decls PARAMS ((tree, tree *, int *, int *, int *, \n \t\t\t\t     int *));\n static void build_base_field PARAMS ((record_layout_info, tree, int *,\n-\t\t\t\t      unsigned int *, splay_tree));\n+\t\t\t\t      splay_tree));\n static void build_base_fields PARAMS ((record_layout_info, int *,\n \t\t\t\t       splay_tree));\n static tree build_vbase_pointer_fields PARAMS ((record_layout_info, int *));\n@@ -182,7 +182,7 @@ static void layout_empty_base PARAMS ((tree, tree, splay_tree));\n static void accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree, tree));\n static tree dfs_accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t       tree));\n-static void set_vindex PARAMS ((tree, tree, int *));\n+static void set_vindex PARAMS ((tree, int *));\n static void build_rtti_vtbl_entries PARAMS ((tree, tree, vtbl_init_data *));\n static void build_vcall_and_vbase_vtbl_entries PARAMS ((tree, \n \t\t\t\t\t\t\tvtbl_init_data *));\n@@ -663,11 +663,7 @@ static tree\n get_vtable_name (type)\n      tree type;\n {\n-  if (flag_new_abi)\n-    return mangle_vtbl_for_type (type);\n-  else\n-    return build_overload_with_type (get_identifier (VTABLE_NAME_PREFIX),\n-\t\t\t\t     type);\n+  return mangle_vtbl_for_type (type);\n }\n \n /* Return an IDENTIFIER_NODE for the name of the virtual table table\n@@ -677,11 +673,7 @@ tree\n get_vtt_name (type)\n      tree type;\n {\n-  if (flag_new_abi)\n-    return mangle_vtt_for_type (type);\n-  else\n-    return build_overload_with_type (get_identifier (VTT_NAME_PREFIX),\n-\t\t\t\t     type);\n+  return mangle_vtt_for_type (type);\n }\n \n /* Return the offset to the main vtable for a given base BINFO.  */\n@@ -1086,35 +1078,17 @@ modify_vtable_entry (t, binfo, fndecl, delta, virtuals)\n     }\n }\n \n-/* Return the index (in the virtual function table) of the first\n-   virtual function.  */\n-\n-int\n-first_vfun_index (t)\n-     tree t;\n-{\n-  /* Under the old ABI, the offset-to-top and RTTI entries are at\n-     indices zero and one; under the new ABI, the first virtual\n-     function is at index zero.  */\n-  if (!CLASSTYPE_COM_INTERFACE (t) && !flag_new_abi)\n-    return flag_vtable_thunks ? 2 : 1;\n-\n-  return 0;\n-}\n-\n /* Set DECL_VINDEX for DECL.  VINDEX_P is the number of virtual\n    functions present in the vtable so far.  */\n \n static void\n-set_vindex (t, decl, vfuns_p)\n-     tree t;\n+set_vindex (decl, vfuns_p)\n      tree decl;\n      int *vfuns_p;\n {\n   int vindex;\n \n   vindex = (*vfuns_p)++;\n-  vindex += first_vfun_index (t);\n   DECL_VINDEX (decl) = build_shared_int_cst (vindex);\n }\n \n@@ -1158,7 +1132,7 @@ add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n       CLASSTYPE_RTTI (t) = t;\n \n       /* Now assign virtual dispatch information.  */\n-      set_vindex (t, fndecl, vfuns_p);\n+      set_vindex (fndecl, vfuns_p);\n       DECL_VIRTUAL_CONTEXT (fndecl) = t;\n \n       /* Save the state we've computed on the NEW_VIRTUALS list.  */\n@@ -1942,9 +1916,6 @@ determine_primary_base (t, vfuns_p)\n \t\t    = tree_cons (base_binfo, \n \t\t\t\t VF_BASETYPE_VALUE (vfields),\n \t\t\t\t CLASSTYPE_VFIELDS (t));\n-\n-\t      if (!flag_new_abi && *vfuns_p == 0)\n-\t\tset_primary_base (t, base_binfo, vfuns_p);\n \t    }\n \t}\n     }\n@@ -1994,7 +1965,7 @@ determine_primary_base (t, vfuns_p)\n   /* The new ABI allows for the use of a \"nearly-empty\" virtual base\n      class as the primary base class if no non-virtual polymorphic\n      base can be found.  */\n-  if (flag_new_abi && !CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n+  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n     {\n       /* If not NULL, this is the best primary base candidate we have\n          found so far.  */\n@@ -2744,37 +2715,32 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n   /* Under the new ABI, we will convert to an intermediate virtual\n      base first, and then use the vcall offset located there to finish\n      the conversion.  */\n-  if (flag_new_abi)\n+  while (b)\n     {\n-      while (b)\n-\t{\n-\t  /* If we find BINFO, then the final overrider is in a class\n-\t     derived from BINFO, so the thunks can be generated with\n-\t     the final overrider.  */\n-\t  if (!virtual_base\n-\t      && same_type_p (BINFO_TYPE (b), BINFO_TYPE (binfo)))\n-\t    generate_thunk_with_vtable_p = 0;\n+      /* If we find BINFO, then the final overrider is in a class\n+\t derived from BINFO, so the thunks can be generated with\n+\t the final overrider.  */\n+      if (!virtual_base\n+\t  && same_type_p (BINFO_TYPE (b), BINFO_TYPE (binfo)))\n+\tgenerate_thunk_with_vtable_p = 0;\n \n \t  /* If we find the final overrider, then we can stop\n \t     walking.  */\n-\t  if (same_type_p (BINFO_TYPE (b), \n-\t\t\t   BINFO_TYPE (TREE_VALUE (overrider))))\n-\t    break;\n+      if (same_type_p (BINFO_TYPE (b), \n+\t\t       BINFO_TYPE (TREE_VALUE (overrider))))\n+\tbreak;\n \n \t  /* If we find a virtual base, and we haven't yet found the\n \t     overrider, then there is a virtual base between the\n \t     declaring base and the final overrider.  */\n-\t  if (!virtual_base && TREE_VIA_VIRTUAL (b))\n-\t    {\n-\t      generate_thunk_with_vtable_p = 1;\n-\t      virtual_base = b;\n-\t    }\n-\n-\t  b = BINFO_INHERITANCE_CHAIN (b);\n+      if (!virtual_base && TREE_VIA_VIRTUAL (b))\n+\t{\n+\t  generate_thunk_with_vtable_p = 1;\n+\t  virtual_base = b;\n \t}\n+\n+      b = BINFO_INHERITANCE_CHAIN (b);\n     }\n-  else\n-    virtual_base = NULL_TREE;\n \n   if (virtual_base)\n     /* The `this' pointer needs to be adjusted to the nearest virtual\n@@ -2822,8 +2788,7 @@ dfs_modify_vtables (binfo, data)\n       /* If we're supporting RTTI then we always need a new vtable to\n \t point to the RTTI information.  Under the new ABI we may need\n \t a new vtable to contain vcall and vbase offsets.  */\n-      if (flag_rtti || flag_new_abi)\n-\tmake_new_vtable (t, binfo);\n+      make_new_vtable (t, binfo);\n       \n       /* Now, go through each of the virtual functions in the virtual\n \t function table for BINFO.  Find the final overrider, and\n@@ -2884,7 +2849,7 @@ modify_all_vtables (t, vfuns_p, overridden_virtuals)\n \t      || !value_member (fn, BINFO_VIRTUALS (binfo)))\n \t    {\n \t      /* Set the vtable index.  */\n-\t      set_vindex (t, fn, vfuns_p);\n+\t      set_vindex (fn, vfuns_p);\n \t      /* We don't need to convert to a base class when calling\n \t\t this function.  */\n \t      DECL_VIRTUAL_CONTEXT (fn) = t;\n@@ -3954,10 +3919,10 @@ layout_nonempty_base_or_field (rli, decl, binfo, offsets)\n \t empty class, have non-zero size, any overlap can happen only\n \t with a direct or indirect base-class -- it can't happen with\n \t a data member.  */\n-      if (flag_new_abi && layout_conflict_p (TREE_TYPE (decl),\n-\t\t\t\t\t     offset,\n-\t\t\t\t\t     offsets, \n-\t\t\t\t\t     field_p))\n+      if (layout_conflict_p (TREE_TYPE (decl),\n+\t\t\t     offset,\n+\t\t\t     offsets, \n+\t\t\t     field_p))\n \t{\n \t  /* Strip off the size allocated to this field.  That puts us\n \t     at the first place we could have put the field with\n@@ -4033,11 +3998,10 @@ layout_empty_base (binfo, eoc, offsets)\n    class.  OFFSETS gives the location of empty base subobjects.  */\n \n static void\n-build_base_field (rli, binfo, empty_p, base_align, offsets)\n+build_base_field (rli, binfo, empty_p, offsets)\n      record_layout_info rli;\n      tree binfo;\n      int *empty_p;\n-     unsigned int *base_align;\n      splay_tree offsets;\n {\n   tree basetype = BINFO_TYPE (binfo);\n@@ -4056,20 +4020,6 @@ build_base_field (rli, binfo, empty_p, base_align, offsets)\n   DECL_ALIGN (decl) = CLASSTYPE_ALIGN (basetype);\n   DECL_USER_ALIGN (decl) = CLASSTYPE_USER_ALIGN (basetype);\n   \n-  if (! flag_new_abi)\n-    {\n-      /* Brain damage for backwards compatibility.  For no good\n-\t reason, the old basetype layout made every base have at least\n-\t as large as the alignment for the bases up to that point,\n-\t gratuitously wasting space.  So we do the same thing here.  */\n-      *base_align = MAX (*base_align, DECL_ALIGN (decl));\n-      DECL_SIZE (decl)\n-\t= size_binop (MAX_EXPR, DECL_SIZE (decl), bitsize_int (*base_align));\n-      DECL_SIZE_UNIT (decl)\n-\t= size_binop (MAX_EXPR, DECL_SIZE_UNIT (decl),\n-\t\t      size_int (*base_align / BITS_PER_UNIT));\n-    }\n-\n   if (!integer_zerop (DECL_SIZE (decl)))\n     {\n       /* The containing class is non-empty because it has a non-empty\n@@ -4120,13 +4070,12 @@ build_base_fields (rli, empty_p, offsets)\n   tree rec = rli->t;\n   int n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n   int i;\n-  unsigned int base_align = 0;\n \n   /* Under the new ABI, the primary base class is always allocated\n      first.  */\n-  if (flag_new_abi && CLASSTYPE_HAS_PRIMARY_BASE_P (rec))\n+  if (CLASSTYPE_HAS_PRIMARY_BASE_P (rec))\n     build_base_field (rli, CLASSTYPE_PRIMARY_BINFO (rec), \n-\t\t      empty_p, &base_align, offsets);\n+\t\t      empty_p, offsets);\n \n   /* Now allocate the rest of the bases.  */\n   for (i = 0; i < n_baseclasses; ++i)\n@@ -4137,7 +4086,7 @@ build_base_fields (rli, empty_p, offsets)\n \n       /* Under the new ABI, the primary base was already allocated\n \t above, so we don't need to allocate it again here.  */\n-      if (flag_new_abi && base_binfo == CLASSTYPE_PRIMARY_BINFO (rec))\n+      if (base_binfo == CLASSTYPE_PRIMARY_BINFO (rec))\n \tcontinue;\n \n       /* A primary virtual base class is allocated just like any other\n@@ -4147,7 +4096,7 @@ build_base_fields (rli, empty_p, offsets)\n \t  && !BINFO_PRIMARY_P (base_binfo))\n \tcontinue;\n \n-      build_base_field (rli, base_binfo, empty_p, &base_align, offsets);\n+      build_base_field (rli, base_binfo, empty_p, offsets);\n     }\n }\n \n@@ -4196,18 +4145,13 @@ check_methods (t)\n \t     [class.free]) requires that the second argument be set\n \t     correctly.  */\n \t  second_parm = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (x)));\n-\t  /* This is overly conservative, but we must maintain this\n-\t     behavior for backwards compatibility.  */\n-\t  if (!flag_new_abi && second_parm != void_list_node)\n-\t    TYPE_VEC_DELETE_TAKES_SIZE (t) = 1;\n \t  /* Under the new ABI, we choose only those function that are\n \t     explicitly declared as `operator delete[] (void *,\n \t     size_t)'.  */\n-\t  else if (flag_new_abi \n-\t\t   && !seen_one_arg_array_delete_p\n-\t\t   && second_parm\n-\t\t   && TREE_CHAIN (second_parm) == void_list_node\n-\t\t   && same_type_p (TREE_VALUE (second_parm), sizetype))\n+\t  if (!seen_one_arg_array_delete_p\n+\t      && second_parm\n+\t      && TREE_CHAIN (second_parm) == void_list_node\n+\t      && same_type_p (TREE_VALUE (second_parm), sizetype))\n \t    TYPE_VEC_DELETE_TAKES_SIZE (t) = 1;\n \t  /* If there's no second parameter, then this is the usual\n \t     deallocation function.  */\n@@ -4351,9 +4295,8 @@ clone_function_decl (fn, update_method_vec_p)\n   tree clone;\n \n   /* Avoid inappropriate cloning.  */\n-  if (! flag_new_abi\n-      || (TREE_CHAIN (fn)\n-\t  && DECL_CLONED_FUNCTION (TREE_CHAIN (fn))))\n+  if (TREE_CHAIN (fn)\n+      && DECL_CLONED_FUNCTION (TREE_CHAIN (fn)))\n     return;\n \n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn))\n@@ -4398,10 +4341,6 @@ clone_constructors_and_destructors (t)\n {\n   tree fns;\n \n-  /* We only clone constructors and destructors under the new ABI.  */\n-  if (!flag_new_abi)\n-    return;\n-\n   /* If for some reason we don't have a CLASSTYPE_METHOD_VEC, we bail\n      out now.  */\n   if (!CLASSTYPE_METHOD_VEC (t))\n@@ -4540,8 +4479,7 @@ create_vtable_ptr (t, empty_p, vfuns_p,\n   /* Loop over the virtual functions, adding them to our various\n      vtables.  */\n   for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n-    if (DECL_VINDEX (fn) \n-\t&& !(flag_new_abi && DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn)))\n+    if (DECL_VINDEX (fn) && !DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn))\n       add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n \t\t\t    vfuns_p, fn, t);\n \n@@ -4580,7 +4518,7 @@ create_vtable_ptr (t, empty_p, vfuns_p,\n \t\t\t\t     t,\n \t\t\t\t     empty_p);\n \n-      if (flag_new_abi && CLASSTYPE_N_BASECLASSES (t))\n+      if (CLASSTYPE_N_BASECLASSES (t))\n \t/* If there were any baseclasses, they can't possibly be at\n \t   offset zero any more, because that's where the vtable\n \t   pointer is.  So, converting to a base class is going to\n@@ -4755,22 +4693,15 @@ layout_virtual_bases (t, offsets)\n      ABI, these are allocated according to a depth-first left-to-right\n      postorder traversal; in the new ABI, inheritance graph order is\n      used instead.  */\n-  for (vbases = (flag_new_abi \n-\t\t ? TYPE_BINFO (t) \n-\t\t : CLASSTYPE_VBASECLASSES (t));\n+  for (vbases = TYPE_BINFO (t);\n        vbases; \n        vbases = TREE_CHAIN (vbases))\n     {\n       tree vbase;\n \n-      if (flag_new_abi)\n-\t{\n-\t  if (!TREE_VIA_VIRTUAL (vbases))\n-\t    continue;\n-\t  vbase = binfo_for_vbase (BINFO_TYPE (vbases), t);\n-\t}\n-      else\n-\tvbase = TREE_VALUE (vbases);\n+      if (!TREE_VIA_VIRTUAL (vbases))\n+\tcontinue;\n+      vbase = binfo_for_vbase (BINFO_TYPE (vbases), t);\n \n       if (!BINFO_PRIMARY_P (vbase))\n \t{\n@@ -4781,13 +4712,7 @@ layout_virtual_bases (t, offsets)\n \n \t  basetype = BINFO_TYPE (vbase);\n \n-\t  if (flag_new_abi)\n-\t    desired_align = CLASSTYPE_ALIGN (basetype);\n-\t  else\n-\t    /* Under the old ABI, virtual bases were aligned as for the\n-\t     entire base object (including its virtual bases).  That's\n-\t     wasteful, in general.  */\n-\t    desired_align = TYPE_ALIGN (basetype);\n+\t  desired_align = CLASSTYPE_ALIGN (basetype);\n \t  TYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), desired_align);\n \n \t  /* Add padding so that we can put the virtual base class at an\n@@ -4796,7 +4721,7 @@ layout_virtual_bases (t, offsets)\n \n \t  /* Under the new ABI, we try to squish empty virtual bases in\n \t     just like ordinary empty bases.  */\n-\t  if (flag_new_abi && is_empty_class (basetype))\n+\t  if (is_empty_class (basetype))\n \t    layout_empty_base (vbase,\n \t\t\t       size_int (CEIL (dsize, BITS_PER_UNIT)),\n \t\t\t       offsets);\n@@ -4945,7 +4870,7 @@ layout_class_type (t, empty_p, vfuns_p,\n \n   /* Under the new ABI, the vptr is always the first thing in the\n      class.  */\n-  if (flag_new_abi && vptr)\n+  if (vptr)\n     {\n       TYPE_FIELDS (t) = chainon (vptr, TYPE_FIELDS (t));\n       place_field (rli, vptr);\n@@ -4986,12 +4911,7 @@ layout_class_type (t, empty_p, vfuns_p,\n \t rules, but the back-end can't handle bitfields longer than a\n \t `long long', so we use the same mechanism.  */\n       if (DECL_C_BIT_FIELD (field)\n-\t  && ((flag_new_abi \n-\t       && INT_CST_LT (TYPE_SIZE (type), DECL_SIZE (field)))\n-\t      || (!flag_new_abi\n-\t\t  && 0 < compare_tree_int (DECL_SIZE (field),\n-\t\t\t\t\t   TYPE_PRECISION\n-\t\t\t\t\t   (long_long_unsigned_type_node)))))\n+\t  && INT_CST_LT (TYPE_SIZE (type), DECL_SIZE (field)))\n \t{\n \t  integer_type_kind itk;\n \t  tree integer_type;\n@@ -5049,10 +4969,6 @@ layout_class_type (t, empty_p, vfuns_p,\n   if (TREE_CODE (rli_size_unit_so_far (rli)) == INTEGER_CST\n       && compare_tree_int (rli_size_unit_so_far (rli), eoc) < 0)\n     {\n-      /* We don't handle zero-sized base classes specially under the\n-\t old ABI, so if we get here, we had better be operating under\n-\t the new ABI rules.  */\n-      my_friendly_assert (flag_new_abi, 20000321);\n       rli->offset = size_binop (MAX_EXPR, rli->offset, size_int (eoc + 1));\n       rli->bitpos = bitsize_zero_node;\n     }\n@@ -5073,14 +4989,6 @@ layout_class_type (t, empty_p, vfuns_p,\n       TREE_STATIC (TYPE_NONCOPIED_PARTS (t)) = 1;\n     }\n \n-  /* Under the old ABI, the vptr comes at the very end of the \n-     class.   */\n-  if (!flag_new_abi && vptr)\n-    {\n-      place_field (rli, vptr);\n-      TYPE_FIELDS (t) = chainon (TYPE_FIELDS (t), vptr);\n-    }\n-  \n   /* Let the back-end lay out the type. Note that at this point we\n      have only included non-virtual base-classes; we will lay out the\n      virtual base classes later.  So, the TYPE_SIZE/TYPE_ALIGN after\n@@ -5094,21 +5002,16 @@ layout_class_type (t, empty_p, vfuns_p,\n \n   /* Remember the size and alignment of the class before adding\n      the virtual bases.  */\n-  if (*empty_p && flag_new_abi)\n+  if (*empty_p)\n     {\n       CLASSTYPE_SIZE (t) = bitsize_zero_node;\n       CLASSTYPE_SIZE_UNIT (t) = size_zero_node;\n     }\n-  else if (flag_new_abi)\n+  else\n     {\n       CLASSTYPE_SIZE (t) = TYPE_BINFO_SIZE (t);\n       CLASSTYPE_SIZE_UNIT (t) = TYPE_BINFO_SIZE_UNIT (t);\n     }\n-  else\n-    {\n-      CLASSTYPE_SIZE (t) = TYPE_SIZE (t);\n-      CLASSTYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (t);\n-    }\n \n   CLASSTYPE_ALIGN (t) = TYPE_ALIGN (t);\n   CLASSTYPE_USER_ALIGN (t) = TYPE_USER_ALIGN (t);\n@@ -6493,23 +6396,13 @@ int\n is_empty_class (type)\n      tree type;\n {\n-  tree t;\n-\n   if (type == error_mark_node)\n     return 0;\n \n   if (! IS_AGGR_TYPE (type))\n     return 0;\n \n-  if (flag_new_abi)\n-    return integer_zerop (CLASSTYPE_SIZE (type));\n-\n-  if (TYPE_BINFO_BASETYPES (type))\n-    return 0;\n-  t = TYPE_FIELDS (type);\n-  while (t && TREE_CODE (t) != FIELD_DECL)\n-    t = TREE_CHAIN (t);\n-  return (t == NULL_TREE);\n+  return integer_zerop (CLASSTYPE_SIZE (type));\n }\n \n /* Find the enclosing class of the given NODE.  NODE can be a *_DECL or\n@@ -6894,10 +6787,6 @@ build_vtt (t)\n   tree vtt;\n   tree index;\n \n-  /* Under the old ABI, we don't use VTTs.  */\n-  if (!flag_new_abi)\n-    return;\n-\n   /* Build up the initializers for the VTT.  */\n   inits = NULL_TREE;\n   index = size_zero_node;\n@@ -7194,10 +7083,7 @@ build_ctor_vtbl_group (binfo, t)\n   tree vbase;\n \n   /* See if we've already create this construction vtable group.  */\n-  if (flag_new_abi)\n-    id = mangle_ctor_vtbl_for_type (t, binfo);\n-  else\n-    id = get_ctor_vtbl_name (t, binfo);\n+  id = mangle_ctor_vtbl_for_type (t, binfo);\n   if (IDENTIFIER_GLOBAL_VALUE (id))\n     return;\n "}, {"sha": "eb7afc04ff54b1d10513d628b83bf6a112aafa3c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -213,10 +213,6 @@ Boston, MA 02111-1307, USA.  */\n \f\n /* ABI control.  */\n \n-/* Nonzero to enable experimental ABI changes.  */\n-\n-extern int flag_new_abi;\n-\n /* Nonzero to use __cxa_atexit, rather than atexit, to register\n    destructors for local statics and global objects.  */\n \n@@ -238,12 +234,12 @@ extern int flag_huge_objects;\n /* Nonzero if virtual base class offsets are stored in the virtual\n    function table.  Zero if, instead, a pointer to the virtual base is\n    stored in the object itself.  */\n-#define vbase_offsets_in_vtable_p() (flag_new_abi)\n+#define vbase_offsets_in_vtable_p() (1)\n \n /* Nonzero if displacements to the `this' pointer to use when calling\n    virtual functions in a virtual base class are present in the\n    vtable.  */\n-#define vcall_offsets_in_vtable_p() (flag_new_abi)\n+#define vcall_offsets_in_vtable_p() (1)\n \n /* Nonzero if a derived class that needs a vptr should always get one,\n    even if a non-primary base class already has one.  For example,\n@@ -255,24 +251,24 @@ extern int flag_huge_objects;\n    one could either reuse the vptr in `S' for `T', or create a new\n    vptr for `T'.  If this flag is nonzero we choose the latter\n    alternative; otherwise, we choose the former.  */\n-#define vptrs_present_everywhere_p() (flag_new_abi)\n+#define vptrs_present_everywhere_p() (1)\n \n /* Nonzero if the vtable for a derived class should contain the\n    virtual functions from the primary base and all virtual functions\n    present in the class itself.  Zero if, instead, it should contain\n    only those virtual functions from the primary base together with\n    the functions declared in the derived class (but not in any base\n    class).  */\n-#define all_overridden_vfuns_in_vtables_p() (flag_new_abi)\n+#define all_overridden_vfuns_in_vtables_p() (1)\n \n /* Nonzero if we use access type_info objects directly, and use the\n    cross-vendor layout for them. Zero if we use an accessor function\n    to get the type_info object address.  */\n-#define new_abi_rtti_p() (flag_new_abi)\n+#define new_abi_rtti_p() (1)\n \n /* Nonzero if primary and secondary vtables are combined into a single\n    vtable.  */\n-#define merge_primary_and_secondary_vtables_p() (flag_new_abi)\n+#define merge_primary_and_secondary_vtables_p() (1)\n \n \f\n /* Language-dependent contents of an identifier.  */\n@@ -2681,9 +2677,7 @@ extern int flag_new_for_scope;\n    pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,\n    before using this macro.  */\n #define TYPE_PTRMEMFUNC_FN_TYPE(NODE) \\\n-  (flag_new_abi                       \\\n-   ? (TREE_TYPE (TYPE_FIELDS (NODE))) \\\n-   : (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (NODE))))))))\n+  (TREE_TYPE (TYPE_FIELDS (NODE)))\n \n /* Returns `A' for a type like `int (A::*)(double)' */\n #define TYPE_PTRMEMFUNC_OBJECT_TYPE(NODE) \\\n@@ -3739,7 +3733,6 @@ extern void push_lang_context\t\t\tPARAMS ((tree));\n extern void pop_lang_context\t\t\tPARAMS ((void));\n extern tree instantiate_type\t\t\tPARAMS ((tree, tree, enum instantiate_type_flags));\n extern void print_class_statistics\t\tPARAMS ((void));\n-extern int first_vfun_index                     PARAMS ((tree));\n extern void build_self_reference\t\tPARAMS ((void));\n extern void warn_hidden\t\t\t\tPARAMS ((tree));\n extern tree get_enclosing_class\t\t\tPARAMS ((tree));\n@@ -4097,22 +4090,13 @@ extern int cp_type_qual_from_rid                PARAMS ((tree));\n \n /* in method.c */\n extern void init_method\t\t\t\tPARAMS ((void));\n-extern char *build_overload_name\t\tPARAMS ((tree, int, int));\n-extern tree build_static_name\t\t\tPARAMS ((tree, tree));\n-extern tree build_decl_overload_real            PARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t\t       tree, int));\n extern void set_mangled_name_for_decl           PARAMS ((tree));\n-extern tree build_typename_overload\t\tPARAMS ((tree));\n-extern tree build_overload_with_type\t\tPARAMS ((tree, tree));\n-extern tree build_destructor_name\t\tPARAMS ((tree));\n extern tree build_opfncall\t\t\tPARAMS ((enum tree_code, int, tree, tree, tree));\n extern tree hack_identifier\t\t\tPARAMS ((tree, tree));\n extern tree make_thunk\t\t\t\tPARAMS ((tree, tree, tree, int));\n extern void use_thunk\t\t\t\tPARAMS ((tree, int));\n extern void synthesize_method\t\t\tPARAMS ((tree));\n-extern tree get_id_2\t\t\t\tPARAMS ((const char *, tree));\n extern tree implicitly_declare_fn               PARAMS ((special_function_kind, tree, int));\n-extern tree get_ctor_vtbl_name                  PARAMS ((tree, tree));\n \n /* In optimize.c */\n extern void optimize_function                   PARAMS ((tree));\n@@ -4191,7 +4175,6 @@ extern tree get_tinfo_decl                      PARAMS((tree));\n extern tree get_typeid\t\t\t\tPARAMS((tree));\n extern tree get_typeid_1\t\t\tPARAMS((tree));\n extern tree build_dynamic_cast\t\t\tPARAMS((tree, tree));\n-extern void synthesize_tinfo_fn\t\t\tPARAMS((tree));\n extern void emit_support_tinfos                 PARAMS((void));\n extern int tinfo_decl_p                         PARAMS((tree, void *));\n extern int emit_tinfo_decl                      PARAMS((tree *, void *));\n@@ -4500,7 +4483,7 @@ extern int cp_type_quals                        PARAMS ((tree));\n extern int cp_has_mutable_p                     PARAMS ((tree));\n extern int at_least_as_qualified_p              PARAMS ((tree, tree));\n extern int more_qualified_p                     PARAMS ((tree, tree));\n-extern tree build_ptrmemfunc1                   PARAMS ((tree, tree, tree, tree, tree));\n+extern tree build_ptrmemfunc1                   PARAMS ((tree, tree, tree));\n extern void expand_ptrmemfunc_cst               PARAMS ((tree, tree *, tree *, tree *, tree *));\n extern tree delta2_from_ptrmemfunc              PARAMS ((tree));\n extern tree pfn_from_ptrmemfunc                 PARAMS ((tree));"}, {"sha": "1f74eb463ab21d2a740975e7f940e12c2be3f09d", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -258,7 +258,7 @@ cp_convert_to_pointer (type, expr, force)\n       if (TYPE_PTRMEMFUNC_P (type))\n \treturn build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0);\n \n-      if (flag_new_abi && TYPE_PTRMEM_P (type))\n+      if (TYPE_PTRMEM_P (type))\n \t/* Under the new ABI, a NULL pointer-to-member is represented\n \t   by -1, not by zero.  */\n \texpr = build_int_2 (-1, -1);"}, {"sha": "ead15dbdd760685a0fcfd8ca993bea5c5fa2f87a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 22, "deletions": 118, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -51,15 +51,10 @@ extern tree global_namespace;\n extern int (*valid_lang_attribute) PARAMS ((tree, tree, tree, tree));\n \n #ifndef BOOL_TYPE_SIZE\n-#ifdef SLOW_BYTE_ACCESS\n /* In the new ABI, `bool' has size and alignment `1', on all\n    platforms.  */\n-#define BOOL_TYPE_SIZE \\\n-  ((SLOW_BYTE_ACCESS && !flag_new_abi) ? (POINTER_SIZE) : (CHAR_TYPE_SIZE))\n-#else\n #define BOOL_TYPE_SIZE CHAR_TYPE_SIZE\n #endif\n-#endif\n \n static tree grokparms\t\t\t\tPARAMS ((tree));\n static const char *redeclaration_error_message\tPARAMS ((tree, tree));\n@@ -149,7 +144,7 @@ static void end_cleanup_fn PARAMS ((void));\n static tree cp_make_fname_decl PARAMS ((tree, const char *, int));\n static void initialize_predefined_identifiers PARAMS ((void));\n static tree check_special_function_return_type\n-  PARAMS ((special_function_kind, tree, tree, tree));\n+  PARAMS ((special_function_kind, tree, tree));\n static tree push_cp_library_fn PARAMS ((enum tree_code, tree));\n static tree build_cp_library_fn PARAMS ((tree, enum tree_code, tree));\n static void store_parm_decls PARAMS ((tree));\n@@ -2844,13 +2839,7 @@ pushtag (name, type, globalize)\n \t    VARRAY_PUSH_TREE (local_classes, type);\n \n \t  if (!uses_template_parms (type))\n-\t    {\n-\t      if (flag_new_abi)\n-\t\tDECL_ASSEMBLER_NAME (d) = mangle_type (type);\n-\t      else\n-\t\tDECL_ASSEMBLER_NAME (d)\n-\t\t  = get_identifier (build_overload_name (type, 1, 1));\n-\t    }\n+\t    DECL_ASSEMBLER_NAME (d) = mangle_type (type);\n         }\n       if (b->parm_flag == 2)\n \t{\n@@ -6307,8 +6296,8 @@ init_decl_processing ()\n \n   /* Check to see that the user did not specify an invalid combination\n      of command-line options.  */\n-  if (flag_new_abi && !flag_vtable_thunks)\n-    error (\"the new ABI requires vtable thunks\");\n+  if (!flag_vtable_thunks)\n+    error (\"the ABI requires vtable thunks\");\n \n   /* Create all the identifiers we need.  */\n   initialize_predefined_identifiers ();\n@@ -6411,17 +6400,8 @@ init_decl_processing ()\n   record_builtin_type (RID_MAX, NULL_PTR, string_type_node);\n #endif\n \n-  if (flag_new_abi)\n-    delta_type_node = ptrdiff_type_node;\n-  else if (flag_huge_objects)\n-    delta_type_node = long_integer_type_node;\n-  else\n-    delta_type_node = short_integer_type_node;\n-\n-  if (flag_new_abi)\n-    vtable_index_type = ptrdiff_type_node;\n-  else\n-    vtable_index_type = delta_type_node;\n+  delta_type_node = ptrdiff_type_node;\n+  vtable_index_type = ptrdiff_type_node;\n \n   vtt_parm_type = build_pointer_type (const_ptr_type_node);\n   lang_type_promotes_to = convert_type_from_ellipsis;\n@@ -6490,12 +6470,9 @@ init_decl_processing ()\n   layout_type (vtbl_ptr_type_node);\n   record_builtin_type (RID_MAX, NULL_PTR, vtbl_ptr_type_node);\n \n-  if (flag_new_abi)\n-    {\n-      push_namespace (get_identifier (\"__cxxabiv1\"));\n-      abi_node = current_namespace;\n-      pop_namespace ();\n-    }\n+  push_namespace (get_identifier (\"__cxxabiv1\"));\n+  abi_node = current_namespace;\n+  pop_namespace ();\n \n   global_type_node = make_node (LANG_TYPE);\n   record_unknown_type (global_type_node, \"global type\");\n@@ -6521,10 +6498,7 @@ init_decl_processing ()\n   }\n \n   abort_fndecl\n-    = build_library_fn_ptr ((flag_new_abi\n-\t\t\t     ? \"__cxa_pure_virtual\"\n-\t\t\t     : \"__pure_virtual\"),\n-\t\t\t    void_ftype);\n+    = build_library_fn_ptr (\"__cxa_pure_virtual\", void_ftype);\n \n   /* Perform other language dependent initializations.  */\n   init_class_processing ();\n@@ -7534,13 +7508,7 @@ maybe_commonize_var (decl)\n \t     which we can't if it has been initialized.  */\n \n \t  if (TREE_PUBLIC (decl))\n-\t    {\n-\t      if (flag_new_abi)\n-\t\tDECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n-\t      else\n-\t\tDECL_ASSEMBLER_NAME (decl)\n-\t\t  = build_static_name (current_function_decl, DECL_NAME (decl));\n-\t    }\n+\t    DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n \t  else\n \t    {\n \t      cp_warning_at (\"sorry: semantics of inline function static data `%#D' are wrong (you'll wind up with multiple copies)\", decl);\n@@ -8977,13 +8945,7 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n       /* DECL_ASSEMBLER_NAME is needed only for full-instantiated\n \t templates.  */\n       if (!uses_template_parms (decl))\n-\t{\n-\t  if (flag_new_abi)\n-\t    DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n-\t  else\n-\t    DECL_ASSEMBLER_NAME (decl) = build_static_name (basetype,\n-\t\t\t\t\t\t\t    declarator);\n-\t}\n+\tDECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n     }\n   else\n     {\n@@ -9008,13 +8970,7 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n \n       context = DECL_CONTEXT (decl);\n       if (declarator && context && current_lang_name != lang_name_c)\n-\t{\n-\t  if (flag_new_abi)\n-\t    DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n-\t  else\n-\t    DECL_ASSEMBLER_NAME (decl)\n-\t      = build_static_name (context, declarator);\n-\t}\n+\tDECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n     }\n \n   if (in_namespace)\n@@ -9079,7 +9035,6 @@ build_ptrmemfunc_type (type)\n {\n   tree fields[4];\n   tree t;\n-  tree u;\n   tree unqualified_variant = NULL_TREE;\n \n   if (type == error_mark_node)\n@@ -9104,30 +9059,10 @@ build_ptrmemfunc_type (type)\n   /* ... and not really an aggregate.  */\n   SET_IS_AGGR_TYPE (t, 0);\n \n-  if (!flag_new_abi)\n-    {\n-      u = make_aggr_type (UNION_TYPE);\n-      SET_IS_AGGR_TYPE (u, 0);\n-      fields[0] = build_decl (FIELD_DECL, pfn_identifier, type);\n-      fields[1] = build_decl (FIELD_DECL, delta2_identifier,\n-\t\t\t      delta_type_node);\n-      finish_builtin_type (u, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n-      TYPE_NAME (u) = NULL_TREE;\n-\n-      fields[0] = build_decl (FIELD_DECL, delta_identifier,\n-\t\t\t      delta_type_node);\n-      fields[1] = build_decl (FIELD_DECL, index_identifier,\n-\t\t\t      delta_type_node);\n-      fields[2] = build_decl (FIELD_DECL, pfn_or_delta2_identifier, u);\n-      finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 2, ptr_type_node);\n-    }\n-  else\n-    {\n-      fields[0] = build_decl (FIELD_DECL, pfn_identifier, type);\n-      fields[1] = build_decl (FIELD_DECL, delta_identifier,\n-\t\t\t      delta_type_node);\n-      finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n-    }\n+  fields[0] = build_decl (FIELD_DECL, pfn_identifier, type);\n+  fields[1] = build_decl (FIELD_DECL, delta_identifier,\n+\t\t\t  delta_type_node);\n+  finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n \n   /* Zap out the name so that the back-end will give us the debugging\n      information for this anonymous RECORD_TYPE.  */\n@@ -9399,17 +9334,15 @@ create_array_type_for_decl (name, type, size)\n \n /* Check that it's OK to declare a function with the indicated TYPE.\n    SFK indicates the kind of special function (if any) that this\n-   function is.  CTYPE is the class of which this function is a\n-   member.  OPTYPE is the type given in a conversion operator\n+   function is.  OPTYPE is the type given in a conversion operator\n    declaration.  Returns the actual return type of the function; that\n    may be different than TYPE if an error occurs, or for certain\n    special functions.  */\n \n static tree\n-check_special_function_return_type (sfk, type, ctype, optype)\n+check_special_function_return_type (sfk, type, optype)\n      special_function_kind sfk;\n      tree type;\n-     tree ctype;\n      tree optype;\n {\n   switch (sfk)\n@@ -9418,9 +9351,8 @@ check_special_function_return_type (sfk, type, ctype, optype)\n       if (type)\n \tcp_error (\"return type specification for constructor invalid\");\n \n-      /* In the old ABI, we return `this'; in the new ABI we don't\n-\t bother.  */\n-      type = flag_new_abi ? void_type_node : build_pointer_type\t(ctype);\n+      /* In the new ABI constructors do not return a value.  */\n+      type = void_type_node;\n       break;\n \n     case sfk_destructor:\n@@ -10030,7 +9962,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n   if (sfk != sfk_none)\n     type = check_special_function_return_type (sfk, type,\n-\t\t\t\t\t       ctor_return_type,\n \t\t\t\t\t       ctor_return_type);\n   else if (type == NULL_TREE)\n     {\n@@ -11048,24 +10979,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    DECL_NAME (CLASSTYPE_TI_TEMPLATE (type))\n \t      = TYPE_IDENTIFIER (type);\n \n-\t  if (flag_new_abi)\n-\t    DECL_ASSEMBLER_NAME (decl) = mangle_type (type);\n-\t  else\n-\t    {\n-\t      /* XXX Temporarily set the scope.\n-\t\t When returning, start_decl expects it as NULL_TREE,\n-\t\t and will then then set it using pushdecl. */\n-\t      my_friendly_assert (DECL_CONTEXT (decl) == NULL_TREE, 980404);\n-\t      if (current_class_type)\n-\t\tDECL_CONTEXT (decl) = current_class_type;\n-\t      else\n-\t\tDECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n-\n-\t      DECL_ASSEMBLER_NAME (decl) = DECL_NAME (decl);\n-\t      DECL_ASSEMBLER_NAME (decl)\n-\t\t= get_identifier (build_overload_name (type, 1, 1));\n-\t      DECL_CONTEXT (decl) = NULL_TREE;\n-\t    }\n+\t  DECL_ASSEMBLER_NAME (decl) = mangle_type (type);\n \n \t  /* FIXME remangle member functions; member functions of a\n \t     type with external linkage have external linkage.  */\n@@ -13637,16 +13551,6 @@ start_function (declspecs, declarator, attrs, flags)\n       dtor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n       DECL_CONTEXT (dtor_label) = current_function_decl;\n     }\n-  /* Under the old ABI we return `this' from constructors, so we make\n-     ordinary `return' statements in constructors jump to CTOR_LABEL;\n-     from there we return `this'.  Under the new ABI, we don't bother\n-     with any of this.  By not setting CTOR_LABEL the remainder of the\n-     machinery is automatically disabled.  */\n-  else if (!flag_new_abi && DECL_CONSTRUCTOR_P (decl1))\n-    {\n-      ctor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-      DECL_CONTEXT (ctor_label) = current_function_decl;\n-    }\n \n   store_parm_decls (current_function_parms);\n "}, {"sha": "08960969781526ae66dd5bf273b0d165780c2c30", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 10, "deletions": 71, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -415,10 +415,6 @@ int flag_new_for_scope = 1;\n \n int flag_weak = 1;\n \n-/* Nonzero to enable experimental ABI changes.  */\n-\n-int flag_new_abi = 1;\n-\n /* Nonzero to use __cxa_atexit, rather than atexit, to register\n    destructors for local statics and global objects.  */\n \n@@ -620,17 +616,6 @@ cxx_decode_option (argc, argv)\n           flag_external_templates = 1;\n           cp_deprecated (\"-fexternal-templates\");\n         }\n-      else if (!strcmp (p, \"new-abi\"))\n-\t{\n-\t  flag_new_abi = 1;\n-\t  flag_do_squangling = 1;\n-\t  flag_vtable_thunks = 1;\n-\t}\n-      else if (!strcmp (p, \"no-new-abi\"))\n-\t{\n-\t  flag_new_abi = 0;\n-\t  flag_do_squangling = 0;\n-\t}\n       else if ((option_value\n                 = skip_leading_substring (p, \"template-depth-\")))\n \tmax_tinst_depth\n@@ -995,7 +980,7 @@ maybe_retrofit_in_chrg (fn)\n \n   /* If this is a subobject constructor or destructor, our caller will\n      pass us a pointer to our VTT.  */\n-  if (flag_new_abi && TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n+  if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n     {\n       DECL_VTT_PARM (fn) = build_artificial_parm (vtt_parm_identifier, \n \t\t\t\t\t\t  vtt_parm_type);\n@@ -1081,12 +1066,7 @@ grokclassfn (ctype, function, flags, quals)\n   if (flags == DTOR_FLAG)\n     {\n       DECL_DESTRUCTOR_P (function) = 1;\n-\n-      if (flag_new_abi) \n-\tset_mangled_name_for_decl (function);\n-      else\n-\tDECL_ASSEMBLER_NAME (function) = build_destructor_name (ctype);\n-\n+      set_mangled_name_for_decl (function);\n       TYPE_HAS_DESTRUCTOR (ctype) = 1;\n     }\n   else\n@@ -1560,11 +1540,7 @@ finish_static_data_member_decl (decl, init, asmspec_tree, flags)\n   if (!asmspec && current_class_type)\n     {\n       DECL_INITIAL (decl) = error_mark_node;\n-      if (flag_new_abi)\n-\tDECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n-      else\n-\tDECL_ASSEMBLER_NAME (decl) \n-\t  = build_static_name (current_class_type, DECL_NAME (decl));\n+      DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n     }\n   if (! processing_template_decl)\n     {\n@@ -1699,13 +1675,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t name for this TYPE_DECL.  */\n       DECL_ASSEMBLER_NAME (value) = DECL_NAME (value);\n       if (!uses_template_parms (value)) \n-\t{\n-\t  if (flag_new_abi)\n-\t    DECL_ASSEMBLER_NAME (value) = mangle_type (TREE_TYPE (value));\n-\t  else\n-\t    DECL_ASSEMBLER_NAME (value) =\n-\t      get_identifier (build_overload_name (TREE_TYPE (value), 1, 1));\n-\t}\n+\tDECL_ASSEMBLER_NAME (value) = mangle_type (TREE_TYPE (value));\n \n       if (processing_template_decl)\n \tvalue = push_template_decl (value);\n@@ -1886,10 +1856,7 @@ grokoptypename (declspecs, declarator)\n      tree declspecs, declarator;\n {\n   tree t = grokdeclarator (declarator, declspecs, TYPENAME, 0, NULL_TREE);\n-  if (flag_new_abi)\n-    return mangle_conv_op_name_for_type (t);\n-  else\n-    return build_typename_overload (t);\n+  return mangle_conv_op_name_for_type (t);\n }\n \n /* When a function is declared with an initializer,\n@@ -2757,9 +2724,7 @@ import_export_decl (decl)\n       tree ctype = DECL_CONTEXT (decl);\n       import_export_class (ctype);\n       if (CLASSTYPE_INTERFACE_KNOWN (ctype)\n-\t  && (flag_new_abi\n-\t      ? (! DECL_THIS_INLINE (decl))\n-\t      : (! DECL_ARTIFICIAL (decl) || DECL_VINDEX (decl))))\n+\t  && ! DECL_THIS_INLINE (decl))\n \t{\n \t  DECL_NOT_REALLY_EXTERN (decl)\n \t    = ! (CLASSTYPE_INTERFACE_ONLY (ctype)\n@@ -2846,35 +2811,15 @@ get_guard (decl)\n   tree sname;\n   tree guard;\n \n-  /* For a local variable, under the old ABI, we do not try to get a\n-     unique mangled name for the DECL.  */\n-  if (!flag_new_abi && DECL_FUNCTION_SCOPE_P (decl))\n-    {\n-      guard = get_temp_name (integer_type_node);\n-      cp_finish_decl (guard, NULL_TREE, NULL_TREE, 0);\n-      return guard;\n-    }\n-\n-  if (!flag_new_abi)\n-    /* For struct X foo __attribute__((weak)), there is a counter\n-       __snfoo. Since base is already an assembler name, sname should\n-       be globally unique */\n-    sname = get_id_2 (\"__sn\", DECL_ASSEMBLER_NAME (decl));\n-  else\n-    sname = mangle_guard_variable (decl);\n-\n+  sname = mangle_guard_variable (decl);\n   guard = IDENTIFIER_GLOBAL_VALUE (sname);\n   if (! guard)\n     {\n       tree guard_type;\n \n       /* Under the new ABI, we use a type that is big enough to\n \t contain a mutex as well as an integer counter.  */\n-      if (flag_new_abi)\n-\tguard_type = long_long_integer_type_node;\n-      else\n-\tguard_type = integer_type_node;\n-\n+      guard_type = long_long_integer_type_node;\n       guard = build_decl (VAR_DECL, sname, guard_type);\n       \n       /* The guard should have the same linkage as what it guards. */\n@@ -2900,9 +2845,6 @@ static tree\n get_guard_bits (guard)\n      tree guard;\n {\n-  if (!flag_new_abi)\n-    return guard;\n-\n   /* Under the new ABI, we only set the first byte of the guard,\n      in order to leave room for a mutex in the high-order bits.  */\n   guard = build1 (ADDR_EXPR, \n@@ -3358,7 +3300,7 @@ start_static_initialization_or_destruction (decl, initp)\n \n   /* Under the new ABI, we have not already set the GUARD, so we must\n      do so now.  */\n-  if (guard && initp && flag_new_abi)\n+  if (guard && initp)\n     finish_expr_stmt (set_guard (guard));\n \n   return guard_if_stmt;\n@@ -3724,10 +3666,7 @@ finish_file ()\n \t\t finish_function doesn't clean things up, and we end\n \t\t up with CURRENT_FUNCTION_DECL set.  */\n \t      push_to_top_level ();\n-\t      if (DECL_TINFO_FN_P (decl))\n-\t\tsynthesize_tinfo_fn (decl);\n-\t      else\n-\t\tsynthesize_method (decl);\n+\t      synthesize_method (decl);\n \t      pop_from_top_level ();\n \t      reconsider = 1;\n \t    }"}, {"sha": "30912362f08d0f360165f5f7398eaafaa9a6a2f3", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -1963,7 +1963,7 @@ dump_expr (t, flags)\n \t      t = TYPE_METHOD_BASETYPE (t);\n \t      virtuals = TYPE_BINFO_VIRTUALS (TYPE_MAIN_VARIANT (t));\n \n-\t      n = tree_low_cst (idx, 0) - first_vfun_index (t);\n+\t      n = tree_low_cst (idx, 0);\n \n \t      /* Map vtable index back one, to allow for the null pointer to\n \t\t member.  */"}, {"sha": "e53582100e39e8887ad6023e0a26c1e89fb8fa65", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -867,8 +867,6 @@ expand_throw (exp)\n \t  tree arg_types;\n \t  \n \t  arg_types = void_list_node;\n-\t  if (!flag_new_abi)\n-\t    arg_types = tree_cons (NULL_TREE, integer_type_node, arg_types);\n \t  arg_types = tree_cons (NULL_TREE, ptr_type_node, arg_types);\n \t  cleanup_type = (build_pointer_type \n \t\t\t  (build_function_type (void_type_node, arg_types)));\n@@ -927,9 +925,7 @@ expand_throw (exp)\n \t  if (TYPE_HAS_DESTRUCTOR (TREE_TYPE (object)))\n \t    {\n \t      cleanup = lookup_fnfields (TYPE_BINFO (TREE_TYPE (object)),\n-\t\t\t\t\t (flag_new_abi\n-\t\t\t\t\t  ? complete_dtor_identifier\n-\t\t\t\t\t  : dtor_identifier),\n+\t\t\t\t\t complete_dtor_identifier,\n \t\t\t\t\t 0);\n \t      cleanup = TREE_VALUE (cleanup);\n \t      mark_used (cleanup);"}, {"sha": "fc22460ff9778a3257d4b3854a36d75d2051f25b", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -56,26 +56,14 @@ cplus_expand_constant (cst)\n \t  {\n \t    /* Find the offset for the field.  */\n \t    tree offset = byte_position (member);\n-\n-\t    if (flag_new_abi)\n-\t      /* Under the new ABI, we use -1 to represent the NULL\n-\t\t pointer; non-NULL values simply contain the offset of\n-\t\t the data member.  */\n-\t      ;\n-\t    else\n-\t      /* We offset all pointer to data members by 1 so that we\n-\t\t can distinguish between a null pointer to data member\n-\t\t and the first data member of a structure.  */\n-\t      offset = size_binop (PLUS_EXPR, offset, size_one_node);\n-\n \t    cst = fold (build1 (NOP_EXPR, type, offset));\n \t  }\n \telse\n \t  {\n \t    tree delta, idx, pfn, delta2;\n \n \t    expand_ptrmemfunc_cst (cst, &delta, &idx, &pfn, &delta2);\n-\t    cst = build_ptrmemfunc1 (type, delta, idx, pfn, delta2);\n+\t    cst = build_ptrmemfunc1 (type, delta, pfn);\n \t  }\n       }\n       break;"}, {"sha": "4e68b645b73f71dc3894353c7ae7c8d8e8680a72", "filename": "gcc/cp/init.c", "status": "modified", "additions": 33, "deletions": 77, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -1954,14 +1954,6 @@ resolve_offset_ref (exp)\n       addr = convert_pointer_to (basetype, addr);\n       member = cp_convert (ptrdiff_type_node, member);\n \n-      if (!flag_new_abi)\n-\t/* Pointer to data members are offset by one, so that a null\n-\t   pointer with a real value of 0 is distinguishable from an\n-\t   offset of the first member of a structure.  */\n-\tmember = cp_build_binary_op (MINUS_EXPR, member,\n-\t\t\t\t     cp_convert (ptrdiff_type_node, \n-\t\t\t\t\t\t integer_one_node));\n-\n       return build1 (INDIRECT_REF, type,\n \t\t     build (PLUS_EXPR, build_pointer_type (type),\n \t\t\t    addr, member));\n@@ -2224,20 +2216,17 @@ build_java_class_ref (type)\n     }\n \n   /* Mangle the class$ field, new and old ABI */\n-  if (flag_new_abi)\n-    {\n-      tree field;\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\tif (DECL_NAME (field) == CL_suffix)\n-\t  {\n-\t    name = mangle_decl (field);\n-\t    break;\n-\t  }\n-      if (!field)\n-\tinternal_error (\"Can't find class$\");\n+  {\n+    tree field;\n+    for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      if (DECL_NAME (field) == CL_suffix)\n+\t{\n+\t  name = mangle_decl (field);\n+\t  break;\n+\t}\n+    if (!field)\n+      internal_error (\"Can't find class$\");\n     }\n-  else\n-    name = build_static_name (type, CL_suffix);\n \n   class_decl = IDENTIFIER_GLOBAL_VALUE (name);\n   if (class_decl == NULL_TREE)\n@@ -2264,27 +2253,17 @@ get_cookie_size (type)\n {\n   tree cookie_size;\n \n-  if (flag_new_abi)\n-    {\n-      /* Under the new ABI, we need to allocate an additional max\n-\t (sizeof (size_t), alignof (true_type)) bytes.  */\n-      tree sizetype_size;\n-      tree type_align;\n-\n-      sizetype_size = size_in_bytes (sizetype);\n-      type_align = size_int (TYPE_ALIGN_UNIT (type));\n-      if (INT_CST_LT_UNSIGNED (type_align, sizetype_size))\n-\tcookie_size = sizetype_size;\n-      else\n-\tcookie_size = type_align;\n-    }\n+  /* Under the new ABI, we need to allocate an additional max\n+     (sizeof (size_t), alignof (true_type)) bytes.  */\n+  tree sizetype_size;\n+  tree type_align;\n+  \n+  sizetype_size = size_in_bytes (sizetype);\n+  type_align = size_int (TYPE_ALIGN_UNIT (type));\n+  if (INT_CST_LT_UNSIGNED (type_align, sizetype_size))\n+    cookie_size = sizetype_size;\n   else\n-    {\n-      if (TYPE_ALIGN (type) > TYPE_ALIGN (BI_header_type))\n-\treturn size_int (TYPE_ALIGN_UNIT (type));\n-      else\n-\treturn size_in_bytes (BI_header_type);\n-    }\n+    cookie_size = type_align;\n \n   return cookie_size;\n }\n@@ -2386,7 +2365,7 @@ build_new_1 (exp)\n   else if (placement && !TREE_CHAIN (placement) \n \t   && same_type_p (TREE_TYPE (TREE_VALUE (placement)),\n \t\t\t   ptr_type_node))\n-    use_cookie = (!flag_new_abi || !use_global_new);\n+    use_cookie = !use_global_new;\n   /* Otherwise, we need the cookie.  */\n   else\n     use_cookie = 1;\n@@ -2481,23 +2460,13 @@ build_new_1 (exp)\n       tree cookie;\n \n       /* Store the number of bytes allocated so that we can know how\n-\t many elements to destroy later.  */\n-      if (flag_new_abi)\n-\t{\n-\t  /* Under the new ABI, we use the last sizeof (size_t) bytes\n-\t     to store the number of elements.  */\n-\t  cookie = build (MINUS_EXPR, build_pointer_type (sizetype),\n-\t\t\t  alloc_node, size_in_bytes (sizetype));\n-\t  cookie = build_indirect_ref (cookie, NULL_PTR);\n-\t}\n-      else\n-\t{\n-\t  cookie = build (MINUS_EXPR, build_pointer_type (BI_header_type),\n-\t\t\t  alloc_node, cookie_size);\n-\t  cookie = build_indirect_ref (cookie, NULL_PTR);\n-\t  cookie = build_component_ref (cookie, nelts_identifier,\n-\t\t\t\t\tNULL_TREE, 0);\n-\t}\n+\t many elements to destroy later.  Under the new ABI, we use\n+\t the last sizeof (size_t) bytes to store the number of\n+\t elements.  */\n+      cookie = build (MINUS_EXPR, build_pointer_type (sizetype),\n+\t\t      alloc_node, size_in_bytes (sizetype));\n+      cookie = build_indirect_ref (cookie, NULL_PTR);\n+\n       cookie_expr = build (MODIFY_EXPR, void_type_node, cookie, nelts);\n       TREE_SIDE_EFFECTS (cookie_expr) = 1;\n     }\n@@ -3412,24 +3381,11 @@ build_vec_delete (base, maxindex, auto_delete_vec, use_global_delete)\n       tree cookie_addr;\n \n       type = strip_array_types (TREE_TYPE (type));\n-      if (flag_new_abi)\n-\t{\n-\t  cookie_addr = build (MINUS_EXPR,\n-\t\t\t       build_pointer_type (sizetype),\n-\t\t\t       base,\n-\t\t\t       TYPE_SIZE_UNIT (sizetype));\n-\t  maxindex = build_indirect_ref (cookie_addr, NULL_PTR);\n-\t}\n-      else\n-\t{\n-\t  tree cookie;\n-\n-\t  cookie_addr = build (MINUS_EXPR, build_pointer_type (BI_header_type),\n-\t\t\t       base, get_cookie_size (type));\n-\t  cookie = build_indirect_ref (cookie_addr, NULL_PTR);\n-\t  maxindex = build_component_ref (cookie, nelts_identifier, \n-\t\t\t\t\t  NULL_TREE, 0);\n-\t}\n+      cookie_addr = build (MINUS_EXPR,\n+\t\t\t   build_pointer_type (sizetype),\n+\t\t\t   base,\n+\t\t\t   TYPE_SIZE_UNIT (sizetype));\n+      maxindex = build_indirect_ref (cookie_addr, NULL_PTR);\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {"}, {"sha": "f493928faaf75c85ed04ed8402077c97ec4f405d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -339,7 +339,7 @@ init_operators ()\n \t : &operator_name_info[(int) CODE]);\t\t\t\t    \\\n   oni->identifier = identifier;\t\t\t\t\t\t    \\\n   oni->name = NAME;\t\t\t\t\t\t\t    \\\n-  oni->mangled_name = flag_new_abi ? NEW_MANGLING : OLD_MANGLING;\n+  oni->mangled_name = NEW_MANGLING;\n \n #include \"operators.def\"\n #undef DEF_OPERATOR"}, {"sha": "a2b0a5aaea41a3e228072054f46af121c1bdc0c2", "filename": "gcc/cp/method.c", "status": "modified", "additions": 7, "deletions": 1843, "changes": 1850, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -61,1851 +61,38 @@ struct pending_inline *pending_inlines;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* Obstack where we build text strings for overloading, etc.  */\n-static struct obstack scratch_obstack;\n-static char *scratch_firstobj;\n-\n-static void icat PARAMS ((HOST_WIDE_INT));\n-static void dicat PARAMS ((HOST_WIDE_INT, HOST_WIDE_INT));\n-static int old_backref_index PARAMS ((tree));\n-static int flush_repeats PARAMS ((int, tree));\n-static void build_overload_identifier PARAMS ((tree));\n-static void build_overload_nested_name PARAMS ((tree));\n-static void mangle_expression PARAMS ((tree));\n-static void build_overload_int PARAMS ((tree, mangling_flags));\n-static void build_overload_identifier PARAMS ((tree));\n-static void build_qualified_name PARAMS ((tree));\n-static void build_overload_value PARAMS ((tree, tree, mangling_flags));\n-static void issue_nrepeats PARAMS ((int, tree));\n-static char *build_mangled_name PARAMS ((tree,int,int));\n-static void process_modifiers PARAMS ((tree));\n-static void process_overload_item PARAMS ((tree,int));\n static void do_build_assign_ref PARAMS ((tree));\n static void do_build_copy_constructor PARAMS ((tree));\n-static void build_template_template_parm_names PARAMS ((tree));\n-static void build_template_parm_names PARAMS ((tree, tree));\n-static void build_underscore_int PARAMS ((int));\n-static void start_squangling PARAMS ((void));\n-static void end_squangling PARAMS ((void));\n-static int check_ktype PARAMS ((tree, int));\n-static int issue_ktype PARAMS ((tree));\n-static void build_overload_scope_ref PARAMS ((tree));\n-static void build_mangled_template_parm_index PARAMS ((const char *, tree));\n #if HOST_BITS_PER_WIDE_INT >= 64\n static void build_mangled_C99_name PARAMS ((int));\n #endif\n-static int is_back_referenceable_type PARAMS ((tree));\n-static int check_btype PARAMS ((tree));\n-static void build_mangled_name_for_type PARAMS ((tree));\n-static void build_mangled_name_for_type_with_Gcode PARAMS ((tree, int));\n static tree synthesize_exception_spec PARAMS ((tree, tree (*) (tree, void *), void *));\n static tree locate_dtor PARAMS ((tree, void *));\n static tree locate_ctor PARAMS ((tree, void *));\n static tree locate_copy PARAMS ((tree, void *));\n \n-# define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)\n-# define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))\n-# define OB_PUTC2(C1,C2)\t\\\n-  (obstack_1grow (&scratch_obstack, (C1)), obstack_1grow (&scratch_obstack, (C2)))\n-# define OB_PUTS(S) (obstack_grow (&scratch_obstack, (S), sizeof (S) - 1))\n-# define OB_PUTID(ID)  \\\n-  (obstack_grow (&scratch_obstack, IDENTIFIER_POINTER (ID),\t\\\n-\t\t IDENTIFIER_LENGTH (ID)))\n-# define OB_PUTCP(S) (obstack_grow (&scratch_obstack, (S), strlen (S)))\n-# define OB_FINISH() (obstack_1grow (&scratch_obstack, '\\0'))\n-# define OB_LAST() (obstack_next_free (&scratch_obstack)[-1])\n-\n-/* type tables for K and B type compression */\n-static varray_type btypelist;\n-static varray_type ktypelist;\n-\n-/* number of each type seen */\n-static size_t maxbtype;\n-static size_t maxktype;\n-\n-/* Array of types seen so far in top-level call to `build_mangled_name'.\n-   Allocated and deallocated by caller.  */\n-static varray_type typevec;\n-\n-/* Number of types interned by `build_mangled_name' so far.  */\n-static size_t maxtype;\n-\n-/* Called once to initialize method.c.  */\n-\n-void\n-init_method ()\n-{\n-  gcc_obstack_init (&scratch_obstack);\n-  scratch_firstobj = (char *)obstack_alloc (&scratch_obstack, 0);\n-  ggc_add_tree_varray_root (&btypelist, 1);\n-  ggc_add_tree_varray_root (&ktypelist, 1);\n-  ggc_add_tree_varray_root (&typevec, 1);\n-  if (flag_new_abi)\n-    init_mangle ();\n-}\n-\n-/* This must be large enough to hold any printed integer or floating-point\n-   value.  */\n-static char digit_buffer[128];\n-\n-\f\n-/* Here is where overload code starts.  */\n-\n-/* Nonzero if we should not try folding parameter types.  */\n-static int nofold;\n-\n-/* Nonzero if an underscore is required before adding a digit to the\n-   mangled name currently being built.  */\n-static int numeric_output_need_bar;\n-\n-static inline void\n-start_squangling ()\n-{\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200005222);\n-\n-  if (flag_do_squangling)\n-    {\n-      nofold = 0;\n-      maxbtype = 0;\n-      maxktype = 0;\n-      VARRAY_TREE_INIT (btypelist, 50, \"btypelist\");\n-      VARRAY_TREE_INIT (ktypelist, 50, \"ktypelist\");\n-    }\n-}\n-\n-static inline void\n-end_squangling ()\n-{\n-  if (flag_do_squangling)\n-    {\n-      VARRAY_FREE (ktypelist);\n-      VARRAY_FREE (btypelist);\n-      maxbtype = 0;\n-      maxktype = 0;\n-    }\n-}\n-\n-/* Code to concatenate an asciified integer to a string.  */\n-\n-static inline void\n-icat (i)\n-     HOST_WIDE_INT i;\n-{\n-  unsigned HOST_WIDE_INT ui;\n-\n-  /* Handle this case first, to go really quickly.  For many common values,\n-     the result of ui/10 below is 1.  */\n-  if (i == 1)\n-    {\n-      OB_PUTC ('1');\n-      return;\n-    }\n-\n-  if (i >= 0)\n-    ui = i;\n-  else\n-    {\n-      OB_PUTC ('m');\n-      ui = -i;\n-    }\n-\n-  if (ui >= 10)\n-    icat (ui / 10);\n-\n-  OB_PUTC ('0' + (ui % 10));\n-}\n-\n-static void\n-dicat (lo, hi)\n-     HOST_WIDE_INT lo, hi;\n-{\n-  unsigned HOST_WIDE_INT ulo, uhi, qlo, qhi;\n-\n-  if (hi >= 0)\n-    {\n-      uhi = hi;\n-      ulo = lo;\n-    }\n-  else\n-    {\n-      uhi = (lo == 0 ? -hi : -hi-1);\n-      ulo = -lo;\n-    }\n-  if (uhi == 0\n-      && ulo < ((unsigned HOST_WIDE_INT)1 << (HOST_BITS_PER_WIDE_INT - 1)))\n-    {\n-      icat (ulo);\n-      return;\n-    }\n-  /* Divide 2^HOST_WIDE_INT*uhi+ulo by 10. */\n-  qhi = uhi / 10;\n-  uhi = uhi % 10;\n-  qlo = uhi * (((unsigned HOST_WIDE_INT)1 << (HOST_BITS_PER_WIDE_INT - 1)) / 5);\n-  qlo += ulo / 10;\n-  ulo = ulo % 10;\n-  ulo += uhi * (((unsigned HOST_WIDE_INT)1 << (HOST_BITS_PER_WIDE_INT - 1)) % 5)\n-\t * 2;\n-  qlo += ulo / 10;\n-  ulo = ulo % 10;\n-  /* Quotient is 2^HOST_WIDE_INT*qhi+qlo, remainder is ulo. */\n-  dicat (qlo, qhi);\n-  OB_PUTC ('0' + ulo);\n-}\n-\n-/* Returns the index of TYPE in the typevec, or -1 if it's not there.  */\n-\n-static inline int\n-old_backref_index (type)\n-     tree type;\n-{\n-  size_t tindex;\n-\n-  if (! is_back_referenceable_type (type))\n-    return -1;\n-\n-  /* The entry for this parm is at maxtype-1, so don't look there for\n-     something to repeat.  */\n-  for (tindex = 0; tindex < maxtype - 1; ++tindex)\n-    if (same_type_p (VARRAY_TREE (typevec, tindex), type))\n-      break;\n-\n-  if (tindex == maxtype - 1)\n-    return -1;\n-\n-  return tindex;\n-}\n-\n-/* Old mangling style:  If TYPE has already been used in the parameter list,\n-   emit a backward reference and return non-zero; otherwise, return 0.\n-\n-   NREPEATS is the number of repeats we've recorded of this type, or 0 if\n-   this is the first time we've seen it and we're just looking to see if\n-   it had been used before.  */\n-\n-static inline int\n-flush_repeats (nrepeats, type)\n-     int nrepeats;\n-     tree type;\n-{\n-  int tindex = old_backref_index (type);\n-\n-  if (tindex == -1)\n-    {\n-      my_friendly_assert (nrepeats == 0, 990316);\n-      return 0;\n-    }\n-\n-  if (nrepeats > 1)\n-    {\n-      OB_PUTC ('N');\n-      icat (nrepeats);\n-      if (nrepeats > 9)\n-\tOB_PUTC ('_');\n-    }\n-  else\n-    OB_PUTC ('T');\n-  icat (tindex);\n-  if (tindex > 9)\n-    OB_PUTC ('_');\n-\n-  return 1;\n-}\n-\n-/* Returns nonzero iff this is a type to which we will want to make\n-   back-references (using the `B' code).  */\n-\n-static int\n-is_back_referenceable_type (type)\n-     tree type;\n-{\n-  /* For some reason, the Java folks don't want back refs on these.  */\n-  if (TYPE_FOR_JAVA (type))\n-    return 0;\n-\n-  switch (TREE_CODE (type)) \n-    {\n-    case BOOLEAN_TYPE:\n-      if (!flag_do_squangling)\n-\t/* Even though the mangling of this is just `b', we did\n-\t   historically generate back-references for it.  */\n-\treturn 1;\n-      /* Fall through.  */\n-      \n-    case INTEGER_TYPE:\n-    case REAL_TYPE:\n-    case VOID_TYPE:\n-      /* These types have single-character manglings, so there's no\n-\t point in generating back-references.  */\n-      return 0;         \n-\n-    case TEMPLATE_TYPE_PARM:\n-      /* It would be a bit complex to demangle signatures correctly if\n-\t we generated back-references to these, and the manglings of\n-\t type parameters are short.  */\n-      return 0;\n-\n-    default:\n-      return 1;\n-    }\n-}\n-\n-/* Issue the squangling code indicating NREPEATS repetitions of TYPE,\n-   which was the last parameter type output.  */\n-\n-static void\n-issue_nrepeats (nrepeats, type)\n-     int nrepeats;\n-     tree type;\n-{\n-  if (nrepeats == 1 && !is_back_referenceable_type (type))\n-    /* For types whose manglings are short, don't bother using the\n-       repetition code if there's only one repetition, since the\n-       repetition code will be about as long as the ordinary mangling.  */ \n-    build_mangled_name_for_type (type);\n-  else\n-    {\n-      OB_PUTC ('n');\n-      icat (nrepeats);\n-      if (nrepeats > 9)\n-\tOB_PUTC ('_');\n-    }\n-}\n-\n-/* Check to see if a tree node has been entered into the Kcode typelist.\n-   If not, add it.  Returns -1 if it isn't found, otherwise returns the\n-   index.  */\n-\n-static int\n-check_ktype (node, add)\n-     tree node;\n-     int add;\n-{\n-  size_t x;\n-  tree localnode = node;\n-\n-  if (ktypelist == NULL)\n-    return -1;\n-\n-  if (TREE_CODE (node) == TYPE_DECL)\n-    localnode = TREE_TYPE (node);\n-\n-  for (x = 0; x < maxktype; x++)\n-    {\n-      if (same_type_p (localnode, VARRAY_TREE (ktypelist, x)))\n-        return x;\n-    }\n-  /* Didn't find it, so add it here.  */\n-  if (add)\n-    {\n-      if (VARRAY_SIZE (ktypelist) <= maxktype)\n-\tVARRAY_GROW (ktypelist, \n-\t\t     VARRAY_SIZE (ktypelist) * 3 / 2);\n-      VARRAY_TREE (ktypelist, maxktype) = localnode;\n-      maxktype++;\n-    }\n-  return -1;\n-}\n-\n-\n-static inline int\n-issue_ktype (decl)\n-     tree decl;\n-{\n-  int kindex;\n-  kindex = check_ktype (decl, FALSE);\n-  if (kindex != -1)\n-    {\n-      OB_PUTC ('K');\n-      icat (kindex);\n-      if (kindex > 9)\n-        OB_PUTC ('_');\n-      return TRUE;\n-    }\n-  return FALSE;\n-}\n-  \n-/* Build a representation for DECL, which may be an entity not at\n-   global scope.  If so, a marker indicating that the name is\n-   qualified has already been output, but the qualifying context has\n-   not.  */\n-\n-static void\n-build_overload_nested_name (decl)\n-     tree decl;\n-{\n-  tree context;\n-\n-  if (ktypelist && issue_ktype (decl))\n-      return;\n-\n-  if (decl == global_namespace)\n-    return;\n-\n-  context = CP_DECL_CONTEXT (decl);\n-\n-  /* try to issue a K type, and if we can't continue the normal path */\n-  if (!(ktypelist && issue_ktype (context)))\n-  {\n-    /* For a template type parameter, we want to output an 'Xn'\n-       rather than 'T' or some such. */\n-    if (TREE_CODE (context) == TEMPLATE_TYPE_PARM\n-        || TREE_CODE (context) == TEMPLATE_TEMPLATE_PARM\n-        || TREE_CODE (context) == BOUND_TEMPLATE_TEMPLATE_PARM)\n-      build_mangled_name_for_type (context);\n-    else\n-    {\n-      if (TYPE_P (context))\n-        context = TYPE_NAME (context);\n-      build_overload_nested_name (context);\n-    }\n-  }\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      static int static_labelno;\n-\n-      tree name = DECL_ASSEMBLER_NAME (decl);\n-      char *label;\n-\n-      ASM_FORMAT_PRIVATE_NAME (label, IDENTIFIER_POINTER (name), static_labelno);\n-      static_labelno++;\n-\n-      if (numeric_output_need_bar)\n-\tOB_PUTC ('_');\n-      icat (strlen (label));\n-      OB_PUTCP (label);\n-      numeric_output_need_bar = 1;\n-    }\n-  else if (TREE_CODE (decl) == NAMESPACE_DECL)\n-    build_overload_identifier (DECL_NAME (decl));\n-  else\t\t\t\t/* TYPE_DECL */\n-    build_overload_identifier (decl);\n-}\n-\n-/* Output the decimal representation of I.  If I > 9, the decimal\n-   representation is preceeded and followed by an underscore.  */\n-\n-static void\n-build_underscore_int (i)\n-     int i;\n-{\n-  if (i > 9)\n-    OB_PUTC ('_');\n-  icat (i);\n-  if (i > 9)\n-    OB_PUTC ('_');\n-}\n-\n-static void\n-build_overload_scope_ref (value)\n-     tree value;\n-{\n-  OB_PUTC2 ('Q', '2');\n-  numeric_output_need_bar = 0;\n-  build_mangled_name_for_type (TREE_OPERAND (value, 0));\n-  build_overload_identifier (TREE_OPERAND (value, 1));\n-}\n-\n-/* VALUE is a complex expression.  Produce an appropriate mangling.\n-   (We are forced to mangle complex expressions when dealing with\n-   templates, and an expression involving template parameters appears\n-   in the type of a function parameter.)  */\n-\n-static void\n-mangle_expression (value)\n-     tree value;\n-{\n-  if (TREE_CODE (value) == SCOPE_REF)\n-    {\n-      build_overload_scope_ref (value);\n-      return;\n-    }\n-\n-  OB_PUTC ('E');\n-  numeric_output_need_bar = 0;\n-\n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (value))))\n-    {\n-      int i;\n-      int operands = TREE_CODE_LENGTH (TREE_CODE (value));\n-      const char *name;\n-\n-      name = operator_name_info[TREE_CODE (value)].mangled_name;\n-      if (name == NULL)\n-\t/* On some erroneous inputs, we can get here with VALUE a\n-\t   LOOKUP_EXPR. We must survive this routine in order to issue\n-\t   a sensible error message, so we fall through to the case\n-\t   below.  */\n-\tgoto bad_value;\n-\n-      for (i = 0; i < operands; ++i)\n-\t{\n-\t  tree operand;\n-\t  enum tree_code tc;\n-\n-\t  /* We just outputted either the `E' or the name of the\n-\t     operator.  */\n-\t  numeric_output_need_bar = 0;\n-\n-\t  if (i != 0)\n-\t    /* Skip the leading underscores.  */\n-\t    OB_PUTCP (name + 2);\n-\n-\t  operand = TREE_OPERAND (value, i);\n-\t  tc = TREE_CODE (operand);\n-\n-\t  if (TREE_CODE_CLASS (tc) == 't')\n-\t    /* We can get here with sizeof, e.g.:\n-\t\t     \n-\t       template <class T> void f(A<sizeof(T)>);  */\n-\t    build_mangled_name_for_type (operand);\n-\t  else\n-\t    build_overload_value (TREE_TYPE (operand),\n-\t\t\t\t  operand,\n-\t\t\t\t  mf_maybe_uninstantiated);\n-\t}\n-    }\n-  else\n-    {\n-      /* We don't ever want this output, but it's\n-\t inconvenient not to be able to build the string.\n-\t This should cause assembler errors we'll notice.  */\n-\t    \n-      static int n;\n-    bad_value:\n-      sprintf (digit_buffer, \" *%d\", n++);\n-      OB_PUTCP (digit_buffer);\n-    }\n-\n-  OB_PUTC ('W');\n-  numeric_output_need_bar = 0;\n-}\n-\n-/* Encoding for an INTEGER_CST value.  */\n-\n-static void\n-build_overload_int (value, flags)\n-     tree value;\n-     mangling_flags flags;\n-{\n-  int multiple_words_p = 0;\n-  int multiple_digits_p = 0;\n-\n-  if ((flags & mf_maybe_uninstantiated) && TREE_CODE (value) != INTEGER_CST)\n-    {\n-      mangle_expression (value);\n-      return;\n-    }\n-\n-  /* Unless we were looking at an uninstantiated template, integers\n-     should always be represented by constants.  */\n-  my_friendly_assert (TREE_CODE (value) == INTEGER_CST, 243);\n-\n-  /* If value doesn't fit in a single HOST_WIDE_INT, we must use a\n-     special output routine that can deal with this.  */\n-  if (! host_integerp (value, 0))\n-    {\n-      multiple_words_p = 1;\n-      /* And there is certainly going to be more than one digit.  */\n-      multiple_digits_p = 1;\n-    }\n-  else \n-    multiple_digits_p = ((HOST_WIDE_INT) TREE_INT_CST_LOW (value) > 9\n-\t\t\t || (HOST_WIDE_INT) TREE_INT_CST_LOW (value) < -9);\n-\n-  /* If necessary, add a leading underscore.  */\n-  if (multiple_digits_p && (flags & mf_use_underscores_around_value))\n-    OB_PUTC ('_');\n-\n-  /* Output the number itself.  */\n-  if (multiple_words_p)\n-    dicat (TREE_INT_CST_LOW (value), TREE_INT_CST_HIGH (value));\n-  else\n-    icat (TREE_INT_CST_LOW (value));\n-\n-  if (flags & mf_use_underscores_around_value)\n-    {\n-      if (multiple_digits_p)\n-\tOB_PUTC ('_');\n-      /* Whether or not there were multiple digits, we don't need an\n-\t underscore.  We've either terminated the number with an\n-\t underscore, or else it only had one digit.  */\n-      numeric_output_need_bar = 0;\n-    }\n-  else\n-    /* We just output a numeric value.  */\n-    numeric_output_need_bar = 1;\n-}\n-\n-\n-/* Output S followed by a representation of the TEMPLATE_PARM_INDEX\n-   supplied in INDEX.  */\n-\n-static void \n-build_mangled_template_parm_index (s, index)\n-     const char *s;\n-     tree index;\n-{\n-  OB_PUTCP (s);\n-  build_underscore_int (TEMPLATE_PARM_IDX (index));\n-  /* We use the LEVEL, not the ORIG_LEVEL, because the mangling is a\n-     representation of the function from the point of view of its\n-     type.  */\n-  build_underscore_int (TEMPLATE_PARM_LEVEL (index));\n-}\n-\n-\n-/* Mangling for C99 integer types (and Cygnus extensions for 128-bit\n-   and other types) is based on the letter \"I\" followed by the hex\n-   representations of the bitsize for the type in question. For\n-   encodings that result in larger than two digits, a leading and\n-   trailing underscore is added.\n-\n-   Thus:\n-   int1_t   = 001 = I01\n-   int8_t   = 008 = I08 \n-   int16_t  = 010 = I10\n-   int24_t  = 018 = I18\n-   int32_t  = 020 = I20\n-   int64_t  = 040 = I40\n-   int80_t  = 050 = I50\n-   int128_t = 080 = I80\n-   int256_t = 100 = I_100_\n-   int512_t = 200 = I_200_\n-\n-   Given an integer in decimal format, mangle according to this scheme. */\n-\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-static void\n-build_mangled_C99_name (bits)\n-     int bits;\n-{\n-  char mangled[10] = \"\";\n-\n-  if (bits > 255)\n-    sprintf (mangled, \"I_%x_\", bits);\n-  else\n-    sprintf (mangled, \"I%.2x\", bits);\n-\n-  OB_PUTCP (mangled);\n-}\n-#endif\n-\n-static void\n-build_overload_value (type, value, flags)\n-     tree type, value;\n-     mangling_flags flags;\n-{\n-  my_friendly_assert (TYPE_P (type), 0);\n-\n-  while (TREE_CODE (value) == NON_LVALUE_EXPR\n-\t || TREE_CODE (value) == NOP_EXPR)\n-    value = TREE_OPERAND (value, 0);\n-\n-  if (numeric_output_need_bar)\n-    {\n-      OB_PUTC ('_');\n-      numeric_output_need_bar = 0;\n-    }\n-\n-  if (TREE_CODE (value) == TEMPLATE_PARM_INDEX)\n-    {\n-      build_mangled_template_parm_index (\"Y\", value);\n-      return;\n-    }\n-\n-  if (TYPE_PTRMEM_P (type))\n-    {\n-      if (TREE_CODE (value) != PTRMEM_CST)\n-\t/* We should have already rejected this pointer to member,\n-\t   since it is not a constant.  */\n-\tmy_friendly_abort (0);\n-\n-      /* Get the actual FIELD_DECL.  */\n-      value = PTRMEM_CST_MEMBER (value);\n-      my_friendly_assert (TREE_CODE (value) == FIELD_DECL, 0);\n-\n-      /* Output the name of the field.  */\n-      build_overload_identifier (DECL_NAME (value));\n-      return;\n-    }\n-  else if (INTEGRAL_TYPE_P (type))\n-    {\n-      build_overload_int (value, flags);\n-      return;\n-    }\n-\n-  /* The only case where we use the extra underscores here is when\n-     forming the mangling for an integral non-type template argument.\n-     If that didn't happen, stop now.  */\n-  flags &= ~mf_use_underscores_around_value;\n-\n-  switch (TREE_CODE (type))\n-    {\n-    case REAL_TYPE:\n-      {\n-\tREAL_VALUE_TYPE val;\n-\tchar *bufp = digit_buffer;\n-\n-\t/* We must handle non-constants in templates.  */\n-\tif (TREE_CODE (value) != REAL_CST)\n-\t  {\n-\t    mangle_expression (value);\n-\t    break;\n-\t  }\n-\n-\tval = TREE_REAL_CST (value);\n-\tif (REAL_VALUE_ISNAN (val))\n-\t  {\n-\t    sprintf (bufp, \"NaN\");\n-\t  }\n-\telse\n-\t  {\n-\t    if (REAL_VALUE_NEGATIVE (val))\n-\t      {\n-\t\tval = REAL_VALUE_NEGATE (val);\n-\t\t*bufp++ = 'm';\n-\t      }\n-\t    if (REAL_VALUE_ISINF (val))\n-\t      {\n-\t\tsprintf (bufp, \"Infinity\");\n-\t      }\n-\t    else\n-\t      {\n-\t\tREAL_VALUE_TO_DECIMAL (val, \"%.20e\", bufp);\n-\t\tbufp = (char *) strchr (bufp, 'e');\n-\t\tif (!bufp)\n-\t\t  strcat (digit_buffer, \"e0\");\n-\t\telse\n-\t\t  {\n-\t\t    char *p;\n-\t\t    bufp++;\n-\t\t    if (*bufp == '-')\n-\t\t      {\n-\t\t\t*bufp++ = 'm';\n-\t\t      }\n-\t\t    p = bufp;\n-\t\t    if (*p == '+')\n-\t\t      p++;\n-\t\t    while (*p == '0')\n-\t\t      p++;\n-\t\t    if (*p == 0)\n-\t\t      {\n-\t\t\t*bufp++ = '0';\n-\t\t\t*bufp = 0;\n-\t\t      }\n-\t\t    else if (p != bufp)\n-\t\t      {\n-\t\t\twhile (*p)\n-\t\t\t  *bufp++ = *p++;\n-\t\t\t*bufp = 0;\n-\t\t      }\n-\t\t  }\n-#ifdef NO_DOT_IN_LABEL\n-\t\tbufp = (char *) strchr (bufp, '.');\n-\t\tif (bufp)\n-\t\t  *bufp = '_';\n-#endif\n-\t      }\n-\t  }\n-\tOB_PUTCP (digit_buffer);\n-\tnumeric_output_need_bar = 1;\n-\treturn;\n-      }\n-    case POINTER_TYPE:\n-      if (TREE_CODE (value) == INTEGER_CST)\n-\t{\n-\t  build_overload_int (value, flags);\n-\t  return;\n-\t}\n-      else if (TREE_CODE (value) == TEMPLATE_PARM_INDEX)\n-\t{\n-\t  build_mangled_template_parm_index (\"\", value);\n-\t  numeric_output_need_bar = 1;\n-\t  return;\n-\t}\n-\n-      value = TREE_OPERAND (value, 0);\n-\n-      /* Fall through.  */\n-\n-    case REFERENCE_TYPE:\n-      if (TREE_CODE (value) == ADDR_EXPR)\n-\tvalue = TREE_OPERAND (value, 0);\n-\n-      if (TREE_CODE (value) == VAR_DECL)\n-\t{\n-\t  my_friendly_assert (DECL_NAME (value) != 0, 245);\n-\t  build_overload_identifier (DECL_ASSEMBLER_NAME (value));\n-\t  return;\n-\t}\n-      else if (TREE_CODE (value) == FUNCTION_DECL)\n-\t{\n-\t  my_friendly_assert (DECL_NAME (value) != 0, 246);\n-\t  build_overload_identifier (DECL_ASSEMBLER_NAME (value));\n-\t  return;\n-\t}\n-      else if (TREE_CODE (value) == SCOPE_REF)\n-\tbuild_overload_scope_ref (value);\n-      else\n-\tmy_friendly_abort (71);\n-      break; /* not really needed */\n-\n-    case RECORD_TYPE:\n-      {\n-\ttree delta;\n-\ttree idx;\n-\ttree pfn;\n-\ttree delta2;\n-\ttree fn;\n-\n-\tmy_friendly_assert (TYPE_PTRMEMFUNC_P (type), 0);\n-\n-\t/* We'll get a ADDR_EXPR of a SCOPE_REF here if we're\n-\t   mangling, an instantiation of something like:\n-\n-\t     template <class T, void (T::*fp)()> class C {};\n-\t     template <class T> C<T, &T::f> x();  \n-\t\n-\t   We mangle the return type of the function, and that\n-\t   contains template parameters.  */\n-\tif (TREE_CODE (value) == ADDR_EXPR\n-\t    && TREE_CODE (TREE_OPERAND (value, 0)) == SCOPE_REF)\n-\t  {\n-\t    build_overload_scope_ref (TREE_OPERAND (value, 0));\n-\t    break;\n-\t  }\n-\n-\tmy_friendly_assert (TREE_CODE (value) == PTRMEM_CST, 0);\n-\n-\texpand_ptrmemfunc_cst (value, &delta, &idx, &pfn, &delta2);\n-\tfn = PTRMEM_CST_MEMBER (value);\n-\tbuild_overload_int (delta, flags);\n-\tOB_PUTC ('_');\n-\tif (!flag_new_abi)\n-\t  {\n-\t    build_overload_int (idx, flags);\n-\t    OB_PUTC ('_');\n-\t  }\n-\telse if (DECL_VIRTUAL_P (fn))\n-\t  {\n-\t    build_overload_int (DECL_VINDEX (fn), flags);\n-\t    OB_PUTC ('_');\n-\t  }\n-\n-\tif (!DECL_VIRTUAL_P (fn))\n-\t  {\n-\t    numeric_output_need_bar = 0;\n-\t    build_overload_identifier (DECL_ASSEMBLER_NAME (fn));\n-\t  }\n-\telse if (!flag_new_abi)\n-\t  {\n-\t    OB_PUTC ('i');\n-\t    build_overload_int (delta2, flags);\n-\t  }\n-      }\n-      break;\n-      \n-    default:\n-      sorry (\"conversion of %s as template parameter\",\n-\t     tree_code_name [(int) TREE_CODE (type)]);\n-      my_friendly_abort (72);\n-    }\n-}\n-\n-\n-/* Add encodings for the declaration of template template parameters.\n-   PARMLIST must be a TREE_VEC.  */\n-\n-static void\n-build_template_template_parm_names (parmlist)\n-     tree parmlist;\n-{\n-  int i, nparms;\n-\n-  my_friendly_assert (TREE_CODE (parmlist) == TREE_VEC, 990228);\n-  nparms = TREE_VEC_LENGTH (parmlist);\n-  icat (nparms);\n-  for (i = 0; i < nparms; i++)\n-    {\n-      tree parm = TREE_VALUE (TREE_VEC_ELT (parmlist, i));\n-      if (TREE_CODE (parm) == TYPE_DECL)\n-\t{\n-\t  /* This parameter is a type.  */\n-\t  OB_PUTC ('Z');\n-\t}\n-      else if (TREE_CODE (parm) == TEMPLATE_DECL)\n-\t{\n-\t  /* This parameter is a template. */\n-\t  OB_PUTC ('z');\n-\t  build_template_template_parm_names (DECL_INNERMOST_TEMPLATE_PARMS (parm));\n-\t}\n-      else\n-\t/* It's a PARM_DECL.  */\n-\tbuild_mangled_name_for_type (TREE_TYPE (parm));\n-    }\n-}\n-\n-\n-/* Add encodings for the vector of template parameters in PARMLIST,\n-   given the vector of arguments to be substituted in ARGLIST.  */\n-\n-static void\n-build_template_parm_names (parmlist, arglist)\n-     tree parmlist;\n-     tree arglist;\n-{\n-  int i, nparms;\n-  tree inner_args = INNERMOST_TEMPLATE_ARGS (arglist);\n-\n-  nparms = TREE_VEC_LENGTH (parmlist);\n-  icat (nparms);\n-  for (i = 0; i < nparms; i++)\n-    {\n-      tree parm = TREE_VALUE (TREE_VEC_ELT (parmlist, i));\n-      tree arg = TREE_VEC_ELT (inner_args, i);\n-      if (TREE_CODE (parm) == TYPE_DECL)\n-\t{\n-\t  /* This parameter is a type.  */\n-\t  OB_PUTC ('Z');\n-\t  build_mangled_name_for_type (arg);\n-\t}\n-      else if (TREE_CODE (parm) == TEMPLATE_DECL)\n-\t{\n-\t  /* This parameter is a template.  */\n-\t  if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n-\t    /* Output parameter declaration, argument index and level.  */\n-\t    build_mangled_name_for_type (arg);\n-\t  else\n-\t    {\n-\t      /* A TEMPLATE_DECL node, output the parameter declaration \n-\t\t and template name */\n-\n-\t      OB_PUTC ('z');\n-\t      build_template_template_parm_names\n-\t\t(DECL_INNERMOST_TEMPLATE_PARMS (parm));\n-\t      icat (IDENTIFIER_LENGTH (DECL_NAME (arg)));\n-\t      OB_PUTID (DECL_NAME (arg));\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  parm = tsubst (parm, inner_args, /*complain=*/1, NULL_TREE);\n-\t  /* It's a PARM_DECL.  */\n-\t  build_mangled_name_for_type (TREE_TYPE (parm));\n-\t  build_overload_value (TREE_TYPE (parm), arg, \n-\t\t\t\t((mf_maybe_uninstantiated \n-\t\t\t\t  * uses_template_parms (arglist))\n-\t\t\t\t | mf_use_underscores_around_value));\n-\t}\n-    }\n- }\n-\n-/* Output the representation for NAME, which is either a TYPE_DECL or\n-   an IDENTIFIER.  */\n-\n-static void\n-build_overload_identifier (name)\n-     tree name;\n-{\n-  if (TREE_CODE (name) == TYPE_DECL\n-      && CLASS_TYPE_P (TREE_TYPE (name))\n-      && CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (name))\n-      && (PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (TREE_TYPE (name)))\n-\t  || (TREE_CODE (CP_DECL_CONTEXT (CLASSTYPE_TI_TEMPLATE \n-\t\t\t\t\t  (TREE_TYPE (name))))\n-\t      == FUNCTION_DECL)))\n-    {\n-      /* NAME is the TYPE_DECL for a template specialization.  */\n-      tree template, parmlist, arglist, tname;\n-      template = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (name));\n-      arglist = CLASSTYPE_TI_ARGS (TREE_TYPE (name));\n-      tname = DECL_NAME (template);\n-      parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n-      OB_PUTC ('t');\n-      icat (IDENTIFIER_LENGTH (tname));\n-      OB_PUTID (tname);\n-      build_template_parm_names (parmlist, arglist);\n-    }\n-  else\n-    {\n-      if (TREE_CODE (name) == TYPE_DECL)\n-\tname = DECL_NAME (name);\n-      if (numeric_output_need_bar)\n-\t{\n-\t  OB_PUTC ('_');\n-\t  numeric_output_need_bar = 0;\n-\t}\n-      icat (IDENTIFIER_LENGTH (name));\n-      OB_PUTID (name);\n-    }\n-}\n-\n-/* Given DECL, either a class TYPE, TYPE_DECL or FUNCTION_DECL, produce\n-   the mangling for it.  Used by build_mangled_name and build_static_name.  */\n-\n-static void\n-build_qualified_name (decl)\n-     tree decl;\n-{\n-  tree context;\n-  int i = 1;\n-\n-  if (TYPE_P (decl))\n-    decl = TYPE_NAME (decl);\n-\n-  /* If DECL_ASSEMBLER_NAME has been set properly, use it.  */\n-  if (TREE_CODE (decl) == TYPE_DECL\n-      && DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl) && !flag_do_squangling)\n-    {\n-      tree id = DECL_ASSEMBLER_NAME (decl);\n-      OB_PUTID (id);\n-      if (ISDIGIT (IDENTIFIER_POINTER (id) [IDENTIFIER_LENGTH (id) - 1]))\n-\tnumeric_output_need_bar = 1;\n-      return;\n-    }\n-\n-  context = decl;\n-  /* If we can't find a Ktype, do it the hard way.  */\n-  if (check_ktype (context, FALSE) == -1)\n-    {\n-      /* Count type and namespace scopes.  */\n-      while (1)\n-\t{\n-\t  context = CP_DECL_CONTEXT (context);\n-\t  if (context == global_namespace)\n-\t    break;\n-\t  i += 1;\n-\t  if (check_ktype (context, FALSE) != -1)\n-\t    /* Found one!  */\n-\t    break;\n-\t  if (TYPE_P (context))\n-\t    context = TYPE_NAME (context);\n-\t}\n-    }\n-\n-  if (i > 1)\n-    {\n-      OB_PUTC ('Q');\n-      build_underscore_int (i);\n-      numeric_output_need_bar = 0;\n-    }\n-  build_overload_nested_name (decl);\n-}\n-\n-/* Output the mangled representation for TYPE.  If EXTRA_GCODE is\n-   non-zero, mangled names for structure/union types are intentionally\n-   mangled differently from the method described in the ARM.  */\n-\n-static void \n-build_mangled_name_for_type_with_Gcode (type, extra_Gcode)\n-     tree type;\n-     int extra_Gcode;\n-{\n-  if (TYPE_PTRMEMFUNC_P (type))\n-    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-  process_modifiers (type);\n-  process_overload_item (type, extra_Gcode);\n-}\n-\n-/* Like build_mangled_name_for_type_with_Gcode, but never outputs the\n-   `G'.  */\n-\n-static void\n-build_mangled_name_for_type (type)\n-     tree type;\n-{\n-  build_mangled_name_for_type_with_Gcode (type, 0);\n-}\n-\n-/* Given a list of parameters in PARMTYPES, create an unambiguous\n-   overload string. Should distinguish any type that C (or C++) can\n-   distinguish. I.e., pointers to functions are treated correctly.\n-\n-   Caller must deal with whether a final `e' goes on the end or not.\n-\n-   Any default conversions must take place before this function\n-   is called.\n-\n-   BEGIN and END control initialization and finalization of the\n-   obstack where we build the string.  */\n-\n-char *\n-build_overload_name (parmtypes, begin, end)\n-     tree parmtypes;\n-     int begin, end;\n-{\n-  char *ret;\n-\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200005221);\n-\n-  start_squangling ();\n-  ret = build_mangled_name (parmtypes, begin, end);\n-  end_squangling ();\n-  return ret ;\n-}\n-\n-/* Output the mangled representation for PARMTYPES.  If PARMTYPES is a\n-   TREE_LIST, then it is a list of parameter types.  Otherwise,\n-   PARMTYPES must be a single type.  */\n-\n-static char *\n-build_mangled_name (parmtypes, begin, end)\n-     tree parmtypes;\n-     int begin, end;\n-{\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200004105);\n-\n-  if (begin) \n-    OB_INIT ();\n-\n-  if (TREE_CODE (parmtypes) != TREE_LIST)  \n-    /* There is only one type.  */\n-    build_mangled_name_for_type (parmtypes);\n-  else  \n-    {\n-      /* There are several types in a parameter list.  */\n-      int nrepeats = 0;\n-      int old_style_repeats = !flag_do_squangling && !nofold && typevec;\n-      tree last_type = NULL_TREE;\n-\n-      for (; parmtypes && parmtypes != void_list_node;\n-\t   parmtypes = TREE_CHAIN (parmtypes))\n-\t{\n-\t  /* We used to call canonical_type_variant here, but that isn't\n-\t     good enough; it doesn't handle pointers to typedef types.  So\n-\t     we can't just set TREE_USED to say we've seen a type already;\n-\t     we have to check each of the earlier types with same_type_p.  */\n-\t  tree parmtype = TREE_VALUE (parmtypes);\n-\n-\t  if (old_style_repeats)\n-\t    {\n-\t      /* Every argument gets counted.  */\n-\t      my_friendly_assert (maxtype < VARRAY_SIZE (typevec), 387);\n-\t      VARRAY_TREE (typevec, maxtype) = parmtype;\n-\t      maxtype++;\n-\t    }\n-\n-\t  if (last_type && same_type_p (parmtype, last_type))\n-\t    {\n-\t      if (flag_do_squangling \n-\t\t  || (old_style_repeats\n-\t\t      && is_back_referenceable_type (parmtype)))\n-\t\t{\n-\t\t  /* The next type is the same as this one.  Keep\n-\t\t     track of the repetition, and output the repeat\n-\t\t     count later.  */\n-\t\t  nrepeats++;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t  else if (nrepeats != 0)\n-\t    {\n-\t      /* Indicate how many times the previous parameter was\n-\t\t repeated.  */\n-\t      if (old_style_repeats)\n-\t\tflush_repeats (nrepeats, last_type);\n-\t      else\n-\t\tissue_nrepeats (nrepeats, last_type);\n-\t      nrepeats = 0;\n-\t    }\n-\t  \n-\t  /* Insead of protecting flush_repeats() against\n-\t     error_mark_node, we can do it here.  Since we wouldn't\n-\t     add anything for an ERROR_MARK anyway, it's ok to skip\n-\t     the mangling for this type.  */\n-\t  if (old_style_repeats && parmtype == error_mark_node)\n-\t    {\n-\t      last_type = NULL_TREE;\n-\t      continue;\n-\t    }\n-\n-\t  last_type = parmtype;\n-\n-\t  /* Note that for bug-compatibility with 2.7.2, we can't build up\n-\t     repeats of types other than the most recent one.  So we call\n-\t     flush_repeats every round, if we get this far.  */\n-\t  if (old_style_repeats && flush_repeats (0, parmtype))\n-\t    continue;\n-\n-\t  /* Output the PARMTYPE.  */\n-\t  build_mangled_name_for_type_with_Gcode (parmtype, 1);\n-\t}\n-\n-      /* Output the repeat count for the last parameter, if\n-\t necessary.  */\n-      if (nrepeats != 0)\n-\t{\n-\t  if (old_style_repeats)\n-\t    flush_repeats (nrepeats, last_type);\n-\t  else\n-\t    issue_nrepeats (nrepeats, last_type);\n-\t  nrepeats = 0;\n-\t}\n-\n-      if (!parmtypes)\n-\t/* The parameter list ends in an ellipsis.  */\n-\tOB_PUTC ('e');\n-    }\n-\n-  if (end) \n-    OB_FINISH ();\n-  return (char *) obstack_base (&scratch_obstack);\n-}\n-\n-/* Emit modifiers such as constant, read-only, and volatile.  */\n-\n-static void \n-process_modifiers (parmtype) \n-     tree parmtype;\n-{\n-  /* Note that here we do not use CP_TYPE_CONST_P and friends because\n-     we describe types recursively; we will get the `const' in \n-     `const int ()[10]' when processing the `const int' part.  */\n-  if (TYPE_READONLY (parmtype))\n-    OB_PUTC ('C');\n-  if (TREE_CODE (parmtype) == INTEGER_TYPE\n-      && ! same_type_p (parmtype, char_type_node)\n-      && ! same_type_p (parmtype, wchar_type_node)\n-      && (TYPE_MAIN_VARIANT (parmtype)\n-\t  == unsigned_type (TYPE_MAIN_VARIANT (parmtype)))\n-      && ! TYPE_FOR_JAVA (parmtype))\n-    OB_PUTC ('U');\n-  if (TYPE_VOLATILE (parmtype))\n-    OB_PUTC ('V');\n-  /* It would be better to use `R' for `restrict', but that's already\n-     used for reference types.  And `r' is used for `long double'.  */\n-  if (TYPE_RESTRICT (parmtype))\n-    OB_PUTC ('u');\n-}\n-\n-/* Check to see if TYPE has been entered into the Bcode typelist.  If\n-   so, return 1 and emit a backreference to TYPE.  Otherwise, add TYPE\n-   to the list of back-referenceable types and return 0.  */\n-\n-static int \n-check_btype (type) \n-     tree type;\n-{\n-  size_t x;\n-\n-  if (btypelist == NULL)\n-    return 0;\n-\n-  if (!is_back_referenceable_type (type))\n-    return 0;\n-\n-  for (x = 0; x < maxbtype; x++) \n-    if (same_type_p (type, VARRAY_TREE (btypelist, x)))\n-      {\n-\tOB_PUTC ('B');\n-\ticat (x);\n-\tif (x > 9)\n-\t  OB_PUTC ('_');\n-\treturn 1 ;\n-      }\n-\n-  if (VARRAY_SIZE (btypelist) <= maxbtype) \n-    /* Enlarge the table.  */\n-    VARRAY_GROW (btypelist,\n-\t\t VARRAY_SIZE (btypelist) * 3 / 2);\n-\n-  /* Register the TYPE.  */\n-  VARRAY_TREE (btypelist, maxbtype) = type;\n-  maxbtype++;\n-\n-  return 0;\n-}\n-\n-/* Emit the correct code for various node types.  */\n+/* Called once to initialize method.c.  */\n \n-static void \n-process_overload_item (parmtype, extra_Gcode) \n-  tree parmtype;\n-  int extra_Gcode;\n+void\n+init_method ()\n {\n-  tree tmp;\n-\n-  numeric_output_need_bar = 0;\n-\n-  /* Our caller should have already handed any qualifiers, so pull out the\n-     TYPE_MAIN_VARIANT to avoid typedef confusion.  Except we can't do that\n-     for arrays, because they are transparent to qualifiers.  Sigh.  */\n-  if (TREE_CODE (parmtype) == ARRAY_TYPE)\n-    parmtype = canonical_type_variant (parmtype);\n-  else\n-    parmtype = TYPE_MAIN_VARIANT (parmtype);\n-\n-  /* These tree types are considered modifiers for B code squangling,\n-     and therefore should not get entries in the Btypelist.  They are,\n-     however, repeatable types.  */\n-\n-  switch (TREE_CODE (parmtype))\n-    {\n-    case REFERENCE_TYPE:\n-      OB_PUTC ('R');\n-      goto more;\n-\n-    case ARRAY_TYPE:\n-      {\n-        OB_PUTC ('A');\n-        if (TYPE_DOMAIN (parmtype) == NULL_TREE)\n-\t  OB_PUTC ('_');\n-        else\n-\t  {\n-\t    tree length = array_type_nelts (parmtype);\n-\t    if (TREE_CODE (length) != INTEGER_CST || flag_do_squangling)\n-\t      {\n-\t\tif (TREE_CODE (length) == MINUS_EXPR\n-\t\t    && TREE_OPERAND (length, 1) == integer_one_node)\n-\t\t  length = TREE_OPERAND (length, 0);\n-\t\telse\n-\t\t  length = fold (build (PLUS_EXPR, TREE_TYPE (length),\n-\t\t\t\t\tlength, integer_one_node));\n-\t\tSTRIP_NOPS (length);\n-\t      }\n-\t    build_overload_value (sizetype, length, 1);\n-\t  }\n-\tif (numeric_output_need_bar && ! flag_do_squangling)\n-\t  OB_PUTC ('_');\n-        goto more;\n-      }\n-\n-    case POINTER_TYPE:\n-      OB_PUTC ('P');\n-    more:\n-      build_mangled_name_for_type (TREE_TYPE (parmtype));\n-      return;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-  \n-  if (flag_do_squangling && check_btype (parmtype)) \n-    /* If PARMTYPE is already in the list of back-referenceable types,\n-       then check_btype will output the appropriate reference, and\n-       there's nothing more to do.  */\n-    return;\n-\n-  switch (TREE_CODE (parmtype))\n-    {\n-    case OFFSET_TYPE:\n-      OB_PUTC ('O');\n-      build_mangled_name_for_type (TYPE_OFFSET_BASETYPE (parmtype));\n-      OB_PUTC ('_');\n-      build_mangled_name_for_type (TREE_TYPE (parmtype));\n-      break;\n-\n-    case FUNCTION_TYPE:\n-    case METHOD_TYPE:\n-      {\n-        tree parms = TYPE_ARG_TYPES (parmtype);\n-\n-\t/* Rather than implementing a reentrant TYPEVEC, we turn off\n-\t   repeat codes here, unless we're squangling.  Squangling\n-\t   doesn't make use of the TYPEVEC, so there's no reentrancy\n-\t   problem.  */\n-\tint old_nofold = nofold;\n-\tif (!flag_do_squangling)\n-\t  nofold = 1;\n-\n-\tif (TREE_CODE (parmtype) == METHOD_TYPE)\n-\t  {\n-\t    /* Mark this as a method.  */\n-            OB_PUTC ('M');\n-\t    /* Output the class of which this method is a member.  */\n-            build_mangled_name_for_type (TYPE_METHOD_BASETYPE (parmtype));\n-\t    /* Output any qualifiers for the `this' parameter.  */\n-\t    process_modifiers (TREE_TYPE (TREE_VALUE (parms)));\n-\t  }\n-\n-\t/* Output the parameter types.  */\n-\tOB_PUTC ('F');\n-\tif (parms == NULL_TREE)\n-\t  OB_PUTC ('e');\n-\telse if (parms == void_list_node)\n-\t  OB_PUTC ('v');\n-\telse\n-\t  build_mangled_name (parms, 0, 0);\n-\n-        /* Output the return type.  */\n-        OB_PUTC ('_');\n-        build_mangled_name_for_type (TREE_TYPE (parmtype));\n-\n-        nofold = old_nofold;\n-        break;\n-      }\n-\n-    case INTEGER_TYPE:\n-    iagain:\n-      if (parmtype == integer_type_node\n-          || parmtype == unsigned_type_node\n-\t  || parmtype == java_int_type_node)\n-        OB_PUTC ('i');\n-      else if (parmtype == long_integer_type_node\n-               || parmtype == long_unsigned_type_node)\n-        OB_PUTC ('l');\n-      else if (parmtype == short_integer_type_node\n-               || parmtype == short_unsigned_type_node\n-\t       || parmtype == java_short_type_node)\n-        OB_PUTC ('s');\n-      else if (parmtype == signed_char_type_node)\n-        {\n-          OB_PUTC ('S');\n-          OB_PUTC ('c');\n-        }\n-      else if (parmtype == char_type_node\n-               || parmtype == unsigned_char_type_node\n-\t       || parmtype == java_byte_type_node)\n-        OB_PUTC ('c');\n-      else if (parmtype == wchar_type_node\n-\t       || parmtype == java_char_type_node)\n-        OB_PUTC ('w');\n-      else if (parmtype == long_long_integer_type_node\n-\t       || parmtype == long_long_unsigned_type_node\n-\t       || parmtype == java_long_type_node)\n-        OB_PUTC ('x');\n-      else if (parmtype == java_boolean_type_node)\n-\tOB_PUTC ('b');\n-      /* Handle intSI_type_node and such like their C++ equivalents.  */\n-      else if (tmp = type_for_mode (TYPE_MODE (parmtype),\n-\t\t\t\t    TREE_UNSIGNED (parmtype)),\n-\t       parmtype != tmp)\n-\t{\n-\t  parmtype = tmp;\n-\t  goto iagain;\n-\t}\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-      else\n-\t{\n-\t  int bits = TREE_INT_CST_LOW (TYPE_SIZE (parmtype));\n-\t  build_mangled_C99_name (bits);\n-\t}\n-#else\n-      else\n-\tmy_friendly_abort (73);\n-#endif\n-      break;\n-\n-    case BOOLEAN_TYPE:\n-      OB_PUTC ('b');\n-      break;\n-\n-    case REAL_TYPE:\n-      if (parmtype == long_double_type_node)\n-        OB_PUTC ('r');\n-      else if (parmtype == double_type_node\n-\t       || parmtype == java_double_type_node)\n-        OB_PUTC ('d');\n-      else if (parmtype == float_type_node\n-\t       || parmtype == java_float_type_node)\n-        OB_PUTC ('f');\n-      else my_friendly_abort (74);\n-      break;\n-\n-    case COMPLEX_TYPE:\n-      OB_PUTC ('J');\n-      build_mangled_name_for_type (TREE_TYPE (parmtype));\n-      break;\n-\n-    case VECTOR_TYPE:\n-      OB_PUTC ('o');\n-      build_mangled_name_for_type (TREE_TYPE (parmtype));\n-      break;\n-\n-    case VOID_TYPE:\n-      OB_PUTC ('v');\n-      break;\n-\n-    case ERROR_MARK:\t/* not right, but nothing is anyway */\n-      break;\n-\n-      /* have to do these */\n-    case UNION_TYPE:\n-    case RECORD_TYPE:\n-      {   \n-        if (extra_Gcode)\n-          OB_PUTC ('G');       /* make it look incompatible with AT&T */\n-        /* drop through into next case */\n-      }\n-    case ENUMERAL_TYPE:\n-      {\n-        tree name = TYPE_NAME (parmtype);\n-\n-        my_friendly_assert (TREE_CODE (name) == TYPE_DECL, 248);\n-\n-        build_qualified_name (name);\n-        break;\n-      }\n-\n-    case UNKNOWN_TYPE:\n-      /* This will take some work.  */\n-      OB_PUTC ('?');\n-      break;\n-\n-    case BOUND_TEMPLATE_TEMPLATE_PARM:\n-      /* Find and output the original template parameter \n-         declaration. */\n-      build_mangled_template_parm_index (\"tzX\",\n-\t\t\t\t\t TEMPLATE_TYPE_PARM_INDEX \n-\t\t\t\t\t (parmtype));\n-      build_template_parm_names\n-\t(DECL_INNERMOST_TEMPLATE_PARMS (TYPE_TI_TEMPLATE (parmtype)),\n-\t TYPE_TI_ARGS (parmtype));\n-      break;\n-\n-    case TEMPLATE_TEMPLATE_PARM:\n-      build_mangled_template_parm_index (\"ZzX\",\n-\t\t\t\t\t TEMPLATE_TYPE_PARM_INDEX \n-\t\t\t\t\t (parmtype));\n-      build_template_template_parm_names\n-\t(DECL_INNERMOST_TEMPLATE_PARMS (TYPE_STUB_DECL (parmtype)));\n-      break;\n-\n-    case TEMPLATE_TYPE_PARM:\n-      build_mangled_template_parm_index (\"X\", \n-\t\t\t\t\t TEMPLATE_TYPE_PARM_INDEX\n-\t\t\t\t\t (parmtype));\n-      break;\n-        \n-    case TYPENAME_TYPE:\n-      /* When mangling the type of a function template whose\n-         declaration looks like:\n-\n-         template <class T> void foo(typename T::U)\n-         \n-         we have to mangle these.  */\n-      build_qualified_name (parmtype);\n-      break;\n-\n-    default:\n-      my_friendly_abort (75);\n-    }\n-\n+  init_mangle ();\n }\n \n-/* Produce the mangling for a variable named NAME in CONTEXT, which can\n-   be either a class TYPE or a FUNCTION_DECL.  */\n-\n-tree\n-build_static_name (context, name)\n-     tree context, name;\n-{\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200004106);\n-\n-  OB_INIT ();\n-  numeric_output_need_bar = 0;\n-  start_squangling ();\n-#ifdef JOINER\n-  OB_PUTC ('_');\n-  build_qualified_name (context);\n-  OB_PUTC (JOINER);\n-#else\n-  OB_PUTS (\"__static_\");\n-  build_qualified_name (context);\n-  OB_PUTC ('_');\n-#endif\n-  OB_PUTID (name);\n-  OB_FINISH ();\n-  end_squangling ();\n-\n-  return get_identifier ((char *)obstack_base (&scratch_obstack));\n-}\n \f\n-/* FOR_METHOD should be 1 if the declaration in question is for a member\n-   of a class (including a static member) and 2 if the declaration is\n-   for a constructor.  */\n-tree \n-build_decl_overload_real (decl, parms, ret_type, tparms, targs,\n-\t\t\t  for_method) \n-     tree decl;\n-     tree parms;\n-     tree ret_type;\n-     tree tparms;\n-     tree targs;\n-     int for_method;\n-{\n-  const char *name;\n-  enum tree_code operator_code;\n-\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 20000410);\n-\n-  operator_code = DECL_OVERLOADED_OPERATOR_P (decl);\n-  if (!DECL_CONV_FN_P (decl) && operator_code)\n-    {\n-      /* member operators new and delete look like methods at this\n-         point.  */\n-      if (! for_method && CP_DECL_CONTEXT (decl) == global_namespace\n-\t  && parms != NULL_TREE && TREE_CODE (parms) == TREE_LIST\n-\t  && TREE_CHAIN (parms) == void_list_node)\n-\tswitch (operator_code)\n-\t  {\n-\t  case DELETE_EXPR:\n-\t    return get_identifier (\"__builtin_delete\");\n-\t  case VEC_DELETE_EXPR:\n-\t    return get_identifier (\"__builtin_vec_delete\");\n-\t  case NEW_EXPR:\n-\t    return get_identifier (\"__builtin_new\");\n-\t  case VEC_NEW_EXPR:\n-\t    return get_identifier (\"__builtin_vec_new\");\n-\t  default:\n-\t    break;\n-\t  }\n-\n-      if (DECL_ASSIGNMENT_OPERATOR_P (decl))\n-\tname = assignment_operator_name_info[(int) operator_code].mangled_name;\n-      else\n-\tname = operator_name_info[(int) operator_code].mangled_name;\n-    }\n-  else\n-    name = IDENTIFIER_POINTER (DECL_NAME (decl));\n-\n-  start_squangling ();\n-  OB_INIT ();\n-  if (for_method != 2)\n-    OB_PUTCP (name);\n-  /* Otherwise, we can divine that this is a constructor,\n-     and figure out its name without any extra encoding.  */\n-\n-  OB_PUTC2 ('_', '_');\n-  numeric_output_need_bar = 0;\n-\n-  if (tparms)\n-    {\n-      OB_PUTC ('H');\n-      build_template_parm_names (tparms, targs);\n-      OB_PUTC ('_');\n-    }\n-  else if (!for_method && CP_DECL_CONTEXT (decl) == global_namespace)\n-    OB_PUTC ('F');\n-\n-  if (!for_method && CP_DECL_CONTEXT (decl) != global_namespace)\n-    /* qualify with namespace */\n-    build_qualified_name (CP_DECL_CONTEXT (decl));\n-\n-  if (parms == NULL_TREE)\n-    OB_PUTC ('e');\n-  else if (parms == void_list_node)\n-    OB_PUTC ('v');\n-  else\n-    {\n-      if (!flag_do_squangling)\n-        {\n-\t  /* Allocate typevec array.  */\n-\t  size_t typevec_size = list_length (parms);\n-          maxtype = 0;\n-\t  if (!for_method && CP_DECL_CONTEXT (decl) != global_namespace)\n-\t    /* The namespace of a global function needs one slot.  */\n-\t    typevec_size++;\n-\t  VARRAY_TREE_INIT (typevec, typevec_size, \"typevec\");\n-        }\n-      nofold = 0;\n-\n-      if (for_method)\n-\t{\n-\t  tree this_type = TREE_TYPE (TREE_VALUE (parms));\n-\n-\t  build_mangled_name_for_type (this_type);\n-\n-          if (!flag_do_squangling) \n-\t    {\n-\t      my_friendly_assert (maxtype < VARRAY_SIZE (typevec), 387);\n-\t      VARRAY_TREE (typevec, maxtype) = this_type;\n-\t      maxtype++;\n-\t    }\n-\n-\t  if (TREE_CHAIN (parms))\n-\t    build_mangled_name (TREE_CHAIN (parms), 0, 0);\n-\t  else\n-\t    OB_PUTC ('e');\n-\t}\n-      else\n-\t{\n-\t  /* the namespace qualifier for a global function \n-\t     will count as type */\n-\t  if (CP_DECL_CONTEXT (decl) != global_namespace\n-\t      && !flag_do_squangling)\n-\t    {\n-\t      my_friendly_assert (maxtype < VARRAY_SIZE (typevec), 387);\n-\t      VARRAY_TREE (typevec, maxtype) = CP_DECL_CONTEXT (decl);\n-\t      maxtype++;\n-\t    }\n-\t  build_mangled_name (parms, 0, 0);\n-\t}\n-\n-      if (!flag_do_squangling)\n-\t/* Deallocate typevec array.  */\n-\tVARRAY_FREE (typevec);\n-    }\n-\n-  if (ret_type != NULL_TREE && for_method != 2)\n-    {\n-      /* Add the return type. */\n-      OB_PUTC ('_');\n-      build_mangled_name_for_type (ret_type);\n-    }\n-\n-  OB_FINISH ();\n-  end_squangling ();\n-  {\n-    tree n = get_identifier (obstack_base (&scratch_obstack));\n-    return n;\n-  }\n-}\n-\n /* Set the mangled name (DECL_ASSEMBLER_NAME) for DECL.  */\n \n void\n set_mangled_name_for_decl (decl)\n      tree decl;\n {\n-  tree parm_types;\n-\n   if (processing_template_decl)\n     /* There's no need to mangle the name of a template function.  */\n     return;\n \n-  if (flag_new_abi)\n-    {\n-      DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n-      return;\n-    }\n-\n-  if (DECL_EXTERN_C_P (decl))\n-    {\n-      /* In extern \"C\" we have to mangle at least overloaded operators,\n-\t because they contain characters invalid in assembler.  */\n-      enum tree_code code = DECL_OVERLOADED_OPERATOR_P (decl);\n-      const char *name;\n-\n-      if (code)\n-\t{\n-\t  if (DECL_ASSIGNMENT_OPERATOR_P (decl))\n-\t    name = assignment_operator_name_info[(int) code].mangled_name;\n-\t  else\n-\t    name = operator_name_info[(int) code].mangled_name;\n-\t  DECL_ASSEMBLER_NAME (decl) = get_identifier (name);\n-\t  return;\n-\t}\n-    }\n-\n-  parm_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-\n-  if (DECL_STATIC_FUNCTION_P (decl))\n-    parm_types = \n-      hash_tree_chain (build_pointer_type (DECL_CONTEXT (decl)),\n-\t\t\t\t\t   parm_types);\n-  else\n-    /* The only member functions whose type is a FUNCTION_TYPE, rather\n-       than a METHOD_TYPE, should be static members.  */\n-    my_friendly_assert (!DECL_CONTEXT (decl)\n-\t\t\t|| !IS_AGGR_TYPE_CODE (TREE_CODE (DECL_CONTEXT (decl)))\n-\t\t\t|| TREE_CODE (TREE_TYPE (decl)) != FUNCTION_TYPE,\n-\t\t\t0);\n-\n-  DECL_ASSEMBLER_NAME (decl)\n-    = build_decl_overload_real (decl, parm_types, NULL_TREE,\n-\t\t\t\tNULL_TREE, NULL_TREE,\n-\t\t\t\tDECL_FUNCTION_MEMBER_P (decl)\n-\t\t\t\t+ DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl));\n-}\n-\n-/* Build an overload name for the type expression TYPE.  */\n-\n-tree\n-build_typename_overload (type)\n-     tree type;\n-{\n-  tree id;\n-\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200004108);\n-\n-  OB_INIT ();\n-  OB_PUTS (OPERATOR_TYPENAME_FORMAT);\n-  nofold = 1;\n-  start_squangling ();\n-  build_mangled_name (type, 0, 1);\n-  id = get_identifier (obstack_base (&scratch_obstack));\n-  IDENTIFIER_OPNAME_P (id) = 1;\n-  IDENTIFIER_TYPENAME_P (id) = 1;\n-  TREE_TYPE (id) = type;\n-  end_squangling ();\n-  return id;\n-}\n-\n-tree\n-build_overload_with_type (name, type)\n-     tree name, type;\n-{\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200004109);\n-\n-  OB_INIT ();\n-  OB_PUTID (name);\n-  nofold = 1;\n-\n-  start_squangling ();\n-  build_mangled_name (type, 0, 1);\n-  end_squangling ();\n-  return get_identifier (obstack_base (&scratch_obstack));\n-}\n-\n-tree\n-get_id_2 (name, name2)\n-     const char *name;\n-     tree name2;\n-{\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 20000411);\n-\n-  OB_INIT ();\n-  OB_PUTCP (name);\n-  OB_PUTID (name2);\n-  OB_FINISH ();\n-  return get_identifier (obstack_base (&scratch_obstack));\n-}\n-\n-/* Returns the name of a construction vtable group.  TYPE is the most\n-   derived class in the hierarhcy.  BINFO is the most derived class in\n-   the construction vtable group.  */\n-\n-tree\n-get_ctor_vtbl_name (type, binfo)\n-     tree type;\n-     tree binfo;\n-{\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200005220);\n-\n-  start_squangling ();\n-  OB_INIT ();\n-  OB_PUTCP (CTOR_VTBL_NAME_PREFIX);\n-  build_mangled_name (type, 0, 0);\n-  OB_PUTC ('_');\n-  build_mangled_name (BINFO_TYPE (binfo), 0, 0);\n-  OB_PUTC ('_');\n-  build_overload_int (BINFO_OFFSET (binfo), mf_none);\n-  OB_FINISH ();\n-  end_squangling ();\n-  return get_identifier (obstack_base (&scratch_obstack));\n+  DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n }\n \n-/* Returns a DECL_ASSEMBLER_NAME for the destructor of type TYPE.  */\n-\n-tree\n-build_destructor_name (type)\n-     tree type;\n-{\n-  return build_overload_with_type (get_identifier (DESTRUCTOR_DECL_PREFIX),\n-\t\t\t\t   type);\n-}\n \f\n /* Given a tree_code CODE, and some arguments (at least one),\n    attempt to use an overloaded operator on the arguments.\n@@ -2145,31 +332,8 @@ make_thunk (function, delta, vcall_index, generate_with_vtable_p)\n   if (TREE_CODE (func_decl) != FUNCTION_DECL)\n     abort ();\n \n-  if (flag_new_abi) \n-    thunk_id = mangle_thunk (TREE_OPERAND (function, 0), \n-\t\t\t     delta, vcall_offset);\n-  else\n-    {\n-      OB_INIT ();\n-      OB_PUTS (\"__thunk_\");\n-      if (d > 0)\n-\t{\n-\t  OB_PUTC ('n');\n-\t  icat (d);\n-\t}\n-      else\n-\ticat (-d);\n-      OB_PUTC ('_');\n-      if (vcall_index)\n-\t{\n-\t  icat (tree_low_cst (vcall_index, 0));\n-\t  OB_PUTC ('_');\n-\t}\n-      OB_PUTID (DECL_ASSEMBLER_NAME (func_decl));\n-      OB_FINISH ();\n-      thunk_id = get_identifier (obstack_base (&scratch_obstack));\n-    }\n-\n+  thunk_id = mangle_thunk (TREE_OPERAND (function, 0), \n+\t\t\t   delta, vcall_offset);\n   thunk = IDENTIFIER_GLOBAL_VALUE (thunk_id);\n   if (thunk && !DECL_THUNK_P (thunk))\n     {"}, {"sha": "c6d43b9991f48d06ce56223dae94d3d3498795f6", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -1,5 +1,5 @@\n /* Perform optimizations on tree structure.\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Written by Mark Michell (mark@codesourcery.com).\n \n This file is part of GNU CC.\n@@ -914,10 +914,6 @@ maybe_clone_body (fn)\n   inline_data id;\n   tree clone;\n \n-  /* We don't clone constructors and destructors under the old ABI.  */\n-  if (!flag_new_abi)\n-    return 0;\n-\n   /* We only clone constructors and destructors.  */\n   if (!DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn)\n       && !DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn))"}, {"sha": "aa77e638636f70c3934ec39039e1ac9bb46429db", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 103, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -4222,11 +4222,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n       DECL_ASSEMBLER_NAME (type_decl) = DECL_NAME (type_decl);\n       if (!is_partial_instantiation)\n \t{\n-\t  if (flag_new_abi)\n-\t    DECL_ASSEMBLER_NAME (type_decl) = mangle_decl (type_decl);\n-\t  else\n-\t    DECL_ASSEMBLER_NAME (type_decl)\n-\t      = get_identifier (build_overload_name (t, 1, 1));\n+\t  DECL_ASSEMBLER_NAME (type_decl) = mangle_decl (type_decl);\n \n \t  /* For backwards compatibility; code that uses\n \t     -fexternal-templates expects looking up a template to\n@@ -5817,14 +5813,9 @@ tsubst_decl (t, args, type)\n \t\t\t      /*entering_scope=*/1);\n \n \tif (member && DECL_CONV_FN_P (r)) \n-\t  {\n-\t    /* Type-conversion operator.  Reconstruct the name, in\n-\t       case it's the name of one of the template's parameters.  */\n-\t    if (flag_new_abi)\n-\t      DECL_NAME (r) = mangle_conv_op_name_for_type (TREE_TYPE (type));\n-\t    else\n-\t      DECL_NAME (r) = build_typename_overload (TREE_TYPE (type));\n-\t  }\n+\t  /* Type-conversion operator.  Reconstruct the name, in\n+\t     case it's the name of one of the template's parameters.  */\n+\t  DECL_NAME (r) = mangle_conv_op_name_for_type (TREE_TYPE (type));\n \n \tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args,\n \t\t\t\t     /*complain=*/1, t);\n@@ -5860,12 +5851,7 @@ tsubst_decl (t, args, type)\n \n \t    /* Set the mangled name for R.  */\n \t    if (DECL_DESTRUCTOR_P (t)) \n-\t      {\n-\t\tif (flag_new_abi)\n-\t\t  set_mangled_name_for_decl (r);\n-\t\telse\n-\t\t  DECL_ASSEMBLER_NAME (r) = build_destructor_name (ctx);\n-\t      }\n+\t      set_mangled_name_for_decl (r);\n \t    else \n \t      {\n \t\t/* Instantiations of template functions must be mangled\n@@ -7223,10 +7209,7 @@ tsubst_copy (t, args, complain, in_decl)\n       if (IDENTIFIER_TYPENAME_P (t))\n \t{\n \t  tree new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n-\t  if (flag_new_abi)\n-\t    return mangle_conv_op_name_for_type (new_type);\n-\t  else\n-\t    return (build_typename_overload (new_type));\n+\t  return mangle_conv_op_name_for_type (new_type);\n \t}\n       else\n \treturn t;\n@@ -10321,90 +10304,11 @@ static void\n set_mangled_name_for_template_decl (decl)\n      tree decl;\n {\n-  tree context = NULL_TREE;\n-  tree fn_type;\n-  tree ret_type;\n-  tree parm_types;\n-  tree tparms;\n-  tree targs;\n-\n   my_friendly_assert (TREE_CODE (decl) == FUNCTION_DECL, 0);\n   my_friendly_assert (DECL_TEMPLATE_INFO (decl) != NULL_TREE, 0);\n \n   /* Under the new ABI, we don't need special machinery.  */\n-  if (flag_new_abi)\n-    {\n-      set_mangled_name_for_decl (decl);\n-      return;\n-    }\n-\n-  /* The names of template functions must be mangled so as to indicate\n-     what template is being specialized with what template arguments.\n-     For example, each of the following three functions must get\n-     different mangled names:\n-\n-       void f(int);                  \n-       template <> void f<7>(int);\n-       template <> void f<8>(int);  */\n-\n-  targs = DECL_TI_ARGS (decl);\n-  if (uses_template_parms (targs))\n-    /* This DECL is for a partial instantiation.  There's no need to\n-       mangle the name of such an entity.  */\n-    return;\n-\n-  /* We now compute the PARMS and RET_TYPE to give to\n-     build_decl_overload_real.  The PARMS and RET_TYPE are the\n-     parameter and return types of the template, after all but the\n-     innermost template arguments have been substituted, not the\n-     parameter and return types of the function DECL.  For example,\n-     given:\n-\n-       template <class T> T f(T);\n-\n-     both PARMS and RET_TYPE should be `T' even if DECL is `int f(int)'.  \n-     A more subtle example is:\n-\n-       template <class T> struct S { template <class U> void f(T, U); }\n-\n-     Here, if DECL is `void S<int>::f(int, double)', PARMS should be\n-     {int, U}.  Thus, the args that we want to subsitute into the\n-     return and parameter type for the function are those in TARGS,\n-     with the innermost level omitted.  */\n-  fn_type = get_mostly_instantiated_function_type (decl, &context, &tparms);\n-\n-  /* Now, get the innermost parameters and arguments, and figure out\n-     the parameter and return types.  */\n-  tparms = INNERMOST_TEMPLATE_PARMS (tparms);\n-  targs = INNERMOST_TEMPLATE_ARGS (targs);\n-  ret_type = TREE_TYPE (fn_type);\n-  parm_types = TYPE_ARG_TYPES (fn_type);\n-\n-  /* For a static member function, we generate a fake `this' pointer,\n-     for the purposes of mangling.  This indicates of which class the\n-     function is a member.  Because of:\n-\n-       [class.static] \n-\n-       There shall not be a static and a nonstatic member function\n-       with the same name and the same parameter types\n-\n-     we don't have to worry that this will result in a clash with a\n-     non-static member function.  */\n-  if (DECL_STATIC_FUNCTION_P (decl))\n-    parm_types = hash_tree_chain (build_pointer_type (context), parm_types);\n-\n-  /* There should be the same number of template parameters as\n-     template arguments.  */\n-  my_friendly_assert (TREE_VEC_LENGTH (tparms) == TREE_VEC_LENGTH (targs),\n-\t\t      0);\n-\n-  /* Actually set the DECL_ASSEMBLER_NAME.  */\n-  DECL_ASSEMBLER_NAME (decl)\n-    = build_decl_overload_real (decl, parm_types, ret_type,\n-\t\t\t\ttparms, targs, \n-\t\t\t\tDECL_FUNCTION_MEMBER_P (decl) \n-\t\t\t        + DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl));\n+  set_mangled_name_for_decl (decl);\n }\n \n /* Return truthvalue if we're processing a template different from"}, {"sha": "e86e1f0805b77cbcc8d04181945f22cced233ab6", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -1,5 +1,5 @@\n /* Code to maintain a C++ template repository.\n-   Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Jason Merrill (jason@cygnus.com)\n \n This file is part of GNU CC.\n@@ -107,25 +107,6 @@ repo_get_id (t)\n \n       vtable = get_vtbl_decl_for_binfo (TYPE_BINFO (t));\n \n-      /* If we don't have a primary vtable, try looking for a secondary\n-\t vtable.  */\n-      if (vtable == NULL_TREE && !flag_new_abi\n-\t  && TYPE_USES_VIRTUAL_BASECLASSES (t))\n-\t{\n-\t  tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n-\t  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\t  for (i = 0; i < n_baselinks; ++i)\n-\t    {\n-\t      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\t      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t\t{\n-\t\t  vtable = get_vtbl_decl_for_binfo (base_binfo);\n-\t\t  if (vtable)\n-\t\t    break;\n-\t\t}\n-\t    }\n-\t}\n-\n       t = vtable;\n       if (t == NULL_TREE)\n \treturn t;"}, {"sha": "b1acc5eb85f19dd6ab90a39ceb9c4eab9ce557b1", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 16, "deletions": 469, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -43,16 +43,10 @@ extern struct obstack permanent_obstack;\n \n static tree build_headof_sub PARAMS((tree));\n static tree build_headof PARAMS((tree));\n-static tree get_tinfo_var PARAMS((tree));\n static tree ifnonnull PARAMS((tree, tree));\n static tree tinfo_name PARAMS((tree));\n static tree get_base_offset PARAMS((tree, tree));\n static tree build_dynamic_cast_1 PARAMS((tree, tree));\n-static void expand_si_desc PARAMS((tree, tree));\n-static void expand_class_desc PARAMS((tree, tree));\n-static void expand_attr_desc PARAMS((tree, tree));\n-static void expand_ptr_desc PARAMS((tree, tree));\n-static void expand_generic_desc PARAMS((tree, tree, const char *));\n static tree throw_bad_cast PARAMS((void));\n static tree throw_bad_typeid PARAMS((void));\n static tree get_tinfo_decl_dynamic PARAMS((tree));\n@@ -182,9 +176,7 @@ build_headof (exp)\n static tree\n throw_bad_cast ()\n {\n-  tree fn = get_identifier (flag_new_abi \n-\t\t\t    ? \"__cxa_bad_cast\" : \n-\t\t\t    \"__throw_bad_cast\");\n+  tree fn = get_identifier (\"__cxa_bad_cast\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))\n     fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n@@ -197,9 +189,7 @@ throw_bad_cast ()\n static tree\n throw_bad_typeid ()\n {\n-  tree fn = get_identifier (flag_new_abi \n-\t\t\t    ? \"__cxa_bad_typeid\"\n-\t\t\t    : \"__throw_bad_typeid\");\n+  tree fn = get_identifier (\"__cxa_bad_typeid\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))\n     fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n@@ -330,49 +320,6 @@ build_typeid (exp)\n   return convert_from_reference (exp);\n }\n \n-static tree\n-get_tinfo_var (type)\n-     tree type;\n-{\n-  tree tname = build_overload_with_type (tinfo_var_id, type);\n-  tree arrtype;\n-  int size;\n-\n-  my_friendly_assert (!new_abi_rtti_p (), 20000118);\n-  if (IDENTIFIER_GLOBAL_VALUE (tname))\n-    return IDENTIFIER_GLOBAL_VALUE (tname);\n-    \n-  /* Figure out how much space we need to allocate for the type_info object.\n-     If our struct layout or the type_info classes are changed, this will\n-     need to be modified.  */\n-  if (TYPE_QUALS (type) != TYPE_UNQUALIFIED)\n-    size = 3 * POINTER_SIZE + INT_TYPE_SIZE;\n-  else if (TREE_CODE (type) == POINTER_TYPE\n-\t   && ! (TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE\n-\t\t || TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE))\n-    size = 3 * POINTER_SIZE;\n-  else if (IS_AGGR_TYPE (type))\n-    {\n-      if (CLASSTYPE_N_BASECLASSES (type) == 0)\n-\tsize = 2 * POINTER_SIZE;\n-      else if (! TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (type)\n-\t       && (TREE_VIA_PUBLIC\n-\t\t   (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), 0))))\n-\tsize = 3 * POINTER_SIZE;\n-      else\n-\tsize = 3 * POINTER_SIZE + TYPE_PRECISION (sizetype);\n-    }\n-  else\n-    size = 2 * POINTER_SIZE;\n-\n-  /* The type for a character array of the appropriate size.  */\n-  arrtype = build_cplus_array_type\n-    (unsigned_char_type_node,\n-     build_index_type (size_int (size / BITS_PER_UNIT - 1)));\n-\n-  return declare_global_var (tname, arrtype);\n-}\n-\n /* Generate the NTBS name of a type.  */\n static tree\n tinfo_name (type)\n@@ -381,10 +328,7 @@ tinfo_name (type)\n   const char *name;\n   tree name_string;\n \n-  if (flag_new_abi)\n-    name = mangle_type_string (type);\n-  else\n-    name = build_overload_name (type, 1, 1);\n+  name = mangle_type_string (type);\n   name_string = combine_strings (build_string (strlen (name) + 1, name));\n   return name_string;\n }\n@@ -410,24 +354,11 @@ get_tinfo_decl (type)\n     type = build_function_type (TREE_TYPE (type),\n \t\t\t\tTREE_CHAIN (TYPE_ARG_TYPES (type)));\n \n-  if (flag_new_abi)\n-    name = mangle_typeinfo_for_type (type);\n-  else\n-    name = build_overload_with_type (tinfo_decl_id, type);\n+  name = mangle_typeinfo_for_type (type);\n \n   d = IDENTIFIER_GLOBAL_VALUE (name);\n   if (d)\n     /* OK */;\n-  else if (!new_abi_rtti_p ())\n-    {\n-      /* The tinfo decl is a function returning a reference to the\n-\t type_info object.  */\n-      d = push_library_fn (name, tinfo_decl_type);\n-      DECL_NOT_REALLY_EXTERN (d) = 1;\n-      SET_DECL_TINFO_FN_P (d);\n-      TREE_TYPE (name) = type;\n-      defer_fn (d);\n-    }\n   else\n     {\n       /* The tinfo decl is the type_info object itself.  We make all\n@@ -889,381 +820,6 @@ build_dynamic_cast (type, expr)\n   return convert_from_reference (build_dynamic_cast_1 (type, expr));\n }\n \f\n-/* Build and initialize various sorts of descriptors.  Every descriptor\n-   node has a name associated with it (the name created by mangling).\n-   For this reason, we use the identifier as our access to the __*_desc\n-   nodes, instead of sticking them directly in the types.  Otherwise we\n-   would burden all built-in types (and pointer types) with slots that\n-   we don't necessarily want to use.\n-\n-   For each descriptor we build, we build a variable that contains\n-   the descriptor's information.  When we need this info at runtime,\n-   all we need is access to these variables.\n-\n-   Note: these constructors always return the address of the descriptor\n-   info, since that is simplest for their mutual interaction.  */\n-\n-/* Build an initializer for a __si_type_info node.  */\n-\n-static void\n-expand_si_desc (tdecl, type)\n-     tree tdecl;\n-     tree type;\n-{\n-  tree t, elems, fn;\n-  tree name_string = tinfo_name (type);\n-\n-  type = BINFO_TYPE (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), 0));\n-  finish_expr_stmt (get_typeid_1 (type));\n-  t = decay_conversion (get_tinfo_var (type));\n-  elems = tree_cons\n-    (NULL_TREE, decay_conversion (tdecl), tree_cons\n-     (NULL_TREE, decay_conversion (name_string), tree_cons\n-      (NULL_TREE, t, NULL_TREE)));\n-\n-  fn = get_identifier (\"__rtti_si\");\n-  if (IDENTIFIER_GLOBAL_VALUE (fn))\n-    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n-  else\n-    {\n-      tree tmp;\n-      tmp = tree_cons\n-\t(NULL_TREE, ptr_type_node, tree_cons\n-\t (NULL_TREE, const_string_type_node, tree_cons\n-\t  (NULL_TREE, build_pointer_type (type_info_type_node),\n-\t   void_list_node)));\n-      fn = push_void_library_fn (fn, tmp);\n-    }\n-\n-  fn = build_call (fn, elems);\n-  finish_expr_stmt (fn);\n-}\n-\n-/* Build an initializer for a __class_type_info node.  */\n-\n-static void\n-expand_class_desc (tdecl, type)\n-     tree tdecl;\n-     tree type;\n-{\n-  tree name_string;\n-  tree fn, tmp;\n-\n-  int i = CLASSTYPE_N_BASECLASSES (type);\n-  int base_cnt = 0;\n-  tree binfos = TYPE_BINFO_BASETYPES (type);\n-  tree base, elems, access, offset, isvir;\n-  tree elt, elts = NULL_TREE;\n-\n-  if (base_desc_type_node == NULL_TREE)\n-    {\n-      tree fields [4];\n-\n-      /* A reasonably close approximation of __class_type_info::base_info */\n-\n-      base_desc_type_node = make_aggr_type (RECORD_TYPE);\n-\n-      /* Actually const __user_type_info * */\n-      fields [0] = build_decl\n-\t(FIELD_DECL, NULL_TREE,\n-\t build_pointer_type (build_qualified_type\n-\t\t\t     (type_info_type_node,\n-\t\t\t      TYPE_QUAL_CONST)));\n-      fields [1] = build_decl\n-\t(FIELD_DECL, NULL_TREE, \n-\t flag_new_abi ? intSI_type_node : unsigned_intSI_type_node);\n-      DECL_BIT_FIELD (fields[1]) = 1;\n-      DECL_SIZE (fields[1]) = bitsize_int (29);\n-\n-      fields [2] = build_decl (FIELD_DECL, NULL_TREE, boolean_type_node);\n-      DECL_BIT_FIELD (fields[2]) = 1;\n-      DECL_SIZE (fields[2]) = bitsize_one_node;\n-\n-      /* Actually enum access */\n-      fields [3] = build_decl (FIELD_DECL, NULL_TREE, integer_type_node);\n-      DECL_BIT_FIELD (fields[3]) = 1;\n-      DECL_SIZE (fields[3]) = bitsize_int (2);\n-\n-      finish_builtin_type (base_desc_type_node, \"__base_info\", fields,\n-\t\t\t   3, ptr_type_node);\n-    }\n-\n-  while (--i >= 0)\n-    {\n-      tree binfo = TREE_VEC_ELT (binfos, i);\n-\n-      finish_expr_stmt (get_typeid_1 (BINFO_TYPE (binfo)));\n-      base = decay_conversion (get_tinfo_var (BINFO_TYPE (binfo)));\n-      offset = get_base_offset (binfo, type);\n-      \n-      if (TREE_VIA_PUBLIC (binfo))\n-        access = access_public_node;\n-      else if (TREE_VIA_PROTECTED (binfo))\n-\taccess = access_protected_node;\n-      else\n-\taccess = access_private_node;\n-      if (TREE_VIA_VIRTUAL (binfo))\n-\tisvir = boolean_true_node;\n-      else\n-\tisvir = boolean_false_node;\n-\n-      elt = build\n-\t(CONSTRUCTOR, base_desc_type_node, NULL_TREE, tree_cons\n-\t (NULL_TREE, base, tree_cons\n-\t  (NULL_TREE, offset, tree_cons\n-\t   (NULL_TREE, isvir, tree_cons\n-\t    (NULL_TREE, access, NULL_TREE)))));\n-      TREE_HAS_CONSTRUCTOR (elt) = TREE_CONSTANT (elt) = TREE_STATIC (elt) = 1;\n-      elts = tree_cons (NULL_TREE, elt, elts);\n-      base_cnt++;\n-    }\n-\n-  name_string = tinfo_name (type);\n-\n-  {\n-    tree arrtype = build_array_type (base_desc_type_node, NULL_TREE);\n-    elts = build (CONSTRUCTOR, arrtype, NULL_TREE, elts);\n-    TREE_HAS_CONSTRUCTOR (elts) = TREE_CONSTANT (elts)\n-      = TREE_STATIC (elts) = 1;\n-    complete_array_type (arrtype, elts, 1);\n-  }\n-\n-  elems = tree_cons\n-    (NULL_TREE, decay_conversion (tdecl), tree_cons\n-     (NULL_TREE, decay_conversion (name_string), tree_cons\n-      (NULL_TREE, decay_conversion (elts), tree_cons\n-       (NULL_TREE, cp_convert (sizetype, build_int_2 (base_cnt, 0)),\n-\tNULL_TREE))));\n-\n-  fn = get_identifier (\"__rtti_class\");\n-  if (IDENTIFIER_GLOBAL_VALUE (fn))\n-    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n-  else\n-    {\n-      tmp = tree_cons\n-\t(NULL_TREE, ptr_type_node, tree_cons\n-\t (NULL_TREE, const_string_type_node, tree_cons\n-\t  (NULL_TREE, build_pointer_type (base_desc_type_node), tree_cons\n-\t   (NULL_TREE, sizetype, void_list_node))));\n-\n-      fn = push_void_library_fn (fn, tmp);\n-    }\n-\n-  fn = build_call (fn, elems);\n-  finish_expr_stmt (fn);\n-}\n-\n-/* Build an initializer for a __pointer_type_info node.  */\n-\n-static void\n-expand_ptr_desc (tdecl, type)\n-     tree tdecl;\n-     tree type;\n-{\n-  tree t, elems, fn;\n-  tree name_string = tinfo_name (type);\n-\n-  type = TREE_TYPE (type);\n-  finish_expr_stmt (get_typeid_1 (type));\n-  t = decay_conversion (get_tinfo_var (type));\n-  elems = tree_cons\n-    (NULL_TREE, decay_conversion (tdecl), tree_cons\n-     (NULL_TREE, decay_conversion (name_string), tree_cons\n-      (NULL_TREE, t, NULL_TREE)));\n-\n-  fn = get_identifier (\"__rtti_ptr\");\n-  if (IDENTIFIER_GLOBAL_VALUE (fn))\n-    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n-  else\n-    {\n-      tree tmp;\n-      tmp = tree_cons\n-\t(NULL_TREE, ptr_type_node, tree_cons\n-\t (NULL_TREE, const_string_type_node, tree_cons\n-\t  (NULL_TREE, build_pointer_type (type_info_type_node),\n-\t   void_list_node)));\n-      fn = push_void_library_fn (fn, tmp);\n-    }\n-\n-  fn = build_call (fn, elems);\n-  finish_expr_stmt (fn);\n-}\n-\n-/* Build an initializer for a __attr_type_info node.  */\n-\n-static void\n-expand_attr_desc (tdecl, type)\n-     tree tdecl;\n-     tree type;\n-{\n-  tree elems, t, fn;\n-  tree name_string = tinfo_name (type);\n-  tree attrval = build_int_2 (TYPE_QUALS (type), 0);\n-\n-  finish_expr_stmt (get_typeid_1 (TYPE_MAIN_VARIANT (type)));\n-  t = decay_conversion (get_tinfo_var (TYPE_MAIN_VARIANT (type)));\n-  elems = tree_cons\n-    (NULL_TREE, decay_conversion (tdecl), tree_cons\n-     (NULL_TREE, decay_conversion (name_string), tree_cons\n-      (NULL_TREE, attrval, tree_cons (NULL_TREE, t, NULL_TREE))));\n-\n-  fn = get_identifier (\"__rtti_attr\");\n-  if (IDENTIFIER_GLOBAL_VALUE (fn))\n-    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n-  else\n-    {\n-      tree tmp;\n-      tmp = tree_cons\n-\t(NULL_TREE, ptr_type_node, tree_cons\n-\t (NULL_TREE, const_string_type_node, tree_cons\n-\t  (NULL_TREE, integer_type_node, tree_cons\n-\t   (NULL_TREE, build_pointer_type (type_info_type_node),\n-\t    void_list_node))));\n-      fn = push_void_library_fn (fn, tmp);\n-    }\n-\n-  fn = build_call (fn, elems);\n-  finish_expr_stmt (fn);\n-}\n-\n-/* Build an initializer for a type_info node that just has a name.  */\n-\n-static void\n-expand_generic_desc (tdecl, type, fnname)\n-     tree tdecl;\n-     tree type;\n-     const char *fnname;\n-{\n-  tree name_string = tinfo_name (type);\n-  tree elems = tree_cons\n-    (NULL_TREE, decay_conversion (tdecl), tree_cons\n-     (NULL_TREE, decay_conversion (name_string), NULL_TREE));\n-\n-  tree fn = get_identifier (fnname);\n-  if (IDENTIFIER_GLOBAL_VALUE (fn))\n-    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n-  else\n-    {\n-      tree tmp;\n-      tmp = tree_cons\n-\t(NULL_TREE, ptr_type_node, tree_cons\n-\t (NULL_TREE, const_string_type_node, void_list_node));\n-      fn = push_void_library_fn (fn, tmp);\n-    }\n-\n-  fn = build_call (fn, elems);\n-  finish_expr_stmt (fn);\n-}\n-\n-/* Generate the code for a type_info initialization function.\n-   Note that we take advantage of the passage\n-\n-   5.2.7  Type identification                               [expr.typeid]\n-   \n-   Whether or not the destructor is called for the type_info object at the\n-   end of the program is unspecified.\n-\n-   and don't bother to arrange for these objects to be destroyed.  It\n-   doesn't matter, anyway, since the destructors don't do anything.\n-       \n-   This must only be called from toplevel (i.e. from finish_file)!  */\n-\n-void\n-synthesize_tinfo_fn (fndecl)\n-     tree fndecl;\n-{\n-  tree type = TREE_TYPE (DECL_NAME (fndecl));\n-  tree tmp, addr, tdecl;\n-  tree compound_stmt;\n-  tree if_stmt;\n-  tree then_clause;\n-\n-  my_friendly_assert (!new_abi_rtti_p (), 20000118);\n-  if (at_eof)\n-    {\n-      import_export_decl (fndecl);\n-      if (DECL_REALLY_EXTERN (fndecl))\n-\treturn;\n-    }\n-\n-  /* Declare the static typeinfo variable.  */\n-  tdecl = get_tinfo_var (type);\n-  DECL_EXTERNAL (tdecl) = 0;\n-  TREE_STATIC (tdecl) = 1;\n-  DECL_COMMON (tdecl) = 1;\n-  TREE_USED (tdecl) = 1;\n-  DECL_ALIGN (tdecl) = TYPE_ALIGN (ptr_type_node);\n-  DECL_USER_ALIGN (tdecl) = 0;\n-  cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0);\n-\n-  /* Begin processing the function.  */\n-  start_function (NULL_TREE, fndecl, NULL_TREE, \n-\t\t  SF_DEFAULT | SF_PRE_PARSED);\n-  DECL_DEFER_OUTPUT (fndecl) = 1;\n-  clear_last_expr ();\n-\n-  /* Begin the body of the function.  */\n-  compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n-\n-  /* For convenience, we save away the address of the static\n-     variable.  */\n-  addr = decay_conversion (tdecl);\n-\n-  /* If the first word of the array (the vtable) is non-zero, we've already\n-     initialized the object, so don't do it again.  */\n-  if_stmt = begin_if_stmt ();\n-  tmp = cp_convert (build_pointer_type (ptr_type_node), addr);\n-  tmp = build_indirect_ref (tmp, 0);\n-  tmp = cp_build_binary_op (EQ_EXPR, tmp, integer_zero_node);\n-  finish_if_stmt_cond (tmp, if_stmt);\n-  then_clause = begin_compound_stmt (/*has_no_scope=*/0);\n-\n-  if (TREE_CODE (type) == FUNCTION_TYPE)\n-    expand_generic_desc (tdecl, type, \"__rtti_func\");\n-  else if (TREE_CODE (type) == ARRAY_TYPE)\n-    expand_generic_desc (tdecl, type, \"__rtti_array\");\n-  else if (TYPE_QUALS (type) != TYPE_UNQUALIFIED)\n-    expand_attr_desc (tdecl, type);\n-  else if (TREE_CODE (type) == POINTER_TYPE)\n-    {\n-      if (TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE)\n-\texpand_generic_desc (tdecl, type, \"__rtti_ptmd\");\n-      else if (TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE)\n-\texpand_generic_desc (tdecl, type, \"__rtti_ptmf\");\n-      else\n-\texpand_ptr_desc (tdecl, type);\n-    }\n-  else if (TYPE_PTRMEMFUNC_P (type))\n-    expand_generic_desc (tdecl, type, \"__rtti_ptmf\");\n-  else if (IS_AGGR_TYPE (type))\n-    {\n-      if (CLASSTYPE_N_BASECLASSES (type) == 0)\n-\texpand_generic_desc (tdecl, type, \"__rtti_user\");\n-      else if (! TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (type)\n-\t       && (TREE_VIA_PUBLIC\n-\t\t   (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), 0))))\n-\texpand_si_desc (tdecl, type);\n-      else\n-\texpand_class_desc (tdecl, type);\n-    }\n-  else if (TREE_CODE (type) == ENUMERAL_TYPE)\n-    expand_generic_desc (tdecl, type, \"__rtti_user\");\n-  else\n-    my_friendly_abort (252);\n-\n-  finish_compound_stmt (/*has_no_scope=*/0, then_clause);\n-  finish_then_clause (if_stmt);\n-  finish_if_stmt ();\n-\n-  /* OK, now return the type_info object.  */\n-  tmp = cp_convert (build_pointer_type (type_info_type_node), addr);\n-  tmp = build_indirect_ref (tmp, 0);\n-  finish_return_stmt (tmp);\n-  /* Finish the function body.  */\n-  finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n-  expand_body (finish_function (0));\n-}\n-\n /* Return the runtime bit mask encoding the qualifiers of TYPE.  */\n \n static int\n@@ -1328,10 +884,7 @@ tinfo_base_init (desc, target)\n                      NULL_TREE);\n     tree name_string = tinfo_name (target);\n \n-    if (flag_new_abi)\n-      name_name = mangle_typeinfo_string_for_type (target);\n-    else\n-      name_name = build_overload_with_type (tinfo_var_id, target);\n+    name_name = mangle_typeinfo_string_for_type (target);\n     name_decl = build_lang_decl (VAR_DECL, name_name, name_type);\n     \n     DECL_ARTIFICIAL (name_decl) = 1;\n@@ -1340,13 +893,10 @@ tinfo_base_init (desc, target)\n     DECL_EXTERNAL (name_decl) = 0;\n     TREE_PUBLIC (name_decl) = 1;\n     comdat_linkage (name_decl);\n-    if (flag_new_abi)\n-      /* The new ABI specifies the external name of the string\n-\t containing the type's name.  */\n-      DECL_ASSEMBLER_NAME (name_decl) \n-\t= mangle_typeinfo_string_for_type (target);\n-    else\n-      DECL_ASSEMBLER_NAME (name_decl) = DECL_NAME (name_decl);\n+    /* The new ABI specifies the external name of the string\n+       containing the type's name.  */\n+    DECL_ASSEMBLER_NAME (name_decl) \n+      = mangle_typeinfo_string_for_type (target);\n     DECL_INITIAL (name_decl) = name_string;\n     cp_finish_decl (name_decl, name_string, NULL_TREE, 0);\n     pushdecl_top_level (name_decl);\n@@ -1809,16 +1359,13 @@ create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n \n   /* Under the new ABI, we need to point into the middle of the\n      vtable.  */\n-  if (flag_new_abi)\n-    {\n-      vtable_decl = build (PLUS_EXPR,\n-\t\t\t   TREE_TYPE (vtable_decl),\n-\t\t\t   vtable_decl,\n-\t\t\t   size_binop (MULT_EXPR,\n-\t\t\t\t       size_int (2),\n-\t\t\t\t       TYPE_SIZE_UNIT (vtable_entry_type)));\n-      TREE_CONSTANT (vtable_decl) = 1;\n-    }\n+  vtable_decl = build (PLUS_EXPR,\n+\t\t       TREE_TYPE (vtable_decl),\n+\t\t       vtable_decl,\n+\t\t       size_binop (MULT_EXPR,\n+\t\t\t\t   size_int (2),\n+\t\t\t\t   TYPE_SIZE_UNIT (vtable_entry_type)));\n+  TREE_CONSTANT (vtable_decl) = 1;\n \n   /* First field is the pseudo type_info base class. */\n   fields[0] = build_decl (FIELD_DECL, NULL_TREE, ti_desc_type_node);"}, {"sha": "8a6378d1d18e92c40c344dea9be518a1ec15fb8a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -2507,8 +2507,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n       *vbase_offsets = delta;\n     }\n \n-  for (virtuals = BINFO_VIRTUALS (binfo), \n-\t n = first_vfun_index (BINFO_TYPE (binfo));\n+  for (virtuals = BINFO_VIRTUALS (binfo), n = 0;\n        virtuals;\n        virtuals = TREE_CHAIN (virtuals), ++n)\n     {"}, {"sha": "f7199f0b0daf8843fc649c0a43d5585a9e632bb2", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -883,7 +883,7 @@ debug_binfo (elem)\n     fprintf (stderr, \"no vtable decl yet\\n\");\n   fprintf (stderr, \"virtuals:\\n\");\n   virtuals = BINFO_VIRTUALS (elem);\n-  n = first_vfun_index (BINFO_TYPE (elem));\n+  n = 0;\n \n   while (virtuals)\n     {\n@@ -2229,9 +2229,6 @@ cp_valid_lang_attribute (attr_name, attr_args, decl, type)\n \t  return 0;\n \t}\n \n-      if (!flag_new_abi)\n-\t/* The v3 ABI is already COM compliant; don't set this flag.  */\n-\tCLASSTYPE_COM_INTERFACE (type) = 1;\n       return 1;\n     }\n   else if (is_attribute_p (\"init_priority\", attr_name))"}, {"sha": "6cc1969a01be69b57e81ce800954e5981cf308ed", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 73, "deletions": 249, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f84ec231e3abac2f8fc874a6231d337cd03897b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=1f84ec231e3abac2f8fc874a6231d337cd03897b", "patch": "@@ -2884,35 +2884,20 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t load-with-sign-extend, while the second used normal load then\n \t shift to sign-extend.  An optimizer flaw, perhaps, but it's\n \t easier to make this change.  */\n-      if (flag_new_abi)\n-\t{\n-\t  idx = cp_build_binary_op (TRUNC_DIV_EXPR, \n-\t\t\t\t    build1 (NOP_EXPR, vtable_index_type, e3),\n-\t\t\t\t    TYPE_SIZE_UNIT (vtable_entry_type));\n-\t  e1 = cp_build_binary_op (BIT_AND_EXPR,\n-\t\t\t\t   build1 (NOP_EXPR, vtable_index_type, e3),\n-\t\t\t\t   integer_one_node);\n-\t}\n-      else\n-\t{\n-\t  idx = save_expr (default_conversion\n-\t\t       (build_component_ref (function,\n-\t\t\t\t\t     index_identifier,\n-\t\t\t\t\t     NULL_TREE, 0)));\n-\t  e1 = cp_build_binary_op (GE_EXPR, idx, integer_zero_node);\n-\t  idx = cp_build_binary_op (MINUS_EXPR, idx, integer_one_node);\n-\t}\n+      idx = cp_build_binary_op (TRUNC_DIV_EXPR, \n+\t\t\t\tbuild1 (NOP_EXPR, vtable_index_type, e3),\n+\t\t\t\tTYPE_SIZE_UNIT (vtable_entry_type));\n+      e1 = cp_build_binary_op (BIT_AND_EXPR,\n+\t\t\t       build1 (NOP_EXPR, vtable_index_type, e3),\n+\t\t\t       integer_one_node);\n \n       vtbl = convert_pointer_to (ptr_type_node, instance);\n       delta = cp_convert (ptrdiff_type_node,\n \t\t\t  build_component_ref (function, delta_identifier,\n \t\t\t\t\t       NULL_TREE, 0));\n-      if (flag_new_abi)\n-\t/* DELTA2 is the amount by which to adjust the `this' pointer\n-\t   to find the vtbl.  */\n-\tdelta2 = delta;\n-      else\n-\tdelta2 = DELTA2_FROM_PTRMEMFUNC (function);\n+      /* DELTA2 is the amount by which to adjust the `this' pointer\n+\t to find the vtbl.  */\n+      delta2 = delta;\n       vtbl = build\n \t(PLUS_EXPR,\n \t build_pointer_type (build_pointer_type (vtable_entry_type)),\n@@ -3630,16 +3615,8 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type0) && null_ptr_cst_p (op1))\n \t{\n-\t  if (flag_new_abi)\n-\t    {\n-\t      op0 = build_component_ref (op0, pfn_identifier, NULL_TREE, 0);\n-\t      op1 = cp_convert (TREE_TYPE (op0), integer_zero_node);\n-\t    }\n-\t  else\n-\t    {\n-\t      op0 = build_component_ref (op0, index_identifier, NULL_TREE, 0);\n-\t      op1 = integer_zero_node;\n-\t    }\n+\t  op0 = build_component_ref (op0, pfn_identifier, NULL_TREE, 0);\n+\t  op1 = cp_convert (TREE_TYPE (op0), integer_zero_node);\n \t  result_type = TREE_TYPE (op0);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type1) && null_ptr_cst_p (op0))\n@@ -3652,80 +3629,38 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t  /* E1 and E2 are for scratch.  */\n \t  tree e1;\n \t  tree e2;\n+\t  tree pfn0;\n+\t  tree pfn1;\n+\t  tree delta0;\n+\t  tree delta1;\n \n \t  if (TREE_SIDE_EFFECTS (op0))\n \t    op0 = save_expr (op0);\n \t  if (TREE_SIDE_EFFECTS (op1))\n \t    op1 = save_expr (op1);\n \n-\t  if (flag_new_abi)\n-\t    {\n-\t      /* We generate:\n-\n-\t\t   (op0.pfn == op1.pfn \n-                    && (!op0.pfn || op0.delta == op1.delta))\n-\t\t    \n-\t\t The reason for the `!op0.pfn' bit is that a NULL\n-\t\t pointer-to-member is any member with a zero PFN; the\n-\t\t DELTA field is unspecified.  */\n-\t      tree pfn0;\n-\t      tree pfn1;\n-\t      tree delta0;\n-\t      tree delta1;\n-\n-\t      pfn0 = pfn_from_ptrmemfunc (op0);\n-\t      pfn1 = pfn_from_ptrmemfunc (op1);\n-\t      delta0 = build_component_ref (op0, delta_identifier,\n-\t\t\t\t\t    NULL_TREE, 0);\n-\t      delta1 = build_component_ref (op1, delta_identifier,\n-\t\t\t\t\t    NULL_TREE, 0);\n-\t      e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1);\n-\t      e2 = cp_build_binary_op (EQ_EXPR, \n-\t\t\t\t       pfn0,\n-\t\t\t\t       cp_convert (TREE_TYPE (pfn0),\n-\t\t\t\t\t\t   integer_zero_node));\n-\t      e1 = cp_build_binary_op (TRUTH_ORIF_EXPR, e1, e2);\n-\t      e2 = build (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n-\t      e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* The code we generate for the test is:\n-\n-\t\t (op0.index == op1.index\n-\t\t  && op0.delta == op1.delta\n-\t\t  && (op1.index == -1 ? op0.pfn == op1.pfn\n-\t\t      : op0.delta2 == op1.delta2)) */\n-\n-\t      tree index0 = build_component_ref (op0, index_identifier,\n-\t\t\t\t\t\t NULL_TREE, 0);\n-\t      tree index1\n-\t\t= save_expr (build_component_ref (op1, index_identifier,\n-\t\t\t\t\t\t  NULL_TREE, 0));\n-\t      tree delta0 = build_component_ref (op0, delta_identifier,\n-\t\t\t\t\t\t NULL_TREE, 0);\n-\t      tree delta1 = build_component_ref (op1, delta_identifier,\n-\t\t\t\t\t\t NULL_TREE, 0);\n-\t      tree pfn0 = PFN_FROM_PTRMEMFUNC (op0);\n-\t      tree pfn1 = PFN_FROM_PTRMEMFUNC (op1);\n-\t      tree delta20 = DELTA2_FROM_PTRMEMFUNC (op0);\n-\t      tree delta21 = DELTA2_FROM_PTRMEMFUNC (op1);\n-\t      tree e3;\n-\t      tree integer_neg_one_node\n-\t\t= cp_build_binary_op (MINUS_EXPR, integer_zero_node,\n-\t\t\t\t      integer_one_node);\n-\t      e1 = cp_build_binary_op (EQ_EXPR, index1, integer_neg_one_node);\n-\t      /* We can't use build_binary_op for this cmp because it\n-\t\t would get confused by the ptr to method types and\n-\t\t think we want pmfs.  */\n-\t      e2 = build (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n-\t      e3 = cp_build_binary_op (EQ_EXPR, delta20, delta21);\n-\t      e = build_conditional_expr (e1, e2, e3);\n-\t      e1 = cp_build_binary_op (EQ_EXPR, index0, index1);\n-\t      e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e1, e);\n-\t      e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1);\n-\t      e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e1, e);\n-\t    }\n+\t  /* We generate:\n+\n+\t     (op0.pfn == op1.pfn \n+\t      && (!op0.pfn || op0.delta == op1.delta))\n+\t     \n+\t     The reason for the `!op0.pfn' bit is that a NULL\n+\t     pointer-to-member is any member with a zero PFN; the\n+\t     DELTA field is unspecified.  */\n+\t  pfn0 = pfn_from_ptrmemfunc (op0);\n+\t  pfn1 = pfn_from_ptrmemfunc (op1);\n+\t  delta0 = build_component_ref (op0, delta_identifier,\n+\t\t\t\t\tNULL_TREE, 0);\n+\t  delta1 = build_component_ref (op1, delta_identifier,\n+\t\t\t\t\tNULL_TREE, 0);\n+\t  e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1);\n+\t  e2 = cp_build_binary_op (EQ_EXPR, \n+\t\t\t\t   pfn0,\n+\t\t\t\t   cp_convert (TREE_TYPE (pfn0),\n+\t\t\t\t\t       integer_zero_node));\n+\t  e1 = cp_build_binary_op (TRUTH_ORIF_EXPR, e1, e2);\n+\t  e2 = build (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n+\t  e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1);\n \t  if (code == EQ_EXPR)\n \t    return e;\n \t  return cp_build_binary_op (EQ_EXPR, e, integer_zero_node);\n@@ -6025,8 +5960,8 @@ get_delta_difference (from, to, force)\n    the other components as specified.  */\n \n tree\n-build_ptrmemfunc1 (type, delta, idx, pfn, delta2)\n-     tree type, delta, idx, pfn, delta2;\n+build_ptrmemfunc1 (type, delta, pfn)\n+     tree type, delta, pfn;\n {\n   tree u = NULL_TREE;\n   tree delta_field;\n@@ -6038,24 +5973,12 @@ build_ptrmemfunc1 (type, delta, idx, pfn, delta2)\n   int allconstant, allsimple;\n \n   /* Pull the FIELD_DECLs out of the type.  */\n-  if (flag_new_abi)\n-    {\n-      pfn_field = TYPE_FIELDS (type);\n-      delta_field = TREE_CHAIN (pfn_field);\n-      idx_field = NULL_TREE;\n-      pfn_or_delta2_field = NULL_TREE;\n-      delta2_field = NULL_TREE;\n-      subtype = NULL_TREE;\n-    }\n-  else\n-    {\n-      delta_field = TYPE_FIELDS (type);\n-      idx_field = TREE_CHAIN (delta_field);\n-      pfn_or_delta2_field = TREE_CHAIN (idx_field);\n-      subtype = TREE_TYPE (pfn_or_delta2_field);\n-      pfn_field = TYPE_FIELDS (subtype);\n-      delta2_field = TREE_CHAIN (pfn_field);\n-    }\n+  pfn_field = TYPE_FIELDS (type);\n+  delta_field = TREE_CHAIN (pfn_field);\n+  idx_field = NULL_TREE;\n+  pfn_or_delta2_field = NULL_TREE;\n+  delta2_field = NULL_TREE;\n+  subtype = NULL_TREE;\n \n   /* Make sure DELTA has the type we want.  */\n   delta = convert_and_check (delta_type_node, delta);\n@@ -6069,49 +5992,21 @@ build_ptrmemfunc1 (type, delta, idx, pfn, delta2)\n   if (pfn)\n     {\n       /* A non-virtual function.  */\n-      if (!flag_new_abi)\n-\tu = build_tree_list (pfn_field, pfn);\n-\n       allconstant &= TREE_CONSTANT (pfn);\n       allsimple &= (initializer_constant_valid_p (pfn, TREE_TYPE (pfn)) \n \t\t    != NULL_TREE);\n     }\n   else\n     {\n       /* A virtual function.  */\n-      if (flag_new_abi)\n-\t{\n-\t  allconstant &= TREE_CONSTANT (pfn);\n-\t  allsimple &= (initializer_constant_valid_p (pfn, TREE_TYPE (pfn)) \n-\t\t\t!= NULL_TREE);\n-\t}\n-      else\n-\t{\n-\t  idx = convert_and_check (delta_type_node, idx);\n-\t  u = build_tree_list (delta2_field, delta2);\n-\n-\t  allconstant &= TREE_CONSTANT (idx) && TREE_CONSTANT (delta2);\n-\t  allsimple &= ((initializer_constant_valid_p (idx, TREE_TYPE (idx)) \n-\t\t\t != NULL_TREE)\n-\t\t\t&& (initializer_constant_valid_p (delta2,\n-\t\t\t\t\t\t\t  TREE_TYPE (delta2))\n-\t\t\t    != NULL_TREE));\n-\t}\n+      allconstant &= TREE_CONSTANT (pfn);\n+      allsimple &= (initializer_constant_valid_p (pfn, TREE_TYPE (pfn)) \n+\t\t    != NULL_TREE);\n     }\n \n   /* Finish creating the initializer.  */\n-  if (flag_new_abi)\n-    u = tree_cons (pfn_field, pfn,\n-\t\t   build_tree_list (delta_field, delta));\n-  else\n-    {\n-      u = build (CONSTRUCTOR, subtype, NULL_TREE, u);\n-      u = tree_cons (delta_field, delta,\n-\t\t     tree_cons (idx_field, \n-\t\t\t\tidx,\n-\t\t\t\tbuild_tree_list (pfn_or_delta2_field,\n-\t\t\t\t\t\t u)));\n-    }\n+  u = tree_cons (pfn_field, pfn,\n+\t\t build_tree_list (delta_field, delta));\n   u = build (CONSTRUCTOR, type, NULL_TREE, u);\n   TREE_CONSTANT (u) = allconstant;\n   TREE_STATIC (u) = allconstant && allsimple;\n@@ -6141,12 +6036,9 @@ build_ptrmemfunc (type, pfn, force)\n   /* Handle multiple conversions of pointer to member functions.  */\n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (pfn)))\n     {\n-      tree idx = integer_zero_node;\n       tree delta = integer_zero_node;\n-      tree delta2 = integer_zero_node;\n       tree npfn = NULL_TREE;\n-      tree ndelta, ndelta2;\n-      tree e1, e2, e3, n;\n+      tree n;\n \n       if (!force \n \t  && !can_convert_arg (to_type, TREE_TYPE (pfn), pfn))\n@@ -6172,65 +6064,22 @@ build_ptrmemfunc (type, pfn, force)\n       if (TREE_SIDE_EFFECTS (pfn))\n \tpfn = save_expr (pfn);\n \n-      if (flag_new_abi)\n-\t{\n-\t  /* Under the new ABI, the conversion is easy.  Just adjust\n-\t     the DELTA field.  */\n-\t  npfn = build_component_ref (pfn, pfn_identifier, NULL_TREE, 0);\n-\t  delta = build_component_ref (pfn, delta_identifier, NULL_TREE, 0);\n-\t  delta = cp_convert (ptrdiff_type_node, delta);\n-\t  delta = cp_build_binary_op (PLUS_EXPR, delta, n);\n-\t  return build_ptrmemfunc1 (to_type, delta, NULL_TREE, npfn,\n-\t\t\t\t    NULL_TREE);\n-\t}\n-\n-      if (TREE_CODE (pfn) == PTRMEM_CST)\n-\t{\n-\t  /* We could just build the resulting CONSTRUCTOR now, but we\n-\t     don't, relying on the general machinery below, together\n-\t     with constant-folding, to do the right thing.  */\n-\t  expand_ptrmemfunc_cst (pfn, &ndelta, &idx, &npfn, &ndelta2);\n-\t  if (npfn)\n-\t    /* This constant points to a non-virtual function.\n-\t       NDELTA2 will be NULL, but it's value doesn't really\n-\t       matter since we won't use it anyhow.  */\n-\t    ndelta2 = integer_zero_node;\n-\t}\n-      else\n-\t{\n-\t  ndelta = cp_convert (ptrdiff_type_node, \n-\t\t\t       build_component_ref (pfn, \n-\t\t\t\t\t\t    delta_identifier, \n-\t\t\t\t\t\t    NULL_TREE, 0));\n-\t  ndelta2 = cp_convert (ptrdiff_type_node, \n-\t\t\t\tDELTA2_FROM_PTRMEMFUNC (pfn));\n-\t  idx = build_component_ref (pfn, index_identifier, NULL_TREE, 0);\n-\t}\n-\n-      delta = cp_build_binary_op (PLUS_EXPR, ndelta, n);\n-      delta2 = cp_build_binary_op (PLUS_EXPR, ndelta2, n);\n-      e1 = fold (build (GT_EXPR, boolean_type_node, idx, integer_zero_node));\n-\t  \n-      /* If it's a virtual function, this is what we want.  */\n-      e2 = build_ptrmemfunc1 (to_type, delta, idx, NULL_TREE, delta2);\n-\n-      pfn = PFN_FROM_PTRMEMFUNC (pfn);\n-      npfn = build1 (NOP_EXPR, type, pfn);\n-      TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n-\n-      /* But if it's a non-virtual function, or NULL, we use this\n-\t instead.  */\n-      e3 = build_ptrmemfunc1 (to_type, delta, idx, npfn, NULL_TREE);\n-      return build_conditional_expr (e1, e2, e3);\n+      /* Under the new ABI, the conversion is easy.  Just adjust\n+\t the DELTA field.  */\n+      npfn = build_component_ref (pfn, pfn_identifier, NULL_TREE, 0);\n+      delta = build_component_ref (pfn, delta_identifier, NULL_TREE, 0);\n+      delta = cp_convert (ptrdiff_type_node, delta);\n+      delta = cp_build_binary_op (PLUS_EXPR, delta, n);\n+      return build_ptrmemfunc1 (to_type, delta, npfn);\n     }\n \n   /* Handle null pointer to member function conversions.  */\n   if (integer_zerop (pfn))\n     {\n       pfn = build_c_cast (type, integer_zero_node);\n       return build_ptrmemfunc1 (to_type,\n-\t\t\t\tinteger_zero_node, integer_zero_node,\n-\t\t\t\tpfn, NULL_TREE);\n+\t\t\t\tinteger_zero_node, \n+\t\t\t\tpfn);\n     }\n \n   if (type_unknown_p (pfn))\n@@ -6273,10 +6122,7 @@ expand_ptrmemfunc_cst (cst, delta, idx, pfn, delta2)\n \n   if (!DECL_VIRTUAL_P (fn))\n     {\n-      if (!flag_new_abi)\n-\t*idx = build_int_2 (-1, -1);\n-      else\n-\t*idx = NULL_TREE;\n+      *idx = NULL_TREE;\n       *pfn = convert (TYPE_PTRMEMFUNC_FN_TYPE (type), build_addr_func (fn));\n       *delta2 = NULL_TREE;\n     }\n@@ -6290,26 +6136,16 @@ expand_ptrmemfunc_cst (cst, delta, idx, pfn, delta2)\n       *delta = fold (build (PLUS_EXPR, TREE_TYPE (*delta),\n \t\t\t    *delta, BINFO_OFFSET (binfo)));\n \n-      if (!flag_new_abi)\n-\t{\n-\t  /* Map everything down one to make room for the null PMF.  */\n-\t  *idx = fold (build (PLUS_EXPR, integer_type_node,\n-\t\t\t      DECL_VINDEX (fn), integer_one_node));\n-\t  *pfn = NULL_TREE;\n-\t}\n-      else\n-\t{\n-\t  /* Under the new ABI, we set PFN to the vtable offset, plus\n-\t     one, at which the function can be found.  */\n-\t  *idx = NULL_TREE;\n-\t  *pfn = fold (build (MULT_EXPR, integer_type_node,\n-\t\t\t      DECL_VINDEX (fn), \n-\t\t\t      TYPE_SIZE_UNIT (vtable_entry_type)));\n-\t  *pfn = fold (build (PLUS_EXPR, integer_type_node, *pfn,\n-\t\t\t      integer_one_node));\n-\t  *pfn = fold (build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type),\n-\t\t\t       *pfn));\n-\t}\n+      /* Under the new ABI, we set PFN to the vtable offset, plus\n+\t one, at which the function can be found.  */\n+      *idx = NULL_TREE;\n+      *pfn = fold (build (MULT_EXPR, integer_type_node,\n+\t\t\t  DECL_VINDEX (fn), \n+\t\t\t  TYPE_SIZE_UNIT (vtable_entry_type)));\n+      *pfn = fold (build (PLUS_EXPR, integer_type_node, *pfn,\n+\t\t\t  integer_one_node));\n+      *pfn = fold (build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type),\n+\t\t\t   *pfn));\n \n       /* Offset from an object of PTR_CLASS to the vptr for ORIG_CLASS.  */\n       *delta2 = fold (build (PLUS_EXPR, integer_type_node, *delta,\n@@ -6324,7 +6160,7 @@ tree\n delta2_from_ptrmemfunc (t)\n      tree t;\n {\n-  my_friendly_assert (!flag_new_abi, 20000221);\n+  my_friendly_assert (0, 20000221);\n \n   if (TREE_CODE (t) == PTRMEM_CST)\n     {\n@@ -6364,14 +6200,7 @@ pfn_from_ptrmemfunc (t)\n \treturn pfn;\n     }\n \n-  if (flag_new_abi)\n-    return build_component_ref (t, pfn_identifier, NULL_TREE, 0);\n-  else\n-    return (build_component_ref \n-\t    (build_component_ref (t,\n-\t\t\t\t  pfn_or_delta2_identifier, NULL_TREE,\n-\t\t\t\t  0), \n-\t     pfn_identifier, NULL_TREE, 0)); \n+  return build_component_ref (t, pfn_identifier, NULL_TREE, 0);\n }\n \n /* Expression EXPR is about to be implicitly converted to TYPE.  Warn\n@@ -6778,11 +6607,6 @@ check_return_expr (retval)\n       return NULL_TREE;\n     }\n \n-  /* Under the old ABI, constructors actually always return `this',\n-     even though in C++ you can't return a value from a constructor.  */\n-  if (!flag_new_abi && DECL_CONSTRUCTOR_P (current_function_decl))\n-    retval = current_class_ptr;\n-\n   /* When no explicit return-value is given in a function with a named\n      return value, the named return value is used.  */\n   result = DECL_RESULT (current_function_decl);"}]}