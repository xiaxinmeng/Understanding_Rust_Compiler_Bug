{"sha": "b210f45f527eb017810af815bbb97a8f6939385f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIxMGY0NWY1MjdlYjAxNzgxMGFmODE1YmJiOTdhOGY2OTM5Mzg1Zg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-02-07T15:46:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-02-07T15:46:17Z"}, "message": "re PR tree-optimization/84037 (Speed regression of polyhedron benchmark since r256644)\n\n2018-02-07  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/84037\n\t* tree-vectorizer.h (struct _loop_vec_info): Add ivexpr_map member.\n\t(cse_and_gimplify_to_preheader): Declare.\n\t(vect_get_place_in_interleaving_chain): Likewise.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize\n\tivexpr_map.\n\t(_loop_vec_info::~_loop_vec_info): Delete it.\n\t(cse_and_gimplify_to_preheader): New function.\n\t* tree-vect-slp.c (vect_get_place_in_interleaving_chain): Export.\n\t* tree-vect-stmts.c (vectorizable_store): CSE base and steps.\n\t(vectorizable_load): Likewise.  For grouped stores always base\n\tthe IV on the first element.\n\t* tree-vect-loop-manip.c (vect_loop_versioning): Unshare versioning\n\tcondition before gimplifying.\n\nFrom-SVN: r257453", "tree": {"sha": "26538f6f069f23a2c3756540d4f8743f7e052695", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26538f6f069f23a2c3756540d4f8743f7e052695"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b210f45f527eb017810af815bbb97a8f6939385f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b210f45f527eb017810af815bbb97a8f6939385f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b210f45f527eb017810af815bbb97a8f6939385f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b210f45f527eb017810af815bbb97a8f6939385f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "43e4df5a0bed4833a4812746e5554ed057b6dfd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e4df5a0bed4833a4812746e5554ed057b6dfd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43e4df5a0bed4833a4812746e5554ed057b6dfd4"}], "stats": {"total": 100, "additions": 80, "deletions": 20}, "files": [{"sha": "9c4d0e87b87388ce78369e978b0d8ff6e3ef92c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b210f45f527eb017810af815bbb97a8f6939385f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b210f45f527eb017810af815bbb97a8f6939385f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b210f45f527eb017810af815bbb97a8f6939385f", "patch": "@@ -1,3 +1,20 @@\n+2018-02-07  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/84037\n+\t* tree-vectorizer.h (struct _loop_vec_info): Add ivexpr_map member.\n+\t(cse_and_gimplify_to_preheader): Declare.\n+\t(vect_get_place_in_interleaving_chain): Likewise.\n+\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize\n+\tivexpr_map.\n+\t(_loop_vec_info::~_loop_vec_info): Delete it.\n+\t(cse_and_gimplify_to_preheader): New function.\n+\t* tree-vect-slp.c (vect_get_place_in_interleaving_chain): Export.\n+\t* tree-vect-stmts.c (vectorizable_store): CSE base and steps.\n+\t(vectorizable_load): Likewise.  For grouped stores always base\n+\tthe IV on the first element.\n+\t* tree-vect-loop-manip.c (vect_loop_versioning): Unshare versioning\n+\tcondition before gimplifying.\n+\n 2018-02-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-eh.c (operation_could_trap_helper_p): Ignore honor_trapv for"}, {"sha": "96d40c8c4b328145a469e997addaf99862dd55a9", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b210f45f527eb017810af815bbb97a8f6939385f/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b210f45f527eb017810af815bbb97a8f6939385f/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=b210f45f527eb017810af815bbb97a8f6939385f", "patch": "@@ -3015,7 +3015,8 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n       vect_create_cond_for_alias_checks (loop_vinfo, &cond_expr);\n     }\n \n-  cond_expr = force_gimple_operand_1 (cond_expr, &gimplify_stmt_list,\n+  cond_expr = force_gimple_operand_1 (unshare_expr (cond_expr),\n+\t\t\t\t      &gimplify_stmt_list,\n \t\t\t\t      is_gimple_condexpr, NULL_TREE);\n   gimple_seq_add_seq (&cond_expr_stmt_list, gimplify_stmt_list);\n "}, {"sha": "3a5114748131a6fdeb73ea1767612144960ea7ee", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b210f45f527eb017810af815bbb97a8f6939385f/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b210f45f527eb017810af815bbb97a8f6939385f/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b210f45f527eb017810af815bbb97a8f6939385f", "patch": "@@ -1128,6 +1128,7 @@ _loop_vec_info::_loop_vec_info (struct loop *loop_in)\n     unaligned_dr (NULL),\n     peeling_for_alignment (0),\n     ptr_mask (0),\n+    ivexpr_map (NULL),\n     slp_unrolling_factor (1),\n     single_scalar_iteration_cost (0),\n     vectorizable (false),\n@@ -1251,10 +1252,38 @@ _loop_vec_info::~_loop_vec_info ()\n   free (bbs);\n \n   release_vec_loop_masks (&masks);\n+  delete ivexpr_map;\n \n   loop->aux = NULL;\n }\n \n+/* Return an invariant or register for EXPR and emit necessary\n+   computations in the LOOP_VINFO loop preheader.  */\n+\n+tree\n+cse_and_gimplify_to_preheader (loop_vec_info loop_vinfo, tree expr)\n+{\n+  if (is_gimple_reg (expr)\n+      || is_gimple_min_invariant (expr))\n+    return expr;\n+\n+  if (! loop_vinfo->ivexpr_map)\n+    loop_vinfo->ivexpr_map = new hash_map<tree_operand_hash, tree>;\n+  tree &cached = loop_vinfo->ivexpr_map->get_or_insert (expr);\n+  if (! cached)\n+    {\n+      gimple_seq stmts = NULL;\n+      cached = force_gimple_operand (unshare_expr (expr),\n+\t\t\t\t     &stmts, true, NULL_TREE);\n+      if (stmts)\n+\t{\n+\t  edge e = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n+\t  gsi_insert_seq_on_edge_immediate (e, stmts);\n+\t}\n+    }\n+  return cached;\n+}\n+\n /* Return true if we can use CMP_TYPE as the comparison type to produce\n    all masks required to mask LOOP_VINFO.  */\n "}, {"sha": "c9f0feac76a032b365cec554556d6799fdb35584", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b210f45f527eb017810af815bbb97a8f6939385f/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b210f45f527eb017810af815bbb97a8f6939385f/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=b210f45f527eb017810af815bbb97a8f6939385f", "patch": "@@ -188,7 +188,7 @@ vect_free_oprnd_info (vec<slp_oprnd_info> &oprnds_info)\n /* Find the place of the data-ref in STMT in the interleaving chain that starts\n    from FIRST_STMT.  Return -1 if the data-ref is not a part of the chain.  */\n \n-static int\n+int\n vect_get_place_in_interleaving_chain (gimple *stmt, gimple *first_stmt)\n {\n   gimple *next_stmt = first_stmt;"}, {"sha": "64a728eb1294fe579491e95b6f031f5a50dcd4f9", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b210f45f527eb017810af815bbb97a8f6939385f/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b210f45f527eb017810af815bbb97a8f6939385f/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b210f45f527eb017810af815bbb97a8f6939385f", "patch": "@@ -6455,7 +6455,6 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       tree offvar;\n       tree ivstep;\n       tree running_off;\n-      gimple_seq stmts = NULL;\n       tree stride_base, stride_step, alias_off;\n       tree vec_oprnd;\n       unsigned int g;\n@@ -6467,11 +6466,11 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n       stride_base\n \t= fold_build_pointer_plus\n-\t    (unshare_expr (DR_BASE_ADDRESS (first_dr)),\n+\t    (DR_BASE_ADDRESS (first_dr),\n \t     size_binop (PLUS_EXPR,\n-\t\t\t convert_to_ptrofftype (unshare_expr (DR_OFFSET (first_dr))),\n+\t\t\t convert_to_ptrofftype (DR_OFFSET (first_dr)),\n \t\t\t convert_to_ptrofftype (DR_INIT (first_dr))));\n-      stride_step = fold_convert (sizetype, unshare_expr (DR_STEP (first_dr)));\n+      stride_step = fold_convert (sizetype, DR_STEP (first_dr));\n \n       /* For a store with loop-invariant (but other than power-of-2)\n          stride (i.e. not a grouped access) like so:\n@@ -6563,15 +6562,15 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n       standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n \n+      stride_base = cse_and_gimplify_to_preheader (loop_vinfo, stride_base);\n+      ivstep = cse_and_gimplify_to_preheader (loop_vinfo, ivstep);\n       create_iv (stride_base, ivstep, NULL,\n \t\t loop, &incr_gsi, insert_after,\n \t\t &offvar, NULL);\n       incr = gsi_stmt (incr_gsi);\n       set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo));\n \n-      stride_step = force_gimple_operand (stride_step, &stmts, true, NULL_TREE);\n-      if (stmts)\n-\tgsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+      stride_step = cse_and_gimplify_to_preheader (loop_vinfo, stride_step);\n \n       prev_stmt_info = NULL;\n       alias_off = build_int_cst (ref_type, 0);\n@@ -7484,27 +7483,37 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       tree ivstep;\n       tree running_off;\n       vec<constructor_elt, va_gc> *v = NULL;\n-      gimple_seq stmts = NULL;\n       tree stride_base, stride_step, alias_off;\n       /* Checked by get_load_store_type.  */\n       unsigned int const_nunits = nunits.to_constant ();\n+      unsigned HOST_WIDE_INT cst_offset = 0;\n \n       gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n       gcc_assert (!nested_in_vect_loop);\n \n-      if (slp && grouped_load)\n+      if (grouped_load)\n \t{\n \t  first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n \t  first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-\t  group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n-\t  ref_type = get_group_alias_ptr_type (first_stmt);\n \t}\n       else\n \t{\n \t  first_stmt = stmt;\n \t  first_dr = dr;\n+\t}\n+      if (slp && grouped_load)\n+\t{\n+\t  group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+\t  ref_type = get_group_alias_ptr_type (first_stmt);\n+\t}\n+      else\n+\t{\n+\t  if (grouped_load)\n+\t    cst_offset\n+\t      = (tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (vectype)))\n+\t\t * vect_get_place_in_interleaving_chain (stmt, first_stmt));\n \t  group_size = 1;\n-\t  ref_type = reference_alias_ptr_type (DR_REF (first_dr));\n+\t  ref_type = reference_alias_ptr_type (DR_REF (dr));\n \t}\n \n       stride_base\n@@ -7536,16 +7545,15 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n       standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n \n-      create_iv (unshare_expr (stride_base), unshare_expr (ivstep), NULL,\n+      stride_base = cse_and_gimplify_to_preheader (loop_vinfo, stride_base);\n+      ivstep = cse_and_gimplify_to_preheader (loop_vinfo, ivstep);\n+      create_iv (stride_base, ivstep, NULL,\n \t\t loop, &incr_gsi, insert_after,\n \t\t &offvar, NULL);\n       incr = gsi_stmt (incr_gsi);\n       set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo));\n \n-      stride_step = force_gimple_operand (unshare_expr (stride_step),\n-\t\t\t\t\t  &stmts, true, NULL_TREE);\n-      if (stmts)\n-\tgsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+      stride_step = cse_and_gimplify_to_preheader (loop_vinfo, stride_step);\n \n       prev_stmt_info = NULL;\n       running_off = offvar;\n@@ -7634,7 +7642,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  for (i = 0; i < nloads; i++)\n \t    {\n \t      tree this_off = build_int_cst (TREE_TYPE (alias_off),\n-\t\t\t\t\t     group_el * elsz);\n+\t\t\t\t\t     group_el * elsz + cst_offset);\n \t      new_stmt = gimple_build_assign (make_ssa_name (ltype),\n \t\t\t\t\t      build2 (MEM_REF, ltype,\n \t\t\t\t\t\t      running_off, this_off));"}, {"sha": "33e6a915ea4b19946d6e8590e97688764a22a9f5", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b210f45f527eb017810af815bbb97a8f6939385f/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b210f45f527eb017810af815bbb97a8f6939385f/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b210f45f527eb017810af815bbb97a8f6939385f", "patch": "@@ -440,6 +440,9 @@ typedef struct _loop_vec_info : public vec_info {\n   /* Cost vector for a single scalar iteration.  */\n   auto_vec<stmt_info_for_cost> scalar_cost_vec;\n \n+  /* Map of IV base/step expressions to inserted name in the preheader.  */\n+  hash_map<tree_operand_hash, tree> *ivexpr_map;\n+\n   /* The unrolling factor needed to SLP the loop. In case of that pure SLP is\n      applied to the loop, i.e., no unrolling is needed, this is 1.  */\n   poly_uint64 slp_unrolling_factor;\n@@ -1544,6 +1547,7 @@ extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,\n \t\t\t\t\tstmt_vector_for_cost *,\n \t\t\t\t\tstmt_vector_for_cost *,\n \t\t\t\t\tstmt_vector_for_cost *);\n+extern tree cse_and_gimplify_to_preheader (loop_vec_info, tree);\n \n /* In tree-vect-slp.c.  */\n extern void vect_free_slp_instance (slp_instance);\n@@ -1564,6 +1568,7 @@ extern bool can_duplicate_and_interleave_p (unsigned int, machine_mode,\n \t\t\t\t\t    tree * = NULL, tree * = NULL);\n extern void duplicate_and_interleave (gimple_seq *, tree, vec<tree>,\n \t\t\t\t      unsigned int, vec<tree> &);\n+extern int vect_get_place_in_interleaving_chain (gimple *, gimple *);\n \n /* In tree-vect-patterns.c.  */\n /* Pattern recognition functions."}]}