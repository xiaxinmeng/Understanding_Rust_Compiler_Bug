{"sha": "93c76f816d844a650535ebbf46c0ea794a7f60cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNjNzZmODE2ZDg0NGE2NTA1MzVlYmJmNDZjMGVhNzk0YTdmNjBjYw==", "commit": {"author": {"name": "Andreas Tobler", "email": "a.tobler@schweiz.ch", "date": "2005-07-10T20:14:37Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2005-07-10T20:14:37Z"}, "message": "cls_5_1_byte.c: New test file.\n\n2005-07-10  Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* testsuite/libffi.call/cls_5_1_byte.c: New test file.\n\t* testsuite/libffi.call/cls_6_1_byte.c: Likewise.\n\t* testsuite/libffi.call/cls_7_1_byte.c: Likewise.\n\nFrom-SVN: r101855", "tree": {"sha": "ef16939832f312d851a1e47e1dbee2099aa4fe6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef16939832f312d851a1e47e1dbee2099aa4fe6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93c76f816d844a650535ebbf46c0ea794a7f60cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c76f816d844a650535ebbf46c0ea794a7f60cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93c76f816d844a650535ebbf46c0ea794a7f60cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c76f816d844a650535ebbf46c0ea794a7f60cc/comments", "author": null, "committer": null, "parents": [{"sha": "46c73d9a4f2a4e5309a682f669154ad0922af17d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c73d9a4f2a4e5309a682f669154ad0922af17d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46c73d9a4f2a4e5309a682f669154ad0922af17d"}], "stats": {"total": 366, "additions": 366, "deletions": 0}, "files": [{"sha": "227f66015ff8e061b6f0aee60ef359f7c46753a1", "filename": "libffi/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c76f816d844a650535ebbf46c0ea794a7f60cc/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c76f816d844a650535ebbf46c0ea794a7f60cc/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=93c76f816d844a650535ebbf46c0ea794a7f60cc", "patch": "@@ -1,3 +1,9 @@\n+2005-07-10  Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\t* testsuite/libffi.call/cls_5_1_byte.c: New test file.\n+\t* testsuite/libffi.call/cls_6_1_byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_7_1_byte.c: Likewise.\n+\n 2005-07-05  Randolph Chung  <tausq@debian.org>\n \n \t* src/pa/ffi.c (ffi_struct_type): Rename FFI_TYPE_SMALL_STRUCT1"}, {"sha": "e0471682eb1959f209afce7dc0775158980b9760", "filename": "libffi/testsuite/libffi.call/cls_5_1_byte.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c76f816d844a650535ebbf46c0ea794a7f60cc/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5_1_byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c76f816d844a650535ebbf46c0ea794a7f60cc/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5_1_byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5_1_byte.c?ref=93c76f816d844a650535ebbf46c0ea794a7f60cc", "patch": "@@ -0,0 +1,116 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20050708\t */\n+\n+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_5byte {\n+  unsigned char a;\n+  unsigned char b;\n+  unsigned char c;\n+  unsigned char d;\n+  unsigned char e;\n+} cls_struct_5byte;\n+\n+cls_struct_5byte cls_struct_5byte_fn(struct cls_struct_5byte a1,\n+\t\t\t    struct cls_struct_5byte a2)\n+{\n+  struct cls_struct_5byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+  result.d = a1.d + a2.d;\n+  result.e = a1.e + a2.e;\n+\n+  printf(\"%d %d %d %d %d %d %d %d %d %d: %d %d %d %d %d\\n\",\n+\t a1.a, a1.b, a1.c, a1.d, a1.e,\n+\t a2.a, a2.b, a2.c, a2.d, a2.e,\n+\t result.a, result.b, result.c, result.d, result.e);\n+\n+  return  result;\n+}\n+\n+static void\n+cls_struct_5byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{\n+\n+  struct cls_struct_5byte a1, a2;\n+\n+  a1 = *(struct cls_struct_5byte*)(args[0]);\n+  a2 = *(struct cls_struct_5byte*)(args[1]);\n+\n+  *(cls_struct_5byte*)resp = cls_struct_5byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[6];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_5byte g_dbl = { 127, 120, 1, 3, 4 };\n+  struct cls_struct_5byte f_dbl = { 12, 128, 9, 3, 4 };\n+  struct cls_struct_5byte res_dbl = { 0, 0, 0, 0, 0 };\n+\n+  cls_struct_fields[0] = &ffi_type_uchar;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = &ffi_type_uchar;\n+  cls_struct_fields[3] = &ffi_type_uchar;\n+  cls_struct_fields[4] = &ffi_type_uchar;\n+  cls_struct_fields[5] = NULL;\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_5byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"127 120 1 3 4 12 128 9 3 4: 139 248 10 6 8\" } */\n+  printf(\"res: %d %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n+\t res_dbl.d, res_dbl.e);\n+  /* { dg-output \"\\nres: 139 248 10 6 8\" } */\n+\n+  res_dbl.a = 0;\n+  res_dbl.b = 0;\n+  res_dbl.c = 0;\n+  res_dbl.d = 0;\n+  res_dbl.e = 0;\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_5byte_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((cls_struct_5byte(*)(cls_struct_5byte, cls_struct_5byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n127 120 1 3 4 12 128 9 3 4: 139 248 10 6 8\" } */\n+  printf(\"res: %d %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n+\t res_dbl.d, res_dbl.e);\n+  /* { dg-output \"\\nres: 139 248 10 6 8\" } */\n+\n+  exit(0);\n+}"}, {"sha": "22c575d640c237d1cd60f8188f59ee63ee0ec293", "filename": "libffi/testsuite/libffi.call/cls_6_1_byte.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c76f816d844a650535ebbf46c0ea794a7f60cc/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6_1_byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c76f816d844a650535ebbf46c0ea794a7f60cc/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6_1_byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6_1_byte.c?ref=93c76f816d844a650535ebbf46c0ea794a7f60cc", "patch": "@@ -0,0 +1,120 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20050708\t */\n+\n+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_6byte {\n+  unsigned char a;\n+  unsigned char b;\n+  unsigned char c;\n+  unsigned char d;\n+  unsigned char e;\n+  unsigned char f;\n+} cls_struct_6byte;\n+\n+cls_struct_6byte cls_struct_6byte_fn(struct cls_struct_6byte a1,\n+\t\t\t    struct cls_struct_6byte a2)\n+{\n+  struct cls_struct_6byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+  result.d = a1.d + a2.d;\n+  result.e = a1.e + a2.e;\n+  result.f = a1.f + a2.f;\n+\n+  printf(\"%d %d %d %d %d %d %d %d %d %d %d %d: %d %d %d %d %d %d\\n\",\n+\t a1.a, a1.b, a1.c, a1.d, a1.e, a1.f,\n+\t a2.a, a2.b, a2.c, a2.d, a2.e, a2.f,\n+\t result.a, result.b, result.c, result.d, result.e, result.f);\n+\n+  return  result;\n+}\n+\n+static void\n+cls_struct_6byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{\n+\n+  struct cls_struct_6byte a1, a2;\n+\n+  a1 = *(struct cls_struct_6byte*)(args[0]);\n+  a2 = *(struct cls_struct_6byte*)(args[1]);\n+\n+  *(cls_struct_6byte*)resp = cls_struct_6byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[7];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_6byte g_dbl = { 127, 120, 1, 3, 4, 5 };\n+  struct cls_struct_6byte f_dbl = { 12, 128, 9, 3, 4, 5 };\n+  struct cls_struct_6byte res_dbl = { 0, 0, 0, 0, 0, 0 };\n+\n+  cls_struct_fields[0] = &ffi_type_uchar;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = &ffi_type_uchar;\n+  cls_struct_fields[3] = &ffi_type_uchar;\n+  cls_struct_fields[4] = &ffi_type_uchar;\n+  cls_struct_fields[5] = &ffi_type_uchar;\n+  cls_struct_fields[6] = NULL;\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_6byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"127 120 1 3 4 5 12 128 9 3 4 5: 139 248 10 6 8 10\" } */\n+  printf(\"res: %d %d %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n+\t res_dbl.d, res_dbl.e, res_dbl.f);\n+  /* { dg-output \"\\nres: 139 248 10 6 8 10\" } */\n+\n+  res_dbl.a = 0;\n+  res_dbl.b = 0;\n+  res_dbl.c = 0;\n+  res_dbl.d = 0;\n+  res_dbl.e = 0;\n+  res_dbl.f = 0;\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_6byte_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((cls_struct_6byte(*)(cls_struct_6byte, cls_struct_6byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n127 120 1 3 4 5 12 128 9 3 4 5: 139 248 10 6 8 10\" } */\n+  printf(\"res: %d %d %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n+\t res_dbl.d, res_dbl.e, res_dbl.f);\n+  /* { dg-output \"\\nres: 139 248 10 6 8 10\" } */\n+\n+  exit(0);\n+}"}, {"sha": "43df48727885736770327b3db04b27c7a2032174", "filename": "libffi/testsuite/libffi.call/cls_7_1_byte.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c76f816d844a650535ebbf46c0ea794a7f60cc/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7_1_byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c76f816d844a650535ebbf46c0ea794a7f60cc/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7_1_byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7_1_byte.c?ref=93c76f816d844a650535ebbf46c0ea794a7f60cc", "patch": "@@ -0,0 +1,124 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20050708\t */\n+\n+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_7byte {\n+  unsigned char a;\n+  unsigned char b;\n+  unsigned char c;\n+  unsigned char d;\n+  unsigned char e;\n+  unsigned char f;\n+  unsigned char g;\n+} cls_struct_7byte;\n+\n+cls_struct_7byte cls_struct_7byte_fn(struct cls_struct_7byte a1,\n+\t\t\t    struct cls_struct_7byte a2)\n+{\n+  struct cls_struct_7byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+  result.d = a1.d + a2.d;\n+  result.e = a1.e + a2.e;\n+  result.f = a1.f + a2.f;\n+  result.g = a1.g + a2.g;\n+\n+  printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d %d %d %d %d %d %d\\n\",\n+\t a1.a, a1.b, a1.c, a1.d, a1.e, a1.f, a1.g,\n+\t a2.a, a2.b, a2.c, a2.d, a2.e, a2.f, a2.g,\n+\t result.a, result.b, result.c, result.d, result.e, result.f, result.g);\n+\n+  return  result;\n+}\n+\n+static void\n+cls_struct_7byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{\n+\n+  struct cls_struct_7byte a1, a2;\n+\n+  a1 = *(struct cls_struct_7byte*)(args[0]);\n+  a2 = *(struct cls_struct_7byte*)(args[1]);\n+\n+  *(cls_struct_7byte*)resp = cls_struct_7byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[8];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_7byte g_dbl = { 127, 120, 1, 3, 4, 5, 6 };\n+  struct cls_struct_7byte f_dbl = { 12, 128, 9, 3, 4, 5, 6 };\n+  struct cls_struct_7byte res_dbl = { 0, 0, 0, 0, 0, 0, 0 };\n+\n+  cls_struct_fields[0] = &ffi_type_uchar;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = &ffi_type_uchar;\n+  cls_struct_fields[3] = &ffi_type_uchar;\n+  cls_struct_fields[4] = &ffi_type_uchar;\n+  cls_struct_fields[5] = &ffi_type_uchar;\n+  cls_struct_fields[6] = &ffi_type_uchar;\n+  cls_struct_fields[7] = NULL;\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_7byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"127 120 1 3 4 5 6 12 128 9 3 4 5 6: 139 248 10 6 8 10 12\" } */\n+  printf(\"res: %d %d %d %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n+\t res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);\n+  /* { dg-output \"\\nres: 139 248 10 6 8 10 12\" } */\n+\n+  res_dbl.a = 0;\n+  res_dbl.b = 0;\n+  res_dbl.c = 0;\n+  res_dbl.d = 0;\n+  res_dbl.e = 0;\n+  res_dbl.f = 0;\n+  res_dbl.g = 0;\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_7byte_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((cls_struct_7byte(*)(cls_struct_7byte, cls_struct_7byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n127 120 1 3 4 5 6 12 128 9 3 4 5 6: 139 248 10 6 8 10 12\" } */\n+  printf(\"res: %d %d %d %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n+\t res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);\n+  /* { dg-output \"\\nres: 139 248 10 6 8 10 12\" } */\n+\n+  exit(0);\n+}"}]}