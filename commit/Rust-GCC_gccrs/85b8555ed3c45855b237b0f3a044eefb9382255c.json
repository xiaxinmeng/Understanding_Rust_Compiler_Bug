{"sha": "85b8555ed3c45855b237b0f3a044eefb9382255c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODViODU1NWVkM2M0NTg1NWIyMzdiMGYzYTA0NGVlZmI5MzgyMjU1Yw==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2011-11-29T21:36:43Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2011-11-29T21:36:43Z"}, "message": ".\n\n\t* configure.ac (rl78-*-*) New case.\n\t* configure: Regenerate.\n\t* MAINTAINERS: Add myself as RL78 maintainer.\n\nlibgcc\n\t* config.host (rl78-*-elf): New case.\n\t* config/rl78: New directory for the Renesas RL78.\n\ngcc\n\t* config.gcc (rl78-*-elf): New case.\n\t* doc/extend.texi: Add RL78 documentation.\n\t* doc/invoke.texi: Likewise.\n\t* doc/md.texi: Likewise.\n\t* doc/contrib.texi: Add RL78.\n\t* doc/install.texi: Add rl78-*-elf.\n\t* config/rl78: New directory for the Renesas RL78.\n\ncontrib\n\t* config-list.mk (LIST): Add rl78-elf.\n\nFrom-SVN: r181819", "tree": {"sha": "65c814557c3c0e61f746e922c96ca834174464c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65c814557c3c0e61f746e922c96ca834174464c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85b8555ed3c45855b237b0f3a044eefb9382255c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b8555ed3c45855b237b0f3a044eefb9382255c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b8555ed3c45855b237b0f3a044eefb9382255c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b8555ed3c45855b237b0f3a044eefb9382255c/comments", "author": null, "committer": null, "parents": [{"sha": "c360c0fb8a1dd8ef61d986671d02071075d2c0b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c360c0fb8a1dd8ef61d986671d02071075d2c0b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c360c0fb8a1dd8ef61d986671d02071075d2c0b9"}], "stats": {"total": 6103, "additions": 6095, "deletions": 8}, "files": [{"sha": "61bb4d5a37e0127d9f1a8b8b3c6dea4b310fb9f1", "filename": "ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -1,3 +1,9 @@\n+2011-11-29  DJ Delorie  <dj@redhat.com>\n+\n+\t* configure.ac (rl78-*-*) New case.\n+\t* configure: Regenerate.\n+\t* MAINTAINERS: Add myself as RL78 maintainer.\n+\n 2011-11-21  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* MAINTAINERS: Add self as co-maintainer of the Ada front end."}, {"sha": "cad649c16c19f38c94d9c1e2a5cc85b9a28976f2", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -87,6 +87,7 @@ moxie port\t\tAnthony Green\t\tgreen@moxielogic.com\n pdp11 port\t\tPaul Koning\t\tni1d@arrl.net\n picochip port\t\tHariharan Sandanagobalane\thariharan@picochip.com\n picochip port\t\tDaniel Towner\t\tdant@picochip.com\n+rl78 port\t\tDJ Delorie\t\tdj@redhat.com\n rs6000 port\t\tGeoff Keating\t\tgeoffk@geoffk.org\n rs6000 port\t\tDavid Edelsohn\t\tdje.gcc@gmail.com\n rs6000 vector extns\tAldy Hernandez\t\taldyh@redhat.com"}, {"sha": "c4a79dc50fc7bbc873da8ece0546d6721e7eac71", "filename": "configure", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -3092,6 +3092,10 @@ case \"${target}\" in\n   powerpc-*-aix* | rs6000-*-aix*)\n     noconfigdirs=\"$noconfigdirs target-libssp\"\n     ;;\n+  rl78-*-*)\n+    # Dereferencing -1 is a compile-time error\n+    noconfigdirs=\"$noconfigdirs target-libssp\"\n+    ;;\n esac\n \n # Disable libstdc++-v3 for some systems."}, {"sha": "9fee56378e184a3c192d8c7fdb1740f954b489e5", "filename": "configure.ac", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -518,6 +518,12 @@ case \"${target}\" in\n   powerpc-*-aix* | rs6000-*-aix*)\n     noconfigdirs=\"$noconfigdirs target-libssp\"\n     ;;\n+  rl78-*-*)\n+    # libssp uses a misaligned load to trigger a fault, but the RL78\n+    # doesn't fault for those - instead, it gives a build-time error\n+    # for explicit misaligned loads.\n+    noconfigdirs=\"$noconfigdirs target-libssp\"\n+    ;;\n esac\n \n # Disable libstdc++-v3 for some systems."}, {"sha": "26d5959085257ef3a903f11a2357ce2601e08628", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -1,3 +1,7 @@\n+2011-11-29  DJ Delorie  <dj@redhat.com>\n+\n+\t* config-list.mk (LIST): Add rl78-elf.\n+\n 2011-11-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* make_sunver.pl: Convert '?' in glob patterns to '.'."}, {"sha": "7d03cd3fae2b40f50c6e08870d095db00f010634", "filename": "contrib/config-list.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/contrib%2Fconfig-list.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/contrib%2Fconfig-list.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconfig-list.mk?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -53,7 +53,7 @@ LIST = alpha-linux-gnu alpha-freebsd6 alpha-netbsd alpha-openbsd \\\n   powerpc-wrs-vxworks powerpc-wrs-vxworksae powerpc-lynxos powerpcle-elf \\\n   powerpcle-eabisim powerpcle-eabi rs6000-ibm-aix4.3 rs6000-ibm-aix5.1.0 \\\n   rs6000-ibm-aix5.2.0 rs6000-ibm-aix5.3.0 rs6000-ibm-aix6.0 \\\n-  rx-elf s390-linux-gnu s390x-linux-gnu s390x-ibm-tpf sh-elf \\\n+  rl78-elf rx-elf s390-linux-gnu s390x-linux-gnu s390x-ibm-tpf sh-elf \\\n   shle-linux sh-netbsdelf sh-superh-elf sh5el-netbsd sh64-netbsd sh64-linux \\\n   sh64-elfOPT-with-newlib sh-rtems sh-wrs-vxworks sparc-elf \\\n   sparc-leon-elf sparc-rtems sparc-linux-gnu \\"}, {"sha": "6ac5db9183f849b03b3a2557667034ccc2ab539c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -1,3 +1,13 @@\n+2011-11-29  DJ Delorie  <dj@redhat.com>\n+\n+\t* config.gcc (rl78-*-elf): New case.\n+\t* doc/extend.texi: Add RL78 documentation.\n+\t* doc/invoke.texi: Likewise.\n+\t* doc/md.texi: Likewise.\n+\t* doc/contrib.texi: Add RL78.\n+\t* doc/install.texi: Add rl78-*-elf.\n+\t* config/rl78: New directory for the Renesas RL78.\n+\n 2011-11-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/51247"}, {"sha": "a4772892b45b33cf1ea8ae6abef87ae5c2529673", "filename": "gcc/config.gcc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -2115,6 +2115,13 @@ rs6000-ibm-aix[6789].* | powerpc-ibm-aix[6789].*)\n \tuse_gcc_stdint=wrap\n \textra_headers=altivec.h\n \t;;\n+rl78-*-elf*)\n+\ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file}\"\n+\ttarget_has_targetm_common=no\n+\tc_target_objs=\"rl78-c.o\"\n+\tcxx_target_objs=\"rl78-c.o\"\n+\ttmake_file=\"${tmake_file} rl78/t-rl78\"\n+\t;;\n rx-*-elf*)\n \ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file}\"\n \ttmake_file=\"${tmake_file} rx/t-rx\""}, {"sha": "a89e1a244e4bc507201db5c7f79095b276b84ab4", "filename": "gcc/config/rl78/constraints.md", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Fconstraints.md?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,266 @@\n+;;  Machine Description for Renesas RL78 processors\n+;;  Copyright (C) 2011 Free Software Foundation, Inc.\n+;;  Contributed by Red Hat.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\f\n+; Constraints in use:\n+\n+; core:\n+; V X g i m n o p r s < >\n+; 0..9\n+; I..Q - integers\n+;   Int8 = 0..255\n+;   Int3 = 1..7\n+;   J = -255..0\n+;   K = 1\n+;   L = -1\n+;   M = 0\n+;   N = 2\n+;   O = -2\n+;   P = 1..15\n+\n+; E..H - float constants\n+\n+; RL78-specific\n+; a x b c d e h l w - 8-bit regs\n+; A B D T S - 16-bit regs\n+; R = all regular registers (A-L)\n+; Y - any valid memory\n+; Wxx - various memory addressing modes\n+; Qxx - conditionals\n+; v = virtual registers\n+; Zxx = specific virtual registers\n+\n+(define_constraint \"Int8\"\n+  \"Integer constant in the range 0 @dots{} 255.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 0, 255)\")))\n+\n+(define_constraint \"Int3\"\n+  \"Integer constant in the range 1 @dots{} 7.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 1, 7)\")))\n+\n+(define_constraint \"J\"\n+  \"Integer constant in the range -255 @dots{} 0\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -255, 0)\")))\n+\n+(define_constraint \"K\"\n+  \"Integer constant 1.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 1, 1)\")))\n+\n+(define_constraint \"L\"\n+  \"Integer constant -1.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -1, -1)\")))\n+\n+(define_constraint \"M\"\n+  \"Integer constant 0.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 0, 0)\")))\n+\n+(define_constraint \"N\"\n+  \"Integer constant 2.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 2, 2)\")))\n+\n+(define_constraint \"O\"\n+  \"Integer constant -2.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -2, -2)\")))\n+\n+(define_constraint \"P\"\n+  \"Integer constant 1..15\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 1, 15)\")))\n+\n+(define_register_constraint \"R\" \"QI_REGS\"\n+ \"@code{A} through @code{L} registers.\")\n+\n+(define_register_constraint \"a\" \"AREG\"\n+ \"The @code{A} register.\")\n+\n+(define_register_constraint \"x\" \"XREG\"\n+ \"The @code{X} register.\")\n+\n+(define_register_constraint \"b\" \"BREG\"\n+ \"The @code{B} register.\")\n+\n+(define_register_constraint \"c\" \"CREG\"\n+ \"The @code{C} register.\")\n+\n+(define_register_constraint \"d\" \"DREG\"\n+ \"The @code{D} register.\")\n+\n+(define_register_constraint \"e\" \"EREG\"\n+ \"The @code{E} register.\")\n+\n+(define_register_constraint \"h\" \"HREG\"\n+ \"The @code{H} register.\")\n+\n+(define_register_constraint \"l\" \"LREG\"\n+ \"The @code{L} register.\")\n+\n+(define_register_constraint \"w\" \"PSWREG\"\n+ \"The @code{PSW} register.\")\n+\n+(define_register_constraint \"A\" \"AXREG\"\n+ \"The @code{AX} register.\")\n+\n+(define_register_constraint \"B\" \"BCREG\"\n+ \"The @code{BC} register.\")\n+\n+(define_register_constraint \"D\" \"DEREG\"\n+ \"The @code{DE} register.\")\n+\n+; because H + L = T, assuming A=1.\n+(define_register_constraint \"T\" \"HLREG\"\n+ \"The @code{HL} register.\")\n+\n+(define_register_constraint \"S\" \"SPREG\"\n+ \"The @code{SP} register.\")\n+\n+(define_register_constraint \"v\" \"V_REGS\"\n+ \"The virtual registers.\")\n+\n+(define_register_constraint \"Z08W\" \"R8W_REGS\"\n+ \"The R8 register, HImode.\")\n+\n+(define_register_constraint \"Z10W\" \"R10W_REGS\"\n+ \"The R10 register, HImode.\")\n+\n+(define_register_constraint \"Zint\" \"INT_REGS\"\n+ \"The interrupt registers.\")\n+\n+; All the memory addressing schemes the RL78 supports\n+; of the form W {register} {bytes of offset}\n+;          or W {register} {register}\n+\n+; absolute address\n+(define_memory_constraint \"Wab\"\n+  \"[addr]\"\n+  (and (match_code \"mem\")\n+       (ior (match_test \"CONSTANT_P (XEXP (op, 0))\")\n+\t    (match_test \"GET_CODE (XEXP (op, 0)) == PLUS && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\"))\n+\t    )\n+  )\n+\n+(define_memory_constraint \"Wbc\"\n+  \"word16[BC]\"\n+  (and (match_code \"mem\")\n+       (ior\n+\t(and (match_code \"reg\" \"0\")\n+\t     (match_test \"REGNO (XEXP (op, 0)) == BC_REG\"))\n+\t(and (match_code \"plus\" \"0\")\n+\t     (and (and (match_code \"reg\" \"00\")\n+\t\t       (match_test \"REGNO (XEXP (XEXP (op, 0), 0)) == BC_REG\"))\n+\t\t       (match_test \"uword_operand (XEXP (XEXP (op, 0), 1), VOIDmode)\"))))\n+       )\n+  )\n+\n+(define_memory_constraint \"Wde\"\n+  \"[DE]\"\n+  (and (match_code \"mem\")\n+       (and (match_code \"reg\" \"0\")\n+\t    (match_test \"REGNO (XEXP (op, 0)) == DE_REG\")))\n+  )\n+\n+(define_memory_constraint \"Wca\"\n+  \"[AX..HL] for calls\"\n+  (and (match_code \"mem\")\n+       (and (match_code \"reg\" \"0\")\n+\t    (match_test \"REGNO (XEXP (op, 0)) <= HL_REG\")))\n+  )\n+\n+(define_memory_constraint \"Wcv\"\n+  \"[AX..HL,r8-r23] for calls\"\n+  (and (match_code \"mem\")\n+       (and (match_code \"reg\" \"0\")\n+\t    (match_test \"REGNO (XEXP (op, 0)) < 24\")))\n+  )\n+\n+(define_memory_constraint \"Wd2\"\n+  \"word16[DE]\"\n+  (and (match_code \"mem\")\n+       (ior\n+\t(and (match_code \"reg\" \"0\")\n+\t     (match_test \"REGNO (XEXP (op, 0)) == DE_REG\"))\n+\t(and (match_code \"plus\" \"0\")\n+\t     (and (and (match_code \"reg\" \"00\")\n+\t\t       (match_test \"REGNO (XEXP (XEXP (op, 0), 0)) == DE_REG\"))\n+\t\t       (match_test \"uword_operand (XEXP (XEXP (op, 0), 1), VOIDmode)\"))))\n+       )\n+  )\n+\n+(define_memory_constraint \"Whl\"\n+  \"[HL]\"\n+  (and (match_code \"mem\")\n+       (and (match_code \"reg\" \"0\")\n+\t    (match_test \"REGNO (XEXP (op, 0)) == HL_REG\")))\n+  )\n+\n+(define_memory_constraint \"Wh1\"\n+  \"byte8[HL]\"\n+  (and (match_code \"mem\")\n+       (and (match_code \"plus\" \"0\")\n+\t    (and (and (match_code \"reg\" \"00\")\n+\t\t      (match_test \"REGNO (XEXP (XEXP (op, 0), 0)) == HL_REG\"))\n+\t\t      (match_test \"ubyte_operand (XEXP (XEXP (op, 0), 1), VOIDmode)\"))))\n+  )\n+\n+(define_memory_constraint \"Whb\"\n+  \"[HL+B]\"\n+  (and (match_code \"mem\")\n+       (match_test \"rl78_hl_b_c_addr_p (XEXP (op, 0))\"))\n+  )\n+\n+(define_memory_constraint \"Ws1\"\n+  \"word8[SP]\"\n+  (and (match_code \"mem\")\n+       (ior\n+\t(and (match_code \"reg\" \"0\")\n+\t     (match_test \"REGNO (XEXP (op, 0)) == SP_REG\"))\n+\t(and (match_code \"plus\" \"0\")\n+\t     (and (and (match_code \"reg\" \"00\")\n+\t\t       (match_test \"REGNO (XEXP (XEXP (op, 0), 0)) == SP_REG\"))\n+\t\t       (match_test \"ubyte_operand (XEXP (XEXP (op, 0), 1), VOIDmode)\"))))\n+       )\n+  )\n+\n+(define_memory_constraint \"Wfr\"\n+  \"ES/CS far pointer\"\n+  (and (match_code \"mem\")\n+       (match_test \"rl78_far_p (op)\"))\n+  )\n+\n+(define_memory_constraint \"Y\"\n+  \"any near legitimate memory access\"\n+  (and (match_code \"mem\")\n+       (match_test \"!rl78_far_p (op) && rl78_as_legitimate_address (VOIDmode, XEXP (op, 0), true, ADDR_SPACE_GENERIC)\"))\n+)\n+\n+\n+(define_memory_constraint \"Qbi\"\n+  \"built-in compare types\"\n+  (match_code \"eq,ne,gtu,ltu,geu,leu\"))\n+\n+(define_memory_constraint \"Qsc\"\n+  \"synthetic compares\"\n+  (match_code \"gt,lt,ge,le\"))"}, {"sha": "343cd8aca6f9a8e32172a6f035872b2940823514", "filename": "gcc/config/rl78/predicates.md", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Fpredicates.md?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,60 @@\n+;;  Machine Description for Renesas RL78 processors\n+;;  Copyright (C) 2011 Free Software Foundation, Inc.\n+;;  Contributed by Red Hat.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\f\n+(define_predicate \"rl78_any_operand\"\n+  (ior (match_operand 0 \"general_operand\")\n+       (match_code \"mem,const_int,const_double,reg\"))\n+)\n+\n+(define_predicate \"rl78_nonfar_operand\"\n+  (and (match_operand 0 \"general_operand\")\n+       (not (match_test \"rl78_far_p (op)\")))\n+)\n+\n+(define_predicate \"rl78_nonfar_nonimm_operand\"\n+  (and (match_operand 0 \"nonimmediate_operand\")\n+       (not (match_test \"rl78_far_p (op)\")))\n+)\n+\n+(define_predicate \"ubyte_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 255)\")))\n+\n+(define_predicate \"rl78_24_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 2 || INTVAL (op) == 4\")))\n+\n+(define_predicate \"uword_operand\"\n+  (ior (match_code \"const\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"IN_RANGE (INTVAL (op), 0, 65536)\"))))\n+\n+(define_predicate \"rl78_cmp_operator_real\"\n+  (match_code \"eq,ne,gtu,ltu,geu,leu\"))\n+(define_predicate \"rl78_cmp_operator\"\n+  (match_code \"eq,ne,gtu,ltu,geu,leu,gt,lt,ge,le\"))\n+\n+(define_predicate \"rl78_ax_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == AX_REG || REGNO (op) >= FIRST_PSEUDO_REGISTER\")))\n+\n+(define_predicate \"rl78_addw_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == AX_REG || REGNO (op) == SP_REG || REGNO (op) >= FIRST_PSEUDO_REGISTER\")))"}, {"sha": "98f704c975c74d46717ef1224e1f0080da4b6d76", "filename": "gcc/config/rl78/rl78-c.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-c.c?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,43 @@\n+/* RL78 C-specific support\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Red Hat, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"c-family/c-pragma.h\"\n+#include \"c-family/c-common.h\"\n+#include \"diagnostic-core.h\"\n+#include \"cpplib.h\"\n+#include \"hard-reg-set.h\"\n+#include \"output.h\"\n+#include \"rl78-protos.h\"\n+#include \"function.h\"\n+#define MAX_RECOG_OPERANDS 10\n+#include \"reload.h\"\n+#include \"target.h\"\n+\n+/* Implements REGISTER_TARGET_PRAGMAS.  */\n+void\n+rl78_register_pragmas (void)\n+{\n+  c_register_addr_space (\"__far\", ADDR_SPACE_FAR);\n+}"}, {"sha": "9707e5ba387d7d9a69b72cb6b0d020d8f1942300", "filename": "gcc/config/rl78/rl78-expand.md", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78-expand.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78-expand.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-expand.md?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,256 @@\n+;;  Machine Description for Renesas RL78 processors\n+;;  Copyright (C) 2011 Free Software Foundation, Inc.\n+;;  Contributed by Red Hat.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\f\n+;;---------- Moving ------------------------\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\")\n+\t(match_operand:QI 1 \"general_operand\"))]\n+  \"\"\n+  {\n+    if (MEM_P (operand0) && MEM_P (operand1))\n+      operands[1] = copy_to_mode_reg (QImode, operand1);\n+    if (rl78_far_p (operand0) && rl78_far_p (operand1))\n+      operands[1] = copy_to_mode_reg (QImode, operand1);\n+\n+    /* FIXME: Not sure how GCC can generate (SUBREG (SYMBOL_REF)),\n+       but it does.  Since this makes no sense, reject it here.  */\n+    if (GET_CODE (operand1) == SUBREG\n+        && GET_CODE (XEXP (operand1, 0)) == SYMBOL_REF)\n+      FAIL;\n+\n+    if (CONST_INT_P (operand1) && ! IN_RANGE (INTVAL (operand1), (-1 << 8) + 1, (1 << 8) - 1))\n+      gcc_unreachable();\n+  }\n+)\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\")\n+\t(match_operand:HI 1 \"general_operand\"))]\n+  \"\"\n+  {\n+    if (MEM_P (operand0) && MEM_P (operand1))\n+      operands[1] = copy_to_mode_reg (HImode, operand1);\n+    if (rl78_far_p (operand0) && rl78_far_p (operand1))\n+      operands[1] = copy_to_mode_reg (HImode, operand1);\n+\n+    /* FIXME: Not sure how GCC can generate (SUBREG (SYMBOL_REF)),\n+       but it does.  Since this makes no sense, reject it here.  */\n+    if (GET_CODE (operand1) == SUBREG\n+        && GET_CODE (XEXP (operand1, 0)) == SYMBOL_REF)\n+      FAIL;\n+  }\n+)\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\")\n+\t(match_operand:SI 1 \"general_operand\"))]\n+  \"\"\n+  {\n+    rl78_expand_movsi (operands);\n+    DONE;\n+  }\n+)\n+\n+;;---------- Conversions ------------------------\n+\n+(define_expand \"zero_extendqihi2\"\n+  [(set (match_operand:HI                 0 \"nonimmediate_operand\")\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand\")))]\n+  \"\"\n+  \"if (rl78_force_nonfar_2 (operands, gen_zero_extendqihi2))\n+     DONE;\"\n+  )\n+\n+(define_expand \"extendqihi2\"\n+  [(set (match_operand:HI                 0 \"nonimmediate_operand\")\n+\t(sign_extend:HI (match_operand:QI 1 \"general_operand\")))]\n+  \"\"\n+  \"if (rl78_force_nonfar_2 (operands, gen_extendqihi2))\n+     DONE;\"\n+  )\n+\n+;;---------- Arithmetic ------------------------\n+\n+(define_expand \"add<mode>3\"\n+  [(set (match_operand:QHI           0 \"nonimmediate_operand\")\n+\t(plus:QHI (match_operand:QHI 1 \"general_operand\")\n+\t\t  (match_operand:QHI 2 \"general_operand\")))\n+   ]\n+  \"\"\n+  \"if (rl78_force_nonfar_3 (operands, gen_add<mode>3))\n+     DONE;\"\n+)\n+\n+(define_expand \"sub<mode>3\"\n+  [(set (match_operand:QHI            0 \"nonimmediate_operand\")\n+\t(minus:QHI (match_operand:QHI 1 \"general_operand\")\n+\t\t   (match_operand:QHI 2 \"general_operand\")))\n+   ]\n+  \"\"\n+  \"if (rl78_force_nonfar_3 (operands, gen_sub<mode>3))\n+     DONE;\"\n+)\n+\n+(define_expand \"neg<mode>2\"\n+  [(set (match_operand:QHI            0 \"nonimmediate_operand\")\n+\t(minus:QHI (const_int 0)\n+\t\t   (match_operand:QHI 1 \"general_operand\")))\n+   ]\n+  \"\"\n+  \"if (rl78_force_nonfar_2 (operands, gen_neg<mode>2))\n+     DONE;\"\n+)\n+\n+(define_expand \"umulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\")\n+        (mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\"))\n+                 (zero_extend:HI (match_operand:QI 2 \"register_operand\"))))]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_expand \"andqi3\"\n+  [(set (match_operand:QI         0 \"nonimmediate_operand\")\n+\t(and:QI (match_operand:QI 1 \"general_operand\")\n+\t\t(match_operand:QI 2 \"general_operand\")))\n+   ]\n+  \"\"\n+  \"if (rl78_force_nonfar_3 (operands, gen_andqi3))\n+     DONE;\"\n+)\n+\n+(define_expand \"iorqi3\"\n+  [(set (match_operand:QI         0 \"nonimmediate_operand\")\n+\t(ior:QI (match_operand:QI 1 \"general_operand\")\n+\t\t(match_operand:QI 2 \"general_operand\")))\n+   ]\n+  \"\"\n+  \"if (rl78_force_nonfar_3 (operands, gen_iorqi3))\n+     DONE;\"\n+)\n+\n+(define_expand \"xorqi3\"\n+  [(set (match_operand:QI         0 \"nonimmediate_operand\")\n+\t(xor:QI (match_operand:QI 1 \"general_operand\")\n+\t\t(match_operand:QI 2 \"general_operand\")))\n+   ]\n+  \"\"\n+  \"if (rl78_force_nonfar_3 (operands, gen_xorqi3))\n+     DONE;\"\n+)\n+\n+(define_expand \"one_cmplqi2\"\n+  [(set (match_operand:QI         0 \"nonimmediate_operand\")\n+\t(xor:QI (match_operand:QI 1 \"general_operand\")\n+\t\t(const_int 255)))\n+   ]\n+  \"\"\n+  \"if (rl78_force_nonfar_2 (operands, gen_one_cmplqi2))\n+     DONE;\"\n+)\n+\n+;;---------- Shifts ------------------------\n+\n+(define_expand \"ashl<mode>3\"\n+  [(set (match_operand:QHI             0 \"nonimmediate_operand\")\n+\t(ashift:QHI (match_operand:QHI 1 \"general_operand\")\n+\t\t    (match_operand:QI  2 \"general_operand\")))\n+   ]\n+  \"\"\n+  \"if (rl78_force_nonfar_3 (operands, gen_ashl<mode>3))\n+     DONE;\"\n+)\n+\n+(define_expand \"ashr<mode>3\"\n+  [(set (match_operand:QHI               0 \"nonimmediate_operand\")\n+\t(ashiftrt:QHI (match_operand:QHI 1 \"general_operand\")\n+\t\t      (match_operand:QI  2 \"general_operand\")))\n+   ]\n+  \"\"\n+  \"if (rl78_force_nonfar_3 (operands, gen_ashr<mode>3))\n+     DONE;\"\n+)\n+\n+(define_expand \"lshr<mode>3\"\n+  [(set (match_operand:QHI               0 \"nonimmediate_operand\")\n+\t(lshiftrt:QHI (match_operand:QHI 1 \"general_operand\")\n+\t\t      (match_operand:QI  2 \"general_operand\")))\n+   ]\n+  \"\"\n+  \"if (rl78_force_nonfar_3 (operands, gen_lshr<mode>3))\n+     DONE;\"\n+)\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI               0 \"register_operand\")\n+\t(ashiftrt:SI (match_operand:SI  1 \"register_operand\")\n+\t\t      (match_operand:SI 2 \"immediate_operand\")))\n+   ]\n+  \"\"\n+  \"if (GET_CODE (operands[2]) != CONST_INT)\n+     FAIL;\"\n+)\n+\n+;;---------- Branching ------------------------\n+\n+(define_expand \"indirect_jump\"\n+  [(set (pc)\n+\t(match_operand:HI 0 \"nonimmediate_operand\"))]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_expand \"call\"\n+  [(call (match_operand:HI 0 \"memory_operand\")\n+\t (match_operand 1 \"\"))]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand          0 \"register_operand\")\n+\t(call (match_operand:HI 1 \"memory_operand\")\n+\t      (match_operand    2 \"\")))]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_expand \"cbranchqi4\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator                    0 \"rl78_cmp_operator\"\n+\t\t\t      [(match_operand:QI 1 \"general_operand\")\n+\t\t\t       (match_operand:QI 2 \"general_operand\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"\"\n+  \"rl78_expand_compare (operands);\"\n+)\n+\n+(define_expand \"cbranchhi4\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator                    0 \"rl78_cmp_operator\"\n+\t\t\t      [(match_operand:HI 1 \"general_operand\")\n+\t\t\t       (match_operand:HI 2 \"general_operand\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"\"\n+  \"rl78_expand_compare (operands);\"\n+)"}, {"sha": "c0caa506ca4720ab065309092946adb51b4bebbf", "filename": "gcc/config/rl78/rl78-opts.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-opts.h?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,30 @@\n+/* GCC option-handling definitions for the Renesas RL78 processor.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef RL78_OPTS_H\n+#define RL78_OPTS_H\n+\n+enum rl78_mul_types\n+{\n+  MUL_NONE,\n+  MUL_RL78,\n+  MUL_G13\n+};\n+\n+#endif"}, {"sha": "f4ce1864273eb9d76900d3e852a37d1da287f02d", "filename": "gcc/config/rl78/rl78-protos.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-protos.h?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,43 @@\n+/* Prototypes for Renesas RL78 processors\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\f\n+void\t\trl78_emit_eh_epilogue (rtx);\n+void\t\trl78_expand_compare (rtx *);\n+void\t\trl78_expand_movsi (rtx *);\n+int\t\trl78_force_nonfar_2 (rtx *, rtx (*gen)(rtx,rtx));\n+int\t\trl78_force_nonfar_3 (rtx *, rtx (*gen)(rtx,rtx,rtx));\n+void\t\trl78_expand_eh_epilogue (rtx);\n+void\t\trl78_expand_epilogue (void);\n+void\t\trl78_expand_prologue (void);\n+int\t\trl78_far_p (rtx x);\n+int\t\trl78_hard_regno_mode_ok (int, enum machine_mode);\n+int\t\trl78_hard_regno_nregs (int, enum machine_mode);\n+bool\t\trl78_hl_b_c_addr_p (rtx);\n+int\t\trl78_initial_elimination_offset (int, int);\n+bool\t\trl78_as_legitimate_address (enum machine_mode, rtx,\n+\t\t\t\t\t    bool, addr_space_t);\n+int\t\trl78_legitimize_reload_address (rtx *, enum machine_mode, int,int, int);\n+enum reg_class\trl78_mode_code_base_reg_class (enum machine_mode, addr_space_t, int, int);\n+bool\t\trl78_peep_movhi_p (rtx *);\n+bool\t\trl78_real_insns_ok (void);\n+void\t\trl78_register_pragmas (void);\n+bool\t\trl78_regno_mode_code_ok_for_base_p (int, enum machine_mode, addr_space_t, int, int);\n+void\t\trl78_setup_peep_movhi (rtx *);\n+bool\t\trl78_virt_insns_ok (void);"}, {"sha": "e13dc4e43823d5e77a489a1eafff5091b9392df7", "filename": "gcc/config/rl78/rl78-real.md", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78-real.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78-real.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-real.md?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,339 @@\n+;;  Machine Description for Renesas RL78 processors\n+;;  Copyright (C) 2011 Free Software Foundation, Inc.\n+;;  Contributed by Red Hat.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\f\n+;; The insns in this file correspond to the actual opcodes the RL78\n+;; can issue with real registers.  All insns in here should be\n+;; conditional on rl78_real_insns_ok() returning true, and should\n+;; allow virtual registers in their predicates - the reorg pass that\n+;; allocates physical registers uses the constraints to select\n+;; registers, but insns with virtual registers MUST match one of these\n+;; patterns - other than the constraints - so that the operand info is\n+;; properly set up for the alloc pass.\n+\n+;;---------- Moving ------------------------\n+\n+(define_insn \"movqi_es\"\n+  [(set (reg:QI ES_REG)\n+\t(match_operand:QI 0 \"register_operand\" \"a\"))]\n+  \"\"\n+  \"mov\\tes, %0\"\n+)\n+\n+(define_insn \"movqi_cs\"\n+  [(set (reg:QI CS_REG)\n+\t(match_operand:QI 0 \"register_operand\" \"a\"))]\n+  \"\"\n+  \"mov\\tcs, %0\"\n+)\n+\n+(define_insn \"*movqi_real\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g,RaxbcWab,RaxbcWab,a,                          bcx,R, WabWd2WhlWh1WhbWbcWs1v, bcx\")\n+\t(match_operand    1 \"general_operand\"      \"0,K,        M,       RInt8sJvWabWdeWd2WhlWh1WhbWbcWs1,Wab,aInt8J,a,                      R\"))]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   ; mov\\t%0, %1\n+   oneb\\t%0\n+   clrb\\t%0\n+   mov\\t%0, %1\n+   mov\\t%0, %1\n+   mov\\t%0, %1\n+   mov\\t%0, %1\n+   mov\\t%0, %S1\"\n+)\n+\n+(define_insn \"*movhi_real\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g,AB,AB,RSv,A,BDTvSWabWd2WdeWhlWh1WbcWs1, BDT,ABDT,v\")\n+\t(match_operand:HI 1 \"general_operand\"      \" 0,K, M, i,  BDTvSWabWd2WdeWh1WhlWbcWs1,A, BDT,vS,  ABDT\"))]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   ; movw\\t%0, %1\n+   onew\\t%0\n+   clrw\\t%0\n+   movw\\t%0, %1\n+   movw\\t%0, %1\n+   movw\\t%0, %1\n+   movw\\t%0, %S1\n+   movw\\t%0, %1\n+   movw\\t%0, %1\"\n+)\n+\n+;;---------- Conversions ------------------------\n+\n+(define_insn \"*zero_extendqihi2_real\"\n+  [(set (match_operand:HI                 0 \"nonimmediate_operand\" \"=rv,A\")\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,a\")))]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   mov\\t%Q0, #0\n+   mov\\tx, a \\;mov\\ta, #0\"\n+  )\n+\n+(define_insn \"*extendqihi2_real\"\n+  [(set (match_operand:HI                 0 \"nonimmediate_operand\" \"=A,A\")\n+\t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"x,a\")))]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   shlw\\t%0, 8 \\;sarw\\t%0, 8\n+   sarw\\t%0, 8\"\n+  )\n+\n+;;---------- Arithmetic ------------------------\n+\n+(define_insn \"*addqi3_real\"\n+  [(set (match_operand:QI          0 \"nonimmediate_operand\"  \"=rvWabWhlWh1,rvWabWhlWh1,a,*bcdehl\")\n+\t(plus:QI (match_operand:QI 1 \"general_operand\"  \"%0,0,0,0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"K,L,RWhlWh1i,a\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+    inc\\t%0\n+    dec\\t%0\n+    add\\t%0, %2\n+    add\\t%0, %2\"\n+)\n+\n+(define_insn \"*addhi3_real\"\n+  [(set (match_operand:HI          0 \"nonimmediate_operand\"  \"=vABDTWh1Wab,vABDTWh1Wab,v,v,A,S,S,A\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand\"  \"%0,0,0,0,0,0,0,S\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"K,L,N,O,RWh1WhlWabiv,Int8,J,Ri\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   incw\\t%0\n+   decw\\t%0\n+   incw\\t%0 \\;incw\\t%0\n+   decw\\t%0 \\;decw\\t%0\n+   addw\\t%0, %p2\n+   addw\\t%0, %2\n+   subw\\t%0, %m2\n+   movw\\t%0, %1 \\;addw\\t%0, %2\"\n+)\n+\n+(define_insn \"*addqihi3a_real\"\n+  [(set (match_operand:HI          0 \"register_operand\"  \"=r\")\n+\t(plus:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\"  \"%r\"))\n+\t\t (match_operand:HI 2 \"register_operand\" \"r\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"add\\t%q0, %q1 \\;addc\\t%Q0, #0\"\n+)\n+\n+(define_insn \"*subqi3_real\"\n+  [(set (match_operand:QI           0 \"nonimmediate_operand\"  \"=a,R,v\")\n+\t(minus:QI (match_operand:QI 1 \"general_operand\"  \"0,0,0\")\n+\t\t  (match_operand:QI 2 \"general_operand\" \"RiWabWhbWh1Whl,a,i\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"sub\\t%0, %2\"\n+)\n+\n+(define_insn \"*subhi3_real\"\n+  [(set (match_operand:HI           0 \"nonimmediate_operand\"  \"=A,S\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\"  \"0,0\")\n+\t\t  (match_operand:HI 2 \"general_operand\" \"iBDTWabWh1v,i\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"subw\\t%0, %2\"\n+)\n+\n+(define_insn \"*umulhi3_shift_real\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A\")\n+        (mult:HI (match_operand:HI 1 \"rl78_nonfar_operand\" \"0,0\")\n+                 (match_operand:HI 2 \"rl78_24_operand\" \"N,i\")))]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   shlw\\t%0, 1\n+   shlw\\t%0, 2\"\n+)\n+\n+(define_insn \"*umulqihi3_real\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=A\")\n+        (mult:HI (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"%a\"))\n+                 (zero_extend:HI (match_operand:QI 2 \"general_operand\" \"x\"))))]\n+  \"rl78_real_insns_ok ()\"\n+  \"mulu\\t%2\"\n+)\n+\n+(define_insn \"*andqi3_real\"\n+  [(set (match_operand:QI         0 \"nonimmediate_operand\"  \"=A,R,v\")\n+\t(and:QI (match_operand:QI 1 \"general_operand\"       \"%0,0,0\")\n+\t\t(match_operand:QI 2 \"general_operand\"       \"iRvWabWhbWh1Whl,A,i\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"and\\t%0, %2\"\n+)\n+\n+(define_insn \"*iorqi3_real\"\n+  [(set (match_operand:QI         0 \"nonimmediate_operand\"  \"=A,R,v\")\n+\t(ior:QI (match_operand:QI 1 \"general_operand\"       \"%0,0,0\")\n+\t\t(match_operand:QI 2 \"general_operand\"       \"iRvWabWhbWh1Whl,A,i\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"or\\t%0, %2\"\n+)\n+\n+(define_insn \"*xorqi3_real\"\n+  [(set (match_operand:QI         0 \"nonimmediate_operand\"  \"=A,R,v\")\n+\t(xor:QI (match_operand:QI 1 \"general_operand\"       \"%0,0,0\")\n+\t\t(match_operand    2 \"general_operand\"       \"iRvWabWhbWh1Whl,A,i\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"xor\\t%0, %2\"\n+)\n+\n+;;---------- Shifts ------------------------\n+\n+(define_insn \"*ashlqi3_real\"\n+  [(set (match_operand:QI            0 \"nonimmediate_operand\"  \"=abc,a,a\")\n+\t(ashift:QI (match_operand:QI 1 \"general_operand\"  \"0,0,0\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"Int3,bc,dehl\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   shl\\t%0, %u2\n+   cmp0 %2\\; bz $2f\\; 1: shl\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\n+   inc %2\\;dec %2\\;bz $2f\\;1: shl\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\"\n+)\n+\n+(define_insn \"*ashlhi3_real\"\n+  [(set (match_operand:HI            0 \"nonimmediate_operand\"  \"=AB,A,A\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\"  \"0,0,0\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"P,bc,dehl\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   shlw\\t%0, %u2\n+   cmp0 %2\\; bz $2f\\; 1: shlw\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\n+   inc %2\\;dec %2\\;bz $2f\\;1: shlw\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\"\n+)\n+\n+;;----------\n+\n+(define_insn \"*ashrqi3_real\"\n+  [(set (match_operand:QI              0 \"nonimmediate_operand\"  \"=abc,a,a\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"general_operand\"  \"0,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"Int3,bc,dehl\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   sar\\t%0, %u2\n+   cmp0 %2\\; bz $2f\\; 1: sar\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\n+   inc %2\\;dec %2\\;bz $2f\\;1: sar\\t%0, 1\\;dec %2 \\;bnz $1b\\;2:\"\n+)\n+\n+(define_insn \"*ashrhi3_real\"\n+  [(set (match_operand:HI              0 \"nonimmediate_operand\"  \"=AB,A,A\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\"  \"0,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"P,bc,dehl\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   sarw\\t%0, %u2\n+   cmp0 %2\\; bz $2f\\; 1: sarw\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\n+   inc %2\\;dec %2\\;bz $2f\\;1: sarw\\t%0, 1\\;dec %2\\;bnz $1b\\;2:\"\n+)\n+\n+;;----------\n+\n+(define_insn \"*lshrqi3_real\"\n+  [(set (match_operand:QI              0 \"nonimmediate_operand\"  \"=abc,a,a\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"general_operand\"  \"0,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"Int3,bc,dehl\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   shr\\t%0, %u2\n+   cmp0 %2\\; bz $2f\\; 1: shr\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\n+   inc %2\\;dec %2\\;bz $2f\\;1: shr\\t%0, 1\\;dec %2\\;bnz $1b\\;2:\"\n+)\n+\n+(define_insn \"*lshrhi3_real\"\n+  [(set (match_operand:HI              0 \"nonimmediate_operand\"  \"=AB,A,A\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\"  \"0,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"P,bc,dehl\")))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   shrw\\t%0, %u2\n+   cmp0 %2\\; bz $2f\\; 1: shrw\\t%0, 1 \\;dec %2 \\;bnz $1b\\;2:\n+   inc %2\\;dec %2\\;bz $2f\\;1: shrw\\t%0, 1\\;dec %2\\;bnz $1b\\;2:\"\n+)\n+\n+;;---------- Branching ------------------------\n+\n+(define_insn \"*indirect_jump_real\"\n+  [(set (pc)\n+\t(match_operand:HI 0 \"nonimmediate_operand\" \"A\"))]\n+  \"rl78_real_insns_ok ()\"\n+  \"br\\t%0\"\n+)\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  ;; $rel8, $!rel16, !abs16, !!abs20\n+  \"br\\t!!%0\"\n+)\n+\n+(define_insn \"*call_real\"\n+  [(call (match_operand:HI 0 \"memory_operand\" \"Wab,Wca\")\n+\t (match_operand 1 \"\" \"\"))]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   call\\t!!%A0\n+   call\\t%A0\"\n+  )\n+\n+(define_insn \"*call_value_real\"\n+  [(set (match_operand 0 \"register_operand\" \"=v,v\")\n+\t(call (match_operand:HI 1 \"memory_operand\" \"Wab,Wca\")\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   call\\t!!%A1\n+   call\\t%A1\"\n+  )\n+\n+(define_insn \"*cbranchqi4_real\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"rl78_cmp_operator_real\"\n+\t\t\t      [(match_operand:QI 1 \"general_operand\" \"Wabvaxbc,a,          v,bcdehl\")\n+\t\t\t       (match_operand:QI 2 \"general_operand\" \"M,       irWhlWh1Whb,i,a\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   cmp0\\t%1 \\;sk%c0 \\;br\\t!!%3\n+   cmp\\t%1, %2 \\;sk%c0 \\;br\\t!!%3\n+   cmp\\t%1, %2 \\;sk%c0 \\;br\\t!!%3\n+   cmp\\t%1, %2 \\;sk%c0 \\;br\\t!!%3\"\n+  )\n+\n+(define_insn \"*cbranchhi4_real\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"rl78_cmp_operator_real\"\n+\t\t\t      [(match_operand:HI 1 \"general_operand\" \"A\")\n+\t\t\t       (match_operand:HI 2 \"general_operand\" \"iBDTWhlWh1\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"rl78_real_insns_ok ()\"\n+  \"cmpw\\t%1, %2 \\;sk%c0 \\;br\\t!!%3\"\n+  )"}, {"sha": "bd224160cd9fe1a95e1092870a8207eb072a9aa1", "filename": "gcc/config/rl78/rl78-virt.md", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-virt.md?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,259 @@\n+;;  Machine Description for Renesas RL78 processors\n+;;  Copyright (C) 2011 Free Software Foundation, Inc.\n+;;  Contributed by Red Hat.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\f\n+;; In this MD file, we define those insn patterns that involve\n+;; registers, where such registers are virtual until allocated to a\n+;; physical register.  All of these insns need to be conditional on\n+;; rl78_virt_insns_ok () being true.\n+\n+;; This tells the physical register allocator what method to use to\n+;; allocate registers.  Basically, this defines the template of the\n+;; instruction - op1 is of the form \"a = op(b)\", op2 is \"a = b op c\"\n+;; etc.\n+\n+(define_attr \"valloc\" \"op1,op2,ro1,cmp,umul,macax\"\n+  (const_string \"op2\"))\n+\n+;;---------- Moving ------------------------\n+\n+(define_insn \"*movqi_virt\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=vY,v,Wfr\")\n+\t(match_operand    1 \"general_operand\" \"vInt8JY,Wfr,vInt8J\"))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.mov %0, %1\"\n+  [(set_attr \"valloc\" \"op1\")]\n+)\n+\n+(define_insn \"*movhi_virt\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=vYS,v,Wfr\")\n+\t(match_operand:HI 1 \"general_operand\" \"viYS,Wfr,v\"))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.movw %0, %1\"\n+  [(set_attr \"valloc\" \"op1\")]\n+)\n+\n+;;---------- Conversions ------------------------\n+\n+(define_insn \"*zero_extendqihi2_virt\"\n+  [(set (match_operand:HI                 0 \"rl78_nonfar_nonimm_operand\" \"=vm\")\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"vim\")))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.zero_extend\\t%0, %1\"\n+  [(set_attr \"valloc\" \"op1\")]\n+  )\n+\n+(define_insn \"*extendqihi2_virt\"\n+  [(set (match_operand:HI                 0 \"rl78_nonfar_nonimm_operand\" \"=vm\")\n+\t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"vim\")))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.sign_extend\\t%0, %1\"\n+  [(set_attr \"valloc\" \"op1\")]\n+  )\n+\n+;;---------- Arithmetic ------------------------\n+\n+(define_insn \"*add<mode>3_virt\"\n+  [(set (match_operand:QHI           0 \"rl78_nonfar_nonimm_operand\" \"=vY,S\")\n+\t(plus:QHI (match_operand:QHI 1 \"rl78_nonfar_operand\" \"viY,0\")\n+\t\t  (match_operand:QHI 2 \"general_operand\" \"vim,i\")))\n+   ]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.add\\t%0, %1, %2\"\n+)\n+\n+(define_insn \"*sub<mode>3_virt\"\n+  [(set (match_operand:QHI            0 \"rl78_nonfar_nonimm_operand\" \"=vm,S\")\n+\t(minus:QHI (match_operand:QHI 1 \"rl78_nonfar_operand\" \"vim,0\")\n+\t\t   (match_operand:QHI 2 \"general_operand\" \"vim,i\")))\n+   ]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.sub\\t%0, %1, %2\"\n+)\n+\n+(define_insn \"*umulhi3_shift_virt\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=vm\")\n+        (mult:HI (match_operand:HI 1 \"rl78_nonfar_operand\" \"%vim\")\n+                 (match_operand:HI 2 \"rl78_24_operand\" \"Ni\")))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.mulu\\t%0, %1, %2\"\n+  [(set_attr \"valloc\" \"umul\")]\n+)\n+\n+(define_insn \"*umulqihi3_virt\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=vm\")\n+        (mult:HI (zero_extend:HI (match_operand:QI 1 \"rl78_nonfar_operand\" \"%vim\"))\n+                 (zero_extend:HI (match_operand:QI 2 \"general_operand\" \"vim\"))))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.mulu\\t%0, %2\"\n+  [(set_attr \"valloc\" \"umul\")]\n+)\n+\n+(define_insn \"*andqi3_virt\"\n+  [(set (match_operand:QI         0 \"rl78_nonfar_nonimm_operand\" \"=vm\")\n+\t(and:QI (match_operand:QI 1 \"rl78_nonfar_operand\" \"vim\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"vim\")))\n+   ]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.and\\t%0, %1, %2\"\n+)\n+\n+(define_insn \"*iorqi3_virt\"\n+  [(set (match_operand:QI         0 \"rl78_nonfar_nonimm_operand\" \"=vm\")\n+\t(ior:QI (match_operand:QI 1 \"rl78_nonfar_operand\" \"vim\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"vim\")))\n+   ]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.or\\t%0, %1, %2\"\n+)\n+\n+(define_insn \"*xor3_virt\"\n+  [(set (match_operand:QI         0 \"rl78_nonfar_nonimm_operand\" \"=v,vm,m\")\n+\t(xor:QI (match_operand:QI 1 \"rl78_nonfar_operand\" \"%0,vm,vm\")\n+\t\t(match_operand    2 \"general_operand\" \"i,vm,vim\")))\n+   ]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.xor\\t%0, %1, %2\"\n+)\n+\n+;;---------- Shifts ------------------------\n+\n+(define_insn \"*ashl<mode>3_virt\"\n+  [(set (match_operand:QHI             0 \"rl78_nonfar_nonimm_operand\" \"=vm\")\n+\t(ashift:QHI (match_operand:QHI 1 \"rl78_nonfar_operand\" \"vim\")\n+\t\t    (match_operand:QI  2 \"general_operand\" \"vim\")))\n+   ]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.shl\\t%0, %1, %2\"\n+)\n+\n+(define_insn \"*ashr<mode>3_virt\"\n+  [(set (match_operand:QHI               0 \"rl78_nonfar_nonimm_operand\" \"=vm\")\n+\t(ashiftrt:QHI (match_operand:QHI 1 \"rl78_nonfar_operand\" \"vim\")\n+\t\t      (match_operand:QI  2 \"general_operand\" \"vim\")))\n+   ]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.sar\\t%0, %1, %2\"\n+)\n+\n+(define_insn \"*lshr<mode>3_virt\"\n+  [(set (match_operand:QHI               0 \"rl78_nonfar_nonimm_operand\" \"=vm\")\n+\t(lshiftrt:QHI (match_operand:QHI 1 \"rl78_nonfar_operand\" \"vim\")\n+\t\t      (match_operand:QI  2 \"general_operand\" \"vim\")))\n+   ]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.shr\\t%0, %1, %2\"\n+)\n+\n+;; really a macro\n+(define_insn \"*ashrsi3_virt\"\n+  [(set (match_operand:SI               0 \"register_operand\" \"=v,v,v\")\n+\t(ashiftrt:SI (match_operand:SI  1 \"register_operand\" \"0,v,0\")\n+\t\t      (match_operand:SI 2 \"immediate_operand\" \"M,K,i\")))\n+   ]\n+  \"\"\n+  \"@\n+   ; ashrsi %0, 0\n+   movw\\tax,%H1\\;sarw\\tax,1\\;movw\\t%H0,ax\\;mov\\ta,%Q1\\;rorc\\ta,1\\;mov\\t%Q0,a\\;mov\\ta,%q1\\;rorc\\ta,1\\;mov\\t%q0,a\n+   mov\\tb,%2\\;1:\\;movw\\tax,%H1\\;sarw\\tax,1\\;movw\\t%H0,ax\\;mov\\ta,%Q1\\;rorc\\ta,1\\;mov\\t%Q0,a\\;mov\\ta,%q1\\;rorc\\ta,1\\;mov\\t%q0,a\\;dec\\tb\\;bnz $1b\"\n+  [(set_attr \"valloc\" \"macax\")]\n+)\n+\n+;;---------- Branching ------------------------\n+\n+(define_insn \"*indirect_jump_virt\"\n+  [(set (pc)\n+\t(match_operand:HI 0 \"nonimmediate_operand\" \"vm\"))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.br\\t%0\"\n+  [(set_attr \"valloc\" \"ro1\")]\n+)\n+\n+(define_insn \"*call_virt\"\n+  [(call (match_operand:HI 0 \"memory_operand\" \"Wab,Wcv\")\n+\t (match_operand 1 \"\" \"\"))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.call\\t%0\"\n+  [(set_attr \"valloc\" \"ro1\")]\n+  )\n+\n+(define_insn \"*call_value_virt\"\n+  [(set (match_operand 0 \"register_operand\" \"=v,v\")\n+\t(call (match_operand:HI 1 \"memory_operand\" \"Wab,Wcv\")\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.call\\t%1\"\n+  [(set_attr \"valloc\" \"op1\")]\n+  )\n+\n+(define_insn \"*cbranchqi4_virt\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"rl78_cmp_operator_real\"\n+\t\t\t      [(match_operand:QI 1 \"general_operand\" \"vim\")\n+\t\t\t       (match_operand:QI 2 \"general_operand\" \"vim\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.cmp\\t%1, %2\\\\n\\tv.b%c0\\t%3\"\n+  [(set_attr \"valloc\" \"cmp\")]\n+  )\n+\n+(define_insn \"*cbranchhi4_virt\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"rl78_cmp_operator_real\"\n+\t\t\t      [(match_operand:HI 1 \"general_operand\" \"vim\")\n+\t\t\t       (match_operand:HI 2 \"general_operand\" \"vim\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.cmpw\\t%1, %2\\\\n\\tv.b%c0\\t%3\"\n+  [(set_attr \"valloc\" \"cmp\")]\n+  )\n+\n+;;---------- Peepholes ------------------------\n+\n+(define_peephole2\n+  [(set (match_operand:QI 0 \"\" \"\")\n+\t(match_operand:QI 1 \"\" \"\"))\n+   (set (match_operand:QI 2 \"\" \"\")\n+\t(match_operand:QI 3 \"\" \"\"))]\n+  \"rl78_peep_movhi_p (operands)\"\n+  [(set (match_dup 4)\n+\t(match_dup 5))]\n+  \"rl78_setup_peep_movhi (operands);\"\n+  )\n+\n+(define_peephole2\n+  [(set (reg:QI A_REG)\n+\t(match_operand:QI 1 \"\" \"\"))\n+   (set (match_operand:QI 0 \"\" \"\")\n+\t(reg:QI A_REG))\n+   (set (reg:QI A_REG)\n+\t(match_operand:QI 3 \"\" \"\"))\n+   (set (match_operand:QI 2 \"\" \"\")\n+\t(reg:QI A_REG))\n+   ]\n+  \"rl78_peep_movhi_p (operands)\"\n+  [(set (reg:HI AX_REG)\n+\t(match_dup 5))\n+   (set (match_dup 4)\n+\t(reg:HI AX_REG))\n+   ]\n+  \"rl78_setup_peep_movhi (operands);\"\n+  )"}, {"sha": "460538eb131d6c9caf9bf7238905636de4d5276e", "filename": "gcc/config/rl78/rl78.c", "status": "added", "additions": 2705, "deletions": 0, "changes": 2705, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,2705 @@\n+/* Subroutines used for code generation on Renesas RL78 processors.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"libfuncs.h\"\n+#include \"recog.h\"\n+#include \"diagnostic-core.h\"\n+#include \"toplev.h\"\n+#include \"reload.h\"\n+#include \"df.h\"\n+#include \"ggc.h\"\n+#include \"tm_p.h\"\n+#include \"debug.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"langhooks.h\"\n+#include \"rl78-protos.h\"\n+#include \"tree-pass.h\"\n+\f\n+static inline bool is_interrupt_func (const_tree decl);\n+static inline bool is_brk_interrupt_func (const_tree decl);\n+static void rl78_reorg (void);\n+\f\n+\n+/* Debugging statements are tagged with DEBUG0 only so that they can\n+   be easily enabled individually, by replacing the '0' with '1' as\n+   needed.  */\n+#define DEBUG0 0\n+#define DEBUG1 1\n+\n+/* REGISTER_NAMES has the names for individual 8-bit registers, but\n+   these have the names we need to use when referring to 16-bit\n+   register pairs.  */\n+static const char * const word_regnames[] =\n+{\n+  \"ax\", \"AX\", \"bc\", \"BC\", \"de\", \"DE\", \"hl\", \"HL\",\n+  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\n+  \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\n+  \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\n+  \"sp\", \"ap\", \"psw\", \"es\", \"cs\"\n+};\n+\n+struct GTY(()) machine_function\n+{\n+  /* If set, the rest of the fields have been computed.  */\n+  int computed;\n+  /* Which register pairs need to be pushed in the prologue.  */\n+  int need_to_push [FIRST_PSEUDO_REGISTER / 2];\n+\n+  /* These fields describe the frame layout...  */\n+  /* arg pointer */\n+  /* 4 bytes for saved PC */\n+  int framesize_regs;\n+  /* frame pointer */\n+  int framesize_locals;\n+  int framesize_outgoing;\n+  /* stack pointer */\n+  int framesize;\n+\n+  /* If set, recog is allowed to match against the \"real\" patterns.  */\n+  int real_insns_ok;\n+  /* If set, recog is allowed to match against the \"virtual\" patterns.  */\n+  int virt_insns_ok;\n+  /* Set if the current function needs to clean up any trampolines.  */\n+  int trampolines_used;\n+};\n+\n+/* This is our init_machine_status, as set in\n+   rl78_option_override.  */\n+static struct machine_function *\n+rl78_init_machine_status (void)\n+{\n+  struct machine_function *m;\n+\n+  m = ggc_alloc_cleared_machine_function ();\n+  m->virt_insns_ok = 1;\n+\n+  return m;\n+}\n+\n+/* Returns whether to run the devirtualization pass.  */\n+static bool\n+devirt_gate (void)\n+{\n+  return true;\n+}\n+\n+/* Runs the devirtualization pass.  */\n+static unsigned int\n+devirt_pass (void)\n+{\n+  rl78_reorg ();\n+  return 0;\n+}\n+\n+/* This pass converts virtual instructions using virtual registers, to\n+   real instructions using real registers.  Rather than run it as\n+   reorg, we reschedule it before vartrack to help with debugging.  */\n+static struct opt_pass rl78_devirt_pass =\n+{\n+  RTL_PASS,\n+  \"devirt\",\n+  devirt_gate,\n+  devirt_pass,\n+  NULL,\n+  NULL,\n+  212,\n+  TV_MACH_DEP,\n+  0, 0, 0,\n+  0,\n+  TODO_dump_func\n+};\n+\n+static struct register_pass_info rl78_devirt_info =\n+{\n+  & rl78_devirt_pass,\n+  \"vartrack\",\n+  1,\n+  PASS_POS_INSERT_BEFORE\n+};\n+\n+#undef  TARGET_ASM_FILE_START\n+#define TARGET_ASM_FILE_START rl78_asm_file_start\n+\n+static void\n+rl78_asm_file_start (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      fprintf (asm_out_file, \"r%d\\t=\\t0x%x\\n\", 8 + i, 0xffef0 + i);\n+      fprintf (asm_out_file, \"r%d\\t=\\t0x%x\\n\", 16 + i, 0xffee8 + i);\n+    }\n+\n+  register_pass (& rl78_devirt_info);\n+}\n+\n+\f\n+#undef  TARGET_OPTION_OVERRIDE\n+#define TARGET_OPTION_OVERRIDE\t\trl78_option_override\n+\n+static void\n+rl78_option_override (void)\n+{\n+  flag_omit_frame_pointer = 1;\n+  flag_no_function_cse = 1;\n+  flag_split_wide_types = 0;\n+\n+  init_machine_status = rl78_init_machine_status;\n+}\n+\n+/* Most registers are 8 bits.  Some are 16 bits because, for example,\n+   gcc doesn't like dealing with $FP as a register pair.  This table\n+   maps register numbers to size in bytes.  */\n+static const int register_sizes[] =\n+{\n+  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 2, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,\n+  2, 2, 1, 1, 1\n+};\n+\n+/* Predicates used in the MD patterns.  This one is true when virtual\n+   insns may be matched, which typically means before (or during) the\n+   devirt pass.  */\n+bool\n+rl78_virt_insns_ok (void)\n+{\n+  if (cfun)\n+    return cfun->machine->virt_insns_ok;\n+  return true;\n+}\n+\n+/* Predicates used in the MD patterns.  This one is true when real\n+   insns may be matched, which typically means after (or during) the\n+   devirt pass.  */\n+bool\n+rl78_real_insns_ok (void)\n+{\n+  if (cfun)\n+    return cfun->machine->real_insns_ok;\n+  return false;\n+}\n+\n+/* Implements HARD_REGNO_NREGS.  */\n+int\n+rl78_hard_regno_nregs (int regno, enum machine_mode mode)\n+{\n+  int rs = register_sizes[regno];\n+  if (rs < 1)\n+    rs = 1;\n+  return ((GET_MODE_SIZE (mode) + rs - 1) / rs);\n+}\n+\n+/* Implements HARD_REGNO_MODE_OK.  */\n+int\n+rl78_hard_regno_mode_ok (int regno, enum machine_mode mode)\n+{\n+  int s = GET_MODE_SIZE (mode);\n+\n+  if (s < 1)\n+    return 0;\n+  /* These are not to be used by gcc.  */\n+  if (regno == 23 || regno == ES_REG || regno == CS_REG)\n+    return 0;\n+  /* $fp can alway sbe accessed as a 16-bit value.  */\n+  if (regno == FP_REG && s == 2)\n+    return 1;\n+  if (regno < SP_REG)\n+    {\n+      /* Since a reg-reg move is really a reg-mem move, we must\n+\t enforce alignment.  */\n+      if (s > 1 && (regno % 2))\n+\treturn 0;\n+      return 1;\n+    }\n+  if (s == CC_REGNUM)\n+    return (mode == BImode);\n+  /* All other registers must be accessed in their natural sizes.  */\n+  if (s == register_sizes [regno])\n+    return 1;\n+  return 0;\n+}\n+\n+/* Simplify_gen_subreg() doesn't handle memory references the way we\n+   need it to below, so we use this function for when we must get a\n+   valid subreg in a \"natural\" state.  */\n+static rtx\n+rl78_subreg (enum machine_mode mode, rtx r, enum machine_mode omode, int byte)\n+{\n+  if (GET_CODE (r) == MEM)\n+    return adjust_address (r, mode, byte);\n+  else\n+    return simplify_gen_subreg (mode, r, omode, byte);\n+}\n+\n+/* Used by movsi.  Split SImode moves into two HImode moves, using\n+   appropriate patterns for the upper and lower halves of symbols.  */\n+void\n+rl78_expand_movsi (rtx *operands)\n+{\n+  rtx op00, op02, op10, op12;\n+\n+  op00 = rl78_subreg (HImode, operands[0], SImode, 0);\n+  op02 = rl78_subreg (HImode, operands[0], SImode, 2);\n+  if (GET_CODE (operands[1]) == CONST\n+      || GET_CODE (operands[1]) == SYMBOL_REF)\n+    {\n+      op10 = gen_rtx_ZERO_EXTRACT (HImode, operands[1], GEN_INT (16), GEN_INT (0));\n+      op10 = gen_rtx_CONST (HImode, op10);\n+      op12 = gen_rtx_ZERO_EXTRACT (HImode, operands[1], GEN_INT (16), GEN_INT (16));\n+      op12 = gen_rtx_CONST (HImode, op12);\n+    }\n+  else\n+    {\n+      op10 = rl78_subreg (HImode, operands[1], SImode, 0);\n+      op12 = rl78_subreg (HImode, operands[1], SImode, 2);\n+    }\n+\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    ;\n+  else if (rtx_equal_p (op00, op12))\n+    {\n+      emit_move_insn (op02, op12);\n+      emit_move_insn (op00, op10);\n+    }\n+  else\n+    {\n+      emit_move_insn (op00, op10);\n+      emit_move_insn (op02, op12);\n+    }\n+}\n+\n+/* Used by various two-operand expanders which cannot accept all\n+   operands in the \"far\" namespace.  Force some such operands into\n+   registers so that each pattern has at most one far operand.  */\n+int\n+rl78_force_nonfar_2 (rtx *operands, rtx (*gen)(rtx,rtx))\n+{\n+  int did = 0;\n+  rtx temp_reg = NULL;\n+\n+  /* FIXME: in the future, be smarter about only doing this if the\n+     other operand is also far, assuming the devirtualizer can also\n+     handle that.  */\n+  if (rl78_far_p (operands[0]))\n+    {\n+      temp_reg = operands[0];\n+      operands[0] = gen_reg_rtx (GET_MODE (operands[0]));\n+      did = 1;\n+    }\n+  if (!did)\n+    return 0;\n+\n+  emit_insn (gen (operands[0], operands[1]));\n+  if (temp_reg)\n+    emit_move_insn (temp_reg, operands[0]);\n+  return 1;\n+}\n+\n+/* Likewise, but for three-operand expanders.  */\n+int\n+rl78_force_nonfar_3 (rtx *operands, rtx (*gen)(rtx,rtx,rtx))\n+{\n+  int did = 0;\n+  rtx temp_reg = NULL;\n+\n+  /* FIXME: Likewise.  */\n+  if (rl78_far_p (operands[1]))\n+    {\n+      rtx temp_reg = gen_reg_rtx (GET_MODE (operands[1]));\n+      emit_move_insn (temp_reg, operands[1]);\n+      operands[1] = temp_reg;\n+      did = 1;\n+    }\n+  if (rl78_far_p (operands[0]))\n+    {\n+      temp_reg = operands[0];\n+      operands[0] = gen_reg_rtx (GET_MODE (operands[0]));\n+      did = 1;\n+    }\n+  if (!did)\n+    return 0;\n+\n+  emit_insn (gen (operands[0], operands[1], operands[2]));\n+  if (temp_reg)\n+    emit_move_insn (temp_reg, operands[0]);\n+  return 1;\n+}\n+\n+#undef  TARGET_CAN_ELIMINATE\n+#define TARGET_CAN_ELIMINATE\t\trl78_can_eliminate\n+\n+static bool\n+rl78_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n+/* Returns nonzero if the given register needs to be saved by the\n+   current function.  */\n+static int\n+need_to_save (int regno)\n+{\n+  if (is_interrupt_func (cfun->decl))\n+    {\n+      if (regno < 8)\n+\treturn 1; /* don't know what devirt will need */\n+      if (regno > 23)\n+\treturn 0; /* don't need to save interrupt registers */\n+      if (current_function_is_leaf)\n+\t{\n+\t  return df_regs_ever_live_p (regno);\n+\t}\n+      else\n+\treturn 1;\n+    }\n+  if (regno == FRAME_POINTER_REGNUM && frame_pointer_needed)\n+    return 1;\n+  if (fixed_regs[regno])\n+    return 0;\n+  if (crtl->calls_eh_return)\n+    return 1;\n+  if (df_regs_ever_live_p (regno)\n+      && !call_used_regs[regno])\n+    return 1;\n+  return 0;\n+}\n+\n+/* We use this to wrap all emitted insns in the prologue.  */\n+static rtx\n+F (rtx x)\n+{\n+  RTX_FRAME_RELATED_P (x) = 1;\n+  return x;\n+}\n+\n+/* Compute all the frame-related fields in our machine_function\n+   structure.  */\n+static void\n+rl78_compute_frame_info (void)\n+{\n+  int i;\n+\n+  cfun->machine->computed = 1;\n+  cfun->machine->framesize_regs = 0;\n+  cfun->machine->framesize_locals = get_frame_size ();\n+  cfun->machine->framesize_outgoing = crtl->outgoing_args_size;\n+\n+  for (i = 0; i < 16; i ++)\n+    if (need_to_save (i * 2) || need_to_save (i * 2 + 1))\n+      {\n+\tcfun->machine->need_to_push [i] = 1;\n+\tcfun->machine->framesize_regs += 2;\n+      }\n+    else\n+      cfun->machine->need_to_push [i] = 0;\n+\n+  if ((cfun->machine->framesize_locals + cfun->machine->framesize_outgoing) & 1)\n+    cfun->machine->framesize_locals ++;\n+\n+  cfun->machine->framesize = (cfun->machine->framesize_regs\n+\t\t\t      + cfun->machine->framesize_locals\n+\t\t\t      + cfun->machine->framesize_outgoing);\n+}\n+\f\n+/* Returns true if the provided function has the specified attribute.  */\n+static inline bool\n+has_func_attr (const_tree decl, const char * func_attr)\n+{\n+  if (decl == NULL_TREE)\n+    decl = current_function_decl;\n+\n+  return lookup_attribute (func_attr, DECL_ATTRIBUTES (decl)) != NULL_TREE;\n+}\n+\n+/* Returns true if the provided function has the \"interrupt\" attribute.  */\n+static inline bool\n+is_interrupt_func (const_tree decl)\n+{\n+  return has_func_attr (decl, \"interrupt\") || has_func_attr (decl, \"brk_interrupt\");\n+}\n+\n+/* Returns true if the provided function has the \"brk_interrupt\" attribute.  */\n+static inline bool\n+is_brk_interrupt_func (const_tree decl)\n+{\n+  return has_func_attr (decl, \"brk_interrupt\");\n+}\n+\n+/* Check \"interrupt\" attributes.  */\n+static tree\n+rl78_handle_func_attribute (tree * node,\n+\t\t\t  tree   name,\n+\t\t\t  tree   args,\n+\t\t\t  int    flags ATTRIBUTE_UNUSED,\n+\t\t\t  bool * no_add_attrs)\n+{\n+  gcc_assert (DECL_P (* node));\n+  gcc_assert (args == NULL_TREE);\n+\n+  if (TREE_CODE (* node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute only applies to functions\",\n+\t       name);\n+      * no_add_attrs = true;\n+    }\n+\n+  /* FIXME: We ought to check that the interrupt and exception\n+     handler attributes have been applied to void functions.  */\n+  return NULL_TREE;\n+}\n+\n+#undef  TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE\t\trl78_attribute_table\n+\n+/* Table of RL78-specific attributes.  */\n+const struct attribute_spec rl78_attribute_table[] =\n+{\n+  /* Name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n+     affects_type_identity.  */\n+  { \"interrupt\",      0, 0, true, false, false, rl78_handle_func_attribute,\n+    false },\n+  { \"brk_interrupt\",  0, 0, true, false, false, rl78_handle_func_attribute,\n+    false },\n+  { NULL,             0, 0, false, false, false, NULL, false }\n+};\n+\n+\n+\f\n+/* Break down an address RTX into its component base/index/addend\n+   portions and return TRUE if the address is of a valid form, else\n+   FALSE.  */\n+static bool\n+characterize_address (rtx x, rtx *base, rtx *index, rtx *addend)\n+{\n+  *base = NULL_RTX;\n+  *index = NULL_RTX;\n+  *addend = NULL_RTX;\n+\n+  if (GET_CODE (x) == REG)\n+    {\n+      *base = x;\n+      return true;\n+    }\n+\n+  /* We sometimes get these without the CONST wrapper */\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      *addend = x;\n+      return true;\n+    }\n+\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      *base = XEXP (x, 0);\n+      x = XEXP (x, 1);\n+\n+      if (GET_CODE (*base) != REG\n+\t  && GET_CODE (x) == REG)\n+\t{\n+\t  rtx tmp = *base;\n+\t  *base = x;\n+\t  x = tmp;\n+\t}\n+\n+      if (GET_CODE (*base) != REG)\n+\treturn false;\n+\n+      if (GET_CODE (x) == ZERO_EXTEND\n+\t  && GET_CODE (XEXP (x, 0)) == REG)\n+\t{\n+\t  *index = XEXP (x, 0);\n+\t  return false;\n+\t}\n+    }\n+\n+  switch (GET_CODE (x))\n+    {\n+    case PLUS:\n+      if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t  && GET_CODE (XEXP (x, 0)) == CONST_INT)\n+\t{\n+\t  *addend = x;\n+\t  return true;\n+\t}\n+      /* fall through */\n+    case MEM:\n+    case REG:\n+      return false;\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case CONST_INT:\n+      *addend = x;\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+\n+  return false;\n+}\n+\n+/* Used by the Whb constraint.  Match addresses that use HL+B or HL+C\n+   addressing.  */\n+bool\n+rl78_hl_b_c_addr_p (rtx op)\n+{\n+  rtx hl, bc;\n+\n+  if (GET_CODE (op) != PLUS)\n+    return false;\n+  hl = XEXP (op, 0);\n+  bc = XEXP (op, 1);\n+  if (GET_CODE (hl) == ZERO_EXTEND)\n+    {\n+      rtx tmp = hl;\n+      hl = bc;\n+      bc = tmp;\n+    }\n+  if (GET_CODE (hl) != REG)\n+    return false;\n+  if (GET_CODE (bc) != ZERO_EXTEND)\n+    return false;\n+  bc = XEXP (bc, 0);\n+  if (GET_CODE (bc) != REG)\n+    return false;\n+  if (REGNO (hl) != HL_REG)\n+    return false;\n+  if (REGNO (bc) != B_REG && REGNO (bc) != C_REG)\n+    return false;\n+\n+  return true;\n+}\n+\n+#define REG_IS(r, regno) (((r) == (regno)) || ((r) >= FIRST_PSEUDO_REGISTER && !(strict)))\n+\n+/* Used in various constraints and predicates to match operands in the\n+   \"far\" address space.  */\n+int\n+rl78_far_p (rtx x)\n+{\n+  if (GET_CODE (x) != MEM)\n+    return 0;\n+#if DEBUG0\n+  fprintf(stderr, \"\\033[35mrl78_far_p: \"); debug_rtx(x);\n+  fprintf(stderr, \" = %d\\033[0m\\n\", MEM_ADDR_SPACE (x) == ADDR_SPACE_FAR);\n+#endif\n+  return MEM_ADDR_SPACE (x) == ADDR_SPACE_FAR;\n+}\n+\n+/* Return the appropriate mode for a named address pointer.  */\n+#undef TARGET_ADDR_SPACE_POINTER_MODE\n+#define TARGET_ADDR_SPACE_POINTER_MODE rl78_addr_space_pointer_mode\n+static enum machine_mode\n+rl78_addr_space_pointer_mode (addr_space_t addrspace)\n+{\n+  switch (addrspace)\n+    {\n+    case ADDR_SPACE_GENERIC:\n+      return HImode;\n+    case ADDR_SPACE_FAR:\n+      return SImode;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return the appropriate mode for a named address address.  */\n+#undef TARGET_ADDR_SPACE_ADDRESS_MODE\n+#define TARGET_ADDR_SPACE_ADDRESS_MODE rl78_addr_space_address_mode\n+static enum machine_mode\n+rl78_addr_space_address_mode (addr_space_t addrspace)\n+{\n+  switch (addrspace)\n+    {\n+    case ADDR_SPACE_GENERIC:\n+      return HImode;\n+    case ADDR_SPACE_FAR:\n+      return SImode;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+#undef  TARGET_LEGITIMATE_CONSTANT_P\n+#define TARGET_LEGITIMATE_CONSTANT_P\t\trl78_is_legitimate_constant\n+\n+static bool\n+rl78_is_legitimate_constant (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n+#undef  TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\trl78_as_legitimate_address\n+\n+bool\n+rl78_as_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x,\n+\t\t\t    bool strict ATTRIBUTE_UNUSED, addr_space_t as ATTRIBUTE_UNUSED)\n+{\n+  rtx base, index, addend;\n+\n+  if (as == ADDR_SPACE_GENERIC\n+      && GET_MODE (x) == SImode)\n+    return false;\n+\n+  if (! characterize_address (x, &base, &index, &addend))\n+    return false;\n+\n+  if (base && index)\n+    {\n+      int ir = REGNO (index);\n+      int br = REGNO (base);\n+\n+#define OK(test, debug) if (test) { /*fprintf(stderr, \"%d: OK %s\\n\", __LINE__, debug);*/ return true; }\n+      OK (REG_IS (br, HL_REG) && REG_IS (ir, B_REG), \"[hl+b]\");\n+      OK (REG_IS (br, HL_REG) && REG_IS (ir, C_REG), \"[hl+c]\");\n+      return false;\n+    }\n+\n+  if (strict && base && GET_CODE (base) == REG && REGNO (base) >= FIRST_PSEUDO_REGISTER)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Determine if one named address space is a subset of another.  */\n+#undef  TARGET_ADDR_SPACE_SUBSET_P\n+#define TARGET_ADDR_SPACE_SUBSET_P rl78_addr_space_subset_p\n+static bool\n+rl78_addr_space_subset_p (addr_space_t subset, addr_space_t superset)\n+{\n+  gcc_assert (subset == ADDR_SPACE_GENERIC || subset == ADDR_SPACE_FAR);\n+  gcc_assert (superset == ADDR_SPACE_GENERIC || superset == ADDR_SPACE_FAR);\n+\n+  if (subset == superset)\n+    return true;\n+\n+  else\n+    return (subset == ADDR_SPACE_GENERIC && superset == ADDR_SPACE_FAR);\n+}\n+\n+#undef  TARGET_ADDR_SPACE_CONVERT\n+#define TARGET_ADDR_SPACE_CONVERT rl78_addr_space_convert\n+/* Convert from one address space to another.  */\n+static rtx\n+rl78_addr_space_convert (rtx op, tree from_type, tree to_type)\n+{\n+  addr_space_t from_as = TYPE_ADDR_SPACE (TREE_TYPE (from_type));\n+  addr_space_t to_as = TYPE_ADDR_SPACE (TREE_TYPE (to_type));\n+  rtx result;\n+\n+  gcc_assert (from_as == ADDR_SPACE_GENERIC || from_as == ADDR_SPACE_FAR);\n+  gcc_assert (to_as == ADDR_SPACE_GENERIC || to_as == ADDR_SPACE_FAR);\n+\n+  if (to_as == ADDR_SPACE_GENERIC && from_as == ADDR_SPACE_FAR)\n+    {\n+      /* This is unpredictable, as we're truncating off usable address\n+\t bits.  */\n+\n+      result = gen_reg_rtx (HImode);\n+      emit_move_insn (result, simplify_subreg (HImode, op, SImode, 0));\n+      return result;\n+    }\n+  else if (to_as == ADDR_SPACE_FAR && from_as == ADDR_SPACE_GENERIC)\n+    {\n+      /* This always works.  */\n+      result = gen_reg_rtx (SImode);\n+      debug_rtx(result);\n+      debug_rtx(op);\n+      emit_move_insn (rl78_subreg (HImode, result, SImode, 0), op);\n+      emit_move_insn (rl78_subreg (HImode, result, SImode, 2), const0_rtx);\n+      return result;\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Implements REGNO_MODE_CODE_OK_FOR_BASE_P.  */\n+bool\n+rl78_regno_mode_code_ok_for_base_p (int regno, enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t    addr_space_t address_space ATTRIBUTE_UNUSED,\n+\t\t\t\t    int outer_code ATTRIBUTE_UNUSED, int index_code)\n+{\n+  if (regno < 24 && regno >= 16)\n+    return true;\n+  if (index_code == REG)\n+    return (regno == HL_REG);\n+  if (regno == C_REG || regno == B_REG || regno == E_REG || regno == L_REG)\n+    return true;\n+  return false;\n+}\n+\n+/* Implements MODE_CODE_BASE_REG_CLASS.  */\n+enum reg_class\n+rl78_mode_code_base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t       addr_space_t address_space ATTRIBUTE_UNUSED,\n+\t\t\t       int outer_code ATTRIBUTE_UNUSED,\n+\t\t\t       int index_code ATTRIBUTE_UNUSED)\n+{\n+  return V_REGS;\n+}\n+\n+/* Implements INITIAL_ELIMINATION_OFFSET.  The frame layout is\n+   described in the machine_Function struct definition, above.  */\n+int\n+rl78_initial_elimination_offset (int from, int to)\n+{\n+  int rv = 0; /* as if arg to arg */\n+\n+  rl78_compute_frame_info ();\n+\n+  switch (to)\n+    {\n+    case STACK_POINTER_REGNUM:\n+      rv += cfun->machine->framesize_outgoing;\n+      rv += cfun->machine->framesize_locals;\n+      /* Fall through.  */\n+    case FRAME_POINTER_REGNUM:\n+      rv += cfun->machine->framesize_regs;\n+      rv += 4;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  switch (from)\n+    {\n+    case FRAME_POINTER_REGNUM:\n+      rv -= 4;\n+      rv -= cfun->machine->framesize_regs;\n+    case ARG_POINTER_REGNUM:\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return rv;\n+}\n+\n+/* Expand the function prologue (from the prologue pattern).  */\n+void\n+rl78_expand_prologue (void)\n+{\n+  int i, fs;\n+  rtx sp = gen_rtx_REG (HImode, STACK_POINTER_REGNUM);\n+  int rb = 0;\n+\n+  if (!cfun->machine->computed)\n+    rl78_compute_frame_info ();\n+\n+  for (i = 0; i < 16; i++)\n+    if (cfun->machine->need_to_push [i])\n+      {\n+\tint need_bank = i/4;\n+\tif (need_bank != rb)\n+\t  {\n+\t    emit_insn (gen_sel_rb (GEN_INT (need_bank)));\n+\t    rb = need_bank;\n+\t  }\n+\tF (emit_insn (gen_push (gen_rtx_REG (HImode, i*2))));\n+      }\n+  if (rb != 0)\n+    emit_insn (gen_sel_rb (GEN_INT (0)));\n+\n+  if (frame_pointer_needed)\n+    F (emit_move_insn (gen_rtx_REG (HImode, FRAME_POINTER_REGNUM),\n+\t\t       gen_rtx_REG (HImode, STACK_POINTER_REGNUM)));\n+\n+  fs = cfun->machine->framesize_locals + cfun->machine->framesize_outgoing;\n+  while (fs > 0)\n+    {\n+      int fs_byte = (fs > 254) ? 254 : fs;\n+      F (emit_insn (gen_subhi3 (sp, sp, GEN_INT (fs_byte))));\n+      fs -= fs_byte;\n+    }\n+}\n+\n+/* Expand the function epilogue (from the epilogue pattern).  */\n+void\n+rl78_expand_epilogue (void)\n+{\n+  int i, fs;\n+  rtx sp = gen_rtx_REG (HImode, STACK_POINTER_REGNUM);\n+  int rb = 0;\n+\n+  if (frame_pointer_needed)\n+    {\n+      emit_move_insn (gen_rtx_REG (HImode, STACK_POINTER_REGNUM),\n+\t\t      gen_rtx_REG (HImode, FRAME_POINTER_REGNUM));\n+    }\n+  else\n+    {\n+      fs = cfun->machine->framesize_locals + cfun->machine->framesize_outgoing;\n+      while (fs > 0)\n+\t{\n+\t  int fs_byte = (fs > 254) ? 254 : fs;\n+\n+\t  emit_insn (gen_addhi3 (sp, sp, GEN_INT (fs_byte)));\n+\t  fs -= fs_byte;\n+\t}\n+    }\n+\n+  for (i = 15; i >= 0; i--)\n+    if (cfun->machine->need_to_push [i])\n+      {\n+\tint need_bank = i / 4;\n+\n+\tif (need_bank != rb)\n+\t  {\n+\t    emit_insn (gen_sel_rb (GEN_INT (need_bank)));\n+\t    rb = need_bank;\n+\t  }\n+\temit_insn (gen_pop (gen_rtx_REG (HImode, i * 2)));\n+      }\n+\n+  if (rb != 0)\n+    emit_insn (gen_sel_rb (GEN_INT (0)));\n+\n+  if (cfun->machine->trampolines_used)\n+    emit_insn (gen_trampoline_uninit ());\n+\n+  if (is_brk_interrupt_func (cfun->decl))\n+    emit_jump_insn (gen_brk_interrupt_return ());\n+  else if (is_interrupt_func (cfun->decl))\n+    emit_jump_insn (gen_interrupt_return ());\n+  else\n+    emit_jump_insn (gen_return ());\n+}\n+\n+/* Likewise, for exception handlers.  */\n+void\n+rl78_expand_eh_epilogue (rtx x ATTRIBUTE_UNUSED)\n+{\n+  /* FIXME - replace this with an indirect jump with stack adjust.  */\n+  emit_jump_insn (gen_return ());\n+}\n+\n+#undef  TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE\trl78_start_function\n+\n+/* We don't use this to actually emit the function prologue.  We use\n+   this to insert a comment in the asm file describing the\n+   function.  */\n+static void\n+rl78_start_function (FILE *file, HOST_WIDE_INT hwi_local ATTRIBUTE_UNUSED)\n+{\n+  int i;\n+\n+  if (cfun->machine->framesize == 0)\n+    return;\n+  fprintf (file, \"\\t; start of function\\n\");\n+\n+  if (cfun->machine->framesize_regs)\n+    {\n+      fprintf (file, \"\\t; push %d:\", cfun->machine->framesize_regs);\n+      for (i = 0; i < 16; i ++)\n+\tif (cfun->machine->need_to_push[i])\n+\t  fprintf (file, \" %s\", word_regnames[i*2]);\n+      fprintf(file, \"\\n\");\n+    }\n+\n+  if (frame_pointer_needed)\n+    fprintf (file, \"\\t; $fp points here (r22)\\n\");\n+\n+  if (cfun->machine->framesize_locals)\n+    fprintf (file, \"\\t; locals: %d byte%s\\n\", cfun->machine->framesize_locals,\n+\t     cfun->machine->framesize_locals == 1 ? \"\" : \"s\");\n+\n+  if (cfun->machine->framesize_outgoing)\n+    fprintf (file, \"\\t; outgoing: %d byte%s\\n\", cfun->machine->framesize_outgoing,\n+\t     cfun->machine->framesize_outgoing == 1 ? \"\" : \"s\");\n+}\n+\n+/* Return an RTL describing where a function return value of type RET_TYPE\n+   is held.  */\n+\n+#undef  TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE\t\trl78_function_value\n+\n+static rtx\n+rl78_function_value (const_tree ret_type,\n+\t\t     const_tree fn_decl_or_type ATTRIBUTE_UNUSED,\n+\t\t     bool       outgoing ATTRIBUTE_UNUSED)\n+{\n+  enum machine_mode mode = TYPE_MODE (ret_type);\n+\n+  return gen_rtx_REG (mode, 8);\n+}\n+\n+#undef  TARGET_PROMOTE_FUNCTION_MODE\n+#define TARGET_PROMOTE_FUNCTION_MODE rl78_promote_function_mode\n+\n+static enum machine_mode\n+rl78_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n+\t\t\t    enum machine_mode mode,\n+\t\t\t    int *punsignedp ATTRIBUTE_UNUSED,\n+\t\t\t    const_tree funtype ATTRIBUTE_UNUSED, int for_return ATTRIBUTE_UNUSED)\n+{\n+  return mode;\n+}\n+\n+/* Return an RTL expression describing the register holding a function\n+   parameter of mode MODE and type TYPE or NULL_RTX if the parameter should\n+   be passed on the stack.  CUM describes the previous parameters to the\n+   function and NAMED is false if the parameter is part of a variable\n+   parameter list, or the last named parameter before the start of a\n+   variable parameter list.  */\n+\n+#undef  TARGET_FUNCTION_ARG\n+#define TARGET_FUNCTION_ARG     \trl78_function_arg\n+\n+static rtx\n+rl78_function_arg (cumulative_args_t cum_v ATTRIBUTE_UNUSED,\n+\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t   const_tree type ATTRIBUTE_UNUSED,\n+\t\t   bool named ATTRIBUTE_UNUSED)\n+{\n+  return NULL_RTX;\n+}\n+\n+#undef  TARGET_FUNCTION_ARG_ADVANCE\n+#define TARGET_FUNCTION_ARG_ADVANCE     rl78_function_arg_advance\n+\n+static void\n+rl78_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode, const_tree type,\n+\t\t\t   bool named ATTRIBUTE_UNUSED)\n+{\n+  int rounded_size;\n+  CUMULATIVE_ARGS * cum = get_cumulative_args (cum_v);\n+\n+  rounded_size = ((mode == BLKmode)\n+\t\t  ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n+  if (rounded_size & 1)\n+    rounded_size ++;\n+  (*cum) += rounded_size;\n+}\n+\n+#undef  TARGET_FUNCTION_ARG_BOUNDARY\n+#define\tTARGET_FUNCTION_ARG_BOUNDARY rl78_function_arg_boundary\n+\n+static unsigned int\n+rl78_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t    const_tree type ATTRIBUTE_UNUSED)\n+{\n+  return 16;\n+}\n+\n+/* Supported modifier letters:\n+\n+   A - address of a MEM\n+   S - SADDR form of a real register\n+   v - real register corresponding to a virtual register\n+   m - minus - negative of CONST_INT value.\n+   c - inverse of a conditional (NE vs EQ for example)\n+\n+   h - bottom HI of an SI\n+   H - top HI of an SI\n+   q - bottom QI of an HI\n+   Q - top QI of an HI\n+   e - third QI of an SI (i.e. where the ES register gets values from)\n+\n+*/\n+\n+/* Implements the bulk of rl78_print_operand, below.  We do it this\n+   way because we need to test for a constant at the top level and\n+   insert the '#', but not test for it anywhere else as we recurse\n+   down into the operand.  */\n+static void\n+rl78_print_operand_1 (FILE * file, rtx op, int letter)\n+{\n+  int need_paren;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case MEM:\n+      if (letter == 'A')\n+\trl78_print_operand_1 (file, XEXP (op, 0), letter);\n+      else\n+\t{\n+\t  if (rl78_far_p (op))\n+\t    fprintf(file, \"es:\");\n+\t  if (letter == 'H')\n+\t    {\n+\t      op = adjust_address (op, HImode, 2);\n+\t      letter = 0;\n+\t    }\n+\t  if (letter == 'h')\n+\t    {\n+\t      op = adjust_address (op, HImode, 0);\n+\t      letter = 0;\n+\t    }\n+\t  if (letter == 'Q')\n+\t    {\n+\t      op = adjust_address (op, QImode, 1);\n+\t      letter = 0;\n+\t    }\n+\t  if (letter == 'q')\n+\t    {\n+\t      op = adjust_address (op, QImode, 0);\n+\t      letter = 0;\n+\t    }\n+\t  if (letter == 'e')\n+\t    {\n+\t      op = adjust_address (op, QImode, 2);\n+\t      letter = 0;\n+\t    }\n+\t  if (CONSTANT_P (XEXP (op, 0)))\n+\t    {\n+\t      fprintf(file, \"!\");\n+\t      rl78_print_operand_1 (file, XEXP (op, 0), letter);\n+\t    }\n+\t  else if (GET_CODE (XEXP (op, 0)) == PLUS\n+\t\t   && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF)\n+\t    {\n+\t      fprintf(file, \"!\");\n+\t      rl78_print_operand_1 (file, XEXP (op, 0), letter);\n+\t    }\n+\t  else if (GET_CODE (XEXP (op, 0)) == PLUS\n+\t\t   && GET_CODE (XEXP (XEXP (op, 0), 0)) == REG\n+\t\t   && REGNO (XEXP (XEXP (op, 0), 0)) == 2)\n+\t    {\n+\t      rl78_print_operand_1 (file, XEXP (XEXP (op, 0), 1), 'u');\n+\t      fprintf(file, \"[\");\n+\t      rl78_print_operand_1 (file, XEXP (XEXP (op, 0), 0), 0);\n+\t      fprintf(file, \"]\");\n+\t    }\n+\t  else\n+\t    {\n+\t      fprintf(file, \"[\");\n+\t      rl78_print_operand_1 (file, XEXP (op, 0), letter);\n+\t      fprintf(file, \"]\");\n+\t    }\n+\t}\n+      break;\n+\n+    case REG:\n+      if (letter == 'Q')\n+\tfprintf (file, \"%s\", reg_names [REGNO (op) | 1]);\n+      else if (letter == 'H')\n+\tfprintf (file, \"%s\", reg_names [REGNO (op) + 2]);\n+      else if (letter == 'q')\n+\tfprintf (file, \"%s\", reg_names [REGNO (op) & ~1]);\n+      else if (letter == 'e')\n+\tfprintf (file, \"%s\", reg_names [REGNO (op) + 2]);\n+      else if (letter == 'S')\n+\tfprintf (file, \"0x%x\", 0xffef8 + REGNO (op));\n+      else if (GET_MODE (op) == HImode\n+\t       && ! (REGNO (op) & ~0xfe))\n+\t{\n+\t  if (letter == 'v')\n+\t    fprintf (file, \"%s\", word_regnames [REGNO (op) % 8]);\n+\t  else\n+\t    fprintf (file, \"%s\", word_regnames [REGNO (op)]);\n+\t}\n+      else\n+\tfprintf (file, \"%s\", reg_names [REGNO (op)]);\n+      break;\n+\n+    case CONST_INT:\n+      if (letter == 'Q')\n+\tfprintf (file, \"%ld\", INTVAL (op) >> 8);\n+      else if (letter == 'H')\n+\tfprintf (file, \"%ld\", INTVAL (op) >> 16);\n+      else if (letter == 'q')\n+\tfprintf (file, \"%ld\", INTVAL (op) & 0xff);\n+      else if (letter == 'h')\n+\tfprintf (file, \"%ld\", INTVAL (op) & 0xffff);\n+      else if (letter == 'e')\n+\tfprintf (file, \"%ld\", (INTVAL (op) >> 16) & 0xff);\n+      else if (letter == 'm')\n+\tfprintf (file, \"%ld\", - INTVAL (op));\n+      else\n+\tfprintf(file, \"%ld\", INTVAL (op));\n+      break;\n+\n+    case CONST:\n+      rl78_print_operand_1 (file, XEXP (op, 0), letter);\n+      break;\n+\n+    case ZERO_EXTRACT:\n+      {\n+\tint bits = INTVAL (XEXP (op, 1));\n+\tint ofs = INTVAL (XEXP (op, 2));\n+\tif (bits == 16 && ofs == 0)\n+\t  fprintf (file, \"%%lo16(\");\n+\telse if (bits == 16 && ofs == 16)\n+\t  fprintf (file, \"%%hi16(\");\n+\telse if (bits == 8 && ofs == 16)\n+\t  fprintf (file, \"%%hi8(\");\n+\telse\n+\t  gcc_unreachable ();\n+\trl78_print_operand_1 (file, XEXP (op, 0), 0);\n+\tfprintf (file, \")\");\n+      }\n+      break;\n+\n+    case ZERO_EXTEND:\n+      if (GET_CODE (XEXP (op, 0)) == REG)\n+\tfprintf (file, \"%s\", reg_names [REGNO (XEXP (op, 0))]);\n+      else\n+\tprint_rtl (file, op);\n+      break;\n+\n+    case PLUS:\n+      need_paren = 0;\n+      if (letter == 'H')\n+\t{\n+\t  fprintf (file, \"%%hi16(\");\n+\t  need_paren = 1;\n+\t  letter = 0;\n+\t}\n+      if (letter == 'h')\n+\t{\n+\t  fprintf (file, \"%%lo16(\");\n+\t  need_paren = 1;\n+\t  letter = 0;\n+\t}\n+      if (letter == 'e')\n+\t{\n+\t  fprintf (file, \"%%hi8(\");\n+\t  need_paren = 1;\n+\t  letter = 0;\n+\t}\n+      if (letter == 'q' || letter == 'Q')\n+\toutput_operand_lossage (\"q/Q modifiers invalid for symbol references\");\n+\n+      if (GET_CODE (XEXP (op, 0)) == ZERO_EXTEND)\n+\t{\n+\t  rl78_print_operand_1 (file, XEXP (op, 1), letter);\n+\t  fprintf (file, \"+\");\n+\t  rl78_print_operand_1 (file, XEXP (op, 0), letter);\n+\t}\n+      else\n+\t{\n+\t  rl78_print_operand_1 (file, XEXP (op, 0), letter);\n+\t  fprintf (file, \"+\");\n+\t  rl78_print_operand_1 (file, XEXP (op, 1), letter);\n+\t}\n+      if (need_paren)\n+\tfprintf (file, \")\");\n+      break;\n+\n+    case SYMBOL_REF:\n+      need_paren = 0;\n+      if (letter == 'H')\n+\t{\n+\t  fprintf (file, \"%%hi16(\");\n+\t  need_paren = 1;\n+\t  letter = 0;\n+\t}\n+      if (letter == 'h')\n+\t{\n+\t  fprintf (file, \"%%lo16(\");\n+\t  need_paren = 1;\n+\t  letter = 0;\n+\t}\n+      if (letter == 'e')\n+\t{\n+\t  fprintf (file, \"%%hi8(\");\n+\t  need_paren = 1;\n+\t  letter = 0;\n+\t}\n+      if (letter == 'q' || letter == 'Q')\n+\toutput_operand_lossage (\"q/Q modifiers invalid for symbol references\");\n+\n+      output_addr_const (file, op);\n+      if (need_paren)\n+\tfprintf (file, \")\");\n+      break;\n+\n+    case CODE_LABEL:\n+    case LABEL_REF:\n+      output_asm_label (op);\n+      break;\n+\n+    case LTU:\n+      fprintf (file, letter == 'c' ? \"nc\" : \"c\");\n+      break;\n+    case LEU:\n+      fprintf (file, letter == 'c' ? \"h\" : \"nh\");\n+      break;\n+    case GEU:\n+      fprintf (file, letter == 'c' ? \"c\" : \"nc\");\n+      break;\n+    case GTU:\n+      fprintf (file, letter == 'c' ? \"nh\" : \"h\");\n+      break;\n+    case EQ:\n+      fprintf (file, letter == 'c' ? \"nz\" : \"z\");\n+      break;\n+    case NE:\n+      fprintf (file, letter == 'c' ? \"z\" : \"nz\");\n+      break;\n+\n+    default:\n+      fprintf (file, \"(%s)\", GET_RTX_NAME (GET_CODE (op)));\n+      break;\n+    }\n+}\n+\n+#undef  TARGET_PRINT_OPERAND\n+#define TARGET_PRINT_OPERAND\t\trl78_print_operand\n+\n+static void\n+rl78_print_operand (FILE * file, rtx op, int letter)\n+{\n+  if (CONSTANT_P (op) && letter != 'u')\n+    fprintf (file, \"#\");\n+  rl78_print_operand_1 (file, op, letter);\n+}\n+\n+#undef  TARGET_TRAMPOLINE_INIT\n+#define TARGET_TRAMPOLINE_INIT rl78_trampoline_init\n+\n+/* Note that the RL78's addressing makes it very difficult to do\n+   trampolines on the stack.  So, libgcc has a small pool of\n+   trampolines from which one is allocated to this task.  */\n+static void\n+rl78_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)\n+{\n+  rtx mov_addr, thunk_addr;\n+  rtx function = XEXP (DECL_RTL (fndecl), 0);\n+\n+  mov_addr = adjust_address (m_tramp, HImode, 0);\n+  thunk_addr = gen_reg_rtx (HImode);\n+\n+  function = force_reg (HImode, function);\n+  static_chain = force_reg (HImode, static_chain);\n+\n+  emit_insn (gen_trampoline_init (thunk_addr, function, static_chain));\n+  emit_move_insn (mov_addr, thunk_addr);\n+\n+  cfun->machine->trampolines_used = 1;\n+}\n+\n+#undef  TARGET_TRAMPOLINE_ADJUST_ADDRESS\n+#define TARGET_TRAMPOLINE_ADJUST_ADDRESS rl78_trampoline_adjust_address\n+\n+static rtx\n+rl78_trampoline_adjust_address (rtx m_tramp)\n+{\n+  rtx x = gen_rtx_MEM (HImode, m_tramp);\n+  return x;\n+}\n+\f\n+/* Expander for cbranchqi4 and cbranchhi4.  RL78 is missing some of\n+   the \"normal\" compares, specifically, it only has unsigned compares,\n+   so we must synthesize the missing ones.  */\n+void\n+rl78_expand_compare (rtx *operands)\n+{\n+  /* RL78 does not have signed comparisons.  We must modify the\n+     operands to be in the unsigned range, and emit an unsigned\n+     comparison.  */\n+\n+  enum machine_mode mode;\n+  rtx high_bit;\n+  int i;\n+  RTX_CODE new_cond;\n+\n+  switch (GET_CODE (operands[0]))\n+    {\n+    case GE:\n+      new_cond = GEU;\n+      break;\n+    case LE:\n+      new_cond = LEU;\n+      break;\n+    case GT:\n+      new_cond = GTU;\n+      break;\n+    case LT:\n+      new_cond = LTU;\n+      break;\n+    default:\n+      return;\n+    }\n+\n+#if DEBUG0\n+  fprintf (stderr, \"\\033[38;5;129mrl78_expand_compare\\n\");\n+  debug_rtx (operands[0]);\n+  fprintf (stderr, \"\\033[0m\");\n+#endif\n+\n+  mode = GET_MODE (operands[1]);\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (operands[2]);\n+  high_bit = GEN_INT (~0 << (GET_MODE_BITSIZE (mode) - 1));\n+\n+  /* 0: conditional 1,2: operands */\n+  for (i = 1; i <= 2; i ++)\n+    {\n+      rtx r = operands[i];\n+\n+      if (GET_CODE (r) == CONST_INT)\n+\tr = GEN_INT (INTVAL (r) ^ INTVAL (high_bit));\n+      else\n+\t{\n+\t  r = gen_rtx_PLUS (mode, operands[i], high_bit);\n+\t  r = copy_to_mode_reg (mode, r);\n+\t}\n+      operands[i] = r;\n+    }\n+\n+  operands[0] = gen_rtx_fmt_ee (new_cond, GET_MODE (operands[0]), operands[1], operands[2]);\n+\n+#if DEBUG0\n+  fprintf (stderr, \"\\033[38;5;142mrl78_expand_compare\\n\");\n+  debug_rtx (operands[0]);\n+  fprintf (stderr, \"\\033[0m\");\n+#endif\n+}\n+\n+\f\n+\n+/* Define this to 1 if you are debugging the peephole optimizers.  */\n+#define DEBUG_PEEP 0\n+\n+/* Predicate used to enable the peephole2 patterns in rl78-virt.md.\n+   The default \"word\" size is a byte so we can effectively use all the\n+   registers, but we want to do 16-bit moves whenever possible.  This\n+   function determines when such a move is an option.  */\n+bool\n+rl78_peep_movhi_p (rtx *operands)\n+{\n+  int i;\n+  rtx m, a;\n+\n+  /* (set (op0) (op1))\n+     (set (op2) (op3)) */\n+\n+#if DEBUG_PEEP\n+  fprintf (stderr, \"\\033[33m\");\n+  debug_rtx(operands[0]);\n+  debug_rtx(operands[1]);\n+  debug_rtx(operands[2]);\n+  debug_rtx(operands[3]);\n+  fprintf (stderr, \"\\033[0m\");\n+#endif\n+\n+  if (rtx_equal_p (operands[0], operands[3]))\n+    {\n+#if DEBUG_PEEP\n+      fprintf (stderr, \"no peep: overlapping\\n\");\n+#endif\n+      return false;\n+    }\n+\n+  for (i = 0; i < 2; i ++)\n+    {\n+      if (GET_CODE (operands[i]) != GET_CODE (operands[i+2]))\n+\t{\n+#if DEBUG_PEEP\n+\t  fprintf (stderr, \"no peep: different codes\\n\");\n+#endif\n+\t  return false;\n+\t}\n+      if (GET_MODE (operands[i]) != GET_MODE (operands[i+2]))\n+\t{\n+#if DEBUG_PEEP\n+\t  fprintf (stderr, \"no peep: different modes\\n\");\n+#endif\n+\t  return false;\n+\t}\n+\n+      switch (GET_CODE (operands[i]))\n+\t{\n+\tcase REG:\n+\t  /*   LSB                      MSB  */\n+\t  if (REGNO (operands[i]) + 1 != REGNO (operands[i+2])\n+\t      || GET_MODE (operands[i]) != QImode)\n+\t    {\n+#if DEBUG_PEEP\n+\t      fprintf (stderr, \"no peep: wrong regnos %d %d %d\\n\",\n+\t\t       REGNO (operands[i]), REGNO (operands[i+2]),\n+\t\t       i);\n+#endif\n+\t      return false;\n+\t    }\n+\t  if (! rl78_hard_regno_mode_ok (REGNO (operands[i]), HImode))\n+\t    {\n+#if DEBUG_PEEP\n+\t      fprintf (stderr, \"no peep: reg %d not HI\\n\", REGNO (operands[i]));\n+#endif\n+\t      return false;\n+\t    }\n+\t  break;\n+\n+\tcase CONST_INT:\n+\t  break;\n+\n+\tcase MEM:\n+\t  if (GET_MODE (operands[i]) != QImode)\n+\t    return false;\n+\t  if (MEM_ALIGN (operands[i]) < 16)\n+\t    return false;\n+\t  a = XEXP (operands[i], 0);\n+\t  if (GET_CODE (a) == CONST)\n+\t    a = XEXP (a, 0);\n+\t  if (GET_CODE (a) == PLUS)\n+\t    a = XEXP (a, 1);\n+\t  if (GET_CODE (a) == CONST_INT\n+\t      && INTVAL (a) & 1)\n+\t    {\n+#if DEBUG_PEEP\n+\t      fprintf (stderr, \"no peep: misaligned mem %d\\n\", i);\n+\t      debug_rtx (operands[i]);\n+#endif\n+\t      return false;\n+\t    }\n+\t  m = adjust_address (operands[i], QImode, 1);\n+\t  if (! rtx_equal_p (m, operands[i+2]))\n+\t    {\n+#if DEBUG_PEEP\n+\t      fprintf (stderr, \"no peep: wrong mem %d\\n\", i);\n+\t      debug_rtx(m);\n+\t      debug_rtx (operands[i+2]);\n+#endif\n+\t      return false;\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+#if DEBUG_PEEP\n+\t  fprintf (stderr, \"no peep: wrong rtx %d\\n\", i);\n+#endif\n+\t  return false;\n+\t}\n+    }\n+#if DEBUG_PEEP\n+  fprintf (stderr, \"\\033[32mpeep!\\033[0m\\n\");\n+#endif\n+  return true;\n+}\n+\n+/* Likewise, when a peephole is activated, this function helps compute\n+   the new operands.  */\n+void\n+rl78_setup_peep_movhi (rtx *operands)\n+{\n+  int i;\n+\n+  for (i = 0; i < 2; i ++)\n+    {\n+      switch (GET_CODE (operands[i]))\n+\t{\n+\tcase REG:\n+\t  operands[i+4] = gen_rtx_REG (HImode, REGNO (operands[i]));\n+\t  break;\n+\n+\tcase CONST_INT:\n+\t  operands[i+4] = GEN_INT ((INTVAL (operands[i]) & 0xff) + ((char)INTVAL (operands[i+2])) * 256);\n+\t  break;\n+\n+\tcase MEM:\n+\t  operands[i+4] = adjust_address (operands[i], HImode, 0);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+}\n+\f\n+/*\n+\tHow Devirtualization works in the RL78 GCC port\n+\n+Background\n+\n+The RL78 is an 8-bit port with some 16-bit operations.  It has 32\n+bytes of register space, in four banks, memory-mapped.  One bank is\n+the \"selected\" bank and holds the registers used for primary\n+operations.  Since the registers are memory mapped, often you can\n+still refer to the unselected banks via memory accesses.\n+\n+Virtual Registers\n+\n+The GCC port uses bank 0 as the \"selected\" registers (A, X, BC, etc)\n+and refers to the other banks via their memory addresses, although\n+they're treated as regular registers internally.  These \"virtual\"\n+registers are R8 through R23 (bank3 is reserved for asm-based\n+interrupt handlers).\n+\n+There are four machine description files:\n+\n+rl78.md        - common register-independent patterns and definitions\n+rl78-expand.md - expanders\n+rl78-virt.md   - patterns that match BEFORE devirtualization\n+rl78-real.md   - patterns that match AFTER devirtualization\n+\n+At least through register allocation and reload, gcc is told that it\n+can do pretty much anything - but may only use the virtual registers.\n+GCC cannot properly create the varying addressing modes that the RL78\n+supports in an efficient way.\n+\n+Sometime after reload, the RL78 backend \"devirtualizes\" the RTL.  It\n+uses the \"valloc\" attribute in rl78-virt.md for determining the rules\n+by which it will replace virtual registers with real registers (or\n+not) and how to make up addressing modes.  For example, insns tagged\n+with \"ro1\" have a single read-only parameter, which may need to be\n+moved from memory/constant/vreg to a suitable real register.  As part\n+of devirtualization, a flag is toggled, disabling the rl78-virt.md\n+patterns and enabling the rl78-real.md patterns.  The new patterns'\n+constraints are used to determine the real registers used.  NOTE:\n+patterns in rl78-virt.md essentially ignore the constrains and rely on\n+predicates, where the rl78-real.md ones essentially ignore the\n+predicates and rely on the constraints.\n+\n+The devirtualization pass is scheduled via the pass manager (despite\n+being called \"rl78_reorg\") so it can be scheduled prior to var-track\n+(the idea is to let gdb know about the new registers).  Ideally, it\n+would be scheduled right after pro/epilogue generation, so the\n+post-reload optimizers could operate on the real registers, but when I\n+tried that there were some issues building the target libraries.\n+\n+During devirtualization, a simple register move optimizer is run.  It\n+would be better to run a full CSE/propogation pass on it through, or\n+re-run regmove, but that has not yet been attempted.\n+\n+ */\n+#define DEBUG_ALLOC 0\n+\n+/* Rescans an insn to see if it's recognized again.  This is done\n+   carefully to ensure that all the constraint information is accurate\n+   for the newly matched insn.  */\n+static bool\n+insn_ok_now (rtx insn)\n+{\n+  INSN_CODE (insn) = -1;\n+  if (recog (PATTERN (insn), insn, 0) > -1)\n+    {\n+      extract_insn (insn);\n+      if (constrain_operands (1))\n+\t{\n+#if DEBUG_ALLOC\n+\t  fprintf (stderr, \"\\033[32m\");\n+\t  debug_rtx (insn);\n+\t  fprintf (stderr, \"\\033[0m\");\n+#endif\n+\t  return true;\n+\t}\n+    }\n+  else\n+    {\n+      fprintf (stderr, \"\\033[41;30m Unrecognized insn \\033[0m\\n\");\n+      debug_rtx (insn);\n+      gcc_unreachable ();\n+    }\n+#if DEBUG_ALLOC\n+  fprintf (stderr, \"\\033[31m\");\n+  debug_rtx (insn);\n+  fprintf (stderr, \"\\033[0m\");\n+#endif\n+  return false;\n+}\n+\n+#if DEBUG_ALLOC\n+#define WORKED fprintf (stderr, \"\\033[48;5;22m Worked at line %d \\033[0m\\n\", __LINE__)\n+#define FAILEDSOFAR fprintf (stderr, \"\\033[48;5;52m FAILED at line %d \\033[0m\\n\", __LINE__)\n+#define FAILED fprintf (stderr, \"\\033[48;5;52m FAILED at line %d \\033[0m\\n\", __LINE__), gcc_unreachable()\n+#define MAYBE_OK(insn) if (insn_ok_now (insn)) { WORKED; return; } else { FAILEDSOFAR; }\n+#else\n+#define WORKED\n+#define FAILEDSOFAR\n+#define FAILED gcc_unreachable ()\n+#define MAYBE_OK(insn) if (insn_ok_now (insn)) return;\n+#endif\n+\n+/* Registers into which we move the contents of virtual registers.  */\n+#define X gen_rtx_REG (QImode, 0)\n+#define A gen_rtx_REG (QImode, 1)\n+#define C gen_rtx_REG (QImode, 2)\n+#define B gen_rtx_REG (QImode, 3)\n+#define E gen_rtx_REG (QImode, 4)\n+#define D gen_rtx_REG (QImode, 5)\n+#define L gen_rtx_REG (QImode, 6)\n+#define H gen_rtx_REG (QImode, 7)\n+\n+#define AX gen_rtx_REG (HImode, 0)\n+#define BC gen_rtx_REG (HImode, 2)\n+#define DE gen_rtx_REG (HImode, 4)\n+#define HL gen_rtx_REG (HImode, 6)\n+\n+#define OP(x) (*recog_data.operand_loc[x])\n+\n+/* Returns TRUE if R is a virtual register.  */\n+static bool\n+is_virtual_register (rtx r)\n+{\n+  return (GET_CODE (r) == REG\n+\t  && REGNO (r) >= 8\n+\t  && REGNO (r) < 24);\n+}\n+\n+/* In all these alloc routines, we expect the following: the insn\n+   pattern is unshared, the insn was previously recognized and failed\n+   due to predicates or constraints, and the operand data is in\n+   recog_data.  */\n+\n+static int virt_insn_was_frame;\n+\n+/* Hook for all insns we emit.  Re-mark them as FRAME_RELATED if\n+   needed.  */\n+static rtx\n+EM2 (int line ATTRIBUTE_UNUSED, rtx r)\n+{\n+#if DEBUG_ALLOC\n+  fprintf (stderr, \"\\033[36m%d: \", line);\n+  debug_rtx(r);\n+  fprintf (stderr, \"\\033[0m\");\n+#endif\n+  /*SCHED_GROUP_P (r) = 1;*/\n+  if (virt_insn_was_frame)\n+    RTX_FRAME_RELATED_P (r) = 1;\n+  return r;\n+}\n+\n+#define EM(x) EM2 (__LINE__, x)\n+\n+/* Return a suitable RTX for the low half of a __far address.  */\n+static rtx\n+rl78_lo16 (rtx addr)\n+{\n+  if (GET_CODE (addr) == SYMBOL_REF\n+      || GET_CODE (addr) == CONST)\n+    {\n+      rtx r = gen_rtx_ZERO_EXTRACT (HImode, addr, GEN_INT (16), GEN_INT (0));\n+      r = gen_rtx_CONST (HImode, r);\n+      return r;\n+    }\n+  return rl78_subreg (HImode, addr, SImode, 0);\n+}\n+\n+/* Return a suitable RTX for the high half's lower byte of a __far address.  */\n+static rtx\n+rl78_hi8 (rtx addr)\n+{\n+  if (GET_CODE (addr) == SYMBOL_REF\n+      || GET_CODE (addr) == CONST)\n+    {\n+      rtx r = gen_rtx_ZERO_EXTRACT (QImode, addr, GEN_INT (8), GEN_INT (16));\n+      r = gen_rtx_CONST (QImode, r);\n+      return r;\n+    }\n+  return rl78_subreg (QImode, addr, SImode, 2);\n+}\n+\n+/* Copy any register values into real registers and return an RTX for\n+   the same memory, now addressed by real registers.  Any needed insns\n+   are emitted before BEFORE.  */\n+static rtx\n+transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n+{\n+  rtx base, index, addendr;\n+  int addend = 0;\n+\n+  if (GET_CODE (m) != MEM)\n+    return m;\n+\n+  if (GET_MODE (XEXP (m, 0)) == SImode)\n+    {\n+      rtx seg = rl78_hi8 (XEXP (m, 0));\n+#if DEBUG_ALLOC\n+      fprintf (stderr, \"setting ES:\\n\");\n+      debug_rtx(seg);\n+#endif\n+      emit_insn_before (EM(gen_movqi (A, seg)), before);\n+      emit_insn_before (EM(gen_movqi_es (A)), before);\n+      m = change_address (m, GET_MODE (m), rl78_lo16 (XEXP (m, 0)));\n+    }\n+\n+  characterize_address (XEXP (m, 0), &base, &index, &addendr);\n+  gcc_assert (index == NULL_RTX);\n+\n+#if DEBUG_ALLOC\n+  fprintf (stderr, \"\\033[33m\"); debug_rtx(m); fprintf (stderr, \"\\033[0m\");\n+  debug_rtx (base);\n+#endif\n+  if (base == NULL_RTX)\n+    return m;\n+\n+  if (addendr && GET_CODE (addendr) == CONST_INT)\n+    addend = INTVAL (addendr);\n+\n+  if (REGNO (base) == SP_REG)\n+    {\n+      if (addend >= 0 && addend  <= 255)\n+\treturn m;\n+    }\n+\n+  /* BASE should be a virtual register.  We copy it to NEWBASE.  If\n+     the addend is out of range for DE/HL, we use AX to compute the full\n+     address.  */\n+\n+  if (addend < 0\n+      || (addend > 255 && REGNO (newbase) != 2)\n+      || (addendr && GET_CODE (addendr) != CONST_INT))\n+    {\n+      /* mov ax, vreg\n+\t add ax, #imm\n+\t mov hl, ax\t*/\n+      EM (emit_insn_before (gen_movhi (AX, base), before));\n+      EM (emit_insn_before (gen_addhi3 (AX, AX, addendr), before));\n+      EM (emit_insn_before (gen_movhi (newbase, AX), before));\n+      base = newbase;\n+      addend = 0;\n+    }\n+  else\n+    {\n+      EM (emit_insn_before (gen_movhi (newbase, base), before));\n+      base = newbase;\n+    }\n+\n+  if (addend)\n+    base = gen_rtx_PLUS (HImode, base, GEN_INT (addend));\n+\n+#if DEBUG_ALLOC\n+  fprintf (stderr, \"\\033[33m\");\n+  debug_rtx (m);\n+#endif\n+  m = change_address (m, GET_MODE (m), base);\n+#if DEBUG_ALLOC\n+  debug_rtx (m);\n+  fprintf (stderr, \"\\033[0m\");\n+#endif\n+  return m;\n+}\n+\n+/* Copy SRC to accumulator (A or AX), placing any generated insns\n+   before BEFORE.  Returns accumulator RTX.  */\n+\n+static rtx\n+move_to_acc (int opno, rtx before)\n+{\n+  rtx src = OP(opno);\n+  enum machine_mode mode = GET_MODE (src);\n+\n+  if (GET_CODE (src) == REG\n+      && REGNO (src) < 2)\n+    return src;\n+\n+  if (mode == VOIDmode)\n+    mode = recog_data.operand_mode[opno];\n+\n+  if (mode == QImode)\n+    {\n+      EM (emit_insn_before (gen_movqi (A, src), before));\n+      return A;\n+    }\n+  else\n+    {\n+      EM (emit_insn_before (gen_movhi (AX, src), before));\n+      return AX;\n+    }\n+}\n+\n+/* Copy accumulator (A or AX) to DEST, placing any generated insns\n+   after AFTER.  Returns accumulator RTX.  */\n+\n+static rtx\n+move_from_acc (rtx dest, rtx after)\n+{\n+  enum machine_mode mode = GET_MODE (dest);\n+\n+  if (REG_P (dest) && REGNO (dest) < 2)\n+    return dest;\n+\n+  if (mode == QImode)\n+    {\n+      EM (emit_insn_after (gen_movqi (dest, A), after));\n+      return A;\n+    }\n+  else\n+    {\n+      EM (emit_insn_after (gen_movhi (dest, AX), after));\n+      return AX;\n+    }\n+}\n+\n+/* Copy accumulator (A or AX) to REGNO, placing any generated insns\n+   before BEFORE.  Returns reg RTX.  */\n+\n+static rtx\n+move_acc_to_reg (rtx acc, int regno, rtx before)\n+{\n+  enum machine_mode mode = GET_MODE (acc);\n+  rtx reg;\n+\n+  reg = gen_rtx_REG (mode, regno);\n+\n+  if (mode == QImode)\n+    {\n+      EM (emit_insn_before (gen_movqi (reg, A), before));\n+      return reg;\n+    }\n+  else\n+    {\n+      EM (emit_insn_before (gen_movhi (reg, AX), before));\n+      return reg;\n+    }\n+}\n+\n+/* Copy SRC to X, placing any generated insns before BEFORE.\n+   Returns X RTX.  */\n+\n+static rtx\n+move_to_x (int opno, rtx before)\n+{\n+  rtx src = OP(opno);\n+  enum machine_mode mode = GET_MODE (src);\n+  rtx reg;\n+\n+  if (mode == VOIDmode)\n+    mode = recog_data.operand_mode[opno];\n+  reg = (mode == QImode) ? X : AX;\n+\n+  if (mode == QImode || ! is_virtual_register (OP (opno)))\n+    {\n+      OP(opno) = move_to_acc (opno, before);\n+      OP(opno) = move_acc_to_reg (OP(opno), X_REG, before);\n+      return reg;\n+    }\n+\n+  if (mode == QImode)\n+    EM (emit_insn_before (gen_movqi (reg, src), before));\n+  else\n+    EM (emit_insn_before (gen_movhi (reg, src), before));\n+\n+  return reg;\n+}\n+\n+/* Copy OP(opno) to H or HL, placing any generated insns before BEFORE.\n+   Returns H/HL RTX.  */\n+\n+static rtx\n+move_to_hl (int opno, rtx before)\n+{\n+  rtx src = OP (opno);\n+  enum machine_mode mode = GET_MODE (src);\n+  rtx reg;\n+\n+  if (mode == VOIDmode)\n+    mode = recog_data.operand_mode[opno];\n+  reg = (mode == QImode) ? L : HL;\n+\n+  if (mode == QImode || ! is_virtual_register (OP (opno)))\n+    {\n+      OP (opno) = move_to_acc (opno, before);\n+      OP (opno) = move_acc_to_reg (OP (opno), L_REG, before);\n+      return reg;\n+    }\n+\n+  if (mode == QImode)\n+    EM (emit_insn_before (gen_movqi (reg, src), before));\n+  else\n+    EM (emit_insn_before (gen_movhi (reg, src), before));\n+\n+  return reg;\n+}\n+\n+/* Copy OP(opno) to E or DE, placing any generated insns before BEFORE.\n+   Returns E/DE RTX.  */\n+\n+static rtx\n+move_to_de (int opno, rtx before)\n+{\n+  rtx src = OP (opno);\n+  enum machine_mode mode = GET_MODE (src);\n+  rtx reg;\n+\n+  if (mode == VOIDmode)\n+    mode = recog_data.operand_mode[opno];\n+\n+  reg = (mode == QImode) ? E : DE;\n+\n+  if (mode == QImode || ! is_virtual_register (OP (opno)))\n+    {\n+      OP (opno) = move_to_acc (opno, before);\n+      OP (opno) = move_acc_to_reg (OP (opno), E_REG, before);\n+    }\n+  else\n+    {\n+      rtx move = mode == QImode ? gen_movqi (reg, src) : gen_movhi (reg, src);\n+\n+      EM (emit_insn_before (move, before));\n+    }\n+\n+  return reg;\n+}\n+\n+/* Devirtualize an insn of the form (SET (op) (unop (op))).  */\n+static void\n+rl78_alloc_physical_registers_op1 (rtx insn)\n+{\n+  /* op[0] = func op[1] */\n+\n+  /* We first try using A as the destination, then copying it\n+     back.  */\n+  if (rtx_equal_p (OP(0), OP(1)))\n+    {\n+      OP(0) =\n+      OP(1) = transcode_memory_rtx (OP(1), DE, insn);\n+    }\n+  else\n+    {\n+      OP(0) = transcode_memory_rtx (OP(0), BC, insn);\n+      OP(1) = transcode_memory_rtx (OP(1), HL, insn);\n+    }\n+\n+  MAYBE_OK (insn);\n+\n+  OP(0) = move_from_acc (OP(0), insn);\n+\n+  MAYBE_OK (insn);\n+\n+  /* Try copying the src to acc first, then.  This is for, for\n+     example, ZERO_EXTEND or NOT.  */\n+  OP(1) = move_to_acc (1, insn);\n+\n+  MAYBE_OK (insn);\n+\n+  FAILED;\n+}\n+\n+/* Devirtualize an insn of the form (SET (op) (unop (op) (op))).  */\n+static void\n+rl78_alloc_physical_registers_op2 (rtx insn)\n+{\n+  /* op[0] = op[1] func op[2] */\n+  rtx prev = prev_nonnote_nondebug_insn (insn);\n+  rtx first;\n+  bool hl_used;\n+\n+  if (rtx_equal_p (OP(0), OP(1)))\n+    {\n+      OP(0) =\n+      OP(1) = transcode_memory_rtx (OP(1), DE, insn);\n+      prev = next_nonnote_nondebug_insn (prev);\n+      OP(2) = transcode_memory_rtx (OP(2), HL, insn);\n+      prev = prev_nonnote_nondebug_insn (prev);\n+    }\n+  else if (rtx_equal_p (OP(0), OP(2)))\n+    {\n+      OP(1) = transcode_memory_rtx (OP(1), DE, insn);\n+      prev = next_nonnote_nondebug_insn (prev);\n+      OP(0) =\n+      OP(2) = transcode_memory_rtx (OP(2), HL, insn);\n+      prev = prev_nonnote_nondebug_insn (prev);\n+    }\n+  else\n+    {\n+      OP(0) = transcode_memory_rtx (OP(0), BC, insn);\n+      OP(1) = transcode_memory_rtx (OP(1), DE, insn);\n+      prev = next_nonnote_nondebug_insn (prev);\n+      OP(2) = transcode_memory_rtx (OP(2), HL, insn);\n+    }\n+\n+  MAYBE_OK (insn);\n+\n+  prev = prev_nonnote_nondebug_insn (insn);\n+  if (recog_data.constraints[1][0] == '%'\n+      && is_virtual_register (OP (1))\n+      && ! is_virtual_register (OP (2))\n+      && ! CONSTANT_P (OP (2)))\n+    {\n+      rtx tmp = OP (1);\n+      OP (1) = OP (2);\n+      OP (2) = tmp;\n+    }\n+\n+  /* Make a note of wether (H)L is being used.  It matters\n+     because if OP(2) alsoneeds reloading, then we must take\n+     care not to corrupt HL.  */\n+  hl_used = reg_mentioned_p (L, OP (0)) || reg_mentioned_p (L, OP (1));\n+\n+  OP(0) = move_from_acc (OP (0), insn);\n+  OP(1) = move_to_acc (1, insn);\n+\n+  MAYBE_OK (insn);\n+\n+  /* We have to copy op2 to HL, but that involves AX, which\n+     already has a live value.  Emit it before those insns.  */\n+\n+  if (prev)\n+    first = next_nonnote_nondebug_insn (prev);\n+  else\n+    for (first = insn; prev_nonnote_nondebug_insn (first); first = prev_nonnote_nondebug_insn (first))\n+      ;\n+\n+  OP (2) = hl_used ? move_to_de (2, first) : move_to_hl (2, first);\n+  \n+  MAYBE_OK (insn);\n+  \n+  FAILED;\n+}\n+\n+/* Devirtualize an insn of the form (SET () (unop (op))).  */\n+\n+static void\n+rl78_alloc_physical_registers_ro1 (rtx insn)\n+{\n+  /* (void) op[0] */\n+  OP(0) = transcode_memory_rtx (OP(0), BC, insn);\n+\n+  MAYBE_OK (insn);\n+\n+  OP(0) = move_to_acc (0, insn);\n+\n+  MAYBE_OK (insn);\n+\n+  FAILED;\n+}\n+\n+/* Devirtualize a compare insn.  */\n+static void\n+rl78_alloc_physical_registers_cmp (rtx insn)\n+{\n+  /* op[1] cmp_op[0] op[2] */\n+  rtx prev = prev_nonnote_nondebug_insn (insn);\n+  rtx first;\n+\n+  OP(1) = transcode_memory_rtx (OP(1), DE, insn);\n+  OP(2) = transcode_memory_rtx (OP(2), HL, insn);\n+\n+  MAYBE_OK (insn);\n+\n+  OP(1) = move_to_acc (1, insn);\n+\n+  MAYBE_OK (insn);\n+\n+  /* We have to copy op2 to HL, but that involves the acc, which\n+     already has a live value.  Emit it before those insns.  */\n+\n+  if (prev)\n+    first = next_nonnote_nondebug_insn (prev);\n+  else\n+    for (first = insn; prev_nonnote_nondebug_insn (first); first = prev_nonnote_nondebug_insn (first))\n+      ;\n+  OP(2) = move_to_hl (2, first);\n+\n+  MAYBE_OK (insn);\n+\n+  FAILED;\n+}\n+\n+/* Like op2, but AX = A op X.  */\n+static void\n+rl78_alloc_physical_registers_umul (rtx insn)\n+{\n+  /* op[0] = op[1] func op[2] */\n+  rtx prev = prev_nonnote_nondebug_insn (insn);\n+  rtx first;\n+\n+  OP(0) = transcode_memory_rtx (OP(0), BC, insn);\n+  OP(1) = transcode_memory_rtx (OP(1), DE, insn);\n+  OP(2) = transcode_memory_rtx (OP(2), HL, insn);\n+\n+  MAYBE_OK (insn);\n+\n+  if (recog_data.constraints[1][0] == '%'\n+      && is_virtual_register (OP(1))\n+      && !is_virtual_register (OP(2))\n+      && !CONSTANT_P (OP(2)))\n+    {\n+      rtx tmp = OP(1);\n+      OP(1) = OP(2);\n+      OP(2) = tmp;\n+    }\n+\n+  OP(0) = move_from_acc (OP(0), insn);\n+  OP(1) = move_to_acc (1, insn);\n+\n+  MAYBE_OK (insn);\n+\n+  /* We have to copy op2 to X, but that involves the acc, which\n+     already has a live value.  Emit it before those insns.  */\n+\n+  if (prev)\n+    first = next_nonnote_nondebug_insn (prev);\n+  else\n+    for (first = insn; prev_nonnote_nondebug_insn (first); first = prev_nonnote_nondebug_insn (first))\n+      ;\n+  OP(2) = move_to_x (2, first);\n+\n+  MAYBE_OK (insn);\n+\n+  FAILED;\n+}\n+\n+/* Scan all insns and devirtualize them.  */\n+static void\n+rl78_alloc_physical_registers (void)\n+{\n+  /* During most of the compile, gcc is dealing with virtual\n+     registers.  At this point, we need to assign physical registers\n+     to the vitual ones, and copy in/out as needed.  */\n+\n+  rtx insn, curr;\n+  enum attr_valloc valloc_method;\n+\n+  for (insn = get_insns (); insn; insn = curr)\n+    {\n+      int i;\n+\n+      curr = next_nonnote_nondebug_insn (insn);\n+\n+      if (INSN_P (insn)\n+\t  && (GET_CODE (PATTERN (insn)) == SET\n+\t      || GET_CODE (PATTERN (insn)) == CALL)\n+\t  && INSN_CODE (insn) == -1)\n+\t{\n+\t  if (GET_CODE (SET_SRC (PATTERN (insn))) == ASM_OPERANDS)\n+\t    continue;\n+\t  i = recog (PATTERN (insn), insn, 0);\n+\t  if (i == -1)\n+\t    {\n+\t      debug_rtx (insn);\n+\t      gcc_unreachable ();\n+\t    }\n+\t  INSN_CODE (insn) = i;\n+\t}\n+    }\n+\n+  cfun->machine->virt_insns_ok = 0;\n+  cfun->machine->real_insns_ok = 1;\n+\n+  for (insn = get_insns (); insn; insn = curr)\n+    {\n+      curr = insn ? next_nonnote_nondebug_insn (insn) : NULL;\n+\n+      if (!INSN_P (insn))\n+\tcontinue;\n+      if (GET_CODE (PATTERN (insn)) != SET\n+\t  && GET_CODE (PATTERN (insn)) != CALL)\n+\t  continue;\n+\n+      if (GET_CODE (SET_SRC (PATTERN (insn))) == ASM_OPERANDS)\n+\tcontinue;\n+\n+      valloc_method = get_attr_valloc (insn);\n+\n+      PATTERN (insn)= copy_rtx_if_shared (PATTERN (insn));\n+\n+      if (insn_ok_now (insn))\n+\tcontinue;\n+\n+      INSN_CODE (insn) = -1;\n+\n+      if (RTX_FRAME_RELATED_P (insn))\n+\tvirt_insn_was_frame = 1;\n+      else\n+\tvirt_insn_was_frame = 0;\n+\n+      switch (valloc_method)\n+\t{\n+\tcase VALLOC_OP1:\n+\t  rl78_alloc_physical_registers_op1 (insn);\n+\t  break;\n+\tcase VALLOC_OP2:\n+\t  rl78_alloc_physical_registers_op2 (insn);\n+\t  break;\n+\tcase VALLOC_RO1:\n+\t  rl78_alloc_physical_registers_ro1 (insn);\n+\t  break;\n+\tcase VALLOC_CMP:\n+\t  rl78_alloc_physical_registers_cmp (insn);\n+\t  break;\n+\tcase VALLOC_UMUL:\n+\t  rl78_alloc_physical_registers_umul (insn);\n+\t  break;\n+\tcase VALLOC_MACAX:\n+\t  /* Macro that clobbers AX */\n+\t  break;\n+\t}\n+    }\n+#if DEBUG_ALLOC\n+  fprintf (stderr, \"\\033[0m\");\n+#endif\n+}\n+\n+/* Add REG_DEAD notes using DEAD[reg] for rtx S which is part of INSN.\n+   This function scans for uses of registers; the last use (i.e. first\n+   encounter when scanning backwards) triggers a REG_DEAD note if the\n+   reg was previously in DEAD[].  */\n+static void\n+rl78_note_reg_uses (char *dead, rtx s, rtx insn)\n+{\n+  const char *fmt;\n+  int i, r;\n+  enum rtx_code code;\n+\n+  if (!s)\n+    return;\n+\n+  code = GET_CODE (s);\n+\n+  switch (code)\n+    {\n+      /* Compare registers by number.  */\n+    case REG:\n+      r = REGNO (s);\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"note use reg %d size %d on insn %d\\n\",\n+\t\t   r, GET_MODE_SIZE (GET_MODE (s)), INSN_UID (insn));\n+\t  print_rtl_single (dump_file, s);\n+\t}\n+      if (dead [r])\n+\tadd_reg_note (insn, REG_DEAD, gen_rtx_REG (GET_MODE (s), r));\n+      for (i = 0; i < GET_MODE_SIZE (GET_MODE (s)); i ++)\n+\tdead [r + i] = 0;\n+      return;\n+\n+      /* These codes have no constituent expressions\n+\t and are unique.  */\n+    case SCRATCH:\n+    case CC0:\n+    case PC:\n+      return;\n+\n+    case CONST_INT:\n+    case CONST_VECTOR:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+      /* These are kept unique for a given value.  */\n+      return;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\t  for (j = XVECLEN (s, i) - 1; j >= 0; j--)\n+\t    rl78_note_reg_uses (dead, XVECEXP (s, i, j), insn);\n+\t}\n+      else if (fmt[i] == 'e')\n+\trl78_note_reg_uses (dead, XEXP (s, i), insn);\n+    }\n+}\n+\n+/* Like the previous function, but scan for SETs instead.  */\n+static void\n+rl78_note_reg_set (char *dead, rtx d, rtx insn)\n+{\n+  int r, i;\n+\n+  if (GET_CODE (d) != REG)\n+    return;\n+\n+  r = REGNO (d);\n+  if (dead [r])\n+    add_reg_note (insn, REG_UNUSED, gen_rtx_REG (GET_MODE (d), r));\n+  if (dump_file)\n+    fprintf (dump_file, \"note set reg %d size %d\\n\", r, GET_MODE_SIZE (GET_MODE (d)));\n+  for (i = 0; i < GET_MODE_SIZE (GET_MODE (d)); i ++)\n+    dead [r + i] = 1;\n+}\n+\n+/* This is a rather crude register death pass.  Death status is reset\n+   at every jump or call insn.  */\n+static void\n+rl78_calculate_death_notes (void)\n+{\n+  char dead[FIRST_PSEUDO_REGISTER];\n+  rtx insn, p, s, d;\n+  int i;\n+\n+  memset (dead, 0, sizeof (dead));\n+\n+  for (insn = get_last_insn ();\n+       insn;\n+       insn = prev_nonnote_nondebug_insn (insn))\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n--------------------------------------------------\");\n+\t  fprintf (dump_file, \"\\nDead:\");\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i ++)\n+\t    if (dead[i])\n+\t      fprintf(dump_file, \" %s\", reg_names[i]);\n+\t  fprintf (dump_file, \"\\n\");\n+\t  print_rtl_single (dump_file, insn);\n+\t}\n+\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase INSN:\n+\t  p = PATTERN (insn);\n+\t  switch (GET_CODE (p))\n+\t    {\n+\t    case SET:\n+\t      s = SET_SRC (p);\n+\t      d = SET_DEST (p);\n+\t      rl78_note_reg_set (dead, d, insn);\n+\t      rl78_note_reg_uses (dead, s, insn);\n+\t      break;\n+\n+\t    case USE:\n+\t      rl78_note_reg_uses (dead, p, insn);\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t  break;\n+\n+\tcase JUMP_INSN:\n+\t  if (INSN_CODE (insn) == CODE_FOR_return)\n+\t    {\n+\t      memset (dead, 1, sizeof (dead));\n+\t      /* We expect a USE just prior to this, which will mark\n+\t\t the actual return registers.  The USE will have a\n+\t\t death note, but we aren't going to be modifying it\n+\t\t after this pass.  */\n+\t      break;\n+\t    }\n+\tcase CALL_INSN:\n+\t  memset (dead, 0, sizeof (dead));\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+      if (dump_file)\n+\tprint_rtl_single (dump_file, insn);\n+    }\n+}\n+\n+/* Helper function to reset the origins in RP and the age in AGE for\n+   all registers.  */\n+static void\n+reset_origins (int *rp, int *age)\n+{\n+  int i;\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      rp[i] = i;\n+      age[i] = 0;\n+    }\n+}\n+\n+/* The idea behind this optimization is to look for cases where we\n+   move data from A to B to C, and instead move from A to B, and A to\n+   C.  If B is a virtual register or memory, this is a big win on its\n+   own.  If B turns out to be unneeded after this, it's a bigger win.\n+   For each register, we try to determine where it's value originally\n+   came from, if it's propogated purely through moves (and not\n+   computes).  The ORIGINS[] array has the regno for the \"origin\" of\n+   the value in the [regno] it's indexed by.  */\n+static void\n+rl78_propogate_register_origins (void)\n+{\n+  int origins[FIRST_PSEUDO_REGISTER];\n+  int age[FIRST_PSEUDO_REGISTER];\n+  int i;\n+  rtx insn, ninsn = NULL_RTX;\n+  rtx pat;\n+\n+  reset_origins (origins, age);\n+\n+  for (insn = get_insns (); insn; insn = ninsn)\n+    {\n+      ninsn = next_nonnote_nondebug_insn (insn);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n\");\n+\t  fprintf (dump_file, \"Origins:\");\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i ++)\n+\t    if (origins[i] != i)\n+\t      fprintf (dump_file, \" r%d=r%d\", i, origins[i]);\n+\t  fprintf (dump_file, \"\\n\");\n+\t  print_rtl_single (dump_file, insn);\n+\t}\n+\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase CODE_LABEL:\n+\tcase BARRIER:\n+\tcase CALL_INSN:\n+\tcase JUMP_INSN:\n+\t  reset_origins (origins, age);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\n+\tcase INSN:\n+\t  pat = PATTERN (insn);\n+\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    {\n+\t      rtx clobber = XVECEXP (pat, 0, 1);\n+\t      pat = XVECEXP (pat, 0, 0);\n+\t      if (GET_CODE (clobber) == CLOBBER)\n+\t\t{\n+\t\t  int cr = REGNO (XEXP (clobber, 0));\n+\t\t  int mb = GET_MODE_SIZE (GET_MODE (XEXP (clobber, 0)));\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"reset origins of %d regs at %d\\n\", mb, cr);\n+\t\t  for (i = 0; i < mb; i++)\n+\t\t    {\n+\t\t      origins[cr + i] = cr + i;\n+\t\t      age[cr + i] = 0;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tbreak;\n+\t    }\n+\n+\t  if (GET_CODE (pat) == SET)\n+\t    {\n+\t      rtx src = SET_SRC (pat);\n+\t      rtx dest = SET_DEST (pat);\n+\t      int mb = GET_MODE_SIZE (GET_MODE (dest));\n+\n+\t      if (GET_CODE (dest) == REG)\n+\t\t{\n+\t\t  int dr = REGNO (dest);\n+\n+\t\t  if (GET_CODE (src) == REG)\n+\t\t    {\n+\t\t      int sr = REGNO (src);\n+\t\t      int same = 1;\n+\t\t      int best_age, best_reg;\n+\n+\t\t      /* See if the copy is not needed.  */\n+\t\t      for (i = 0; i < mb; i ++)\n+\t\t\tif (origins[dr + i] != origins[sr + i])\n+\t\t\t  same = 0;\n+\t\t      if (same)\n+\t\t\t{\n+\t\t\t  if (dump_file)\n+\t\t\t    fprintf (dump_file, \"deleting because dest already has correct value\\n\");\n+\t\t\t  delete_insn (insn);\n+\t\t\t  break;\n+\t\t\t}\n+\n+\t\t      if (dr < 8 || sr >= 8)\n+\t\t\t{\n+\t\t\t  int ar;\n+\n+\t\t\t  best_age = -1;\n+\t\t\t  best_reg = -1;\n+\t\t\t  /* See if the copy can be made from another\n+\t\t\t     bank 0 register instead, instead of the\n+\t\t\t     virtual src register.  */\n+\t\t\t  for (ar = 0; ar < 8; ar += mb)\n+\t\t\t    {\n+\t\t\t      same = 1;\n+\t\t\t      for (i = 0; i < mb; i ++)\n+\t\t\t\tif (origins[ar + i] != origins[sr + i])\n+\t\t\t\t  same = 0;\n+\n+\t\t\t      /* The chip has some reg-reg move limitations.  */\n+\t\t\t      if (mb == 1 && dr > 3)\n+\t\t\t\tsame = 0;\n+\n+\t\t\t      if (same)\n+\t\t\t\t{\n+\t\t\t\t  if (best_age == -1 || best_age > age[sr + i])\n+\t\t\t\t    {\n+\t\t\t\t      best_age = age[sr + i];\n+\t\t\t\t      best_reg = sr;\n+\t\t\t\t    }\n+\t\t\t\t}\n+\t\t\t    }\n+\n+\t\t\t  if (best_reg != -1)\n+\t\t\t    {\n+\t\t\t      /* FIXME: copy debug info too.  */\n+\t\t\t      SET_SRC (pat) = gen_rtx_REG (GET_MODE (src), best_reg);\n+\t\t\t      sr = best_reg;\n+\t\t\t    }\n+\t\t\t}\n+\n+\t\t      for (i = 0; i < mb; i++)\n+\t\t\t{\n+\t\t\t  origins[dr + i] = origins[sr + i];\n+\t\t\t  age[dr + i] = age[sr + i] + 1;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* The destination is computed, its origin is itself.  */\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"resetting origin of r%d for %d byte%s\\n\",\n+\t\t\t\t dr, mb, mb == 1 ? \"\" : \"s\");\n+\t\t      for (i = 0; i < mb; i ++)\n+\t\t\t{\n+\t\t\t  origins[dr + i] = dr + i;\n+\t\t\t  age[dr + i] = 0;\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  /* Any registers marked with that reg as an origin are reset.  */\n+\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\t    if (origins[i] >= dr && origins[i] < dr + mb)\n+\t\t      {\n+\t\t\torigins[i] = i;\n+\t\t\tage[i] = 0;\n+\t\t      }\n+\t\t}\n+\n+\t      /* Special case - our ADDSI3 macro uses AX */\n+\t      if (get_attr_valloc (insn) == VALLOC_MACAX)\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Resetting origin of AX for macro.\\n\");\n+\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\t    if (i <= 1 || origins[i] <= 1)\n+\t\t      {\n+\t\t\torigins[i] = i;\n+\t\t\tage[i] = 0;\n+\t\t      }\n+\t\t}\n+\n+\t      if (GET_CODE (src) == ASHIFT\n+\t\t  || GET_CODE (src) == ASHIFTRT\n+\t\t  || GET_CODE (src) == LSHIFTRT)\n+\t\t{\n+\t\t  rtx count = XEXP (src, 1);\n+\t\t  if (GET_CODE (count) == REG)\n+\t\t    {\n+\t\t      /* Special case - our pattern clobbers the count register.  */\n+\t\t      int r = REGNO (count);\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"Resetting origin of r%d for shift.\\n\", r);\n+\t\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\t\tif (i == r || origins[i] == r)\n+\t\t\t  {\n+\t\t\t    origins[i] = i;\n+\t\t\t    age[i] = 0;\n+\t\t\t  }\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Remove any SETs where the destination is unneeded.  */\n+static void\n+rl78_remove_unused_sets (void)\n+{\n+  rtx insn, ninsn = NULL_RTX;\n+  rtx dest;\n+\n+  for (insn = get_insns (); insn; insn = ninsn)\n+    {\n+      ninsn = next_nonnote_nondebug_insn (insn);\n+\n+      if ((insn = single_set (insn)) == NULL_RTX)\n+\tcontinue;\n+\n+      dest = SET_DEST (insn);\n+\n+      if (REGNO (dest) > 23)\n+\tcontinue;\n+\n+      if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))\n+\tdelete_insn (insn);\n+    }\n+}\n+\n+#undef  xTARGET_MACHINE_DEPENDENT_REORG\n+#define xTARGET_MACHINE_DEPENDENT_REORG  rl78_reorg\n+\n+/* This is the top of the devritualization pass.  */\n+static void\n+rl78_reorg (void)\n+{\n+  rl78_alloc_physical_registers ();\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n================DEVIRT:=AFTER=ALLOC=PHYSICAL=REGISTERS================\\n\");\n+      print_rtl_with_bb (dump_file, get_insns ());\n+    }\n+\n+  rl78_propogate_register_origins ();\n+  rl78_calculate_death_notes ();\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n================DEVIRT:=AFTER=PROPOGATION=============================\\n\");\n+      print_rtl_with_bb (dump_file, get_insns ());\n+      fprintf (dump_file, \"\\n======================================================================\\n\");\n+    }\n+\n+  rl78_remove_unused_sets ();\n+\n+  /* The code after devirtualizing has changed so much that at this point\n+     we might as well just rescan everything.  Note that\n+     df_rescan_all_insns is not going to help here because it does not\n+     touch the artificial uses and defs.  */\n+  df_finish_pass (true);\n+  if (optimize > 1)\n+    df_live_add_problem ();\n+  df_scan_alloc (NULL);\n+  df_scan_blocks ();\n+\n+  if (optimize)\n+    df_analyze ();\n+}\n+\n+#undef TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY rl78_return_in_memory\n+\n+static bool\n+rl78_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n+{\n+  const HOST_WIDE_INT size = int_size_in_bytes (type);\n+  return (size == -1 || size > 8);\n+}\n+\n+\f\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+#include \"gt-rl78.h\""}, {"sha": "5980c418843f36566c32228214e9741c2a86285a", "filename": "gcc/config/rl78/rl78.h", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.h?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,462 @@\n+/* GCC backend definitions for the Renesas RL78 processor.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\f\n+\n+#define RL78_MUL_NONE\t(rl78_mul_type == MUL_NONE)\n+#define RL78_MUL_RL78\t(rl78_mul_type == MUL_RL78)\n+#define RL78_MUL_G13\t(rl78_mul_type == MUL_G13)\n+\n+#define TARGET_CPU_CPP_BUILTINS()               \\\n+  do                                            \\\n+    {                                           \\\n+      builtin_define (\"__RL78__\"); \t\t\\\n+      builtin_assert (\"cpu=RL78\"); \t\t\\\n+      if (RL78_MUL_RL78)\t\t\t\\\n+\tbuiltin_define (\"__RL78_MUL_RL78__\"); \t\\\n+      if (RL78_MUL_G13)\t\t\t\t\\\n+\tbuiltin_define (\"__RL78_MUL_G13__\"); \t\\\n+    }                                           \\\n+  while (0)\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{pg:gcrt0.o%s}%{!pg:crt0.o%s} crtbegin.o%s\"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n+\n+#undef  LIB_SPEC\n+#define LIB_SPEC \"\t\t\t\t\t\\\n+--start-group\t\t\t\t\t\t\\\n+-lc\t\t\t\t\t\t\t\\\n+-lsim\t\t\t\t\t\t\t\\\n+%{fprofile-arcs|fprofile-generate|coverage:-lgcov} \t\\\n+--end-group\t\t\t\t\t   \t\\\n+%{!T*: %{msim:%Trl78-sim.ld}%{!msim:%Trl78.ld}}\t\t\\\n+\"\n+\f\n+\n+#define BITS_BIG_ENDIAN \t\t0\n+#define BYTES_BIG_ENDIAN \t\t0\n+#define WORDS_BIG_ENDIAN \t\t0\n+\n+#ifdef IN_LIBGCC2\n+/* This is to get correct SI and DI modes in libgcc2.c (32 and 64 bits).  */\n+#define\tUNITS_PER_WORD\t\t\t4\n+/* We have a problem with libgcc2.  It only defines two versions of\n+   each function, one for \"int\" and one for \"long long\".  Ie it assumes\n+   that \"sizeof (int) == sizeof (long)\".  For the RL78 this is not true\n+   and we need a third set of functions.  We explicitly define\n+   LIBGCC2_UNITS_PER_WORD here so that it is clear that we are expecting\n+   to get the SI and DI versions from the libgcc2.c sources, and we\n+   provide our own set of HI functions, which is why this\n+   definition is surrounded by #ifndef..#endif.  */\n+#ifndef LIBGCC2_UNITS_PER_WORD\n+#define LIBGCC2_UNITS_PER_WORD \t\t4\n+#endif\n+#else\n+/* Actual width of a word, in units (bytes).  */\n+#define\tUNITS_PER_WORD \t\t\t1\n+#endif\n+\n+#define SHORT_TYPE_SIZE\t\t\t16\n+#define INT_TYPE_SIZE\t\t\t16\n+#define LONG_TYPE_SIZE\t\t\t32\n+#define LONG_LONG_TYPE_SIZE\t\t64\n+\n+#define FLOAT_TYPE_SIZE \t\t32\n+#define DOUBLE_TYPE_SIZE \t\t32 /*64*/\n+#define LONG_DOUBLE_TYPE_SIZE\t\t64 /*DOUBLE_TYPE_SIZE*/\n+\n+#define LIBGCC2_HAS_DF_MODE\t\t1\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE   64\n+\n+#define DEFAULT_SIGNED_CHAR\t\t0\n+\n+#define STRICT_ALIGNMENT \t\t1\n+#define FUNCTION_BOUNDARY \t\t8\n+#define BIGGEST_ALIGNMENT \t\t16\n+#define STACK_BOUNDARY \t\t\t16\n+#define PARM_BOUNDARY \t\t\t16\n+\n+#define STACK_GROWS_DOWNWARD\t\t1\n+#define FRAME_GROWS_DOWNWARD\t\t1\n+#define FIRST_PARM_OFFSET(FNDECL) \t0\n+\n+#define MAX_REGS_PER_ADDRESS \t\t1\n+\n+#define Pmode \t\t\t\tHImode\n+#define POINTER_SIZE\t\t\t16\n+#undef  SIZE_TYPE\n+#define SIZE_TYPE\t\t\t\"unsigned int\"\n+#undef  PTRDIFF_TYPE\n+#define PTRDIFF_TYPE\t\t\t\"int\"\n+#undef  WCHAR_TYPE\n+#define WCHAR_TYPE\t\t\t\"long int\"\n+#undef  WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE\t\t\tBITS_PER_WORD\n+#define POINTERS_EXTEND_UNSIGNED\t1\n+#define FUNCTION_MODE \t\t\tHImode\n+#define CASE_VECTOR_MODE\t\tPmode\n+#define WORD_REGISTER_OPERATIONS\t0\n+#define HAS_LONG_COND_BRANCH\t\t0\n+#define HAS_LONG_UNCOND_BRANCH\t\t0\n+\n+#define MOVE_MAX \t\t\t2\n+#define STARTING_FRAME_OFFSET\t\t0\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)   1\n+\n+#define ADDR_SPACE_FAR\t1\n+\n+#define HAVE_PRE_DECCREMENT\t\t0\n+#define HAVE_POST_INCREMENT\t\t0\n+\n+#define MOVE_RATIO(SPEED) \t\t((SPEED) ? 24 : 16)\n+#define SLOW_BYTE_ACCESS\t\t0\n+\n+#define STORE_FLAG_VALUE\t\t1\n+#define LOAD_EXTEND_OP(MODE)\t\tZERO_EXTEND\n+#define SHORT_IMMEDIATES_SIGN_EXTEND\t0\n+\f\n+\n+/* The RL78 has four register banks.  Normal operation uses RB0 as\n+   real registers, RB1 and RB2 as \"virtual\" registers (because we know\n+   they'll be there, and not used as variables), and RB3 is reserved\n+   for interrupt handlers.  The virtual registers are accessed as\n+   SADDRs:\n+\n+   FFEE0-FFEE7 RB0\n+   FFEE8-FFEEF RB1\n+   FFEF0-FFEF7 RB2\n+   FFEF8-FFEFF RB3\n+*/\n+#define REGISTER_NAMES\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    \"x\", \"a\", \"c\", \"b\", \"e\", \"d\", \"l\", \"h\", \t\t\t\\\n+    \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\\\n+    \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\t\\\n+    \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\t\\\n+      \"sp\", \"ap\", \"psw\", \"es\", \"cs\"\t\t\t\t\\\n+  }\n+\n+#define ADDITIONAL_REGISTER_NAMES\t\\\n+{\t\t\t\t\t\\\n+{ \"ax\", 0 }, \\\n+{ \"bc\", 2 }, \\\n+{ \"de\", 4 }, \\\n+{ \"hl\", 6 }, \\\n+{ \"rp0\", 0 }, \\\n+{ \"rp1\", 2 }, \\\n+{ \"rp2\", 4 }, \\\n+{ \"rp3\", 6 }, \\\n+{ \"r0\", 0 }, \\\n+{ \"r1\", 1 }, \\\n+{ \"r2\", 2 }, \\\n+{ \"r3\", 3 }, \\\n+{ \"r4\", 4 }, \\\n+{ \"r5\", 5 }, \\\n+{ \"r6\", 6 }, \\\n+{ \"r7\", 7 }, \\\n+}\n+\n+enum reg_class\n+{\n+  NO_REGS,\t\t\t/* No registers in set.  */\n+  XREG,\n+  AREG,\n+  AXREG,\n+  CREG,\n+  BREG,\n+  BCREG,\n+  EREG,\n+  DREG,\n+  DEREG,\n+  LREG,\n+  HREG,\n+  HLREG,\n+  IDX_REGS,\n+  QI_REGS,\n+  SPREG,\n+  R8W_REGS,\n+  R10W_REGS,\n+  INT_REGS,\n+  V_REGS,\t\t\t/* Virtual registers.  */\n+  GR_REGS,\t\t\t/* Integer registers.  */\n+  PSWREG,\n+  ALL_REGS,\t\t\t/* All registers.  */\n+  LIM_REG_CLASSES\t\t/* Max value + 1.  */\n+};\n+\n+#define REG_CLASS_NAMES\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  \"NO_REGS\",\t\t\t\t\t\t\\\n+  \"XREG\",\t\t\t\t\t\t\\\n+  \"AREG\",\t\t\t\t\t\t\\\n+  \"AXREG\",\t\t\t\t\t\t\\\n+  \"CREG\",\t\t\t\t\t\t\\\n+  \"BREG\",\t\t\t\t\t\t\\\n+  \"BCREG\",\t\t\t\t\t\t\\\n+  \"EREG\",\t\t\t\t\t\t\\\n+  \"DREG\",\t\t\t\t\t\t\\\n+  \"DEREG\",\t\t\t\t\t\t\\\n+  \"LREG\",\t\t\t\t\t\t\\\n+  \"HREG\",\t\t\t\t\t\t\\\n+  \"HLREG\",\t\t\t\t\t\t\\\n+  \"IDX_REGS\",\t\t\t\t\t\t\\\n+  \"QI_REGS\",\t\t\t\t\t\t\\\n+  \"SPREG\",\t\t\t\t\t\t\\\n+  \"R8W_REGS\",\t\t\t\t\t\t\\\n+  \"R10W_REGS\",\t\t\t\t\t\t\\\n+  \"INT_REGS\",\t\t\t\t\t\t\\\n+  \"V_REGS\",\t\t\t\t\t\t\\\n+  \"GR_REGS\",\t\t\t\t\t\t\\\n+  \"PSWREG\",\t\t\t\t\t\t\\\n+  \"ALL_REGS\"\t\t\t\t\t\t\\\n+}\n+\n+#define REG_CLASS_CONTENTS\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000 },\t/* No registers,  */\t\t\\\n+  { 0x00000001, 0x00000000 }, \\\n+  { 0x00000002, 0x00000000 }, \\\n+  { 0x00000003, 0x00000000 }, \\\n+  { 0x00000004, 0x00000000 }, \\\n+  { 0x00000008, 0x00000000 }, \\\n+  { 0x0000000c, 0x00000000 }, \\\n+  { 0x00000010, 0x00000000 }, \\\n+  { 0x00000020, 0x00000000 }, \\\n+  { 0x00000030, 0x00000000 }, \\\n+  { 0x00000040, 0x00000000 }, \\\n+  { 0x00000080, 0x00000000 }, \\\n+  { 0x000000c0, 0x00000000 }, \\\n+  { 0x0000000c, 0x00000000 },\t/* B and C - index regs.  */\t\\\n+  { 0x000000ff, 0x00000000 },\t/* all real registers.  */\t\\\n+  { 0x00000000, 0x00000001 }, \t/* SP */\t\t\t\\\n+  { 0x00000300, 0x00000000 }, \t/* R8 - HImode */\t\t\\\n+  { 0x00000c00, 0x00000000 }, \t/* R10 - HImode */\t\t\\\n+  { 0xff000000, 0x00000000 }, \t/* INT - HImode */\t\t\\\n+  { 0x007fff00, 0x00000000 },\t/* Virtual registers.  */\t\\\n+  { 0xff7fffff, 0x00000002 },\t/* General registers.  */\t\\\n+  { 0x04000000, 0x00000004 },\t/* PSW.  */\t\\\n+  { 0xff7fffff, 0x0000001f }\t/* All registers.  */\t\t\\\n+}\n+\n+#define SMALL_REGISTER_CLASSES \t\t1\n+#define N_REG_CLASSES\t\t\t(int) LIM_REG_CLASSES\n+#define CLASS_MAX_NREGS(CLASS, MODE)    ((GET_MODE_SIZE (MODE) \\\n+\t\t\t\t\t  + UNITS_PER_WORD - 1) \\\n+\t\t\t\t\t / UNITS_PER_WORD)\n+\n+#define GENERAL_REGS\t\t\tGR_REGS\n+#define BASE_REG_CLASS  \t\tV_REGS\n+#define INDEX_REG_CLASS\t\t\tV_REGS\n+\n+#define FIRST_PSEUDO_REGISTER \t\t37\n+\n+#define REGNO_REG_CLASS(REGNO)          ((REGNO) < FIRST_PSEUDO_REGISTER \\\n+\t\t\t\t\t ? GR_REGS : NO_REGS)\n+\n+#define FRAME_POINTER_REGNUM \t\t22\n+#define STACK_POINTER_REGNUM \t        32\n+#define ARG_POINTER_REGNUM \t\t33\n+#define CC_REGNUM                       34\n+#define FUNC_RETURN_REGNUM              8\n+#define STATIC_CHAIN_REGNUM \t\t14\n+\n+/* Trampolines are implemented with a separate data stack.  The memory\n+   on stack only holds the function pointer for the chosen stub.\n+ */\n+\n+#define TRAMPOLINE_SIZE\t\t\t4\n+#define TRAMPOLINE_ALIGNMENT\t\t16\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM },\t\\\n+ { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM },\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM }}\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\\\n+  (OFFSET) = rl78_initial_elimination_offset ((FROM), (TO))\n+\n+\n+#define FUNCTION_ARG_REGNO_P(N)\t  \t0\n+#define FUNCTION_VALUE_REGNO_P(N) \t((N) == 8)\n+#define DEFAULT_PCC_STRUCT_RETURN\t0\n+\n+#define FIXED_REGISTERS\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  1,1,1,1, 1,1,1,1,\t\t\t\t\t\\\n+  0,0,0,0, 0,0,0,0,\t\t\t\t\t\\\n+  0,0,0,0, 0,0,1,1,\t\t\t\t\t\\\n+  1,1,1,1, 1,1,1,1,\t\t\t\t\t\\\n+  0, 1, 0, 1, 1\t\t\t\t\t\t\\\n+}\n+\n+#define CALL_USED_REGISTERS\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  1,1,1,1, 1,1,1,1,\t\t\t\t\t\\\n+  1,1,1,1, 1,1,1,1,\t\t\t\t\t\\\n+  0,0,0,0, 0,0,1,1,\t\t\t\t\t\\\n+  1,1,1,1, 1,1,1,1,\t\t\t\t\t\\\n+  0, 1, 1, 1, 1\t\t\t\t\t\t\\\n+}\n+\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\\\n+  gen_rtx_REG ((MODE),\t\t\t\t\t\\\n+\t       FUNC_RETURN_REGNUM)\n+\n+/* Order of allocation of registers.  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\t\\\n+  { 8, 9, 10, 11, 12, 13, 14, 15,\t\t\t\\\n+    16, 17, 18, 19, 20, 21, 22, 23,\t\t\t\\\n+    0, 1, 6, 7, 2, 3, 4, 5,\t\t\t\t\\\n+    24, 25, 26, 27, 28, 29, 30, 31,\t\t\t\\\n+    32, 33, 34\t\t\t\t\t\t\\\n+}\n+\n+#define REGNO_IN_RANGE(REGNO, MIN, MAX)\t\t\t\\\n+  (IN_RANGE ((REGNO), (MIN), (MAX)) \t\t\t\\\n+   || (reg_renumber != NULL\t\t\t\t\\\n+       && reg_renumber[(REGNO)] >= (MIN)\t\t\\\n+       && reg_renumber[(REGNO)] <= (MAX)))\n+\n+#ifdef REG_OK_STRICT\n+#define REGNO_OK_FOR_BASE_P(regno)      REGNO_IN_RANGE (regno, 16, 23)\n+#else\n+#define REGNO_OK_FOR_BASE_P(regno)\t1\n+#endif\n+\n+#define REGNO_OK_FOR_INDEX_P(regno)\tREGNO_OK_FOR_BASE_P (regno)\n+\n+#define REGNO_MODE_CODE_OK_FOR_BASE_P(regno, mode, address_space, outer_code, index_code) \\\n+  rl78_regno_mode_code_ok_for_base_p (regno, mode, address_space, outer_code, index_code)\n+\n+#define MODE_CODE_BASE_REG_CLASS(mode, address_space, outer_code, index_code) \\\n+  rl78_mode_code_base_reg_class (mode, address_space, outer_code, index_code)\n+\n+#define RETURN_ADDR_RTX(COUNT, FRAMEADDR)\t\t\t\t\\\n+  ((COUNT) == 0\t\t\t\t\t\t\t\t\\\n+   ? gen_rtx_MEM (Pmode, gen_rtx_PLUS (HImode, arg_pointer_rtx, GEN_INT (-4))) \\\n+   : NULL_RTX)\n+\n+#define INCOMING_RETURN_ADDR_RTX\tgen_rtx_MEM (Pmode, stack_pointer_rtx)\n+\n+#define ACCUMULATE_OUTGOING_ARGS\t1\n+\n+typedef unsigned int CUMULATIVE_ARGS;\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n+  (CUM) = 0\n+\n+\f\n+/* FIXME */\n+#define NO_PROFILE_COUNTERS     1\n+#define PROFILE_BEFORE_PROLOGUE 1\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n+    fprintf (FILE, \"\\tbsr\\t__mcount\\n\");\n+\f\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)            \\\n+  rl78_hard_regno_nregs (REGNO, MODE)\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\\\n+  rl78_hard_regno_mode_ok (REGNO, MODE)\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n+  (   (   GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\t\\\n+       || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\\\n+   == (   GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\t\t\\\n+       || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n+\f\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+#define DATA_SECTION_ASM_OP \".data\"\n+#define BSS_SECTION_ASM_OP \".bss\"\n+#define CTORS_SECTION_ASM_OP \".section \\\".ctors\\\",\\\"a\\\"\"\n+#define DTORS_SECTION_ASM_OP \".section \\\".dtors\\\",\\\"a\\\"\"\n+\n+#define ASM_COMMENT_START\t\" ;\"\n+#define ASM_APP_ON\t\t\"\"\n+#define ASM_APP_OFF \t\t\"\"\n+#define LOCAL_LABEL_PREFIX\t\".L\"\n+#undef  USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX\t\"_\"\n+\n+#define GLOBAL_ASM_OP \t\t\"\\t.global\\t\"\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n+  fprintf (FILE, \"\\t.long .L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   Note: The local label referenced by the \"3b\" below is emitted by\n+   the tablejump insn.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n+  fprintf (FILE, \"\\t.long .L%d - 1b\\n\", VALUE)\n+\n+\n+#define ASM_OUTPUT_ALIGN(STREAM, LOG)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if ((LOG) == 0)\t\t\t\t\\\n+        break;\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.balign %d\\n\", 1 << (LOG));\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* For PIC put jump tables into the text section so that the offsets that\n+   they contain are always computed between two same-section symbols.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION\t(flag_pic)\n+\f\n+/* This is a version of REG_P that also returns TRUE for SUBREGs.  */\n+#define RL78_REG_P(rtl) (REG_P (rtl) || GET_CODE (rtl) == SUBREG)\n+\n+/* Like REG_P except that this macro is true for SET expressions.  */\n+#define SET_P(rtl)    (GET_CODE (rtl) == SET)\n+\f\n+#undef  PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+#undef\tDWARF2_ADDR_SIZE\n+#define\tDWARF2_ADDR_SIZE\t\t\t4\n+\n+#define DWARF2_ASM_LINE_DEBUG_INFO\t\t1\n+\n+#define EXIT_IGNORE_STACK\t\t\t0\n+#define INCOMING_FRAME_SP_OFFSET\t\t4\n+\f\n+\n+#define BRANCH_COST(SPEED,PREDICT)       1\n+#define REGISTER_MOVE_COST(MODE,FROM,TO) 2\n+\n+#define EH_RETURN_DATA_REGNO(N) (N < 2 ? (8+(N)*2) : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX gen_rtx_REG (HImode, 20)\n+\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL) DW_EH_PE_udata4\n+\n+/* NOTE: defined but zero means dwarf2 debugging, but sjlj EH.  */\n+#define DWARF2_UNWIND_INFO 0\n+/*#define DONT_USE_BUILTIN_SETJMP 1*/\n+#undef DONT_USE_BUILTIN_SETJMP\n+#define JMP_BUF_SIZE (8*3+8)\n+\n+#define REGISTER_TARGET_PRAGMAS() rl78_register_pragmas()"}, {"sha": "220ed991773b2682653b12038096a8c1bb06444a", "filename": "gcc/config/rl78/rl78.md", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.md?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,320 @@\n+;;  Machine Description for Renesas RL78 processors\n+;;  Copyright (C) 2011 Free Software Foundation, Inc.\n+;;  Contributed by Red Hat.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\f\n+(define_constants\n+  [\n+   (AX_REG 0)\n+   (X_REG 0)\n+   (A_REG 1)\n+   (BC_REG 2)\n+   (C_REG 2)\n+   (B_REG 3)\n+   (DE_REG 4)\n+   (E_REG 4)\n+   (D_REG 5)\n+   (HL_REG 6)\n+   (L_REG 6)\n+   (H_REG 7)\n+\n+   (FP_REG 22)\n+   (SP_REG 32)\n+   (CC_REG 33)\n+   (ES_REG 35)\n+   (CS_REG 36)\n+\n+   (UNS_PROLOG\t1)\n+   (UNS_EPILOG\t1)\n+   (UNS_RETI\t2)\n+   (UNS_RETB\t3)\n+\n+   (UNS_SET_RB\t10)\n+\n+   (UNS_TRAMPOLINE_INIT\t\t20)\n+   (UNS_TRAMPOLINE_UNINIT\t21)\n+   (UNS_NONLOCAL_GOTO\t\t22)\n+\n+   ])\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  )\n+\n+(define_mode_iterator QHI [QI HI])\n+\n+(include \"predicates.md\")\n+(include \"constraints.md\")\n+(include \"rl78-expand.md\")\n+(include \"rl78-virt.md\")\n+(include \"rl78-real.md\")\n+\n+\n+;; Function Prologue/Epilogue Instructions\n+\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"rl78_expand_prologue (); DONE;\"\n+)\n+\n+(define_expand \"epilogue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"rl78_expand_epilogue (); DONE;\"\n+)\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(return)]\n+  \"\"\n+  \"FAIL;\"\n+)\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"\"\n+  \"ret\"\n+)\n+\n+(define_insn \"interrupt_return\"\n+  [(unspec_volatile [(return)] UNS_RETI) ]\n+  \"\"\n+  \"reti\"\n+)\n+\n+(define_insn \"brk_interrupt_return\"\n+  [(unspec_volatile [(return)] UNS_RETB) ]\n+  \"\"\n+  \"retb\"\n+)\n+\n+(define_expand \"eh_return\"\n+  [(match_operand:HI 0 \"\" \"\")]\n+  \"\"\n+  \"rl78_expand_eh_epilogue (operands[0]);\n+   emit_barrier ();\n+   DONE;\"\n+)\n+\n+;; These are used only by prologue/epilogue so it's \"safe\" to pass\n+;; virtual registers.\n+(define_insn \"push\"\n+  [(set (reg:HI SP_REG)\n+\t(plus:HI (reg:HI SP_REG)\n+\t\t  (const_int -2)))\n+   (set (mem:HI (reg:HI SP_REG))\n+\t(match_operand:HI 0 \"register_operand\" \"ABDT,vZint\"))]\n+  \"\"\n+  \"@\n+   push\\t%v0\n+   push\\t%v0 ; %0\"\n+)\n+\n+(define_insn \"pop\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=ABDT,vZint\")\n+\t(mem:HI (reg:HI SP_REG)))\n+   (set (reg:HI SP_REG)\n+\t(plus:HI (reg:HI SP_REG)\n+\t\t    (const_int 2)))]\n+  \"\"\n+  \"@\n+   pop\\t%v0\n+   pop\\t%v0 ; %0\"\n+)\n+\n+(define_insn \"sel_rb\"\n+  [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"\")] UNS_SET_RB)]\n+  \"\"\n+  \"sel\\trb%u0\"\n+  )\n+\n+(define_insn \"trampoline_init\"\n+  [(set (match_operand 0 \"register_operand\" \"=Z08W\")\n+\t(unspec_volatile [(match_operand 1 \"register_operand\" \"Z08W\")\n+\t\t\t  (match_operand 2 \"register_operand\" \"Z10W\")\n+\t\t\t  ] UNS_TRAMPOLINE_INIT))\n+   ]\n+  \"\"\n+  \"call !!___trampoline_init ; %0 <= %1 %2\"\n+  )\n+\n+(define_insn \"trampoline_uninit\"\n+  [(unspec_volatile [(const_int 0)] UNS_TRAMPOLINE_UNINIT)\n+   ]\n+  \"\"\n+  \"call !!___trampoline_uninit\"\n+  )\n+\n+;; GCC restores $fp *before* using it to access values on the *old*\n+;; frame.  So, we do it ourselves, to ensure this is not the case.\n+;; Note that while %1 is usually a label_ref, we allow for a\n+;; non-immediate as well.\n+(define_expand \"nonlocal_goto\"\n+  [(set (pc)\n+\t(unspec_volatile [(match_operand 0 \"\" \"\") ;; fp (ignore)\n+\t\t\t  (match_operand 1 \"\" \"vi\") ;; target\n+\t\t\t  (match_operand 2 \"\" \"vi\") ;; sp\n+\t\t\t  (match_operand 3 \"\" \"vi\") ;; ?\n+\t\t\t  ] UNS_NONLOCAL_GOTO))\n+   ]\n+  \"\"\n+  \"emit_jump_insn (gen_nonlocal_goto_insn (operands[0], operands[1], operands[2], operands[3]));\n+   emit_barrier ();\n+   DONE;\"\n+  )\n+\n+(define_insn \"nonlocal_goto_insn\"\n+  [(set (pc)\n+\t(unspec_volatile [(match_operand 0 \"\" \"\") ;; fp (ignore)\n+\t\t\t  (match_operand 1 \"\" \"vi\") ;; target\n+\t\t\t  (match_operand 2 \"\" \"vi\") ;; sp\n+\t\t\t  (match_operand 3 \"\" \"vi\") ;; ?\n+\t\t\t  ] UNS_NONLOCAL_GOTO))\n+   ]\n+  \"\"\n+  \"; nonlocal goto\n+\tmovw\tax, %3\n+\tmovw\tr22, ax\n+\tmovw\tax, %2\n+\tmovw\tsp, ax\n+\tmovw\tax, %1\n+\tbr\tax\n+\"\n+  )\n+\n+;;======================================================================\n+;;\n+;; \"macro\" insns - cases where inline chunks of code are more\n+;; efficient than anything else.\n+\n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=&v\")\n+\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"vi\")\n+\t\t (match_operand    2 \"nonmemory_operand\" \"vi\")))\n+   ]\n+  \"\"\n+  \"if (!nonmemory_operand (operands[1], SImode))\n+     operands[1] = force_reg (SImode, operands[1]);\n+   if (!nonmemory_operand (operands[1], SImode))\n+     operands[2] = force_reg (SImode, operands[2]);\"\n+)\n+\n+(define_insn \"addsi3_internal\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=&v\")\n+\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"vi\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"vi\")))\n+   ]\n+  \"\"\n+  \"; addSI macro %0 = %1 + %2\n+\tmovw\tax, %h1\n+\taddw\tax, %h2\n+\tmovw\t%h0, ax\n+\tmovw\tax,%H1\n+\tsknc\n+\tincw\tax\n+\taddw\tax,%H2\n+\tmovw\t%H0,ax\n+\t; end of addSI macro\"\n+  [(set_attr \"valloc\" \"macax\")]\n+)\n+\n+(define_expand \"mulsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=&v\")\n+\t(mult:SI (match_operand:SI 1 \"nonmemory_operand\" \"vi\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"vi\")))\n+   ]\n+  \"! RL78_MUL_NONE\"\n+  \"\"\n+)\n+\n+;; 0xFFFF0 is MACR(L).  0xFFFF2 is MACR(H) but we don't care about it\n+;; because we're only using the lower 16 bits (which is the upper 16\n+;; bits of the result).\n+(define_insn \"mulsi3_rl78\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=&v\")\n+\t(mult:SI (match_operand:SI 1 \"nonmemory_operand\" \"vi\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"vi\")))\n+   ]\n+  \"RL78_MUL_RL78\"\n+  \"; mulsi macro %0 = %1 * %2\n+\tmovw\tax, %h1\n+\tmovw\tbc, %h2\n+\tMULHU\t; bcax = bc * ax\n+\tmovw\t%h0, ax\n+\tmovw\tax, bc\n+\tmovw\t0xffff0, ax\n+\tmovw\tax, %H1\n+\tmovw\tbc, %h2\n+\tMACHU\t; MACR += bc * ax\n+\tmovw\tax, %h1\n+\tmovw\tbc, %H2\n+\tMACHU\t; MACR += bc * ax\n+\tmovw\tax, 0xffff0\n+\tmovw\t%H0, ax\n+\t; end of mulsi macro\"\n+  [(set_attr \"valloc\" \"macax\")]\n+  )\n+\n+;; 0xFFFF0 is MDAL.  0xFFFF2 is MDAH.\n+;; 0xFFFF4 is MDBL.  0xFFFF6 is MDBH.\n+;; 0xF00E0 is MDCL.  0xF00E2 is MDCH.\n+;; 0xF00E8 is MDUC.\n+;; Warning: this matches the documentation, not the silicon.\n+(define_insn \"mulsi3_g13\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=&v\")\n+\t(mult:SI (match_operand:SI 1 \"nonmemory_operand\" \"vi\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"vi\")))\n+   ]\n+  \"RL78_MUL_G13\"\n+  \"; mulsi macro %0 = %1 * %2\n+\tmov\ta, #0x00\n+\tmov\t!0xf00e8, a\t; MDUC\n+\tmovw\tax, %h1\n+\tmovw\t0xffff0, ax\t; MDAL\n+\tmovw\tax, %h2\n+\tmovw\t0xffff2, ax\t; MDAH\n+\tnop\t; mdb = mdal * mdah\n+\tmovw\tax, 0xffff4\t; MDBL\n+\tmovw\t%h0, ax\n+\n+\tmov\ta, #0x40\n+\tmov\t!0xf00e8, a\t; MDUC\n+\tmovw\tax, 0xffff6\t; MDBH\n+\tmovw\t!0xf00e0, ax\t; MDCL\n+\tmovw\tax, #0\n+\tmovw\t!0xf00e2, ax\t; MDCL\n+\tmovw\tax, %H1\n+\tmovw\t0xffff0, ax\t; MDAL\n+\tmovw\tax, %h2\n+\tmovw\t0xffff2, ax\t; MDAH\n+\tnop\t; mdc += mdal * mdah\n+\n+\tmov\ta, #0x40\n+\tmov\t!0xf00e8, a\t; MDUC\n+\tmovw\tax, %h1\n+\tmovw\t0xffff0, ax\t; MDAL\n+\tmovw\tax, %H2\n+\tmovw\t0xffff2, ax\t; MDAH\n+\tnop\t; mdc += mdal * mdah\n+\tmovw\tax, !0xf00e0\t; MDCL\n+\tmovw\t%H0, ax\n+\t; end of mulsi macro\"\n+  [(set_attr \"valloc\" \"macax\")]\n+  )"}, {"sha": "d4858ba1794b0e82f10276f97435f02dba940a4d", "filename": "gcc/config/rl78/rl78.opt", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Frl78.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.opt?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,43 @@\n+; Command line options for the Renesas RL78 port of GCC.\n+; Copyright (C) 2011 Free Software Foundation, Inc.\n+; Contributed by Red Hat.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+;---------------------------------------------------\n+\n+HeaderInclude\n+config/rl78/rl78-opts.h\n+\n+msim\n+Target\n+Use the simulator runtime.\n+\n+mmul=\n+Target RejectNegative Joined Var(rl78_mul_type) Report Tolower Enum(rl78_mul_types) Init(MUL_NONE)\n+Select hardware or software multiplication support.\n+\n+Enum\n+Name(rl78_mul_types) Type(enum rl78_mul_types)\n+\n+EnumValue\n+Enum(rl78_mul_types) String(none) Value(MUL_NONE)\n+\n+EnumValue\n+Enum(rl78_mul_types) String(rl78) Value(MUL_RL78)\n+\n+EnumValue\n+Enum(rl78_mul_types) String(g13) Value(MUL_G13)"}, {"sha": "9d08f1f2526bdf436d168d4bb7741551938fa5d0", "filename": "gcc/config/rl78/t-rl78", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Ft-rl78", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fconfig%2Frl78%2Ft-rl78", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Ft-rl78?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,22 @@\n+# Makefile fragment for building GCC for the Renesas RL78 target.\n+# Copyright (C) 2011 Free Software Foundation, Inc.\n+# Contributed by Red Hat.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See\n+# the GNU General Public License for more details.\n+#\n+# You should have received a copy of the  GNU General Public\n+# License along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+rl78-c.o: $(srcdir)/config/rl78/rl78-c.c $(RTL_H) $(TREE_H) $(CONFIG_H) $(TM_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<"}, {"sha": "37e24f06a1d751adcc97afc8cd7bed37b61f143a", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -220,7 +220,7 @@ Mo DeJong for GCJ and libgcj bug fixes.\n \n @item\n DJ Delorie for the DJGPP port, build and libiberty maintenance,\n-various bug fixes, and the M32C and MeP ports.\n+various bug fixes, and the M32C, MeP, and RL78 ports.\n \n @item\n Arnaud Desitter for helping to debug GNU Fortran."}, {"sha": "7f39a61fdb28bde133b606d1e7ecedbfd424015b", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -1220,11 +1220,12 @@ Fixed-point types are supported by the DWARF2 debug information format.\n \n As an extension, the GNU C compiler supports named address spaces as\n defined in the N1275 draft of ISO/IEC DTR 18037.  Support for named\n-address spaces in GCC will evolve as the draft technical report changes.\n-Calling conventions for any target might also change.  At present, only\n-the SPU and M32C targets support other address spaces.  On the SPU target, for\n-example, variables may be declared as belonging to another address space\n-by qualifying the type with the @code{__ea} address space identifier:\n+address spaces in GCC will evolve as the draft technical report\n+changes.  Calling conventions for any target might also change.  At\n+present, only the SPU, M32C, and RL78 targets support other address\n+spaces.  On the SPU target, for example, variables may be declared as\n+belonging to another address space by qualifying the type with the\n+@code{__ea} address space identifier:\n \n @smallexample\n extern int __ea i;\n@@ -1244,6 +1245,11 @@ qualified with @code{__far} are accessed using 32-bit addresses in\n order to access memory beyond the first 64k bytes.  If @code{__far} is\n used with the M32CM or M32C cpu variants, it has no effect.\n \n+On the RL78 target, variables qualified with @code{__far} are accessed\n+with 32-bit pointers (20-bit addresses) rather than the default 16-bit\n+addresses.  Non-far variables are assumed to appear in the topmost 64\n+kB of the address space.\n+\n @node Zero Length\n @section Arrays of Length Zero\n @cindex arrays of length zero\n@@ -2553,7 +2559,7 @@ This attribute is ignored for R8C target.\n @item interrupt\n @cindex interrupt handler functions\n Use this attribute on the ARM, AVR, Epiphany, M32C, M32R/D, m68k, MeP, MIPS,\n-RX and Xstormy16 ports to indicate that the specified function is an\n+RL78, RX and Xstormy16 ports to indicate that the specified function is an\n interrupt handler.  The compiler will generate function entry and exit\n sequences suitable for use in an interrupt handler when this attribute\n is present.\n@@ -2611,6 +2617,10 @@ void __attribute__ ((interrupt, use_shadow_register_set,\n                      use_debug_exception_return)) v7 ();\n @end smallexample\n \n+On RL78, use @code{brk_interrupt} instead of @code{interrupt} for\n+handlers intended to be used with the @code{BRK} opcode (i.e.  those\n+that must end with @code{RETB} instead of @code{RETI}).\n+\n @item ifunc (\"@var{resolver}\")\n @cindex @code{ifunc} attribute\n The @code{ifunc} attribute is used to mark a function as an indirect"}, {"sha": "da84758f2543cb81ffab2771b494c23d5d758158", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -4137,6 +4137,13 @@ the PSIM simulator.\n @heading @anchor{powerpcle-x-eabi}powerpcle-*-eabi\n Embedded PowerPC system in little endian mode.\n \n+@html\n+<hr />\n+@end html\n+@heading @anchor{rl78-x-elf}rl78-*-elf\n+The Renesas RL78 processor.\n+This configuration is intended for embedded systems.\n+\n @html\n <hr />\n @end html"}, {"sha": "265c8f06cba45902e5c1f4634e2c5d1106e2275d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -778,6 +778,9 @@ Objective-C and Objective-C++ Dialects}.\n @emph{PowerPC Options}\n See RS/6000 and PowerPC Options.\n \n+@emph{RL78 Options}\n+@gccoptlist{-msim -mmul=none -mmul=g13 -mmul=rl78}\n+\n @emph{RS/6000 and PowerPC Options}\n @gccoptlist{-mcpu=@var{cpu-type} @gol\n -mtune=@var{cpu-type} @gol\n@@ -10303,6 +10306,7 @@ platform.\n * PDP-11 Options::\n * picoChip Options::\n * PowerPC Options::\n+* RL78 Options::\n * RS/6000 and PowerPC Options::\n * RX Options::\n * S/390 and zSeries Options::\n@@ -15931,6 +15935,29 @@ the warning to be turned off.\n \n These are listed under @xref{RS/6000 and PowerPC Options}.\n \n+@node RL78 Options\n+@subsection RL78 Options\n+@cindex RL78 Options\n+\n+@table @gcctabopt\n+\n+@item -msim\n+@opindex msim\n+Links in additional target libraries to support operation within a\n+simulator.\n+\n+@item -mmul=none\n+@itemx -mmul=g13\n+@itemx -mmul=rl78\n+@opindex mmul\n+Specifies the type of hardware multiplication support to be used.  The\n+default is @code{none}, which uses software multiplication functions.\n+The @code{g13} option is for the hardware multiply/divide peripheral\n+only on the RL78/G13 targets.  The @code{rl78} option is for the\n+standard hardware multiplication defined in the RL78 software manual.\n+\n+@end table\n+\n @node RS/6000 and PowerPC Options\n @subsection IBM RS/6000 and PowerPC Options\n @cindex RS/6000 and PowerPC Options"}, {"sha": "dc87ca732d3b6bb37a26263479816d9c4fa7a691", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -2979,6 +2979,96 @@ A memory reference that is encoded within the opcode.\n \n @end table\n \n+@item RL78---@file{config/rl78/constraints.md}\n+@table @code\n+\n+@item Int3\n+An integer constant in the range 1 @dots{} 7.\n+@item Int8\n+An integer constant in the range 0 @dots{} 255.\n+@item J\n+An integer constant in the range @minus{}255 @dots{} 0\n+@item K\n+The integer constant 1.\n+@item L\n+The integer constant -1.\n+@item M\n+The integer constant 0.\n+@item N\n+The integer constant 2.\n+@item O\n+The integer constant -2.\n+@item P\n+An integer constant in the range 1 @dots{} 15.\n+@item Qbi\n+The built-in compare types--eq, ne, gtu, ltu, geu, and leu.\n+@item Qsc\n+The synthetic compare types--gt, lt, ge, and le.\n+@item Wab\n+A memory reference with an absolute address.\n+@item Wbc\n+A memory reference using @code{BC} as a base register, with an optional offset.\n+@item Wca\n+A memory reference using @code{AX}, @code{BC}, @code{DE}, or @code{HL} for the address, for calls.\n+@item Wcv\n+A memory reference using any 16-bit register pair for the address, for calls.\n+@item Wd2\n+A memory reference using @code{DE} as a base register, with an optional offset.\n+@item Wde\n+A memory reference using @code{DE} as a base register, without any offset.\n+@item Wfr\n+Any memory reference to an address in the far address space.\n+@item Wh1\n+A memory reference using @code{HL} as a base register, with an optional one-byte offset.\n+@item Whb\n+A memory reference using @code{HL} as a base register, with @code{B} or @code{C} as the index register.\n+@item Whl\n+A memory reference using @code{HL} as a base register, without any offset.\n+@item Ws1\n+A memory reference using @code{SP} as a base register, with an optional one-byte offset.\n+@item Y\n+Any memory reference to an address in the near address space.\n+@item A\n+The @code{AX} register.\n+@item B\n+The @code{BC} register.\n+@item D\n+The @code{DE} register.\n+@item R\n+@code{A} through @code{L} registers.\n+@item S\n+The @code{SP} register.\n+@item T\n+The @code{HL} register.\n+@item Z08W\n+The 16-bit @code{R8} register.\n+@item Z10W\n+The 16-bit @code{R10} register.\n+@item Zint\n+The registers reserved for interrupts (@code{R24} to @code{R31}).\n+@item a\n+The @code{A} register.\n+@item b\n+The @code{B} register.\n+@item c\n+The @code{C} register.\n+@item d\n+The @code{D} register.\n+@item e\n+The @code{E} register.\n+@item h\n+The @code{H} register.\n+@item l\n+The @code{L} register.\n+@item v\n+The virtual registers.\n+@item w\n+The @code{PSW} register.\n+@item x\n+The @code{X} register.\n+\n+@end table\n+\n @item RX---@file{config/rx/constraints.md}\n @table @code\n @item Q"}, {"sha": "bf07e10a3ea3986f396e6bf8b3fe403b58fc6db1", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -1,3 +1,8 @@\n+2011-11-29  DJ Delorie  <dj@redhat.com>\n+\n+\t* config.host (rl78-*-elf): New case.\n+\t* config/rl78: New directory for the Renesas RL78.\n+\n 2011-11-29  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* config.host (tic6x-*-uclinux): Append to extra_parts.  Fix"}, {"sha": "f15282c4924d05b7faf43920f5297422de33e536", "filename": "libgcc/config.host", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -916,6 +916,9 @@ rs6000-ibm-aix[56789].* | powerpc-ibm-aix[56789].*)\n \tmd_unwind_header=rs6000/aix-unwind.h\n \ttmake_file=\"t-fdpbit rs6000/t-ppc64-fp rs6000/t-ibm-ldouble rs6000/t-slibgcc-aix\"\n \t;;\n+rl78-*-elf)\n+\ttmake_file=\"$tm_file t-fdpbit rl78/t-rl78\"\n+\t;;\n rx-*-elf)\n \ttmake_file=\"rx/t-rx t-fdpbit\"\n \ttm_file=\"$tm_file rx/rx-abi.h rx/rx-lib.h\""}, {"sha": "14fa3cf0383415c6e2dd87f52065d1eecf018cf9", "filename": "libgcc/config/rl78/cmpsi2.S", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Fcmpsi2.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Fcmpsi2.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fcmpsi2.S?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,122 @@\n+;   Copyright (C) 2011 Free Software Foundation, Inc.\n+;   Contributed by Red Hat.\n+; \n+; This file is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published by the\n+; Free Software Foundation; either version 3, or (at your option) any\n+; later version.\n+; \n+; This file is distributed in the hope that it will be useful, but\n+; WITHOUT ANY WARRANTY; without even the implied warranty of\n+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+; General Public License for more details.\n+; \n+; Under Section 7 of GPL version 3, you are granted additional\n+; permissions described in the GCC Runtime Library Exception, version\n+; 3.1, as published by the Free Software Foundation.\n+;\n+; You should have received a copy of the GNU General Public License and\n+; a copy of the GCC Runtime Library Exception along with this program;\n+; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+; <http://www.gnu.org/licenses/>.\n+\n+\n+; clobberable\n+r8\t=\t0xffef0\n+\n+\t.text\n+\n+\t;;   int __cmpsi2 (signed long A, signed long B)\n+\t;;\n+\t;; Performs a signed comparison of A and B.\n+\t;; If A is less than B it returns 0.  If A is greater\n+\t;; than B it returns 2.  If they are equal it returns 1.\n+\n+\t.global\t___cmpsi2\n+        .type   ___cmpsi2, @function\n+___cmpsi2:\n+\t;; A is at [sp+4]\n+\t;; B is at [sp+8]\n+\t;; Result put in R8\n+\n+\t;; Initialise default return value.\n+\tonew\tbc\n+\t\n+\t;;  Compare the high words.\n+\tmovw\tax, [sp + 10]\n+\tmovw\tde, ax\n+\tmovw\tax, [sp + 6]\n+\tcmpw\tax, de\n+\tskz\n+\tbr\t!!.Lconvert_to_signed\n+\n+.Lcompare_bottom_words:\t\n+\t;; The top words are equal - compare the bottom words.\n+\t;; Note - code from __ucmpsi2 branches into here.\n+\tmovw   ax, [sp + 8]\n+\tmovw   de, ax\n+\tmovw   ax, [sp + 4]\n+\tcmpw   ax, de\n+\tsknz\n+\tbr\t!!.Lless_than_or_greater_than\n+\t;; The words are equal - return 1.\n+\t;; Note - we could branch to the return code at the end of the\n+\t;; function but a branch instruction takes 4 bytes, and the\n+\t;; return sequence itself is only 4 bytes long...\n+\tmovw\tax, bc\n+\tmovw\tr8, ax\n+\tret\n+\n+.Lconvert_to_signed:\t\n+\t;; The top words are different.  Unfortunately the comparison\n+\t;; is always unsigned, so to get a signed result we XOR the CY\n+\t;; flag with the top bits of AX and DE.\n+\txor1\tcy, a.7\n+\tmov\ta, d\n+\txor1\tcy, a.7\n+\t;; Fall through.\n+\n+.Lless_than_or_greater_than:\n+\t;; We now have a signed less than/greater than result in CY.\n+\t;; Return 0 for less than, 2 for greater than.\n+\t;; Note - code from __ucmpsi2 branches into here.\n+\tincw\tbc\n+\tsknc\n+\tclrw\tbc\n+\n+\t;; Get the result value, currently in BC, into r8\n+\tmovw\tax, bc\n+\tmovw\tr8, ax\n+\tret\n+\n+\t.size\t___cmpsi2, . - ___cmpsi2\n+\t\n+\t\n+\t;;   int __ucmpsi2 (unsigned long A, unsigned long B)\n+\t;;\n+\t;; Performs an unsigned comparison of A and B.\n+\t;; If A is less than B it returns 0.  If A is greater\n+\t;; than B it returns 2.  If they are equal it returns 1.\n+\n+\t.global\t___ucmpsi2\n+        .type   ___ucmpsi2, @function\n+___ucmpsi2:\n+\t;; A is at [sp+4]\n+\t;; B is at [sp+8]\n+\t;; Result put in R8..R9\n+\n+\t;; Initialise default return value.\n+\tonew\tbc\n+\n+\t;;  Compare the high words.\n+\tmovw\tax, [sp + 10]\n+\tmovw\tde, ax\n+\tmovw\tax, [sp + 6]\n+\tcmpw\tax, de\n+\tskz\n+\t;; Note: These branches go into the __cmpsi2 code!\n+\tbr\t!!.Lless_than_or_greater_than\n+\tbr\t!!.Lcompare_bottom_words\n+\n+\t.size\t___ucmpsi2, . - ___ucmpsi2\n+\t\n\\ No newline at end of file"}, {"sha": "679f26dccec99a5fe639fa6b10c21df286767b3b", "filename": "libgcc/config/rl78/lib2div.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Flib2div.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Flib2div.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Flib2div.c?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,81 @@\n+/* libgcc routines for RL78\n+   Copyright (C) 2005, 2009, 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+typedef          int  sint32_type   __attribute__ ((mode (SI)));\n+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));\n+typedef          int  sint16_type   __attribute__ ((mode (HI)));\n+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));\n+typedef          int  sint08_type   __attribute__ ((mode (QI)));\n+typedef unsigned int  uint08_type   __attribute__ ((mode (QI)));\n+typedef int           word_type     __attribute__ ((mode (__word__)));\n+\n+#define C3B(a,b,c) a##b##c\n+#define C3(a,b,c) C3B(a,b,c)\n+\n+#define UINT_TYPE\tuint32_type\n+#define SINT_TYPE\tsint32_type\n+#define BITS_MINUS_1\t31\n+#define NAME_MODE\tsi\n+\n+#include \"rl78-divmod.h\"\n+\n+#undef UINT_TYPE\n+#undef SINT_TYPE\n+#undef BITS_MINUS_1\n+#undef NAME_MODE\n+\n+#define UINT_TYPE\tuint16_type\n+#define SINT_TYPE\tsint16_type\n+#define BITS_MINUS_1\t15\n+#define NAME_MODE\thi\n+\n+#include \"rl78-divmod.h\"\n+\n+#undef UINT_TYPE\n+#undef SINT_TYPE\n+#undef BITS_MINUS_1\n+#undef NAME_MODE\n+\n+#define UINT_TYPE\tuint08_type\n+#define SINT_TYPE\tsint08_type\n+#define BITS_MINUS_1\t7\n+#define NAME_MODE\tqi\n+\n+#include \"rl78-divmod.h\"\n+\n+/* See the comment by the definition of LIBGCC2_UNITS_PER_WORD in\n+   m32c.h for why we are creating extra versions of some of the\n+   functions defined in libgcc2.c.  */\n+\n+#define LIBGCC2_UNITS_PER_WORD 2\n+\n+#define L_clzsi2\n+#define L_ctzsi2\n+#define L_ffssi2\n+#define L_paritysi2\n+#define L_popcountsi2\n+\n+#include \"libgcc2.c\""}, {"sha": "123690bc9ba81e5b3e006554be0b7c05f521e5af", "filename": "libgcc/config/rl78/lib2mul.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Flib2mul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Flib2mul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Flib2mul.c?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,49 @@\n+/* libgcc routines for RL78\n+   Copyright (C) 2005, 2009, 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));\n+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));\n+typedef unsigned int  uint08_type   __attribute__ ((mode (QI)));\n+\n+#define C3B(a,b,c) a##b##c\n+#define C3(a,b,c) C3B(a,b,c)\n+\n+\n+#define UINT_TYPE\tuint16_type\n+#define BITS_MINUS_1\t15\n+#define NAME_MODE\thi\n+\n+/*#include \"rl78-mul.h\"*/\n+\n+#undef UINT_TYPE\n+#undef BITS_MINUS_1\n+#undef NAME_MODE\n+\n+#define UINT_TYPE\tuint08_type\n+#define BITS_MINUS_1\t7\n+#define NAME_MODE\tqi\n+\n+#include \"rl78-mul.h\""}, {"sha": "c9db85ea0eda1cdf8f5fae871d0126a639b37fa8", "filename": "libgcc/config/rl78/lib2shift.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Flib2shift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Flib2shift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Flib2shift.c?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,113 @@\n+/* Shift functions for the GCC support library for the Renesas RL78 processors.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\f\n+typedef          int  sint32_type   __attribute__ ((mode (SI)));\n+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));\n+typedef          int  sint16_type   __attribute__ ((mode (HI)));\n+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));\n+\n+uint32_type __ashlsi3 (uint32_type in, char bit);\n+sint32_type __ashrsi3 (sint32_type in, char bit);\n+int __clrsbhi2 (sint16_type x);\n+extern int __clrsbsi2 (sint32_type x);\n+\n+typedef struct\n+{\n+  union\n+  {\n+    uint32_type u;\n+    uint16_type h[2];\n+  } u;\n+} dd;\n+\n+uint32_type\n+__ashlsi3 (uint32_type in, char bit)\n+{\n+  uint16_type h, l;\n+  dd d;\n+\n+  if (bit > 32)\n+    return 0;\n+  if (bit < 0)\n+    return in;\n+\n+  d.u.u = in;\n+  h = d.u.h[1];\n+  l = d.u.h[0];\n+\n+  if (bit > 15)\n+    {\n+      h = l;\n+      l = 0;\n+      bit -= 16;\n+    }\n+\n+  while (bit)\n+    {\n+      h = (h << 1) | (l >> 15);\n+      l <<= 1;\n+      bit --;\n+    }\n+\n+  d.u.h[1] = h;\n+  d.u.h[0] = l;\n+  return d.u.u;\n+}\n+\n+sint32_type\n+__ashrsi3 (sint32_type in, char bit)\n+{\n+  sint16_type h;\n+  uint16_type l;\n+  dd d;\n+\n+  if (bit > 32)\n+    return 0;\n+  if (bit < 0)\n+    return in;\n+\n+  d.u.u = in;\n+  h = d.u.h[1];\n+  l = d.u.h[0];\n+\n+  while (bit)\n+    {\n+      l = (h << 15) | (l >> 1);\n+      h >>= 1;\n+      bit --;\n+    }\n+\n+  d.u.h[1] = h;\n+  d.u.h[0] = l;\n+  return d.u.u;\n+}\n+\n+int\n+__clrsbhi2 (sint16_type x)\n+{\n+  if (x == 0)\n+    return 15;\n+  return __clrsbsi2 ((sint32_type) x) - 16;\n+}"}, {"sha": "84222844259501edb114572dd6e80dae5faa0ce5", "filename": "libgcc/config/rl78/lshrsi3.S", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Flshrsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Flshrsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Flshrsi3.S?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,131 @@\n+;   Copyright (C) 2011 Free Software Foundation, Inc.\n+;   Contributed by Red Hat.\n+; \n+; This file is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published by the\n+; Free Software Foundation; either version 3, or (at your option) any\n+; later version.\n+; \n+; This file is distributed in the hope that it will be useful, but\n+; WITHOUT ANY WARRANTY; without even the implied warranty of\n+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+; General Public License for more details.\n+; \n+; Under Section 7 of GPL version 3, you are granted additional\n+; permissions described in the GCC Runtime Library Exception, version\n+; 3.1, as published by the Free Software Foundation.\n+;\n+; You should have received a copy of the GNU General Public License and\n+; a copy of the GCC Runtime Library Exception along with this program;\n+; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+; <http://www.gnu.org/licenses/>.\n+\n+r8\t=\t0xffef0\n+r16\t=\t0xffee8\n+r9\t=\t0xffef1\n+r17\t=\t0xffee9\n+r10\t=\t0xffef2\n+r18\t=\t0xffeea\n+r11\t=\t0xffef3\n+r19\t=\t0xffeeb\n+r12\t=\t0xffef4\n+r20\t=\t0xffeec\n+r13\t=\t0xffef5\n+r21\t=\t0xffeed\n+r14\t=\t0xffef6\n+r22\t=\t0xffeee\n+r15\t=\t0xffef7\n+r23\t=\t0xffeef\n+\t\n+\t.text\n+\t.global\t___lshrsi3\n+\t.type\t___lshrsi3, @function\n+___lshrsi3:\n+\n+\t;; input:\n+\t;; \n+\t;; [zero]\n+\t;; [count]   <= $sp+8\n+\t;; [in MSB]\n+\t;; [in]\n+\t;; [in]\n+\t;; [in LSB]  <- $sp+4\n+\n+\t;; output:\n+\t;; \n+\t;; [r8..r11] result\n+\n+\t;; registers:\n+\t;;\n+\t;; AX - temp for shift/rotate\n+\t;; B  - count\n+\n+\tmov\ta, [sp+8]\t; A now contains the count\n+\n+\tcmp\ta, #0x20\n+\tbc\t$.Lcount_is_normal\n+\n+\t;; count is out of bounds, just return zero.\n+\tmovw\tr8, #0\n+\tmovw\tr10, #0\n+\tret\n+\n+.Lcount_is_normal:\n+\tcmp0\ta\n+\tbnz\t$.Lcount_is_nonzero\n+\n+\t;; count is zero, just copy IN to OUT\n+\tmovw\tax, [sp+4]\n+\tmovw\tr8, ax\n+\tmovw\tax, [sp+6]\n+\tmovw\tr10, ax\n+\tret\n+\n+.Lcount_is_nonzero:\n+\tmov\tb, a\t\t; B now contains the count also\n+\tbf\ta.4, $.Lcount_lt_16\n+\n+\t;; count >= 16, shift 16 at a time.\n+\tmovw\tr10, #0\n+\tmovw\tax, [sp+6]\n+\tmovw\tr8, ax\n+\tmov\ta, b\n+\tand\ta, #0x0f\n+\tsknz\n+\tret\n+\n+\tmov\tb, a\t\t; B now contains the remaining count\n+\tinc\tb\n+\tbr\t$.Lloop_top\n+\n+.Lcount_lt_16:\t\n+\t;; count is nonzero.  Do one \n+\tmovw\tax, [sp+6]\n+\tshrw\tax,1\n+\tmovw\tr10, ax\n+\tmov\ta, [sp+5]\n+\trorc\ta,1\n+\tmov\tr9, a\n+\tmov\ta, [sp+4]\n+\trorc\ta,1\n+\tmov\tr8, a\n+\n+\t;; we did one shift above; do as many more as we need now.\n+.Lloop_top:\t\n+\tdec\tb\n+\tsknz\n+\tret\n+\n+\tmovw\tax, r10\n+\tshrw\tax,1\n+\tmovw\tr10, ax\n+\tmov\ta, r9\n+\trorc\ta,1\n+\tmov\tr9, a\n+\tmov\ta, r8\n+\trorc\ta,1\n+\tmov\tr8, a\n+\n+\tbr\t$.Lloop_top\n+\n+\t.size\t___lshrsi3, .-___lshrsi3"}, {"sha": "0bca43ad098fdbe157c3056c0c755690a4e13331", "filename": "libgcc/config/rl78/mulsi3.S", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Fmulsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Fmulsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fmulsi3.S?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,235 @@\n+;   Copyright (C) 2011 Free Software Foundation, Inc.\n+;   Contributed by Red Hat.\n+; \n+; This file is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published by the\n+; Free Software Foundation; either version 3, or (at your option) any\n+; later version.\n+; \n+; This file is distributed in the hope that it will be useful, but\n+; WITHOUT ANY WARRANTY; without even the implied warranty of\n+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+; General Public License for more details.\n+; \n+; Under Section 7 of GPL version 3, you are granted additional\n+; permissions described in the GCC Runtime Library Exception, version\n+; 3.1, as published by the Free Software Foundation.\n+;\n+; You should have received a copy of the GNU General Public License and\n+; a copy of the GCC Runtime Library Exception along with this program;\n+; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+; <http://www.gnu.org/licenses/>.\n+\n+;; 32x32=32 multiply\n+\n+; real\n+; GAS defines r0..r7 as aliases for real registers; we want the saddr\n+; forms here.\n+r_0\t=\t0xffef8\n+r_1\t=\t0xffef9\n+r_2\t=\t0xffefa\n+r_3\t=\t0xffefb\n+r_4\t=\t0xffefc\n+r_5\t=\t0xffefd\n+r_6\t=\t0xffefe\n+r_7\t=\t0xffeff\n+; clobberable\n+r8\t=\t0xffef0\n+r9\t=\t0xffef1\n+r10\t=\t0xffef2\n+r11\t=\t0xffef3\n+r12\t=\t0xffef4\n+r13\t=\t0xffef5\n+r14\t=\t0xffef6\n+r15\t=\t0xffef7\n+; preserved\n+r16\t=\t0xffee8\n+r17\t=\t0xffee9\n+r18\t=\t0xffeea\n+r19\t=\t0xffeeb\n+r20\t=\t0xffeec\n+r21\t=\t0xffeed\n+r22\t=\t0xffeee\n+r23\t=\t0xffeef\n+\n+\n+;----------------------------------------------------------------------\n+\n+; Register use:\n+;\tRB0\tRB1\tRB2\n+; AX\top2L\tres32L\tres32H\n+; BC\top2H\t(resH)\top1\n+; DE\tcount\t(resL-tmp)\n+; HL\t[sp+4]\n+\n+\t.text\n+\tnop\n+\t.global\t___mulsi3\t\t; (USI a, USI b)\n+___mulsi3:\n+\t;; A is at [sp+4]\n+\t;; B is at [sp+8]\n+\t;; result is in R8..R11\n+\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\n+\tsel\trb2\n+\tpush\tax\n+\tpush\tbc\n+\tsel\trb0\n+\n+\tclrw\tax\n+\tmovw\tr8, ax\n+\tmovw\tr16, ax\n+\n+\tmovw\tax, [hl+6]\n+\tcmpw\tax, #0\n+\tbz\t$1f\n+\tcmpw\tax, #0xffff\n+\tbnz\t$2f\n+\tmovw\tax, [hl]\n+\tsel\trb1\n+\tsubw\tax, r_0\n+\tsel\trb0\n+\tbr\t$1f\n+2:\t\n+\tmovw\tbc, ax\n+\tmovw\tax, [hl]\n+\tcmpw\tax, #0\n+\tskz\n+\tcall\t!.Lmul_hi\n+1:\t\n+\n+\tmovw\tax, [hl+2]\n+\tcmpw\tax, #0\n+\tbz\t$1f\n+\tcmpw\tax, #0xffff\n+\tbnz\t$2f\n+\tmovw\tax, [hl+4]\n+\tsel\trb1\n+\tsubw\tax, r_0\n+\tsel\trb0\n+\tbr\t$1f\n+2:\t\n+\tmovw\tbc, ax\n+\tmovw\tax, [hl+4]\n+\tcmpw\tax, #0\n+\tskz\n+\tcall\t!.Lmul_hi\n+1:\t\n+\n+\tmovw\tax, r8\n+\tmovw\tr16, ax\n+\tclrw\tax\n+\tmovw\tr8, ax\n+\n+\t;; now do R16:R8 += op1L * op2L\n+\n+\t;; op1 is in AX.0 (needs to shrw)\n+\t;; op2 is in BC.2 and BC.1 (bc can shlw/rolcw)\n+\t;; res is in AX.2 and AX.1 (needs to addw)\n+\n+\tmovw\tax, [hl]\n+\tmovw\tr10, ax\t\t; BC.1\n+\tmovw\tax, [hl+4]\n+\n+\tcmpw\tax, r10\n+\tbc\t$.Lmul_hisi_top\n+\tmovw\tbc, r10\n+\tmovw\tr10, ax\n+\tmovw\tax, bc\n+\n+\n+.Lmul_hisi_top:\n+\tmovw\tbc, #0\n+\n+.Lmul_hisi_loop:\n+\tshrw\tax, 1\n+\tbnc\t$.Lmul_hisi_no_add\n+\tsel\trb1\n+\taddw\tax, bc\n+\tsel\trb2\n+\tsknc\n+\tincw\tax\n+\taddw\tax, r_2\n+.Lmul_hisi_no_add:\t\n+\tsel\trb1\n+\tshlw\tbc, 1\n+\tsel\trb0\n+\trolwc\tbc, 1\n+\tcmpw\tax, #0\n+\tbz\t$.Lmul_hisi_done\n+\n+\tshrw\tax, 1\n+\tbnc\t$.Lmul_hisi_no_add2\n+\tsel\trb1\n+\taddw\tax, bc\n+\tsel\trb2\n+\tsknc\n+\tincw\tax\n+\taddw\tax, r_2\n+.Lmul_hisi_no_add2:\n+\tsel\trb1\n+\tshlw\tbc, 1\n+\tsel\trb0\n+\trolwc\tbc, 1\n+\tcmpw\tax, #0\n+\tbnz\t$.Lmul_hisi_loop\n+\n+.Lmul_hisi_done:\n+\n+\tmovw\tax, r16\n+\tmovw\tr10, ax\n+\t\n+\tsel\trb2\n+\tpop\tbc\n+\tpop\tax\n+\tsel\trb0\n+\n+\tret\n+\n+;----------------------------------------------------------------------\n+\n+\t;; R8 += AX * BC\n+.Lmul_hi:\n+\tcmpw\tax, bc\n+\tskc\n+\txchw\tax, bc\n+\tbr\t$.Lmul_hi_loop\n+\t\n+.Lmul_hi_top:\n+\tsel\trb1\n+\taddw\tax, r_2\n+\tsel\trb0\n+.Lmul_hi_no_add:\t\n+\tshlw\tbc, 1\n+.Lmul_hi_loop:\n+\tshrw\tax, 1\n+\tbc\t$.Lmul_hi_top\n+\tcmpw\tax, #0\n+\tbz\t$.Lmul_hi_done\n+\n+\tshlw\tbc, 1\n+\tshrw\tax, 1\n+\tbc\t$.Lmul_hi_top\n+\tcmpw\tax, #0\n+\tbnz\t$.Lmul_hi_no_add\n+\n+.Lmul_hi_done:\n+\tret\n+\n+;----------------------------------------------------------------------\n+\n+\t.global\t___mulhi3\n+___mulhi3:\n+\tsel\trb1\n+\tclrw\tax\n+\tsel\trb0\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tmovw\tax, [hl+2]\n+\tmovw\tbc, ax\n+\tmovw\tax, [hl]\n+\tbr\t$.Lmul_hi"}, {"sha": "8ea5e1eeb10eb2ebe690098f9b807ffc86e224e1", "filename": "libgcc/config/rl78/rl78-divmod.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Frl78-divmod.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Frl78-divmod.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Frl78-divmod.h?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,118 @@\n+/* libgcc routines for RL78\n+   Copyright (C) 2005, 2009, 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+UINT_TYPE C3(udivmod,NAME_MODE,4) (UINT_TYPE, UINT_TYPE, word_type);\n+SINT_TYPE C3(__div,NAME_MODE,3)   (SINT_TYPE, SINT_TYPE);\n+SINT_TYPE C3(__mod,NAME_MODE,3)   (SINT_TYPE, SINT_TYPE);\n+UINT_TYPE C3(__udiv,NAME_MODE,3)  (UINT_TYPE, UINT_TYPE);\n+UINT_TYPE C3(__umod,NAME_MODE,3)  (UINT_TYPE, UINT_TYPE);\n+\n+UINT_TYPE\n+C3(udivmod,NAME_MODE,4) (UINT_TYPE num, UINT_TYPE den, word_type modwanted)\n+{\n+  UINT_TYPE bit = 1;\n+  UINT_TYPE res = 0;\n+\n+  while (den < num && bit && !(den & (1L << BITS_MINUS_1)))\n+    {\n+      den <<= 1;\n+      bit <<= 1;\n+    }\n+  while (bit)\n+    {\n+      if (num >= den)\n+\t{\n+\t  num -= den;\n+\t  res |= bit;\n+\t}\n+      bit >>= 1;\n+      den >>= 1;\n+    }\n+  if (modwanted)\n+    return num;\n+  return res;\n+}\n+\n+SINT_TYPE\n+C3(__div,NAME_MODE,3) (SINT_TYPE a, SINT_TYPE b)\n+{\n+  word_type neg = 0;\n+  SINT_TYPE res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = !neg;\n+    }\n+\n+  if (b < 0)\n+    {\n+      b = -b;\n+      neg = !neg;\n+    }\n+\n+  res = C3(udivmod,NAME_MODE,4) (a, b, 0);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+SINT_TYPE\n+C3(__mod,NAME_MODE,3) (SINT_TYPE a, SINT_TYPE b)\n+{\n+  word_type neg = 0;\n+  SINT_TYPE res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = 1;\n+    }\n+\n+  if (b < 0)\n+    b = -b;\n+\n+  res = C3(udivmod,NAME_MODE,4) (a, b, 1);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+UINT_TYPE\n+C3(__udiv,NAME_MODE,3) (UINT_TYPE a, UINT_TYPE b)\n+{\n+  return C3(udivmod,NAME_MODE,4) (a, b, 0);\n+}\n+\n+UINT_TYPE\n+C3(__umod,NAME_MODE,3) (UINT_TYPE a, UINT_TYPE b)\n+{\n+  return C3(udivmod,NAME_MODE,4) (a, b, 1);\n+}"}, {"sha": "fc2cd6c6ebb08e768c9ac7fcdfc80b153caf7e85", "filename": "libgcc/config/rl78/rl78-mul.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Frl78-mul.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Frl78-mul.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Frl78-mul.h?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,43 @@\n+/* libgcc routines for RL78\n+   Copyright (C) 2005, 2009, 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+UINT_TYPE C3(__mul,NAME_MODE,3)   (UINT_TYPE, UINT_TYPE);\n+UINT_TYPE\n+C3(__mul,NAME_MODE,3) (UINT_TYPE a, UINT_TYPE b)\n+{\n+  UINT_TYPE rv = 0;\n+\n+  char bit;\n+\n+  for (bit=0; b && bit<sizeof(UINT_TYPE)*8; bit++)\n+    {\n+      if (b & 1)\n+\trv += a;\n+      a <<= 1;\n+      b >>= 1;\n+    }\n+  return rv;\n+}"}, {"sha": "d1a82a290203bd3a6516cb0e1494727fd132f259", "filename": "libgcc/config/rl78/t-rl78", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Ft-rl78", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Ft-rl78", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Ft-rl78?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,28 @@\n+# Makefile fragment for building LIBGCC for the Renesas RL78 target.\n+# Copyright (C) 2011 Free Software Foundation, Inc.\n+# Contributed by Red Hat.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See\n+# the GNU General Public License for more details.\n+#\n+# You should have received a copy of the  GNU General Public\n+# License along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+LIB2ADD = \\\n+\t$(srcdir)/config/rl78/trampoline.S \\\n+\t$(srcdir)/config/rl78/lib2div.c \\\n+\t$(srcdir)/config/rl78/lib2mul.c \\\n+\t$(srcdir)/config/rl78/lib2shift.c \\\n+\t$(srcdir)/config/rl78/lshrsi3.S \\\n+\t$(srcdir)/config/rl78/mulsi3.S \\\n+\t$(srcdir)/config/rl78/cmpsi2.S"}, {"sha": "ef3aa6c97a688e00e3ba39ad5d647baf9479c3c9", "filename": "libgcc/config/rl78/trampoline.S", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Ftrampoline.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b8555ed3c45855b237b0f3a044eefb9382255c/libgcc%2Fconfig%2Frl78%2Ftrampoline.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Ftrampoline.S?ref=85b8555ed3c45855b237b0f3a044eefb9382255c", "patch": "@@ -0,0 +1,139 @@\n+/* libgcc routines for RL78\n+   Copyright (C) 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* RL78 Trampoline support\n+\n+  Since the RL78's RAM is not in the first 64k, we cannot \"just\" use a\n+  function pointer to point to a trampoline on the stack.  So, we\n+  create N fixed trampolines that read from an array, and allocate\n+  them as needed.\n+\n+*/\n+\n+r8\t=\t0xffef0\n+r10\t=\t0xffef2\n+r14\t=\t0xffef6\n+\n+\t.data\n+\t.p2align\t1\n+trampoline_array:\n+\n+\t.macro stub n\n+\n+\t.text\n+trampoline_\\n:\n+        .type   trampoline_\\n, @function\n+\tmovw\tax, !trampoline_chain_\\n\n+\tmovw\tr14, ax\n+\tmovw\tax, !trampoline_addr_\\n\n+\tbr\tax\n+\t.size\ttrampoline_\\n, .-trampoline_\\n\n+\n+\t.data\n+trampoline_frame_\\n:\n+\t.short\t0\n+trampoline_stub_\\n:\n+\t.short\ttrampoline_\\n\n+trampoline_chain_\\n:\n+\t.short\t0\n+trampoline_addr_\\n:\n+\t.short\t0\n+\n+#define TO_FRAME 0\n+#define TO_STUB  2\n+#define TO_CHAIN 4\n+#define TO_ADDR  6\n+#define TO_SIZE  8\n+\n+\t.endm\n+\n+\tstub\t0\n+\tstub\t1\n+\tstub\t2\n+\tstub\t3\n+\tstub\t4\n+\tstub\t5\n+\n+trampoline_array_end:\n+\n+/* Given the function pointer in R8 and the static chain\n+   pointer in R10, allocate a trampoline and return its address in\n+   R8. */\n+\n+\t.text\n+\t.global ___trampoline_init\n+        .type   ___trampoline_init, @function\n+___trampoline_init:\n+\n+\tmovw\thl, #trampoline_array\n+1:\n+\tmovw\tax, [hl + TO_ADDR]\n+\tcmpw\tax, #0\n+\tbz\t$2f\n+\n+\tmovw\tax, hl\n+\taddw\tax, #TO_SIZE\n+\tmovw\thl, ax\n+\tcmpw\tax, #trampoline_array_end\n+\tbnz\t$1b\n+\tbrk\t\t\t; no more slots?\n+\n+2:\tmovw\tax, r8\n+\tmovw\t[hl + TO_ADDR], ax\n+\tmovw\tax, r10\n+\tmovw\t[hl + TO_CHAIN], ax\n+\tmovw\tax, sp\n+\tmovw\t[hl + TO_FRAME], ax\n+\n+\tmovw\tax, [hl + TO_STUB]\n+\tmovw\tr8, ax\n+\n+\tret\n+\t.size\t___trampoline_init, . - ___trampoline_init\n+\n+\t.global\t___trampoline_uninit\n+        .type   ___trampoline_uninit, @function\n+___trampoline_uninit:\n+\tmovw\thl, #trampoline_array\n+\tmovw\tax, sp\n+\tmovw\tbc, ax\n+1:\n+\tmovw\tax, [hl + TO_FRAME]\n+\tcmpw\tax, bc\n+\tbc\t$2f\n+\n+\tclrw\tax\n+\tmovw\t[hl + TO_ADDR], ax\n+\n+2:\n+\tmovw\tax, hl\n+\taddw\tax, #TO_SIZE\n+\tmovw\thl, ax\n+\tcmpw\tax, #trampoline_array_end\n+\tbnz\t$1b\n+\n+\tret\n+\t.size\t___trampoline_uninit, . - ___trampoline_uninit"}]}