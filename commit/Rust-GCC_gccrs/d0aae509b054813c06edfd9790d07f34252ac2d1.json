{"sha": "d0aae509b054813c06edfd9790d07f34252ac2d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBhYWU1MDliMDU0ODEzYzA2ZWRmZDk3OTBkMDdmMzQyNTJhYzJkMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-08-21T17:20:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-08-21T17:20:04Z"}, "message": "(movdi-1...\n\n(movdi-1, movdf-1): Make conditional on reload_completed, delete\nconditions checking for pseudo registers and Q addresses.  Add code to\nhandle SUBREG.\n\nFrom-SVN: r10265", "tree": {"sha": "719e4bb733ffe0a642544aab5e03526897c64268", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/719e4bb733ffe0a642544aab5e03526897c64268"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0aae509b054813c06edfd9790d07f34252ac2d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0aae509b054813c06edfd9790d07f34252ac2d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0aae509b054813c06edfd9790d07f34252ac2d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0aae509b054813c06edfd9790d07f34252ac2d1/comments", "author": null, "committer": null, "parents": [{"sha": "c182df0b41f965988f06df25bcf63a98c0ec5030", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c182df0b41f965988f06df25bcf63a98c0ec5030", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c182df0b41f965988f06df25bcf63a98c0ec5030"}], "stats": {"total": 81, "additions": 45, "deletions": 36}, "files": [{"sha": "5bb256ea29ab92931c3c5f5d1158b17dc241d39b", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0aae509b054813c06edfd9790d07f34252ac2d1/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0aae509b054813c06edfd9790d07f34252ac2d1/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=d0aae509b054813c06edfd9790d07f34252ac2d1", "patch": "@@ -21,6 +21,9 @@\n ;; Boston, MA 02111-1307, USA.\n \n \n+;; ??? Should prepend a * to all pattern names which are not used.\n+;; This will make the compiler smaller, and rebuilds after changes faster.\n+\n ;; ??? Should be enhanced to include support for many more GNU superoptimizer\n ;; sequences.  Especially the sequences for arithmetic right shifts.\n \n@@ -1162,33 +1165,34 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"pcload,move,load,store,move\")])\n \n-;; If the output is a register and the input is memory, we have to be careful\n-;; and see which word needs to be loaded first.\n-\n-;; ??? Why are Q constraint addresses rejected here but not in the DFmode\n-;; split pattern?\n+;; If the output is a register and the input is memory or a register, we have\n+;; to be careful and see which word needs to be loaded first.  \n \n (define_split\n   [(set (match_operand:DI 0 \"general_movdst_operand\" \"\")\n \t(match_operand:DI 1 \"general_movsrc_operand\" \"\"))]\n- \"! (GET_CODE (operands[0]) == REG\n-     && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n-   && ! (GET_CODE (operands[1]) == REG\n-         && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n-   && ! (GET_CODE (operands[0]) == REG && GET_CODE (operands[1]) == REG\n-\t && ! reload_completed\n-\t && reg_overlap_mentioned_p (operands[0], operands[1]))\n-   && ! (GET_CODE (operands[0]) == MEM\n-\t && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-   && ! (GET_CODE (operands[1]) == MEM\n-\t && GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n-   && ! EXTRA_CONSTRAINT_Q (operands[1])\"\n+  \"reload_completed\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 4) (match_dup 5))]\n   \"\n-{ if (GET_CODE (operands[0]) != REG\n-      || ! refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t      operands[1], 0))\n+{\n+  int regno;\n+\n+  if ((GET_CODE (operands[0]) == MEM\n+       && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+      || (GET_CODE (operands[1]) == MEM\n+\t  && GET_CODE (XEXP (operands[1], 0)) == POST_INC))\n+    FAIL;\n+\n+  if (GET_CODE (operands[0]) == REG)\n+    regno = REGNO (operands[0]);\n+  else if (GET_CODE (operands[0]) == SUBREG)\n+    regno = REGNO (SUBREG_REG (operands[0])) + SUBREG_WORD (operands[0]);\n+  else if (GET_CODE (operands[0]) == MEM)\n+    regno = -1;\n+\n+  if (regno == -1\n+      || ! refers_to_regno_p (regno, regno + 1, operands[1], 0))\n     {\n       operands[2] = operand_subword (operands[0], 0, 0, DImode);\n       operands[3] = operand_subword (operands[1], 0, 0, DImode);\n@@ -1225,29 +1229,34 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"move,load,store\")])\n \n-;; If the output is a register and the input is memory, we have to be careful\n-;; and see which word needs to be loaded first.\n+;; If the output is a register and the input is memory or a register, we have\n+;; to be careful and see which word needs to be loaded first.  \n \n (define_split\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n \t(match_operand:DF 1 \"general_movsrc_operand\" \"\"))]\n-  \"! (GET_CODE (operands[0]) == REG\n-     && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n-   && ! (GET_CODE (operands[1]) == REG\n-         && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n-   && ! (GET_CODE (operands[0]) == REG && GET_CODE (operands[1]) == REG\n-\t && ! reload_completed\n-\t && reg_overlap_mentioned_p (operands[0], operands[1]))\n-   && ! (GET_CODE (operands[0]) == MEM\n-\t && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-   && ! (GET_CODE (operands[1]) == MEM\n-\t && GET_CODE (XEXP (operands[1], 0)) == POST_INC)\"\n+  \"reload_completed\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 4) (match_dup 5))]\n   \"\n-{ if (GET_CODE (operands[0]) != REG\n-      || ! refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t      operands[1], 0))\n+{\n+  int regno;\n+\n+  if ((GET_CODE (operands[0]) == MEM\n+       && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+      || (GET_CODE (operands[1]) == MEM\n+\t  && GET_CODE (XEXP (operands[1], 0)) == POST_INC))\n+    FAIL;\n+\n+  if (GET_CODE (operands[0]) == REG)\n+    regno = REGNO (operands[0]);\n+  else if (GET_CODE (operands[0]) == SUBREG)\n+    regno = REGNO (SUBREG_REG (operands[0])) + SUBREG_WORD (operands[0]);\n+  else if (GET_CODE (operands[0]) == MEM)\n+    regno = -1;\n+\n+  if (regno == -1\n+      || ! refers_to_regno_p (regno, regno + 1, operands[1], 0))\n     {\n       operands[2] = operand_subword (operands[0], 0, 0, DFmode);\n       operands[3] = operand_subword (operands[1], 0, 0, DFmode);"}]}