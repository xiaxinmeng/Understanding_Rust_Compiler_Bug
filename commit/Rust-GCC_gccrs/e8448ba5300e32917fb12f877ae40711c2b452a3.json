{"sha": "e8448ba5300e32917fb12f877ae40711c2b452a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg0NDhiYTUzMDBlMzI5MTdmYjEyZjg3N2FlNDA3MTFjMmI0NTJhMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-09T17:58:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-09T17:58:59Z"}, "message": "Make note_stores take an rtx_insn\n\nI have a series of patches that (as a side effect) makes all rtl\npasses use the information collected by -fipa-ra.  This showed up a\nlatent bug in the liveness tracking in regrename.c, which doesn't take\nCALL_INSN_FUNCTION_USAGE into account when processing clobbers.\n\nThis actually seems to be quite a common problem with passes that use\nnote_stores; only a handful remember to walk CALL_INSN_FUNCTION_USAGE\ntoo.  I think it was just luck that I saw it with regrename first.\n\nThis patch tries to make things more robust by passing an insn rather\nthan a pattern to note_stores.  The old function is still available\nas note_pattern_stores for the few places that need it.\n\nWhen updating callers, I've erred on the side of using note_stores\nrather than note_pattern_stores, because IMO note_stores should be\nthe default choice and we should only use note_pattern_stores if\nthere's a specific reason.  Specifically:\n\n* For cselib.c, \"body\" may be a COND_EXEC_CODE instead of the main\n  insn pattern.\n\n* For ira.c, I wasn't sure whether extending no_equiv to\n  CALL_INSN_FUNCTION_USAGE really made sense, since we don't do that\n  for normal call-clobbered registers.  Same for mark_not_eliminable\n  in reload1.c\n\n* Some other places only have a pattern available, and since those\n  places wouldn't benefit from walking CALL_INSN_FUNCTION_USAGE,\n  it seemed better to alter the code as little as possible.\n\n* In the config/ changes, quite a few callers have already weeded\n  out CALL insns.  It still seemed better to use note_stores rather\n  than prematurely optimise.  (note_stores should tail call to\n  note_pattern_stores once it sees that the insn isn't a call.)\n\nThe patch also documents what SETs mean in CALL_INSN_FUNCTION_USAGE.\n\n2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* rtl.h (CALL_INSN_FUNCTION_USAGE): Document what SETs mean.\n\t(note_pattern_stores): Declare.\n\t(note_stores): Take an rtx_insn *.\n\t* rtlanal.c (set_of): Use note_pattern_stores instead of note_stores.\n\t(find_all_hard_reg_sets): Pass the insn rather than its pattern to\n\tnote_stores.  Remove explicit handling of CALL_INSN_FUNCTION_USAGE.\n\t(note_stores): Take an rtx_insn * as argument and process\n\tCALL_INSN_FUNCTION_USAGE.  Rename old function to...\n\t(note_pattern_stores): ...this.\n\t(find_first_parameter_load): Pass the insn rather than\n\tits pattern to note_stores.\n\t* alias.c (memory_modified_in_insn_p, init_alias_analysis): Likewise.\n\t* caller-save.c (setup_save_areas, save_call_clobbered_regs)\n\t(insert_one_insn): Likewise.\n\t* combine.c (combine_instructions): Likewise.\n\t(likely_spilled_retval_p): Likewise.\n\t(try_combine): Use note_pattern_stores instead of note_stores.\n\t(record_dead_and_set_regs): Pass the insn rather than its pattern\n\tto note_stores.\n\t(reg_dead_at_p): Likewise.\n\t* config/bfin/bfin.c (workaround_speculation): Likewise.\n\t* config/c6x/c6x.c (maybe_clobber_cond): Likewise.  Take an rtx_insn *\n\trather than an rtx.\n\t* config/frv/frv.c (frv_registers_update): Use note_pattern_stores\n\tinstead of note_stores.\n\t(frv_optimize_membar_local): Pass the insn rather than its pattern\n\tto note_stores.\n\t* config/gcn/gcn.c (gcn_md_reorg): Likewise.\n\t* config/i386/i386.c (ix86_avx_u128_mode_after): Likewise.\n\t* config/mips/mips.c (vr4130_true_reg_dependence_p): Likewise.\n\t(r10k_needs_protection_p, mips_sim_issue_insn): Likewise.\n\t(mips_reorg_process_insns): Likewise.\n\t* config/s390/s390.c (s390_regs_ever_clobbered): Likewise.\n\t* config/sh/sh.c (flow_dependent_p): Likewise.  Take rtx_insn *s\n\trather than rtxes.\n\t* cse.c (delete_trivially_dead_insns): Pass the insn rather than\n\tits pattern to note_stores.\n\t* cselib.c (cselib_record_sets): Use note_pattern_stores instead\n\tof note_stores.\n\t* dce.c (mark_nonreg_stores): Remove the \"body\" parameter and pass\n\tthe insn to note_stores.\n\t(prescan_insns_for_dce): Update call accordingly.\n\t* ddg.c (mem_write_insn_p): Pass the insn rather than its pattern\n\tto note_stores.\n\t* df-problems.c (can_move_insns_across): Likewise.\n\t* dse.c (emit_inc_dec_insn_before, replace_read): Likewise.\n\t* function.c (assign_parm_setup_reg): Likewise.\n\t* gcse-common.c (record_last_mem_set_info_common): Likewise.\n\t* gcse.c (load_killed_in_block_p, compute_hash_table_work): Likewise.\n\t(single_set_gcse): Likewise.\n\t* ira.c (validate_equiv_mem): Likewise.\n\t(update_equiv_regs): Use note_pattern_stores rather than note_stores\n\tfor no_equiv.\n\t* loop-doloop.c (doloop_optimize): Pass the insn rather than its\n\tpattern to note_stores.\n\t* loop-invariant.c (calculate_loop_reg_pressure): Likewise.\n\t* loop-iv.c (simplify_using_initial_values): Likewise.\n\t* mode-switching.c (optimize_mode_switching): Likewise.\n\t* optabs.c (emit_libcall_block_1): Likewise.\n\t(expand_atomic_compare_and_swap): Likewise.\n\t* postreload-gcse.c (load_killed_in_block_p): Likewise.\n\t(record_opr_changes): Likewise.  Remove explicit handling of\n\tCALL_INSN_FUNCTION_USAGE.\n\t* postreload.c (reload_combine, reload_cse_move2add): Likewise.\n\t* regcprop.c (kill_clobbered_values): Likewise.\n\t(copyprop_hardreg_forward_1): Pass the insn rather than its pattern\n\tto note_stores.\n\t* regrename.c (build_def_use): Likewise.\n\t* reload1.c (reload):  Use note_pattern_stores instead of note_stores\n\tfor mark_not_eliminable.\n\t(reload_as_needed): Pass the insn rather than its pattern\n\tto note_stores.\n\t(emit_output_reload_insns): Likewise.\n\t* resource.c (mark_target_live_regs): Likewise.\n\t* sched-deps.c (init_insn_reg_pressure_info): Likewise.\n\t* sched-rgn.c (sets_likely_spilled): Use note_pattern_stores\n\tinstead of note_stores.\n\t* shrink-wrap.c (try_shrink_wrapping): Pass the insn rather than\n\tits pattern to note_stores.\n\t* stack-ptr-mod.c (pass_stack_ptr_mod::execute): Likewise.\n\t* var-tracking.c (adjust_insn, add_with_sets): Likewise.\n\nFrom-SVN: r275527", "tree": {"sha": "4cc1aecf5c5fc575c2235d1a62a8de07c0e250ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cc1aecf5c5fc575c2235d1a62a8de07c0e250ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8448ba5300e32917fb12f877ae40711c2b452a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8448ba5300e32917fb12f877ae40711c2b452a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8448ba5300e32917fb12f877ae40711c2b452a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8448ba5300e32917fb12f877ae40711c2b452a3/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/504279ae0a0ce28ad37f820dcdb7f6557aabef7c"}], "stats": {"total": 366, "additions": 202, "deletions": 164}, "files": [{"sha": "338f4041dadf876edfa59f81eb4edfb6c2a24f94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -1,3 +1,87 @@\n+2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* rtl.h (CALL_INSN_FUNCTION_USAGE): Document what SETs mean.\n+\t(note_pattern_stores): Declare.\n+\t(note_stores): Take an rtx_insn *.\n+\t* rtlanal.c (set_of): Use note_pattern_stores instead of note_stores.\n+\t(find_all_hard_reg_sets): Pass the insn rather than its pattern to\n+\tnote_stores.  Remove explicit handling of CALL_INSN_FUNCTION_USAGE.\n+\t(note_stores): Take an rtx_insn * as argument and process\n+\tCALL_INSN_FUNCTION_USAGE.  Rename old function to...\n+\t(note_pattern_stores): ...this.\n+\t(find_first_parameter_load): Pass the insn rather than\n+\tits pattern to note_stores.\n+\t* alias.c (memory_modified_in_insn_p, init_alias_analysis): Likewise.\n+\t* caller-save.c (setup_save_areas, save_call_clobbered_regs)\n+\t(insert_one_insn): Likewise.\n+\t* combine.c (combine_instructions): Likewise.\n+\t(likely_spilled_retval_p): Likewise.\n+\t(try_combine): Use note_pattern_stores instead of note_stores.\n+\t(record_dead_and_set_regs): Pass the insn rather than its pattern\n+\tto note_stores.\n+\t(reg_dead_at_p): Likewise.\n+\t* config/bfin/bfin.c (workaround_speculation): Likewise.\n+\t* config/c6x/c6x.c (maybe_clobber_cond): Likewise.  Take an rtx_insn *\n+\trather than an rtx.\n+\t* config/frv/frv.c (frv_registers_update): Use note_pattern_stores\n+\tinstead of note_stores.\n+\t(frv_optimize_membar_local): Pass the insn rather than its pattern\n+\tto note_stores.\n+\t* config/gcn/gcn.c (gcn_md_reorg): Likewise.\n+\t* config/i386/i386.c (ix86_avx_u128_mode_after): Likewise.\n+\t* config/mips/mips.c (vr4130_true_reg_dependence_p): Likewise.\n+\t(r10k_needs_protection_p, mips_sim_issue_insn): Likewise.\n+\t(mips_reorg_process_insns): Likewise.\n+\t* config/s390/s390.c (s390_regs_ever_clobbered): Likewise.\n+\t* config/sh/sh.c (flow_dependent_p): Likewise.  Take rtx_insn *s\n+\trather than rtxes.\n+\t* cse.c (delete_trivially_dead_insns): Pass the insn rather than\n+\tits pattern to note_stores.\n+\t* cselib.c (cselib_record_sets): Use note_pattern_stores instead\n+\tof note_stores.\n+\t* dce.c (mark_nonreg_stores): Remove the \"body\" parameter and pass\n+\tthe insn to note_stores.\n+\t(prescan_insns_for_dce): Update call accordingly.\n+\t* ddg.c (mem_write_insn_p): Pass the insn rather than its pattern\n+\tto note_stores.\n+\t* df-problems.c (can_move_insns_across): Likewise.\n+\t* dse.c (emit_inc_dec_insn_before, replace_read): Likewise.\n+\t* function.c (assign_parm_setup_reg): Likewise.\n+\t* gcse-common.c (record_last_mem_set_info_common): Likewise.\n+\t* gcse.c (load_killed_in_block_p, compute_hash_table_work): Likewise.\n+\t(single_set_gcse): Likewise.\n+\t* ira.c (validate_equiv_mem): Likewise.\n+\t(update_equiv_regs): Use note_pattern_stores rather than note_stores\n+\tfor no_equiv.\n+\t* loop-doloop.c (doloop_optimize): Pass the insn rather than its\n+\tpattern to note_stores.\n+\t* loop-invariant.c (calculate_loop_reg_pressure): Likewise.\n+\t* loop-iv.c (simplify_using_initial_values): Likewise.\n+\t* mode-switching.c (optimize_mode_switching): Likewise.\n+\t* optabs.c (emit_libcall_block_1): Likewise.\n+\t(expand_atomic_compare_and_swap): Likewise.\n+\t* postreload-gcse.c (load_killed_in_block_p): Likewise.\n+\t(record_opr_changes): Likewise.  Remove explicit handling of\n+\tCALL_INSN_FUNCTION_USAGE.\n+\t* postreload.c (reload_combine, reload_cse_move2add): Likewise.\n+\t* regcprop.c (kill_clobbered_values): Likewise.\n+\t(copyprop_hardreg_forward_1): Pass the insn rather than its pattern\n+\tto note_stores.\n+\t* regrename.c (build_def_use): Likewise.\n+\t* reload1.c (reload):  Use note_pattern_stores instead of note_stores\n+\tfor mark_not_eliminable.\n+\t(reload_as_needed): Pass the insn rather than its pattern\n+\tto note_stores.\n+\t(emit_output_reload_insns): Likewise.\n+\t* resource.c (mark_target_live_regs): Likewise.\n+\t* sched-deps.c (init_insn_reg_pressure_info): Likewise.\n+\t* sched-rgn.c (sets_likely_spilled): Use note_pattern_stores\n+\tinstead of note_stores.\n+\t* shrink-wrap.c (try_shrink_wrapping): Pass the insn rather than\n+\tits pattern to note_stores.\n+\t* stack-ptr-mod.c (pass_stack_ptr_mod::execute): Likewise.\n+\t* var-tracking.c (adjust_insn, add_with_sets): Likewise.\n+\n 2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* hard-reg-set.h (HARD_REG_SET): Define using a typedef rather"}, {"sha": "0ed1cbe916483cdfa3b7e7f7b8cc2535163b2a69", "filename": "gcc/alias.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -3268,7 +3268,8 @@ memory_modified_in_insn_p (const_rtx mem, const_rtx insn)\n   if (CALL_P (insn))\n     return true;\n   memory_modified = false;\n-  note_stores (PATTERN (insn), memory_modified_1, CONST_CAST_RTX(mem));\n+  note_stores (as_a<const rtx_insn *> (insn), memory_modified_1,\n+\t       CONST_CAST_RTX(mem));\n   return memory_modified;\n }\n \n@@ -3396,7 +3397,7 @@ init_alias_analysis (void)\n \t\t      && find_reg_note (insn, REG_NOALIAS, NULL_RTX))\n \t\t    record_set (SET_DEST (PATTERN (insn)), NULL_RTX, NULL);\n \t\t  else\n-\t\t    note_stores (PATTERN (insn), record_set, NULL);\n+\t\t    note_stores (insn, record_set, NULL);\n \n \t\t  set = single_set (insn);\n "}, {"sha": "5edbcc9c2ee0c562b84d34ae5d19ee6a1254bf01", "filename": "gcc/caller-save.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -450,7 +450,7 @@ setup_save_areas (void)\n \t live during the call, but the subreg that is set\n \t isn't.  */\n       CLEAR_HARD_REG_SET (this_insn_sets);\n-      note_stores (PATTERN (insn), mark_set_regs, &this_insn_sets);\n+      note_stores (insn, mark_set_regs, &this_insn_sets);\n       /* Sibcalls are considered to set the return value.  */\n       if (SIBLING_CALL_P (insn) && crtl->return_rtx)\n \tmark_set_regs (crtl->return_rtx, NULL_RTX, &this_insn_sets);\n@@ -534,7 +534,7 @@ setup_save_areas (void)\n \t     live during the call, but the subreg that is set\n \t     isn't.  */\n \t  CLEAR_HARD_REG_SET (this_insn_sets);\n-\t  note_stores (PATTERN (insn), mark_set_regs, &this_insn_sets);\n+\t  note_stores (insn, mark_set_regs, &this_insn_sets);\n \t  /* Sibcalls are considered to set the return value,\n \t     compare df-scan.c:df_get_call_refs.  */\n \t  if (SIBLING_CALL_P (insn) && crtl->return_rtx)\n@@ -795,7 +795,7 @@ save_call_clobbered_regs (void)\n \t\t be live across the call, while the other is set\n \t\t afterwards.  */\n \t      CLEAR_HARD_REG_SET (this_insn_sets);\n-\t      note_stores (PATTERN (insn), mark_set_regs, &this_insn_sets);\n+\t      note_stores (insn, mark_set_regs, &this_insn_sets);\n \t      AND_COMPL_HARD_REG_SET (hard_regs_saved, this_insn_sets);\n \t    }\n \n@@ -849,7 +849,7 @@ save_call_clobbered_regs (void)\n \t\t multi-hard-reg pseudo; then the pseudo is considered live\n \t\t during the call, but the subreg that is set isn't.  */\n \t      CLEAR_HARD_REG_SET (this_insn_sets);\n-\t      note_stores (PATTERN (insn), mark_set_regs, &this_insn_sets);\n+\t      note_stores (insn, mark_set_regs, &this_insn_sets);\n \n \t      /* Compute which hard regs must be saved before this call.  */\n \t      AND_COMPL_HARD_REG_SET (hard_regs_to_save, call_fixed_reg_set);\n@@ -1414,8 +1414,7 @@ insert_one_insn (class insn_chain *chain, int before_p, int code, rtx pat)\n       /* Registers that are set in CHAIN->INSN live in the new insn.\n \t (Unless there is a REG_UNUSED note for them, but we don't\n \t  look for them here.) */\n-      note_stores (PATTERN (chain->insn), add_stored_regs,\n-\t\t   &new_chain->live_throughout);\n+      note_stores (chain->insn, add_stored_regs, &new_chain->live_throughout);\n       CLEAR_REG_SET (&new_chain->dead_or_set);\n       if (chain->insn == BB_END (BASIC_BLOCK_FOR_FN (cfun, chain->block)))\n \tBB_END (BASIC_BLOCK_FOR_FN (cfun, chain->block)) = new_chain->insn;"}, {"sha": "981e7b0ad9de309c31ab4b2baa9ee93b27d64fde", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -1224,8 +1224,7 @@ combine_instructions (rtx_insn *f, unsigned int nregs)\n             subst_low_luid = DF_INSN_LUID (insn);\n             subst_insn = insn;\n \n-\t    note_stores (PATTERN (insn), set_nonzero_bits_and_sign_copies,\n-\t\t         insn);\n+\t    note_stores (insn, set_nonzero_bits_and_sign_copies, insn);\n \t    record_dead_and_set_regs (insn);\n \n \t    if (AUTO_INC_DEC)\n@@ -2439,7 +2438,7 @@ likely_spilled_retval_p (rtx_insn *insn)\n   info.mask = mask;\n   for (p = PREV_INSN (use); info.mask && p != insn; p = PREV_INSN (p))\n     if (INSN_P (p))\n-      note_stores (PATTERN (p), likely_spilled_retval_1, &info);\n+      note_stores (p, likely_spilled_retval_1, &info);\n   mask = info.mask;\n \n   /* Check if any of the (probably) live return value registers is\n@@ -4741,8 +4740,8 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n        been made to this insn.  The order is important, because newi2pat\n        can affect nonzero_bits of newpat.  */\n     if (newi2pat)\n-      note_stores (newi2pat, set_nonzero_bits_and_sign_copies, NULL);\n-    note_stores (newpat, set_nonzero_bits_and_sign_copies, NULL);\n+      note_pattern_stores (newi2pat, set_nonzero_bits_and_sign_copies, NULL);\n+    note_pattern_stores (newpat, set_nonzero_bits_and_sign_copies, NULL);\n   }\n \n   if (undobuf.other_insn != NULL_RTX)\n@@ -13487,10 +13486,10 @@ record_dead_and_set_regs (rtx_insn *insn)\n \t the return value register is set at this LUID.  We could\n \t still replace a register with the return value from the\n \t wrong subroutine call!  */\n-      note_stores (PATTERN (insn), record_dead_and_set_regs_1, NULL_RTX);\n+      note_stores (insn, record_dead_and_set_regs_1, NULL_RTX);\n     }\n   else\n-    note_stores (PATTERN (insn), record_dead_and_set_regs_1, insn);\n+    note_stores (insn, record_dead_and_set_regs_1, insn);\n }\n \n /* If a SUBREG has the promoted bit set, it is in fact a property of the\n@@ -13904,7 +13903,7 @@ reg_dead_at_p (rtx reg, rtx_insn *insn)\n \t  if (find_regno_note (insn, REG_UNUSED, reg_dead_regno))\n \t    return 1;\n \n-\t  note_stores (PATTERN (insn), reg_dead_at_p_1, NULL);\n+\t  note_stores (insn, reg_dead_at_p_1, NULL);\n \t  if (reg_dead_flag)\n \t    return reg_dead_flag == 1 ? 1 : 0;\n "}, {"sha": "49f18b6f236a0a948bb2b2de7fc852a934aa8eb1", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -4419,7 +4419,7 @@ workaround_speculation (void)\n \t     we found earlier.  */\n \t  if (recog_memoized (insn) != CODE_FOR_compare_eq)\n \t    {\n-\t      note_stores (PATTERN (insn), note_np_check_stores, NULL);\n+\t      note_stores (insn, note_np_check_stores, NULL);\n \t      if (np_check_regno != -1)\n \t\t{\n \t\t  if (find_regno_note (insn, REG_INC, np_check_regno))"}, {"sha": "05b111e3fd89f49f37bbfcf69bb9e329f5631547", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -4308,7 +4308,7 @@ clobber_cond_1 (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data1)\n    only those jumps which are still in flight.  */\n \n static void\n-maybe_clobber_cond (rtx insn, int clock_var)\n+maybe_clobber_cond (rtx_insn *insn, int clock_var)\n {\n   int n, idx;\n   idx = ss.jump_cycle_index;\n@@ -4333,7 +4333,7 @@ maybe_clobber_cond (rtx insn, int clock_var)\n \t  continue;\n \t}\n \n-      note_stores (PATTERN (insn), clobber_cond_1, ss.jump_cond + idx);\n+      note_stores (insn, clobber_cond_1, ss.jump_cond + idx);\n       for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \tif (REG_NOTE_KIND (link) == REG_INC)\n \t  clobber_cond_1 (XEXP (link, 0), NULL_RTX, ss.jump_cond + idx);"}, {"sha": "6008e9a59ad5e8fda917cfa48c65187e097ed55d", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -7136,7 +7136,7 @@ frv_registers_update (rtx x)\n       flags |= frv_cond_flags (XEXP (x, 0));\n       x = XEXP (x, 1);\n     }\n-  note_stores (x, frv_registers_update_1, &flags);\n+  note_pattern_stores (x, frv_registers_update_1, &flags);\n }\n \n \n@@ -7770,8 +7770,7 @@ frv_optimize_membar_local (basic_block bb, struct frv_io *next_io,\n \t  /* Invalidate NEXT_IO's address if it depends on something that\n \t     is clobbered by INSN.  */\n \t  if (next_io->var_address)\n-\t    note_stores (PATTERN (insn), frv_io_check_address,\n-\t\t\t &next_io->var_address);\n+\t    note_stores (insn, frv_io_check_address, &next_io->var_address);\n \n \t  /* If the next membar is associated with a __builtin_read,\n \t     see if INSN reads from that address.  If it does, and if\n@@ -7814,7 +7813,7 @@ frv_optimize_membar_local (basic_block bb, struct frv_io *next_io,\n \t  if (volatile_refs_p (PATTERN (insn)))\n \t    CLEAR_HARD_REG_SET (used_regs);\n \t  else\n-\t    note_stores (PATTERN (insn), frv_io_handle_set, &used_regs);\n+\t    note_stores (insn, frv_io_handle_set, &used_regs);\n \n \t  note_uses (&PATTERN (insn), frv_io_handle_use, &used_regs);\n \t  break;"}, {"sha": "cdb1c6ed794a34045b079258bedd0b144dbbaec0", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -4345,7 +4345,7 @@ gcn_md_reorg (void)\n \t  HARD_REG_SET defs, uses;\n \t  CLEAR_HARD_REG_SET (defs);\n \t  CLEAR_HARD_REG_SET (uses);\n-\t  note_stores (PATTERN (insn), record_hard_reg_sets, &defs);\n+\t  note_stores (insn, record_hard_reg_sets, &defs);\n \t  note_uses (&PATTERN (insn), record_hard_reg_uses, &uses);\n \n \t  bool exec_lo_def_p = TEST_HARD_REG_BIT (defs, EXEC_LO_REG);\n@@ -4533,7 +4533,7 @@ gcn_md_reorg (void)\n       HARD_REG_SET ireads, iwrites;\n       CLEAR_HARD_REG_SET (ireads);\n       CLEAR_HARD_REG_SET (iwrites);\n-      note_stores (PATTERN (insn), record_hard_reg_sets, &iwrites);\n+      note_stores (insn, record_hard_reg_sets, &iwrites);\n       note_uses (&PATTERN (insn), record_hard_reg_uses, &ireads);\n \n       /* Scan recent previous instructions for dependencies not handled in"}, {"sha": "f6de6e9e1fd944daed30d67c8ca095dfbe5fb0dd", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -13635,7 +13635,7 @@ ix86_avx_u128_mode_after (int mode, rtx_insn *insn)\n   if (CALL_P (insn))\n     {\n       bool avx_upper_reg_found = false;\n-      note_stores (pat, ix86_check_avx_upper_stores, &avx_upper_reg_found);\n+      note_stores (insn, ix86_check_avx_upper_stores, &avx_upper_reg_found);\n \n       return avx_upper_reg_found ? AVX_U128_DIRTY : AVX_U128_CLEAN;\n     }"}, {"sha": "c5389d29750b5a269e76402acfc62d3c87107a25", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -14889,8 +14889,7 @@ vr4130_true_reg_dependence_p_1 (rtx x, const_rtx pat ATTRIBUTE_UNUSED,\n static bool\n vr4130_true_reg_dependence_p (rtx insn)\n {\n-  note_stores (PATTERN (vr4130_last_insn),\n-\t       vr4130_true_reg_dependence_p_1, &insn);\n+  note_stores (vr4130_last_insn, vr4130_true_reg_dependence_p_1, &insn);\n   return insn == 0;\n }\n \n@@ -17787,7 +17786,7 @@ r10k_needs_protection_p (rtx_insn *insn)\n \n   if (mips_r10k_cache_barrier == R10K_CACHE_BARRIER_STORE)\n     {\n-      note_stores (PATTERN (insn), r10k_needs_protection_p_store, &insn);\n+      note_stores (insn, r10k_needs_protection_p_store, &insn);\n       return insn == NULL_RTX;\n     }\n \n@@ -18296,7 +18295,7 @@ mips_sim_issue_insn (struct mips_sim *state, rtx_insn *insn)\n \t\t\t\t\t\t    state->insns_left);\n \n   mips_sim_insn = insn;\n-  note_stores (PATTERN (insn), mips_sim_record_set, state);\n+  note_stores (insn, mips_sim_record_set, state);\n }\n \n /* Simulate issuing a NOP in state STATE.  */\n@@ -19026,7 +19025,7 @@ mips_reorg_process_insns (void)\n \t\t\t     &uses);\n \t\t  HARD_REG_SET delay_sets;\n \t\t  CLEAR_HARD_REG_SET (delay_sets);\n-\t\t  note_stores (PATTERN (SEQ_END (insn)), record_hard_reg_sets,\n+\t\t  note_stores (SEQ_END (insn), record_hard_reg_sets,\n \t\t\t       &delay_sets);\n \n \t\t  rtx_insn *prev = prev_active_insn (insn);\n@@ -19036,8 +19035,7 @@ mips_reorg_process_insns (void)\n \t\t    {\n \t\t      HARD_REG_SET sets;\n \t\t      CLEAR_HARD_REG_SET (sets);\n-\t\t      note_stores (PATTERN (prev), record_hard_reg_sets,\n-\t\t\t\t   &sets);\n+\t\t      note_stores (prev, record_hard_reg_sets, &sets);\n \n \t\t      /* Re-order if safe.  */\n \t\t      if (!hard_reg_set_intersect_p (delay_sets, uses)"}, {"sha": "389fca8553b6fc5f609b458fbf25f3ca3fab3384", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -9474,7 +9474,7 @@ s390_regs_ever_clobbered (char regs_ever_clobbered[])\n \t\tcontinue;\n \t    }\n \n-\t  note_stores (pat,\n+\t  note_stores (cur_insn,\n \t\t       s390_reg_clobbered_rtx,\n \t\t       regs_ever_clobbered);\n \t}"}, {"sha": "04c56aa111b45a1046d899b99699cad386aad89a", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -249,7 +249,7 @@ static void sh_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\tHOST_WIDE_INT, tree);\n static void sh_file_start (void);\n static bool sh_assemble_integer (rtx, unsigned int, int);\n-static bool flow_dependent_p (rtx, rtx);\n+static bool flow_dependent_p (rtx_insn *, rtx_insn *);\n static void flow_dependent_p_1 (rtx, const_rtx, void *);\n static int shiftcosts (rtx);\n static int and_xor_ior_costs (rtx, int);\n@@ -9633,11 +9633,11 @@ sh_adjust_cost (rtx_insn *insn, int dep_type, rtx_insn *dep_insn, int cost,\n /* Check if INSN is flow-dependent on DEP_INSN.  Can also be used to check\n    if DEP_INSN is anti-flow dependent on INSN.  */\n static bool\n-flow_dependent_p (rtx insn, rtx dep_insn)\n+flow_dependent_p (rtx_insn *insn, rtx_insn *dep_insn)\n {\n   rtx tmp = PATTERN (insn);\n \n-  note_stores (PATTERN (dep_insn), flow_dependent_p_1, &tmp);\n+  note_stores (dep_insn, flow_dependent_p_1, &tmp);\n   return tmp == NULL_RTX;\n }\n "}, {"sha": "098671c035daef5ce87b4c9449dbad14d794a7dd", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -7158,7 +7158,7 @@ delete_trivially_dead_insns (rtx_insn *insns, int nreg)\n \telse if (INSN_P (insn))\n \t  {\n \t    count_reg_usage (insn, counts, NULL_RTX, 1);\n-\t    note_stores (PATTERN (insn), count_stores, counts + nreg * 2);\n+\t    note_stores (insn, count_stores, counts + nreg * 2);\n \t  }\n       /* If there can be debug insns, COUNTS are 3 consecutive arrays.\n \t First one counts how many times each pseudo is used outside"}, {"sha": "87b3d33f0617d9923d59ef0a2b69384c254bd7ca", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -2659,7 +2659,7 @@ cselib_record_sets (rtx_insn *insn)\n   /* Invalidate all locations written by this insn.  Note that the elts we\n      looked up in the previous loop aren't affected, just some of their\n      locations may go away.  */\n-  note_stores (body, cselib_invalidate_rtx_note_stores, NULL);\n+  note_pattern_stores (body, cselib_invalidate_rtx_note_stores, NULL);\n \n   for (i = n_sets_before_autoinc; i < n_sets; i++)\n     cselib_invalidate_rtx (sets[i].dest);"}, {"sha": "af22eb37f1b37b200c0b7e2bce5082ce817b8ce3", "filename": "gcc/dce.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -265,15 +265,15 @@ mark_nonreg_stores_2 (rtx dest, const_rtx pattern, void *data)\n }\n \n \n-/* Mark INSN if BODY stores to a non-register destination.  */\n+/* Mark INSN if it stores to a non-register destination.  */\n \n static void\n-mark_nonreg_stores (rtx body, rtx_insn *insn, bool fast)\n+mark_nonreg_stores (rtx_insn *insn, bool fast)\n {\n   if (fast)\n-    note_stores (body, mark_nonreg_stores_1, insn);\n+    note_stores (insn, mark_nonreg_stores_1, insn);\n   else\n-    note_stores (body, mark_nonreg_stores_2, insn);\n+    note_stores (insn, mark_nonreg_stores_2, insn);\n }\n \n \n@@ -691,7 +691,7 @@ prescan_insns_for_dce (bool fast)\n \t    if (arg_stores && bitmap_bit_p (arg_stores, INSN_UID (insn)))\n \t      continue;\n \t    if (deletable_insn_p (insn, fast, arg_stores))\n-\t      mark_nonreg_stores (PATTERN (insn), insn, fast);\n+\t      mark_nonreg_stores (insn, fast);\n \t    else\n \t      mark_insn (insn, fast);\n \t  }"}, {"sha": "68cba605b6a5585a37eccc35070a7c7982bfb949", "filename": "gcc/ddg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -84,7 +84,7 @@ static bool\n mem_write_insn_p (rtx_insn *insn)\n {\n   mem_ref_p = false;\n-  note_stores (PATTERN (insn), mark_mem_store, NULL);\n+  note_stores (insn, mark_mem_store, NULL);\n   return mem_ref_p;\n }\n "}, {"sha": "e8a45ae68950c75279a5a81172826320280b8480", "filename": "gcc/df-problems.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -4094,8 +4094,7 @@ can_move_insns_across (rtx_insn *from, rtx_insn *to,\n \t  if (volatile_insn_p (PATTERN (insn)))\n \t    return false;\n \t  memrefs_in_across |= find_memory (insn);\n-\t  note_stores (PATTERN (insn), find_memory_stores,\n-\t\t       &mem_sets_in_across);\n+\t  note_stores (insn, find_memory_stores, &mem_sets_in_across);\n \t  /* This is used just to find sets of the stack pointer.  */\n \t  memrefs_in_across |= mem_sets_in_across;\n \t  trapping_insns_in_across |= may_trap_p (PATTERN (insn));\n@@ -4174,7 +4173,7 @@ can_move_insns_across (rtx_insn *from, rtx_insn *to,\n \t    {\n \t      int mem_ref_flags = 0;\n \t      int mem_set_flags = 0;\n-\t      note_stores (PATTERN (insn), find_memory_stores, &mem_set_flags);\n+\t      note_stores (insn, find_memory_stores, &mem_set_flags);\n \t      mem_ref_flags = find_memory (insn);\n \t      /* Catch sets of the stack pointer.  */\n \t      mem_ref_flags |= mem_set_flags;"}, {"sha": "55b3cf1b0b3783a7db477a63028a69c0d8794f09", "filename": "gcc/dse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -822,7 +822,7 @@ emit_inc_dec_insn_before (rtx mem ATTRIBUTE_UNUSED,\n   for (cur = new_insn; cur; cur = NEXT_INSN (cur))\n     {\n       info.current = cur;\n-      note_stores (PATTERN (cur), note_add_store, &info);\n+      note_stores (cur, note_add_store, &info);\n     }\n \n   /* If a failure was flagged above, return 1 so that for_each_inc_dec will\n@@ -1979,7 +1979,7 @@ replace_read (store_info *store_info, insn_info_t store_insn,\n       bitmap regs_set = BITMAP_ALLOC (&reg_obstack);\n \n       for (this_insn = insns; this_insn != NULL_RTX; this_insn = NEXT_INSN (this_insn))\n-\tnote_stores (PATTERN (this_insn), look_for_hardregs, regs_set);\n+\tnote_stores (this_insn, look_for_hardregs, regs_set);\n \n       bitmap_and_into (regs_set, regs_live);\n       if (!bitmap_empty_p (regs_set))"}, {"sha": "33e3f3e910647df2f856135fd6519931c9880598", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -3227,8 +3227,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t  for (insn = insns; insn && moved; insn = NEXT_INSN (insn))\n \t    {\n \t      if (INSN_P (insn))\n-\t\tnote_stores (PATTERN (insn), record_hard_reg_sets,\n-\t\t\t     &hardregs);\n+\t\tnote_stores (insn, record_hard_reg_sets, &hardregs);\n \t      if (!hard_reg_set_empty_p (hardregs))\n \t\tmoved = false;\n \t    }"}, {"sha": "55148623f2ddfaa9102f7ac792c015315d6b437e", "filename": "gcc/gcse-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fgcse-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fgcse-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse-common.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -89,7 +89,7 @@ record_last_mem_set_info_common (rtx_insn *insn,\n       struct gcse_note_stores_info data;\n       data.insn = insn;\n       data.canon_mem_list = canon_modify_mem_list;\n-      note_stores (PATTERN (insn), canon_list_insert, (void*) &data);\n+      note_stores (insn, canon_list_insert, (void*) &data);\n     }\n }\n "}, {"sha": "9bde8619b7bba204900bd37de4e83b2c97d00f7f", "filename": "gcc/gcse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -1049,7 +1049,7 @@ load_killed_in_block_p (const_basic_block bb, int uid_limit, const_rtx x,\n \t note_stores to examine each hunk of memory that is modified.  */\n       mci.mem = x;\n       mci.conflict = false;\n-      note_stores (PATTERN (setter), mems_conflict_for_gcse_p, &mci);\n+      note_stores (setter, mems_conflict_for_gcse_p, &mci);\n       if (mci.conflict)\n \treturn 1;\n     }\n@@ -1537,7 +1537,7 @@ compute_hash_table_work (struct gcse_hash_table_d *table)\n \t\trecord_last_mem_set_info (insn);\n \t    }\n \n-\t  note_stores (PATTERN (insn), record_last_set_info, insn);\n+\t  note_stores (insn, record_last_set_info, insn);\n \t}\n \n       /* The next pass builds the hash table.  */\n@@ -2415,7 +2415,7 @@ single_set_gcse (rtx_insn *insn)\n \n   s.insn = insn;\n   s.nsets = 0;\n-  note_stores (pattern, record_set_data, &s);\n+  note_pattern_stores (pattern, record_set_data, &s);\n \n   /* Considered invariant insns have exactly one set.  */\n   gcc_assert (s.nsets == 1);"}, {"sha": "66f1fc1337a980aee9ea1f18e7f3dca217772ab7", "filename": "gcc/ira.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -3004,7 +3004,7 @@ validate_equiv_mem (rtx_insn *start, rtx reg, rtx memref)\n \t    return valid_none;\n \t}\n \n-      note_stores (PATTERN (insn), validate_equiv_mem_from_store, &info);\n+      note_stores (insn, validate_equiv_mem_from_store, &info);\n       if (info.equiv_mem_modified)\n \treturn valid_none;\n \n@@ -3447,7 +3447,7 @@ update_equiv_regs (void)\n \t  if (set == NULL_RTX\n \t      || side_effects_p (SET_SRC (set)))\n \t    {\n-\t      note_stores (PATTERN (insn), no_equiv, NULL);\n+\t      note_pattern_stores (PATTERN (insn), no_equiv, NULL);\n \t      continue;\n \t    }\n \t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n@@ -3458,7 +3458,7 @@ update_equiv_regs (void)\n \t\t{\n \t\t  rtx part = XVECEXP (PATTERN (insn), 0, i);\n \t\t  if (part != set)\n-\t\t    note_stores (part, no_equiv, NULL);\n+\t\t    note_pattern_stores (part, no_equiv, NULL);\n \t\t}\n \t    }\n \n@@ -3516,15 +3516,15 @@ update_equiv_regs (void)\n \t    {\n \t      /* This might be setting a SUBREG of a pseudo, a pseudo that is\n \t\t also set somewhere else to a constant.  */\n-\t      note_stores (set, no_equiv, NULL);\n+\t      note_pattern_stores (set, no_equiv, NULL);\n \t      continue;\n \t    }\n \n \t  /* Don't set reg mentioned in a paradoxical subreg\n \t     equivalent to a mem.  */\n \t  if (MEM_P (src) && reg_equiv[regno].pdx_subregs)\n \t    {\n-\t      note_stores (set, no_equiv, NULL);\n+\t      note_pattern_stores (set, no_equiv, NULL);\n \t      continue;\n \t    }\n "}, {"sha": "ccd020a2dbab47569161b6e8d22c0ea15e1a14de", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -731,7 +731,7 @@ doloop_optimize (class loop *loop)\n     bitmap modified = BITMAP_ALLOC (NULL);\n \n     for (rtx_insn *i = doloop_seq; i != NULL; i = NEXT_INSN (i))\n-      note_stores (PATTERN (i), record_reg_sets, modified);\n+      note_stores (i, record_reg_sets, modified);\n \n     basic_block loop_end = desc->out_edge->src;\n     bool fail = bitmap_intersect_p (df_get_live_out (loop_end), modified);"}, {"sha": "d54cca417374e427599e7ffaff3da97fdde91c06", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -2171,7 +2171,7 @@ calculate_loop_reg_pressure (void)\n \n \t  mark_ref_regs (PATTERN (insn));\n \t  n_regs_set = 0;\n-\t  note_stores (PATTERN (insn), mark_reg_clobber, NULL);\n+\t  note_stores (insn, mark_reg_clobber, NULL);\n \n \t  /* Mark any registers dead after INSN as dead now.  */\n \n@@ -2184,7 +2184,7 @@ calculate_loop_reg_pressure (void)\n \t     Clobbers are processed again, so they conflict with\n \t     the registers that are set.  */\n \n-\t  note_stores (PATTERN (insn), mark_reg_store, NULL);\n+\t  note_stores (insn, mark_reg_store, NULL);\n \n \t  if (AUTO_INC_DEC)\n \t    for (link = REG_NOTES (insn); link; link = XEXP (link, 1))"}, {"sha": "82b329f67a7c31f7479fbb1c68a6ebf0262dad62", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -1970,7 +1970,7 @@ simplify_using_initial_values (class loop *loop, enum rtx_code op, rtx *expr)\n \t    continue;\n \n \t  CLEAR_REG_SET (this_altered);\n-\t  note_stores (PATTERN (insn), mark_altered, this_altered);\n+\t  note_stores (insn, mark_altered, this_altered);\n \t  if (CALL_P (insn))\n \t    {\n \t      /* Kill all call clobbered registers.  */"}, {"sha": "eba750922f77f2f549a0986306237bf84c7c9a09", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -637,7 +637,7 @@ optimize_mode_switching (void)\n \t\t    if (REG_NOTE_KIND (link) == REG_DEAD)\n \t\t      reg_dies (XEXP (link, 0), &live_now);\n \n-\t\t  note_stores (PATTERN (insn), reg_becomes_live, &live_now);\n+\t\t  note_stores (insn, reg_becomes_live, &live_now);\n \t\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t\t    if (REG_NOTE_KIND (link) == REG_UNUSED)\n \t\t      reg_dies (XEXP (link, 0), &live_now);"}, {"sha": "35921e691f94e301f0461a8943435aad0be94bd8", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -3738,7 +3738,7 @@ emit_libcall_block_1 (rtx_insn *insns, rtx target, rtx result, rtx equiv,\n \t  data.first = insns;\n \t  data.insn = insn;\n \t  data.must_stay = 0;\n-\t  note_stores (PATTERN (insn), no_conflict_move_test, &data);\n+\t  note_stores (insn, no_conflict_move_test, &data);\n \t  if (! data.must_stay)\n \t    {\n \t      if (PREV_INSN (insn))\n@@ -6478,7 +6478,7 @@ expand_atomic_compare_and_swap (rtx *ptarget_bool, rtx *ptarget_oval,\n       /* Otherwise, work out if the compare-and-swap succeeded.  */\n       cc_reg = NULL_RTX;\n       if (have_insn_for (COMPARE, CCmode))\n-\tnote_stores (PATTERN (get_last_insn ()), find_cc_set, &cc_reg);\n+\tnote_stores (get_last_insn (), find_cc_set, &cc_reg);\n       if (cc_reg)\n \t{\n \t  target_bool = emit_store_flag_force (target_bool, EQ, cc_reg,"}, {"sha": "a7098387db227dcb44c57005c68383561fcf8ad0", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -658,7 +658,7 @@ load_killed_in_block_p (int uid_limit, rtx x, bool after_insn)\n \t It will set mems_conflict_p to nonzero if there may be a\n \t conflict between X and SETTER.  */\n       mems_conflict_p = 0;\n-      note_stores (PATTERN (setter), find_mem_conflicts, x);\n+      note_stores (setter, find_mem_conflicts, x);\n       if (mems_conflict_p)\n \treturn 1;\n \n@@ -760,7 +760,7 @@ record_opr_changes (rtx_insn *insn)\n   rtx note;\n \n   /* Find all stores and record them.  */\n-  note_stores (PATTERN (insn), record_last_set_info, insn);\n+  note_stores (insn, record_last_set_info, insn);\n \n   /* Also record autoincremented REGs for this insn as changed.  */\n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n@@ -771,25 +771,10 @@ record_opr_changes (rtx_insn *insn)\n   if (CALL_P (insn))\n     {\n       unsigned int regno;\n-      rtx link, x;\n       hard_reg_set_iterator hrsi;\n       EXECUTE_IF_SET_IN_HARD_REG_SET (regs_invalidated_by_call, 0, regno, hrsi)\n \trecord_last_reg_set_info_regno (insn, regno);\n \n-      for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n-\t{\n-\t  gcc_assert (GET_CODE (XEXP (link, 0)) != CLOBBER_HIGH);\n-\t  if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n-\t    {\n-\t      x = XEXP (XEXP (link, 0), 0);\n-\t      if (REG_P (x))\n-\t\t{\n-\t\t  gcc_assert (HARD_REGISTER_P (x));\n-\t\t  record_last_reg_set_info (insn, x);\n-\t\t}\n-\t    }\n-\t}\n-\n       if (! RTL_CONST_OR_PURE_CALL_P (insn))\n \trecord_last_mem_set_info (insn);\n     }"}, {"sha": "497a4b0e9f93688a085f5107a108a4ec8adf690d", "filename": "gcc/postreload.c", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -1325,7 +1325,7 @@ reload_combine (void)\n \t  || reload_combine_recognize_pattern (insn))\n \tcontinue;\n \n-      note_stores (PATTERN (insn), reload_combine_note_store, NULL);\n+      note_stores (insn, reload_combine_note_store, NULL);\n \n       if (CALL_P (insn))\n \t{\n@@ -1346,22 +1346,12 @@ reload_combine (void)\n \t    {\n \t      rtx setuse = XEXP (link, 0);\n \t      rtx usage_rtx = XEXP (setuse, 0);\n-\t      /* We could support CLOBBER_HIGH and treat it in the same way as\n-\t\t HARD_REGNO_CALL_PART_CLOBBERED, but no port needs that yet.  */\n-\t      gcc_assert (GET_CODE (setuse) != CLOBBER_HIGH);\n \n-\t      if ((GET_CODE (setuse) == USE || GET_CODE (setuse) == CLOBBER)\n-\t\t  && REG_P (usage_rtx))\n+\t      if (GET_CODE (setuse) == USE && REG_P (usage_rtx))\n \t        {\n \t\t  unsigned int end_regno = END_REGNO (usage_rtx);\n \t\t  for (unsigned int i = REGNO (usage_rtx); i < end_regno; ++i)\n-\t\t    if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n-\t\t      {\n-\t\t        reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n-\t\t        reg_state[i].store_ruid = reload_combine_ruid;\n-\t\t      }\n-\t\t    else\n-\t\t      reg_state[i].use_index = -1;\n+\t\t    reg_state[i].use_index = -1;\n \t         }\n \t     }\n \t}\n@@ -2104,7 +2094,7 @@ reload_cse_move2add (rtx_insn *first)\n \t\t}\n \t    }\n \t}\n-      note_stores (PATTERN (insn), move2add_note_store, insn);\n+      note_stores (insn, move2add_note_store, insn);\n \n       /* If INSN is a conditional branch, we try to extract an\n \t implicit set out of it.  */\n@@ -2134,32 +2124,12 @@ reload_cse_move2add (rtx_insn *first)\n \t unknown values.  */\n       if (CALL_P (insn))\n \t{\n-\t  rtx link;\n-\n \t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n \t    {\n \t      if (call_used_regs[i])\n \t\t/* Reset the information about this register.  */\n \t\treg_mode[i] = VOIDmode;\n \t    }\n-\n-\t  for (link = CALL_INSN_FUNCTION_USAGE (insn); link;\n-\t       link = XEXP (link, 1))\n-\t    {\n-\t      rtx setuse = XEXP (link, 0);\n-\t      rtx usage_rtx = XEXP (setuse, 0);\n-\t      /* CALL_INSN_FUNCTION_USAGEs can only have full clobbers, not\n-\t\t clobber_highs.  */\n-\t      gcc_assert (GET_CODE (setuse) != CLOBBER_HIGH);\n-\t      if (GET_CODE (setuse) == CLOBBER\n-\t\t  && REG_P (usage_rtx))\n-\t        {\n-\t\t  unsigned int end_regno = END_REGNO (usage_rtx);\n-\t\t  for (unsigned int r = REGNO (usage_rtx); r < end_regno; ++r)\n-\t\t    /* Reset the information about this register.  */\n-\t\t    reg_mode[r] = VOIDmode;\n-\t\t}\n-\t    }\n \t}\n     }\n   return changed;"}, {"sha": "4dc82a70545b3f15d784464a918803aa2ac6dec0", "filename": "gcc/regcprop.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -728,19 +728,7 @@ cprop_find_used_regs (rtx *loc, void *data)\n static void\n kill_clobbered_values (rtx_insn *insn, struct value_data *vd)\n {\n-  note_stores (PATTERN (insn), kill_clobbered_value, vd);\n-\n-  if (CALL_P (insn))\n-    {\n-      rtx exp;\n-\n-      for (exp = CALL_INSN_FUNCTION_USAGE (insn); exp; exp = XEXP (exp, 1))\n-\t{\n-\t  rtx x = XEXP (exp, 0);\n-\t  if (GET_CODE (x) == CLOBBER)\n-\t    kill_value (SET_DEST (x), vd);\n-\t}\n-    }\n+  note_stores (insn, kill_clobbered_value, vd);\n }\n \n /* Perform the forward copy propagation on basic block BB.  */\n@@ -1109,7 +1097,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n       if (!noop_p)\n \t{\n \t  /* Notice stores.  */\n-\t  note_stores (PATTERN (insn), kill_set_value, &ksvd);\n+\t  note_stores (insn, kill_set_value, &ksvd);\n \n \t  /* Notice copies.  */\n \t  if (copy_p)"}, {"sha": "580f29d4937b02c1a4407299e93e7516e073f383", "filename": "gcc/regrename.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -1741,7 +1741,7 @@ build_def_use (basic_block bb)\n \t     outside an operand, as live.  */\n \t  hide_operands (n_ops, old_operands, old_dups, untracked_operands,\n \t\t\t false);\n-\t  note_stores (PATTERN (insn), note_sets_clobbers, &clobber_code);\n+\t  note_stores (insn, note_sets_clobbers, &clobber_code);\n \t  restore_operands (insn, n_ops, old_operands, old_dups);\n \n \t  /* Step 1b: Begin new chains for earlyclobbered writes inside\n@@ -1857,7 +1857,7 @@ build_def_use (basic_block bb)\n \t     outside an operand, as live.  */\n \t  hide_operands (n_ops, old_operands, old_dups, untracked_operands,\n \t\t\t false);\n-\t  note_stores (PATTERN (insn), note_sets_clobbers, &set_code);\n+\t  note_stores (insn, note_sets_clobbers, &set_code);\n \t  restore_operands (insn, n_ops, old_operands, old_dups);\n \n \t  /* Step 6b: Begin new chains for writes inside operands.  */"}, {"sha": "e6069824d5efdb3e27fa722159e0f70aced42bc5", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -843,7 +843,7 @@ reload (rtx_insn *first, int global)\n      cannot be done.  */\n   for (insn = first; insn && num_eliminable; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n-      note_stores (PATTERN (insn), mark_not_eliminable, NULL);\n+      note_pattern_stores (PATTERN (insn), mark_not_eliminable, NULL);\n \n   maybe_fix_stack_asms ();\n \n@@ -4494,7 +4494,7 @@ reload_as_needed (int live_known)\n \t{\n \t  regset_head regs_to_forget;\n \t  INIT_REG_SET (&regs_to_forget);\n-\t  note_stores (PATTERN (insn), forget_old_reloads_1, &regs_to_forget);\n+\t  note_stores (insn, forget_old_reloads_1, &regs_to_forget);\n \n \t  /* If this is a USE and CLOBBER of a MEM, ensure that any\n \t     references to eliminable registers have been removed.  */\n@@ -4621,7 +4621,7 @@ reload_as_needed (int live_known)\n \t     between INSN and NEXT and use them to forget old reloads.  */\n \t  for (rtx_insn *x = NEXT_INSN (insn); x != old_next; x = NEXT_INSN (x))\n \t    if (NONJUMP_INSN_P (x) && GET_CODE (PATTERN (x)) == CLOBBER)\n-\t      note_stores (PATTERN (x), forget_old_reloads_1, NULL);\n+\t      note_stores (x, forget_old_reloads_1, NULL);\n \n #if AUTO_INC_DEC\n \t  /* Likewise for regs altered by auto-increment in this insn.\n@@ -7702,7 +7702,7 @@ emit_output_reload_insns (class insn_chain *chain, struct reload *rl,\n \t   clear any memory of reloaded copies of the pseudo reg.\n \t   If this output reload comes from a spill reg,\n \t   reg_has_output_reload will make this do nothing.  */\n-\tnote_stores (pat, forget_old_reloads_1, NULL);\n+\tnote_stores (p, forget_old_reloads_1, NULL);\n \n \tif (reg_mentioned_p (rl_reg_rtx, pat))\n \t  {"}, {"sha": "d4d86ce4179893356e59023a1dbcc9af5fefa763", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -1078,7 +1078,7 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n \t\t\t\t      GET_MODE (XEXP (link, 0)),\n \t\t\t\t      REGNO (XEXP (link, 0)));\n \n-\t      note_stores (PATTERN (real_insn), update_live_status, NULL);\n+\t      note_stores (real_insn, update_live_status, NULL);\n \n \t      /* If any registers were unused after this insn, kill them.\n \t\t These notes will always be accurate.  */"}, {"sha": "911b563a6dc5c749a4d7a392b728766cb707de9e", "filename": "gcc/rtl.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -1630,11 +1630,17 @@ extern const char * const reg_note_name[];\n #define GET_REG_NOTE_NAME(MODE) (reg_note_name[(int) (MODE)])\n \n /* This field is only present on CALL_INSNs.  It holds a chain of EXPR_LIST of\n-   USE and CLOBBER expressions.\n+   USE, CLOBBER and SET expressions.\n      USE expressions list the registers filled with arguments that\n    are passed to the function.\n      CLOBBER expressions document the registers explicitly clobbered\n    by this CALL_INSN.\n+     SET expressions say that the return value of the call (the SET_DEST)\n+   is equivalent to a value available before the call (the SET_SRC).\n+   This kind of SET is used when the return value is predictable in\n+   advance.  It is purely an optimisation hint; unlike USEs and CLOBBERs,\n+   it does not affect register liveness.\n+\n      Pseudo registers cannot be mentioned in this list.  */\n #define CALL_INSN_FUNCTION_USAGE(INSN)\tXEXP(INSN, 7)\n \n@@ -3442,7 +3448,10 @@ extern void record_hard_reg_sets (rtx, const_rtx, void *);\n extern void record_hard_reg_uses (rtx *, void *);\n extern void find_all_hard_regs (const_rtx, HARD_REG_SET *);\n extern void find_all_hard_reg_sets (const rtx_insn *, HARD_REG_SET *, bool);\n-extern void note_stores (const_rtx, void (*) (rtx, const_rtx, void *), void *);\n+extern void note_pattern_stores (const_rtx,\n+\t\t\t\t void (*) (rtx, const_rtx, void *), void *);\n+extern void note_stores (const rtx_insn *,\n+\t\t\t void (*) (rtx, const_rtx, void *), void *);\n extern void note_uses (rtx *, void (*) (rtx *, void *), void *);\n extern int dead_or_set_p (const rtx_insn *, const_rtx);\n extern int dead_or_set_regno_p (const rtx_insn *, unsigned int);"}, {"sha": "15185b7ad7e9d6d0944e45dbe9bbfffc1939addc", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -1440,7 +1440,7 @@ set_of (const_rtx pat, const_rtx insn)\n   struct set_of_data data;\n   data.found = NULL_RTX;\n   data.pat = pat;\n-  note_stores (INSN_P (insn) ? PATTERN (insn) : insn, set_of_1, &data);\n+  note_pattern_stores (INSN_P (insn) ? PATTERN (insn) : insn, set_of_1, &data);\n   return data.found;\n }\n \n@@ -1476,15 +1476,9 @@ find_all_hard_reg_sets (const rtx_insn *insn, HARD_REG_SET *pset, bool implicit)\n   rtx link;\n \n   CLEAR_HARD_REG_SET (*pset);\n-  note_stores (PATTERN (insn), record_hard_reg_sets, pset);\n-  if (CALL_P (insn))\n-    {\n-      if (implicit)\n-\tIOR_HARD_REG_SET (*pset, call_used_reg_set);\n-\n-      for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n-\trecord_hard_reg_sets (XEXP (link, 0), NULL, pset);\n-    }\n+  note_stores (insn, record_hard_reg_sets, pset);\n+  if (CALL_P (insn) && implicit)\n+    IOR_HARD_REG_SET (*pset, call_used_reg_set);\n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n     if (REG_NOTE_KIND (link) == REG_INC)\n       record_hard_reg_sets (XEXP (link, 0), NULL, pset);\n@@ -1899,7 +1893,8 @@ reg_overlap_mentioned_p (const_rtx x, const_rtx in)\n   the SUBREG will be passed.  */\n \n void\n-note_stores (const_rtx x, void (*fun) (rtx, const_rtx, void *), void *data)\n+note_pattern_stores (const_rtx x,\n+\t\t     void (*fun) (rtx, const_rtx, void *), void *data)\n {\n   int i;\n \n@@ -1933,7 +1928,22 @@ note_stores (const_rtx x, void (*fun) (rtx, const_rtx, void *), void *data)\n \n   else if (GET_CODE (x) == PARALLEL)\n     for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-      note_stores (XVECEXP (x, 0, i), fun, data);\n+      note_pattern_stores (XVECEXP (x, 0, i), fun, data);\n+}\n+\n+/* Same, but for an instruction.  If the instruction is a call, include\n+   any CLOBBERs in its CALL_INSN_FUNCTION_USAGE.  */\n+\n+void\n+note_stores (const rtx_insn *insn,\n+\t     void (*fun) (rtx, const_rtx, void *), void *data)\n+{\n+  if (CALL_P (insn))\n+    for (rtx link = CALL_INSN_FUNCTION_USAGE (insn);\n+\t link; link = XEXP (link, 1))\n+      if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n+\tnote_pattern_stores (XEXP (link, 0), fun, data);\n+  note_pattern_stores (PATTERN (insn), fun, data);\n }\n \f\n /* Like notes_stores, but call FUN for each expression that is being\n@@ -4140,7 +4150,7 @@ find_first_parameter_load (rtx_insn *call_insn, rtx_insn *boundary)\n       if (INSN_P (before))\n \t{\n \t  int nregs_old = parm.nregs;\n-\t  note_stores (PATTERN (before), parms_set, &parm);\n+\t  note_stores (before, parms_set, &parm);\n \t  /* If we found something that did not set a parameter reg,\n \t     we're done.  Do not keep going, as that might result\n \t     in hoisting an insn before the setting of a pseudo"}, {"sha": "dcc84d736408db373a95daa08241b7d16281b24a", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -2203,9 +2203,9 @@ init_insn_reg_pressure_info (rtx_insn *insn)\n       reg_pressure_info[cl].change = 0;\n     }\n \n-  note_stores (PATTERN (insn), mark_insn_reg_clobber, insn);\n+  note_stores (insn, mark_insn_reg_clobber, insn);\n \n-  note_stores (PATTERN (insn), mark_insn_reg_store, insn);\n+  note_stores (insn, mark_insn_reg_store, insn);\n \n   if (AUTO_INC_DEC)\n     for (link = REG_NOTES (insn); link; link = XEXP (link, 1))"}, {"sha": "3e0825075a34967f7fa495e2a486336f5c6fce36", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -2416,7 +2416,7 @@ static bool\n sets_likely_spilled (rtx pat)\n {\n   bool ret = false;\n-  note_stores (pat, sets_likely_spilled_1, &ret);\n+  note_pattern_stores (pat, sets_likely_spilled_1, &ret);\n   return ret;\n }\n "}, {"sha": "9ee712e589253041274d2016f934860f9ae7d467", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -689,7 +689,7 @@ try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)\n \tnote_uses (&PATTERN (insn), record_hard_reg_uses, &this_used);\n \tAND_COMPL_HARD_REG_SET (this_used, prologue_clobbered);\n \tIOR_HARD_REG_SET (prologue_used, this_used);\n-\tnote_stores (PATTERN (insn), record_hard_reg_sets, &prologue_clobbered);\n+\tnote_stores (insn, record_hard_reg_sets, &prologue_clobbered);\n       }\n   CLEAR_HARD_REG_BIT (prologue_clobbered, STACK_POINTER_REGNUM);\n   if (frame_pointer_needed)"}, {"sha": "5cb95e71261c0be3dfb3064647378175388583ce", "filename": "gcc/stack-ptr-mod.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fstack-ptr-mod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fstack-ptr-mod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstack-ptr-mod.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -91,9 +91,7 @@ pass_stack_ptr_mod::execute (function *fun)\n \t  if (INSN_P (insn))\n \t    {\n \t      /* Check if insn modifies the stack pointer.  */\n-\t      note_stores (PATTERN (insn),\n-\t\t\t   notice_stack_pointer_modification_1,\n-\t\t\t   NULL);\n+\t      note_stores (insn, notice_stack_pointer_modification_1, NULL);\n \t      if (! crtl->sp_is_unchanging)\n \t\treturn 0;\n \t    }"}, {"sha": "6c26b61dd1644990185fbf96ccb4e6cfc45f51af", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8448ba5300e32917fb12f877ae40711c2b452a3/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=e8448ba5300e32917fb12f877ae40711c2b452a3", "patch": "@@ -1239,7 +1239,7 @@ adjust_insn (basic_block bb, rtx_insn *insn)\n   amd.stack_adjust = -VTI (bb)->out.stack_adjust;\n \n   amd.store = true;\n-  note_stores (PATTERN (insn), adjust_mem_stores, &amd);\n+  note_stores (insn, adjust_mem_stores, &amd);\n \n   amd.store = false;\n   if (GET_CODE (PATTERN (insn)) == PARALLEL\n@@ -6632,7 +6632,7 @@ add_with_sets (rtx_insn *insn, struct cselib_set *sets, int n_sets)\n      insert notes before it without worrying about any\n      notes that MO_USEs might emit after the insn.  */\n   cui.store_p = true;\n-  note_stores (PATTERN (insn), add_stores, &cui);\n+  note_stores (insn, add_stores, &cui);\n   n2 = VTI (bb)->mos.length () - 1;\n   mos = VTI (bb)->mos.address ();\n "}]}