{"sha": "5e81d5beff4813ceaa0133f1b272a38df8e9115a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU4MWQ1YmVmZjQ4MTNjZWFhMDEzM2YxYjI3MmEzOGRmOGU5MTE1YQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2002-10-31T21:56:32Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-10-31T21:56:32Z"}, "message": "ZipFile.java (readLeShort): Take and use DataInput as argument.\n\n\t* java/util/zip/ZipFile.java (readLeShort): Take and use DataInput as\n\targument.\n\t(readLeShort): Likewise and use byte[].\n\t(readLeInt): Likewise.\n\t(readEntries): Use new versions of methods and use byte[] for reading\n\ta complete zip entry. Add ZipFile name to exceptions.\n\t(entries): Add ZipFile name to exceptions.\n\t(getEntry): Likewise.\n\t(checkLocalHeader): Use new versions of methods and add ZipFile name\n\tto exceptions.\n\nFrom-SVN: r58697", "tree": {"sha": "014ac9abd5a6aac2cfda79de11ea9dde56757788", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/014ac9abd5a6aac2cfda79de11ea9dde56757788"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e81d5beff4813ceaa0133f1b272a38df8e9115a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e81d5beff4813ceaa0133f1b272a38df8e9115a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e81d5beff4813ceaa0133f1b272a38df8e9115a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e81d5beff4813ceaa0133f1b272a38df8e9115a/comments", "author": null, "committer": null, "parents": [{"sha": "bab076f76ac1930fcec0f0b2e8a6f11b966d2d87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bab076f76ac1930fcec0f0b2e8a6f11b966d2d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bab076f76ac1930fcec0f0b2e8a6f11b966d2d87"}], "stats": {"total": 110, "additions": 71, "deletions": 39}, "files": [{"sha": "b5b0f3eeebedbce78b05e5e4ea324eae48e732c5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e81d5beff4813ceaa0133f1b272a38df8e9115a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e81d5beff4813ceaa0133f1b272a38df8e9115a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5e81d5beff4813ceaa0133f1b272a38df8e9115a", "patch": "@@ -1,3 +1,16 @@\n+2002-10-27  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/util/zip/ZipFile.java (readLeShort): Take and use DataInput as\n+\targument.\n+\t(readLeShort): Likewise and use byte[].\n+\t(readLeInt): Likewise.\n+\t(readEntries): Use new versions of methods and use byte[] for reading\n+\ta complete zip entry. Add ZipFile name to exceptions.\n+\t(entries): Add ZipFile name to exceptions.\n+\t(getEntry): Likewise.\n+\t(checkLocalHeader): Use new versions of methods and add ZipFile name\n+\tto exceptions.\n+\n 2002-10-31  Mark Anderson  <mark@panonet.net>\n \n \t* java/awt/GridBagLayout.java (setConstraints): New stubbed method"}, {"sha": "2eb1156d2bc9a80ddf64f0ef3529f2f9982c1b09", "filename": "libjava/java/util/zip/ZipFile.java", "status": "modified", "additions": 58, "deletions": 39, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e81d5beff4813ceaa0133f1b272a38df8e9115a/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e81d5beff4813ceaa0133f1b272a38df8e9115a/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java?ref=5e81d5beff4813ceaa0133f1b272a38df8e9115a", "patch": "@@ -1,5 +1,5 @@\n /* java.util.zip.ZipFile\n-   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -36,6 +36,10 @@\n exception statement from your version. */\n \n package java.util.zip;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.DataInput;\n+import java.io.DataInputStream;\n import java.io.File;\n import java.io.InputStream;\n import java.io.IOException;\n@@ -102,9 +106,9 @@ public ZipFile(File file) throws ZipException, IOException\n   /**\n    * Opens a Zip file reading the given File in the given mode.\n    *\n-   * If the OPEN_DELETE mode is specified, the zip file will be deleted at some time moment\n-   * after it is opened. It will be deleted before the zip file is closed or the Virtual Machine\n-   * exits.\n+   * If the OPEN_DELETE mode is specified, the zip file will be deleted at\n+   * some time moment after it is opened. It will be deleted before the zip\n+   * file is closed or the Virtual Machine exits.\n    * \n    * The contents of the zip file will be accessible until it is closed.\n    *\n@@ -121,7 +125,8 @@ public ZipFile(File file, int mode) throws ZipException, IOException\n   {\n     if ((mode & OPEN_DELETE) != 0)\n       {\n-\tthrow new IllegalArgumentException(\"OPEN_DELETE mode not supported yet in java.util.zip.ZipFile\");\n+\tthrow new IllegalArgumentException\n+\t  (\"OPEN_DELETE mode not supported yet in java.util.zip.ZipFile\");\n       }\n     this.raf = new RandomAccessFile(file, \"r\");\n     this.name = file.getName();\n@@ -133,17 +138,24 @@ public ZipFile(File file, int mode) throws ZipException, IOException\n    * @exception IOException if a i/o error occured.\n    * @exception EOFException if the file ends prematurely\n    */\n-  private final int readLeShort() throws IOException {\n-    return raf.readUnsignedByte() | raf.readUnsignedByte() << 8;\n+  private final int readLeShort(DataInput di) throws IOException\n+  {\n+    byte[] b = new byte[2];\n+    di.readFully(b);\n+    return (b[0] & 0xff) | (b[1] & 0xff) << 8;\n   }\n \n   /**\n    * Read an int in little endian byte order.\n    * @exception IOException if a i/o error occured.\n    * @exception EOFException if the file ends prematurely\n    */\n-  private final int readLeInt() throws IOException {\n-    return readLeShort() | readLeShort() << 16;\n+  private final int readLeInt(DataInput di) throws IOException\n+  {\n+    byte[] b = new byte[4];\n+    di.readFully(b);\n+    return ((b[0] & 0xff) | (b[1] & 0xff) << 8)\n+\t    | ((b[2] & 0xff) | (b[3] & 0xff) << 8) << 16;\n   }\n \n   /**\n@@ -164,36 +176,43 @@ private void readEntries() throws ZipException, IOException\n       {\n \tif (pos < 0)\n \t  throw new ZipException\n-\t    (\"central directory not found, probably not a zip file\");\n+\t    (\"central directory not found, probably not a zip file: \" + name);\n \traf.seek(pos--);\n       }\n-    while (readLeInt() != ENDSIG);\n+    while (readLeInt(raf) != ENDSIG);\n     if (raf.skipBytes(ENDTOT - ENDNRD) != ENDTOT - ENDNRD)\n-      throw new EOFException();\n-    int count = readLeShort();\n+      throw new EOFException(name);\n+    int count = readLeShort(raf);\n     if (raf.skipBytes(ENDOFF - ENDSIZ) != ENDOFF - ENDSIZ)\n-      throw new EOFException();\n-    int centralOffset = readLeInt();\n+      throw new EOFException(name);\n+    int centralOffset = readLeInt(raf);\n \n     entries = new ZipEntry[count];\n     raf.seek(centralOffset);\n+    byte[] ebs  = new byte[24];\n+    ByteArrayInputStream ebais = new ByteArrayInputStream(ebs);\n+    DataInputStream edip = new DataInputStream(ebais);\n     for (int i = 0; i < count; i++)\n       {\n-\tif (readLeInt() != CENSIG)\n-\t  throw new ZipException(\"Wrong Central Directory signature\");\n+\tif (readLeInt(raf) != CENSIG)\n+\t  throw new ZipException(\"Wrong Central Directory signature: \" + name);\n \tif (raf.skipBytes(CENHOW - CENVEM) != CENHOW - CENVEM)\n-\t  throw new EOFException();\n-\tint method = readLeShort();\n-\tint dostime = readLeInt();\n-\tint crc = readLeInt();\n-\tint csize = readLeInt();\n-\tint size = readLeInt();\n-\tint nameLen = readLeShort();\n-\tint extraLen = readLeShort();\n-\tint commentLen = readLeShort();\n+\t  throw new EOFException(name);\n+\n+\traf.readFully(ebs);\n+\tebais.reset();\n+\tint method = readLeShort(edip);\n+\tint dostime = readLeInt(edip);\n+\tint crc = readLeInt(edip);\n+\tint csize = readLeInt(edip);\n+\tint size = readLeInt(edip);\n+\tint nameLen = readLeShort(edip);\n+\tint extraLen = readLeShort(edip);\n+\tint commentLen = readLeShort(edip);\n+\n \tif (raf.skipBytes(CENOFF - CENDSK) != CENOFF - CENDSK)\n-\t  throw new EOFException();\n-\tint offset = readLeInt();\n+\t  throw new EOFException(name);\n+\tint offset = readLeInt(raf);\n \n \tbyte[] buffer = new byte[Math.max(nameLen, commentLen)];\n \n@@ -244,7 +263,7 @@ public void close() throws IOException\n   public Enumeration entries()\n   {\n     if (entries == null)\n-      throw new IllegalStateException(\"ZipFile has closed\");\n+      throw new IllegalStateException(\"ZipFile has closed: \" + name);\n     return new ZipEntryEnumeration(entries);\n   }\n \n@@ -265,7 +284,7 @@ private int getEntryIndex(String name)\n   public ZipEntry getEntry(String name)\n   {\n     if (entries == null)\n-      throw new IllegalStateException(\"ZipFile has closed\");\n+      throw new IllegalStateException(\"ZipFile has closed: \" + name);\n     int index = getEntryIndex(name);\n     return index >= 0 ? (ZipEntry) entries[index].clone() : null;\n   }\n@@ -283,24 +302,24 @@ private long checkLocalHeader(ZipEntry entry) throws IOException\n     synchronized (raf)\n       {\n \traf.seek(entry.offset);\n-\tif (readLeInt() != LOCSIG)\n-\t  throw new ZipException(\"Wrong Local header signature\");\n+\tif (readLeInt(raf) != LOCSIG)\n+\t  throw new ZipException(\"Wrong Local header signature: \" + name);\n \n \t/* skip version and flags */\n \tif (raf.skipBytes(LOCHOW - LOCVER) != LOCHOW - LOCVER)\n-\t  throw new EOFException();\n+\t  throw new EOFException(name);\n \n-\tif (entry.getMethod() != readLeShort())\n-\t  throw new ZipException(\"Compression method mismatch\");\n+\tif (entry.getMethod() != readLeShort(raf))\n+\t  throw new ZipException(\"Compression method mismatch: \" + name);\n \n \t/* Skip time, crc, size and csize */\n \tif (raf.skipBytes(LOCNAM - LOCTIM) != LOCNAM - LOCTIM)\n-\t  throw new EOFException();\n+\t  throw new EOFException(name);\n \n-\tif (entry.getName().length() != readLeShort())\n-\t  throw new ZipException(\"file name length mismatch\");\n+\tif (entry.getName().length() != readLeShort(raf))\n+\t  throw new ZipException(\"file name length mismatch: \" + name);\n \n-\tint extraLen = entry.getName().length() + readLeShort();\n+\tint extraLen = entry.getName().length() + readLeShort(raf);\n \treturn entry.offset + LOCHDR + extraLen;\n       }\n   }"}]}