{"sha": "b1efde2a0bef10502751bbb5f9caf96370424805", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFlZmRlMmEwYmVmMTA1MDI3NTFiYmI1ZjljYWY5NjM3MDQyNDgwNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-19T16:57:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-19T16:57:37Z"}, "message": "mn10300: Re-write move patterns.\n\nUse the \"D\" and \"A\" constraints, and the enabled attribute to\nunify all ofthe integer move patterns.  Delete the fake double\nword move patterns; let the middle-end generate subregs as required.\n\nUnfortunately, this somehow exposes a register pressure problem\nwith the udivmod pattern.  This is properly fixed with subsequent\npatches that expose the MDR register.\n\nIn the meantime it is highly desirable to to preserve bisect-ability\nof the patch series, so disable this pattern for AM30.\n\nFrom-SVN: r169004", "tree": {"sha": "88e45d5807f38f55aad1a69b0c8b7e995a33e83b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88e45d5807f38f55aad1a69b0c8b7e995a33e83b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1efde2a0bef10502751bbb5f9caf96370424805", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1efde2a0bef10502751bbb5f9caf96370424805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1efde2a0bef10502751bbb5f9caf96370424805", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1efde2a0bef10502751bbb5f9caf96370424805/comments", "author": null, "committer": null, "parents": [{"sha": "036c8f37959ccdafc6ea055ec109eb7cc3051697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036c8f37959ccdafc6ea055ec109eb7cc3051697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/036c8f37959ccdafc6ea055ec109eb7cc3051697"}], "stats": {"total": 952, "additions": 190, "deletions": 762}, "files": [{"sha": "46ebaee53f213040aa9680bf13248f5326152128", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1efde2a0bef10502751bbb5f9caf96370424805/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1efde2a0bef10502751bbb5f9caf96370424805/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1efde2a0bef10502751bbb5f9caf96370424805", "patch": "@@ -1,3 +1,20 @@\n+2011-01-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/mn10300/mn10300.md (*am33_movqi, *mn10300_movqi): Merge into\n+\t(*movqi_internal): ... here.\n+\t(*am33_movhi, *mn10300_movhi): Merge into...\n+\t(*movhi_internal): ... here.\n+\t(*movsi_internal): Use \"r\" instead of \"dax\" in constraints.  Use \"A\"\n+\tas the source/destination of moves from/to SP.\n+\t(movsf): Only allow for AM33-2.\n+\t(*movsf_internal): Use \"r\" instead of \"dax\"; use \"F\" instead of \n+\tany integer constant constraint.  Only allow for AM33-2.  Tidy\n+\tall of the alternative outputs.\n+\t(movdi, movdf, *am33_2_movdf, *mn10300_movdf): Remove.\n+\t(udivmodsi4): Delete expander and promote *udivmodsi4.  Disallow\n+\tfor MN103.\n+\t(udivsi3, umodsi3): New patterns for MN103 only.\n+\n 2011-01-19  Joern Rennecke  <amylaar@spamcop.net>\n \n \t* doc/tm.texi.in: Spell out that a lack of register class unions"}, {"sha": "9cddebf3e79d17a701dddc9fefba2db0b1987016", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 173, "deletions": 762, "changes": 935, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1efde2a0bef10502751bbb5f9caf96370424805/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1efde2a0bef10502751bbb5f9caf96370424805/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=b1efde2a0bef10502751bbb5f9caf96370424805", "patch": "@@ -188,107 +188,42 @@\n   [(set (match_operand:QI 0 \"nonimmediate_operand\")\n \t(match_operand:QI 1 \"general_operand\"))]\n   \"\"\n-  \"\n {\n   /* One of the ops has to be in a register.  */\n   if (!register_operand (operand0, QImode)\n       && !register_operand (operand1, QImode))\n-    operands[1] = copy_to_mode_reg (QImode, operand1);\n-}\")\n-\n-(define_insn \"*am33_movqi\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\"\n-\t\t\t  ;; 0       1      2      3     4       5\n-\t\t\t  \"=d*x*a*f, d*x*a, d*x*a, m,   *f,      d*x*a\")\n-\t(match_operand:QI 1 \"general_operand\"\n-\t\t\t   \"0,       d*xai, m,     d*xa, d*xa*f, *f\"))]\n-  \"TARGET_AM33\n-   && (register_operand (operands[0], QImode)\n-       || register_operand (operands[1], QImode))\"\n-  \"*\n-  {\n-    switch (which_alternative)\n-      {\n-      case 0:\n-        return \\\"nop\\\";\n-      case 1:\n-        gcc_assert (! CONST_DOUBLE_P (operands[1]));\n-\n-        if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n-\t    && CONST_INT_P (operands[1]))\n-\t  {\n-\t    HOST_WIDE_INT val = INTVAL (operands[1]);\n-\n-\t    if (((val & 0x80) && ! (val & 0xffffff00))\n-\t        || ((val & 0x800000) && ! (val & 0xff000000)))\n-\t      return \\\"movu %1,%0\\\";\n-\t  }\n-        return \\\"mov %1,%0\\\";\n-      case 2:\n-      case 3:\n-        return \\\"movbu %1,%0\\\";\n-      case 4:\n-      case 5:\n-        return \\\"fmov %1,%0\\\";\n-      default:\n-        gcc_unreachable ();\n-      }\n-  }\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 11) (const_int 22))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 47) (const_int 25))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 47) (const_int 25))\n-\t\t\t ])\n-  ]\n-)\n+    operands[1] = force_reg (QImode, operand1);\n+})\n \n-(define_insn \"*mn10300_movqi\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d*a,d,d,!*a,d*a,d,m\")\n-\t(match_operand:QI 1 \"general_operand\"       \"0,  I,i,i,  da, m,d\"))]\n-  \"register_operand (operands[0], QImode)\n-   || register_operand (operands[1], QImode)\"\n-  \"*\n+(define_insn \"*movqi_internal\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=*r,D*r,D*r,D,m\")\n+\t(match_operand:QI 1 \"general_operand\"      \"  0,D*r,  i,m,D\"))]\n+  \"(register_operand (operands[0], QImode)\n+    || register_operand (operands[1], QImode))\"\n {\n   switch (which_alternative)\n     {\n     case 0:\n-      return \\\"nop\\\";\n+      return \"\";\n     case 1:\n     case 2:\n+      return \"mov %1,%0\";\n     case 3:\n     case 4:\n-      gcc_assert (! CONST_DOUBLE_P (operands[1]));\n-      return \\\"mov %1,%0\\\";\n-    case 5:\n-    case 6:\n-      return \\\"movbu %1,%0\\\";\n+      return \"movbu %1,%0\";\n     default:\n       gcc_unreachable ();\n     }\n-}\"\n+}\n   [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (const_int 11)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 11) (const_int 22))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 11) (const_int 22))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 11) (const_int 22))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 13) (const_int 24))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 13) (const_int 24))\n-\t\t\t ])\n-  ]\n+\t [(const_int 11)\n+\t  (const_int 11)\n+\t  (const_int 11)\n+\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t(const_int 13) (const_int 24))\n+\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t(const_int 11) (const_int 22))\n+\t ])]\n )\n \n ;; movhi\n@@ -297,107 +232,52 @@\n   [(set (match_operand:HI 0 \"nonimmediate_operand\")\n \t(match_operand:HI 1 \"general_operand\"))]\n   \"\"\n-  \"\n {\n   /* One of the ops has to be in a register.  */\n   if (!register_operand (operand1, HImode)\n       && !register_operand (operand0, HImode))\n-    operands[1] = copy_to_mode_reg (HImode, operand1);\n-}\")\n-\n-(define_insn \"*am33_movhi\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\"\n-\t\t\t  ;; 0       1       2      3     4         5\n-\t\t\t  \"=d*x*a*f, d*x*a,  d*x*a, m,    *f,       d*x*a\")\n-\t(match_operand:HI 1 \"general_operand\"\n-\t\t\t  \"0,        d*x*ai, m,     d*x*a, d*x*a*f, *f\"))]\n-  \"TARGET_AM33\n-   && (register_operand (operands[0], HImode)\n-       || register_operand (operands[1], HImode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \\\"nop\\\";\n-    case 1:\n-      gcc_assert (! CONST_DOUBLE_P (operands[1]));\n-\n-      if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n-\t  && CONST_INT_P (operands[1]))\n-\t{\n-\t  HOST_WIDE_INT val = INTVAL (operands[1]);\n-\n-\t  if (((val & 0x80) && ! (val & 0xffffff00))\n-\t      || ((val & 0x800000) && ! (val & 0xff000000)))\n-\t    return \\\"movu %1,%0\\\";\n-\t}\n-      return \\\"mov %1,%0\\\";\n-    case 2:\n-    case 3:\n-      return \\\"movhu %1,%0\\\";\n-    case 4:\n-    case 5:\n-      return \\\"fmov %1,%0\\\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 11) (const_int 22))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 13) (const_int 24))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 13) (const_int 24))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 47) (const_int 25))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 47) (const_int 25))\n-\t\t\t ])\n-  ]\n-)\n+    operands[1] = force_reg (HImode, operand1);\n+})\n \n-(define_insn \"*mn10300_movhi\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d*a,d,d,!*a,d*a,d,m\")\n-\t(match_operand:HI 1 \"general_operand\"       \"0,  I,i,i,  da, m,d\"))]\n-  \"register_operand (operands[0], HImode)\n-   || register_operand (operands[1], HImode)\"\n-  \"*\n+(define_insn \"*movhi_internal\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=*r,D*r,D*r,D,m\")\n+\t(match_operand:HI 1 \"general_operand\"      \"  0,  i,D*r,m,D\"))]\n+  \"(register_operand (operands[0], HImode)\n+    || register_operand (operands[1], HImode))\"\n {\n   switch (which_alternative)\n     {\n     case 0:\n-      return \\\"nop\\\";\n+      return \"\";\n     case 1:\n+      /* Note that \"MOV imm8,An\" is already zero-extending, and is 2 bytes.\n+\t We have \"MOV imm16,Dn\" at 3 bytes.  The only win for the 4 byte\n+\t movu is for an 8-bit unsigned move into Rn.  */\n+      if (TARGET_AM33\n+\t  && CONST_INT_P (operands[1])\n+\t  && IN_RANGE (INTVAL (operands[1]), 0x80, 0xff)\n+\t  && REGNO_EXTENDED_P (REGNO (operands[0]), 1))\n+\treturn \"movu %1,%0\";\n+      /* FALLTHRU */\n     case 2:\n+      return \"mov %1,%0\";\n     case 3:\n     case 4:\n-      gcc_assert (! CONST_DOUBLE_P (operands[1]));\n-      return \\\"mov %1,%0\\\";\n-    case 5:\n-    case 6:\n-      return \\\"movhu %1,%0\\\";\n+      return \"movhu %1,%0\";\n     default:\n       gcc_unreachable ();\n     }\n-}\"\n+}\n   [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (const_int 11)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 11) (const_int 22))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 11) (const_int 22))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 11) (const_int 22))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 13) (const_int 24))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 13) (const_int 24))\n-\t\t\t ])\n-  ]\n+\t [(const_int 11)\n+\t  (const_int 11)\n+\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t  \t\t(const_int 11) (const_int 22))\n+\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t  \t\t(const_int 13) (const_int 24))\n+\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t  \t\t(const_int 11) (const_int 22))\n+\t ])]\n )\n \n ;; movsi and helpers\n@@ -457,12 +337,11 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\")\n \t(match_operand:SI 1 \"general_operand\"))]\n   \"\"\n-  \"\n {\n   /* One of the ops has to be in a register.  */\n   if (!register_operand (operand1, SImode)\n       && !register_operand (operand0, SImode))\n-    operands[1] = copy_to_mode_reg (SImode, operand1);\n+    operands[1] = force_reg (SImode, operand1);\n   if (flag_pic)\n     {\n       rtx temp;\n@@ -493,594 +372,123 @@\n \t\t\t\t      0, OPTAB_LIB_WIDEN);\n \t}\n     }\n-}\")\n+})\n \n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\t  \"=dax, dax,  m,   dax, ax,!*y\")\n+\t\t\t  \"=r,r,r,m,r, A,*y,*y\")\n \t(match_operand:SI 1 \"general_operand\"\n-\t\t\t  \"0,    Idax, dax, im, !*y, ax\"))\n-  ]\n+\t\t\t  \" 0,i,r,r,m,*y, A, i\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\"\n-  \"*\n-  {\n-    if (which_alternative == 0)\n-      return \\\"nop\\\";\n-\n-    gcc_assert (! CONST_DOUBLE_P (operands[1]));\n-\n-    if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n-        && CONST_INT_P (operands[1]))\n-      {\n-        HOST_WIDE_INT val = INTVAL (operands[1]);\n-\n-        if (((val & 0x80) && ! (val & 0xffffff00))\n-            || ((val & 0x800000) && ! (val & 0xff000000)))\n-          return \\\"movu %1, %0\\\";\n-      }\n-\n-    return \\\"mov %1, %0\\\";\n-  }\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t ])\n-  ]\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"\";\n+    case 1: /* imm-reg*/\n+      /* See movhi for a discussion of sizes for 8-bit movu.  Note that the\n+\t 24-bit movu is 6 bytes, which is the same size as the full 32-bit\n+\t mov form for An and Dn.  So again movu is only a win for Rn.  */\n+      if (TARGET_AM33\n+\t  && CONST_INT_P (operands[1])\n+\t  && REGNO_EXTENDED_P (REGNO (operands[0]), 1))\n+\t{\n+\t  HOST_WIDE_INT val = INTVAL (operands[1]);\n+\t  if (IN_RANGE (val, 0x80, 0xff)\n+\t      || IN_RANGE (val, 0x800000, 0xffffff))\n+\t    return \"movu %1,%0\";\n+\t}\n+      /* FALLTHRU */\n+    case 2:  /* reg-reg */\n+    case 3:  /* reg-mem */\n+    case 4:  /* mem-reg */\n+    case 5:  /* sp-reg */\n+    case 6:  /* reg-sp */\n+    case 7:  /* imm-sp */\n+      return \"mov %1,%0\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"isa\" \"*,*,*,*,*,*,*,am33\")\n+   (set_attr_alternative \"timings\"\n+\t [(const_int 11)\n+\t  (const_int 22)\n+\t  (const_int 11)\n+\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t(const_int 11) (const_int 22))\n+\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t(const_int 13) (const_int 24))\n+\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t(const_int 11) (const_int 22))\n+\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t(const_int 13) (const_int 24))\n+\t  (const_int 11)\n+\t ])]\n )\n \n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\")\n \t(match_operand:SF 1 \"general_operand\"))]\n-  \"\"\n-  \"\n+  \"TARGET_AM33_2\"\n {\n   /* One of the ops has to be in a register.  */\n   if (!register_operand (operand1, SFmode)\n       && !register_operand (operand0, SFmode))\n-    operands[1] = copy_to_mode_reg (SFmode, operand1);\n-}\")\n+    operands[1] = force_reg (SFmode, operand1);\n+})\n \n (define_insn \"*movsf_internal\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\"\n-\t\t\t  ;; 0    1    2       3     4     5\n-\t\t\t  \"=fdxa, dxa, f,      dxaQ, daxm, dax\")\n-\t(match_operand:SF 1 \"general_operand\"\n-\t\t\t  \" 0,    G,   fdxaQF, f,    dax,  daxFm\"))\n-  ]\n-  \"register_operand (operands[0], SFmode)\n-   || register_operand (operands[1], SFmode)\"\n-  \"*\n-  {\n-    switch (which_alternative)\n-      {\n-      case 0:\n-        return \\\"nop\\\";\n-      /* case 1: below.  */\n-      case 2:\n-      case 3:\n-        return \\\"fmov %1, %0\\\";\n-      case 1:\n-      case 4:\n-      case 5:\n-        if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n-\t    && CONST_INT_P (operands[1]))\n-\t  {\n-\t    HOST_WIDE_INT val = INTVAL (operands[1]);\n-\n-\t    if (((val & 0x80) && ! (val & 0xffffff00))\n-\t        || ((val & 0x800000) && ! (val & 0xff000000)))\n-\t      return \\\"movu %1, %0\\\";\n-\t  }\n-        return \\\"mov %1, %0\\\";\n-      default:\n-        gcc_unreachable ();\n-      }\n-  }\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 47) (const_int 25))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 47) (const_int 25))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t ])\n-  ]\n-)\n-\n-(define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\")\n-\t(match_operand:DI 1 \"general_operand\"))]\n-  \"\"\n-  \"\n-{\n-  /* One of the ops has to be in a register.  */\n-  if (!register_operand (operand1, DImode)\n-      && !register_operand (operand0, DImode))\n-    operands[1] = copy_to_mode_reg (DImode, operand1);\n-}\")\n-\n-\n-(define_insn \"*movdi_internal\"                   ;;   0 1  2  3 4   5   6  7 8  9\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=dx,ax,dx,a,dxm,dxm,a, a,dx,a\")\n-\t(match_operand:DI 1 \"general_operand\"        \"0,0, I, I,dx, a,  dx,a,im,im\"))]\n-  \"register_operand (operands[0], DImode)\n-   || register_operand (operands[1], DImode)\"\n-  \"*\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=rf,r,f,r,f,r,f,r,m,f,Q\")\n+\t(match_operand:SF 1 \"general_operand\"\t   \"  0,F,F,r,f,f,r,m,r,Q,f\"))]\n+  \"TARGET_AM33_2\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode))\"\n {\n-  long val[2];\n-  REAL_VALUE_TYPE rv;\n-\n   switch (which_alternative)\n     {\n-      case 0:\n-      case 1:\n-\treturn \\\"nop\\\";\n-\n-      case 2:\n-\treturn \\\"mov 0, %L0\\;mov 0, %H0\\\";\n-\n-      case 3:\n-\tif (rtx_equal_p (operands[0], operands[1]))\n-\t  return \\\"sub %L1,%L0\\;mov %L0,%H0\\\";\n-\telse\n-\t  return \\\"mov %1,%L0\\;mov %L0,%H0\\\";\n-      case 4:\n-      case 5:\n-      case 6:\n-      case 7:\n-      case 8:\n-      case 9:\n-\tif (CONST_INT_P (operands[1]))\n-\t  {\n-\t    rtx low, high;\n-\t    split_double (operands[1], &low, &high);\n-\t    val[0] = INTVAL (low);\n-\t    val[1] = INTVAL (high);\n-\t  }\n-\tif (CONST_DOUBLE_P (operands[1]))\n-\t  {\n-\t    if (GET_MODE (operands[1]) == DFmode)\n-\t      {\n-\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-\t\tREAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n-\t      }\n-\t    else if (GET_MODE (operands[1]) == VOIDmode\n-\t\t     || GET_MODE (operands[1]) == DImode)\n-\t      {\n-\t\tval[0] = CONST_DOUBLE_LOW (operands[1]);\n-\t\tval[1] = CONST_DOUBLE_HIGH (operands[1]);\n-\t      }\n-\t  }\n-\n-\tif (MEM_P (operands[1])\n-\t    && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))\n-\t  {\n-\t    rtx temp = operands[0];\n-\n-\t    while (GET_CODE (temp) == SUBREG)\n-\t      temp = SUBREG_REG (temp);\n-\n-\t    gcc_assert (REG_P (temp));\n-\n-\t    if (reg_overlap_mentioned_p (gen_rtx_REG (SImode, REGNO (temp)),\n-\t\t\t\t\t XEXP (operands[1], 0)))\n-\t      return \\\"mov %H1,%H0\\;mov %L1,%L0\\\";\n-\t    else\n-\t      return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n-\n-\t  }\n-\telse if (MEM_P (operands[1])\n-\t\t && CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\n-\t\t && REGNO_REG_CLASS (REGNO (operands[0])) == ADDRESS_REGS)\n-\t  {\n-\t    rtx xoperands[2];\n-\n-\t    xoperands[0] = operands[0];\n-\t    xoperands[1] = XEXP (operands[1], 0);\n-\n-\t    output_asm_insn (\\\"mov %1,%L0\\;mov (4,%L0),%H0\\;mov (%L0),%L0\\\",\n-\t\t\t     xoperands);\n-\t    return \\\"\\\";\n-\t  }\n-\telse\n-\t  {\n-\t    if ((CONST_INT_P (operands[1])\n-\t\t || CONST_DOUBLE_P (operands[1]))\n-\t\t&& val[0] == 0)\n-\t      {\n-\t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t\t  output_asm_insn (\\\"mov 0, %L0\\\", operands);\n-\t\telse\n-\t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n-\t      }\n-\t    else if ((CONST_INT_P (operands[1])\n-\t\t      || CONST_DOUBLE_P (operands[1]))\n-\t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n-\t\t\t == EXTENDED_REGS)\n-\t\t     && (((val[0] & 0x80) && ! (val[0] & 0xffffff00))\n-\t\t\t || ((val[0] & 0x800000) && ! (val[0] & 0xff000000))))\n-\t      output_asm_insn (\\\"movu %L1,%L0\\\", operands);\n-\t    else\n-\t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n-\n-\t    if ((CONST_INT_P (operands[1])\n-\t\t || CONST_DOUBLE_P (operands[1]))\n-\t\t&& val[1] == 0)\n-\t      {\n-\t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t\t  output_asm_insn (\\\"mov 0, %H0\\\", operands);\n-\t\telse\n-\t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n-\t      }\n-\t    else if ((CONST_INT_P (operands[1])\n-\t\t      || CONST_DOUBLE_P (operands[1]))\n-\t\t     && val[0] == val[1])\n-\t      output_asm_insn (\\\"mov %L0,%H0\\\", operands);\n-\t    else if ((CONST_INT_P (operands[1])\n-\t\t      || CONST_DOUBLE_P (operands[1]))\n-\t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n-\t\t\t == EXTENDED_REGS)\n-\t\t     && (((val[1] & 0x80) && ! (val[1] & 0xffffff00))\n-\t\t\t || ((val[1] & 0x800000) && ! (val[1] & 0xff000000))))\n-\t      output_asm_insn (\\\"movu %H1,%H0\\\", operands);\n-\t    else\n-\t      output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n-\t    return \\\"\\\";\n-\t  }\n-    default:\n-      gcc_unreachable ();\n-    }\n-  }\"\n-  ;; The timing of \"37\" is an approximation of the worst case sceanario.\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (const_int 11)\n-\t\t\t  (const_int 22)\n-\t\t\t  (const_int 22)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t ])\n-  ]\n-)\n-\n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\")\n-\t(match_operand:DF 1 \"general_operand\"))]\n-  \"\"\n-  \"\n-{\n-  /* One of the ops has to be in a register.  */\n-  if (!register_operand (operand1, DFmode)\n-      && !register_operand (operand0, DFmode))\n-    operands[1] = copy_to_mode_reg (DFmode, operand1);\n-}\")\n-\n-(define_insn \"*am33_2_movdf\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\t  ;; 0   1   2    3    4 5 6   7   8  9 10 11\n-\t\t\t  \"=fdax,dax,fdxa,f,   f,Q,dxm,dxm,a, a,dx,a\")\n-\t(match_operand:DF 1 \"general_operand\"\n-\t\t\t  \" 0,   G,  f,   dxaF,Q,f,dx, a,  dx,a,Fm,Fm\"))]\n-  \"TARGET_AM33_2\n-   && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode))\"\n-  \"*\n-  {\n-    long val[2];\n-    REAL_VALUE_TYPE rv;\n-\n-    switch (which_alternative)\n-      {\n-      case 0:\n-\treturn \\\"nop\\\";\n-\n-      case 1:\n-\treturn \\\"mov 0, %L0\\; mov 0, %H0\\\";\n-\n-      case 2:\n-      case 3:\n-        return \\\"fmov %L1, %L0\\; fmov %H1, %H0\\\";\n-\n-      case 4:\n-\tif (MEM_P (operands[1])\n-\t    && CONST_INT_P (XEXP (operands[1], 0))\n-\t    && (INTVAL (XEXP (operands[1], 0)) & 7) == 0)\n-\t  return \\\"fmov %D1, %D0\\\";\n-\telse\n-          return \\\"fmov %L1, %L0\\; fmov %H1, %H0\\\";\n-\n-      case 5:\n-\tif (MEM_P (operands[0])\n-\t    && CONST_INT_P (XEXP (operands[0], 0))\n-\t    && (INTVAL (XEXP (operands[0], 0)) & 7) == 0)\n-\t  return \\\"fmov %D1, %D0\\\";\n-\telse\n-          return \\\"fmov %L1, %L0\\; fmov %H1, %H0\\\";\n-\n-      case 6:\n-      case 7:\n-      case 8:\n-      case 9:\n-      case 10:\n-      case 11:\n-\tif (CONST_INT_P (operands[1]))\n-\t  {\n-\t    rtx low, high;\n-\t    split_double (operands[1], &low, &high);\n-\t    val[0] = INTVAL (low);\n-\t    val[1] = INTVAL (high);\n-\t  }\n-\tif (CONST_DOUBLE_P (operands[1]))\n-\t  {\n-\t    if (GET_MODE (operands[1]) == DFmode)\n-\t      {\n-\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-\t\tREAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n-\t      }\n-\t    else if (GET_MODE (operands[1]) == VOIDmode\n-\t\t     || GET_MODE (operands[1]) == DImode)\n-\t      {\n-\t\tval[0] = CONST_DOUBLE_LOW (operands[1]);\n-\t\tval[1] = CONST_DOUBLE_HIGH (operands[1]);\n-\t      }\n-\t  }\n-\n-\tif (MEM_P (operands[1])\n-\t    && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))\n-\t  {\n-\t    rtx temp = operands[0];\n-\n-\t    while (GET_CODE (temp) == SUBREG)\n-\t      temp = SUBREG_REG (temp);\n-\n-\t    gcc_assert (REG_P (temp));\n-\n-\t    if (reg_overlap_mentioned_p (gen_rtx_REG (SImode, REGNO (temp)),\n-\t\t\t\t\t XEXP (operands[1], 0)))\n-\t      return \\\"mov %H1, %H0\\; mov %L1, %L0\\\";\n-\t    else\n-\t      return \\\"mov %L1, %L0\\; mov %H1, %H0\\\";\n-\n-\t  }\n-\telse if (MEM_P (operands[1])\n-\t\t && CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\n-\t\t && REGNO_REG_CLASS (REGNO (operands[0])) == ADDRESS_REGS)\n-\t  {\n-\t    rtx xoperands[2];\n-\n-\t    xoperands[0] = operands[0];\n-\t    xoperands[1] = XEXP (operands[1], 0);\n-\n-\t    output_asm_insn (\\\"mov %1, %L0\\; mov (4, %L0), %H0\\; mov (%L0), %L0\\\",\n-\t\t\t     xoperands);\n-\t    return \\\"\\\";\n-\t  }\n-\telse\n-\t  {\n-\t    if ((CONST_INT_P (operands[1])\n-\t\t || CONST_DOUBLE_P (operands[1]))\n-\t\t&& val[0] == 0)\n-\t      {\n-\t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t\t  output_asm_insn (\\\"mov 0, %L0\\\", operands);\n-\t\telse\n-\t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n-\t      }\n-\t    else if ((CONST_INT_P (operands[1])\n-\t\t      || CONST_DOUBLE_P (operands[1]))\n-\t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n-\t\t\t == EXTENDED_REGS)\n-\t\t     && (((val[0] & 0x80) && ! (val[0] & 0xffffff00))\n-\t\t\t || ((val[0] & 0x800000) && ! (val[0] & 0xff000000))))\n-\t      output_asm_insn (\\\"movu %L1, %L0\\\", operands);\n-\t    else\n-\t      output_asm_insn (\\\"mov %L1, %L0\\\", operands);\n-\n-\t    if ((CONST_INT_P (operands[1])\n-\t\t || CONST_DOUBLE_P (operands[1]))\n-\t\t&& val[1] == 0)\n-\t      {\n-\t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t\t  output_asm_insn (\\\"mov 0, %H0\\\", operands);\n-\t\telse\n-\t\t  output_asm_insn (\\\"mov %H1, %H0\\\", operands);\n-\t      }\n-\t    else if ((CONST_INT_P (operands[1])\n-\t\t      || CONST_DOUBLE_P (operands[1]))\n-\t\t     && val[0] == val[1])\n-\t      output_asm_insn (\\\"mov %L0,%H0\\\", operands);\n-\t    else if ((CONST_INT_P (operands[1])\n-\t\t      || CONST_DOUBLE_P (operands[1]))\n-\t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n-\t\t\t == EXTENDED_REGS)\n-\t\t     && (((val[1] & 0x80) && ! (val[1] & 0xffffff00))\n-\t\t\t || ((val[1] & 0x800000) && ! (val[1] & 0xff000000))))\n-\t      output_asm_insn (\\\"movu %H1, %H0\\\", operands);\n-\t    else\n-\t      output_asm_insn (\\\"mov %H1, %H0\\\", operands);\n-\t    return \\\"\\\";\n-\t  }\n+    case 0:\n+      return \"\";\n+    case 1:\n+    case 3:\n+    case 7:\n+    case 8:\n+      return \"mov %1,%0\";\n+    case 2:\n+    case 4:\n+    case 5:\n+    case 6:\n+    case 9:\n+    case 10:\n+      return \"fmov %1,%0\";\n     default:\n       gcc_unreachable ();\n     }\n-  }\"\n-  ;; The timing of \"37\" is an approximation of the worst case sceanario.\n+}\n   [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (const_int 22)\n-\t\t\t  (const_int 22)\n-\t\t\t  (const_int 22)\n-\t\t\t  (const_int 22)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t ])\n-  ]\n+\t\t [(const_int 11)\n+\t\t  (const_int 22)\n+\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t(const_int 47) (const_int 25))\n+\t\t  (const_int 11)\n+\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t(const_int 13) (const_int 14))\n+\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t(const_int 13) (const_int 12))\n+\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t(const_int 13) (const_int 14))\n+\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t(const_int 13) (const_int 24))\n+\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t(const_int 13) (const_int 24))\n+\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t(const_int 13) (const_int 24))\n+\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t(const_int 13) (const_int 24))\n+\t\t ])]\n )\n \n-(define_insn \"*mn10300_movdf\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\t  ;;0    1    2    3    4   5  6   7\n-\t\t\t  \"=dxa, dax, dxm, dxm, a,  a, dx, a\")\n-\t(match_operand:DF 1 \"general_operand\"\n-\t\t\t  \" 0,   G,   dx,  a,   dx, a, Fm, Fm\"))]\n-  \"register_operand (operands[0], DFmode)\n-   || register_operand (operands[1], DFmode)\"\n-  \"*\n-  {\n-    long val[2];\n-    REAL_VALUE_TYPE rv;\n-\n-    switch (which_alternative)\n-      {\n-      case 0:\n-\treturn \\\"nop\\\";\n-\n-      case 1:\n-\treturn \\\"mov 0, %L0\\; mov 0, %H0\\\";\n-\n-      case 2:\n-      case 3:\n-      case 4:\n-      case 5:\n-      case 6:\n-      case 7:\n-\tif (CONST_INT_P (operands[1]))\n-\t  {\n-\t    rtx low, high;\n-\t    split_double (operands[1], &low, &high);\n-\t    val[0] = INTVAL (low);\n-\t    val[1] = INTVAL (high);\n-\t  }\n-        if (CONST_DOUBLE_P (operands[1]))\n-\t  {\n-\t    if (GET_MODE (operands[1]) == DFmode)\n-\t      {\n-\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-\t\tREAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n-\t      }\n-\t    else if (GET_MODE (operands[1]) == VOIDmode\n-\t\t     || GET_MODE (operands[1]) == DImode)\n-\t      {\n-\t\tval[0] = CONST_DOUBLE_LOW (operands[1]);\n-\t\tval[1] = CONST_DOUBLE_HIGH (operands[1]);\n-\t      }\n-\t  }\n-\n-\tif (MEM_P (operands[1])\n-\t    && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))\n-\t  {\n-\t    rtx temp = operands[0];\n-\n-\t    while (GET_CODE (temp) == SUBREG)\n-\t      temp = SUBREG_REG (temp);\n-\n-\t    gcc_assert (REG_P (temp));\n-\n-\t    if (reg_overlap_mentioned_p (gen_rtx_REG (SImode, REGNO (temp)),\n-\t\t\t\t\t XEXP (operands[1], 0)))\n-\t      return \\\"mov %H1, %H0\\; mov %L1, %L0\\\";\n-\t    else\n-\t      return \\\"mov %L1, %L0\\; mov %H1, %H0\\\";\n-\t  }\n-\telse if (MEM_P (operands[1])\n-\t\t && CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\n-\t\t && REGNO_REG_CLASS (REGNO (operands[0])) == ADDRESS_REGS)\n-\t  {\n-\t    rtx xoperands[2];\n-\n-\t    xoperands[0] = operands[0];\n-\t    xoperands[1] = XEXP (operands[1], 0);\n-\n-\t    output_asm_insn (\\\"mov %1, %L0\\; mov (4, %L0), %H0\\; mov (%L0), %L0\\\",\n-\t\t\t     xoperands);\n-\t    return \\\"\\\";\n-\t  }\n-\telse\n-\t  {\n-\t    if ((CONST_INT_P (operands[1])\n-\t\t || CONST_DOUBLE_P (operands[1]))\n-\t\t&& val[0] == 0)\n-\t      {\n-\t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t\t  output_asm_insn (\\\"mov 0, %L0\\\", operands);\n-\t\telse\n-\t\t  output_asm_insn (\\\"mov %L1, %L0\\\", operands);\n-\t      }\n-\t    else if ((CONST_INT_P (operands[1])\n-\t\t      || CONST_DOUBLE_P (operands[1]))\n-\t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n-\t\t\t == EXTENDED_REGS)\n-\t\t     && (((val[0] & 0x80) && ! (val[0] & 0xffffff00))\n-\t\t\t || ((val[0] & 0x800000) && ! (val[0] & 0xff000000))))\n-\t      output_asm_insn (\\\"movu %L1, %L0\\\", operands);\n-\t    else\n-\t      output_asm_insn (\\\"mov %L1, %L0\\\", operands);\n-\n-\t    if ((CONST_INT_P (operands[1])\n-\t\t || CONST_DOUBLE_P (operands[1]))\n-\t\t&& val[1] == 0)\n-\t      {\n-\t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t\t  output_asm_insn (\\\"mov 0, %H0\\\", operands);\n-\t\telse\n-\t\t  output_asm_insn (\\\"mov %H1, %H0\\\", operands);\n-\t      }\n-\t    else if ((CONST_INT_P (operands[1])\n-\t\t      || CONST_DOUBLE_P (operands[1]))\n-\t\t     && val[0] == val[1])\n-\t      output_asm_insn (\\\"mov %L0, %H0\\\", operands);\n-\t    else if ((CONST_INT_P (operands[1])\n-\t\t      || CONST_DOUBLE_P (operands[1]))\n-\t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n-\t\t\t == EXTENDED_REGS)\n-\t\t     && (((val[1] & 0x80) && ! (val[1] & 0xffffff00))\n-\t\t\t || ((val[1] & 0x800000) && ! (val[1] & 0xff000000))))\n-\t      output_asm_insn (\\\"movu %H1, %H0\\\", operands);\n-\t    else\n-\t      output_asm_insn (\\\"mov %H1, %H0\\\", operands);\n-\t    return \\\"\\\";\n-\t  }\n-    default:\n-      gcc_unreachable ();\n-    }\n-  }\"\n-  ;; Timings of \"37\" is approximation of the worst case sceanario.\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (const_int 22)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t  (const_int 37)\n-\t\t\t ])\n-  ]\n-)\n \f\n ;; ----------------------------------------------------------------------\n ;; ADD INSTRUCTIONS\n@@ -1394,42 +802,23 @@\n   \t      \t\t \t       (const_int 24) (const_int 23)))]\n )\n \n-(define_expand \"udivmodsi4\"\n-  [(parallel [(set (match_operand:SI          0 \"register_operand\")\n-\t\t   (udiv:SI (match_operand:SI 1 \"general_operand\")\n-\t\t\t    (match_operand:SI 2 \"general_operand\")))\n-\t      (set (match_operand:SI          3 \"register_operand\")\n-\t\t   (umod:SI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n-  \"\"\n-  \"{\n-    if (!register_operand (operands[1], SImode))\n-      operands[1] = copy_to_mode_reg (SImode, operands[1]);\n-    if (!register_operand (operands[2], SImode))\n-      operands[2] = copy_to_mode_reg (SImode, operands[2]);\n-   }\"\n-)\n-\n-(define_insn \"*udivmodsi4\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=dx\")\n+;; ??? This pattern causes too-high register pressure for MN103.\n+;; ??? To be fixed by exposing the MDR register properly.\n+(define_insn \"udivmodsi4\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=D\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"dx\")))\n+\t\t (match_operand:SI 2 \"register_operand\" \"D\")))\n    (set (match_operand:SI          3 \"register_operand\" \"=&d\")\n \t(umod:SI (match_dup 1) (match_dup 2)))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"\"\n-  \"*\n+   (clobber (reg:CC CC_REG))]\n+  \"TARGET_AM33\"\n {\n-  output_asm_insn (\\\"sub %3,%3\\;mov %3,mdr\\\", operands);\n-\n+  output_asm_insn (\"clr %3\\;ext %3\", operands);\n   if (find_reg_note (insn, REG_UNUSED, operands[3]))\n-    return \\\"divu %2,%0\\\";\n+    return \"divu %2,%0\";\n   else\n-    return \\\"divu %2,%0\\;mov mdr,%3\\\";\n-}\"\n+    return \"divu %2,%0\\;mov mdr,%3\";\n+}\n   ;; Timings:  AM33   AM34\n   ;;  SUB       1/1    1/1\n   ;;  MOV       1/1    1/1\n@@ -1441,6 +830,28 @@\n   \t      \t\t \t       (const_int 4546) (const_int 4142)))]\n )\n \n+;; ??? In the meantime MN103 can use these two patterns,\n+;; which reduce the register pressure by one.\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=&d\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n+   (clobber (reg:CC CC_REG))]\n+  \"!TARGET_AM33\"\n+  \"clr %0\\;ext %0\\;mov %1,%0\\;divu %2,%0\"\n+  [(set_attr \"timings\" \"4142\")]\n+)\n+\n+(define_insn \"umodsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=&d\")\n+\t(umod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n+   (clobber (reg:CC CC_REG))]\n+  \"!TARGET_AM33\"\n+  \"clr %0\\;ext %0\\;mov %1,%0\\;divu %2,%0\\;mov mdr,%0\"\n+  [(set_attr \"timings\" \"4142\")]\n+)\n+\n (define_insn \"divmodsi4\"\n   [(set (match_operand:SI          0 \"register_operand\" \"=dx\")\n \t(div:SI (match_operand:SI  1 \"register_operand\"  \"0\")"}]}