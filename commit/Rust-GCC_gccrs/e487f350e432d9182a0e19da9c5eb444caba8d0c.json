{"sha": "e487f350e432d9182a0e19da9c5eb444caba8d0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ4N2YzNTBlNDMyZDkxODJhMGUxOWRhOWM1ZWI0NDRjYWJhOGQwYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T12:51:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T12:51:37Z"}, "message": "Fix header.\n\nFrom-SVN: r161278", "tree": {"sha": "5bb0ab78c1d932adb2797f4e997690a303685b2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bb0ab78c1d932adb2797f4e997690a303685b2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e487f350e432d9182a0e19da9c5eb444caba8d0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e487f350e432d9182a0e19da9c5eb444caba8d0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e487f350e432d9182a0e19da9c5eb444caba8d0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e487f350e432d9182a0e19da9c5eb444caba8d0c/comments", "author": null, "committer": null, "parents": [{"sha": "6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5"}], "stats": {"total": 2932, "additions": 2854, "deletions": 78}, "files": [{"sha": "56f0a06a50fb2b655523170cb905f7ca1a5f2ef1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e487f350e432d9182a0e19da9c5eb444caba8d0c", "patch": "@@ -1,3 +1,30 @@\n+2010-06-23  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_attr.adb (Expand_Access_To_Protected_Op): When rewriting a\n+\treference to a protected subprogram outside of the protected's scope,\n+\tensure the corresponding external subprogram is frozen before the\n+\treference.\n+\n+2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb: Fix typo in error message.\n+\t* sem.adb: Refine previous change.\n+\n+2010-06-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* impunit.adb, a-suewen.adb, a-suewen.ads, a-suenco.adb, a-suenco.ads,\n+\ta-suezen.adb, a-suezen.ads, a-stuten.adb, a-stuten.ads, Makefile.rtl:\n+\tImplement Ada 2012 string encoding packages.\n+\n+2010-06-23  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* a-stwiun-shared.adb, a-stwiun-shared.ads, a-stzunb-shared.adb,\n+\ta-stzunb-shared.ads, a-swunau-shared.adb, a-swuwti-shared.adb,\n+\ta-szunau-shared.adb, a-szuzti-shared.adb, a-strunb-shared.adb,\n+\ta-strunb-shared.ads, a-stunau-shared.adb, a-suteio-shared.adb: New\n+\tfiles.\n+\t* gcc-interface/Makefile.in: Enable use of above files.\n+\n 2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch13.adb (Check_Constant_Address_Clauses): Do not check legality"}, {"sha": "f4083b59e935d6dac133fed1c2e1c4da593db61a", "filename": "gcc/ada/a-strunb-shared.adb", "status": "added", "additions": 2086, "deletions": 0, "changes": 2086, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-strunb-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-strunb-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strunb-shared.adb?ref=e487f350e432d9182a0e19da9c5eb444caba8d0c", "patch": "@@ -0,0 +1,2086 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 A D A . S T R I N G S . U N B O U N D E D                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Search;\n+with Ada.Unchecked_Deallocation;\n+\n+package body Ada.Strings.Unbounded is\n+\n+   use Ada.Strings.Maps;\n+\n+   Growth_Factor : constant := 32;\n+   --  The growth factor controls how much extra space is allocated when\n+   --  we have to increase the size of an allocated unbounded string. By\n+   --  allocating extra space, we avoid the need to reallocate on every\n+   --  append, particularly important when a string is built up by repeated\n+   --  append operations of small pieces. This is expressed as a factor so\n+   --  32 means add 1/32 of the length of the string as growth space.\n+\n+   Min_Mul_Alloc : constant := Standard'Maximum_Alignment;\n+   --  Allocation will be done by a multiple of Min_Mul_Alloc. This causes\n+   --  no memory loss as most (all?) malloc implementations are obliged to\n+   --  align the returned memory on the maximum alignment as malloc does not\n+   --  know the target alignment.\n+\n+   procedure Sync_Add_And_Fetch\n+     (Ptr   : access Interfaces.Unsigned_32;\n+      Value : Interfaces.Unsigned_32);\n+   pragma Import (Intrinsic, Sync_Add_And_Fetch, \"__sync_add_and_fetch_4\");\n+\n+   function Sync_Sub_And_Fetch\n+     (Ptr   : access Interfaces.Unsigned_32;\n+      Value : Interfaces.Unsigned_32) return Interfaces.Unsigned_32;\n+   pragma Import (Intrinsic, Sync_Sub_And_Fetch, \"__sync_sub_and_fetch_4\");\n+\n+   function Aligned_Max_Length (Max_Length : Natural) return Natural;\n+   --  Returns recommended length of the shared string which is greater or\n+   --  equal to specified length. Calculation take in sense alignment of the\n+   --  allocated memory segments to use memory effectively by Append/Insert/etc\n+   --  operations.\n+\n+   ---------\n+   -- \"&\" --\n+   ---------\n+\n+   function \"&\"\n+     (Left  : Unbounded_String;\n+      Right : Unbounded_String) return Unbounded_String\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+      RR : constant Shared_String_Access := Right.Reference;\n+      DL : constant Natural := LR.Last + RR.Last;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Left string is empty, return Rigth string\n+\n+      elsif LR.Last = 0 then\n+         Reference (RR);\n+         DR := RR;\n+\n+      --  Right string is empty, return Left string\n+\n+      elsif RR.Last = 0 then\n+         Reference (LR);\n+         DR := LR;\n+\n+      --  Overwise, allocate new shared string and fill data\n+\n+      else\n+         DR := Allocate (LR.Last + RR.Last);\n+         DR.Data (1 .. LR.Last) := LR.Data (1 .. LR.Last);\n+         DR.Data (LR.Last + 1 .. DL) := RR.Data (1 .. RR.Last);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Unbounded_String;\n+      Right : String) return Unbounded_String\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+      DL : constant Natural := LR.Last + Right'Length;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Right is an empty string, return Left string\n+\n+      elsif Right'Length = 0 then\n+         Reference (LR);\n+         DR := LR;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL);\n+         DR.Data (1 .. LR.Last) := LR.Data (1 .. LR.Last);\n+         DR.Data (LR.Last + 1 .. DL) := Right;\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : String;\n+      Right : Unbounded_String) return Unbounded_String\n+   is\n+      RR : constant Shared_String_Access := Right.Reference;\n+      DL : constant Natural := Left'Length + RR.Last;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Result is an empty string, reuse shared one\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Left is empty string, return Right string\n+\n+      elsif Left'Length = 0 then\n+         Reference (RR);\n+         DR := RR;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL);\n+         DR.Data (1 .. Left'Length) := Left;\n+         DR.Data (Left'Length + 1 .. DL) := RR.Data (1 .. RR.Last);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Unbounded_String;\n+      Right : Character) return Unbounded_String\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+      DL : constant Natural := LR.Last + 1;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      DR := Allocate (DL);\n+      DR.Data (1 .. LR.Last) := LR.Data (1 .. LR.Last);\n+      DR.Data (DL) := Right;\n+      DR.Last := DL;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Character;\n+      Right : Unbounded_String) return Unbounded_String\n+   is\n+      RR : constant Shared_String_Access := Right.Reference;\n+      DL : constant Natural := 1 + RR.Last;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      DR := Allocate (DL);\n+      DR.Data (1) := Left;\n+      DR.Data (2 .. DL) := RR.Data (1 .. RR.Last);\n+      DR.Last := DL;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Character) return Unbounded_String\n+   is\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string\n+\n+      if Left = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Left);\n+\n+         for J in 1 .. Left loop\n+            DR.Data (J) := Right;\n+         end loop;\n+\n+         DR.Last := Left;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : String) return Unbounded_String\n+   is\n+      DL : constant Natural := Left * Right'Length;\n+      DR : Shared_String_Access;\n+      K  : Positive;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL);\n+         K := 1;\n+\n+         for J in 1 .. Left loop\n+            DR.Data (K .. K + Right'Length - 1) := Right;\n+            K := K + Right'Length;\n+         end loop;\n+\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Unbounded_String) return Unbounded_String\n+   is\n+      RR : constant Shared_String_Access := Right.Reference;\n+      DL : constant Natural := Left * RR.Last;\n+      DR : Shared_String_Access;\n+      K  : Positive;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Coefficient is one, just return string itself\n+\n+      elsif Left = 1 then\n+         Reference (RR);\n+         DR := RR;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL);\n+         K := 1;\n+\n+         for J in 1 .. Left loop\n+            DR.Data (K .. K + RR.Last - 1) := RR.Data (1 .. RR.Last);\n+            K := K + RR.Last;\n+         end loop;\n+\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"*\";\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\"\n+     (Left  : Unbounded_String;\n+      Right : Unbounded_String) return Boolean\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+      RR : constant Shared_String_Access := Right.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) < RR.Data (1 .. RR.Last);\n+   end \"<\";\n+\n+   function \"<\"\n+     (Left  : Unbounded_String;\n+      Right : String) return Boolean\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) < Right;\n+   end \"<\";\n+\n+   function \"<\"\n+     (Left  : String;\n+      Right : Unbounded_String) return Boolean\n+   is\n+      RR : constant Shared_String_Access := Right.Reference;\n+   begin\n+      return Left < RR.Data (1 .. RR.Last);\n+   end \"<\";\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\"\n+     (Left  : Unbounded_String;\n+      Right : Unbounded_String) return Boolean\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+      RR : constant Shared_String_Access := Right.Reference;\n+\n+   begin\n+      --  LR = RR means two strings shares shared string, thus they are equal\n+\n+      return LR = RR or else LR.Data (1 .. LR.Last) <= RR.Data (1 .. RR.Last);\n+   end \"<=\";\n+\n+   function \"<=\"\n+     (Left  : Unbounded_String;\n+      Right : String) return Boolean\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) <= Right;\n+   end \"<=\";\n+\n+   function \"<=\"\n+     (Left  : String;\n+      Right : Unbounded_String) return Boolean\n+   is\n+      RR : constant Shared_String_Access := Right.Reference;\n+   begin\n+      return Left <= RR.Data (1 .. RR.Last);\n+   end \"<=\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\"\n+     (Left  : Unbounded_String;\n+      Right : Unbounded_String) return Boolean\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+      RR : constant Shared_String_Access := Right.Reference;\n+\n+   begin\n+      return LR = RR or else LR.Data (1 .. LR.Last) = RR.Data (1 .. RR.Last);\n+      --  LR = RR means two strings shares shared string, thus they are equal\n+   end \"=\";\n+\n+   function \"=\"\n+     (Left  : Unbounded_String;\n+      Right : String) return Boolean\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) = Right;\n+   end \"=\";\n+\n+   function \"=\"\n+     (Left  : String;\n+      Right : Unbounded_String) return Boolean\n+   is\n+      RR : constant Shared_String_Access := Right.Reference;\n+   begin\n+      return Left = RR.Data (1 .. RR.Last);\n+   end \"=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\"\n+     (Left  : Unbounded_String;\n+      Right : Unbounded_String) return Boolean\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+      RR : constant Shared_String_Access := Right.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) > RR.Data (1 .. RR.Last);\n+   end \">\";\n+\n+   function \">\"\n+     (Left  : Unbounded_String;\n+      Right : String) return Boolean\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) > Right;\n+   end \">\";\n+\n+   function \">\"\n+     (Left  : String;\n+      Right : Unbounded_String) return Boolean\n+   is\n+      RR : constant Shared_String_Access := Right.Reference;\n+   begin\n+      return Left > RR.Data (1 .. RR.Last);\n+   end \">\";\n+\n+   ----------\n+   -- \">=\" --\n+   ----------\n+\n+   function \">=\"\n+     (Left  : Unbounded_String;\n+      Right : Unbounded_String) return Boolean\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+      RR : constant Shared_String_Access := Right.Reference;\n+\n+   begin\n+      --  LR = RR means two strings shares shared string, thus they are equal\n+\n+      return LR = RR or else LR.Data (1 .. LR.Last) >= RR.Data (1 .. RR.Last);\n+   end \">=\";\n+\n+   function \">=\"\n+     (Left  : Unbounded_String;\n+      Right : String) return Boolean\n+   is\n+      LR : constant Shared_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) >= Right;\n+   end \">=\";\n+\n+   function \">=\"\n+     (Left  : String;\n+      Right : Unbounded_String) return Boolean\n+   is\n+      RR : constant Shared_String_Access := Right.Reference;\n+   begin\n+      return Left >= RR.Data (1 .. RR.Last);\n+   end \">=\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Object : in out Unbounded_String) is\n+   begin\n+      Reference (Object.Reference);\n+   end Adjust;\n+\n+   ------------------------\n+   -- Aligned_Max_Length --\n+   ------------------------\n+\n+   function Aligned_Max_Length (Max_Length : Natural) return Natural is\n+      Static_Size : constant Natural :=\n+                      Empty_Shared_String'Size / Standard'Storage_Unit;\n+      --  Total size of all static components\n+\n+   begin\n+      return\n+        ((Static_Size + Max_Length - 1) / Min_Mul_Alloc + 2) * Min_Mul_Alloc\n+           - Static_Size;\n+   end Aligned_Max_Length;\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   function Allocate (Max_Length : Natural) return Shared_String_Access is\n+   begin\n+      --  Empty string requested, return shared empty string\n+\n+      if Max_Length = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         return Empty_Shared_String'Access;\n+\n+      --  Otherwise, allocate requested space (and probably some more room)\n+\n+      else\n+         return new Shared_String (Aligned_Max_Length (Max_Length));\n+      end if;\n+   end Allocate;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append\n+     (Source   : in out Unbounded_String;\n+      New_Item : Unbounded_String)\n+   is\n+      SR  : constant Shared_String_Access := Source.Reference;\n+      NR  : constant Shared_String_Access := New_Item.Reference;\n+      DL  : constant Natural              := SR.Last + NR.Last;\n+      DR  : Shared_String_Access;\n+\n+   begin\n+      --  Source is an empty string, reuse New_Item data\n+\n+      if SR.Last = 0 then\n+         Reference (NR);\n+         Source.Reference := NR;\n+         Unreference (SR);\n+\n+      --  New_Item is empty string, nothing to do\n+\n+      elsif NR.Last = 0 then\n+         null;\n+\n+      --  Try to reuse existing shared string\n+\n+      elsif Can_Be_Reused (SR, DL) then\n+         SR.Data (SR.Last + 1 .. DL) := NR.Data (1 .. NR.Last);\n+         SR.Last := DL;\n+\n+      --  Otherwise, allocate new one and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+         DR.Data (SR.Last + 1 .. DL) := NR.Data (1 .. NR.Last);\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Append;\n+\n+   procedure Append\n+     (Source   : in out Unbounded_String;\n+      New_Item : String)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DL : constant Natural := SR.Last + New_Item'Length;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  New_Item is an empty string, nothing to do\n+\n+      if New_Item'Length = 0 then\n+         null;\n+\n+      --  Try to reuse existing shared string\n+\n+      elsif Can_Be_Reused (SR, DL) then\n+         SR.Data (SR.Last + 1 .. DL) := New_Item;\n+         SR.Last := DL;\n+\n+      --  Otherwise, allocate new one and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+         DR.Data (SR.Last + 1 .. DL) := New_Item;\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Append;\n+\n+   procedure Append\n+     (Source   : in out Unbounded_String;\n+      New_Item : Character)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DL : constant Natural := SR.Last + 1;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Try to reuse existing shared string\n+\n+      if Can_Be_Reused (SR, SR.Last + 1) then\n+         SR.Data (SR.Last + 1) := New_Item;\n+         SR.Last := SR.Last + 1;\n+\n+      --  Otherwise, allocate new one and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+         DR.Data (DL) := New_Item;\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Append;\n+\n+   -------------------\n+   -- Can_Be_Reused --\n+   -------------------\n+\n+   function Can_Be_Reused\n+     (Item   : Shared_String_Access;\n+      Length : Natural) return Boolean\n+   is\n+      use Interfaces;\n+   begin\n+      return\n+        Item.Counter = 1\n+          and then Item.Max_Length >= Length\n+          and then Item.Max_Length <=\n+                     Aligned_Max_Length (Length + Length / Growth_Factor);\n+   end Can_Be_Reused;\n+\n+   -----------\n+   -- Count --\n+   -----------\n+\n+   function Count\n+     (Source  : Unbounded_String;\n+      Pattern : String;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      return Search.Count (SR.Data (1 .. SR.Last), Pattern, Mapping);\n+   end Count;\n+\n+   function Count\n+     (Source  : Unbounded_String;\n+      Pattern : String;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      return Search.Count (SR.Data (1 .. SR.Last), Pattern, Mapping);\n+   end Count;\n+\n+   function Count\n+     (Source : Unbounded_String;\n+      Set    : Maps.Character_Set) return Natural\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      return Search.Count (SR.Data (1 .. SR.Last), Set);\n+   end Count;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   function Delete\n+     (Source  : Unbounded_String;\n+      From    : Positive;\n+      Through : Natural) return Unbounded_String\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Empty slice is deleted, use the same shared string\n+\n+      if From > Through then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Index is out of range\n+\n+      elsif Through > SR.Last then\n+         raise Index_Error;\n+\n+      --  Compute size of the result\n+\n+      else\n+         DL := SR.Last - (Through - From + 1);\n+\n+         --  Result is an empty string, reuse shared empty string\n+\n+         if DL = 0 then\n+            Reference (Empty_Shared_String'Access);\n+            DR := Empty_Shared_String'Access;\n+\n+         --  Otherwise, allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. From - 1) := SR.Data (1 .. From - 1);\n+            DR.Data (From .. DL) := SR.Data (Through + 1 .. SR.Last);\n+            DR.Last := DL;\n+         end if;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Delete;\n+\n+   procedure Delete\n+     (Source  : in out Unbounded_String;\n+      From    : Positive;\n+      Through : Natural)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Nothing changed, return\n+\n+      if From > Through then\n+         null;\n+\n+      --  Through is outside of the range\n+\n+      elsif Through > SR.Last then\n+         raise Index_Error;\n+\n+      else\n+         DL := SR.Last - (Through - From + 1);\n+\n+         --  Result is empty, reuse shared empty string\n+\n+         if DL = 0 then\n+            Reference (Empty_Shared_String'Access);\n+            Source.Reference := Empty_Shared_String'Access;\n+            Unreference (SR);\n+\n+         --  Try to reuse existing shared string\n+\n+         elsif Can_Be_Reused (SR, DL) then\n+            SR.Data (From .. DL) := SR.Data (Through + 1 .. SR.Last);\n+            SR.Last := DL;\n+\n+         --  Otherwise, allocate new shared string\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. From - 1) := SR.Data (1 .. From - 1);\n+            DR.Data (From .. DL) := SR.Data (Through + 1 .. SR.Last);\n+            DR.Last := DL;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+      end if;\n+   end Delete;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element\n+     (Source : Unbounded_String;\n+      Index  : Positive) return Character\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      if Index <= SR.Last then\n+         return SR.Data (Index);\n+      else\n+         raise Index_Error;\n+      end if;\n+   end Element;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Object : in out Unbounded_String) is\n+      SR : constant Shared_String_Access := Object.Reference;\n+\n+   begin\n+      if SR /= null then\n+\n+         --  The same controlled object can be finalized several times for\n+         --  some reason. As per 7.6.1(24) this should have no ill effect,\n+         --  so we need to add a guard for the case of finalizing the same\n+         --  object twice.\n+\n+         Object.Reference := null;\n+         Unreference (SR);\n+      end if;\n+   end Finalize;\n+\n+   ----------------\n+   -- Find_Token --\n+   ----------------\n+\n+   procedure Find_Token\n+     (Source : Unbounded_String;\n+      Set    : Maps.Character_Set;\n+      Test   : Strings.Membership;\n+      First  : out Positive;\n+      Last   : out Natural)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      Search.Find_Token (SR.Data (1 .. SR.Last), Set, Test, First, Last);\n+   end Find_Token;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out String_Access) is\n+      procedure Deallocate is\n+        new Ada.Unchecked_Deallocation (String, String_Access);\n+   begin\n+      Deallocate (X);\n+   end Free;\n+\n+   ----------\n+   -- Head --\n+   ----------\n+\n+   function Head\n+     (Source : Unbounded_String;\n+      Count  : Natural;\n+      Pad    : Character := Space) return Unbounded_String\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Result is empty, reuse shared empty string\n+\n+      if Count = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Length of the string is the same as requested, reuse source shared\n+      --  string.\n+\n+      elsif Count = SR.Last then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Count);\n+\n+         --  Length of the source string is more than requested, copy\n+         --  corresponding slice.\n+\n+         if Count < SR.Last then\n+            DR.Data (1 .. Count) := SR.Data (1 .. Count);\n+\n+         --  Length of the source string is less then requested, copy all\n+         --  contents and fill others by Pad character.\n+\n+         else\n+            DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+\n+            for J in SR.Last + 1 .. Count loop\n+               DR.Data (J) := Pad;\n+            end loop;\n+         end if;\n+\n+         DR.Last := Count;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Head;\n+\n+   procedure Head\n+     (Source : in out Unbounded_String;\n+      Count  : Natural;\n+      Pad    : Character := Space)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Result is empty, reuse empty shared string\n+\n+      if Count = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         Source.Reference := Empty_Shared_String'Access;\n+         Unreference (SR);\n+\n+      --  Result is same as source string, reuse source shared string\n+\n+      elsif Count = SR.Last then\n+         null;\n+\n+      --  Try to reuse existing shared string\n+\n+      elsif Can_Be_Reused (SR, Count) then\n+         if Count > SR.Last then\n+            for J in SR.Last + 1 .. Count loop\n+               SR.Data (J) := Pad;\n+            end loop;\n+         end if;\n+\n+         SR.Last := Count;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Count);\n+\n+         --  Length of the source string is greater then requested, copy\n+         --  corresponding slice.\n+\n+         if Count < SR.Last then\n+            DR.Data (1 .. Count) := SR.Data (1 .. Count);\n+\n+         --  Length of the source string is less the requested, copy all\n+         --  existing data and fill remaining positions with Pad characters.\n+\n+         else\n+            DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+\n+            for J in SR.Last + 1 .. Count loop\n+               DR.Data (J) := Pad;\n+            end loop;\n+         end if;\n+\n+         DR.Last := Count;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Head;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (Source  : Unbounded_String;\n+      Pattern : String;\n+      Going   : Strings.Direction := Strings.Forward;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      return Search.Index (SR.Data (1 .. SR.Last), Pattern, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_String;\n+      Pattern : String;\n+      Going   : Direction := Forward;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      return Search.Index (SR.Data (1 .. SR.Last), Pattern, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source : Unbounded_String;\n+      Set    : Maps.Character_Set;\n+      Test   : Strings.Membership := Strings.Inside;\n+      Going  : Strings.Direction  := Strings.Forward) return Natural\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      return Search.Index (SR.Data (1 .. SR.Last), Set, Test, Going);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_String;\n+      Pattern : String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      return Search.Index\n+        (SR.Data (1 .. SR.Last), Pattern, From, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_String;\n+      Pattern : String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      return Search.Index\n+        (SR.Data (1 .. SR.Last), Pattern, From, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_String;\n+      Set     : Maps.Character_Set;\n+      From    : Positive;\n+      Test    : Membership := Inside;\n+      Going   : Direction := Forward) return Natural\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      return Search.Index (SR.Data (1 .. SR.Last), Set, From, Test, Going);\n+   end Index;\n+\n+   ---------------------\n+   -- Index_Non_Blank --\n+   ---------------------\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_String;\n+      Going  : Strings.Direction := Strings.Forward) return Natural\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      return Search.Index_Non_Blank (SR.Data (1 .. SR.Last), Going);\n+   end Index_Non_Blank;\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_String;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+   begin\n+      return Search.Index_Non_Blank (SR.Data (1 .. SR.Last), From, Going);\n+   end Index_Non_Blank;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Object : in out Unbounded_String) is\n+   begin\n+      Reference (Object.Reference);\n+   end Initialize;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   function Insert\n+     (Source   : Unbounded_String;\n+      Before   : Positive;\n+      New_Item : String) return Unbounded_String\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DL : constant Natural := SR.Last + New_Item'Length;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Check index first\n+\n+      if Before > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      --  Result is empty, reuse empty shared string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Inserted string is empty, reuse source shared string\n+\n+      elsif New_Item'Length = 0 then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL + DL /Growth_Factor);\n+         DR.Data (1 .. Before - 1) := SR.Data (1 .. Before - 1);\n+         DR.Data (Before .. Before + New_Item'Length - 1) := New_Item;\n+         DR.Data (Before + New_Item'Length .. DL) :=\n+           SR.Data (Before .. SR.Last);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Insert;\n+\n+   procedure Insert\n+     (Source   : in out Unbounded_String;\n+      Before   : Positive;\n+      New_Item : String)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DL : constant Natural              := SR.Last + New_Item'Length;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Before > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      --  Result is empty string, reuse empty shared string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         Source.Reference := Empty_Shared_String'Access;\n+         Unreference (SR);\n+\n+      --  Inserted string is empty, nothing to do\n+\n+      elsif New_Item'Length = 0 then\n+         null;\n+\n+      --  Try to reuse existing shared string first\n+\n+      elsif Can_Be_Reused (SR, DL) then\n+         SR.Data (Before + New_Item'Length .. DL) :=\n+           SR.Data (Before .. SR.Last);\n+         SR.Data (Before .. Before + New_Item'Length - 1) := New_Item;\n+         SR.Last := DL;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. Before - 1) := SR.Data (1 .. Before - 1);\n+         DR.Data (Before .. Before + New_Item'Length - 1) := New_Item;\n+         DR.Data (Before + New_Item'Length .. DL) :=\n+           SR.Data (Before .. SR.Last);\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Insert;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Source : Unbounded_String) return Natural is\n+   begin\n+      return Source.Reference.Last;\n+   end Length;\n+\n+   ---------------\n+   -- Overwrite --\n+   ---------------\n+\n+   function Overwrite\n+     (Source   : Unbounded_String;\n+      Position : Positive;\n+      New_Item : String) return Unbounded_String\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Position > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      DL := Integer'Max (SR.Last, Position + New_Item'Length - 1);\n+\n+      --  Result is empty string, reuse empty shared string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Result is same as source string, reuse source shared string\n+\n+      elsif New_Item'Length = 0 then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL);\n+         DR.Data (1 .. Position - 1) := SR.Data (1 .. Position - 1);\n+         DR.Data (Position .. Position + New_Item'Length - 1) := New_Item;\n+         DR.Data (Position + New_Item'Length .. DL) :=\n+           SR.Data (Position + New_Item'Length .. SR.Last);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Overwrite;\n+\n+   procedure Overwrite\n+     (Source    : in out Unbounded_String;\n+      Position  : Positive;\n+      New_Item  : String)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Bounds check\n+\n+      if Position > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      DL := Integer'Max (SR.Last, Position + New_Item'Length - 1);\n+\n+      --  Result is empty string, reuse empty shared string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         Source.Reference := Empty_Shared_String'Access;\n+         Unreference (SR);\n+\n+      --  String unchanged, nothing to do\n+\n+      elsif New_Item'Length = 0 then\n+         null;\n+\n+      --  Try to reuse existing shared string\n+\n+      elsif Can_Be_Reused (SR, DL) then\n+         SR.Data (Position .. Position + New_Item'Length - 1) := New_Item;\n+         SR.Last := DL;\n+\n+      --  Otherwise allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL);\n+         DR.Data (1 .. Position - 1) := SR.Data (1 .. Position - 1);\n+         DR.Data (Position .. Position + New_Item'Length - 1) := New_Item;\n+         DR.Data (Position + New_Item'Length .. DL) :=\n+           SR.Data (Position + New_Item'Length .. SR.Last);\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Overwrite;\n+\n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   procedure Reference (Item : not null Shared_String_Access) is\n+   begin\n+      Sync_Add_And_Fetch (Item.Counter'Access, 1);\n+   end Reference;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Source : in out Unbounded_String;\n+      Index  : Positive;\n+      By     : Character)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Bounds check.\n+\n+      if Index <= SR.Last then\n+\n+         --  Try to reuse existing shared string\n+\n+         if Can_Be_Reused (SR, SR.Last) then\n+            SR.Data (Index) := By;\n+\n+         --  Otherwise allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (SR.Last);\n+            DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+            DR.Data (Index) := By;\n+            DR.Last := SR.Last;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+\n+      else\n+         raise Index_Error;\n+      end if;\n+   end Replace_Element;\n+\n+   -------------------\n+   -- Replace_Slice --\n+   -------------------\n+\n+   function Replace_Slice\n+     (Source : Unbounded_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : String) return Unbounded_String\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Low > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      --  Do replace operation when removed slice is not empty\n+\n+      if High >= Low then\n+         DL := By'Length + SR.Last + Low - High - 1;\n+\n+         --  Result is empty string, reuse empty shared string\n+\n+         if DL = 0 then\n+            Reference (Empty_Shared_String'Access);\n+            DR := Empty_Shared_String'Access;\n+\n+         --  Otherwise allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. Low - 1) := SR.Data (1 .. Low - 1);\n+            DR.Data (Low .. Low + By'Length - 1) := By;\n+            DR.Data (Low + By'Length .. DL) := SR.Data (High + 1 .. SR.Last);\n+            DR.Last := DL;\n+         end if;\n+\n+         return (AF.Controlled with Reference => DR);\n+\n+      --  Otherwise just insert string\n+\n+      else\n+         return Insert (Source, Low, By);\n+      end if;\n+   end Replace_Slice;\n+\n+   procedure Replace_Slice\n+     (Source : in out Unbounded_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : String)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Bounds check\n+\n+      if Low > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      --  Do replace operation only when replaced slice is not empty\n+\n+      if High >= Low then\n+         DL := By'Length + SR.Last + Low - High - 1;\n+\n+         --  Result is empty string, reuse empty shared string\n+\n+         if DL = 0 then\n+            Reference (Empty_Shared_String'Access);\n+            Source.Reference := Empty_Shared_String'Access;\n+            Unreference (SR);\n+\n+         --  Try to reuse existing shared string\n+\n+         elsif Can_Be_Reused (SR, DL) then\n+            SR.Data (Low + By'Length .. DL) := SR.Data (High + 1 .. SR.Last);\n+            SR.Data (Low .. Low + By'Length - 1) := By;\n+            SR.Last := DL;\n+\n+         --  Otherwise allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. Low - 1) := SR.Data (1 .. Low - 1);\n+            DR.Data (Low .. Low + By'Length - 1) := By;\n+            DR.Data (Low + By'Length .. DL) := SR.Data (High + 1 .. SR.Last);\n+            DR.Last := DL;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+\n+      --  Otherwise just insert item\n+\n+      else\n+         Insert (Source, Low, By);\n+      end if;\n+   end Replace_Slice;\n+\n+   --------------------------\n+   -- Set_Unbounded_String --\n+   --------------------------\n+\n+   procedure Set_Unbounded_String\n+     (Target : out Unbounded_String;\n+      Source : String)\n+   is\n+      TR : constant Shared_String_Access := Target.Reference;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  In case of empty string, reuse empty shared string\n+\n+      if Source'Length = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         Target.Reference := Empty_Shared_String'Access;\n+\n+      else\n+         --  Try to reuse existing shared string\n+\n+         if Can_Be_Reused (TR, Source'Length) then\n+            Reference (TR);\n+            DR := TR;\n+\n+         --  Otherwise allocate new shared string\n+\n+         else\n+            DR := Allocate (Source'Length);\n+            Target.Reference := DR;\n+         end if;\n+\n+         DR.Data (1 .. Source'Length) := Source;\n+         DR.Last := Source'Length;\n+      end if;\n+\n+      Unreference (TR);\n+   end Set_Unbounded_String;\n+\n+   -----------\n+   -- Slice --\n+   -----------\n+\n+   function Slice\n+     (Source : Unbounded_String;\n+      Low    : Positive;\n+      High   : Natural) return String\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+\n+   begin\n+      --  Note: test of High > Length is in accordance with AI95-00128\n+\n+      if Low > SR.Last + 1 or else High > SR.Last then\n+         raise Index_Error;\n+\n+      else\n+         return SR.Data (Low .. High);\n+      end if;\n+   end Slice;\n+\n+   ----------\n+   -- Tail --\n+   ----------\n+\n+   function Tail\n+     (Source : Unbounded_String;\n+      Count  : Natural;\n+      Pad    : Character := Space) return Unbounded_String\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  For empty result reuse empty shared string\n+\n+      if Count = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Result is whole source string, reuse source shared string\n+\n+      elsif Count = SR.Last then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Otherwise allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Count);\n+\n+         if Count < SR.Last then\n+            DR.Data (1 .. Count) := SR.Data (SR.Last - Count + 1 .. SR.Last);\n+\n+         else\n+            for J in 1 .. Count - SR.Last loop\n+               DR.Data (J) := Pad;\n+            end loop;\n+\n+            DR.Data (Count - SR.Last + 1 .. Count) := SR.Data (1 .. SR.Last);\n+         end if;\n+\n+         DR.Last := Count;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Tail;\n+\n+   procedure Tail\n+     (Source : in out Unbounded_String;\n+      Count  : Natural;\n+      Pad    : Character := Space)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DR : Shared_String_Access;\n+\n+      procedure Common\n+        (SR    : Shared_String_Access;\n+         DR    : Shared_String_Access;\n+         Count : Natural);\n+      --  Common code of tail computation. SR/DR can point to the same object\n+\n+      ------------\n+      -- Common --\n+      ------------\n+\n+      procedure Common\n+        (SR    : Shared_String_Access;\n+         DR    : Shared_String_Access;\n+         Count : Natural) is\n+      begin\n+         if Count < SR.Last then\n+            DR.Data (1 .. Count) := SR.Data (SR.Last - Count + 1 .. SR.Last);\n+\n+         else\n+            DR.Data (Count - SR.Last + 1 .. Count) := SR.Data (1 .. SR.Last);\n+\n+            for J in 1 .. Count - SR.Last loop\n+               DR.Data (J) := Pad;\n+            end loop;\n+         end if;\n+\n+         DR.Last := Count;\n+      end Common;\n+\n+   begin\n+      --  Result is empty string, reuse empty shared string\n+\n+      if Count = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         Source.Reference := Empty_Shared_String'Access;\n+         Unreference (SR);\n+\n+      --  Length of the result is the same as length of the source string,\n+      --  reuse source shared string.\n+\n+      elsif Count = SR.Last then\n+         null;\n+\n+      --  Try to reuse existing shared string\n+\n+      elsif Can_Be_Reused (SR, Count) then\n+         Common (SR, SR, Count);\n+\n+      --  Otherwise allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Count);\n+         Common (SR, DR, Count);\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Tail;\n+\n+   ---------------\n+   -- To_String --\n+   ---------------\n+\n+   function To_String (Source : Unbounded_String) return String is\n+   begin\n+      return Source.Reference.Data (1 .. Source.Reference.Last);\n+   end To_String;\n+\n+   -------------------------\n+   -- To_Unbounded_String --\n+   -------------------------\n+\n+   function To_Unbounded_String (Source : String) return Unbounded_String is\n+      DR : constant Shared_String_Access := Allocate (Source'Length);\n+   begin\n+      DR.Data (1 .. Source'Length) := Source;\n+      DR.Last := Source'Length;\n+      return (AF.Controlled with Reference => DR);\n+   end To_Unbounded_String;\n+\n+   function To_Unbounded_String (Length : Natural) return Unbounded_String is\n+      DR : constant Shared_String_Access := Allocate (Length);\n+   begin\n+      DR.Last := Length;\n+      return (AF.Controlled with Reference => DR);\n+   end To_Unbounded_String;\n+\n+   ---------------\n+   -- Translate --\n+   ---------------\n+\n+   function Translate\n+     (Source  : Unbounded_String;\n+      Mapping : Maps.Character_Mapping) return Unbounded_String\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Nothing to translate, reuse empty shared string\n+\n+      if SR.Last = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (SR.Last);\n+\n+         for J in 1 .. SR.Last loop\n+            DR.Data (J) := Value (Mapping, SR.Data (J));\n+         end loop;\n+\n+         DR.Last := SR.Last;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Translate;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_String;\n+      Mapping : Maps.Character_Mapping)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Nothing to translate\n+\n+      if SR.Last = 0 then\n+         null;\n+\n+      --  Try to reuse shared string\n+\n+      elsif Can_Be_Reused (SR, SR.Last) then\n+         for J in 1 .. SR.Last loop\n+            SR.Data (J) := Value (Mapping, SR.Data (J));\n+         end loop;\n+\n+      --  Otherwise, allocate new shared string\n+\n+      else\n+         DR := Allocate (SR.Last);\n+\n+         for J in 1 .. SR.Last loop\n+            DR.Data (J) := Value (Mapping, SR.Data (J));\n+         end loop;\n+\n+         DR.Last := SR.Last;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Translate;\n+\n+   function Translate\n+     (Source  : Unbounded_String;\n+      Mapping : Maps.Character_Mapping_Function) return Unbounded_String\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Nothing to translate, reuse empty shared string\n+\n+      if SR.Last = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (SR.Last);\n+\n+         for J in 1 .. SR.Last loop\n+            DR.Data (J) := Mapping.all (SR.Data (J));\n+         end loop;\n+\n+         DR.Last := SR.Last;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+\n+   exception\n+      when others =>\n+         Unreference (DR);\n+\n+         raise;\n+   end Translate;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_String;\n+      Mapping : Maps.Character_Mapping_Function)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Nothing to translate\n+\n+      if SR.Last = 0 then\n+         null;\n+\n+      --  Try to reuse shared string\n+\n+      elsif Can_Be_Reused (SR, SR.Last) then\n+         for J in 1 .. SR.Last loop\n+            SR.Data (J) := Mapping.all (SR.Data (J));\n+         end loop;\n+\n+      --  Otherwise allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (SR.Last);\n+\n+         for J in 1 .. SR.Last loop\n+            DR.Data (J) := Mapping.all (SR.Data (J));\n+         end loop;\n+\n+         DR.Last := SR.Last;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+\n+   exception\n+      when others =>\n+         if DR /= null then\n+            Unreference (DR);\n+         end if;\n+\n+         raise;\n+   end Translate;\n+\n+   ----------\n+   -- Trim --\n+   ----------\n+\n+   function Trim\n+     (Source : Unbounded_String;\n+      Side   : Trim_End) return Unbounded_String\n+   is\n+      SR   : constant Shared_String_Access := Source.Reference;\n+      DL   : Natural;\n+      DR   : Shared_String_Access;\n+      Low  : Natural;\n+      High : Natural;\n+\n+   begin\n+      Low := Index_Non_Blank (Source, Forward);\n+\n+      --  All blanks, reuse empty shared string\n+\n+      if Low = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      else\n+         case Side is\n+            when Left =>\n+               High := SR.Last;\n+               DL   := SR.Last - Low + 1;\n+\n+            when Right =>\n+               Low  := 1;\n+               High := Index_Non_Blank (Source, Backward);\n+               DL   := High;\n+\n+            when Both =>\n+               High := Index_Non_Blank (Source, Backward);\n+               DL   := High - Low + 1;\n+         end case;\n+\n+         --  Length of the result is the same as length of the source string,\n+         --  reuse source shared string.\n+\n+         if DL = SR.Last then\n+            Reference (SR);\n+            DR := SR;\n+\n+         --  Otherwise, allocate new shared string\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+         end if;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Trim;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_String;\n+      Side   : Trim_End)\n+   is\n+      SR   : constant Shared_String_Access := Source.Reference;\n+      DL   : Natural;\n+      DR   : Shared_String_Access;\n+      Low  : Natural;\n+      High : Natural;\n+\n+   begin\n+      Low := Index_Non_Blank (Source, Forward);\n+\n+      --  All blanks, reuse empty shared string\n+\n+      if Low = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         Source.Reference := Empty_Shared_String'Access;\n+         Unreference (SR);\n+\n+      else\n+         case Side is\n+            when Left =>\n+               High := SR.Last;\n+               DL   := SR.Last - Low + 1;\n+\n+            when Right =>\n+               Low  := 1;\n+               High := Index_Non_Blank (Source, Backward);\n+               DL   := High;\n+\n+            when Both =>\n+               High := Index_Non_Blank (Source, Backward);\n+               DL   := High - Low + 1;\n+         end case;\n+\n+         --  Length of the result is the same as length of the source string,\n+         --  nothing to do.\n+\n+         if DL = SR.Last then\n+            null;\n+\n+         --  Try to reuse existing shared string\n+\n+         elsif Can_Be_Reused (SR, DL) then\n+            SR.Data (1 .. DL) := SR.Data (Low .. High);\n+            SR.Last := DL;\n+\n+         --  Otherwise, allocate new shared string\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+      end if;\n+   end Trim;\n+\n+   function Trim\n+     (Source : Unbounded_String;\n+      Left   : Maps.Character_Set;\n+      Right  : Maps.Character_Set) return Unbounded_String\n+   is\n+      SR   : constant Shared_String_Access := Source.Reference;\n+      DL   : Natural;\n+      DR   : Shared_String_Access;\n+      Low  : Natural;\n+      High : Natural;\n+\n+   begin\n+      Low := Index (Source, Left, Outside, Forward);\n+\n+      --  Source includes only characters from Left set, reuse empty shared\n+      --  string.\n+\n+      if Low = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      else\n+         High := Index (Source, Right, Outside, Backward);\n+         DL   := Integer'Max (0, High - Low + 1);\n+\n+         --  Source includes only characters from Right set or result string\n+         --  is empty, reuse empty shared string.\n+\n+         if High = 0 or else DL = 0 then\n+            Reference (Empty_Shared_String'Access);\n+            DR := Empty_Shared_String'Access;\n+\n+         --  Otherwise, allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+         end if;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Trim;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_String;\n+      Left   : Maps.Character_Set;\n+      Right  : Maps.Character_Set)\n+   is\n+      SR   : constant Shared_String_Access := Source.Reference;\n+      DL   : Natural;\n+      DR   : Shared_String_Access;\n+      Low  : Natural;\n+      High : Natural;\n+\n+   begin\n+      Low := Index (Source, Left, Outside, Forward);\n+\n+      --  Source includes only characters from Left set, reuse empty shared\n+      --  string.\n+\n+      if Low = 0 then\n+         Reference (Empty_Shared_String'Access);\n+         Source.Reference := Empty_Shared_String'Access;\n+         Unreference (SR);\n+\n+      else\n+         High := Index (Source, Right, Outside, Backward);\n+         DL   := Integer'Max (0, High - Low + 1);\n+\n+         --  Source includes only characters from Right set or result string\n+         --  is empty, reuse empty shared string.\n+\n+         if High = 0 or else DL = 0 then\n+            Reference (Empty_Shared_String'Access);\n+            Source.Reference := Empty_Shared_String'Access;\n+            Unreference (SR);\n+\n+         --  Try to reuse existing shared string\n+\n+         elsif Can_Be_Reused (SR, DL) then\n+            SR.Data (1 .. DL) := SR.Data (Low .. High);\n+            SR.Last := DL;\n+\n+         --  Otherwise, allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+      end if;\n+   end Trim;\n+\n+   ---------------------\n+   -- Unbounded_Slice --\n+   ---------------------\n+\n+   function Unbounded_Slice\n+     (Source : Unbounded_String;\n+      Low    : Positive;\n+      High   : Natural) return Unbounded_String\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Low > SR.Last + 1 or else High > SR.Last then\n+         raise Index_Error;\n+\n+      --  Result is empty slice, reuse empty shared string\n+\n+      elsif Low > High then\n+         Reference (Empty_Shared_String'Access);\n+         DR := Empty_Shared_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DL := High - Low + 1;\n+         DR := Allocate (DL);\n+         DR.Data (1 .. DL) := SR.Data (Low .. High);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Unbounded_Slice;\n+\n+   procedure Unbounded_Slice\n+     (Source : Unbounded_String;\n+      Target : out Unbounded_String;\n+      Low    : Positive;\n+      High   : Natural)\n+   is\n+      SR : constant Shared_String_Access := Source.Reference;\n+      TR : constant Shared_String_Access := Target.Reference;\n+      DL : Natural;\n+      DR : Shared_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Low > SR.Last + 1 or else High > SR.Last then\n+         raise Index_Error;\n+\n+      --  Result is empty slice, reuse empty shared string\n+\n+      elsif Low > High then\n+         Reference (Empty_Shared_String'Access);\n+         Target.Reference := Empty_Shared_String'Access;\n+         Unreference (TR);\n+\n+      else\n+         DL := High - Low + 1;\n+\n+         --  Try to reuse existing shared string\n+\n+         if Can_Be_Reused (TR, DL) then\n+            TR.Data (1 .. DL) := SR.Data (Low .. High);\n+            TR.Last := DL;\n+\n+         --  Otherwise, allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+            Target.Reference := DR;\n+            Unreference (TR);\n+         end if;\n+      end if;\n+   end Unbounded_Slice;\n+\n+   -----------------\n+   -- Unreference --\n+   -----------------\n+\n+   procedure Unreference (Item : not null Shared_String_Access) is\n+      use Interfaces;\n+\n+      procedure Free is\n+        new Ada.Unchecked_Deallocation (Shared_String, Shared_String_Access);\n+\n+      Aux : Shared_String_Access := Item;\n+\n+   begin\n+      if Sync_Sub_And_Fetch (Aux.Counter'Access, 1) = 0 then\n+\n+         --  Reference counter of Empty_Shared_String must never reach zero\n+\n+         pragma Assert (Aux /= Empty_Shared_String'Access);\n+\n+         Free (Aux);\n+      end if;\n+   end Unreference;\n+\n+end Ada.Strings.Unbounded;"}, {"sha": "b4b7c62275930de451d05d8c4a9475ae97bd70d6", "filename": "gcc/ada/a-strunb-shared.ads", "status": "added", "additions": 481, "deletions": 0, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-strunb-shared.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-strunb-shared.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strunb-shared.ads?ref=e487f350e432d9182a0e19da9c5eb444caba8d0c", "patch": "@@ -0,0 +1,481 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 A D A . S T R I N G S . U N B O U N D E D                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides an implementation of Ada.Strings.Unbounded that uses\n+--  reference counts to implement copy on modification (rather than copy on\n+--  assignment). This is significantly more efficient on many targets.\n+\n+--  This version is supported on:\n+--    - all Alpha platforms\n+--    - all ia64 platforms\n+--    - all PowerPC platforms\n+--    - all SPARC V9 platforms\n+--    - all x86_64 platforms\n+\n+   --  This package uses several techniques to increase speed:\n+\n+   --   - Implicit sharing or copy-on-write. An Unbounded_String contains only\n+   --     the reference to the data which is shared between several instances.\n+   --     The shared data is reallocated only when its value is changed and\n+   --     the object mutation can't be used or it is unefficient to use it.\n+\n+   --   - Object mutation. Shared data object can be reused without memory\n+   --     reallocation when all of the following requirements are met:\n+   --      - shared data object is no longer used by anyone else.\n+   --      - the size is sufficient to store new value.\n+   --      - the gap after reuse is less then a defined threashold.\n+\n+   --   - Memory preallocation. Most of used memory allocation algorithms\n+   --     allign allocated segments on the some boundary, thus some amount of\n+   --     additional memory can be preallocated without any impact. Such\n+   --     preallocated memory can used later by Append/Insert operations\n+   --     without reallocation.\n+\n+   --  Reference counting uses GCC builtin atomic operations, which allows to\n+   --  safely share internal data between Ada tasks. Nevertheless, this not\n+   --  make objects of Unbounded_String thread-safe, so each instance can't be\n+   --  accessed by several tasks simulatenously.\n+\n+with Ada.Strings.Maps;\n+private with Ada.Finalization;\n+private with Interfaces;\n+\n+package Ada.Strings.Unbounded is\n+   pragma Preelaborate;\n+\n+   type Unbounded_String is private;\n+   pragma Preelaborable_Initialization (Unbounded_String);\n+\n+   Null_Unbounded_String : constant Unbounded_String;\n+\n+   function Length (Source : Unbounded_String) return Natural;\n+\n+   type String_Access is access all String;\n+\n+   procedure Free (X : in out String_Access);\n+\n+   --------------------------------------------------------\n+   -- Conversion, Concatenation, and Selection Functions --\n+   --------------------------------------------------------\n+\n+   function To_Unbounded_String\n+     (Source : String)  return Unbounded_String;\n+\n+   function To_Unbounded_String\n+     (Length : Natural) return Unbounded_String;\n+\n+   function To_String (Source : Unbounded_String) return String;\n+\n+   procedure Set_Unbounded_String\n+     (Target : out Unbounded_String;\n+      Source : String);\n+   pragma Ada_05 (Set_Unbounded_String);\n+\n+   procedure Append\n+     (Source   : in out Unbounded_String;\n+      New_Item : Unbounded_String);\n+\n+   procedure Append\n+     (Source   : in out Unbounded_String;\n+      New_Item : String);\n+\n+   procedure Append\n+     (Source   : in out Unbounded_String;\n+      New_Item : Character);\n+\n+   function \"&\"\n+     (Left  : Unbounded_String;\n+      Right : Unbounded_String) return Unbounded_String;\n+\n+   function \"&\"\n+     (Left  : Unbounded_String;\n+      Right : String) return Unbounded_String;\n+\n+   function \"&\"\n+     (Left  : String;\n+      Right : Unbounded_String) return Unbounded_String;\n+\n+   function \"&\"\n+     (Left  : Unbounded_String;\n+      Right : Character) return Unbounded_String;\n+\n+   function \"&\"\n+     (Left  : Character;\n+      Right : Unbounded_String) return Unbounded_String;\n+\n+   function Element\n+     (Source : Unbounded_String;\n+      Index  : Positive) return Character;\n+\n+   procedure Replace_Element\n+     (Source : in out Unbounded_String;\n+      Index  : Positive;\n+      By     : Character);\n+\n+   function Slice\n+     (Source : Unbounded_String;\n+      Low    : Positive;\n+      High   : Natural) return String;\n+\n+   function Unbounded_Slice\n+     (Source : Unbounded_String;\n+      Low    : Positive;\n+      High   : Natural) return Unbounded_String;\n+   pragma Ada_05 (Unbounded_Slice);\n+\n+   procedure Unbounded_Slice\n+     (Source : Unbounded_String;\n+      Target : out Unbounded_String;\n+      Low    : Positive;\n+      High   : Natural);\n+   pragma Ada_05 (Unbounded_Slice);\n+\n+   function \"=\"\n+     (Left  : Unbounded_String;\n+      Right : Unbounded_String) return Boolean;\n+\n+   function \"=\"\n+     (Left  : Unbounded_String;\n+      Right : String) return Boolean;\n+\n+   function \"=\"\n+     (Left  : String;\n+      Right : Unbounded_String) return Boolean;\n+\n+   function \"<\"\n+     (Left  : Unbounded_String;\n+      Right : Unbounded_String) return Boolean;\n+\n+   function \"<\"\n+     (Left  : Unbounded_String;\n+      Right : String) return Boolean;\n+\n+   function \"<\"\n+     (Left  : String;\n+      Right : Unbounded_String) return Boolean;\n+\n+   function \"<=\"\n+     (Left  : Unbounded_String;\n+      Right : Unbounded_String) return Boolean;\n+\n+   function \"<=\"\n+     (Left  : Unbounded_String;\n+      Right : String) return Boolean;\n+\n+   function \"<=\"\n+     (Left  : String;\n+      Right : Unbounded_String) return Boolean;\n+\n+   function \">\"\n+     (Left  : Unbounded_String;\n+      Right : Unbounded_String) return Boolean;\n+\n+   function \">\"\n+     (Left  : Unbounded_String;\n+      Right : String) return Boolean;\n+\n+   function \">\"\n+     (Left  : String;\n+      Right : Unbounded_String) return Boolean;\n+\n+   function \">=\"\n+     (Left  : Unbounded_String;\n+      Right : Unbounded_String) return Boolean;\n+\n+   function \">=\"\n+     (Left  : Unbounded_String;\n+      Right : String) return Boolean;\n+\n+   function \">=\"\n+     (Left  : String;\n+      Right : Unbounded_String) return Boolean;\n+\n+   ------------------------\n+   -- Search Subprograms --\n+   ------------------------\n+\n+   function Index\n+     (Source  : Unbounded_String;\n+      Pattern : String;\n+      Going   : Direction := Forward;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+\n+   function Index\n+     (Source  : Unbounded_String;\n+      Pattern : String;\n+      Going   : Direction := Forward;\n+      Mapping : Maps.Character_Mapping_Function) return Natural;\n+\n+   function Index\n+     (Source : Unbounded_String;\n+      Set    : Maps.Character_Set;\n+      Test   : Membership := Inside;\n+      Going  : Direction  := Forward) return Natural;\n+\n+   function Index\n+     (Source  : Unbounded_String;\n+      Pattern : String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index\n+     (Source  : Unbounded_String;\n+      Pattern : String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Maps.Character_Mapping_Function) return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index\n+     (Source  : Unbounded_String;\n+      Set     : Maps.Character_Set;\n+      From    : Positive;\n+      Test    : Membership := Inside;\n+      Going   : Direction := Forward) return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_String;\n+      Going  : Direction := Forward) return Natural;\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_String;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural;\n+   pragma Ada_05 (Index_Non_Blank);\n+\n+   function Count\n+     (Source  : Unbounded_String;\n+      Pattern : String;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+\n+   function Count\n+     (Source  : Unbounded_String;\n+      Pattern : String;\n+      Mapping : Maps.Character_Mapping_Function) return Natural;\n+\n+   function Count\n+     (Source : Unbounded_String;\n+      Set    : Maps.Character_Set) return Natural;\n+\n+   procedure Find_Token\n+     (Source : Unbounded_String;\n+      Set    : Maps.Character_Set;\n+      Test   : Membership;\n+      First  : out Positive;\n+      Last   : out Natural);\n+\n+   ------------------------------------\n+   -- String Translation Subprograms --\n+   ------------------------------------\n+\n+   function Translate\n+     (Source  : Unbounded_String;\n+      Mapping : Maps.Character_Mapping) return Unbounded_String;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_String;\n+      Mapping : Maps.Character_Mapping);\n+\n+   function Translate\n+     (Source  : Unbounded_String;\n+      Mapping : Maps.Character_Mapping_Function) return Unbounded_String;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_String;\n+      Mapping : Maps.Character_Mapping_Function);\n+\n+   ---------------------------------------\n+   -- String Transformation Subprograms --\n+   ---------------------------------------\n+\n+   function Replace_Slice\n+     (Source : Unbounded_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : String) return Unbounded_String;\n+\n+   procedure Replace_Slice\n+     (Source : in out Unbounded_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : String);\n+\n+   function Insert\n+     (Source   : Unbounded_String;\n+      Before   : Positive;\n+      New_Item : String) return Unbounded_String;\n+\n+   procedure Insert\n+     (Source   : in out Unbounded_String;\n+      Before   : Positive;\n+      New_Item : String);\n+\n+   function Overwrite\n+     (Source   : Unbounded_String;\n+      Position : Positive;\n+      New_Item : String) return Unbounded_String;\n+\n+   procedure Overwrite\n+     (Source   : in out Unbounded_String;\n+      Position : Positive;\n+      New_Item : String);\n+\n+   function Delete\n+     (Source  : Unbounded_String;\n+      From    : Positive;\n+      Through : Natural) return Unbounded_String;\n+\n+   procedure Delete\n+     (Source  : in out Unbounded_String;\n+      From    : Positive;\n+      Through : Natural);\n+\n+   function Trim\n+     (Source : Unbounded_String;\n+      Side   : Trim_End) return Unbounded_String;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_String;\n+      Side   : Trim_End);\n+\n+   function Trim\n+     (Source : Unbounded_String;\n+      Left   : Maps.Character_Set;\n+      Right  : Maps.Character_Set) return Unbounded_String;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_String;\n+      Left   : Maps.Character_Set;\n+      Right  : Maps.Character_Set);\n+\n+   function Head\n+     (Source : Unbounded_String;\n+      Count  : Natural;\n+      Pad    : Character := Space) return Unbounded_String;\n+\n+   procedure Head\n+     (Source : in out Unbounded_String;\n+      Count  : Natural;\n+      Pad    : Character := Space);\n+\n+   function Tail\n+     (Source : Unbounded_String;\n+      Count  : Natural;\n+      Pad    : Character := Space) return Unbounded_String;\n+\n+   procedure Tail\n+     (Source : in out Unbounded_String;\n+      Count  : Natural;\n+      Pad    : Character := Space);\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Character) return Unbounded_String;\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : String) return Unbounded_String;\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Unbounded_String) return Unbounded_String;\n+\n+private\n+   pragma Inline (Length);\n+\n+   package AF renames Ada.Finalization;\n+\n+   type Shared_String (Max_Length : Natural) is limited record\n+      Counter : aliased Interfaces.Unsigned_32 := 1;\n+      --  Reference counter\n+\n+      Last : Natural := 0;\n+      Data : String (1 .. Max_Length);\n+      --  Last is the index of last significant element of the Data. All\n+      --  elements with larger indexes are currently insignificant.\n+   end record;\n+\n+   type Shared_String_Access is access all Shared_String;\n+\n+   procedure Reference (Item : not null Shared_String_Access);\n+   --  Increment reference counter\n+\n+   procedure Unreference (Item : not null Shared_String_Access);\n+   --  Decrement reference counter, deallocate Item when counter goes to zero\n+\n+   function Can_Be_Reused\n+     (Item   : Shared_String_Access;\n+      Length : Natural) return Boolean;\n+   --  Returns True if Shared_String can be reused. There are two criteria when\n+   --  Shared_String can be reused: its reference counter must be one (thus\n+   --  Shared_String is owned exclusively) and its size is sufficient to\n+   --  store string with specified length effectively.\n+\n+   function Allocate (Max_Length : Natural) return Shared_String_Access;\n+   --  Allocates new Shared_String with at least specified maximum length.\n+   --  Actual maximum length of the allocated Shared_String can be sligtly\n+   --  greater. Returns reference to Empty_Shared_String when requested length\n+   --  is zero.\n+\n+   Empty_Shared_String : aliased Shared_String (0);\n+\n+   function To_Unbounded (S : String) return Unbounded_String\n+     renames To_Unbounded_String;\n+   --  This renames are here only to be used in the pragma Stream_Convert\n+\n+   type Unbounded_String is new AF.Controlled with record\n+      Reference : Shared_String_Access := Empty_Shared_String'Access;\n+   end record;\n+\n+   pragma Stream_Convert (Unbounded_String, To_Unbounded, To_String);\n+   --  Provide stream routines without dragging in Ada.Streams\n+\n+   pragma Finalize_Storage_Only (Unbounded_String);\n+   --  Finalization is required only for freeing storage\n+\n+   overriding procedure Initialize (Object : in out Unbounded_String);\n+   overriding procedure Adjust     (Object : in out Unbounded_String);\n+   overriding procedure Finalize   (Object : in out Unbounded_String);\n+\n+   Null_Unbounded_String : constant Unbounded_String :=\n+                             (AF.Controlled with\n+                                Reference => Empty_Shared_String'Access);\n+\n+end Ada.Strings.Unbounded;"}, {"sha": "6ca416243b74803ea962aa43a53380d8a12dd271", "filename": "gcc/ada/a-stunau-shared.adb", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-stunau-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-stunau-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stunau-shared.adb?ref=e487f350e432d9182a0e19da9c5eb444caba8d0c", "patch": "@@ -0,0 +1,62 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                          GNAT RUN-TIME COMPONENTS                        --\n+--                                                                          --\n+--            A D A . S T R I N G S . U N B O U N D E D . A U X             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Strings.Unbounded.Aux is\n+\n+   ----------------\n+   -- Get_String --\n+   ----------------\n+\n+   procedure Get_String\n+     (U : Unbounded_String;\n+      S : out Big_String_Access;\n+      L : out Natural)\n+   is\n+      X : aliased Big_String;\n+      for X'Address use U.Reference.Data'Address;\n+   begin\n+      S := X'Unchecked_Access;\n+      L := U.Reference.Last;\n+   end Get_String;\n+\n+   ----------------\n+   -- Set_String --\n+   ----------------\n+\n+   procedure Set_String (UP : in out Unbounded_String; S : String_Access) is\n+      X : String_Access := S;\n+\n+   begin\n+      Set_Unbounded_String (UP, S.all);\n+      Free (X);\n+   end Set_String;\n+\n+end Ada.Strings.Unbounded.Aux;"}, {"sha": "0f61c7130e6659f39367273f7b0fdbf79ffc1670", "filename": "gcc/ada/a-stwiun-shared.adb", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-stwiun-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-stwiun-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiun-shared.adb?ref=e487f350e432d9182a0e19da9c5eb444caba8d0c", "patch": "@@ -6,25 +6,23 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n -- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n --                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n --                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --"}, {"sha": "e20cd98e8a098574124fd892097562ba55be126b", "filename": "gcc/ada/a-stzunb-shared.adb", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-stzunb-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-stzunb-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzunb-shared.adb?ref=e487f350e432d9182a0e19da9c5eb444caba8d0c", "patch": "@@ -6,25 +6,23 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n -- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n --                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n --                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --"}, {"sha": "d50ed7767758415d75ee667334bbe4d775895b86", "filename": "gcc/ada/a-suteio-shared.adb", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-suteio-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-suteio-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suteio-shared.adb?ref=e487f350e432d9182a0e19da9c5eb444caba8d0c", "patch": "@@ -0,0 +1,132 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--         A D A . S T R I N G S . U N B O U N D E D . T E X T _ I O        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1997-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO; use Ada.Text_IO;\n+\n+package body Ada.Strings.Unbounded.Text_IO is\n+\n+   --------------\n+   -- Get_Line --\n+   --------------\n+\n+   function Get_Line return Unbounded_String is\n+      Buffer : String (1 .. 1000);\n+      Last   : Natural;\n+      Result : Unbounded_String;\n+\n+   begin\n+      Get_Line (Buffer, Last);\n+      Set_Unbounded_String (Result, Buffer (1 .. Last));\n+\n+      while Last = Buffer'Last loop\n+         Get_Line (Buffer, Last);\n+         Append (Result, Buffer (1 .. Last));\n+      end loop;\n+\n+      return Result;\n+   end Get_Line;\n+\n+   function Get_Line (File : Ada.Text_IO.File_Type) return Unbounded_String is\n+      Buffer : String (1 .. 1000);\n+      Last   : Natural;\n+      Result : Unbounded_String;\n+\n+   begin\n+      Get_Line (File, Buffer, Last);\n+      Set_Unbounded_String (Result, Buffer (1 .. Last));\n+\n+      while Last = Buffer'Last loop\n+         Get_Line (File, Buffer, Last);\n+         Append (Result, Buffer (1 .. Last));\n+      end loop;\n+\n+      return Result;\n+   end Get_Line;\n+\n+   procedure Get_Line (Item : out Unbounded_String) is\n+   begin\n+      Get_Line (Current_Input, Item);\n+   end Get_Line;\n+\n+   procedure Get_Line\n+     (File : Ada.Text_IO.File_Type;\n+      Item : out Unbounded_String)\n+   is\n+      Buffer : String (1 .. 1000);\n+      Last   : Natural;\n+\n+   begin\n+      Get_Line (File, Buffer, Last);\n+      Set_Unbounded_String (Item, Buffer (1 .. Last));\n+\n+      while Last = Buffer'Last loop\n+         Get_Line (File, Buffer, Last);\n+         Append (Item, Buffer (1 .. Last));\n+      end loop;\n+   end Get_Line;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put (U : Unbounded_String) is\n+      UR : constant Shared_String_Access := U.Reference;\n+\n+   begin\n+      Put (UR.Data (1 .. UR.Last));\n+   end Put;\n+\n+   procedure Put (File : File_Type; U : Unbounded_String) is\n+      UR : constant Shared_String_Access := U.Reference;\n+\n+   begin\n+      Put (File, UR.Data (1 .. UR.Last));\n+   end Put;\n+\n+   --------------\n+   -- Put_Line --\n+   --------------\n+\n+   procedure Put_Line (U : Unbounded_String) is\n+      UR : constant Shared_String_Access := U.Reference;\n+\n+   begin\n+      Put_Line (UR.Data (1 .. UR.Last));\n+   end Put_Line;\n+\n+   procedure Put_Line (File : File_Type; U : Unbounded_String) is\n+      UR : constant Shared_String_Access := U.Reference;\n+\n+   begin\n+      Put_Line (File, UR.Data (1 .. UR.Last));\n+   end Put_Line;\n+\n+end Ada.Strings.Unbounded.Text_IO;"}, {"sha": "ad397b8c5b3e59385979abcc5a5942b0c31591c3", "filename": "gcc/ada/a-swunau-shared.adb", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-swunau-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-swunau-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swunau-shared.adb?ref=e487f350e432d9182a0e19da9c5eb444caba8d0c", "patch": "@@ -6,25 +6,23 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n -- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n --                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n --                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --"}, {"sha": "9cf7c0ad559dea18130ae224da1bb33d3f448ae4", "filename": "gcc/ada/a-swuwti-shared.adb", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-swuwti-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-swuwti-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swuwti-shared.adb?ref=e487f350e432d9182a0e19da9c5eb444caba8d0c", "patch": "@@ -6,25 +6,23 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n -- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n --                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n --                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --"}, {"sha": "87b2cb40d1552c74959ca3e53e4bb4a7790260ac", "filename": "gcc/ada/a-szunau-shared.adb", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-szunau-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-szunau-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szunau-shared.adb?ref=e487f350e432d9182a0e19da9c5eb444caba8d0c", "patch": "@@ -6,25 +6,23 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n -- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n --                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n --                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --"}, {"sha": "247ccb2bcd5918dff26894a80a71fea6cb9fca97", "filename": "gcc/ada/a-szuzti-shared.adb", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-szuzti-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e487f350e432d9182a0e19da9c5eb444caba8d0c/gcc%2Fada%2Fa-szuzti-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szuzti-shared.adb?ref=e487f350e432d9182a0e19da9c5eb444caba8d0c", "patch": "@@ -6,25 +6,23 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n -- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n --                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n --                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --"}]}