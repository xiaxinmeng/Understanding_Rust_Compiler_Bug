{"sha": "5cda5098057c002cf332708f0e5b53bb35d49d76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNkYTUwOTgwNTdjMDAyY2YzMzI3MDhmMGU1YjUzYmIzNWQ0OWQ3Ng==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-08-12T19:57:01Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-08-12T19:57:01Z"}, "message": "re PR fortran/29600 ([F03] MINLOC and MAXLOC take an optional KIND argument)\n\n\tPR fortran/29600\n\n\t* intrinsic.c (add_functions): Add KIND arguments to COUNT,\n\tIACHAR, ICHAR, INDEX, LBOUND, LEN, LEN_TRIM, SCAN, SIZE, UBOUND\n\tand VERIFY.\n\t* iresolve.c (gfc_resolve_count): Add kind argument.\n\t(gfc_resolve_iachar): New function.\n\t(gfc_resolve_ichar): Add kind argument.\n\t(gfc_resolve_index_func): Likewise.\n\t(gfc_resolve_lbound): Likewise.\n\t(gfc_resolve_len): Likewise.\n\t(gfc_resolve_len_trim): Likewise.\n\t(gfc_resolve_scan): Likewise.\n\t(gfc_resolve_size): New function.\n\t(gfc_resolve_ubound): Add kind argument.\n\t(gfc_resolve_verify): Likewise.\n\t* trans-decl.c (gfc_get_extern_function_decl): Allow specific\n\tintrinsics to have 4 arguments.\n\t* check.c (gfc_check_count): Add kind argument.\n\t(gfc_check_ichar_iachar): Likewise.\n\t(gfc_check_index): Likewise.\n\t(gfc_check_lbound): Likewise.\n\t(gfc_check_len_lentrim): New function.\n\t(gfc_check_scan): Add kind argument.\n\t(gfc_check_size): Likewise.\n\t(gfc_check_ubound): Likewise.\n\t(gfc_check_verify): Likewise.\n\t* intrinsic.texi: Update documentation for COUNT, IACHAR, ICHAR,\n\tINDEX, LBOUND, LEN, LEN_TRIM, SCAN, SIZE, UBOUND and VERIFY.\n\t* simplify.c (get_kind): Whitespace fix.\n\t(int_expr_with_kind): New function.\n\t(gfc_simplify_iachar): Add kind argument.\n\t(gfc_simplify_iachar): Likewise.\n\t(gfc_simplify_ichar): Likewise.\n\t(gfc_simplify_index): Likewise.\n\t(simplify_bound_dim): Likewise.\n\t(simplify_bound): Likewise.\n\t(gfc_simplify_lbound): Likewise.\n\t(gfc_simplify_len): Likewise.\n\t(gfc_simplify_len_trim): Likewise.\n\t(gfc_simplify_scan): Likewise.\n\t(gfc_simplify_shape): Pass NULL as kind argument to gfc_simplify_size.\n\t(gfc_simplify_size): Add kind argument.\n\t(gfc_simplify_ubound): Likewise.\n\t(gfc_simplify_verify): Likewise.\n\t* intrinsic.h: Update prototypes and add new ones.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_index): Rename into\n\tgfc_conv_intrinsic_index_scan_verify.\n\t(gfc_conv_intrinsic_scan, gfc_conv_intrinsic_verify): Remove.\n\t(gfc_conv_intrinsic_function): Call\n\tgfc_conv_intrinsic_index_scan_verify to translate the INDEX,\n\tSCAN and VERIFY intrinsics.\n\n\t* gfortran.dg/intrinsics_kind_argument_1.f90: New test.\n\t* gfortran.dg/pure_dummy_length_1.f90: Adapt to new error wording.\n\nFrom-SVN: r127380", "tree": {"sha": "2e41090a373d3a5875dc9d4f8d3f1658d4cab476", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e41090a373d3a5875dc9d4f8d3f1658d4cab476"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cda5098057c002cf332708f0e5b53bb35d49d76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cda5098057c002cf332708f0e5b53bb35d49d76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cda5098057c002cf332708f0e5b53bb35d49d76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cda5098057c002cf332708f0e5b53bb35d49d76/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9687668119bb3ce043e263f4922d3d93b55da352", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9687668119bb3ce043e263f4922d3d93b55da352", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9687668119bb3ce043e263f4922d3d93b55da352"}], "stats": {"total": 758, "additions": 520, "deletions": 238}, "files": [{"sha": "ecb75698b91e85fd0f9beb83ac0bf2881f33e8d1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5cda5098057c002cf332708f0e5b53bb35d49d76", "patch": "@@ -1,3 +1,57 @@\n+2007-08-12  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/29600\n+\t* intrinsic.c (add_functions): Add KIND arguments to COUNT,\n+\tIACHAR, ICHAR, INDEX, LBOUND, LEN, LEN_TRIM, SCAN, SIZE, UBOUND\n+\tand VERIFY.\n+\t* iresolve.c (gfc_resolve_count): Add kind argument.\n+\t(gfc_resolve_iachar): New function.\n+\t(gfc_resolve_ichar): Add kind argument.\n+\t(gfc_resolve_index_func): Likewise.\n+\t(gfc_resolve_lbound): Likewise.\n+\t(gfc_resolve_len): Likewise.\n+\t(gfc_resolve_len_trim): Likewise.\n+\t(gfc_resolve_scan): Likewise.\n+\t(gfc_resolve_size): New function.\n+\t(gfc_resolve_ubound): Add kind argument.\n+\t(gfc_resolve_verify): Likewise.\n+\t* trans-decl.c (gfc_get_extern_function_decl): Allow specific\n+\tintrinsics to have 4 arguments.\n+\t* check.c (gfc_check_count): Add kind argument.\n+\t(gfc_check_ichar_iachar): Likewise.\n+\t(gfc_check_index): Likewise.\n+\t(gfc_check_lbound): Likewise.\n+\t(gfc_check_len_lentrim): New function.\n+\t(gfc_check_scan): Add kind argument.\n+\t(gfc_check_size): Likewise.\n+\t(gfc_check_ubound): Likewise.\n+\t(gfc_check_verify): Likewise.\n+\t* intrinsic.texi: Update documentation for COUNT, IACHAR, ICHAR,\n+\tINDEX, LBOUND, LEN, LEN_TRIM, SCAN, SIZE, UBOUND and VERIFY.\n+\t* simplify.c (get_kind): Whitespace fix.\n+\t(int_expr_with_kind): New function.\n+\t(gfc_simplify_iachar): Add kind argument.\n+\t(gfc_simplify_iachar): Likewise.\n+\t(gfc_simplify_ichar): Likewise.\n+\t(gfc_simplify_index): Likewise.\n+\t(simplify_bound_dim): Likewise.\n+\t(simplify_bound): Likewise.\n+\t(gfc_simplify_lbound): Likewise.\n+\t(gfc_simplify_len): Likewise.\n+\t(gfc_simplify_len_trim): Likewise.\n+\t(gfc_simplify_scan): Likewise.\n+\t(gfc_simplify_shape): Pass NULL as kind argument to gfc_simplify_size.\n+\t(gfc_simplify_size): Add kind argument.\n+\t(gfc_simplify_ubound): Likewise.\n+\t(gfc_simplify_verify): Likewise.\n+\t* intrinsic.h: Update prototypes and add new ones.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_index): Rename into\n+\tgfc_conv_intrinsic_index_scan_verify.\n+\t(gfc_conv_intrinsic_scan, gfc_conv_intrinsic_verify): Remove.\n+\t(gfc_conv_intrinsic_function): Call\n+\tgfc_conv_intrinsic_index_scan_verify to translate the INDEX,\n+\tSCAN and VERIFY intrinsics.\n+\n 2007-08-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/31189"}, {"sha": "f0de08f3a21ce789a07ad2e6668234a91e5a5095", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 84, "deletions": 9, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=5cda5098057c002cf332708f0e5b53bb35d49d76", "patch": "@@ -786,12 +786,18 @@ gfc_check_complex (gfc_expr *x, gfc_expr *y)\n \n \n try\n-gfc_check_count (gfc_expr *mask, gfc_expr *dim)\n+gfc_check_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n {\n   if (logical_array_check (mask, 0) == FAILURE)\n     return FAILURE;\n   if (dim_check (dim, 1, 1) == FAILURE)\n     return FAILURE;\n+  if (kind_check (kind, 2, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+\t\t\t      \"with KIND argument at %L\",\n+\t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -1088,13 +1094,21 @@ gfc_check_ibset (gfc_expr *i, gfc_expr *pos)\n \n \n try\n-gfc_check_ichar_iachar (gfc_expr *c)\n+gfc_check_ichar_iachar (gfc_expr *c, gfc_expr *kind)\n {\n   int i;\n \n   if (type_check (c, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n \n+  if (kind_check (kind, 1, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+\t\t\t      \"with KIND argument at %L\",\n+\t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n+    return FAILURE;\n+\n   if (c->expr_type == EXPR_VARIABLE || c->expr_type == EXPR_SUBSTRING)\n     {\n       gfc_expr *start;\n@@ -1181,16 +1195,23 @@ gfc_check_ieor (gfc_expr *i, gfc_expr *j)\n \n \n try\n-gfc_check_index (gfc_expr *string, gfc_expr *substring, gfc_expr *back)\n+gfc_check_index (gfc_expr *string, gfc_expr *substring, gfc_expr *back,\n+\t\t gfc_expr *kind)\n {\n   if (type_check (string, 0, BT_CHARACTER) == FAILURE\n       || type_check (substring, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n \n-\n   if (back != NULL && type_check (back, 2, BT_LOGICAL) == FAILURE)\n     return FAILURE;\n \n+  if (kind_check (kind, 3, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+\t\t\t      \"with KIND argument at %L\",\n+\t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n+    return FAILURE;\n+\n   if (string->ts.kind != substring->ts.kind)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be the same \"\n@@ -1335,7 +1356,7 @@ gfc_check_kind (gfc_expr *x)\n \n \n try\n-gfc_check_lbound (gfc_expr *array, gfc_expr *dim)\n+gfc_check_lbound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n   if (array_check (array, 0) == FAILURE)\n     return FAILURE;\n@@ -1348,6 +1369,31 @@ gfc_check_lbound (gfc_expr *array, gfc_expr *dim)\n       if (dim_rank_check (dim, array, 1) == FAILURE)\n \treturn FAILURE;\n     }\n+\n+  if (kind_check (kind, 2, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+\t\t\t      \"with KIND argument at %L\",\n+\t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n+try\n+gfc_check_len_lentrim (gfc_expr *s, gfc_expr *kind)\n+{\n+  if (type_check (s, 0, BT_CHARACTER) == FAILURE)\n+    return FAILURE;\n+\n+  if (kind_check (kind, 1, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+\t\t\t      \"with KIND argument at %L\",\n+\t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n+    return FAILURE;\n+\n   return SUCCESS;\n }\n \n@@ -2160,7 +2206,7 @@ gfc_check_scale (gfc_expr *x, gfc_expr *i)\n \n \n try\n-gfc_check_scan (gfc_expr *x, gfc_expr *y, gfc_expr *z)\n+gfc_check_scan (gfc_expr *x, gfc_expr *y, gfc_expr *z, gfc_expr *kind)\n {\n   if (type_check (x, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -2171,6 +2217,13 @@ gfc_check_scan (gfc_expr *x, gfc_expr *y, gfc_expr *z)\n   if (z != NULL && type_check (z, 2, BT_LOGICAL) == FAILURE)\n     return FAILURE;\n \n+  if (kind_check (kind, 3, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+\t\t\t      \"with KIND argument at %L\",\n+\t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n+    return FAILURE;\n+\n   if (same_type_check (x, 0, y, 1) == FAILURE)\n     return FAILURE;\n \n@@ -2276,7 +2329,7 @@ gfc_check_sign (gfc_expr *a, gfc_expr *b)\n \n \n try\n-gfc_check_size (gfc_expr *array, gfc_expr *dim)\n+gfc_check_size (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n   if (array_check (array, 0) == FAILURE)\n     return FAILURE;\n@@ -2293,6 +2346,14 @@ gfc_check_size (gfc_expr *array, gfc_expr *dim)\n \treturn FAILURE;\n     }\n \n+  if (kind_check (kind, 2, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+\t\t\t      \"with KIND argument at %L\",\n+\t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n+    return FAILURE;\n+\n+\n   return SUCCESS;\n }\n \n@@ -2603,7 +2664,7 @@ gfc_check_transpose (gfc_expr *matrix)\n \n \n try\n-gfc_check_ubound (gfc_expr *array, gfc_expr *dim)\n+gfc_check_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n   if (array_check (array, 0) == FAILURE)\n     return FAILURE;\n@@ -2617,6 +2678,13 @@ gfc_check_ubound (gfc_expr *array, gfc_expr *dim)\n \treturn FAILURE;\n     }\n \n+  if (kind_check (kind, 2, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+\t\t\t      \"with KIND argument at %L\",\n+\t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n+    return FAILURE;\n+\n   return SUCCESS;\n }\n \n@@ -2641,7 +2709,7 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n \n \n try\n-gfc_check_verify (gfc_expr *x, gfc_expr *y, gfc_expr *z)\n+gfc_check_verify (gfc_expr *x, gfc_expr *y, gfc_expr *z, gfc_expr *kind)\n {\n   if (type_check (x, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -2652,6 +2720,13 @@ gfc_check_verify (gfc_expr *x, gfc_expr *y, gfc_expr *z)\n   if (z != NULL && type_check (z, 2, BT_LOGICAL) == FAILURE)\n     return FAILURE;\n \n+  if (kind_check (kind, 3, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+\t\t\t      \"with KIND argument at %L\",\n+\t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n+    return FAILURE;\n+\n   return SUCCESS;\n }\n "}, {"sha": "59006b2ee24c2deb7c936898b153820158ae75e4", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=5cda5098057c002cf332708f0e5b53bb35d49d76", "patch": "@@ -1256,9 +1256,11 @@ add_functions (void)\n \n   make_generic (\"cosh\", GFC_ISYM_COSH, GFC_STD_F77);\n \n-  add_sym_2 (\"count\", GFC_ISYM_COUNT, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n+  add_sym_3 (\"count\", GFC_ISYM_COUNT, CLASS_TRANSFORMATIONAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F95,\n \t     gfc_check_count, NULL, gfc_resolve_count,\n-\t     msk, BT_LOGICAL, dl, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL);\n+\t     msk, BT_LOGICAL, dl, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n+\t     kind, BT_INTEGER, di, OPTIONAL);\n \n   make_generic (\"count\", GFC_ISYM_COUNT, GFC_STD_F95);\n \n@@ -1484,9 +1486,10 @@ add_functions (void)\n \n   make_generic (\"huge\", GFC_ISYM_HUGE, GFC_STD_F95);\n \n-  add_sym_1 (\"iachar\", GFC_ISYM_IACHAR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n-\t     gfc_check_ichar_iachar, gfc_simplify_iachar, NULL,\n-\t     c, BT_CHARACTER, dc, REQUIRED);\n+  add_sym_2 (\"iachar\", GFC_ISYM_IACHAR, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F95,\n+\t     gfc_check_ichar_iachar, gfc_simplify_iachar, gfc_resolve_iachar,\n+\t     c, BT_CHARACTER, dc, REQUIRED, kind, BT_INTEGER, di, OPTIONAL);\n \n   make_generic (\"iachar\", GFC_ISYM_IACHAR, GFC_STD_F95);\n \n@@ -1526,9 +1529,10 @@ add_functions (void)\n \n   make_generic (\"ibset\", GFC_ISYM_IBSET, GFC_STD_F95);\n \n-  add_sym_1 (\"ichar\", GFC_ISYM_ICHAR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F77,\n+  add_sym_2 (\"ichar\", GFC_ISYM_ICHAR, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F77,\n \t     gfc_check_ichar_iachar, gfc_simplify_ichar, gfc_resolve_ichar,\n-\t     c, BT_CHARACTER, dc, REQUIRED);\n+\t     c, BT_CHARACTER, dc, REQUIRED, kind, BT_INTEGER, di, OPTIONAL);\n \n   make_generic (\"ichar\", GFC_ISYM_ICHAR, GFC_STD_F77);\n \n@@ -1551,10 +1555,11 @@ add_functions (void)\n \n   /* The resolution function for INDEX is called gfc_resolve_index_func\n      because the name gfc_resolve_index is already used in resolve.c.  */\n-  add_sym_3 (\"index\", GFC_ISYM_INDEX, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, di, GFC_STD_F77,\n+  add_sym_4 (\"index\", GFC_ISYM_INDEX, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_INTEGER, di, GFC_STD_F77,\n \t     gfc_check_index, gfc_simplify_index, gfc_resolve_index_func,\n \t     stg, BT_CHARACTER, dc, REQUIRED, ssg, BT_CHARACTER, dc, REQUIRED,\n-\t     bck, BT_LOGICAL, dl, OPTIONAL);\n+\t     bck, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL);\n \n   make_generic (\"index\", GFC_ISYM_INDEX, GFC_STD_F77);\n \n@@ -1660,21 +1665,25 @@ add_functions (void)\n \n   make_generic (\"kind\", GFC_ISYM_KIND, GFC_STD_F95);\n \n-  add_sym_2 (\"lbound\", GFC_ISYM_LBOUND, CLASS_INQUIRY, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n+  add_sym_3 (\"lbound\", GFC_ISYM_LBOUND, CLASS_INQUIRY, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F95,\n \t     gfc_check_lbound, gfc_simplify_lbound, gfc_resolve_lbound,\n-\t     ar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, di, OPTIONAL);\n+\t     ar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, di, OPTIONAL,\n+\t     kind, BT_INTEGER, di, OPTIONAL);\n \n   make_generic (\"lbound\", GFC_ISYM_LBOUND, GFC_STD_F95);\n \n-  add_sym_1 (\"len\", GFC_ISYM_LEN, CLASS_INQUIRY, ACTUAL_YES, BT_INTEGER, di, GFC_STD_F77,\n-\t     NULL, gfc_simplify_len, gfc_resolve_len,\n-\t     stg, BT_CHARACTER, dc, REQUIRED);\n+  add_sym_2 (\"len\", GFC_ISYM_LEN, CLASS_INQUIRY, ACTUAL_YES,\n+\t     BT_INTEGER, di, GFC_STD_F77,\n+\t     gfc_check_len_lentrim, gfc_simplify_len, gfc_resolve_len,\n+\t     stg, BT_CHARACTER, dc, REQUIRED, kind, BT_INTEGER, di, OPTIONAL);\n \n   make_generic (\"len\", GFC_ISYM_LEN, GFC_STD_F77);\n \n-  add_sym_1 (\"len_trim\", GFC_ISYM_LEN_TRIM, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n-\t     NULL, gfc_simplify_len_trim, gfc_resolve_len_trim,\n-\t     stg, BT_CHARACTER, dc, REQUIRED);\n+  add_sym_2 (\"len_trim\", GFC_ISYM_LEN_TRIM, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F95,\n+\t     gfc_check_len_lentrim, gfc_simplify_len_trim, gfc_resolve_len_trim,\n+\t     stg, BT_CHARACTER, dc, REQUIRED, kind, BT_INTEGER, di, OPTIONAL);\n \n   make_alias (\"lnblnk\", GFC_STD_GNU);\n \n@@ -2040,10 +2049,11 @@ add_functions (void)\n \n   make_generic (\"scale\", GFC_ISYM_SCALE, GFC_STD_F95);\n \n-  add_sym_3 (\"scan\", GFC_ISYM_SCAN, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n+  add_sym_4 (\"scan\", GFC_ISYM_SCAN, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F95,\n \t     gfc_check_scan, gfc_simplify_scan, gfc_resolve_scan,\n \t     stg, BT_CHARACTER, dc, REQUIRED, set, BT_CHARACTER, dc, REQUIRED,\n-\t     bck, BT_LOGICAL, dl, OPTIONAL);\n+\t     bck, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL);\n \n   make_generic (\"scan\", GFC_ISYM_SCAN, GFC_STD_F95);\n \n@@ -2136,9 +2146,11 @@ add_functions (void)\n \n   make_generic (\"sinh\", GFC_ISYM_SINH, GFC_STD_F77);\n \n-  add_sym_2 (\"size\", GFC_ISYM_SIZE, CLASS_INQUIRY, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n-\t     gfc_check_size, gfc_simplify_size, NULL,\n-\t     ar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL);\n+  add_sym_3 (\"size\", GFC_ISYM_SIZE, CLASS_INQUIRY, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F95,\n+\t     gfc_check_size, gfc_simplify_size, gfc_resolve_size,\n+\t     ar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n+\t     kind, BT_INTEGER, di, OPTIONAL);\n \n   make_generic (\"size\", GFC_ISYM_SIZE, GFC_STD_F95);\n \n@@ -2267,9 +2279,11 @@ add_functions (void)\n \n   make_generic (\"ttynam\", GFC_ISYM_TTYNAM, GFC_STD_GNU);\n \n-  add_sym_2 (\"ubound\", GFC_ISYM_UBOUND, CLASS_INQUIRY, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n+  add_sym_3 (\"ubound\", GFC_ISYM_UBOUND, CLASS_INQUIRY, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F95,\n \t     gfc_check_ubound, gfc_simplify_ubound, gfc_resolve_ubound,\n-\t     ar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL);\n+\t     ar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n+\t     kind, BT_INTEGER, di, OPTIONAL);\n \n   make_generic (\"ubound\", GFC_ISYM_UBOUND, GFC_STD_F95);\n \n@@ -2294,10 +2308,11 @@ add_functions (void)\n \n   make_generic (\"unpack\", GFC_ISYM_UNPACK, GFC_STD_F95);\n \n-  add_sym_3 (\"verify\", GFC_ISYM_VERIFY, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n+  add_sym_4 (\"verify\", GFC_ISYM_VERIFY, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F95,\n \t     gfc_check_verify, gfc_simplify_verify, gfc_resolve_verify,\n \t     stg, BT_CHARACTER, dc, REQUIRED, set, BT_CHARACTER, dc, REQUIRED,\n-\t     bck, BT_LOGICAL, dl, OPTIONAL);\n+\t     bck, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL);\n \n   make_generic (\"verify\", GFC_ISYM_VERIFY, GFC_STD_F95);\n     "}, {"sha": "79cf3e52951545ce1620d499c059ed51452d43d8", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=5cda5098057c002cf332708f0e5b53bb35d49d76", "patch": "@@ -44,7 +44,7 @@ try gfc_check_chdir (gfc_expr *);\n try gfc_check_chmod (gfc_expr *, gfc_expr *);\n try gfc_check_cmplx (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_complex (gfc_expr *, gfc_expr *);\n-try gfc_check_count (gfc_expr *, gfc_expr *);\n+try gfc_check_count (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_cshift (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_ctime (gfc_expr *);\n try gfc_check_dcmplx (gfc_expr *, gfc_expr *);\n@@ -69,10 +69,10 @@ try gfc_check_and (gfc_expr *, gfc_expr *);\n try gfc_check_ibclr (gfc_expr *, gfc_expr *);\n try gfc_check_ibits (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_ibset (gfc_expr *, gfc_expr *);\n-try gfc_check_ichar_iachar (gfc_expr *);\n+try gfc_check_ichar_iachar (gfc_expr *, gfc_expr *);\n try gfc_check_idnint (gfc_expr *);\n try gfc_check_ieor (gfc_expr *, gfc_expr *);\n-try gfc_check_index (gfc_expr *, gfc_expr *, gfc_expr *);\n+try gfc_check_index (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_int (gfc_expr *, gfc_expr *);\n try gfc_check_intconv (gfc_expr *);\n try gfc_check_ior (gfc_expr *, gfc_expr *);\n@@ -83,7 +83,8 @@ try gfc_check_ishft (gfc_expr *, gfc_expr *);\n try gfc_check_ishftc (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_kill (gfc_expr *, gfc_expr *);\n try gfc_check_kind (gfc_expr *);\n-try gfc_check_lbound (gfc_expr *, gfc_expr *);\n+try gfc_check_lbound (gfc_expr *, gfc_expr *, gfc_expr *);\n+try gfc_check_len_lentrim (gfc_expr *, gfc_expr *);\n try gfc_check_link (gfc_expr *, gfc_expr *);\n try gfc_check_loc (gfc_expr *);\n try gfc_check_logical (gfc_expr *, gfc_expr *);\n@@ -111,14 +112,14 @@ try gfc_check_rename (gfc_expr *, gfc_expr *);\n try gfc_check_repeat (gfc_expr *, gfc_expr *);\n try gfc_check_reshape (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_scale (gfc_expr *, gfc_expr *);\n-try gfc_check_scan (gfc_expr *, gfc_expr *, gfc_expr *);\n+try gfc_check_scan (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_second_sub (gfc_expr *);\n try gfc_check_secnds (gfc_expr *);\n try gfc_check_selected_int_kind (gfc_expr *);\n try gfc_check_selected_real_kind (gfc_expr *, gfc_expr *);\n try gfc_check_set_exponent (gfc_expr *, gfc_expr *);\n try gfc_check_shape (gfc_expr *);\n-try gfc_check_size (gfc_expr *, gfc_expr *);\n+try gfc_check_size (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_sign (gfc_expr *, gfc_expr *);\n try gfc_check_signal (gfc_expr *, gfc_expr *);\n try gfc_check_sizeof (gfc_expr *);\n@@ -131,11 +132,11 @@ try gfc_check_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_transpose (gfc_expr *);\n try gfc_check_trim (gfc_expr *);\n try gfc_check_ttynam (gfc_expr *);\n-try gfc_check_ubound (gfc_expr *, gfc_expr *);\n+try gfc_check_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_umask (gfc_expr *);\n try gfc_check_unlink (gfc_expr *);\n try gfc_check_unpack (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_verify (gfc_expr *, gfc_expr *, gfc_expr *);\n+try gfc_check_verify (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_x (gfc_expr *);\n \n \n@@ -221,14 +222,14 @@ gfc_expr *gfc_simplify_float (gfc_expr *);\n gfc_expr *gfc_simplify_floor (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_fraction (gfc_expr *);\n gfc_expr *gfc_simplify_huge (gfc_expr *);\n-gfc_expr *gfc_simplify_iachar (gfc_expr *);\n+gfc_expr *gfc_simplify_iachar (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_iand (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ibclr (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ibits (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ibset (gfc_expr *, gfc_expr *);\n-gfc_expr *gfc_simplify_ichar (gfc_expr *);\n+gfc_expr *gfc_simplify_ichar (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ieor (gfc_expr *, gfc_expr *);\n-gfc_expr *gfc_simplify_index (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_index (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_int (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_int2 (gfc_expr *);\n gfc_expr *gfc_simplify_int8 (gfc_expr *);\n@@ -239,9 +240,9 @@ gfc_expr *gfc_simplify_ior (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ishft (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ishftc (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_kind (gfc_expr *);\n-gfc_expr *gfc_simplify_lbound (gfc_expr *, gfc_expr *);\n-gfc_expr *gfc_simplify_len (gfc_expr *);\n-gfc_expr *gfc_simplify_len_trim (gfc_expr *);\n+gfc_expr *gfc_simplify_lbound (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_len (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_len_trim (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_lge (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_lgt (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_lle (gfc_expr *, gfc_expr *);\n@@ -274,15 +275,15 @@ gfc_expr *gfc_simplify_reshape (gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t\tgfc_expr *);\n gfc_expr *gfc_simplify_rrspacing (gfc_expr *);\n gfc_expr *gfc_simplify_scale (gfc_expr *, gfc_expr *);\n-gfc_expr *gfc_simplify_scan (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_scan (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_selected_int_kind (gfc_expr *);\n gfc_expr *gfc_simplify_selected_real_kind (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_set_exponent (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_sign (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_shape (gfc_expr *);\n gfc_expr *gfc_simplify_sin (gfc_expr *);\n gfc_expr *gfc_simplify_sinh (gfc_expr *);\n-gfc_expr *gfc_simplify_size (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_size (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_sngl (gfc_expr *);\n gfc_expr *gfc_simplify_spacing (gfc_expr *);\n gfc_expr *gfc_simplify_sqrt (gfc_expr *);\n@@ -291,8 +292,8 @@ gfc_expr *gfc_simplify_tanh (gfc_expr *);\n gfc_expr *gfc_simplify_tiny (gfc_expr *);\n gfc_expr *gfc_simplify_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_trim (gfc_expr *);\n-gfc_expr *gfc_simplify_ubound (gfc_expr *, gfc_expr *);\n-gfc_expr *gfc_simplify_verify (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_verify (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_xor (gfc_expr *, gfc_expr *);\n \n /* Constant conversion simplification.  */\n@@ -330,7 +331,7 @@ void gfc_resolve_complex (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_conjg (gfc_expr *, gfc_expr *);\n void gfc_resolve_cos (gfc_expr *, gfc_expr *);\n void gfc_resolve_cosh (gfc_expr *, gfc_expr *);\n-void gfc_resolve_count (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_count (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_cshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ctime (gfc_expr *, gfc_expr *);\n void gfc_resolve_dble (gfc_expr *, gfc_expr *);\n@@ -362,10 +363,12 @@ void gfc_resolve_iand (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ibclr (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ibits (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ibset (gfc_expr *, gfc_expr *, gfc_expr *);\n-void gfc_resolve_index_func (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_index_func (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t     gfc_expr *);\n void gfc_resolve_ierrno (gfc_expr *);\n void gfc_resolve_ieor (gfc_expr *, gfc_expr *, gfc_expr *);\n-void gfc_resolve_ichar (gfc_expr *, gfc_expr *);\n+void gfc_resolve_ichar (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_iachar (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_idnint (gfc_expr *, gfc_expr *);\n void gfc_resolve_int (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_int2 (gfc_expr *, gfc_expr *);\n@@ -378,9 +381,9 @@ void gfc_resolve_lshift (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ishft (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ishftc (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_kill (gfc_expr *, gfc_expr *, gfc_expr *);\n-void gfc_resolve_lbound (gfc_expr *, gfc_expr *, gfc_expr *);\n-void gfc_resolve_len (gfc_expr *, gfc_expr *);\n-void gfc_resolve_len_trim (gfc_expr *, gfc_expr *);\n+void gfc_resolve_lbound (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_len (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_len_trim (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_link (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_loc (gfc_expr *, gfc_expr *);\n void gfc_resolve_log (gfc_expr *, gfc_expr *);\n@@ -414,7 +417,8 @@ void gfc_resolve_reshape (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t  gfc_expr *);\n void gfc_resolve_rrspacing (gfc_expr *, gfc_expr *);\n void gfc_resolve_scale (gfc_expr *, gfc_expr *, gfc_expr *);\n-void gfc_resolve_scan (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_scan (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t       gfc_expr *);\n void gfc_resolve_second_sub (gfc_code *);\n void gfc_resolve_secnds (gfc_expr *, gfc_expr *);\n void gfc_resolve_set_exponent (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -423,6 +427,7 @@ void gfc_resolve_sign (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_signal (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_sin (gfc_expr *, gfc_expr *);\n void gfc_resolve_sinh (gfc_expr *, gfc_expr *);\n+void gfc_resolve_size (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_spacing (gfc_expr *, gfc_expr *);\n void gfc_resolve_spread (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_sqrt (gfc_expr *, gfc_expr *);\n@@ -439,11 +444,12 @@ void gfc_resolve_transfer (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_transpose (gfc_expr *, gfc_expr *);\n void gfc_resolve_trim (gfc_expr *, gfc_expr *);\n void gfc_resolve_ttynam (gfc_expr *, gfc_expr *);\n-void gfc_resolve_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_ubound (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_umask (gfc_expr *, gfc_expr *);\n void gfc_resolve_unlink (gfc_expr *, gfc_expr *);\n void gfc_resolve_unpack (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-void gfc_resolve_verify (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_verify (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t gfc_expr *);\n void gfc_resolve_xor (gfc_expr *, gfc_expr *, gfc_expr *);\n \n "}, {"sha": "f09246cc95e1b01ee3b5c8785e083d034619d38a", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 76, "deletions": 34, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=5cda5098057c002cf332708f0e5b53bb35d49d76", "patch": "@@ -2644,10 +2644,12 @@ Inverse function: @ref{ACOSH}\n \n @table @asis\n @item @emph{Description}:\n-@code{COUNT(MASK [, DIM])} counts the number of @code{.TRUE.} elements of\n-@var{MASK} along the dimension of @var{DIM}.  If @var{DIM} is omitted it is\n-taken to be @code{1}.  @var{DIM} is a scaler of type @code{INTEGER} in the\n-range of @math{1 /leq DIM /leq n)} where @math{n} is the rank of @var{MASK}.\n+\n+@code{COUNT(MASK [, DIM [, KIND]])} counts the number of @code{.TRUE.}\n+elements of @var{MASK} along the dimension of @var{DIM}.  If @var{DIM} is\n+omitted it is taken to be @code{1}.  @var{DIM} is a scaler of type\n+@code{INTEGER} in the range of @math{1 /leq DIM /leq n)} where @math{n}\n+is the rank of @var{MASK}.\n \n @item @emph{Standard}:\n F95 and later\n@@ -2656,17 +2658,21 @@ F95 and later\n Transformational function\n \n @item @emph{Syntax}:\n-@code{RESULT = COUNT(MASK [, DIM])}\n+@code{RESULT = COUNT(MASK [, DIM [, KIND]])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{MASK} @tab The type shall be @code{LOGICAL}.\n-@item @var{DIM}  @tab The type shall be @code{INTEGER}.\n+@item @var{DIM}  @tab (Optional) The type shall be @code{INTEGER}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n+                      expression indicating the kind parameter of\n+\t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER} with rank equal to that of\n-@var{MASK}.\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n+The result has a rank equal to that of @var{MASK}.\n \n @item @emph{Example}:\n @smallexample\n@@ -5112,16 +5118,19 @@ F95 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = IACHAR(C)}\n+@code{RESULT = IACHAR(C [, KIND])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{C} @tab Shall be a scalar @code{CHARACTER}, with @code{INTENT(IN)}\n+@item @var{C}    @tab Shall be a scalar @code{CHARACTER}, with @code{INTENT(IN)}\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n+                      expression indicating the kind parameter of\n+\t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER} and of the default integer\n-kind.\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n \n @item @emph{Example}:\n @smallexample\n@@ -5366,16 +5375,19 @@ F95 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = ICHAR(C)}\n+@code{RESULT = ICHAR(C [, KIND])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{C} @tab Shall be a scalar @code{CHARACTER}, with @code{INTENT(IN)}\n+@item @var{C}    @tab Shall be a scalar @code{CHARACTER}, with @code{INTENT(IN)}\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n+                      expression indicating the kind parameter of\n+\t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER} and of the default integer\n-kind.\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n \n @item @emph{Example}:\n @smallexample\n@@ -5552,7 +5564,7 @@ F77 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = INDEX(STRING, SUBSTRING [, BACK])}\n+@code{RESULT = INDEX(STRING, SUBSTRING [, BACK [, KIND]])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n@@ -5562,11 +5574,14 @@ Elemental function\n @code{INTENT(IN)}\n @item @var{BACK} @tab (Optional) Shall be a scalar @code{LOGICAL(*)}, with\n @code{INTENT(IN)}\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n+                      expression indicating the kind parameter of\n+\t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER} and of the default integer\n-kind.\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n \n @item @emph{See also}:\n @ref{SCAN}, @ref{VERIFY}\n@@ -6111,15 +6126,20 @@ F95 and later\n Inquiry function\n \n @item @emph{Syntax}:\n-@code{RESULT = LBOUND(ARRAY [, DIM])}\n+@code{RESULT = LBOUND(ARRAY [, DIM [, KIND]])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{ARRAY} @tab Shall be an array, of any type.\n @item @var{DIM} @tab (Optional) Shall be a scalar @code{INTEGER(*)}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n+                      expression indicating the kind parameter of\n+\t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n If @var{DIM} is absent, the result is an array of the lower bounds of\n @var{ARRAY}.  If @var{DIM} is present, the result is a scalar\n corresponding to the lower bound of the array along that dimension.  If\n@@ -6152,16 +6172,20 @@ F77 and later\n Inquiry function\n \n @item @emph{Syntax}:\n-@code{L = LEN(STRING)}\n+@code{L = LEN(STRING [, KIND])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{STRING} @tab Shall be a scalar or array of type\n @code{CHARACTER(*)}, with @code{INTENT(IN)}\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n+                      expression indicating the kind parameter of\n+\t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is an @code{INTEGER} of the default kind.\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n \n @item @emph{See also}:\n @ref{LEN_TRIM}, @ref{ADJUSTL}, @ref{ADJUSTR}\n@@ -6185,16 +6209,20 @@ F95 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = LEN_TRIM(STRING)}\n+@code{RESULT = LEN_TRIM(STRING [, KIND])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{STRING} @tab Shall be a scalar of type @code{CHARACTER(*)},\n with @code{INTENT(IN)}\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n+                      expression indicating the kind parameter of\n+\t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is an @code{INTEGER} of the default kind.\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n \n @item @emph{See also}:\n @ref{LEN}, @ref{ADJUSTL}, @ref{ADJUSTR}\n@@ -8788,18 +8816,21 @@ F95 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = SCAN(STRING, SET[, BACK])}\n+@code{RESULT = SCAN(STRING, SET[, BACK [, KIND]])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{STRING} @tab Shall be of type @code{CHARACTER(*)}.\n @item @var{SET}    @tab Shall be of type @code{CHARACTER(*)}.\n @item @var{BACK}   @tab (Optional) shall be of type @code{LOGICAL}.\n+@item @var{KIND}   @tab (Optional) An @code{INTEGER} initialization\n+                        expression indicating the kind parameter of\n+\t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER} and of the default\n-integer kind.\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n \n @item @emph{Example}:\n @smallexample\n@@ -9342,7 +9373,7 @@ F95 and later\n Inquiry function\n \n @item @emph{Syntax}:\n-@code{RESULT = SIZE(ARRAY[, DIM])}\n+@code{RESULT = SIZE(ARRAY[, DIM [, KIND]])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n@@ -9351,11 +9382,14 @@ a pointer it must be associated and allocatable arrays must be allocated.\n @item @var{DIM}   @tab (Optional) shall be a scalar of type @code{INTEGER} \n and its value shall be in the range from 1 to n, where n equals the rank \n of @var{ARRAY}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n+                      expression indicating the kind parameter of\n+\t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER} and of the default\n-integer kind.\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n \n @item @emph{Example}:\n @smallexample\n@@ -10367,15 +10401,20 @@ F95 and later\n Inquiry function\n \n @item @emph{Syntax}:\n-@code{RESULT = UBOUND(ARRAY [, DIM])}\n+@code{RESULT = UBOUND(ARRAY [, DIM [, KIND]])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{ARRAY} @tab Shall be an array, of any type.\n @item @var{DIM} @tab (Optional) Shall be a scalar @code{INTEGER(*)}.\n+@item @var{KIND}@tab (Optional) An @code{INTEGER} initialization\n+                     expression indicating the kind parameter of\n+\t\t     the result.\n @end multitable\n \n @item @emph{Return value}:\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n If @var{DIM} is absent, the result is an array of the upper bounds of\n @var{ARRAY}.  If @var{DIM} is present, the result is a scalar\n corresponding to the upper bound of the array along that dimension.  If\n@@ -10533,18 +10572,21 @@ F95 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = VERIFY(STRING, SET[, BACK])}\n+@code{RESULT = VERIFY(STRING, SET[, BACK [, KIND]])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{STRING} @tab Shall be of type @code{CHARACTER(*)}.\n @item @var{SET}    @tab Shall be of type @code{CHARACTER(*)}.\n @item @var{BACK}   @tab (Optional) shall be of type @code{LOGICAL}.\n+@item @var{KIND}   @tab (Optional) An @code{INTEGER} initialization\n+                        expression indicating the kind parameter of\n+\t\t        the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER} and of the default\n-integer kind.\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n \n @item @emph{Example}:\n @smallexample"}, {"sha": "e3186155f27aeed7759b2065e73d0643dc2c8d97", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 70, "deletions": 18, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=5cda5098057c002cf332708f0e5b53bb35d49d76", "patch": "@@ -520,10 +520,13 @@ gfc_resolve_cosh (gfc_expr *f, gfc_expr *x)\n \n \n void\n-gfc_resolve_count (gfc_expr *f, gfc_expr *mask, gfc_expr *dim)\n+gfc_resolve_count (gfc_expr *f, gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n {\n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = gfc_default_integer_kind;\n+  if (kind)\n+    f->ts.kind = mpz_get_si (kind->value.integer);\n+  else\n+    f->ts.kind = gfc_default_integer_kind;\n \n   if (dim != NULL)\n     {\n@@ -856,10 +859,25 @@ gfc_resolve_ibset (gfc_expr *f, gfc_expr *i, gfc_expr *pos ATTRIBUTE_UNUSED)\n \n \n void\n-gfc_resolve_ichar (gfc_expr *f, gfc_expr *c)\n+gfc_resolve_iachar (gfc_expr *f, gfc_expr *c, gfc_expr *kind)\n {\n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = gfc_default_integer_kind;\n+  if (kind)\n+    f->ts.kind = mpz_get_si (kind->value.integer);\n+  else\n+    f->ts.kind = gfc_default_integer_kind;\n+  f->value.function.name = gfc_get_string (\"__ichar_%d\", c->ts.kind);\n+}\n+\n+\n+void\n+gfc_resolve_ichar (gfc_expr *f, gfc_expr *c, gfc_expr *kind)\n+{\n+  f->ts.type = BT_INTEGER;\n+  if (kind)\n+    f->ts.kind = mpz_get_si (kind->value.integer);\n+  else\n+    f->ts.kind = gfc_default_integer_kind;\n   f->value.function.name = gfc_get_string (\"__ichar_%d\", c->ts.kind);\n }\n \n@@ -920,12 +938,16 @@ gfc_resolve_ior (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n \n void\n gfc_resolve_index_func (gfc_expr *f, gfc_expr *str,\n-\t\t\tgfc_expr *sub_str ATTRIBUTE_UNUSED, gfc_expr *back)\n+\t\t\tgfc_expr *sub_str ATTRIBUTE_UNUSED, gfc_expr *back,\n+\t\t\tgfc_expr *kind)\n {\n   gfc_typespec ts;\n \n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = gfc_default_integer_kind;\n+  if (kind)\n+    f->ts.kind = mpz_get_si (kind->value.integer);\n+  else\n+    f->ts.kind = gfc_default_integer_kind;\n \n   if (back && back->ts.kind != gfc_default_integer_kind)\n     {\n@@ -1057,12 +1079,15 @@ gfc_resolve_kill (gfc_expr *f, gfc_expr *p ATTRIBUTE_UNUSED,\n \n \n void\n-gfc_resolve_lbound (gfc_expr *f, gfc_expr *array, gfc_expr *dim)\n+gfc_resolve_lbound (gfc_expr *f, gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n   static char lbound[] = \"__lbound\";\n \n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = gfc_default_integer_kind;\n+  if (kind)\n+    f->ts.kind = mpz_get_si (kind->value.integer);\n+  else\n+    f->ts.kind = gfc_default_integer_kind;\n \n   if (dim == NULL)\n     {\n@@ -1076,21 +1101,27 @@ gfc_resolve_lbound (gfc_expr *f, gfc_expr *array, gfc_expr *dim)\n \n \n void\n-gfc_resolve_len (gfc_expr *f, gfc_expr *string)\n+gfc_resolve_len (gfc_expr *f, gfc_expr *string, gfc_expr *kind)\n {\n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = gfc_default_integer_kind;\n+  if (kind)\n+    f->ts.kind = mpz_get_si (kind->value.integer);\n+  else\n+    f->ts.kind = gfc_default_integer_kind;\n   f->value.function.name\n     = gfc_get_string (\"__len_%d_i%d\", string->ts.kind,\n \t\t      gfc_default_integer_kind);\n }\n \n \n void\n-gfc_resolve_len_trim (gfc_expr *f, gfc_expr *string)\n+gfc_resolve_len_trim (gfc_expr *f, gfc_expr *string, gfc_expr *kind)\n {\n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = gfc_default_integer_kind;\n+  if (kind)\n+    f->ts.kind = mpz_get_si (kind->value.integer);\n+  else\n+    f->ts.kind = gfc_default_integer_kind;\n   f->value.function.name = gfc_get_string (\"__len_trim%d\", string->ts.kind);\n }\n \n@@ -1776,10 +1807,13 @@ gfc_resolve_scale (gfc_expr *f, gfc_expr *x, gfc_expr *i)\n void\n gfc_resolve_scan (gfc_expr *f, gfc_expr *string,\n \t\t  gfc_expr *set ATTRIBUTE_UNUSED,\n-\t\t  gfc_expr *back ATTRIBUTE_UNUSED)\n+\t\t  gfc_expr *back ATTRIBUTE_UNUSED, gfc_expr *kind)\n {\n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = gfc_default_integer_kind;\n+  if (kind)\n+    f->ts.kind = mpz_get_si (kind->value.integer);\n+  else\n+    f->ts.kind = gfc_default_integer_kind;\n   f->value.function.name = gfc_get_string (\"__scan_%d\", string->ts.kind);\n }\n \n@@ -1872,6 +1906,18 @@ gfc_resolve_sinh (gfc_expr *f, gfc_expr *x)\n }\n \n \n+void\n+gfc_resolve_size (gfc_expr *f, gfc_expr *array ATTRIBUTE_UNUSED,\n+\t\t  gfc_expr *dim ATTRIBUTE_UNUSED, gfc_expr *kind)\n+{\n+  f->ts.type = BT_INTEGER;\n+  if (kind)\n+    f->ts.kind = mpz_get_si (kind->value.integer);\n+  else\n+    f->ts.kind = gfc_default_integer_kind;\n+}\n+\n+\n void\n gfc_resolve_spacing (gfc_expr *f, gfc_expr *x)\n {\n@@ -2265,12 +2311,15 @@ gfc_resolve_trim (gfc_expr *f, gfc_expr *string)\n \n \n void\n-gfc_resolve_ubound (gfc_expr *f, gfc_expr *array, gfc_expr *dim)\n+gfc_resolve_ubound (gfc_expr *f, gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n   static char ubound[] = \"__ubound\";\n \n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = gfc_default_integer_kind;\n+  if (kind)\n+    f->ts.kind = mpz_get_si (kind->value.integer);\n+  else\n+    f->ts.kind = gfc_default_integer_kind;\n \n   if (dim == NULL)\n     {\n@@ -2343,10 +2392,13 @@ gfc_resolve_unpack (gfc_expr *f, gfc_expr *vector, gfc_expr *mask,\n void\n gfc_resolve_verify (gfc_expr *f, gfc_expr *string,\n \t\t    gfc_expr *set ATTRIBUTE_UNUSED,\n-\t\t    gfc_expr *back ATTRIBUTE_UNUSED)\n+\t\t    gfc_expr *back ATTRIBUTE_UNUSED, gfc_expr *kind)\n {\n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = gfc_default_integer_kind;\n+  if (kind)\n+    f->ts.kind = mpz_get_si (kind->value.integer);\n+  else\n+    f->ts.kind = gfc_default_integer_kind;\n   f->value.function.name = gfc_get_string (\"__verify_%d\", string->ts.kind);\n }\n "}, {"sha": "c3c23cb921573364f3bb93b5051cd46ce216c426", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 82, "deletions": 41, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=5cda5098057c002cf332708f0e5b53bb35d49d76", "patch": "@@ -115,14 +115,12 @@ get_kind (bt type, gfc_expr *k, const char *name, int default_kind)\n     {\n       gfc_error (\"KIND parameter of %s at %L must be an initialization \"\n \t\t \"expression\", name, &k->where);\n-\n       return -1;\n     }\n \n   if (gfc_extract_int (k, &kind) != NULL\n       || gfc_validate_kind (type, kind, true) < 0)\n     {\n-\n       gfc_error (\"Invalid KIND parameter of %s at %L\", name, &k->where);\n       return -1;\n     }\n@@ -131,6 +129,20 @@ get_kind (bt type, gfc_expr *k, const char *name, int default_kind)\n }\n \n \n+/* Helper function to get an integer constant with a kind number given\n+   by an integer constant expression.  */\n+static gfc_expr *\n+int_expr_with_kind (int i, gfc_expr *kind, const char *name)\n+{\n+  gfc_expr *res = gfc_int_expr (i);\n+  res->ts.kind = get_kind (BT_INTEGER, kind, name, gfc_default_integer_kind); \n+  if (res->ts.kind == -1)\n+    return NULL;\n+  else\n+    return res;\n+}\n+\n+\n /* Converts an mpz_t signed variable into an unsigned one, assuming\n    two's complement representations and a binary width of bitsize.\n    The conversion is a no-op unless x is negative; otherwise, it can\n@@ -1198,7 +1210,7 @@ gfc_simplify_huge (gfc_expr *e)\n    systems that gfortran currently works on are ASCII.  */\n \n gfc_expr *\n-gfc_simplify_iachar (gfc_expr *e)\n+gfc_simplify_iachar (gfc_expr *e, gfc_expr *kind)\n {\n   gfc_expr *result;\n   int index;\n@@ -1218,7 +1230,9 @@ gfc_simplify_iachar (gfc_expr *e)\n     gfc_warning (\"Argument of IACHAR function at %L outside of range 0..127\",\n \t\t &e->where);\n \n-  result = gfc_int_expr (index);\n+  if ((result = int_expr_with_kind (index, kind, \"IACHAR\")) == NULL)\n+    return &gfc_bad_expr;\n+\n   result->where = e->where;\n \n   return range_check (result, \"IACHAR\");\n@@ -1380,7 +1394,7 @@ gfc_simplify_ibset (gfc_expr *x, gfc_expr *y)\n \n \n gfc_expr *\n-gfc_simplify_ichar (gfc_expr *e)\n+gfc_simplify_ichar (gfc_expr *e, gfc_expr *kind)\n {\n   gfc_expr *result;\n   int index;\n@@ -1399,7 +1413,9 @@ gfc_simplify_ichar (gfc_expr *e)\n   if (index < 0 || index > UCHAR_MAX)\n     gfc_internal_error(\"Argument of ICHAR at %L out of range\", &e->where);\n \n-  result = gfc_int_expr (index);\n+  if ((result = int_expr_with_kind (index, kind, \"ICHAR\")) == NULL)\n+    return &gfc_bad_expr;\n+\n   result->where = e->where;\n   return range_check (result, \"ICHAR\");\n }\n@@ -1422,7 +1438,7 @@ gfc_simplify_ieor (gfc_expr *x, gfc_expr *y)\n \n \n gfc_expr *\n-gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b)\n+gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b, gfc_expr *kind)\n {\n   gfc_expr *result;\n   int back, len, lensub;\n@@ -1436,8 +1452,11 @@ gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b)\n   else\n     back = 0;\n \n-  result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind,\n-\t\t\t\t&x->where);\n+  k = get_kind (BT_INTEGER, kind, \"INDEX\", gfc_default_integer_kind); \n+  if (k == -1)\n+    return &gfc_bad_expr;\n+\n+  result = gfc_constant_result (BT_INTEGER, k, &x->where);\n \n   len = x->value.character.length;\n   lensub = y->value.character.length;\n@@ -1938,9 +1957,11 @@ gfc_simplify_kind (gfc_expr *e)\n \n \n static gfc_expr *\n-simplify_bound_dim (gfc_expr *array, int d, int upper, gfc_array_spec *as)\n+simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n+\t\t    gfc_array_spec *as)\n {\n   gfc_expr *l, *u, *result;\n+  int k;\n \n   /* The last dimension of an assumed-size array is special.  */\n   if (d == as->rank && as->type == AS_ASSUMED_SIZE && !upper)\n@@ -1958,8 +1979,12 @@ simplify_bound_dim (gfc_expr *array, int d, int upper, gfc_array_spec *as)\n   if (l->expr_type != EXPR_CONSTANT || u->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind,\n-\t\t\t\t&array->where);\n+  k = get_kind (BT_INTEGER, kind, upper ? \"UBOUND\" : \"LBOUND\",\n+\t\tgfc_default_integer_kind); \n+  if (k == -1)\n+    return &gfc_bad_expr;\n+\n+  result = gfc_constant_result (BT_INTEGER, k, &array->where);\n \n   if (mpz_cmp (l->value.integer, u->value.integer) > 0)\n     {\n@@ -1983,7 +2008,7 @@ simplify_bound_dim (gfc_expr *array, int d, int upper, gfc_array_spec *as)\n \n \n static gfc_expr *\n-simplify_bound (gfc_expr *array, gfc_expr *dim, int upper)\n+simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n {\n   gfc_ref *ref;\n   gfc_array_spec *as;\n@@ -2039,6 +2064,7 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, int upper)\n       gfc_expr *bounds[GFC_MAX_DIMENSIONS];\n       gfc_expr *e;\n       gfc_constructor *head, *tail;\n+      int k;\n \n       /* UBOUND(ARRAY) is not valid for an assumed-size array.  */\n       if (upper && as->type == AS_ASSUMED_SIZE)\n@@ -2051,7 +2077,7 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, int upper)\n       /* Simplify the bounds for each dimension.  */\n       for (d = 0; d < array->rank; d++)\n \t{\n-\t  bounds[d] = simplify_bound_dim (array, d + 1, upper, as);\n+\t  bounds[d] = simplify_bound_dim (array, kind, d + 1, upper, as);\n \t  if (bounds[d] == NULL || bounds[d] == &gfc_bad_expr)\n \t    {\n \t      int j;\n@@ -2067,7 +2093,11 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, int upper)\n       e->where = array->where;\n       e->expr_type = EXPR_ARRAY;\n       e->ts.type = BT_INTEGER;\n-      e->ts.kind = gfc_default_integer_kind;\n+      k = get_kind (BT_INTEGER, kind, upper ? \"UBOUND\" : \"LBOUND\",\n+\t\t    gfc_default_integer_kind); \n+      if (k == -1)\n+\treturn &gfc_bad_expr;\n+      e->ts.kind = k;\n \n       /* The result is a rank 1 array; its size is the rank of the first\n \t argument to {L,U}BOUND.  */\n@@ -2110,27 +2140,30 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, int upper)\n \t  return &gfc_bad_expr;\n \t}\n \n-      return simplify_bound_dim (array, d, upper, as);\n+      return simplify_bound_dim (array, kind, d, upper, as);\n     }\n }\n \n \n gfc_expr *\n-gfc_simplify_lbound (gfc_expr *array, gfc_expr *dim)\n+gfc_simplify_lbound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n-  return simplify_bound (array, dim, 0);\n+  return simplify_bound (array, dim, kind, 0);\n }\n \n \n gfc_expr *\n-gfc_simplify_len (gfc_expr *e)\n+gfc_simplify_len (gfc_expr *e, gfc_expr *kind)\n {\n   gfc_expr *result;\n+  int k = get_kind (BT_INTEGER, kind, \"LEN\", gfc_default_integer_kind);\n+\n+  if (k == -1)\n+    return &gfc_bad_expr;\n \n   if (e->expr_type == EXPR_CONSTANT)\n     {\n-      result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind,\n-\t\t\t\t    &e->where);\n+      result = gfc_constant_result (BT_INTEGER, k, &e->where);\n       mpz_set_si (result->value.integer, e->value.character.length);\n       return range_check (result, \"LEN\");\n     }\n@@ -2139,8 +2172,7 @@ gfc_simplify_len (gfc_expr *e)\n       && e->ts.cl->length->expr_type == EXPR_CONSTANT\n       && e->ts.cl->length->ts.type == BT_INTEGER)\n     {\n-      result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind,\n-\t\t\t\t    &e->where);\n+      result = gfc_constant_result (BT_INTEGER, k, &e->where);\n       mpz_set (result->value.integer, e->ts.cl->length->value.integer);\n       return range_check (result, \"LEN\");\n     }\n@@ -2150,17 +2182,19 @@ gfc_simplify_len (gfc_expr *e)\n \n \n gfc_expr *\n-gfc_simplify_len_trim (gfc_expr *e)\n+gfc_simplify_len_trim (gfc_expr *e, gfc_expr *kind)\n {\n   gfc_expr *result;\n   int count, len, lentrim, i;\n+  int k = get_kind (BT_INTEGER, kind, \"LEN_TRIM\", gfc_default_integer_kind);\n+\n+  if (k == -1)\n+    return &gfc_bad_expr;\n \n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind,\n-\t\t\t\t&e->where);\n-\n+  result = gfc_constant_result (BT_INTEGER, k, &e->where);\n   len = e->value.character.length;\n \n   for (count = 0, i = 1; i <= len; i++)\n@@ -3323,12 +3357,16 @@ gfc_simplify_scale (gfc_expr *x, gfc_expr *i)\n \n \n gfc_expr *\n-gfc_simplify_scan (gfc_expr *e, gfc_expr *c, gfc_expr *b)\n+gfc_simplify_scan (gfc_expr *e, gfc_expr *c, gfc_expr *b, gfc_expr *kind)\n {\n   gfc_expr *result;\n   int back;\n   size_t i;\n   size_t indx, len, lenc;\n+  int k = get_kind (BT_INTEGER, kind, \"SCAN\", gfc_default_integer_kind);\n+\n+  if (k == -1)\n+    return &gfc_bad_expr;\n \n   if (e->expr_type != EXPR_CONSTANT || c->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -3338,8 +3376,7 @@ gfc_simplify_scan (gfc_expr *e, gfc_expr *c, gfc_expr *b)\n   else\n     back = 0;\n \n-  result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind,\n-\t\t\t\t&e->where);\n+  result = gfc_constant_result (BT_INTEGER, k, &e->where);\n \n   len = e->value.character.length;\n   lenc = c->value.character.length;\n@@ -3545,7 +3582,7 @@ gfc_simplify_shape (gfc_expr *source)\n \t{\n \t  mpz_set_ui (e->value.integer, n + 1);\n \n-\t  f = gfc_simplify_size (source, e);\n+\t  f = gfc_simplify_size (source, e, NULL);\n \t  gfc_free_expr (e);\n \t  if (f == NULL)\n \t    {\n@@ -3566,11 +3603,15 @@ gfc_simplify_shape (gfc_expr *source)\n \n \n gfc_expr *\n-gfc_simplify_size (gfc_expr *array, gfc_expr *dim)\n+gfc_simplify_size (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n   mpz_t size;\n   gfc_expr *result;\n   int d;\n+  int k = get_kind (BT_INTEGER, kind, \"SCAN\", gfc_default_integer_kind);\n+\n+  if (k == -1)\n+    return &gfc_bad_expr;\n \n   if (dim == NULL)\n     {\n@@ -3587,11 +3628,8 @@ gfc_simplify_size (gfc_expr *array, gfc_expr *dim)\n \treturn NULL;\n     }\n \n-  result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind,\n-\t\t\t\t&array->where);\n-\n+  result = gfc_constant_result (BT_INTEGER, k, &array->where);\n   mpz_set (result->value.integer, size);\n-\n   return result;\n }\n \n@@ -4028,19 +4066,23 @@ gfc_simplify_trim (gfc_expr *e)\n \n \n gfc_expr *\n-gfc_simplify_ubound (gfc_expr *array, gfc_expr *dim)\n+gfc_simplify_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n-  return simplify_bound (array, dim, 1);\n+  return simplify_bound (array, dim, kind, 1);\n }\n \n \n gfc_expr *\n-gfc_simplify_verify (gfc_expr *s, gfc_expr *set, gfc_expr *b)\n+gfc_simplify_verify (gfc_expr *s, gfc_expr *set, gfc_expr *b, gfc_expr *kind)\n {\n   gfc_expr *result;\n   int back;\n   size_t index, len, lenset;\n   size_t i;\n+  int k = get_kind (BT_INTEGER, kind, \"VERIFY\", gfc_default_integer_kind);\n+\n+  if (k == -1)\n+    return &gfc_bad_expr;\n \n   if (s->expr_type != EXPR_CONSTANT || set->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -4050,8 +4092,7 @@ gfc_simplify_verify (gfc_expr *s, gfc_expr *set, gfc_expr *b)\n   else\n     back = 0;\n \n-  result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind,\n-\t\t\t\t&s->where);\n+  result = gfc_constant_result (BT_INTEGER, k, &s->where);\n \n   len = s->value.character.length;\n   lenset = set->value.character.length;"}, {"sha": "e9b9480219049e435d9e1d2196b2b9a744f0e582", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=5cda5098057c002cf332708f0e5b53bb35d49d76", "patch": "@@ -1109,9 +1109,14 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n \t    isym->resolve.f2 (&e, &argexpr, NULL);\n \t  else\n \t    {\n-\t      /* All specific intrinsics take less than 4 arguments.  */\n-\t      gcc_assert (isym->formal->next->next->next == NULL);\n-\t      isym->resolve.f3 (&e, &argexpr, NULL, NULL);\n+\t      if (isym->formal->next->next->next == NULL)\n+\t\tisym->resolve.f3 (&e, &argexpr, NULL, NULL);\n+\t      else\n+\t\t{\n+\t\t  /* All specific intrinsics take less than 5 arguments.  */\n+\t\t  gcc_assert (isym->formal->next->next->next->next == NULL);\n+\t\t  isym->resolve.f4 (&e, &argexpr, NULL, NULL, NULL);\n+\t\t}\n \t    }\n \t}\n "}, {"sha": "c8e16462aa8fbd2319ea70cf1e550131b7ef29f5", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 11, "deletions": 79, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=5cda5098057c002cf332708f0e5b53bb35d49d76", "patch": "@@ -2759,7 +2759,8 @@ gfc_conv_intrinsic_len_trim (gfc_se * se, gfc_expr * expr)\n /* Returns the starting position of a substring within a string.  */\n \n static void\n-gfc_conv_intrinsic_index (gfc_se * se, gfc_expr * expr)\n+gfc_conv_intrinsic_index_scan_verify (gfc_se * se, gfc_expr * expr,\n+\t\t\t\t      tree function)\n {\n   tree logical4_type_node = gfc_get_logical_type (4);\n   tree type;\n@@ -2770,20 +2771,18 @@ gfc_conv_intrinsic_index (gfc_se * se, gfc_expr * expr)\n   num_args = gfc_intrinsic_argument_list_length (expr);\n   args = alloca (sizeof (tree) * 5);\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n+  gfc_conv_intrinsic_function_args (se, expr, args,\n+\t\t\t\t    num_args >= 5 ? 5 : num_args);\n   type = gfc_typenode_for_spec (&expr->ts);\n \n   if (num_args == 4)\n     args[4] = build_int_cst (logical4_type_node, 0);\n   else\n-    {\n-      gcc_assert (num_args == 5);\n-      args[4] = convert (logical4_type_node, args[4]);\n-    }\n+    args[4] = convert (logical4_type_node, args[4]);\n \n-  fndecl = build_addr (gfor_fndecl_string_index, current_function_decl);\n-  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_string_index)),\n-\t\t\t       fndecl, 5, args);\n+  fndecl = build_addr (function, current_function_decl);\n+  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (function)), fndecl,\n+\t\t\t       5, args);\n   se->expr = convert (type, se->expr);\n \n }\n@@ -3471,73 +3470,6 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n }\n \n \n-/* Scan a string for any one of the characters in a set of characters.  */\n-\n-static void\n-gfc_conv_intrinsic_scan (gfc_se * se, gfc_expr * expr)\n-{\n-  tree logical4_type_node = gfc_get_logical_type (4);\n-  tree type;\n-  tree fndecl;\n-  tree *args;\n-  unsigned int num_args;\n-\n-  num_args = gfc_intrinsic_argument_list_length (expr);\n-  args = alloca (sizeof (tree) * 5);\n-\n-  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n-  type = gfc_typenode_for_spec (&expr->ts);\n-\n-  if (num_args == 4)\n-    args[4] = build_int_cst (logical4_type_node, 0);\n-  else\n-    {\n-      gcc_assert (num_args == 5);\n-      args[4] = convert (logical4_type_node, args[4]);\n-    }\n-\n-  fndecl = build_addr (gfor_fndecl_string_scan, current_function_decl);\n-  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_string_scan)),\n-\t\t\t       fndecl, 5, args);\n-  se->expr = convert (type, se->expr);\n-}\n-\n-\n-/* Verify that a set of characters contains all the characters in a string\n-   by identifying the position of the first character in a string of\n-   characters that does not appear in a given set of characters.  */\n-\n-static void\n-gfc_conv_intrinsic_verify (gfc_se * se, gfc_expr * expr)\n-{\n-  tree logical4_type_node = gfc_get_logical_type (4);\n-  tree type;\n-  tree fndecl;\n-  tree *args;\n-  unsigned int num_args;\n-\n-  num_args = gfc_intrinsic_argument_list_length (expr);\n-  args = alloca (sizeof (tree) * 5);\n-\n-  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n-  type = gfc_typenode_for_spec (&expr->ts);\n-\n-  if (num_args == 4)\n-    args[4] = build_int_cst (logical4_type_node, 0);\n-  else\n-    {\n-      gcc_assert (num_args == 5);\n-      args[4] = convert (logical4_type_node, args[4]);\n-    }\n-\n-  fndecl = build_addr (gfor_fndecl_string_verify, current_function_decl);\n-  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_string_verify)),\n-\t\t\t       fndecl, 5, args);\n-\n-  se->expr = convert (type, se->expr);\n-}\n-\n-\n /* Generate code for SELECTED_INT_KIND (R) intrinsic function.  */\n \n static void\n@@ -3862,11 +3794,11 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_SCAN:\n-      gfc_conv_intrinsic_scan (se, expr);\n+      gfc_conv_intrinsic_index_scan_verify (se, expr, gfor_fndecl_string_scan);\n       break;\n \n     case GFC_ISYM_VERIFY:\n-      gfc_conv_intrinsic_verify (se, expr);\n+      gfc_conv_intrinsic_index_scan_verify (se, expr, gfor_fndecl_string_verify);\n       break;\n \n     case GFC_ISYM_ALLOCATED:\n@@ -4029,7 +3961,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_INDEX:\n-      gfc_conv_intrinsic_index (se, expr);\n+      gfc_conv_intrinsic_index_scan_verify (se, expr, gfor_fndecl_string_index);\n       break;\n \n     case GFC_ISYM_IOR:"}, {"sha": "b2ae17c1acf7e0c1cfbefff745a8eb2f2ee71224", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5cda5098057c002cf332708f0e5b53bb35d49d76", "patch": "@@ -1,3 +1,9 @@\n+2007-08-12  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/29600\n+\t* gfortran.dg/intrinsics_kind_argument_1.f90: New test.\n+\t* gfortran.dg/pure_dummy_length_1.f90: Adapt to new error wording.\n+\n 2007-08-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/32937"}, {"sha": "b02ff749aed6b44d5376e5522c0c29adbff7fb39", "filename": "gcc/testsuite/gfortran.dg/intrinsics_kind_argument_1.f90", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsics_kind_argument_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsics_kind_argument_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsics_kind_argument_1.f90?ref=5cda5098057c002cf332708f0e5b53bb35d49d76", "patch": "@@ -0,0 +1,54 @@\n+! Test various intrinsics who take a kind argument since Fortran 2003\n+!\n+! { dg-do compile }\n+!\n+program test\n+  integer, parameter :: k = kind(0)\n+  logical :: l_array(4,5)\n+  character(len=1) :: s\n+  character(len=20) :: t\n+\n+  l_array = .true.\n+  s = \"u\"\n+  t = \"bartutugee\"\n+\n+  call check (count(l_array, kind=k), 20)\n+  if (any (count(l_array, 2, kind=k) /= 5)) call abort\n+  if (any (count(l_array, kind=k, dim=2) /= 5)) call abort\n+\n+  call check (iachar (s, k), 117)\n+  call check (iachar (s, kind=k), 117)\n+  call check (ichar (s, k), 117)\n+  call check (ichar (s, kind=k), 117)\n+\n+  call check (index (t, s, .true., k), 7)\n+  call check (index (t, s, kind=k, back=.false.), 5)\n+\n+  if (any (lbound (l_array, kind=k) /= 1)) call abort\n+  call check (lbound (l_array, 1), 1)\n+  call check (lbound (l_array, 1, kind=k), 1)\n+\n+  if (any (ubound (l_array, kind=k) /= (/4, 5/))) call abort\n+  call check (ubound (l_array, 1), 4)\n+  call check (ubound (l_array, 1, kind=k), 4)\n+\n+  call check (len(t, k), 20)\n+  call check (len_trim(t, k), 10)\n+\n+  call check (scan (t, s, .true., k), 7)\n+  call check (scan (t, s, kind=k, back=.false.), 5)\n+\n+  call check (size (l_array, 1, kind=k), 4)\n+  call check (size (l_array, kind=k), 20)\n+\n+  call check (verify (t, s, .true., k), 20)\n+  call check (verify (t, s, kind=k, back=.false.), 1)\n+\n+contains\n+\n+  subroutine check(x,y)\n+    integer, intent(in) :: x, y\n+    if (x /= y) call abort\n+  end subroutine check\n+\n+end program test"}, {"sha": "c1bc17224311d281366e9a43ac0a5f731d6f3a35", "filename": "gcc/testsuite/gfortran.dg/pure_dummy_length_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ftestsuite%2Fgfortran.dg%2Fpure_dummy_length_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cda5098057c002cf332708f0e5b53bb35d49d76/gcc%2Ftestsuite%2Fgfortran.dg%2Fpure_dummy_length_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpure_dummy_length_1.f90?ref=5cda5098057c002cf332708f0e5b53bb35d49d76", "patch": "@@ -10,7 +10,7 @@ pure function equals(self, &     ! { dg-error \"must be INTENT\" }\n          character(*), intent(in) :: string\r\n          integer(4), intent(in) :: ignore_case\r\n          integer(4) :: same\r\n-         if (len (self) < 1) return ! { dg-error \"Type of argument\" }\r\n+         if (len (self) < 1) return ! { dg-error \"must be CHARACTER\" }\r\n          same = 1\r\n    end function\r\n \r"}]}