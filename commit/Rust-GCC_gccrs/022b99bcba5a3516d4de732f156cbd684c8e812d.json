{"sha": "022b99bcba5a3516d4de732f156cbd684c8e812d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIyYjk5YmNiYTVhMzUxNmQ0ZGU3MzJmMTU2Y2JkNjg0YzhlODEyZA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-11T19:48:34Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-13T07:34:49Z"}, "message": "Move vrp_prop before vrp_folder.\n\ngcc/ChangeLog:\n\n\t* tree-vrp.c (class vrp_prop): Move entire class...\n\t(class vrp_folder): ...before here.", "tree": {"sha": "77741810258eceeb400273a2b66c450bac99e346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77741810258eceeb400273a2b66c450bac99e346"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/022b99bcba5a3516d4de732f156cbd684c8e812d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/022b99bcba5a3516d4de732f156cbd684c8e812d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/022b99bcba5a3516d4de732f156cbd684c8e812d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/022b99bcba5a3516d4de732f156cbd684c8e812d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cc52bc85e90ed71e67c443f14137f2fcf6adf3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc52bc85e90ed71e67c443f14137f2fcf6adf3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc52bc85e90ed71e67c443f14137f2fcf6adf3c"}], "stats": {"total": 200, "additions": 100, "deletions": 100}, "files": [{"sha": "15267e3d878aff279ffaded89db9d162eb53a2ad", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022b99bcba5a3516d4de732f156cbd684c8e812d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022b99bcba5a3516d4de732f156cbd684c8e812d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=022b99bcba5a3516d4de732f156cbd684c8e812d", "patch": "@@ -3814,106 +3814,6 @@ vrp_asserts::remove_range_assertions ()\n       }\n }\n \n-class vrp_folder : public substitute_and_fold_engine\n-{\n- public:\n-  vrp_folder (vr_values *v)\n-    : substitute_and_fold_engine (/* Fold all stmts.  */ true),\n-      m_vr_values (v), simplifier (v)\n-    {  }\n-  bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n-\n-  tree value_of_expr (tree name, gimple *stmt) OVERRIDE\n-    {\n-      return m_vr_values->value_of_expr (name, stmt);\n-    }\n-  class vr_values *m_vr_values;\n-\n-private:\n-  bool fold_predicate_in (gimple_stmt_iterator *);\n-  /* Delegators.  */\n-  tree vrp_evaluate_conditional (tree_code code, tree op0,\n-\t\t\t\t tree op1, gimple *stmt)\n-    { return simplifier.vrp_evaluate_conditional (code, op0, op1, stmt); }\n-  bool simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n-    { return simplifier.simplify (gsi); }\n-\n-  simplify_using_ranges simplifier;\n-};\n-\n-/* If the statement pointed by SI has a predicate whose value can be\n-   computed using the value range information computed by VRP, compute\n-   its value and return true.  Otherwise, return false.  */\n-\n-bool\n-vrp_folder::fold_predicate_in (gimple_stmt_iterator *si)\n-{\n-  bool assignment_p = false;\n-  tree val;\n-  gimple *stmt = gsi_stmt (*si);\n-\n-  if (is_gimple_assign (stmt)\n-      && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison)\n-    {\n-      assignment_p = true;\n-      val = vrp_evaluate_conditional (gimple_assign_rhs_code (stmt),\n-\t\t\t\t      gimple_assign_rhs1 (stmt),\n-\t\t\t\t      gimple_assign_rhs2 (stmt),\n-\t\t\t\t      stmt);\n-    }\n-  else if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n-    val = vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n-\t\t\t\t    gimple_cond_lhs (cond_stmt),\n-\t\t\t\t    gimple_cond_rhs (cond_stmt),\n-\t\t\t\t    stmt);\n-  else\n-    return false;\n-\n-  if (val)\n-    {\n-      if (assignment_p)\n-        val = fold_convert (gimple_expr_type (stmt), val);\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"Folding predicate \");\n-\t  print_gimple_expr (dump_file, stmt, 0);\n-\t  fprintf (dump_file, \" to \");\n-\t  print_generic_expr (dump_file, val);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n-      if (is_gimple_assign (stmt))\n-\tgimple_assign_set_rhs_from_tree (si, val);\n-      else\n-\t{\n-\t  gcc_assert (gimple_code (stmt) == GIMPLE_COND);\n-\t  gcond *cond_stmt = as_a <gcond *> (stmt);\n-\t  if (integer_zerop (val))\n-\t    gimple_cond_make_false (cond_stmt);\n-\t  else if (integer_onep (val))\n-\t    gimple_cond_make_true (cond_stmt);\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Callback for substitute_and_fold folding the stmt at *SI.  */\n-\n-bool\n-vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n-{\n-  if (fold_predicate_in (si))\n-    return true;\n-\n-  return simplify_stmt_using_ranges (si);\n-}\n-\n class vrp_prop : public ssa_propagation_engine\n {\n public:\n@@ -4152,6 +4052,106 @@ vrp_prop::finalize ()\n     }\n }\n \n+class vrp_folder : public substitute_and_fold_engine\n+{\n+ public:\n+  vrp_folder (vr_values *v)\n+    : substitute_and_fold_engine (/* Fold all stmts.  */ true),\n+      m_vr_values (v), simplifier (v)\n+    {  }\n+  bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n+\n+  tree value_of_expr (tree name, gimple *stmt) OVERRIDE\n+    {\n+      return m_vr_values->value_of_expr (name, stmt);\n+    }\n+  class vr_values *m_vr_values;\n+\n+private:\n+  bool fold_predicate_in (gimple_stmt_iterator *);\n+  /* Delegators.  */\n+  tree vrp_evaluate_conditional (tree_code code, tree op0,\n+\t\t\t\t tree op1, gimple *stmt)\n+    { return simplifier.vrp_evaluate_conditional (code, op0, op1, stmt); }\n+  bool simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n+    { return simplifier.simplify (gsi); }\n+\n+  simplify_using_ranges simplifier;\n+};\n+\n+/* If the statement pointed by SI has a predicate whose value can be\n+   computed using the value range information computed by VRP, compute\n+   its value and return true.  Otherwise, return false.  */\n+\n+bool\n+vrp_folder::fold_predicate_in (gimple_stmt_iterator *si)\n+{\n+  bool assignment_p = false;\n+  tree val;\n+  gimple *stmt = gsi_stmt (*si);\n+\n+  if (is_gimple_assign (stmt)\n+      && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison)\n+    {\n+      assignment_p = true;\n+      val = vrp_evaluate_conditional (gimple_assign_rhs_code (stmt),\n+\t\t\t\t      gimple_assign_rhs1 (stmt),\n+\t\t\t\t      gimple_assign_rhs2 (stmt),\n+\t\t\t\t      stmt);\n+    }\n+  else if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n+    val = vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+\t\t\t\t    gimple_cond_lhs (cond_stmt),\n+\t\t\t\t    gimple_cond_rhs (cond_stmt),\n+\t\t\t\t    stmt);\n+  else\n+    return false;\n+\n+  if (val)\n+    {\n+      if (assignment_p)\n+        val = fold_convert (gimple_expr_type (stmt), val);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Folding predicate \");\n+\t  print_gimple_expr (dump_file, stmt, 0);\n+\t  fprintf (dump_file, \" to \");\n+\t  print_generic_expr (dump_file, val);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      if (is_gimple_assign (stmt))\n+\tgimple_assign_set_rhs_from_tree (si, val);\n+      else\n+\t{\n+\t  gcc_assert (gimple_code (stmt) == GIMPLE_COND);\n+\t  gcond *cond_stmt = as_a <gcond *> (stmt);\n+\t  if (integer_zerop (val))\n+\t    gimple_cond_make_false (cond_stmt);\n+\t  else if (integer_onep (val))\n+\t    gimple_cond_make_true (cond_stmt);\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Callback for substitute_and_fold folding the stmt at *SI.  */\n+\n+bool\n+vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n+{\n+  if (fold_predicate_in (si))\n+    return true;\n+\n+  return simplify_stmt_using_ranges (si);\n+}\n+\n /* Blocks which have more than one predecessor and more than\n    one successor present jump threading opportunities, i.e.,\n    when the block is reached from a specific predecessor, we"}]}