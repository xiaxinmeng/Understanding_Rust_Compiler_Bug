{"sha": "6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYzMGYxZjEzY2NmYjMyZjhhNDVkYWEzZTZhYzQ1OTlkOTgxM2I4YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-03-01T01:49:00Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-03-01T01:49:00Z"}, "message": "tree.h (TARGET_EXPR_SLOT, [...]): New macros.\n\n        * tree.h (TARGET_EXPR_SLOT, TARGET_EXPR_INITIAL): New macros.\n        (TARGET_EXPR_CLEANUP): New macro.\ncp/\n        * except.c: Don't include decl.h or obstack.h.  Do include\n        tree-inline.h.\n        (build_throw): Destroy temporaries from the thrown\n        expression before calling __cxa_throw.  Construct a thrown\n        temporary directly into the exception object.\n        (stabilize_throw_expr): New function.\n        (wrap_cleanups_r): New function.\n        * tree.c (stabilize_expr): New function.\n        * init.c (build_init): New function.\n        * Make-lang.in (cp/except.o): Adjust .h deps.\n\nFrom-SVN: r50177", "tree": {"sha": "b629fbdbb8ced39d7c5c023b8e9b14061bff1de5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b629fbdbb8ced39d7c5c023b8e9b14061bff1de5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e38ff265dab5f9cf6bb7cf00db5c5dce04b43cad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38ff265dab5f9cf6bb7cf00db5c5dce04b43cad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e38ff265dab5f9cf6bb7cf00db5c5dce04b43cad"}], "stats": {"total": 235, "additions": 197, "deletions": 38}, "files": [{"sha": "2066310cc3640b0b63458b063fe7bd7c902c2cc2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a", "patch": "@@ -1,3 +1,8 @@\n+2002-03-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree.h (TARGET_EXPR_SLOT, TARGET_EXPR_INITIAL): New macros.\n+\t(TARGET_EXPR_CLEANUP): New macro.\n+\n 2002-02-28  Steve Ellcey  <sje@cup.hp.com>\n \n \t* doc/rtl.texi (SUBREG_PROMOTED_UNSIGNED_P): Change definition\n@@ -78,7 +83,7 @@\n \t(STARTFILE_SPEC): Add 64 bit files.\n \t(ENDFILE_SPEC): Likewise.\n \n-2002-02-25  Jason Merrill  <jason@redhat.com>\n+2002-02-28  Jason Merrill  <jason@redhat.com>\n \n \t* c-decl.c (finish_function): Only warn about missing return\n \tstatement with -Wreturn-type."}, {"sha": "540e8749d449385ac7277f52d3e7c81db8b335fa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a", "patch": "@@ -1,3 +1,16 @@\n+2002-03-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* except.c: Don't include decl.h or obstack.h.  Do include\n+\ttree-inline.h.\n+\t(build_throw): Destroy temporaries from the thrown\n+\texpression before calling __cxa_throw.  Construct a thrown \n+\ttemporary directly into the exception object.\n+\t(stabilize_throw_expr): New function.\n+\t(wrap_cleanups_r): New function.\n+\t* tree.c (stabilize_expr): New function.\n+\t* init.c (build_init): New function.\n+\t* Make-lang.in (cp/except.o): Adjust .h deps.\n+\n 2002-02-28  Jason Merrill  <jason@redhat.com>\n \n \t* search.c (lookup_base_r): Don't clear is_non_public just because"}, {"sha": "1e721b6ac5665859dc5e5e8e69a18f000d552928", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a", "patch": "@@ -277,7 +277,7 @@ cp/tree.o: cp/tree.c $(CXX_TREE_H) flags.h toplev.h $(GGC_H) $(RTL_H) \\\n cp/ptree.o: cp/ptree.c $(CXX_TREE_H) $(SYSTEM_H)\n cp/rtti.o: cp/rtti.c $(CXX_TREE_H) flags.h toplev.h\n cp/except.o: cp/except.c $(CXX_TREE_H) flags.h $(RTL_H) except.h toplev.h \\\n-  cp/cfns.h $(EXPR_H) libfuncs.h cp/decl.h $(OBSTACK_H)\n+  cp/cfns.h $(EXPR_H) libfuncs.h tree-inline.h\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(RTL_H) flags.h $(EXPR_H) toplev.h \\\n   except.h $(TM_P_H)\n cp/pt.o: cp/pt.c $(CXX_TREE_H) cp/decl.h cp/parse.h cp/lex.h toplev.h \\"}, {"sha": "8cbbfa916cb4a464b6e8819c7bf573204858d420", "filename": "gcc/cp/except.c", "status": "modified", "additions": 119, "deletions": 36, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a", "patch": "@@ -35,6 +35,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n+#include \"tree-inline.h\"\n \n static void push_eh_cleanup PARAMS ((tree));\n static tree prepare_eh_type PARAMS ((tree));\n@@ -46,15 +47,14 @@ static void push_eh_cleanup PARAMS ((tree));\n static bool decl_is_java_type PARAMS ((tree decl, int err));\n static void initialize_handler_parm PARAMS ((tree, tree));\n static tree do_allocate_exception PARAMS ((tree));\n+static tree stabilize_throw_expr PARAMS ((tree, tree *));\n+static tree wrap_cleanups_r PARAMS ((tree *, int *, void *));\n static int complete_ptr_ref_or_void_ptr_p PARAMS ((tree, tree));\n static bool is_admissible_throw_operand PARAMS ((tree));\n static int can_convert_eh PARAMS ((tree, tree));\n static void check_handlers_1 PARAMS ((tree, tree));\n static tree cp_protect_cleanup_actions PARAMS ((void));\n \n-#include \"decl.h\"\n-#include \"obstack.h\"\n-\n /* Sets up all the global eh stuff that needs to be initialized at the\n    start of compilation.  */\n \n@@ -518,7 +518,7 @@ do_allocate_exception (type)\n \n #if 0\n /* Call __cxa_free_exception from a cleanup.  This is never invoked\n-   directly.  */\n+   directly, but see the comment for stabilize_throw_expr.  */\n \n static tree\n do_free_exception (ptr)\n@@ -540,6 +540,89 @@ do_free_exception (ptr)\n }\n #endif\n \n+/* Wrap all cleanups for TARGET_EXPRs in MUST_NOT_THROW_EXPR.\n+   Called from build_throw via walk_tree_without_duplicates.  */\n+\n+static tree\n+wrap_cleanups_r (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  tree exp = *tp;\n+  tree cleanup;\n+\n+  /* Don't walk into types.  */\n+  if (TYPE_P (exp))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+  if (TREE_CODE (exp) != TARGET_EXPR)\n+    return NULL_TREE;\n+\n+  cleanup = TARGET_EXPR_CLEANUP (exp);\n+  if (cleanup)\n+    {\n+      cleanup = build1 (MUST_NOT_THROW_EXPR, TREE_TYPE (cleanup), cleanup);\n+      TARGET_EXPR_CLEANUP (exp) = cleanup;\n+    }\n+\n+  /* Keep iterating.  */\n+  return NULL_TREE;\n+}\n+\n+/* Like stabilize_expr, but specifically for a thrown expression.  When\n+   throwing a temporary class object, we want to construct it directly into\n+   the thrown exception, so we look past the TARGET_EXPR and stabilize the\n+   arguments of the call instead.\n+\n+   The case where EXP is a call to a function returning a class is a bit of\n+   a grey area in the standard; it's unclear whether or not it should be\n+   allowed to throw.  I'm going to say no, as that allows us to optimize\n+   this case without worrying about deallocating the exception object if it\n+   does.  The alternatives would be either not optimizing this case, or\n+   wrapping the initialization in a TRY_CATCH_EXPR to call do_free_exception\n+   rather than in a MUST_NOT_THROW_EXPR, for this case only.  */\n+\n+static tree\n+stabilize_throw_expr (exp, initp)\n+     tree exp;\n+     tree *initp;\n+{\n+  tree init_expr;\n+\n+  if (TREE_CODE (exp) == TARGET_EXPR\n+      && TREE_CODE (TARGET_EXPR_INITIAL (exp)) == AGGR_INIT_EXPR\n+      && flag_elide_constructors)\n+    {\n+      tree aggr_init = AGGR_INIT_EXPR_CHECK (TARGET_EXPR_INITIAL (exp));\n+      tree args = TREE_OPERAND (aggr_init, 1);\n+      tree newargs = NULL_TREE;\n+      tree *p = &newargs;\n+\n+      init_expr = void_zero_node;\n+      for (; args; args = TREE_CHAIN (args))\n+\t{\n+\t  tree arg_init_expr;\n+\t  tree newarg = stabilize_expr (TREE_VALUE (args), &arg_init_expr);\n+\n+\t  if (arg_init_expr != void_zero_node)\n+\t    init_expr = build (COMPOUND_EXPR, void_type_node, arg_init_expr, init_expr);\n+\t  *p = tree_cons (NULL_TREE, newarg, NULL_TREE);\n+\t  p = &TREE_CHAIN (*p);\n+\t}\n+      TREE_OPERAND (aggr_init, 1) = newargs;\n+    }\n+  else\n+    {\n+      exp = stabilize_expr (exp, &init_expr);\n+    }\n+\n+  *initp = init_expr;\n+  return exp;\n+}\n+\n /* Build a throw expression.  */\n \n tree\n@@ -585,10 +668,9 @@ build_throw (exp)\n     {\n       tree throw_type;\n       tree cleanup;\n-      tree stmt_expr;\n-      tree compound_stmt;\n       tree object, ptr;\n       tree tmp;\n+      tree temp_expr, allocate_expr;\n \n       fn = get_identifier (\"__cxa_throw\");\n       if (IDENTIFIER_GLOBAL_VALUE (fn))\n@@ -614,8 +696,6 @@ build_throw (exp)\n \t  fn = push_throw_library_fn (fn, tmp);\n \t}\n \n-      begin_init_stmts (&stmt_expr, &compound_stmt);\n-\n       /* throw expression */\n       /* First, decay it.  */\n       exp = decay_conversion (exp);\n@@ -633,37 +713,40 @@ build_throw (exp)\n \t the call to __cxa_allocate_exception first (which doesn't\n \t matter, since it can't throw).  */\n \n-      my_friendly_assert (stmts_are_full_exprs_p () == 1, 19990926);\n-\n-      /* Store the throw expression into a temp.  This can be less\n-\t efficient than storing it into the allocated space directly, but\n-\t if we allocated the space first we would have to deal with\n-\t cleaning it up if evaluating this expression throws.  */\n-      if (TREE_SIDE_EFFECTS (exp))\n-\t{\n-\t  tmp = create_temporary_var (TREE_TYPE (exp));\n-\t  DECL_INITIAL (tmp) = exp;\n-\t  cp_finish_decl (tmp, exp, NULL_TREE, LOOKUP_ONLYCONVERTING);\n-\t  exp = tmp;\n-\t}\n+      /* Pre-evaluate the thrown expression first, since if we allocated\n+\t the space first we would have to deal with cleaning it up if\n+\t evaluating this expression throws.  */\n+      exp = stabilize_throw_expr (exp, &temp_expr);\n \n       /* Allocate the space for the exception.  */\n-      ptr = create_temporary_var (ptr_type_node);\n-      DECL_REGISTER (ptr) = 1;\n-      cp_finish_decl (ptr, NULL_TREE, NULL_TREE, LOOKUP_ONLYCONVERTING);\n-      tmp = do_allocate_exception (TREE_TYPE (exp));\n-      tmp = build_modify_expr (ptr, INIT_EXPR, tmp);\n-      finish_expr_stmt (tmp);\n-\n+      allocate_expr = do_allocate_exception (TREE_TYPE (exp));\n+      allocate_expr = get_target_expr (allocate_expr);\n+      ptr = TARGET_EXPR_SLOT (allocate_expr);\n       object = build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (exp)), ptr);\n       object = build_indirect_ref (object, NULL);\n \n-      exp = build_modify_expr (object, INIT_EXPR, exp);\n+      /* And initialize the exception object.  */\n+      exp = build_init (object, exp, LOOKUP_ONLYCONVERTING);\n       if (exp == error_mark_node)\n-\terror (\"  in thrown expression\");\n+\t{\n+\t  error (\"  in thrown expression\");\n+\t  return error_mark_node;\n+\t}\n \n       exp = build1 (MUST_NOT_THROW_EXPR, TREE_TYPE (exp), exp);\n-      finish_expr_stmt (exp);\n+      /* Prepend the allocation.  */\n+      exp = build (COMPOUND_EXPR, TREE_TYPE (exp), allocate_expr, exp);\n+      if (temp_expr != void_zero_node)\n+\t{\n+\t  /* Prepend the calculation of the throw expression.  Also, force\n+\t     any cleanups from the expression to be evaluated here so that\n+\t     we don't have to do them during unwinding.  But first wrap\n+\t     them in MUST_NOT_THROW_EXPR, since they are run after the\n+\t     exception object is initialized.  */\n+\t  walk_tree_without_duplicates (&temp_expr, wrap_cleanups_r, 0);\n+\t  exp = build (COMPOUND_EXPR, TREE_TYPE (exp), temp_expr, exp);\n+\t  exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);\n+\t}\n \n       throw_type = build_eh_type_type (prepare_eh_type (TREE_TYPE (object)));\n \n@@ -686,13 +769,11 @@ build_throw (exp)\n       tmp = tree_cons (NULL_TREE, cleanup, NULL_TREE);\n       tmp = tree_cons (NULL_TREE, throw_type, tmp);\n       tmp = tree_cons (NULL_TREE, ptr, tmp);\n-      tmp = build_function_call (fn, tmp);\n-\n       /* ??? Indicate that this function call throws throw_type.  */\n+      tmp = build_function_call (fn, tmp);\n \n-      finish_expr_stmt (tmp);\n-\n-      exp = finish_init_stmts (stmt_expr, compound_stmt);\n+      /* Tack on the initialization stuff.  */\n+      exp = build (COMPOUND_EXPR, TREE_TYPE (tmp), exp, tmp);\n     }\n   else\n     {\n@@ -708,6 +789,8 @@ build_throw (exp)\n \t    (fn, build_function_type (void_type_node, void_list_node));\n \t}\n \n+      /* ??? Indicate that this function call allows exceptions of the type\n+\t of the enclosing catch block (if known).  */\t \n       exp = build_function_call (fn, NULL_TREE);\n     }\n "}, {"sha": "7eaafc99354376173896c297f578859f2250ed66", "filename": "gcc/cp/init.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a", "patch": "@@ -1201,6 +1201,26 @@ build_aggr_init (exp, init, flags)\n   return stmt_expr;\n }\n \n+/* Like build_aggr_init, but not just for aggregates.  */\n+\n+tree\n+build_init (decl, init, flags)\n+     tree decl, init;\n+     int flags;\n+{\n+  tree expr;\n+\n+  if (IS_AGGR_TYPE (TREE_TYPE (decl))\n+      || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+    expr = build_aggr_init (decl, init, flags);\n+  else\n+    {\n+      expr = build (INIT_EXPR, TREE_TYPE (decl), decl, init);\n+      TREE_SIDE_EFFECTS (expr) = 1;\n+    }\n+  return expr;\n+}\n+\n static void\n expand_default_init (binfo, true_exp, exp, init, flags)\n      tree binfo;"}, {"sha": "a49a2dcc6646ae25abbd71a1d58d7b3532b4400d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a", "patch": "@@ -2497,3 +2497,36 @@ decl_linkage (decl)\n   /* Everything else has internal linkage.  */\n   return lk_internal;\n }\n+\f\n+/* EXP is an expression that we want to pre-evaluate.  Returns via INITP an\n+   expression to perform the pre-evaluation, and returns directly an\n+   expression to use the precalculated result.  */\n+\n+tree\n+stabilize_expr (exp, initp)\n+     tree exp;\n+     tree *initp;\n+{\n+  tree init_expr;\n+\n+  if (!TREE_SIDE_EFFECTS (exp))\n+    {\n+      init_expr = void_zero_node;\n+    }\n+  else if (!real_lvalue_p (exp)\n+\t   || !TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (exp)))\n+    {\n+      init_expr = get_target_expr (exp);\n+      exp = TARGET_EXPR_SLOT (init_expr);\n+    }\n+  else\n+    {\n+      exp = build_unary_op (ADDR_EXPR, exp, 1);\n+      init_expr = get_target_expr (exp);\n+      exp = TARGET_EXPR_SLOT (init_expr);\n+      exp = build_indirect_ref (exp, 0);\n+    }\n+\n+  *initp = init_expr;\n+  return exp;\n+}"}, {"sha": "b13fc53cdb5397a69cce7035a03f76bc957266ac", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6f30f1f13ccfb32f8a45daa3e6ac4599d9813b8a", "patch": "@@ -868,6 +868,11 @@ struct tree_vec\n #define EXPR_WFL_SET_LINECOL(NODE, LINE, COL) \\\n   (EXPR_WFL_LINECOL(NODE) = ((LINE) << 12) | ((COL) & 0xfff))\n \n+/* In a TARGET_EXPR node.  */\n+#define TARGET_EXPR_SLOT(NODE) TREE_OPERAND (TARGET_EXPR_CHECK (NODE), 0)\n+#define TARGET_EXPR_INITIAL(NODE) TREE_OPERAND (TARGET_EXPR_CHECK (NODE), 1)\n+#define TARGET_EXPR_CLEANUP(NODE) TREE_OPERAND (TARGET_EXPR_CHECK (NODE), 2)\n+\n struct tree_exp\n {\n   struct tree_common common;"}]}