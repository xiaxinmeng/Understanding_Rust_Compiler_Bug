{"sha": "0191520b2d2267b4a8a898ceb4d4682d730ee2e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE5MTUyMGIyZDIyNjdiNGE4YTg5OGNlYjRkNDY4MmQ3MzBlZTJlMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@twiddle.net", "date": "2019-06-05T18:16:18Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2019-06-05T18:16:18Z"}, "message": "alpha.c (direct_return): Move down after struct machine_function definition...\n\n\t* config/alpha/alpha.c (direct_return): Move down after\n\tstruct machine_function definition; use saved frame_size;\n\treturn bool.\n\t(struct machine_function): Add sa_mask, sa_size, frame_size.\n\t(alpha_sa_mask, alpha_sa_size, compute_frame_size): Merge into ...\n\t(alpha_compute_frame_layout): ... new function.\n\t(TARGET_COMPUTE_FRAME_LAYOUT): New.\n\t(alpha_initial_elimination_offset): Use saved sa_size.\n\t(alpha_vms_initial_elimination_offset): Likewise.\n\t(alpha_vms_can_eliminate): Remove alpha_sa_size call.\n\t(alpha_expand_prologue): Use saved frame data.  Merge integer\n\tand fp register save loops.\n\t(alpha_expand_epilogue): Likewise.\n\t(alpha_start_function): Use saved frame data.\n\t* config/alpha/alpha-protos.h (direct_return): Update.\n\t(alpha_sa_size): Remove.\n\nFrom-SVN: r271970", "tree": {"sha": "90d5c06330733f077dc1ebefcab342c979ccdfda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90d5c06330733f077dc1ebefcab342c979ccdfda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0191520b2d2267b4a8a898ceb4d4682d730ee2e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0191520b2d2267b4a8a898ceb4d4682d730ee2e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0191520b2d2267b4a8a898ceb4d4682d730ee2e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0191520b2d2267b4a8a898ceb4d4682d730ee2e2/comments", "author": {"login": "rth7680", "id": 2529319, "node_id": "MDQ6VXNlcjI1MjkzMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2529319?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rth7680", "html_url": "https://github.com/rth7680", "followers_url": "https://api.github.com/users/rth7680/followers", "following_url": "https://api.github.com/users/rth7680/following{/other_user}", "gists_url": "https://api.github.com/users/rth7680/gists{/gist_id}", "starred_url": "https://api.github.com/users/rth7680/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rth7680/subscriptions", "organizations_url": "https://api.github.com/users/rth7680/orgs", "repos_url": "https://api.github.com/users/rth7680/repos", "events_url": "https://api.github.com/users/rth7680/events{/privacy}", "received_events_url": "https://api.github.com/users/rth7680/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6f0926e644cf63547f70194f7830d5ce63211a86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f0926e644cf63547f70194f7830d5ce63211a86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f0926e644cf63547f70194f7830d5ce63211a86"}], "stats": {"total": 315, "additions": 128, "deletions": 187}, "files": [{"sha": "00ab0d9ecd70d60a57719b8597faa2187faa582a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0191520b2d2267b4a8a898ceb4d4682d730ee2e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0191520b2d2267b4a8a898ceb4d4682d730ee2e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0191520b2d2267b4a8a898ceb4d4682d730ee2e2", "patch": "@@ -1,3 +1,22 @@\n+2019-06-05  Richard Henderson  <rth@twiddle.net>\n+\n+\t* config/alpha/alpha.c (direct_return): Move down after\n+\tstruct machine_function definition; use saved frame_size;\n+\treturn bool.\n+\t(struct machine_function): Add sa_mask, sa_size, frame_size.\n+\t(alpha_sa_mask, alpha_sa_size, compute_frame_size): Merge into ...\n+\t(alpha_compute_frame_layout): ... new function.\n+\t(TARGET_COMPUTE_FRAME_LAYOUT): New.\n+\t(alpha_initial_elimination_offset): Use saved sa_size.\n+\t(alpha_vms_initial_elimination_offset): Likewise.\n+\t(alpha_vms_can_eliminate): Remove alpha_sa_size call.\n+\t(alpha_expand_prologue): Use saved frame data.  Merge integer\n+\tand fp register save loops.\n+\t(alpha_expand_epilogue): Likewise.\n+\t(alpha_start_function): Use saved frame data.\n+\t* config/alpha/alpha-protos.h (direct_return): Update.\n+\t(alpha_sa_size): Remove.\n+\n 2019-06-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* fold-const.c (extract_muldiv_1) <PLUS_EXPR>: Do not distribute a"}, {"sha": "7d340927c58dcb37cb9f9e550a26c3f8d938c34c", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0191520b2d2267b4a8a898ceb4d4682d730ee2e2/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0191520b2d2267b4a8a898ceb4d4682d730ee2e2/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=0191520b2d2267b4a8a898ceb4d4682d730ee2e2", "patch": "@@ -21,9 +21,8 @@ extern int alpha_next_sequence_number;\n \n extern void literal_section (void);\n extern int zap_mask (HOST_WIDE_INT);\n-extern int direct_return (void);\n+extern bool direct_return (void);\n \n-extern int alpha_sa_size (void);\n extern HOST_WIDE_INT alpha_initial_elimination_offset (unsigned int,\n \t\t\t\t\t\t       unsigned int);\n extern void alpha_expand_prologue (void);"}, {"sha": "db17f7c06e2570d988cf7e3718b7f7f9a4cc3b7a", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 108, "deletions": 185, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0191520b2d2267b4a8a898ceb4d4682d730ee2e2/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0191520b2d2267b4a8a898ceb4d4682d730ee2e2/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=0191520b2d2267b4a8a898ceb4d4682d730ee2e2", "patch": "@@ -731,19 +731,6 @@ alpha_vector_mode_supported_p (machine_mode mode)\n   return mode == V8QImode || mode == V4HImode || mode == V2SImode;\n }\n \n-/* Return 1 if this function can directly return via $26.  */\n-\n-int\n-direct_return (void)\n-{\n-  return (TARGET_ABI_OSF\n-\t  && reload_completed\n-\t  && alpha_sa_size () == 0\n-\t  && get_frame_size () == 0\n-\t  && crtl->outgoing_args_size == 0\n-\t  && crtl->args.pretend_args_size == 0);\n-}\n-\n /* Return the TLS model to use for SYMBOL.  */\n \n static enum tls_model\n@@ -4840,6 +4827,10 @@ struct GTY(()) alpha_links;\n \n struct GTY(()) machine_function\n {\n+  unsigned HOST_WIDE_INT sa_mask;\n+  HOST_WIDE_INT sa_size;\n+  HOST_WIDE_INT frame_size;\n+\n   /* For flag_reorder_blocks_and_partition.  */\n   rtx gp_save_rtx;\n \n@@ -7271,83 +7262,59 @@ static int vms_save_fp_regno;\n /* Register number used to reference objects off our PV.  */\n static int vms_base_regno;\n \n-/* Compute register masks for saved registers.  */\n-\n+/* Compute register masks for saved registers, register save area size,\n+   and total frame size.  */\n static void\n-alpha_sa_mask (unsigned long *imaskP, unsigned long *fmaskP)\n+alpha_compute_frame_layout (void)\n {\n-  unsigned long imask = 0;\n-  unsigned long fmask = 0;\n-  unsigned int i;\n+  unsigned HOST_WIDE_INT sa_mask = 0;\n+  HOST_WIDE_INT frame_size;\n+  int sa_size;\n \n   /* When outputting a thunk, we don't have valid register life info,\n      but assemble_start_function wants to output .frame and .mask\n      directives.  */\n-  if (cfun->is_thunk)\n+  if (!cfun->is_thunk)\n     {\n-      *imaskP = 0;\n-      *fmaskP = 0;\n-      return;\n-    }\n-\n-  if (TARGET_ABI_OPEN_VMS && alpha_procedure_type == PT_STACK)\n-    imask |= (1UL << HARD_FRAME_POINTER_REGNUM);\n+      if (TARGET_ABI_OPEN_VMS && alpha_procedure_type == PT_STACK)\n+\tsa_mask |= HOST_WIDE_INT_1U << HARD_FRAME_POINTER_REGNUM;\n \n-  /* One for every register we have to save.  */\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (! fixed_regs[i] && ! call_used_regs[i]\n-\t&& df_regs_ever_live_p (i) && i != REG_RA)\n-      {\n-\tif (i < 32)\n-\t  imask |= (1UL << i);\n-\telse\n-\t  fmask |= (1UL << (i - 32));\n-      }\n+      /* One for every register we have to save.  */\n+      for (unsigned i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (! fixed_regs[i] && ! call_used_regs[i]\n+\t    && df_regs_ever_live_p (i) && i != REG_RA)\n+\t  sa_mask |= HOST_WIDE_INT_1U << i;\n \n-  /* We need to restore these for the handler.  */\n-  if (crtl->calls_eh_return)\n-    {\n-      for (i = 0; ; ++i)\n+      /* We need to restore these for the handler.  */\n+      if (crtl->calls_eh_return)\n \t{\n-\t  unsigned regno = EH_RETURN_DATA_REGNO (i);\n-\t  if (regno == INVALID_REGNUM)\n-\t    break;\n-\t  imask |= 1UL << regno;\n+\t  for (unsigned i = 0; ; ++i)\n+\t    {\n+\t      unsigned regno = EH_RETURN_DATA_REGNO (i);\n+\t      if (regno == INVALID_REGNUM)\n+\t\tbreak;\n+\t      sa_mask |= HOST_WIDE_INT_1U << regno;\n+\t    }\n \t}\n-    }\n-\n-  /* If any register spilled, then spill the return address also.  */\n-  /* ??? This is required by the Digital stack unwind specification\n-     and isn't needed if we're doing Dwarf2 unwinding.  */\n-  if (imask || fmask || alpha_ra_ever_killed ())\n-    imask |= (1UL << REG_RA);\n-\n-  *imaskP = imask;\n-  *fmaskP = fmask;\n-}\n \n-int\n-alpha_sa_size (void)\n-{\n-  unsigned long mask[2];\n-  int sa_size = 0;\n-  int i, j;\n-\n-  alpha_sa_mask (&mask[0], &mask[1]);\n+      /* If any register spilled, then spill the return address also.  */\n+      /* ??? This is required by the Digital stack unwind specification\n+\t and isn't needed if we're doing Dwarf2 unwinding.  */\n+      if (sa_mask || alpha_ra_ever_killed ())\n+\tsa_mask |= HOST_WIDE_INT_1U << REG_RA;\n+    }\n \n-  for (j = 0; j < 2; ++j)\n-    for (i = 0; i < 32; ++i)\n-      if ((mask[j] >> i) & 1)\n-\tsa_size++;\n+  sa_size = popcount_hwi(sa_mask);\n+  frame_size = get_frame_size ();\n \n   if (TARGET_ABI_OPEN_VMS)\n     {\n       /* Start with a stack procedure if we make any calls (REG_RA used), or\n \t need a frame pointer, with a register procedure if we otherwise need\n \t at least a slot, and with a null procedure in other cases.  */\n-      if ((mask[0] >> REG_RA) & 1 || frame_pointer_needed)\n+      if ((sa_mask >> REG_RA) & 1 || frame_pointer_needed)\n \talpha_procedure_type = PT_STACK;\n-      else if (get_frame_size() != 0)\n+      else if (frame_size != 0)\n \talpha_procedure_type = PT_REGISTER;\n       else\n \talpha_procedure_type = PT_NULL;\n@@ -7371,12 +7338,15 @@ alpha_sa_size (void)\n \n       /* If we want to copy PV into FP, we need to find some register\n \t in which to save FP.  */\n-\n       vms_save_fp_regno = -1;\n       if (vms_base_regno == HARD_FRAME_POINTER_REGNUM)\n-\tfor (i = 0; i < 32; i++)\n-\t  if (! fixed_regs[i] && call_used_regs[i] && ! df_regs_ever_live_p (i))\n-\t    vms_save_fp_regno = i;\n+\tfor (unsigned i = 0; i < 32; i++)\n+\t  if (! fixed_regs[i] && call_used_regs[i]\n+\t      && ! df_regs_ever_live_p (i))\n+\t    {\n+\t      vms_save_fp_regno = i;\n+\t      break;\n+\t    }\n \n       /* A VMS condition handler requires a stack procedure in our\n \t implementation. (not required by the calling standard).  */\n@@ -7401,8 +7371,34 @@ alpha_sa_size (void)\n       if (sa_size & 1)\n \tsa_size++;\n     }\n+  sa_size *= 8;\n+\n+  if (TARGET_ABI_OPEN_VMS)\n+    frame_size = ALPHA_ROUND (sa_size\n+\t\t\t      + (alpha_procedure_type == PT_STACK ? 8 : 0)\n+\t\t\t      + frame_size\n+\t\t\t      + crtl->args.pretend_args_size);\n+  else\n+    frame_size = (ALPHA_ROUND (crtl->outgoing_args_size)\n+\t\t  + sa_size\n+\t\t  + ALPHA_ROUND (frame_size + crtl->args.pretend_args_size));\n \n-  return sa_size * 8;\n+  cfun->machine->sa_mask = sa_mask;\n+  cfun->machine->sa_size = sa_size;\n+  cfun->machine->frame_size = frame_size;\n+}\n+\n+#undef  TARGET_COMPUTE_FRAME_LAYOUT\n+#define TARGET_COMPUTE_FRAME_LAYOUT  alpha_compute_frame_layout\n+\n+/* Return 1 if this function can directly return via $26.  */\n+\n+bool\n+direct_return (void)\n+{\n+  return (TARGET_ABI_OSF\n+\t  && reload_completed\n+\t  && cfun->machine->frame_size == 0);\n }\n \n /* Define the offset between two registers, one to be eliminated,\n@@ -7414,7 +7410,7 @@ alpha_initial_elimination_offset (unsigned int from,\n {\n   HOST_WIDE_INT ret;\n \n-  ret = alpha_sa_size ();\n+  ret = cfun->machine->sa_size;\n   ret += ALPHA_ROUND (crtl->outgoing_args_size);\n \n   switch (from)\n@@ -7442,9 +7438,6 @@ alpha_initial_elimination_offset (unsigned int from,\n static bool\n alpha_vms_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n {\n-  /* We need the alpha_procedure_type to decide. Evaluate it now.  */\n-  alpha_sa_size ();\n-\n   switch (alpha_procedure_type)\n     {\n     case PT_NULL:\n@@ -7474,7 +7467,7 @@ alpha_vms_initial_elimination_offset (unsigned int from, unsigned int to)\n      on the proper computations and will need the register save area size\n      in most cases.  */\n \n-  HOST_WIDE_INT sa_size = alpha_sa_size ();\n+  HOST_WIDE_INT sa_size = cfun->machine->sa_size;\n \n   /* PT_NULL procedures have no frame of their own and we only allow\n      elimination to the stack pointer. This is the argument pointer and we\n@@ -7706,24 +7699,6 @@ emit_frame_store (unsigned int regno, rtx base_reg,\n   emit_frame_store_1 (reg, base_reg, frame_bias, base_ofs, reg);\n }\n \n-/* Compute the frame size.  SIZE is the size of the \"naked\" frame\n-   and SA_SIZE is the size of the register save area.  */\n-\n-static HOST_WIDE_INT\n-compute_frame_size (HOST_WIDE_INT size, HOST_WIDE_INT sa_size)\n-{\n-  if (TARGET_ABI_OPEN_VMS)\n-    return ALPHA_ROUND (sa_size \n-\t\t\t+ (alpha_procedure_type == PT_STACK ? 8 : 0)\n-\t\t\t+ size\n-\t\t\t+ crtl->args.pretend_args_size);\n-  else\n-    return ALPHA_ROUND (crtl->outgoing_args_size)\n-\t   + sa_size\n-\t   + ALPHA_ROUND (size\n-\t\t\t  + crtl->args.pretend_args_size);\n-}\n-\n /* Write function prologue.  */\n \n /* On vms we have two kinds of functions:\n@@ -7745,22 +7720,17 @@ void\n alpha_expand_prologue (void)\n {\n   /* Registers to save.  */\n-  unsigned long imask = 0;\n-  unsigned long fmask = 0;\n+  unsigned HOST_WIDE_INT sa_mask = cfun->machine->sa_mask;\n   /* Stack space needed for pushing registers clobbered by us.  */\n-  HOST_WIDE_INT sa_size, sa_bias;\n+  HOST_WIDE_INT sa_size = cfun->machine->sa_size;\n   /* Complete stack size needed.  */\n-  HOST_WIDE_INT frame_size;\n+  HOST_WIDE_INT frame_size = cfun->machine->frame_size;\n   /* Probed stack size; it additionally includes the size of\n      the \"reserve region\" if any.  */\n-  HOST_WIDE_INT probed_size;\n+  HOST_WIDE_INT probed_size, sa_bias;\n   /* Offset from base reg to register save area.  */\n   HOST_WIDE_INT reg_offset;\n   rtx sa_reg;\n-  int i;\n-\n-  sa_size = alpha_sa_size ();\n-  frame_size = compute_frame_size (get_frame_size (), sa_size);\n \n   if (flag_stack_usage_info)\n     current_function_static_stack_size = frame_size;\n@@ -7770,8 +7740,6 @@ alpha_expand_prologue (void)\n   else\n     reg_offset = ALPHA_ROUND (crtl->outgoing_args_size);\n \n-  alpha_sa_mask (&imask, &fmask);\n-\n   /* Emit an insn to reload GP, if needed.  */\n   if (TARGET_ABI_OSF)\n     {\n@@ -7910,29 +7878,15 @@ alpha_expand_prologue (void)\n   if (TARGET_ABI_OPEN_VMS && alpha_procedure_type == PT_STACK)\n     emit_frame_store (REG_PV, stack_pointer_rtx, 0, 0);\n \n-  /* Save register RA next.  */\n-  if (imask & (1UL << REG_RA))\n+  /* Save register RA next, followed by any other registers\n+     that need to be saved.  */\n+  for (unsigned i = REG_RA; sa_mask != 0; i = ctz_hwi(sa_mask))\n     {\n-      emit_frame_store (REG_RA, sa_reg, sa_bias, reg_offset);\n-      imask &= ~(1UL << REG_RA);\n+      emit_frame_store (i, sa_reg, sa_bias, reg_offset);\n       reg_offset += 8;\n+      sa_mask &= ~(HOST_WIDE_INT_1U << i);\n     }\n \n-  /* Now save any other registers required to be saved.  */\n-  for (i = 0; i < 31; i++)\n-    if (imask & (1UL << i))\n-      {\n-\temit_frame_store (i, sa_reg, sa_bias, reg_offset);\n-\treg_offset += 8;\n-      }\n-\n-  for (i = 0; i < 31; i++)\n-    if (fmask & (1UL << i))\n-      {\n-\temit_frame_store (i+32, sa_reg, sa_bias, reg_offset);\n-\treg_offset += 8;\n-      }\n-\n   if (TARGET_ABI_OPEN_VMS)\n     {\n       /* Register frame procedures save the fp.  */\n@@ -8019,14 +7973,11 @@ void\n alpha_start_function (FILE *file, const char *fnname,\n \t\t      tree decl ATTRIBUTE_UNUSED)\n {\n-  unsigned long imask = 0;\n-  unsigned long fmask = 0;\n-  /* Stack space needed for pushing registers clobbered by us.  */\n-  HOST_WIDE_INT sa_size;\n+  unsigned long imask, fmask;\n   /* Complete stack size needed.  */\n-  unsigned HOST_WIDE_INT frame_size;\n+  HOST_WIDE_INT frame_size = cfun->machine->frame_size;\n   /* The maximum debuggable frame size.  */\n-  unsigned HOST_WIDE_INT max_frame_size = 1UL << 31;\n+  const HOST_WIDE_INT max_frame_size = HOST_WIDE_INT_1 << 31;\n   /* Offset from base reg to register save area.  */\n   HOST_WIDE_INT reg_offset;\n   char *entry_label = (char *) alloca (strlen (fnname) + 6);\n@@ -8038,15 +7989,14 @@ alpha_start_function (FILE *file, const char *fnname,\n #endif\n \n   alpha_fnname = fnname;\n-  sa_size = alpha_sa_size ();\n-  frame_size = compute_frame_size (get_frame_size (), sa_size);\n \n   if (TARGET_ABI_OPEN_VMS)\n     reg_offset = 8 + 8 * cfun->machine->uses_condition_handler;\n   else\n     reg_offset = ALPHA_ROUND (crtl->outgoing_args_size);\n \n-  alpha_sa_mask (&imask, &fmask);\n+  imask = cfun->machine->sa_mask & 0xffffffffu;\n+  fmask = cfun->machine->sa_mask >> 32;\n \n   /* Issue function start and label.  */\n   if (TARGET_ABI_OPEN_VMS || !flag_inhibit_size_directive)\n@@ -8113,7 +8063,7 @@ alpha_start_function (FILE *file, const char *fnname,\n     fprintf (file, \"\\t.frame $%d,\" HOST_WIDE_INT_PRINT_DEC \",$26,\"\n \t     HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t     vms_unwind_regno,\n-\t     frame_size >= (1UL << 31) ? 0 : frame_size,\n+\t     frame_size >= max_frame_size ? 0 : frame_size,\n \t     reg_offset);\n   else if (!flag_inhibit_size_directive)\n     fprintf (file, \"\\t.frame $%d,\" HOST_WIDE_INT_PRINT_DEC \",$26,%d\\n\",\n@@ -8193,23 +8143,18 @@ void\n alpha_expand_epilogue (void)\n {\n   /* Registers to save.  */\n-  unsigned long imask = 0;\n-  unsigned long fmask = 0;\n+  unsigned HOST_WIDE_INT sa_mask = cfun->machine->sa_mask;\n   /* Stack space needed for pushing registers clobbered by us.  */\n-  HOST_WIDE_INT sa_size;\n+  HOST_WIDE_INT sa_size = cfun->machine->sa_size;\n   /* Complete stack size needed.  */\n-  HOST_WIDE_INT frame_size;\n+  HOST_WIDE_INT frame_size = cfun->machine->frame_size;\n   /* Offset from base reg to register save area.  */\n   HOST_WIDE_INT reg_offset;\n   int fp_is_frame_pointer, fp_offset;\n   rtx sa_reg, sa_reg_exp = NULL;\n   rtx sp_adj1, sp_adj2, mem, reg, insn;\n   rtx eh_ofs;\n   rtx cfa_restores = NULL_RTX;\n-  int i;\n-\n-  sa_size = alpha_sa_size ();\n-  frame_size = compute_frame_size (get_frame_size (), sa_size);\n \n   if (TARGET_ABI_OPEN_VMS)\n     {\n@@ -8221,8 +8166,6 @@ alpha_expand_epilogue (void)\n   else\n     reg_offset = ALPHA_ROUND (crtl->outgoing_args_size);\n \n-  alpha_sa_mask (&imask, &fmask);\n-\n   fp_is_frame_pointer\n     = (TARGET_ABI_OPEN_VMS\n        ? alpha_procedure_type == PT_STACK\n@@ -8261,43 +8204,23 @@ alpha_expand_epilogue (void)\n \t}\n \n       /* Restore registers in order, excepting a true frame pointer.  */\n-\n-      mem = gen_frame_mem (DImode, plus_constant (Pmode, sa_reg, reg_offset));\n-      reg = gen_rtx_REG (DImode, REG_RA);\n-      emit_move_insn (reg, mem);\n-      cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n-\n-      reg_offset += 8;\n-      imask &= ~(1UL << REG_RA);\n-\n-      for (i = 0; i < 31; ++i)\n-\tif (imask & (1UL << i))\n-\t  {\n-\t    if (i == HARD_FRAME_POINTER_REGNUM && fp_is_frame_pointer)\n-\t      fp_offset = reg_offset;\n-\t    else\n-\t      {\n-\t\tmem = gen_frame_mem (DImode,\n-\t\t\t\t     plus_constant (Pmode, sa_reg,\n-\t\t\t\t\t\t    reg_offset));\n-\t\treg = gen_rtx_REG (DImode, i);\n-\t\temit_move_insn (reg, mem);\n-\t\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n-\t\t\t\t\t       cfa_restores);\n-\t      }\n-\t    reg_offset += 8;\n-\t  }\n-\n-      for (i = 0; i < 31; ++i)\n-\tif (fmask & (1UL << i))\n-\t  {\n-\t    mem = gen_frame_mem (DFmode, plus_constant (Pmode, sa_reg,\n-\t\t\t\t\t\t        reg_offset));\n-\t    reg = gen_rtx_REG (DFmode, i+32);\n-\t    emit_move_insn (reg, mem);\n-\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n-\t    reg_offset += 8;\n-\t  }\n+      for (unsigned i = REG_RA; sa_mask != 0; i = ctz_hwi(sa_mask))\n+\t{\n+\t  if (i == HARD_FRAME_POINTER_REGNUM && fp_is_frame_pointer)\n+\t    fp_offset = reg_offset;\n+\t  else\n+\t    {\n+\t      mem = gen_frame_mem (DImode,\n+\t\t\t\t   plus_constant (Pmode, sa_reg,\n+\t\t\t\t\t\t  reg_offset));\n+\t      reg = gen_rtx_REG (DImode, i);\n+\t      emit_move_insn (reg, mem);\n+\t      cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n+\t\t\t\t\t     cfa_restores);\n+\t    }\n+\t  reg_offset += 8;\n+\t  sa_mask &= ~(HOST_WIDE_INT_1U << i);\n+\t}\n     }\n \n   if (frame_size || eh_ofs)"}]}