{"sha": "4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIxM2Y5M2I2YWVhNjRmNGVhNWY4YTUzOWEzZjBhZDkxMmJlYzFkMg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-10-17T20:52:37Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-10-17T20:52:37Z"}, "message": "re PR fortran/23446 (Valid internal subprogram array argument declaration is not accepted.)\n\n2005-10-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/23446\n\t* gfortran.h: Primitive for gfc_is_formal_arg.\n\t* resolve.c(gfc_is_formal_arg): New function to signal across\n\tseveral function calls that formal argument lists are being\n\tprocessed.\n\t(resolve_formal_arglist): Set/reset the flag for gfc_is_formal_arg.\n\t*expr.c(check_restricted): Add check, via gfc_is_formal_arg, if\n\tsymbol is part of an formal argument declaration.\n\n\tPR fortran/21459\n\t* decl.c (add_init_expr_to_sym): Make a new character\n\tlength for each variable, when the expression is NULL\n\tand link to cl_list.\n\n\tPR fortran/20866\n\t* match.c (recursive_stmt_fcn): New function that tests if\n\ta statement function resurses through itself or other other\n\tstatement functions.\n\t(gfc_match_st_function): Call recursive_stmt_fcn to check\n\tif this is recursive and to raise error if so.\n\n\tPR fortran/20849\n\tPR fortran/20853\n\t* resolve.c (resolve_symbol): Errors for assumed size arrays\n\twith default initializer and for external objects with an\n\tinitializer.\n\n\tPR fortran/20837\n\t* decl.c (match_attr_spec): Prevent PUBLIC from being used\n\toutside a module.\n\n2005-10-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/23446\n\t* gfortran.dg/host_dummy_index_1.f90: New test.\n\n\tPR fortran/21459\n\tgfortran.dg/automatic_char_len_2.f90: New test.\n\n\tPR fortran/20866\n\tgfortran.dg/recursive_statement_functions.f90: New test.\n\n\tPR fortran/20853\n\tgfortran.dg/assumed_size_dt_dummy.f90: New test.\n\n\tPR fortran/20849\n\tgfortran.dg/external_initializer.f90: New test.\n\n\tPR fortran/20837\n\tnon_module_public.f90: New test.\n\nFrom-SVN: r105518", "tree": {"sha": "69e1371af15ca815b604fa39a051f202ee0a4764", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69e1371af15ca815b604fa39a051f202ee0a4764"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/comments", "author": null, "committer": null, "parents": [{"sha": "be3914df4cc863fa52e3b74ad84ee683a4621e76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be3914df4cc863fa52e3b74ad84ee683a4621e76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be3914df4cc863fa52e3b74ad84ee683a4621e76"}], "stats": {"total": 296, "additions": 295, "deletions": 1}, "files": [{"sha": "ff6246abf2f7b0a79a643680158824394021677f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -1,3 +1,36 @@\n+2005-10-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/23446\n+\t* gfortran.h: Primitive for gfc_is_formal_arg.\n+\t* resolve.c(gfc_is_formal_arg): New function to signal across\n+\tseveral function calls that formal argument lists are being\n+\tprocessed.\n+\t(resolve_formal_arglist): Set/reset the flag for gfc_is_formal_arg.\n+\t*expr.c(check_restricted): Add check, via gfc_is_formal_arg, if\n+\tsymbol is part of an formal argument declaration.\n+\n+\tPR fortran/21459\n+\t* decl.c (add_init_expr_to_sym): Make a new character\n+\tlength for each variable, when the expression is NULL\n+\tand link to cl_list.\n+\n+\tPR fortran/20866\n+\t* match.c (recursive_stmt_fcn): New function that tests if\n+\ta statement function resurses through itself or other other\n+\tstatement functions.\n+\t(gfc_match_st_function): Call recursive_stmt_fcn to check\n+\tif this is recursive and to raise error if so.\n+\n+\tPR fortran/20849\n+\tPR fortran/20853\n+\t* resolve.c (resolve_symbol): Errors for assumed size arrays\n+\twith default initializer and for external objects with an\n+\tinitializer.\n+\n+\tPR fortran/20837\n+\t* decl.c (match_attr_spec): Prevent PUBLIC from being used\n+\toutside a module.\n+\n 2005-10-16  Erik Edelmann  <erik.edelmann@iki.fi>\n \n \tPR 22273"}, {"sha": "21f1089e42d28c96e8e2f0ee2276720f80fc125d", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -746,6 +746,13 @@ add_init_expr_to_sym (const char *name, gfc_expr ** initp,\n \t  /* Update symbol character length according initializer.  */\n \t  if (sym->ts.cl->length == NULL)\n \t    {\n+\t      /* If there are multiple CHARACTER variables declared on\n+\t\t the same line, we don't want them to share the same\n+\t        length.  */\n+\t      sym->ts.cl = gfc_get_charlen ();\n+\t      sym->ts.cl->next = gfc_current_ns->cl_list;\n+\t      gfc_current_ns->cl_list = sym->ts.cl;\n+\n \t      if (init->expr_type == EXPR_CONSTANT)\n \t\tsym->ts.cl->length =\n \t\t\tgfc_int_expr (init->value.character.length);\n@@ -1867,6 +1874,20 @@ match_attr_spec (void)\n \t  goto cleanup;\n \t}\n \n+      if ((d == DECL_PRIVATE || d == DECL_PUBLIC)\n+\t     && gfc_current_state () != COMP_MODULE)\n+\t{\n+\t  if (d == DECL_PRIVATE)\n+\t    attr = \"PRIVATE\";\n+\t  else\n+\t    attr = \"PUBLIC\";\n+\n+\t  gfc_error (\"%s attribute at %L is not allowed outside of a MODULE\",\n+\t\t     attr, &seen_at[d]);\n+\t  m = MATCH_ERROR;\n+\t  goto cleanup;\n+\t}\n+\n       switch (d)\n \t{\n \tcase DECL_ALLOCATABLE:"}, {"sha": "ebfd8486a13e9492270f938246ab530073077120", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -1673,12 +1673,16 @@ check_restricted (gfc_expr * e)\n \t  break;\n \t}\n \n+      /* gfc_is_formal_arg broadcasts that a formal argument list is being processed\n+\t in resolve.c(resolve_formal_arglist).  This is done so that host associated\n+\t dummy array indices are accepted (PR23446).  */\n       if (sym->attr.in_common\n \t  || sym->attr.use_assoc\n \t  || sym->attr.dummy\n \t  || sym->ns != gfc_current_ns\n \t  || (sym->ns->proc_name != NULL\n-\t      && sym->ns->proc_name->attr.flavor == FL_MODULE))\n+\t      && sym->ns->proc_name->attr.flavor == FL_MODULE)\n+\t  || gfc_is_formal_arg ())\n \t{\n \t  t = SUCCESS;\n \t  break;"}, {"sha": "894761367bec5dc33a13cd82a2d554563bc55ab0", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -1805,6 +1805,7 @@ int gfc_elemental (gfc_symbol *);\n try gfc_resolve_iterator (gfc_iterator *, bool);\n try gfc_resolve_index (gfc_expr *, int);\n try gfc_resolve_dim_arg (gfc_expr *);\n+int gfc_is_formal_arg (void);\n \n /* array.c */\n void gfc_free_array_spec (gfc_array_spec *);"}, {"sha": "eac5697c5e400cb611b2a1eaba238d5fc5a30c8e", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -2700,6 +2700,88 @@ gfc_match_equivalence (void)\n   return MATCH_ERROR;\n }\n \n+/* Check that a statement function is not recursive. This is done by looking\n+   for the statement function symbol(sym) by looking recursively through its\n+   expression(e).  If a reference to sym is found, true is returned.  */\n+static bool\n+recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n+{\n+  gfc_actual_arglist *arg;\n+  gfc_ref *ref;\n+  int i;\n+\n+  if (e == NULL)\n+    return false;\n+\n+  switch (e->expr_type)\n+    {\n+    case EXPR_FUNCTION:\n+      for (arg = e->value.function.actual; arg; arg = arg->next)\n+\t{\n+\t  if (sym->name == arg->name\n+\t\t|| recursive_stmt_fcn (arg->expr, sym))\n+\t    return true;\n+\t}\n+\n+      /* Check the name before testing for nested recursion!  */\n+      if (sym->name == e->symtree->n.sym->name)\n+\treturn true;\n+\n+      /* Catch recursion via other statement functions.  */\n+      if (e->symtree->n.sym->attr.proc == PROC_ST_FUNCTION\n+\t    && e->symtree->n.sym->value\n+\t    && recursive_stmt_fcn (e->symtree->n.sym->value, sym))\n+\treturn true;\n+\n+      break;\n+\n+    case EXPR_VARIABLE:\n+      if (sym->name == e->symtree->n.sym->name)\n+\treturn true;\n+      break;\n+\n+    case EXPR_OP:\n+      if (recursive_stmt_fcn (e->value.op.op1, sym)\n+\t    || recursive_stmt_fcn (e->value.op.op2, sym))\n+\treturn true;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Component references do not need to be checked.  */\n+  if (e->ref)\n+    {\n+      for (ref = e->ref; ref; ref = ref->next)\n+\t{\n+\t  switch (ref->type)\n+\t    {\n+\t    case REF_ARRAY:\n+\t      for (i = 0; i < ref->u.ar.dimen; i++)\n+\t\t{\n+\t\t  if (recursive_stmt_fcn (ref->u.ar.start[i], sym)\n+\t\t\t|| recursive_stmt_fcn (ref->u.ar.end[i], sym)\n+\t\t\t|| recursive_stmt_fcn (ref->u.ar.stride[i], sym))\n+\t\t    return true;\n+\t\t}\n+\t      break;\n+\n+\t    case REF_SUBSTRING:\n+\t      if (recursive_stmt_fcn (ref->u.ss.start, sym)\n+\t\t    || recursive_stmt_fcn (ref->u.ss.end, sym))\n+\t\treturn true;\n+\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return false;\n+}\n+\n \n /* Match a statement function declaration.  It is so easy to match\n    non-statement function statements with a MATCH_ERROR as opposed to\n@@ -2734,6 +2816,13 @@ gfc_match_st_function (void)\n   if (m == MATCH_ERROR)\n     return m;\n \n+  if (recursive_stmt_fcn (expr, sym))\n+    {\n+      gfc_error (\"Statement function at %L is recursive\",\n+\t\t &expr->where);\n+      return MATCH_ERROR;\n+    }\n+\n   sym->value = expr;\n \n   return MATCH_YES;"}, {"sha": "66ebd86381eab6818c7efa07e82218783ef286cd", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -50,6 +50,16 @@ static code_stack *cs_base = NULL;\n \n static int forall_flag;\n \n+/* Nonzero if we are processing a formal arglist. The corresponding function\n+   resets the flag each time that it is read.  */\n+static int formal_arg_flag = 0;\n+\n+int\n+gfc_is_formal_arg (void)\n+{\n+  return formal_arg_flag;\n+}\n+\n /* Resolve types of formal argument lists.  These have to be done early so that\n    the formal argument lists of module procedures can be copied to the\n    containing module before the individual procedures are resolved\n@@ -78,6 +88,8 @@ resolve_formal_arglist (gfc_symbol * proc)\n       || (sym->as && sym->as->rank > 0))\n     proc->attr.always_explicit = 1;\n \n+  formal_arg_flag = 1;\n+\n   for (f = proc->formal; f; f = f->next)\n     {\n       sym = f->sym;\n@@ -224,6 +236,7 @@ resolve_formal_arglist (gfc_symbol * proc)\n             }\n         }\n     }\n+  formal_arg_flag = 0;\n }\n \n \n@@ -4301,6 +4314,26 @@ resolve_symbol (gfc_symbol * sym)\n \t}\n     }\n \n+  /* An assumed-size array with INTENT(OUT) shall not be of a type for which\n+     default initialization is defined (5.1.2.4.4).  */\n+  if (sym->ts.type == BT_DERIVED\n+\t&& sym->attr.dummy\n+\t&& sym->attr.intent == INTENT_OUT\n+\t&& sym->as->type == AS_ASSUMED_SIZE)\n+    {\n+      for (c = sym->ts.derived->components; c; c = c->next)\n+\t{\n+\t  if (c->initializer)\n+\t    {\n+\t      gfc_error (\"The INTENT(OUT) dummy argument '%s' at %L is \"\n+\t\t\t \"ASSUMED SIZE and so cannot have a default initializer\",\n+\t\t\t sym->name, &sym->declared_at);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+\n   /* Ensure that derived type formal arguments of a public procedure\n      are not of a private type.  */\n   if (sym->attr.flavor == FL_PROCEDURE\n@@ -4427,6 +4460,15 @@ resolve_symbol (gfc_symbol * sym)\n       break;\n \n     default:\n+\n+      /* An external symbol falls through to here if it is not referenced.  */\n+      if (sym->attr.external && sym->value)\n+\t{\n+\t  gfc_error (\"External object at %L may not have an initializer\",\n+\t\t     &sym->declared_at);\n+\t  return;\n+\t}\n+\n       break;\n     }\n "}, {"sha": "5e1d0af3af26ee8a9f8fe96e0235fe8f321e2848", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -1,3 +1,23 @@\n+2005-10-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/23446\n+\t* gfortran.dg/host_dummy_index_1.f90: New test.\n+\n+\tPR fortran/21459\n+\tgfortran.dg/automatic_char_len_2.f90: New test.\n+\n+\tPR fortran/20866\n+\tgfortran.dg/recursive_statement_functions.f90: New test.\n+\n+\tPR fortran/20853\n+\tgfortran.dg/assumed_size_dt_dummy.f90: New test.\n+\n+\tPR fortran/20849\n+\tgfortran.dg/external_initializer.f90: New test.\n+\n+\tPR fortran/20837\n+\tnon_module_public.f90: New test.\n+\n 2005-10-17  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/24386"}, {"sha": "f7b5e299567083e0dc20440b5e82e37eaac1743f", "filename": "gcc/testsuite/gfortran.dg/assumed_size_dt_dummy.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_size_dt_dummy.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_size_dt_dummy.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_size_dt_dummy.f90?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! PR20853 - No array size information for initializer.\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+MODULE TEST\n+TYPE init\n+INTEGER :: I=0\n+END TYPE init\n+CONTAINS\n+SUBROUTINE try(A) ! { dg-error \"cannot have a default initializer\" }\n+  TYPE(init), DIMENSION(*), INTENT(OUT) :: A\n+END SUBROUTINE try\n+END MODULE TEST\n+END"}, {"sha": "18bb8d12dbdfe88a4566f600635db2dc98be0955", "filename": "gcc/testsuite/gfortran.dg/automatic_char_len_2.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fautomatic_char_len_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fautomatic_char_len_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fautomatic_char_len_2.f90?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-O0\" }\n+!\n+! Tests fix for PR21459 - This is the original example.\n+!\n+program format_string\n+  implicit none\n+  character(len=*), parameter :: rform='(F15.5)', &\n+  cform=\"(' (', F15.5, ',' F15.5, ') ')\"\n+  call print_a_number(cform)\n+contains\n+subroutine print_a_number(style)\n+  character(len=*) :: style\n+  write(*, style) cmplx(42.0, 99.0) ! { dg-output \"99.00000\" }\n+end subroutine print_a_number\n+end program format_string"}, {"sha": "5688bbfe715d4f0d8ffde3deb2bdc806a3e94df4", "filename": "gcc/testsuite/gfortran.dg/external_initializer.f90", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fexternal_initializer.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fexternal_initializer.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fexternal_initializer.f90?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -0,0 +1,5 @@\n+! { dg-do compile }\n+! PR20849 - An external symbol may not have a initializer.\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+REAL, EXTERNAL :: X=0 ! { dg-error \"may not have an initializer\" }\n+END"}, {"sha": "cc045ff96bc98e17aa3bb734219cbc65331c6d3f", "filename": "gcc/testsuite/gfortran.dg/host_dummy_index_1.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_dummy_index_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_dummy_index_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_dummy_index_1.f90?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! Tests the fix for PR23446. Based on PR example.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+PROGRAM TST\n+  INTEGER IMAX\n+  INTEGER :: A(4) = 1\n+  IMAX=2\n+\n+  CALL S(A)\n+  CALL T(A)\n+  CALL U(A)\n+  if ( ALL(A.ne.(/2,2,3,4/))) CALL ABORT ()\n+\n+CONTAINS\n+  SUBROUTINE S(A)\n+    INTEGER A(IMAX)\n+    a = 2\n+  END SUBROUTINE S\n+  SUBROUTINE T(A)\n+    INTEGER A(3:IMAX+4)\n+    A(5:IMAX+4) = 3\n+  END SUBROUTINE T\n+  SUBROUTINE U(A)\n+    INTEGER A(2,IMAX)\n+    A(2,2) = 4\n+  END SUBROUTINE U\n+ENDPROGRAM TST"}, {"sha": "cf99dd737de54a66d69f2b20a235c3936825fab7", "filename": "gcc/testsuite/gfortran.dg/non_module_public.f90", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fnon_module_public.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fnon_module_public.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnon_module_public.f90?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -0,0 +1,5 @@\n+! { dg-do compile }\n+! PR20837 - A symbol may not be declared PUBLIC or PRIVATE outside a module.\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+integer, parameter, public :: i=1 ! { dg-error \"allowed outside of a MODULE\" }\n+END"}, {"sha": "489f11862b6ca505a49673e9c4f2864c78ab7acc", "filename": "gcc/testsuite/gfortran.dg/recursive_statement_functions.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_statement_functions.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_statement_functions.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_statement_functions.f90?ref=4213f93b6aea64f4ea5f8a539a3f0ad912bec1d2", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+! PR20866 - A statement function cannot be recursive.\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+  INTEGER :: i, st1, st2, st3\n+  REAL :: x, z(2,2)\n+  character*8 :: ch\n+!\n+! Test check for recursion via other statement functions, string\n+! length references, function actual arguments and array index\n+! references.\n+  st1(i)=len(ch(st2(1):8))\n+  st2(i)=max (st3(1), 4)\n+  st3(i)=2 + cos (z(st1 (1), i)) ! { dg-error \"is recursive\" }\n+  write(6,*) st1(1)\n+  END\n+"}]}