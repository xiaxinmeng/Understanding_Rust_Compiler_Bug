{"sha": "a7790c7174a016fcea0af852a493479f0dadfdf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc3OTBjNzE3NGEwMTZmY2VhMGFmODUyYTQ5MzQ3OWYwZGFkZmRmMw==", "commit": {"author": {"name": "Dominik Vogt", "email": "vogt@linux.vnet.ibm.com", "date": "2016-11-18T14:28:49Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-11-18T14:28:49Z"}, "message": "RS6000: Fix PR 77359: Properly align local variables in functions calling alloca.\n\ngcc/ChangeLog:\n\n2016-11-18  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_stack_info): PR/77359: Properly align\n\tlocal variables in functions calling alloca.  Also update the ASCII\n\tdrawings\n\t* config/rs6000/rs6000.h (STARTING_FRAME_OFFSET, STACK_DYNAMIC_OFFSET):\n\tPR/77359: Likewise.\n\t* config/rs6000/aix.h (STARTING_FRAME_OFFSET, STACK_DYNAMIC_OFFSET):\n\tPR/77359: Copy AIX specific versions of the rs6000.h macros to aix.h.\n\nFrom-SVN: r242589", "tree": {"sha": "ee729e30eec5262d5ad6e74a5080a228fb603783", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee729e30eec5262d5ad6e74a5080a228fb603783"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7790c7174a016fcea0af852a493479f0dadfdf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7790c7174a016fcea0af852a493479f0dadfdf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7790c7174a016fcea0af852a493479f0dadfdf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7790c7174a016fcea0af852a493479f0dadfdf3/comments", "author": {"login": "vogtd", "id": 9690100, "node_id": "MDQ6VXNlcjk2OTAxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/9690100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vogtd", "html_url": "https://github.com/vogtd", "followers_url": "https://api.github.com/users/vogtd/followers", "following_url": "https://api.github.com/users/vogtd/following{/other_user}", "gists_url": "https://api.github.com/users/vogtd/gists{/gist_id}", "starred_url": "https://api.github.com/users/vogtd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vogtd/subscriptions", "organizations_url": "https://api.github.com/users/vogtd/orgs", "repos_url": "https://api.github.com/users/vogtd/repos", "events_url": "https://api.github.com/users/vogtd/events{/privacy}", "received_events_url": "https://api.github.com/users/vogtd/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dbb29a2a37900549c9d90f4d33bf7e00641655c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbb29a2a37900549c9d90f4d33bf7e00641655c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbb29a2a37900549c9d90f4d33bf7e00641655c6"}], "stats": {"total": 97, "additions": 84, "deletions": 13}, "files": [{"sha": "95506d39c0f190c90b9670640ba64938ff019e1b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7790c7174a016fcea0af852a493479f0dadfdf3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7790c7174a016fcea0af852a493479f0dadfdf3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7790c7174a016fcea0af852a493479f0dadfdf3", "patch": "@@ -1,3 +1,15 @@\n+2016-11-18  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\n+\tPR bootstrap/77359\n+\t* config/rs6000/rs6000.c (rs6000_stack_info): Properly align local\n+\tvariables in functions calling alloca.  Also update the ASCII\n+\tdrawings.\n+\t* config/rs6000/rs6000.h (STARTING_FRAME_OFFSET)\n+\t(STACK_DYNAMIC_OFFSET): Likewise.\n+\t* config/rs6000/aix.h (STARTING_FRAME_OFFSET)\n+\t(STACK_DYNAMIC_OFFSET): Copy AIX specific versions of the rs6000.h\n+\tmacros to aix.h.\n+\n 2016-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "f6eb122d45a761629e61c1541f7c2a5b85fa0ec9", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7790c7174a016fcea0af852a493479f0dadfdf3/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7790c7174a016fcea0af852a493479f0dadfdf3/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=a7790c7174a016fcea0af852a493479f0dadfdf3", "patch": "@@ -40,6 +40,41 @@\n #undef  STACK_BOUNDARY\n #define STACK_BOUNDARY 128\n \n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.\n+\n+   On the RS/6000, the frame pointer is the same as the stack pointer,\n+   except for dynamic allocations.  So we start after the fixed area and\n+   outgoing parameter area.\n+\n+   If the function uses dynamic stack space (CALLS_ALLOCA is set), that\n+   space needs to be aligned to STACK_BOUNDARY, i.e. the sum of the\n+   sizes of the fixed area and the parameter area must be a multiple of\n+   STACK_BOUNDARY.  */\n+\n+#undef STARTING_FRAME_OFFSET\n+#define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n+  (FRAME_GROWS_DOWNWARD\t\t\t\t\t\t\t\\\n+   ? 0\t\t\t\t\t\t\t\t\t\\\n+   : (cfun->calls_alloca\t\t\t\t\t\t\\\n+      ? RS6000_ALIGN (crtl->outgoing_args_size + RS6000_SAVE_AREA, 16)\t\\\n+      : (RS6000_ALIGN (crtl->outgoing_args_size, 16) + RS6000_SAVE_AREA)))\n+\n+/* Offset from the stack pointer register to an item dynamically\n+   allocated on the stack, e.g., by `alloca'.\n+\n+   The default value for this macro is `STACK_POINTER_OFFSET' plus the\n+   length of the outgoing arguments.  The default is correct for most\n+   machines.  See `function.c' for details.\n+\n+   This value must be a multiple of STACK_BOUNDARY (hard coded in\n+   `emit-rtl.c').  */\n+#undef STACK_DYNAMIC_OFFSET\n+#define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n+   RS6000_ALIGN (crtl->outgoing_args_size + STACK_POINTER_OFFSET, 16)\n+\n #undef  TARGET_IEEEQUAD\n #define TARGET_IEEEQUAD 0\n "}, {"sha": "bec49bffea2a155b47255874b4dc38677bc4ccc2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7790c7174a016fcea0af852a493479f0dadfdf3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7790c7174a016fcea0af852a493479f0dadfdf3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a7790c7174a016fcea0af852a493479f0dadfdf3", "patch": "@@ -25898,7 +25898,7 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n \t\t+---------------------------------------+\n \t\t| saved TOC pointer\t\t\t| 20      40\n \t\t+---------------------------------------+\n-\t\t| Parameter save area (P)\t\t| 24      48\n+\t\t| Parameter save area (+padding*) (P)\t| 24      48\n \t\t+---------------------------------------+\n \t\t| Alloca space (A)\t\t\t| 24+P    etc.\n \t\t+---------------------------------------+\n@@ -25919,6 +25919,9 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n \told SP->| back chain to caller's caller\t\t|\n \t\t+---------------------------------------+\n \n+     * If the alloca area is present, the parameter save area is\n+       padded so that the former starts 16-byte aligned.\n+\n    The required alignment for AIX configurations is two words (i.e., 8\n    or 16 bytes).\n \n@@ -25933,7 +25936,7 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n \t\t+---------------------------------------+\n \t\t| Saved TOC pointer\t\t\t|  24\n \t\t+---------------------------------------+\n-\t\t| Parameter save area (P)\t\t|  32\n+\t\t| Parameter save area (+padding*) (P)\t|  32\n \t\t+---------------------------------------+\n \t\t| Alloca space (A)\t\t\t|  32+P\n \t\t+---------------------------------------+\n@@ -25950,6 +25953,8 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n \told SP->| back chain to caller's caller\t\t|  32+P+A+L+W+Y+G+F\n \t\t+---------------------------------------+\n \n+     * If the alloca area is present, the parameter save area is\n+       padded so that the former starts 16-byte aligned.\n \n    V.4 stack frames look like:\n \n@@ -25958,7 +25963,7 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n \t\t+---------------------------------------+\n \t\t| caller's saved LR\t\t\t| 4\n \t\t+---------------------------------------+\n-\t\t| Parameter save area (P)\t\t| 8\n+\t\t| Parameter save area (+padding*) (P)\t| 8\n \t\t+---------------------------------------+\n \t\t| Alloca space (A)\t\t\t| 8+P\n \t\t+---------------------------------------+\n@@ -25987,6 +25992,10 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n \told SP->| back chain to caller's caller\t\t|\n \t\t+---------------------------------------+\n \n+     * If the alloca area is present and the required alignment is\n+       16 bytes, the parameter save area is padded so that the\n+       alloca area starts 16-byte aligned.\n+\n    The required alignment for V.4 is 16 bytes, or 8 bytes if -meabi is\n    given.  (But note below and in sysv4.h that we require only 8 and\n    may round up the size of our stack frame anyways.  The historical\n@@ -26121,8 +26130,13 @@ rs6000_stack_info (void)\n   info->reg_size     = reg_size;\n   info->fixed_size   = RS6000_SAVE_AREA;\n   info->vars_size    = RS6000_ALIGN (get_frame_size (), 8);\n-  info->parm_size    = RS6000_ALIGN (crtl->outgoing_args_size,\n-\t\t\t\t\t TARGET_ALTIVEC ? 16 : 8);\n+  if (cfun->calls_alloca)\n+    info->parm_size  =\n+      RS6000_ALIGN (crtl->outgoing_args_size + info->fixed_size,\n+\t\t    STACK_BOUNDARY / BITS_PER_UNIT) - info->fixed_size;\n+  else\n+    info->parm_size  = RS6000_ALIGN (crtl->outgoing_args_size,\n+\t\t\t\t     TARGET_ALTIVEC ? 16 : 8);\n   if (FRAME_GROWS_DOWNWARD)\n     info->vars_size\n       += RS6000_ALIGN (info->fixed_size + info->vars_size + info->parm_size,"}, {"sha": "19a476bc8047d9420f3a7ed25c5f7a61b35d428a", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7790c7174a016fcea0af852a493479f0dadfdf3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7790c7174a016fcea0af852a493479f0dadfdf3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=a7790c7174a016fcea0af852a493479f0dadfdf3", "patch": "@@ -1724,25 +1724,35 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n \n    On the RS/6000, the frame pointer is the same as the stack pointer,\n    except for dynamic allocations.  So we start after the fixed area and\n-   outgoing parameter area.  */\n+   outgoing parameter area.\n+\n+   If the function uses dynamic stack space (CALLS_ALLOCA is set), that\n+   space needs to be aligned to STACK_BOUNDARY, i.e. the sum of the\n+   sizes of the fixed area and the parameter area must be a multiple of\n+   STACK_BOUNDARY.  */\n \n #define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n   (FRAME_GROWS_DOWNWARD\t\t\t\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\t\t\t\\\n-   : (RS6000_ALIGN (crtl->outgoing_args_size,\t\t\t\t\\\n-\t\t    (TARGET_ALTIVEC || TARGET_VSX) ? 16 : 8)\t\t\\\n-      + RS6000_SAVE_AREA))\n+   : (cfun->calls_alloca\t\t\t\t\t\t\\\n+      ? (RS6000_ALIGN (crtl->outgoing_args_size + RS6000_SAVE_AREA,\t\\\n+\t\t       (TARGET_ALTIVEC || TARGET_VSX) ? 16 : 8 ))\t\\\n+      : (RS6000_ALIGN (crtl->outgoing_args_size,\t\t\t\\\n+\t\t       (TARGET_ALTIVEC || TARGET_VSX) ? 16 : 8)\t\t\\\n+\t + RS6000_SAVE_AREA)))\n \n /* Offset from the stack pointer register to an item dynamically\n    allocated on the stack, e.g., by `alloca'.\n \n    The default value for this macro is `STACK_POINTER_OFFSET' plus the\n    length of the outgoing arguments.  The default is correct for most\n-   machines.  See `function.c' for details.  */\n+   machines.  See `function.c' for details.\n+\n+   This value must be a multiple of STACK_BOUNDARY (hard coded in\n+   `emit-rtl.c').  */\n #define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n-  (RS6000_ALIGN (crtl->outgoing_args_size,\t\t\t\t\\\n-\t\t (TARGET_ALTIVEC || TARGET_VSX) ? 16 : 8)\t\t\\\n-   + (STACK_POINTER_OFFSET))\n+  RS6000_ALIGN (crtl->outgoing_args_size + STACK_POINTER_OFFSET,\t\\\n+\t\t(TARGET_ALTIVEC || TARGET_VSX) ? 16 : 8)\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by."}]}