{"sha": "8e53f957a14fa15bee351126d720632f608b01c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU1M2Y5NTdhMTRmYTE1YmVlMzUxMTI2ZDcyMDYzMmY2MDhiMDFjMQ==", "commit": {"author": {"name": "Keith Seitz", "email": "keiths@redhat.com", "date": "2007-02-17T01:21:28Z"}, "committer": {"name": "Keith Seitz", "email": "kseitz@gcc.gnu.org", "date": "2007-02-17T01:21:28Z"}, "message": "* gnu/classpath/jdwp/natVMVirtualMachine.cc\n        (get_line_table): New function.\n        (handle_single_step): New function.\n        (jdwpSingleStepCB): New function.\n        (jdwpVMInitCB): Define a JVMTI single step\n        callback, but don't enable it until needed.\n\nFrom-SVN: r122065", "tree": {"sha": "fdca9067d7ff54b9147b9600f0f16715680937d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdca9067d7ff54b9147b9600f0f16715680937d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e53f957a14fa15bee351126d720632f608b01c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e53f957a14fa15bee351126d720632f608b01c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e53f957a14fa15bee351126d720632f608b01c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e53f957a14fa15bee351126d720632f608b01c1/comments", "author": {"login": "shtiek", "id": 107581324, "node_id": "U_kgDOBmmPjA", "avatar_url": "https://avatars.githubusercontent.com/u/107581324?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shtiek", "html_url": "https://github.com/shtiek", "followers_url": "https://api.github.com/users/shtiek/followers", "following_url": "https://api.github.com/users/shtiek/following{/other_user}", "gists_url": "https://api.github.com/users/shtiek/gists{/gist_id}", "starred_url": "https://api.github.com/users/shtiek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shtiek/subscriptions", "organizations_url": "https://api.github.com/users/shtiek/orgs", "repos_url": "https://api.github.com/users/shtiek/repos", "events_url": "https://api.github.com/users/shtiek/events{/privacy}", "received_events_url": "https://api.github.com/users/shtiek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99239742996a2c899f1387b872f02b46d04ad25d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99239742996a2c899f1387b872f02b46d04ad25d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99239742996a2c899f1387b872f02b46d04ad25d"}], "stats": {"total": 184, "additions": 184, "deletions": 0}, "files": [{"sha": "1a457df2005f027ac48063c2e7485ede1ecc6a38", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e53f957a14fa15bee351126d720632f608b01c1/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e53f957a14fa15bee351126d720632f608b01c1/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8e53f957a14fa15bee351126d720632f608b01c1", "patch": "@@ -1,3 +1,12 @@\n+2007-02-16  Keith Seitz  <keiths@redhat.com>\n+\n+\t* gnu/classpath/jdwp/natVMVirtualMachine.cc\n+\t(get_line_table): New function.\n+\t(handle_single_step): New function.\n+\t(jdwpSingleStepCB): New function.\n+\t(jdwpVMInitCB): Define a JVMTI single step\n+\tcallback, but don't enable it until needed.\n+\n 2007-02-16  David Daney  <ddaney@avtrex.com>\n \n \t* java/lang/Thread.java (Thread(ThreadGroup, Runnable, String)): Pass"}, {"sha": "c47d440ea2f362e145a184c99742eb01c5cd3815", "filename": "libjava/gnu/classpath/jdwp/natVMVirtualMachine.cc", "status": "modified", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e53f957a14fa15bee351126d720632f608b01c1/libjava%2Fgnu%2Fclasspath%2Fjdwp%2FnatVMVirtualMachine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e53f957a14fa15bee351126d720632f608b01c1/libjava%2Fgnu%2Fclasspath%2Fjdwp%2FnatVMVirtualMachine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fclasspath%2Fjdwp%2FnatVMVirtualMachine.cc?ref=8e53f957a14fa15bee351126d720632f608b01c1", "patch": "@@ -29,13 +29,16 @@ details. */\n #include <java/util/Iterator.h>\n \n #include <gnu/classpath/jdwp/Jdwp.h>\n+#include <gnu/classpath/jdwp/JdwpConstants$StepDepth.h>\n+#include <gnu/classpath/jdwp/JdwpConstants$StepSize.h>\n #include <gnu/classpath/jdwp/VMFrame.h>\n #include <gnu/classpath/jdwp/VMMethod.h>\n #include <gnu/classpath/jdwp/VMVirtualMachine.h>\n #include <gnu/classpath/jdwp/event/BreakpointEvent.h>\n #include <gnu/classpath/jdwp/event/ClassPrepareEvent.h>\n #include <gnu/classpath/jdwp/event/EventManager.h>\n #include <gnu/classpath/jdwp/event/EventRequest.h>\n+#include <gnu/classpath/jdwp/event/SingleStepEvent.h>\n #include <gnu/classpath/jdwp/event/ThreadEndEvent.h>\n #include <gnu/classpath/jdwp/event/ThreadStartEvent.h>\n #include <gnu/classpath/jdwp/event/VmDeathEvent.h>\n@@ -67,12 +70,18 @@ struct step_info\n };\n \n // Forward declarations\n+static jvmtiError get_linetable (jvmtiEnv *, jmethodID, jint *,\n+\t\t\t\t jvmtiLineNumberEntry **);\n static Location *get_request_location (EventRequest *);\n static gnu::classpath::jdwp::event::filters::StepFilter *\n get_request_step_filter (EventRequest *);\n+static void handle_single_step (jvmtiEnv *, struct step_info *, jthread,\n+\t\t\t\tjmethodID, jlocation);\n static void JNICALL jdwpBreakpointCB (jvmtiEnv *, JNIEnv *, jthread,\n \t\t\t\t      jmethodID, jlocation);\n static void JNICALL jdwpClassPrepareCB (jvmtiEnv *, JNIEnv *, jthread, jclass);\n+static void JNICALL jdwpSingleStepCB (jvmtiEnv *, JNIEnv *, jthread,\n+\t\t\t\t      jmethodID, jlocation);\n static void JNICALL jdwpThreadEndCB (jvmtiEnv *, JNIEnv *, jthread);\n static void JNICALL jdwpThreadStartCB (jvmtiEnv *, JNIEnv *, jthread);\n static void JNICALL jdwpVMDeathCB (jvmtiEnv *, JNIEnv *);\n@@ -624,6 +633,38 @@ getSourceFile (MAYBE_UNUSED jclass clazz)\n   return NULL;\n }\n \n+// A simple caching function used while single-stepping\n+static jvmtiError\n+get_linetable (jvmtiEnv *env, jmethodID method, jint *count_ptr,\n+\t       jvmtiLineNumberEntry **table_ptr)\n+{\n+  static jint last_count = 0;\n+  static jvmtiLineNumberEntry *last_table = NULL;\n+  static jmethodID last_method = 0;\n+\n+  if (method == last_method)\n+    {\n+      *count_ptr = last_count;\n+      *table_ptr = last_table;\n+      return JVMTI_ERROR_NONE;\n+    }\n+\n+  jvmtiError err;\n+  jint count;\n+  jvmtiLineNumberEntry *table;\n+  err = env->GetLineNumberTable (method, &count, &table);\n+  if (err != JVMTI_ERROR_NONE)\n+    {\n+      // Keep last table in cache\n+      return err;\n+    }\n+\n+  env->Deallocate ((unsigned char *) last_table);\n+  last_table = *table_ptr = table;\n+  last_count = *count_ptr = count;\n+  return JVMTI_ERROR_NONE;\n+}\n+\n static gnu::classpath::jdwp::event::filters::StepFilter *\n get_request_step_filter (EventRequest *request)\n {\n@@ -665,6 +706,71 @@ get_request_location (EventRequest *request)\n   return loc;\n }\n \n+static void\n+handle_single_step (jvmtiEnv *env, struct step_info *sinfo, jthread thread,\n+\t\t    jmethodID method, jlocation location)\n+{\n+  using namespace gnu::classpath::jdwp;\n+\n+  if (sinfo == NULL || sinfo->size == JdwpConstants$StepSize::MIN)\n+    {\n+      // Stop now\n+      goto send_notification;\n+    }\n+  else\n+    {\n+      // Check if we're on a new source line\n+      /* This is a little inefficient when we're stepping OVER,\n+\t but this must be done when stepping INTO. */\n+      jint count;\n+      jvmtiLineNumberEntry *table;\n+      if (get_linetable (env, method, &count, &table) == JVMTI_ERROR_NONE)\n+\t{\n+\t  jint i;\n+\t  for (i = 0; i < count; ++i)\n+\t    {\n+\t      if (table[i].start_location == location)\n+\t\t{\n+\t\t  // This is the start of a new line -- stop\n+\t\t  goto send_notification;\n+\t\t}\n+\t    }\n+\n+\t  // Not at a new source line -- just keep stepping\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  /* Something went wrong: either \"absent information\"\n+\t     or \"out of memory\" (\"invalid method id\" and \"native\n+\t     method\" aren't possible -- those are validated before\n+\t     single stepping is enabled).\n+\n+\t     Do what gdb does: just keep going. */\n+\t  return;\n+\t}\n+    }\n+\n+ send_notification:\n+  jclass klass;\n+  jvmtiError err = env->GetMethodDeclaringClass (method, &klass);\n+  if (err != JVMTI_ERROR_NONE)\n+    {\n+      fprintf (stderr, \"libgcj: internal error: could not find class for method while single stepping -- continuing\\n\");\n+      return;\n+    }\n+\n+  VMMethod *vmmethod = new VMMethod (klass, reinterpret_cast<jlong> (method));\n+  Location *loc = new Location (vmmethod, location);\n+  JvAssert (thread->frame.frame_type == frame_interpreter);\n+  _Jv_InterpFrame *iframe\n+    = reinterpret_cast<_Jv_InterpFrame *> (thread->interp_frame);  \n+  jobject instance = iframe->get_this_ptr ();\n+  event::SingleStepEvent *event\n+    = new event::SingleStepEvent (thread, loc, instance);\n+  Jdwp::notify (event);\n+}\n+\n static void\n throw_jvmti_error (jvmtiError err)\n {\n@@ -732,6 +838,73 @@ jdwpClassPrepareCB (jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env,\n   Jdwp::notify (event);\n }\n \n+static void JNICALL\n+jdwpSingleStepCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread,\n+\t\t  jmethodID method, jlocation location)\n+{\n+  jobject si =\n+    gnu::classpath::jdwp::VMVirtualMachine::_stepping_threads->get (thread);\n+  struct step_info *sinfo = reinterpret_cast<struct step_info *> (si);\n+\n+  if (sinfo == NULL)\n+    {\n+      // no step filter for this thread - simply report it\n+      handle_single_step (env, NULL, thread, method, location);\n+    }\n+  else\n+    {\n+      // A step filter exists for this thread\n+      using namespace gnu::classpath::jdwp;\n+\n+      _Jv_InterpFrame *frame\n+\t= reinterpret_cast<_Jv_InterpFrame *> (thread->interp_frame);\n+\n+      switch (sinfo->depth)\n+\t{\n+\tcase JdwpConstants$StepDepth::INTO:\n+\t  /* This is the easy case. We ignore the method and\n+\t     simply stop at either the next insn, or the next source\n+\t     line. */\n+\t  handle_single_step (env, sinfo, thread, method, location);\n+\t  break;\n+\n+\tcase JdwpConstants$StepDepth::OVER:\n+\t  /* This is also a pretty easy case. We just make sure that\n+\t     the methods are the same and that we are at the same\n+\t     stack depth, but we should also stop on the next\n+\t     insn/line if the stack depth is LESS THAN it was when\n+\t     we started stepping. */\n+\t  if (method == sinfo->method)\n+\t    {\n+\t      // Still in the same method -- must be at same stack depth\n+\t      // to avoid confusion with recursive methods.\n+\t      if (frame->depth () == sinfo->stack_depth)\n+\t\thandle_single_step (env, sinfo, thread, method, location);\n+\t    }\n+\t  else if (frame->depth () < sinfo->stack_depth)\n+\t    {\n+\t      // The method in which we were stepping was popped off\n+\t      // the stack. We simply need to stop at the next insn/line.\n+\t      handle_single_step (env, sinfo, thread, method, location);\n+\t    }\n+\t  break;\n+\n+\tcase JdwpConstants$StepDepth::OUT:\n+\t  // All we need to do is check the stack depth\n+\t  if (sinfo->stack_depth > frame->depth ())\n+\t    handle_single_step (env, sinfo, thread, method, location);\n+\t  break;\n+\n+\tdefault:\n+\t  /* This should not happen. The JDWP back-end should have\n+\t     validated the StepFilter. */\n+\t  fprintf (stderr,\n+\t\t   \"libgcj: unknown step depth while single stepping\\n\");\n+\t  return;\n+\t}\n+    }\n+}\n+\n static void JNICALL\n jdwpThreadEndCB (MAYBE_UNUSED jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env,\n \t\t jthread thread)\n@@ -767,6 +940,7 @@ jdwpVMInitCB (MAYBE_UNUSED jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env,\n   jvmtiEventCallbacks callbacks;\n   DEFINE_CALLBACK (callbacks, Breakpoint);\n   DEFINE_CALLBACK (callbacks, ClassPrepare);\n+  DEFINE_CALLBACK (callbacks, SingleStep);\n   DEFINE_CALLBACK (callbacks, ThreadEnd);\n   DEFINE_CALLBACK (callbacks, ThreadStart);\n   DEFINE_CALLBACK (callbacks, VMDeath);\n@@ -775,6 +949,7 @@ jdwpVMInitCB (MAYBE_UNUSED jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env,\n   // Enable callbacks\n   ENABLE_EVENT (BREAKPOINT, NULL);\n   ENABLE_EVENT (CLASS_PREPARE, NULL);\n+  // SingleStep is enabled only when needed\n   ENABLE_EVENT (THREAD_END, NULL);\n   ENABLE_EVENT (THREAD_START, NULL);\n   ENABLE_EVENT (VM_DEATH, NULL);"}]}