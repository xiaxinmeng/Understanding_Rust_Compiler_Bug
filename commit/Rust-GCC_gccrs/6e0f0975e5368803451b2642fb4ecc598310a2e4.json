{"sha": "6e0f0975e5368803451b2642fb4ecc598310a2e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwZjA5NzVlNTM2ODgwMzQ1MWIyNjQyZmI0ZWNjNTk4MzEwYTJlNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-20T19:56:48Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-20T19:56:48Z"}, "message": "decl.c (gnat_to_gnu_entity): Rewrite Esize calculation.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Rewrite Esize calculation.\n\t<E_Signed_Integer_Subtype>: Set the RM size on the integer type\n\tbefore wrapping it up in the record type.  Do not overwrite the\n\tAda size of the record type with the Esize.\n\nFrom-SVN: r146452", "tree": {"sha": "1cf69154bdae6c2bd8d476bdb6d5f490186ef5c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cf69154bdae6c2bd8d476bdb6d5f490186ef5c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e0f0975e5368803451b2642fb4ecc598310a2e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e0f0975e5368803451b2642fb4ecc598310a2e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e0f0975e5368803451b2642fb4ecc598310a2e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e0f0975e5368803451b2642fb4ecc598310a2e4/comments", "author": null, "committer": null, "parents": [{"sha": "bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbbbb16a888987aea0b85ce1133cf1dac4557ecc"}], "stats": {"total": 87, "additions": 61, "deletions": 26}, "files": [{"sha": "d94432f80b1e03d0327a373d2e16a148623582fa", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0f0975e5368803451b2642fb4ecc598310a2e4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0f0975e5368803451b2642fb4ecc598310a2e4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6e0f0975e5368803451b2642fb4ecc598310a2e4", "patch": "@@ -1,3 +1,10 @@\n+2009-04-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Rewrite Esize calculation.\n+\t<E_Signed_Integer_Subtype>: Set the RM size on the integer type\n+\tbefore wrapping it up in the record type.  Do not overwrite the\n+\tAda size of the record type with the Esize.\n+\n 2009-04-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (unchecked_conversion_lhs_nop): New predicate."}, {"sha": "390d458f7017845f96e43bc0c0449728d18a545d", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0f0975e5368803451b2642fb4ecc598310a2e4/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0f0975e5368803451b2642fb4ecc598310a2e4/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=6e0f0975e5368803451b2642fb4ecc598310a2e4", "patch": "@@ -201,18 +201,27 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   /* True if this entity is to be considered as imported.  */\n   bool imported_p = (Is_Imported (gnat_entity)\n \t\t     && No (Address_Clause (gnat_entity)));\n-  unsigned int esize\n-    = ((Known_Esize (gnat_entity)\n-\t&& UI_Is_In_Int_Range (Esize (gnat_entity)))\n-       ? MIN (UI_To_Int (Esize (gnat_entity)),\n-\t      IN (kind, Float_Kind)\n-\t      ? fp_prec_to_size (LONG_DOUBLE_TYPE_SIZE)\n-\t      : IN (kind, Access_Kind) ? POINTER_SIZE * 2\n-\t      : LONG_LONG_TYPE_SIZE)\n-       : LONG_LONG_TYPE_SIZE);\n-  unsigned int align = 0;\n+  unsigned int esize, align = 0;\n   struct attrib *attr_list = NULL;\n \n+  /* First compute a default value for the size of the entity.  */\n+  if (Known_Esize (gnat_entity) && UI_Is_In_Int_Range (Esize (gnat_entity)))\n+    {\n+      unsigned int max_esize;\n+      esize = UI_To_Int (Esize (gnat_entity));\n+\n+      if (IN (kind, Float_Kind))\n+\tmax_esize = fp_prec_to_size (LONG_DOUBLE_TYPE_SIZE);\n+      else if (IN (kind, Access_Kind))\n+\tmax_esize = POINTER_SIZE * 2;\n+      else\n+\tmax_esize = LONG_LONG_TYPE_SIZE;\n+\n+      esize = MIN (esize, max_esize);\n+    }\n+  else\n+    esize = LONG_LONG_TYPE_SIZE;\n+\n   /* Since a use of an Itype is a definition, process it as such if it\n      is not in a with'ed unit.  */\n   if (!definition\n@@ -1561,12 +1570,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t subtypes of Standard.Boolean.  */\n       if (Is_Packed_Array_Type (gnat_entity)\n \t  && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n-\t{\n-\t  esize = UI_To_Int (RM_Size (gnat_entity));\n-\t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type) = 1;\n-\t}\n+\tesize = UI_To_Int (RM_Size (gnat_entity));\n       else if (TREE_CODE (TREE_TYPE (gnu_type)) == BOOLEAN_TYPE)\n-        esize = 1;\n+\tesize = 1;\n \n       TYPE_PRECISION (gnu_type) = esize;\n \n@@ -1612,26 +1618,29 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t within a subtype hierarchy.  */\n       relate_alias_sets (gnu_type, TREE_TYPE (gnu_type), ALIAS_SET_COPY);\n \n-      /* If the type we are dealing with is to represent a packed array,\n+      /* If the type we are dealing with represents a bit-packed array,\n \t we need to have the bits left justified on big-endian targets\n \t and right justified on little-endian targets.  We also need to\n \t ensure that when the value is read (e.g. for comparison of two\n \t such values), we only get the good bits, since the unused bits\n-\t are uninitialized.  Both goals are accomplished by wrapping the\n-\t modular value in an enclosing struct.  */\n+\t are uninitialized.  Both goals are accomplished by wrapping up\n+\t the modular type in an enclosing record type.  */\n       if (Is_Packed_Array_Type (gnat_entity)\n \t  && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n \t{\n-\t  tree gnu_field_type = gnu_type;\n-\t  tree gnu_field;\n+\t  tree gnu_field_type, gnu_field;\n \n-\t  TYPE_RM_SIZE_NUM (gnu_field_type)\n+\t  /* Set the RM size before wrapping up the type.  */\n+\t  TYPE_RM_SIZE_NUM (gnu_type)\n \t    = UI_To_gnu (RM_Size (gnat_entity), bitsizetype);\n+\t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type) = 1;\n+\t  gnu_field_type = gnu_type;\n+\n \t  gnu_type = make_node (RECORD_TYPE);\n \t  TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"JM\");\n \n \t  /* Propagate the alignment of the modular type to the record.\n-\t     This means that bitpacked arrays have \"ceil\" alignment for\n+\t     This means that bit-packed arrays have \"ceil\" alignment for\n \t     their size, which may seem counter-intuitive but makes it\n \t     possible to easily overlay them on modular types.  */\n \t  TYPE_ALIGN (gnu_type) = TYPE_ALIGN (gnu_field_type);\n@@ -1650,7 +1659,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  finish_record_type (gnu_type, gnu_field, 0, false);\n \t  TYPE_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n-\t  SET_TYPE_ADA_SIZE (gnu_type, bitsize_int (esize));\n \n \t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n \t}\n@@ -1663,8 +1671,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       && (align = UI_To_Int (Alignment (gnat_entity)) * BITS_PER_UNIT)\n \t       && align < TYPE_ALIGN (gnu_type))\n \t{\n-\t  tree gnu_field_type = gnu_type;\n-\t  tree gnu_field;\n+\t  tree gnu_field_type, gnu_field;\n+\n+\t  /* Set the RM size before wrapping up the type.  */\n+\t  TYPE_RM_SIZE_NUM (gnu_type)\n+\t    = UI_To_gnu (RM_Size (gnat_entity), bitsizetype);\n+\t  gnu_field_type = gnu_type;\n \n \t  gnu_type = make_node (RECORD_TYPE);\n \t  TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"PAD\");\n@@ -1685,7 +1697,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  finish_record_type (gnu_type, gnu_field, 0, false);\n \t  TYPE_IS_PADDING_P (gnu_type) = 1;\n-\t  SET_TYPE_ADA_SIZE (gnu_type, bitsize_int (esize));\n \n \t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n \t}"}, {"sha": "478e893681287e3a182791efa3de2d8f2cc16cd3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0f0975e5368803451b2642fb4ecc598310a2e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0f0975e5368803451b2642fb4ecc598310a2e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e0f0975e5368803451b2642fb4ecc598310a2e4", "patch": "@@ -1,3 +1,7 @@\n+2009-04-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/small_alignment.ads: New test.\n+\n 2009-04-20  Ian Lance Taylor  <iant@google.com>\n \n \t* gcc.dg/Wcxx-compat-3.c: New testcase."}, {"sha": "318148d1a68b0a3f6de2194b442ce9289fee3429", "filename": "gcc/testsuite/gnat.dg/specs/small_alignment.ads", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0f0975e5368803451b2642fb4ecc598310a2e4/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsmall_alignment.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0f0975e5368803451b2642fb4ecc598310a2e4/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsmall_alignment.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsmall_alignment.ads?ref=6e0f0975e5368803451b2642fb4ecc598310a2e4", "patch": "@@ -0,0 +1,13 @@\n+-- { dg-compile }\n+\n+package Small_Alignment is\n+\n+  type Int is range -512 .. 511;\n+  for Int'Alignment use 1;\n+\n+  type R is record\n+    I: Int;\n+  end record;\n+  Pragma Pack (R);\n+\n+end Small_Alignment;"}]}