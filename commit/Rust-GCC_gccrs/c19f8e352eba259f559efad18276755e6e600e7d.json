{"sha": "c19f8e352eba259f559efad18276755e6e600e7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE5ZjhlMzUyZWJhMjU5ZjU1OWVmYWQxODI3Njc1NWU2ZTYwMGU3ZA==", "commit": {"author": {"name": "Nicola Pero", "email": "n.pero@mi.flashnet.it", "date": "2003-07-10T09:24:51Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2003-07-10T09:24:51Z"}, "message": "Fixed rare threading problem\n\nFrom-SVN: r69181", "tree": {"sha": "ddc4865c614c5e7c084b3e2b44cba9d112c9ccc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddc4865c614c5e7c084b3e2b44cba9d112c9ccc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c19f8e352eba259f559efad18276755e6e600e7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c19f8e352eba259f559efad18276755e6e600e7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c19f8e352eba259f559efad18276755e6e600e7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c19f8e352eba259f559efad18276755e6e600e7d/comments", "author": null, "committer": null, "parents": [{"sha": "633221dbab4b06bae16c5cd3b6da0c91608fb5ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/633221dbab4b06bae16c5cd3b6da0c91608fb5ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/633221dbab4b06bae16c5cd3b6da0c91608fb5ff"}], "stats": {"total": 81, "additions": 67, "deletions": 14}, "files": [{"sha": "433baed342e097659d1a30efc7e4b28411aedbf1", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c19f8e352eba259f559efad18276755e6e600e7d/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c19f8e352eba259f559efad18276755e6e600e7d/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=c19f8e352eba259f559efad18276755e6e600e7d", "patch": "@@ -1,3 +1,12 @@\n+Thu Jul 10 10:27:43 2003  Nicola Pero  <n.pero@mi.flashnet.it>\n+\n+\tlibobjc/9969\n+\t* sendmsg.c (get_imp): Fixed rare threading problem.\n+\t(__objc_responds_to): Similar fixes.\n+\t(objc_msg_lookup): Similar fixes.\n+\t(__objc_init_install_dtable): Lock the runtime before checking if the\n+\ttable is installed.\n+\t\n 2003-05-23  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* hash.c, init.c, libobjc.def, libobjc_entry.c, linking.m,"}, {"sha": "0214e77afcd88732519037c10cbea8c9a3ac88c7", "filename": "libobjc/sendmsg.c", "status": "modified", "additions": 58, "deletions": 14, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c19f8e352eba259f559efad18276755e6e600e7d/libobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c19f8e352eba259f559efad18276755e6e600e7d/libobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsendmsg.c?ref=c19f8e352eba259f559efad18276755e6e600e7d", "patch": "@@ -119,6 +119,14 @@ __inline__\n IMP\n get_imp (Class class, SEL sel)\n {\n+  /* In a vanilla implementation we would first check if the dispatch\n+     table is installed.  Here instead, to get more speed in the\n+     standard case (that the dispatch table is installed) we first try\n+     to get the imp using brute force.  Only if that fails, we do what\n+     we should have been doing from the very beginning, that is, check\n+     if the dispatch table needs to be installed, install it if it's\n+     not installed, and retrieve the imp from the table if it's\n+     installed.  */\n   void *res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);\n   if (res == 0)\n     {\n@@ -127,18 +135,39 @@ get_imp (Class class, SEL sel)\n \t{\n \t  /* The dispatch table needs to be installed. */\n \t  objc_mutex_lock (__objc_runtime_mutex);\n-\t  __objc_install_dispatch_table_for_class (class);\n+\n+\t   /* Double-checked locking pattern: Check\n+\t      __objc_uninstalled_dtable again in case another thread\n+\t      installed the dtable while we were waiting for the lock\n+\t      to be released.  */\n+         if (class->dtable == __objc_uninstalled_dtable)\n+           {\n+             __objc_install_dispatch_table_for_class (class);\n+           }\n+\n \t  objc_mutex_unlock (__objc_runtime_mutex);\n \t  /* Call ourselves with the installed dispatch table\n \t     and get the real method */\n \t  res = get_imp (class, sel);\n \t}\n       else\n \t{\n-\t  /* The dispatch table has been installed so the\n-\t     method just doesn't exist for the class.\n-\t     Return the forwarding implementation. */\n-\t  res = __objc_get_forward_imp (sel);\n+\t  /* The dispatch table has been installed.  */\n+\n+         /* Get the method from the dispatch table (we try to get it\n+\t    again in case another thread has installed the dtable just\n+\t    after we invoked sarray_get_safe, but before we checked\n+\t    class->dtable == __objc_uninstalled_dtable).\n+         */\n+\t  res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);\n+\t  if (res == 0)\n+\t    {\n+\t      /* The dispatch table has been installed, and the method\n+\t\t is not in the dispatch table.  So the method just\n+\t\t doesn't exist for the class.  Return the forwarding\n+\t\t implementation. */\n+\t      res = __objc_get_forward_imp (sel);\n+\t    }\n \t}\n     }\n   return res;\n@@ -157,7 +186,10 @@ __objc_responds_to (id object, SEL sel)\n   if (object->class_pointer->dtable == __objc_uninstalled_dtable)\n     {\n       objc_mutex_lock (__objc_runtime_mutex);\n-      __objc_install_dispatch_table_for_class (object->class_pointer);\n+      if (object->class_pointer->dtable == __objc_uninstalled_dtable)\n+\t{\n+\t  __objc_install_dispatch_table_for_class (object->class_pointer);\n+\t}\n       objc_mutex_unlock (__objc_runtime_mutex);\n     }\n \n@@ -192,10 +224,19 @@ objc_msg_lookup (id receiver, SEL op)\n \t    }\n \t  else\n \t    {\n-\t      /* The dispatch table has been installed so the\n-\t\t method just doesn't exist for the class.\n-\t\t Attempt to forward the method. */\n-\t      result = __objc_get_forward_imp (op);\n+\t      /* The dispatch table has been installed.  Check again\n+\t\t if the method exists (just in case the dispatch table\n+\t\t has been installed by another thread after we did the\n+\t\t previous check that the method exists).\n+\t      */\n+\t      result = sarray_get_safe (receiver->class_pointer->dtable,\n+\t\t\t\t\t(sidx)op->sel_id);\n+\t      if (result == 0)\n+\t\t{\n+\t\t  /* If the method still just doesn't exist for the\n+\t\t     class, attempt to forward the method. */\n+\t\t  result = __objc_get_forward_imp (op);\n+\t\t}\n \t    }\n \t}\n       return result;\n@@ -239,13 +280,16 @@ __objc_init_dispatch_tables ()\n static void\n __objc_init_install_dtable (id receiver, SEL op __attribute__ ((__unused__)))\n {\n+  objc_mutex_lock (__objc_runtime_mutex);\n+  \n   /* This may happen, if the programmer has taken the address of a \n      method before the dtable was initialized... too bad for him! */\n   if (receiver->class_pointer->dtable != __objc_uninstalled_dtable)\n-    return;\n-\n-  objc_mutex_lock (__objc_runtime_mutex);\n-\n+    {\n+      objc_mutex_unlock (__objc_runtime_mutex);\n+      return;\n+    }\n+  \n   if (CLS_ISCLASS (receiver->class_pointer))\n     {\n       /* receiver is an ordinary object */"}]}