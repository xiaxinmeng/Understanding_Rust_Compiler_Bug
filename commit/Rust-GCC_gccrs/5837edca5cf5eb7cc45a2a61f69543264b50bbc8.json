{"sha": "5837edca5cf5eb7cc45a2a61f69543264b50bbc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgzN2VkY2E1Y2Y1ZWI3Y2M0NWEyYTYxZjY5NTQzMjY0YjUwYmJjOA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-12-19T22:09:00Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-12-19T22:09:00Z"}, "message": "PR c++/83394 - always_inline vs. noinline no longer diagnosed\n\nPR c++/83394 - always_inline vs. noinline no longer diagnosed\nPR c++/83322 - ICE: tree check: expected class \u2018type\u2019, have \u2018exceptional\u2019\n\ngcc/cp/ChangeLog:\n\n\tPR c++/83394\n\tPR c++/83322\n\t* decl2.c (cplus_decl_attributes): Look up member functions\n\tin the scope of their class.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/83394\n\t* g++.dg/Wattributes-3.C: New test.\n\t* g++.dg/Wattributes-4.C: New test.\n\t* g++.dg/Wattributes-5.C: New test.\n\nFrom-SVN: r255844", "tree": {"sha": "4edb5b94d34e42be541d40917ea365d8ba308efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4edb5b94d34e42be541d40917ea365d8ba308efd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5837edca5cf5eb7cc45a2a61f69543264b50bbc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5837edca5cf5eb7cc45a2a61f69543264b50bbc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5837edca5cf5eb7cc45a2a61f69543264b50bbc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0cbe950d2475c51d8df2cc3a5afd55ff537d25cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cbe950d2475c51d8df2cc3a5afd55ff537d25cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cbe950d2475c51d8df2cc3a5afd55ff537d25cc"}], "stats": {"total": 236, "additions": 214, "deletions": 22}, "files": [{"sha": "831cb23edd902f899219ed871cb7f0dff3faf35a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5837edca5cf5eb7cc45a2a61f69543264b50bbc8", "patch": "@@ -1,3 +1,10 @@\n+2017-12-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/83394\n+\tPR c++/83322\n+\t* decl2.c (cplus_decl_attributes): Look up member functions\n+\tin the scope of their class.\n+\n 2017-12-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* name-lookup.c (get_std_name_hint): Replace Yoda conditions with"}, {"sha": "d5111d58cca10263f3632f737e2a9be39fc39122", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5837edca5cf5eb7cc45a2a61f69543264b50bbc8", "patch": "@@ -1445,6 +1445,52 @@ cp_omp_mappable_type (tree type)\n   return true;\n }\n \n+/* Return the last pushed declaration for the symbol DECL or NULL\n+   when no such declaration exists.  */\n+\n+static tree\n+find_last_decl (tree decl)\n+{\n+  tree last_decl = NULL_TREE;\n+\n+  if (tree name = DECL_P (decl) ? DECL_NAME (decl) : NULL_TREE)\n+    {\n+      /* Look up the declaration in its scope.  */\n+      tree pushed_scope = NULL_TREE;\n+      if (tree ctype = DECL_CONTEXT (decl))\n+\tpushed_scope = push_scope (ctype);\n+\n+      last_decl = lookup_name (name);\n+\n+      if (pushed_scope)\n+\tpop_scope (pushed_scope);\n+\n+      /* The declaration may be a member conversion operator\n+\t or a bunch of overfloads (handle the latter below).  */\n+      if (last_decl && BASELINK_P (last_decl))\n+\tlast_decl = BASELINK_FUNCTIONS (last_decl);\n+    }\n+\n+  if (!last_decl)\n+    return NULL_TREE;\n+\n+  if (DECL_P (last_decl) || TREE_CODE (last_decl) == OVERLOAD)\n+    {\n+      /* A set of overloads of the same function.  */\n+      for (lkp_iterator iter (last_decl); iter; ++iter)\n+\t{\n+\t  if (TREE_CODE (*iter) == OVERLOAD)\n+\t    continue;\n+\n+\t  if (decls_match (decl, *iter, /*record_decls=*/false))\n+\t    return *iter;\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Like decl_attributes, but handle C++ complexity.  */\n \n void\n@@ -1496,28 +1542,7 @@ cplus_decl_attributes (tree *decl, tree attributes, int flags)\n     }\n   else\n     {\n-      tree last_decl = (DECL_P (*decl) && DECL_NAME (*decl)\n-\t\t\t? lookup_name (DECL_NAME (*decl)) : NULL_TREE);\n-\n-      if (last_decl && TREE_CODE (last_decl) == OVERLOAD)\n-\tfor (ovl_iterator iter (last_decl, true); ; ++iter)\n-\t  {\n-\t    if (!iter)\n-\t      {\n-\t\tlast_decl = NULL_TREE;\n-\t\tbreak;\n-\t      }\n-\n-\t    if (TREE_CODE (*iter) == OVERLOAD)\n-\t      continue;\n-\n-\t    if (decls_match (*decl, *iter, /*record_decls=*/false))\n-\t      {\n-\t\tlast_decl = *iter;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\n+      tree last_decl = find_last_decl (*decl);\n       decl_attributes (decl, attributes, flags, last_decl);\n     }\n "}, {"sha": "cb9e01223d42f0ee50956db092b2bf85006e53a4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5837edca5cf5eb7cc45a2a61f69543264b50bbc8", "patch": "@@ -1,3 +1,10 @@\n+2017-12-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/83394\n+\t* g++.dg/Wattributes-3.C: New test.\n+\t* g++.dg/Wattributes-4.C: New test.\n+\t* g++.dg/Wattributes-5.C: New test.\n+\n 2017-12-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/82975"}, {"sha": "a70176b14b63fecd1355e07531492c60e89cd123", "filename": "gcc/testsuite/g++.dg/Wattributes-3.C", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWattributes-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWattributes-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWattributes-3.C?ref=5837edca5cf5eb7cc45a2a61f69543264b50bbc8", "patch": "@@ -0,0 +1,90 @@\n+// PR c++/83394 - always_inline vs. noinline no longer diagnosed\n+// { dg-do compile }\n+// { dg-options \"-Wattributes\" }\n+\n+#define ATTR(list) __attribute__ (list)\n+\n+struct A\n+{\n+  ATTR ((__noinline__)) operator int ();\n+};\n+\n+ATTR ((__always_inline__))\n+A::operator int ()            // { dg-warning \"ignoring attribute .always_inline. because it conflicts with attribute .noinline.\" }\n+{\n+  return 0;\n+}\n+\n+\n+struct B\n+{\n+  operator char () const;\n+  ATTR ((__always_inline__)) operator int () const;\n+};\n+\n+B::operator char () const { return 0; }\n+\n+ATTR ((__noinline__))\n+B::operator int () const      // { dg-warning \"ignoring attribute .noinline. because it conflicts with attribute .always_inline.\" }\n+{\n+  return 0;\n+}\n+\n+\n+struct C\n+{\n+  operator char ();\n+  ATTR ((__always_inline__)) operator short ();\n+  operator int ();\n+  ATTR ((__noinline__)) operator long ();\n+};\n+\n+C::operator char () { return 0; }\n+\n+ATTR ((__noinline__))\n+C::operator short ()           // { dg-warning \"ignoring attribute .noinline. because it conflicts with attribute .always_inline.\" }\n+{ return 0; }\n+\n+inline ATTR ((__noinline__))\n+C::operator int ()\n+{ return 0; }\n+\n+\n+ATTR ((__always_inline__))\n+C::operator long ()           // { dg-warning \"ignoring attribute .always_inline. because it conflicts with attribute .noinline.\" }\n+{ return 0; }\n+\n+\n+struct D\n+{\n+  int foo ();\n+  int foo (int);\n+  int ATTR ((const)) foo (int, int);\n+  int ATTR ((pure)) foo (int, int, int);\n+\n+  int ATTR ((const)) foo (int, int, int, int);\n+\n+  int foo (int, int, int, int, int);\n+};\n+\n+int ATTR ((const))\n+D::foo ()\n+{ return 0; }\n+\n+int ATTR ((pure))\n+D::foo (int)\n+{ return 0; }\n+\n+int ATTR ((pure))\n+D::foo (int, int)             // { dg-warning \"ignoring attribute .pure. because it conflicts with attribute .const.\" }\n+{ return 0; }\n+\n+int ATTR ((const))\n+D::foo (int, int, int)        // { dg-warning \"ignoring attribute .const. because it conflicts with attribute .pure.\" }\n+{ return 0; }\n+\n+int\n+D::foo (int, int, int, int) { return 0; }\n+\n+int ATTR ((const))\n+D::foo (int, int, int, int, int) { return 0; }"}, {"sha": "c925225d3a89eef735bb79c4fe456112f1e93d78", "filename": "gcc/testsuite/g++.dg/Wattributes-4.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWattributes-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWattributes-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWattributes-4.C?ref=5837edca5cf5eb7cc45a2a61f69543264b50bbc8", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/83322 - ICE: tree check: expected class \u2018type\u2019, have \u2018exceptional\u2019\n+// (baselink) in diag_attr_exclusions, at attribs.c:393\n+// { dg-do compile }\n+// { dg-options \"-Wattributes\" }\n+\n+#define ATTR(list) __attribute__ (list)\n+\n+// Test case from comment #0.\n+struct A0\n+{\n+  template <class T> operator T();\n+  ATTR ((always_inline)) operator int();\n+};\n+\n+// Test case from comment #4.\n+struct A1\n+{\n+  void foo();\n+};\n+\n+struct B\n+{\n+  bool foo;\n+};\n+\n+struct C: A1, B\n+{\n+  ATTR ((warn_unused_result)) int foo ();\n+};"}, {"sha": "70116c92ae89de03d9872eebfe5683f41628833c", "filename": "gcc/testsuite/g++.dg/Wattributes-5.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWattributes-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5837edca5cf5eb7cc45a2a61f69543264b50bbc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWattributes-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWattributes-5.C?ref=5837edca5cf5eb7cc45a2a61f69543264b50bbc8", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile }\n+// { dg-options \"-Wattributes\" }\n+\n+#define ATTR(list) __attribute__ (list)\n+\n+template <int>\n+struct A\n+{\n+  int __attribute__ ((noinline))\n+  f ();                       // { dg-message \"previous declaration here\" }\n+};\n+\n+template <int N>\n+int __attribute__ ((always_inline))\n+A<N>::f ()                    // { dg-warning \"ignoring attribute .always_inline. because it conflicts with attribute .noinline.\" } */\n+{ return 0; }\n+\n+\n+template <int>\n+struct B\n+{\n+  int __attribute__ ((always_inline))\n+  f ();\n+};\n+\n+template <>\n+inline int __attribute__ ((always_inline))\n+B<0>::f ()\n+{ return 0; }\n+\n+template <>\n+int __attribute__ ((noinline))\n+B<1>::f ()\n+{ return 1; }"}]}