{"sha": "3ba1236fc8cac5ccf80f7f53a8b9252b66403b56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JhMTIzNmZjOGNhYzVjY2Y4MGY3ZjUzYThiOTI1MmI2NjQwM2I1Ng==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-12-25T05:46:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-12-25T05:46:32Z"}, "message": "pa.c (output_function_epilogue): Use assemble_integer rather than calling ASM_OUTPUT_INT directly.\n\n        * pa.c (output_function_epilogue): Use assemble_integer rather\n        than calling ASM_OUTPUT_INT directly.\n        * pa.h (ASM_OUTPUT_INT): Use plabels for everything in the\n        exception table section.\n\n        * pa.c (print_operand): Don't call fprintf to output a register\n        name.  Use fputs instead.\n\nFrom-SVN: r10861", "tree": {"sha": "be5cbb1f4b92bf94e9c6ad10fd643b2b86aec2b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be5cbb1f4b92bf94e9c6ad10fd643b2b86aec2b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ba1236fc8cac5ccf80f7f53a8b9252b66403b56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba1236fc8cac5ccf80f7f53a8b9252b66403b56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ba1236fc8cac5ccf80f7f53a8b9252b66403b56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba1236fc8cac5ccf80f7f53a8b9252b66403b56/comments", "author": null, "committer": null, "parents": [{"sha": "435b1237b12c65e34bb7475ccccd9b06edefa301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/435b1237b12c65e34bb7475ccccd9b06edefa301", "html_url": "https://github.com/Rust-GCC/gccrs/commit/435b1237b12c65e34bb7475ccccd9b06edefa301"}], "stats": {"total": 16, "additions": 11, "deletions": 5}, "files": [{"sha": "ed019cbeb0897ed3e04bbadac572a9ca338db99d", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba1236fc8cac5ccf80f7f53a8b9252b66403b56/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba1236fc8cac5ccf80f7f53a8b9252b66403b56/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=3ba1236fc8cac5ccf80f7f53a8b9252b66403b56", "patch": "@@ -2320,7 +2320,7 @@ output_function_epilogue (file, size)\n   for (i = 0; i < n_deferred_plabels; i++)\n     {\n       ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (deferred_plabels[i].internal_label));\n-      ASM_OUTPUT_INT (file, deferred_plabels[i].symbol);\n+      assemble_integer (deferred_plabels[i].symbol, 4, 1);\n     }\n   n_deferred_plabels = 0;\n }\n@@ -3065,10 +3065,9 @@ print_operand (file, x, code)\n     }\n   if (GET_CODE (x) == REG)\n     {\n+      fputs (reg_names [REGNO (x)], file);\n       if (FP_REG_P (x) && GET_MODE_SIZE (GET_MODE (x)) <= 4 && (REGNO (x) & 1) == 0)\n-\tfprintf (file, \"%sL\", reg_names [REGNO (x)]);\n-      else\n-\tfprintf (file, \"%s\", reg_names [REGNO (x)]);\n+\tfputs (\"L\", file);\n     }\n   else if (GET_CODE (x) == MEM)\n     {"}, {"sha": "8e1d89a58ce9383b4bdbba71f45f9db59aa5fb54", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba1236fc8cac5ccf80f7f53a8b9252b66403b56/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba1236fc8cac5ccf80f7f53a8b9252b66403b56/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=3ba1236fc8cac5ccf80f7f53a8b9252b66403b56", "patch": "@@ -2018,13 +2018,20 @@ DTORS_SECTION_FUNCTION\n        fprintf (FILE, \"\\t.word 0x%lx\\n\", l);\t\t\t\t\\\n      } while (0)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n+/* This is how to output an assembler line defining an `int' constant. \n+\n+   This is made more complicated by the fact that functions must be\n+   prefixed by a P% as well as code label references for the exception\n+   table -- otherwise the linker chokes.  */\n \n #define ASM_OUTPUT_INT(FILE,VALUE)  \\\n { fputs (\"\\t.word \", FILE);\t\t\t\\\n   if (function_label_operand (VALUE, VOIDmode)\t\\\n       && !TARGET_PORTABLE_RUNTIME)\t\t\\\n     fputs (\"P%\", FILE);\t\t\t\\\n+  if (in_section == in_named\t\t\\\n+      && ! strcmp (\".gcc_except_table\", in_named_name))\\\n+    fputs (\"P%\", FILE);\t\t\t\\\n   output_addr_const (FILE, (VALUE));\t\t\\\n   fputs (\"\\n\", FILE);}\n "}]}