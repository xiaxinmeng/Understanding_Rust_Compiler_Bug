{"sha": "5ecfc99a62d3a8069689275708703baf0cc5a192", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVjZmM5OWE2MmQzYTgwNjk2ODkyNzU3MDg3MDNiYWYwY2M1YTE5Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-04-30T12:09:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-04-30T12:09:28Z"}, "message": "expr.c (store_constructor): SIZE operand is now in bits...\n\n\t* expr.c (store_constructor): SIZE operand is now in bits; CLEARED\n\tless than zero now means emitted CLOBBER already.\n\t(store_constructor_field, expand_expr_real): Reflect above changes.\n\nFrom-SVN: r81335", "tree": {"sha": "e42c8d5f952b38c6694e65f0bdad260e87412688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e42c8d5f952b38c6694e65f0bdad260e87412688"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ecfc99a62d3a8069689275708703baf0cc5a192", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ecfc99a62d3a8069689275708703baf0cc5a192", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ecfc99a62d3a8069689275708703baf0cc5a192", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ecfc99a62d3a8069689275708703baf0cc5a192/comments", "author": null, "committer": null, "parents": [{"sha": "e344dbf315197023671560d95663f162483c32f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e344dbf315197023671560d95663f162483c32f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e344dbf315197023671560d95663f162483c32f4"}], "stats": {"total": 67, "additions": 42, "deletions": 25}, "files": [{"sha": "f8cea4740ff7faa95f2c7fab053430ec8c248563", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ecfc99a62d3a8069689275708703baf0cc5a192/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ecfc99a62d3a8069689275708703baf0cc5a192/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ecfc99a62d3a8069689275708703baf0cc5a192", "patch": "@@ -1,3 +1,9 @@\n+2004-04-30  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (store_constructor): SIZE operand is now in bits; CLEARED\n+\tless than zero now means emitted CLOBBER already.\n+\t(store_constructor_field, expand_expr_real): Reflect above changes.\n+\n 2004-04-30  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* flow.c (propagate_one_insn): Call mark_set_regs for stack pointer"}, {"sha": "2afe44db287a96b993018d5b32b7a112b1599e3c", "filename": "gcc/expr.c", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ecfc99a62d3a8069689275708703baf0cc5a192/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ecfc99a62d3a8069689275708703baf0cc5a192/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5ecfc99a62d3a8069689275708703baf0cc5a192", "patch": "@@ -4515,7 +4515,7 @@ store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n \t  set_mem_alias_set (target, alias_set);\n \t}\n \n-      store_constructor (exp, target, cleared, bitsize / BITS_PER_UNIT);\n+      store_constructor (exp, target, cleared, bitsize);\n     }\n   else\n     store_field (target, bitsize, bitpos, mode, exp, VOIDmode, 0, type,\n@@ -4525,8 +4525,10 @@ store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n /* Store the value of constructor EXP into the rtx TARGET.\n    TARGET is either a REG or a MEM; we know it cannot conflict, since\n    safe_from_p has been called.\n-   CLEARED is true if TARGET is known to have been zero'd.\n-   SIZE is the number of bytes of TARGET we are allowed to modify: this\n+   CLEARED is positive if TARGET is known to have been zeroed, zero if\n+   this is the top level of calls to store_constructor, and negative\n+   if this is a recursive call but no clearing has been done.\n+   SIZE is the number of bits of TARGET we are allowed to modify: this\n    may not be the same as the size of EXP if we are assigning to a field\n    which has been packed to exclude padding bits.  */\n \n@@ -4543,16 +4545,19 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n     {\n       tree elt;\n \n-      /* If size is zero or the target is already cleared, do nothing.  */\n-      if (size == 0 || cleared)\n+      /* If this is not the top level, we don't do any initialization.  */\n+      if (cleared)\n+\t;\n+      /* If the size is zero, pretend we've cleared it.  */\n+      else if (size == 0)\n \tcleared = 1;\n       /* We either clear the aggregate or indicate the value is dead.  */\n       else if ((TREE_CODE (type) == UNION_TYPE\n \t\t|| TREE_CODE (type) == QUAL_UNION_TYPE)\n \t       && ! CONSTRUCTOR_ELTS (exp))\n \t/* If the constructor is empty, clear the union.  */\n \t{\n-\t  clear_storage (target, expr_size (exp));\n+\t  clear_storage (target, GEN_INT (size / BITS_PER_UNIT));\n \t  cleared = 1;\n \t}\n \n@@ -4575,7 +4580,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n       else if (((list_length (CONSTRUCTOR_ELTS (exp)) != fields_length (type))\n \t\t|| mostly_zeros_p (exp))\n \t       && (GET_CODE (target) != REG\n-\t\t   || ((HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (target))\n+\t\t   || ((HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (target))\n \t\t       == size)))\n \t{\n \t  rtx xtarget = target;\n@@ -4586,12 +4591,14 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      RTX_UNCHANGING_P (xtarget) = 1;\n \t    }\n \n-\t  clear_storage (xtarget, GEN_INT (size));\n+\t  clear_storage (xtarget, GEN_INT (size / BITS_PER_UNIT));\n \t  cleared = 1;\n \t}\n-\n-      if (! cleared)\n-\temit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n+      else\n+\t{\n+\t  emit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n+\t  cleared = -1;\n+\t}\n \n       /* Store each element of the constructor into\n \t the corresponding field of TARGET.  */\n@@ -4612,7 +4619,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t  if (field == 0)\n \t    continue;\n \n-\t  if (cleared && is_zeros_p (value))\n+\t  if (cleared > 0 && is_zeros_p (value))\n \t    continue;\n \n \t  if (host_integerp (DECL_SIZE (field), 1))\n@@ -4822,13 +4829,17 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      if (REG_P (target))\n \t\temit_move_insn (target,  CONST0_RTX (GET_MODE (target)));\n \t      else\n-\t\tclear_storage (target, GEN_INT (size));\n+\t\tclear_storage (target, GEN_INT (size / BITS_PER_UNIT));\n+\n+\t      cleared = 1;\n \t    }\n-\t  cleared = 1;\n \t}\n       else if (REG_P (target))\n-\t/* Inform later passes that the old value is dead.  */\n-\temit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n+\t{\n+\t  /* Inform later passes that the old value is dead.  */\n+\t  emit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n+\t  cleared = -1;\n+\t}\n \n       /* Store each element of the constructor into\n \t the corresponding element of TARGET, determined\n@@ -4845,7 +4856,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t  tree index = TREE_PURPOSE (elt);\n \t  rtx xtarget = target;\n \n-\t  if (cleared && is_zeros_p (value))\n+\t  if (cleared > 0 && is_zeros_p (value))\n \t    continue;\n \n \t  unsignedp = TYPE_UNSIGNED (elttype);\n@@ -4939,8 +4950,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t\t\t    highest_pow2_factor (position));\n \t\t  xtarget = adjust_address (xtarget, mode, 0);\n \t\t  if (TREE_CODE (value) == CONSTRUCTOR)\n-\t\t    store_constructor (value, xtarget, cleared,\n-\t\t\t\t       bitsize / BITS_PER_UNIT);\n+\t\t    store_constructor (value, xtarget, cleared, bitsize);\n \t\t  else\n \t\t    store_expr (value, xtarget, 0);\n \n@@ -5038,8 +5048,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n       /* Check for all zeros.  */\n       if (elt == NULL_TREE && size > 0)\n \t{\n-\t  if (!cleared)\n-\t    clear_storage (target, GEN_INT (size));\n+\t  if (cleared <= 0)\n+\t    clear_storage (target, GEN_INT (size / BITS_PER_UNIT));\n \t  return;\n \t}\n \n@@ -5079,7 +5089,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      bit_pos++;  ibit++;\n \t      if (bit_pos >= set_word_size || ibit == nbits)\n \t\t{\n-\t\t  if (word != 0 || ! cleared)\n+\t\t  if (word != 0 || cleared <= 0)\n \t\t    {\n \t\t      rtx datum = gen_int_mode (word, mode);\n \t\t      rtx to_rtx;\n@@ -5104,7 +5114,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t}\n \t    }\n \t}\n-      else if (!cleared)\n+      else if (cleared <= 0)\n \t/* Don't bother clearing storage if the set is all ones.  */\n \tif (TREE_CHAIN (elt) != NULL_TREE\n \t    || (TREE_PURPOSE (elt) == NULL_TREE\n@@ -5114,7 +5124,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t   || (tree_low_cst (TREE_VALUE (elt), 0)\n \t\t       - tree_low_cst (TREE_PURPOSE (elt), 0) + 1\n \t\t       != (HOST_WIDE_INT) nbits))))\n-\t  clear_storage (target, expr_size (exp));\n+\t  clear_storage (target, GEN_INT (size / BITS_PER_UNIT));\n \n       for (; elt != NULL_TREE; elt = TREE_CHAIN (elt))\n \t{\n@@ -6742,7 +6752,8 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t\t\t       * TYPE_QUAL_CONST))),\n \t\t\t     0, TREE_ADDRESSABLE (exp), 1);\n \n-\t  store_constructor (exp, target, 0, int_expr_size (exp));\n+\t  store_constructor (exp, target, 0,\n+\t\t\t     int_expr_size (exp) * BITS_PER_UNIT);\n \t  return target;\n \t}\n "}]}