{"sha": "63b2149fb4b0bd16c44ab9485cfdc37149e97b97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNiMjE0OWZiNGIwYmQxNmM0NGFiOTQ4NWNmZGMzNzE0OWU5N2I5Nw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-26T14:58:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-26T15:00:25Z"}, "message": "Refactor SLP instance analysis\n\nThis refactors the toplevel entry to analyze an SLP instance to\nexpose a worker analyzing from a vector of stmts and an SLP entry\nkind.\n\n2020-10-26  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (enum slp_instance_kind): New.\n\t(vect_build_slp_instance): Split out from...\n\t(vect_analyze_slp_instance): ... this.", "tree": {"sha": "8a30e6418cd0cbe28aba66b16e3724b9ff9d3a04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a30e6418cd0cbe28aba66b16e3724b9ff9d3a04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63b2149fb4b0bd16c44ab9485cfdc37149e97b97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63b2149fb4b0bd16c44ab9485cfdc37149e97b97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63b2149fb4b0bd16c44ab9485cfdc37149e97b97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63b2149fb4b0bd16c44ab9485cfdc37149e97b97/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "425bb53b54aece8ffe8298686c9ba5259ab17b0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/425bb53b54aece8ffe8298686c9ba5259ab17b0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/425bb53b54aece8ffe8298686c9ba5259ab17b0e"}], "stats": {"total": 260, "additions": 152, "deletions": 108}, "files": [{"sha": "014bcba78198dda94115eb932c7d3eb545829bd1", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 152, "deletions": 108, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63b2149fb4b0bd16c44ab9485cfdc37149e97b97/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63b2149fb4b0bd16c44ab9485cfdc37149e97b97/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=63b2149fb4b0bd16c44ab9485cfdc37149e97b97", "patch": "@@ -1997,124 +1997,50 @@ calculate_unrolling_factor (poly_uint64 nunits, unsigned int group_size)\n   return exact_div (common_multiple (nunits, group_size), group_size);\n }\n \n-/* Analyze an SLP instance starting from a group of grouped stores.  Call\n-   vect_build_slp_tree to build a tree of packed stmts if possible.\n-   Return FALSE if it's impossible to SLP any stmt in the loop.  */\n+enum slp_instance_kind {\n+    slp_inst_kind_store,\n+    slp_inst_kind_reduc_group,\n+    slp_inst_kind_reduc_chain,\n+    slp_inst_kind_ctor\n+};\n \n static bool\n vect_analyze_slp_instance (vec_info *vinfo,\n \t\t\t   scalar_stmts_to_slp_tree_map_t *bst_map,\n-\t\t\t   stmt_vec_info stmt_info, unsigned max_tree_size)\n-{\n-  slp_instance new_instance;\n-  slp_tree node;\n-  unsigned int group_size;\n-  unsigned int i;\n-  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  vec<stmt_vec_info> scalar_stmts;\n-  bool constructor = false;\n-\n-  if (is_a <bb_vec_info> (vinfo))\n-    vect_location = stmt_info->stmt;\n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    {\n-      group_size = DR_GROUP_SIZE (stmt_info);\n-    }\n-  else if (!dr && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n-    {\n-      gcc_assert (is_a <loop_vec_info> (vinfo));\n-      group_size = REDUC_GROUP_SIZE (stmt_info);\n-    }\n-  else if (is_gimple_assign (stmt_info->stmt)\n-\t    && gimple_assign_rhs_code (stmt_info->stmt) == CONSTRUCTOR)\n-    {\n-      group_size = CONSTRUCTOR_NELTS (gimple_assign_rhs1 (stmt_info->stmt));\n-      constructor = true;\n-    }\n-  else\n-    {\n-      gcc_assert (is_a <loop_vec_info> (vinfo));\n-      group_size = as_a <loop_vec_info> (vinfo)->reductions.length ();\n-    }\n+\t\t\t   stmt_vec_info stmt_info, unsigned max_tree_size);\n \n-  /* Create a node (a root of the SLP tree) for the packed grouped stores.  */\n-  scalar_stmts.create (group_size);\n-  stmt_vec_info next_info = stmt_info;\n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    {\n-      /* Collect the stores and store them in SLP_TREE_SCALAR_STMTS.  */\n-      while (next_info)\n-        {\n-\t  scalar_stmts.safe_push (vect_stmt_to_vectorize (next_info));\n-\t  next_info = DR_GROUP_NEXT_ELEMENT (next_info);\n-        }\n-    }\n-  else if (!dr && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n-    {\n-      /* Collect the reduction stmts and store them in\n-\t SLP_TREE_SCALAR_STMTS.  */\n-      while (next_info)\n-        {\n-\t  scalar_stmts.safe_push (vect_stmt_to_vectorize (next_info));\n-\t  next_info = REDUC_GROUP_NEXT_ELEMENT (next_info);\n-        }\n-      /* Mark the first element of the reduction chain as reduction to properly\n-\t transform the node.  In the reduction analysis phase only the last\n-\t element of the chain is marked as reduction.  */\n-      STMT_VINFO_DEF_TYPE (stmt_info)\n-\t= STMT_VINFO_DEF_TYPE (scalar_stmts.last ());\n-      STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info))\n-\t= STMT_VINFO_REDUC_DEF (vect_orig_stmt (scalar_stmts.last ()));\n-    }\n-  else if (constructor)\n-    {\n-      tree rhs = gimple_assign_rhs1 (stmt_info->stmt);\n-      tree val;\n-      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), i, val)\n-\t{\n-\t  if (TREE_CODE (val) == SSA_NAME)\n-\t    {\n-\t      gimple* def = SSA_NAME_DEF_STMT (val);\n-\t      stmt_vec_info def_info = vinfo->lookup_stmt (def);\n-\t      /* Value is defined in another basic block.  */\n-\t      if (!def_info)\n-\t\treturn false;\n-\t      def_info = vect_stmt_to_vectorize (def_info);\n-\t      scalar_stmts.safe_push (def_info);\n-\t    }\n-\t  else\n-\t    return false;\n-\t}\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"Analyzing vectorizable constructor: %G\\n\",\n-\t\t\t stmt_info->stmt);\n-    }\n-  else\n-    {\n-      /* Collect reduction statements.  */\n-      vec<stmt_vec_info> reductions = as_a <loop_vec_info> (vinfo)->reductions;\n-      for (i = 0; reductions.iterate (i, &next_info); i++)\n-\tscalar_stmts.safe_push (next_info);\n-    }\n+/* Analyze an SLP instance starting from SCALAR_STMTS which are a group\n+   of KIND.  Return true if successful.  */\n \n+static bool\n+vect_build_slp_instance (vec_info *vinfo,\n+\t\t\t slp_instance_kind kind,\n+\t\t\t vec<stmt_vec_info> scalar_stmts,\n+\t\t\t stmt_vec_info root_stmt_info,\n+\t\t\t unsigned max_tree_size,\n+\t\t\t scalar_stmts_to_slp_tree_map_t *bst_map,\n+\t\t\t /* ???  We need stmt_info for group splitting.  */\n+\t\t\t stmt_vec_info stmt_info_)\n+{\n   if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t       \"Starting SLP discovery for\\n\");\n-      for (i = 0; i < scalar_stmts.length (); ++i)\n+      for (unsigned i = 0; i < scalar_stmts.length (); ++i)\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"  %G\", scalar_stmts[i]->stmt);\n     }\n \n   /* Build the tree for the SLP instance.  */\n+  unsigned int group_size = scalar_stmts.length ();\n   bool *matches = XALLOCAVEC (bool, group_size);\n   unsigned npermutes = 0;\n   poly_uint64 max_nunits = 1;\n   unsigned tree_size = 0;\n-  node = vect_build_slp_tree (vinfo, scalar_stmts, group_size,\n-\t\t\t      &max_nunits, matches, &npermutes,\n-\t\t\t      &tree_size, bst_map);\n+  unsigned i;\n+  slp_tree node = vect_build_slp_tree (vinfo, scalar_stmts, group_size,\n+\t\t\t\t       &max_nunits, matches, &npermutes,\n+\t\t\t\t       &tree_size, bst_map);\n   if (node != NULL)\n     {\n       /* Calculate the unrolling factor based on the smallest type.  */\n@@ -2148,11 +2074,11 @@ vect_analyze_slp_instance (vec_info *vinfo,\n       else\n \t{\n \t  /* Create a new SLP instance.  */\n-\t  new_instance = XNEW (class _slp_instance);\n+\t  slp_instance new_instance = XNEW (class _slp_instance);\n \t  SLP_INSTANCE_TREE (new_instance) = node;\n \t  SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n \t  SLP_INSTANCE_LOADS (new_instance) = vNULL;\n-\t  SLP_INSTANCE_ROOT_STMT (new_instance) = constructor ? stmt_info : NULL;\n+\t  SLP_INSTANCE_ROOT_STMT (new_instance) = root_stmt_info;\n \t  new_instance->reduc_phis = NULL;\n \t  new_instance->cost_vec = vNULL;\n \t  new_instance->subgraph_entries = vNULL;\n@@ -2184,7 +2110,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t     instructions do not generate this SLP instance.  */\n \t  if (is_a <loop_vec_info> (vinfo)\n \t      && loads_permuted\n-\t      && dr\n+\t      && kind == slp_inst_kind_store\n \t      && vect_store_lanes_supported\n \t\t   (STMT_VINFO_VECTYPE (scalar_stmts[0]), group_size, false))\n \t    {\n@@ -2213,9 +2139,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \n \t  /* If this is a reduction chain with a conversion in front\n \t     amend the SLP tree with a node for that.  */\n-\t  if (!dr\n-\t      && REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n-\t      && STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def)\n+\t  if (kind == slp_inst_kind_reduc_chain\n+\t      && STMT_VINFO_DEF_TYPE (scalar_stmts[0]) != vect_reduction_def)\n \t    {\n \t      /* Get at the conversion stmt - we know it's the single use\n \t\t of the last stmt of the reduction chain.  */\n@@ -2225,7 +2150,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t      bool r = single_imm_use (gimple_assign_lhs (tem),\n \t\t\t\t       &use_p, &use_stmt);\n \t      gcc_assert (r);\n-\t      next_info = vinfo->lookup_stmt (use_stmt);\n+\t      stmt_vec_info next_info = vinfo->lookup_stmt (use_stmt);\n \t      next_info = vect_stmt_to_vectorize (next_info);\n \t      scalar_stmts = vNULL;\n \t      scalar_stmts.create (group_size);\n@@ -2268,10 +2193,13 @@ vect_analyze_slp_instance (vec_info *vinfo,\n       scalar_stmts.release ();\n     }\n \n+  stmt_vec_info stmt_info = stmt_info_;\n   /* Try to break the group up into pieces.  */\n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-      && DR_IS_WRITE (STMT_VINFO_DATA_REF (stmt_info)))\n+  if (kind == slp_inst_kind_store)\n     {\n+      /* ???  We could delay all the actual splitting of store-groups\n+\t until after SLP discovery of the original group completed.\n+\t Then we can recurse to vect_build_slp_instance directly.  */\n       for (i = 0; i < group_size; i++)\n \tif (!matches[i])\n \t  break;\n@@ -2354,6 +2282,122 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   return false;\n }\n \n+\n+/* Analyze an SLP instance starting from a group of grouped stores.  Call\n+   vect_build_slp_tree to build a tree of packed stmts if possible.\n+   Return FALSE if it's impossible to SLP any stmt in the loop.  */\n+\n+static bool\n+vect_analyze_slp_instance (vec_info *vinfo,\n+\t\t\t   scalar_stmts_to_slp_tree_map_t *bst_map,\n+\t\t\t   stmt_vec_info stmt_info, unsigned max_tree_size)\n+{\n+  unsigned int group_size;\n+  unsigned int i;\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  vec<stmt_vec_info> scalar_stmts;\n+  slp_instance_kind kind;\n+\n+  if (is_a <bb_vec_info> (vinfo))\n+    vect_location = stmt_info->stmt;\n+  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+    {\n+      kind = slp_inst_kind_store;\n+      group_size = DR_GROUP_SIZE (stmt_info);\n+    }\n+  else if (!dr && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n+    {\n+      kind = slp_inst_kind_reduc_chain;\n+      gcc_assert (is_a <loop_vec_info> (vinfo));\n+      group_size = REDUC_GROUP_SIZE (stmt_info);\n+    }\n+  else if (is_gimple_assign (stmt_info->stmt)\n+\t    && gimple_assign_rhs_code (stmt_info->stmt) == CONSTRUCTOR)\n+    {\n+      kind = slp_inst_kind_ctor;\n+      group_size = CONSTRUCTOR_NELTS (gimple_assign_rhs1 (stmt_info->stmt));\n+    }\n+  else\n+    {\n+      kind = slp_inst_kind_reduc_group;\n+      gcc_assert (is_a <loop_vec_info> (vinfo));\n+      group_size = as_a <loop_vec_info> (vinfo)->reductions.length ();\n+    }\n+\n+  /* Create a node (a root of the SLP tree) for the packed grouped stores.  */\n+  scalar_stmts.create (group_size);\n+  stmt_vec_info next_info = stmt_info;\n+  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+    {\n+      /* Collect the stores and store them in SLP_TREE_SCALAR_STMTS.  */\n+      while (next_info)\n+\t{\n+\t  scalar_stmts.safe_push (vect_stmt_to_vectorize (next_info));\n+\t  next_info = DR_GROUP_NEXT_ELEMENT (next_info);\n+\t}\n+    }\n+  else if (!dr && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n+    {\n+      /* Collect the reduction stmts and store them in\n+\t SLP_TREE_SCALAR_STMTS.  */\n+      while (next_info)\n+\t{\n+\t  scalar_stmts.safe_push (vect_stmt_to_vectorize (next_info));\n+\t  next_info = REDUC_GROUP_NEXT_ELEMENT (next_info);\n+\t}\n+      /* Mark the first element of the reduction chain as reduction to properly\n+\t transform the node.  In the reduction analysis phase only the last\n+\t element of the chain is marked as reduction.  */\n+      STMT_VINFO_DEF_TYPE (stmt_info)\n+\t= STMT_VINFO_DEF_TYPE (scalar_stmts.last ());\n+      STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info))\n+\t= STMT_VINFO_REDUC_DEF (vect_orig_stmt (scalar_stmts.last ()));\n+    }\n+  else if (kind == slp_inst_kind_ctor)\n+    {\n+      tree rhs = gimple_assign_rhs1 (stmt_info->stmt);\n+      tree val;\n+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), i, val)\n+\t{\n+\t  if (TREE_CODE (val) == SSA_NAME)\n+\t    {\n+\t      gimple* def = SSA_NAME_DEF_STMT (val);\n+\t      stmt_vec_info def_info = vinfo->lookup_stmt (def);\n+\t      /* Value is defined in another basic block.  */\n+\t      if (!def_info)\n+\t\treturn false;\n+\t      def_info = vect_stmt_to_vectorize (def_info);\n+\t      scalar_stmts.safe_push (def_info);\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Analyzing vectorizable constructor: %G\\n\",\n+\t\t\t stmt_info->stmt);\n+    }\n+  else\n+    {\n+      /* Collect reduction statements.  */\n+      vec<stmt_vec_info> reductions = as_a <loop_vec_info> (vinfo)->reductions;\n+      for (i = 0; reductions.iterate (i, &next_info); i++)\n+\tscalar_stmts.safe_push (next_info);\n+    }\n+\n+  /* Build the tree for the SLP instance.  */\n+  bool res = vect_build_slp_instance (vinfo, kind, scalar_stmts,\n+\t\t\t\t      kind == slp_inst_kind_ctor\n+\t\t\t\t      ? stmt_info : NULL,\n+\t\t\t\t      max_tree_size,\n+\t\t\t\t      bst_map, stmt_info);\n+\n+  /* ???  If this is slp_inst_kind_store and the above succeeded here's\n+     where we should do store group splitting.  */\n+\n+  return res;\n+}\n+\n /* Fill in backedge SLP children in the SLP graph.  */\n \n static void"}]}