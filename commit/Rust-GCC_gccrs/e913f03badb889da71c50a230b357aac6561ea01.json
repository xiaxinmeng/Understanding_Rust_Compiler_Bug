{"sha": "e913f03badb889da71c50a230b357aac6561ea01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkxM2YwM2JhZGI4ODlkYTcxYzUwYTIzMGIzNTdhYWM2NTYxZWEwMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-12-08T11:26:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-12-08T11:26:32Z"}, "message": "* eval_fat.adb: Revert previous change.\n\nFrom-SVN: r91880", "tree": {"sha": "a95b5dcf4a56cc259d21ca56fd2f88e3125491bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a95b5dcf4a56cc259d21ca56fd2f88e3125491bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e913f03badb889da71c50a230b357aac6561ea01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e913f03badb889da71c50a230b357aac6561ea01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e913f03badb889da71c50a230b357aac6561ea01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e913f03badb889da71c50a230b357aac6561ea01/comments", "author": null, "committer": null, "parents": [{"sha": "0da07eae29b486dcbd85cd85cc92fd20a10ca999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da07eae29b486dcbd85cd85cc92fd20a10ca999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0da07eae29b486dcbd85cd85cc92fd20a10ca999"}], "stats": {"total": 123, "additions": 90, "deletions": 33}, "files": [{"sha": "00a131dd623d23afa9b18928024b330e3774522f", "filename": "gcc/ada/eval_fat.adb", "status": "modified", "additions": 90, "deletions": 33, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e913f03badb889da71c50a230b357aac6561ea01/gcc%2Fada%2Feval_fat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e913f03badb889da71c50a230b357aac6561ea01/gcc%2Fada%2Feval_fat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.adb?ref=e913f03badb889da71c50a230b357aac6561ea01", "patch": "@@ -38,14 +38,14 @@ package body Eval_Fat is\n    --  case of anyone ever having to adjust this code for another value,\n    --  and for documentation purposes.\n \n-   --  Another assumption is that the range of the floating-point type\n-   --  is symmetric around zero.\n-\n    type Radix_Power_Table is array (Int range 1 .. 4) of Int;\n \n    Radix_Powers : constant Radix_Power_Table :=\n                     (Radix ** 1, Radix ** 2, Radix ** 3, Radix ** 4);\n \n+   function Float_Radix return T renames Ureal_2;\n+   --  Radix expressed in real form\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -74,6 +74,12 @@ package body Eval_Fat is\n    --  even, a floor operation or a ceiling operation depending on the setting\n    --  of Mode (see corresponding descriptions in Urealp).\n \n+   function Eps_Model (RT : R) return T;\n+   --  Return the smallest model number of R.\n+\n+   function Eps_Denorm (RT : R) return T;\n+   --  Return the smallest denormal of type R.\n+\n    function Machine_Emin (RT : R) return Int;\n    --  Return value of the Machine_Emin attribute\n \n@@ -85,8 +91,10 @@ package body Eval_Fat is\n    begin\n       if Towards = X then\n          return X;\n+\n       elsif Towards > X then\n          return Succ (RT, X);\n+\n       else\n          return Pred (RT, X);\n       end if;\n@@ -98,11 +106,14 @@ package body Eval_Fat is\n \n    function Ceiling (RT : R; X : T) return T is\n       XT : constant T := Truncation (RT, X);\n+\n    begin\n       if UR_Is_Negative (X) then\n          return XT;\n+\n       elsif X = XT then\n          return X;\n+\n       else\n          return XT + Ureal_1;\n       end if;\n@@ -371,10 +382,10 @@ package body Eval_Fat is\n       Calculate_Fraction_And_Exponent : begin\n          Uintp_Mark := Mark;\n \n-         --  Determine correct rounding based on the remainder which is in\n-         --  N and the divisor D. The rounding is performed on the absolute\n-         --  value of X, so Ceiling and Floor need to check for the sign of\n-         --  X explicitly.\n+         --  Determine correct rounding based on the remainder\n+         --  which is in N and the divisor D. The rounding is\n+         --  performed on the absolute value of X, so Ceiling\n+         --  and Floor need to check for the sign of X explicitly.\n \n          case Mode is\n             when Round_Even =>\n@@ -429,6 +440,25 @@ package body Eval_Fat is\n       end Calculate_Fraction_And_Exponent;\n    end Decompose_Int;\n \n+   ----------------\n+   -- Eps_Denorm --\n+   ----------------\n+\n+   function Eps_Denorm (RT : R) return T is\n+   begin\n+      return Float_Radix ** UI_From_Int\n+                                  (Machine_Emin (RT) - Machine_Mantissa (RT));\n+   end Eps_Denorm;\n+\n+   ---------------\n+   -- Eps_Model --\n+   ---------------\n+\n+   function Eps_Model (RT : R) return T is\n+   begin\n+      return Float_Radix ** UI_From_Int (Machine_Emin (RT));\n+   end Eps_Model;\n+\n    --------------\n    -- Exponent --\n    --------------\n@@ -705,8 +735,37 @@ package body Eval_Fat is\n    ----------\n \n    function Pred (RT : R; X : T) return T is\n+      Result_F : UI;\n+      Result_X : UI;\n+\n    begin\n-      return -Succ (RT, -X);\n+      if abs X < Eps_Model (RT) then\n+         if Denorm_On_Target then\n+            return X - Eps_Denorm (RT);\n+\n+         elsif X > Ureal_0 then\n+\n+            --  Target does not support denorms, so predecessor is 0.0\n+\n+            return Ureal_0;\n+\n+         else\n+            --  Target does not support denorms, and X is 0.0\n+            --  or at least bigger than -Eps_Model (RT)\n+\n+            return -Eps_Model (RT);\n+         end if;\n+\n+      else\n+         Decompose_Int (RT, X, Result_F,  Result_X, Ceiling);\n+         return UR_From_Components\n+           (Num      => Result_F - 1,\n+            Den      => Machine_Mantissa (RT) - Result_X,\n+            Rbase    => Radix,\n+            Negative => False);\n+         --  Result_F may be false, but this is OK as UR_From_Components\n+         --  handles that situation.\n+      end if;\n    end Pred;\n \n    ---------------\n@@ -833,38 +892,35 @@ package body Eval_Fat is\n    ----------\n \n    function Succ (RT : R; X : T) return T is\n-      Emin     : constant UI := UI_From_Int (Machine_Emin (RT));\n-      Mantissa : constant UI := UI_From_Int (Machine_Mantissa (RT));\n-      Exp      : UI := UI_Max (Emin, Exponent (RT, X));\n-      Frac     : T;\n-      New_Frac : T;\n+      Result_F : UI;\n+      Result_X : UI;\n \n    begin\n-      if UR_Is_Zero (X) then\n-         Exp := Emin;\n-      end if;\n+      if abs X < Eps_Model (RT) then\n+         if Denorm_On_Target then\n+            return X + Eps_Denorm (RT);\n \n-      --  Set exponent such that the radix point will be directly\n-      --  following the mantissa after scaling\n+         elsif X < Ureal_0 then\n+            --  Target does not support denorms, so successor is 0.0\n+            return Ureal_0;\n \n-      if Denorm_On_Target or Exp /= Emin then\n-         Exp := Exp - Mantissa;\n-      else\n-         Exp := Exp - 1;\n-      end if;\n-\n-      Frac := Scaling (RT, X, -Exp);\n-      New_Frac := Ceiling (RT, Frac);\n-\n-      if New_Frac = Frac then\n-         if New_Frac = Scaling (RT, -Ureal_1, Mantissa - 1) then\n-            New_Frac := New_Frac + Scaling (RT, Ureal_1, Uint_Minus_1);\n          else\n-            New_Frac := New_Frac + Ureal_1;\n+            --  Target does not support denorms, and X is 0.0\n+            --  or at least smaller than Eps_Model (RT)\n+\n+            return Eps_Model (RT);\n          end if;\n-      end if;\n \n-      return Scaling (RT, New_Frac, Exp);\n+      else\n+         Decompose_Int (RT, X, Result_F, Result_X, Floor);\n+         return UR_From_Components\n+           (Num      => Result_F + 1,\n+            Den      => Machine_Mantissa (RT) - Result_X,\n+            Rbase    => Radix,\n+            Negative => False);\n+         --  Result_F may be false, but this is OK as UR_From_Components\n+         --  handles that situation.\n+      end if;\n    end Succ;\n \n    ----------------\n@@ -873,6 +929,7 @@ package body Eval_Fat is\n \n    function Truncation (RT : R; X : T) return T is\n       pragma Warnings (Off, RT);\n+\n    begin\n       return UR_From_Uint (UR_Trunc (X));\n    end Truncation;"}]}