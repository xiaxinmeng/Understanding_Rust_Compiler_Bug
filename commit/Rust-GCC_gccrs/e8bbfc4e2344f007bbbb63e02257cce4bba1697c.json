{"sha": "e8bbfc4e2344f007bbbb63e02257cce4bba1697c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThiYmZjNGUyMzQ0ZjAwN2JiYmI2M2UwMjI1N2NjZTRiYmExNjk3Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-06T23:36:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-06T23:36:01Z"}, "message": "Initial revision\n\nFrom-SVN: r406", "tree": {"sha": "cfedbf399a5a0b65e9fa78e2eb727548383f6c40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfedbf399a5a0b65e9fa78e2eb727548383f6c40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8bbfc4e2344f007bbbb63e02257cce4bba1697c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8bbfc4e2344f007bbbb63e02257cce4bba1697c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8bbfc4e2344f007bbbb63e02257cce4bba1697c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8bbfc4e2344f007bbbb63e02257cce4bba1697c/comments", "author": null, "committer": null, "parents": [{"sha": "dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666"}], "stats": {"total": 2554, "additions": 2554, "deletions": 0}, "files": [{"sha": "a78135be810dc4dabcef8274ad2ae094b609fad9", "filename": "gcc/c-lex.c", "status": "added", "additions": 1950, "deletions": 0, "changes": 1950, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8bbfc4e2344f007bbbb63e02257cce4bba1697c/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8bbfc4e2344f007bbbb63e02257cce4bba1697c/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=e8bbfc4e2344f007bbbb63e02257cce4bba1697c", "patch": "@@ -0,0 +1,1950 @@\n+/* Lexical analyser for C and Objective C.\n+   Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include <errno.h>\n+#include <setjmp.h>\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"input.h\"\n+#include \"c-lex.h\"\n+#include \"c-tree.h\"\n+#include \"flags.h\"\n+#include \"c-parse.h\"\n+\n+#ifdef MULTIBYTE_CHARS\n+#include <stdlib.h>\n+#include <locale.h>\n+#endif\n+\n+#ifndef errno\n+extern int errno;\n+#endif\n+\n+/* The elements of `ridpointers' are identifier nodes\n+   for the reserved type names and storage classes.\n+   It is indexed by a RID_... value.  */\n+tree ridpointers[(int) RID_MAX];\n+\n+/* Cause the `yydebug' variable to be defined.  */\n+#define YYDEBUG 1\n+\n+/* the declaration found for the last IDENTIFIER token read in.\n+   yylex must look this up to detect typedefs, which get token type TYPENAME,\n+   so it is left around in case the identifier is not a typedef but is\n+   used in a context which makes it a reference to a variable.  */\n+tree lastiddecl;\n+\n+/* Nonzero enables objc features.  */\n+\n+int doing_objc_thang;\n+\n+extern tree lookup_interface ();\n+\n+extern int yydebug;\n+\n+/* File used for outputting assembler code.  */\n+extern FILE *asm_out_file;\n+\n+#ifndef WCHAR_TYPE_SIZE\n+#ifdef INT_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE INT_TYPE_SIZE\n+#else\n+#define WCHAR_TYPE_SIZE\tBITS_PER_WORD\n+#endif\n+#endif\n+\n+/* Number of bytes in a wide character.  */\n+#define WCHAR_BYTES (WCHAR_TYPE_SIZE / BITS_PER_UNIT)\n+\n+static int maxtoken;\t\t/* Current nominal length of token buffer.  */\n+char *token_buffer;\t/* Pointer to token buffer.\n+\t\t\t   Actual allocated length is maxtoken + 2.\n+\t\t\t   This is not static because objc-parse.y uses it.  */\n+\n+/* Nonzero if end-of-file has been seen on input.  */\n+static int end_of_file;\n+\n+/* Buffered-back input character; faster than using ungetc.  */\n+static int nextchar = -1;\n+\n+int check_newline ();\n+\n+/* Nonzero tells yylex to ignore \\ in string constants.  */\n+static int ignore_escape_flag = 0;\n+\f\n+/* C code produced by gperf version 2.5 (GNU C++ version) */\n+/* Command-line: gperf -p -j1 -i 1 -g -o -t -N is_reserved_word -k1,3,$ c-parse.gperf  */ \n+struct resword { char *name; short token; enum rid rid; };\n+\n+#define TOTAL_KEYWORDS 53\n+#define MIN_WORD_LENGTH 2\n+#define MAX_WORD_LENGTH 13\n+#define MIN_HASH_VALUE 7\n+#define MAX_HASH_VALUE 102\n+/* maximum key range = 96, duplicates = 0 */\n+\n+#ifdef __GNUC__\n+__inline\n+#endif\n+static unsigned int\n+hash (str, len)\n+     register char *str;\n+     register int unsigned len;\n+{\n+  static unsigned char asso_values[] =\n+    {\n+     103, 103, 103, 103, 103, 103, 103, 103, 103, 103,\n+     103, 103, 103, 103, 103, 103, 103, 103, 103, 103,\n+     103, 103, 103, 103, 103, 103, 103, 103, 103, 103,\n+     103, 103, 103, 103, 103, 103, 103, 103, 103, 103,\n+     103, 103, 103, 103, 103, 103, 103, 103, 103, 103,\n+     103, 103, 103, 103, 103, 103, 103, 103, 103, 103,\n+     103, 103, 103, 103, 103, 103, 103, 103, 103, 103,\n+     103, 103, 103, 103, 103, 103, 103, 103, 103, 103,\n+     103, 103, 103, 103, 103, 103, 103, 103, 103, 103,\n+     103, 103, 103, 103, 103,   1, 103,   2,   1,  24,\n+       1,   5,  19,  39,  16,  13, 103,   1,  25,   1,\n+      34,  34,  24, 103,  13,  12,   1,  45,  24,   7,\n+     103, 103,   2, 103, 103, 103, 103, 103,\n+    };\n+  register int hval = len;\n+\n+  switch (hval)\n+    {\n+      default:\n+      case 3:\n+        hval += asso_values[str[2]];\n+      case 2:\n+      case 1:\n+        hval += asso_values[str[0]];\n+    }\n+  return hval + asso_values[str[len - 1]];\n+}\n+\n+#ifdef __GNUC__\n+__inline\n+#endif\n+struct resword *\n+is_reserved_word (str, len)\n+     register char *str;\n+     register unsigned int len;\n+{\n+  static struct resword wordlist[] =\n+    {\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"asm\",  ASM, NORID},\n+      {\"\",}, \n+      {\"__asm\",  ASM, NORID},\n+      {\"\",}, \n+      {\"__asm__\",  ASM, NORID},\n+      {\"break\",  BREAK, NORID},\n+      {\"__typeof__\",  TYPEOF, NORID},\n+      {\"\",}, \n+      {\"__alignof__\",  ALIGNOF, NORID},\n+      {\"\",}, \n+      {\"__attribute__\",  ATTRIBUTE, NORID},\n+      {\"int\",  TYPESPEC, RID_INT},\n+      {\"__attribute\",  ATTRIBUTE, NORID},\n+      {\"__extension__\",  EXTENSION, NORID},\n+      {\"\",}, \n+      {\"__signed\",  TYPESPEC, RID_SIGNED},\n+      {\"\",}, \n+      {\"__signed__\",  TYPESPEC, RID_SIGNED},\n+      {\"__inline__\",  SCSPEC, RID_INLINE},\n+      {\"else\",  ELSE, NORID},\n+      {\"__inline\",  SCSPEC, RID_INLINE},\n+      {\"default\",  DEFAULT, NORID},\n+      {\"__typeof\",  TYPEOF, NORID},\n+      {\"while\",  WHILE, NORID},\n+      {\"__alignof\",  ALIGNOF, NORID},\n+      {\"struct\",  STRUCT, NORID},\n+      {\"__const\",  TYPE_QUAL, RID_CONST},\n+      {\"if\",  IF, NORID},\n+      {\"__const__\",  TYPE_QUAL, RID_CONST},\n+      {\"__label__\",  LABEL, NORID},\n+      {\"do\",  DO, NORID},\n+      {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n+      {\"sizeof\",  SIZEOF, NORID},\n+      {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n+      {\"auto\",  SCSPEC, RID_AUTO},\n+      {\"void\",  TYPESPEC, RID_VOID},\n+      {\"char\",  TYPESPEC, RID_CHAR},\n+      {\"static\",  SCSPEC, RID_STATIC},\n+      {\"case\",  CASE, NORID},\n+      {\"extern\",  SCSPEC, RID_EXTERN},\n+      {\"switch\",  SWITCH, NORID},\n+      {\"for\",  FOR, NORID},\n+      {\"inline\",  SCSPEC, RID_INLINE},\n+      {\"typeof\",  TYPEOF, NORID},\n+      {\"typedef\",  SCSPEC, RID_TYPEDEF},\n+      {\"short\",  TYPESPEC, RID_SHORT},\n+      {\"\",}, \n+      {\"return\",  RETURN, NORID},\n+      {\"enum\",  ENUM, NORID},\n+      {\"\",}, \n+      {\"double\",  TYPESPEC, RID_DOUBLE},\n+      {\"signed\",  TYPESPEC, RID_SIGNED},\n+      {\"float\",  TYPESPEC, RID_FLOAT},\n+      {\"\",}, {\"\",}, \n+      {\"volatile\",  TYPE_QUAL, RID_VOLATILE},\n+      {\"\",}, \n+      {\"const\",  TYPE_QUAL, RID_CONST},\n+      {\"\",}, \n+      {\"unsigned\",  TYPESPEC, RID_UNSIGNED},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"continue\",  CONTINUE, NORID},\n+      {\"\",}, \n+      {\"register\",  SCSPEC, RID_REGISTER},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"goto\",  GOTO, NORID},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      \n+      {\"union\",  UNION, NORID},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"long\",  TYPESPEC, RID_LONG},\n+    };\n+\n+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n+    {\n+      register int key = hash (str, len);\n+\n+      if (key <= MAX_HASH_VALUE && key >= 0)\n+        {\n+          register char *s = wordlist[key].name;\n+\n+          if (*s == *str && !strcmp (str + 1, s + 1))\n+            return &wordlist[key];\n+        }\n+    }\n+  return 0;\n+}\n+\f\n+/* Return something to represent absolute declarators containing a *.\n+   TARGET is the absolute declarator that the * contains.\n+   TYPE_QUALS is a list of modifiers such as const or volatile\n+   to apply to the pointer type, represented as identifiers.\n+\n+   We return an INDIRECT_REF whose \"contents\" are TARGET\n+   and whose type is the modifier list.  */\n+\n+tree\n+make_pointer_declarator (type_quals, target)\n+     tree type_quals, target;\n+{\n+  return build1 (INDIRECT_REF, type_quals, target);\n+}\n+\f\n+void\n+init_lex ()\n+{\n+  /* Make identifier nodes long enough for the language-specific slots.  */\n+  set_identifier_size (sizeof (struct lang_identifier));\n+\n+  /* Start it at 0, because check_newline is called at the very beginning\n+     and will increment it to 1.  */\n+  lineno = 0;\n+\n+#ifdef MULTIBYTE_CHARS\n+  /* Change to the native locale for multibyte conversions.  */\n+  setlocale (LC_CTYPE, \"\");\n+#endif\n+\n+  maxtoken = 40;\n+  token_buffer = (char *) xmalloc (maxtoken + 2);\n+\n+  ridpointers[(int) RID_INT] = get_identifier (\"int\");\n+  ridpointers[(int) RID_CHAR] = get_identifier (\"char\");\n+  ridpointers[(int) RID_VOID] = get_identifier (\"void\");\n+  ridpointers[(int) RID_FLOAT] = get_identifier (\"float\");\n+  ridpointers[(int) RID_DOUBLE] = get_identifier (\"double\");\n+  ridpointers[(int) RID_SHORT] = get_identifier (\"short\");\n+  ridpointers[(int) RID_LONG] = get_identifier (\"long\");\n+  ridpointers[(int) RID_UNSIGNED] = get_identifier (\"unsigned\");\n+  ridpointers[(int) RID_SIGNED] = get_identifier (\"signed\");\n+  ridpointers[(int) RID_INLINE] = get_identifier (\"inline\");\n+  ridpointers[(int) RID_CONST] = get_identifier (\"const\");\n+  ridpointers[(int) RID_VOLATILE] = get_identifier (\"volatile\");\n+  ridpointers[(int) RID_AUTO] = get_identifier (\"auto\");\n+  ridpointers[(int) RID_STATIC] = get_identifier (\"static\");\n+  ridpointers[(int) RID_EXTERN] = get_identifier (\"extern\");\n+  ridpointers[(int) RID_TYPEDEF] = get_identifier (\"typedef\");\n+  ridpointers[(int) RID_REGISTER] = get_identifier (\"register\");\n+\n+  /* Some options inhibit certain reserved words.\n+     Clear those words out of the hash table so they won't be recognized.  */\n+#define UNSET_RESERVED_WORD(STRING) \\\n+  do { struct resword *s = is_reserved_word (STRING, sizeof (STRING) - 1); \\\n+       if (s) s->name = \"\"; } while (0)\n+\n+  if (flag_traditional)\n+    {\n+      UNSET_RESERVED_WORD (\"const\");\n+      UNSET_RESERVED_WORD (\"volatile\");\n+      UNSET_RESERVED_WORD (\"typeof\");\n+      UNSET_RESERVED_WORD (\"signed\");\n+      UNSET_RESERVED_WORD (\"inline\");\n+    }\n+  if (flag_no_asm)\n+    {\n+      UNSET_RESERVED_WORD (\"asm\");\n+      UNSET_RESERVED_WORD (\"typeof\");\n+      UNSET_RESERVED_WORD (\"inline\");\n+    }\n+}\n+\n+void\n+reinit_parse_for_function ()\n+{\n+}\n+\f\n+/* Function used when yydebug is set, to print a token in more detail.  */\n+\n+void\n+yyprint (file, yychar, yylval)\n+     FILE *file;\n+     int yychar;\n+     YYSTYPE yylval;\n+{\n+  tree t;\n+  switch (yychar)\n+    {\n+    case IDENTIFIER:\n+    case TYPENAME:\n+      t = yylval.ttype;\n+      if (IDENTIFIER_POINTER (t))\n+\tfprintf (file, \" `%s'\", IDENTIFIER_POINTER (t));\n+      break;\n+\n+    case CONSTANT:\n+      t = yylval.ttype;\n+      if (TREE_CODE (t) == INTEGER_CST)\n+\tfprintf (file, \" 0x%8x%8x\", TREE_INT_CST_HIGH (t),\n+\t\t TREE_INT_CST_LOW (t));\n+      break;\n+    }\n+}\n+\n+\f\n+/* If C is not whitespace, return C.\n+   Otherwise skip whitespace and return first nonwhite char read.  */\n+\n+static int\n+skip_white_space (c)\n+     register int c;\n+{\n+#if 0\n+  register int inside;\n+#endif\n+\n+  for (;;)\n+    {\n+      switch (c)\n+\t{\n+\t  /* Don't recognize comments in cc1: all comments are removed by cpp,\n+\t     and cpp output can include / and * consecutively as operators.  */\n+#if 0\n+\tcase '/':\n+\t  c = getc (finput);\n+\t  if (c != '*')\n+\t    {\n+\t      ungetc (c, finput);\n+\t      return '/';\n+\t    }\n+\n+\t  c = getc (finput);\n+\n+\t  inside = 1;\n+\t  while (inside)\n+\t    {\n+\t      if (c == '*')\n+\t\t{\n+\t\t  while (c == '*')\n+\t\t    c = getc (finput);\n+\n+\t\t  if (c == '/')\n+\t\t    {\n+\t\t      inside = 0;\n+\t\t      c = getc (finput);\n+\t\t    }\n+\t\t}\n+\t      else if (c == '\\n')\n+\t\t{\n+\t\t  lineno++;\n+\t\t  c = getc (finput);\n+\t\t}\n+\t      else if (c == EOF)\n+\t\t{\n+\t\t  error (\"unterminated comment\");\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\tc = getc (finput);\n+\t    }\n+\n+\t  break;\n+#endif\n+\n+\tcase '\\n':\n+\t  c = check_newline ();\n+\t  break;\n+\n+\tcase ' ':\n+\tcase '\\t':\n+\tcase '\\f':\n+#if 0  /* ANSI says no.  */\n+\tcase '\\r':\n+#endif\n+\tcase '\\v':\n+\tcase '\\b':\n+\t  c = getc (finput);\n+\t  break;\n+\n+\tcase '\\\\':\n+\t  c = getc (finput);\n+\t  if (c == '\\n')\n+\t    lineno++;\n+\t  else\n+\t    error (\"stray '\\\\' in program\");\n+\t  c = getc (finput);\n+\t  break;\n+\n+\tdefault:\n+\t  return (c);\n+\t}\n+    }\n+}\n+\n+/* Skips all of the white space at the current location in the input file.\n+   Must use and reset nextchar if it has the next character.  */\n+\n+void\n+position_after_white_space ()\n+{\n+  register int c;\n+\n+  if (nextchar != -1)\n+    c = nextchar, nextchar = -1;\n+  else\n+    c = getc (finput);\n+\n+  ungetc (skip_white_space (c), finput);\n+}\n+\n+/* Make the token buffer longer, preserving the data in it.\n+   P should point to just beyond the last valid character in the old buffer.\n+   The value we return is a pointer to the new buffer\n+   at a place corresponding to P.  */\n+\n+static char *\n+extend_token_buffer (p)\n+     char *p;\n+{\n+  int offset = p - token_buffer;\n+\n+  maxtoken = maxtoken * 2 + 10;\n+  token_buffer = (char *) xrealloc (token_buffer, maxtoken + 2);\n+\n+  return token_buffer + offset;\n+}\n+\f\n+/* At the beginning of a line, increment the line number\n+   and process any #-directive on this line.\n+   If the line is a #-directive, read the entire line and return a newline.\n+   Otherwise, return the line's first non-whitespace character.  */\n+\n+int\n+check_newline ()\n+{\n+  register int c;\n+  register int token;\n+\n+  lineno++;\n+\n+  /* Read first nonwhite char on the line.  */\n+\n+  c = getc (finput);\n+  while (c == ' ' || c == '\\t')\n+    c = getc (finput);\n+\n+  if (c != '#')\n+    {\n+      /* If not #, return it so caller will use it.  */\n+      return c;\n+    }\n+\n+  /* Read first nonwhite char after the `#'.  */\n+\n+  c = getc (finput);\n+  while (c == ' ' || c == '\\t')\n+    c = getc (finput);\n+\n+  /* If a letter follows, then if the word here is `line', skip\n+     it and ignore it; otherwise, ignore the line, with an error\n+     if the word isn't `pragma', `ident', `define', or `undef'.  */\n+\n+  if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n+    {\n+      if (c == 'p')\n+\t{\n+\t  if (getc (finput) == 'r'\n+\t      && getc (finput) == 'a'\n+\t      && getc (finput) == 'g'\n+\t      && getc (finput) == 'm'\n+\t      && getc (finput) == 'a'\n+\t      && ((c = getc (finput)) == ' ' || c == '\\t' || c == '\\n'))\n+\t    {\n+#ifdef HANDLE_PRAGMA\n+\t      HANDLE_PRAGMA (finput);\n+#endif /* HANDLE_PRAGMA */\n+\t      goto skipline;\n+\t    }\n+\t}\n+\n+      else if (c == 'd')\n+\t{\n+\t  if (getc (finput) == 'e'\n+\t      && getc (finput) == 'f'\n+\t      && getc (finput) == 'i'\n+\t      && getc (finput) == 'n'\n+\t      && getc (finput) == 'e'\n+\t      && ((c = getc (finput)) == ' ' || c == '\\t' || c == '\\n'))\n+\t    {\n+#ifdef DWARF_DEBUGGING_INFO\n+\t      if ((debug_info_level == DINFO_LEVEL_VERBOSE)\n+\t\t  && (write_symbols == DWARF_DEBUG))\n+\t        dwarfout_define (lineno, get_directive_line (finput));\n+#endif /* DWARF_DEBUGGING_INFO */\n+\t      goto skipline;\n+\t    }\n+\t}\n+      else if (c == 'u')\n+\t{\n+\t  if (getc (finput) == 'n'\n+\t      && getc (finput) == 'd'\n+\t      && getc (finput) == 'e'\n+\t      && getc (finput) == 'f'\n+\t      && ((c = getc (finput)) == ' ' || c == '\\t' || c == '\\n'))\n+\t    {\n+#ifdef DWARF_DEBUGGING_INFO\n+\t      if ((debug_info_level == DINFO_LEVEL_VERBOSE)\n+\t\t  && (write_symbols == DWARF_DEBUG))\n+\t        dwarfout_undef (lineno, get_directive_line (finput));\n+#endif /* DWARF_DEBUGGING_INFO */\n+\t      goto skipline;\n+\t    }\n+\t}\n+      else if (c == 'l')\n+\t{\n+\t  if (getc (finput) == 'i'\n+\t      && getc (finput) == 'n'\n+\t      && getc (finput) == 'e'\n+\t      && ((c = getc (finput)) == ' ' || c == '\\t'))\n+\t    goto linenum;\n+\t}\n+      else if (c == 'i')\n+\t{\n+\t  if (getc (finput) == 'd'\n+\t      && getc (finput) == 'e'\n+\t      && getc (finput) == 'n'\n+\t      && getc (finput) == 't'\n+\t      && ((c = getc (finput)) == ' ' || c == '\\t'))\n+\t    {\n+\t      /* #ident.  The pedantic warning is now in cccp.c.  */\n+\n+\t      /* Here we have just seen `#ident '.\n+\t\t A string constant should follow.  */\n+\n+\t      while (c == ' ' || c == '\\t')\n+\t\tc = getc (finput);\n+\n+\t      /* If no argument, ignore the line.  */\n+\t      if (c == '\\n')\n+\t\treturn c;\n+\n+\t      ungetc (c, finput);\n+\t      token = yylex ();\n+\t      if (token != STRING\n+\t\t  || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t\t{\n+\t\t  error (\"invalid #ident\");\n+\t\t  goto skipline;\n+\t\t}\n+\n+\t      if (!flag_no_ident)\n+\t\t{\n+#ifdef ASM_OUTPUT_IDENT\n+\t\t  ASM_OUTPUT_IDENT (asm_out_file, TREE_STRING_POINTER (yylval.ttype));\n+#endif\n+\t\t}\n+\n+\t      /* Skip the rest of this line.  */\n+\t      goto skipline;\n+\t    }\n+\t}\n+\n+      error (\"undefined or invalid # directive\");\n+      goto skipline;\n+    }\n+\n+linenum:\n+  /* Here we have either `#line' or `# <nonletter>'.\n+     In either case, it should be a line number; a digit should follow.  */\n+\n+  while (c == ' ' || c == '\\t')\n+    c = getc (finput);\n+\n+  /* If the # is the only nonwhite char on the line,\n+     just ignore it.  Check the new newline.  */\n+  if (c == '\\n')\n+    return c;\n+\n+  /* Something follows the #; read a token.  */\n+\n+  ungetc (c, finput);\n+  token = yylex ();\n+\n+  if (token == CONSTANT\n+      && TREE_CODE (yylval.ttype) == INTEGER_CST)\n+    {\n+      int old_lineno = lineno;\n+      int used_up = 0;\n+      /* subtract one, because it is the following line that\n+\t gets the specified number */\n+\n+      int l = TREE_INT_CST_LOW (yylval.ttype) - 1;\n+\n+      /* Is this the last nonwhite stuff on the line?  */\n+      c = getc (finput);\n+      while (c == ' ' || c == '\\t')\n+\tc = getc (finput);\n+      if (c == '\\n')\n+\t{\n+\t  /* No more: store the line number and check following line.  */\n+\t  lineno = l;\n+\t  return c;\n+\t}\n+      ungetc (c, finput);\n+\n+      /* More follows: it must be a string constant (filename).  */\n+\n+      /* Read the string constant, but don't treat \\ as special.  */\n+      ignore_escape_flag = 1;\n+      token = yylex ();\n+      ignore_escape_flag = 0;\n+\n+      if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t{\n+\t  error (\"invalid #line\");\n+\t  goto skipline;\n+\t}\n+\n+      input_filename\n+\t= (char *) permalloc (TREE_STRING_LENGTH (yylval.ttype) + 1);\n+      strcpy (input_filename, TREE_STRING_POINTER (yylval.ttype));\n+      lineno = l;\n+\n+      /* Each change of file name\n+\t reinitializes whether we are now in a system header.  */\n+      in_system_header = 0;\n+\n+      if (main_input_filename == 0)\n+\tmain_input_filename = input_filename;\n+\n+      /* Is this the last nonwhite stuff on the line?  */\n+      c = getc (finput);\n+      while (c == ' ' || c == '\\t')\n+\tc = getc (finput);\n+      if (c == '\\n')\n+\treturn c;\n+      ungetc (c, finput);\n+\n+      token = yylex ();\n+      used_up = 0;\n+\n+      /* `1' after file name means entering new file.\n+\t `2' after file name means just left a file.  */\n+\n+      if (token == CONSTANT\n+\t  && TREE_CODE (yylval.ttype) == INTEGER_CST)\n+\t{\n+\t  if (TREE_INT_CST_LOW (yylval.ttype) == 1)\n+\t    {\n+\t      /* Pushing to a new file.  */\n+\t      struct file_stack *p\n+\t\t= (struct file_stack *) xmalloc (sizeof (struct file_stack));\n+\t      input_file_stack->line = old_lineno;\n+\t      p->next = input_file_stack;\n+\t      p->name = input_filename;\n+\t      input_file_stack = p;\n+\t      input_file_stack_tick++;\n+#ifdef DWARF_DEBUGGING_INFO\n+\t      if (debug_info_level == DINFO_LEVEL_VERBOSE\n+\t\t  && write_symbols == DWARF_DEBUG)\n+\t\tdwarfout_start_new_source_file (input_filename);\n+#endif /* DWARF_DEBUGGING_INFO */\n+\n+\t      used_up = 1;\n+\t    }\n+\t  else if (TREE_INT_CST_LOW (yylval.ttype) == 2)\n+\t    {\n+\t      /* Popping out of a file.  */\n+\t      if (input_file_stack->next)\n+\t\t{\n+\t\t  struct file_stack *p = input_file_stack;\n+\t\t  input_file_stack = p->next;\n+\t\t  free (p);\n+\t\t  input_file_stack_tick++;\n+#ifdef DWARF_DEBUGGING_INFO\n+\t\t  if (debug_info_level == DINFO_LEVEL_VERBOSE\n+\t\t      && write_symbols == DWARF_DEBUG)\n+\t\t    dwarfout_resume_previous_source_file (input_file_stack->line);\n+#endif /* DWARF_DEBUGGING_INFO */\n+\t\t}\n+\t      else\n+\t\terror (\"#-lines for entering and leaving files don't match\");\n+\n+\t      used_up = 1;\n+\t    }\n+\t}\n+\n+      /* If we have handled a `1' or a `2',\n+\t see if there is another number to read.  */\n+      if (used_up)\n+\t{\n+\t  /* Is this the last nonwhite stuff on the line?  */\n+\t  c = getc (finput);\n+\t  while (c == ' ' || c == '\\t')\n+\t    c = getc (finput);\n+\t  if (c == '\\n')\n+\t    return c;\n+\t  ungetc (c, finput);\n+\n+\t  token = yylex ();\n+\t  used_up = 0;\n+\t}\n+\n+      /* `3' after file name means this is a system header file.  */\n+\n+      if (token == CONSTANT\n+\t  && TREE_CODE (yylval.ttype) == INTEGER_CST\n+\t  && TREE_INT_CST_LOW (yylval.ttype) == 3)\n+\tin_system_header = 1;\n+    }\n+  else\n+    error (\"invalid #-line\");\n+\n+  /* skip the rest of this line.  */\n+ skipline:\n+  if (c == '\\n')\n+    return c;\n+  while ((c = getc (finput)) != EOF && c != '\\n');\n+  return c;\n+}\n+\f\n+#define isalnum(char) ((char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') || (char >= '0' && char <= '9'))\n+#define isdigit(char) (char >= '0' && char <= '9')\n+#define ENDFILE -1  /* token that represents end-of-file */\n+\n+/* Read an escape sequence, returning its equivalent as a character,\n+   or -1 if it is backslash-newline.  */\n+\n+static int\n+readescape ()\n+{\n+  register int c = getc (finput);\n+  register int code;\n+  register unsigned count;\n+  unsigned firstdig;\n+\n+  switch (c)\n+    {\n+    case 'x':\n+      if (warn_traditional)\n+\twarning (\"the meaning of `\\\\x' varies with -traditional\");\n+\n+      if (flag_traditional)\n+\treturn c;\n+\n+      code = 0;\n+      count = 0;\n+      while (1)\n+\t{\n+\t  c = getc (finput);\n+\t  if (!(c >= 'a' && c <= 'f')\n+\t      && !(c >= 'A' && c <= 'F')\n+\t      && !(c >= '0' && c <= '9'))\n+\t    {\n+\t      ungetc (c, finput);\n+\t      break;\n+\t    }\n+\t  code *= 16;\n+\t  if (c >= 'a' && c <= 'f')\n+\t    code += c - 'a' + 10;\n+\t  if (c >= 'A' && c <= 'F')\n+\t    code += c - 'A' + 10;\n+\t  if (c >= '0' && c <= '9')\n+\t    code += c - '0';\n+\t  if (count == 0)\n+\t    firstdig = code;\n+\t  count++;\n+\t}\n+      if (count == 0)\n+\terror (\"\\\\x used with no following hex digits\");\n+      else if ((count - 1) * 4 >= TYPE_PRECISION (integer_type_node)\n+\t       || (count > 1\n+\t\t   && ((1 << (TYPE_PRECISION (integer_type_node) - (count - 1) * 4))\n+\t\t       <= firstdig)))\n+\tpedwarn (\"hex escape out of range\");\n+      return code;\n+\n+    case '0':  case '1':  case '2':  case '3':  case '4':\n+    case '5':  case '6':  case '7':\n+      code = 0;\n+      count = 0;\n+      while ((c <= '7') && (c >= '0') && (count++ < 3))\n+\t{\n+\t  code = (code * 8) + (c - '0');\n+\t  c = getc (finput);\n+\t}\n+      ungetc (c, finput);\n+      return code;\n+\n+    case '\\\\': case '\\'': case '\"':\n+      return c;\n+\n+    case '\\n':\n+      lineno++;\n+      return -1;\n+\n+    case 'n':\n+      return TARGET_NEWLINE;\n+\n+    case 't':\n+      return TARGET_TAB;\n+\n+    case 'r':\n+      return TARGET_CR;\n+\n+    case 'f':\n+      return TARGET_FF;\n+\n+    case 'b':\n+      return TARGET_BS;\n+\n+    case 'a':\n+      if (warn_traditional)\n+\twarning (\"the meaning of `\\\\a' varies with -traditional\");\n+\n+      if (flag_traditional)\n+\treturn c;\n+      return TARGET_BELL;\n+\n+    case 'v':\n+#if 0 /* Vertical tab is present in common usage compilers.  */\n+      if (flag_traditional)\n+\treturn c;\n+#endif\n+      return TARGET_VT;\n+\n+    case 'E':\n+      pedwarn (\"non-ANSI-standard escape sequence, `\\\\E'\");\n+      return 033;\n+\n+    case '?':\n+      return c;\n+\n+      /* `\\(', etc, are used at beginning of line to avoid confusing Emacs.  */\n+    case '(':\n+    case '{':\n+    case '[':\n+      if (pedantic)\n+\tpedwarn (\"non-ANSI escape sequence `\\\\%c'\", c);\n+      return c;\n+    }\n+  if (c >= 040 && c <= 0177)\n+    pedwarn (\"unknown escape sequence `\\\\%c'\", c);\n+  else\n+    pedwarn (\"unknown escape sequence: `\\\\' followed by char code 0x%x\", c);\n+  return c;\n+}\n+\f\n+void\n+yyerror (string)\n+     char *string;\n+{\n+  char buf[200];\n+\n+  strcpy (buf, string);\n+\n+  /* We can't print string and character constants well\n+     because the token_buffer contains the result of processing escapes.  */\n+  if (end_of_file)\n+    strcat (buf, \" at end of input\");\n+  else if (token_buffer[0] == 0)\n+    strcat (buf, \" at null character\");\n+  else if (token_buffer[0] == '\"')\n+    strcat (buf, \" before string constant\");\n+  else if (token_buffer[0] == '\\'')\n+    strcat (buf, \" before character constant\");\n+  else if (token_buffer[0] < 040 || (unsigned char) token_buffer[0] >= 0177)\n+    sprintf (buf + strlen (buf), \" before character 0%o\",\n+\t     (unsigned char) token_buffer[0]);\n+  else\n+    strcat (buf, \" before `%s'\");\n+\n+  error (buf, token_buffer);\n+}\n+\n+#if 0\n+\n+struct try_type\n+{\n+  tree *node_var;\n+  char unsigned_flag;\n+  char long_flag;\n+  char long_long_flag;\n+};\n+\n+struct try_type type_sequence[] = \n+{\n+  { &integer_type_node, 0, 0, 0},\n+  { &unsigned_type_node, 1, 0, 0},\n+  { &long_integer_type_node, 0, 1, 0},\n+  { &long_unsigned_type_node, 1, 1, 0},\n+  { &long_long_integer_type_node, 0, 1, 1},\n+  { &long_long_unsigned_type_node, 1, 1, 1}\n+};\n+#endif /* 0 */\n+\f\n+int\n+yylex ()\n+{\n+  register int c;\n+  register char *p;\n+  register int value;\n+  int wide_flag = 0;\n+\n+  if (nextchar >= 0)\n+    c = nextchar, nextchar = -1;\n+  else\n+    c = getc (finput);\n+\n+  /* Effectively do c = skip_white_space (c)\n+     but do it faster in the usual cases.  */\n+  while (1)\n+    switch (c)\n+      {\n+      case '\\r':\n+\tif (!flag_traditional)\t/* ANSI says no */\n+\t  goto found_nonwhite;\n+      case ' ':\n+      case '\\t':\n+      case '\\f':\n+      case '\\v':\n+      case '\\b':\n+\tc = getc (finput);\n+\tbreak;\n+\n+      case '\\n':\n+      case '/':\n+      case '\\\\':\n+\tc = skip_white_space (c);\n+      default:\n+\tgoto found_nonwhite;\n+      }\n+ found_nonwhite:\n+\n+  token_buffer[0] = c;\n+  token_buffer[1] = 0;\n+\n+/*  yylloc.first_line = lineno; */\n+\n+  switch (c)\n+    {\n+    case EOF:\n+      end_of_file = 1;\n+      token_buffer[0] = 0;\n+      value = ENDFILE;\n+      break;\n+\n+    case '$':\n+      if (dollars_in_ident)\n+\tgoto letter;\n+      return '$';\n+\n+    case 'L':\n+      /* Capital L may start a wide-string or wide-character constant.  */\n+      {\n+\tregister int c = getc (finput);\n+\tif (c == '\\'')\n+\t  {\n+\t    wide_flag = 1;\n+\t    goto char_constant;\n+\t  }\n+\tif (c == '\"')\n+\t  {\n+\t    wide_flag = 1;\n+\t    goto string_constant;\n+\t  }\n+\tungetc (c, finput);\n+      }\n+      goto letter;\n+\n+    case '@':\n+      if (!doing_objc_thang)\n+\t{\n+\t  value = c;\n+\t  break;\n+\t}\n+      p = token_buffer;\n+      *p++ = '@';\n+      c = getc (finput);\n+      while (isalnum (c) || c == '_')\n+\t{\n+\t  if (p >= token_buffer + maxtoken)\n+\t    p = extend_token_buffer (p);\n+\n+\t  *p++ = c;\n+\t  c = getc (finput);\n+\t}\n+\n+      *p = 0;\n+      nextchar = c;\n+      value = recognize_objc_keyword (token_buffer + 1);\n+      if (value != 0)\n+\tbreak;\n+      error (\"invalid Objective C keyword `%s'\", token_buffer);\n+      /* Cause a syntax error--1 is not a valid token type.  */\n+      value = 1;\n+      break;\n+\n+    case 'A':  case 'B':  case 'C':  case 'D':  case 'E':\n+    case 'F':  case 'G':  case 'H':  case 'I':  case 'J':\n+    case 'K':\t\t  case 'M':  case 'N':  case 'O':\n+    case 'P':  case 'Q':  case 'R':  case 'S':  case 'T':\n+    case 'U':  case 'V':  case 'W':  case 'X':  case 'Y':\n+    case 'Z':\n+    case 'a':  case 'b':  case 'c':  case 'd':  case 'e':\n+    case 'f':  case 'g':  case 'h':  case 'i':  case 'j':\n+    case 'k':  case 'l':  case 'm':  case 'n':  case 'o':\n+    case 'p':  case 'q':  case 'r':  case 's':  case 't':\n+    case 'u':  case 'v':  case 'w':  case 'x':  case 'y':\n+    case 'z':\n+    case '_':\n+    letter:\n+      p = token_buffer;\n+      while (isalnum (c) || c == '_' || c == '$' || c == '@')\n+\t{\n+\t  if (p >= token_buffer + maxtoken)\n+\t    p = extend_token_buffer (p);\n+\t  if (c == '$' && ! dollars_in_ident)\n+\t    break;\n+\n+\t  *p++ = c;\n+\t  c = getc (finput);\n+\t}\n+\n+      *p = 0;\n+      nextchar = c;\n+\n+      value = IDENTIFIER;\n+      yylval.itype = 0;\n+\n+      /* Try to recognize a keyword.  Uses minimum-perfect hash function */\n+\n+      {\n+\tregister struct resword *ptr;\n+\n+\tif (ptr = is_reserved_word (token_buffer, p - token_buffer))\n+\t  {\n+\t    if (ptr->rid)\n+\t      yylval.ttype = ridpointers[(int) ptr->rid];\n+\t    value = (int) ptr->token;\n+\n+\t    /* Even if we decided to recognize asm, still perhaps warn.  */\n+\t    if (pedantic\n+\t\t&& (value == ASM || value == TYPEOF\n+\t\t    || ptr->rid == RID_INLINE)\n+\t\t&& token_buffer[0] != '_')\n+\t      pedwarn (\"ANSI does not permit the keyword `%s'\",\n+\t\t       token_buffer);\n+\t  }\n+      }\n+\n+      /* If we did not find a keyword, look for an identifier\n+\t (or a typename).  */\n+\n+      if (value == IDENTIFIER)\n+\t{\n+          yylval.ttype = get_identifier (token_buffer);\n+\t  lastiddecl = lookup_name (yylval.ttype);\n+\n+\t  if (lastiddecl != 0 && TREE_CODE (lastiddecl) == TYPE_DECL)\n+\t    value = TYPENAME;\n+          else if (doing_objc_thang)\n+            {\n+\t      tree objc_interface_decl = lookup_interface (yylval.ttype);\n+\n+\t      if (objc_interface_decl)\n+\t\t{\n+\t\t  value = CLASSNAME;\n+\t\t  yylval.ttype = objc_interface_decl;\n+\t\t}\n+\t    }\n+\t}\n+\n+      break;\n+\n+    case '0':  case '1':  case '2':  case '3':  case '4':\n+    case '5':  case '6':  case '7':  case '8':  case '9':\n+    case '.':\n+      {\n+\tint base = 10;\n+\tint count = 0;\n+\tint largest_digit = 0;\n+\tint numdigits = 0;\n+\t/* for multi-precision arithmetic,\n+\t   we store only 8 live bits in each short,\n+\t   giving us 64 bits of reliable precision */\n+\tshort shorts[8];\n+\tint overflow = 0;\n+\n+\tenum anon1 { NOT_FLOAT, AFTER_POINT, TOO_MANY_POINTS} floatflag\n+\t  = NOT_FLOAT;\n+\n+\tfor (count = 0; count < 8; count++)\n+\t  shorts[count] = 0;\n+\n+\tp = token_buffer;\n+\t*p++ = c;\n+\n+\tif (c == '0')\n+\t  {\n+\t    *p++ = (c = getc (finput));\n+\t    if ((c == 'x') || (c == 'X'))\n+\t      {\n+\t\tbase = 16;\n+\t\t*p++ = (c = getc (finput));\n+\t      }\n+\t    /* Leading 0 forces octal unless the 0 is the only digit.  */\n+\t    else if (c >= '0' && c <= '9')\n+\t      {\n+\t\tbase = 8;\n+\t\tnumdigits++;\n+\t      }\n+\t    else\n+\t      numdigits++;\n+\t  }\n+\n+\t/* Read all the digits-and-decimal-points.  */\n+\n+\twhile (c == '.'\n+\t       || (isalnum (c) && (c != 'l') && (c != 'L')\n+\t\t   && (c != 'u') && (c != 'U')\n+\t\t   && (floatflag == NOT_FLOAT || ((c != 'f') && (c != 'F')))))\n+\t  {\n+\t    if (c == '.')\n+\t      {\n+\t\tif (base == 16)\n+\t\t  error (\"floating constant may not be in radix 16\");\n+\t\tif (floatflag == AFTER_POINT)\n+\t\t  {\n+\t\t    error (\"malformed floating constant\");\n+\t\t    floatflag = TOO_MANY_POINTS;\n+\t\t  }\n+\t\telse\n+\t\t  floatflag = AFTER_POINT;\n+\n+\t\tbase = 10;\n+\t\t*p++ = c = getc (finput);\n+\t\t/* Accept '.' as the start of a floating-point number\n+\t\t   only when it is followed by a digit.\n+\t\t   Otherwise, unread the following non-digit\n+\t\t   and use the '.' as a structural token.  */\n+\t\tif (p == token_buffer + 2 && !isdigit (c))\n+\t\t  {\n+\t\t    if (c == '.')\n+\t\t      {\n+\t\t\tc = getc (finput);\n+\t\t\tif (c == '.')\n+\t\t\t  {\n+\t\t\t    *p++ = c;\n+\t\t\t    *p = 0;\n+\t\t\t    return ELLIPSIS;\n+\t\t\t  }\n+\t\t\terror (\"parse error at `..'\");\n+\t\t      }\n+\t\t    ungetc (c, finput);\n+\t\t    token_buffer[1] = 0;\n+\t\t    value = '.';\n+\t\t    goto done;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* It is not a decimal point.\n+\t\t   It should be a digit (perhaps a hex digit).  */\n+\n+\t\tif (isdigit (c))\n+\t\t  {\n+\t\t    c = c - '0';\n+\t\t  }\n+\t\telse if (base <= 10)\n+\t\t  {\n+\t\t    if ((c&~040) == 'E')\n+\t\t      {\n+\t\t\tbase = 10;\n+\t\t\tfloatflag = AFTER_POINT;\n+\t\t\tbreak;   /* start of exponent */\n+\t\t      }\n+\t\t    error (\"nondigits in number and not hexadecimal\");\n+\t\t    c = 0;\n+\t\t  }\n+\t\telse if (c >= 'a')\n+\t\t  {\n+\t\t    c = c - 'a' + 10;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    c = c - 'A' + 10;\n+\t\t  }\n+\t\tif (c >= largest_digit)\n+\t\t  largest_digit = c;\n+\t\tnumdigits++;\n+\n+\t\tfor (count = 0; count < 8; count++)\n+\t\t  {\n+\t\t    shorts[count] *= base;\n+\t\t    if (count)\n+\t\t      {\n+\t\t\tshorts[count] += (shorts[count-1] >> 8);\n+\t\t\tshorts[count-1] &= (1<<8)-1;\n+\t\t      }\n+\t\t    else shorts[0] += c;\n+\t\t  }\n+\n+\t\tif (shorts[7] >= 1<<8\n+\t\t    || shorts[7] < - (1 << 8))\n+\t\t  overflow = TRUE;\n+\n+\t\tif (p >= token_buffer + maxtoken - 3)\n+\t\t  p = extend_token_buffer (p);\n+\t\t*p++ = (c = getc (finput));\n+\t      }\n+\t  }\n+\n+\tif (numdigits == 0)\n+\t  error (\"numeric constant with no digits\");\n+\n+\tif (largest_digit >= base)\n+\t  error (\"numeric constant contains digits beyond the radix\");\n+\n+\t/* Remove terminating char from the token buffer and delimit the string */\n+\t*--p = 0;\n+\n+\tif (floatflag != NOT_FLOAT)\n+\t  {\n+\t    tree type = double_type_node;\n+\t    char f_seen = 0;\n+\t    char l_seen = 0;\n+\t    REAL_VALUE_TYPE value;\n+\t    jmp_buf handler;\n+\n+\t    /* Read explicit exponent if any, and put it in tokenbuf.  */\n+\n+\t    if ((c == 'e') || (c == 'E'))\n+\t      {\n+\t\tif (p >= token_buffer + maxtoken - 3)\n+\t\t  p = extend_token_buffer (p);\n+\t\t*p++ = c;\n+\t\tc = getc (finput);\n+\t\tif ((c == '+') || (c == '-'))\n+\t\t  {\n+\t\t    *p++ = c;\n+\t\t    c = getc (finput);\n+\t\t  }\n+\t\tif (! isdigit (c))\n+\t\t  error (\"floating constant exponent has no digits\");\n+\t        while (isdigit (c))\n+\t\t  {\n+\t\t    if (p >= token_buffer + maxtoken - 3)\n+\t\t      p = extend_token_buffer (p);\n+\t\t    *p++ = c;\n+\t\t    c = getc (finput);\n+\t\t  }\n+\t      }\n+\n+\t    *p = 0;\n+\t    errno = 0;\n+\n+\t    /* Convert string to a double, checking for overflow.  */\n+\t    if (setjmp (handler))\n+\t      {\n+\t\terror (\"floating constant out of range\");\n+\t\tvalue = dconst0;\n+\t      }\n+\t    else\n+\t      {\n+\t\tset_float_handler (handler);\n+\t\tvalue = REAL_VALUE_ATOF (token_buffer);\n+\t\tset_float_handler (0);\n+\t      }\n+#ifdef ERANGE\n+\t    if (errno == ERANGE && !flag_traditional)\n+\t      {\n+\t\tchar *p1 = token_buffer;\n+\t\t/* Check for \"0.0\" and variants;\n+\t\t   Sunos 4 spuriously returns ERANGE for them.  */\n+\t\twhile (*p1 == '0') p1++;\n+\t\tif (*p1 == '.')\n+\t\t  {\n+\t\t    p1++;\n+\t\t    while (*p1 == '0') p1++;\n+\t\t  }\n+\t\tif (*p1 == 'e' || *p1 == 'E')\n+\t\t  {\n+\t\t    /* with significand==0, ignore the exponent */\n+\t\t    p1++;\n+\t\t    while (*p1 != 0) p1++;\n+\t\t  }\n+\t\t/* ERANGE is also reported for underflow,\n+\t\t   so test the value to distinguish overflow from that.  */\n+\t\tif (*p1 != 0 && (value > 1.0 || value < -1.0))\n+\t\t  warning (\"floating point number exceeds range of `double'\");\n+\t      }\n+#endif\n+\n+\t    /* Read the suffixes to choose a data type.  */\n+\t    while (1)\n+\t      {\n+\t\tif (c == 'f' || c == 'F')\n+\t\t  {\n+\t\t    if (f_seen)\n+\t\t      error (\"two `f's in floating constant\");\n+\t\t    f_seen = 1;\n+\t\t    type = float_type_node;\n+\t\t    value = REAL_VALUE_TRUNCATE (TYPE_MODE (type), value);\n+\t\t  }\n+\t\telse if (c == 'l' || c == 'L')\n+\t\t  {\n+\t\t    if (l_seen)\n+\t\t      error (\"two `l's in floating constant\");\n+\t\t    l_seen = 1;\n+\t\t    type = long_double_type_node;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (isalnum (c))\n+\t\t      {\n+\t\t\terror (\"garbage at end of number\");\n+\t\t\twhile (isalnum (c))\n+\t\t\t  {\n+\t\t\t    if (p >= token_buffer + maxtoken - 3)\n+\t\t\t      p = extend_token_buffer (p);\n+\t\t\t    *p++ = c;\n+\t\t\t    c = getc (finput);\n+\t\t\t  }\n+\t\t      }\n+\t\t    break;\n+\t\t  }\n+\t\tif (p >= token_buffer + maxtoken - 3)\n+\t\t  p = extend_token_buffer (p);\n+\t\t*p++ = c;\n+\t\tc = getc (finput);\n+\t      }\n+\n+\t    /* Create a node with determined type and value.  */\n+\t    yylval.ttype = build_real (type, value);\n+\n+\t    ungetc (c, finput);\n+\t    *p = 0;\n+\t  }\n+\telse\n+\t  {\n+\t    tree traditional_type, ansi_type, type;\n+\t    int spec_unsigned = 0;\n+\t    int spec_long = 0;\n+\t    int spec_long_long = 0;\n+\t    int bytes, warn, i;\n+\n+\t    while (1)\n+\t      {\n+\t\tif (c == 'u' || c == 'U')\n+\t\t  {\n+\t\t    if (spec_unsigned)\n+\t\t      error (\"two `u's in integer constant\");\n+\t\t    spec_unsigned = 1;\n+\t\t  }\n+\t\telse if (c == 'l' || c == 'L')\n+\t\t  {\n+\t\t    if (spec_long)\n+\t\t      {\n+\t\t\tif (spec_long_long)\n+\t\t\t  error (\"three `l's in integer constant\");\n+\t\t\telse if (pedantic)\n+\t\t\t  pedwarn (\"ANSI C forbids long long integer constants\");\n+\t\t\tspec_long_long = 1;\n+\t\t      }\n+\t\t    spec_long = 1;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (isalnum (c))\n+\t\t      {\n+\t\t\terror (\"garbage at end of number\");\n+\t\t\twhile (isalnum (c))\n+\t\t\t  {\n+\t\t\t    if (p >= token_buffer + maxtoken - 3)\n+\t\t\t      p = extend_token_buffer (p);\n+\t\t\t    *p++ = c;\n+\t\t\t    c = getc (finput);\n+\t\t\t  }\n+\t\t      }\n+\t\t    break;\n+\t\t  }\n+\t\tif (p >= token_buffer + maxtoken - 3)\n+\t\t  p = extend_token_buffer (p);\n+\t\t*p++ = c;\n+\t\tc = getc (finput);\n+\t      }\n+\n+\t    ungetc (c, finput);\n+\n+\t    /* If the constant is not long long and it won't fit in an\n+\t       unsigned long, or if the constant is long long and won't fit\n+\t       in an unsigned long long, then warn that the constant is out\n+\t       of range.  */\n+\n+\t    /* ??? This assumes that long long and long integer types are\n+\t       a multiple of 8 bits.  This better than the original code\n+\t       though which assumed that long was exactly 32 bits and long\n+\t       long was exactly 64 bits.  */\n+\n+\t    if (spec_long_long)\n+\t      bytes = TYPE_PRECISION (long_long_integer_type_node) / 8;\n+\t    else\n+\t      bytes = TYPE_PRECISION (long_integer_type_node) / 8;\n+\n+\t    if (bytes <= 8)\n+\t      {\n+\t\twarn = overflow;\n+\t\tfor (i = bytes; i < 8; i++)\n+\t\t  if (shorts[i])\n+\t\t    {\n+\t\t      /* If LL was not used, then clear any excess precision.\n+\t\t\t This is equivalent to the original code, but it is\n+\t\t\t not clear why this is being done.  Perhaps to prevent\n+\t\t\t ANSI programs from creating long long constants\n+\t\t\t by accident?  */\n+\t\t      if (! spec_long_long)\n+\t\t\tshorts[i] = 0;\n+\t\t      warn = 1;\n+\t\t    }\n+\t\tif (warn)\n+\t\t  warning (\"integer constant out of range\");\n+\t      }\n+\t    else if (overflow)\n+\t      warning (\"integer constant larger than compiler can handle\");\n+\n+\t    /* If it overflowed our internal buffer, then make it unsigned.\n+\t       We can't distinguish based on the tree node because\n+\t       any integer constant fits any long long type.  */\n+\t    if (overflow)\n+\t      spec_unsigned = 1;\n+\n+\t    /* This is simplified by the fact that our constant\n+\t       is always positive.  */\n+\t    /* The casts in the following statement should not be\n+\t       needed, but they get around bugs in some C compilers.  */\n+\t    yylval.ttype\n+\t      = (build_int_2\n+\t\t ((((long)shorts[3]<<24) + ((long)shorts[2]<<16)\n+\t\t   + ((long)shorts[1]<<8) + (long)shorts[0]),\n+\t\t  (((long)shorts[7]<<24) + ((long)shorts[6]<<16)\n+\t\t   + ((long)shorts[5]<<8) + (long)shorts[4])));\n+\n+#if 0\n+\t    /* Find the first allowable type that the value fits in.  */\n+\t    type = 0;\n+\t    for (i = 0; i < sizeof (type_sequence) / sizeof (type_sequence[0]);\n+\t\t i++)\n+\t      if (!(spec_long && !type_sequence[i].long_flag)\n+\t\t  && !(spec_long_long && !type_sequence[i].long_long_flag)\n+\t\t  && !(spec_unsigned && !type_sequence[i].unsigned_flag)\n+\t\t  /* A decimal constant can't be unsigned int\n+\t\t     unless explicitly specified.  */\n+\t\t  && !(base == 10 && !spec_unsigned\n+\t\t       && *type_sequence[i].node_var == unsigned_type_node))\n+\t\tif (int_fits_type_p (yylval.ttype, *type_sequence[i].node_var))\n+\t\t  {\n+\t\t    type = *type_sequence[i].node_var;\n+\t\t    break;\n+\t\t  }\n+\t    if (flag_traditional && type == long_unsigned_type_node\n+\t\t&& !spec_unsigned)\n+\t      type = long_integer_type_node;\n+\t      \n+\t    if (type == 0)\n+\t      {\n+\t\ttype = long_long_integer_type_node;\n+\t\twarning (\"integer constant out of range\");\n+\t      }\n+\n+\t    /* Warn about some cases where the type of a given constant\n+\t       changes from traditional C to ANSI C.  */\n+\t    if (warn_traditional)\n+\t      {\n+\t\ttree other_type = 0;\n+\n+\t\t/* This computation is the same as the previous one\n+\t\t   except that flag_traditional is used backwards.  */\n+\t\tfor (i = 0; i < sizeof (type_sequence) / sizeof (type_sequence[0]);\n+\t\t     i++)\n+\t\t  if (!(spec_long && !type_sequence[i].long_flag)\n+\t\t      && !(spec_long_long && !type_sequence[i].long_long_flag)\n+\t\t      && !(spec_unsigned && !type_sequence[i].unsigned_flag)\n+\t\t      /* A decimal constant can't be unsigned int\n+\t\t\t unless explicitly specified.  */\n+\t\t      && !(base == 10 && !spec_unsigned\n+\t\t\t   && *type_sequence[i].node_var == unsigned_type_node))\n+\t\t    if (int_fits_type_p (yylval.ttype, *type_sequence[i].node_var))\n+\t\t      {\n+\t\t\tother_type = *type_sequence[i].node_var;\n+\t\t\tbreak;\n+\t\t      }\n+\t\tif (!flag_traditional && type == long_unsigned_type_node\n+\t\t    && !spec_unsigned)\n+\t\t  type = long_integer_type_node;\n+\t      \n+\t\tif (other_type != 0 && other_type != type)\n+\t\t  {\n+\t\t    if (flag_traditional)\n+\t\t      warning (\"type of integer constant would be different without -traditional\");\n+\t\t    else\n+\t\t      warning (\"type of integer constant would be different with -traditional\");\n+\t\t  }\n+\t      }\n+\n+#else /* 1 */\n+\t    /* If warn_traditional, calculate both the ANSI type and the\n+\t       traditional type, then see if they disagree.\n+\t       Otherwise, calculate only the type for the dialect in use.  */\n+\t    if (warn_traditional || flag_traditional)\n+\t      {\n+\t\t/* Calculate the traditional type.  */\n+\t\t/* Traditionally, any constant is signed;\n+\t\t   but if unsigned is specified explicitly, obey that.\n+\t\t   Use the smallest size with the right number of bits,\n+\t\t   except for one special case with decimal constants.  */\n+\t\tif (! spec_long && base != 10\n+\t\t    && int_fits_type_p (yylval.ttype, unsigned_type_node))\n+\t\t  traditional_type = (spec_unsigned ? unsigned_type_node\n+\t\t\t\t      : integer_type_node);\n+\t\t/* A decimal constant must be long\n+\t\t   if it does not fit in type int.\n+\t\t   I think this is independent of whether\n+\t\t   the constant is signed.  */\n+\t\telse if (! spec_long && base == 10\n+\t\t\t && int_fits_type_p (yylval.ttype, integer_type_node))\n+\t\t  traditional_type = (spec_unsigned ? unsigned_type_node\n+\t\t\t\t      : integer_type_node);\n+\t\telse if (! spec_long_long\n+\t\t\t && int_fits_type_p (yylval.ttype,\n+\t\t\t\t\t     long_unsigned_type_node))\n+\t\t  traditional_type = (spec_unsigned ? long_unsigned_type_node\n+\t\t\t\t      : long_integer_type_node);\n+\t\telse\n+\t\t  traditional_type = (spec_unsigned\n+\t\t\t\t      ? long_long_unsigned_type_node\n+\t\t\t\t      : long_long_integer_type_node);\n+\t      }\n+\t    if (warn_traditional || ! flag_traditional)\n+\t      {\n+\t\t/* Calculate the ANSI type.  */\n+\t\tif (! spec_long && ! spec_unsigned\n+\t\t    && int_fits_type_p (yylval.ttype, integer_type_node))\n+\t\t  ansi_type = integer_type_node;\n+\t\telse if (! spec_long && (base != 10 || spec_unsigned)\n+\t\t\t && int_fits_type_p (yylval.ttype, unsigned_type_node))\n+\t\t  ansi_type = unsigned_type_node;\n+\t\telse if (! spec_unsigned && !spec_long_long\n+\t\t\t && int_fits_type_p (yylval.ttype, long_integer_type_node))\n+\t\t  ansi_type = long_integer_type_node;\n+\t\telse if (! spec_long_long\n+\t\t\t && int_fits_type_p (yylval.ttype,\n+\t\t\t\t\t     long_unsigned_type_node))\n+\t\t  ansi_type = long_unsigned_type_node;\n+\t\telse if (! spec_unsigned\n+\t\t\t && int_fits_type_p (yylval.ttype,\n+\t\t\t\t\t     long_long_integer_type_node))\n+\t\t  ansi_type = long_long_integer_type_node;\n+\t\telse\n+\t\t  ansi_type = long_long_unsigned_type_node;\n+\t      }\n+\n+\t    type = flag_traditional ? traditional_type : ansi_type;\n+\n+\t    if (warn_traditional && traditional_type != ansi_type)\n+\t      {\n+\t\tif (TYPE_PRECISION (traditional_type)\n+\t\t    != TYPE_PRECISION (ansi_type))\n+\t\t  warning (\"width of integer constant changes with -traditional\");\n+\t\telse if (TREE_UNSIGNED (traditional_type)\n+\t\t\t != TREE_UNSIGNED (ansi_type))\n+\t\t  warning (\"integer constant is unsigned in ANSI C, signed with -traditional\");\n+\t\telse abort ();\n+\t      }\n+#endif\n+\n+\t    TREE_TYPE (yylval.ttype) = type;\n+\t    *p = 0;\n+\t  }\n+\n+\tvalue = CONSTANT; break;\n+      }\n+\n+    case '\\'':\n+    char_constant:\n+      {\n+\tregister int result = 0;\n+\tregister num_chars = 0;\n+\tunsigned width = TYPE_PRECISION (char_type_node);\n+\tint max_chars;\n+\n+\tif (wide_flag)\n+\t  {\n+\t    width = WCHAR_TYPE_SIZE;\n+#ifdef MULTIBYTE_CHARS\n+\t    max_chars = MB_CUR_MAX;\n+#else\n+\t    max_chars = 1;\n+#endif\n+\t  }\n+\telse\n+\t  max_chars = TYPE_PRECISION (integer_type_node) / width;\n+\n+\twhile (1)\n+\t  {\n+\t  tryagain:\n+\n+\t    c = getc (finput);\n+\n+\t    if (c == '\\'' || c == EOF)\n+\t      break;\n+\n+\t    if (c == '\\\\')\n+\t      {\n+\t\tc = readescape ();\n+\t\tif (c < 0)\n+\t\t  goto tryagain;\n+\t\tif (width < HOST_BITS_PER_INT\n+\t\t    && (unsigned) c >= (1 << width))\n+\t\t  pedwarn (\"escape sequence out of range for character\");\n+\t      }\n+\t    else if (c == '\\n')\n+\t      {\n+\t\tif (pedantic)\n+\t\t  pedwarn (\"ANSI C forbids newline in character constant\");\n+\t\tlineno++;\n+\t      }\n+\n+\t    num_chars++;\n+\t    if (num_chars > maxtoken - 4)\n+\t      extend_token_buffer (token_buffer);\n+\n+\t    token_buffer[num_chars] = c;\n+\n+\t    /* Merge character into result; ignore excess chars.  */\n+\t    if (num_chars < max_chars + 1)\n+\t      {\n+\t\tif (width < HOST_BITS_PER_INT)\n+\t\t  result = (result << width) | (c & ((1 << width) - 1));\n+\t\telse\n+\t\t  result = c;\n+\t      }\n+\t  }\n+\n+\ttoken_buffer[num_chars + 1] = '\\'';\n+\ttoken_buffer[num_chars + 2] = 0;\n+\n+\tif (c != '\\'')\n+\t  error (\"malformatted character constant\");\n+\telse if (num_chars == 0)\n+\t  error (\"empty character constant\");\n+\telse if (num_chars > max_chars)\n+\t  {\n+\t    num_chars = max_chars;\n+\t    error (\"character constant too long\");\n+\t  }\n+\telse if (num_chars != 1 && ! flag_traditional)\n+\t  warning (\"multi-character character constant\");\n+\n+\t/* If char type is signed, sign-extend the constant.  */\n+\tif (! wide_flag)\n+\t  {\n+\t    int num_bits = num_chars * width;\n+\t    if (TREE_UNSIGNED (char_type_node)\n+\t\t|| ((result >> (num_bits - 1)) & 1) == 0)\n+\t      yylval.ttype\n+\t\t= build_int_2 (result & ((unsigned) ~0\n+\t\t\t\t\t >> (HOST_BITS_PER_INT - num_bits)),\n+\t\t\t       0);\n+\t    else\n+\t      yylval.ttype\n+\t\t= build_int_2 (result | ~((unsigned) ~0\n+\t\t\t\t\t  >> (HOST_BITS_PER_INT - num_bits)),\n+\t\t\t       -1);\n+\t  }\n+\telse\n+\t  {\n+#ifdef MULTIBYTE_CHARS\n+\t    /* Set the initial shift state and convert the next sequence.  */\n+\t    result = 0;\n+\t    /* In all locales L'\\0' is zero and mbtowc will return zero,\n+\t       so don't use it.  */\n+\t    if (num_chars > 1\n+\t\t|| (num_chars == 1 && token_buffer[1] != '\\0'))\n+\t      {\n+\t\twchar_t wc;\n+\t\t(void) mbtowc (NULL, NULL, 0);\n+\t\tif (mbtowc (& wc, token_buffer + 1, num_chars) == num_chars)\n+\t\t  result = wc;\n+\t\telse\n+\t\t  warning (\"Ignoring invalid multibyte character\");\n+\t      }\n+#endif\n+\t    yylval.ttype = build_int_2 (result, 0);\n+\t  }\n+\n+\tTREE_TYPE (yylval.ttype) = integer_type_node;\n+\tvalue = CONSTANT;\n+\tbreak;\n+      }\n+\n+    case '\"':\n+    string_constant:\n+      {\n+\tc = getc (finput);\n+\tp = token_buffer + 1;\n+\n+\twhile (c != '\"' && c >= 0)\n+\t  {\n+\t    /* ignore_escape_flag is set for reading the filename in #line.  */\n+\t    if (!ignore_escape_flag && c == '\\\\')\n+\t      {\n+\t\tc = readescape ();\n+\t\tif (c < 0)\n+\t\t  goto skipnewline;\n+\t\tif (!wide_flag\n+\t\t    && TYPE_PRECISION (char_type_node) < HOST_BITS_PER_INT\n+\t\t    && c >= (1 << TYPE_PRECISION (char_type_node)))\n+\t\t  pedwarn (\"escape sequence out of range for character\");\n+\t      }\n+\t    else if (c == '\\n')\n+\t      {\n+\t\tif (pedantic)\n+\t\t  pedwarn (\"ANSI C forbids newline in string constant\");\n+\t\tlineno++;\n+\t      }\n+\n+\t    if (p == token_buffer + maxtoken)\n+\t      p = extend_token_buffer (p);\n+\t    *p++ = c;\n+\n+\t  skipnewline:\n+\t    c = getc (finput);\n+\t  }\n+\t*p = 0;\n+\n+\t/* We have read the entire constant.\n+\t   Construct a STRING_CST for the result.  */\n+\n+\tif (wide_flag)\n+\t  {\n+\t    /* If this is a L\"...\" wide-string, convert the multibyte string\n+\t       to a wide character string.  */\n+\t    char *widep = (char *) alloca ((p - token_buffer) * WCHAR_BYTES);\n+\t    int len;\n+\n+#ifdef MULTIBYTE_CHARS\n+\t    len = mbstowcs ((wchar_t *) widep, token_buffer + 1, p - token_buffer);\n+\t    if ((unsigned) len >= (p - token_buffer))\n+\t      {\n+\t\twarning (\"Ignoring invalid multibyte string\");\n+\t\tlen = 0;\n+\t      }\n+\t    bzero (widep + (len * WCHAR_BYTES), WCHAR_BYTES);\n+#else\n+\t    {\n+\t      union { long l; char c[sizeof (long)]; } u;\n+\t      int big_endian;\n+\t      char *wp, *cp;\n+\n+\t      /* Determine whether host is little or big endian.  */\n+\t      u.l = 1;\n+\t      big_endian = u.c[sizeof (long) - 1];\n+\t      wp = widep + (big_endian ? WCHAR_BYTES - 1 : 0);\n+\n+\t      bzero (widep, (p - token_buffer) * WCHAR_BYTES);\n+\t      for (cp = token_buffer + 1; cp < p; cp++)\n+\t\t*wp = *cp, wp += WCHAR_BYTES;\n+\t      len = p - token_buffer - 1;\n+\t    }\n+#endif\n+\t    yylval.ttype = build_string ((len + 1) * WCHAR_BYTES, widep);\n+\t    TREE_TYPE (yylval.ttype) = wchar_array_type_node;\n+\t  }\n+\telse\n+\t  {\n+\t    yylval.ttype = build_string (p - token_buffer, token_buffer + 1);\n+\t    TREE_TYPE (yylval.ttype) = char_array_type_node;\n+\t  }\n+\n+\t*p++ = '\"';\n+\t*p = 0;\n+\n+\tvalue = STRING; break;\n+      }\n+\n+    case '+':\n+    case '-':\n+    case '&':\n+    case '|':\n+    case '<':\n+    case '>':\n+    case '*':\n+    case '/':\n+    case '%':\n+    case '^':\n+    case '!':\n+    case '=':\n+      {\n+\tregister int c1;\n+\n+      combine:\n+\n+\tswitch (c)\n+\t  {\n+\t  case '+':\n+\t    yylval.code = PLUS_EXPR; break;\n+\t  case '-':\n+\t    yylval.code = MINUS_EXPR; break;\n+\t  case '&':\n+\t    yylval.code = BIT_AND_EXPR; break;\n+\t  case '|':\n+\t    yylval.code = BIT_IOR_EXPR; break;\n+\t  case '*':\n+\t    yylval.code = MULT_EXPR; break;\n+\t  case '/':\n+\t    yylval.code = TRUNC_DIV_EXPR; break;\n+\t  case '%':\n+\t    yylval.code = TRUNC_MOD_EXPR; break;\n+\t  case '^':\n+\t    yylval.code = BIT_XOR_EXPR; break;\n+\t  case LSHIFT:\n+\t    yylval.code = LSHIFT_EXPR; break;\n+\t  case RSHIFT:\n+\t    yylval.code = RSHIFT_EXPR; break;\n+\t  case '<':\n+\t    yylval.code = LT_EXPR; break;\n+\t  case '>':\n+\t    yylval.code = GT_EXPR; break;\n+\t  }\n+\n+\ttoken_buffer[1] = c1 = getc (finput);\n+\ttoken_buffer[2] = 0;\n+\n+\tif (c1 == '=')\n+\t  {\n+\t    switch (c)\n+\t      {\n+\t      case '<':\n+\t\tvalue = ARITHCOMPARE; yylval.code = LE_EXPR; goto done;\n+\t      case '>':\n+\t\tvalue = ARITHCOMPARE; yylval.code = GE_EXPR; goto done;\n+\t      case '!':\n+\t\tvalue = EQCOMPARE; yylval.code = NE_EXPR; goto done;\n+\t      case '=':\n+\t\tvalue = EQCOMPARE; yylval.code = EQ_EXPR; goto done;\n+\t      }\n+\t    value = ASSIGN; goto done;\n+\t  }\n+\telse if (c == c1)\n+\t  switch (c)\n+\t    {\n+\t    case '+':\n+\t      value = PLUSPLUS; goto done;\n+\t    case '-':\n+\t      value = MINUSMINUS; goto done;\n+\t    case '&':\n+\t      value = ANDAND; goto done;\n+\t    case '|':\n+\t      value = OROR; goto done;\n+\t    case '<':\n+\t      c = LSHIFT;\n+\t      goto combine;\n+\t    case '>':\n+\t      c = RSHIFT;\n+\t      goto combine;\n+\t    }\n+\telse if ((c == '-') && (c1 == '>'))\n+\t  { value = POINTSAT; goto done; }\n+\tungetc (c1, finput);\n+\ttoken_buffer[1] = 0;\n+\n+\tif ((c == '<') || (c == '>'))\n+\t  value = ARITHCOMPARE;\n+\telse value = c;\n+\tgoto done;\n+      }\n+\n+    case 0:\n+      /* Don't make yyparse think this is eof.  */\n+      value = 1;\n+      break;\n+\n+    default:\n+      value = c;\n+    }\n+\n+done:\n+/*  yylloc.last_line = lineno; */\n+\n+  return value;\n+}\n+\n+/* Sets the value of the 'yydebug' varable to VALUE.\n+   This is a function so we don't have to have YYDEBUG defined\n+   in order to build the compiler.  */\n+\n+void\n+set_yydebug (value)\n+     int value;\n+{\n+#if YYDEBUG != 0\n+  yydebug = value;\n+#else\n+  warning (\"YYDEBUG not defined.\");\n+#endif\n+}"}, {"sha": "66ebcc610e78fac5076b0a0d697ebca62b52631d", "filename": "gcc/expr.h", "status": "added", "additions": 604, "deletions": 0, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8bbfc4e2344f007bbbb63e02257cce4bba1697c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8bbfc4e2344f007bbbb63e02257cce4bba1697c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=e8bbfc4e2344f007bbbb63e02257cce4bba1697c", "patch": "@@ -0,0 +1,604 @@\n+/* Definitions for code generation pass of GNU compiler.\n+   Copyright (C) 1987, 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#ifndef __STDC__\n+#ifndef const\n+#define const\n+#endif\n+#endif\n+\n+/* The default branch cost is 1.  */\n+#ifndef BRANCH_COST\n+#define BRANCH_COST 1\n+#endif\n+\n+/* Macros to access the slots of a QUEUED rtx.\n+   Here rather than in rtl.h because only the expansion pass\n+   should ever encounter a QUEUED.  */\n+\n+/* The variable for which an increment is queued.  */\n+#define QUEUED_VAR(P) XEXP (P, 0)\n+/* If the increment has been emitted, this is the insn\n+   that does the increment.  It is zero before the increment is emitted.  */\n+#define QUEUED_INSN(P) XEXP (P, 1)\n+/* If a pre-increment copy has been generated, this is the copy\n+   (it is a temporary reg).  Zero if no copy made yet.  */\n+#define QUEUED_COPY(P) XEXP (P, 2)\n+/* This is the body to use for the insn to do the increment.\n+   It is used to emit the increment.  */\n+#define QUEUED_BODY(P) XEXP (P, 3)\n+/* Next QUEUED in the queue.  */\n+#define QUEUED_NEXT(P) XEXP (P, 4)\n+\n+/* This is the 4th arg to `expand_expr'.\n+   EXPAND_SUM means it is ok to return a PLUS rtx or MULT rtx.\n+   EXPAND_INITIALIZER is similar but also record any labels on forced_labels.\n+   EXPAND_CONST_ADDRESS means it is ok to return a MEM whose address\n+    is a constant that is not a legitimate address.  */\n+enum expand_modifier {EXPAND_NORMAL, EXPAND_SUM,\n+\t\t      EXPAND_CONST_ADDRESS, EXPAND_INITIALIZER};\n+\n+/* List of labels that must never be deleted.  */\n+extern rtx forced_labels;\n+\n+/* List (chain of EXPR_LISTs) of pseudo-regs of SAVE_EXPRs.\n+   So we can mark them all live at the end of the function, if stupid.  */\n+extern rtx save_expr_regs;\n+\n+extern int current_function_calls_alloca;\n+extern int current_function_outgoing_args_size;\n+\n+/* This is the offset from the arg pointer to the place where the first\n+   anonymous arg can be found, if there is one.  */\n+extern rtx current_function_arg_offset_rtx;\n+\n+/* This is nonzero if the current function uses the constant pool.  */\n+extern int current_function_uses_const_pool;\n+\n+/* This is nonzero if the current function uses pic_offset_table_rtx.  */\n+extern int current_function_uses_pic_offset_table;\n+\n+/* The arg pointer hard register, or the pseudo into which it was copied.  */\n+extern rtx current_function_internal_arg_pointer;\n+\n+/* Nonzero means stack pops must not be deferred, and deferred stack\n+   pops must not be output.  It is nonzero inside a function call,\n+   inside a conditional expression, inside a statement expression,\n+   and in other cases as well.  */\n+extern int inhibit_defer_pop;\n+\n+/* Number of function calls seen so far in current function.  */\n+\n+extern int function_call_count;\n+\n+/* RTX for stack slot that holds the current handler for nonlocal gotos.\n+   Zero when function does not have nonlocal labels.  */\n+\n+extern rtx nonlocal_goto_handler_slot;\n+\n+/* RTX for stack slot that holds the stack pointer value to restore\n+   for a nonlocal goto.\n+   Zero when function does not have nonlocal labels.  */\n+\n+extern rtx nonlocal_goto_stack_level;\n+\n+/* List (chain of TREE_LIST) of LABEL_DECLs for all nonlocal labels\n+   (labels to which there can be nonlocal gotos from nested functions)\n+   in this function.  */\n+\n+#ifdef TREE_CODE   /* Don't lose if tree.h not included.  */\n+extern tree nonlocal_labels;\n+#endif\n+\n+#define NO_DEFER_POP (inhibit_defer_pop += 1)\n+#define OK_DEFER_POP (inhibit_defer_pop -= 1)\n+\n+/* Number of units that we should eventually pop off the stack.\n+   These are the arguments to function calls that have already returned.  */\n+extern int pending_stack_adjust;\n+\n+/* A list of all cleanups which belong to the arguments of\n+   function calls being expanded by expand_call.  */\n+#ifdef TREE_CODE   /* Don't lose if tree.h not included.  */\n+extern tree cleanups_this_call;\n+#endif\n+\f\n+#ifdef TREE_CODE /* Don't lose if tree.h not included.  */\n+/* Structure to record the size of a sequence of arguments\n+   as the sum of a tree-expression and a constant.  */\n+\n+struct args_size\n+{\n+  int constant;\n+  tree var;\n+};\n+#endif\n+\n+/* Add the value of the tree INC to the `struct args_size' TO.  */\n+\n+#define ADD_PARM_SIZE(TO, INC)\t\\\n+{ tree inc = (INC);\t\t\t\t\\\n+  if (TREE_CODE (inc) == INTEGER_CST)\t\t\\\n+    (TO).constant += TREE_INT_CST_LOW (inc);\t\\\n+  else if ((TO).var == 0)\t\t\t\\\n+    (TO).var = inc;\t\t\t\t\\\n+  else\t\t\t\t\t\t\\\n+    (TO).var = size_binop (PLUS_EXPR, (TO).var, inc); }\n+\n+#define SUB_PARM_SIZE(TO, DEC)\t\\\n+{ tree dec = (DEC);\t\t\t\t\\\n+  if (TREE_CODE (dec) == INTEGER_CST)\t\t\\\n+    (TO).constant -= TREE_INT_CST_LOW (dec);\t\\\n+  else if ((TO).var == 0)\t\t\t\\\n+    (TO).var = size_binop (MINUS_EXPR, integer_zero_node, dec); \\\n+  else\t\t\t\t\t\t\\\n+    (TO).var = size_binop (MINUS_EXPR, (TO).var, dec); }\n+\n+/* Convert the implicit sum in a `struct args_size' into an rtx.  */\n+#define ARGS_SIZE_RTX(SIZE)\t\t\t\t\t\t\\\n+((SIZE).var == 0 ? gen_rtx (CONST_INT, VOIDmode, (SIZE).constant)\t\\\n+ : expand_expr (size_binop (PLUS_EXPR, (SIZE).var,\t\t\t\\\n+\t\t\t    size_int ((SIZE).constant)),\t\t\\\n+\t\t0, VOIDmode, 0))\n+\n+/* Convert the implicit sum in a `struct args_size' into a tree.  */\n+#define ARGS_SIZE_TREE(SIZE)\t\t\t\t\t\t\\\n+((SIZE).var == 0 ? size_int ((SIZE).constant)\t\t\t\t\\\n+ : size_binop (PLUS_EXPR, (SIZE).var, size_int ((SIZE).constant)))\n+\n+/* Supply a default definition for FUNCTION_ARG_PADDING:\n+   usually pad upward, but pad short, non-BLKmode args downward on\n+   big-endian machines.  */\n+\n+enum direction {none, upward, downward};  /* Value has this type.  */\n+\n+#ifndef FUNCTION_ARG_PADDING\n+#if BYTES_BIG_ENDIAN\n+#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n+  (((MODE) == BLKmode\t\t\t\t\t\t\t\\\n+    ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n+       && int_size_in_bytes (TYPE) < PARM_BOUNDARY / BITS_PER_UNIT)\t\\\n+    : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\t\\\n+   ? downward : upward)\n+#else\n+#define FUNCTION_ARG_PADDING(MODE, TYPE) upward\n+#endif\n+#endif\n+\n+/* Supply a default definition for FUNCTION_ARG_BOUNDARY.  Normally, we let\n+   FUNCTION_ARG_PADDING, which also pads the length, handle any needed\n+   alignment.  */\n+  \n+#ifndef FUNCTION_ARG_BOUNDARY\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\tPARM_BOUNDARY\n+#endif\n+\n+/* Nonzero if we do not know how to pass TYPE solely in registers.\n+   We cannot do so in the following cases:\n+\n+   - if the type has variable size\n+   - if the type is marked as addressable (it is required to be constructed\n+     into the stack)\n+   - if the padding and mode of the type is such that a copy into a register\n+     would put it into the wrong part of the register\n+   - when STRICT_ALIGNMENT and the type is BLKmode and is is not\n+     aligned to a boundary corresponding to what can be loaded into a\n+     register.  */\n+\n+#define MUST_PASS_IN_STACK_BAD_ALIGN(MODE,TYPE)\t\t\t\\\n+  (STRICT_ALIGNMENT && MODE == BLKmode\t\t\t        \\\n+   && TYPE_ALIGN (TYPE) < (BIGGEST_ALIGNMENT < BITS_PER_WORD\t\\\n+\t\t\t   ? BIGGEST_ALIGNMENT : BITS_PER_WORD))\n+  \n+/* Which padding can't be supported depends on the byte endianness.  */\n+\n+/* A value in a register is implicitly padded at the most significant end.\n+   On a big-endian machine, that is the lower end in memory.\n+   So a value padded in memory at the upper end can't go in a register.\n+   For a little-endian machine, the reverse is true.  */\n+\n+#if BYTES_BIG_ENDIAN\n+#define MUST_PASS_IN_STACK_BAD_PADDING\tupward\n+#else\n+#define MUST_PASS_IN_STACK_BAD_PADDING\tdownward\n+#endif\n+\n+#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\\\n+  ((TYPE) != 0\t\t\t\t\t\t\\\n+   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n+       || TREE_ADDRESSABLE (TYPE)\t\t\t\\\n+       || ((MODE) == BLKmode \t\t\t\t\\\n+\t   && (FUNCTION_ARG_PADDING (MODE, TYPE)\t\\\n+\t       == MUST_PASS_IN_STACK_BAD_PADDING))\t\\\n+       || MUST_PASS_IN_STACK_BAD_ALIGN (MODE, TYPE)))\n+\n+/* Nonzero if type TYPE should be returned in memory\n+   (even though its mode is not BLKmode).\n+   Most machines can use the following default definition.  */\n+\n+#ifndef RETURN_IN_MEMORY\n+#define RETURN_IN_MEMORY(TYPE) 0\n+#endif\n+\f\n+/* Optabs are tables saying how to generate insn bodies\n+   for various machine modes and numbers of operands.\n+   Each optab applies to one operation.\n+   For example, add_optab applies to addition.\n+\n+   The insn_code slot is the enum insn_code that says how to\n+   generate an insn for this operation on a particular machine mode.\n+   It is CODE_FOR_nothing if there is no such insn on the target machine.\n+\n+   The `lib_call' slot is the name of the library function that\n+   can be used to perform the operation.\n+\n+   A few optabs, such as move_optab and cmp_optab, are used\n+   by special code.  */\n+\n+/* Everything that uses expr.h needs to define enum insn_code\n+   but we don't list it in the Makefile dependencies just for that.  */\n+#include \"insn-codes.h\"\n+\n+typedef struct optab\n+{\n+  enum rtx_code code;\n+  struct {\n+    enum insn_code insn_code;\n+    rtx libfunc;\n+  } handlers [NUM_MACHINE_MODES];\n+} * optab;\n+\n+/* Given an enum insn_code, access the function to construct\n+   the body of that kind of insn.  */\n+#ifdef FUNCTION_CONVERSION_BUG\n+/* Some compilers fail to convert a function properly to a\n+   pointer-to-function when used as an argument.\n+   So produce the pointer-to-function directly.\n+   Luckily, these compilers seem to work properly when you\n+   call the pointer-to-function.  */\n+#define GEN_FCN(CODE) (insn_gen_function[(int) (CODE)])\n+#else\n+#define GEN_FCN(CODE) (*insn_gen_function[(int) (CODE)])\n+#endif\n+\n+extern rtx (*const insn_gen_function[]) ();\n+\n+extern optab add_optab;\n+extern optab sub_optab;\n+extern optab smul_optab;\t/* Signed multiply */\n+extern optab smul_widen_optab;\t/* Signed multiply with result \n+\t\t\t\t   one machine mode wider than args */\n+extern optab umul_widen_optab;\n+extern optab sdiv_optab;\t/* Signed divide */\n+extern optab sdivmod_optab;\t/* Signed divide-and-remainder in one */\n+extern optab udiv_optab;\n+extern optab udivmod_optab;\n+extern optab smod_optab;\t/* Signed remainder */\n+extern optab umod_optab;\n+extern optab flodiv_optab;\t/* Optab for floating divide. */\n+extern optab ftrunc_optab;\t/* Convert float to integer in float fmt */\n+extern optab and_optab;\t\t/* Logical and */\n+extern optab ior_optab;\t\t/* Logical or */\n+extern optab xor_optab;\t\t/* Logical xor */\n+extern optab ashl_optab;\t/* Arithmetic shift left */\n+extern optab ashr_optab;\t/* Arithmetic shift right */\n+extern optab lshl_optab;\t/* Logical shift left */\n+extern optab lshr_optab;\t/* Logical shift right */\n+extern optab rotl_optab;\t/* Rotate left */\n+extern optab rotr_optab;\t/* Rotate right */\n+extern optab smin_optab;\t/* Signed minimum value */\n+extern optab smax_optab;\t/* Signed maximum value */\n+extern optab umin_optab;\t/* Unsigned minimum value */\n+extern optab umax_optab;\t/* Unsigned maximum value */\n+\n+extern optab mov_optab;\t\t/* Move instruction.  */\n+extern optab movstrict_optab;\t/* Move, preserving high part of register.  */\n+\n+extern optab cmp_optab;\t\t/* Compare insn; two operands.  */\n+extern optab tst_optab;\t\t/* tst insn; compare one operand against 0 */\n+\n+/* Unary operations */\n+extern optab neg_optab;\t\t/* Negation */\n+extern optab abs_optab;\t\t/* Abs value */\n+extern optab one_cmpl_optab;\t/* Bitwise not */\n+extern optab ffs_optab;\t\t/* Find first bit set */\n+\n+/* Passed to expand_binop and expand_unop to say which options to try to use\n+   if the requested operation can't be open-coded on the requisite mode.\n+   Either OPTAB_LIB or OPTAB_LIB_WIDEN says try using a library call.\n+   Either OPTAB_WIDEN or OPTAB_LIB_WIDEN says try using a wider mode.\n+   OPTAB_MUST_WIDEN says try widening and don't try anything else.  */\n+\n+enum optab_methods\n+{\n+  OPTAB_DIRECT,\n+  OPTAB_LIB,\n+  OPTAB_WIDEN,\n+  OPTAB_LIB_WIDEN,\n+  OPTAB_MUST_WIDEN\n+};\n+\n+/* SYMBOL_REF rtx's for the library functions that are called\n+   implicitly and not via optabs.  */\n+\n+extern rtx extendsfdf2_libfunc;\n+extern rtx truncdfsf2_libfunc;\n+extern rtx memcpy_libfunc;\n+extern rtx bcopy_libfunc;\n+extern rtx memcmp_libfunc;\n+extern rtx bcmp_libfunc;\n+extern rtx memset_libfunc;\n+extern rtx bzero_libfunc;\n+extern rtx eqsf2_libfunc;\n+extern rtx nesf2_libfunc;\n+extern rtx gtsf2_libfunc;\n+extern rtx gesf2_libfunc;\n+extern rtx ltsf2_libfunc;\n+extern rtx lesf2_libfunc;\n+extern rtx eqdf2_libfunc;\n+extern rtx nedf2_libfunc;\n+extern rtx gtdf2_libfunc;\n+extern rtx gedf2_libfunc;\n+extern rtx ltdf2_libfunc;\n+extern rtx ledf2_libfunc;\n+extern rtx floatdisf_libfunc;\n+extern rtx floatsisf_libfunc;\n+extern rtx floatdidf_libfunc;\n+extern rtx floatsidf_libfunc;\n+extern rtx fixsfsi_libfunc;\n+extern rtx fixsfdi_libfunc;\n+extern rtx fixdfsi_libfunc;\n+extern rtx fixdfdi_libfunc;\n+extern rtx fixunssfsi_libfunc;\n+extern rtx fixunssfdi_libfunc;\n+extern rtx fixunsdfsi_libfunc;\n+extern rtx fixunsdfdi_libfunc;\n+\f\n+typedef rtx (*rtxfun) ();\n+\n+/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n+   gives the gen_function to make a branch to test that condition.  */\n+\n+extern rtxfun bcc_gen_fctn[NUM_RTX_CODE];\n+\n+/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n+   gives the insn code to make a store-condition insn\n+   to test that condition.  */\n+\n+extern enum insn_code setcc_gen_code[NUM_RTX_CODE];\n+\n+/* Expand a binary operation given optab and rtx operands.  */\n+extern rtx expand_binop ();\n+\n+/* Expand a binary operation with both signed and unsigned forms.  */\n+extern rtx sign_expand_binop ();\n+\n+/* Expand a unary arithmetic operation given optab rtx operand.  */\n+extern rtx expand_unop ();\n+\n+/* Arguments MODE, RTX: return an rtx for the negation of that value.\n+   May emit insns.  */\n+extern rtx negate_rtx ();\n+\n+/* Expand a logical AND operation.  */\n+extern rtx expand_and ();\n+\n+/* Emit a store-flag operation.  */\n+extern rtx emit_store_flag ();\n+\n+/* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\n+extern rtx label_rtx ();\n+\n+/* Given a JUMP_INSN, return a description of the test being made.  */\n+extern rtx get_condition ();\n+\n+/* Return the INSN_CODE to use for an extend operation.  */\n+extern enum insn_code can_extend_p ();\n+\n+/* Initialize the tables that control conversion between fixed and\n+   floating values.  */\n+extern void init_fixtab ();\n+extern void init_floattab ();\n+\n+/* Generate code for a FIX_EXPR.  */\n+extern void expand_fix ();\n+\n+/* Generate code for a FLOAT_EXPR.  */\n+extern void expand_float ();\n+\n+/* Create but don't emit one rtl instruction to add one rtx into another.\n+   Modes must match; operands must meet the operation's predicates.\n+   Likewise for subtraction and for just copying.\n+   These do not call protect_from_queue; caller must do so.  */\n+extern rtx gen_add2_insn ();\n+extern rtx gen_sub2_insn ();\n+extern rtx gen_move_insn ();\n+\n+/* Emit one rtl instruction to store zero in specified rtx.  */\n+extern void emit_clr_insn ();\n+\n+/* Emit one rtl insn to store 1 in specified rtx assuming it contains 0.  */\n+extern void emit_0_to_1_insn ();\n+\n+/* Emit one rtl insn to compare two rtx's.  */\n+extern void emit_cmp_insn ();\n+\n+/* Generate rtl to compate two rtx's, will call emit_cmp_insn.  */\n+extern rtx compare_from_rtx ();\n+\n+/* Emit some rtl insns to move data between rtx's, converting machine modes.\n+   Both modes must be floating or both fixed.  */\n+extern void convert_move ();\n+\n+/* Convert an rtx to specified machine mode and return the result.  */\n+extern rtx convert_to_mode ();\n+\n+/* Emit code to push some arguments and call a library routine,\n+   storing the value in a specified place.  Calling sequence is\n+   complicated.  */\n+extern void emit_library_call ();\n+\n+/* Given an rtx that may include add and multiply operations,\n+   generate them as insns and return a pseudo-reg containing the value.\n+   Useful after calling expand_expr with 1 as sum_ok.  */\n+extern rtx force_operand ();\n+\n+/* Return an rtx for the size in bytes of the value of an expr.  */\n+extern rtx expr_size ();\n+\n+/* Return an rtx for the sum of an rtx and an integer.  */\n+extern rtx plus_constant ();\n+\n+extern rtx lookup_static_chain ();\n+\n+/* Return an rtx like arg but sans any constant terms.\n+   Returns the original rtx if it has no constant terms.\n+   The constant terms are added and stored via a second arg.  */\n+extern rtx eliminate_constant_term ();\n+\n+/* Convert arg to a valid memory address for specified machine mode,\n+   by emitting insns to perform arithmetic if nec.  */\n+extern rtx memory_address ();\n+\n+/* Like `memory_address' but pretent `flag_force_addr' is 0.  */\n+extern rtx memory_address_noforce ();\n+\n+/* Return a memory reference like MEMREF, but with its mode changed\n+   to MODE and its address changed to ADDR.\n+   (VOIDmode means don't change the mode.\n+   NULL for ADDR means don't change the address.)  */\n+extern rtx change_address ();\n+\n+/* Return a memory reference like MEMREF, but which is known to have a\n+   valid address.  */\n+\n+extern rtx validize_mem ();\n+\n+/* Convert a stack slot address ADDR valid in function FNDECL\n+   into an address valid in this function (using a static chain).  */\n+extern rtx fix_lexical_addr ();\n+\n+/* Return the address of the trampoline for entering nested fn FUNCTION.  */\n+extern rtx trampoline_address ();\n+\n+/* Assemble the static constant template for function entry trampolines.  */\n+extern rtx assemble_trampoline_template ();\n+\n+/* Return 1 if two rtx's are equivalent in structure and elements.  */\n+extern int rtx_equal_p ();\n+\n+/* Given rtx, return new rtx whose address won't be affected by\n+   any side effects.  It has been copied to a new temporary reg.  */\n+extern rtx stabilize ();\n+\n+/* Given an rtx, copy all regs it refers to into new temps\n+   and return a modified copy that refers to the new temps.  */\n+extern rtx copy_all_regs ();\n+\n+/* Copy given rtx to a new temp reg and return that.  */\n+extern rtx copy_to_reg ();\n+\n+/* Like copy_to_reg but always make the reg Pmode.  */\n+extern rtx copy_addr_to_reg ();\n+\n+/* Like copy_to_reg but always make the reg the specified mode MODE.  */\n+extern rtx copy_to_mode_reg ();\n+\n+/* Copy given rtx to given temp reg and return that.  */\n+extern rtx copy_to_suggested_reg ();\n+\n+/* Copy a value to a register if it isn't already a register.\n+   Args are mode (in case value is a constant) and the value.  */\n+extern rtx force_reg ();\n+\n+/* Return given rtx, copied into a new temp reg if it was in memory.  */\n+extern rtx force_not_mem ();\n+\n+/* Remove some bytes from the stack.  An rtx says how many.  */\n+extern void adjust_stack ();\n+\n+/* Add some bytes to the stack.  An rtx says how many.  */\n+extern void anti_adjust_stack ();\n+\n+/* Allocate some space on the stack dynamically and return its address.  An rtx\n+   says how many bytes.  */\n+extern rtx allocate_dynamic_stack_space ();\n+\n+/* Emit code to copy function value to a new temp reg and return that reg.  */\n+extern rtx function_value ();\n+\n+/* Return an rtx that refers to the value returned by a function\n+   in its original home.  This becomes invalid if any more code is emitted.  */\n+extern rtx hard_function_value ();\n+\n+/* Return an rtx that refers to the value returned by a library call\n+   in its original home.  This becomes invalid if any more code is emitted.  */\n+extern rtx hard_libcall_value ();\n+\n+/* Emit code to copy function value to a specified place.  */\n+extern void copy_function_value ();\n+\n+/* Given an rtx, return an rtx for a value rounded up to a multiple\n+   of STACK_BOUNDARY / BITS_PER_UNIT.  */\n+extern rtx round_push ();\n+\n+/* Push a block of length SIZE (perhaps variable)\n+   and return an rtx to address the beginning of the block.  */\n+extern rtx push_block ();\n+\n+/* Generate code for computing expression EXP,\n+   and storing the value into TARGET.\n+   If SUGGEST_REG is nonzero, copy the value through a register\n+   and return that register, if that is possible.  */\n+extern rtx store_expr ();\n+\n+extern rtx prepare_call_address ();\n+extern rtx expand_call ();\n+extern void emit_call_1 ();\n+\n+extern void emit_block_move ();\n+extern void emit_push_insn ();\n+extern void use_regs ();\n+extern void move_block_to_reg ();\n+\n+extern rtx store_bit_field ();\n+extern rtx extract_bit_field ();\n+extern rtx expand_shift ();\n+extern rtx expand_mult ();\n+extern rtx expand_divmod ();\n+extern rtx expand_mult_add ();\n+extern rtx expand_stmt_expr ();\n+extern rtx emit_no_conflict_block ();\n+extern void emit_libcall_block ();\n+\n+extern void jumpifnot ();\n+extern void jumpif ();\n+extern void do_jump ();\n+\n+extern rtx assemble_static_space ();\n+\n+extern void locate_and_pad_parm ();\n+\n+extern rtx expand_inline_function ();\n+\n+/* Hook called by expand_expr for language-specific tree codes.\n+   It is up to the language front end to install a hook\n+   if it has any such codes that expand_expr needs to know about.  */\n+extern rtx (*lang_expand_expr) ();"}]}