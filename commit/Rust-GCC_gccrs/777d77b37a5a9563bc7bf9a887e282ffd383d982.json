{"sha": "777d77b37a5a9563bc7bf9a887e282ffd383d982", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc3ZDc3YjM3YTVhOTU2M2JjN2JmOWE4ODdlMjgyZmZkMzgzZDk4Mg==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2012-08-06T16:38:48Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2012-08-06T16:38:48Z"}, "message": "re PR tree-optimization/51938 (missed optimization: 2 comparisons)\n\n2012-08-06 Marc Glisse <marc.glisse@inria.fr>\n\ngcc/\n\tPR tree-optimization/51938\n\tPR tree-optimization/52005\n\t* tree-ssa-ifcombine.c (ifcombine_ifandif): New parameters for\n\tinverted conditions.\n\t(ifcombine_iforif): Remove, merge code into ifcombine_ifandif.\n\t(tree_ssa_ifcombine_bb): Update calls to the above. Detect !a&&b\n\tand !a||b patterns.\n\ngcc/testsuite/\n\tPR tree-optimization/51938\n\tPR tree-optimization/52005\n\t* gcc.dg/tree-ssa/ssa-ifcombine-8.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-ifcombine-9.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ifcombine-10.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ifcombine-11.c: Likewise.\n\nFrom-SVN: r190184", "tree": {"sha": "0874c41f243af364dbf1a7d854ea1a26da175de1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0874c41f243af364dbf1a7d854ea1a26da175de1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/777d77b37a5a9563bc7bf9a887e282ffd383d982", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777d77b37a5a9563bc7bf9a887e282ffd383d982", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777d77b37a5a9563bc7bf9a887e282ffd383d982", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777d77b37a5a9563bc7bf9a887e282ffd383d982/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "61b6d4cdee65148788a7638495ae61f8f2c93272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b6d4cdee65148788a7638495ae61f8f2c93272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61b6d4cdee65148788a7638495ae61f8f2c93272"}], "stats": {"total": 277, "additions": 193, "deletions": 84}, "files": [{"sha": "26e3e0fa7b143527e88624dde200815e5df71a61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=777d77b37a5a9563bc7bf9a887e282ffd383d982", "patch": "@@ -1,3 +1,13 @@\n+2012-08-06  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\tPR tree-optimization/51938\n+\tPR tree-optimization/52005\n+\t* tree-ssa-ifcombine.c (ifcombine_ifandif): New parameters for\n+\tinverted conditions.\n+\t(ifcombine_iforif): Remove, merge code into ifcombine_ifandif.\n+\t(tree_ssa_ifcombine_bb): Update calls to the above. Detect !a&&b\n+\tand !a||b patterns.\n+\n 2012-08-06  Olivier Hainque  <hainque@adacore.com>\n \n \t* tree-emutls.c (new_emutls_decl): When a var_section is requested by"}, {"sha": "ff22fbf199cb7ed935604d682c699959b79f78fc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=777d77b37a5a9563bc7bf9a887e282ffd383d982", "patch": "@@ -1,3 +1,12 @@\n+2012-08-06  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\tPR tree-optimization/51938\n+\tPR tree-optimization/52005\n+\t* gcc.dg/tree-ssa/ssa-ifcombine-8.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-ifcombine-9.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ifcombine-10.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ifcombine-11.c: Likewise.\n+\n 2012-08-06  Dodji Seketeli  <dodji@redhat.com>\n \n \tAvoid crashing on erroneous static_assert usage"}, {"sha": "c2b1c19d0e7d87d52af0d4ab16b998de3be174f0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-10.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-10.c?ref=777d77b37a5a9563bc7bf9a887e282ffd383d982", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+/* Testcase for PR31657.  */\n+\n+int f(int x, int a, int b)\n+{\n+  int t = 0;\n+  int c = 1 << a;\n+  if (!(x & 1))\n+    t = 0;\n+  else\n+    if (x & (1 << 2))\n+      t = 3;\n+    else\n+      t = 0;\n+  return t;\n+}\n+/* { dg-final { scan-tree-dump \"& 5\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d024df85accc38320abfad4c090dc61c1e37e65e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-11.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-11.c?ref=777d77b37a5a9563bc7bf9a887e282ffd383d982", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+/* Testcase for PR31657.  */\n+int g(void);\n+int f(int x, int a, int b)\n+{\n+  int t = 0;\n+  int c = 1 << a;\n+  if (!(x & 1))\n+    t = 0;\n+  else\n+    if (x & (1 << 2))\n+      t = g();\n+    else\n+      t = 0;\n+  return t;\n+}\n+\n+/* { dg-final { scan-tree-dump \"& 5\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "a6c4282ef63559d3fcddf58edaa679a62cb5cc99", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-8.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-8.c?ref=777d77b37a5a9563bc7bf9a887e282ffd383d982", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-trapping-math -fdump-tree-ifcombine\" } */\n+\n+double test1 (double i, double j)\n+{\n+  if (i >= j)\n+    if (i <= j)\n+      goto plif;\n+    else\n+      goto plouf;\n+  else\n+    goto plif;\n+\n+plif:\n+  return 0;\n+plouf:\n+  return -1;\n+}\n+\n+/* The above should be optimized to a i > j test by ifcombine.\n+   The transformation would also be legal with -ftrapping-math.\n+   Instead we get u<=, which is acceptable with -fno-trapping-math.  */\n+\n+/* { dg-final { scan-tree-dump \" u<= \" \"ifcombine\" } } */\n+/* { dg-final { cleanup-tree-dump \"ifcombine\" } } */"}, {"sha": "cb575022715730e64ab59ce88d1c3e0682990ba2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-9.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-9.c?ref=777d77b37a5a9563bc7bf9a887e282ffd383d982", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-trapping-math -fdump-tree-ifcombine\" } */\n+\n+void f ();\n+enum Sign { NEG=-1, ZERO, POS };\n+\n+static inline enum Sign sign (double x)\n+{\n+  if (x > 0) return POS;\n+  if (x < 0) return NEG;\n+  return ZERO;\n+}\n+void g (double x)\n+{\n+  if (sign (x) == NEG) f();\n+}\n+\n+/* The above should be optimized to x < 0 by ifcombine.\n+   The transformation would also be legal with -ftrapping-math.  */\n+\n+/* { dg-final { scan-tree-dump \"optimizing.* < \" \"ifcombine\" } } */\n+/* { dg-final { cleanup-tree-dump \"ifcombine\" } } */"}, {"sha": "5c61f7f3b01fca65ff034dbf8afde40a6230cbfc", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 86, "deletions": 84, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777d77b37a5a9563bc7bf9a887e282ffd383d982/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=777d77b37a5a9563bc7bf9a887e282ffd383d982", "patch": "@@ -166,12 +166,12 @@ get_name_for_bit_test (tree candidate)\n    Returns true if the pattern matched, false otherwise.  */\n \n static bool\n-recognize_single_bit_test (gimple cond, tree *name, tree *bit)\n+recognize_single_bit_test (gimple cond, tree *name, tree *bit, bool inv)\n {\n   gimple stmt;\n \n   /* Get at the definition of the result of the bit test.  */\n-  if (gimple_cond_code (cond) != NE_EXPR\n+  if (gimple_cond_code (cond) != (inv ? EQ_EXPR : NE_EXPR)\n       || TREE_CODE (gimple_cond_lhs (cond)) != SSA_NAME\n       || !integer_zerop (gimple_cond_rhs (cond)))\n     return false;\n@@ -274,12 +274,12 @@ recognize_single_bit_test (gimple cond, tree *name, tree *bit)\n    Returns true if the pattern matched, false otherwise.  */\n \n static bool\n-recognize_bits_test (gimple cond, tree *name, tree *bits)\n+recognize_bits_test (gimple cond, tree *name, tree *bits, bool inv)\n {\n   gimple stmt;\n \n   /* Get at the definition of the result of the bit test.  */\n-  if (gimple_cond_code (cond) != NE_EXPR\n+  if (gimple_cond_code (cond) != (inv ? EQ_EXPR : NE_EXPR)\n       || TREE_CODE (gimple_cond_lhs (cond)) != SSA_NAME\n       || !integer_zerop (gimple_cond_rhs (cond)))\n     return false;\n@@ -296,14 +296,17 @@ recognize_bits_test (gimple cond, tree *name, tree *bits)\n \n /* If-convert on a and pattern with a common else block.  The inner\n    if is specified by its INNER_COND_BB, the outer by OUTER_COND_BB.\n+   inner_inv, outer_inv and result_inv indicate whether the conditions\n+   are inverted.\n    Returns true if the edges to the common else basic-block were merged.  */\n \n static bool\n-ifcombine_ifandif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n+ifcombine_ifandif (basic_block inner_cond_bb, bool inner_inv,\n+\t\t   basic_block outer_cond_bb, bool outer_inv, bool result_inv)\n {\n   gimple_stmt_iterator gsi;\n   gimple inner_cond, outer_cond;\n-  tree name1, name2, bit1, bit2;\n+  tree name1, name2, bit1, bit2, bits1, bits2;\n \n   inner_cond = last_stmt (inner_cond_bb);\n   if (!inner_cond\n@@ -319,8 +322,8 @@ ifcombine_ifandif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n      that case remove the outer test, merging both else edges,\n      and change the inner one to test for\n      name & (bit1 | bit2) == (bit1 | bit2).  */\n-  if (recognize_single_bit_test (inner_cond, &name1, &bit1)\n-      && recognize_single_bit_test (outer_cond, &name2, &bit2)\n+  if (recognize_single_bit_test (inner_cond, &name1, &bit1, inner_inv)\n+      && recognize_single_bit_test (outer_cond, &name2, &bit2, outer_inv)\n       && name1 == name2)\n     {\n       tree t, t2;\n@@ -337,15 +340,17 @@ ifcombine_ifandif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n       t2 = fold_build2 (BIT_AND_EXPR, TREE_TYPE (name1), name1, t);\n       t2 = force_gimple_operand_gsi (&gsi, t2, true, NULL_TREE,\n \t\t\t\t     true, GSI_SAME_STMT);\n-      t = fold_build2 (EQ_EXPR, boolean_type_node, t2, t);\n+      t = fold_build2 (result_inv ? NE_EXPR : EQ_EXPR,\n+\t\t       boolean_type_node, t2, t);\n       t = canonicalize_cond_expr_cond (t);\n       if (!t)\n \treturn false;\n       gimple_cond_set_condition_from_tree (inner_cond, t);\n       update_stmt (inner_cond);\n \n       /* Leave CFG optimization to cfg_cleanup.  */\n-      gimple_cond_set_condition_from_tree (outer_cond, boolean_true_node);\n+      gimple_cond_set_condition_from_tree (outer_cond,\n+\touter_inv ? boolean_false_node : boolean_true_node);\n       update_stmt (outer_cond);\n \n       if (dump_file)\n@@ -362,68 +367,11 @@ ifcombine_ifandif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n       return true;\n     }\n \n-  /* See if we have two comparisons that we can merge into one.  */\n-  else if (TREE_CODE_CLASS (gimple_cond_code (inner_cond)) == tcc_comparison\n-\t   && TREE_CODE_CLASS (gimple_cond_code (outer_cond)) == tcc_comparison)\n-    {\n-      tree t;\n-\n-      if (!(t = maybe_fold_and_comparisons (gimple_cond_code (inner_cond),\n-\t\t\t\t\t    gimple_cond_lhs (inner_cond),\n-\t\t\t\t\t    gimple_cond_rhs (inner_cond),\n-\t\t\t\t\t    gimple_cond_code (outer_cond),\n-\t\t\t\t\t    gimple_cond_lhs (outer_cond),\n-\t\t\t\t\t    gimple_cond_rhs (outer_cond))))\n-\treturn false;\n-      t = canonicalize_cond_expr_cond (t);\n-      if (!t)\n-\treturn false;\n-      gimple_cond_set_condition_from_tree (inner_cond, t);\n-      update_stmt (inner_cond);\n-\n-      /* Leave CFG optimization to cfg_cleanup.  */\n-      gimple_cond_set_condition_from_tree (outer_cond, boolean_true_node);\n-      update_stmt (outer_cond);\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"optimizing two comparisons to \");\n-\t  print_generic_expr (dump_file, t, 0);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n-/* If-convert on a or pattern with a common then block.  The inner\n-   if is specified by its INNER_COND_BB, the outer by OUTER_COND_BB.\n-   Returns true, if the edges leading to the common then basic-block\n-   were merged.  */\n-\n-static bool\n-ifcombine_iforif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n-{\n-  gimple inner_cond, outer_cond;\n-  tree name1, name2, bits1, bits2;\n-\n-  inner_cond = last_stmt (inner_cond_bb);\n-  if (!inner_cond\n-      || gimple_code (inner_cond) != GIMPLE_COND)\n-    return false;\n-\n-  outer_cond = last_stmt (outer_cond_bb);\n-  if (!outer_cond\n-      || gimple_code (outer_cond) != GIMPLE_COND)\n-    return false;\n-\n   /* See if we have two bit tests of the same name in both tests.\n      In that case remove the outer test and change the inner one to\n      test for name & (bits1 | bits2) != 0.  */\n-  if (recognize_bits_test (inner_cond, &name1, &bits1)\n-      && recognize_bits_test (outer_cond, &name2, &bits2))\n+  else if (recognize_bits_test (inner_cond, &name1, &bits1, !inner_inv)\n+      && recognize_bits_test (outer_cond, &name2, &bits2, !outer_inv))\n     {\n       gimple_stmt_iterator gsi;\n       tree t;\n@@ -482,7 +430,7 @@ ifcombine_iforif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n       t = fold_build2 (BIT_AND_EXPR, TREE_TYPE (name1), name1, t);\n       t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t    true, GSI_SAME_STMT);\n-      t = fold_build2 (NE_EXPR, boolean_type_node, t,\n+      t = fold_build2 (result_inv ? NE_EXPR : EQ_EXPR, boolean_type_node, t,\n \t\t       build_int_cst (TREE_TYPE (t), 0));\n       t = canonicalize_cond_expr_cond (t);\n       if (!t)\n@@ -491,7 +439,8 @@ ifcombine_iforif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n       update_stmt (inner_cond);\n \n       /* Leave CFG optimization to cfg_cleanup.  */\n-      gimple_cond_set_condition_from_tree (outer_cond, boolean_false_node);\n+      gimple_cond_set_condition_from_tree (outer_cond,\n+\touter_inv ? boolean_false_node : boolean_true_node);\n       update_stmt (outer_cond);\n \n       if (dump_file)\n@@ -508,29 +457,45 @@ ifcombine_iforif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n       return true;\n     }\n \n-  /* See if we have two comparisons that we can merge into one.\n-     This happens for C++ operator overloading where for example\n-     GE_EXPR is implemented as GT_EXPR || EQ_EXPR.  */\n-    else if (TREE_CODE_CLASS (gimple_cond_code (inner_cond)) == tcc_comparison\n+  /* See if we have two comparisons that we can merge into one.  */\n+  else if (TREE_CODE_CLASS (gimple_cond_code (inner_cond)) == tcc_comparison\n \t   && TREE_CODE_CLASS (gimple_cond_code (outer_cond)) == tcc_comparison)\n     {\n       tree t;\n+      enum tree_code inner_cond_code = gimple_cond_code (inner_cond);\n+      enum tree_code outer_cond_code = gimple_cond_code (outer_cond);\n+\n+      /* Invert comparisons if necessary (and possible).  */\n+      if (inner_inv)\n+\tinner_cond_code = invert_tree_comparison (inner_cond_code,\n+\t  HONOR_NANS (TYPE_MODE (TREE_TYPE (gimple_cond_lhs (inner_cond)))));\n+      if (inner_cond_code == ERROR_MARK)\n+\treturn false;\n+      if (outer_inv)\n+\touter_cond_code = invert_tree_comparison (outer_cond_code,\n+\t  HONOR_NANS (TYPE_MODE (TREE_TYPE (gimple_cond_lhs (outer_cond)))));\n+      if (outer_cond_code == ERROR_MARK)\n+\treturn false;\n+      /* Don't return false so fast, try maybe_fold_or_comparisons?  */\n \n-      if (!(t = maybe_fold_or_comparisons (gimple_cond_code (inner_cond),\n-\t\t\t\t\t   gimple_cond_lhs (inner_cond),\n-\t\t\t\t\t   gimple_cond_rhs (inner_cond),\n-\t\t\t\t\t   gimple_cond_code (outer_cond),\n-\t\t\t\t\t   gimple_cond_lhs (outer_cond),\n-\t\t\t\t\t   gimple_cond_rhs (outer_cond))))\n+      if (!(t = maybe_fold_and_comparisons (inner_cond_code,\n+\t\t\t\t\t    gimple_cond_lhs (inner_cond),\n+\t\t\t\t\t    gimple_cond_rhs (inner_cond),\n+\t\t\t\t\t    outer_cond_code,\n+\t\t\t\t\t    gimple_cond_lhs (outer_cond),\n+\t\t\t\t\t    gimple_cond_rhs (outer_cond))))\n \treturn false;\n+      if (result_inv)\n+\tt = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (t), t);\n       t = canonicalize_cond_expr_cond (t);\n       if (!t)\n \treturn false;\n       gimple_cond_set_condition_from_tree (inner_cond, t);\n       update_stmt (inner_cond);\n \n       /* Leave CFG optimization to cfg_cleanup.  */\n-      gimple_cond_set_condition_from_tree (outer_cond, boolean_false_node);\n+      gimple_cond_set_condition_from_tree (outer_cond,\n+\touter_inv ? boolean_false_node : boolean_true_node);\n       update_stmt (outer_cond);\n \n       if (dump_file)\n@@ -587,7 +552,26 @@ tree_ssa_ifcombine_bb (basic_block inner_cond_bb)\n \t       <else_bb>\n \t\t ...\n \t   */\n-\t  return ifcombine_ifandif (inner_cond_bb, outer_cond_bb);\n+\t  return ifcombine_ifandif (inner_cond_bb, false, outer_cond_bb, false,\n+\t\t\t\t    false);\n+\t}\n+\n+      /* And a version where the outer condition is negated.  */\n+      if (recognize_if_then_else (outer_cond_bb, &else_bb, &inner_cond_bb)\n+\t  && same_phi_args_p (outer_cond_bb, inner_cond_bb, else_bb)\n+\t  && bb_no_side_effects_p (inner_cond_bb))\n+\t{\n+\t  /* We have\n+\t       <outer_cond_bb>\n+\t\t if (q) goto else_bb; else goto inner_cond_bb;\n+\t       <inner_cond_bb>\n+\t\t if (p) goto ...; else goto else_bb;\n+\t\t ...\n+\t       <else_bb>\n+\t\t ...\n+\t   */\n+\t  return ifcombine_ifandif (inner_cond_bb, false, outer_cond_bb, true,\n+\t\t\t\t    false);\n \t}\n \n       /* The || form is characterized by a common then_bb with the\n@@ -606,7 +590,25 @@ tree_ssa_ifcombine_bb (basic_block inner_cond_bb)\n \t       <then_bb>\n \t\t ...\n \t   */\n-\t  return ifcombine_iforif (inner_cond_bb, outer_cond_bb);\n+\t  return ifcombine_ifandif (inner_cond_bb, true, outer_cond_bb, true,\n+\t\t\t\t    true);\n+\t}\n+\n+      /* And a version where the outer condition is negated.  */\n+      if (recognize_if_then_else (outer_cond_bb, &inner_cond_bb, &then_bb)\n+\t  && same_phi_args_p (outer_cond_bb, inner_cond_bb, then_bb)\n+\t  && bb_no_side_effects_p (inner_cond_bb))\n+\t{\n+\t  /* We have\n+\t       <outer_cond_bb>\n+\t\t if (q) goto inner_cond_bb; else goto then_bb;\n+\t       <inner_cond_bb>\n+\t\t if (q) goto then_bb; else goto ...;\n+\t       <then_bb>\n+\t\t ...\n+\t   */\n+\t  return ifcombine_ifandif (inner_cond_bb, true, outer_cond_bb, false,\n+\t\t\t\t    true);\n \t}\n     }\n "}]}