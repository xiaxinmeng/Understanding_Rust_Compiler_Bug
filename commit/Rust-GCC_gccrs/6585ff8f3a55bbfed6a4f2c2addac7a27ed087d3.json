{"sha": "6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU4NWZmOGYzYTU1YmJmZWQ2YTRmMmMyYWRkYWM3YTI3ZWQwODdkMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:21:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:21:41Z"}, "message": "[07/46] Add vec_info::lookup_stmt\n\nThis patch adds a vec_info replacement for vinfo_for_stmt.  The main\ndifference is that the new routine can cope with arbitrary statements,\nso there's no need to call vect_stmt_in_region_p first.\n\nThe patch only converts calls that are still needed at the end of the\nseries.  Later patches get rid of most other calls to vinfo_for_stmt.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vec_info::lookup_stmt): Declare.\n\t* tree-vectorizer.c (vec_info::lookup_stmt): New function.\n\t* tree-vect-loop.c (vect_determine_vf_for_stmt): Use it instead\n\tof vinfo_for_stmt.\n\t(vect_determine_vectorization_factor, vect_analyze_scalar_cycles_1)\n\t(vect_compute_single_scalar_iteration_cost, vect_analyze_loop_form)\n\t(vect_update_vf_for_slp, vect_analyze_loop_operations)\n\t(vect_is_slp_reduction, vectorizable_induction)\n\t(vect_transform_loop_stmt, vect_transform_loop): Likewise.\n\t* tree-vect-patterns.c (vect_init_pattern_stmt):\n\t(vect_determine_min_output_precision_1, vect_determine_precisions)\n\t(vect_pattern_recog): Likewise.\n\t* tree-vect-stmts.c (vect_analyze_stmt, vect_transform_stmt): Likewise.\n\t* config/powerpcspe/powerpcspe.c (rs6000_density_test): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_density_test): Likewise.\n\t* tree-vect-slp.c (vect_detect_hybrid_slp_stmts): Likewise.\n\t(vect_detect_hybrid_slp_1, vect_detect_hybrid_slp_2)\n\t(vect_detect_hybrid_slp): Likewise.  Change the walk_stmt_info\n\tinfo field from a loop to a loop_vec_info.\n\nFrom-SVN: r263122", "tree": {"sha": "61540cd369e12398dc0d0ced819f84da27426967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61540cd369e12398dc0d0ced819f84da27426967"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4fbeb36361aab0c197c01f6268e442446f2c1fa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fbeb36361aab0c197c01f6268e442446f2c1fa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fbeb36361aab0c197c01f6268e442446f2c1fa8"}], "stats": {"total": 175, "additions": 111, "deletions": 64}, "files": [{"sha": "2f244c42d88b62c16f7971708e4995d4c165bad7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "patch": "@@ -1,3 +1,25 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vec_info::lookup_stmt): Declare.\n+\t* tree-vectorizer.c (vec_info::lookup_stmt): New function.\n+\t* tree-vect-loop.c (vect_determine_vf_for_stmt): Use it instead\n+\tof vinfo_for_stmt.\n+\t(vect_determine_vectorization_factor, vect_analyze_scalar_cycles_1)\n+\t(vect_compute_single_scalar_iteration_cost, vect_analyze_loop_form)\n+\t(vect_update_vf_for_slp, vect_analyze_loop_operations)\n+\t(vect_is_slp_reduction, vectorizable_induction)\n+\t(vect_transform_loop_stmt, vect_transform_loop): Likewise.\n+\t* tree-vect-patterns.c (vect_init_pattern_stmt):\n+\t(vect_determine_min_output_precision_1, vect_determine_precisions)\n+\t(vect_pattern_recog): Likewise.\n+\t* tree-vect-stmts.c (vect_analyze_stmt, vect_transform_stmt): Likewise.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_density_test): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_density_test): Likewise.\n+\t* tree-vect-slp.c (vect_detect_hybrid_slp_stmts): Likewise.\n+\t(vect_detect_hybrid_slp_1, vect_detect_hybrid_slp_2)\n+\t(vect_detect_hybrid_slp): Likewise.  Change the walk_stmt_info\n+\tinfo field from a loop to a loop_vec_info.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (stmt_vec_info): Move typedef earlier in file."}, {"sha": "dea1eab11881ceab73b1de59328fa9b6f83641f2", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "patch": "@@ -6030,6 +6030,7 @@ rs6000_density_test (rs6000_cost_data *data)\n   struct loop *loop = data->loop_info;\n   basic_block *bbs = get_loop_body (loop);\n   int nbbs = loop->num_nodes;\n+  loop_vec_info loop_vinfo = loop_vec_info_for_loop (data->loop_info);\n   int vec_cost = data->cost[vect_body], not_vec_cost = 0;\n   int i, density_pct;\n \n@@ -6041,7 +6042,7 @@ rs6000_density_test (rs6000_cost_data *data)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n-\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (stmt);\n \n \t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n \t      && !STMT_VINFO_IN_PATTERN_P (stmt_info))"}, {"sha": "30403828c46569991fad4fb4e23ed7fda36651fd", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "patch": "@@ -5325,6 +5325,7 @@ rs6000_density_test (rs6000_cost_data *data)\n   struct loop *loop = data->loop_info;\n   basic_block *bbs = get_loop_body (loop);\n   int nbbs = loop->num_nodes;\n+  loop_vec_info loop_vinfo = loop_vec_info_for_loop (data->loop_info);\n   int vec_cost = data->cost[vect_body], not_vec_cost = 0;\n   int i, density_pct;\n \n@@ -5336,7 +5337,7 @@ rs6000_density_test (rs6000_cost_data *data)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n-\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (stmt);\n \n \t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n \t      && !STMT_VINFO_IN_PATTERN_P (stmt_info))"}, {"sha": "50103fc1dc5653e6a6faef66fc3442749a8352bf", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "patch": "@@ -213,6 +213,7 @@ static bool\n vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf,\n \t\t\t    vec<stmt_vec_info > *mask_producers)\n {\n+  vec_info *vinfo = stmt_info->vinfo;\n   if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"==> examining statement: \");\n@@ -231,7 +232,7 @@ vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf,\n       for (gimple_stmt_iterator si = gsi_start (pattern_def_seq);\n \t   !gsi_end_p (si); gsi_next (&si))\n \t{\n-\t  stmt_vec_info def_stmt_info = vinfo_for_stmt (gsi_stmt (si));\n+\t  stmt_vec_info def_stmt_info = vinfo->lookup_stmt (gsi_stmt (si));\n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n@@ -306,7 +307,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t   gsi_next (&si))\n \t{\n \t  phi = si.phi ();\n-\t  stmt_info = vinfo_for_stmt (phi);\n+\t  stmt_info = loop_vinfo->lookup_stmt (phi);\n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"==> examining phi: \");\n@@ -366,7 +367,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n       for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n \t   gsi_next (&si))\n \t{\n-\t  stmt_info = vinfo_for_stmt (gsi_stmt (si));\n+\t  stmt_info = loop_vinfo->lookup_stmt (gsi_stmt (si));\n \t  if (!vect_determine_vf_for_stmt (stmt_info, &vectorization_factor,\n \t\t\t\t\t   &mask_producers))\n \t    return false;\n@@ -487,7 +488,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       gphi *phi = gsi.phi ();\n       tree access_fn = NULL;\n       tree def = PHI_RESULT (phi);\n-      stmt_vec_info stmt_vinfo = vinfo_for_stmt (phi);\n+      stmt_vec_info stmt_vinfo = loop_vinfo->lookup_stmt (phi);\n \n       if (dump_enabled_p ())\n \t{\n@@ -1101,7 +1102,7 @@ vect_compute_single_scalar_iteration_cost (loop_vec_info loop_vinfo)\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n         {\n \t  gimple *stmt = gsi_stmt (si);\n-          stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (stmt);\n \n           if (!is_gimple_assign (stmt) && !is_gimple_call (stmt))\n             continue;\n@@ -1390,10 +1391,14 @@ vect_analyze_loop_form (struct loop *loop, vec_info_shared *shared)\n         }\n     }\n \n-  STMT_VINFO_TYPE (vinfo_for_stmt (loop_cond)) = loop_exit_ctrl_vec_info_type;\n+  stmt_vec_info loop_cond_info = loop_vinfo->lookup_stmt (loop_cond);\n+  STMT_VINFO_TYPE (loop_cond_info) = loop_exit_ctrl_vec_info_type;\n   if (inner_loop_cond)\n-    STMT_VINFO_TYPE (vinfo_for_stmt (inner_loop_cond))\n-      = loop_exit_ctrl_vec_info_type;\n+    {\n+      stmt_vec_info inner_loop_cond_info\n+\t= loop_vinfo->lookup_stmt (inner_loop_cond);\n+      STMT_VINFO_TYPE (inner_loop_cond_info) = loop_exit_ctrl_vec_info_type;\n+    }\n \n   gcc_assert (!loop->aux);\n   loop->aux = loop_vinfo;\n@@ -1432,7 +1437,7 @@ vect_update_vf_for_slp (loop_vec_info loop_vinfo)\n \t   gsi_next (&si))\n \t{\n \t  gimple *stmt = gsi_stmt (si);\n-\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (gsi_stmt (si));\n \t  if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n \t      && STMT_VINFO_RELATED_STMT (stmt_info))\n \t    {\n@@ -1532,7 +1537,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n           gphi *phi = si.phi ();\n           ok = true;\n \n-          stmt_info = vinfo_for_stmt (phi);\n+\t  stmt_info = loop_vinfo->lookup_stmt (phi);\n           if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_NOTE, vect_location, \"examining phi: \");\n@@ -2238,13 +2243,13 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       for (gimple_stmt_iterator si = gsi_start_phis (bb);\n \t   !gsi_end_p (si); gsi_next (&si))\n \t{\n-\t  stmt_vec_info stmt_info = vinfo_for_stmt (gsi_stmt (si));\n+\t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (gsi_stmt (si));\n \t  STMT_SLP_TYPE (stmt_info) = loop_vect;\n \t}\n       for (gimple_stmt_iterator si = gsi_start_bb (bb);\n \t   !gsi_end_p (si); gsi_next (&si))\n \t{\n-\t  stmt_vec_info stmt_info = vinfo_for_stmt (gsi_stmt (si));\n+\t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (gsi_stmt (si));\n \t  STMT_SLP_TYPE (stmt_info) = loop_vect;\n \t  if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n \t    {\n@@ -2253,10 +2258,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t      STMT_SLP_TYPE (stmt_info) = loop_vect;\n \t      for (gimple_stmt_iterator pi = gsi_start (pattern_def_seq);\n \t\t   !gsi_end_p (pi); gsi_next (&pi))\n-\t\t{\n-\t\t  gimple *pstmt = gsi_stmt (pi);\n-\t\t  STMT_SLP_TYPE (vinfo_for_stmt (pstmt)) = loop_vect;\n-\t\t}\n+\t\tSTMT_SLP_TYPE (loop_vinfo->lookup_stmt (gsi_stmt (pi)))\n+\t\t  = loop_vect;\n \t    }\n \t}\n     }\n@@ -2602,7 +2605,7 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n         return false;\n \n       /* Insert USE_STMT into reduction chain.  */\n-      use_stmt_info = vinfo_for_stmt (loop_use_stmt);\n+      use_stmt_info = loop_info->lookup_stmt (loop_use_stmt);\n       if (current_stmt)\n         {\n           current_stmt_info = vinfo_for_stmt (current_stmt);\n@@ -5549,7 +5552,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n         {\n \t  stmt_vec_info epilog_stmt_info = loop_vinfo->add_stmt (epilog_stmt);\n \t  STMT_VINFO_RELATED_STMT (epilog_stmt_info)\n-\t    = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (new_phi));\n+\t    = STMT_VINFO_RELATED_STMT (loop_vinfo->lookup_stmt (new_phi));\n \n           if (!double_reduc)\n             scalar_results.quick_push (new_temp);\n@@ -5653,7 +5656,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n         {\n           if (outer_loop)\n             {\n-              stmt_vec_info exit_phi_vinfo = vinfo_for_stmt (exit_phi);\n+\t      stmt_vec_info exit_phi_vinfo\n+\t\t= loop_vinfo->lookup_stmt (exit_phi);\n               gphi *vect_phi;\n \n               /* FORNOW. Currently not supporting the case that an inner-loop\n@@ -5700,7 +5704,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n                       || gimple_phi_num_args (use_stmt) != 2\n                       || bb->loop_father != outer_loop)\n                     continue;\n-                  use_stmt_vinfo = vinfo_for_stmt (use_stmt);\n+\t\t  use_stmt_vinfo = loop_vinfo->lookup_stmt (use_stmt);\n                   if (!use_stmt_vinfo\n                       || STMT_VINFO_DEF_TYPE (use_stmt_vinfo)\n                           != vect_double_reduction_def)\n@@ -7377,7 +7381,7 @@ vectorizable_induction (gimple *phi,\n \t}\n       if (exit_phi)\n \t{\n-\t  stmt_vec_info exit_phi_vinfo  = vinfo_for_stmt (exit_phi);\n+\t  stmt_vec_info exit_phi_vinfo = loop_vinfo->lookup_stmt (exit_phi);\n \t  if (!(STMT_VINFO_RELEVANT_P (exit_phi_vinfo)\n \t\t&& !STMT_VINFO_LIVE_P (exit_phi_vinfo)))\n \t    {\n@@ -7801,7 +7805,7 @@ vectorizable_induction (gimple *phi,\n         }\n       if (exit_phi)\n \t{\n-\t  stmt_vec_info stmt_vinfo = vinfo_for_stmt (exit_phi);\n+\t  stmt_vec_info stmt_vinfo = loop_vinfo->lookup_stmt (exit_phi);\n \t  /* FORNOW. Currently not supporting the case that an inner-loop induction\n \t     is not used in the outer-loop (i.e. only outside the outer-loop).  */\n \t  gcc_assert (STMT_VINFO_RELEVANT_P (stmt_vinfo)\n@@ -8260,7 +8264,7 @@ vect_transform_loop_stmt (loop_vec_info loop_vinfo, gimple *stmt,\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (stmt);\n   if (!stmt_info)\n     return;\n \n@@ -8463,7 +8467,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n                                \"------>vectorizing phi: \");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n \t    }\n-\t  stmt_info = vinfo_for_stmt (phi);\n+\t  stmt_info = loop_vinfo->lookup_stmt (phi);\n \t  if (!stmt_info)\n \t    continue;\n \n@@ -8504,7 +8508,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t    }\n \t  else\n \t    {\n-\t      stmt_info = vinfo_for_stmt (stmt);\n+\t      stmt_info = loop_vinfo->lookup_stmt (stmt);\n \n \t      /* vector stmts created in the outer-loop during vectorization of\n \t\t stmts in an inner-loop may not have a stmt_info, and do not"}, {"sha": "de0454b31aebd0e717f8fe2390e41318c5375472", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "patch": "@@ -101,7 +101,8 @@ static void\n vect_init_pattern_stmt (gimple *pattern_stmt, stmt_vec_info orig_stmt_info,\n \t\t\ttree vectype)\n {\n-  stmt_vec_info pattern_stmt_info = vinfo_for_stmt (pattern_stmt);\n+  vec_info *vinfo = orig_stmt_info->vinfo;\n+  stmt_vec_info pattern_stmt_info = vinfo->lookup_stmt (pattern_stmt);\n   if (pattern_stmt_info == NULL)\n     pattern_stmt_info = orig_stmt_info->vinfo->add_stmt (pattern_stmt);\n   gimple_set_bb (pattern_stmt, gimple_bb (orig_stmt_info->stmt));\n@@ -4401,6 +4402,7 @@ static bool\n vect_determine_min_output_precision_1 (stmt_vec_info stmt_info, tree lhs)\n {\n   /* Take the maximum precision required by users of the result.  */\n+  vec_info *vinfo = stmt_info->vinfo;\n   unsigned int precision = 0;\n   imm_use_iterator iter;\n   use_operand_p use;\n@@ -4409,10 +4411,8 @@ vect_determine_min_output_precision_1 (stmt_vec_info stmt_info, tree lhs)\n       gimple *use_stmt = USE_STMT (use);\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n-      if (!vect_stmt_in_region_p (stmt_info->vinfo, use_stmt))\n-\treturn false;\n-      stmt_vec_info use_stmt_info = vinfo_for_stmt (use_stmt);\n-      if (!use_stmt_info->min_input_precision)\n+      stmt_vec_info use_stmt_info = vinfo->lookup_stmt (use_stmt);\n+      if (!use_stmt_info || !use_stmt_info->min_input_precision)\n \treturn false;\n       precision = MAX (precision, use_stmt_info->min_input_precision);\n     }\n@@ -4657,7 +4657,8 @@ vect_determine_precisions (vec_info *vinfo)\n \t  basic_block bb = bbs[nbbs - i - 1];\n \t  for (gimple_stmt_iterator si = gsi_last_bb (bb);\n \t       !gsi_end_p (si); gsi_prev (&si))\n-\t    vect_determine_stmt_precisions (vinfo_for_stmt (gsi_stmt (si)));\n+\t    vect_determine_stmt_precisions\n+\t      (vinfo->lookup_stmt (gsi_stmt (si)));\n \t}\n     }\n   else\n@@ -4672,7 +4673,7 @@ vect_determine_precisions (vec_info *vinfo)\n \t  else\n \t    gsi_prev (&si);\n \t  stmt = gsi_stmt (si);\n-\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  stmt_vec_info stmt_info = vinfo->lookup_stmt (stmt);\n \t  if (stmt_info && STMT_VINFO_VECTORIZABLE (stmt_info))\n \t    vect_determine_stmt_precisions (stmt_info);\n \t}\n@@ -4971,7 +4972,7 @@ vect_pattern_recog (vec_info *vinfo)\n \t   gsi_stmt (si) != gsi_stmt (bb_vinfo->region_end); gsi_next (&si))\n \t{\n \t  gimple *stmt = gsi_stmt (si);\n-\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  stmt_vec_info stmt_info = bb_vinfo->lookup_stmt (stmt);\n \t  if (stmt_info && !STMT_VINFO_VECTORIZABLE (stmt_info))\n \t    continue;\n "}, {"sha": "631a076219c7657f8061e91ba43677136feaf38f", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "patch": "@@ -2315,7 +2315,6 @@ vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n   stmt_vec_info use_vinfo, stmt_vinfo = vinfo_for_stmt (stmt);\n   slp_tree child;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   int j;\n \n   /* Propagate hybrid down the SLP tree.  */\n@@ -2340,9 +2339,9 @@ vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n       if (def)\n \tFOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n \t  {\n-\t    if (!flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n+\t    use_vinfo = loop_vinfo->lookup_stmt (use_stmt);\n+\t    if (!use_vinfo)\n \t      continue;\n-\t    use_vinfo = vinfo_for_stmt (use_stmt);\n \t    if (STMT_VINFO_IN_PATTERN_P (use_vinfo)\n \t\t&& STMT_VINFO_RELATED_STMT (use_vinfo))\n \t      use_vinfo = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (use_vinfo));\n@@ -2385,35 +2384,34 @@ static tree\n vect_detect_hybrid_slp_1 (tree *tp, int *, void *data)\n {\n   walk_stmt_info *wi = (walk_stmt_info *)data;\n-  struct loop *loopp = (struct loop *)wi->info;\n+  loop_vec_info loop_vinfo = (loop_vec_info) wi->info;\n \n   if (wi->is_lhs)\n     return NULL_TREE;\n \n+  stmt_vec_info def_stmt_info;\n   if (TREE_CODE (*tp) == SSA_NAME\n-      && !SSA_NAME_IS_DEFAULT_DEF (*tp))\n+      && !SSA_NAME_IS_DEFAULT_DEF (*tp)\n+      && (def_stmt_info = loop_vinfo->lookup_stmt (SSA_NAME_DEF_STMT (*tp)))\n+      && PURE_SLP_STMT (def_stmt_info))\n     {\n-      gimple *def_stmt = SSA_NAME_DEF_STMT (*tp);\n-      if (flow_bb_inside_loop_p (loopp, gimple_bb (def_stmt))\n-\t  && PURE_SLP_STMT (vinfo_for_stmt (def_stmt)))\n+      if (dump_enabled_p ())\n \t{\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location, \"marking hybrid: \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt, 0);\n-\t    }\n-\t  STMT_SLP_TYPE (vinfo_for_stmt (def_stmt)) = hybrid;\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \"marking hybrid: \");\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt_info->stmt, 0);\n \t}\n+      STMT_SLP_TYPE (def_stmt_info) = hybrid;\n     }\n \n   return NULL_TREE;\n }\n \n static tree\n vect_detect_hybrid_slp_2 (gimple_stmt_iterator *gsi, bool *handled,\n-\t\t\t  walk_stmt_info *)\n+\t\t\t  walk_stmt_info *wi)\n {\n-  stmt_vec_info use_vinfo = vinfo_for_stmt (gsi_stmt (*gsi));\n+  loop_vec_info loop_vinfo = (loop_vec_info) wi->info;\n+  stmt_vec_info use_vinfo = loop_vinfo->lookup_stmt (gsi_stmt (*gsi));\n   /* If the stmt is in a SLP instance then this isn't a reason\n      to mark use definitions in other SLP instances as hybrid.  */\n   if (! STMT_SLP_TYPE (use_vinfo)\n@@ -2447,12 +2445,12 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n \t   gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n-\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (stmt);\n \t  if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n \t    {\n \t      walk_stmt_info wi;\n \t      memset (&wi, 0, sizeof (wi));\n-\t      wi.info = LOOP_VINFO_LOOP (loop_vinfo);\n+\t      wi.info = loop_vinfo;\n \t      gimple_stmt_iterator gsi2\n \t\t= gsi_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n \t      walk_gimple_stmt (&gsi2, vect_detect_hybrid_slp_2,"}, {"sha": "2aca038d38c75b18e18b876968737672b8b5623c", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "patch": "@@ -9377,6 +9377,7 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n \t\t   slp_instance node_instance, stmt_vector_for_cost *cost_vec)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  vec_info *vinfo = stmt_info->vinfo;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   enum vect_relevant relevance = STMT_VINFO_RELEVANT (stmt_info);\n   bool ok;\n@@ -9407,8 +9408,10 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n       for (si = gsi_start (pattern_def_seq); !gsi_end_p (si); gsi_next (&si))\n \t{\n \t  gimple *pattern_def_stmt = gsi_stmt (si);\n-\t  if (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_def_stmt))\n-\t      || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_def_stmt)))\n+\t  stmt_vec_info pattern_def_stmt_info\n+\t    = vinfo->lookup_stmt (gsi_stmt (si));\n+\t  if (STMT_VINFO_RELEVANT_P (pattern_def_stmt_info)\n+\t      || STMT_VINFO_LIVE_P (pattern_def_stmt_info))\n \t    {\n \t      /* Analyze def stmt of STMT if it's a pattern stmt.  */\n \t      if (dump_enabled_p ())\n@@ -9605,9 +9608,10 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t     bool *grouped_store, slp_tree slp_node,\n                      slp_instance slp_node_instance)\n {\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  vec_info *vinfo = stmt_info->vinfo;\n   bool is_store = false;\n   gimple *vec_stmt = NULL;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   bool done;\n \n   gcc_assert (slp_node || !PURE_SLP_STMT (stmt_info));\n@@ -9728,7 +9732,6 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n       imm_use_iterator imm_iter;\n       use_operand_p use_p;\n       tree scalar_dest;\n-      gimple *exit_phi;\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n@@ -9743,13 +9746,12 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n         scalar_dest = gimple_assign_lhs (stmt);\n \n       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, scalar_dest)\n-       {\n-         if (!flow_bb_inside_loop_p (innerloop, gimple_bb (USE_STMT (use_p))))\n-           {\n-             exit_phi = USE_STMT (use_p);\n-             STMT_VINFO_VEC_STMT (vinfo_for_stmt (exit_phi)) = vec_stmt;\n-           }\n-       }\n+\tif (!flow_bb_inside_loop_p (innerloop, gimple_bb (USE_STMT (use_p))))\n+\t  {\n+\t    stmt_vec_info exit_phi_info\n+\t      = vinfo->lookup_stmt (USE_STMT (use_p));\n+\t    STMT_VINFO_VEC_STMT (exit_phi_info) = vec_stmt;\n+\t  }\n     }\n \n   /* Handle stmts whose DEF is used outside the loop-nest that is"}, {"sha": "9273f4d067d70b3395d18a2789a3d0ebece058b0", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "patch": "@@ -518,6 +518,23 @@ vec_info::add_stmt (gimple *stmt)\n   return res;\n }\n \n+/* If STMT has an associated stmt_vec_info, return that vec_info, otherwise\n+   return null.  It is safe to call this function on any statement, even if\n+   it might not be part of the vectorizable region.  */\n+\n+stmt_vec_info\n+vec_info::lookup_stmt (gimple *stmt)\n+{\n+  unsigned int uid = gimple_uid (stmt);\n+  if (uid > 0 && uid - 1 < stmt_vec_infos.length ())\n+    {\n+      stmt_vec_info res = stmt_vec_infos[uid - 1];\n+      if (res && res->stmt == stmt)\n+\treturn res;\n+    }\n+  return NULL;\n+}\n+\n /* A helper function to free scev and LOOP niter information, as well as\n    clear loop constraint LOOP_C_FINITE.  */\n "}, {"sha": "3b55a65f97f42b8b0520811b3b6332a2a85d0c19", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "patch": "@@ -218,6 +218,7 @@ struct vec_info {\n   ~vec_info ();\n \n   stmt_vec_info add_stmt (gimple *);\n+  stmt_vec_info lookup_stmt (gimple *);\n \n   /* The type of vectorization.  */\n   vec_kind kind;"}]}