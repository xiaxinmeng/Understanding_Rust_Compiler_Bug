{"sha": "3b40e71b7b49b7ed0d0c92ebb22c56988db59280", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I0MGU3MWI3YjQ5YjdlZDBkMGM5MmViYjIyYzU2OTg4ZGI1OTI4MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-02-26T05:46:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-02-26T05:46:15Z"}, "message": "expr.c (expand_expr): Do not apply distributive law in EXPAND_SUM case.\n\n        * expr.c (expand_expr) [MULT_EXPR]: Do not apply distributive law\n        in EXPAND_SUM case.  Use host_integerp/tree_low_cst.\n\nFrom-SVN: r50033", "tree": {"sha": "b0eaa6c8b2c0bcf71599a0f3f06b5957082ec36b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0eaa6c8b2c0bcf71599a0f3f06b5957082ec36b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b40e71b7b49b7ed0d0c92ebb22c56988db59280", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b40e71b7b49b7ed0d0c92ebb22c56988db59280", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b40e71b7b49b7ed0d0c92ebb22c56988db59280", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b40e71b7b49b7ed0d0c92ebb22c56988db59280/comments", "author": null, "committer": null, "parents": [{"sha": "1bc59af523f6fa2eefc7601bde3d1b15218e2f40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bc59af523f6fa2eefc7601bde3d1b15218e2f40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bc59af523f6fa2eefc7601bde3d1b15218e2f40"}], "stats": {"total": 30, "additions": 16, "deletions": 14}, "files": [{"sha": "e0f6612b37c1c9e635769ba2760a1216046f965b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b40e71b7b49b7ed0d0c92ebb22c56988db59280/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b40e71b7b49b7ed0d0c92ebb22c56988db59280/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b40e71b7b49b7ed0d0c92ebb22c56988db59280", "patch": "@@ -1,3 +1,8 @@\n+2002-02-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.c (expand_expr) [MULT_EXPR]: Do not apply distributive law\n+\tin EXPAND_SUM case.  Use host_integerp/tree_low_cst.\n+\n 2002-02-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/5755"}, {"sha": "7d0f12a864a43e87dc8bcfa0b6d2d582d446a8f1", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b40e71b7b49b7ed0d0c92ebb22c56988db59280/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b40e71b7b49b7ed0d0c92ebb22c56988db59280/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3b40e71b7b49b7ed0d0c92ebb22c56988db59280", "patch": "@@ -7610,23 +7610,20 @@ expand_expr (exp, target, tmode, modifier)\n \t indexed address, for machines that support that.  */\n \n       if (modifier == EXPAND_SUM && mode == ptr_mode\n-\t  && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n-\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+\t  && host_integerp (TREE_OPERAND (exp, 1), 0))\n \t{\n \t  op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode,\n \t\t\t     EXPAND_SUM);\n \n-\t  /* Apply distributive law if OP0 is x+c.  */\n-\t  if (GET_CODE (op0) == PLUS\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT)\n-\t    return\n-\t      gen_rtx_PLUS\n-\t\t(mode,\n-\t\t gen_rtx_MULT\n-\t\t (mode, XEXP (op0, 0),\n-\t\t  GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)))),\n-\t\t GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))\n-\t\t\t  * INTVAL (XEXP (op0, 1))));\n+\t  /* If we knew for certain that this is arithmetic for an array\n+\t     reference, and we knew the bounds of the array, then we could\n+\t     apply the distributive law across (PLUS X C) for constant C.\n+\t     Without such knowledge, we risk overflowing the computation\n+\t     when both X and C are large, but X+C isn't.  */\n+\t  /* ??? Could perhaps special-case EXP being unsigned and C being\n+\t     positive.  In that case we are certain that X+C is no smaller\n+\t     than X and so the transformed expression will overflow iff the\n+\t     original would have.  */\n \n \t  if (GET_CODE (op0) != REG)\n \t    op0 = force_operand (op0, NULL_RTX);\n@@ -7635,7 +7632,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t  return\n \t    gen_rtx_MULT (mode, op0,\n-\t\t\t  GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))));\n+\t\t\t  GEN_INT (tree_low_cst (TREE_OPERAND (exp, 1), 0)));\n \t}\n \n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))"}]}