{"sha": "6bdfada421e21cbeb4cfb29b2566ac6075be463a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJkZmFkYTQyMWUyMWNiZWI0Y2ZiMjliMjU2NmFjNjA3NWJlNDYzYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-06-19T00:38:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-06-19T00:38:44Z"}, "message": "tree.c (cp_expr_location): New.\n\n\t* tree.c (cp_expr_location): New.\n\n\t* cp-tree.h (cp_expr_loc_or_loc): New.\n\t* call.c, cvt.c, constexpr.c, constraint.cc, cp-gimplify.c, decl.c,\n\terror.c, init.c, lex.c, parser.c, pt.c, semantics.c, typeck.c,\n\ttypeck2.c: Use it instead of EXPR_LOC_OR_LOC.\n\nFrom-SVN: r261728", "tree": {"sha": "74cc71c125d772adebe67c6d5bb27461e03218ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74cc71c125d772adebe67c6d5bb27461e03218ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bdfada421e21cbeb4cfb29b2566ac6075be463a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bdfada421e21cbeb4cfb29b2566ac6075be463a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bdfada421e21cbeb4cfb29b2566ac6075be463a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bdfada421e21cbeb4cfb29b2566ac6075be463a/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c0e11c6afb448b0a9423b62c86c207945a0f5335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e11c6afb448b0a9423b62c86c207945a0f5335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e11c6afb448b0a9423b62c86c207945a0f5335"}], "stats": {"total": 196, "additions": 117, "deletions": 79}, "files": [{"sha": "7c903c553378033fc368800bbd470b39f64a9e42", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -1,5 +1,11 @@\n 2018-06-18  Jason Merrill  <jason@redhat.com>\n \n+\t* tree.c (cp_expr_location): New.\n+\t* cp-tree.h (cp_expr_loc_or_loc): New.\n+\t* call.c, cvt.c, constexpr.c, constraint.cc, cp-gimplify.c, decl.c,\n+\terror.c, init.c, lex.c, parser.c, pt.c, semantics.c, typeck.c,\n+\ttypeck2.c: Use it instead of EXPR_LOC_OR_LOC.\n+\n \t* parser.c (cp_parser_lambda_expression): Use a range for\n \tLAMBDA_EXPR_LOCATION.\n "}, {"sha": "e417590e97d5b8954bb04dd6ae5f2133d4b6ddf1", "filename": "gcc/cp/call.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -4025,7 +4025,7 @@ build_converted_constant_expr (tree type, tree expr, tsubst_flags_t complain)\n   conversion *conv;\n   void *p;\n   tree t;\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n \n   if (error_operand_p (expr))\n     return error_mark_node;\n@@ -5003,12 +5003,12 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n           if (complain & tf_error)\n             {\n               if (VOID_TYPE_P (arg2_type))\n-                error_at (EXPR_LOC_OR_LOC (arg3, loc),\n+                error_at (cp_expr_loc_or_loc (arg3, loc),\n \t\t\t  \"second operand to the conditional operator \"\n \t\t\t  \"is of type %<void%>, but the third operand is \"\n \t\t\t  \"neither a throw-expression nor of type %<void%>\");\n               else\n-                error_at (EXPR_LOC_OR_LOC (arg2, loc),\n+                error_at (cp_expr_loc_or_loc (arg2, loc),\n \t\t\t  \"third operand to the conditional operator \"\n \t\t\t  \"is of type %<void%>, but the second operand is \"\n \t\t\t  \"neither a throw-expression nor of type %<void%>\");\n@@ -6622,7 +6622,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n   tree totype = convs->type;\n   diagnostic_t diag_kind;\n   int flags;\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n \n   if (convs->bad_p && !(complain & tf_error))\n     return error_mark_node;\n@@ -7127,7 +7127,7 @@ tree\n convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n {\n   tree arg_type;\n-  location_t loc = EXPR_LOC_OR_LOC (arg, input_location);\n+  location_t loc = cp_expr_loc_or_loc (arg, input_location);\n \n   /* [expr.call]\n \n@@ -7434,7 +7434,7 @@ convert_for_arg_passing (tree type, tree val, tsubst_flags_t complain)\n \t\t     \"argument of function call might be a candidate \"\n \t\t     \"for a format attribute\");\n \t}\n-      maybe_warn_parm_abi (type, EXPR_LOC_OR_LOC (val, input_location));\n+      maybe_warn_parm_abi (type, cp_expr_loc_or_loc (val, input_location));\n     }\n   return val;\n }\n@@ -8228,7 +8228,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       tree type = TREE_TYPE (to);\n       tree as_base = CLASSTYPE_AS_BASE (type);\n       tree arg = argarray[1];\n-      location_t loc = EXPR_LOC_OR_LOC (arg, input_location);\n+      location_t loc = cp_expr_loc_or_loc (arg, input_location);\n \n       if (is_really_empty_class (type))\n \t{\n@@ -8788,7 +8788,7 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n   tree fndecl;\n \n   /* Remember roughly where this call is.  */\n-  location_t loc = EXPR_LOC_OR_LOC (fn, input_location);\n+  location_t loc = cp_expr_loc_or_loc (fn, input_location);\n   fn = build_call_a (fn, nargs, argarray);\n   SET_EXPR_LOCATION (fn, loc);\n \n@@ -10679,7 +10679,7 @@ perform_implicit_conversion_flags (tree type, tree expr,\n {\n   conversion *conv;\n   void *p;\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n \n   if (TYPE_REF_P (type))\n     expr = mark_lvalue_use (expr);\n@@ -11013,7 +11013,7 @@ initialize_reference (tree type, tree expr,\n {\n   conversion *conv;\n   void *p;\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n \n   if (type == error_mark_node || error_operand_p (expr))\n     return error_mark_node;"}, {"sha": "0e6f3570cfa8bace9266c0f590de3d78e97d1238", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -1412,7 +1412,7 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n \n     default:\n       if (!ctx->quiet)\n-\terror_at (EXPR_LOC_OR_LOC (t, input_location),\n+\terror_at (cp_expr_loc_or_loc (t, input_location),\n \t\t  \"call to internal function %qE\", t);\n       *non_constant_p = true;\n       return t;\n@@ -1427,7 +1427,7 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n \n   if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n     {\n-      location_t loc = EXPR_LOC_OR_LOC (t, input_location);\n+      location_t loc = cp_expr_loc_or_loc (t, input_location);\n       tree type = TREE_TYPE (TREE_TYPE (t));\n       tree result = fold_binary_loc (loc, opcode, type,\n \t\t\t\t     fold_convert_loc (loc, type, arg0),\n@@ -1469,7 +1469,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t  bool lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n-  location_t loc = EXPR_LOC_OR_LOC (t, input_location);\n+  location_t loc = cp_expr_loc_or_loc (t, input_location);\n   tree fun = get_function_named_in_call (t);\n   constexpr_call new_call = { NULL, NULL, NULL, 0 };\n   bool depth_ok;\n@@ -3981,7 +3981,7 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n       if (++count >= constexpr_loop_limit)\n \t{\n \t  if (!ctx->quiet)\n-\t    error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t    error_at (cp_expr_loc_or_loc (t, input_location),\n \t\t      \"%<constexpr%> loop iteration count exceeds limit of %d \"\n \t\t      \"(use -fconstexpr-loop-limit= to increase the limit)\",\n \t\t      constexpr_loop_limit);\n@@ -4597,7 +4597,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       if (REINTERPRET_CAST_P (t))\n \t{\n \t  if (!ctx->quiet)\n-\t    error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t    error_at (cp_expr_loc_or_loc (t, input_location),\n \t\t      \"a reinterpret_cast is not a constant expression\");\n \t  *non_constant_p = true;\n \t  return t;\n@@ -4634,7 +4634,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\tif (TYPE_REF_P (type))\n \t\t  {\n \t\t    if (!ctx->quiet)\n-\t\t      error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t      error_at (cp_expr_loc_or_loc (t, input_location),\n \t\t\t\t\"dereferencing a null pointer\");\n \t\t    *non_constant_p = true;\n \t\t    return t;\n@@ -4646,7 +4646,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t    if (!can_convert (type, from, tf_none))\n \t\t      {\n \t\t\tif (!ctx->quiet)\n-\t\t\t  error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t\t  error_at (cp_expr_loc_or_loc (t, input_location),\n \t\t\t\t    \"conversion of %qT null pointer to %qT \"\n \t\t\t\t    \"is not a constant expression\",\n \t\t\t\t    from, type);\n@@ -4661,7 +4661,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t     reinterpret_cast<void*>(sizeof 0)\n \t\t*/\n \t\tif (!ctx->quiet)\n-\t\t  error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t  error_at (cp_expr_loc_or_loc (t, input_location),\n \t\t\t    \"%<reinterpret_cast<%T>(%E)%> is not \"\n \t\t\t    \"a constant expression\",\n \t\t\t    type, op);\n@@ -4726,7 +4726,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case BASELINK:\n     case OFFSET_REF:\n       if (!ctx->quiet)\n-        error_at (EXPR_LOC_OR_LOC (t, input_location),\n+        error_at (cp_expr_loc_or_loc (t, input_location),\n \t\t  \"expression %qE is not a constant expression\", t);\n       *non_constant_p = true;\n       break;\n@@ -5327,7 +5327,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n     return false;\n   if (t == NULL_TREE)\n     return true;\n-  location_t loc = EXPR_LOC_OR_LOC (t, input_location);\n+  location_t loc = cp_expr_loc_or_loc (t, input_location);\n   if (TREE_THIS_VOLATILE (t) && !DECL_P (t))\n     {\n       if (flags & tf_error)"}, {"sha": "9f9fb52356e53f33053a4355f294b4bde03559ae", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -804,7 +804,7 @@ check_for_logical_overloads (tree t)\n \n   if (DECL_OVERLOADED_OPERATOR_P (fn))\n     {\n-      location_t loc = EXPR_LOC_OR_LOC (t, input_location);\n+      location_t loc = cp_expr_loc_or_loc (t, input_location);\n       error_at (loc, \"constraint %qE, uses overloaded operator\", t);\n       return true;\n     }\n@@ -2012,7 +2012,7 @@ satisfy_predicate_constraint (tree t, tree args,\n   tree type = cv_unqualified (TREE_TYPE (expr));\n   if (!same_type_p (type, boolean_type_node))\n     {\n-      error_at (EXPR_LOC_OR_LOC (expr, input_location),\n+      error_at (cp_expr_loc_or_loc (expr, input_location),\n                 \"constraint %qE does not have type %qT\",\n                 expr, boolean_type_node);\n       return boolean_false_node;"}, {"sha": "16831fc710027dc86fb8548e562c27c0b309847b", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -217,7 +217,7 @@ genericize_cp_loop (tree *stmt_p, location_t start_locus, tree cond, tree body,\n     {\n       /* If COND is constant, don't bother building an exit.  If it's false,\n \t we won't build a loop.  If it's true, any exits are in the body.  */\n-      location_t cloc = EXPR_LOC_OR_LOC (cond, start_locus);\n+      location_t cloc = cp_expr_loc_or_loc (cond, start_locus);\n       exit = build1_loc (cloc, GOTO_EXPR, void_type_node,\n \t\t\t get_bc_label (bc_break));\n       exit = fold_build3_loc (cloc, COND_EXPR, void_type_node, cond,\n@@ -579,7 +579,7 @@ int\n cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n {\n   int saved_stmts_are_full_exprs_p = 0;\n-  location_t loc = EXPR_LOC_OR_LOC (*expr_p, input_location);\n+  location_t loc = cp_expr_loc_or_loc (*expr_p, input_location);\n   enum tree_code code = TREE_CODE (*expr_p);\n   enum gimplify_status ret;\n "}, {"sha": "ba6cc1a054c9bf6e481418f6e9a055d408de79b4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -47,14 +47,16 @@ c-common.h, not after.\n    but not all node kinds do (e.g. constants, and references to\n    params, locals, etc), so we stash a copy here.  */\n \n+extern location_t cp_expr_location\t\t(const_tree);\n+\n class cp_expr\n {\n public:\n   cp_expr () :\n     m_value (NULL), m_loc (UNKNOWN_LOCATION) {}\n \n   cp_expr (tree value) :\n-    m_value (value), m_loc (EXPR_LOCATION (m_value)) {}\n+    m_value (value), m_loc (cp_expr_location (m_value)) {}\n \n   cp_expr (tree value, location_t loc):\n     m_value (value), m_loc (loc) {}\n@@ -7317,11 +7319,21 @@ extern tree finish_binary_fold_expr          (tree, tree, int);\n extern void require_complete_eh_spec_types\t(tree, tree);\n extern void cxx_incomplete_type_diagnostic\t(location_t, const_tree,\n \t\t\t\t\t\t const_tree, diagnostic_t);\n+\n+inline location_t\n+cp_expr_loc_or_loc (const_tree t, location_t or_loc)\n+{\n+  location_t loc = cp_expr_location (t);\n+  if (loc == UNKNOWN_LOCATION)\n+    loc = or_loc;\n+  return loc;\n+}\n+\n inline void\n cxx_incomplete_type_diagnostic (const_tree value, const_tree type,\n \t\t\t\tdiagnostic_t diag_kind)\n {\n-  cxx_incomplete_type_diagnostic (EXPR_LOC_OR_LOC (value, input_location),\n+  cxx_incomplete_type_diagnostic (cp_expr_loc_or_loc (value, input_location),\n \t\t\t\t  value, type, diag_kind);\n }\n "}, {"sha": "da98414855626ba6b5f4dc78b8da431f109cc9e5", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -77,7 +77,7 @@ cp_convert_to_pointer (tree type, tree expr, bool dofold,\n   tree intype = TREE_TYPE (expr);\n   enum tree_code form;\n   tree rval;\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n \n   if (intype == error_mark_node)\n     return error_mark_node;\n@@ -419,7 +419,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n   tree rval = NULL_TREE;\n   tree rval_as_conversion = NULL_TREE;\n   bool can_convert_intype_to_type;\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n \n   if (TREE_CODE (type) == FUNCTION_TYPE\n       && TREE_TYPE (expr) == unknown_type_node)\n@@ -667,7 +667,7 @@ cp_convert_and_check (tree type, tree expr, tsubst_flags_t complain)\n       folded_result = fold_simple (folded_result);\n       if (!TREE_OVERFLOW_P (folded)\n \t  && folded_result != error_mark_node)\n-\twarnings_for_convert_and_check (EXPR_LOC_OR_LOC (expr, input_location),\n+\twarnings_for_convert_and_check (cp_expr_loc_or_loc (expr, input_location),\n \t\t\t\t\ttype, folded, folded_result);\n     }\n \n@@ -686,7 +686,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n   enum tree_code code = TREE_CODE (type);\n   const char *invalid_conv_diag;\n   tree e1;\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n   bool dofold = (convtype & CONV_FOLD);\n \n   if (error_operand_p (e) || type == error_mark_node)\n@@ -1001,7 +1001,7 @@ maybe_warn_nodiscard (tree expr, impl_conv_void implicit)\n   tree call = expr;\n   if (TREE_CODE (expr) == TARGET_EXPR)\n     call = TARGET_EXPR_INITIAL (expr);\n-  location_t loc = EXPR_LOC_OR_LOC (call, input_location);\n+  location_t loc = cp_expr_loc_or_loc (call, input_location);\n   tree callee = cp_get_callee (call);\n   if (!callee)\n     return;\n@@ -1078,7 +1078,7 @@ maybe_warn_nodiscard (tree expr, impl_conv_void implicit)\n tree\n convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n {\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n \n   if (expr == error_mark_node\n       || TREE_TYPE (expr) == error_mark_node)"}, {"sha": "90714cce0626d2f924777a292d7712ee2b5b213b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -3480,7 +3480,7 @@ pop_switch (void)\n   location_t switch_location;\n \n   /* Emit warnings as needed.  */\n-  switch_location = EXPR_LOC_OR_LOC (cs->switch_stmt, input_location);\n+  switch_location = cp_expr_loc_or_loc (cs->switch_stmt, input_location);\n   const bool bool_cond_p\n     = (SWITCH_STMT_TYPE (cs->switch_stmt)\n        && TREE_CODE (SWITCH_STMT_TYPE (cs->switch_stmt)) == BOOLEAN_TYPE);\n@@ -5410,7 +5410,7 @@ maybe_deduce_size_from_array_init (tree decl, tree init)\n \t\t\t\t\t    do_default);\n \t  if (failure == 1)\n \t    {\n-\t      error_at (EXPR_LOC_OR_LOC (initializer,\n+\t      error_at (cp_expr_loc_or_loc (initializer,\n \t\t\t\t\t DECL_SOURCE_LOCATION (decl)),\n \t\t\t\"initializer fails to determine size of %qD\", decl);\n \t    }\n@@ -6266,7 +6266,7 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n \t    }\n \t  else if (init_len != 1 && TREE_CODE (type) != COMPLEX_TYPE)\n \t    {\n-\t      error_at (EXPR_LOC_OR_LOC (init, DECL_SOURCE_LOCATION (decl)),\n+\t      error_at (cp_expr_loc_or_loc (init, DECL_SOURCE_LOCATION (decl)),\n \t\t\t\"scalar object %qD requires one element in \"\n \t\t\t\"initializer\", decl);\n \t      TREE_TYPE (decl) = error_mark_node;\n@@ -6311,7 +6311,7 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n \t    {\n \t      /* Don't reshape if the class has constructors.  */\n \t      if (cxx_dialect == cxx98)\n-\t\terror_at (EXPR_LOC_OR_LOC (init, DECL_SOURCE_LOCATION (decl)),\n+\t\terror_at (cp_expr_loc_or_loc (init, DECL_SOURCE_LOCATION (decl)),\n \t\t\t  \"in C++98 %qD must be initialized by \"\n \t\t\t  \"constructor, not by %<{...}%>\",\n \t\t\t  decl);\n@@ -6407,7 +6407,7 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n \t      && DECL_INITIAL (decl)\n \t      && TREE_CODE (DECL_INITIAL (decl)) == STRING_CST\n \t      && PAREN_STRING_LITERAL_P (DECL_INITIAL (decl)))\n-\t    warning_at (EXPR_LOC_OR_LOC (DECL_INITIAL (decl),\n+\t    warning_at (cp_expr_loc_or_loc (DECL_INITIAL (decl),\n \t\t\t\t\t DECL_SOURCE_LOCATION (decl)),\n \t\t\t0, \"array %qD initialized by parenthesized \"\n \t\t\t\"string literal %qE\","}, {"sha": "6a261132afb95a43ea0085e566eec332d80cd3cb", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -3031,7 +3031,7 @@ location_of (tree t)\n     return DECL_SOURCE_LOCATION (t);\n   if (TREE_CODE (t) == DEFAULT_ARG)\n     return defarg_location (t);\n-  return EXPR_LOC_OR_LOC (t, input_location);\n+  return cp_expr_loc_or_loc (t, input_location);\n }\n \n /* Now the interfaces from error et al to dump_type et al. Each takes an"}, {"sha": "57697d67035481d22edd01f5c41f576293dcd73e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -553,7 +553,7 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)\n     {\n       init = DECL_INITIAL (DECL_TI_TEMPLATE (member));\n       location_t expr_loc\n-\t= EXPR_LOC_OR_LOC (init, DECL_SOURCE_LOCATION (member));\n+\t= cp_expr_loc_or_loc (init, DECL_SOURCE_LOCATION (member));\n       tree *slot;\n       if (TREE_CODE (init) == DEFAULT_ARG)\n \t/* Unparsed.  */;\n@@ -742,7 +742,7 @@ maybe_warn_list_ctor (tree member, tree init)\n   if (!begin)\n     return;\n \n-  location_t loc = EXPR_LOC_OR_LOC (init, input_location);\n+  location_t loc = cp_expr_loc_or_loc (init, input_location);\n   warning_at (loc, OPT_Winit_list_lifetime,\n \t     \"initializing %qD from %qE does not extend the lifetime \"\n \t     \"of the underlying array\", member, begin);\n@@ -1740,7 +1740,7 @@ build_aggr_init (tree exp, tree init, int flags, tsubst_flags_t complain)\n     return error_mark_node;\n \n   location_t init_loc = (init\n-\t\t\t ? EXPR_LOC_OR_LOC (init, input_location)\n+\t\t\t ? cp_expr_loc_or_loc (init, input_location)\n \t\t\t : location_of (exp));\n \n   TREE_READONLY (exp) = 0;\n@@ -2571,7 +2571,7 @@ find_flexarray_init (tree t, tree init)\n static void\n warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n {\n-  location_t loc = EXPR_LOC_OR_LOC (oper, input_location);\n+  location_t loc = cp_expr_loc_or_loc (oper, input_location);\n \n   /* The number of bytes to add to or subtract from the size of the provided\n      buffer based on an offset into an array or an array element reference.\n@@ -2963,7 +2963,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t{\n \t  if (complain & tf_error)\n \t    {\n-\t      error_at (EXPR_LOC_OR_LOC (inner_nelts, input_location),\n+\t      error_at (cp_expr_loc_or_loc (inner_nelts, input_location),\n \t\t\t\"array size in new-expression must be constant\");\n \t      cxx_constant_value(inner_nelts);\n \t    }\n@@ -2992,7 +2992,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n     {\n       if (complain & tf_warning_or_error)\n \t{\n-\t  pedwarn (EXPR_LOC_OR_LOC (outer_nelts, input_location), OPT_Wvla,\n+\t  pedwarn (cp_expr_loc_or_loc (outer_nelts, input_location), OPT_Wvla,\n \t\t   typedef_variant_p (orig_type)\n \t\t   ? G_(\"non-constant array new length must be specified \"\n \t\t\t\"directly, not by typedef\")\n@@ -4109,7 +4109,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n   tree obase = base;\n   bool xvalue = false;\n   bool errors = false;\n-  location_t loc = (init ? EXPR_LOC_OR_LOC (init, input_location)\n+  location_t loc = (init ? cp_expr_loc_or_loc (init, input_location)\n \t\t    : location_of (base));\n \n   if (TREE_CODE (atype) == ARRAY_TYPE && TYPE_DOMAIN (atype))"}, {"sha": "c47ae1dd5a18f3e7ed76cbe32081486a96c939e7", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -491,7 +491,7 @@ tree\n unqualified_name_lookup_error (tree name, location_t loc)\n {\n   if (loc == UNKNOWN_LOCATION)\n-    loc = EXPR_LOC_OR_LOC (name, input_location);\n+    loc = cp_expr_loc_or_loc (name, input_location);\n \n   if (IDENTIFIER_ANY_OP_P (name))\n     error_at (loc, \"%qD not defined\", name);"}, {"sha": "c6206fc353ce287506a99c0c5c75f7350c9ec963", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -22350,7 +22350,7 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n \t  {\n \t    if (IDENTIFIER_MARKED (designator))\n \t      {\n-\t\terror_at (EXPR_LOC_OR_LOC (val, input_location),\n+\t\terror_at (cp_expr_loc_or_loc (val, input_location),\n \t\t\t  \"%<.%s%> designator used multiple times in \"\n \t\t\t  \"the same initializer list\",\n \t\t\t  IDENTIFIER_POINTER (designator));\n@@ -34812,7 +34812,7 @@ cp_parser_omp_for_cond (cp_parser *parser, tree decl)\n \t  || CLASS_TYPE_P (TREE_TYPE (decl))))\n     return cond;\n \n-  return build_x_binary_op (EXPR_LOC_OR_LOC (cond, input_location),\n+  return build_x_binary_op (cp_expr_loc_or_loc (cond, input_location),\n \t\t\t    TREE_CODE (cond),\n \t\t\t    TREE_OPERAND (cond, 0), ERROR_MARK,\n \t\t\t    TREE_OPERAND (cond, 1), ERROR_MARK,"}, {"sha": "1ecc6fb373db092f1e04b48bfd2fec2062150436", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -4058,7 +4058,7 @@ check_for_bare_parameter_packs (tree t, location_t loc /* = UNKNOWN_LOCATION */)\n   if (parameter_packs) \n     {\n       if (loc == UNKNOWN_LOCATION)\n-\tloc = EXPR_LOC_OR_LOC (t, input_location);\n+\tloc = cp_expr_loc_or_loc (t, input_location);\n       error_at (loc, \"parameter packs not expanded with %<...%>:\");\n       while (parameter_packs)\n         {\n@@ -6297,7 +6297,7 @@ static bool\n check_valid_ptrmem_cst_expr (tree type, tree expr,\n \t\t\t     tsubst_flags_t complain)\n {\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n   tree orig_expr = expr;\n   STRIP_NOPS (expr);\n   if (null_ptr_cst_p (expr))\n@@ -6516,7 +6516,7 @@ unify_arg_conversion (bool explain_p, tree to_type,\n \t\t      tree from_type, tree arg)\n {\n   if (explain_p)\n-    inform (EXPR_LOC_OR_LOC (arg, input_location),\n+    inform (cp_expr_loc_or_loc (arg, input_location),\n \t    \"  cannot convert %qE (type %qT) to type %qT\",\n \t    arg, from_type, to_type);\n   return unify_invalid (explain_p);\n@@ -6593,7 +6593,7 @@ static tree\n convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n {\n   tree expr_type;\n-  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n   tree orig_expr = expr;\n \n   /* Detect immediately string literals as invalid non-type argument.\n@@ -16580,8 +16580,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n     return t;\n \n   loc = input_location;\n-  if (EXPR_HAS_LOCATION (t))\n-    input_location = EXPR_LOCATION (t);\n+  if (location_t eloc = cp_expr_location (t))\n+    input_location = eloc;\n   if (STATEMENT_CODE_P (TREE_CODE (t)))\n     current_stmt_tree ()->stmts_are_full_exprs_p = STMT_IS_FULL_EXPR_P (t);\n \n@@ -17693,8 +17693,8 @@ tsubst_copy_and_build (tree t,\n     return t;\n \n   loc = input_location;\n-  if (EXPR_HAS_LOCATION (t))\n-    input_location = EXPR_LOCATION (t);\n+  if (location_t eloc = cp_expr_location (t))\n+    input_location = eloc;\n \n   /* N3276 decltype magic only applies to calls at the top level or on the\n      right side of a comma.  */\n@@ -18351,10 +18351,10 @@ tsubst_copy_and_build (tree t,\n \n \t\t    bool diag = true;\n \t\t    if (in_lambda)\n-\t\t      error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t      error_at (cp_expr_loc_or_loc (t, input_location),\n \t\t\t\tmsg, function);\n \t\t    else\n-\t\t      diag = permerror (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t      diag = permerror (cp_expr_loc_or_loc (t, input_location),\n \t\t\t\t\tmsg, function);\n \t\t    if (diag)\n \t\t      {\n@@ -18369,7 +18369,7 @@ tsubst_copy_and_build (tree t,\n \t\t\t  /* Can't say anything more.  */;\n \t\t\telse if (DECL_CLASS_SCOPE_P (fn))\n \t\t\t  {\n-\t\t\t    location_t loc = EXPR_LOC_OR_LOC (t,\n+\t\t\t    location_t loc = cp_expr_loc_or_loc (t,\n \t\t\t\t\t\t\t      input_location);\n \t\t\t    inform (loc,\n \t\t\t\t    \"declarations in dependent base %qT are \"\n@@ -18425,13 +18425,13 @@ tsubst_copy_and_build (tree t,\n \t      gcc_assert (nargs == 1);\n \t      if (vec_safe_length (call_args) != 1)\n \t\t{\n-\t\t  error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t  error_at (cp_expr_loc_or_loc (t, input_location),\n \t\t\t    \"wrong number of arguments to \"\n \t\t\t    \"%<__builtin_launder%>\");\n \t\t  ret = error_mark_node;\n \t\t}\n \t      else\n-\t\tret = finish_builtin_launder (EXPR_LOC_OR_LOC (t,\n+\t\tret = finish_builtin_launder (cp_expr_loc_or_loc (t,\n \t\t\t\t\t\t\t       input_location),\n \t\t\t\t\t      (*call_args)[0], complain);\n \t      break;\n@@ -23590,7 +23590,7 @@ maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)\n       else if (!(added = !fns->add (fn)))\n \t{\n \t  /* If hash_set::add returns true, the element was already there.  */\n-\t  location_t loc = EXPR_LOC_OR_LOC (DEFERRED_NOEXCEPT_PATTERN (noex),\n+\t  location_t loc = cp_expr_loc_or_loc (DEFERRED_NOEXCEPT_PATTERN (noex),\n \t\t\t\t\t    DECL_SOURCE_LOCATION (fn));\n \t  error_at (loc,\n \t\t    \"exception specification of %qD depends on itself\",\n@@ -25780,7 +25780,7 @@ resolve_typename_type (tree type, bool only_current_p)\n \n \t     [temp.names]: In a qualified-id of a declarator-id, the keyword\n \t     template shall not appear at the top level.  */\n-\t  pedwarn (EXPR_LOC_OR_LOC (fullname, input_location), OPT_Wpedantic,\n+\t  pedwarn (cp_expr_loc_or_loc (fullname, input_location), OPT_Wpedantic,\n \t\t   \"keyword %<template%> not allowed in declarator-id\");\n \t  tmpl = decl;\n \t}"}, {"sha": "2356940a6bbd943c510e8491321b8b8cc2f7a936", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -658,7 +658,7 @@ maybe_convert_cond (tree cond)\n       && !TREE_NO_WARNING (cond)\n       && warn_parentheses)\n     {\n-      warning_at (EXPR_LOC_OR_LOC (cond, input_location), OPT_Wparentheses,\n+      warning_at (cp_expr_loc_or_loc (cond, input_location), OPT_Wparentheses,\n \t\t  \"suggest parentheses around assignment used as truth value\");\n       TREE_NO_WARNING (cond) = 1;\n     }\n@@ -2382,7 +2382,7 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n \t  || any_type_dependent_arguments_p (*args))\n \t{\n \t  result = build_min_nt_call_vec (orig_fn, *args);\n-\t  SET_EXPR_LOCATION (result, EXPR_LOC_OR_LOC (fn, input_location));\n+\t  SET_EXPR_LOCATION (result, cp_expr_loc_or_loc (fn, input_location));\n \t  KOENIG_LOOKUP_P (result) = koenig_p;\n \t  if (is_overloaded_fn (fn))\n \t    {"}, {"sha": "4e91dbb75dac1c7206c2f98f55fb97c69c97add8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -479,8 +479,8 @@ build_target_expr (tree decl, tree value, tsubst_flags_t complain)\n \treturn error_mark_node;\n     }\n   t = build4 (TARGET_EXPR, type, decl, value, t, NULL_TREE);\n-  if (EXPR_HAS_LOCATION (value))\n-    SET_EXPR_LOCATION (t, EXPR_LOCATION (value));\n+  if (location_t eloc = cp_expr_location (value))\n+    SET_EXPR_LOCATION (t, eloc);\n   /* We always set TREE_SIDE_EFFECTS so that expand_expr does not\n      ignore the TARGET_EXPR.  If there really turn out to be no\n      side-effects, then the optimizer should be able to get rid of\n@@ -5454,6 +5454,26 @@ cp_tree_code_length (enum tree_code code)\n     }\n }\n \n+/* Like EXPR_LOCATION, but also handle some tcc_exceptional that have\n+   locations.  */\n+\n+location_t\n+cp_expr_location (const_tree t_)\n+{\n+  tree t = CONST_CAST_TREE (t_);\n+  if (t == NULL_TREE)\n+    return UNKNOWN_LOCATION;\n+  switch (TREE_CODE (t))\n+    {\n+    case LAMBDA_EXPR:\n+      return LAMBDA_EXPR_LOCATION (t);\n+    case STATIC_ASSERT:\n+      return STATIC_ASSERT_SOURCE_LOCATION (t);\n+    default:\n+      return EXPR_LOCATION (t);\n+    }\n+}\n+\n /* Implement -Wzero_as_null_pointer_constant.  Return true if the\n    conditions for the warning hold, false otherwise.  */\n bool"}, {"sha": "936de9fe5c6cf890577e0a07a5b2e499b42d84cd", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -1990,7 +1990,7 @@ decay_conversion (tree exp,\n {\n   tree type;\n   enum tree_code code;\n-  location_t loc = EXPR_LOC_OR_LOC (exp, input_location);\n+  location_t loc = cp_expr_loc_or_loc (exp, input_location);\n \n   type = TREE_TYPE (exp);\n   if (type == error_mark_node)\n@@ -2254,7 +2254,7 @@ static tree\n rationalize_conditional_expr (enum tree_code code, tree t,\n                               tsubst_flags_t complain)\n {\n-  location_t loc = EXPR_LOC_OR_LOC (t, input_location);\n+  location_t loc = cp_expr_loc_or_loc (t, input_location);\n \n   /* For MIN_EXPR or MAX_EXPR, fold-const.c has arranged things so that\n      the first operand is always the one to be used if both operands\n@@ -6041,7 +6041,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,\n {\n   /* No default_conversion here.  It causes trouble for ADDR_EXPR.  */\n   tree arg = xarg;\n-  location_t location = EXPR_LOC_OR_LOC (arg, input_location);\n+  location_t location = cp_expr_loc_or_loc (arg, input_location);\n   tree argtype = 0;\n   const char *errstring = NULL;\n   tree val;\n@@ -6593,7 +6593,7 @@ build_x_compound_expr_from_list (tree list, expr_list_kind exp,\n       && !CONSTRUCTOR_IS_DIRECT_INIT (expr))\n     {\n       if (complain & tf_error)\n-\tpedwarn (EXPR_LOC_OR_LOC (expr, input_location), 0,\n+\tpedwarn (cp_expr_loc_or_loc (expr, input_location), 0,\n \t\t \"list-initializer for non-class type must not \"\n \t\t \"be parenthesized\");\n       else\n@@ -8802,7 +8802,7 @@ convert_for_assignment (tree type, tree rhs,\n \t\t}\n \t      else if (fndecl)\n \t\t{\n-\t\t  error_at (EXPR_LOC_OR_LOC (rhs, input_location),\n+\t\t  error_at (cp_expr_loc_or_loc (rhs, input_location),\n \t\t\t    \"cannot convert %qH to %qI\",\n \t\t\t    rhstype, type);\n \t\t  inform (get_fndecl_argument_location (fndecl, parmnum),\n@@ -8904,7 +8904,7 @@ convert_for_assignment (tree type, tree rhs,\n       && TREE_CODE (TREE_TYPE (rhs)) != BOOLEAN_TYPE\n       && (complain & tf_warning))\n     {\n-      location_t loc = EXPR_LOC_OR_LOC (rhs, input_location);\n+      location_t loc = cp_expr_loc_or_loc (rhs, input_location);\n \n       warning_at (loc, OPT_Wparentheses,\n \t\t  \"suggest parentheses around assignment used as truth value\");\n@@ -9016,7 +9016,7 @@ maybe_warn_about_returning_address_of_local (tree retval)\n {\n   tree valtype = TREE_TYPE (DECL_RESULT (current_function_decl));\n   tree whats_returned = fold_for_warn (retval);\n-  location_t loc = EXPR_LOC_OR_LOC (retval, input_location);\n+  location_t loc = cp_expr_loc_or_loc (retval, input_location);\n \n   for (;;)\n     {"}, {"sha": "ca87b438bd3b551ab12642fb5131cbf649cd42f2", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -959,7 +959,7 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain)\n \n   if (!ok)\n     {\n-      location_t loc = EXPR_LOC_OR_LOC (init, input_location);\n+      location_t loc = cp_expr_loc_or_loc (init, input_location);\n       if (cxx_dialect == cxx98)\n \t{\n \t  if (complain & tf_warning)\n@@ -1032,7 +1032,7 @@ digest_init_r (tree type, tree init, int nested, int flags,\n   if (TREE_CODE (init) == NON_LVALUE_EXPR)\n     init = TREE_OPERAND (init, 0);\n \n-  location_t loc = EXPR_LOC_OR_LOC (init, input_location);\n+  location_t loc = cp_expr_loc_or_loc (init, input_location);\n \n   /* Initialization of an array of chars from a string constant. The initializer\n      can be optionally enclosed in braces, but reshape_init has already removed\n@@ -1293,7 +1293,7 @@ process_init_constructor_array (tree type, tree init, int nested,\n       if (nested == 2 && !domain && !vec_safe_is_empty (v))\n \t{\n \t  if (complain & tf_error)\n-\t    error_at (EXPR_LOC_OR_LOC (init, input_location),\n+\t    error_at (cp_expr_loc_or_loc (init, input_location),\n \t\t      \"initialization of flexible array member \"\n \t\t      \"in a nested context\");\n \t  return PICFLAG_ERRONEOUS;"}, {"sha": "c8ed0f6e5f0a52364acb53677cb1c8ea5e573fa7", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic7.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfada421e21cbeb4cfb29b2566ac6075be463a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic7.C?ref=6bdfada421e21cbeb4cfb29b2566ac6075be463a", "patch": "@@ -4,9 +4,9 @@\n template<typename ... Args>\n static void foo()\n {\n-  [](Args, int x) {\n+  [](Args, int x) {\t\t// { dg-error \"packs not expanded\" }\n     x;\n-  };\t\t\t\t// { dg-error \"packs not expanded\" }\n+  };\n }\n int main()\n {"}]}