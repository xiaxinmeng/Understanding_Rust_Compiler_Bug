{"sha": "cff9f8d50930e9e8dd627c92ce5255323576ed02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZmOWY4ZDUwOTMwZTllOGRkNjI3YzkyY2U1MjU1MzIzNTc2ZWQwMg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2002-11-04T16:58:39Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2002-11-04T16:58:39Z"}, "message": "hard-reg-set.h (REG_CANNOT_CHANGE_MODE_P): New.\n\n\n2002-11-04  Aldy Hernandez  <aldyh@redhat.com>\n\n\t* hard-reg-set.h (REG_CANNOT_CHANGE_MODE_P): New.\n\n\t* config/rs6000/rs6000.h (CLASS_CANNOT_CHANGE_MODE_P): Remove.\n\t(CLASS_CANNOT_CHANGE_MODE): Remove.\n\t(CANNOT_CHANGE_MODE_CLASS): New.\n\n\t* config/alpha/alpha.h: Same.\n\n\t* config/ia64/ia64.h: Same.\n\n\t* config/mips/mips.h: Same.\n\n\t* config/s390/s390.h: Same.\n\n\t* config/sh/sh.h: Same.\n\n\t* config/pa/pa64-regs.h: Same.\n\n\t* config/sh/sh-protos.h (sh_cannot_change_mode_class): Add prototype.\n\n\t* config/sh/sh.c (sh_cannot_change_mode_class): New.\n\n\t* config/mips/mips-protos.h (mips_cannot_change_mode_class): Add\n\tprototype.\n\n\t* config/mips/mips.c (mips_cannot_change_mode_class): New.\n\n\t* doc/tm.texi (Register Classes): Remove\n\tCLASS_CANNOT_CHANGE_MODE and CLASS_CANNOT_CHANGE_MODE_P.\n\tDocument CANNOT_CHANGE_MODE_CLASS.\n\n\t* reload.c (push_reload): Use CANNOT_CHANGE_MODE_CLASS.\n\t(push_reload): Same.\n\n\t* simplify-rtx.c (simplify_subreg): Same.\n\n\t* reload1.c (choose_reload_regs): Same.\n\n\t* recog.c (register_operand): Same.\n\n\t* regrename.c (mode_change_ok): Change to use new\n\tCANNOT_CHANGE_MODE_CLASS infrastructure.\n\n\t* regclass.c (cannot_change_mode_set_regs): New.\n\tDeclare subregs_of_mode.\n\t(regclass): Use subregs_of_mode.\n\tRemove references to reg_changes_mode.\n\t(init_reg_sets_1): Remove class_can_change_mode and\n\treg_changes_mode code.\n\t(invalid_mode_change_p): New.\n\t(dump_regclass): Use invalid_mode_change_p instead of\n\tclass_can_change_mode.\n\t(regclass): Same.\n\t(record_operand_costs): Do not set reg_changes_mode.\n\n\t* local-alloc.c (struct qty): Remove changes_mode field.\n\t(alloc_qty): Remove changes_mode initialization.\n\t(update_qty_class): Remove set of changes_mode.\n\t(find_free_reg): Use subregs_of_mode.\n\n\t* global.c (find_reg): Use subregs_of_mode info.\n\n\t* rtl.h (cannot_change_mode_set_regs): New prototype.\n\t(invalid_mode_change_p): Same.\n\t(REG_CANNOT_CHANGE_MODE_P): New macro.\n\n\t* flow.c (mark_used_regs): Calculate subregs_of_mode.  Remove\n\tREG_CHANGES_MODE.\n\t(life_analysis): Clear subregs_of_mode.\n\n\t* combine.c (subst): Pass class to CLASS_CANNOT_CHANGE_MODE_P.\n\tRemove use of CLASS_CANNOT_CHANGE_MODE.\n\t(simplify_set): Same.\n\t(gen_lowpart_for_combine): Calculate subregs_of_mode.  Remove\n\tREG_CHANGES_MODE.\n\n\t* regs.h: Add extern for subregs_of_mode;\n\tInclude hard-reg-set and basic-block.\n\t(REG_CHANGES_MODE): Delete.\n\nFrom-SVN: r58794", "tree": {"sha": "9864774f05d9aef4abaed8431d0fa7b660a6a998", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9864774f05d9aef4abaed8431d0fa7b660a6a998"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cff9f8d50930e9e8dd627c92ce5255323576ed02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff9f8d50930e9e8dd627c92ce5255323576ed02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cff9f8d50930e9e8dd627c92ce5255323576ed02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff9f8d50930e9e8dd627c92ce5255323576ed02/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1c129e309fc1681abecfd655bafa9318306bbb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c129e309fc1681abecfd655bafa9318306bbb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1c129e309fc1681abecfd655bafa9318306bbb8"}], "stats": {"total": 535, "additions": 303, "deletions": 232}, "files": [{"sha": "9b4c1439034e6e6709f39f23d62eb5bdabfdbf98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -1,3 +1,85 @@\n+2002-11-04  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* hard-reg-set.h (REG_CANNOT_CHANGE_MODE_P): New.\n+\n+\t* config/rs6000/rs6000.h (CLASS_CANNOT_CHANGE_MODE_P): Remove.\n+\t(CLASS_CANNOT_CHANGE_MODE): Remove.\n+\t(CANNOT_CHANGE_MODE_CLASS): New.\n+\n+\t* config/alpha/alpha.h: Same.\n+\n+\t* config/ia64/ia64.h: Same.\n+\n+\t* config/mips/mips.h: Same.\n+\n+\t* config/s390/s390.h: Same.\n+\n+\t* config/sh/sh.h: Same.\n+\n+\t* config/pa/pa64-regs.h: Same.\n+\n+\t* config/sh/sh-protos.h (sh_cannot_change_mode_class): Add prototype.\n+\t\n+\t* config/sh/sh.c (sh_cannot_change_mode_class): New.\n+\n+\t* config/mips/mips-protos.h (mips_cannot_change_mode_class): Add\n+\tprototype.\n+\n+\t* config/mips/mips.c (mips_cannot_change_mode_class): New.\n+\n+\t* doc/tm.texi (Register Classes): Remove\n+\tCLASS_CANNOT_CHANGE_MODE and CLASS_CANNOT_CHANGE_MODE_P.\n+\tDocument CANNOT_CHANGE_MODE_CLASS.\n+\n+\t* reload.c (push_reload): Use CANNOT_CHANGE_MODE_CLASS.\n+\t(push_reload): Same.\n+\n+\t* simplify-rtx.c (simplify_subreg): Same.\n+\n+\t* reload1.c (choose_reload_regs): Same.\n+\n+\t* recog.c (register_operand): Same.\n+\n+\t* regrename.c (mode_change_ok): Change to use new\n+\tCANNOT_CHANGE_MODE_CLASS infrastructure.\n+\n+\t* regclass.c (cannot_change_mode_set_regs): New.\n+\tDeclare subregs_of_mode.\n+\t(regclass): Use subregs_of_mode.\n+\tRemove references to reg_changes_mode.\n+\t(init_reg_sets_1): Remove class_can_change_mode and\n+\treg_changes_mode code.\n+\t(invalid_mode_change_p): New.\n+\t(dump_regclass): Use invalid_mode_change_p instead of\n+\tclass_can_change_mode.\n+\t(regclass): Same.\n+\t(record_operand_costs): Do not set reg_changes_mode.\n+\n+\t* local-alloc.c (struct qty): Remove changes_mode field.\n+\t(alloc_qty): Remove changes_mode initialization.\n+\t(update_qty_class): Remove set of changes_mode.\n+\t(find_free_reg): Use subregs_of_mode.\n+\n+\t* global.c (find_reg): Use subregs_of_mode info.\n+\n+\t* rtl.h (cannot_change_mode_set_regs): New prototype.\n+\t(invalid_mode_change_p): Same.\n+\t(REG_CANNOT_CHANGE_MODE_P): New macro.\n+\n+\t* flow.c (mark_used_regs): Calculate subregs_of_mode.  Remove\n+\tREG_CHANGES_MODE.\n+\t(life_analysis): Clear subregs_of_mode.\n+\n+\t* combine.c (subst): Pass class to CLASS_CANNOT_CHANGE_MODE_P.\n+\tRemove use of CLASS_CANNOT_CHANGE_MODE.\n+\t(simplify_set): Same.\n+\t(gen_lowpart_for_combine): Calculate subregs_of_mode.  Remove\n+\tREG_CHANGES_MODE.\n+\t\n+\t* regs.h: Add extern for subregs_of_mode;\n+\tInclude hard-reg-set and basic-block.\n+\t(REG_CHANGES_MODE): Delete.\n+\n 2002-11-03  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* jump.c (never_reached_warning): Don't set contains_insn until the"}, {"sha": "8ce9d10eb1d013b69781ad58bf72eaf56748a6a2", "filename": "gcc/combine.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -3519,15 +3519,13 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t      )\n \t\t    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);\n \n-#ifdef CLASS_CANNOT_CHANGE_MODE\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n \t\t  if (code == SUBREG\n \t\t      && GET_CODE (to) == REG\n \t\t      && REGNO (to) < FIRST_PSEUDO_REGISTER\n-\t\t      && (TEST_HARD_REG_BIT\n-\t\t\t  (reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE],\n-\t\t\t   REGNO (to)))\n-\t\t      && CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (to),\n-\t\t\t\t\t\t     GET_MODE (x)))\n+\t\t      && REG_CANNOT_CHANGE_MODE_P (REGNO (to),\n+\t\t\t\t\t\t   GET_MODE (to),\n+\t\t\t\t\t\t   GET_MODE (x)))\n \t\t    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);\n #endif\n \n@@ -5198,13 +5196,11 @@ simplify_set (x)\n       && (GET_MODE_SIZE (GET_MODE (src))\n \t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))\n #endif\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n       && ! (GET_CODE (dest) == REG && REGNO (dest) < FIRST_PSEUDO_REGISTER\n-\t    && (TEST_HARD_REG_BIT\n-\t\t(reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE],\n-\t\t REGNO (dest)))\n-\t    && CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (src),\n-\t\t\t\t\t   GET_MODE (SUBREG_REG (src))))\n+\t    && REG_CANNOT_CHANGE_MODE_P (REGNO (dest),\n+\t\t\t\t\t GET_MODE (src), \n+\t\t\t\t\t GET_MODE (SUBREG_REG (src))))\n #endif\n       && (GET_CODE (dest) == REG\n \t  || (GET_CODE (dest) == SUBREG\n@@ -9937,14 +9933,13 @@ gen_lowpart_for_combine (mode, x)\n     }\n \n   result = gen_lowpart_common (mode, x);\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n   if (result != 0\n       && GET_CODE (result) == SUBREG\n       && GET_CODE (SUBREG_REG (result)) == REG\n-      && REGNO (SUBREG_REG (result)) >= FIRST_PSEUDO_REGISTER\n-      && CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (result),\n-\t\t\t\t     GET_MODE (SUBREG_REG (result))))\n-    REG_CHANGES_MODE (REGNO (SUBREG_REG (result))) = 1;\n+      && REGNO (SUBREG_REG (result)) >= FIRST_PSEUDO_REGISTER)\n+    SET_REGNO_REG_SET (&subregs_of_mode[GET_MODE (result)],\n+\t\t       REGNO (SUBREG_REG (result)));\n #endif\n \n   if (result)"}, {"sha": "9e39a40395b6a645f97e09fafdfb2abf4bac2979", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -857,15 +857,10 @@ enum reg_class {\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\\\n  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* If defined, gives a class of registers that cannot be used as the\n-   operand of a SUBREG that changes the mode of the object illegally.  */\n+/* Return the class of registers that cannot change mode from FROM to TO.  */\n \n-#define CLASS_CANNOT_CHANGE_MODE\tFLOAT_REGS\n-\n-/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.  */\n-\n-#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) \\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO) \\\n+  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) ? FLOAT_REGS : NO_REGS)\n \n /* Define the cost of moving between registers of various classes.  Moving\n    between FLOAT_REGS and anything else except float regs is expensive. "}, {"sha": "59d6e230366550bd8135aa7b52c2bc3b4fa12984", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -1008,17 +1008,11 @@ enum reg_class\n    : ((CLASS) == FR_REGS && (MODE) == TFmode) ? 1\t\t\\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* If defined, gives a class of registers that cannot be used as the\n-   operand of a SUBREG that changes the mode of the object illegally.  */\n-\n-#define CLASS_CANNOT_CHANGE_MODE        FR_REGS\n-\n-/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.\n-   In FP regs, we can't change FP values to integer values and vice\n+/* In FP regs, we can't change FP values to integer values and vice\n    versa, but we can change e.g. DImode to SImode.  */\n \n-#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) \\\n-  (GET_MODE_CLASS (FROM) != GET_MODE_CLASS (TO))\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO) \t\\\n+  (GET_MODE_CLASS (FROM) != GET_MODE_CLASS (TO) ? FR_REGS : NO_REGS)\n \n /* A C expression that defines the machine-dependent operand constraint\n    letters (`I', `J', `K', .. 'P') that specify particular ranges of"}, {"sha": "d92f7e573b3a653d3703449f0d8dc4f904b85410", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -122,6 +122,8 @@ extern int              mips_adjust_insn_length PARAMS ((rtx, int));\n extern enum reg_class\tmips_secondary_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t\t     enum machine_mode,\n \t\t\t\t\t\t\t     rtx, int));\n+extern enum reg_class\tmips_cannot_change_mode_class \n+\t\t\t  PARAMS ((enum machine_mode, enum machine_mode));\n extern int              mips_class_max_nregs PARAMS ((enum reg_class,\n \t\t\t\t\t\t      enum machine_mode));\n extern int              mips_register_move_cost PARAMS ((enum machine_mode,"}, {"sha": "d58affff1c2f0037893062d5955f1ef3ecc0140d", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -8399,6 +8399,23 @@ function_arg_pass_by_reference (cum, mode, type, named)\n   return size == -1 || size > UNITS_PER_WORD;\n }\n \n+/* Return the class of registers for which a mode change from FROM to TO\n+   is invalid.  */\n+enum reg_class\n+mips_cannot_change_mode_class (from, to)\n+     enum machine_mode from, to;\n+{\n+  if (GET_MODE_SIZE (from) != GET_MODE_SIZE (to))\n+    {\n+      if (TARGET_BIG_ENDIAN)\n+        return FP_REGS;\n+      if (TARGET_FLOAT64)\n+        return HI_AND_FP_REGS;\n+      return HI_REG;\n+    }\n+  return NO_REGS;\n+}\n+\n /* This function returns the register class required for a secondary\n    register when copying between one of the registers in CLASS, and X,\n    using MODE.  If IN_P is nonzero, the copy is going from X to the"}, {"sha": "bc37a145e284997b8a9bed2d3c565b9bfd9ec0af", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -2343,14 +2343,8 @@ extern enum reg_class mips_char_to_class[256];\n    We can't allow 64-bit float registers to change from a 32-bit\n    mode to a 64-bit mode.  */\n \n-#define CLASS_CANNOT_CHANGE_MODE\t\t\t\t\t\\\n-  (TARGET_BIG_ENDIAN ? FP_REGS\t\t\t\t\t\t\\\n-   : (TARGET_FLOAT64 ? HI_AND_FP_REGS : HI_REG))\n-\n-/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.  */\n-\n-#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) \\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO) \\\n+  mips_cannot_change_mode_class (FROM, TO)\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "2d0ebe3d17264b23035dee556f1a916e41d7db85", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -232,21 +232,17 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n   {0x00000000, 0x10000000},\t/* SHIFT_REGS */\t\t\\\n   {0xfffffffe, 0x1fffffff}}\t/* ALL_REGS */\n \n-/* If defined, gives a class of registers that cannot be used as the\n-   operand of a SUBREG that changes the mode of the object illegally.  */\n-\n-#define CLASS_CANNOT_CHANGE_MODE\t(FP_REGS)\n-\n-/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.\n+/* Defines invalid mode changes.\n \n    SImode loads to floating-point registers are not zero-extended.\n    The definition for LOAD_EXTEND_OP specifies that integer loads\n    narrower than BITS_PER_WORD will be zero-extended.  As a result,\n    we inhibit changes from SImode unless they are to a mode that is\n    identical in size.  */\n \n-#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO)\t\t\t\t\\\n-  ((FROM) == SImode && GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO)\t\t\t\\\n+  ((FROM) == SImode && GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)       \\\n+   ? FP_REGS : NO_REGS)\n \n /* Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression"}, {"sha": "39ef154f04636f017df11ed7f59f0f131ac862a6", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -1314,16 +1314,14 @@ enum reg_class\n   ? ((GET_MODE_SIZE (MODE) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD) \\\n   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* If defined, gives a class of registers that cannot be used as the\n-   operand of a SUBREG that changes the mode of the object illegally.  */\n \n-#define CLASS_CANNOT_CHANGE_MODE        FLOAT_REGS\n+/* Return a class of registers that cannot change FROM mode to TO mode.  */\n \n-/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.  */\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO)\t\t\t\t \\\n+  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) ? FLOAT_REGS\t\t \\\n+   : (SPE_VECTOR_MODE (FROM) + SPE_VECTOR_MODE (TO)) == 1 ? GENERAL_REGS \\\n+   : NO_REGS)\n \n-#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) \\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n-\f\n /* Stack layout; function entry, exit and calling.  */\n \n /* Enumeration to give which calling sequence to use.  */"}, {"sha": "268ee2f3445467c064700d9812d232bcb57fc9d6", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -330,10 +330,8 @@ do\t\t\t\t\t\t\t\t\\\n /* If a 4-byte value is loaded into a FPR, it is placed into the\n    *upper* half of the register, not the lower.  Therefore, we\n    cannot use SUBREGs to switch between modes in FP registers.  */\n-#define CLASS_CANNOT_CHANGE_MODE FP_REGS\n-#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) \\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n-\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO)\t\t\\\n+  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) ? FP_REGS : NO_REGS)\n \n /* Register classes.  */\n  "}, {"sha": "a729462393eed3a5cafd867ae41b4cb2dad7afc3", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -126,6 +126,8 @@ extern int sh_pr_n_sets PARAMS ((void));\n extern int sh_hard_regno_rename_ok PARAMS ((unsigned int, unsigned int));\n extern int sh_cfun_interrupt_handler_p PARAMS ((void));\n extern void sh_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n+extern enum reg_class sh_cannot_change_mode_class\n+\t      PARAMS ((enum machine_mode, enum machine_mode));\n \n #ifdef HARD_CONST\n extern void fpscr_set_from_mem PARAMS ((int, HARD_REG_SET));"}, {"sha": "d2cc47186d9e9fe168be6ca0f20570aca90daffb", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -7733,4 +7733,26 @@ sh_expand_binop_v2sf (code, op0, op1, op2)\n   emit_insn ((*fn) (op0, op1, op2, op, sel1, sel1, sel1));\n }\n \n+/* Return the class of registers for which a mode change from FROM to TO\n+   is invalid.  */\n+enum reg_class \n+sh_cannot_change_mode_class (from, to)\n+     enum machine_mode from, to;\n+{\n+  if (GET_MODE_SIZE (from) != GET_MODE_SIZE (to))\n+    {\n+       if (TARGET_LITTLE_ENDIAN)\n+         {\n+\t   if (GET_MODE_SIZE (to) < 8 || GET_MODE_SIZE (from) < 8)\n+\t     return DF_REGS;\n+\t }\n+       else\n+\t {\n+\t   if (GET_MODE_SIZE (from) < 8)\n+\t     return DF_HI_REGS;\n+\t }\n+    }\n+  return NO_REGS;\n+}\n+\n #include \"gt-sh.h\""}, {"sha": "feadbb7d841bd0ef847ed95af5589c7cc3b4616b", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -1372,14 +1372,8 @@ extern const enum reg_class reg_class_from_letter[];\n /* ??? We need to renumber the internal numbers for the frnn registers\n    when in little endian in order to allow mode size changes.  */\n \n-#define CLASS_CANNOT_CHANGE_MODE (TARGET_LITTLE_ENDIAN ? DF_REGS : DF_HI_REGS)\n-\n-/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.  */\n-\n-#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) \\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) \\\n-   && ((TARGET_LITTLE_ENDIAN  && GET_MODE_SIZE (TO) < 8) \\\n-       || GET_MODE_SIZE (FROM) < 8))\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO) \t\t\t    \\\n+  sh_cannot_change_mode_class (FROM, TO)\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "b8f2b934671aceae1e88a52372b454c7f6a3a96e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -2561,25 +2561,22 @@ should be the maximum value of @code{HARD_REGNO_NREGS (@var{regno},\n This macro helps control the handling of multiple-word values\n in the reload pass.\n \n-@item CLASS_CANNOT_CHANGE_MODE\n-If defined, a C expression for a class that contains registers for\n-which the compiler may not change modes arbitrarily.\n-\n-@item CLASS_CANNOT_CHANGE_MODE_P(@var{from}, @var{to})\n-A C expression that is true if, for a register in\n-@code{CLASS_CANNOT_CHANGE_MODE}, the requested mode punning is invalid.\n+@item CANNOT_CHANGE_MODE_CLASS(@var{from}, @var{to})\n+If defined, a C expression that returns a register class for which\n+a change from mode @var{from} to mode @var{to} is invalid, otherwise the\n+macro returns @code{NO_REGS}.\n \n For the example, loading 32-bit integer or floating-point objects into\n floating-point registers on the Alpha extends them to 64 bits.\n Therefore loading a 64-bit object and then storing it as a 32-bit object\n does not store the low-order 32 bits, as would be the case for a normal\n-register.  Therefore, @file{alpha.h} defines @code{CLASS_CANNOT_CHANGE_MODE}\n-as @code{FLOAT_REGS} and @code{CLASS_CANNOT_CHANGE_MODE_P} restricts\n-mode changes to same-size modes.\n+register.  Therefore, @file{alpha.h} defines @code{CANNOT_CHANGE_MODE_CLASS}\n+as below:\n \n-Compare this to IA-64, which extends floating-point values to 82-bits,\n-and stores 64-bit integers in a different format than 64-bit doubles.\n-Therefore @code{CLASS_CANNOT_CHANGE_MODE_P} is always true.\n+@example\n+#define CANNOT_CHANGE_MODE_CLASS \\\n+  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) ? FLOAT_REGS : NO_REGS)\n+@end example\n @end table\n \n Three other special macros describe which operands fit which constraint"}, {"sha": "180796268c67d2d702657d154e0ba84ef44a914e", "filename": "gcc/flow.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -414,8 +414,8 @@ life_analysis (f, file, flags)\n      FILE *file;\n      int flags;\n {\n-#ifdef ELIMINABLE_REGS\n   int i;\n+#ifdef ELIMINABLE_REGS\n   static const struct {const int from, to; } eliminables[] = ELIMINABLE_REGS;\n #endif\n \n@@ -431,6 +431,13 @@ life_analysis (f, file, flags)\n   SET_HARD_REG_BIT (elim_reg_set, FRAME_POINTER_REGNUM);\n #endif\n \n+\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+  if (flags & PROP_REG_INFO)\n+    for (i=0; i < NUM_MACHINE_MODES; ++i)\n+      INIT_REG_SET (&subregs_of_mode[i]);\n+#endif\n+\n   if (! optimize)\n     flags &= ~(PROP_LOG_LINKS | PROP_AUTOINC | PROP_ALLOW_CFG_CHANGES);\n \n@@ -3813,12 +3820,11 @@ mark_used_regs (pbi, x, cond, insn)\n       break;\n \n     case SUBREG:\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n       if (GET_CODE (SUBREG_REG (x)) == REG\n-\t  && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER\n-\t  && CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (x),\n-\t\t\t\t\t GET_MODE (SUBREG_REG (x))))\n-\tREG_CHANGES_MODE (REGNO (SUBREG_REG (x))) = 1;\n+\t  && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER)\n+\tSET_REGNO_REG_SET (&subregs_of_mode[GET_MODE (x)],\n+\t\t\t   REGNO (SUBREG_REG (x)));\n #endif\n \n       /* While we're here, optimize this case.  */\n@@ -3862,13 +3868,12 @@ mark_used_regs (pbi, x, cond, insn)\n \t       || GET_CODE (testreg) == SIGN_EXTRACT\n \t       || GET_CODE (testreg) == SUBREG)\n \t  {\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n \t    if (GET_CODE (testreg) == SUBREG\n \t\t&& GET_CODE (SUBREG_REG (testreg)) == REG\n-\t\t&& REGNO (SUBREG_REG (testreg)) >= FIRST_PSEUDO_REGISTER\n-\t\t&& CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (SUBREG_REG (testreg)),\n-\t\t\t\t\t       GET_MODE (testreg)))\n-\t      REG_CHANGES_MODE (REGNO (SUBREG_REG (testreg))) = 1;\n+\t\t&& REGNO (SUBREG_REG (testreg)) >= FIRST_PSEUDO_REGISTER)\n+\t      SET_REGNO_REG_SET (&subregs_of_mode[GET_MODE (testreg)],\n+\t\t\t\t REGNO (SUBREG_REG (testreg)));\n #endif\n \n \t    /* Modifying a single register in an alternate mode"}, {"sha": "dfbe0388d018fb96a3ea4d84e4e125f7f30826dd", "filename": "gcc/global.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -974,10 +974,7 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n      int retrying;\n {\n   int i, best_reg, pass;\n-#ifdef HARD_REG_SET\n-  register\t\t/* Declare it register if it's a scalar.  */\n-#endif\n-    HARD_REG_SET used, used1, used2;\n+  HARD_REG_SET used, used1, used2;\n \n   enum reg_class class = (alt_regs_p\n \t\t\t  ? reg_alternate_class (allocno[num].reg)\n@@ -1001,10 +998,8 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \n   IOR_HARD_REG_SET (used1, allocno[num].hard_reg_conflicts);\n \n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-  if (REG_CHANGES_MODE (allocno[num].reg))\n-    IOR_HARD_REG_SET (used1,\n-\t\t      reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE]);\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+  cannot_change_mode_set_regs (&used1, mode, allocno[num].reg);\n #endif\n \n   /* Try each hard reg to see if it fits.  Do this in two passes.\n@@ -1200,11 +1195,9 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t      && (allocno[num].calls_crossed == 0\n \t\t  || accept_call_clobbered\n \t\t  || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-\t      && ! (REG_CHANGES_MODE (allocno[num].reg)\n-\t\t    && (TEST_HARD_REG_BIT\n-\t\t\t(reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE],\n-\t\t\t regno)))\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+\t      && ! invalid_mode_change_p (regno, REGNO_REG_CLASS (regno),\n+\t\t\t\t\t  mode)\n #endif\n \t      )\n \t    {"}, {"sha": "712a26791f31fa52969593d91b2774375050a3b7", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -488,4 +488,11 @@ extern int n_non_fixed_regs;\n \n extern const char * reg_names[FIRST_PSEUDO_REGISTER];\n \n+/* Given a hard REGN a FROM mode and a TO mode, return non-zero if\n+   REGN cannot change modes between the specified modes.  */\n+#define REG_CANNOT_CHANGE_MODE_P(REGN, FROM, TO)                          \\\n+        (TEST_HARD_REG_BIT                                                \\\n+          (reg_class_contents[(int) CANNOT_CHANGE_MODE_CLASS (FROM, TO)],  \\\n+           REGN))\n+\n #endif /* ! GCC_HARD_REG_SET_H */"}, {"sha": "c2d6c0c610b49799e6ce6c6939eccdd7f001fe80", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -61,10 +61,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"hard-reg-set.h\"\n #include \"rtl.h\"\n #include \"tm_p.h\"\n #include \"flags.h\"\n-#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"regs.h\"\n #include \"function.h\"\n@@ -144,12 +144,6 @@ struct qty\n      or -1 if none was found.  */\n \n   short phys_reg;\n-\n-  /* Nonzero if this quantity has been used in a SUBREG in some\n-     way that is illegal.  */\n-\n-  char changes_mode;\n-\n };\n \n static struct qty *qty;\n@@ -328,7 +322,6 @@ alloc_qty (regno, mode, size, birth)\n   qty[qtyno].alternate_class = reg_alternate_class (regno);\n   qty[qtyno].n_refs = REG_N_REFS (regno);\n   qty[qtyno].freq = REG_FREQ (regno);\n-  qty[qtyno].changes_mode = REG_CHANGES_MODE (regno);\n }\n \f\n /* Main entry point of this file.  */\n@@ -2026,9 +2019,6 @@ update_qty_class (qtyno, reg)\n   rclass = reg_alternate_class (reg);\n   if (reg_class_subset_p (rclass, qty[qtyno].alternate_class))\n     qty[qtyno].alternate_class = rclass;\n-\n-  if (REG_CHANGES_MODE (reg))\n-    qty[qtyno].changes_mode = 1;\n }\n \f\n /* Handle something which alters the value of an rtx REG.\n@@ -2182,11 +2172,7 @@ find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n      int born_index, dead_index;\n {\n   int i, ins;\n-#ifdef HARD_REG_SET\n-  /* Declare it register if it's a scalar.  */\n-  register\n-#endif\n-    HARD_REG_SET used, first_used;\n+  HARD_REG_SET first_used, used;\n #ifdef ELIMINABLE_REGS\n   static const struct {const int from, to; } eliminables[] = ELIMINABLE_REGS;\n #endif\n@@ -2234,10 +2220,8 @@ find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n   SET_HARD_REG_BIT (used, FRAME_POINTER_REGNUM);\n #endif\n \n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-  if (qty[qtyno].changes_mode)\n-    IOR_HARD_REG_SET (used,\n-\t\t      reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE]);\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+  cannot_change_mode_set_regs (&used, mode, qty[qtyno].first_reg);\n #endif\n \n   /* Normally, the registers that can be used for the first register in"}, {"sha": "b40867bf7a312fbb1b5d1bfdb22db392aedee6a8", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -1083,13 +1083,10 @@ register_operand (op, mode)\n       if (! reload_completed && GET_CODE (sub) == MEM)\n \treturn general_operand (op, mode);\n \n-#ifdef CLASS_CANNOT_CHANGE_MODE\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n       if (GET_CODE (sub) == REG\n \t  && REGNO (sub) < FIRST_PSEUDO_REGISTER\n-\t  && (TEST_HARD_REG_BIT\n-\t      (reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE],\n-\t       REGNO (sub)))\n-\t  && CLASS_CANNOT_CHANGE_MODE_P (mode, GET_MODE (sub))\n+\t  && REG_CANNOT_CHANGE_MODE_P (REGNO (sub), mode, GET_MODE (sub))\n \t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_INT\n \t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_FLOAT)\n \treturn 0;"}, {"sha": "20c7d3b03d1a06528a4ec6f4c26c6f3b806d19bc", "filename": "gcc/regclass.c", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -26,10 +26,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"hard-reg-set.h\"\n #include \"rtl.h\"\n #include \"expr.h\"\n #include \"tm_p.h\"\n-#include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"basic-block.h\"\n #include \"regs.h\"\n@@ -227,20 +227,11 @@ static char *in_inc_dec;\n \n #endif /* FORBIDDEN_INC_DEC_CLASSES */\n \n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-\n-/* These are the classes containing only registers that can be used in\n-   a SUBREG expression that changes the mode of the register in some\n-   way that is illegal.  */\n-\n-static int class_can_change_mode[N_REG_CLASSES];\n-\n-/* Registers, including pseudos, which change modes in some way that\n-   is illegal.  */\n-\n-static regset reg_changes_mode;\n-\n-#endif /* CLASS_CANNOT_CHANGE_MODE */\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+/* All registers that have been subreged.  Indexed by mode, where each\n+   entry is a regset of registers.  */\n+regset_head subregs_of_mode [NUM_MACHINE_MODES];\n+#endif\n \n /* Sample MEM values for use by memory_move_secondary_cost.  */\n \n@@ -549,22 +540,6 @@ init_reg_sets_1 ()\n \t\tmay_move_out_cost[m][i][j] = 65536;\n \t      }\n       }\n-\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-  {\n-    HARD_REG_SET c;\n-    COMPL_HARD_REG_SET (c, reg_class_contents[CLASS_CANNOT_CHANGE_MODE]);\n-\n-    for (i = 0; i < N_REG_CLASSES; i++)\n-      {\n-\tGO_IF_HARD_REG_SUBSET (reg_class_contents[i], c, ok_class);\n-\tclass_can_change_mode [i] = 0;\n-\tcontinue;\n-      ok_class:\n-\tclass_can_change_mode [i] = 1;\n-      }\n-    }\n-#endif /* CLASS_CANNOT_CHANGE_MODE */\n }\n \n /* Compute the table of register modes.\n@@ -952,9 +927,9 @@ dump_regclass (dump)\n \t\t&& (!in_inc_dec[i]\n \t\t    || !forbidden_inc_dec_class[(enum reg_class) class])\n #endif\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-\t\t&& (!REGNO_REG_SET_P (reg_changes_mode, i)\n-\t\t     || class_can_change_mode [(enum reg_class) class])\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+\t\t&& ! invalid_mode_change_p (i, (enum reg_class) class,\n+\t\t\t\t\t    PSEUDO_REGNO_MODE (i))\n #endif\n \t\t)\n \t    fprintf (dump, \" %s:%i\", reg_class_names[class],\n@@ -994,15 +969,7 @@ record_operand_costs (insn, op_costs, reg_pref)\n       op_costs[i] = init_cost;\n \n       if (GET_CODE (recog_data.operand[i]) == SUBREG)\n-\t{\n-\t  rtx inner = SUBREG_REG (recog_data.operand[i]);\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-\t  if (GET_CODE (inner) == REG\n-\t      && CLASS_CANNOT_CHANGE_MODE_P (modes[i], GET_MODE (inner)))\n-\t    SET_REGNO_REG_SET (reg_changes_mode, REGNO (inner));\n-#endif\n-\t  recog_data.operand[i] = inner;\n-\t}\n+\trecog_data.operand[i] = SUBREG_REG (recog_data.operand[i]);\n \n       if (GET_CODE (recog_data.operand[i]) == MEM)\n \trecord_address_regs (XEXP (recog_data.operand[i], 0),\n@@ -1193,10 +1160,6 @@ regclass (f, nregs, dump)\n \n   costs = (struct costs *) xmalloc (nregs * sizeof (struct costs));\n \n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-  reg_changes_mode = BITMAP_XMALLOC ();\n-#endif\n-\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \n   in_inc_dec = (char *) xmalloc (nregs);\n@@ -1329,9 +1292,9 @@ regclass (f, nregs, dump)\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \t\t  || (in_inc_dec[i] && forbidden_inc_dec_class[class])\n #endif\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-\t\t  || (REGNO_REG_SET_P (reg_changes_mode, i)\n-\t\t      && ! class_can_change_mode [class])\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+\t\t  || invalid_mode_change_p (i, (enum reg_class) class,\n+\t\t\t\t\t    PSEUDO_REGNO_MODE (i))\n #endif\n \t\t  )\n \t\t;\n@@ -1359,9 +1322,9 @@ regclass (f, nregs, dump)\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \t\t  && ! (in_inc_dec[i] && forbidden_inc_dec_class[class])\n #endif\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-\t\t  && ! (REGNO_REG_SET_P (reg_changes_mode, i)\n-\t\t\t&& ! class_can_change_mode [class])\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+\t\t  && ! invalid_mode_change_p (i, (enum reg_class) class,\n+\t\t\t\t\t      PSEUDO_REGNO_MODE (i))\n #endif\n \t\t  )\n \t\talt = reg_class_subunion[(int) alt][class];\n@@ -1394,9 +1357,6 @@ regclass (f, nregs, dump)\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n   free (in_inc_dec);\n-#endif\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-  BITMAP_XFREE (reg_changes_mode);\n #endif\n   free (costs);\n }\n@@ -2643,4 +2603,46 @@ regset_release_memory ()\n   bitmap_release_memory ();\n }\n \n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+/* Set bits in *USED which correspond to registers which can't change\n+   their mode from FROM to any mode in which REGNO was encountered.  */\n+\n+void\n+cannot_change_mode_set_regs (used, from, regno)\n+     HARD_REG_SET *used;\n+     enum machine_mode from;\n+     unsigned int regno;\n+{\n+  enum machine_mode to;\n+  enum reg_class class;\n+\n+  for (to = VOIDmode; to < MAX_MACHINE_MODE; ++to)\n+    if (REGNO_REG_SET_P (&subregs_of_mode[to], regno))\n+      {\n+        class = CANNOT_CHANGE_MODE_CLASS (from, to);\n+        if (class != NO_REGS)\n+          IOR_HARD_REG_SET (*used, reg_class_contents [(int) class]);\n+      }\n+}\n+\n+/* Return 1 if REGNO has had an invalid mode change in CLASS from FROM\n+   mode.  */\n+\n+bool\n+invalid_mode_change_p (regno, class, from_mode)\n+     unsigned int regno;\n+      enum reg_class class;\n+     enum machine_mode from_mode;\n+{\n+  enum machine_mode to_mode;\n+\n+  for (to_mode = 0; to_mode < NUM_MACHINE_MODES; ++to_mode)\n+    if (REGNO_REG_SET_P (&subregs_of_mode[(int) to_mode], regno)\n+\t&& reg_classes_intersect_p \n+\t     (class, CANNOT_CHANGE_MODE_CLASS (from_mode, to_mode)))\n+      return 1;\n+  return 0;\n+}\n+#endif /* CANNOT_CHANGE_MODE_CLASS */\n+\n #include \"gt-regclass.h\""}, {"sha": "9b7dfd6d3c5ad1edae449893701d284fa3778aeb", "filename": "gcc/regrename.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -1313,10 +1313,8 @@ mode_change_ok (orig_mode, new_mode, regno)\n   if (GET_MODE_SIZE (orig_mode) < GET_MODE_SIZE (new_mode))\n     return false;\n \n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-  if (TEST_HARD_REG_BIT (reg_class_contents[CLASS_CANNOT_CHANGE_MODE], regno)\n-      && CLASS_CANNOT_CHANGE_MODE_P (orig_mode, new_mode))\n-    return false;\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+  return !REG_CANNOT_CHANGE_MODE_P (regno, orig_mode, new_mode);\n #endif\n \n   return true;"}, {"sha": "4a78212ec805ad60a859c6f1b8a8dccb8c6d67b9", "filename": "gcc/regs.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -21,6 +21,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n \n #include \"varray.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n \n #define REG_BYTES(R) mode_size[(int) GET_MODE (R)]\n \n@@ -64,6 +66,8 @@ typedef struct reg_info_def\n \n extern varray_type reg_n_info;\n \n+extern regset_head subregs_of_mode [NUM_MACHINE_MODES];\n+\n /* Indexed by n, gives number of times (REG n) is used or set.  */\n \n #define REG_N_REFS(N) (VARRAY_REG (reg_n_info, N)->refs)\n@@ -104,13 +108,6 @@ extern varray_type reg_n_info;\n \n #define REG_N_DEATHS(N) (VARRAY_REG (reg_n_info, N)->deaths)\n \n-/* Indexed by N; says whether a pseudo register N was ever used\n-   within a SUBREG that changes the mode of the reg in some way\n-   that is illegal for a given class (usually floating-point)\n-   of registers.  */\n-\n-#define REG_CHANGES_MODE(N) (VARRAY_REG (reg_n_info, N)->changes_mode)\n-\n /* Get the number of consecutive words required to hold pseudo-reg N.  */\n \n #define PSEUDO_REGNO_SIZE(N) \\"}, {"sha": "2b119886d4be3768b7fee63f05a9cc92a977ebfc", "filename": "gcc/reload.c", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -967,9 +967,10 @@ push_reload (in, out, inloc, outloc, class,\n \n   if (in != 0 && GET_CODE (in) == SUBREG\n       && (subreg_lowpart_p (in) || strict_low)\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-      && (class != CLASS_CANNOT_CHANGE_MODE\n-\t  || ! CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (SUBREG_REG (in)), inmode))\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+      && !reg_classes_intersect_p \n+\t   (class, CANNOT_CHANGE_MODE_CLASS (GET_MODE (SUBREG_REG (in)),\n+\t\t\t\t\t     inmode))\n #endif\n       && (CONSTANT_P (SUBREG_REG (in))\n \t  || GET_CODE (SUBREG_REG (in)) == PLUS\n@@ -1016,14 +1017,11 @@ push_reload (in, out, inloc, outloc, class,\n \t\t\t\t\t\tSUBREG_REG (in))\n \t\t  == NO_REGS))\n #endif\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n \t  || (GET_CODE (SUBREG_REG (in)) == REG\n \t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n-\t      && (TEST_HARD_REG_BIT\n-\t\t  (reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE],\n-\t\t   REGNO (SUBREG_REG (in))))\n-\t      && CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (SUBREG_REG (in)),\n-\t\t\t\t\t     inmode))\n+\t      && REG_CANNOT_CHANGE_MODE_P\n+\t      (REGNO (SUBREG_REG (in)), GET_MODE (SUBREG_REG (in)), inmode))\n #endif\n \t  ))\n     {\n@@ -1081,10 +1079,10 @@ push_reload (in, out, inloc, outloc, class,\n      and in that case the constraint should label it input-output.)  */\n   if (out != 0 && GET_CODE (out) == SUBREG\n       && (subreg_lowpart_p (out) || strict_low)\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-      && (class != CLASS_CANNOT_CHANGE_MODE\n-\t  || ! CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (SUBREG_REG (out)),\n-\t\t\t\t\t   outmode))\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+      && !reg_classes_intersect_p \n+\t    (class, CANNOT_CHANGE_MODE_CLASS (GET_MODE (SUBREG_REG (out)),\n+\t\t\t\t\t      outmode))\n #endif\n       && (CONSTANT_P (SUBREG_REG (out))\n \t  || strict_low\n@@ -1118,14 +1116,12 @@ push_reload (in, out, inloc, outloc, class,\n \t\t\t\t\t\t SUBREG_REG (out))\n \t\t  == NO_REGS))\n #endif\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n \t  || (GET_CODE (SUBREG_REG (out)) == REG\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n-\t      && (TEST_HARD_REG_BIT\n-\t\t  (reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE],\n-\t\t   REGNO (SUBREG_REG (out))))\n-\t      && CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (SUBREG_REG (out)),\n-\t\t\t\t\t     outmode))\n+\t      && REG_CANNOT_CHANGE_MODE_P (REGNO (SUBREG_REG (out)),\n+\t\t   \t\t\t   GET_MODE (SUBREG_REG (out)), \n+\t\t\t\t\t   outmode))\n #endif\n \t  ))\n     {"}, {"sha": "2704dadab4d92a5b4c10dd4ba290b982b1cc4210", "filename": "gcc/reload1.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -5490,16 +5490,15 @@ choose_reload_regs (chain)\n \t\t\t\t\t\tGET_MODE_CLASS (mode));\n \n \t\t  if (\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-\t\t      (TEST_HARD_REG_BIT\n-\t\t       (reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE], i)\n-\t\t       ? ! CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (last_reg),\n-\t\t\t\t\t\t       need_mode)\n-\t\t       : (GET_MODE_SIZE (GET_MODE (last_reg))\n-\t\t\t  >= GET_MODE_SIZE (need_mode)))\n-#else\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+\t\t      (!REG_CANNOT_CHANGE_MODE_P (i, GET_MODE (last_reg),\n+\t\t\t\t\t\t  need_mode)\n+\t\t       ||\n+#endif\n \t\t      (GET_MODE_SIZE (GET_MODE (last_reg))\n \t\t       >= GET_MODE_SIZE (need_mode))\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+\t\t      )\n #endif\n \t\t      && reg_reloaded_contents[i] == regno\n \t\t      && TEST_HARD_REG_BIT (reg_reloaded_valid, i)"}, {"sha": "1d71ec90ce41d1400fe893224656082e66e654a7", "filename": "gcc/rtl.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -2092,6 +2092,7 @@ extern int global_alloc\t\t\tPARAMS ((FILE *));\n extern void dump_global_regs\t\tPARAMS ((FILE *));\n #endif\n #ifdef HARD_CONST\n+/* Yes, this ifdef is silly, but HARD_REG_SET is not always defined.  */\n extern void retry_global_alloc\t\tPARAMS ((int, HARD_REG_SET));\n #endif\n extern void build_insn_chain\t\tPARAMS ((rtx));\n@@ -2109,6 +2110,14 @@ extern void regclass\t\t\tPARAMS ((rtx, int, FILE *));\n extern void reg_scan\t\t\tPARAMS ((rtx, unsigned int, int));\n extern void reg_scan_update\t\tPARAMS ((rtx, rtx, unsigned int));\n extern void fix_register\t\tPARAMS ((const char *, int, int));\n+#ifdef HARD_CONST\n+extern void cannot_change_mode_set_regs PARAMS ((HARD_REG_SET *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t unsigned int));\n+#endif\n+extern bool invalid_mode_change_p\tPARAMS ((unsigned int,\n+\t\t\t\t\t\t enum reg_class,\n+\t\t\t\t\t\t enum machine_mode));\n \n extern int delete_null_pointer_checks\tPARAMS ((rtx));\n \n@@ -2269,4 +2278,5 @@ extern void invert_br_probabilities\tPARAMS ((rtx));\n extern bool expensive_function_p\tPARAMS ((int));\n /* In tracer.c */\n extern void tracer\t\t\tPARAMS ((void));\n+\n #endif /* ! GCC_RTL_H */"}, {"sha": "212d3b9023609d93716787a3a9c84a4739421ca6", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff9f8d50930e9e8dd627c92ce5255323576ed02/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=cff9f8d50930e9e8dd627c92ce5255323576ed02", "patch": "@@ -2586,15 +2586,12 @@ simplify_subreg (outermode, op, innermode, byte)\n   if (REG_P (op)\n       && (! REG_FUNCTION_VALUE_P (op)\n \t  || ! rtx_equal_function_value_matters)\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-      && ! (CLASS_CANNOT_CHANGE_MODE_P (outermode, innermode)\n+      && REGNO (op) < FIRST_PSEUDO_REGISTER\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+      && ! (REG_CANNOT_CHANGE_MODE_P (REGNO (op), outermode, innermode)\n \t    && GET_MODE_CLASS (innermode) != MODE_COMPLEX_INT\n-\t    && GET_MODE_CLASS (innermode) != MODE_COMPLEX_FLOAT\n-\t    && (TEST_HARD_REG_BIT\n-\t\t(reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE],\n-\t\t REGNO (op))))\n+\t    && GET_MODE_CLASS (innermode) != MODE_COMPLEX_FLOAT)\n #endif\n-      && REGNO (op) < FIRST_PSEUDO_REGISTER\n       && ((reload_completed && !frame_pointer_needed)\n \t  || (REGNO (op) != FRAME_POINTER_REGNUM\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM"}]}