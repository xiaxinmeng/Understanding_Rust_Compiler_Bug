{"sha": "ab5934a8fe1dc70030fd73703c0fb6c68e96b086", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI1OTM0YThmZTFkYzcwMDMwZmQ3MzcwM2MwZmI2YzY4ZTk2YjA4Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-02-21T09:40:25Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-13T13:26:45Z"}, "message": "Remove SLP_INSTANCE_GROUP_SIZE\n\nThis removes the SLP_INSTANCE_GROUP_SIZE member since the number of\nlanes throughout a SLP subgraph is not necessarily constant.\n\n2020-05-13  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (SLP_INSTANCE_GROUP_SIZE): Remove.\n\t(_slp_instance::group_size): Likewise.\n\t* tree-vect-loop.c (vectorizable_reduction): The group size\n\tis the number of lanes in the node.\n\t* tree-vect-slp.c (vect_attempt_slp_rearrange_stmts): Likewise.\n\t(vect_analyze_slp_instance): Do not set SLP_INSTANCE_GROUP_SIZE,\n\tverify it matches the instance trees number of lanes.\n\t(vect_slp_analyze_node_operations_1): Use the numer of lanes\n\tin the node as group size.\n\t(vect_bb_vectorization_profitable_p): Use the instance root\n\tnumber of lanes for the size of life.\n\t(vect_schedule_slp_instance): Use the number of lanes as\n\tgroup_size.\n\t* tree-vect-stmts.c (vectorizable_load): Remove SLP instance\n\tparameter.  Use the number of lanes of the load for the group\n\tsize in the gap adjustment code.\n\t(vect_analyze_stmt): Adjust.\n\t(vect_transform_stmt): Likewise.", "tree": {"sha": "0c72e0cd5770bfdeea7d86edc5dc862f2f416861", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c72e0cd5770bfdeea7d86edc5dc862f2f416861"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab5934a8fe1dc70030fd73703c0fb6c68e96b086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab5934a8fe1dc70030fd73703c0fb6c68e96b086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab5934a8fe1dc70030fd73703c0fb6c68e96b086", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab5934a8fe1dc70030fd73703c0fb6c68e96b086/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b56828c573910e4210fa05138ddf5aabb8e4b03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b56828c573910e4210fa05138ddf5aabb8e4b03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b56828c573910e4210fa05138ddf5aabb8e4b03"}], "stats": {"total": 72, "additions": 49, "deletions": 23}, "files": [{"sha": "ed6e1025efd5106edeb496569c45d1d9148df4bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab5934a8fe1dc70030fd73703c0fb6c68e96b086/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab5934a8fe1dc70030fd73703c0fb6c68e96b086/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab5934a8fe1dc70030fd73703c0fb6c68e96b086", "patch": "@@ -1,3 +1,24 @@\n+2020-05-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (SLP_INSTANCE_GROUP_SIZE): Remove.\n+\t(_slp_instance::group_size): Likewise.\n+\t* tree-vect-loop.c (vectorizable_reduction): The group size\n+\tis the number of lanes in the node.\n+\t* tree-vect-slp.c (vect_attempt_slp_rearrange_stmts): Likewise.\n+\t(vect_analyze_slp_instance): Do not set SLP_INSTANCE_GROUP_SIZE,\n+\tverify it matches the instance trees number of lanes.\n+\t(vect_slp_analyze_node_operations_1): Use the numer of lanes\n+\tin the node as group size.\n+\t(vect_bb_vectorization_profitable_p): Use the instance root\n+\tnumber of lanes for the size of life.\n+\t(vect_schedule_slp_instance): Use the number of lanes as\n+\tgroup_size.\n+\t* tree-vect-stmts.c (vectorizable_load): Remove SLP instance\n+\tparameter.  Use the number of lanes of the load for the group\n+\tsize in the gap adjustment code.\n+\t(vect_analyze_stmt): Adjust.\n+\t(vect_transform_stmt): Likewise.\n+\n 2020-05-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/95080"}, {"sha": "a1f52dcc2ad8b792fcf8b79951a8b0ccad4f014d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab5934a8fe1dc70030fd73703c0fb6c68e96b086/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab5934a8fe1dc70030fd73703c0fb6c68e96b086/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=ab5934a8fe1dc70030fd73703c0fb6c68e96b086", "patch": "@@ -6574,7 +6574,7 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n \t which each SLP statement has its own initial value and in which\n \t that value needs to be repeated for every instance of the\n \t statement within the initial vector.  */\n-      unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n+      unsigned int group_size = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n       if (!neutral_op\n \t  && !can_duplicate_and_interleave_p (loop_vinfo, group_size,\n \t\t\t\t\t      TREE_TYPE (vectype_out)))"}, {"sha": "6f623955ce5191edfe81efed519f9f8cf26b4fcb", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab5934a8fe1dc70030fd73703c0fb6c68e96b086/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab5934a8fe1dc70030fd73703c0fb6c68e96b086/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=ab5934a8fe1dc70030fd73703c0fb6c68e96b086", "patch": "@@ -1810,7 +1810,6 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n static bool\n vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n {\n-  unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_instn);\n   unsigned int i, j;\n   unsigned int lidx;\n   slp_tree node, load;\n@@ -1821,14 +1820,16 @@ vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n   /* Compare all the permutation sequences to the first one.  We know\n      that at least one load is permuted.  */\n   node = SLP_INSTANCE_LOADS (slp_instn)[0];\n-  if (!node->load_permutation.exists ())\n+  if (!SLP_TREE_LOAD_PERMUTATION (node).exists ())\n     return false;\n+  unsigned int group_size = SLP_TREE_LOAD_PERMUTATION (node).length ();\n   for (i = 1; SLP_INSTANCE_LOADS (slp_instn).iterate (i, &load); ++i)\n     {\n-      if (!load->load_permutation.exists ())\n+      if (!SLP_TREE_LOAD_PERMUTATION (load).exists ()\n+\t  || SLP_TREE_LOAD_PERMUTATION (load).length () != group_size)\n \treturn false;\n-      FOR_EACH_VEC_ELT (load->load_permutation, j, lidx)\n-\tif (lidx != node->load_permutation[j])\n+      FOR_EACH_VEC_ELT (SLP_TREE_LOAD_PERMUTATION (load), j, lidx)\n+\tif (lidx != SLP_TREE_LOAD_PERMUTATION (node)[j])\n \t  return false;\n     }\n \n@@ -2151,7 +2152,6 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t  /* Create a new SLP instance.  */\n \t  new_instance = XNEW (class _slp_instance);\n \t  SLP_INSTANCE_TREE (new_instance) = node;\n-\t  SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n \t  SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n \t  SLP_INSTANCE_LOADS (new_instance) = vNULL;\n \t  SLP_INSTANCE_ROOT_STMT (new_instance) = constructor ? stmt_info : NULL;\n@@ -2240,6 +2240,12 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \n \t  vinfo->slp_instances.safe_push (new_instance);\n \n+\t  /* ???  We've replaced the old SLP_INSTANCE_GROUP_SIZE with\n+\t     the number of scalar stmts in the root in a few places.\n+\t     Verify that assumption holds.  */\n+\t  gcc_assert (SLP_TREE_SCALAR_STMTS (SLP_INSTANCE_TREE (new_instance))\n+\t\t\t.length () == group_size);\n+\n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2670,7 +2676,7 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n \tvf = loop_vinfo->vectorization_factor;\n       else\n \tvf = 1;\n-      unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (node_instance);\n+      unsigned int group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n       SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n \t= vect_get_num_vectors (vf * group_size, vectype);\n@@ -2956,7 +2962,8 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       auto_vec<bool, 20> life;\n-      life.safe_grow_cleared (SLP_INSTANCE_GROUP_SIZE (instance));\n+      life.safe_grow_cleared\n+\t(SLP_TREE_SCALAR_STMTS (SLP_INSTANCE_TREE (instance)).length ());\n       vect_bb_slp_scalar_cost (bb_vinfo,\n \t\t\t       SLP_INSTANCE_TREE (instance),\n \t\t\t       &life, &scalar_costs, visited);\n@@ -3791,8 +3798,7 @@ vect_get_slp_defs (vec_info *vinfo,\n \n /* Generate vector permute statements from a list of loads in DR_CHAIN.\n    If ANALYZE_ONLY is TRUE, only check that it is possible to create valid\n-   permute statements for the SLP node NODE of the SLP instance\n-   SLP_NODE_INSTANCE.  */\n+   permute statements for the SLP node NODE.  */\n \n bool\n vect_transform_slp_perm_load (vec_info *vinfo,\n@@ -4040,7 +4046,7 @@ vect_schedule_slp_instance (vec_info *vinfo,\n   /* VECTYPE is the type of the destination.  */\n   vectype = STMT_VINFO_VECTYPE (stmt_info);\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n+  group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n \n   gcc_assert (SLP_TREE_NUMBER_OF_VEC_STMTS (node) != 0);\n   SLP_TREE_VEC_STMTS (node).create (SLP_TREE_NUMBER_OF_VEC_STMTS (node));"}, {"sha": "61b1ac3531807e0c622d7aba7dfd3f074c8835e7", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab5934a8fe1dc70030fd73703c0fb6c68e96b086/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab5934a8fe1dc70030fd73703c0fb6c68e96b086/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ab5934a8fe1dc70030fd73703c0fb6c68e96b086", "patch": "@@ -8606,7 +8606,6 @@ static bool\n vectorizable_load (vec_info *vinfo,\n \t\t   stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t   stmt_vec_info *vec_stmt, slp_tree slp_node,\n-\t\t   slp_instance slp_node_instance,\n \t\t   stmt_vector_for_cost *cost_vec)\n {\n   tree scalar_dest;\n@@ -9221,8 +9220,9 @@ vectorizable_load (vec_info *vinfo,\n \t     unpermuted sequence.  In other cases we need to load the\n \t     whole group, not only the number of vector stmts the\n \t     permutation result fits in.  */\n+\t  unsigned scalar_lanes = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n \t  if (slp_perm\n-\t      && (group_size != SLP_INSTANCE_GROUP_SIZE (slp_node_instance)\n+\t      && (group_size != scalar_lanes \n \t\t  || !multiple_p (nunits, group_size)))\n \t    {\n \t      /* We don't yet generate such SLP_TREE_LOAD_PERMUTATIONs for\n@@ -9236,7 +9236,7 @@ vectorizable_load (vec_info *vinfo,\n \t    {\n \t      vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n \t      group_gap_adj\n-\t\t= group_size - SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n+\t\t= group_size - scalar_lanes;\n \t    }\n     \t}\n       else\n@@ -11062,8 +11062,7 @@ vect_analyze_stmt (vec_info *vinfo,\n \t\t\t\t     NULL, NULL, node, cost_vec)\n \t  || vectorizable_assignment (vinfo, stmt_info,\n \t\t\t\t      NULL, NULL, node, cost_vec)\n-\t  || vectorizable_load (vinfo, stmt_info,\n-\t\t\t\tNULL, NULL, node, node_instance, cost_vec)\n+\t  || vectorizable_load (vinfo, stmt_info, NULL, NULL, node, cost_vec)\n \t  || vectorizable_store (vinfo, stmt_info, NULL, NULL, node, cost_vec)\n \t  || vectorizable_reduction (as_a <loop_vec_info> (vinfo), stmt_info,\n \t\t\t\t     node, node_instance, cost_vec)\n@@ -11091,7 +11090,7 @@ vect_analyze_stmt (vec_info *vinfo,\n \t      || vectorizable_assignment (vinfo, stmt_info, NULL, NULL, node,\n \t\t\t\t\t  cost_vec)\n \t      || vectorizable_load (vinfo, stmt_info,\n-\t\t\t\t    NULL, NULL, node, node_instance, cost_vec)\n+\t\t\t\t    NULL, NULL, node, cost_vec)\n \t      || vectorizable_store (vinfo, stmt_info,\n \t\t\t\t     NULL, NULL, node, cost_vec)\n \t      || vectorizable_condition (vinfo, stmt_info,\n@@ -11182,7 +11181,7 @@ vect_transform_stmt (vec_info *vinfo,\n \n     case load_vec_info_type:\n       done = vectorizable_load (vinfo, stmt_info, gsi, &vec_stmt, slp_node,\n-                                slp_node_instance, NULL);\n+\t\t\t\tNULL);\n       gcc_assert (done);\n       break;\n "}, {"sha": "20784251b6fbfc927a55273a8092eef5f7502a42", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab5934a8fe1dc70030fd73703c0fb6c68e96b086/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab5934a8fe1dc70030fd73703c0fb6c68e96b086/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=ab5934a8fe1dc70030fd73703c0fb6c68e96b086", "patch": "@@ -119,20 +119,24 @@ typedef struct _slp_tree *slp_tree;\n struct _slp_tree {\n   /* Nodes that contain def-stmts of this node statements operands.  */\n   vec<slp_tree> children;\n+\n   /* A group of scalar stmts to be vectorized together.  */\n   vec<stmt_vec_info> stmts;\n   /* A group of scalar operands to be vectorized together.  */\n   vec<tree> ops;\n+\n   /* Load permutation relative to the stores, NULL if there is no\n      permutation.  */\n   vec<unsigned> load_permutation;\n+\n   /* Vectorized stmt/s.  */\n   vec<stmt_vec_info> vec_stmts;\n   /* Number of vector stmts that are created to replace the group of scalar\n      stmts. It is calculated during the transformation phase as the number of\n      scalar elements in one scalar iteration (GROUP_SIZE) multiplied by VF\n      divided by vector size.  */\n   unsigned int vec_stmts_size;\n+\n   /* Reference count in the SLP graph.  */\n   unsigned int refcnt;\n   /* The maximum number of vector elements for the subtree rooted\n@@ -156,9 +160,6 @@ typedef class _slp_instance {\n      from, NULL otherwise.  */\n   stmt_vec_info root_stmt;\n \n-  /* Size of groups of scalar stmts that will be replaced by SIMD stmt/s.  */\n-  unsigned int group_size;\n-\n   /* The unrolling factor required to vectorized this SLP instance.  */\n   poly_uint64 unrolling_factor;\n \n@@ -172,7 +173,6 @@ typedef class _slp_instance {\n \n /* Access Functions.  */\n #define SLP_INSTANCE_TREE(S)                     (S)->root\n-#define SLP_INSTANCE_GROUP_SIZE(S)               (S)->group_size\n #define SLP_INSTANCE_UNROLLING_FACTOR(S)         (S)->unrolling_factor\n #define SLP_INSTANCE_LOADS(S)                    (S)->loads\n #define SLP_INSTANCE_ROOT_STMT(S)                (S)->root_stmt"}]}