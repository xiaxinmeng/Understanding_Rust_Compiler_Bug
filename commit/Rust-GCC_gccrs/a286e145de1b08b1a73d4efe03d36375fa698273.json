{"sha": "a286e145de1b08b1a73d4efe03d36375fa698273", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI4NmUxNDVkZTFiMDhiMWE3M2Q0ZWZlMDNkMzYzNzVmYTY5ODI3Mw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2006-02-09T23:59:30Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2006-02-09T23:59:30Z"}, "message": "Class.h (_Jv_IDispatchTable): Make it a struct.\n\n2006-02-09  Bryce McKinlay  <mckinlay@redhat.com>\n\n\t* java/lang/Class.h (_Jv_IDispatchTable): Make it a struct. Put \n\t'itable' inline, instead of as a pointer.\n\t(java::lang::Class): Put 'idt' in anonymous union with 'ioffsets'.\n\t* link.cc (null_idt): Update definition.\n\t(_Jv_Linker::prepare_constant_time_tables): Allocate klass->idt\n\tas a single struct. Use _Jv_AllocBytes, not _Jv_AllocRawObj.\n\t(_Jv_Linker::generate_itable): Update to use 'ioffsets'.\n\t(_Jv_Linker::find_iindex): Likewise. Update comment.\n\t* java/lang/natClass.cc\t(_Jv_LookupInterfaceMethodIdx): Update for\n\t_Jv_IDispatchTable change.\n\t(_Jv_IsAssignableFrom): Likewise.\n\nFrom-SVN: r110818", "tree": {"sha": "bd4f0f64a0edeb902ab500f977edf15f2ea0b8f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd4f0f64a0edeb902ab500f977edf15f2ea0b8f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a286e145de1b08b1a73d4efe03d36375fa698273", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a286e145de1b08b1a73d4efe03d36375fa698273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a286e145de1b08b1a73d4efe03d36375fa698273", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a286e145de1b08b1a73d4efe03d36375fa698273/comments", "author": null, "committer": null, "parents": [{"sha": "c4bbc105641ea61b0d4e5a826d639f1051a00667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4bbc105641ea61b0d4e5a826d639f1051a00667", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4bbc105641ea61b0d4e5a826d639f1051a00667"}], "stats": {"total": 110, "additions": 57, "deletions": 53}, "files": [{"sha": "22afafa959b43d70782ced06f1719e05b3731d5e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a286e145de1b08b1a73d4efe03d36375fa698273/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a286e145de1b08b1a73d4efe03d36375fa698273/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a286e145de1b08b1a73d4efe03d36375fa698273", "patch": "@@ -1,3 +1,17 @@\n+2006-02-09  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* java/lang/Class.h (_Jv_IDispatchTable): Make it a struct. Put \n+\t'itable' inline, instead of as a pointer.\n+\t(java::lang::Class): Put 'idt' in anonymous union with 'ioffsets'.\n+\t* link.cc (null_idt): Update definition.\n+\t(_Jv_Linker::prepare_constant_time_tables): Allocate klass->idt\n+\tas a single struct. Use _Jv_AllocBytes, not _Jv_AllocRawObj.\n+\t(_Jv_Linker::generate_itable): Update to use 'ioffsets'.\n+\t(_Jv_Linker::find_iindex): Likewise. Update comment.\n+\t* java/lang/natClass.cc\t(_Jv_LookupInterfaceMethodIdx): Update for\n+\t_Jv_IDispatchTable change.\n+\t(_Jv_IsAssignableFrom): Likewise.\n+\n 2006-02-08  Bryce McKinlay  <mckinlay@redhat.com>\n \n \tPR libgcj/25187:"}, {"sha": "787e2638b2b3ce11cb544fa324a7519317b90483", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a286e145de1b08b1a73d4efe03d36375fa698273/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a286e145de1b08b1a73d4efe03d36375fa698273/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=a286e145de1b08b1a73d4efe03d36375fa698273", "patch": "@@ -120,23 +120,14 @@ struct _Jv_Method\n   { return this + 1; }\n };\n \n-// Interface Dispatch Tables \n-union _Jv_IDispatchTable\n+// The table used to resolve interface calls.\n+struct _Jv_IDispatchTable\n {\n-  struct\n-  {\n-    // Index into interface's ioffsets.\n-    jshort iindex;\n-    jshort itable_length;\n-    // Class Interface dispatch table.\n-    void **itable;\n-  } cls;\n-\n-  struct\n-  {\n-    // Offsets into implementation class itables.\n-    jshort *ioffsets;\n-  } iface;\n+  // Index into interface's ioffsets.\n+  jshort iindex;\n+  jshort itable_length;\n+  // Class Interface dispatch table.\n+  void *itable[0];\n };\n \n // Used by _Jv_Linker::get_interfaces ()\n@@ -600,8 +591,13 @@ class java::lang::Class : public java::lang::Object\n   jshort depth;\n   // Vector of this class's superclasses, ordered by decreasing depth.\n   jclass *ancestors;\n-  // Interface Dispatch Table.\n-  _Jv_IDispatchTable *idt;\n+  // In a regular class, this field points to the Class Interface Dispatch \n+  // Table. In an interface, it points to the ioffsets table.\n+  union \n+  {\n+    _Jv_IDispatchTable *idt;\n+    jshort *ioffsets;\n+  };\n   // Pointer to the class that represents an array of this class.\n   jclass arrayclass;\n   // Security Domain to which this class belongs (or null)."}, {"sha": "8972cb2c49970c9d3b2b1955f1b4a90fa9222b40", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a286e145de1b08b1a73d4efe03d36375fa698273/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a286e145de1b08b1a73d4efe03d36375fa698273/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=a286e145de1b08b1a73d4efe03d36375fa698273", "patch": "@@ -985,8 +985,8 @@ void *\n _Jv_LookupInterfaceMethodIdx (jclass klass, jclass iface, int method_idx)\n {\n   _Jv_IDispatchTable *cldt = klass->idt;\n-  int idx = iface->idt->iface.ioffsets[cldt->cls.iindex] + method_idx;\n-  return cldt->cls.itable[idx];\n+  int idx = iface->ioffsets[cldt->iindex] + method_idx;\n+  return cldt->itable[idx];\n }\n \n jboolean\n@@ -1013,16 +1013,15 @@ _Jv_IsAssignableFrom (jclass source, jclass target)\n         return _Jv_InterfaceAssignableFrom (source, target);\n \n       _Jv_IDispatchTable *cl_idt = source->idt;\n-      _Jv_IDispatchTable *if_idt = target->idt;\n \n-      if (__builtin_expect ((if_idt == NULL), false))\n+      if (__builtin_expect ((target->ioffsets == NULL), false))\n \treturn false; // No class implementing TARGET has been loaded.    \n-      jshort cl_iindex = cl_idt->cls.iindex;\n-      if (cl_iindex < if_idt->iface.ioffsets[0])\n+      jshort cl_iindex = cl_idt->iindex;\n+      if (cl_iindex < target->ioffsets[0])\n         {\n-\t  jshort offset = if_idt->iface.ioffsets[cl_iindex];\n-\t  if (offset != -1 && offset < cl_idt->cls.itable_length\n-\t      && cl_idt->cls.itable[offset] == target)\n+\t  jshort offset = target->ioffsets[cl_iindex];\n+\t  if (offset != -1 && offset < cl_idt->itable_length\n+\t      && cl_idt->itable[offset] == target)\n \t    return true;\n \t}\n       return false;"}, {"sha": "481f98a138bcb6a3d3d2261fb80b76743e931df2", "filename": "libjava/link.cc", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a286e145de1b08b1a73d4efe03d36375fa698273/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a286e145de1b08b1a73d4efe03d36375fa698273/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=a286e145de1b08b1a73d4efe03d36375fa698273", "patch": "@@ -552,7 +552,7 @@ _Jv_Linker::search_method_in_class (jclass cls, jclass klass,\n #define INITIAL_IOFFSETS_LEN 4\n #define INITIAL_IFACES_LEN 4\n \n-static _Jv_IDispatchTable null_idt = { {SHRT_MAX, 0, NULL} };\n+static _Jv_IDispatchTable null_idt = {SHRT_MAX, 0, {}};\n \n // Generate tables for constant-time assignment testing and interface\n // method lookup. This implements the technique described by Per Bothner\n@@ -611,9 +611,6 @@ _Jv_Linker::prepare_constant_time_tables (jclass klass)\n       return;\n     }\n \n-  klass->idt = \n-    (_Jv_IDispatchTable *) _Jv_AllocRawObj (sizeof (_Jv_IDispatchTable));\n-\n   _Jv_ifaces ifaces;\n   ifaces.count = 0;\n   ifaces.len = INITIAL_IFACES_LEN;\n@@ -625,9 +622,10 @@ _Jv_Linker::prepare_constant_time_tables (jclass klass)\n     {\n       // The classes pointed to by the itable will always be reachable\n       // via other paths.\n-      klass->idt->cls.itable = \n-\t(void **) _Jv_AllocBytes (itable_size * sizeof (void *));\n-      klass->idt->cls.itable_length = itable_size;\n+      int idt_bytes = sizeof (_Jv_IDispatchTable) + (itable_size \n+\t\t\t\t\t\t     * sizeof (void *));\n+      klass->idt = (_Jv_IDispatchTable *) _Jv_AllocBytes (idt_bytes);\n+      klass->idt->itable_length = itable_size;\n \n       jshort *itable_offsets = \n \t(jshort *) _Jv_Malloc (ifaces.count * sizeof (jshort));\n@@ -639,18 +637,17 @@ _Jv_Linker::prepare_constant_time_tables (jclass klass)\n \n       for (int i = 0; i < ifaces.count; i++)\n \t{\n-\t  ifaces.list[i]->idt->iface.ioffsets[cls_iindex] =\n-\t    itable_offsets[i];\n+\t  ifaces.list[i]->ioffsets[cls_iindex] = itable_offsets[i];\n \t}\n \n-      klass->idt->cls.iindex = cls_iindex;\t    \n+      klass->idt->iindex = cls_iindex;\t    \n \n       _Jv_Free (ifaces.list);\n       _Jv_Free (itable_offsets);\n     }\n   else \n     {\n-      klass->idt->cls.iindex = SHRT_MAX;\n+      klass->idt->iindex = SHRT_MAX;\n     }\n }\n \n@@ -713,7 +710,7 @@ void\n _Jv_Linker::generate_itable (jclass klass, _Jv_ifaces *ifaces,\n \t\t\t       jshort *itable_offsets)\n {\n-  void **itable = klass->idt->cls.itable;\n+  void **itable = klass->idt->itable;\n   jshort itable_pos = 0;\n \n   for (int i = 0; i < ifaces->count; i++)\n@@ -722,20 +719,17 @@ _Jv_Linker::generate_itable (jclass klass, _Jv_ifaces *ifaces,\n       itable_offsets[i] = itable_pos;\n       itable_pos = append_partial_itable (klass, iface, itable, itable_pos);\n \n-      /* Create interface dispatch table for iface */\n-      if (iface->idt == NULL)\n+      /* Create ioffsets table for iface */\n+      if (iface->ioffsets == NULL)\n \t{\n-\t  iface->idt\n-\t    = (_Jv_IDispatchTable *) _Jv_AllocRawObj (sizeof (_Jv_IDispatchTable));\n-\n \t  // The first element of ioffsets is its length (itself included).\n \t  jshort *ioffsets = (jshort *) _Jv_AllocBytes (INITIAL_IOFFSETS_LEN\n \t\t\t\t\t\t\t* sizeof (jshort));\n \t  ioffsets[0] = INITIAL_IOFFSETS_LEN;\n \t  for (int i = 1; i < INITIAL_IOFFSETS_LEN; i++)\n \t    ioffsets[i] = -1;\n \n-\t  iface->idt->iface.ioffsets = ioffsets;\t    \n+\t  iface->ioffsets = ioffsets;\n \t}\n     }\n }\n@@ -881,8 +875,8 @@ static bool iindex_mutex_initialized = false;\n // Interface Dispatch Table, we just compare the first element to see if it \n // matches the desired interface. So how can we find the correct offset?  \n // Our solution is to keep a vector of candiate offsets in each interface \n-// (idt->iface.ioffsets), and in each class we have an index \n-// (idt->cls.iindex) used to select the correct offset from ioffsets.\n+// (ioffsets), and in each class we have an index (idt->iindex) used to\n+// select the correct offset from ioffsets.\n //\n // Calculate and return iindex for a new class. \n // ifaces is a vector of num interfaces that the class implements.\n@@ -913,9 +907,9 @@ _Jv_Linker::find_iindex (jclass *ifaces, jshort *offsets, jshort num)\n         {\n \t  if (j >= num)\n \t    goto found;\n-\t  if (i >= ifaces[j]->idt->iface.ioffsets[0])\n+\t  if (i >= ifaces[j]->ioffsets[0])\n \t    continue;\n-\t  int ioffset = ifaces[j]->idt->iface.ioffsets[i];\n+\t  int ioffset = ifaces[j]->ioffsets[i];\n \t  /* We can potentially share this position with another class. */\n \t  if (ioffset >= 0 && ioffset != offsets[j])\n \t    break; /* Nope. Try next i. */\t  \n@@ -924,14 +918,15 @@ _Jv_Linker::find_iindex (jclass *ifaces, jshort *offsets, jshort num)\n   found:\n   for (j = 0; j < num; j++)\n     {\n-      int len = ifaces[j]->idt->iface.ioffsets[0];\n+      int len = ifaces[j]->ioffsets[0];\n       if (i >= len) \n \t{\n \t  // Resize ioffsets.\n \t  int newlen = 2 * len;\n \t  if (i >= newlen)\n \t    newlen = i + 3;\n-\t  jshort *old_ioffsets = ifaces[j]->idt->iface.ioffsets;\n+\n+\t  jshort *old_ioffsets = ifaces[j]->ioffsets;\n \t  jshort *new_ioffsets = (jshort *) _Jv_AllocBytes (newlen\n \t\t\t\t\t\t\t    * sizeof(jshort));\n \t  memcpy (&new_ioffsets[1], &old_ioffsets[1],\n@@ -941,9 +936,9 @@ _Jv_Linker::find_iindex (jclass *ifaces, jshort *offsets, jshort num)\n \t  while (len < newlen)\n \t    new_ioffsets[len++] = -1;\n \t  \n-\t  ifaces[j]->idt->iface.ioffsets = new_ioffsets;\n+\t  ifaces[j]->ioffsets = new_ioffsets;\n \t}\n-      ifaces[j]->idt->iface.ioffsets[i] = offsets[j];\n+      ifaces[j]->ioffsets[i] = offsets[j];\n     }\n \n   _Jv_MutexUnlock (&iindex_mutex);"}]}