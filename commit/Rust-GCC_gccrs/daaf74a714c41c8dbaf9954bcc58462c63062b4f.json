{"sha": "daaf74a714c41c8dbaf9954bcc58462c63062b4f", "node_id": "C_kwDOANBUbNoAKGRhYWY3NGE3MTRjNDFjOGRiYWY5OTU0YmNjNTg0NjJjNjMwNjJiNGY", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-04T09:18:37Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-04T09:18:37Z"}, "message": "c-family: Fix up -Wsign-compare BIT_NOT_EXPR handling [PR107465]\n\nThe following patch fixes multiple bugs in warn_for_sign_compare related to\nthe BIT_NOT_EXPR related warnings.\nMy understanding is that what those 3 warnings are meant to warn (since 1995\napparently) is the case where we have BIT_NOT_EXPR of a zero-extended\nvalue, so in result_type the value is something like:\n0b11111111XXXXXXXX (e.g. ~ of a 8->16 bit zero extension)\n0b000000000000000011111111XXXXXXXX (e.g. ~ of a 8->16 bit zero extension\nthen zero extended to 32 bits)\n0b111111111111111111111111XXXXXXXX (e.g. ~ of a 8->16 bit zero extension\nthen sign extended to 32 bits)\nand the intention of the warning is to warn when this is compared against\nsomething that has some 0 bits at the place where the above has guaranteed\n1 bits, either ensured through comparison against constant where we know\nthe bits exactly, or through zero extension from some narrower type where\nagain we know at least some upper bits are zero extended.\nThe bugs in the warning code are:\n1) misunderstanding of the {,c_common_}get_narrower APIs - the unsignedp\n   it sets is only meaningful if the function actually returns something\n   narrower (in that case it says whether the narrower value is then\n   sign (0) or zero (1) extended to the originally passed value.\n   Though op0 or op1 at this point might be already narrower than\n   result_type, and if the function doesn't return anything narrower,\n   it all depends on whether the passed in op{0,1} had TYPE_UNSIGNED\n   type or not\n2) the code didn't check at all whether the BIT_NOT_EXPR operand\n   was actually zero extended (i.e. that it was narrower and unsignedp\n   was set to 1 for it), all it did is check that unsignedp from the\n   call was 1.  But that isn't well defined thing, if the argument\n   is returned as is, the function sets unsignedp to 0, but if there\n   is e.g. a useless cast to the same or compatible type in between,\n   it can return 1 if the cast is unsigned; now, if BIT_NOT_EXPR\n   operand is not zero extended, we know nothing at all about any bits\n   in the operand containing BIT_NOT_EXPR, so there is nothing to warn\n   about\n3) the code was actually testing both operands after calling\n   c_common_get_narrower on them and on the one with BIT_NOT_EXPR\n   again for constants; I think that is just wrong in case the BIT_NOT_EXPR\n   operand wouldn't be fully folded, the warning makes sense only if the\n   other operand not having BIT_NOT_EXPR in it is constant\n4) as can be seen from the above bit pattern examples, the upper bits above\n   (in the patch arg0) aren't always all 1s, there could be some zero extension\n   above it and from it one would have 0s, so that needs to be taken into\n   account for the choice which constant bits to test for being always set\n   otherwise warning is emitted, or for the zero extension guaranteed zero\n   bits\n5) the patch also simplifies the handling, we only do it if one but not\n   both operands are BIT_NOT_EXPR after first {,c_common_}get_narrower,\n   so we can just use std::swap to ensure it is the first one\n6) the code compared bits against HOST_BITS_PER_LONG, which made sense\n   back in 1995 when the values were stored into long, but now that they\n   are HOST_WIDE_INT should test HOST_BITS_PER_WIDE_INT (or we could rewrite\n   the stuff to wide_int, not done in the patch)\n\n2023-03-04  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c/107465\n\t* c-warn.cc (warn_for_sign_compare): If c_common_get_narrower\n\tdoesn't return a narrower result, use TYPE_UNSIGNED to set unsignedp0\n\tand unsignedp1.  For the one BIT_NOT_EXPR case vs. one without,\n\tonly check for constant in the non-BIT_NOT_EXPR operand, use std::swap\n\tto simplify the code, only warn if BIT_NOT_EXPR operand is extended\n\tfrom narrower unsigned, fix up computation of mask for the constant\n\tcases and for unsigned other operand case handle differently\n\tBIT_NOT_EXPR result being sign vs. zero extended.\n\n\t* c-c++-common/Wsign-compare-2.c: New test.\n\t* c-c++-common/pr107465.c: New test.", "tree": {"sha": "4561b73aeca9aec748d62ce16b9d4a54c461a409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4561b73aeca9aec748d62ce16b9d4a54c461a409"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/daaf74a714c41c8dbaf9954bcc58462c63062b4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daaf74a714c41c8dbaf9954bcc58462c63062b4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daaf74a714c41c8dbaf9954bcc58462c63062b4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daaf74a714c41c8dbaf9954bcc58462c63062b4f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db1405ddf566fe6129328229579b3f98a574b34c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db1405ddf566fe6129328229579b3f98a574b34c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db1405ddf566fe6129328229579b3f98a574b34c"}], "stats": {"total": 215, "additions": 184, "deletions": 31}, "files": [{"sha": "70d9bb20097fc5758ad5a3bccedabe986cf874b3", "filename": "gcc/c-family/c-warn.cc", "status": "modified", "additions": 56, "deletions": 31, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daaf74a714c41c8dbaf9954bcc58462c63062b4f/gcc%2Fc-family%2Fc-warn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daaf74a714c41c8dbaf9954bcc58462c63062b4f/gcc%2Fc-family%2Fc-warn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.cc?ref=daaf74a714c41c8dbaf9954bcc58462c63062b4f", "patch": "@@ -2345,42 +2345,50 @@ warn_for_sign_compare (location_t location,\n      have all bits set that are set in the ~ operand when it is\n      extended.  */\n \n-  op0 = c_common_get_narrower (op0, &unsignedp0);\n-  op1 = c_common_get_narrower (op1, &unsignedp1);\n+  tree arg0 = c_common_get_narrower (op0, &unsignedp0);\n+  if (TYPE_PRECISION (TREE_TYPE (arg0)) == TYPE_PRECISION (TREE_TYPE (op0)))\n+    unsignedp0 = TYPE_UNSIGNED (TREE_TYPE (op0));\n+  op0 = arg0;\n+  tree arg1 = c_common_get_narrower (op1, &unsignedp1);\n+  if (TYPE_PRECISION (TREE_TYPE (arg1)) == TYPE_PRECISION (TREE_TYPE (op1)))\n+    unsignedp1 = TYPE_UNSIGNED (TREE_TYPE (op1));\n+  op1 = arg1;\n \n   if ((TREE_CODE (op0) == BIT_NOT_EXPR)\n       ^ (TREE_CODE (op1) == BIT_NOT_EXPR))\n     {\n-      if (TREE_CODE (op0) == BIT_NOT_EXPR)\n-\top0 = c_common_get_narrower (TREE_OPERAND (op0, 0), &unsignedp0);\n       if (TREE_CODE (op1) == BIT_NOT_EXPR)\n-\top1 = c_common_get_narrower (TREE_OPERAND (op1, 0), &unsignedp1);\n-\n-      if (tree_fits_shwi_p (op0) || tree_fits_shwi_p (op1))\n \t{\n-\t  tree primop;\n-\t  HOST_WIDE_INT constant, mask;\n-\t  int unsignedp;\n-\t  unsigned int bits;\n+\t  std::swap (op0, op1);\n+\t  std::swap (unsignedp0, unsignedp1);\n+\t}\n \n-\t  if (tree_fits_shwi_p (op0))\n-\t    {\n-\t      primop = op1;\n-\t      unsignedp = unsignedp1;\n-\t      constant = tree_to_shwi (op0);\n-\t    }\n-\t  else\n-\t    {\n-\t      primop = op0;\n-\t      unsignedp = unsignedp0;\n-\t      constant = tree_to_shwi (op1);\n-\t    }\n+      int unsignedp;\n+      arg0 = c_common_get_narrower (TREE_OPERAND (op0, 0), &unsignedp);\n \n-\t  bits = TYPE_PRECISION (TREE_TYPE (primop));\n-\t  if (bits < TYPE_PRECISION (result_type)\n-\t      && bits < HOST_BITS_PER_LONG && unsignedp)\n+      /* For these warnings, we need BIT_NOT_EXPR operand to be\n+\t zero extended from narrower type to BIT_NOT_EXPR's type.\n+\t In that case, all those bits above the narrower's type\n+\t are after BIT_NOT_EXPR set to 1.  */\n+      if (tree_fits_shwi_p (op1))\n+\t{\n+\t  HOST_WIDE_INT constant = tree_to_shwi (op1);\n+\t  unsigned int bits = TYPE_PRECISION (TREE_TYPE (arg0));\n+\t  if (unsignedp\n+\t      && bits < TYPE_PRECISION (TREE_TYPE (op0))\n+\t      && bits < HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      mask = HOST_WIDE_INT_M1U << bits;\n+\t      HOST_WIDE_INT mask = HOST_WIDE_INT_M1U << bits;\n+\t      if (unsignedp0)\n+\t\t{\n+\t\t  bits = TYPE_PRECISION (TREE_TYPE (op0));\n+\t\t  if (bits < TYPE_PRECISION (result_type)\n+\t\t      && bits < HOST_BITS_PER_WIDE_INT)\n+\t\t    mask &= ~(HOST_WIDE_INT_M1U << bits);\n+\t\t}\n+\t      bits = TYPE_PRECISION (result_type);\n+\t      if (bits < HOST_BITS_PER_WIDE_INT)\n+\t\tmask &= ~(HOST_WIDE_INT_M1U << bits);\n \t      if ((mask & constant) != mask)\n \t\t{\n \t\t  if (constant == 0)\n@@ -2394,11 +2402,28 @@ warn_for_sign_compare (location_t location,\n \t\t}\n \t    }\n \t}\n-      else if (unsignedp0 && unsignedp1\n-\t       && (TYPE_PRECISION (TREE_TYPE (op0))\n-\t\t   < TYPE_PRECISION (result_type))\n+      else if ((TYPE_PRECISION (TREE_TYPE (arg0))\n+\t\t< TYPE_PRECISION (TREE_TYPE (op0)))\n+\t       && unsignedp\n+\t       && unsignedp1\n+\t       /* If unsignedp0, the BIT_NOT_EXPR result is\n+\t\t  zero extended, so say if op0 is unsigned char\n+\t\t  variable, BIT_NOT_EXPR is unsigned short and\n+\t\t  result type int and op0 has value 0x55, the\n+\t\t  int value will be 0xffaa, or for op0 0xaa it\n+\t\t  will be 0xff55.  In these cases, warn if\n+\t\t  op1 is unsigned and narrower than unsigned short.\n+\t\t  While if unsignedp0 is false, the BIT_NOT_EXPR\n+\t\t  result is sign extended and because of the\n+\t\t  above TYPE_PRECISION comparison we know the\n+\t\t  MSB of BIT_NOT_EXPR is set (perhaps with some\n+\t\t  further bits below it).  The sign extension will\n+\t\t  then ensure all bits above BIT_NOT_EXPR up to\n+\t\t  result_type's precision are set.  */\n \t       && (TYPE_PRECISION (TREE_TYPE (op1))\n-\t\t   < TYPE_PRECISION (result_type)))\n+\t\t   < TYPE_PRECISION (unsignedp0\n+\t\t\t\t     ? TREE_TYPE (op0)\n+\t\t\t\t     : result_type)))\n \twarning_at (location, OPT_Wsign_compare,\n \t\t    \"comparison of promoted bitwise complement \"\n \t\t    \"of an unsigned value with unsigned\");"}, {"sha": "23933d09cdc758b7bd85a27415702b3aa1c609c4", "filename": "gcc/testsuite/c-c++-common/Wsign-compare-2.c", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daaf74a714c41c8dbaf9954bcc58462c63062b4f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsign-compare-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daaf74a714c41c8dbaf9954bcc58462c63062b4f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsign-compare-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsign-compare-2.c?ref=daaf74a714c41c8dbaf9954bcc58462c63062b4f", "patch": "@@ -0,0 +1,106 @@\n+/* { dg-do compile { target { ilp32 || lp64 } } } */\n+/* { dg-options \"-Wsign-compare\" } */\n+\n+int\n+f1 (unsigned char x)\n+{\n+  return (unsigned short) (~(unsigned short) x) == 0;\t\t/* { dg-warning \"promoted bitwise complement of an unsigned value is always nonzero\" \"\" { target c } } */\n+}\n+\n+int\n+f2 (unsigned char x)\n+{\n+  return (unsigned short) (~(unsigned short) x) == 5;\t\t/* { dg-warning \"comparison of promoted bitwise complement of an unsigned value with constant\" \"\" { target c }  } */\n+}\n+\n+int\n+f3 (unsigned char x)\n+{\n+  return (unsigned int) (~(unsigned short) x) == 0xffff0005U;\t/* { dg-warning \"comparison of promoted bitwise complement of an unsigned value with constant\" } */\n+}\n+\n+int\n+f4 (unsigned char x)\n+{\n+  return (unsigned int) (~(unsigned short) x) == 0xffff0005ULL;\t/* { dg-warning \"comparison of promoted bitwise complement of an unsigned value with constant\" } */\n+}\n+\n+int\n+f5 (unsigned char x)\n+{\n+  return (unsigned int) (~(unsigned short) x) == 0xffffff05U;\t/* { dg-bogus \"comparison of promoted bitwise complement of an unsigned value with constant\" } */\n+}\n+\n+int\n+f6 (unsigned char x)\n+{\n+  return (unsigned int) (~(unsigned short) x) == 0xffffff05ULL;\t/* { dg-bogus \"comparison of promoted bitwise complement of an unsigned value with constant\" } */\n+}\n+\n+int\n+f7 (unsigned char x)\n+{\n+  return (unsigned long long) (~(unsigned short) x) == 0xffffffffffffff05ULL;\t/* { dg-bogus \"comparison of promoted bitwise complement of an unsigned value with constant\" } */\n+}\n+\n+typedef unsigned short T;\n+\n+int\n+f8 (T x)\n+{\n+  return (unsigned short) (~(unsigned short) x) == 0;\t\t/* { dg-bogus \"promoted bitwise complement of an unsigned value is always nonzero\" } */\n+}\n+\n+int\n+f9 (T x)\n+{\n+  return (unsigned short) (~(unsigned short) x) == 5;\t\t/* { dg-bogus \"comparison of promoted bitwise complement of an unsigned value with constant\" } */\n+}\n+\n+int\n+f10 (T x, unsigned char y)\n+{\n+  return (unsigned short) (~(unsigned short) x) == y;\t\t/* { dg-bogus \"comparison of promoted bitwise complement of an unsigned value with unsigned\" } */\n+}\n+\n+int\n+f11 (T x, unsigned char y)\n+{\n+  return (unsigned short) (~(unsigned short) x) == y;\t\t/* { dg-bogus \"comparison of promoted bitwise complement of an unsigned value with unsigned\" } */\n+}\n+\n+int\n+f12 (unsigned char x, unsigned char y)\n+{\n+  return (unsigned short) (~(unsigned short) x) == y;\t\t/* { dg-warning \"comparison of promoted bitwise complement of an unsigned value with unsigned\" \"\" { target c } } */\n+}\n+\n+int\n+f13 (unsigned char x, unsigned char y)\n+{\n+  return (unsigned short) (~(unsigned short) x) == y;\t\t/* { dg-warning \"comparison of promoted bitwise complement of an unsigned value with unsigned\" \"\" { target c } } */\n+}\n+\n+int\n+f14 (unsigned char x, unsigned int y)\n+{\n+  return (unsigned long long) (~x) == y;\t\t\t/* { dg-warning \"comparison of promoted bitwise complement of an unsigned value with unsigned\" } */\n+}\n+\n+int\n+f15 (unsigned short x, unsigned int y)\n+{\n+  return (long long) (~x) == y;\t\t\t\t\t/* { dg-warning \"comparison of promoted bitwise complement of an unsigned value with unsigned\" } */\n+}\n+\n+int\n+f16 (unsigned char x, unsigned short y)\n+{\n+  return (unsigned short) (~(unsigned short) x) == y;\t\t/* { dg-bogus \"comparison of promoted bitwise complement of an unsigned value with unsigned\" } */\n+}\n+\n+int\n+f17 (unsigned char x, unsigned short y)\n+{\n+  return (unsigned short) (~(unsigned short) x) == y;\t\t/* { dg-bogus \"comparison of promoted bitwise complement of an unsigned value with unsigned\" } */\n+}"}, {"sha": "7c9ff24bc83b98bbf8a5abe9100473b45ddbe076", "filename": "gcc/testsuite/c-c++-common/pr107465.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daaf74a714c41c8dbaf9954bcc58462c63062b4f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr107465.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daaf74a714c41c8dbaf9954bcc58462c63062b4f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr107465.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr107465.c?ref=daaf74a714c41c8dbaf9954bcc58462c63062b4f", "patch": "@@ -0,0 +1,22 @@\n+/* PR c/107465 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wsign-compare\" } */\n+\n+void baz (void);\n+typedef unsigned short T;\n+\n+#if __SIZEOF_SHORT__ * __CHAR_BIT__ == 16\n+void\n+foo (unsigned short x)\n+{\n+  if (!(x ^ 0xFFFF))\n+    baz ();\n+}\n+\n+void\n+bar (T x)\n+{\n+  if (!(x ^ 0xFFFF))\t/* { dg-bogus \"promoted bitwise complement of an unsigned value is always nonzero\" } */\n+    baz ();\n+}\n+#endif"}]}