{"sha": "56daab84ad1d63680d4f3b80fadec6a3c7b40fe8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZkYWFiODRhZDFkNjM2ODBkNGYzYjgwZmFkZWM2YTNjN2I0MGZlOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-05-08T09:48:22Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-08T09:48:22Z"}, "message": "alpha.c (tls_symbolic_operand_1): Use gcc_assert and gcc_unreachable as appropriate.\n\n\t* config/alpha/alpha.c (tls_symbolic_operand_1): Use gcc_assert\n\tand gcc_unreachable as appropriate.\n\t(get_aligned_mem, get_unaligned_address,\n\talpha_emit_set_long_const, alpha_emit_conditional_branch,\n\talpha_emit_setcc, alpha_emit_conditional_move,\n\talpha_lookup_xfloating_lib_func, alpha_compute_xfloating_mode_arg,\n\talpha_emit_xfloating_libcall, alpha_split_tfmode_pair,\n\talpha_expand_unaligned_load, alpha_expand_block_move,\n\talpha_expand_zap_mask, get_trap_mode_suffix,\n\tget_round_mode_suffix, get_some_local_dynamic_name,\n\tprint_operand_address, function_arg, alpha_return_in_memory,\n\tfunction_value, alpha_expand_builtin,\n\talpha_initial_elimination_offset, alpha_expand_epilogue,\n\tsummarize_insn, alpha_handle_trap_shadows, alphaev5_insn_pipe,\n\talphaev5_next_group, alpha_align_insns,\n\tunicosmk_initial_elimination_offset, unicosmk_unique_section,\n\tunicosmk_ssib_name): Likewise.\n\t* config/alpha/alpha.h (ASM_OUTPUT_ADDR_VEC_ELT): Likewise.\n\t* config/alpha/unicosmk.h (TRAMPOLINE_TEMPLATE,\n\tASM_OUTPUT_ADDR_DIFF_ELT, ASM_OUTPUT_ADDR_DIFF_VEC): Likewise.\n\t* config/alpha/vms.h (INITIAL_ELIMINATION_OFFSET,\n\tASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n\t* config/alpha/alpha.md (*divmodsi_internal_er,\n\t*divmoddi_internal_er, ashldi3, *insxl, sibcall, call_osf,\n\tcall_nt, call_umk, call_vms, call_value, sibcall_value,\n\tcall_value_osf, call_value_nt, call_value_vms, call_value_umk,\n\t*call_vms_1, *movmemdi_1, *clrmemdi_1, *call_value_vms_1): Likewise.\n\t* config/alpha/predicates.md (input_operand): Likewise.\n\nCo-Authored-By: Falk Hueffner <falk@debian.org>\n\nFrom-SVN: r99384", "tree": {"sha": "8f23164ad0cba276eb1854a16933382687027963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f23164ad0cba276eb1854a16933382687027963"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/comments", "author": null, "committer": null, "parents": [{"sha": "44e91694bda9e891e1eeac71bd5cda66d6acce25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44e91694bda9e891e1eeac71bd5cda66d6acce25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44e91694bda9e891e1eeac71bd5cda66d6acce25"}], "stats": {"total": 401, "additions": 220, "deletions": 181}, "files": [{"sha": "4786a4fc7cc50261485fcc71c3308128cd2c4212", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56daab84ad1d63680d4f3b80fadec6a3c7b40fe8", "patch": "@@ -1,3 +1,35 @@\n+2005-05-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Falk Hueffner  <falk@debian.org>\n+\n+\t* config/alpha/alpha.c (tls_symbolic_operand_1): Use gcc_assert\n+\tand gcc_unreachable as appropriate.\n+\t(get_aligned_mem, get_unaligned_address,\n+\talpha_emit_set_long_const, alpha_emit_conditional_branch,\n+\talpha_emit_setcc, alpha_emit_conditional_move,\n+\talpha_lookup_xfloating_lib_func, alpha_compute_xfloating_mode_arg,\n+\talpha_emit_xfloating_libcall, alpha_split_tfmode_pair,\n+\talpha_expand_unaligned_load, alpha_expand_block_move,\n+\talpha_expand_zap_mask, get_trap_mode_suffix,\n+\tget_round_mode_suffix, get_some_local_dynamic_name,\n+\tprint_operand_address, function_arg, alpha_return_in_memory,\n+\tfunction_value, alpha_expand_builtin,\n+\talpha_initial_elimination_offset, alpha_expand_epilogue,\n+\tsummarize_insn, alpha_handle_trap_shadows, alphaev5_insn_pipe,\n+\talphaev5_next_group, alpha_align_insns,\n+\tunicosmk_initial_elimination_offset, unicosmk_unique_section,\n+\tunicosmk_ssib_name): Likewise.\n+\t* config/alpha/alpha.h (ASM_OUTPUT_ADDR_VEC_ELT): Likewise.\n+\t* config/alpha/unicosmk.h (TRAMPOLINE_TEMPLATE,\n+\tASM_OUTPUT_ADDR_DIFF_ELT, ASM_OUTPUT_ADDR_DIFF_VEC): Likewise.\n+\t* config/alpha/vms.h (INITIAL_ELIMINATION_OFFSET,\n+\tASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n+\t* config/alpha/alpha.md (*divmodsi_internal_er,\n+\t*divmoddi_internal_er, ashldi3, *insxl, sibcall, call_osf,\n+\tcall_nt, call_umk, call_vms, call_value, sibcall_value,\n+\tcall_value_osf, call_value_nt, call_value_vms, call_value_umk,\n+\t*call_vms_1, *movmemdi_1, *clrmemdi_1, *call_value_vms_1): Likewise.\n+\t* config/alpha/predicates.md (input_operand): Likewise.\n+\n 2005-05-08  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/frv/frv.c (frv_default_flags_for_cpu): Use gcc_assert and"}, {"sha": "36f09c0105c53a1da56f8cb213a52f817d11a714", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 148, "deletions": 136, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=56daab84ad1d63680d4f3b80fadec6a3c7b40fe8", "patch": "@@ -596,7 +596,7 @@ tls_symbolic_operand_1 (rtx op, int size, int unspec)\n     case TLS_MODEL_LOCAL_EXEC:\n       return unspec == UNSPEC_TPREL;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1531,21 +1531,17 @@ get_aligned_mem (rtx ref, rtx *paligned_mem, rtx *pbitnum)\n   rtx base;\n   HOST_WIDE_INT offset = 0;\n \n-  if (GET_CODE (ref) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (ref) == MEM);\n \n   if (reload_in_progress\n       && ! memory_address_p (GET_MODE (ref), XEXP (ref, 0)))\n     {\n       base = find_replacement (&XEXP (ref, 0));\n \n-      if (! memory_address_p (GET_MODE (ref), base))\n-\tabort ();\n+      gcc_assert (memory_address_p (GET_MODE (ref), base));\n     }\n   else\n-    {\n-      base = XEXP (ref, 0);\n-    }\n+    base = XEXP (ref, 0);\n \n   if (GET_CODE (base) == PLUS)\n     offset += INTVAL (XEXP (base, 1)), base = XEXP (base, 0);\n@@ -1569,21 +1565,17 @@ get_unaligned_address (rtx ref, int extra_offset)\n   rtx base;\n   HOST_WIDE_INT offset = 0;\n \n-  if (GET_CODE (ref) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (ref) == MEM);\n \n   if (reload_in_progress\n       && ! memory_address_p (GET_MODE (ref), XEXP (ref, 0)))\n     {\n       base = find_replacement (&XEXP (ref, 0));\n \n-      if (! memory_address_p (GET_MODE (ref), base))\n-\tabort ();\n+      gcc_assert (memory_address_p (GET_MODE (ref), base));\n     }\n   else\n-    {\n-      base = XEXP (ref, 0);\n-    }\n+    base = XEXP (ref, 0);\n \n   if (GET_CODE (base) == PLUS)\n     offset += INTVAL (XEXP (base, 1)), base = XEXP (base, 0);\n@@ -2053,29 +2045,25 @@ alpha_emit_set_long_const (rtx target, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n \n   /* Decompose the entire word */\n #if HOST_BITS_PER_WIDE_INT >= 64\n-  if (c2 != -(c1 < 0))\n-    abort ();\n+  gcc_assert (c2 == -(c1 < 0));\n   d1 = ((c1 & 0xffff) ^ 0x8000) - 0x8000;\n   c1 -= d1;\n   d2 = ((c1 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n   c1 = (c1 - d2) >> 32;\n   d3 = ((c1 & 0xffff) ^ 0x8000) - 0x8000;\n   c1 -= d3;\n   d4 = ((c1 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-  if (c1 != d4)\n-    abort ();\n+  gcc_assert (c1 == d4);\n #else\n   d1 = ((c1 & 0xffff) ^ 0x8000) - 0x8000;\n   c1 -= d1;\n   d2 = ((c1 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-  if (c1 != d2)\n-    abort ();\n+  gcc_assert (c1 == d2);\n   c2 += (d2 < 0);\n   d3 = ((c2 & 0xffff) ^ 0x8000) - 0x8000;\n   c2 -= d3;\n   d4 = ((c2 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-  if (c2 != d4)\n-    abort ();\n+  gcc_assert (c2 == d4);\n #endif\n \n   /* Construct the high word */\n@@ -2513,8 +2501,7 @@ alpha_emit_conditional_branch (enum rtx_code code)\n \n   if (alpha_compare.fp_p && GET_MODE (op0) == TFmode)\n     {\n-      if (! TARGET_HAS_XFLOATING_LIBS)\n-\tabort ();\n+      gcc_assert (TARGET_HAS_XFLOATING_LIBS);\n \n       /* X_floating library comparison functions return\n \t   -1  unordered\n@@ -2579,7 +2566,7 @@ alpha_emit_conditional_branch (enum rtx_code code)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (alpha_compare.fp_p)\n@@ -2678,8 +2665,7 @@ alpha_emit_setcc (enum rtx_code code)\n \n   if (fp_p && GET_MODE (op0) == TFmode)\n     {\n-      if (! TARGET_HAS_XFLOATING_LIBS)\n-\tabort ();\n+      gcc_assert (TARGET_HAS_XFLOATING_LIBS);\n \n       /* X_floating library comparison functions return\n \t   -1  unordered\n@@ -2742,7 +2728,7 @@ alpha_emit_setcc (enum rtx_code code)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (!fp_p)\n@@ -2834,7 +2820,7 @@ alpha_emit_conditional_move (rtx cmp, enum machine_mode mode)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       tem = gen_reg_rtx (cmp_op_mode);\n@@ -2886,7 +2872,7 @@ alpha_emit_conditional_move (rtx cmp, enum machine_mode mode)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (!fp_p)\n@@ -3059,7 +3045,7 @@ alpha_lookup_xfloating_lib_func (enum rtx_code code)\n         return func;\n       }\n \n-  abort();\n+  gcc_unreachable ();\n }\n \n /* Most X_floating operations take the rounding mode as an argument.\n@@ -3086,7 +3072,7 @@ alpha_compute_xfloating_mode_arg (enum rtx_code code,\n       mode = 4;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n \n     /* XXX For reference, round to +inf is mode = 3.  */\n     }\n@@ -3134,16 +3120,15 @@ alpha_emit_xfloating_libcall (rtx func, rtx target, rtx operands[],\n \t  break;\n \n \tcase VOIDmode:\n-\t  if (GET_CODE (operands[i]) != CONST_INT)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (operands[i]) == CONST_INT);\n \t  /* FALLTHRU */\n \tcase DImode:\n \t  reg = gen_rtx_REG (DImode, regno);\n \t  regno += 1;\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       emit_move_insn (reg, operands[i]);\n@@ -3162,7 +3147,7 @@ alpha_emit_xfloating_libcall (rtx func, rtx target, rtx operands[],\n       reg = gen_rtx_REG (DImode, 0);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   tmp = gen_rtx_MEM (QImode, func);\n@@ -3265,33 +3250,42 @@ alpha_emit_xfloating_cvt (enum rtx_code orig_code, rtx operands[])\n void\n alpha_split_tfmode_pair (rtx operands[4])\n {\n-  if (GET_CODE (operands[1]) == REG)\n+  switch (GET_CODE (operands[1]))\n     {\n+    case REG:\n       operands[3] = gen_rtx_REG (DImode, REGNO (operands[1]) + 1);\n       operands[2] = gen_rtx_REG (DImode, REGNO (operands[1]));\n-    }\n-  else if (GET_CODE (operands[1]) == MEM)\n-    {\n+      break;\n+\n+    case MEM:\n       operands[3] = adjust_address (operands[1], DImode, 8);\n       operands[2] = adjust_address (operands[1], DImode, 0);\n+      break;\n+\n+    case CONST_FLOAT:\n+      gcc_assert (operands[1] == CONST0_RTX (TFmode));\n+      operands[2] = operands[3] = const0_rtx;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else if (operands[1] == CONST0_RTX (TFmode))\n-    operands[2] = operands[3] = const0_rtx;\n-  else\n-    abort ();\n \n-  if (GET_CODE (operands[0]) == REG)\n+  switch (GET_CODE (operands[0]))\n     {\n+    case REG:\n       operands[1] = gen_rtx_REG (DImode, REGNO (operands[0]) + 1);\n       operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n-    }\n-  else if (GET_CODE (operands[0]) == MEM)\n-    {\n+      break;\n+\n+    case MEM:\n       operands[1] = adjust_address (operands[0], DImode, 8);\n       operands[0] = adjust_address (operands[0], DImode, 0);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n }\n \n /* Implement negtf2 or abstf2.  Op0 is destination, op1 is source,\n@@ -3477,7 +3471,7 @@ alpha_expand_unaligned_load (rtx tgt, rtx mem, HOST_WIDE_INT size,\n \t      break;\n \n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t  emit_insn (gen_extxl_be (exth, memh, GEN_INT (size*8), addr));\n \t}\n@@ -3503,7 +3497,7 @@ alpha_expand_unaligned_load (rtx tgt, rtx mem, HOST_WIDE_INT size,\n \t      break;\n \n \t    default:\n-\t      abort();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n \n@@ -4029,8 +4023,7 @@ alpha_expand_block_move (rtx operands[])\n       ofs += 1;\n     }\n \n-  if (nregs > ARRAY_SIZE (data_regs))\n-    abort ();\n+  gcc_assert (nregs <= ARRAY_SIZE (data_regs));\n \n   /* Now save it back out again.  */\n \n@@ -4117,16 +4110,15 @@ alpha_expand_block_move (rtx operands[])\n \tofs += 2;\n       }\n \n-  while (i < nregs && GET_MODE (data_regs[i]) == QImode)\n+  /* The remainder must be byte copies.  */\n+  while (i < nregs)\n     {\n+      gcc_assert (GET_MODE (data_regs[i]) == QImode);\n       emit_move_insn (adjust_address (orig_dst, QImode, ofs), data_regs[i]);\n       i++;\n       ofs += 1;\n     }\n \n-  if (i != nregs)\n-    abort ();\n-\n   return 1;\n }\n \n@@ -4424,10 +4416,12 @@ alpha_expand_zap_mask (HOST_WIDE_INT value)\n \n       result = gen_int_mode (mask, DImode);\n     }\n-  else if (HOST_BITS_PER_WIDE_INT == 32)\n+  else\n     {\n       HOST_WIDE_INT mask_lo = 0, mask_hi = 0;\n \n+      gcc_assert (HOST_BITS_PER_WIDE_INT == 32);\n+      \n       for (i = 7; i >= 4; --i)\n \t{\n \t  mask_hi <<= 8;\n@@ -4444,8 +4438,6 @@ alpha_expand_zap_mask (HOST_WIDE_INT value)\n \n       result = immed_double_const (mask_lo, mask_hi, DImode);\n     }\n-  else\n-    abort ();\n \n   return result;\n }\n@@ -4699,8 +4691,9 @@ get_trap_mode_suffix (void)\n \tcase ALPHA_FPTM_SU:\n \tcase ALPHA_FPTM_SUI:\n \t  return \"sv\";\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      break;\n \n     case TRAP_SUFFIX_V_SV_SVI:\n       switch (alpha_fptm)\n@@ -4713,6 +4706,8 @@ get_trap_mode_suffix (void)\n \t  return \"sv\";\n \tcase ALPHA_FPTM_SUI:\n \t  return \"svi\";\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n@@ -4727,10 +4722,15 @@ get_trap_mode_suffix (void)\n \t  return \"su\";\n \tcase ALPHA_FPTM_SUI:\n \t  return \"sui\";\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n       break;\n+      \n+    default:\n+      gcc_unreachable ();\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Return the rounding mode suffix applicable to the current\n@@ -4756,13 +4756,18 @@ get_round_mode_suffix (void)\n \t  return \"c\";\n \tcase ALPHA_FPRM_DYN:\n \t  return \"d\";\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n     case ROUND_SUFFIX_C:\n       return \"c\";\n+      \n+    default:\n+      gcc_unreachable ();\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Locate some local-dynamic symbol still in use by this function\n@@ -4796,7 +4801,7 @@ get_some_local_dynamic_name (void)\n \t&& for_each_rtx (&PATTERN (insn), get_some_local_dynamic_name_1, 0))\n       return cfun->machine->some_ld_name;\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Print an operand.  Recognize special options, documented below.  */\n@@ -5205,46 +5210,56 @@ print_operand_address (FILE *file, rtx addr)\n \tfprintf (file, \"+\" HOST_WIDE_INT_PRINT_DEC, offset);\n \n       addr = XEXP (addr, 0);\n-      if (GET_CODE (addr) == REG)\n-\tbasereg = REGNO (addr);\n-      else if (GET_CODE (addr) == SUBREG\n-\t       && GET_CODE (SUBREG_REG (addr)) == REG)\n-\tbasereg = subreg_regno (addr);\n-      else\n-\tabort ();\n+      switch (GET_CODE (addr))\n+\t{\n+\tcase REG:\n+\t  basereg = REGNO (addr);\n+\t  break;\n+\n+\tcase SUBREG:\n+\t  basereg = subreg_regno (addr);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n       fprintf (file, \"($%d)\\t\\t!%s\", basereg,\n \t       (basereg == 29 ? reloc16 : reloclo));\n       return;\n     }\n \n-  if (GET_CODE (addr) == REG)\n-    basereg = REGNO (addr);\n-  else if (GET_CODE (addr) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (addr)) == REG)\n-    basereg = subreg_regno (addr);\n-  else if (GET_CODE (addr) == CONST_INT)\n-    offset = INTVAL (addr);\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      basereg = REGNO (addr);\n+      break;\n+\n+    case SUBREG:\n+      basereg = subreg_regno (addr);\n+      break;\n+\n+    case CONST_INT:\n+      offset = INTVAL (addr);\n+      break;\n \n #if TARGET_ABI_OPEN_VMS\n-  else if (GET_CODE (addr) == SYMBOL_REF)\n-    {\n+    case SYMBOL_REF:\n       fprintf (file, \"%s\", XSTR (addr, 0));\n       return;\n-    }\n-  else if (GET_CODE (addr) == CONST\n-\t   && GET_CODE (XEXP (addr, 0)) == PLUS\n-\t   && GET_CODE (XEXP (XEXP (addr, 0), 0)) == SYMBOL_REF)\n-    {\n+\n+    case CONST:\n+      gcc_assert (GET_CODE (XEXP (addr, 0)) == PLUS\n+\t\t  && GET_CODE (XEXP (XEXP (addr, 0), 0)) == SYMBOL_REF);\n       fprintf (file, \"%s+\" HOST_WIDE_INT_PRINT_DEC,\n \t       XSTR (XEXP (XEXP (addr, 0), 0), 0),\n \t       INTVAL (XEXP (XEXP (addr, 0), 1)));\n       return;\n-    }\n+    \n #endif\n-\n-  else\n-    abort ();\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   fprintf (file, HOST_WIDE_INT_PRINT_DEC \"($%d)\", offset, basereg);\n }\n@@ -5343,8 +5358,7 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n #ifdef ENABLE_CHECKING\n       /* With alpha_split_complex_arg, we shouldn't see any raw complex\n \t values here.  */\n-      if (COMPLEX_MODE_P (mode))\n-\tabort ();\n+      gcc_assert (!COMPLEX_MODE_P (mode));\n #endif\n \n       /* Set up defaults for FP operands passed in FP registers, and\n@@ -5514,8 +5528,9 @@ alpha_return_in_memory (tree type, tree fndecl ATTRIBUTE_UNUSED)\n \n     default:\n       /* ??? We get called on all sorts of random stuff from\n-\t aggregate_value_p.  We can't abort, but it's not clear\n-\t what's safe to return.  Pretend it's a struct I guess.  */\n+\t aggregate_value_p.  We must return something, but it's not\n+\t clear what's safe to return.  Pretend it's a struct I\n+\t guess.  */\n       return true;\n     }\n \n@@ -5549,10 +5564,7 @@ function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n   unsigned int regnum, dummy;\n   enum mode_class class;\n \n-#ifdef ENABLE_CHECKING\n-  if (valtype && alpha_return_in_memory (valtype, func))\n-    abort ();\n-#endif\n+  gcc_assert (!valtype || !alpha_return_in_memory (valtype, func));\n \n   if (valtype)\n     mode = TYPE_MODE (valtype);\n@@ -5587,7 +5599,7 @@ function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n       }\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return gen_rtx_REG (mode, regnum);\n@@ -6368,7 +6380,7 @@ alpha_expand_builtin (tree exp, rtx target,\n       pat = GEN_FCN (icode) (target, op[0], op[1]);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   if (!pat)\n     return NULL_RTX;\n@@ -7052,14 +7064,20 @@ alpha_initial_elimination_offset (unsigned int from,\n   ret = alpha_sa_size ();\n   ret += ALPHA_ROUND (current_function_outgoing_args_size);\n \n-  if (from == FRAME_POINTER_REGNUM)\n-    ;\n-  else if (from == ARG_POINTER_REGNUM)\n-    ret += (ALPHA_ROUND (get_frame_size ()\n-\t\t\t + current_function_pretend_args_size)\n-\t    - current_function_pretend_args_size);\n-  else\n-    abort ();\n+  switch (from)\n+    {\n+    case FRAME_POINTER_REGNUM:\n+      break;\n+\n+    case ARG_POINTER_REGNUM:\n+      ret += (ALPHA_ROUND (get_frame_size ()\n+\t\t\t   + current_function_pretend_args_size)\n+\t      - current_function_pretend_args_size);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   return ret;\n }\n@@ -7957,8 +7975,7 @@ alpha_expand_epilogue (void)\n \t\t so build it up by pieces.  */\n \t      FRP (sp_adj2 = alpha_emit_set_long_const (tmp, frame_size,\n \t\t\t\t\t\t\t-(frame_size < 0)));\n-\t      if (!sp_adj2)\n-\t\tabort ();\n+\t      gcc_assert (sp_adj2);\n \t    }\n \t}\n \n@@ -8334,7 +8351,7 @@ summarize_insn (rtx x, struct shadow_summary *sum, int set)\n \t    break;\n \n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n     }\n }\n@@ -8432,7 +8449,7 @@ alpha_handle_trap_shadows (void)\n \t\t  switch (GET_CODE (i))\n \t\t    {\n \t\t    case INSN:\n-\t\t      /* Annoyingly, get_attr_trap will abort on these.  */\n+\t\t      /* Annoyingly, get_attr_trap will die on these.  */\n \t\t      if (GET_CODE (PATTERN (i)) == USE\n \t\t\t  || GET_CODE (PATTERN (i)) == CLOBBER)\n \t\t\tbreak;\n@@ -8459,10 +8476,9 @@ alpha_handle_trap_shadows (void)\n \t\t\t  || (sum.defd.mem & shadow.used.mem))\n \t\t\t{\n \t\t\t  /* (a) would be violated (also takes care of (b))  */\n-\t\t\t  if (get_attr_trap (i) == TRAP_YES\n-\t\t\t      && ((sum.defd.i & sum.used.i)\n-\t\t\t\t  || (sum.defd.fp & sum.used.fp)))\n-\t\t\t    abort ();\n+\t\t\t  gcc_assert (get_attr_trap (i) != TRAP_YES\n+\t\t\t\t      || (!(sum.defd.i & sum.used.i)\n+\t\t\t\t\t  && !(sum.defd.fp & sum.used.fp)));\n \n \t\t\t  goto close_shadow;\n \t\t\t}\n@@ -8474,7 +8490,7 @@ alpha_handle_trap_shadows (void)\n \t\t      goto close_shadow;\n \n \t\t    default:\n-\t\t      abort ();\n+\t\t      gcc_unreachable ();\n \t\t    }\n \t\t}\n \t      else\n@@ -8567,7 +8583,7 @@ alphaev4_insn_pipe (rtx insn)\n       return EV4_IB1;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -8619,7 +8635,7 @@ alphaev5_insn_pipe (rtx insn)\n       return EV5_FM;\n \n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -8690,7 +8706,7 @@ alphaev4_next_group (rtx insn, int *pin_use, int *plen)\n \t  break;\n \n \tdefault:\n-\t  abort();\n+\t  gcc_unreachable ();\n \t}\n       len += 4;\n \n@@ -8760,11 +8776,11 @@ alphaev5_next_group (rtx insn, int *pin_use, int *plen)\n \t    len = get_attr_length (insn);\n \t  goto next_and_done;\n \n-\t/* ??? Most of the places below, we would like to abort, as\n-\t   it would indicate an error either in Haifa, or in the\n-\t   scheduling description.  Unfortunately, Haifa never\n-\t   schedules the last instruction of the BB, so we don't\n-\t   have an accurate TI bit to go off.  */\n+\t/* ??? Most of the places below, we would like to assert never\n+\t   happen, as it would indicate an error either in Haifa, or\n+\t   in the scheduling description.  Unfortunately, Haifa never\n+\t   schedules the last instruction of the BB, so we don't have\n+\t   an accurate TI bit to go off.  */\n \tcase EV5_E01:\n \t  if (in_use & EV5_E0)\n \t    {\n@@ -8819,7 +8835,7 @@ alphaev5_next_group (rtx insn, int *pin_use, int *plen)\n \t  break;\n \n \tdefault:\n-\t  abort();\n+\t  gcc_unreachable ();\n \t}\n       len += 4;\n \n@@ -8954,8 +8970,7 @@ alpha_align_insns (unsigned int max_align,\n \n \t  else if (ofs & (new_align-1))\n \t    ofs = (ofs | (new_align-1)) + 1;\n-\t  if (len != 0)\n-\t    abort();\n+\t  gcc_assert (!len);\n \t}\n \n       /* Handle complex instructions special.  */\n@@ -9542,7 +9557,7 @@ unicosmk_initial_elimination_offset (int from, int to)\n \t    + ALPHA_ROUND (get_frame_size()\n \t\t\t   + current_function_outgoing_args_size));\n   else\n-    abort ();\n+    gcc_unreachable ();\n }\n \n /* Output the module name for .ident and .end directives. We have to strip\n@@ -9626,8 +9641,7 @@ unicosmk_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n   const char *name;\n   int len;\n \n-  if (!decl)\n-    abort ();\n+  gcc_assert (decl);\n \n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n   name = default_strip_name_encoding (name);\n@@ -9777,11 +9791,9 @@ unicosmk_ssib_name (void)\n   int len;\n \n   x = DECL_RTL (cfun->decl);\n-  if (GET_CODE (x) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (x) == MEM);\n   x = XEXP (x, 0);\n-  if (GET_CODE (x) != SYMBOL_REF)\n-    abort ();\n+  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n   fnname = XSTR (x, 0);\n \n   len = strlen (fnname);"}, {"sha": "8d2974574a1693a2fca5284c3d87a25fb267d306", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=56daab84ad1d63680d4f3b80fadec6a3c7b40fe8", "patch": "@@ -1369,7 +1369,7 @@ do {\t\t\t\t\t\t\\\n /* This is how to output an element of a case-vector that is absolute.\n    (Alpha does not use such vectors, but we must define this macro anyway.)  */\n \n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) abort ()\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) gcc_unreachable ()\n \n /* This is how to output an element of a case-vector that is relative.  */\n "}, {"sha": "def77b4efeeaacbd92d5de6cf0bb294d7e1e5bc7", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 19, "deletions": 29, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=56daab84ad1d63680d4f3b80fadec6a3c7b40fe8", "patch": "@@ -1003,7 +1003,7 @@\n       str = \"__remlu\";\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   operands[4] = GEN_INT (alpha_next_sequence_number++);\n   emit_insn (gen_movdi_er_high_g (operands[0], pic_offset_table_rtx,\n@@ -1071,7 +1071,7 @@\n       str = \"__remqu\";\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   operands[4] = GEN_INT (alpha_next_sequence_number++);\n   emit_insn (gen_movdi_er_high_g (operands[0], pic_offset_table_rtx,\n@@ -1452,7 +1452,7 @@\n     case 1:\n       return \"sll %r1,%2,%0\";\n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"iadd,shift\")])\n@@ -2124,7 +2124,7 @@\n       == (unsigned HOST_WIDE_INT) INTVAL (operands[3]))\n     return \"insll %1,%s2,%0\";\n #endif\n-  abort();\n+  gcc_unreachable ();\n }\n   [(set_attr \"type\" \"shift\")])\n \n@@ -4497,8 +4497,7 @@\n \t      (unspec [(reg:DI 29)] UNSPEC_SIBCALL)])]\n   \"TARGET_ABI_OSF\"\n {\n-  if (GET_CODE (operands[0]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[0]) == MEM);\n   operands[0] = XEXP (operands[0], 0);\n })\n \n@@ -4509,8 +4508,7 @@\n \t      (clobber (reg:DI 26))])]\n   \"\"\n {\n-  if (GET_CODE (operands[0]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[0]) == MEM);\n \n   operands[0] = XEXP (operands[0], 0);\n   if (! call_operand (operands[0], Pmode))\n@@ -4523,8 +4521,7 @@\n \t      (clobber (reg:DI 26))])]\n   \"\"\n {\n-  if (GET_CODE (operands[0]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[0]) == MEM);\n \n   operands[0] = XEXP (operands[0], 0);\n   if (GET_CODE (operands[0]) != SYMBOL_REF && GET_CODE (operands[0]) != REG)\n@@ -4542,8 +4539,7 @@\n \t       (clobber (reg:DI 26))])]\n    \"\"\n {\n-  if (GET_CODE (operands[0]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[0]) == MEM);\n \n   /* Always load the address of the called function into a register;\n      load the CIW in $25.  */\n@@ -4569,8 +4565,7 @@\n \t      (clobber (reg:DI 27))])]\n   \"\"\n {\n-  if (GET_CODE (operands[0]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[0]) == MEM);\n \n   operands[0] = XEXP (operands[0], 0);\n \n@@ -4623,8 +4618,7 @@\n \t      (unspec [(reg:DI 29)] UNSPEC_SIBCALL)])]\n   \"TARGET_ABI_OSF\"\n {\n-  if (GET_CODE (operands[1]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[1]) == MEM);\n   operands[1] = XEXP (operands[1], 0);\n })\n \n@@ -4636,8 +4630,7 @@\n \t      (clobber (reg:DI 26))])]\n   \"\"\n {\n-  if (GET_CODE (operands[1]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[1]) == MEM);\n \n   operands[1] = XEXP (operands[1], 0);\n   if (! call_operand (operands[1], Pmode))\n@@ -4651,8 +4644,7 @@\n \t      (clobber (reg:DI 26))])]\n   \"\"\n {\n-  if (GET_CODE (operands[1]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[1]) == MEM);\n \n   operands[1] = XEXP (operands[1], 0);\n   if (GET_CODE (operands[1]) != SYMBOL_REF && GET_CODE (operands[1]) != REG)\n@@ -4669,8 +4661,7 @@\n \t      (clobber (reg:DI 27))])]\n   \"\"\n {\n-  if (GET_CODE (operands[1]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[1]) == MEM);\n \n   operands[1] = XEXP (operands[1], 0);\n \n@@ -4701,8 +4692,7 @@\n \t      (clobber (reg:DI 26))])]\n   \"\"\n {\n-  if (GET_CODE (operands[1]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[1]) == MEM);\n \n   operands[1] = XEXP (operands[1], 0);\n   if (GET_CODE (operands[1]) != REG)\n@@ -4902,7 +4892,7 @@\n \toperands [3] = alpha_use_linkage (operands [0], cfun->decl, 0, 0);\n    \treturn \"ldq $26,%3\\;ldq $27,%2\\;jsr $26,%0\\;ldq $27,0($29)\";\n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"jsr\")\n@@ -5639,7 +5629,7 @@\n \n ;; VMS needs to set up \"vms_base_regno\" for unwinding.  This move\n ;; often appears dead to the life analysis code, at which point we\n-;; abort for emitting dead prologue instructions.  Force this live.\n+;; die for emitting dead prologue instructions.  Force this live.\n \n (define_insn \"force_movdi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -6556,7 +6546,7 @@\n     case 1:\n \treturn \"lda $16,%0\\;lda $17,%2($31)\\;lda $18,%1\\;ldq $26,%5\\;lda $25,3($31)\\;jsr $26,%4\\;ldq $27,0($29)\";\n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"multi\")\n@@ -6613,7 +6603,7 @@\n     case 1:\n \treturn \"lda $16,%0\\;lda $17,%1($31)\\;ldq $26,%4\\;lda $25,2($31)\\;jsr $26,%3\\;ldq $27,0($29)\";\n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"multi\")\n@@ -8036,7 +8026,7 @@\n \toperands [4] = alpha_use_linkage (operands [1], cfun->decl, 0, 0);\n    \treturn \"ldq $26,%4\\;ldq $27,%3\\;jsr $26,%1\\;ldq $27,0($29)\";\n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"jsr\")"}, {"sha": "fe7b0a38b1e9ffca3366842f8754eda1ba09f1d4", "filename": "gcc/config/alpha/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2Fconfig%2Falpha%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2Fconfig%2Falpha%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fpredicates.md?ref=56daab84ad1d63680d4f3b80fadec6a3c7b40fe8", "patch": "@@ -231,7 +231,7 @@\n       return add_operand (op, mode);\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return 0;\n })\n@@ -506,7 +506,7 @@\n \n ;; Returns 1 if OP is not an eliminable register.\n ;;\n-;; This exists to cure a pathological abort in the s8addq (et al) patterns,\n+;; This exists to cure a pathological failure in the s8addq (et al) patterns,\n ;;\n ;;\tlong foo () { long t; bar(); return (long) &t * 26107; }\n ;;"}, {"sha": "22a69d5f144476f2e179370f8ac6eb53837e1bad", "filename": "gcc/config/alpha/unicosmk.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2Fconfig%2Falpha%2Funicosmk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2Fconfig%2Falpha%2Funicosmk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Funicosmk.h?ref=56daab84ad1d63680d4f3b80fadec6a3c7b40fe8", "patch": "@@ -230,7 +230,7 @@ do { fprintf (FILE, \"\\tbr $1,0\\n\");\t\t\t\\\n /* We don't support nested functions (yet).  */\n \n #undef TRAMPOLINE_TEMPLATE\n-#define TRAMPOLINE_TEMPLATE(FILE) abort ()\n+#define TRAMPOLINE_TEMPLATE(FILE) gcc_unreachable ()\n \f\n /* Specify the machine mode that this machine uses for the index in the\n    tablejump instruction. On Unicos/Mk, we don't support relative case\n@@ -374,7 +374,7 @@ ssib_section (void)\t\t\\\n    (Unicos/Mk does not use such vectors yet).  */\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) abort ()\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) gcc_unreachable ()\n \n /* We can't output case vectors in the same section as the function code\n    because CAM doesn't allow data definitions in code sections. Thus, we\n@@ -384,7 +384,7 @@ ssib_section (void)\t\t\\\n #define ASM_OUTPUT_ADDR_VEC(LAB,VEC) \\\n   unicosmk_defer_case_vector ((LAB),(VEC))\n \n-#define ASM_OUTPUT_ADDR_DIFF_VEC(LAB,VEC) abort ()\n+#define ASM_OUTPUT_ADDR_DIFF_VEC(LAB,VEC) gcc_unreachable ()\n \n /* This is how to output an assembler line that says to advance the location\n    counter to a multiple of 2**LOG bytes. Annoyingly, CAM always uses zeroes"}, {"sha": "5bc899abc953530d72733ff57235f973dcbf01ef", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56daab84ad1d63680d4f3b80fadec6a3c7b40fe8/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=56daab84ad1d63680d4f3b80fadec6a3c7b40fe8", "patch": "@@ -136,15 +136,20 @@ Boston, MA 02111-1307, USA.  */\n \n #undef INITIAL_ELIMINATION_OFFSET\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n-{ if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t\t\\\n-    (OFFSET) = alpha_sa_size () + alpha_pv_save_size ();\t\t\\\n-  else if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\\\n-    (OFFSET) = (ALPHA_ROUND (alpha_sa_size () + alpha_pv_save_size ()\t\\\n-\t\t\t     + get_frame_size ()\t\t\t\\\n-\t\t\t     + current_function_pretend_args_size)\t\\\n-\t\t- current_function_pretend_args_size);\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    abort();\t\t\t\t\t\t\t\t\\\n+{ switch (FROM)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case FRAME_POINTER_REGNUM:\t\t\t\t\t\t\\\n+      (OFFSET) = alpha_sa_size () + alpha_pv_save_size ();\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case ARG_POINTER_REGNUM:\t\t\t\t\t\t\\\n+      (OFFSET) = (ALPHA_ROUND (alpha_sa_size () + alpha_pv_save_size ()\t\\\n+\t\t\t       + get_frame_size ()\t\t\t\\\n+\t\t\t       + current_function_pretend_args_size)\t\\\n+\t\t  - current_function_pretend_args_size);\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      gcc_unreachable ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\t\\\n     (OFFSET) += ALPHA_ROUND (current_function_outgoing_args_size);\t\\\n }\n@@ -227,7 +232,7 @@ extern void link_section (void);\n extern void literals_section (void);\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) abort ()\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) gcc_unreachable ()\n \n #undef ASM_OUTPUT_ADDR_VEC_ELT\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\"}]}