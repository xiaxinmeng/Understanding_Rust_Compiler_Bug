{"sha": "10e77af221ac8dc12cd2c414e77559ce9da9e082", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBlNzdhZjIyMWFjOGRjMTJjZDJjNDE0ZTc3NTU5Y2U5ZGE5ZTA4Mg==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2007-06-06T10:35:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:35:54Z"}, "message": "a-clrefi.adb, [...]: New files\n\n2007-04-20  Vincent Celier  <celier@adacore.com>\n\t    Arnaud Charlet  <charlet@adacore.com>\n\n\t* a-clrefi.adb, a-clrefi.ads: New files\n\n\t* impunit.adb: Add s-os_lib in the list of user visible units.\n\t(Non_Imp_File_Names_95): Add a-clrefi to this list\n\tRemove obsolete run-time entries.\n\t(Non_Imp_File_Names_05): Add Ada 2005 entries for:\n\t \"a-exetim\" -- Ada.Execution_Time\n\t \"a-extiti\" -- Ada.Execution_Time.Timers\n\n\t* mlib-prj.ads, mlib-prj.adb\n\t(Build_Library): Use untouched object dir and library dir. At the\n\tsame time makes sure that the checks are done using the canonical\n\tform. Removes hard-coded directory separator and use the proper host\n\tone instead.\n\t(Process_Project): Do not look in object directory to check if libgnarl\n\tis needed for a library, if there is no object directory.\n\t(Build_Library): Scan the ALI files to decide if libgnarl is needed for\n\tlinking.\n\t(Build_Library): When invoking gnatbind, use a response file if the\n\ttotal size of the arguments is too large.\n\n\t* Makefile.rtl: (g-sttsne): New object file.\n\tAdd entry for a-clrefi, s-utf_32, System.Exceptions\n\n\t* Make-lang.in: Remove bogus dependency of s-memory.o on memtrack.o.\n\t(GNAT_ADA_OBJS, GNATBIND_OBJS): Add s-except.o.\n\t(GNATBIND_OBJS): Add new objects a-clrefi.o and a-comlin.o\n\tChange g-string to s-string, g-os_lib to s-os_lib\n\tChange all g-utf_32 references to s-utf_32\n\nFrom-SVN: r125427", "tree": {"sha": "2976184ea91da428f6c12161c5aeef9012d00b26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2976184ea91da428f6c12161c5aeef9012d00b26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10e77af221ac8dc12cd2c414e77559ce9da9e082", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e77af221ac8dc12cd2c414e77559ce9da9e082", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10e77af221ac8dc12cd2c414e77559ce9da9e082", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e77af221ac8dc12cd2c414e77559ce9da9e082/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "26fa2a35f5069fc553bbbadbdb92b786220be7f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26fa2a35f5069fc553bbbadbdb92b786220be7f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26fa2a35f5069fc553bbbadbdb92b786220be7f5"}], "stats": {"total": 2143, "additions": 1501, "deletions": 642}, "files": [{"sha": "967742d9fa9da822d9e09ad374a0a58fa38cb032", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 449, "deletions": 428, "changes": 877, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=10e77af221ac8dc12cd2c414e77559ce9da9e082"}, {"sha": "c60bffbe447b93de8319b38439f0354aeb06bdda", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=10e77af221ac8dc12cd2c414e77559ce9da9e082", "patch": "@@ -1,5 +1,5 @@\n # Makefile.rtl for GNU Ada Compiler (GNAT).\n-#   Copyright (C) 2003-2005, Free Software Foundation, Inc.\n+#   Copyright (C) 2003-2007, Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -100,6 +100,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-ciorma$(objext) \\\n   a-ciormu$(objext) \\\n   a-ciorse$(objext) \\\n+  a-clrefi$(objext) \\\n   a-cohama$(objext) \\\n   a-cohase$(objext) \\\n   a-cohata$(objext) \\\n@@ -366,6 +367,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-sptavs$(objext) \\\n   g-string$(objext) \\\n   g-strspl$(objext) \\\n+  g-sttsne$(objext) \\\n   g-table$(objext) \\\n   g-tasloc$(objext) \\\n   g-traceb$(objext) \\\n@@ -409,6 +411,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-dsaser$(objext) \\\n   s-errrep$(objext) \\\n   s-exctab$(objext) \\\n+  s-except$(objext) \\\n   s-exnint$(objext) \\\n   s-exnllf$(objext) \\\n   s-exnlli$(objext) \\\n@@ -454,6 +457,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-maccod$(objext) \\\n   s-mantis$(objext) \\\n   s-mastop$(objext) \\\n+  s-os_lib$(objext) \\\n   s-osprim$(objext) \\\n   s-pack03$(objext) \\\n   s-pack05$(objext) \\\n@@ -519,6 +523,8 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-poosiz$(objext) \\\n   s-powtab$(objext) \\\n   s-purexc$(objext) \\\n+  s-regexp$(objext) \\\n+  s-regpat$(objext) \\\n   s-restri$(objext) \\\n   s-rident$(objext) \\\n   s-rpc$(objext)    \\\n@@ -540,10 +546,13 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-soflin$(objext) \\\n   s-memory$(objext) \\\n   s-memcop$(objext) \\\n+  s-string$(objext) \\\n+  s-tasloc$(objext) \\\n   s-traceb$(objext) \\\n   s-traces$(objext) \\\n   s-traent$(objext) \\\n   s-unstyp$(objext) \\\n+  s-utf_32$(objext) \\\n   s-vaflop$(objext) \\\n   s-valboo$(objext) \\\n   s-valcha$(objext) \\"}, {"sha": "0b125e2b2ee5452791b6021ab7a085efd30a93f7", "filename": "gcc/ada/a-clrefi.adb", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2Fa-clrefi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2Fa-clrefi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-clrefi.adb?ref=10e77af221ac8dc12cd2c414e77559ce9da9e082", "patch": "@@ -0,0 +1,521 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--       A D A . C O M M A N D _ L I N E . R E S P O N S E _ F I L E        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2007, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+with System.OS_Lib; use System.OS_Lib;\n+\n+package body Ada.Command_Line.Response_File is\n+\n+   type File_Rec;\n+   type File_Ptr is access File_Rec;\n+   type File_Rec is record\n+      Name : String_Access;\n+      Next : File_Ptr;\n+      Prev : File_Ptr;\n+   end record;\n+   --  To build a stack of response file names\n+\n+   procedure Free is new Ada.Unchecked_Deallocation (File_Rec, File_Ptr);\n+\n+   type Argument_List_Access is access Argument_List;\n+   procedure Free is new Ada.Unchecked_Deallocation\n+     (Argument_List, Argument_List_Access);\n+   --  Free only the allocated Argument_List, not the allocated String\n+   --  components.\n+\n+   --------------------\n+   -- Arguments_From --\n+   --------------------\n+\n+   function Arguments_From\n+     (Response_File_Name        : String;\n+      Recursive                 : Boolean := False;\n+      Ignore_Non_Existing_Files : Boolean := False)\n+      return Argument_List\n+   is\n+      First_File : File_Ptr := null;\n+      Last_File  : File_Ptr := null;\n+      --  The stack of response files\n+\n+      Arguments  : Argument_List_Access := new Argument_List (1 .. 4);\n+      Last_Arg   : Natural := 0;\n+\n+      procedure Add_Argument (Arg : String);\n+      --  Add argument Arg to argument list Arguments, increasing Arguments\n+      --  if necessary.\n+\n+      procedure Recurse (File_Name : String);\n+      --  Get the arguments from the file and call itself recursively if\n+      --  one of the argument starts with character '@'.\n+\n+      ------------------\n+      -- Add_Argument --\n+      ------------------\n+\n+      procedure Add_Argument (Arg : String) is\n+      begin\n+         if Last_Arg = Arguments'Last then\n+            declare\n+               New_Arguments : constant Argument_List_Access :=\n+                                 new Argument_List (1 .. Arguments'Last * 2);\n+            begin\n+               New_Arguments (Arguments'Range) := Arguments.all;\n+               Arguments.all := (others => null);\n+               Free (Arguments);\n+               Arguments := New_Arguments;\n+            end;\n+         end if;\n+\n+         Last_Arg := Last_Arg + 1;\n+         Arguments (Last_Arg) := new String'(Arg);\n+      end Add_Argument;\n+\n+      -------------\n+      -- Recurse --\n+      -------------\n+\n+      procedure Recurse (File_Name : String) is\n+         FD : File_Descriptor;\n+\n+         Buffer_Size : constant := 1500;\n+         Buffer : String (1 .. Buffer_Size);\n+\n+         Buffer_Length : Natural;\n+\n+         Buffer_Cursor : Natural;\n+\n+         End_Of_File_Reached : Boolean;\n+\n+         Line : String (1 .. Max_Line_Length + 1);\n+         Last : Natural;\n+\n+         First_Char : Positive;\n+         --  Index of the first character of an argument in Line\n+\n+         Last_Char  : Natural;\n+         --  Index of the last character of an argument in Line\n+\n+         In_String : Boolean;\n+         --  True when inside a quoted string\n+\n+         Arg  : Positive;\n+\n+         function End_Of_File return Boolean;\n+         --  True when the end of the response file has been reached\n+\n+         procedure Get_Buffer;\n+         --  Read one buffer from the response file\n+\n+         procedure Get_Line;\n+         --  Get one line from the response file\n+\n+         -----------------\n+         -- End_Of_File --\n+         -----------------\n+\n+         function End_Of_File return Boolean is\n+         begin\n+            return End_Of_File_Reached and then Buffer_Cursor > Buffer_Length;\n+         end End_Of_File;\n+\n+         ----------------\n+         -- Get_Buffer --\n+         ----------------\n+\n+         procedure Get_Buffer is\n+         begin\n+            Buffer_Length := Read (FD, Buffer (1)'Address, Buffer'Length);\n+            End_Of_File_Reached := Buffer_Length < Buffer'Length;\n+            Buffer_Cursor := 1;\n+         end Get_Buffer;\n+\n+         --------------\n+         -- Get_Line --\n+         --------------\n+\n+         procedure Get_Line is\n+            Ch : Character;\n+         begin\n+            Last := 0;\n+\n+            if End_Of_File then\n+               return;\n+            end if;\n+\n+            loop\n+               Ch := Buffer (Buffer_Cursor);\n+\n+               exit when Ch = ASCII.CR or else\n+                         Ch = ASCII.LF or else\n+                         Ch = ASCII.FF;\n+\n+               Last := Last + 1;\n+               Line (Last) := Ch;\n+\n+               if Last = Line'Last then\n+                  return;\n+               end if;\n+\n+               Buffer_Cursor := Buffer_Cursor + 1;\n+\n+               if Buffer_Cursor > Buffer_Length then\n+                  Get_Buffer;\n+\n+                  if End_Of_File then\n+                     return;\n+                  end if;\n+               end if;\n+            end loop;\n+\n+            loop\n+               Ch := Buffer (Buffer_Cursor);\n+\n+               exit when Ch /= ASCII.HT and then\n+                         Ch /= ASCII.LF and then\n+                         Ch /= ASCII.FF;\n+\n+               Buffer_Cursor := Buffer_Cursor + 1;\n+\n+               if Buffer_Cursor > Buffer_Length then\n+                  Get_Buffer;\n+\n+                  if End_Of_File then\n+                     return;\n+                  end if;\n+               end if;\n+            end loop;\n+         end Get_Line;\n+\n+      --  Start or Recurse\n+\n+      begin\n+         Last_Arg := 0;\n+\n+         --  Open the response file. If not found, fail or report a warning,\n+         --  depending on the value of Ignore_Non_Existing_Files.\n+\n+         FD := Open_Read (File_Name, Text);\n+\n+         if FD = Invalid_FD then\n+            if Ignore_Non_Existing_Files then\n+               return;\n+\n+            else\n+               raise File_Does_Not_Exist;\n+            end if;\n+         end if;\n+\n+         --  Put the response file name on the stack\n+\n+         if First_File = null then\n+            First_File :=\n+              new File_Rec'\n+                (Name => new String'(File_Name),\n+                 Next => null,\n+                 Prev => null);\n+            Last_File  := First_File;\n+         else\n+            declare\n+               Current : File_Ptr := First_File;\n+            begin\n+               loop\n+                  if Current.Name.all = File_Name then\n+                     raise Circularity_Detected;\n+                  end if;\n+\n+                  Current := Current.Next;\n+                  exit when Current = null;\n+               end loop;\n+\n+               Last_File.Next :=\n+                 new File_Rec'\n+                   (Name => new String'(File_Name),\n+                    Next => null,\n+                    Prev => Last_File);\n+               Last_File := Last_File.Next;\n+            end;\n+         end if;\n+\n+         End_Of_File_Reached := False;\n+         Get_Buffer;\n+\n+         --  Read the response file line by line\n+\n+         Line_Loop :\n+         while not End_Of_File loop\n+            Get_Line;\n+\n+            if Last = Line'Last then\n+               raise Line_Too_Long;\n+            end if;\n+\n+            First_Char := 1;\n+\n+            --  Get each argument on the line\n+\n+            Arg_Loop :\n+            loop\n+               --  First, skip any white space\n+\n+               while First_Char <= Last loop\n+                  exit when Line (First_Char) /= ' ' and then\n+                            Line (First_Char) /= ASCII.HT;\n+                  First_Char := First_Char + 1;\n+               end loop;\n+\n+               exit Arg_Loop when First_Char > Last;\n+\n+               Last_Char := First_Char;\n+               In_String := False;\n+\n+               --  Get the character one by one\n+\n+               Character_Loop :\n+               while Last_Char <= Last loop\n+                  --  Inside a string, check only for '\"'\n+\n+                  if In_String then\n+                     if Line (Last_Char) = '\"' then\n+                        --  Remove the '\"'\n+\n+                        Line (Last_Char .. Last - 1) :=\n+                          Line (Last_Char + 1 .. Last);\n+                        Last := Last - 1;\n+\n+                        --  End of string is end of argument\n+                        if Last_Char > Last or else\n+                          Line (Last_Char) = ' ' or else\n+                          Line (Last_Char) = ASCII.HT\n+                        then\n+                           In_String := False;\n+\n+                           Last_Char := Last_Char - 1;\n+                           exit Character_Loop;\n+\n+                        else\n+                           --  If there are two consecutive '\"', the quoted\n+                           --  string is not closed\n+\n+                           In_String := Line (Last_Char) = '\"';\n+\n+                           if In_String then\n+                              Last_Char := Last_Char + 1;\n+                           end if;\n+                        end if;\n+\n+                     else\n+                        Last_Char := Last_Char + 1;\n+                     end if;\n+\n+                  elsif Last_Char = Last then\n+                     --  An opening '\"' at the end of the line is an error\n+\n+                     if Line (Last) = '\"' then\n+                        raise No_Closing_Quote;\n+\n+                     else\n+                        --  The argument ends with the line\n+\n+                        exit Character_Loop;\n+                     end if;\n+\n+                  elsif Line (Last_Char) = '\"' then\n+                     --  Entering a quoted string: remove the '\"'\n+\n+                     In_String := True;\n+                     Line (Last_Char .. Last - 1) :=\n+                       Line (Last_Char + 1 .. Last);\n+                     Last := Last - 1;\n+\n+                  else\n+                     --  Outside of quoted strings, white space ends the\n+                     --  argument.\n+\n+                     exit Character_Loop\n+                          when Line (Last_Char + 1) = ' ' or else\n+                               Line (Last_Char + 1) = ASCII.HT;\n+\n+                     Last_Char := Last_Char + 1;\n+                  end if;\n+               end loop Character_Loop;\n+\n+               --  It is an error to not close a quoted string before the end\n+               --  of the line.\n+\n+               if In_String then\n+                  raise No_Closing_Quote;\n+               end if;\n+\n+               --  Add the argument to the list\n+\n+               declare\n+                  Arg : String (1 .. Last_Char - First_Char + 1);\n+               begin\n+                  Arg := Line (First_Char .. Last_Char);\n+                  Add_Argument (Arg);\n+               end;\n+\n+               --  Next argument, if line is not finished\n+\n+               First_Char := Last_Char + 1;\n+            end loop Arg_Loop;\n+         end loop Line_Loop;\n+\n+         Close (FD);\n+\n+         --  If Recursive is True, check for any argument starting with '@'\n+\n+         if Recursive then\n+            Arg := 1;\n+            while Arg <= Last_Arg loop\n+\n+               if Arguments (Arg)'Length > 0 and then\n+                  Arguments (Arg) (1) = '@'\n+               then\n+                  --  Ignore argument \"@\" with no file name\n+\n+                  if Arguments (Arg)'Length = 1 then\n+                     Arguments (Arg .. Last_Arg - 1) :=\n+                       Arguments (Arg + 1 .. Last_Arg);\n+                     Last_Arg := Last_Arg - 1;\n+\n+                  else\n+                     --  Save the current arguments and get those in the\n+                     --  new response file.\n+\n+                     declare\n+                        Inc_File_Name     : constant String :=\n+                                              Arguments (Arg)\n+                                              (2 .. Arguments (Arg)'Last);\n+                        Current_Arguments : constant Argument_List :=\n+                                              Arguments (1 .. Last_Arg);\n+                     begin\n+                        Recurse (Inc_File_Name);\n+\n+                        --  Insert the new arguments where the new response\n+                        --  file was imported.\n+\n+                        declare\n+                           New_Arguments : constant Argument_List :=\n+                                             Arguments (1 .. Last_Arg);\n+                           New_Last_Arg  : constant Positive :=\n+                                             Current_Arguments'Length +\n+                                             New_Arguments'Length - 1;\n+\n+                        begin\n+                           --  Grow Arguments if it is not large enough\n+                           if Arguments'Last < New_Last_Arg then\n+                              Last_Arg := Arguments'Last;\n+                              Free (Arguments);\n+\n+                              while Last_Arg < New_Last_Arg loop\n+                                 Last_Arg := Last_Arg * 2;\n+                              end loop;\n+\n+                              Arguments := new Argument_List (1 .. Last_Arg);\n+                           end if;\n+\n+                           Last_Arg := New_Last_Arg;\n+\n+                           Arguments (1 .. Last_Arg) :=\n+                             Current_Arguments (1 .. Arg - 1) &\n+                           New_Arguments &\n+                           Current_Arguments\n+                             (Arg + 1 .. Current_Arguments'Last);\n+\n+                           Arg := Arg + New_Arguments'Length;\n+                        end;\n+                     end;\n+                  end if;\n+\n+               else\n+                  Arg := Arg + 1;\n+               end if;\n+            end loop;\n+         end if;\n+\n+         --  Remove the response file name from the stack\n+\n+         if First_File = Last_File then\n+            System.Strings.Free (First_File.Name);\n+            Free (First_File);\n+            First_File := null;\n+            Last_File := null;\n+\n+         else\n+            System.Strings.Free (Last_File.Name);\n+            Last_File := Last_File.Prev;\n+            Free (Last_File.Next);\n+         end if;\n+\n+      exception\n+         when others =>\n+            Close (FD);\n+\n+            raise;\n+      end Recurse;\n+\n+   --  Start of Arguments_From\n+\n+   begin\n+      --  The job is done by procedure Recurse\n+\n+      Recurse (Response_File_Name);\n+\n+      --  Free Arguments before returning the result\n+\n+      declare\n+         Result : constant Argument_List := Arguments (1 .. Last_Arg);\n+      begin\n+         Free (Arguments);\n+         return Result;\n+      end;\n+\n+   exception\n+      when others =>\n+         --  When an exception occurs, deallocate everything\n+\n+         Free (Arguments);\n+\n+         while First_File /= null loop\n+            Last_File := First_File.Next;\n+            System.Strings.Free (First_File.Name);\n+            Free (First_File);\n+            First_File := Last_File;\n+         end loop;\n+\n+         raise;\n+   end Arguments_From;\n+\n+end Ada.Command_Line.Response_File;"}, {"sha": "65edf344e9667dedfe54b75b03e45f516f87d5c0", "filename": "gcc/ada/a-clrefi.ads", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2Fa-clrefi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2Fa-clrefi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-clrefi.ads?ref=10e77af221ac8dc12cd2c414e77559ce9da9e082", "patch": "@@ -0,0 +1,100 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--       A D A . C O M M A N D _ L I N E . R E S P O N S E _ F I L E        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2007, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package is intended to be used in conjunction with its parent unit,\n+--  Ada.Command_Line. It provides facilities for getting command line arguments\n+--  from a text file, called a \"response file\".\n+--\n+--  Using a response file allow passing a set of arguments to an executable\n+--  longer than the maximum allowed by the system on the command line.\n+\n+with System.Strings;\n+\n+package Ada.Command_Line.Response_File is\n+\n+   subtype String_Access is System.Strings.String_Access;\n+   --  type String_Access is access all String;\n+\n+   procedure Free (S : in out String_Access) renames System.Strings.Free;\n+   --  To deallocate a String\n+\n+   subtype Argument_List is System.Strings.String_List;\n+   --  type String_List is array (Positive range <>) of String_Access;\n+\n+   Max_Line_Length : constant := 4096;\n+   --  The maximum length of lines in a response file\n+\n+   File_Does_Not_Exist : exception;\n+   --  Raise by Arguments_From when a response file cannot be found\n+\n+   Line_Too_Long : exception;\n+   --  Raise by Arguments_From when a line in the response file is longer than\n+   --  Max_Line_Length.\n+\n+   No_Closing_Quote : exception;\n+   --  Raise by Arguments_From when a quoted string does not end before the\n+   --  end of the line.\n+\n+   Circularity_Detected : exception;\n+   --  Raise by Arguments_From when Recursive is True and the same response\n+   --  file is reading itself, either directly or indirectly.\n+\n+   function Arguments_From\n+     (Response_File_Name        : String;\n+      Recursive                 : Boolean := False;\n+      Ignore_Non_Existing_Files : Boolean := False)\n+      return Argument_List;\n+   --  Read response file with name Response_File_Name and return the argument\n+   --  it contains as an Argument_List. It is the responsibility of the caller\n+   --  to deallocate the strings in the Argument_List if desired. When\n+   --  Recursive is True, any argument of the form @file_name indicates the\n+   --  name of another response file and is replaced by the arguments in this\n+   --  response file.\n+   --\n+   --  Each non empty line of the response file contains one or several\n+   --  arguments sparated by white space. Empty lines or lines containing only\n+   --  white space are ignored. Arguments containing white space or a double\n+   --  quote ('\"')must be quoted. A double quote inside a quote string is\n+   --  indicated by two consecutive double quotes. Example: \"-Idir with quote\n+   --  \"\" and spaces\" Non white space characters immediately before or after a\n+   --  quoted string are part of the same argument. Example -Idir\" with \"spaces\n+   --\n+   --  When a response file cannot be found, exception File_Does_Not_Exist is\n+   --  raised if Ignore_Non_Existing_Files is False, otherwise the response\n+   --  file is ignored. Exception Line_Too_Long is raised when a line of a\n+   --  response file is longer than Max_Line_Length. Exception No_Closing_Quote\n+   --  is raised when a quoted argument is not closed before the end of the\n+   --  line. Exception Circularity_Detected is raised when a Recursive is True\n+   --  and a response file is reading itself, either directly or indirectly.\n+\n+end Ada.Command_Line.Response_File;"}, {"sha": "e42698e1ba6360fea219ef1983cc684a4f35c402", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=10e77af221ac8dc12cd2c414e77559ce9da9e082", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2000-2006, Free Software Foundation, Inc.        --\n+--           Copyright (C) 2000-2007, Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -145,6 +145,7 @@ package body Impunit is\n    -----------------------------------\n \n      \"a-chlat9\",    -- Ada.Characters.Latin_9\n+     \"a-clrefi\",    -- Ada.Command_Line.Response_File\n      \"a-colien\",    -- Ada.Command_Line.Environment\n      \"a-colire\",    -- Ada.Command_Line.Remove\n      \"a-cwila1\",    -- Ada.Characters.Wide_Latin_1\n@@ -288,17 +289,8 @@ package body Impunit is\n      \"i-cexten\",    -- Interfaces.C.Extensions\n      \"i-cpp   \",    -- Interfaces.CPP\n      \"i-cstrea\",    -- Interfaces.C.Streams\n-     \"i-jalaob\",    -- Interfaces.Java.Lang.Object\n-     \"i-jalasy\",    -- Interfaces.Java.Lang.System\n-     \"i-jalath\",    -- Interfaces.Java.Lang.Thread\n      \"i-java  \",    -- Interfaces.Java\n-     \"i-javlan\",    -- Interfaces.Java.Lang\n-     \"i-os2err\",    -- Interfaces.Os2lib.Errors\n-     \"i-os2lib\",    -- Interfaces.Os2lib\n-     \"i-os2syn\",    -- Interfaces.Os2lib.Synchronization\n-     \"i-os2thr\",    -- Interfaces.Os2lib.Threads\n      \"i-pacdec\",    -- Interfaces.Packed_Decimal\n-     \"i-vthrea\",    -- Interfaces.Vthreads\n      \"i-vxwoio\",    -- Interfaces.VxWorks.IO\n      \"i-vxwork\",    -- Interfaces.VxWorks\n \n@@ -319,6 +311,7 @@ package body Impunit is\n      \"s-addima\",    -- System.Address_Image\n      \"s-assert\",    -- System.Assertions\n      \"s-memory\",    -- System.Memory\n+     \"s-os_lib\",    -- System.Os_Lib\n      \"s-parint\",    -- System.Partition_Interface\n      \"s-pooglo\",    -- System.Pool_Global\n      \"s-pooloc\",    -- System.Pool_Local\n@@ -364,6 +357,8 @@ package body Impunit is\n      \"a-diroro\",    -- Ada.Dispatching.Round_Robin\n      \"a-dispat\",    -- Ada.Dispatching\n      \"a-envvar\",    -- Ada.Environment_Variables\n+     \"a-exetim\",    -- Ada.Execution_Time\n+     \"a-extiti\",    -- Ada.Execution_Time.Timers\n      \"a-rttiev\",    -- Ada.Real_Time.Timing_Events\n      \"a-ngcoar\",    -- Ada.Numerics.Generic_Complex_Arrays\n      \"a-ngrear\",    -- Ada.Numerics.Generic_Real_Arrays"}, {"sha": "83d14068596f7ab7754b39f257125671c98da6cf", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 413, "deletions": 201, "changes": 614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=10e77af221ac8dc12cd2c414e77559ce9da9e082", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---                            M L I B . P R J                               --\n+--                             M L I B . P R J                              --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2006, AdaCore                     --\n+--                     Copyright (C) 2001-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,7 +29,6 @@ with Gnatvsn;  use Gnatvsn;\n with MLib.Fil; use MLib.Fil;\n with MLib.Tgt; use MLib.Tgt;\n with MLib.Utl; use MLib.Utl;\n-with Namet;    use Namet;\n with Opt;\n with Output;   use Output;\n with Prj.Com;  use Prj.Com;\n@@ -40,11 +39,14 @@ with Snames;   use Snames;\n with Switch;   use Switch;\n with Table;\n with Targparm; use Targparm;\n+with Tempdir;\n+with Types;    use Types;\n \n with Ada.Characters.Handling;\n \n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.HTable;\n+\n with Interfaces.C_Streams;      use Interfaces.C_Streams;\n with System;                    use System;\n with System.Case_Util;          use System.Case_Util;\n@@ -63,13 +65,13 @@ package body MLib.Prj is\n    B_Start : String_Ptr := new String'(\"b~\");\n    --  Prefix of bind file, changed to b__ for VMS\n \n-   S_Osinte_Ads : Name_Id := No_Name;\n+   S_Osinte_Ads : File_Name_Type := No_File;\n    --  Name_Id for \"s-osinte.ads\"\n \n-   S_Dec_Ads : Name_Id := No_Name;\n+   S_Dec_Ads : File_Name_Type := No_File;\n    --  Name_Id for \"dec.ads\"\n \n-   G_Trasym_Ads : Name_Id := No_Name;\n+   G_Trasym_Ads : File_Name_Type := No_File;\n    --  Name_Id for \"g-trasym.ads\"\n \n    No_Argument_List : aliased String_List := (1 .. 0 => null);\n@@ -158,7 +160,7 @@ package body MLib.Prj is\n      (Header_Num => Header_Num,\n       Element    => Boolean,\n       No_Element => False,\n-      Key        => Name_Id,\n+      Key        => File_Name_Type,\n       Hash       => Hash,\n       Equal      => \"=\");\n \n@@ -168,7 +170,7 @@ package body MLib.Prj is\n      (Header_Num => Header_Num,\n       Element    => Boolean,\n       No_Element => False,\n-      Key        => Name_Id,\n+      Key        => File_Name_Type,\n       Hash       => Hash,\n       Equal      => \"=\");\n \n@@ -179,7 +181,7 @@ package body MLib.Prj is\n      (Header_Num => Header_Num,\n       Element    => Boolean,\n       No_Element => False,\n-      Key        => Name_Id,\n+      Key        => File_Name_Type,\n       Hash       => Hash,\n       Equal      => \"=\");\n \n@@ -222,7 +224,7 @@ package body MLib.Prj is\n      (For_Project : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n       Interfaces  : Argument_List;\n-      To_Dir      : Name_Id);\n+      To_Dir      : Path_Name_Type);\n    --  Copy the interface sources of a SAL to directory To_Dir\n \n    procedure Display (Executable : String);\n@@ -238,7 +240,7 @@ package body MLib.Prj is\n \n    procedure Reset_Tables;\n    --  Make sure that all the above tables are empty\n-   --  (Objects, Foreign_Objects, Ali_Files, Options).\n+   --  (Objects, ALIs, Options, ...).\n \n    function SALs_Use_Constructors return Boolean;\n    --  Indicate if Stand-Alone Libraries are automatically initialized using\n@@ -312,24 +314,32 @@ package body MLib.Prj is\n       Bind          : Boolean := True;\n       Link          : Boolean := True)\n    is\n+      Maximum_Size : Integer;\n+      pragma Import (C, Maximum_Size, \"__gnat_link_max\");\n+      --  Maximum number of bytes to put in an invocation of the\n+      --  gnatbind.\n+\n+      Size : Integer;\n+      --  The number of bytes for the invocation of the gnatbind\n+\n       Warning_For_Library : Boolean := False;\n       --  Set to True for the first warning about a unit missing from the\n       --  interface set.\n \n-      Libgnarl_Needed   : Boolean := False;\n-      --  Set to True if library needs to be linked with libgnarl\n-\n-      Libdecgnat_Needed : Boolean := False;\n-      --  On OpenVMS, set to True if library needs to be linked with libdecgnat\n-\n       Gtrasymobj_Needed : Boolean := False;\n       --  On OpenVMS, set to True if library needs to be linked with\n       --  g-trasym.obj.\n \n       Data : Project_Data := In_Tree.Projects.Table (For_Project);\n \n+      Libgnarl_Needed   : Yes_No_Unknown := Data.Libgnarl_Needed;\n+      --  Set to True if library needs to be linked with libgnarl\n+\n+      Libdecgnat_Needed : Boolean := False;\n+      --  On OpenVMS, set to True if library needs to be linked with libdecgnat\n+\n       Object_Directory_Path : constant String :=\n-                          Get_Name_String (Data.Object_Directory);\n+                                Get_Name_String (Data.Display_Object_Dir);\n \n       Standalone   : constant Boolean := Data.Standalone_Library;\n \n@@ -346,7 +356,6 @@ package body MLib.Prj is\n       Success : Boolean := False;\n \n       Library_Options : Variable_Value := Nil_Variable_Value;\n-\n       Library_GCC     : Variable_Value := Nil_Variable_Value;\n \n       Driver_Name : Name_Id := No_Name;\n@@ -366,20 +375,19 @@ package body MLib.Prj is\n       --  If null, Path Option is not supported.\n       --  Not a constant so that it can be deallocated.\n \n-      First_ALI : Name_Id := No_Name;\n+      First_ALI : File_Name_Type := No_File;\n       --  Store the ALI file name of a source of the library (the first found)\n \n-      procedure Add_ALI_For (Source : Name_Id);\n-      --  Add the name of the ALI file corresponding to Source to the\n-      --  Arguments.\n+      procedure Add_ALI_For (Source : File_Name_Type);\n+      --  Add the name of the ALI file corresponding to Source to the arguments\n \n       procedure Add_Rpath (Path : String);\n       --  Add a path name to Rpath\n \n       function Check_Project (P : Project_Id) return Boolean;\n       --  Returns True if P is For_Project or a project extended by For_Project\n \n-      procedure Check_Libs (ALI_File : String);\n+      procedure Check_Libs (ALI_File : String; Main_Project : Boolean);\n       --  Set Libgnarl_Needed if the ALI_File indicates that there is a need\n       --  to link with -lgnarl (this is the case when there is a dependency\n       --  on s-osinte.ads). On OpenVMS, set Libdecgnat_Needed if the ALI file\n@@ -401,9 +409,9 @@ package body MLib.Prj is\n       -- Add_ALI_For --\n       -----------------\n \n-      procedure Add_ALI_For (Source : Name_Id) is\n+      procedure Add_ALI_For (Source : File_Name_Type) is\n          ALI    : constant String := ALI_File_Name (Get_Name_String (Source));\n-         ALI_Id : Name_Id;\n+         ALI_Id : File_Name_Type;\n \n       begin\n          if Bind then\n@@ -422,7 +430,7 @@ package body MLib.Prj is\n \n          --  Set First_ALI, if not already done\n \n-         if First_ALI = No_Name then\n+         if First_ALI = No_File then\n             First_ALI := ALI_Id;\n          end if;\n       end Add_ALI_For;\n@@ -512,16 +520,17 @@ package body MLib.Prj is\n       -- Check_Libs --\n       ----------------\n \n-      procedure Check_Libs (ALI_File : String) is\n-         Lib_File : Name_Id;\n+      procedure Check_Libs (ALI_File : String; Main_Project : Boolean) is\n+         Lib_File : File_Name_Type;\n          Text     : Text_Buffer_Ptr;\n          Id       : ALI.ALI_Id;\n \n       begin\n-         if not Libgnarl_Needed or\n-           (OpenVMS_On_Target and then\n-              ((not Libdecgnat_Needed) or\n-               (not Gtrasymobj_Needed)))\n+         if Libgnarl_Needed /= Yes\n+           or else\n+            (Main_Project\n+              and then OpenVMS_On_Target\n+              and then ((not Libdecgnat_Needed) or (not Gtrasymobj_Needed)))\n          then\n             --  Scan the ALI file\n \n@@ -544,7 +553,14 @@ package body MLib.Prj is\n                          ALI.ALIs.Table (Id).Last_Sdep\n             loop\n                if ALI.Sdep.Table (Index).Sfile = S_Osinte_Ads then\n-                  Libgnarl_Needed := True;\n+                  Libgnarl_Needed      := Yes;\n+\n+                  if Main_Project then\n+                     In_Tree.Projects.Table (For_Project).Libgnarl_Needed :=\n+                       Yes;\n+                  else\n+                     exit;\n+                  end if;\n \n                elsif OpenVMS_On_Target then\n                   if ALI.Sdep.Table (Index).Sfile = S_Dec_Ads then\n@@ -611,7 +627,7 @@ package body MLib.Prj is\n                      for W in Unit_Data.First_With .. Unit_Data.Last_With loop\n                         Afile := Withs.Table (W).Afile;\n \n-                        if Afile /= No_Name and then Library_ALIs.Get (Afile)\n+                        if Afile /= No_File and then Library_ALIs.Get (Afile)\n                           and then not Processed_ALIs.Get (Afile)\n                         then\n                            if not Interface_ALIs.Get (Afile) then\n@@ -676,8 +692,7 @@ package body MLib.Prj is\n          ---------------------\n \n          procedure Process_Project (Project : Project_Id) is\n-            Data     : constant Project_Data :=\n-                         In_Tree.Projects.Table (Project);\n+            Data     : Project_Data := In_Tree.Projects.Table (Project);\n             Imported : Project_List := Data.Imported_Projects;\n             Element  : Project_Element;\n \n@@ -707,6 +722,76 @@ package body MLib.Prj is\n                if Project /= For_Project and then Data.Library then\n                   Library_Projs.Increment_Last;\n                   Library_Projs.Table (Library_Projs.Last) := Project;\n+\n+                  --  Check if because of this library we need to use libgnarl\n+\n+                  if Libgnarl_Needed = Unknown then\n+                     if Data.Libgnarl_Needed = Unknown\n+                       and then Data.Object_Directory /= No_Path\n+                     then\n+                        --  Check if libgnarl is needed for this library\n+\n+                        declare\n+                           Object_Dir_Path : constant String :=\n+                                               Get_Name_String\n+                                                 (Data.Display_Object_Dir);\n+                           Object_Dir      : Dir_Type;\n+                           Filename        : String (1 .. 255);\n+                           Last            : Natural;\n+\n+                        begin\n+                           Open (Object_Dir, Object_Dir_Path);\n+\n+                           --  For all entries in the object directory\n+\n+                           loop\n+                              Read (Object_Dir, Filename, Last);\n+                              exit when Last = 0;\n+\n+                              --  Check if it is an object file\n+\n+                              if Is_Obj (Filename (1 .. Last)) then\n+                                 declare\n+                                    Object_Path : constant String :=\n+                                                    Normalize_Pathname\n+                                                      (Object_Dir_Path &\n+                                                       Directory_Separator &\n+                                                       Filename (1 .. Last));\n+                                    ALI_File    : constant String :=\n+                                                    Ext_To\n+                                                      (Object_Path, \"ali\");\n+\n+                                 begin\n+                                    if Is_Regular_File (ALI_File) then\n+\n+                                       --  Find out if for this ALI file,\n+                                       --  libgnarl is necessary.\n+\n+                                       Check_Libs\n+                                         (ALI_File, Main_Project => False);\n+\n+                                       if Libgnarl_Needed = Yes then\n+                                          Data.Libgnarl_Needed := Yes;\n+                                          In_Tree.Projects.Table\n+                                            (For_Project).Libgnarl_Needed :=\n+                                            Yes;\n+                                          exit;\n+                                       end if;\n+                                    end if;\n+                                 end;\n+                              end if;\n+                           end loop;\n+\n+                           Close (Object_Dir);\n+                        end;\n+                     end if;\n+\n+                     if Data.Libgnarl_Needed = Yes then\n+                        Libgnarl_Needed := Yes;\n+                        In_Tree.Projects.Table (For_Project).Libgnarl_Needed :=\n+                          Yes;\n+                     end if;\n+                  end if;\n                end if;\n \n             end if;\n@@ -722,14 +807,15 @@ package body MLib.Prj is\n \n          --  Add the -L and -l switches and, if the Rpath option is supported,\n          --  add the directory to the Rpath.\n+\n          --  As the library projects are in the wrong order, process from the\n          --  last to the first.\n \n          for Index in reverse 1 .. Library_Projs.Last loop\n             Current := Library_Projs.Table (Index);\n \n             Get_Name_String\n-              (In_Tree.Projects.Table (Current).Library_Dir);\n+              (In_Tree.Projects.Table (Current).Display_Library_Dir);\n             Opts.Increment_Last;\n             Opts.Table (Opts.Last) :=\n               new String'(\"-L\" & Name_Buffer (1 .. Name_Len));\n@@ -760,21 +846,21 @@ package body MLib.Prj is\n       end if;\n \n       --  If this is the first time Build_Library is called, get the Name_Id\n-      --  of \"s-osinte.ads\".\n+      --  values of \"s-osinte.ads\", \"dec.ads\", and \"g-trasym.ads\".\n \n-      if S_Osinte_Ads = No_Name then\n+      if S_Osinte_Ads = No_File then\n          Name_Len := 0;\n          Add_Str_To_Name_Buffer (\"s-osinte.ads\");\n          S_Osinte_Ads := Name_Find;\n       end if;\n \n-      if S_Dec_Ads = No_Name then\n+      if S_Dec_Ads = No_File then\n          Name_Len := 0;\n          Add_Str_To_Name_Buffer (\"dec.ads\");\n          S_Dec_Ads := Name_Find;\n       end if;\n \n-      if G_Trasym_Ads = No_Name then\n+      if G_Trasym_Ads = No_File then\n          Name_Len := 0;\n          Add_Str_To_Name_Buffer (\"g-trasym.ads\");\n          G_Trasym_Ads := Name_Find;\n@@ -785,6 +871,7 @@ package body MLib.Prj is\n       Change_Dir (Object_Directory_Path);\n \n       if Standalone then\n+\n          --  Call gnatbind only if Bind is True\n \n          if Bind then\n@@ -888,26 +975,25 @@ package body MLib.Prj is\n             loop\n                Unit := In_Tree.Units.Table (Source);\n \n-               if Unit.File_Names (Body_Part).Name /= No_Name\n+               if Unit.File_Names (Body_Part).Name /= No_File\n                  and then Unit.File_Names (Body_Part).Path /= Slash\n                then\n                   if\n                     Check_Project (Unit.File_Names (Body_Part).Project)\n                   then\n-                     if Unit.File_Names (Specification).Name = No_Name then\n+                     if Unit.File_Names (Specification).Name = No_File then\n                         declare\n                            Src_Ind : Source_File_Index;\n \n                         begin\n                            Src_Ind := Sinput.P.Load_Project_File\n                              (Get_Name_String\n-                                (Unit.File_Names\n-                                   (Body_Part).Path));\n+                                (Unit.File_Names (Body_Part).Path));\n \n                            --  Add the ALI file only if it is not a subunit\n \n                            if\n-                           not Sinput.P.Source_File_Is_Subunit (Src_Ind)\n+                             not Sinput.P.Source_File_Is_Subunit (Src_Ind)\n                            then\n                               Add_ALI_For\n                                 (Unit.File_Names (Body_Part).Name);\n@@ -921,7 +1007,7 @@ package body MLib.Prj is\n                      end if;\n                   end if;\n \n-               elsif Unit.File_Names (Specification).Name /= No_Name\n+               elsif Unit.File_Names (Specification).Name /= No_File\n                  and then Unit.File_Names (Specification).Path /= Slash\n                  and then Check_Project\n                    (Unit.File_Names (Specification).Project)\n@@ -938,7 +1024,7 @@ package body MLib.Prj is\n \n             --  Get an eventual --RTS from the ALI file\n \n-            if First_ALI /= No_Name then\n+            if First_ALI /= No_File then\n                declare\n                   T : Text_Buffer_Ptr;\n                   A : ALI_Id;\n@@ -989,10 +1075,114 @@ package body MLib.Prj is\n \n             Display (Gnatbind);\n \n-            --  Invoke gnatbind\n+            --  Check the size of the arguments\n \n-            GNAT.OS_Lib.Spawn\n-              (Gnatbind_Path.all, Arguments (1 .. Argument_Number), Success);\n+            Size := 0;\n+            for J in 1 .. Argument_Number loop\n+               Size := Size + Arguments (J)'Length + 1;\n+            end loop;\n+\n+            --  Invoke gnatbind with the arguments if the size is not too large\n+\n+            if Size <= Maximum_Size then\n+               Spawn\n+                 (Gnatbind_Path.all,\n+                  Arguments (1 .. Argument_Number),\n+                  Success);\n+\n+            else\n+               --  Otherwise create a temporary response file\n+\n+               declare\n+                  FD            : File_Descriptor;\n+                  Path          : Path_Name_Type;\n+                  Args          : Argument_List (1 .. 1);\n+                  EOL           : constant String (1 .. 1) := (1 => ASCII.LF);\n+                  Status        : Integer;\n+                  Succ          : Boolean;\n+                  Quotes_Needed : Boolean;\n+                  Last_Char     : Natural;\n+                  Ch            : Character;\n+\n+               begin\n+                  Tempdir.Create_Temp_File (FD, Path);\n+                  Args (1) := new String'(\"@\" & Get_Name_String (Path));\n+\n+                  for J in 1 .. Argument_Number loop\n+\n+                     --  Check if the argument should be quoted\n+\n+                     Quotes_Needed := False;\n+                     Last_Char     := Arguments (J)'Length;\n+\n+                     for K in Arguments (J)'Range loop\n+                        Ch := Arguments (J) (K);\n+\n+                        if Ch = ' ' or else Ch = ASCII.HT or else Ch = '\"' then\n+                           Quotes_Needed := True;\n+                           exit;\n+                        end if;\n+                     end loop;\n+\n+                     if Quotes_Needed then\n+\n+                        --  Quote the argument, doubling '\"'\n+\n+                        declare\n+                           Arg : String (1 .. Arguments (J)'Length * 2 + 2);\n+\n+                        begin\n+                           Arg (1) := '\"';\n+                           Last_Char := 1;\n+\n+                           for K in Arguments (J)'Range loop\n+                              Ch := Arguments (J) (K);\n+                              Last_Char := Last_Char + 1;\n+                              Arg (Last_Char) := Ch;\n+\n+                              if Ch = '\"' then\n+                                 Last_Char := Last_Char + 1;\n+                                 Arg (Last_Char) := '\"';\n+                              end if;\n+                           end loop;\n+\n+                           Last_Char := Last_Char + 1;\n+                           Arg (Last_Char) := '\"';\n+\n+                           Status := Write (FD, Arg'Address, Last_Char);\n+                        end;\n+\n+                     else\n+                        Status := Write\n+                          (FD,\n+                           Arguments (J) (Arguments (J)'First)'Address,\n+                           Last_Char);\n+                     end if;\n+\n+                     if Status /= Last_Char then\n+                        Fail (\"disk full\");\n+                     end if;\n+\n+                     Status := Write (FD, EOL (1)'Address, 1);\n+\n+                     if Status /= 1 then\n+                        Fail (\"disk full\");\n+                     end if;\n+                  end loop;\n+\n+                  Close (FD);\n+\n+                  --  And invoke gnatbind with this this response file\n+\n+                  Spawn (Gnatbind_Path.all, Args, Success);\n+\n+                  Delete_File (Get_Name_String (Path), Succ);\n+\n+                  if not Succ then\n+                     null;\n+                  end if;\n+               end;\n+            end if;\n \n             if not Success then\n                Com.Fail (\"could not bind standalone library \",\n@@ -1003,6 +1193,7 @@ package body MLib.Prj is\n          --  Compile the binder generated file only if Link is true\n \n          if Link then\n+\n             --  Set the paths\n \n             Set_Ada_Paths\n@@ -1037,7 +1228,7 @@ package body MLib.Prj is\n \n             --  Get the back-end switches and --RTS from the ALI file\n \n-            if First_ALI /= No_Name then\n+            if First_ALI /= No_File then\n                declare\n                   T : Text_Buffer_Ptr;\n                   A : ALI_Id;\n@@ -1136,8 +1327,10 @@ package body MLib.Prj is\n             end;\n          end if;\n \n-         Lib_Dirpath  := new String'(Get_Name_String (Data.Library_Dir));\n-         Lib_Filename := new String'(Get_Name_String (Data.Library_Name));\n+         Lib_Dirpath :=\n+           new String'(Get_Name_String (Data.Display_Library_Dir));\n+         Lib_Filename :=\n+           new String'(Get_Name_String (Data.Library_Name));\n \n          case Data.Library_Kind is\n             when Static =>\n@@ -1157,14 +1350,15 @@ package body MLib.Prj is\n \n          --  Get the library version, if any\n \n-         if Data.Lib_Internal_Name /= No_Name then\n+         if Data.Lib_Internal_Name /= No_File then\n             Lib_Version :=\n               new String'(Get_Name_String (Data.Lib_Internal_Name));\n          end if;\n \n          --  Add the objects found in the object directory and the object\n          --  directories of the extended files, if any, except for generated\n          --  object files (b~.. or B__..) from extended projects.\n+\n          --  When there are one or more extended files, only add an object file\n          --  if no object file with the same name have already been added.\n \n@@ -1173,7 +1367,7 @@ package body MLib.Prj is\n          loop\n             declare\n                Object_Dir_Path : constant String :=\n-                                   Get_Name_String (Data.Object_Directory);\n+                                   Get_Name_String (Data.Display_Object_Dir);\n                Object_Dir      : Dir_Type;\n                Filename        : String (1 .. 255);\n                Last            : Natural;\n@@ -1193,24 +1387,28 @@ package body MLib.Prj is\n \n                   if Is_Obj (Filename (1 .. Last)) then\n                      declare\n-                        Object_Path : String :=\n+                        Object_Path : constant String :=\n                           Normalize_Pathname\n                             (Object_Dir_Path & Directory_Separator &\n                              Filename (1 .. Last));\n+                        C_Object_Path : String := Object_Path;\n+                        C_Filename    : String := Filename (1 .. Last);\n \n                      begin\n-                        Canonical_Case_File_Name (Object_Path);\n-                        Canonical_Case_File_Name (Filename (1 .. Last));\n+                        Canonical_Case_File_Name (C_Object_Path);\n+                        Canonical_Case_File_Name (C_Filename);\n \n                         --  If in the object directory of an extended project,\n                         --  do not consider generated object files.\n \n                         if In_Main_Object_Directory\n                           or else Last < 5\n-                          or else Filename (1 .. B_Start'Length) /= B_Start.all\n+                          or else C_Filename (1 .. B_Start'Length) /=\n+                            B_Start.all\n                         then\n                            Name_Len := Last;\n-                           Name_Buffer (1 .. Name_Len) := Filename (1 .. Last);\n+                           Name_Buffer (1 .. Name_Len) :=\n+                             C_Filename (1 .. Last);\n                            Id := Name_Find;\n \n                            if not Objects_Htable.Get (Id) then\n@@ -1235,11 +1433,11 @@ package body MLib.Prj is\n                                     ALIs.Table (ALIs.Last) :=\n                                       new String'(ALI_File);\n \n-                                    --  Find out if for this ALI file,\n-                                    --  libgnarl or libdecgnat or g-trasym.obj\n-                                    --  (on OpenVMS) is necessary.\n+                                    --  Find out if for this ALI file, libgnarl\n+                                    --  or libdecgnat or g-trasym.obj (on\n+                                    --  OpenVMS) is necessary.\n \n-                                    Check_Libs (ALI_File);\n+                                    Check_Libs (ALI_File, True);\n \n                                  else\n                                     --  Object file is a foreign object file\n@@ -1312,14 +1510,17 @@ package body MLib.Prj is\n             end;\n          end if;\n \n-         if Libgnarl_Needed then\n+         if Libgnarl_Needed = Yes then\n             Opts.Increment_Last;\n \n             if The_Build_Mode = Static then\n                Opts.Table (Opts.Last) := new String'(\"-lgnarl\");\n             else\n                Opts.Table (Opts.Last) := new String'(Shared_Lib (\"gnarl\"));\n             end if;\n+\n+         else\n+            In_Tree.Projects.Table (For_Project).Libgnarl_Needed := No;\n          end if;\n \n          if Gtrasymobj_Needed then\n@@ -1377,8 +1578,8 @@ package body MLib.Prj is\n          Options :=\n            new Argument_List'(Argument_List (Opts.Table (1 .. Opts.Last)));\n \n-         --  We fail if there are no object to put in the library\n-         --  (Ada or foreign objects).\n+         --  We fail if there are no object to put in the library (Ada or\n+         --  foreign objects).\n \n          if Object_Files'Length = 0 then\n             Com.Fail (\"no object files for library \"\"\" &\n@@ -1393,8 +1594,7 @@ package body MLib.Prj is\n             Write_Str  (\" library for project \");\n             Write_Line (Project_Name);\n \n-            --  Only output the list of object files and ALI files in verbose\n-            --  mode.\n+            --  Only output list of object files and ALI files in verbose mode\n \n             if Opt.Verbose_Mode then\n                Write_Eol;\n@@ -1428,17 +1628,17 @@ package body MLib.Prj is\n \n          Check_Context;\n \n-         --  Delete the existing library file, if it exists.\n-         --  Fail if the library file is not writable, or if it is not possible\n-         --  to delete the file.\n+         --  Delete the existing library file, if it exists. Fail if the\n+         --  library file is not writable, or if it is not possible to delete\n+         --  the file.\n \n          declare\n             DLL_Name : aliased String :=\n-                         Lib_Dirpath.all & '/' & DLL_Prefix &\n+                         Lib_Dirpath.all & Directory_Separator & DLL_Prefix &\n                            Lib_Filename.all & \".\" & DLL_Ext;\n \n             Archive_Name : aliased String :=\n-                             Lib_Dirpath.all & \"/lib\" &\n+                             Lib_Dirpath.all & Directory_Separator & \"lib\" &\n                                Lib_Filename.all & \".\" & Archive_Ext;\n \n             type Str_Ptr is access all String;\n@@ -1482,19 +1682,20 @@ package body MLib.Prj is\n             Data := In_Tree.Projects.Table (For_Project);\n \n             declare\n-               Iface : String_List_Id := Data.Lib_Interface_ALIs;\n+               Iface : String_List_Id;\n                ALI   : File_Name_Type;\n \n             begin\n+               Iface := Data.Lib_Interface_ALIs;\n                while Iface /= Nil_String loop\n                   ALI :=\n-                    In_Tree.String_Elements.Table (Iface).Value;\n+                    File_Name_Type\n+                      (In_Tree.String_Elements.Table (Iface).Value);\n                   Interface_ALIs.Set (ALI, True);\n                   Get_Name_String\n                     (In_Tree.String_Elements.Table (Iface).Value);\n                   Add_Argument (Name_Buffer (1 .. Name_Len));\n-                  Iface :=\n-                    In_Tree.String_Elements.Table (Iface).Next;\n+                  Iface := In_Tree.String_Elements.Table (Iface).Next;\n                end loop;\n \n                Iface := Data.Lib_Interface_ALIs;\n@@ -1506,32 +1707,27 @@ package body MLib.Prj is\n                   --  interface. If it is not the case, output a warning.\n \n                   while Iface /= Nil_String loop\n-                     ALI := In_Tree.String_Elements.Table\n-                              (Iface).Value;\n+                     ALI :=\n+                       File_Name_Type\n+                         (In_Tree.String_Elements.Table (Iface).Value);\n                      Process (ALI);\n-                     Iface :=\n-                       In_Tree.String_Elements.Table (Iface).Next;\n+                     Iface := In_Tree.String_Elements.Table (Iface).Next;\n                   end loop;\n                end if;\n             end;\n          end if;\n \n          declare\n             Current_Dir  : constant String := Get_Current_Dir;\n-            Dir          : Dir_Type;\n-\n-            Name : String (1 .. 200);\n-            Last : Natural;\n-\n-            Disregard : Boolean;\n-\n-            DLL_Name : aliased constant String :=\n-                         Lib_Filename.all & \".\" & DLL_Ext;\n-\n+            DLL_Name     : aliased constant String :=\n+                             Lib_Filename.all & \".\" & DLL_Ext;\n             Archive_Name : aliased constant String :=\n                              Lib_Filename.all & \".\" & Archive_Ext;\n-\n-            Delete : Boolean := False;\n+            Dir          : Dir_Type;\n+            Name         : String (1 .. 200);\n+            Last         : Natural;\n+            Disregard    : Boolean;\n+            Delete       : Boolean := False;\n \n          begin\n             --  Clean the library directory: remove any file with the name of\n@@ -1556,74 +1752,85 @@ package body MLib.Prj is\n                Read (Dir, Name, Last);\n                exit when Last = 0;\n \n-               if Is_Regular_File (Name (1 .. Last)) then\n-                  Canonical_Case_File_Name (Name (1 .. Last));\n-                  Delete := False;\n-\n-                  if (The_Build_Mode = Static and then\n-                        Name (1 .. Last) =  Archive_Name)\n-                    or else\n-                      ((The_Build_Mode = Dynamic or else\n-                          The_Build_Mode = Relocatable)\n-                       and then\n-                         Name (1 .. Last) = DLL_Name)\n-                  then\n-                     Delete := True;\n+               declare\n+                  Filename : constant String := Name (1 .. Last);\n \n-                  elsif Last > 4 and then Name (Last - 3 .. Last) = \".ali\" then\n-                     declare\n-                        Unit : Unit_Data;\n-                     begin\n-                        --  Compare with ALI file names of the project\n+               begin\n+                  if Is_Regular_File (Filename) then\n+                     Canonical_Case_File_Name (Name (1 .. Last));\n+                     Delete := False;\n \n-                        for Index in 1 .. Unit_Table.Last (In_Tree.Units) loop\n-                           Unit := In_Tree.Units.Table (Index);\n+                     if (The_Build_Mode = Static and then\n+                           Name (1 .. Last) =  Archive_Name)\n+                       or else\n+                         ((The_Build_Mode = Dynamic or else\n+                             The_Build_Mode = Relocatable)\n+                          and then\n+                            Name (1 .. Last) = DLL_Name)\n+                     then\n+                        Delete := True;\n \n-                           if Unit.File_Names (Body_Part).Project /=\n-                             No_Project\n-                           then\n-                              if  Ultimate_Extension_Of\n-                                (Unit.File_Names (Body_Part).Project, In_Tree)\n-                                 = For_Project\n+                     elsif Last > 4\n+                       and then Name (Last - 3 .. Last) = \".ali\"\n+                     then\n+                        declare\n+                           Unit : Unit_Data;\n+\n+                        begin\n+                           --  Compare with ALI file names of the project\n+\n+                           for Index in\n+                             1 .. Unit_Table.Last (In_Tree.Units)\n+                           loop\n+                              Unit := In_Tree.Units.Table (Index);\n+\n+                              if Unit.File_Names (Body_Part).Project /=\n+                                No_Project\n+                              then\n+                                 if  Ultimate_Extension_Of\n+                                   (Unit.File_Names (Body_Part).Project,\n+                                    In_Tree) = For_Project\n+                                 then\n+                                    Get_Name_String\n+                                      (Unit.File_Names (Body_Part).Name);\n+                                    Name_Len := Name_Len -\n+                                      File_Extension\n+                                        (Name (1 .. Name_Len))'Length;\n+                                    if Name_Buffer (1 .. Name_Len) =\n+                                      Name (1 .. Last - 4)\n+                                    then\n+                                       Delete := True;\n+                                       exit;\n+                                    end if;\n+                                 end if;\n+\n+                              elsif Ultimate_Extension_Of\n+                                (Unit.File_Names (Specification).Project,\n+                                 In_Tree) = For_Project\n                               then\n                                  Get_Name_String\n-                                   (Unit.File_Names (Body_Part).Name);\n+                                   (Unit.File_Names (Specification).Name);\n                                  Name_Len := Name_Len -\n                                    File_Extension\n                                      (Name (1 .. Name_Len))'Length;\n+\n                                  if Name_Buffer (1 .. Name_Len) =\n-                                     Name (1 .. Last - 4)\n+                                   Name (1 .. Last - 4)\n                                  then\n                                     Delete := True;\n                                     exit;\n                                  end if;\n                               end if;\n+                           end loop;\n+                        end;\n+                     end if;\n \n-                           elsif Ultimate_Extension_Of\n-                             (Unit.File_Names (Specification).Project, In_Tree)\n-                             = For_Project\n-                           then\n-                              Get_Name_String\n-                                (Unit.File_Names (Specification).Name);\n-                              Name_Len := Name_Len -\n-                                File_Extension (Name (1 .. Name_Len))'Length;\n-\n-                              if Name_Buffer (1 .. Name_Len) =\n-                                   Name (1 .. Last - 4)\n-                              then\n-                                 Delete := True;\n-                                 exit;\n-                              end if;\n-                           end if;\n-                        end loop;\n-                     end;\n-                  end if;\n-\n-                  if Delete then\n-                     Set_Writable (Name (1 .. Last));\n-                     Delete_File (Name (1 .. Last), Disregard);\n+                     if Delete then\n+                        Set_Writable (Filename);\n+                        Delete_File (Filename, Disregard);\n+                     end if;\n                   end if;\n-               end if;\n+               end;\n             end loop;\n \n             Close (Dir);\n@@ -1671,14 +1878,15 @@ package body MLib.Prj is\n \n          Copy_ALI_Files\n            (Files      => Ali_Files.all,\n-            To         => In_Tree.Projects.Table (For_Project).Library_ALI_Dir,\n+            To         => In_Tree.Projects.Table\n+                            (For_Project).Display_Library_ALI_Dir,\n             Interfaces => Arguments (1 .. Argument_Number));\n \n          --  Copy interface sources if Library_Src_Dir specified\n \n          if Standalone\n            and then In_Tree.Projects.Table\n-                      (For_Project).Library_Src_Dir /= No_Name\n+                      (For_Project).Library_Src_Dir /= No_Path\n          then\n             --  Clean the interface copy directory: remove any source that\n             --  could be a source of the project.\n@@ -1697,13 +1905,11 @@ package body MLib.Prj is\n             end;\n \n             declare\n-               Dir    : Dir_Type;\n-               Delete : Boolean := False;\n-               Unit   : Unit_Data;\n-\n-               Name : String (1 .. 200);\n-               Last : Natural;\n-\n+               Dir       : Dir_Type;\n+               Delete    : Boolean := False;\n+               Unit      : Unit_Data;\n+               Name      : String (1 .. 200);\n+               Last      : Natural;\n                Disregard : Boolean;\n \n             begin\n@@ -1713,45 +1919,50 @@ package body MLib.Prj is\n                   Read (Dir, Name, Last);\n                   exit when Last = 0;\n \n-                  if Is_Regular_File (Name (1 .. Last)) then\n-                     Canonical_Case_File_Name (Name (1 .. Last));\n-                     Delete := False;\n+                  declare\n+                     Filename : constant String := Name (1 .. Last);\n \n-                     --  Compare with source file names of the project\n+                  begin\n+                     if Is_Regular_File (Filename) then\n+                        Canonical_Case_File_Name (Name (1 .. Last));\n+                        Delete := False;\n \n-                     for Index in 1 .. Unit_Table.Last (In_Tree.Units) loop\n-                        Unit := In_Tree.Units.Table (Index);\n+                        --  Compare with source file names of the project\n \n-                        if Ultimate_Extension_Of\n-                            (Unit.File_Names (Body_Part).Project, In_Tree) =\n-                            For_Project\n-                          and then\n-                            Get_Name_String\n-                              (Unit.File_Names (Body_Part).Name) =\n-                            Name (1 .. Last)\n-                        then\n-                           Delete := True;\n-                           exit;\n-                        end if;\n+                        for Index in 1 .. Unit_Table.Last (In_Tree.Units) loop\n+                           Unit := In_Tree.Units.Table (Index);\n \n-                        if Ultimate_Extension_Of\n-                           (Unit.File_Names (Specification).Project, In_Tree) =\n-                           For_Project\n-                          and then\n-                           Get_Name_String\n-                             (Unit.File_Names (Specification).Name) =\n-                           Name (1 .. Last)\n-                        then\n-                           Delete := True;\n-                           exit;\n-                        end if;\n-                     end loop;\n-                  end if;\n+                           if Ultimate_Extension_Of\n+                             (Unit.File_Names (Body_Part).Project, In_Tree) =\n+                             For_Project\n+                             and then\n+                               Get_Name_String\n+                                 (Unit.File_Names (Body_Part).Name) =\n+                             Name (1 .. Last)\n+                           then\n+                              Delete := True;\n+                              exit;\n+                           end if;\n \n-                  if Delete then\n-                     Set_Writable (Name (1 .. Last));\n-                     Delete_File (Name (1 .. Last), Disregard);\n-                  end if;\n+                           if Ultimate_Extension_Of\n+                             (Unit.File_Names\n+                                (Specification).Project, In_Tree) = For_Project\n+                             and then\n+                               Get_Name_String\n+                                 (Unit.File_Names (Specification).Name) =\n+                                                              Name (1 .. Last)\n+                           then\n+                              Delete := True;\n+                              exit;\n+                           end if;\n+                        end loop;\n+                     end if;\n+\n+                     if Delete then\n+                        Set_Writable (Filename);\n+                        Delete_File (Filename, Disregard);\n+                     end if;\n+                  end;\n                end loop;\n \n                Close (Dir);\n@@ -1762,7 +1973,7 @@ package body MLib.Prj is\n                In_Tree     => In_Tree,\n                Interfaces  => Arguments (1 .. Argument_Number),\n                To_Dir      => In_Tree.Projects.Table\n-                                (For_Project).Library_Src_Dir);\n+                                (For_Project).Display_Library_Src_Dir);\n          end if;\n       end if;\n \n@@ -1800,7 +2011,8 @@ package body MLib.Prj is\n    -------------------\n \n    procedure Check_Library\n-     (For_Project : Project_Id; In_Tree : Project_Tree_Ref)\n+     (For_Project : Project_Id;\n+      In_Tree     : Project_Tree_Ref)\n    is\n       Data    : constant Project_Data :=\n                   In_Tree.Projects.Table (For_Project);\n@@ -1813,8 +2025,8 @@ package body MLib.Prj is\n \n       if Data.Library then\n          declare\n-            Lib_Name : constant Name_Id :=\n-              Library_File_Name_For (For_Project, In_Tree);\n+            Lib_Name : constant File_Name_Type :=\n+                         Library_File_Name_For (For_Project, In_Tree);\n          begin\n             Change_Dir (Get_Name_String (Data.Library_Dir));\n             Lib_TS := File_Stamp (Lib_Name);\n@@ -1823,7 +2035,7 @@ package body MLib.Prj is\n \n          if not Data.Externally_Built\n            and then not Data.Need_To_Build_Lib\n-           and then Data.Object_Directory /= No_Name\n+           and then Data.Object_Directory /= No_Path\n          then\n             declare\n                Obj_TS     : Time_Stamp_Type;\n@@ -1854,7 +2066,7 @@ package body MLib.Prj is\n                   then\n                      --  Get the object file time stamp\n \n-                     Obj_TS := File_Stamp (Name_Find);\n+                     Obj_TS := File_Stamp (File_Name_Type'(Name_Find));\n \n                      --  If library file time stamp is earlier, set\n                      --  Need_To_Build_Lib and return. String comparaison is\n@@ -1889,7 +2101,7 @@ package body MLib.Prj is\n      (For_Project : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n       Interfaces  : Argument_List;\n-      To_Dir      : Name_Id)\n+      To_Dir      : Path_Name_Type)\n    is\n       Current : constant Dir_Name_Str := Get_Current_Dir;\n       --  The current directory, where to return to at the end\n@@ -1899,7 +2111,7 @@ package body MLib.Prj is\n \n       Text     : Text_Buffer_Ptr;\n       The_ALI  : ALI.ALI_Id;\n-      Lib_File : Name_Id;\n+      Lib_File : File_Name_Type;\n \n       First_Unit  : ALI.Unit_Id;\n       Second_Unit : ALI.Unit_Id;\n@@ -1909,7 +2121,7 @@ package body MLib.Prj is\n       Copy_Subunits : Boolean := False;\n       --  When True, indicates that subunits, if any, need to be copied too\n \n-      procedure Copy (File_Name : Name_Id);\n+      procedure Copy (File_Name : File_Name_Type);\n       --  Copy one source of the project to the target directory\n \n       function Is_Same_Or_Extension\n@@ -1922,7 +2134,7 @@ package body MLib.Prj is\n       -- Copy --\n       ----------\n \n-      procedure Copy (File_Name : Name_Id) is\n+      procedure Copy (File_Name : File_Name_Type) is\n          Success : Boolean := False;\n \n       begin"}, {"sha": "73acbfd9d2e15a86734fab80441dd9dba8927f8c", "filename": "gcc/ada/mlib-prj.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2Fmlib-prj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e77af221ac8dc12cd2c414e77559ce9da9e082/gcc%2Fada%2Fmlib-prj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.ads?ref=10e77af221ac8dc12cd2c414e77559ce9da9e082", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2005, AdaCore                     --\n+--                     Copyright (C) 2001-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,7 +47,8 @@ package MLib.Prj is\n    --  If Link is False, the library is not linked/built.\n \n    procedure Check_Library\n-     (For_Project : Project_Id; In_Tree : Project_Tree_Ref);\n+     (For_Project : Project_Id;\n+      In_Tree     : Project_Tree_Ref);\n    --  Check if the library of a library project needs to be rebuilt,\n    --  because its time-stamp is earlier than the time stamp of one of its\n    --  object files."}]}