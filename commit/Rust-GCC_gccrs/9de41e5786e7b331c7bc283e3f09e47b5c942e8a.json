{"sha": "9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRlNDFlNTc4NmU3YjMzMWM3YmMyODNlM2YwOWU0N2I1Yzk0MmU4YQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2014-09-04T18:04:14Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2014-09-04T18:04:14Z"}, "message": "Revert incorrect merging of debug-early branch.\n\nFrom-SVN: r214914", "tree": {"sha": "a1475a4d1d9c293ad247466bba59dc257d5b9ce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1475a4d1d9c293ad247466bba59dc257d5b9ce5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/comments", "author": null, "committer": null, "parents": [{"sha": "c5a36850156812b5d2d3f1401307315feef0aed5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a36850156812b5d2d3f1401307315feef0aed5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5a36850156812b5d2d3f1401307315feef0aed5"}], "stats": {"total": 372, "additions": 70, "deletions": 302}, "files": [{"sha": "b4995a67733c6c74cdba559cced0e43a774559b9", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -10308,10 +10308,7 @@ c_write_global_declarations_1 (tree globals)\n   while (reconsider);\n \n   for (decl = globals; decl; decl = DECL_CHAIN (decl))\n-    {\n-      check_global_declaration_1 (decl);\n-      debug_hooks->global_decl (decl, /*early=*/true);\n-    }\n+    check_global_declaration_1 (decl);\n }\n \n /* A subroutine of c_write_global_declarations Emit debug information for each\n@@ -10323,7 +10320,7 @@ c_write_global_declarations_2 (tree globals)\n   tree decl;\n \n   for (decl = globals; decl ; decl = DECL_CHAIN (decl))\n-    debug_hooks->global_decl (decl, /*early=*/false);\n+    debug_hooks->global_decl (decl);\n }\n \n /* Callback to collect a source_ref from a DECL.  */"}, {"sha": "ebcbb5c5580f4933a7252d76a70a83de943a6f36", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -3859,7 +3859,7 @@ do_namespace_alias (tree alias, tree name_space)\n \n   /* Emit debug info for namespace alias.  */\n   if (!building_stmt_list_p ())\n-    (*debug_hooks->global_decl) (alias, /*early=*/false);\n+    (*debug_hooks->global_decl) (alias);\n }\n \n /* Like pushdecl, only it places X in the current namespace,"}, {"sha": "d856bddc115d8fa4f3bdb1d0bbece8a587ba0dfd", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -325,7 +325,7 @@ static int dbxout_symbol_location (tree, tree, const char *, rtx);\n static void dbxout_symbol_name (tree, const char *, int);\n static void dbxout_common_name (tree, const char *, stab_code_type);\n static const char *dbxout_common_check (tree, int *);\n-static void dbxout_global_decl (tree, bool);\n+static void dbxout_global_decl (tree);\n static void dbxout_type_decl (tree, int);\n static void dbxout_handle_pch (unsigned);\n static void debug_free_queue (void);\n@@ -1320,7 +1320,7 @@ dbxout_function_decl (tree decl)\n /* Debug information for a global DECL.  Called from toplev.c after\n    compilation proper has finished.  */\n static void\n-dbxout_global_decl (tree decl, bool early ATTRIBUTE_UNUSED)\n+dbxout_global_decl (tree decl)\n {\n   if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n     {"}, {"sha": "dba068cc24adc88b1072324c019df2b498b862c7", "filename": "gcc/debug.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.c?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -43,7 +43,7 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =\n   debug_nothing_tree,\t\t         /* begin_function */\n   debug_nothing_int,\t\t         /* end_function */\n   debug_nothing_tree,\t\t         /* function_decl */\n-  debug_nothing_tree_bool,\t         /* global_decl */\n+  debug_nothing_tree,\t\t         /* global_decl */\n   debug_nothing_tree_int,\t\t /* type_decl */\n   debug_nothing_tree_tree_tree_bool,\t /* imported_module_or_decl */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n@@ -70,12 +70,6 @@ debug_nothing_tree (tree decl ATTRIBUTE_UNUSED)\n {\n }\n \n-void\n-debug_nothing_tree_bool (tree decl ATTRIBUTE_UNUSED,\n-\t\t\t bool early ATTRIBUTE_UNUSED)\n-{\n-}\n-\n void\n debug_nothing_tree_tree (tree t1 ATTRIBUTE_UNUSED,\n \t\t\t tree t2 ATTRIBUTE_UNUSED)"}, {"sha": "3ac7976c5de7e8cd90249de9100976f26750b41b", "filename": "gcc/debug.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -93,11 +93,8 @@ struct gcc_debug_hooks\n   void (* function_decl) (tree decl);\n \n   /* Debug information for a global DECL.  Called from toplev.c after\n-     compilation proper has finished.  EARLY is true if global_decl()\n-     is being called early on in the compilation process (i.e., before\n-     cgraph information is available and before code is\n-     generated).  */\n-  void (* global_decl) (tree decl, bool early);\n+     compilation proper has finished.  */\n+  void (* global_decl) (tree decl);\n \n   /* Debug information for a type DECL.  Called from toplev.c after\n      compilation proper, also from various language front ends to\n@@ -159,7 +156,6 @@ extern void debug_nothing_int_charstar_int_bool (unsigned int, const char *,\n extern void debug_nothing_int (unsigned int);\n extern void debug_nothing_int_int (unsigned int, unsigned int);\n extern void debug_nothing_tree (tree);\n-extern void debug_nothing_tree_bool (tree, bool);\n extern void debug_nothing_tree_tree (tree, tree);\n extern void debug_nothing_tree_int (tree, int);\n extern void debug_nothing_tree_tree_tree_bool (tree, tree, tree, bool);\n@@ -191,8 +187,6 @@ extern void dwarf2out_switch_text_section (void);\n const char *remap_debug_filename (const char *);\n void add_debug_prefix_map (const char *);\n \n-extern void dwarf2out_early_decl (tree);\n-\n /* For -fdump-go-spec.  */\n \n extern const struct gcc_debug_hooks *"}, {"sha": "23a80d831cbea38bb9d5d134e77936a0863ede93", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 49, "deletions": 264, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -103,7 +103,7 @@ along with GCC; see the file COPYING3.  If not see\n static void dwarf2out_source_line (unsigned int, const char *, int, bool);\n static rtx_insn *last_var_location_insn;\n static rtx_insn *cached_next_real_insn;\n-static dw_die_ref dwarf2out_decl (tree);\n+static void dwarf2out_decl (tree);\n \n #ifdef VMS_DEBUGGING_INFO\n int vms_file_stats_name (const char *, long long *, long *, char *, int *);\n@@ -2430,7 +2430,7 @@ static void dwarf2out_function_decl (tree);\n static void dwarf2out_begin_block (unsigned, unsigned);\n static void dwarf2out_end_block (unsigned, unsigned);\n static bool dwarf2out_ignore_block (const_tree);\n-static void dwarf2out_global_decl (tree, bool);\n+static void dwarf2out_global_decl (tree);\n static void dwarf2out_type_decl (tree, int);\n static void dwarf2out_imported_module_or_decl (tree, tree, tree, bool);\n static void dwarf2out_imported_module_or_decl_1 (tree, tree, tree,\n@@ -2609,8 +2609,6 @@ typedef struct GTY((chain_circular (\"%h.die_sib\"))) die_struct {\n   /* Die is used and must not be pruned as unused.  */\n   BOOL_BITFIELD die_perennial_p : 1;\n   BOOL_BITFIELD comdat_type_p : 1; /* DIE has a type signature */\n-  /* Die was generated early via dwarf2out_early_decl.  */\n-  BOOL_BITFIELD dumped_early : 1;\n   /* Lots of spare bits.  */\n }\n die_node;\n@@ -3681,7 +3679,7 @@ decl_ultimate_origin (const_tree decl)\n   /* output_inline_function sets DECL_ABSTRACT_ORIGIN for all the\n      nodes in the function to point to themselves; ignore that if\n      we're trying to output the abstract instance of this function.  */\n-  if (/*DECL_ABSTRACT (decl) &&*/ DECL_ABSTRACT_ORIGIN (decl) == decl)\n+  if (DECL_ABSTRACT (decl) && DECL_ABSTRACT_ORIGIN (decl) == decl)\n     return NULL_TREE;\n \n   /* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the\n@@ -4781,7 +4779,6 @@ remove_child_TAG (dw_die_ref die, enum dwarf_tag tag)\n     while (c->die_tag == tag)\n       {\n \tremove_child_with_prev (c, prev);\n-\tc->die_parent = NULL;\n \t/* Might have removed every child.  */\n \tif (c == c->die_sib)\n \t  return;\n@@ -4811,28 +4808,15 @@ add_child_die (dw_die_ref die, dw_die_ref child_die)\n   die->die_child = child_die;\n }\n \n-/* Unassociate CHILD from its parent, and make its parent be\n-   NEW_PARENT.  */\n-\n-static void\n-reparent_child (dw_die_ref child, dw_die_ref new_parent)\n-{\n-  for (dw_die_ref p = child->die_parent->die_child; ; p = p->die_sib)\n-    if (p->die_sib == child)\n-      {\n-\tremove_child_with_prev (child, p);\n-\tbreak;\n-      }\n-  add_child_die (new_parent, child);\n-}\n-\n /* Move CHILD, which must be a child of PARENT or the DIE for which PARENT\n    is the specification, to the end of PARENT's list of children.\n    This is done by removing and re-adding it.  */\n \n static void\n splice_child_die (dw_die_ref parent, dw_die_ref child)\n {\n+  dw_die_ref p;\n+\n   /* We want the declaration DIE from inside the class, not the\n      specification DIE at toplevel.  */\n   if (child->die_parent != parent)\n@@ -4847,7 +4831,14 @@ splice_child_die (dw_die_ref parent, dw_die_ref child)\n \t      || (child->die_parent\n \t\t  == get_AT_ref (parent, DW_AT_specification)));\n \n-  reparent_child (child, parent);\n+  for (p = child->die_parent->die_child; ; p = p->die_sib)\n+    if (p->die_sib == child)\n+      {\n+\tremove_child_with_prev (child, p);\n+\tbreak;\n+      }\n+\n+  add_child_die (parent, child);\n }\n \n /* Return a pointer to a newly created DIE node.  */\n@@ -5526,49 +5517,6 @@ debug_dwarf (void)\n   print_indent = 0;\n   print_die (comp_unit_die (), stderr);\n }\n-\n-/* Perform some sanity checks on DIEs after they have been generated\n-   earlier in the compilation process.  */\n-\n-static void\n-check_die (dw_die_ref die, unsigned level)\n-{\n-  static unsigned long mark = 1;\n-  dw_die_ref c, p;\n-  /* Check that all our childs have their parent set to us.  */\n-  c = die->die_child;\n-  if (c) do {\n-      c = c->die_sib;\n-      gcc_assert (c->die_parent == die);\n-    } while (c != die->die_child);\n-\n-  /* Check the we are part of our parent's child list.  */\n-  mark++;\n-  p = die->die_parent;\n-  if (p)\n-    {\n-      c = p->die_child;\n-      gcc_assert (c);\n-      do {\n-\tc = c->die_sib;\n-\t/* Found it.  */\n-\tif (c == die)\n-\t  break;\n-\t/* If we're at start --> not found.  */\n-\tgcc_assert (c != p->die_child);\n-\t/* If we've seen this node already the circular list doesn't\n-\t   even go back to start.  */\n-\tgcc_assert (c->die_abbrev != mark);\n-\tc->die_abbrev = mark;\n-      } while (1);\n-    }\n-\n-  if (!level)\n-    return;\n-\n-  FOR_EACH_CHILD (die, c, check_die (c, level - 1));\n-}\n-\n \f\n /* Start a new compilation unit DIE for an include file.  OLD_UNIT is the CU\n    for the enclosing include file, if any.  BINCL_DIE is the DW_TAG_GNU_BINCL\n@@ -8711,11 +8659,9 @@ output_die (dw_die_ref die)\n   if (! die->comdat_type_p && die->die_id.die_symbol)\n     output_die_symbol (die);\n \n-  dw2_asm_output_data_uleb128 (die->die_abbrev, \"(DIE (%#lx) %s (parent DIE=%#lx) early=%d)\",\n+  dw2_asm_output_data_uleb128 (die->die_abbrev, \"(DIE (%#lx) %s)\",\n \t\t\t       (unsigned long)die->die_offset,\n-\t\t\t       dwarf_tag_name (die->die_tag),\n-\t\t\t       die->die_parent ? die->die_parent->die_offset : 0,\n-\t\t\t       die->dumped_early);\n+\t\t\t       dwarf_tag_name (die->die_tag));\n \n   FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     {\n@@ -17657,52 +17603,16 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,\n {\n   tree node_or_origin = node ? node : origin;\n   tree ultimate_origin;\n-  dw_die_ref parm_die = NULL;\n-  \n-  if (TREE_CODE_CLASS (TREE_CODE (node_or_origin)) == tcc_declaration)\n-    {\n-      parm_die = lookup_decl_die (node);\n-\n-      if (parm_die && parm_die->die_parent == NULL)\n-\t{\n-\t  /* Check that parm_die already has the right attributes that\n-\t     we would have added below.  If any attributes are\n-\t     missing, fall through to add them.\n-\n-\t     ?? Add more checks here.  */\n-\t  if (! DECL_ABSTRACT (node_or_origin)\n-\t      && !get_AT (parm_die, DW_AT_location)\n-\t      && !get_AT (parm_die, DW_AT_const_value))\n-\t    /* We are missing  location info, and are about to add it.  */\n-\t    ;\n-\t  else\n-\t    {\n-\t      add_child_die (context_die, parm_die);\n-\t      return parm_die;\n-\t    }\n-\t}\n-    }\n-\n-  bool reusing_die;\n-  if (parm_die)\n-    reusing_die = true;\n-  else\n-    {\n-      parm_die = new_die (DW_TAG_formal_parameter, context_die, node);\n-      reusing_die = false;\n-    }\n+  dw_die_ref parm_die\n+    = new_die (DW_TAG_formal_parameter, context_die, node);\n \n   switch (TREE_CODE_CLASS (TREE_CODE (node_or_origin)))\n     {\n     case tcc_declaration:\n       ultimate_origin = decl_ultimate_origin (node_or_origin);\n       if (node || ultimate_origin)\n \torigin = ultimate_origin;\n-\n-      if (reusing_die)\n-\tgoto add_location;\n-\n-      if (origin != NULL && node != origin)\n+      if (origin != NULL)\n \tadd_abstract_origin_attribute (parm_die, origin);\n       else if (emit_name_p)\n \tadd_name_and_src_coords_attributes (parm_die, node);\n@@ -17726,7 +17636,6 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,\n \n       if (node && node != origin)\n         equate_decl_number_to_die (node, parm_die);\n-    add_location:\n       if (! DECL_ABSTRACT (node_or_origin))\n \tadd_location_or_const_value_attribute (parm_die, node_or_origin,\n \t\t\t\t\t       node == NULL, DW_AT_location);\n@@ -18241,7 +18150,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       && debug_info_level > DINFO_LEVEL_TERSE)\n     old_die = force_decl_die (decl);\n \n-  if (origin != NULL && origin != decl)\n+  if (origin != NULL)\n     {\n       gcc_assert (!declaration || local_scope_p (context_die));\n \n@@ -18271,13 +18180,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t  && !get_AT (old_die, DW_AT_inline))\n \t{\n \t  /* Detect and ignore this case, where we are trying to output\n-\t     something we have already output.\n-\n-\t     If we have no location information, this must be a\n-\t     partially generated DIE from early dwarf generation.\n-\t     Fall through and generate it.  */\n-\t  if (get_AT (old_die, DW_AT_low_pc)\n-\t      || get_AT (old_die, DW_AT_ranges))\n+\t     something we have already output.  */\n \t  return;\n \t}\n \n@@ -18296,20 +18199,14 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t{\n \t  subr_die = old_die;\n \n-\t  /* ??? Hmmm, early dwarf generation happened earlier, so no\n-\t     sense in removing the parameters.  Let's keep them and\n-\t     augment them with location information later.  */\n-\t  if (!old_die->dumped_early)\n-\t    {\n-\t      /* Clear out the declaration attribute and the formal parameters.\n-\t\t Do not remove all children, because it is possible that this\n-\t\t declaration die was forced using force_decl_die(). In such\n-\t\t cases die that forced declaration die (e.g. TAG_imported_module)\n-\t\t is one of the children that we do not want to remove.  */\n-\t      remove_AT (subr_die, DW_AT_declaration);\n-\t      remove_AT (subr_die, DW_AT_object_pointer);\n-\t      remove_child_TAG (subr_die, DW_TAG_formal_parameter);\n-\t    }\n+\t  /* Clear out the declaration attribute and the formal parameters.\n+\t     Do not remove all children, because it is possible that this\n+\t     declaration die was forced using force_decl_die(). In such\n+\t     cases die that forced declaration die (e.g. TAG_imported_module)\n+\t     is one of the children that we do not want to remove.  */\n+\t  remove_AT (subr_die, DW_AT_declaration);\n+\t  remove_AT (subr_die, DW_AT_object_pointer);\n+\t  remove_child_TAG (subr_die, DW_TAG_formal_parameter);\n \t}\n       else\n \t{\n@@ -18400,12 +18297,9 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n       equate_decl_number_to_die (decl, subr_die);\n     }\n-  else if (!DECL_EXTERNAL (decl)\n-\t   && (!DECL_STRUCT_FUNCTION (decl)\n-\t       || DECL_STRUCT_FUNCTION (decl)->gimple_df))\n+  else if (!DECL_EXTERNAL (decl))\n     {\n       HOST_WIDE_INT cfa_fb_offset;\n-\n       struct function *fun = DECL_STRUCT_FUNCTION (decl);\n \n       if (!old_die || !get_AT (old_die, DW_AT_inline))\n@@ -18568,20 +18462,10 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \tadd_AT_location_description (subr_die, DW_AT_static_link,\n \t\t loc_list_from_tree (fun->static_chain_decl, 2));\n     }\n-  else if (!DECL_EXTERNAL (decl))\n-    {\n-      if (!old_die || !get_AT (old_die, DW_AT_inline))\n-\tequate_decl_number_to_die (decl, subr_die);\n-    }\n \n   /* Generate child dies for template paramaters.  */\n   if (debug_info_level > DINFO_LEVEL_TERSE)\n-    {\n-      /* XXX */\n-      if (!lookup_decl_die (decl))\n-\tequate_decl_number_to_die (decl, subr_die);\n-      gen_generic_params_dies (decl);\n-    }\n+    gen_generic_params_dies (decl);\n \n   /* Now output descriptions of the arguments for this function. This gets\n      (unnecessarily?) complex because of the fact that the DECL_ARGUMENT list\n@@ -18685,9 +18569,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n      a BLOCK node representing the function's outermost pair of curly braces,\n      and any blocks used for the base and member initializers of a C++\n      constructor function.  */\n-  if (! declaration && outer_scope && TREE_CODE (outer_scope) != ERROR_MARK\n-      && (!DECL_STRUCT_FUNCTION (decl)\n-\t  || DECL_STRUCT_FUNCTION (decl)->gimple_df))\n+  if (! declaration && outer_scope && TREE_CODE (outer_scope) != ERROR_MARK)\n     {\n       int call_site_note_count = 0;\n       int tail_call_site_note_count = 0;\n@@ -19007,19 +18889,9 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n      and if we already emitted a DIE for it, don't emit a second\n      DIE for it again. Allow re-declarations of DECLs that are\n      inside functions, though.  */\n-  if (old_die && !declaration && !local_scope_p (context_die))\n+  if (old_die && declaration && !local_scope_p (context_die))\n     return;\n \n-  /* If a DIE was dumped early, it still needs location info.  Skip to\n-     the part where we fill the location bits.  */\n-  if (old_die && old_die->dumped_early)\n-    {\n-      gcc_assert (old_die->die_parent == context_die);\n-      var_die = old_die;\n-      old_die = NULL;\n-      goto gen_variable_die_location;\n-    }\n-\n   /* For static data members, the declaration in the class is supposed\n      to have DW_TAG_member tag; the specification should still be\n      DW_TAG_variable referencing the DW_TAG_member DIE.  */\n@@ -19103,7 +18975,6 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n   if (decl && (DECL_ABSTRACT (decl) || declaration || old_die == NULL))\n     equate_decl_number_to_die (decl, var_die);\n \n- gen_variable_die_location:\n   if (! declaration\n       && (! DECL_ABSTRACT (decl_or_origin)\n \t  /* Local static vars are shared between all clones/inlines,\n@@ -20817,29 +20688,12 @@ gen_decl_die (tree decl, tree origin, dw_die_ref context_die)\n   return NULL;\n }\n \f\n-/* Output debug information for global decl DECL.  Called from\n-   toplev.c after compilation proper has finished.\n-\n-   dwarf2out_decl() will be called twice on each global symbol: once\n-   immediately after parsing (EARLY=true), and once after the full\n-   compilation has finished (EARLY=false).  There are checks in\n-   dwarf2out_decl() to make sure that if we have a DECL DIE upon\n-   entry, that the previously created DIE is reused.  No new DECL DIEs\n-   should be created when EARLY=false.\n-\n-   The second time dwarf2out_decl() is called (or for that matter, the\n-   second time any DECL DIE is seen throughout dwarf2out), only\n-   information not previously available (e.g. location) is tacked onto\n-   the early dumped DIE.  That's the plan anyhow ;-).  */\n+/* Output debug information for global decl DECL.  Called from toplev.c after\n+   compilation proper has finished.  */\n \n static void\n-dwarf2out_global_decl (tree decl, bool early)\n+dwarf2out_global_decl (tree decl)\n {\n-  if (early)\n-    {\n-      dwarf2out_early_decl (decl);\n-      return;\n-    }\n   /* Output DWARF2 information for file-scope tentative data object\n      declarations, file-scope (extern) function declarations (which\n      had no corresponding body) and file-scope tagged type declarations\n@@ -21028,30 +20882,17 @@ gen_namelist_decl (tree name, dw_die_ref scope_die, tree item_decls)\n }\n \n \n-/* Write the debugging output for DECL and return the DIE.  */\n+/* Write the debugging output for DECL.  */\n \n-static dw_die_ref\n+static void\n dwarf2out_decl (tree decl)\n {\n   dw_die_ref context_die = comp_unit_die ();\n \n-#ifdef ENABLE_CHECKING\n-  /* Save some info so we can later determine if we erroneously\n-     created a DIE for something we had already created a DIE for.\n-     We should always be reusing DIEs created early.  */\n-  dw_die_ref early_die = NULL;\n-  if (decl_die_table)\n-    {\n-      early_die = lookup_decl_die (decl);\n-      if (early_die && !early_die->dumped_early)\n-\tearly_die = NULL;\n-    }\n-#endif\n-\n   switch (TREE_CODE (decl))\n     {\n     case ERROR_MARK:\n-      return NULL;\n+      return;\n \n     case FUNCTION_DECL:\n       /* What we would really like to do here is to filter out all mere\n@@ -21088,7 +20929,7 @@ dwarf2out_decl (tree decl)\n \t or not at all.  */\n       if (DECL_INITIAL (decl) == NULL_TREE\n \t  && ! DECL_ABSTRACT (decl))\n-\treturn NULL;\n+\treturn;\n \n       /* If we're a nested function, initially use a parent of NULL; if we're\n \t a plain function, this will be fixed up in decls_for_scope.  If\n@@ -21109,7 +20950,7 @@ dwarf2out_decl (tree decl)\n \t would screw-up the debugger's name lookup mechanism and cause it to\n \t miss things which really ought to be in scope at a given point.  */\n       if (DECL_EXTERNAL (decl) && !TREE_USED (decl))\n-\treturn NULL;\n+\treturn;\n \n       /* For local statics lookup proper context die.  */\n       if (TREE_STATIC (decl)\n@@ -21120,39 +20961,39 @@ dwarf2out_decl (tree decl)\n       /* If we are in terse mode, don't generate any DIEs to represent any\n \t variable declarations or definitions.  */\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-\treturn NULL;\n+\treturn;\n       break;\n \n     case CONST_DECL:\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-\treturn NULL;\n+\treturn;\n       if (!is_fortran () && !is_ada ())\n-\treturn NULL;\n+\treturn;\n       if (TREE_STATIC (decl) && decl_function_context (decl))\n \tcontext_die = lookup_decl_die (DECL_CONTEXT (decl));\n       break;\n \n     case NAMESPACE_DECL:\n     case IMPORTED_DECL:\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-\treturn NULL;\n+\treturn;\n       if (lookup_decl_die (decl) != NULL)\n-\treturn NULL;\n+\treturn;\n       break;\n \n     case TYPE_DECL:\n       /* Don't emit stubs for types unless they are needed by other DIEs.  */\n       if (TYPE_DECL_SUPPRESS_DEBUG (decl))\n-\treturn NULL;\n+\treturn;\n \n       /* Don't bother trying to generate any DIEs to represent any of the\n \t normal built-in types for the language we are compiling.  */\n       if (DECL_IS_BUILTIN (decl))\n-\treturn NULL;\n+\treturn;\n \n       /* If we are in terse mode, don't generate any DIEs for types.  */\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-\treturn NULL;\n+\treturn;\n \n       /* If we're a function-scope tag, initially use a parent of NULL;\n \t this will be fixed up in decls_for_scope.  */\n@@ -21165,66 +21006,10 @@ dwarf2out_decl (tree decl)\n       break;\n \n     default:\n-      return NULL;\n+      return;\n     }\n \n   gen_decl_die (decl, NULL, context_die);\n-\n-  dw_die_ref die = lookup_decl_die (decl);\n-  if (die)\n-    check_die (die, 0);\n-#ifdef ENABLE_CHECKING\n-  /* If we early created a DIE, make sure it didn't get re-created by\n-     mistake.  */\n-  gcc_assert (!early_die || early_die == die);\n-#endif\n-  return die;\n-}\n-\n-/* Early dumping of DECLs before we lose language data.  */\n-\n-void\n-dwarf2out_early_decl (tree decl)\n-{\n-  /* gen_decl_die() will set DECL_ABSTRACT because\n-     cgraph_function_possibly_inlined_p() returns true.  This is in\n-     turn will cause DW_AT_inline attributes to be set.\n-\n-     This happens because at early dwarf generation, there is no\n-     cgraph information, causing cgraph_function_possibly_inlined_p()\n-     to return true.  Trick cgraph_function_possibly_inlined_p()\n-     while we generate dwarf early.  */\n-  bool save = symtab->global_info_ready;\n-  symtab->global_info_ready = true;\n-\n-  /* We don't handle TYPE_DECLs.  If required, they'll be reached via\n-     other DECLs and they can point to template types or other things\n-     that dwarf2out can't handle when done via dwarf2out_decl.  */\n-  if (TREE_CODE (decl) != TYPE_DECL\n-      && TREE_CODE (decl) != PARM_DECL)\n-    {\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t{\n-\t  /* A missing cfun means the symbol is unused and was removed\n-\t     from the callgraph.  */\n-\t  if (!DECL_STRUCT_FUNCTION (decl))\n-\t    goto early_decl_exit;\n-\n-\t  push_cfun (DECL_STRUCT_FUNCTION (decl));\n-\t  current_function_decl = decl;\n-\t}\n-      dw_die_ref die = dwarf2out_decl (decl);\n-      if (die)\n-\tdie->dumped_early = true;\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t{\n-\t  pop_cfun ();\n-\t  current_function_decl = NULL;\n-\t}\n-    }\n- early_decl_exit:\n-  symtab->global_info_ready = save;\n-  return;\n }\n \n /* Write the debugging output for DECL.  */"}, {"sha": "6afa6f3b6963ac3e65993290a9f628b6e74f8edd", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -4693,7 +4693,7 @@ gfc_emit_parameter_debug_info (gfc_symbol *sym)\n \t\t\t\t\t      TREE_TYPE (decl),\n \t\t\t\t\t      sym->attr.dimension,\n \t\t\t\t\t      false, false);\n-  debug_hooks->global_decl (decl, /*early=*/false);\n+  debug_hooks->global_decl (decl);\n }\n \n "}, {"sha": "7566f4d3effae89f779644e559aabcc80ba13ee4", "filename": "gcc/godump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fgodump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fgodump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgodump.c?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -496,9 +496,9 @@ go_function_decl (tree decl)\n /* A global variable decl.  */\n \n static void\n-go_global_decl (tree decl, bool early)\n+go_global_decl (tree decl)\n {\n-  real_debug_hooks->global_decl (decl, early);\n+  real_debug_hooks->global_decl (decl);\n   go_decl (decl);\n }\n "}, {"sha": "9e8524acac2dbe267ff90168b129386d4d747cf7", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -1093,7 +1093,7 @@ lto_write_globals (void)\n   varpool_node *vnode;\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n     if (!decl_function_context (vnode->decl))\n-      debug_hooks->global_decl (vnode->decl, /*early=*/false);\n+      debug_hooks->global_decl (vnode->decl);\n }\n \n static tree"}, {"sha": "7b6f4573e05b6b036f7121f68182da841f0d3064", "filename": "gcc/sdbout.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -119,7 +119,7 @@ static void sdbout_begin_block\t\t(unsigned int, unsigned int);\n static void sdbout_end_block\t\t(unsigned int, unsigned int);\n static void sdbout_source_line\t\t(unsigned int, const char *, int, bool);\n static void sdbout_end_epilogue\t\t(unsigned int, const char *);\n-static void sdbout_global_decl\t\t(tree, bool);\n+static void sdbout_global_decl\t\t(tree);\n static void sdbout_begin_prologue\t(unsigned int, const char *);\n static void sdbout_end_prologue\t\t(unsigned int, const char *);\n static void sdbout_begin_function\t(tree);\n@@ -142,6 +142,7 @@ static void sdbout_field_types\t\t(tree);\n static void sdbout_one_type\t\t(tree);\n static void sdbout_parms\t\t(tree);\n static void sdbout_reg_parms\t\t(tree);\n+static void sdbout_global_decl\t\t(tree);\n \n /* Random macros describing parts of SDB data.  */\n \n@@ -1421,7 +1422,7 @@ sdbout_reg_parms (tree parms)\n    after compilation proper has finished.  */\n \n static void\n-sdbout_global_decl (tree decl, bool early ATTRIBUTE_UNUSED)\n+sdbout_global_decl (tree decl)\n {\n   if (TREE_CODE (decl) == VAR_DECL\n       && !DECL_EXTERNAL (decl)"}, {"sha": "492a7ef58e5234e9df90b71597f20a7d5177986a", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -532,7 +532,7 @@ emit_debug_global_declarations (tree *vec, int len)\n \n   timevar_push (TV_SYMOUT);\n   for (i = 0; i < len; i++)\n-    debug_hooks->global_decl (vec[i], /*early=*/false);\n+    debug_hooks->global_decl (vec[i]);\n   timevar_pop (TV_SYMOUT);\n }\n "}, {"sha": "d1d67efa62942cb9662ebb48127e7c83cccc0c77", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -5032,10 +5032,6 @@ free_lang_data_in_decl (tree decl)\n {\n   gcc_assert (DECL_P (decl));\n \n-  /* Early dumping of DECLs before we lose language data.  */\n-  if (debug_info_level > DINFO_LEVEL_NONE)\n-    dwarf2out_early_decl (decl);\n-\n   /* Give the FE a chance to remove its own data first.  */\n   lang_hooks.free_lang_data (decl);\n \n@@ -5634,7 +5630,8 @@ free_lang_data (void)\n   unsigned i;\n \n   /* If we are the LTO frontend we have freed lang-specific data already.  */\n-  if (in_lto_p)\n+  if (in_lto_p\n+      || !flag_generate_lto)\n     return 0;\n \n   /* Allocate and assign alias sets to the standard integer types"}, {"sha": "463a4182622a7aef0f8366b54b56dfff790df0da", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de41e5786e7b331c7bc283e3f09e47b5c942e8a/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=9de41e5786e7b331c7bc283e3f09e47b5c942e8a", "patch": "@@ -163,7 +163,7 @@ static void vmsdbgout_begin_epilogue (unsigned int, const char *);\n static void vmsdbgout_end_epilogue (unsigned int, const char *);\n static void vmsdbgout_begin_function (tree);\n static void vmsdbgout_decl (tree);\n-static void vmsdbgout_global_decl (tree, bool);\n+static void vmsdbgout_global_decl (tree);\n static void vmsdbgout_type_decl (tree, int);\n static void vmsdbgout_abstract_function (tree);\n \n@@ -1510,10 +1510,10 @@ vmsdbgout_decl (tree decl)\n /* Not implemented in VMS Debug.  */\n \n static void\n-vmsdbgout_global_decl (tree decl, bool early)\n+vmsdbgout_global_decl (tree decl)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n-    (*dwarf2_debug_hooks.global_decl) (decl, early);\n+    (*dwarf2_debug_hooks.global_decl) (decl);\n }\n \n /* Not implemented in VMS Debug.  */"}]}