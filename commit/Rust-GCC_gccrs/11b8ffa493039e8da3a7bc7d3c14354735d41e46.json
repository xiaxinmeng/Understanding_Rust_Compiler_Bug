{"sha": "11b8ffa493039e8da3a7bc7d3c14354735d41e46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFiOGZmYTQ5MzAzOWU4ZGEzYTdiYzdkM2MxNDM1NDczNWQ0MWU0Ng==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2020-08-06T23:57:15Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2020-08-06T23:57:15Z"}, "message": "mmix: fix gcc.dg/loop-9.c by more accurate move insns\n\nIt looks like gcc.dg/loop-9.c kind-of works as sentinel for sane\nmove-instruction generation for a port.\n\nLooking at the\nFAIL: gcc.dg/loop-9.c scan-rtl-dump loop2_invariant \"Decided\"\nFAIL: gcc.dg/loop-9.c scan-rtl-dump loop2_invariant \"without introducing a new temporary register\"\nit seems the problem is that in the loop:\n\n  for (i = 0; i < 100; i++)\n    a[i] = 18.4242;\n\nthe move insn corresponding to \"a[i] = 18.4242\" happens to be\ngenerated as a move of a constant to a memory address, using no\nregisters except for the address (edited):\n\n(insn 9 8 10 3 (set (mem:DF (reg:DI 269 [ ivtmp::9 ]))\n        (const_double:DF 1.84241999e+1)) \"x/loop-9.c\":9:10 6 {movdf})\n\nTo wit, at the loop2 pass there's no register-initialization to move\nout of the loop!  The insn above isn't accurate and has to be fixed up\nat register allocation time to make constraints match.  While there\nare insns to set memory to constant in MMIX, that's limited to 64-bit\nmoves corresponding to the integer bit-patterns for 0..255, and\n18.4242 isn't one of them.  (Only 0.0 matches; the bit-patterns for\n0..255 would IIUC be interpreted as denormal floating-point numbers\na.k.a. subnormal numbers and don't seem worthwhile to handle.)\n\nThe fault is with the port, for not requiring a register for an\noperand that actually requires an intermediate register, in order to\nenable pre-register-allocation passes to do their job.  The movdf\npattern (actually, all MMIX movM), only required the destination to be\na non-immediate operand and the source to be a general_operand,\ni.e. anything-to-anything.\n\nBetter force the source to be a register, when asked to generate such\na move insn.  Also, make operands stay sane by using the matching insn\ncondition to require one of the operands to be a register\npre-register-allocation (for sake of combine-like passes that cook up\n\"simplified\" insns, possibly losing the use of a register).  Looking\nno deeper than at the results of test-runs with different variants, I\nsee that the latter \"safety latch\" has no effect on the test-results\n(at 919c9d4bd3db7da0), but it just feels like the right thing to do.\nSimilarly, there's no effect on test-suite results, to do the same not\njust for movdf but for all moves.\n\ngcc:\n\t* config/mmix/mmix.md (MM): New mode_iterator.\n\t(\"mov<mode>\"): New expander to expand for all MM-modes.\n\t(\"*movqi_expanded\", \"*movhi_expanded\", \"*movsi_expanded\")\n\t(\"*movsf_expanded\", \"*movdf_expanded\"): Rename from the\n\tcorresponding mov<M> named pattern.  Add to the condition that\n\teither operand must be a register_operand.\n\t(\"*movdi_expanded\"): Similar, but also allow STCO in the condition.", "tree": {"sha": "e2f8979088dce10c72b810e4d9bf9b6d507a902d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2f8979088dce10c72b810e4d9bf9b6d507a902d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11b8ffa493039e8da3a7bc7d3c14354735d41e46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11b8ffa493039e8da3a7bc7d3c14354735d41e46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11b8ffa493039e8da3a7bc7d3c14354735d41e46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11b8ffa493039e8da3a7bc7d3c14354735d41e46/comments", "author": null, "committer": null, "parents": [{"sha": "140cf935cd118f7208b7c3826a8b9d50936242f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/140cf935cd118f7208b7c3826a8b9d50936242f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/140cf935cd118f7208b7c3826a8b9d50936242f0"}], "stats": {"total": 48, "additions": 36, "deletions": 12}, "files": [{"sha": "f41a5b260ddadc698e6e5e70e1480e6b074a16d1", "filename": "gcc/config/mmix/mmix.md", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11b8ffa493039e8da3a7bc7d3c14354735d41e46/gcc%2Fconfig%2Fmmix%2Fmmix.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11b8ffa493039e8da3a7bc7d3c14354735d41e46/gcc%2Fconfig%2Fmmix%2Fmmix.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.md?ref=11b8ffa493039e8da3a7bc7d3c14354735d41e46", "patch": "@@ -38,6 +38,8 @@\n    (MMIX_rR_REGNUM 260)\n    (MMIX_fp_rO_OFFSET -24)]\n )\n+\n+(define_mode_iterator MM [QI HI SI DI SF DF])\n \f\n ;; Operand and operator predicates.\n \n@@ -46,10 +48,25 @@\n \f\n ;; FIXME: Can we remove the reg-to-reg for smaller modes?  Shouldn't they\n ;; be synthesized ok?\n-(define_insn \"movqi\"\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:MM 0 \"nonimmediate_operand\")\n+\t(match_operand:MM 1 \"general_operand\"))]\n+  \"\"\n+{\n+  /*  Help pre-register-allocation to use at least one register in a move.\n+      FIXME: support STCO also for DFmode (storing 0.0).  */\n+  if (!REG_P (operands[0]) && !REG_P (operands[1])\n+      && (<MODE>mode != DImode\n+\t  || !memory_operand (operands[0], DImode)\n+\t  || !satisfies_constraint_I (operands[1])))\n+    operands[1] = force_reg (<MODE>mode, operands[1]);\n+})\n+\n+(define_insn \"*movqi_expanded\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r ,r,x ,r,r,m,??r\")\n \t(match_operand:QI 1 \"general_operand\"\t    \"r,LS,K,rI,x,m,r,n\"))]\n-  \"\"\n+  \"register_operand (operands[0], QImode)\n+   || register_operand (operands[1], QImode)\"\n   \"@\n    SET %0,%1\n    %s1 %0,%v1\n@@ -60,10 +77,11 @@\n    STBU %1,%0\n    %r0%I1\")\n \n-(define_insn \"movhi\"\n+(define_insn \"*movhi_expanded\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r ,r ,x,r,r,m,??r\")\n \t(match_operand:HI 1 \"general_operand\"\t    \"r,LS,K,r,x,m,r,n\"))]\n-  \"\"\n+  \"register_operand (operands[0], HImode)\n+   || register_operand (operands[1], HImode)\"\n   \"@\n    SET %0,%1\n    %s1 %0,%v1\n@@ -75,10 +93,11 @@\n    %r0%I1\")\n \n ;; gcc.c-torture/compile/920428-2.c fails if there's no \"n\".\n-(define_insn \"movsi\"\n+(define_insn \"*movsi_expanded\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r ,r,x,r,r,m,??r\")\n \t(match_operand:SI 1 \"general_operand\"\t    \"r,LS,K,r,x,m,r,n\"))]\n-  \"\"\n+  \"register_operand (operands[0], SImode)\n+   || register_operand (operands[1], SImode)\"\n   \"@\n    SET %0,%1\n    %s1 %0,%v1\n@@ -90,10 +109,13 @@\n    %r0%I1\")\n \n ;; We assume all \"s\" are addresses.  Does that hold?\n-(define_insn \"movdi\"\n+(define_insn \"*movdi_expanded\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r ,r,x,r,m,r,m,r,r,??r\")\n \t(match_operand:DI 1 \"general_operand\"\t    \"r,LS,K,r,x,I,m,r,R,s,n\"))]\n-  \"\"\n+  \"register_operand (operands[0], DImode)\n+   || register_operand (operands[1], DImode)\n+   || (memory_operand (operands[0], DImode)\n+       && satisfies_constraint_I (operands[1]))\"\n   \"@\n    SET %0,%1\n    %s1 %0,%v1\n@@ -109,10 +131,11 @@\n \n ;; Note that we move around the float as a collection of bits; no\n ;; conversion to double.\n-(define_insn \"movsf\"\n+(define_insn \"*movsf_expanded\"\n  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,x,r,r,m,??r\")\n        (match_operand:SF 1 \"general_operand\"\t   \"r,G,r,x,m,r,F\"))]\n-  \"\"\n+  \"register_operand (operands[0], SFmode)\n+   || register_operand (operands[1], SFmode)\"\n   \"@\n    SET %0,%1\n    SETL %0,0\n@@ -122,10 +145,11 @@\n    STTU %1,%0\n    %r0%I1\")\n \n-(define_insn \"movdf\"\n+(define_insn \"*movdf_expanded\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,x,r,r,m,??r\")\n \t(match_operand:DF 1 \"general_operand\"\t    \"r,G,r,x,m,r,F\"))]\n-  \"\"\n+  \"register_operand (operands[0], DFmode)\n+   || register_operand (operands[1], DFmode)\"\n   \"@\n    SET %0,%1\n    SETL %0,0"}]}