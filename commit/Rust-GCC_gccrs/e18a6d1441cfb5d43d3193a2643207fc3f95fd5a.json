{"sha": "e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE4YTZkMTQ0MWNmYjVkNDNkMzE5M2EyNjQzMjA3ZmMzZjk1ZmQ1YQ==", "commit": {"author": {"name": "Andrew Burgess", "email": "andrew.burgess@embecosm.com", "date": "2019-10-28T16:26:19Z"}, "committer": {"name": "Andrew Burgess", "email": "aburgess@gcc.gnu.org", "date": "2019-10-28T16:26:19Z"}, "message": "gcc/riscv: Add a mechanism to remove some calls to _riscv_save_0\n\nWhen using the -msave-restore flag we end up with calls to\n_riscv_save_0 and _riscv_restore_0.  These functions adjust the stack\nand save or restore the return address.  Due to grouping multiple\nsave/restore stub functions together the save/restore 0 calls actually\nsave s0, s1, s2, and the return address, but only the return address\nactually matters.  Leaf functions don't call the save/restore stubs,\nso whenever we do see a call to the save/restore stubs, the store of\nthe return address is required.\n\nIf we look in gcc/config/riscv/riscv.c at the function\nriscv_expand_prologue and riscv_expand_epilogue we can see that it\nwould be reasonably easy to adjust these functions to avoid the calls\nto the save/restore stubs for those cases where we are about to call\n_riscv_save_0 and _riscv_restore_0, however, the actual code size\nsaving this would give is debatable, with linker relaxation, the calls\nto save/restore are often just 4-bytes, and can sometimes even be\n2-bytes, while leaving the stack adjust and return address save inline\nis always going to be 4-bytes.\n\nThe interesting case is when we call _riscv_save_0 and\n_riscv_restore_0, and also have a frame that would (without\nsave/restore) have resulted in a tail call.  In this case if we could\nremove the save/restore calls, and restore the tail call then we would\nget a real size saving.\n\nThe problem is that the choice of generating a tail call or not is\ndone during the gimple expand pass, at which point we don't know how\nmany registers we need to save (or restore).\n\nThe solution presented in this patch offers a partial solution to this\nproblem.  By using the TARGET_MACHINE_DEPENDENT_REORG pass to\nimplement a very limited pattern matching we identify functions that\ncall _riscv_save_0 and _riscv_restore_0, and which could be converted\nto make use of a tail call.  These functions are then converted to the\nnon save/restore tail call form.\n\nThis should result in a code size reduction when compiling with -Os\nand with the -msave-restore flag.\n\ngcc/ChangeLog:\n\n        * config.gcc: Add riscv-sr.o to extra_objs for riscv.\n        * config/riscv/riscv-sr.c: New file.\n        * config/riscv/riscv.c (riscv_reorg): New function.\n        (TARGET_MACHINE_DEPENDENT_REORG): Define.\n        * config/riscv/riscv.h (SIBCALL_REG_P): Define.\n        (riscv_remove_unneeded_save_restore_calls): Declare.\n        * config/riscv/t-riscv (riscv-sr.o): New build rule.\n\ngcc/testsuite/ChangeLog:\n\n        * gcc.target/riscv/save-restore-2.c: New file.\n        * gcc.target/riscv/save-restore-3.c: New file.\n        * gcc.target/riscv/save-restore-4.c: New file.\n        * gcc.target/riscv/save-restore-5.c: New file.\n        * gcc.target/riscv/save-restore-6.c: New file.\n        * gcc.target/riscv/save-restore-7.c: New file.\n        * gcc.target/riscv/save-restore-8.c: New file.\n\nFrom-SVN: r277527", "tree": {"sha": "317e4993f74123551321eccf1c21bdb9b15ab169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/317e4993f74123551321eccf1c21bdb9b15ab169"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/comments", "author": {"login": "T-J-Teru", "id": 475372, "node_id": "MDQ6VXNlcjQ3NTM3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4", "gravatar_id": "", "url": "https://api.github.com/users/T-J-Teru", "html_url": "https://github.com/T-J-Teru", "followers_url": "https://api.github.com/users/T-J-Teru/followers", "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}", "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}", "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions", "organizations_url": "https://api.github.com/users/T-J-Teru/orgs", "repos_url": "https://api.github.com/users/T-J-Teru/repos", "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}", "received_events_url": "https://api.github.com/users/T-J-Teru/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b0ab0d9588f6c63f7102e70de52684cdda49de8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b0ab0d9588f6c63f7102e70de52684cdda49de8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b0ab0d9588f6c63f7102e70de52684cdda49de8"}], "stats": {"total": 637, "additions": 636, "deletions": 1}, "files": [{"sha": "b875cef27931a97ddb1e9097d673fe9ad1e86572", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -1,3 +1,13 @@\n+2019-10-28  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* config.gcc: Add riscv-sr.o to extra_objs for riscv.\n+\t* config/riscv/riscv-sr.c: New file.\n+\t* config/riscv/riscv.c (riscv_reorg): New function.\n+\t(TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t* config/riscv/riscv.h (SIBCALL_REG_P): Define.\n+\t(riscv_remove_unneeded_save_restore_calls): Declare.\n+\t* config/riscv/t-riscv (riscv-sr.o): New build rule.\n+\n 2019-10-28  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \tPR tree-optimization/92163"}, {"sha": "b4440877e99f15d4351bff0b58214d5e9d6aee9d", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -523,7 +523,7 @@ pru-*-*)\n \t;;\n riscv*)\n \tcpu_type=riscv\n-\textra_objs=\"riscv-builtins.o riscv-c.o\"\n+\textra_objs=\"riscv-builtins.o riscv-c.o riscv-sr.o\"\n \td_target_objs=\"riscv-d.o\"\n \t;;\n rs6000*-*-*)"}, {"sha": "e3180efcbcca25d6995a210be0cb37527e674e09", "filename": "gcc/config/riscv/riscv-sr.c", "status": "added", "additions": 465, "deletions": 0, "changes": 465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Fconfig%2Friscv%2Friscv-sr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Fconfig%2Friscv%2Friscv-sr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-sr.c?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -0,0 +1,465 @@\n+/* This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains code aimed at optimizing function generated with the\n+   use of '-msave-restore.  The goal is to identify cases where the call\n+   out to the save/restore routines are sub-optimal, and remove the calls\n+   in this case.\n+\n+   As GCC currently makes the choice between using or not using\n+   save/restore early on (during the gimple expand pass) once we have\n+   selected to use save/restore we are stuck with it.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"function.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+#include \"target.h\"\n+#include \"basic-block.h\"\n+#include \"bitmap.h\"\n+#include \"df.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"cfg.h\"\n+\n+/* This file should be included last.  */\n+#include \"hard-reg-set.h\"\n+\n+/* Look in the function prologue for a call to the save stub.  Ensure that\n+   the instruction is as we expect (see detail below) and if the\n+   instruction matches return a pointer to it.  Otherwise, return NULL.\n+\n+   We expect the function prologue to look like this:\n+\n+   (note NOTE_INSN_BASIC_BLOCK)\n+   (insn (parallel [\n+\t          (unspec_volatile [\n+\t                  (const_int 2 [0x2])\n+\t              ] UNSPECV_GPR_SAVE)\n+\t          (clobber (reg:SI 5 t0))\n+\t          (clobber (reg:SI 6 t1))])\n+   (note NOTE_INSN_PROLOGUE_END)\n+\n+   Between the NOTE_INSN_BASIC_BLOCK and the GPR_SAVE insn we might find\n+   other notes of type NOTE_INSN_DELETED and/or NOTE_INSN_FUNCTION_BEG.\n+\n+   The parameter BODY is updated to point to the first instruction after\n+   the NOTE_INSN_PROLOGUE_END or will be updated to NULL if the prologue\n+   end note was not found.  */\n+\n+static rtx_insn *\n+riscv_sr_match_prologue (rtx_insn **body)\n+{\n+  rtx_insn *insn, *bb_note;\n+  *body = NULL;\n+\n+  /* Find the prologue end note.  */\n+  for (insn = get_insns (); insn != NULL; insn = NEXT_INSN (insn))\n+    if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_PROLOGUE_END)\n+      {\n+\t*body = NEXT_INSN (insn);\n+\tbreak;\n+      }\n+\n+  /* If we don't have the prologue end note and at least one instruction\n+     before it, then this function doesn't have the structure we expect.  */\n+  if (insn == NULL\n+      || PREV_INSN (insn) == NULL)\n+    return NULL;\n+\n+  /* The INSN is the end of prologue note, before this we expect to find\n+     one real instruction which makes the prologue, and before that we\n+     expect to find some number of notes for deleted instructions, the\n+     beginning of the function, and finally a basicblock beginning.  The\n+     following loop checks that this assumption is true.  */\n+  for (bb_note = PREV_INSN (PREV_INSN (insn));\n+       bb_note != NULL;\n+       bb_note = PREV_INSN (bb_note))\n+    {\n+      if (!NOTE_P (bb_note))\n+\treturn NULL;\n+      if (NOTE_KIND (bb_note) == NOTE_INSN_BASIC_BLOCK)\n+\tbreak;\n+      if (NOTE_KIND (bb_note) != NOTE_INSN_DELETED\n+\t  && NOTE_KIND (bb_note) != NOTE_INSN_FUNCTION_BEG)\n+\treturn NULL;\n+    }\n+  if (bb_note == NULL)\n+    return NULL;\n+\n+  /* Set INSN to point to the actual interesting prologue instruction.  */\n+  insn = PREV_INSN (insn);\n+  if (INSN_P (insn)\n+      && INSN_CODE (insn) == CODE_FOR_gpr_save\n+      /* Check this is a call to _riscv_save_0.  */\n+      && GET_CODE (PATTERN (insn)) == PARALLEL\n+      && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == UNSPEC_VOLATILE\n+      && (GET_CODE (XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 0))\n+\t  == CONST_INT)\n+      && XINT (XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 0), 0) == 2)\n+    return insn;\n+\n+  return NULL;\n+}\n+\n+/* Find the first instruction in the epilogue of the current function, and\n+   return a pointer to that instruction if, and only if, the epilogue has\n+   the correct structure that would allow us to optimize out the call to\n+   _riscv_restore_0.  */\n+\n+static rtx_insn *\n+riscv_sr_match_epilogue (void)\n+{\n+  /* Find the first instruction in the epilogue.  */\n+  rtx_insn *insn, *start;\n+  for (insn = get_insns (); insn != NULL; insn = NEXT_INSN (insn))\n+    if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_EPILOGUE_BEG)\n+      {\n+\tinsn = NEXT_INSN (insn);\n+\tbreak;\n+      }\n+  if (insn == NULL)\n+    return NULL;\n+\n+  /* At this point INSN is the first instruction in the epilogue.  A\n+     standard epilogue (of the form we expect to handle) consists of the\n+     following instructions:\n+\n+     1. A stack_tiesi or stack_tiedi (for RV32 and RV64 respectively),\n+\n+     2. An optional use instruction for the register holding the return\n+        value.  This will be missing in functions with no return value,\n+\n+     3. A gpr_restore instruction, and\n+\n+     4. A jump instruction of type gpr_restore_return.  */\n+  start = insn;\n+  if (INSN_CODE (insn) != CODE_FOR_stack_tiesi\n+      && INSN_CODE (insn) != CODE_FOR_stack_tiedi)\n+    return NULL;\n+\n+  insn = NEXT_INSN (insn);\n+  if (INSN_P (insn) && GET_CODE (PATTERN (insn)) == USE)\n+    insn = NEXT_INSN (insn);\n+\n+  if (!INSN_P (insn) || INSN_CODE (insn) != CODE_FOR_gpr_restore)\n+    return NULL;\n+\n+  insn = NEXT_INSN (insn);\n+  if (!INSN_P (insn) || INSN_CODE (insn) != CODE_FOR_gpr_restore_return)\n+    return NULL;\n+\n+  return start;\n+}\n+\n+/* Helper for riscv_remove_unneeded_save_restore_calls.  If we match the\n+   prologue instructions but not the epilogue then we might have the case\n+   where the epilogue has been optimized out due to a call to a no-return\n+   function.  In this case we might be able to remove the prologue too -\n+   that's what this function does.  PROLOGUE is the matched prolgoue\n+   instruction, by the time this function returns the progloue instruction\n+   may have been removed.  */\n+\n+static void\n+check_for_no_return_call (rtx_insn *prologue)\n+{\n+  /* Check to see if we have the following pattern:\n+\n+     PROLOGUE instruction\n+     NOTE_INSN_PROLOGUE_END\n+     A no-return call instruction\n+\n+     If we do, then we can remove the prologue instruction safely. Remember\n+     that we've already confirmed by this point that the prologue is a call\n+     to riscv_save_0.  */\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"Prologue matched, checking for no-return epilogue.\\n\");\n+\n+  rtx_insn *tmp = NEXT_INSN (prologue);\n+  if (!NOTE_P (tmp) || NOTE_KIND (tmp) != NOTE_INSN_PROLOGUE_END)\n+    return;\n+\n+  /* Skip any extra notes in here, they're most likely just debug.  */\n+  do\n+    {\n+      tmp = NEXT_INSN (tmp);\n+    }\n+  while (tmp != NULL && NOTE_P (tmp));\n+\n+  if (tmp == NULL || !INSN_P (tmp))\n+    return;\n+\n+  bool noreturn_p = find_reg_note (tmp, REG_NORETURN, NULL_RTX) != NULL_RTX;\n+  if (!CALL_P (tmp) || !noreturn_p)\n+    return;\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"Prologue call to riscv_save_0 followed by noreturn call, \"\n+\t     \"removing prologue.\\n\");\n+  remove_insn (prologue);\n+}\n+\n+/* Entry point called from riscv_reorg to remove some unneeded calls to\n+   the save and restore stubs.  This should only be called when\n+   -msave-restore is in use.\n+\n+   We identify some simple cases where the function looks like this:\n+\n+   call t0,__riscv_save_0\n+   <other-code>\n+   call foo\n+   tail __riscv_restore_0\n+\n+   And transform it into something like this:\n+\n+   <other-code>\n+   tail foo\n+\n+   In the above examples, what can appear in <other-code> is pretty\n+   restricted; only caller saved registers can be touched, this prevents\n+   any additional calls (as they would write to 'ra').  */\n+\n+void\n+riscv_remove_unneeded_save_restore_calls (void)\n+{\n+  /* Will point to the first instruction of the function body, after the\n+     prologue end note.  */\n+  rtx_insn *body = NULL;\n+\n+  /* Should only be called with -msave-restore is in use.  */\n+  gcc_assert (TARGET_SAVE_RESTORE);\n+\n+  /* Match the expected prologue and epilogue patterns.  If either of these\n+     fail to match then we abandon our attempt to optimize this function.  */\n+  rtx_insn *prologue_matched = riscv_sr_match_prologue (&body);\n+  if (prologue_matched == NULL || body == NULL)\n+    return;\n+\n+  rtx_insn *epilogue_matched = riscv_sr_match_epilogue ();\n+  if (epilogue_matched == NULL)\n+    {\n+      check_for_no_return_call (prologue_matched);\n+      return;\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"Could be a candidate for save/restore removal\\n\");\n+\n+  /* We want to check which registers this function uses.  */\n+  df_analyze ();\n+\n+  int call_count = 0;\n+  bool good_use = true;\n+  int epilogue_count = 0;\n+\n+  /* Now examine all of the instructions that make up this function, we're\n+     looking for call instructions and also double checking register usage\n+     while we're at it (see comments below).  */\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      rtx_insn *insn;\n+\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Block %d, Insn %d\\n\", bb->index, INSN_UID (insn));\n+\n+\t  /* If we scan the epilogue we will fall foul of our register\n+\t     usage check below (due to it's use of the return address), so\n+\t     once we spot we're at the epilogue, just skip the rest of this\n+\t     block.  Scanning the prologue instructions again (if they\n+\t     match the expected pattern) is harmless.  */\n+\t  if (NOTE_P (insn)\n+\t      && NOTE_KIND (insn) == NOTE_INSN_EPILOGUE_BEG)\n+\t    {\n+\t      ++epilogue_count;\n+\t      break;\n+\t    }\n+\n+\t  if (!INSN_P (insn))\n+\t    continue;\n+\n+\t  if (CALL_P (insn))\n+\t    ++call_count;\n+\t  else\n+\t    {\n+\t      df_ref use;\n+\n+\t      FOR_EACH_INSN_USE (use, insn)\n+\t\t{\n+\t\t  /* If the function makes use of any registers that are\n+\t\t     callee saved then we should be saving them in this\n+\t\t     function, which would suggest that a call to the save\n+\t\t     and restore functions is required.  This would seem to\n+\t\t     indicate that something has gone wrong above, as we\n+\t\t     should only get here if we are saving zero registers.\n+\n+\t\t     The one exception to this rule is the return address\n+\t\t     register used within a call instruction.  We can\n+\t\t     optimize a single call within a function (by making it\n+\t\t     a tail call), so we skip call instructions here.  */\n+\t\t  if (!call_used_regs[DF_REF_REGNO (use)])\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \"Found unsupported use of callee saved \"\n+\t\t\t\t \"register in instruction %d\\n\",\n+\t\t\t\t INSN_UID (insn));\n+\t\t      good_use = false;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (!good_use)\n+\t\tbreak;\n+\t    }\n+\t}\n+    }\n+\n+  /* If we used any registers that would indicate a need for a call to a\n+     save/restore stub then don't optimize.  */\n+  if (!good_use)\n+    return;\n+\n+  /* If this function has multiple epilogues, then for now we don't try to\n+     optimize it.  */\n+  if (epilogue_count != 1)\n+    return;\n+\n+  /* We can only optimize functions containing a single call, any more\n+     would require us to add instructions to store the return address on\n+     the stack (and restore it before we return).  We could do this in the\n+     future, but for now we don't.  A single call can be transformed into\n+     a tail call reasonably easily.  */\n+  if (call_count > 1)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Found too many call instructions\\n\");\n+      return;\n+    }\n+\n+  rtx_insn *epilogue_begin_note = PREV_INSN (epilogue_matched);\n+  gcc_assert (NOTE_P (epilogue_begin_note)\n+\t      && NOTE_KIND (epilogue_begin_note) == NOTE_INSN_EPILOGUE_BEG);\n+\n+  df_finish_pass (false);\n+\n+  /* Find the first instruction before the function epilogue.  */\n+  rtx_insn *insn_before_epilogue;\n+  for (insn_before_epilogue = PREV_INSN (epilogue_begin_note);\n+       NOTE_P (insn_before_epilogue);\n+       insn_before_epilogue = PREV_INSN (insn_before_epilogue))\n+    ;\n+\n+  /* Leaf functions will not generate calls to the save/restore stubs, so\n+     there's no need for this optimization there.  We know this function\n+     has no more than 1 call (checked above).  To convert this single call\n+     into a tail call we rely on the call being the last thing before the\n+     epilogue.  */\n+  if (GET_CODE (insn_before_epilogue) != CALL_INSN)\n+    return;\n+\n+  /* The last instruction in this block, just before the epilogue is a\n+     call.  We can potentially change this call into a tail call.  */\n+  rtx_insn *call = insn_before_epilogue;\n+\n+  /* Transform call in insn to a sibcall, this will only be done if the\n+     last thing in the function is a call.  */\n+  rtx callpat = PATTERN (call);\n+  gcc_assert (GET_CODE (callpat) == PARALLEL);\n+\n+  /* Extract from CALLPAT the information we need to build the sibcall.  */\n+  rtx target_call = NULL;\n+  rtx tmp_rtx = XVECEXP (callpat, 0, 0);\n+  rtx set_target = NULL;\n+  switch (GET_CODE (tmp_rtx))\n+    {\n+    case CALL:\n+      target_call = tmp_rtx;\n+      break;\n+\n+    case SET:\n+      {\n+\tset_target = XEXP (tmp_rtx, 0);\n+\ttmp_rtx = XEXP (tmp_rtx, 1);\n+\tif (GET_CODE (tmp_rtx) != CALL)\n+\t  return;\n+\ttarget_call = tmp_rtx;\n+\tbreak;\n+      }\n+\n+    default:\n+      return;\n+    }\n+\n+  rtx target_mem = XEXP (target_call, 0);\n+  if (GET_CODE (target_mem) != MEM)\n+    return;\n+\n+  rtx target = XEXP (target_mem, 0);\n+  if (GET_CODE (target) != SYMBOL_REF && GET_CODE (target) != REG)\n+    return;\n+\n+  /* The sibcall instructions can only use a specific subset of\n+     registers, we're about to (possibly) move a call through a\n+     register from the function body and make it a sibcall.  If we're\n+     not using an appropriate register then we can't make this change.\n+\n+     Maybe in some future iteration we could actually scan the\n+     function, find a suitable sibcall register, and switch over the\n+     registers.  But we don't do that yet.  */\n+  if (GET_CODE (target) == REG\n+      && !SIBCALL_REG_P (REGNO (target)))\n+    return;\n+\n+  rtx sibcall = NULL;\n+  if (set_target != NULL)\n+    sibcall\n+      = gen_sibcall_value_internal (set_target, target, const0_rtx);\n+  else\n+    sibcall = gen_sibcall_internal (target, const0_rtx);\n+\n+  rtx_insn *before_call = PREV_INSN (call);\n+  remove_insn (call);\n+  rtx_insn *insn = emit_call_insn_after_setloc (sibcall, before_call,\n+\t\t\t\t\t\tINSN_LOCATION (call));\n+  REG_NOTES (insn) = REG_NOTES (call);\n+  SIBLING_CALL_P (insn) = 1;\n+\n+  /* Now update the prologue and epilogue to take account of the\n+     changes within the function body.  */\n+  remove_insn (prologue_matched);\n+  remove_insn (NEXT_INSN (NEXT_INSN (NEXT_INSN (epilogue_matched))));\n+  remove_insn (NEXT_INSN (NEXT_INSN (epilogue_matched)));\n+  remove_insn (NEXT_INSN (epilogue_matched));\n+  remove_insn (epilogue_matched);\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"Save/restore successfully removed\\n\");\n+}"}, {"sha": "11a43c1b64d4485aa0340af21d5d772d7913e008", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -5007,6 +5007,16 @@ riscv_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n   return mode;\n }\n \n+/* Implement TARGET_MACHINE_DEPENDENT_REORG.  */\n+\n+static void\n+riscv_reorg (void)\n+{\n+  /* Do nothing unless we have -msave-restore */\n+  if (TARGET_SAVE_RESTORE)\n+    riscv_remove_unneeded_save_restore_calls ();\n+}\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.half\\t\"\n@@ -5181,6 +5191,9 @@ riscv_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 1\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG riscv_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-riscv.h\""}, {"sha": "b1e3403f8a762e661402f4862b11128d9965fc27", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -289,6 +289,10 @@ along with GCC; see the file COPYING3.  If not see\n #define FP_REG_P(REGNO)  \\\n   ((unsigned int) ((int) (REGNO) - FP_REG_FIRST) < FP_REG_NUM)\n \n+/* True when REGNO is in SIBCALL_REGS set.  */\n+#define SIBCALL_REG_P(REGNO)\t\\\n+  TEST_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], REGNO)\n+\n #define FP_REG_RTX_P(X) (REG_P (X) && FP_REG_P (REGNO (X)))\n \n /* Use s0 as the frame pointer if it is so requested.  */\n@@ -918,4 +922,8 @@ extern unsigned riscv_stack_boundary;\n #define SWSP_REACH (4LL << C_SxSP_BITS)\n #define SDSP_REACH (8LL << C_SxSP_BITS)\n \n+/* Called from RISCV_REORG, this is defined in riscv-sr.c.  */\n+\n+extern void riscv_remove_unneeded_save_restore_calls (void);\n+\n #endif /* ! GCC_RISCV_H */"}, {"sha": "5ecb3c160a6196740517e987df943b578edeb110", "filename": "gcc/config/riscv/t-riscv", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Fconfig%2Friscv%2Ft-riscv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Fconfig%2Friscv%2Ft-riscv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-riscv?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -5,6 +5,11 @@ riscv-builtins.o: $(srcdir)/config/riscv/riscv-builtins.c $(CONFIG_H) \\\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$(srcdir)/config/riscv/riscv-builtins.c\n \n+riscv-sr.o: $(srcdir)/config/riscv/riscv-sr.c $(CONFIG_H) \\\n+  $(SYSTEM_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/riscv/riscv-sr.c\n+\n riscv-c.o: $(srcdir)/config/riscv/riscv-c.c $(CONFIG_H) $(SYSTEM_H) \\\n     coretypes.h $(TM_H) $(TREE_H) output.h $(C_COMMON_H) $(TARGET_H)\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\"}, {"sha": "14b3147d8478fcaa3c86200dfd42fcc283c277aa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -1,3 +1,13 @@\n+2019-10-28  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gcc.target/riscv/save-restore-2.c: New file.\n+\t* gcc.target/riscv/save-restore-3.c: New file.\n+\t* gcc.target/riscv/save-restore-4.c: New file.\n+\t* gcc.target/riscv/save-restore-5.c: New file.\n+\t* gcc.target/riscv/save-restore-6.c: New file.\n+\t* gcc.target/riscv/save-restore-7.c: New file.\n+\t* gcc.target/riscv/save-restore-8.c: New file.\n+\n 2019-10-28  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \tPR tree-optimization/92163"}, {"sha": "204bf67b66e5edfab043b1a07f6c319aa0519973", "filename": "gcc/testsuite/gcc.target/riscv/save-restore-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-2.c?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-options \"-Os -msave-restore\" } */\n+\n+/* With -msave-restore in use it should not be possible to remove the calls\n+   to the save and restore stubs in this case (in current GCC).  */\n+\n+extern void fn2 ();\n+\n+volatile int a = 0;\n+\n+int\n+fn1 ()\n+{\n+  fn2 ();\n+\n+  while (a)\n+    ;\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"call\\[ \\t\\]*t0,__riscv_save_0\" } } */\n+/* { dg-final { scan-assembler \"tail\\[ \\t\\]*__riscv_restore_0\" } } */"}, {"sha": "6bf9fb014d6b0bdc8c5cbef0de399bb0e3db88ca", "filename": "gcc/testsuite/gcc.target/riscv/save-restore-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-3.c?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-Os -msave-restore\" } */\n+\n+/* With -msave-restore in use GCC should be able to remove the calls to the\n+   save and restore stubs in this case, replacing them with a tail call to\n+   foo.  */\n+\n+extern int foo ();\n+\n+int bar ()\n+{\n+  return foo ();\n+}\n+\n+/* { dg-final { scan-assembler-not \"call\\[ \\t\\]*t0,__riscv_save_0\" } } */\n+/* { dg-final { scan-assembler-not \"tail\\[ \\t\\]*__riscv_restore_0\" } } */\n+/* { dg-final { scan-assembler \"tail\\[ \\t\\]*foo\" } } */"}, {"sha": "9a0313f2c427eddd41882c69e2e4718294a89a74", "filename": "gcc/testsuite/gcc.target/riscv/save-restore-4.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-4.c?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-options \"-Os -msave-restore\" } */\n+\n+/* This test covers a case where we can't (currently) remove the calls to\n+   the save/restore stubs.  The cast of the return value from BAR requires\n+   a zero extension between the call to BAR, and the return from FOO, this\n+   currently prevents the removal of the save/restore calls.  */\n+\n+typedef unsigned long long u_64;\n+typedef unsigned int u_32;\n+\n+extern u_32 bar (u_32 arg);\n+\n+u_64 foo (u_32 arg)\n+{\n+  return (u_64) bar (arg);\n+}\n+\n+/* { dg-final { scan-assembler \"call\\[ \\t\\]*t0,__riscv_save_0\" } } */\n+/* { dg-final { scan-assembler \"tail\\[ \\t\\]*__riscv_restore_0\" } } */"}, {"sha": "fe0ffdcd50446a7f569c7df7bfac07520a29e0df", "filename": "gcc/testsuite/gcc.target/riscv/save-restore-5.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-5.c?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -0,0 +1,9 @@\n+typedef int (*FPTR) (void);\n+FPTR a;\n+\n+int\n+func ()\n+{\n+  int b = a ();\n+  return b;\n+}"}, {"sha": "530865456a22b61d1162e4ec68ee8145f55bbcc0", "filename": "gcc/testsuite/gcc.target/riscv/save-restore-6.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-6.c?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-Os -msave-restore\" } */\n+\n+/* With -msave-restore in use GCC should be able to remove the calls to the\n+   save and restore stubs in this case, replacing them with a tail call to\n+   other_func.  */\n+\n+extern void other_func ();\n+\n+void func ()\n+{\n+  other_func ();\n+}\n+\n+/* { dg-final { scan-assembler-not \"call\\[ \\t\\]*t0,__riscv_save_0\" } } */\n+/* { dg-final { scan-assembler-not \"tail\\[ \\t\\]*__riscv_restore_0\" } } */\n+/* { dg-final { scan-assembler \"tail\\[ \\t\\]*other_func\" } } */"}, {"sha": "06719c4e41383e80cbca6201b7b555219da35930", "filename": "gcc/testsuite/gcc.target/riscv/save-restore-7.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-7.c?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-options \"-Os -msave-restore\" } */\n+\n+/* With -msave-restore in use it should not be possible to remove the calls\n+   to the save and restore stubs in this case (in current GCC).  */\n+\n+enum\n+  {\n+   VAL_A,\n+   VAL_B,\n+   VAL_C,\n+   VAL_D\n+  } a;\n+\n+extern void other_1 ();\n+extern void other_2 ();\n+\n+void func ()\n+{\n+  switch (a)\n+    {\n+    case VAL_B:\n+    case VAL_C:\n+      other_1 ();\n+    case VAL_D:\n+      other_2 ();\n+    }\n+}\n+\n+/* { dg-final { scan-assembler \"call\\[ \\t\\]*t0,__riscv_save_0\" } } */\n+/* { dg-final { scan-assembler \"tail\\[ \\t\\]*__riscv_restore_0\" } } */"}, {"sha": "8880cd288eea87a7be59bdc0971aa6c5a7f7d809", "filename": "gcc/testsuite/gcc.target/riscv/save-restore-8.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18a6d1441cfb5d43d3193a2643207fc3f95fd5a/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fsave-restore-8.c?ref=e18a6d1441cfb5d43d3193a2643207fc3f95fd5a", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-options \"-Os -msave-restore\" } */\n+\n+/* As a leaf function this should never have the calls to the save and\n+   restore stubs added, but lets check anyway.  */\n+\n+int func ()\n+{\n+  return 3;\n+}\n+\n+/* { dg-final { scan-assembler-not \"call\\[ \\t\\]*t0,__riscv_save_0\" } } */\n+/* { dg-final { scan-assembler-not \"tail\\[ \\t\\]*__riscv_restore_0\" } } */"}]}