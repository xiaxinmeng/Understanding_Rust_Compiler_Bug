{"sha": "7b4db06ceeb85373d9bd52fb68eec77600455f12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I0ZGIwNmNlZWI4NTM3M2Q5YmQ1MmZiNjhlZWM3NzYwMDQ1NWYxMg==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2009-07-10T09:30:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-10T09:30:44Z"}, "message": "exp_ch3.adb (Expand_Freeze_Record_Type): Handle constructors of non-tagged record types.\n\n2009-07-10  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch3.adb (Expand_Freeze_Record_Type): Handle constructors of\n\tnon-tagged record types.\n\n\t* sem_prag.adb\n\t(Process_Import_Or_Interface): Allow the use of \"pragma Import (CPP,..)\"\n\twith non-tagged types. Required to import C++ classes that have no\n\tvirtual primitives.\n\t(Analyze_Pragma): For pragma CPP_Constructor. Allow the use of functions\n\treturning non-tagged types. For backward compatibility, if the\n\tconstructor returns a class wide type we internally change the\n\treturned type to the corresponding non class-wide type.\n\n\t* sem_aggr.adb\n\t(Valid_Ancestor_Type): CPP_Constructors code cleanup.\n\t(Resolve_Extension_Aggregate): CPP_Constructors code cleanup.\n\t(Resolve_Aggr_Expr): CPP_Constructors code cleanup.\n\t(Resolve_Record_Aggregate): CPP_Constructors code cleanup.\n\n\t* sem_ch3.adb\n\t(Analyze_Object_Declaration): CPP_Constructors code cleanup.\n\n\t* sem_ch5.adb (Analyze_Assignment): CPP_Constructors code cleanup.\n\n\t* sem_util.adb (Is_CPP_Constructor_Call): Code cleanup.\n\n\t* sem_res.adb (Resolve_Allocator): CPP_Constructors code cleanup.\n\n\t* exp_ch4.adb (Expand_Allocator_Expression): CPP_Constructors code\n\tcleanup.\n\t\n\t* exp_aggr.adb (Build_Record_Aggr_Code): CPP_Constructors code clean up.\n\n\t* gnat_rm.texi\n\t(pragma CPP_Class): Document that it can be used now with non-tagged\n\trecord types.\n\t(pragma CPP_Constructor): Document that it can be used now with\n\tfunctions returning specific types. For backward compatibility\n\twe also support functions returning class-wide types.\n\n\t* gnat_ugn.texi\n\t(Interfacing with C++ constructors): Update the examples to incorporate\n\tthe new syntax in which the functions used to import C++ constructors\n\treturn specific types.\n\t(Interfacing with C++ at the Class Level): Update the examples to\n\tincorporate the new syntax in which the functions used to import\n\tC++ constructors return specific types.\n\nFrom-SVN: r149466", "tree": {"sha": "41ab0fc08d1c87bf5e938cb42b0fcb2af63f480e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41ab0fc08d1c87bf5e938cb42b0fcb2af63f480e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b4db06ceeb85373d9bd52fb68eec77600455f12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b4db06ceeb85373d9bd52fb68eec77600455f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b4db06ceeb85373d9bd52fb68eec77600455f12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b4db06ceeb85373d9bd52fb68eec77600455f12/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f2abc637c35d07f2d742a6069f631e015affb026", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2abc637c35d07f2d742a6069f631e015affb026", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2abc637c35d07f2d742a6069f631e015affb026"}], "stats": {"total": 308, "additions": 188, "deletions": 120}, "files": [{"sha": "bdcea2315918b6d32a4b501000fe1a6e8cdc33d9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7b4db06ceeb85373d9bd52fb68eec77600455f12", "patch": "@@ -1,3 +1,52 @@\n+2009-07-10  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_Freeze_Record_Type): Handle constructors of\n+\tnon-tagged record types.\n+\n+\t* sem_prag.adb\n+\t(Process_Import_Or_Interface): Allow the use of \"pragma Import (CPP,..)\"\n+\twith non-tagged types. Required to import C++ classes that have no\n+\tvirtual primitives.\n+\t(Analyze_Pragma): For pragma CPP_Constructor. Allow the use of functions\n+\treturning non-tagged types. For backward compatibility, if the\n+\tconstructor returns a class wide type we internally change the\n+\treturned type to the corresponding non class-wide type.\n+\n+\t* sem_aggr.adb\n+\t(Valid_Ancestor_Type): CPP_Constructors code cleanup.\n+\t(Resolve_Extension_Aggregate): CPP_Constructors code cleanup.\n+\t(Resolve_Aggr_Expr): CPP_Constructors code cleanup.\n+\t(Resolve_Record_Aggregate): CPP_Constructors code cleanup.\n+\n+\t* sem_ch3.adb\n+\t(Analyze_Object_Declaration): CPP_Constructors code cleanup.\n+\n+\t* sem_ch5.adb (Analyze_Assignment): CPP_Constructors code cleanup.\n+\n+\t* sem_util.adb (Is_CPP_Constructor_Call): Code cleanup.\n+\n+\t* sem_res.adb (Resolve_Allocator): CPP_Constructors code cleanup.\n+\n+\t* exp_ch4.adb (Expand_Allocator_Expression): CPP_Constructors code\n+\tcleanup.\n+\t\n+\t* exp_aggr.adb (Build_Record_Aggr_Code): CPP_Constructors code clean up.\n+\n+\t* gnat_rm.texi\n+\t(pragma CPP_Class): Document that it can be used now with non-tagged\n+\trecord types.\n+\t(pragma CPP_Constructor): Document that it can be used now with\n+\tfunctions returning specific types. For backward compatibility\n+\twe also support functions returning class-wide types.\n+\n+\t* gnat_ugn.texi\n+\t(Interfacing with C++ constructors): Update the examples to incorporate\n+\tthe new syntax in which the functions used to import C++ constructors\n+\treturn specific types.\n+\t(Interfacing with C++ at the Class Level): Update the examples to\n+\tincorporate the new syntax in which the functions used to import\n+\tC++ constructors return specific types.\n+\n 2009-07-10  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_disp.adb (Make_Disp_Asynchronous_Select_Body,"}, {"sha": "a65a7139eddfecff4fc9913194e5074b799af155", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=7b4db06ceeb85373d9bd52fb68eec77600455f12", "patch": "@@ -2380,9 +2380,8 @@ package body Exp_Aggr is\n       end Gen_Ctrl_Actions_For_Aggr;\n \n       function Rewrite_Discriminant (Expr : Node_Id) return Traverse_Result;\n-      --  If the default expression of a component mentions a discriminant of\n-      --  the type, it has to be rewritten as the discriminant of the target\n-      --  object.\n+      --  If default expression of a component mentions a discriminant of the\n+      --  type, it must be rewritten as the discriminant of the target object.\n \n       function Replace_Type (Expr : Node_Id) return Traverse_Result;\n       --  If the aggregate contains a self-reference, traverse each expression\n@@ -2402,7 +2401,7 @@ package body Exp_Aggr is\n          then\n             Rewrite (Expr,\n               Make_Selected_Component (Loc,\n-                Prefix => New_Occurrence_Of (Obj, Loc),\n+                Prefix        => New_Occurrence_Of (Obj, Loc),\n                 Selector_Name => Make_Identifier (Loc, Chars (Expr))));\n          end if;\n          return OK;\n@@ -2565,7 +2564,7 @@ package body Exp_Aggr is\n             --  Handle calls to C++ constructors\n \n             elsif Is_CPP_Constructor_Call (A) then\n-               Init_Typ := Etype (Etype (A));\n+               Init_Typ := Etype (A);\n                Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n                Set_Assignment_OK (Ref);\n \n@@ -3053,7 +3052,7 @@ package body Exp_Aggr is\n                Instr :=\n                  Make_OK_Assignment_Statement (Loc,\n                    Name       => Comp_Expr,\n-                   Expression =>  Expr_Q);\n+                   Expression => Expr_Q);\n \n                Set_No_Ctrl_Actions (Instr);\n                Append_To (L, Instr);"}, {"sha": "cb8e41e0b0c8e40629dae76b40afd49f424709a3", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=7b4db06ceeb85373d9bd52fb68eec77600455f12", "patch": "@@ -5702,6 +5702,14 @@ package body Exp_Ch3 is\n          Next_Component (Comp);\n       end loop;\n \n+      --  Handle constructors of non-tagged CPP_Class types\n+\n+      if not Is_Tagged_Type (Def_Id)\n+        and then Is_CPP_Class (Def_Id)\n+      then\n+         Set_CPP_Constructors (Def_Id);\n+      end if;\n+\n       --  Creation of the Dispatch Table. Note that a Dispatch Table is built\n       --  for regular tagged types as well as for Ada types deriving from a C++\n       --  Class, but not for tagged types directly corresponding to C++ classes"}, {"sha": "7cfcaeed200492714f594e6b065444ac54d07536", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=7b4db06ceeb85373d9bd52fb68eec77600455f12", "patch": "@@ -580,8 +580,7 @@ package body Exp_Ch4 is\n             --  Allocate the object with no expression\n \n             Node := Relocate_Node (N);\n-            Set_Expression (Node,\n-              New_Reference_To (Root_Type (Etype (Exp)), Loc));\n+            Set_Expression (Node, New_Reference_To (Etype (Exp), Loc));\n \n             --  Avoid its expansion to avoid generating a call to the default\n             --  C++ constructor\n@@ -615,7 +614,7 @@ package body Exp_Ch4 is\n                    Id_Ref =>\n                      Make_Explicit_Dereference (Loc,\n                        Prefix => New_Reference_To (Temp, Loc)),\n-                   Typ => Root_Type (Etype (Exp)),\n+                   Typ => Etype (Exp),\n                    Constructor_Ref => Exp));\n             end;\n "}, {"sha": "3e85ef79921d842a05c82505b5be6fd4f7b56690", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=7b4db06ceeb85373d9bd52fb68eec77600455f12", "patch": "@@ -1494,9 +1494,10 @@ pragma CPP_Class ([Entity =>] LOCAL_NAME);\n \n @noindent\n The argument denotes an entity in the current declarative region that is\n-declared as a tagged record type. It indicates that the type corresponds\n-to an externally declared C++ class type, and is to be laid out the same\n-way that C++ would lay out the type.\n+declared as a record type. It indicates that the type corresponds to an\n+externally declared C++ class type, and is to be laid out the same way\n+that C++ would lay out the type. If the C++ class has virtual primitives\n+then the record must be declared as a tagged record type.\n \n Types for which @code{CPP_Class} is specified do not have assignment or\n equality operators defined (such operations can be imported or declared\n@@ -1534,22 +1535,30 @@ with pragma @code{Import}) as corresponding to a C++ constructor. If\n in a pragma @code{Import} with @code{Convention} = @code{CPP}. Such name\n must be of one of the following forms:\n \n+@itemize @bullet\n+@item\n+@code{function @var{Fname} return @var{T}}\n+\n @itemize @bullet\n @item\n @code{function @var{Fname} return @var{T}'Class}\n \n+@item\n+@code{function @var{Fname} (@dots{}) return @var{T}}\n+@end itemize\n+\n @item\n @code{function @var{Fname} (@dots{}) return @var{T}'Class}\n @end itemize\n \n @noindent\n-where @var{T} is a tagged limited type imported from C++ with pragma\n+where @var{T} is a limited record type imported from C++ with pragma\n @code{Import} and @code{Convention} = @code{CPP}.\n \n-The first form is the default constructor, used when an object of type\n-@var{T} is created on the Ada side with no explicit constructor.  The\n-second form covers all the non-default constructors of the type. See\n-the GNAT users guide for details.\n+The first two forms import the default constructor, used when an object\n+of type @var{T} is created on the Ada side with no explicit constructor.\n+The latter two forms cover all the non-default constructors of the type.\n+See the GNAT users guide for details.\n \n If no constructors are imported, it is impossible to create any objects\n on the Ada side and the type is implicitly declared abstract.\n@@ -1558,6 +1567,12 @@ Pragma @code{CPP_Constructor} is intended primarily for automatic generation\n using an automatic binding generator tool.\n See @ref{Interfacing to C++} for more related information.\n \n+Note: The use of functions returning class-wide types for constructors is\n+currently obsolete. They are supported for backward compatibility. The\n+use of functions returning the type T leave the Ada sources more clear\n+because the imported C++ constructors always return an object of type T;\n+that is, they never return an object whose type is a descendant of type T.\n+\n @node Pragma CPP_Virtual\n @unnumberedsec Pragma CPP_Virtual\n @cindex Interfacing to C++"}, {"sha": "4242ef07304e2803e0951cdf159ca428a3230c68", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=7b4db06ceeb85373d9bd52fb68eec77600455f12", "patch": "@@ -3278,13 +3278,13 @@ package Pkg_Root is\n   function Get_Value (Obj : Root) return int;\n   pragma Import (CPP, Get_Value);\n \n-  function Constructor return Root'Class;\n+  function Constructor return Root;\n   pragma Cpp_Constructor (Constructor, \"_ZN4RootC1Ev\");\n \n-  function Constructor (v : Integer) return Root'Class;\n+  function Constructor (v : Integer) return Root;\n   pragma Cpp_Constructor (Constructor, \"_ZN4RootC1Ei\");\n \n-  function Constructor (v, w : Integer) return Root'Class;\n+  function Constructor (v, w : Integer) return Root;\n   pragma Cpp_Constructor (Constructor, \"_ZN4RootC1Eii\");\n end Pkg_Root;\n @end smallexample\n@@ -3527,7 +3527,7 @@ package Animals is\n   procedure Set_Owner (A : in out Dog; Name : Chars_Ptr);\n   pragma Import (C_Plus_Plus, Set_Owner);\n \n-  function New_Dog return Dog'Class;\n+  function New_Dog return Dog;\n   pragma CPP_Constructor (New_Dog);\n   pragma Import (CPP, New_Dog, \"_ZN3DogC2Ev\");\n end Animals;\n@@ -22833,7 +22833,7 @@ The corresponding Ada code is generated:\n       (this : access Dog; Name : Interfaces.C.Strings.chars_ptr);\n     pragma Import (CPP, Set_Owner, \"_ZN3Dog9Set_OwnerEPc\");\n \n-    function New_Dog return Dog'Class;\n+    function New_Dog return Dog;\n     pragma CPP_Constructor (New_Dog);\n     pragma Import (CPP, New_Dog, \"_ZN3DogC1Ev\");\n   end;"}, {"sha": "b160b9287a17d6acdd26bb2345ae3e2afd0f3a32", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=7b4db06ceeb85373d9bd52fb68eec77600455f12", "patch": "@@ -2183,11 +2183,6 @@ package body Sem_Aggr is\n             if Etype (Imm_Type) = Base_Type (A_Type) then\n                return True;\n \n-            elsif Is_CPP_Constructor_Call (A)\n-              and then Etype (Imm_Type) = Base_Type (Etype (A_Type))\n-            then\n-               return True;\n-\n             --  The base type of the parent type may appear as  a private\n             --  extension if it is declared as such in a parent unit of\n             --  the current one. For consistency of the subsequent analysis\n@@ -2303,7 +2298,6 @@ package body Sem_Aggr is\n \n             if Is_Class_Wide_Type (Etype (A))\n               and then Nkind (Original_Node (A)) = N_Function_Call\n-              and then not Is_CPP_Constructor_Call (Original_Node (A))\n             then\n                --  If the ancestor part is a dispatching call, it appears\n                --  statically to be a legal ancestor, but it yields any\n@@ -2795,9 +2789,7 @@ package body Sem_Aggr is\n \n          --  Check wrong use of class-wide types\n \n-         if Is_Class_Wide_Type (Etype (Expr))\n-           and then not Is_CPP_Constructor_Call (Expr)\n-         then\n+         if Is_Class_Wide_Type (Etype (Expr)) then\n             Error_Msg_N (\"dynamically tagged expression not allowed\", Expr);\n          end if;\n \n@@ -3100,21 +3092,7 @@ package body Sem_Aggr is\n             --  ancestors, starting with the root.\n \n             if Nkind (N) = N_Extension_Aggregate then\n-\n-               --  Handle case where ancestor part is a C++ constructor. In\n-               --  this case it must be a function returning a class-wide type.\n-               --  If the ancestor part is a C++ constructor, then it must be a\n-               --  function returning a class-wide type, so handle that here.\n-\n-               if Is_CPP_Constructor_Call (Ancestor_Part (N)) then\n-                  pragma Assert\n-                    (Is_Class_Wide_Type (Etype (Ancestor_Part (N))));\n-                  Root_Typ := Root_Type (Etype (Ancestor_Part (N)));\n-\n-               --  Normal case, not a C++ constructor\n-               else\n-                  Root_Typ := Base_Type (Etype (Ancestor_Part (N)));\n-               end if;\n+               Root_Typ := Base_Type (Etype (Ancestor_Part (N)));\n \n             else\n                Root_Typ := Root_Type (Typ);"}, {"sha": "c6a10e01b86a0e8dd1633f4822b5e580fece97af", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7b4db06ceeb85373d9bd52fb68eec77600455f12", "patch": "@@ -2631,7 +2631,6 @@ package body Sem_Ch3 is\n          if (Is_Class_Wide_Type (Etype (E)) or else Is_Dynamically_Tagged (E))\n            and then Is_Tagged_Type (T)\n            and then not Is_Class_Wide_Type (T)\n-           and then not Is_CPP_Constructor_Call (E)\n          then\n             Error_Msg_N (\"dynamically tagged expression not allowed!\", E);\n          end if;"}, {"sha": "8402e3318afada1d6169b238da36e9b29bcf12f0", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=7b4db06ceeb85373d9bd52fb68eec77600455f12", "patch": "@@ -549,7 +549,6 @@ package body Sem_Ch5 is\n            or else (Is_Dynamically_Tagged (Rhs)\n                      and then not Is_Access_Type (T1)))\n         and then not Is_Class_Wide_Type (T1)\n-        and then not Is_CPP_Constructor_Call (Rhs)\n       then\n          Error_Msg_N (\"dynamically tagged expression not allowed!\", Rhs);\n "}, {"sha": "90de628c663b2c959148dfa26d271eea457b6fdd", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 92, "deletions": 61, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=7b4db06ceeb85373d9bd52fb68eec77600455f12", "patch": "@@ -35,6 +35,7 @@ with Checks;   use Checks;\n with Csets;    use Csets;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Dist; use Exp_Dist;\n with Lib;      use Lib;\n@@ -3553,73 +3554,67 @@ package body Sem_Prag is\n          elsif Is_Record_Type (Def_Id)\n            and then C = Convention_CPP\n          then\n-            if not Is_Tagged_Type (Def_Id) then\n-               Error_Msg_Sloc := Sloc (Def_Id);\n-               Error_Pragma_Arg (\"imported 'C'P'P type must be tagged\", Arg2);\n-\n-            else\n-               --  Types treated as CPP classes are treated as limited, but we\n-               --  don't require them to be declared this way. A warning is\n-               --  issued to encourage the user to declare them as limited.\n-               --  This is not an error, for compatibility reasons, because\n-               --  these types have been supported this way for some time.\n+            --  Types treated as CPP classes are treated as limited, but we\n+            --  don't require them to be declared this way. A warning is\n+            --  issued to encourage the user to declare them as limited.\n+            --  This is not an error, for compatibility reasons, because\n+            --  these types have been supported this way for some time.\n \n-               if not Is_Limited_Type (Def_Id) then\n-                  Error_Msg_N\n-                    (\"imported 'C'P'P type should be \" &\n-                       \"explicitly declared limited?\",\n-                     Get_Pragma_Arg (Arg2));\n-                  Error_Msg_N\n-                    (\"\\type will be considered limited\",\n-                     Get_Pragma_Arg (Arg2));\n-               end if;\n+            if not Is_Limited_Type (Def_Id) then\n+               Error_Msg_N\n+                 (\"imported 'C'P'P type should be \" &\n+                    \"explicitly declared limited?\",\n+                  Get_Pragma_Arg (Arg2));\n+               Error_Msg_N\n+                 (\"\\type will be considered limited\",\n+                  Get_Pragma_Arg (Arg2));\n+            end if;\n \n-               Set_Is_CPP_Class (Def_Id);\n-               Set_Is_Limited_Record (Def_Id);\n+            Set_Is_CPP_Class (Def_Id);\n+            Set_Is_Limited_Record (Def_Id);\n \n-               --  Imported CPP types must not have discriminants (because C++\n-               --  classes do not have discriminants).\n+            --  Imported CPP types must not have discriminants (because C++\n+            --  classes do not have discriminants).\n \n-               if Has_Discriminants (Def_Id) then\n-                  Error_Msg_N\n-                    (\"imported 'C'P'P type cannot have discriminants\",\n-                     First (Discriminant_Specifications\n-                             (Declaration_Node (Def_Id))));\n-               end if;\n+            if Has_Discriminants (Def_Id) then\n+               Error_Msg_N\n+                 (\"imported 'C'P'P type cannot have discriminants\",\n+                  First (Discriminant_Specifications\n+                          (Declaration_Node (Def_Id))));\n+            end if;\n \n-               --  Components of imported CPP types must not have default\n-               --  expressions because the constructor (if any) is in the\n-               --  C++ side.\n+            --  Components of imported CPP types must not have default\n+            --  expressions because the constructor (if any) is in the\n+            --  C++ side.\n \n-               declare\n-                  Tdef  : constant Node_Id :=\n-                            Type_Definition (Declaration_Node (Def_Id));\n-                  Clist : Node_Id;\n-                  Comp  : Node_Id;\n+            declare\n+               Tdef  : constant Node_Id :=\n+                         Type_Definition (Declaration_Node (Def_Id));\n+               Clist : Node_Id;\n+               Comp  : Node_Id;\n \n-               begin\n-                  if Nkind (Tdef) = N_Record_Definition then\n-                     Clist := Component_List (Tdef);\n+            begin\n+               if Nkind (Tdef) = N_Record_Definition then\n+                  Clist := Component_List (Tdef);\n \n-                  else\n-                     pragma Assert (Nkind (Tdef) = N_Derived_Type_Definition);\n-                     Clist := Component_List (Record_Extension_Part (Tdef));\n-                  end if;\n+               else\n+                  pragma Assert (Nkind (Tdef) = N_Derived_Type_Definition);\n+                  Clist := Component_List (Record_Extension_Part (Tdef));\n+               end if;\n \n-                  if Present (Clist) then\n-                     Comp := First (Component_Items (Clist));\n-                     while Present (Comp) loop\n-                        if Present (Expression (Comp)) then\n-                           Error_Msg_N\n-                             (\"component of imported 'C'P'P type cannot have\" &\n-                              \" default expression\", Expression (Comp));\n-                        end if;\n+               if Present (Clist) then\n+                  Comp := First (Component_Items (Clist));\n+                  while Present (Comp) loop\n+                     if Present (Expression (Comp)) then\n+                        Error_Msg_N\n+                          (\"component of imported 'C'P'P type cannot have\" &\n+                           \" default expression\", Expression (Comp));\n+                     end if;\n \n-                        Next (Comp);\n-                     end loop;\n-                  end if;\n-               end;\n-            end if;\n+                     Next (Comp);\n+                  end loop;\n+               end if;\n+            end;\n \n          else\n             Error_Pragma_Arg\n@@ -6272,8 +6267,10 @@ package body Sem_Prag is\n          --    [, [Link_Name     =>] static_string_EXPRESSION ]);\n \n          when Pragma_CPP_Constructor => CPP_Constructor : declare\n-            Id     : Entity_Id;\n-            Def_Id : Entity_Id;\n+            Elmt    : Elmt_Id;\n+            Id      : Entity_Id;\n+            Def_Id  : Entity_Id;\n+            Tag_Typ : Entity_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -6294,8 +6291,10 @@ package body Sem_Prag is\n             Def_Id := Entity (Id);\n \n             if Ekind (Def_Id) = E_Function\n-              and then Is_Class_Wide_Type (Etype (Def_Id))\n-              and then Is_CPP_Class (Etype (Etype (Def_Id)))\n+              and then (Is_CPP_Class (Etype (Def_Id))\n+                         or else (Is_Class_Wide_Type (Etype (Def_Id))\n+                                   and then\n+                                  Is_CPP_Class (Root_Type (Etype (Def_Id)))))\n             then\n                if Arg_Count >= 2 then\n                   Set_Imported (Def_Id);\n@@ -6306,6 +6305,38 @@ package body Sem_Prag is\n                Set_Has_Completion (Def_Id);\n                Set_Is_Constructor (Def_Id);\n \n+               --  Imported C++ constructors are not dispatching primitives\n+               --  because in C++ they don't have a dispatch table slot.\n+               --  However, in Ada the constructor has the profile of a\n+               --  function that returns a tagged type and therefore it has\n+               --  been considered by the Semantic analyzer a dispatching\n+               --  primitive operation. We extract it now from the list of\n+               --  primitive operations of the type.\n+\n+               if Is_Tagged_Type (Etype (Def_Id))\n+                 and then not Is_Class_Wide_Type (Etype (Def_Id))\n+               then\n+                  pragma Assert (Is_Dispatching_Operation (Def_Id));\n+                  Tag_Typ := Etype (Def_Id);\n+\n+                  Elmt := First_Elmt (Primitive_Operations (Tag_Typ));\n+                  while Present (Elmt)\n+                     and then Node (Elmt) /= Def_Id\n+                  loop\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+\n+                  Remove_Elmt (Primitive_Operations (Tag_Typ), Elmt);\n+                  Set_Is_Dispatching_Operation (Def_Id, False);\n+               end if;\n+\n+               --  For backward compatibility, if the constructor returns a\n+               --  class wide type we internally change the returned type to\n+               --  the corresponding non class-wide type.\n+\n+               if Is_Class_Wide_Type (Etype (Def_Id)) then\n+                  Set_Etype (Def_Id, Root_Type (Etype (Def_Id)));\n+               end if;\n             else\n                Error_Pragma_Arg\n                  (\"pragma% requires function returning a 'C'P'P_Class type\","}, {"sha": "14ec28d4bc841beb115c05a4d1349525f12f916d", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=7b4db06ceeb85373d9bd52fb68eec77600455f12", "patch": "@@ -3982,17 +3982,9 @@ package body Sem_Res is\n          Check_Unset_Reference (Expression (E));\n \n          --  A qualified expression requires an exact match of the type,\n-         --  class-wide matching is not allowed. We skip this test in a call\n-         --  to a CPP constructor because in such case, although the function\n-         --  profile indicates that it returns a class-wide type, the object\n-         --  returned by the C++ constructor has a concrete type.\n+         --  class-wide matching is not allowed.\n \n-         if Is_Class_Wide_Type (Etype (Expression (E)))\n-           and then Is_CPP_Constructor_Call (Expression (E))\n-         then\n-            null;\n-\n-         elsif (Is_Class_Wide_Type (Etype (Expression (E)))\n+         if (Is_Class_Wide_Type (Etype (Expression (E)))\n                  or else Is_Class_Wide_Type (Etype (E)))\n            and then Base_Type (Etype (Expression (E))) /= Base_Type (Etype (E))\n          then"}, {"sha": "7e9fea5924b15d80ad8eb149f22ea38e19cb0172", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4db06ceeb85373d9bd52fb68eec77600455f12/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7b4db06ceeb85373d9bd52fb68eec77600455f12", "patch": "@@ -5530,7 +5530,6 @@ package body Sem_Util is\n    function Is_CPP_Constructor_Call (N : Node_Id) return Boolean is\n    begin\n       return Nkind (N) = N_Function_Call\n-        and then Is_Class_Wide_Type (Etype (N))\n         and then Is_CPP_Class (Etype (Etype (N)))\n         and then Is_Constructor (Entity (Name (N)))\n         and then Is_Imported (Entity (Name (N)));"}]}