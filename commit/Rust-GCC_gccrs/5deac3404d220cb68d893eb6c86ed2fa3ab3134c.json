{"sha": "5deac3404d220cb68d893eb6c86ed2fa3ab3134c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRlYWMzNDA0ZDIyMGNiNjhkODkzZWI2Yzg2ZWQyZmEzYWIzMTM0Yw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-08-17T08:03:54Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-08-17T08:03:54Z"}, "message": "hash-table.h (class hash_table): Use a descriptor template argument instead of decomposed element type and...\n\n2012-08-17  Richard Guenther  <rguenther@suse.de>\n\n\t* hash-table.h (class hash_table): Use a descriptor template\n\targument instead of decomposed element type and support\n\tfunctions.\n\t(struct pointer_hash): New generic typed pointer-hash.\n\t(struct typed_free_remove, struct typed_noop_remove): Generic\n\thash_table support pieces.\n\t* coverage.c (struct counts_entry): Add hash_table support\n\tmembers.\n\t* tree-ssa-ccp.c (gimple_htab): Use pointer_hash.\n\t* tree-ssa-coalesce.c (struct ssa_name_var_hash): New generic\n\tSSA name by SSA_NAME_VAR hash.\n\t(coalesce_ssa_name): Use it.\n\t* tree-ssa-pre.c (struct pre_expr_d): Add hash_table support.\n\t(expression_to_id): Adjust.\n\t(struct expr_pred_trans_d): Add hash_table support.\n\t(phi_translate_table): Adjust.\n\t(phi_trans_lookup): Likewise.\n\t(phi_trans_add): Likewise.\n\t(do_regular_insertion): Likewise.\n\t* tree-ssa-tail-merge.c (struct same_succ_def): Add hash_table\n\tsupport.\n\t(same_succ_htab): Adjust.\n\t(find_same_succ_bb): Likewise.\n\t(find_same_succ): Likewise.\n\t(update_worklist): Likewise.\n\t* tree-ssa-threadupdate.c (struct redirection_data): Add hash_table\n\tsupport.\n\t(redirection_data): Adjust.\n\nFrom-SVN: r190471", "tree": {"sha": "f5e13f0401d96073f145438cc14798458718ef90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5e13f0401d96073f145438cc14798458718ef90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5deac3404d220cb68d893eb6c86ed2fa3ab3134c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5deac3404d220cb68d893eb6c86ed2fa3ab3134c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5deac3404d220cb68d893eb6c86ed2fa3ab3134c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c58c0d4c81fb4e313fa10a74e73800fd59efdf92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c58c0d4c81fb4e313fa10a74e73800fd59efdf92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c58c0d4c81fb4e313fa10a74e73800fd59efdf92"}], "stats": {"total": 546, "additions": 269, "deletions": 277}, "files": [{"sha": "ebc10025bcd39efae2cdff46b535f617369a6c9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5deac3404d220cb68d893eb6c86ed2fa3ab3134c", "patch": "@@ -1,3 +1,34 @@\n+2012-08-17  Richard Guenther  <rguenther@suse.de>\n+\n+\t* hash-table.h (class hash_table): Use a descriptor template\n+\targument instead of decomposed element type and support\n+\tfunctions.\n+\t(struct pointer_hash): New generic typed pointer-hash.\n+\t(struct typed_free_remove, struct typed_noop_remove): Generic\n+\thash_table support pieces.\n+\t* coverage.c (struct counts_entry): Add hash_table support\n+\tmembers.\n+\t* tree-ssa-ccp.c (gimple_htab): Use pointer_hash.\n+\t* tree-ssa-coalesce.c (struct ssa_name_var_hash): New generic\n+\tSSA name by SSA_NAME_VAR hash.\n+\t(coalesce_ssa_name): Use it.\n+\t* tree-ssa-pre.c (struct pre_expr_d): Add hash_table support.\n+\t(expression_to_id): Adjust.\n+\t(struct expr_pred_trans_d): Add hash_table support.\n+\t(phi_translate_table): Adjust.\n+\t(phi_trans_lookup): Likewise.\n+\t(phi_trans_add): Likewise.\n+\t(do_regular_insertion): Likewise.\n+\t* tree-ssa-tail-merge.c (struct same_succ_def): Add hash_table\n+\tsupport.\n+\t(same_succ_htab): Adjust.\n+\t(find_same_succ_bb): Likewise.\n+\t(find_same_succ): Likewise.\n+\t(update_worklist): Likewise.\n+\t* tree-ssa-threadupdate.c (struct redirection_data): Add hash_table\n+\tsupport.\n+\t(redirection_data): Adjust.\n+\n 2012-08-17  Richard Guenther  <rguenther@suse.de>\n \n \t* params.def (integer-share-limit): Decrease from 256 to 251,"}, {"sha": "b4d22dfd9c69922ed7069deb7eae9c77b35460c9", "filename": "gcc/coverage.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=5deac3404d220cb68d893eb6c86ed2fa3ab3134c", "patch": "@@ -77,6 +77,12 @@ typedef struct counts_entry\n   unsigned cfg_checksum;\n   gcov_type *counts;\n   struct gcov_ctr_summary summary;\n+\n+  /* hash_table support.  */\n+  typedef counts_entry T;\n+  static inline hashval_t hash (const counts_entry *);\n+  static int equal (const counts_entry *, const counts_entry *);\n+  static void remove (counts_entry *);\n } counts_entry_t;\n \n static GTY(()) struct coverage_data *functions_head = 0;\n@@ -144,29 +150,27 @@ get_gcov_unsigned_t (void)\n }\n \f\n inline hashval_t\n-coverage_counts_entry_hash (const counts_entry_t *entry)\n+counts_entry::hash (const counts_entry_t *entry)\n {\n   return entry->ident * GCOV_COUNTERS + entry->ctr;\n }\n \n inline int\n-coverage_counts_entry_eq (const counts_entry_t *entry1,\n-                          const counts_entry_t *entry2)\n+counts_entry::equal (const counts_entry_t *entry1,\n+\t\t     const counts_entry_t *entry2)\n {\n   return entry1->ident == entry2->ident && entry1->ctr == entry2->ctr;\n }\n \n inline void\n-coverage_counts_entry_del (counts_entry_t *entry)\n+counts_entry::remove (counts_entry_t *entry)\n {\n   free (entry->counts);\n   free (entry);\n }\n \n /* Hash table of count data.  */\n-static hash_table <counts_entry_t, coverage_counts_entry_hash,\n-\t\t   coverage_counts_entry_eq, coverage_counts_entry_del>\n-\t\t  counts_hash;\n+static hash_table <counts_entry> counts_hash;\n \n /* Read in the counts file, if available.  */\n "}, {"sha": "91231a21c336167cb6e736699be1cccdf5bf114c", "filename": "gcc/hash-table.h", "status": "modified", "additions": 139, "deletions": 192, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=5deac3404d220cb68d893eb6c86ed2fa3ab3134c", "patch": "@@ -83,45 +83,52 @@ xcallocator <Type>::data_free (Type *memory)\n }\n \n \n-/* A common function for hashing a CANDIDATE typed pointer.  */\n+/* Remove method dispatching to free.  */\n \n template <typename Element>\n-inline hashval_t\n-typed_pointer_hash (const Element *candidate)\n+struct typed_free_remove\n {\n-  /* This is a really poor hash function, but it is what the current code uses,\n-     so I am reusing it to avoid an additional axis in testing.  */\n-  return (hashval_t) ((intptr_t)candidate >> 3);\n-}\n-\n+  static inline void remove (Element *p) { free (p); }\n+};\n \n-/* A common function for comparing an EXISTING and CANDIDATE typed pointers\n-   for equality. */\n+/* No-op remove method.  */\n \n template <typename Element>\n-inline int\n-typed_pointer_equal (const Element *existing, const Element * candidate)\n+struct typed_noop_remove\n {\n-  return existing == candidate;\n-}\n+  static inline void remove (Element *) {}\n+};\n \n \n-/* A common function for doing nothing on removing a RETIRED slot.  */\n+/* Pointer hash with a no-op remove method.  */\n \n template <typename Element>\n-inline void\n-typed_null_remove (Element *retired ATTRIBUTE_UNUSED)\n+struct pointer_hash : typed_noop_remove <Element>\n {\n-}\n+  typedef Element T;\n \n+  static inline hashval_t\n+  hash (const T *);\n \n-/* A common function for using free on removing a RETIRED slot.  */\n+  static inline int\n+  equal (const T *existing, const T * candidate);\n+};\n \n template <typename Element>\n-inline void\n-typed_free_remove (Element *retired)\n+inline hashval_t\n+pointer_hash<Element>::hash (const T *candidate)\n+{\n+  /* This is a really poor hash function, but it is what the current code uses,\n+     so I am reusing it to avoid an additional axis in testing.  */\n+  return (hashval_t) ((intptr_t)candidate >> 3);\n+}\n+\n+template <typename Element>\n+inline int\n+pointer_hash<Element>::equal (const T *existing,\n+\t\t\t      const T *candidate)\n {\n-  free (retired);\n+  return existing == candidate;\n }\n \n \n@@ -147,11 +154,11 @@ extern hashval_t hash_table_mod2 (hashval_t hash, unsigned int index);\n \n /* Internal implementation type.  */\n \n-template <typename Element>\n+template <typename T>\n struct hash_table_control\n {\n   /* Table itself.  */\n-  Element **entries;\n+  T **entries;\n \n   /* Current size (in entries) of the hash table.  */\n   size_t size;\n@@ -180,15 +187,15 @@ struct hash_table_control\n \n    The table stores elements of type Element.\n \n-   It hashes elements with the Hash function.\n+   It hashes elements with the hash function.\n      The table currently works with relatively weak hash functions.\n      Use typed_pointer_hash <Element> when hashing pointers instead of objects.\n \n-   It compares elements with the Equal function.\n+   It compares elements with the equal function.\n      Two elements with the same hash may not be equal.\n      Use typed_pointer_equal <Element> when hashing pointers instead of objects.\n \n-   It removes elements with the Remove function.\n+   It removes elements with the remove function.\n      This feature is useful for freeing memory.\n      Use typed_null_remove <Element> when not freeing objects.\n      Use typed_free_remove <Element> when doing a simple object free.\n@@ -198,145 +205,121 @@ struct hash_table_control\n \n */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator = xcallocator>\n class hash_table\n {\n+public:\n+  typedef typename Descr::T T;\n \n private:\n+  hash_table_control <T> *htab;\n \n-  hash_table_control <Element> *htab;\n-\n-  Element **find_empty_slot_for_expand (hashval_t hash);\n+  T **find_empty_slot_for_expand (hashval_t hash);\n   void expand ();\n \n public:\n-\n   hash_table ();\n   void create (size_t initial_slots);\n   bool is_created ();\n   void dispose ();\n-  Element *find (Element *comparable);\n-  Element *find_with_hash (Element *comparable, hashval_t hash);\n-  Element **find_slot (Element *comparable, enum insert_option insert);\n-  Element **find_slot_with_hash (Element *comparable, hashval_t hash,\n-\t\t\t\t enum insert_option insert);\n+  T *find (T *comparable);\n+  T *find_with_hash (T *comparable, hashval_t hash);\n+  T **find_slot (T *comparable, enum insert_option insert);\n+  T **find_slot_with_hash (T *comparable, hashval_t hash,\n+\t\t\t\t   enum insert_option insert);\n   void empty ();\n-  void clear_slot (Element **slot);\n-  void remove_elt (Element *comparable);\n-  void remove_elt_with_hash (Element *comparable, hashval_t hash);\n+  void clear_slot (T **slot);\n+  void remove_elt (T *comparable);\n+  void remove_elt_with_hash (T *comparable, hashval_t hash);\n   size_t size();\n   size_t elements();\n   double collisions();\n \n   template <typename Argument,\n-\t    int (*Callback) (Element **slot, Argument argument)>\n+\t    int (*Callback) (T **slot, Argument argument)>\n   void traverse_noresize (Argument argument);\n \n   template <typename Argument,\n-\t    int (*Callback) (Element **slot, Argument argument)>\n+\t    int (*Callback) (T **slot, Argument argument)>\n   void traverse (Argument argument);\n };\n \n \n /* Construct the hash table.  The only useful operation next is create.  */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n inline\n-hash_table <Element, Hash, Equal, Remove, Allocator>::hash_table ()\n+hash_table <Descr, Allocator>::hash_table ()\n : htab (NULL)\n {\n }\n \n \n /* See if the table has been created, as opposed to constructed.  */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n inline bool\n-hash_table <Element, Hash, Equal, Remove, Allocator>::is_created ()\n+hash_table <Descr, Allocator>::is_created ()\n {\n   return htab != NULL;\n }\n \n \n /* Like find_with_hash, but compute the hash value from the element.  */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n-inline Element *\n-hash_table <Element, Hash, Equal, Remove, Allocator>::find (Element *comparable)\n+inline typename Descr::T *\n+hash_table <Descr, Allocator>::find (T *comparable)\n {\n-  return find_with_hash (comparable, Hash (comparable));\n+  return find_with_hash (comparable, Descr::hash (comparable));\n }\n \n \n /* Like find_slot_with_hash, but compute the hash value from the element.  */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n-inline Element **\n-hash_table <Element, Hash, Equal, Remove, Allocator>\n-::find_slot (Element *comparable, enum insert_option insert)\n+inline typename Descr::T **\n+hash_table <Descr, Allocator>\n+::find_slot (T *comparable, enum insert_option insert)\n {\n-  return find_slot_with_hash (comparable, Hash (comparable), insert);\n+  return find_slot_with_hash (comparable, Descr::hash (comparable), insert);\n }\n \n \n /* Like remove_elt_with_hash, but compute the hash value from the element.  */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n inline void\n-hash_table <Element, Hash, Equal, Remove, Allocator>\n-::remove_elt (Element *comparable)\n+hash_table <Descr, Allocator>\n+::remove_elt (T *comparable)\n {\n-  remove_elt_with_hash (comparable, Hash (comparable));\n+  remove_elt_with_hash (comparable, Descr::hash (comparable));\n }\n \n \n /* Return the current size of this hash table.  */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n inline size_t\n-hash_table <Element, Hash, Equal, Remove, Allocator>::size()\n+hash_table <Descr, Allocator>::size()\n {\n   return htab->size;\n }\n \n \n /* Return the current number of elements in this hash table. */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n inline size_t\n-hash_table <Element, Hash, Equal, Remove, Allocator>::elements()\n+hash_table <Descr, Allocator>::elements()\n {\n   return htab->n_elements - htab->n_deleted;\n }\n@@ -345,13 +328,10 @@ hash_table <Element, Hash, Equal, Remove, Allocator>::elements()\n   /* Return the fraction of fixed collisions during all work with given\n      hash table. */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n inline double\n-hash_table <Element, Hash, Equal, Remove, Allocator>::collisions()\n+hash_table <Descr, Allocator>::collisions()\n {\n   if (htab->searches == 0)\n     return 0.0;\n@@ -362,22 +342,19 @@ hash_table <Element, Hash, Equal, Remove, Allocator>::collisions()\n \n /* Create a hash table with at least the given number of INITIAL_SLOTS.  */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n void\n-hash_table <Element, Hash, Equal, Remove, Allocator>::create (size_t size)\n+hash_table <Descr, Allocator>::create (size_t size)\n {\n   unsigned int size_prime_index;\n \n   size_prime_index = hash_table_higher_prime_index (size);\n   size = prime_tab[size_prime_index].prime;\n \n-  htab = Allocator <hash_table_control <Element> > ::control_alloc (1);\n+  htab = Allocator <hash_table_control <T> > ::control_alloc (1);\n   gcc_assert (htab != NULL);\n-  htab->entries = Allocator <Element*> ::data_alloc (size);\n+  htab->entries = Allocator <T*> ::data_alloc (size);\n   gcc_assert (htab->entries != NULL);\n   htab->size = size;\n   htab->size_prime_index = size_prime_index;\n@@ -387,46 +364,40 @@ hash_table <Element, Hash, Equal, Remove, Allocator>::create (size_t size)\n /* Dispose of a hash table.  Free all memory and return this hash table to\n    the non-created state.  Naturally the hash table must already exist.  */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n void\n-hash_table <Element, Hash, Equal, Remove, Allocator>::dispose ()\n+hash_table <Descr, Allocator>::dispose ()\n {\n   size_t size = htab->size;\n-  Element **entries = htab->entries;\n+  T **entries = htab->entries;\n \n   for (int i = size - 1; i >= 0; i--)\n     if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)\n-      Remove (entries[i]);\n+      Descr::remove (entries[i]);\n \n-  Allocator <Element *> ::data_free (entries);\n-  Allocator <hash_table_control <Element> > ::control_free (htab);\n+  Allocator <T *> ::data_free (entries);\n+  Allocator <hash_table_control <T> > ::control_free (htab);\n   htab = NULL;\n }\n \n \n /* Similar to find_slot, but without several unwanted side effects:\n-    - Does not call Equal when it finds an existing entry.\n+    - Does not call equal when it finds an existing entry.\n     - Does not change the count of elements/searches/collisions in the\n       hash table.\n    This function also assumes there are no deleted entries in the table.\n    HASH is the hash value for the element to be inserted.  */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n-Element **\n-hash_table <Element, Hash, Equal, Remove, Allocator>\n+typename Descr::T **\n+hash_table <Descr, Allocator>\n ::find_empty_slot_for_expand (hashval_t hash)\n {\n   hashval_t index = hash_table_mod1 (hash, htab->size_prime_index);\n   size_t size = htab->size;\n-  Element **slot = htab->entries + index;\n+  T **slot = htab->entries + index;\n   hashval_t hash2;\n \n   if (*slot == HTAB_EMPTY_ENTRY)\n@@ -457,18 +428,15 @@ ::find_empty_slot_for_expand (hashval_t hash)\n    table entries is changed.  If memory allocation fails, this function\n    will abort.  */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n void\n-hash_table <Element, Hash, Equal, Remove, Allocator>::expand ()\n+hash_table <Descr, Allocator>::expand ()\n {\n-  Element **oentries;\n-  Element **olimit;\n-  Element **p;\n-  Element **nentries;\n+  T **oentries;\n+  T **olimit;\n+  T **p;\n+  T **nentries;\n   size_t nsize, osize, elts;\n   unsigned int oindex, nindex;\n \n@@ -491,7 +459,7 @@ hash_table <Element, Hash, Equal, Remove, Allocator>::expand ()\n       nsize = osize;\n     }\n \n-  nentries = Allocator <Element *> ::data_alloc (nsize);\n+  nentries = Allocator <T *> ::data_alloc (nsize);\n   gcc_assert (nentries != NULL);\n   htab->entries = nentries;\n   htab->size = nsize;\n@@ -502,11 +470,11 @@ hash_table <Element, Hash, Equal, Remove, Allocator>::expand ()\n   p = oentries;\n   do\n     {\n-      Element *x = *p;\n+      T *x = *p;\n \n       if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n         {\n-          Element **q = find_empty_slot_for_expand (Hash (x));\n+          T **q = find_empty_slot_for_expand (Descr::hash (x));\n \n           *q = x;\n         }\n@@ -515,34 +483,31 @@ hash_table <Element, Hash, Equal, Remove, Allocator>::expand ()\n     }\n   while (p < olimit);\n \n-  Allocator <Element *> ::data_free (oentries);\n+  Allocator <T *> ::data_free (oentries);\n }\n \n \n /* This function searches for a hash table entry equal to the given\n    COMPARABLE element starting with the given HASH value.  It cannot\n    be used to insert or delete an element. */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n-Element *\n-hash_table <Element, Hash, Equal, Remove, Allocator>\n-::find_with_hash (Element *comparable, hashval_t hash)\n+typename Descr::T *\n+hash_table <Descr, Allocator>\n+::find_with_hash (T *comparable, hashval_t hash)\n {\n   hashval_t index, hash2;\n   size_t size;\n-  Element *entry;\n+  T *entry;\n \n   htab->searches++;\n   size = htab->size;\n   index = hash_table_mod1 (hash, htab->size_prime_index);\n \n   entry = htab->entries[index];\n   if (entry == HTAB_EMPTY_ENTRY\n-      || (entry != HTAB_DELETED_ENTRY && Equal (entry, comparable)))\n+      || (entry != HTAB_DELETED_ENTRY && Descr::equal (entry, comparable)))\n     return entry;\n \n   hash2 = hash_table_mod2 (hash, htab->size_prime_index);\n@@ -555,7 +520,7 @@ ::find_with_hash (Element *comparable, hashval_t hash)\n \n       entry = htab->entries[index];\n       if (entry == HTAB_EMPTY_ENTRY\n-          || (entry != HTAB_DELETED_ENTRY && Equal (entry, comparable)))\n+          || (entry != HTAB_DELETED_ENTRY && Descr::equal (entry, comparable)))\n         return entry;\n     }\n }\n@@ -569,20 +534,17 @@ ::find_with_hash (Element *comparable, hashval_t hash)\n    write the value you want into the returned slot.  When inserting an\n    entry, NULL may be returned if memory allocation fails. */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n-Element **\n-hash_table <Element, Hash, Equal, Remove, Allocator>\n-::find_slot_with_hash (Element *comparable, hashval_t hash,\n+typename Descr::T **\n+hash_table <Descr, Allocator>\n+::find_slot_with_hash (T *comparable, hashval_t hash,\n \t\t       enum insert_option insert)\n {\n-  Element **first_deleted_slot;\n+  T **first_deleted_slot;\n   hashval_t index, hash2;\n   size_t size;\n-  Element *entry;\n+  T *entry;\n \n   size = htab->size;\n   if (insert == INSERT && size * 3 <= htab->n_elements * 4)\n@@ -601,7 +563,7 @@ ::find_slot_with_hash (Element *comparable, hashval_t hash,\n     goto empty_entry;\n   else if (entry == HTAB_DELETED_ENTRY)\n     first_deleted_slot = &htab->entries[index];\n-  else if (Equal (entry, comparable))\n+  else if (Descr::equal (entry, comparable))\n     return &htab->entries[index];\n       \n   hash2 = hash_table_mod2 (hash, htab->size_prime_index);\n@@ -620,7 +582,7 @@ ::find_slot_with_hash (Element *comparable, hashval_t hash,\n \t  if (!first_deleted_slot)\n \t    first_deleted_slot = &htab->entries[index];\n \t}\n-      else if (Equal (entry, comparable))\n+      else if (Descr::equal (entry, comparable))\n \treturn &htab->entries[index];\n     }\n \n@@ -631,7 +593,7 @@ ::find_slot_with_hash (Element *comparable, hashval_t hash,\n   if (first_deleted_slot)\n     {\n       htab->n_deleted--;\n-      *first_deleted_slot = static_cast <Element *> (HTAB_EMPTY_ENTRY);\n+      *first_deleted_slot = static_cast <T *> (HTAB_EMPTY_ENTRY);\n       return first_deleted_slot;\n     }\n \n@@ -642,35 +604,32 @@ ::find_slot_with_hash (Element *comparable, hashval_t hash,\n \n /* This function clears all entries in the given hash table.  */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n void\n-hash_table <Element, Hash, Equal, Remove, Allocator>::empty ()\n+hash_table <Descr, Allocator>::empty ()\n {\n   size_t size = htab_size (htab);\n-  Element **entries = htab->entries;\n+  T **entries = htab->entries;\n   int i;\n \n   for (i = size - 1; i >= 0; i--)\n     if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)\n-      Remove (entries[i]);\n+      Descr::remove (entries[i]);\n \n   /* Instead of clearing megabyte, downsize the table.  */\n   if (size > 1024*1024 / sizeof (PTR))\n     {\n       int nindex = hash_table_higher_prime_index (1024 / sizeof (PTR));\n       int nsize = prime_tab[nindex].prime;\n \n-      Allocator <Element *> ::data_free (htab->entries);\n-      htab->entries = Allocator <Element *> ::data_alloc (nsize);\n+      Allocator <T *> ::data_free (htab->entries);\n+      htab->entries = Allocator <T *> ::data_alloc (nsize);\n       htab->size = nsize;\n       htab->size_prime_index = nindex;\n     }\n   else\n-    memset (entries, 0, size * sizeof (Element *));\n+    memset (entries, 0, size * sizeof (T *));\n   htab->n_deleted = 0;\n   htab->n_elements = 0;\n }\n@@ -680,20 +639,17 @@ hash_table <Element, Hash, Equal, Remove, Allocator>::empty ()\n    useful when you've already done the lookup and don't want to do it\n    again. */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n void\n-hash_table <Element, Hash, Equal, Remove, Allocator>\n-::clear_slot (Element **slot)\n+hash_table <Descr, Allocator>\n+::clear_slot (T **slot)\n {\n   if (slot < htab->entries || slot >= htab->entries + htab->size\n       || *slot == HTAB_EMPTY_ENTRY || *slot == HTAB_DELETED_ENTRY)\n     abort ();\n \n-  Remove (*slot);\n+  Descr::remove (*slot);\n \n   *slot = HTAB_DELETED_ENTRY;\n   htab->n_deleted++;\n@@ -704,24 +660,21 @@ ::clear_slot (Element **slot)\n    from hash table starting with the given HASH.  If there is no\n    matching element in the hash table, this function does nothing. */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n void\n-hash_table <Element, Hash, Equal, Remove, Allocator>\n-::remove_elt_with_hash (Element *comparable, hashval_t hash)\n+hash_table <Descr, Allocator>\n+::remove_elt_with_hash (T *comparable, hashval_t hash)\n {\n-  Element **slot;\n+  T **slot;\n \n   slot = find_slot_with_hash (comparable, hash, NO_INSERT);\n   if (*slot == HTAB_EMPTY_ENTRY)\n     return;\n \n-  Remove (*slot);\n+  Descr::remove (*slot);\n \n-  *slot = static_cast <Element *> (HTAB_DELETED_ENTRY);\n+  *slot = static_cast <T *> (HTAB_DELETED_ENTRY);\n   htab->n_deleted++;\n }\n \n@@ -730,26 +683,23 @@ ::remove_elt_with_hash (Element *comparable, hashval_t hash)\n    each live entry.  If CALLBACK returns false, the iteration stops.\n    ARGUMENT is passed as CALLBACK's second argument. */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n template <typename Argument,\n-\t  int (*Callback) (Element **slot, Argument argument)>\n+\t  int (*Callback) (typename Descr::T **slot, Argument argument)>\n void\n-hash_table <Element, Hash, Equal, Remove, Allocator>\n+hash_table <Descr, Allocator>\n ::traverse_noresize (Argument argument)\n {\n-  Element **slot;\n-  Element **limit;\n+  T **slot;\n+  T **limit;\n \n   slot = htab->entries;\n   limit = slot + htab->size;\n \n   do\n     {\n-      Element *x = *slot;\n+      T *x = *slot;\n \n       if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n         if (! Callback (slot, argument))\n@@ -762,15 +712,12 @@ ::traverse_noresize (Argument argument)\n /* Like traverse_noresize, but does resize the table when it is too empty\n    to improve effectivity of subsequent calls.  */\n \n-template <typename Element,\n-\t  hashval_t (*Hash) (const Element *candidate),\n-\t  int (*Equal) (const Element *existing, const Element * candidate),\n-\t  void (*Remove) (Element *retired),\n+template <typename Descr,\n \t  template <typename Type> class Allocator>\n template <typename Argument,\n-\t  int (*Callback) (Element **slot, Argument argument)>\n+\t  int (*Callback) (typename Descr::T **slot, Argument argument)>\n void\n-hash_table <Element, Hash, Equal, Remove, Allocator>\n+hash_table <Descr, Allocator>\n ::traverse (Argument argument)\n {\n   size_t size = htab->size;"}, {"sha": "ac6ad5da74ff6ef2f7ba4c62215023b62aeb48be", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=5deac3404d220cb68d893eb6c86ed2fa3ab3134c", "patch": "@@ -1688,10 +1688,7 @@ evaluate_stmt (gimple stmt)\n   return val;\n }\n \n-typedef hash_table <gimple_statement_d, typed_pointer_hash<gimple_statement_d>,\n-\t\t    typed_pointer_equal<gimple_statement_d>,\n-\t\t    typed_null_remove<gimple_statement_d> >\n-\t\t   gimple_htab;\n+typedef hash_table <pointer_hash <gimple_statement_d> > gimple_htab;\n \n /* Given a BUILT_IN_STACK_SAVE value SAVED_VAL, insert a clobber of VAR before\n    each matching BUILT_IN_STACK_RESTORE.  Mark visited phis in VISITED.  */"}, {"sha": "dfcd4aad4fa1b17d77471eb2a61f2de3a56b5a45", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=5deac3404d220cb68d893eb6c86ed2fa3ab3134c", "patch": "@@ -1258,22 +1258,29 @@ coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n     }\n }\n \n-/* Returns a hash code for N.  */\n+\n+/* Hashtable support for storing SSA names hashed by their SSA_NAME_VAR.  */\n+\n+struct ssa_name_var_hash : typed_noop_remove <union tree_node>\n+{\n+  typedef union tree_node T;\n+  static inline hashval_t hash (const_tree);\n+  static inline int equal (const_tree, const_tree);\n+};\n \n inline hashval_t\n-hash_ssa_name_by_var (const_tree n)\n+ssa_name_var_hash::hash (const_tree n)\n {\n-  return (hashval_t) htab_hash_pointer (SSA_NAME_VAR (n));\n+  return DECL_UID (SSA_NAME_VAR (n));\n }\n \n-/* Returns nonzero if N1 and N2 are equal.  */\n-\n inline int\n-eq_ssa_name_by_var (const_tree n1, const_tree n2)\n+ssa_name_var_hash::equal (const_tree n1, const_tree n2)\n {\n   return SSA_NAME_VAR (n1) == SSA_NAME_VAR (n2);\n }\n \n+\n /* Reduce the number of copies by coalescing variables in the function.  Return\n    a partition map with the resulting coalesces.  */\n \n@@ -1286,9 +1293,7 @@ coalesce_ssa_name (void)\n   bitmap used_in_copies = BITMAP_ALLOC (NULL);\n   var_map map;\n   unsigned int i;\n-  static hash_table <tree_node, hash_ssa_name_by_var, eq_ssa_name_by_var,\n-\t\t     typed_null_remove<tree_node> >\n-\t\t    ssa_name_hash;\n+  static hash_table <ssa_name_var_hash> ssa_name_hash;\n \n   cl = create_coalesce_list ();\n   map = create_outofssa_var_map (cl, used_in_copies);"}, {"sha": "e1135395f65746fdd3a06e0921dc287fb50c98cd", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=5deac3404d220cb68d893eb6c86ed2fa3ab3134c", "patch": "@@ -165,11 +165,16 @@ typedef union pre_expr_union_d\n   vn_reference_t reference;\n } pre_expr_union;\n \n-typedef struct pre_expr_d\n+typedef struct pre_expr_d : typed_noop_remove <pre_expr_d>\n {\n   enum pre_expr_kind kind;\n   unsigned int id;\n   pre_expr_union u;\n+\n+  /* hash_table support.  */\n+  typedef pre_expr_d T;\n+  static inline hashval_t hash (const pre_expr_d *);\n+  static inline int equal (const pre_expr_d *, const pre_expr_d *);\n } *pre_expr;\n \n #define PRE_EXPR_NAME(e) (e)->u.name\n@@ -180,7 +185,7 @@ typedef struct pre_expr_d\n /* Compare E1 and E1 for equality.  */\n \n inline int\n-ssa_pre_expr_eq (const struct pre_expr_d *e1, const struct pre_expr_d *e2)\n+pre_expr_d::equal (const struct pre_expr_d *e1, const struct pre_expr_d *e2)\n {\n   if (e1->kind != e2->kind)\n     return false;\n@@ -205,7 +210,7 @@ ssa_pre_expr_eq (const struct pre_expr_d *e1, const struct pre_expr_d *e2)\n /* Hash E.  */\n \n inline hashval_t\n-ssa_pre_expr_hash (const struct pre_expr_d *e)\n+pre_expr_d::hash (const struct pre_expr_d *e)\n {\n   switch (e->kind)\n     {\n@@ -229,9 +234,7 @@ static unsigned int next_expression_id;\n DEF_VEC_P (pre_expr);\n DEF_VEC_ALLOC_P (pre_expr, heap);\n static VEC(pre_expr, heap) *expressions;\n-static hash_table <pre_expr_d, ssa_pre_expr_hash, ssa_pre_expr_eq,\n-\t\t   typed_null_remove <pre_expr_d> >\n-\t\t  expression_to_id;\n+static hash_table <pre_expr_d> expression_to_id;\n static VEC(unsigned, heap) *name_to_id;\n \n /* Allocate an expression id for EXPR.  */\n@@ -483,7 +486,7 @@ static bitmap need_ab_cleanup;\n /* A three tuple {e, pred, v} used to cache phi translations in the\n    phi_translate_table.  */\n \n-typedef struct expr_pred_trans_d\n+typedef struct expr_pred_trans_d : typed_free_remove<expr_pred_trans_d>\n {\n   /* The expression.  */\n   pre_expr e;\n@@ -497,23 +500,23 @@ typedef struct expr_pred_trans_d\n   /* The hashcode for the expression, pred pair. This is cached for\n      speed reasons.  */\n   hashval_t hashcode;\n+\n+  /* hash_table support.  */\n+  typedef expr_pred_trans_d T;\n+  static inline hashval_t hash (const expr_pred_trans_d *);\n+  static inline int equal (const expr_pred_trans_d *, const expr_pred_trans_d *);\n } *expr_pred_trans_t;\n typedef const struct expr_pred_trans_d *const_expr_pred_trans_t;\n \n-/* Return the hash value for a phi translation table entry.  */\n-\n inline hashval_t\n-ssa_expr_pred_trans_hash (const expr_pred_trans_d *ve)\n+expr_pred_trans_d::hash (const expr_pred_trans_d *e)\n {\n-  return ve->hashcode;\n+  return e->hashcode;\n }\n \n-/* Return true if two phi translation table entries are the same.\n-   P1 and P2 should point to the expr_pred_trans_t's to be compared.*/\n-\n inline int\n-ssa_expr_pred_trans_eq (const expr_pred_trans_d *ve1,\n-\t\t\tconst expr_pred_trans_d *ve2)\n+expr_pred_trans_d::equal (const expr_pred_trans_d *ve1,\n+\t\t\t  const expr_pred_trans_d *ve2)\n {\n   basic_block b1 = ve1->pred;\n   basic_block b2 = ve2->pred;\n@@ -522,16 +525,12 @@ ssa_expr_pred_trans_eq (const expr_pred_trans_d *ve1,\n      be equal.  */\n   if (b1 != b2)\n     return false;\n-  return ssa_pre_expr_eq (ve1->e, ve2->e);\n+  return pre_expr_d::equal (ve1->e, ve2->e);\n }\n \n /* The phi_translate_table caches phi translations for a given\n    expression and predecessor.  */\n-\n-static hash_table <expr_pred_trans_d, ssa_expr_pred_trans_hash,\n-\t\t   ssa_expr_pred_trans_eq,\n-\t\t   typed_free_remove <expr_pred_trans_d> >\n-\t\t  phi_translate_table;\n+static hash_table <expr_pred_trans_d> phi_translate_table;\n \n /* Search in the phi translation table for the translation of\n    expression E in basic block PRED.\n@@ -545,7 +544,7 @@ phi_trans_lookup (pre_expr e, basic_block pred)\n \n   ept.e = e;\n   ept.pred = pred;\n-  ept.hashcode = iterative_hash_hashval_t (ssa_pre_expr_hash (e), pred->index);\n+  ept.hashcode = iterative_hash_hashval_t (pre_expr_d::hash (e), pred->index);\n   slot = phi_translate_table.find_slot_with_hash (&ept, ept.hashcode,\n \t\t\t\t   NO_INSERT);\n   if (!slot)\n@@ -566,7 +565,7 @@ phi_trans_add (pre_expr e, pre_expr v, basic_block pred)\n   new_pair->e = e;\n   new_pair->pred = pred;\n   new_pair->v = v;\n-  new_pair->hashcode = iterative_hash_hashval_t (ssa_pre_expr_hash (e),\n+  new_pair->hashcode = iterative_hash_hashval_t (pre_expr_d::hash (e),\n \t\t\t\t\t\t pred->index);\n \n   slot = phi_translate_table.find_slot_with_hash (new_pair,\n@@ -3495,7 +3494,7 @@ do_regular_insertion (basic_block block, basic_block dom)\n \t\t    do_insertion = true;\n \t\t  if (first_s == NULL)\n \t\t    first_s = edoubleprime;\n-\t\t  else if (!ssa_pre_expr_eq (first_s, edoubleprime))\n+\t\t  else if (!pre_expr_d::equal (first_s, edoubleprime))\n \t\t    all_same = false;\n \t\t}\n \t    }"}, {"sha": "372096c344c4f60b5b53138580dc208d391ba717", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=5deac3404d220cb68d893eb6c86ed2fa3ab3134c", "patch": "@@ -224,10 +224,24 @@ struct same_succ_def\n   bool in_worklist;\n   /* The hash value of the struct.  */\n   hashval_t hashval;\n+\n+  /* hash_table support.  */\n+  typedef same_succ_def T;\n+  static inline hashval_t hash (const same_succ_def *);\n+  static int equal (const same_succ_def *, const same_succ_def *);\n+  static void remove (same_succ_def *);\n };\n typedef struct same_succ_def *same_succ;\n typedef const struct same_succ_def *const_same_succ;\n \n+/* hash routine for hash_table support, returns hashval of E.  */\n+\n+inline hashval_t\n+same_succ_def::hash (const same_succ_def *e)\n+{\n+  return e->hashval;\n+}\n+\n /* A group of bbs where 1 bb from bbs can replace the other bbs.  */\n \n struct bb_cluster_def\n@@ -415,8 +429,8 @@ stmt_update_dep_bb (gimple stmt)\n \n /* Calculates hash value for same_succ VE.  */\n \n-hashval_t\n-ssa_same_succ_hash (const_same_succ e)\n+static hashval_t\n+same_succ_hash (const_same_succ e)\n {\n   hashval_t hashval = bitmap_hash (e->succs);\n   int flags;\n@@ -511,10 +525,10 @@ inverse_flags (const_same_succ e1, const_same_succ e2)\n   return (f1a & mask) == (f2a & mask) && (f1b & mask) == (f2b & mask);\n }\n \n-/* Compares SAME_SUCCs VE1 and VE2.  */\n+/* Compares SAME_SUCCs E1 and E2.  */\n \n int\n-ssa_same_succ_equal (const_same_succ e1, const_same_succ e2)\n+same_succ_def::equal (const_same_succ e1, const_same_succ e2)\n {\n   unsigned int i, first1, first2;\n   gimple_stmt_iterator gsi1, gsi2;\n@@ -584,10 +598,10 @@ same_succ_alloc (void)\n   return same;\n }\n \n-/* Delete same_succ VE.  */\n+/* Delete same_succ E.  */\n \n-inline void\n-ssa_same_succ_delete (same_succ e)\n+void\n+same_succ_def::remove (same_succ e)\n {\n   BITMAP_FREE (e->bbs);\n   BITMAP_FREE (e->succs);\n@@ -608,11 +622,7 @@ same_succ_reset (same_succ same)\n   VEC_truncate (int, same->succ_flags, 0);\n }\n \n-/* Hash table with all same_succ entries.  */\n-\n-static hash_table <struct same_succ_def, ssa_same_succ_hash,\n-\t\t   ssa_same_succ_equal, ssa_same_succ_delete>\n-\t\t  same_succ_htab;\n+static hash_table <same_succ_def> same_succ_htab;\n \n /* Array that is used to store the edge flags for a successor.  */\n \n@@ -692,7 +702,7 @@ find_same_succ_bb (basic_block bb, same_succ *same_p)\n   EXECUTE_IF_SET_IN_BITMAP (same->succs, 0, j, bj)\n     VEC_safe_push (int, heap, same->succ_flags, same_succ_edge_flags[j]);\n \n-  same->hashval = ssa_same_succ_hash (same);\n+  same->hashval = same_succ_hash (same);\n \n   slot = same_succ_htab.find_slot_with_hash (same, same->hashval, INSERT);\n   if (*slot == NULL)\n@@ -728,7 +738,7 @@ find_same_succ (void)\n \tsame = same_succ_alloc ();\n     }\n \n-  ssa_same_succ_delete (same);\n+  same_succ_def::remove (same);\n }\n \n /* Initializes worklist administration.  */\n@@ -860,7 +870,7 @@ update_worklist (void)\n       if (same == NULL)\n \tsame = same_succ_alloc ();\n     }\n-  ssa_same_succ_delete (same);\n+  same_succ_def::remove (same);\n   bitmap_clear (deleted_bb_preds);\n }\n "}, {"sha": "86ad74f1bc8af49e22a3e13ce750246d5220ca47", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deac3404d220cb68d893eb6c86ed2fa3ab3134c/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=5deac3404d220cb68d893eb6c86ed2fa3ab3134c", "patch": "@@ -110,7 +110,7 @@ struct el\n    may have many incoming edges threaded to the same outgoing edge.  This\n    can be naturally implemented with a hash table.  */\n \n-struct redirection_data\n+struct redirection_data : typed_free_remove<redirection_data>\n {\n   /* A duplicate of B with the trailing control statement removed and which\n      targets a single successor of B.  */\n@@ -125,8 +125,30 @@ struct redirection_data\n   /* A list of incoming edges which we want to thread to\n      OUTGOING_EDGE->dest.  */\n   struct el *incoming_edges;\n+\n+  /* hash_table support.  */\n+  typedef redirection_data T;\n+  static inline hashval_t hash (const redirection_data *);\n+  static inline int equal (const redirection_data *, const redirection_data *);\n };\n \n+inline hashval_t\n+redirection_data::hash (const redirection_data *p)\n+{\n+  edge e = p->outgoing_edge;\n+  return e->dest->index;\n+}\n+\n+inline int\n+redirection_data::equal (const redirection_data *p1, const redirection_data *p2)\n+{\n+  edge e1 = p1->outgoing_edge;\n+  edge e2 = p2->outgoing_edge;\n+  edge e3 = p1->intermediate_edge;\n+  edge e4 = p2->intermediate_edge;\n+  return e1 == e2 && e3 == e4;\n+}\n+\n /* Data structure of information to pass to hash table traversal routines.  */\n struct ssa_local_info_t\n {\n@@ -217,32 +239,9 @@ create_block_for_threading (basic_block bb, struct redirection_data *rd)\n   rd->dup_block->count = 0;\n }\n \n-/* Hashing and equality routines for our hash table.  */\n-inline hashval_t\n-ssa_redirection_data_hash (const struct redirection_data *p)\n-{\n-  edge e = p->outgoing_edge;\n-  return e->dest->index;\n-}\n-\n-inline int\n-ssa_redirection_data_eq (const struct redirection_data *p1,\n-\t\t\t const struct redirection_data *p2)\n-{\n-  edge e1 = p1->outgoing_edge;\n-  edge e2 = p2->outgoing_edge;\n-  edge e3 = p1->intermediate_edge;\n-  edge e4 = p2->intermediate_edge;\n-\n-  return e1 == e2 && e3 == e4;\n-}\n-\n /* Main data structure to hold information for duplicates of BB.  */\n \n-static hash_table <struct redirection_data, ssa_redirection_data_hash,\n-\t\t   ssa_redirection_data_eq,\n-\t\t   typed_free_remove<struct redirection_data> >\n-\t\t  redirection_data;\n+static hash_table <redirection_data> redirection_data;\n \n /* Given an outgoing edge E lookup and return its entry in our hash table.\n "}]}