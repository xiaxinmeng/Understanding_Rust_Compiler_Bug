{"sha": "e3033a2240395246cdfce0197c39162e02c71995", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMwMzNhMjI0MDM5NTI0NmNkZmNlMDE5N2MzOTE2MmUwMmM3MTk5NQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@unitus.it", "date": "2003-05-15T23:43:15Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-05-15T23:43:15Z"}, "message": "fstream.tcc (_M_overflow): Rewrote to call _M_convert_to_external only once (_M_buf_size is now the size...\n\n\n2003-05-15  Paolo Carlini  <pcarlini@unitus.it>\n\t    Nathan Myers  <ncm@cantrip.org>\n\n\t* include/bits/fstream.tcc (_M_overflow): Rewrote to call\n\t_M_convert_to_external only once (_M_buf_size is now the size of\n\tthe put area + 1 for the overflow char of a full area); call\n\t_M_set_buffer instead of _M_set_indeterminate.\n\t(setbuf): Don't accept a buffer smaller than 2 chars.\n\t(_M_underflow): Refill _M_buf_size - 1 chars; call _M_set_buffer,\n\tinstead of _M_set_determinate.\n\t(open): Call _M_set_buffer, instead of _M_set_indeterminate.\n\t(seekoff): Likewise.\n\t* include/ext/stdio_filebuf.h (stdio_filebuf(int,\n\tstd::ios_base::openmode, bool, size_t),\n\tstdio_filebuf(std::__c_file*, std::ios_base::openmode, size_t):\n\tLikewise.\n\t* include/std/std_fstream.h (_M_set_indeterminate): Remove.\n\t(_M_set_determinate): Rename as _M_set_buffer, _M_buf_size ->\n\t_M_buf_size - 1.\n\t* include/std/std_streambuf.h: Tweak _M_out_lim comment.\n\t* testsuite/27_io/basic_filebuf/sgetn/char/1.cc: Tweak, taking\n\tinto account that, for _M_buf_size == BUFSIZ == 8192, the size of\n\tthe put area is now BUFSIZ - 1.\n\t* testsuite/ext/stdio_filebuf_2.cc: Tweak, taking into account\n\tthat now the smallest _M_buf_size is 2 (still fails, for the same\n\treason, with 3.2.3)\n\nCo-Authored-By: Nathan Myers <ncm@cantrip.org>\n\nFrom-SVN: r66848", "tree": {"sha": "f1d8e25813e00141dae73bc128d0ead3c9d03c2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1d8e25813e00141dae73bc128d0ead3c9d03c2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3033a2240395246cdfce0197c39162e02c71995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3033a2240395246cdfce0197c39162e02c71995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3033a2240395246cdfce0197c39162e02c71995", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3033a2240395246cdfce0197c39162e02c71995/comments", "author": null, "committer": null, "parents": [{"sha": "36b9c271acce64c9315e73d9941f2b445a73460b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36b9c271acce64c9315e73d9941f2b445a73460b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36b9c271acce64c9315e73d9941f2b445a73460b"}], "stats": {"total": 211, "additions": 113, "deletions": 98}, "files": [{"sha": "10ad1d6e0122ee457d94212a1beeb8aa397cf483", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e3033a2240395246cdfce0197c39162e02c71995", "patch": "@@ -1,3 +1,30 @@\n+2003-05-15  Paolo Carlini  <pcarlini@unitus.it>\n+\t    Nathan Myers  <ncm@cantrip.org>\n+\n+\t* include/bits/fstream.tcc (_M_overflow): Rewrote to call\n+\t_M_convert_to_external only once (_M_buf_size is now the size of\n+\tthe put area + 1 for the overflow char of a full area); call\n+\t_M_set_buffer instead of _M_set_indeterminate.\n+\t(setbuf): Don't accept a buffer smaller than 2 chars.\n+\t(_M_underflow): Refill _M_buf_size - 1 chars; call _M_set_buffer,\n+\tinstead of _M_set_determinate.\n+\t(open): Call _M_set_buffer, instead of _M_set_indeterminate.\n+\t(seekoff): Likewise.\n+\t* include/ext/stdio_filebuf.h (stdio_filebuf(int,\n+\tstd::ios_base::openmode, bool, size_t),\n+\tstdio_filebuf(std::__c_file*, std::ios_base::openmode, size_t):\n+\tLikewise.\n+\t* include/std/std_fstream.h (_M_set_indeterminate): Remove.\n+\t(_M_set_determinate): Rename as _M_set_buffer, _M_buf_size ->\n+\t_M_buf_size - 1.\n+\t* include/std/std_streambuf.h: Tweak _M_out_lim comment.\n+\t* testsuite/27_io/basic_filebuf/sgetn/char/1.cc: Tweak, taking\n+\tinto account that, for _M_buf_size == BUFSIZ == 8192, the size of\n+\tthe put area is now BUFSIZ - 1.\n+\t* testsuite/ext/stdio_filebuf_2.cc: Tweak, taking into account\n+\tthat now the smallest _M_buf_size is 2 (still fails, for the same\n+\treason, with 3.2.3)\n+\n 2003-05-14  Loren J. Rittle  <ljrittle@acm.org>\n \n \t* testsuite/thread/pthread4.cc: Tweak test."}, {"sha": "4fb153ff72438e13fa864e8f19e6b6dac68c3a82", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 44, "deletions": 49, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=e3033a2240395246cdfce0197c39162e02c71995", "patch": "@@ -48,7 +48,7 @@ namespace std\n     basic_filebuf<_CharT, _Traits>::\n     _M_allocate_internal_buffer()\n     {\n-      if (!this->_M_buf && this->_M_buf_size)\n+      if (!_M_buf_allocated && this->_M_buf_size)\n \t{\n \t  // Allocate internal buffer.\n \t  this->_M_buf = new char_type[this->_M_buf_size];\n@@ -101,9 +101,9 @@ namespace std\n \t      this->_M_mode = __mode;\n \n \t      // Setup initial position of buffer.\n-\t      _M_set_indeterminate();\n+\t      _M_set_buffer(0);\n \n-\t      if ((__mode & ios_base::ate)\n+\t      if ((__mode & ios_base::ate) \n \t\t  && this->seekoff(0, ios_base::end, __mode) < 0)\n \t\t// 27.8.1.3,4\n \t\tthis->close();\n@@ -218,27 +218,28 @@ namespace std\n \t\t\t\tios_base::in);\n \t    }\n \n-\t  if (_M_buf_size)\n+\t  if (_M_buf_size > 1)\n \t    {\n \t      streamsize __elen = 0;\n \t      streamsize __ilen = 0;\n \n \t      if (__check_facet(_M_codecvt).always_noconv())\n \t\t{\n-\t\t  __elen = _M_file.xsgetn(reinterpret_cast<char*>(this->_M_in_beg), _M_buf_size);\n+\t\t  __elen = _M_file.xsgetn(reinterpret_cast<char*>(this->_M_in_beg), _M_buf_size - 1);\n \t\t  __ilen = __elen;\n \t\t}\n \t      else\n \t\t{\n-\t\t  char* __buf = static_cast<char*>(__builtin_alloca(_M_buf_size));\n-\t\t  __elen = _M_file.xsgetn(__buf, _M_buf_size);\n+\t\t  char* __buf = static_cast<char*>(__builtin_alloca(_M_buf_size - 1));\n+\t\t  __elen = _M_file.xsgetn(__buf, _M_buf_size - 1);\n \t\t  \n \t\t  const char* __eend;\n \t\t  char_type* __iend;\n \t\t  codecvt_base::result __r;\n \t\t  __r = _M_codecvt->in(_M_state_cur, __buf, __buf + __elen, \n \t\t\t\t       __eend, this->_M_in_beg, \n-\t\t\t\t       this->_M_in_beg + _M_buf_size, __iend);\n+\t\t\t\t       this->_M_in_beg + _M_buf_size - 1, \n+\t\t\t\t       __iend);\n \t\t  if (__r == codecvt_base::ok)\n \t\t    __ilen = __iend - this->_M_in_beg;\n \t\t  else if (__r == codecvt_base::noconv)\n@@ -258,7 +259,7 @@ namespace std\n \n \t      if (0 < __ilen)\n \t\t{\n-\t\t  _M_set_determinate(__ilen);\n+\t\t  _M_set_buffer(__ilen);\n \t\t  __ret = traits_type::to_int_type(*this->_M_in_cur);\n \t\t  if (__bump)\n \t\t    _M_move_in_cur(1);\n@@ -338,41 +339,30 @@ namespace std\n     _M_overflow(int_type __c)\n     {\n       int_type __ret = traits_type::eof();\n+      const bool __testeof = traits_type::eq_int_type(__c, __ret);\n       const bool __testput = this->_M_out_beg < this->_M_out_lim;\n \n       if (__testput)\n-\t{\n-\t  // Need to restore current position. The position of the external\n-\t  // byte sequence (_M_file) corresponds to _M_filepos, and we need\n-\t  // to move it to _M_out_beg for the write.\n-\t  if (_M_filepos && _M_filepos != this->_M_out_beg)\n-\t    {\n-\t      off_type __off = this->_M_out_beg - _M_filepos;\n-\t      _M_file.seekoff(__off, ios_base::cur);\n-\t    }\n-\n-\t  // Convert internal buffer to external representation, output.\n-\t  if (_M_convert_to_external(this->_M_out_beg, \n-\t\t\t\t     this->_M_out_lim - this->_M_out_beg))\n+ \t{\n+ \t  // Need to restore current position. The position of the\n+ \t  // external byte sequence (_M_file) corresponds to\n+ \t  // _M_filepos, and we need to move it to _M_out_beg for the\n+ \t  // write.\n+\t  if (_M_filepos != this->_M_out_beg)\n+\t    _M_file.seekoff(this->_M_out_beg - _M_filepos, ios_base::cur);\n+\n+\t  // If appropriate, append the overflow char.\n+\t  if (!__testeof)\n+\t    *this->_M_out_lim++ = traits_type::to_char_type(__c);\n+\n+\t  // Convert pending sequence to external representation,\n+\t  // output. \n+\t  if (_M_convert_to_external(this->_M_out_beg,\n+\t\t\t\t     this->_M_out_lim - this->_M_out_beg)\n+\t      && (!__testeof || (__testeof && !_M_file.sync())))\n \t    {\n-\t      // Convert pending sequence to external representation, output.\n-\t      // If eof, then just attempt sync.\n-\t      if (!traits_type::eq_int_type(__c, traits_type::eof()))\n-\t\t{\n-\t\t  // User code must flush when switching modes (thus\n-\t\t  // don't sync).\n-\t\t  char_type __pending = traits_type::to_char_type(__c);\n-\t\t  if (_M_convert_to_external(&__pending, 1))\n-\t\t    {\n-\t\t      _M_set_indeterminate();\n-\t\t      __ret = traits_type::not_eof(__c);\n-\t\t    }\n-\t\t}\n-\t      else if (!_M_file.sync())\n-\t\t{\n-\t\t  _M_set_indeterminate();\n-\t\t  __ret = traits_type::not_eof(__c);\n-\t\t}\n+\t      _M_set_buffer(0);\n+\t      __ret = traits_type::not_eof(__c);\n \t    }\n \t}\n       _M_last_overflowed = true;\t\n@@ -388,20 +378,22 @@ namespace std\n       const bool __testput = this->_M_out_cur < this->_M_out_end;\n       const bool __testout = this->_M_mode & ios_base::out;\n       \n+      // Perhaps set below in _M_overflow.\n+      _M_last_overflowed = false;\n+\n       if (__testout)\n \t{\n \t  if (traits_type::eq_int_type(__c, traits_type::eof()))\n \t    __ret = traits_type::not_eof(__c);\n \t  else if (__testput)\n \t    {\n-\t      *this->_M_out_cur = traits_type::to_char_type(__c);\n+ \t      *this->_M_out_cur = traits_type::to_char_type(__c);\n \t      _M_move_out_cur(1);\n \t      __ret = traits_type::not_eof(__c);\n \t    }\n \t  else \n \t    __ret = this->_M_overflow(__c);\n \t}\n-      _M_last_overflowed = false;    // Set in _M_overflow, below.\n       return __ret;\n     }\n   \n@@ -479,20 +471,23 @@ namespace std\n     {\n       if (!this->is_open() && __s == 0 && __n == 0)\n \tthis->_M_buf_size = 0;\n-      else if (__s && __n)\n+      else if (__s && __n > 1)\n \t{\n-\t  // This is implementation-defined behavior, and assumes\n-\t  // that an external char_type array of length (__s + __n)\n-\t  // exists and has been pre-allocated. If this is not the\n-\t  // case, things will quickly blow up.\n+\t  // This is implementation-defined behavior, and assumes that\n+\t  // an external char_type array of length (__s + __n) exists\n+\t  // and has been pre-allocated. If this is not the case,\n+\t  // things will quickly blow up. The length argument __n must\n+\t  // be greater than 1 because __n - 1 positions will be used\n+\t  // for the get and put areas, and 1 position is needed to\n+\t  // host the overflow char of a full put area.\n \n \t  // Step 1: Destroy the current internal array.\n \t  _M_destroy_internal_buffer();\n \t  \n \t  // Step 2: Use the external array.\n \t  this->_M_buf = __s;\n \t  this->_M_buf_size = __n;\n-\t  _M_set_indeterminate();\n+\t  _M_set_buffer(0);\n \t}\n       _M_last_overflowed = false;\t\n       return this; \n@@ -539,7 +534,7 @@ namespace std\n \n \t      // Return pos_type(off_type(-1)) in case of failure.\n \t      __ret = _M_file.seekoff(__computed_off, __way, __mode);\n-\t      _M_set_indeterminate();\n+\t      _M_set_buffer(0);\n \t    }\n \t  else\n \t    {"}, {"sha": "3f7cd1c69f5b1bf17af5d5165b924eead25e7d7f", "filename": "libstdc++-v3/include/ext/stdio_filebuf.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_filebuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_filebuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_filebuf.h?ref=e3033a2240395246cdfce0197c39162e02c71995", "patch": "@@ -67,19 +67,23 @@ namespace __gnu_cxx\n        *  @param  mode  Same meaning as in a standard filebuf.\n        *  @param  del  Whether to close the file on destruction.\n        *  @param  size  Optimal or preferred size of internal buffer, in bytes.\n+       *                Note that it includes a position for the overflow char,\n+       *                therefore, can't be smaller than 2.\n        *\n        *  This constructor associates a file stream buffer with an open\n        *  POSIX file descriptor.  Iff @a del is true, then the associated\n        *  file will be closed when the stdio_filebuf is closed/destroyed.\n       */\n       stdio_filebuf(int __fd, std::ios_base::openmode __mode, bool __del, \n-\t\t    size_t __size);\n+\t\t    size_t __size = static_cast<size_t>(BUFSIZ));\n \n       /**\n        *  @param  f  An open @c FILE*.\n        *  @param  mode  Same meaning as in a standard filebuf.\n        *  @param  size  Optimal or preferred size of internal buffer, in bytes.\n-       *                Defaults to system's @c BUFSIZ.\n+       *                Defaults to system's @c BUFSIZ. Note that it includes\n+       *                a position for the overflow char, therefore, can't be\n+       *                smaller than 2.\n        *\n        *  This constructor associates a file stream buffer with an open\n        *  C @c FILE*.  The @c FILE* will not be automatically closed when the\n@@ -123,7 +127,7 @@ namespace __gnu_cxx\n \t  this->_M_mode = __mode;\n \t  this->_M_buf_size = __size;\n \t  _M_allocate_internal_buffer();\n-\t  _M_set_indeterminate();\n+\t  _M_set_buffer(0);\n \t}\n     }\n \n@@ -138,7 +142,7 @@ namespace __gnu_cxx\n \t  this->_M_mode = __mode;\n \t  this->_M_buf_size = __size;\n \t  _M_allocate_internal_buffer();\n-\t  _M_set_indeterminate();\n+\t  _M_set_buffer(0);\n \t}\n     }\n } // namespace __gnu_cxx"}, {"sha": "e99d8103286f735d0656cf2668dd178b1197800b", "filename": "libstdc++-v3/include/std/std_fstream.h", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h?ref=e3033a2240395246cdfce0197c39162e02c71995", "patch": "@@ -123,7 +123,9 @@ namespace std\n \n       /**\n        *  @if maint\n-       *  Actual size of internal buffer.\n+       *  Actual size of internal buffer. This number is equal to the size\n+       *  of the put area + 1 position, reserved for the overflow char of\n+       *  a full area.\n        *  @endif\n       */\n       size_t\t\t\t_M_buf_size;\n@@ -452,41 +454,30 @@ namespace std\n       void\n       _M_output_unshift();\n \n-      // These two functions are used to clarify internal buffer\n-      // maintenance. After an overflow, or after a seekoff call that\n-      // started at beg or end, or possibly when the stream becomes\n-      // unbuffered, and a myrid other obscure corner cases, the\n-      // internal buffer does not truly reflect the contents of the\n-      // external buffer. At this point, for whatever reason, it is in\n-      // an indeterminate state.\n-      /**\n-       *  @if maint\n-       *  @doctodo\n-       *  @endif\n-      */\n-      void\n-      _M_set_indeterminate(void)\n-      { _M_set_determinate(off_type(0)); }\n-\n-      /**\n-       *  @if maint\n-       *  @doctodo\n-       *  @endif\n-      */\n-      void\n-      _M_set_determinate(off_type __off)\n-      {\n-\tconst bool __testin = this->_M_mode & ios_base::in;\n-\tconst bool __testout = this->_M_mode & ios_base::out;\n-\tif (__testin)\n-\t  this->setg(this->_M_buf, this->_M_buf, this->_M_buf + __off);\n-\tif (__testout)\n+       // This function sets the pointers of the internal buffer, both get\n+       // and put areas. Typically, __off == _M_in_end - _M_in_beg upon\n+       // _M_underflow; __off == 0 upon _M_overflow, seekoff, open, setbuf.\n+       // \n+       // NB: _M_out_end - _M_out_beg == _M_buf_size - 1, since _M_buf_size\n+       // reflects the actual allocated memory and the last cell is reserved\n+       // for the overflow char of a full put area.\n+       void\n+       _M_set_buffer(streamsize __off)\n+       {\n+ \tconst bool __testin = this->_M_mode & ios_base::in;\n+ \tconst bool __testout = this->_M_mode & ios_base::out;\n+\tif (_M_buf_size)\n \t  {\n-\t    this->setp(this->_M_buf, this->_M_buf + this->_M_buf_size);\n-\t    this->_M_out_lim += __off;\n+\t    if (__testin)\n+\t      this->setg(this->_M_buf, this->_M_buf, this->_M_buf + __off);\n+\t    if (__testout)\n+\t      {\n+\t\tthis->setp(this->_M_buf, this->_M_buf + this->_M_buf_size - 1);\n+\t\tthis->_M_out_lim += __off;\n+\t      }\n+\t    _M_filepos = this->_M_buf + __off;\n \t  }\n-\t_M_filepos = this->_M_buf + __off;\n-      }\n+       }\n     };\n \n   // [27.8.1.5] Template class basic_ifstream"}, {"sha": "38aa6075f03dd133315674f1a9d11bc80a49d90d", "filename": "libstdc++-v3/include/std/std_streambuf.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h?ref=e3033a2240395246cdfce0197c39162e02c71995", "patch": "@@ -187,9 +187,9 @@ namespace std\n       //@{\n       /**\n        *  @if maint\n-       *  _M_set_indeterminate and setp set it equal to _M_out_beg, then\n-       *  at each put operation it may be moved forward (toward _M_out_end)\n-       *  by _M_out_cur_move.\n+       *  setp (and _M_set_buffer(0) in basic_filebuf) set it equal to\n+       *  _M_out_beg, then at each put operation it may be moved\n+       *  forward (toward _M_out_end) by _M_out_cur_move.\n        *  @endif\n       */      \n       char_type*                _M_out_lim;    // End limit of used put area."}, {"sha": "d890f3e7dcf01dc247df34d81c1653862539e783", "filename": "libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fsgetn%2Fchar%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fsgetn%2Fchar%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fsgetn%2Fchar%2F1.cc?ref=e3033a2240395246cdfce0197c39162e02c71995", "patch": "@@ -123,11 +123,11 @@ void test05()\n   VERIFY( c7 == c2 ); // n != i\n   strmsz_1 = fb_03.sgetn(carray1, 10);\n   VERIFY( !strmsz_1 ); //zero\n-  strmsz_1 = fb_01.in_avail();\n+  strmsz_1 = fb_01.in_avail(); // N.B.: _M_in_end - _M_in_beg == BUFSIZ - 1\n   strmsz_2 = fb_01.sgetn(carray2, strmsz_1 + 5);\n   VERIFY( strmsz_1 == strmsz_2 - 5 ); \n   c4 = fb_01.sgetc(); // buffer should have underflowed from above.\n-  VERIFY( c4 == 'i' );\n+  VERIFY( c4 == 'h' );\n   strmsz_1 = fb_01.in_avail();\n   VERIFY( strmsz_1 > 0 );\n   strmsz_2 = fb_01.sgetn(carray2, strmsz_1 + 5);"}, {"sha": "a46f2399b4274cb63368578d190d9f948224195c", "filename": "libstdc++-v3/testsuite/ext/stdio_filebuf_2.cc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fstdio_filebuf_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3033a2240395246cdfce0197c39162e02c71995/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fstdio_filebuf_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fstdio_filebuf_2.cc?ref=e3033a2240395246cdfce0197c39162e02c71995", "patch": "@@ -29,19 +29,17 @@\n // out by _M_really_overflow upon overflow.\n void test01()\n {\n-  \n   using namespace std;\n   bool test = true;\n \n   const char* name = \"tmp_file1\";\n   FILE* file = fopen(name, \"w\");\n   {\n     using namespace __gnu_cxx;\n-    \n-    // One char big stack-based buffer.\n-    stdio_filebuf<char> sbuf(file, ios_base::out, 1); \n+    stdio_filebuf<char> sbuf(file, ios_base::out, 2); \n     sbuf.sputc('T');\n     sbuf.sputc('S');\n+    sbuf.sputc('P');\n   }\n   fclose(file);\n \n@@ -51,8 +49,8 @@ void test01()\n   streamsize n = fbuf.sgetn(buf, sizeof(buf));\t\n   fbuf.close();\n   \n-  VERIFY( n == 2 );\n-  VERIFY( !memcmp(buf, \"TS\", 2) );\n+  VERIFY( n == 3 );\n+  VERIFY( !memcmp(buf, \"TSP\", 3) );\n }\n \n int main()"}]}