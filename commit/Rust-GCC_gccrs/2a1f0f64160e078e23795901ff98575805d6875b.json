{"sha": "2a1f0f64160e078e23795901ff98575805d6875b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmExZjBmNjQxNjBlMDc4ZTIzNzk1OTAxZmY5ODU3NTgwNWQ2ODc1Yg==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-03-26T20:17:13Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-03-26T20:31:05Z"}, "message": "coroutines: Implement n4849 changes to exception handling.\n\nThe standard now calls up a revised mechanism to handle exceptions\nwhere exceptions thrown by the await_resume () method of the\ninitial suspend expression are considered in the same manner as\nexceptions thrown by the user-authored function body.\n\nThis implements [dcl.fct.def.coroutine] / 5.3.\n\ngcc/cp/ChangeLog:\n\n2020-03-26  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* coroutines.cc (co_await_expander): If we are expanding the\n\tinitial await expression, set a boolean flag to show that we\n\thave now reached the initial await_resume() method call.\n\t(expand_co_awaits): Handle the 'initial await resume called' flag.\n\t(build_actor_fn): Insert the initial await expression into the\n\tstart of the user-authored function-body. Handle the 'initial await\n\tresume called' flag.\n\t(morph_fn_to_coro): Initialise the 'initial await resume called'\n\tflag.  Modify the unhandled exception catch clause to recognise\n\texceptions that occur before the initial await_resume() and re-\n\tthrow them.\n\ngcc/testsuite/ChangeLog:\n\n2020-03-26  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* g++.dg/coroutines/torture/exceptions-test-01-n4849-a.C: New test.", "tree": {"sha": "d2ed2c50dfb587d54af0b82d5e77399ab986d6b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2ed2c50dfb587d54af0b82d5e77399ab986d6b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a1f0f64160e078e23795901ff98575805d6875b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1f0f64160e078e23795901ff98575805d6875b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a1f0f64160e078e23795901ff98575805d6875b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1f0f64160e078e23795901ff98575805d6875b/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16948c54b7576fb4b27c59915eac71a0c6bf94f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16948c54b7576fb4b27c59915eac71a0c6bf94f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16948c54b7576fb4b27c59915eac71a0c6bf94f6"}], "stats": {"total": 324, "additions": 319, "deletions": 5}, "files": [{"sha": "e1c8d570a89e911f63172448025fee8e27046c5b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1f0f64160e078e23795901ff98575805d6875b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1f0f64160e078e23795901ff98575805d6875b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2a1f0f64160e078e23795901ff98575805d6875b", "patch": "@@ -1,3 +1,17 @@\n+2020-03-26  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* coroutines.cc (co_await_expander): If we are expanding the\n+\tinitial await expression, set a boolean flag to show that we\n+\thave now reached the initial await_resume() method call.\n+\t(expand_co_awaits): Handle the 'initial await resume called' flag.\n+\t(build_actor_fn): Insert the initial await expression into the\n+\tstart of the user-authored function-body. Handle the 'initial await\n+\tresume called' flag.\n+\t(morph_fn_to_coro): Initialise the 'initial await resume called'\n+\tflag.  Modify the unhandled exception catch clause to recognise\n+\texceptions that occur before the initial await_resume() and re-\n+\tthrow them.\n+\n 2020-03-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/81349"}, {"sha": "ce9377785f90a07d9e58a1d3c3b33ccd80b4e50a", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 88, "deletions": 5, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1f0f64160e078e23795901ff98575805d6875b/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1f0f64160e078e23795901ff98575805d6875b/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=2a1f0f64160e078e23795901ff98575805d6875b", "patch": "@@ -1348,6 +1348,7 @@ struct coro_aw_data\n   tree actor_fn;   /* Decl for context.  */\n   tree coro_fp;    /* Frame pointer var.  */\n   tree resume_idx; /* This is the index var in the frame.  */\n+  tree i_a_r_c;    /* initial suspend await_resume() was called if true.  */\n   tree self_h;     /* This is a handle to the current coro (frame var).  */\n   tree cleanup;    /* This is where to go once we complete local destroy.  */\n   tree cororet;    /* This is where to go if we suspend.  */\n@@ -1445,6 +1446,8 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n   tree awaiter_calls = TREE_OPERAND (saved_co_await, 3);\n \n   tree source = TREE_OPERAND (saved_co_await, 4);\n+  bool is_initial =\n+    (source && TREE_INT_CST_LOW (source) == (int) INITIAL_SUSPEND_POINT);\n   bool is_final = (source\n \t\t   && TREE_INT_CST_LOW (source) == (int) FINAL_SUSPEND_POINT);\n   bool needs_dtor = TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (var));\n@@ -1586,6 +1589,16 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n   resume_label = build_stmt (loc, LABEL_EXPR, resume_label);\n   append_to_statement_list (resume_label, &stmt_list);\n \n+  if (is_initial)\n+    {\n+      /* Note that we are about to execute the await_resume() for the initial\n+\t await expression.  */\n+      r = build2_loc (loc, MODIFY_EXPR, boolean_type_node, data->i_a_r_c,\n+\t\t      boolean_true_node);\n+      r = coro_build_cvt_void_expr_stmt (r, loc);\n+      append_to_statement_list (r, &stmt_list);\n+    }\n+\n   /* This will produce the value (if one is provided) from the co_await\n      expression.  */\n   tree resume_call = TREE_VEC_ELT (awaiter_calls, 2); /* await_resume().  */\n@@ -1634,10 +1647,10 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n \n static tree\n expand_co_awaits (tree fn, tree *fnbody, tree coro_fp, tree resume_idx,\n-\t\t  tree cleanup, tree cororet, tree self_h)\n+\t\t  tree i_a_r_c, tree cleanup, tree cororet, tree self_h)\n {\n   coro_aw_data data\n-    = {fn, coro_fp, resume_idx, self_h, cleanup, cororet, 2};\n+    = {fn, coro_fp, resume_idx, i_a_r_c, self_h, cleanup, cororet, 2};\n   cp_walk_tree (fnbody, co_await_expander, &data, NULL);\n   return *fnbody;\n }\n@@ -2158,15 +2171,42 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \n   /* Get a reference to the initial suspend var in the frame.  */\n   transform_await_expr (initial_await, &xform);\n-  r = coro_build_expr_stmt (initial_await, loc);\n-  add_stmt (r);\n+  tree initial_await_stmt = coro_build_expr_stmt (initial_await, loc);\n \n   /* co_return branches to the final_suspend label, so declare that now.  */\n   tree fs_label = create_named_label_with_ctx (loc, \"final.suspend\", actor);\n \n   /* Expand co_returns in the saved function body  */\n   fnbody = expand_co_returns (&fnbody, promise_proxy, ap, fs_label);\n \n+  /* n4849 adds specific behaviour to treat exceptions thrown by the\n+     await_resume () of the initial suspend expression.  In order to\n+     implement this, we need to treat the initial_suspend expression\n+     as if it were part of the user-authored function body.  This\n+     only applies if exceptions are enabled.  */\n+  if (flag_exceptions)\n+    {\n+      tree outer = fnbody;\n+      if (TREE_CODE (outer) == BIND_EXPR)\n+\touter = BIND_EXPR_BODY (outer);\n+      gcc_checking_assert (TREE_CODE (outer) == TRY_BLOCK);\n+      tree sl = TRY_STMTS (outer);\n+      if (TREE_CODE (sl) == STATEMENT_LIST)\n+\t{\n+\t  tree_stmt_iterator si = tsi_start (sl);\n+\t  tsi_link_before (&si, initial_await_stmt, TSI_NEW_STMT);\n+\t}\n+      else\n+\t{\n+\t  tree new_try = NULL_TREE;\n+\t  append_to_statement_list (initial_await_stmt, &new_try);\n+\t  append_to_statement_list (sl, &new_try);\n+\t  TRY_STMTS (outer) = new_try;\n+\t}\n+    }\n+  else\n+    add_stmt (initial_await_stmt);\n+\n   /* Transform the await expressions in the function body.  Only do each\n      await tree once!  */\n   hash_set<tree> pset;\n@@ -2336,10 +2376,20 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n     = build_class_member_access_expr (actor_frame, res_idx_m, NULL_TREE, false,\n \t\t\t\t      tf_warning_or_error);\n \n+  /* Boolean value to flag that the initial suspend expression's\n+     await_resume () has been called, and therefore we are in the user's\n+     function body for the purposes of handing exceptions.  */\n+  tree i_a_r_c_m\n+    = lookup_member (coro_frame_type, get_identifier (\"__i_a_r_c\"),\n+\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n+  tree i_a_r_c\n+    = build_class_member_access_expr (actor_frame, i_a_r_c_m, NULL_TREE,\n+\t\t\t\t      false, tf_warning_or_error);\n+\n   /* We've now rewritten the tree and added the initial and final\n      co_awaits.  Now pass over the tree and expand the co_awaits.  */\n   actor_body = expand_co_awaits (actor, &actor_body, actor_fp, res_idx,\n-\t\t\t\t del_promise_label, ret_label, ash);\n+\t\t\t\t i_a_r_c, del_promise_label, ret_label, ash);\n \n   actor_body = pop_stmt_list (actor_body);\n   BIND_EXPR_BODY (actor_bind) = actor_body;\n@@ -3040,6 +3090,7 @@ act_des_fn (tree orig, tree fn_type, tree coro_frame_ptr, const char* name)\n   void (*__destroy)(_R_frame *);\n   coro1::promise_type __p;\n   bool frame_needs_free; free the coro frame mem if set.\n+  bool i_a_r_c; [dcl.fct.def.coroutine] / 5.3\n   short __resume_at;\n   handle_type self_handle;\n   (maybe) parameter copies.\n@@ -3161,6 +3212,8 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     = coro_make_frame_entry (&field_list, \"__p\", promise_type, fn_start);\n   tree fnf_name = coro_make_frame_entry (&field_list, \"__frame_needs_free\",\n \t\t\t\t\t boolean_type_node, fn_start);\n+  tree iarc_name = coro_make_frame_entry (&field_list, \"__i_a_r_c\",\n+\t\t\t\t\t boolean_type_node, fn_start);\n   tree resume_idx_name\n     = coro_make_frame_entry (&field_list, \"__resume_at\",\n \t\t\t     short_unsigned_type_node, fn_start);\n@@ -3725,6 +3778,17 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   r = coro_build_cvt_void_expr_stmt (r, fn_start);\n   add_stmt (r);\n \n+  /* Initialize 'initial-await-resume-called' as per\n+     [dcl.fct.def.coroutine] / 5.3 */\n+  tree i_a_r_c_m\n+    = lookup_member (coro_frame_type, iarc_name, 1, 0, tf_warning_or_error);\n+  tree i_a_r_c = build_class_member_access_expr (deref_fp, i_a_r_c_m,\n+\t\t\t\t\t\t NULL_TREE, false,\n+\t\t\t\t\t\t tf_warning_or_error);\n+  r = build2 (INIT_EXPR, boolean_type_node, i_a_r_c, boolean_false_node);\n+  r = coro_build_cvt_void_expr_stmt (r, fn_start);\n+  add_stmt (r);\n+\n   /* So .. call the actor ..  */\n   r = build_call_expr_loc (fn_start, actor, 1, coro_fp);\n   r = maybe_cleanup_point_expr_void (r);\n@@ -3845,6 +3909,25 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       /* Mimic what the parser does for the catch.  */\n       tree handler = begin_handler ();\n       finish_handler_parms (NULL_TREE, handler); /* catch (...) */\n+\n+      /* Get the initial await resume called value.  */\n+      tree i_a_r_c = build_class_member_access_expr (actor_frame, i_a_r_c_m,\n+\t\t\t\t\t\t     NULL_TREE, false,\n+\t\t\t\t\t\t     tf_warning_or_error);\n+      tree not_iarc_if = begin_if_stmt ();\n+      tree not_iarc = build1_loc (fn_start, TRUTH_NOT_EXPR,\n+\t\t\t\t  boolean_type_node, i_a_r_c);\n+      finish_if_stmt_cond (not_iarc, not_iarc_if);\n+      /* If the initial await resume called value is false, rethrow...  */\n+      tree rethrow = build_throw (fn_start, NULL_TREE);\n+      TREE_NO_WARNING (rethrow) = true;\n+      finish_expr_stmt (rethrow);\n+      finish_then_clause (not_iarc_if);\n+      tree iarc_scope = IF_SCOPE (not_iarc_if);\n+      IF_SCOPE (not_iarc_if) = NULL;\n+      not_iarc_if = do_poplevel (iarc_scope);\n+      add_stmt (not_iarc_if);\n+      /* ... else call the promise unhandled exception method.  */\n       ueh = maybe_cleanup_point_expr_void (ueh);\n       add_stmt (ueh);\n       finish_handler (handler);"}, {"sha": "0d59569f8f4df5408a685dd5508d78ddca4a6072", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1f0f64160e078e23795901ff98575805d6875b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1f0f64160e078e23795901ff98575805d6875b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2a1f0f64160e078e23795901ff98575805d6875b", "patch": "@@ -1,3 +1,7 @@\n+2020-03-26  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* g++.dg/coroutines/torture/exceptions-test-01-n4849-a.C: New test.\n+\n 2020-03-26  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.target/i386/pr81213.c: Do not scan assembler"}, {"sha": "e96b4ed1a8bc51c8e07e0ce53ec2a3e45f81f974", "filename": "gcc/testsuite/g++.dg/coroutines/torture/exceptions-test-01-n4849-a.C", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1f0f64160e078e23795901ff98575805d6875b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fexceptions-test-01-n4849-a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1f0f64160e078e23795901ff98575805d6875b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fexceptions-test-01-n4849-a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fexceptions-test-01-n4849-a.C?ref=2a1f0f64160e078e23795901ff98575805d6875b", "patch": "@@ -0,0 +1,213 @@\n+//  { dg-do run }\n+\n+// Test exceptions in the initial await expression, per n4849.\n+\n+#include \"../coro.h\"\n+#include <exception>\n+\n+int gX = 0;\n+\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+    s.handle = nullptr;\n+    PRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+    handle = s.handle;\n+    s.handle = nullptr;\n+    PRINT(\"coro1 op=  \");\n+    return *this;\n+  }\n+  ~coro1() {\n+    PRINT(\"Destroyed coro1\");\n+    if ( handle )\n+      handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+    bool await_ready() const noexcept { return true; }\n+    void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\"); }\n+    void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  };\n+\n+  struct  suspend_always_prt {\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\"); }\n+    void await_resume() const noexcept { PRINT (\"susp-always-resume\"); }\n+    ~suspend_always_prt() { PRINT (\"susp-always-DTOR\"); }\n+  };\n+\n+  /* Constructing this with:\n+      * a value of '1' will cause the initial suspend await_suspend()\n+      call to throw.\n+      * a value of '2' will cause the await resume to throw.  */\n+  struct  suspend_always_susp_throws_prt {\n+    int thrower;\n+    suspend_always_susp_throws_prt (int _t) : thrower(_t) {}\n+    bool await_ready() const noexcept { return false; }\n+\n+    void await_suspend(handle_type) const\n+      { PRINT (\"suspend_always_susp_throws_prt:await_suspend\");\n+        if (thrower == 1)\n+          throw (42);\n+      }\n+    void await_resume() const\n+      { PRINT (\"suspend_always_susp_throws_prt:await_resume\");\n+        if (thrower == 2)\n+          throw (6174);\n+      }\n+    ~suspend_always_susp_throws_prt() { PRINT (\"suspend_always_susp_throws_prt-DTOR\"); }\n+  };\n+\n+  struct promise_type {\n+  int throw_control = 0;\n+  int value;\n+  promise_type(int k)  : throw_control(k), value(-373)\n+  {  PRINTF (\"Created Promise with %d\\n\", k);}\n+\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+  // This provides the tests for what catches exceptions thrown at\n+  // different points in the initial await expression.\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_susp_throws_prt(throw_control);\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  void return_value (int v) {\n+    PRINTF (\"return_value () %d\\n\",v);\n+    value = v;\n+  }\n+  auto yield_value (int v) {\n+    PRINTF (\"yield_value () %d and suspend always\\n\",v);\n+    value = v;\n+    return suspend_always_prt{};\n+  }\n+  int get_value (void) { return value; }\n+\n+  void unhandled_exception() {\n+    PRINT (\"unhandled_exception: caught one!\");\n+    gX = -11;\n+    // returning from here should end up in final_suspend.\n+    }\n+  };\n+};\n+\n+// This doesn't have to do much - we only need to exercise the initial\n+// await expression.\n+\n+struct coro1\n+n4849_ia_thrower (int k)\n+{\n+  int caught = 0;\n+  PRINT (\"f: about to return 22\");\n+  co_return 22;\n+}\n+\n+int main ()\n+{\n+  {\n+  /* Case 0 - nothing should throw.  */\n+  struct coro1 x0;\n+  try {\n+    x0 = n4849_ia_thrower (0);\n+  } catch (...) {\n+    PRINT (\"main: case 0 ctor threw?\");\n+    abort ();\n+  }\n+  /* Resume the initial suspend expression.  */\n+  PRINT (\"main: got coro, resuming..\");\n+  x0.handle.resume();\n+  int y = x0.handle.promise().get_value();\n+  if ( y != 22 )\n+    {\n+      PRINT (\"main: case 0 got the wrong answer.\");\n+      abort ();\n+    }\n+  if (!x0.handle.done())\n+    {\n+      PRINT (\"main: case 0 not done.\");\n+      abort ();\n+    }\n+  if (gX != 0)\n+    {\n+      PRINT (\"main: case 0 body threw?\");\n+      abort ();\n+    }\n+  }\n+\n+  {\n+  /* Case 1 - initial suspend should throw and thus be caught by the \n+     ramp's caller.  */\n+  struct coro1 x1;\n+  try {\n+    x1 = n4849_ia_thrower (1);\n+  } catch (int message) {\n+    PRINTF (\"main: caught an int %d\\n\", message);\n+    if (message != 42)\n+      {\n+        PRINT (\"main: unexpected value?\");\n+        abort ();\n+      }\n+  } catch (...) {\n+    PRINT (\"main: case 1 ctor threw something else?\");\n+    abort ();\n+  }\n+  if (gX != 0)\n+    {\n+      PRINT (\"main: case 0 body threw (how?)\");\n+      abort ();\n+    }\n+  }\n+\n+  {\n+  /* Case 2 - the await_resume from the initial await expression throws\n+     this should be caught by the regular function body wrapper.  */\n+  struct coro1 x2;\n+  try {\n+    x2 = n4849_ia_thrower (2);\n+  } catch (...) {\n+    PRINT (\"main: case 2 ctor threw?\");\n+    abort ();\n+  }\n+  // We now resume - and expect the await_resume to throw which should\n+  // be caught by unhandled_exception().\n+  PRINT (\"main: got coro, resuming..\");\n+  x2.handle.resume();\n+  int y = x2.handle.promise().get_value();\n+  if ( y != -373 )\n+    {\n+      PRINT (\"main: case 2 got the wrong answer.\");\n+      abort ();\n+    }\n+  if (!x2.handle.done())\n+    {\n+      PRINT (\"main: case 2 not done.\");\n+      abort ();\n+    }\n+  if (gX != -11)\n+    {\n+      PRINT (\"main: n4849_is_thrower await_resume exception not caught\");\n+      abort ();\n+    }\n+  }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}]}