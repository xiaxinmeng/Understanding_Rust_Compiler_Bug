{"sha": "b9c91b7f3279e23aed965c05197acf3b6f439f8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjljOTFiN2YzMjc5ZTIzYWVkOTY1YzA1MTk3YWNmM2I2ZjQzOWY4ZA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-27T23:27:47Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-28T01:07:37Z"}, "message": "coroutines: Fix handling of non-class coroutine returns [PR94759]\n\nFrom the standard:\n\nThe header <coroutine> defines the primary template coroutine_traits\nsuch that if ArgTypes is a parameter pack of types and if the\nqualified-id R::promise_type is valid and denotes a type, then\ncoroutine_traits<R,ArgTypes...> has the following publicly accessible\nmember:\n     using promise_type = typename R::promise_type;\n\nthis should not prevent more specialised cases and  the following\ncode should be accepted, but is currently rejected with:\n\n'error: coroutine return type \u2018void\u2019 is not a class'\n\nThis is because the check for non-class-ness of the return value was\nin the wrong place; it needs to be carried out in a SFINAE context.\n\nThe following patch removes the restriction in the traits template\ninstantiation and allows for the case that the ramp function could\nreturn void.\n\nThe <coroutine> header is amended to implement the required\nfunctionality.\n\ngcc/cp/ChangeLog:\n\n2020-04-28  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94759\n\t* coroutines.cc (coro_promise_type_found_p): Do not\n\texclude non-classes here (this needs to be handled in the\n\tcoroutine header).\n\t(morph_fn_to_coro):  Allow for the case where the coroutine\n\treturns void.\n\ngcc/testsuite/ChangeLog:\n\n2020-04-28  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94759\n\t* g++.dg/coroutines/coro-bad-alloc-00-bad-op-new.C: Adjust for\n\tupdated error messages.\n\t* g++.dg/coroutines/coro-bad-alloc-01-bad-op-del.C: Likewise.\n\t* g++.dg/coroutines/coro-bad-alloc-02-no-op-new-nt.C: Likewise.\n\t* g++.dg/coroutines/coro-missing-promise.C: Likewise.\n\t* g++.dg/coroutines/pr93458-5-bad-coro-type.C: Liekwise.\n\t* g++.dg/coroutines/torture/co-ret-17-void-ret-coro.C: New test.\n\nlibstdc++-v3/ChangeLog:\n\n2020-04-28  Jonathan Wakely  <jwakely@redhat.com>\n\t    Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94759\n\t* include/std/coroutine: Implement handing for non-\n\tclass coroutine return types.", "tree": {"sha": "f1defb0510f253de446d9aa6875ab7a5772c0a0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1defb0510f253de446d9aa6875ab7a5772c0a0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9c91b7f3279e23aed965c05197acf3b6f439f8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9c91b7f3279e23aed965c05197acf3b6f439f8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9c91b7f3279e23aed965c05197acf3b6f439f8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9c91b7f3279e23aed965c05197acf3b6f439f8d/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5726da6bdcdc58c44eafd60814aee074bf9d835a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5726da6bdcdc58c44eafd60814aee074bf9d835a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5726da6bdcdc58c44eafd60814aee074bf9d835a"}], "stats": {"total": 217, "additions": 151, "deletions": 66}, "files": [{"sha": "7a90c4c98f3eb97dfa79da10194f9edb1a392621", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b9c91b7f3279e23aed965c05197acf3b6f439f8d", "patch": "@@ -1,3 +1,12 @@\n+2020-04-28  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/94759\n+\t* coroutines.cc (coro_promise_type_found_p): Do not\n+\texclude non-classes here (this needs to be handled in the\n+\tcoroutine header).\n+\t(morph_fn_to_coro):  Allow for the case where the coroutine\n+\treturns void.\n+\n 2020-04-27  Iain Sandoe  <iain@sandoe.co.uk>\n \n \tPR c++/94701"}, {"sha": "b4dc731ae86d73a357ce4c3e13fa04d31bd5ae6d", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 49, "deletions": 55, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=b9c91b7f3279e23aed965c05197acf3b6f439f8d", "patch": "@@ -441,18 +441,6 @@ coro_promise_type_found_p (tree fndecl, location_t loc)\n     {\n       /* Get the coroutine traits template class instance for the function\n \t signature we have - coroutine_traits <R, ...>  */\n-      tree return_type = TREE_TYPE (TREE_TYPE (fndecl));\n-      if (!CLASS_TYPE_P (return_type))\n-\t{\n-\t  /* It makes more sense to show the function header for this, even\n-\t     though we will have encountered it when processing a keyword.\n-\t     Only emit the error once, not for every keyword we encounter.  */\n-\t  if (!coro_info->coro_ret_type_error_emitted)\n-\t    error_at (DECL_SOURCE_LOCATION (fndecl), \"coroutine return type\"\n-\t\t      \" %qT is not a class\", return_type);\n-\t  coro_info->coro_ret_type_error_emitted = true;\n-\t  return false;\n-\t}\n \n       tree templ_class = instantiate_coro_traits (fndecl, loc);\n \n@@ -3518,9 +3506,6 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   if (!coro_function_valid_p (orig))\n     return false;\n \n-  /* The ramp function does return a value.  */\n-  current_function_returns_value = 1;\n-\n   /* We can't validly get here with an empty statement list, since there's no\n      way for the FE to decide it's a coroutine in the absence of any code.  */\n   tree fnbody = pop_stmt_list (DECL_SAVED_TREE (orig));\n@@ -3593,7 +3578,6 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n      1. Types we already know.  */\n \n   tree fn_return_type = TREE_TYPE (TREE_TYPE (orig));\n-  gcc_assert (!VOID_TYPE_P (fn_return_type));\n   tree handle_type = get_coroutine_handle_type (orig);\n   tree promise_type = get_coroutine_promise_type (orig);\n \n@@ -3778,7 +3762,6 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree ramp_bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n   add_stmt (ramp_bind);\n   tree ramp_body = push_stmt_list ();\n-  tree empty_list = build_empty_stmt (fn_start);\n \n   tree coro_fp = build_lang_decl (VAR_DECL, get_identifier (\"coro.frameptr\"),\n \t\t\t\t  coro_frame_ptr);\n@@ -3952,33 +3935,27 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t control to the caller of the coroutine and the return value is\n \t obtained by a call to T::get_return_object_on_allocation_failure(),\n \t where T is the promise type.  */\n-       tree cfra_label\n-\t= create_named_label_with_ctx (fn_start, \"coro.frame.active\",\n-\t\t\t\t       current_scope ());\n-      tree early_ret_list = NULL;\n-      /* init the retval using the user's func.  */\n-      r = build2 (INIT_EXPR, TREE_TYPE (DECL_RESULT (orig)), DECL_RESULT (orig),\n-\t\t  grooaf);\n-      r = coro_build_cvt_void_expr_stmt (r, fn_start);\n-      append_to_statement_list (r, &early_ret_list);\n-      /* We know it's the correct type.  */\n-      r = DECL_RESULT (orig);\n-      r = build_stmt (fn_start, RETURN_EXPR, r);\n-      TREE_NO_WARNING (r) |= 1;\n-      r = maybe_cleanup_point_expr_void (r);\n-      append_to_statement_list (r, &early_ret_list);\n-\n-      tree goto_st = NULL;\n-      r = build1 (GOTO_EXPR, void_type_node, cfra_label);\n-      append_to_statement_list (r, &goto_st);\n-\n-      tree ckk = build1 (CONVERT_EXPR, coro_frame_ptr, integer_zero_node);\n-      tree ckz = build2 (EQ_EXPR, boolean_type_node, coro_fp, ckk);\n-      r = build3 (COND_EXPR, void_type_node, ckz, early_ret_list, empty_list);\n-      add_stmt (r);\n \n-      cfra_label = build_stmt (fn_start, LABEL_EXPR, cfra_label);\n-      add_stmt (cfra_label);\n+      gcc_checking_assert (same_type_p (fn_return_type, TREE_TYPE (grooaf)));\n+      tree if_stmt = begin_if_stmt ();\n+      tree cond = build1 (CONVERT_EXPR, coro_frame_ptr, integer_zero_node);\n+      cond = build2 (EQ_EXPR, boolean_type_node, coro_fp, cond);\n+      finish_if_stmt_cond (cond, if_stmt);\n+      if (VOID_TYPE_P (fn_return_type))\n+\t{\n+\t  /* Execute the get-return-object-on-alloc-fail call...  */\n+\t  finish_expr_stmt (grooaf);\n+\t  /* ... but discard the result, since we return void.  */\n+\t  finish_return_stmt (NULL_TREE);\n+\t}\n+      else\n+\t{\n+\t  /* Get the fallback return object.  */\n+\t  r = build_cplus_new (fn_return_type, grooaf, tf_warning_or_error);\n+\t  finish_return_stmt (r);\n+\t}\n+      finish_then_clause (if_stmt);\n+      finish_if_stmt (if_stmt);\n     }\n \n   /* deref the frame pointer, to use in member access code.  */\n@@ -4176,17 +4153,25 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     }\n \n   tree gro_context_body = push_stmt_list ();\n-  tree gro = build_lang_decl (VAR_DECL, get_identifier (\"coro.gro\"),\n-\t\t\t      TREE_TYPE (get_ro));\n-  DECL_CONTEXT (gro) = current_scope ();\n-  add_decl_expr (gro);\n-  tree gro_bind_vars = gro;\n+  bool gro_is_void_p = VOID_TYPE_P (TREE_TYPE (get_ro));\n \n+  tree gro, gro_bind_vars = NULL_TREE;\n   /* We have to sequence the call to get_return_object before initial\n      suspend.  */\n-  r = build2_loc (fn_start, INIT_EXPR, TREE_TYPE (gro), gro, get_ro);\n-  r = coro_build_cvt_void_expr_stmt (r, fn_start);\n-  add_stmt (r);\n+  if (gro_is_void_p)\n+    finish_expr_stmt (get_ro);\n+  else\n+    {\n+      gro = build_lang_decl (VAR_DECL, get_identifier (\"coro.gro\"),\n+\t\t\t      TREE_TYPE (get_ro));\n+      DECL_CONTEXT (gro) = current_scope ();\n+      add_decl_expr (gro);\n+      gro_bind_vars = gro;\n+\n+      r = build2_loc (fn_start, INIT_EXPR, TREE_TYPE (gro), gro, get_ro);\n+      r = coro_build_cvt_void_expr_stmt (r, fn_start);\n+      add_stmt (r);\n+    }\n \n   /* Initialize the resume_idx_name to 0, meaning \"not started\".  */\n   tree resume_idx_m\n@@ -4222,16 +4207,25 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   /* The ramp is done, we just need the return value.  */\n   if (!same_type_p (TREE_TYPE (get_ro), fn_return_type))\n     {\n-      /* construct the return value with a single GRO param.  */\n-      vec<tree, va_gc> *args = make_tree_vector_single (gro);\n+      /* construct the return value with a single GRO param, if it's not\n+\t void.  */\n+      vec<tree, va_gc> *args = NULL;\n+      vec<tree, va_gc> **arglist = NULL;\n+      if (!gro_is_void_p)\n+\t{\n+\t  args = make_tree_vector_single (gro);\n+\t  arglist = &args;\n+\t}\n       r = build_special_member_call (NULL_TREE,\n-\t\t\t\t     complete_ctor_identifier, &args,\n+\t\t\t\t     complete_ctor_identifier, arglist,\n \t\t\t\t     fn_return_type, LOOKUP_NORMAL,\n \t\t\t\t     tf_warning_or_error);\n       r = build_cplus_new (fn_return_type, r, tf_warning_or_error);\n     }\n-  else\n+  else if (!gro_is_void_p)\n     r = rvalue (gro); /* The GRO is the return value.  */\n+  else\n+    r = NULL_TREE;\n \n   finish_return_stmt (r);\n "}, {"sha": "fe3375a029c8e529a6ae480157a2dc74dd54dfd5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b9c91b7f3279e23aed965c05197acf3b6f439f8d", "patch": "@@ -1,4 +1,15 @@\n-2020-04-21  Iain Sandoe  <iain@sandoe.co.uk>\n+2020-04-28  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/94759\n+\t* g++.dg/coroutines/coro-bad-alloc-00-bad-op-new.C: Adjust for\n+\tupdated error messages.\n+\t* g++.dg/coroutines/coro-bad-alloc-01-bad-op-del.C: Likewise.\n+\t* g++.dg/coroutines/coro-bad-alloc-02-no-op-new-nt.C: Likewise.\n+\t* g++.dg/coroutines/coro-missing-promise.C: Likewise.\n+\t* g++.dg/coroutines/pr93458-5-bad-coro-type.C: Liekwise.\n+\t* g++.dg/coroutines/torture/co-ret-17-void-ret-coro.C: New test.\n+\n+2020-04-27  Iain Sandoe  <iain@sandoe.co.uk>\n \n \tPR c++/94701\n \t* g++.dg/coroutines/torture/local-var-06-structured-binding.C:"}, {"sha": "4706deebf4e0ce42743502ac94c7aab0c15b5249", "filename": "gcc/testsuite/g++.dg/coroutines/coro-bad-alloc-00-bad-op-new.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-00-bad-op-new.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-00-bad-op-new.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-00-bad-op-new.C?ref=b9c91b7f3279e23aed965c05197acf3b6f439f8d", "patch": "@@ -6,7 +6,7 @@\n #include \"coro1-allocators.h\"\n \n struct coro1\n-f ()  /* { dg-error {'operator new' is provided by 'std::__n4861::coroutine_traits<coro1>::promise_type' \\{aka 'coro1::promise_type'\\} but is not usable with the function signature 'coro1 f\\(\\)'} } */\n+f ()  /* { dg-error {'operator new' is provided by 'std::__n4861::__coroutine_traits_impl<coro1, void>::promise_type' \\{aka 'coro1::promise_type'\\} but is not usable with the function signature 'coro1 f\\(\\)'} } */\n {\n   co_return;\n }"}, {"sha": "252cb5e442c26c6813e77c3febe8f65ffdb5804f", "filename": "gcc/testsuite/g++.dg/coroutines/coro-bad-alloc-01-bad-op-del.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-01-bad-op-del.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-01-bad-op-del.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-01-bad-op-del.C?ref=b9c91b7f3279e23aed965c05197acf3b6f439f8d", "patch": "@@ -6,7 +6,7 @@\n #include \"coro1-allocators.h\"\n \n struct coro1\n-f ()  /* { dg-error {'operator delete' is provided by 'std::__n4861::coroutine_traits<coro1>::promise_type' \\{aka 'coro1::promise_type'\\} but is not usable with the function signature 'coro1 f\\(\\)'} } */\n+f ()  /* { dg-error {'operator delete' is provided by 'std::__n4861::__coroutine_traits_impl<coro1, void>::promise_type' \\{aka 'coro1::promise_type'\\} but is not usable with the function signature 'coro1 f\\(\\)'} } */\n {\n   co_return;\n }"}, {"sha": "89972b609452221eefa33be1fdaa5612cf20f10a", "filename": "gcc/testsuite/g++.dg/coroutines/coro-bad-alloc-02-no-op-new-nt.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-02-no-op-new-nt.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-02-no-op-new-nt.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-02-no-op-new-nt.C?ref=b9c91b7f3279e23aed965c05197acf3b6f439f8d", "patch": "@@ -9,7 +9,7 @@\n #include \"coro1-allocators.h\"\n \n struct coro1\n-f () /* { dg-error {'coro1::promise_type::get_return_object_on_allocation_failure\\(\\)\\(\\)' is provided by 'std::__n4861::coroutine_traits<coro1>::promise_type' \\{aka 'coro1::promise_type'\\} but 'operator new' is not marked 'throw\\(\\)' or 'noexcept'} } */\n+f () /* { dg-error {'coro1::promise_type::get_return_object_on_allocation_failure\\(\\)\\(\\)' is provided by 'std::__n4861::__coroutine_traits_impl<coro1, void>::promise_type' \\{aka 'coro1::promise_type'\\} but 'operator new' is not marked 'throw\\(\\)' or 'noexcept'} } */\n {\n   co_return;\n }"}, {"sha": "e75f2002db0c9ef717edebf495b8e8c8c5141f0b", "filename": "gcc/testsuite/g++.dg/coroutines/coro-missing-promise.C", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-promise.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-promise.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-promise.C?ref=b9c91b7f3279e23aed965c05197acf3b6f439f8d", "patch": "@@ -4,8 +4,6 @@\n \n // Diagnose completely missing promise.\n \n-// { dg-error {no type named 'promise_type' in 'struct NoPromiseHere'} \"\" { target *-*-* } 0 }\n-\n struct NoPromiseHere {\n   coro::coroutine_handle<> handle;\n   NoPromiseHere () : handle (nullptr) {}"}, {"sha": "765c04892efd9d6079c6c241595c9838aa859449", "filename": "gcc/testsuite/g++.dg/coroutines/pr93458-5-bad-coro-type.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-5-bad-coro-type.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-5-bad-coro-type.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-5-bad-coro-type.C?ref=b9c91b7f3279e23aed965c05197acf3b6f439f8d", "patch": "@@ -5,8 +5,8 @@\n #include \"coro.h\"\n \n int\n-bad_coroutine (void) // { dg-error {coroutine return type 'int' is not a class} }\n+bad_coroutine (void) \n {\n-  co_yield 5;\n+  co_yield 5; // { dg-error {unable to find the promise type for this coroutine} }\n   co_return;\n }"}, {"sha": "3168ea272c18bbded90ab993215de1aa7fe7fa1c", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-17-void-ret-coro.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-17-void-ret-coro.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c91b7f3279e23aed965c05197acf3b6f439f8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-17-void-ret-coro.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-17-void-ret-coro.C?ref=b9c91b7f3279e23aed965c05197acf3b6f439f8d", "patch": "@@ -0,0 +1,57 @@\n+//  { dg-do run }\n+\n+// Test the ability to specialize the coroutine traits to include\n+// non-class type coroutine ramp return values.\n+\n+#include \"../coro.h\"\n+\n+template<typename R, typename HandleRef, typename ...T>\n+struct std::coroutine_traits<R, HandleRef, T...> {\n+    struct promise_type {\n+        promise_type (HandleRef h, T ...args)\n+        { h = std::coroutine_handle<promise_type>::from_promise (*this);\n+          PRINT (\"Created Promise\");\n+        }\n+\n+        void get_return_object() {}\n+\n+        auto initial_suspend() {\n+          return std::suspend_always{};\n+         }\n+        auto final_suspend() { return std::suspend_never{}; }\n+\n+        void return_void() {}\n+        void unhandled_exception() {}\n+    };\n+};\n+\n+void\n+my_coro (std::coroutine_handle<>& h)\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  std::coroutine_handle<> h;\n+  my_coro (h);\n+\n+  if (h.done())\n+    {\n+      PRINT (\"main: apparently was already done...\");\n+      abort ();\n+    }\n+\n+  // initial suspend.\n+  h.resume ();\n+  \n+  if (!h.done())\n+    {\n+      PRINT (\"main: apparently wasn't done...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "f6de19da5de926a999704fd805177fe2c273e6f8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c91b7f3279e23aed965c05197acf3b6f439f8d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c91b7f3279e23aed965c05197acf3b6f439f8d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b9c91b7f3279e23aed965c05197acf3b6f439f8d", "patch": "@@ -1,3 +1,10 @@\n+2020-04-28  Jonathan Wakely  <jwakely@redhat.com>\n+\t    Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/94759\n+\t* include/std/coroutine: Implement handing for non-\n+\tclass coroutine return types.\n+\n 2020-04-24  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/experimental/executor (service_already_exists): Make default"}, {"sha": "b40a3bcf9cc82a41fad6e296c144d248cc741376", "filename": "libstdc++-v3/include/std/coroutine", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c91b7f3279e23aed965c05197acf3b6f439f8d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcoroutine", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c91b7f3279e23aed965c05197acf3b6f439f8d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcoroutine", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcoroutine?ref=b9c91b7f3279e23aed965c05197acf3b6f439f8d", "patch": "@@ -63,12 +63,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // 17.12.2 coroutine traits\n   /// [coroutine.traits]\n   /// [coroutine.traits.primary]\n-  template <typename _Result, typename...>\n-    struct coroutine_traits\n+  /// If _Result::promise_type is valid and denotes a type then the traits\n+  /// have a single publicly accessible member, otherwise they are empty.\n+  template <typename _Result, typename = void>\n+   struct __coroutine_traits_impl {};\n+\n+  template <typename _Result>\n+    struct __coroutine_traits_impl<_Result,\n+\t\t\t\t    __void_t<typename _Result::promise_type>>\n     {\n-       using promise_type = typename _Result::promise_type;\n+      using promise_type = typename _Result::promise_type;\n     };\n \n+  template <typename _Result, typename...>\n+    struct coroutine_traits : __coroutine_traits_impl<_Result> {};\n+\n   // 17.12.3 Class template coroutine_handle\n   /// [coroutine.handle]\n   template <typename _Promise = void>"}]}