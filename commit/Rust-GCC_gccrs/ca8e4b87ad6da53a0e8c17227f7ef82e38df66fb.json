{"sha": "ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E4ZTRiODdhZDZkYTUzYTBlOGMxNzIyN2Y3ZWY4MmUzOGRmNjZmYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-12-07T04:35:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-12-07T04:35:08Z"}, "message": "Fix decltype-call1.C with -std=c++1z.\n\n\t* parser.h (struct cp_token): Tell GTY that CPP_DECLTYPE uses\n\ttree_check_value.\n\t* parser.c (cp_parser_decltype): Use tree_check_value.\n\t(saved_checks_value): New.\n\t(cp_parser_nested_name_specifier_opt): Use it.\n\t(cp_parser_template_id): Use it.\n\t(cp_parser_simple_type_specifier): Use it.\n\t(cp_parser_pre_parsed_nested_name_specifier): Use it.\n\nFrom-SVN: r231353", "tree": {"sha": "a2db1f22fa258b5aed20835a904e972177465a6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2db1f22fa258b5aed20835a904e972177465a6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5ea106d85b5e2e7278472070b45d22f892f1e1d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ea106d85b5e2e7278472070b45d22f892f1e1d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ea106d85b5e2e7278472070b45d22f892f1e1d3"}], "stats": {"total": 82, "additions": 44, "deletions": 38}, "files": [{"sha": "ca9b97cba47a0fc0828fbedb5f5d0070ad75cad5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb", "patch": "@@ -1,5 +1,14 @@\n 2015-12-06  Jason Merrill  <jason@redhat.com>\n \n+\t* parser.h (struct cp_token): Tell GTY that CPP_DECLTYPE uses\n+\ttree_check_value.\n+\t* parser.c (cp_parser_decltype): Use tree_check_value.\n+\t(saved_checks_value): New.\n+\t(cp_parser_nested_name_specifier_opt): Use it.\n+\t(cp_parser_template_id): Use it.\n+\t(cp_parser_simple_type_specifier): Use it.\n+\t(cp_parser_pre_parsed_nested_name_specifier): Use it.\n+\n \t* semantics.c (finish_qualified_id_expr): Handle\n \tUNBOUND_CLASS_TEMPLATE.\n "}, {"sha": "ce5a21a759a36fa82f1f40726d4a95042c5c9bb6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb", "patch": "@@ -1008,6 +1008,28 @@ cp_lexer_next_token_is_decltype (cp_lexer *lexer)\n   return token_is_decltype (t);\n }\n \n+/* Called when processing a token with tree_check_value; perform or defer the\n+   associated checks and return the value.  */\n+\n+static tree\n+saved_checks_value (struct tree_check *check_value)\n+{\n+  /* Perform any access checks that were deferred.  */\n+  vec<deferred_access_check, va_gc> *checks;\n+  deferred_access_check *chk;\n+  checks = check_value->checks;\n+  if (checks)\n+    {\n+      int i;\n+      FOR_EACH_VEC_SAFE_ELT (checks, i, chk)\n+\tperform_or_defer_access_check (chk->binfo,\n+\t\t\t\t       chk->decl,\n+\t\t\t\t       chk->diag_decl, tf_warning_or_error);\n+    }\n+  /* Return the stored value.  */\n+  return check_value->value;\n+}\n+\n /* Return a pointer to the Nth token in the token stream.  If N is 1,\n    then this is precisely equivalent to cp_lexer_peek_token (except\n    that it is not inline).  One would like to disallow that case, but\n@@ -5818,7 +5840,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t      token = cp_lexer_consume_token (parser->lexer);\n \t      error_at (token->location, \"decltype evaluates to %qT, \"\n \t\t\t\"which is not a class or enumeration type\",\n-\t\t\ttoken->u.value);\n+\t\t\ttoken->u.tree_check_value->value);\n \t      parser->scope = error_mark_node;\n \t      error_p = true;\n \t      /* As below.  */\n@@ -13016,7 +13038,7 @@ cp_parser_decltype (cp_parser *parser)\n     {\n       /* Already parsed.  */\n       cp_lexer_consume_token (parser->lexer);\n-      return start_token->u.value;\n+      return saved_checks_value (start_token->u.tree_check_value);\n     }\n \n   /* Look for the `decltype' token.  */\n@@ -13101,7 +13123,9 @@ cp_parser_decltype (cp_parser *parser)\n   /* Replace the decltype with a CPP_DECLTYPE so we don't need to parse\n      it again.  */\n   start_token->type = CPP_DECLTYPE;\n-  start_token->u.value = expr;\n+  start_token->u.tree_check_value = ggc_cleared_alloc<struct tree_check> ();\n+  start_token->u.tree_check_value->value = expr;\n+  start_token->u.tree_check_value->checks = get_deferred_access_checks ();\n   start_token->keyword = RID_MAX;\n   cp_lexer_purge_tokens_after (parser->lexer, start_token);\n \n@@ -14617,13 +14641,10 @@ cp_parser_template_id (cp_parser *parser,\n \t\t       enum tag_types tag_type,\n \t\t       bool is_declaration)\n {\n-  int i;\n   tree templ;\n   tree arguments;\n   tree template_id;\n   cp_token_position start_of_id = 0;\n-  deferred_access_check *chk;\n-  vec<deferred_access_check, va_gc> *access_check;\n   cp_token *next_token = NULL, *next_token_2 = NULL;\n   bool is_identifier;\n \n@@ -14632,22 +14653,8 @@ cp_parser_template_id (cp_parser *parser,\n   next_token = cp_lexer_peek_token (parser->lexer);\n   if (next_token->type == CPP_TEMPLATE_ID)\n     {\n-      struct tree_check *check_value;\n-\n-      /* Get the stored value.  */\n-      check_value = cp_lexer_consume_token (parser->lexer)->u.tree_check_value;\n-      /* Perform any access checks that were deferred.  */\n-      access_check = check_value->checks;\n-      if (access_check)\n-\t{\n-\t  FOR_EACH_VEC_ELT (*access_check, i, chk)\n-\t    perform_or_defer_access_check (chk->binfo,\n-\t\t\t\t\t   chk->decl,\n-\t\t\t\t\t   chk->diag_decl,\n-\t\t\t\t\t   tf_warning_or_error);\n-\t}\n-      /* Return the stored value.  */\n-      return check_value->value;\n+      cp_lexer_consume_token (parser->lexer);\n+      return saved_checks_value (next_token->u.tree_check_value);\n     }\n \n   /* Avoid performing name lookup if there is no possibility of\n@@ -15999,7 +16006,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n   if (token->type == CPP_DECLTYPE\n       && cp_lexer_peek_nth_token (parser->lexer, 2)->type != CPP_SCOPE)\n     {\n-      type = token->u.value;\n+      type = saved_checks_value (token->u.tree_check_value);\n       if (decl_specs)\n \t{\n \t  cp_parser_set_decl_spec_type (decl_specs, type,\n@@ -27042,24 +27049,12 @@ cp_parser_optional_template_keyword (cp_parser *parser)\n static void\n cp_parser_pre_parsed_nested_name_specifier (cp_parser *parser)\n {\n-  int i;\n   struct tree_check *check_value;\n-  deferred_access_check *chk;\n-  vec<deferred_access_check, va_gc> *checks;\n \n   /* Get the stored value.  */\n   check_value = cp_lexer_consume_token (parser->lexer)->u.tree_check_value;\n-  /* Perform any access checks that were deferred.  */\n-  checks = check_value->checks;\n-  if (checks)\n-    {\n-      FOR_EACH_VEC_SAFE_ELT (checks, i, chk)\n-\tperform_or_defer_access_check (chk->binfo,\n-\t\t\t\t       chk->decl,\n-\t\t\t\t       chk->diag_decl, tf_warning_or_error);\n-    }\n   /* Set the scope from the stored value.  */\n-  parser->scope = check_value->value;\n+  parser->scope = saved_checks_value (check_value);\n   parser->qualifying_scope = check_value->qualifying_scope;\n   parser->object_scope = NULL_TREE;\n }"}, {"sha": "891dd4143efedce9a1a3faa41406b325307f01fc", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=ca8e4b87ad6da53a0e8c17227f7ef82e38df66fb", "patch": "@@ -63,11 +63,13 @@ struct GTY (()) cp_token {\n   location_t location;\n   /* The value associated with this token, if any.  */\n   union cp_token_value {\n-    /* Used for CPP_NESTED_NAME_SPECIFIER and CPP_TEMPLATE_ID.  */\n+    /* Used for compound tokens such as CPP_NESTED_NAME_SPECIFIER.  */\n     struct tree_check* GTY((tag (\"1\"))) tree_check_value;\n     /* Use for all other tokens.  */\n     tree GTY((tag (\"0\"))) value;\n-  } GTY((desc (\"(%1.type == CPP_TEMPLATE_ID) || (%1.type == CPP_NESTED_NAME_SPECIFIER)\"))) u;\n+  } GTY((desc (\"(%1.type == CPP_TEMPLATE_ID)\"\n+\t       \"|| (%1.type == CPP_NESTED_NAME_SPECIFIER)\"\n+\t       \"|| (%1.type == CPP_DECLTYPE)\"))) u;\n };\n \n "}]}