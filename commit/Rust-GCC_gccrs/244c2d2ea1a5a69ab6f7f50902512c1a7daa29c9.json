{"sha": "244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ0YzJkMmVhMWE1YTY5YWI2ZjdmNTA5MDI1MTJjMWE3ZGFhMjljOQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-01-26T17:28:52Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-01-27T10:42:43Z"}, "message": "Support binding functions to LetStmts.\n\nThis supports basic function pointers in rust most of the code was already\nthere to infer this but this has now helped tidy it up and make it work.\n\nFixes #184", "tree": {"sha": "6e7cd01cd95637ad9606570e5ee92d549bd85594", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e7cd01cd95637ad9606570e5ee92d549bd85594"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8578c61be5061fab91fe679a15fd68ab5fad987c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8578c61be5061fab91fe679a15fd68ab5fad987c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8578c61be5061fab91fe679a15fd68ab5fad987c"}], "stats": {"total": 340, "additions": 292, "deletions": 48}, "files": [{"sha": "a9e0f0f0b21341c8ce9078fbc3db47b7ac91a369", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -816,6 +816,10 @@ struct MaybeNamedParam\n     rust_assert (param_type != nullptr);\n     return param_type;\n   }\n+\n+  ParamKind get_param_kind () const { return param_kind; }\n+\n+  Identifier get_name () const { return name; }\n };\n \n /* A function pointer type - can be created via coercion from function items and"}, {"sha": "81d778668fd86b3efa3eff79edbab1f30e59fcd4", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -127,20 +127,28 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    // this could be a constant reference\n-    if (ctx->lookup_const_decl (ref, &translated))\n-      return;\n-\n-    // must be an identifier\n+    Bfunction *fn = nullptr;\n     Bvariable *var = nullptr;\n-    if (!ctx->lookup_var_decl (ref, &var))\n+    if (ctx->lookup_const_decl (ref, &translated))\n       {\n-\trust_fatal_error (expr.get_locus (),\n-\t\t\t  \"failed to lookup compiled variable\");\n \treturn;\n       }\n-\n-    translated = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n+    else if (ctx->lookup_function_decl (ref, &fn))\n+      {\n+\ttranslated\n+\t  = ctx->get_backend ()->function_code_expression (fn,\n+\t\t\t\t\t\t\t   expr.get_locus ());\n+      }\n+    else if (ctx->lookup_var_decl (ref, &var))\n+      {\n+\ttranslated\n+\t  = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n+      }\n+    else\n+      {\n+\trust_fatal_error (expr.get_locus (),\n+\t\t\t  \"failed to lookup compiled reference\");\n+      }\n   }\n \n   void visit (HIR::LiteralExpr &expr)"}, {"sha": "818d5cbeac3cc1e514106059759f4145f9d8f13d", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -28,23 +28,43 @@ void\n ResolvePathRef::visit (HIR::PathInExpression &expr)\n {\n   // need to look up the reference for this identifier\n-  NodeId ref_node_id;\n-  if (!ctx->get_resolver ()->lookup_resolved_name (\n+  NodeId ref_node_id = UNKNOWN_NODEID;\n+  if (ctx->get_resolver ()->lookup_resolved_name (\n \texpr.get_mappings ().get_nodeid (), &ref_node_id))\n     {\n-      return;\n+      Resolver::Definition def;\n+      if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n+\t{\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"unknown reference for resolved name\");\n+\t  return;\n+\t}\n+      ref_node_id = def.parent;\n     }\n \n+  // this can fail because it might be a Constructor for something\n+  // in that case the caller should attempt ResolvePathType::Compile\n+  if (ref_node_id == UNKNOWN_NODEID)\n+    return;\n+\n   HirId ref;\n   if (!ctx->get_mappings ()->lookup_node_to_hir (\n \texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n     {\n-      rust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+      rust_error_at (expr.get_locus (), \"reverse call path lookup failure\");\n       return;\n     }\n \n-  // assumes paths are functions for now\n-  Bfunction *fn;\n+  // this might be a variable reference or a function reference\n+  Bvariable *var = nullptr;\n+  if (ctx->lookup_var_decl (ref, &var))\n+    {\n+      resolved = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n+      return;\n+    }\n+\n+  // must be a function call\n+  Bfunction *fn = nullptr;\n   if (!ctx->lookup_function_decl (ref, &fn))\n     {\n       // this might fail because its a forward decl so we can attempt to"}, {"sha": "e78ae5aaa10b5cc0c9badbb4e8b50909968539fe", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -42,6 +42,57 @@ class ASTLoweringType : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  void visit (AST::BareFunctionType &fntype)\n+  {\n+    bool is_variadic = false;\n+    std::vector<HIR::LifetimeParam> lifetime_params;\n+    HIR::FunctionQualifiers qualifiers (\n+      HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n+\n+    std::vector<HIR::MaybeNamedParam> named_params;\n+    for (auto &param : fntype.get_function_params ())\n+      {\n+\tHIR::MaybeNamedParam::ParamKind kind;\n+\tswitch (param.get_param_kind ())\n+\t  {\n+\t  case AST::MaybeNamedParam::ParamKind::UNNAMED:\n+\t    kind = HIR::MaybeNamedParam::ParamKind::UNNAMED;\n+\t    break;\n+\t  case AST::MaybeNamedParam::ParamKind::IDENTIFIER:\n+\t    kind = HIR::MaybeNamedParam::ParamKind::IDENTIFIER;\n+\t    break;\n+\t  case AST::MaybeNamedParam::ParamKind::WILDCARD:\n+\t    kind = HIR::MaybeNamedParam::ParamKind::WILDCARD;\n+\t    break;\n+\t  }\n+\n+\tHIR::Type *param_type\n+\t  = ASTLoweringType::translate (param.get_type ().get ());\n+\n+\tHIR::MaybeNamedParam p (param.get_name (), kind,\n+\t\t\t\tstd::unique_ptr<HIR::Type> (param_type),\n+\t\t\t\tparam.get_locus ());\n+\tnamed_params.push_back (std::move (p));\n+      }\n+\n+    HIR::Type *return_type = nullptr;\n+    if (fntype.has_return_type ())\n+      {\n+\treturn_type\n+\t  = ASTLoweringType::translate (fntype.get_return_type ().get ());\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, fntype.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::BareFunctionType (\n+      std::move (mapping), std::move (lifetime_params), std::move (qualifiers),\n+      std::move (named_params), is_variadic,\n+      std::unique_ptr<HIR::Type> (return_type), fntype.get_locus ());\n+  }\n+\n   void visit (AST::TupleType &tuple)\n   {\n     std::vector<std::unique_ptr<HIR::Type> > elems;"}, {"sha": "ebed11987c4565de59f9938bff3dca488139a0f9", "filename": "gcc/rust/hir/tree/rust-hir-type.h", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -791,6 +791,16 @@ struct MaybeNamedParam\n   }\n \n   Location get_locus () const { return locus; }\n+\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (param_type != nullptr);\n+    return param_type;\n+  }\n+\n+  ParamKind get_param_kind () const { return param_kind; }\n+\n+  Identifier get_name () const { return name; }\n };\n \n /* A function pointer type - can be created via coercion from function items and\n@@ -805,9 +815,7 @@ class BareFunctionType : public TypeNoBounds\n   std::vector<MaybeNamedParam> params;\n   bool is_variadic;\n \n-  // bool has_return_type;\n-  // BareFunctionReturnType return_type;\n-  std::unique_ptr<TypeNoBounds> return_type; // inlined version\n+  std::unique_ptr<Type> return_type; // inlined version\n \n   Location locus;\n \n@@ -822,7 +830,7 @@ class BareFunctionType : public TypeNoBounds\n \t\t    std::vector<LifetimeParam> lifetime_params,\n \t\t    FunctionQualifiers qualifiers,\n \t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic,\n-\t\t    std::unique_ptr<TypeNoBounds> type, Location locus)\n+\t\t    std::unique_ptr<Type> type, Location locus)\n     : TypeNoBounds (mappings), for_lifetimes (std::move (lifetime_params)),\n       function_qualifiers (std::move (qualifiers)),\n       params (std::move (named_params)), is_variadic (is_variadic),\n@@ -834,8 +842,7 @@ class BareFunctionType : public TypeNoBounds\n     : TypeNoBounds (other.mappings), for_lifetimes (other.for_lifetimes),\n       function_qualifiers (other.function_qualifiers), params (other.params),\n       is_variadic (other.is_variadic),\n-      return_type (other.return_type->clone_type_no_bounds ()),\n-      locus (other.locus)\n+      return_type (other.return_type->clone_type ()), locus (other.locus)\n   {}\n \n   // Overload assignment operator to deep copy\n@@ -846,7 +853,7 @@ class BareFunctionType : public TypeNoBounds\n     function_qualifiers = other.function_qualifiers;\n     params = other.params;\n     is_variadic = other.is_variadic;\n-    return_type = other.return_type->clone_type_no_bounds ();\n+    return_type = other.return_type->clone_type ();\n     locus = other.locus;\n \n     return *this;\n@@ -862,6 +869,19 @@ class BareFunctionType : public TypeNoBounds\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<MaybeNamedParam> &get_function_params () { return params; }\n+  const std::vector<MaybeNamedParam> &get_function_params () const\n+  {\n+    return params;\n+  }\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "f62f17c1276f54ca0fa0dc235bb9fa70ced37e6d", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -102,16 +102,26 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::IdentifierExpr &expr)\n   {\n-    if (!resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+    if (resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+      {\n+\tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t\t Definition{expr.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+      }\n+    else if (resolver->get_type_scope ().lookup (expr.as_string (),\n+\t\t\t\t\t\t &resolved_node))\n+      {\n+\tresolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t\t Definition{expr.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+      }\n+    else\n       {\n \trust_error_at (expr.get_locus (), \"failed to find name: %s\",\n \t\t       expr.as_string ().c_str ());\n-\treturn;\n       }\n-\n-    resolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n-    resolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t     Definition{expr.get_node_id (), parent});\n   }\n \n   void visit (AST::ArithmeticOrLogicalExpr &expr)"}, {"sha": "c3f5e4c26b8937e88d046c9f17decc906eb2512b", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -75,6 +75,9 @@ class ResolveTopLevel : public ResolverBase\n     resolver->get_name_scope ().insert (function.get_function_name (),\n \t\t\t\t\tfunction.get_node_id (),\n \t\t\t\t\tfunction.get_locus ());\n+    resolver->insert_new_definition (function.get_node_id (),\n+\t\t\t\t     Definition{function.get_node_id (),\n+\t\t\t\t\t\tfunction.get_node_id ()});\n \n     // if this does not get a reference it will be determined to be unused\n     // lets give it a fake reference to itself"}, {"sha": "b303ee905d5aef411a15b2b16bc45c8942e0218d", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -34,6 +34,15 @@ class ResolveType : public ResolverBase\n     type->accept_vis (resolver);\n   };\n \n+  void visit (AST::BareFunctionType &fntype)\n+  {\n+    for (auto &param : fntype.get_function_params ())\n+      ResolveType::go (param.get_type ().get (), fntype.get_node_id ());\n+\n+    if (fntype.has_return_type ())\n+      ResolveType::go (fntype.get_return_type ().get (), fntype.get_node_id ());\n+  }\n+\n   void visit (AST::TupleType &tuple)\n   {\n     if (tuple.is_unit_type ())"}, {"sha": "afc238b2d077e647b1f4ff77c6a7c44727d7dff1", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -550,8 +550,8 @@ Session::parse_file (const char *filename)\n   type_resolution (hir);\n \n   // FIXME this needs an option of itself\n-  // auto buf = Resolver::TypeResolverDump::go (hir);\n-  // fprintf (stderr, \"%s\\n\", buf.c_str ());\n+  auto buf = Resolver::TypeResolverDump::go (hir);\n+  fprintf (stderr, \"%s\\n\", buf.c_str ());\n \n   if (saw_errors ())\n     return;"}, {"sha": "78f0d0d2ce32ab7df6a6bd3b32a1a70443f4cce2", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -157,17 +157,32 @@ class TypeCheckExpr : public TypeCheckBase\n     auto fn = expr.get_fnexpr ();\n     auto fn_node_id = fn->get_mappings ().get_nodeid ();\n \n-    // CallExpr might be a function but it might also be a TupleStruct\n-    NodeId ref_node_id;\n-    if (!resolver->lookup_resolved_name (fn_node_id, &ref_node_id))\n+    // then lookup the reference_node_id\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (fn_node_id, &ref_node_id))\n       {\n-\tif (!resolver->lookup_resolved_type (fn_node_id, &ref_node_id))\n+\tDefinition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n \t  {\n \t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"Failed to lookup reference for node: %s\",\n-\t\t\t   expr.as_string ().c_str ());\n+\t\t\t   \"unknown reference for resolved name\");\n \t    return;\n \t  }\n+\tref_node_id = def.parent;\n+      }\n+    else if (!resolver->lookup_resolved_type (fn_node_id, &ref_node_id))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"Failed to lookup type reference for node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    if (ref_node_id == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n       }\n \n     // node back to HIR\n@@ -258,28 +273,39 @@ class TypeCheckExpr : public TypeCheckBase\n     NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n \n     // then lookup the reference_node_id\n-    NodeId ref_node_id;\n-    if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      {\n+\t// these ref_node_ids will resolve to a pattern declaration but we are\n+\t// interested in the definition that this refers to get the parent id\n+\tDefinition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"unknown reference for resolved name\");\n+\t    return;\n+\t  }\n+\tref_node_id = def.parent;\n+      }\n+    else if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n       {\n \trust_error_at (expr.get_locus (),\n-\t\t       \"Failed to lookup reference for node: %s\",\n+\t\t       \"Failed to lookup type reference for node: %s\",\n \t\t       expr.as_string ().c_str ());\n \treturn;\n       }\n \n-    // these ref_node_ids will resolve to a pattern declaration but we are\n-    // interested in the definition that this refers to get the parent id\n-    Definition def;\n-    if (!resolver->lookup_definition (ref_node_id, &def))\n+    if (ref_node_id == UNKNOWN_NODEID)\n       {\n-\trust_error_at (expr.get_locus (), \"unknown reference\");\n+\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n+\t\t       expr.as_string ().c_str ());\n \treturn;\n       }\n \n     // node back to HIR\n     HirId ref;\n     if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t       def.parent, &ref))\n+\t\t\t\t       ref_node_id, &ref))\n       {\n \trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n \treturn;"}, {"sha": "28948991081aec8658f153b6562c52fa23ff1ad7", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -79,6 +79,34 @@ class TypeCheckType : public TypeCheckBase\n     return resolver.translated;\n   }\n \n+  void visit (HIR::BareFunctionType &fntype)\n+  {\n+    TyTy::TyBase *return_type\n+      = fntype.has_return_type ()\n+\t  ? TypeCheckType::Resolve (fntype.get_return_type ().get ())\n+\t  : new TyTy::UnitType (fntype.get_mappings ().get_hirid ());\n+\n+    std::vector<std::pair<HIR::Pattern *, TyTy::TyBase *> > params;\n+    for (auto &param : fntype.get_function_params ())\n+      {\n+\tstd::unique_ptr<HIR::Pattern> to_bind;\n+\n+\tbool is_ref = false;\n+\tbool is_mut = false;\n+\n+\tHIR::Pattern *pattern\n+\t  = new HIR::IdentifierPattern (param.get_name (), param.get_locus (),\n+\t\t\t\t\tis_ref, is_mut, std::move (to_bind));\n+\n+\tTyTy::TyBase *ptype = TypeCheckType::Resolve (param.get_type ().get ());\n+\tparams.push_back (\n+\t  std::pair<HIR::Pattern *, TyTy::TyBase *> (pattern, ptype));\n+      }\n+\n+    translated = new TyTy::FnType (fntype.get_mappings ().get_hirid (),\n+\t\t\t\t   std::move (params), return_type);\n+  }\n+\n   void visit (HIR::TupleType &tuple)\n   {\n     if (tuple.is_unit_type ())"}, {"sha": "be58805ef280bb10ceb9f6ecef247f0b8f898c24", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -410,6 +410,52 @@ class FnRules : public BaseRules\n public:\n   FnRules (FnType *base) : BaseRules (base), base (base) {}\n \n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FnType &type) override\n+  {\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    // FIXME add an abstract method for is_equal on TyBase\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto a = base->param_at (i).second;\n+\tauto b = type.param_at (i).second;\n+\n+\tauto combined_param = a->combine (b);\n+\tif (combined_param == nullptr)\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    auto combined_return\n+      = base->get_return_type ()->combine (type.get_return_type ());\n+    if (combined_return == nullptr)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n private:\n   FnType *base;\n };"}, {"sha": "d506415e504cb3acd1843d5926aef77bbdcc7e44", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -147,11 +147,14 @@ ADTType::accept_vis (TyVisitor &vis)\n std::string\n ADTType::as_string () const\n {\n+  if (num_fields () == 0)\n+    return identifier;\n+\n   std::string fields_buffer;\n   for (auto &field : fields)\n-    fields_buffer += field->as_string () + \"\\n\";\n+    fields_buffer += field->as_string () + \", \";\n \n-  return identifier + \"{\\n\" + fields_buffer + \"\\n}\";\n+  return identifier + \"{\" + fields_buffer + \"}\";\n }\n \n TyBase *"}, {"sha": "604bad054d21d7b95bfd385e981424da76c11f94", "filename": "gcc/testsuite/rust.test/compilable/function_reference1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference1.rs?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -0,0 +1,8 @@\n+fn test(a: i32) -> i32 {\n+    a + 1\n+}\n+\n+fn main() {\n+    let a = test;\n+    let b = a(1);\n+}"}, {"sha": "0b963b27e051d8e45a1c67edd18c3499b8cd8d20", "filename": "gcc/testsuite/rust.test/compilable/function_reference2.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference2.rs?ref=244c2d2ea1a5a69ab6f7f50902512c1a7daa29c9", "patch": "@@ -0,0 +1,8 @@\n+fn test(a: i32) -> i32 {\n+    a + 1\n+}\n+\n+fn main() {\n+    let a: fn(i32) -> i32 = test;\n+    let b = a(1);\n+}"}]}