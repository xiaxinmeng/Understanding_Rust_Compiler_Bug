{"sha": "894d0b150255d479c511373f975747df5e0ada8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk0ZDBiMTUwMjU1ZDQ3OWM1MTEzNzNmOTc1NzQ3ZGY1ZTBhZGE4YQ==", "commit": {"author": {"name": "Chris Fairles", "email": "chris.fairles@gmail.com", "date": "2007-12-26T15:23:49Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-12-26T15:23:49Z"}, "message": "tuple: New.\n\n2007-12-26  Chris Fairles  <chris.fairles@gmail.com>\n\t    Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/std/tuple: New.\n\t* include/tr1/tuple: New, adjust from tr1_impl/tuple code.\t\n\t* include/tr1_impl/tuple: Remove.\n\t* include/Makefile.am: Update.\n\t* include/Makefile.in: Regenerate.\n\nCo-Authored-By: Paolo Carlini <pcarlini@suse.de>\n\nFrom-SVN: r131183", "tree": {"sha": "6bd03fd824d3bef5349165819e4d31cead7399d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bd03fd824d3bef5349165819e4d31cead7399d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/894d0b150255d479c511373f975747df5e0ada8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894d0b150255d479c511373f975747df5e0ada8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/894d0b150255d479c511373f975747df5e0ada8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894d0b150255d479c511373f975747df5e0ada8a/comments", "author": {"login": "chrisfearless", "id": 812000, "node_id": "MDQ6VXNlcjgxMjAwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/812000?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chrisfearless", "html_url": "https://github.com/chrisfearless", "followers_url": "https://api.github.com/users/chrisfearless/followers", "following_url": "https://api.github.com/users/chrisfearless/following{/other_user}", "gists_url": "https://api.github.com/users/chrisfearless/gists{/gist_id}", "starred_url": "https://api.github.com/users/chrisfearless/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chrisfearless/subscriptions", "organizations_url": "https://api.github.com/users/chrisfearless/orgs", "repos_url": "https://api.github.com/users/chrisfearless/repos", "events_url": "https://api.github.com/users/chrisfearless/events{/privacy}", "received_events_url": "https://api.github.com/users/chrisfearless/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a8eabe747536302adff780a868a185d081c77c3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8eabe747536302adff780a868a185d081c77c3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8eabe747536302adff780a868a185d081c77c3c"}], "stats": {"total": 1379, "additions": 911, "deletions": 468}, "files": [{"sha": "ae3ca7a33f6964870bc0270f714e3d78bb0b2e0a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d0b150255d479c511373f975747df5e0ada8a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d0b150255d479c511373f975747df5e0ada8a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=894d0b150255d479c511373f975747df5e0ada8a", "patch": "@@ -1,3 +1,12 @@\n+2007-12-26  Chris Fairles  <chris.fairles@gmail.com>\n+\t    Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/std/tuple: New.\n+\t* include/tr1/tuple: New, adjust from tr1_impl/tuple code.\t\n+\t* include/tr1_impl/tuple: Remove.\n+\t* include/Makefile.am: Update.\n+\t* include/Makefile.in: Regenerate.\n+\n 2007-12-25  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/tr1_impl/hashtable_policy.h (__lower_bound): Add."}, {"sha": "c955de1c19c0933ef1467197e22a1748b4c5c263", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d0b150255d479c511373f975747df5e0ada8a/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d0b150255d479c511373f975747df5e0ada8a/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=894d0b150255d479c511373f975747df5e0ada8a", "patch": "@@ -595,7 +595,6 @@ tr1_impl_headers = \\\n \t${tr1_impl_srcdir}/random \\\n \t${tr1_impl_srcdir}/random.tcc \\\n \t${tr1_impl_srcdir}/regex \\\n-\t${tr1_impl_srcdir}/tuple \\\n \t${tr1_impl_srcdir}/type_traits \\\n \t${tr1_impl_srcdir}/unordered_map \\\n \t${tr1_impl_srcdir}/unordered_set \\"}, {"sha": "afd8190551eff0c463f51a968b3316890cbf0532", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d0b150255d479c511373f975747df5e0ada8a/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d0b150255d479c511373f975747df5e0ada8a/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=894d0b150255d479c511373f975747df5e0ada8a", "patch": "@@ -841,7 +841,6 @@ tr1_impl_headers = \\\n \t${tr1_impl_srcdir}/random \\\n \t${tr1_impl_srcdir}/random.tcc \\\n \t${tr1_impl_srcdir}/regex \\\n-\t${tr1_impl_srcdir}/tuple \\\n \t${tr1_impl_srcdir}/type_traits \\\n \t${tr1_impl_srcdir}/unordered_map \\\n \t${tr1_impl_srcdir}/unordered_set \\"}, {"sha": "1bec09152bd9d9a2493e1a6486a18e71dbf82fb2", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 510, "deletions": 17, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d0b150255d479c511373f975747df5e0ada8a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d0b150255d479c511373f975747df5e0ada8a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=894d0b150255d479c511373f975747df5e0ada8a", "patch": "@@ -40,24 +40,517 @@\n # include <c++0x_warning.h>\n #endif\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n-\n #include <utility>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  include <tr1_impl/tuple>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1\n-#  include <tr1_impl/tuple>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#endif\n+namespace std\n+{\n+  // Adds a const reference to a non-reference type.\n+  template<typename _Tp>\n+    struct __add_c_ref\n+    { typedef const _Tp& type; };\n+\n+  template<typename _Tp>\n+    struct __add_c_ref<_Tp&>\n+    { typedef _Tp& type; };\n+\n+  // Adds a reference to a non-reference type.\n+  template<typename _Tp>\n+    struct __add_ref\n+    { typedef _Tp& type; };\n+\n+  template<typename _Tp>\n+    struct __add_ref<_Tp&>\n+    { typedef _Tp& type; };\n+\n+  template<int _Idx, typename _Head, bool _IsEmpty>\n+    struct _Head_base;    \n+ \n+  template<int _Idx, typename _Head>\n+    struct _Head_base<_Idx, _Head, true>\n+    : public _Head\n+    {\n+      _Head_base()\n+      : _Head() { }\n+\n+      _Head_base(typename __add_c_ref<_Head>::type __h)\n+      : _Head(__h) { }\n+\n+      _Head_base(typename std::remove_reference<_Head>::type&& __h)\n+      : _Head(std::forward<_Head>(__h)) { }\n+\n+      _Head&       _M_head()       { return *this; }\n+      const _Head& _M_head() const { return *this; }\n+    };\n+\n+  template<int _Idx, typename _Head>\n+    struct _Head_base<_Idx, _Head, false>\n+    {\n+      _Head_base()\n+      : _M_head_impl() { }\n+\n+      _Head_base(typename __add_c_ref<_Head>::type __h)\n+      : _M_head_impl(__h) { }\n+\n+      _Head_base(typename std::remove_reference<_Head>::type&& __h)\n+      : _M_head_impl(std::move(__h)) { }\n+\n+      _Head&       _M_head()       { return _M_head_impl; }\n+      const _Head& _M_head() const { return _M_head_impl; }        \n+\n+      _Head _M_head_impl; \n+    };\n+\n+  /**\n+   * @if maint\n+   * Contains the actual implementation of the @c tuple template, stored\n+   * as a recursive inheritance hierarchy from the first element (most\n+   * derived class) to the last (least derived class). The @c Idx\n+   * parameter gives the 0-based index of the element stored at this\n+   * point in the hierarchy; we use it to implement a constant-time\n+   * get() operation.\n+   * @endif\n+   */\n+  template<int _Idx, typename... _Elements>\n+    struct _Tuple_impl; \n+\n+  /**\n+   * @if maint\n+   * Zero-element tuple implementation. This is the basis case for the \n+   * inheritance recursion.\n+   * @endif maint\n+   */\n+  template<int _Idx>\n+    struct _Tuple_impl<_Idx> { };\n+\n+  /**\n+   * @if maint\n+   * Recursive tuple implementation. Here we store the @c Head element\n+   * and derive from a @c Tuple_impl containing the remaining elements\n+   * (which contains the @c Tail).\n+   * @endif\n+   */\n+  template<int _Idx, typename _Head, typename... _Tail>\n+    struct _Tuple_impl<_Idx, _Head, _Tail...>\n+    : public _Tuple_impl<_Idx + 1, _Tail...>,\n+      private _Head_base<_Idx, _Head, std::is_empty<_Head>::value>\n+    {\n+      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;\n+      typedef _Head_base<_Idx, _Head, std::is_empty<_Head>::value> _Base;\n+\n+      _Head&            _M_head()       { return _Base::_M_head(); }\n+      const _Head&      _M_head() const { return _Base::_M_head(); }\n+\n+      _Inherited&       _M_tail()       { return *this; }\n+      const _Inherited& _M_tail() const { return *this; }\n+\n+      _Tuple_impl()\n+      : _Inherited(), _Base() { }\n+\n+      explicit \n+      _Tuple_impl(typename __add_c_ref<_Head>::type __head,\n+\t\t  typename __add_c_ref<_Tail>::type... __tail)\n+      : _Inherited(__tail...), _Base(__head) { }\n+\n+      template<typename... _UElements>\n+      _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)\n+      : _Inherited(__in._M_tail()), _Base(__in._M_head()) { }\n+\n+      _Tuple_impl(const _Tuple_impl& __in)\n+      : _Inherited(__in._M_tail()), _Base(__in._M_head()) { }\n+\n+      template<typename... _UElements>\n+        _Tuple_impl&\n+        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)\n+        {\n+\t  _M_head() = __in._M_head();\n+\t  _M_tail() = __in._M_tail();\n+\t  return *this;\n+\t}\n+\n+      _Tuple_impl&\n+      operator=(const _Tuple_impl& __in)\n+      {\n+\t_M_head() = __in._M_head();\n+\t_M_tail() = __in._M_tail();\n+\treturn *this;\n+      }\n+    };\n+\n+  template<typename... _Elements> \n+    class tuple : public _Tuple_impl<0, _Elements...>\n+    {\n+      typedef _Tuple_impl<0, _Elements...> _Inherited;\n+\n+    public:\n+      tuple()\n+      : _Inherited() { }\n+\n+      explicit\n+      tuple(typename __add_c_ref<_Elements>::type... __elements)\n+      : _Inherited(__elements...) { }\n+\n+      template<typename... _UElements>\n+        tuple(const tuple<_UElements...>& __in)\n+\t: _Inherited(__in) { }\n+\n+      tuple(const tuple& __in)\n+      : _Inherited(__in) { }\n+\n+      template<typename... _UElements>\n+        tuple&\n+        operator=(const tuple<_UElements...>& __in)\n+        {\n+\t  static_cast<_Inherited&>(*this) = __in;\n+\t  return *this;\n+\t}\n+\n+      tuple&\n+      operator=(const tuple& __in)\n+      {\n+\tstatic_cast<_Inherited&>(*this) = __in;\n+\treturn *this;\n+      }\n+    };\n+\n+  template<> class tuple<> { };\n+\n+  // 2-element tuple, with construction and assignment from a pair.\n+  template<typename _T1, typename _T2>\n+    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>\n+    {\n+      typedef _Tuple_impl<0, _T1, _T2> _Inherited;\n+\n+    public:\n+      tuple()\n+      : _Inherited() { }\n+\n+      explicit\n+      tuple(typename __add_c_ref<_T1>::type __a1,\n+\t    typename __add_c_ref<_T2>::type __a2)\n+      : _Inherited(__a1, __a2) { }\n+\n+      template<typename _U1, typename _U2>\n+        tuple(const tuple<_U1, _U2>& __in)\n+\t: _Inherited(__in) { }\n+\n+      tuple(const tuple& __in)\n+      : _Inherited(__in) { }\n+\n+      template<typename _U1, typename _U2>\n+        tuple(const pair<_U1, _U2>& __in)\n+\t: _Inherited(_Tuple_impl<0, \n+\t\t     typename __add_c_ref<_U1>::type,\n+\t\t     typename __add_c_ref<_U2>::type>(__in.first, \n+\t\t\t\t\t\t      __in.second))\n+        { }\n+  \n+      template<typename _U1, typename _U2>\n+        tuple&\n+        operator=(const tuple<_U1, _U2>& __in)\n+        {\n+\t  static_cast<_Inherited&>(*this) = __in;\n+\t  return *this;\n+\t}\n+\n+      tuple&\n+      operator=(const tuple& __in)\n+      {\n+\tstatic_cast<_Inherited&>(*this) = __in;\n+\treturn *this;\n+      }\n+\n+      template<typename _U1, typename _U2>\n+        tuple&\n+        operator=(const pair<_U1, _U2>& __in)\n+        {\n+\t  this->_M_head() = __in.first;\n+\t  this->_M_tail()._M_head() = __in.second;\n+\t  return *this;\n+\t}\n+    };\n+\n+\n+  /// Gives the type of the ith element of a given tuple type.\n+  template<int __i, typename _Tp>\n+    struct tuple_element;\n+\n+  /**\n+   * @if maint\n+   * Recursive case for tuple_element: strip off the first element in\n+   * the tuple and retrieve the (i-1)th element of the remaining tuple.\n+   * @endif\n+   */\n+  template<int __i, typename _Head, typename... _Tail>\n+    struct tuple_element<__i, tuple<_Head, _Tail...> >\n+    : tuple_element<__i - 1, tuple<_Tail...> > { };\n+\n+  /**\n+   * @if maint\n+   * Basis case for tuple_element: The first element is the one we're seeking.\n+   * @endif\n+   */\n+  template<typename _Head, typename... _Tail>\n+    struct tuple_element<0, tuple<_Head, _Tail...> >\n+    {\n+      typedef _Head type;\n+    };\n+\n+  /// Finds the size of a given tuple type.\n+  template<typename _Tp>\n+    struct tuple_size;\n+\n+  /// @brief class tuple_size\n+  template<typename... _Elements>\n+    struct tuple_size<tuple<_Elements...> >\n+    {\n+      static const int value = sizeof...(_Elements);\n+    };\n+\n+  template<typename... _Elements>\n+    const int tuple_size<tuple<_Elements...> >::value;\n+\n+  template<int __i, typename _Head, typename... _Tail>\n+    inline typename __add_ref<_Head>::type\n+    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t)\n+    { return __t._M_head(); }\n+\n+  template<int __i, typename _Head, typename... _Tail>\n+    inline typename __add_c_ref<_Head>::type\n+    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t)\n+    { return __t._M_head(); }\n+\n+  // Return a reference (const reference) to the ith element of a tuple.\n+  // Any const or non-const ref elements are returned with their original type.\n+  template<int __i, typename... _Elements>\n+    inline typename __add_ref<\n+                      typename tuple_element<__i, tuple<_Elements...> >::type\n+                    >::type\n+    get(tuple<_Elements...>& __t)\n+    { return __get_helper<__i>(__t); }\n+\n+  template<int __i, typename... _Elements>\n+    inline typename __add_c_ref<\n+                      typename tuple_element<__i, tuple<_Elements...> >::type\n+                    >::type\n+    get(const tuple<_Elements...>& __t)\n+    { return __get_helper<__i>(__t); }\n+\n+  // This class helps construct the various comparison operations on tuples\n+  template<int __check_equal_size, int __i, int __j,\n+\t   typename _Tp, typename _Up>\n+    struct __tuple_compare;\n+\n+  template<int __i, int __j, typename _Tp, typename _Up>\n+    struct __tuple_compare<0, __i, __j, _Tp, _Up>\n+    {\n+      static bool __eq(const _Tp& __t, const _Up& __u)\n+      {\n+\treturn (get<__i>(__t) == get<__i>(__u) &&\n+\t\t__tuple_compare<0, __i+1, __j, _Tp, _Up>::__eq(__t, __u));\n+      }\n+     \n+      static bool __less(const _Tp& __t, const _Up& __u)\n+      {\n+\treturn ((get<__i>(__t) < get<__i>(__u))\n+\t\t|| !(get<__i>(__u) < get<__i>(__t)) &&\n+\t\t__tuple_compare<0, __i+1, __j, _Tp, _Up>::__less(__t, __u));\n+      }\n+    };\n+\n+  template<int __i, typename _Tp, typename _Up>\n+    struct __tuple_compare<0, __i, __i, _Tp, _Up>\n+    {\n+      static bool __eq(const _Tp&, const _Up&)\n+      { return true; }\n+     \n+      static bool __less(const _Tp&, const _Up&)\n+      { return false; }\n+    };\n+\n+  template<typename... _TElements, typename... _UElements>\n+    bool\n+    operator==(const tuple<_TElements...>& __t,\n+\t       const tuple<_UElements...>& __u)\n+    {\n+      typedef tuple<_TElements...> _Tp;\n+      typedef tuple<_UElements...> _Up;\n+      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value,\n+\t      0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));\n+    }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    bool\n+    operator<(const tuple<_TElements...>& __t,\n+\t      const tuple<_UElements...>& __u)\n+    {\n+      typedef tuple<_TElements...> _Tp;\n+      typedef tuple<_UElements...> _Up;\n+      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value,\n+\t      0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));\n+    }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    inline bool\n+    operator!=(const tuple<_TElements...>& __t,\n+\t       const tuple<_UElements...>& __u)\n+    { return !(__t == __u); }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    inline bool\n+    operator>(const tuple<_TElements...>& __t,\n+\t      const tuple<_UElements...>& __u)\n+    { return __u < __t; }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    inline bool\n+    operator<=(const tuple<_TElements...>& __t,\n+\t       const tuple<_UElements...>& __u)\n+    { return !(__u < __t); }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    inline bool\n+    operator>=(const tuple<_TElements...>& __t,\n+\t       const tuple<_UElements...>& __u)\n+    { return !(__t < __u); }\n+\n+  // NB: DR 705.\n+  template<typename... _Elements>\n+    inline tuple<typename __decay_and_strip<_Elements>::__type...>\n+    make_tuple(_Elements&&... __args)\n+    {\n+      typedef tuple<typename __decay_and_strip<_Elements>::__type...>\n+\t__result_type;\n+      return __result_type(std::forward<_Elements>(__args)...);\n+    }\n+\n+  template<int...> struct __index_holder { };    \n+\n+  template<int __i, typename _IdxHolder, typename... _Elements>\n+    struct __index_holder_impl;\n+\n+  template<int __i, int... _Indexes, typename _IdxHolder, typename... _Elements>\n+    struct __index_holder_impl<__i, __index_holder<_Indexes...>,\n+\t\t\t       _IdxHolder, _Elements...> \n+    {\n+      typedef typename __index_holder_impl<__i + 1,\n+\t\t\t\t\t   __index_holder<_Indexes..., __i>,\n+\t\t\t\t\t   _Elements...>::type type;\n+    };\n+ \n+  template<int __i, int... _Indexes>\n+    struct __index_holder_impl<__i, __index_holder<_Indexes...> >\n+    { typedef __index_holder<_Indexes...> type; };\n+\n+  template<typename... _Elements>\n+    struct __make_index_holder \n+    : __index_holder_impl<0, __index_holder<>, _Elements...> { };\n+    \n+  template<typename... _TElements, int... _TIdx,\n+\t   typename... _UElements, int... _UIdx> \n+    inline tuple<_TElements..., _UElements...> \n+    __tuple_cat_helper(const tuple<_TElements...>& __t,\n+\t\t       const __index_holder<_TIdx...>&,\n+                       const tuple<_UElements...>& __u,\n+\t\t       const __index_holder<_UIdx...>&)\n+    { return tuple<_TElements..., _UElements...>(get<_TIdx>(__t)...,\n+\t\t\t\t\t\t get<_UIdx>(__u)...); }\n+\n+  template<typename... _TElements, int... _TIdx,\n+\t   typename... _UElements, int... _UIdx> \n+    inline tuple<_TElements..., _UElements...> \n+    __tuple_cat_helper(tuple<_TElements...>&& __t,\n+\t\t       const __index_holder<_TIdx...>&, \n+\t\t       const tuple<_UElements...>& __u,\n+\t\t       const __index_holder<_UIdx...>&)\n+    { return tuple<_TElements..., _UElements...>(std::move(get<_TIdx>(__t))...,\n+\t\t\t\t\t\t get<_UIdx>(__u)...); }\n+\n+  template<typename... _TElements, int... _TIdx,\n+\t   typename... _UElements, int... _UIdx>\n+    inline tuple<_TElements..., _UElements...> \n+    __tuple_cat_helper(const tuple<_TElements...>& __t,\n+\t\t       const __index_holder<_TIdx...>&, \n+\t\t       tuple<_UElements...>&& __u,\n+\t\t       const __index_holder<_UIdx...>&)\n+    { return tuple<_TElements..., _UElements...>(get<_TIdx>(__t)...,\n+\t\t\t\t\t\t std::move(get<_UIdx>(__u))...); }\n+\n+  template<typename... _TElements, int... _TIdx,\n+\t   typename... _UElements, int... _UIdx> \n+    inline tuple<_TElements..., _UElements...> \n+    __tuple_cat_helper(tuple<_TElements...>&& __t,\n+\t\t       const __index_holder<_TIdx...>&, \n+\t\t       tuple<_UElements...>&& __u,\n+\t\t       const __index_holder<_UIdx...>&)\n+    { return tuple<_TElements..., _UElements...>(std::move(get<_TIdx>(__t))...,\n+\t\t\t\t\t\t std::move(get<_UIdx>(__u))...); }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    inline tuple<_TElements..., _UElements...> \n+    tuple_cat(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n+    { \n+      return __tuple_cat_helper(__t, typename\n+\t\t\t\t__make_index_holder<_TElements...>::type(),\n+\t\t\t\t__u, typename\n+\t\t\t\t__make_index_holder<_UElements...>::type());\n+    }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    inline tuple<_TElements..., _UElements...> \n+    tuple_cat(tuple<_TElements...>&& __t, const tuple<_UElements...>& __u)\n+    {\n+      return __tuple_cat_helper(std::move(__t), typename\n+\t\t\t\t __make_index_holder<_TElements...>::type(),\n+\t\t\t\t __u, typename\n+\t\t\t\t __make_index_holder<_UElements...>::type());\n+    }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    inline tuple<_TElements..., _UElements...> \n+    tuple_cat(const tuple<_TElements...>& __t, tuple<_UElements...>&& __u)\n+    {\n+      return __tuple_cat_helper(__t, typename\n+\t\t\t\t__make_index_holder<_TElements...>::type(),\n+\t\t\t\tstd::move(__u), typename\n+\t\t\t\t__make_index_holder<_UElements...>::type());\n+    }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    inline tuple<_TElements..., _UElements...>\n+    tuple_cat(tuple<_TElements...>&& __t, tuple<_UElements...>&& __u)\n+    {\n+      return __tuple_cat_helper(std::move(__t), typename\n+\t\t\t\t__make_index_holder<_TElements...>::type(),\n+\t\t\t\tstd::move(__u), typename\n+\t\t\t\t__make_index_holder<_UElements...>::type());\n+    }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    tuple<_TElements..., _UElements...>\n+    operator+(tuple<_TElements...>&& __t, tuple<_UElements...>&& __u)\n+    { return tuple_cat(std::forward<decltype(__t)>(__t),\n+\t\t       std::forward<decltype(__u)>(__u)); }\n+\n+  template<typename... _Elements>\n+    inline tuple<_Elements&...>\n+    tie(_Elements&... __args)\n+    { return tuple<_Elements&...>(__args...); }\n+\n+  // A class (and instance) which can be used in 'tie' when an element\n+  // of a tuple is not required\n+  struct _Swallow_assign\n+  {\n+    template<class _Tp>\n+      _Swallow_assign&\n+      operator=(const _Tp&)\n+      { return *this; }\n+  };\n+\n+  // TODO: Put this in some kind of shared file.\n+  namespace\n+  {\n+    _Swallow_assign ignore;\n+  }; // anonymous namespace\n+}\n \n #endif // _GLIBCXX_CXX0X_TUPLE"}, {"sha": "b342fc3674e496a81c49e67397e14d2e9edf41d6", "filename": "libstdc++-v3/include/tr1/tuple", "status": "modified", "additions": 392, "deletions": 17, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d0b150255d479c511373f975747df5e0ada8a/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d0b150255d479c511373f975747df5e0ada8a/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple?ref=894d0b150255d479c511373f975747df5e0ada8a", "patch": "@@ -39,24 +39,399 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <utility>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/tuple>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/tuple>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n-#endif\n+namespace std\n+{\n+namespace tr1\n+{\n+  // Adds a const reference to a non-reference type.\n+  template<typename _Tp>\n+    struct __add_c_ref\n+    { typedef const _Tp& type; };\n+\n+  template<typename _Tp>\n+    struct __add_c_ref<_Tp&>\n+    { typedef _Tp& type; };\n+\n+  // Adds a reference to a non-reference type.\n+  template<typename _Tp>\n+    struct __add_ref\n+    { typedef _Tp& type; };\n+\n+  template<typename _Tp>\n+    struct __add_ref<_Tp&>\n+    { typedef _Tp& type; };\n+\n+  /**\n+   * @if maint\n+   * Contains the actual implementation of the @c tuple template, stored\n+   * as a recursive inheritance hierarchy from the first element (most\n+   * derived class) to the last (least derived class). The @c Idx\n+   * parameter gives the 0-based index of the element stored at this\n+   * point in the hierarchy; we use it to implement a constant-time\n+   * get() operation.\n+   * @endif\n+   */\n+  template<int _Idx, typename... _Elements>\n+    struct _Tuple_impl; \n+\n+  /**\n+   * @if maint\n+   * Zero-element tuple implementation. This is the basis case for the \n+   * inheritance recursion.\n+   * @endif maint\n+   */\n+  template<int _Idx>\n+    struct _Tuple_impl<_Idx> { };\n+\n+  /**\n+   * @if maint\n+   * Recursive tuple implementation. Here we store the @c Head element\n+   * and derive from a @c Tuple_impl containing the remaining elements\n+   * (which contains the @c Tail).\n+   * @endif\n+   */\n+  template<int _Idx, typename _Head, typename... _Tail>\n+    struct _Tuple_impl<_Idx, _Head, _Tail...>\n+    : public _Tuple_impl<_Idx + 1, _Tail...>\n+    {\n+      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;\n+      \n+      _Head _M_head;\n+      \n+      _Inherited&       _M_tail()       { return *this; }\n+      const _Inherited& _M_tail() const { return *this; }\n+      \n+      _Tuple_impl() : _Inherited(), _M_head() { }\n+      \n+      explicit \n+      _Tuple_impl(typename __add_c_ref<_Head>::type __head,\n+\t\t  typename __add_c_ref<_Tail>::type... __tail)\n+      : _Inherited(__tail...), _M_head(__head) { }\n+\n+      template<typename... _UElements>\n+      _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)\n+      : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }\n+\n+      _Tuple_impl(const _Tuple_impl& __in)\n+      : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }\n+     \n+      template<typename... _UElements>\n+        _Tuple_impl&\n+        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)\n+        {\n+\t  _M_head = __in._M_head;\n+\t  _M_tail() = __in._M_tail();\n+\t  return *this;\n+\t}\n+\n+      _Tuple_impl&\n+      operator=(const _Tuple_impl& __in)\n+      {\n+\t_M_head = __in._M_head;\n+\t_M_tail() = __in._M_tail();\n+\treturn *this;\n+      }\n+    };\n+\n+  template<typename... _Elements> \n+    class tuple : public _Tuple_impl<0, _Elements...>\n+    {\n+      typedef _Tuple_impl<0, _Elements...> _Inherited;\n+\n+    public:\n+      tuple() : _Inherited() { }\n+\n+      explicit\n+      tuple(typename __add_c_ref<_Elements>::type... __elements)\n+      : _Inherited(__elements...) { }\n+\n+      template<typename... _UElements>\n+        tuple(const tuple<_UElements...>& __in)\n+\t: _Inherited(__in) { }\n+\n+      tuple(const tuple& __in)\n+      : _Inherited(__in) { }\n+\n+      template<typename... _UElements>\n+        tuple&\n+        operator=(const tuple<_UElements...>& __in)\n+        {\n+\t  static_cast<_Inherited&>(*this) = __in;\n+\t  return *this;\n+\t}\n+\n+      tuple&\n+      operator=(const tuple& __in)\n+      {\n+\tstatic_cast<_Inherited&>(*this) = __in;\n+\treturn *this;\n+      }\n+    };\n+\n+  template<> class tuple<> { };\n+\n+  // 2-element tuple, with construction and assignment from a pair.\n+  template<typename _T1, typename _T2>\n+    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>\n+    {\n+      typedef _Tuple_impl<0, _T1, _T2> _Inherited;\n+\n+    public:\n+      tuple() : _Inherited() { }\n+\n+      explicit\n+      tuple(typename __add_c_ref<_T1>::type __a1,\n+\t    typename __add_c_ref<_T2>::type __a2)\n+      : _Inherited(__a1, __a2) { }\n+\n+      template<typename _U1, typename _U2>\n+        tuple(const tuple<_U1, _U2>& __in)\n+\t: _Inherited(__in) { }\n+\n+      tuple(const tuple& __in)\n+      : _Inherited(__in) { }\n+\n+      template<typename _U1, typename _U2>\n+        tuple(const pair<_U1, _U2>& __in)\n+\t: _Inherited(_Tuple_impl<0, \n+\t\t     typename __add_c_ref<_U1>::type,\n+\t\t     typename __add_c_ref<_U2>::type>(__in.first, \n+\t\t\t\t\t\t      __in.second))\n+        { }\n+  \n+      template<typename _U1, typename _U2>\n+        tuple&\n+        operator=(const tuple<_U1, _U2>& __in)\n+        {\n+\t  static_cast<_Inherited&>(*this) = __in;\n+\t  return *this;\n+\t}\n+\n+      tuple&\n+      operator=(const tuple& __in)\n+      {\n+\tstatic_cast<_Inherited&>(*this) = __in;\n+\treturn *this;\n+      }\n+\n+      template<typename _U1, typename _U2>\n+        tuple&\n+        operator=(const pair<_U1, _U2>& __in)\n+        {\n+\t  this->_M_head = __in.first;\n+\t  this->_M_tail()._M_head = __in.second;\n+\t  return *this;\n+\t}\n+    };\n+\n+  \n+  /// Gives the type of the ith element of a given tuple type.\n+  template<int __i, typename _Tp>\n+    struct tuple_element;\n+\n+  /**\n+   * @if maint\n+   * Recursive case for tuple_element: strip off the first element in\n+   * the tuple and retrieve the (i-1)th element of the remaining tuple.\n+   * @endif\n+   */\n+  template<int __i, typename _Head, typename... _Tail>\n+    struct tuple_element<__i, tuple<_Head, _Tail...> >\n+    : tuple_element<__i - 1, tuple<_Tail...> > { };\n+\n+  /**\n+   * @if maint\n+   * Basis case for tuple_element: The first element is the one we're seeking.\n+   * @endif\n+   */\n+  template<typename _Head, typename... _Tail>\n+    struct tuple_element<0, tuple<_Head, _Tail...> >\n+    {\n+      typedef _Head type;\n+    };\n+\n+  /// Finds the size of a given tuple type.\n+  template<typename _Tp>\n+    struct tuple_size;\n+\n+  /// @brief class tuple_size\n+  template<typename... _Elements>\n+    struct tuple_size<tuple<_Elements...> >\n+    {\n+      static const int value = sizeof...(_Elements);\n+    };\n+\n+  template<typename... _Elements>\n+    const int tuple_size<tuple<_Elements...> >::value;\n+\n+  template<int __i, typename _Head, typename... _Tail>\n+    inline typename __add_ref<_Head>::type\n+    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t)\n+    {\n+      return __t._M_head;\n+    }\n+\n+  template<int __i, typename _Head, typename... _Tail>\n+    inline typename __add_c_ref<_Head>::type\n+    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t)\n+    {\n+      return __t._M_head;\n+    }\n+\n+  // Return a reference (const reference) to the ith element of a tuple.\n+  // Any const or non-const ref elements are returned with their original type.\n+  template<int __i, typename... _Elements>\n+    inline typename __add_ref<\n+                      typename tuple_element<__i, tuple<_Elements...> >::type\n+                    >::type\n+    get(tuple<_Elements...>& __t)\n+    { \n+      return __get_helper<__i>(__t); \n+    }\n+\n+  template<int __i, typename... _Elements>\n+    inline typename __add_c_ref<\n+                      typename tuple_element<__i, tuple<_Elements...> >::type\n+                    >::type\n+    get(const tuple<_Elements...>& __t)\n+    {\n+      return __get_helper<__i>(__t);\n+    }\n+\n+  // This class helps construct the various comparison operations on tuples\n+  template<int __check_equal_size, int __i, int __j,\n+\t   typename _Tp, typename _Up>\n+    struct __tuple_compare;\n+\n+  template<int __i, int __j, typename _Tp, typename _Up>\n+    struct __tuple_compare<0, __i, __j, _Tp, _Up>\n+    {\n+      static bool __eq(const _Tp& __t, const _Up& __u)\n+      {\n+\treturn (get<__i>(__t) == get<__i>(__u) &&\n+\t\t__tuple_compare<0, __i+1, __j, _Tp, _Up>::__eq(__t, __u));\n+      }\n+     \n+      static bool __less(const _Tp& __t, const _Up& __u)\n+      {\n+\treturn ((get<__i>(__t) < get<__i>(__u))\n+\t\t|| !(get<__i>(__u) < get<__i>(__t)) &&\n+\t\t__tuple_compare<0, __i+1, __j, _Tp, _Up>::__less(__t, __u));\n+      }\n+    };\n+\n+  template<int __i, typename _Tp, typename _Up>\n+    struct __tuple_compare<0, __i, __i, _Tp, _Up>\n+    {\n+      static bool __eq(const _Tp&, const _Up&)\n+      { return true; }\n+     \n+      static bool __less(const _Tp&, const _Up&)\n+      { return false; }\n+    };\n+\n+  template<typename... _TElements, typename... _UElements>\n+    bool\n+    operator==(const tuple<_TElements...>& __t,\n+\t       const tuple<_UElements...>& __u)\n+    {\n+      typedef tuple<_TElements...> _Tp;\n+      typedef tuple<_UElements...> _Up;\n+      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value,\n+\t      0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));\n+    }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    bool\n+    operator<(const tuple<_TElements...>& __t,\n+\t      const tuple<_UElements...>& __u)\n+    {\n+      typedef tuple<_TElements...> _Tp;\n+      typedef tuple<_UElements...> _Up;\n+      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value,\n+\t      0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));\n+    }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    inline bool\n+    operator!=(const tuple<_TElements...>& __t,\n+\t       const tuple<_UElements...>& __u)\n+    { return !(__t == __u); }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    inline bool\n+    operator>(const tuple<_TElements...>& __t,\n+\t      const tuple<_UElements...>& __u)\n+    { return __u < __t; }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    inline bool\n+    operator<=(const tuple<_TElements...>& __t,\n+\t       const tuple<_UElements...>& __u)\n+    { return !(__u < __t); }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    inline bool\n+    operator>=(const tuple<_TElements...>& __t,\n+\t       const tuple<_UElements...>& __u)\n+    { return !(__t < __u); }\n+\n+  template<typename _Tp>\n+    class reference_wrapper;\n+\n+  // Helper which adds a reference to a type when given a reference_wrapper\n+  template<typename _Tp>\n+    struct __strip_reference_wrapper\n+    {\n+      typedef _Tp __type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __strip_reference_wrapper<reference_wrapper<_Tp> >\n+    {\n+      typedef _Tp& __type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >\n+    {\n+      typedef _Tp& __type;\n+    };\n+\n+  template<typename... _Elements>\n+    inline tuple<typename __strip_reference_wrapper<_Elements>::__type...>\n+    make_tuple(_Elements... __args)\n+    {\n+      typedef tuple<typename __strip_reference_wrapper<_Elements>::__type...>\n+        __result_type;\n+      return __result_type(__args...);\n+    }\n+\n+  template<typename... _Elements>\n+    inline tuple<_Elements&...>\n+    tie(_Elements&... __args)\n+    {\n+      return tuple<_Elements&...>(__args...);\n+    }\n+\n+  // A class (and instance) which can be used in 'tie' when an element\n+  // of a tuple is not required\n+  struct _Swallow_assign\n+  {\n+    template<class _Tp>\n+      _Swallow_assign&\n+      operator=(const _Tp&)\n+      { return *this; }\n+  };\n+\n+  // TODO: Put this in some kind of shared file.\n+  namespace\n+  {\n+    _Swallow_assign ignore;\n+  }; // anonymous namespace\n+}\n+}\n \n #endif // _GLIBCXX_TR1_TUPLE"}, {"sha": "e71bd4174c2b57d8e55599b63a5f5d2289ef1f73", "filename": "libstdc++-v3/include/tr1_impl/tuple", "status": "removed", "additions": 0, "deletions": 432, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8eabe747536302adff780a868a185d081c77c3c/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8eabe747536302adff780a868a185d081c77c3c/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftuple?ref=a8eabe747536302adff780a868a185d081c77c3c", "patch": "@@ -1,432 +0,0 @@\n-// class template tuple -*- C++ -*-\n-\n-// Copyright (C) 2007 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file tr1_impl/tuple\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n-*/\n-\n-// Chris Jefferson <chris@bubblescope.net>\n-// Variadic Templates support by Douglas Gregor <doug.gregor@gmail.com>\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-  // Adds a const reference to a non-reference type.\n-  template<typename _Tp>\n-    struct __add_c_ref\n-    { typedef const _Tp& type; };\n-\n-  template<typename _Tp>\n-    struct __add_c_ref<_Tp&>\n-    { typedef _Tp& type; };\n-\n-  // Adds a reference to a non-reference type.\n-  template<typename _Tp>\n-    struct __add_ref\n-    { typedef _Tp& type; };\n-\n-  template<typename _Tp>\n-    struct __add_ref<_Tp&>\n-    { typedef _Tp& type; };\n-\n-  /**\n-   * @if maint\n-   * Contains the actual implementation of the @c tuple template, stored\n-   * as a recursive inheritance hierarchy from the first element (most\n-   * derived class) to the last (least derived class). The @c Idx\n-   * parameter gives the 0-based index of the element stored at this\n-   * point in the hierarchy; we use it to implement a constant-time\n-   * get() operation.\n-   * @endif\n-   */\n-  template<int _Idx, typename... _Elements>\n-    struct _Tuple_impl; \n-\n-  /**\n-   * @if maint\n-   * Zero-element tuple implementation. This is the basis case for the \n-   * inheritance recursion.\n-   * @endif maint\n-   */\n-  template<int _Idx>\n-    struct _Tuple_impl<_Idx> { };\n-\n-  /**\n-   * @if maint\n-   * Recursive tuple implementation. Here we store the @c Head element\n-   * and derive from a @c Tuple_impl containing the remaining elements\n-   * (which contains the @c Tail).\n-   * @endif\n-   */\n-  template<int _Idx, typename _Head, typename... _Tail>\n-    struct _Tuple_impl<_Idx, _Head, _Tail...>\n-    : public _Tuple_impl<_Idx + 1, _Tail...>\n-    {\n-      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;\n-      \n-      _Head _M_head;\n-      \n-      _Inherited&       _M_tail()       { return *this; }\n-      const _Inherited& _M_tail() const { return *this; }\n-      \n-      _Tuple_impl() : _Inherited(), _M_head() { }\n-      \n-      explicit \n-      _Tuple_impl(typename __add_c_ref<_Head>::type __head,\n-\t\t  typename __add_c_ref<_Tail>::type... __tail)\n-      : _Inherited(__tail...), _M_head(__head) { }\n-\n-      template<typename... _UElements>\n-      _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)\n-      : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }\n-\n-      _Tuple_impl(const _Tuple_impl& __in)\n-      : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }\n-     \n-      template<typename... _UElements>\n-        _Tuple_impl&\n-        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)\n-        {\n-\t  _M_head = __in._M_head;\n-\t  _M_tail() = __in._M_tail();\n-\t  return *this;\n-\t}\n-\n-      _Tuple_impl&\n-      operator=(const _Tuple_impl& __in)\n-      {\n-\t_M_head = __in._M_head;\n-\t_M_tail() = __in._M_tail();\n-\treturn *this;\n-      }\n-    };\n-\n-  template<typename... _Elements> \n-    class tuple : public _Tuple_impl<0, _Elements...>\n-    {\n-      typedef _Tuple_impl<0, _Elements...> _Inherited;\n-\n-    public:\n-      tuple() : _Inherited() { }\n-\n-      explicit\n-      tuple(typename __add_c_ref<_Elements>::type... __elements)\n-      : _Inherited(__elements...) { }\n-\n-      template<typename... _UElements>\n-        tuple(const tuple<_UElements...>& __in)\n-\t: _Inherited(__in) { }\n-\n-      tuple(const tuple& __in)\n-      : _Inherited(__in) { }\n-\n-      template<typename... _UElements>\n-        tuple&\n-        operator=(const tuple<_UElements...>& __in)\n-        {\n-\t  static_cast<_Inherited&>(*this) = __in;\n-\t  return *this;\n-\t}\n-\n-      tuple&\n-      operator=(const tuple& __in)\n-      {\n-\tstatic_cast<_Inherited&>(*this) = __in;\n-\treturn *this;\n-      }\n-    };\n-\n-  template<> class tuple<> { };\n-\n-  // 2-element tuple, with construction and assignment from a pair.\n-  template<typename _T1, typename _T2>\n-    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>\n-    {\n-      typedef _Tuple_impl<0, _T1, _T2> _Inherited;\n-\n-    public:\n-      tuple() : _Inherited() { }\n-\n-      explicit\n-      tuple(typename __add_c_ref<_T1>::type __a1,\n-\t    typename __add_c_ref<_T2>::type __a2)\n-      : _Inherited(__a1, __a2) { }\n-\n-      template<typename _U1, typename _U2>\n-        tuple(const tuple<_U1, _U2>& __in)\n-\t: _Inherited(__in) { }\n-\n-      tuple(const tuple& __in)\n-      : _Inherited(__in) { }\n-\n-      template<typename _U1, typename _U2>\n-        tuple(const pair<_U1, _U2>& __in)\n-\t: _Inherited(_Tuple_impl<0, \n-\t\t     typename __add_c_ref<_U1>::type,\n-\t\t     typename __add_c_ref<_U2>::type>(__in.first, \n-\t\t\t\t\t\t      __in.second))\n-        { }\n-  \n-      template<typename _U1, typename _U2>\n-        tuple&\n-        operator=(const tuple<_U1, _U2>& __in)\n-        {\n-\t  static_cast<_Inherited&>(*this) = __in;\n-\t  return *this;\n-\t}\n-\n-      tuple&\n-      operator=(const tuple& __in)\n-      {\n-\tstatic_cast<_Inherited&>(*this) = __in;\n-\treturn *this;\n-      }\n-\n-      template<typename _U1, typename _U2>\n-        tuple&\n-        operator=(const pair<_U1, _U2>& __in)\n-        {\n-\t  this->_M_head = __in.first;\n-\t  this->_M_tail()._M_head = __in.second;\n-\t  return *this;\n-\t}\n-    };\n-\n-  \n-  /// Gives the type of the ith element of a given tuple type.\n-  template<int __i, typename _Tp>\n-    struct tuple_element;\n-\n-  /**\n-   * @if maint\n-   * Recursive case for tuple_element: strip off the first element in\n-   * the tuple and retrieve the (i-1)th element of the remaining tuple.\n-   * @endif\n-   */\n-  template<int __i, typename _Head, typename... _Tail>\n-    struct tuple_element<__i, tuple<_Head, _Tail...> >\n-    : tuple_element<__i - 1, tuple<_Tail...> > { };\n-\n-  /**\n-   * @if maint\n-   * Basis case for tuple_element: The first element is the one we're seeking.\n-   * @endif\n-   */\n-  template<typename _Head, typename... _Tail>\n-    struct tuple_element<0, tuple<_Head, _Tail...> >\n-    {\n-      typedef _Head type;\n-    };\n-\n-  /// Finds the size of a given tuple type.\n-  template<typename _Tp>\n-    struct tuple_size;\n-\n-  /// @brief class tuple_size\n-  template<typename... _Elements>\n-    struct tuple_size<tuple<_Elements...> >\n-    {\n-      static const int value = sizeof...(_Elements);\n-    };\n-\n-  template<typename... _Elements>\n-    const int tuple_size<tuple<_Elements...> >::value;\n-\n-  template<int __i, typename _Head, typename... _Tail>\n-    inline typename __add_ref<_Head>::type\n-    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t)\n-    {\n-      return __t._M_head;\n-    }\n-\n-  template<int __i, typename _Head, typename... _Tail>\n-    inline typename __add_c_ref<_Head>::type\n-    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t)\n-    {\n-      return __t._M_head;\n-    }\n-\n-  // Return a reference (const reference) to the ith element of a tuple.\n-  // Any const or non-const ref elements are returned with their original type.\n-  template<int __i, typename... _Elements>\n-    inline typename __add_ref<\n-                      typename tuple_element<__i, tuple<_Elements...> >::type\n-                    >::type\n-    get(tuple<_Elements...>& __t)\n-    { \n-      return __get_helper<__i>(__t); \n-    }\n-\n-  template<int __i, typename... _Elements>\n-    inline typename __add_c_ref<\n-                      typename tuple_element<__i, tuple<_Elements...> >::type\n-                    >::type\n-    get(const tuple<_Elements...>& __t)\n-    {\n-      return __get_helper<__i>(__t);\n-    }\n-\n-  // This class helps construct the various comparison operations on tuples\n-  template<int __check_equal_size, int __i, int __j,\n-\t   typename _Tp, typename _Up>\n-    struct __tuple_compare;\n-\n-  template<int __i, int __j, typename _Tp, typename _Up>\n-    struct __tuple_compare<0, __i, __j, _Tp, _Up>\n-    {\n-      static bool __eq(const _Tp& __t, const _Up& __u)\n-      {\n-\treturn (get<__i>(__t) == get<__i>(__u) &&\n-\t\t__tuple_compare<0, __i+1, __j, _Tp, _Up>::__eq(__t, __u));\n-      }\n-     \n-      static bool __less(const _Tp& __t, const _Up& __u)\n-      {\n-\treturn ((get<__i>(__t) < get<__i>(__u))\n-\t\t|| !(get<__i>(__u) < get<__i>(__t)) &&\n-\t\t__tuple_compare<0, __i+1, __j, _Tp, _Up>::__less(__t, __u));\n-      }\n-    };\n-\n-  template<int __i, typename _Tp, typename _Up>\n-    struct __tuple_compare<0, __i, __i, _Tp, _Up>\n-    {\n-      static bool __eq(const _Tp&, const _Up&)\n-      { return true; }\n-     \n-      static bool __less(const _Tp&, const _Up&)\n-      { return false; }\n-    };\n-\n-  template<typename... _TElements, typename... _UElements>\n-    bool\n-    operator==(const tuple<_TElements...>& __t,\n-\t       const tuple<_UElements...>& __u)\n-    {\n-      typedef tuple<_TElements...> _Tp;\n-      typedef tuple<_UElements...> _Up;\n-      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value,\n-\t      0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));\n-    }\n-\n-  template<typename... _TElements, typename... _UElements>\n-    bool\n-    operator<(const tuple<_TElements...>& __t,\n-\t      const tuple<_UElements...>& __u)\n-    {\n-      typedef tuple<_TElements...> _Tp;\n-      typedef tuple<_UElements...> _Up;\n-      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value,\n-\t      0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));\n-    }\n-\n-  template<typename... _TElements, typename... _UElements>\n-    bool\n-    operator!=(const tuple<_TElements...>& __t,\n-\t       const tuple<_UElements...>& __u)\n-    { return !(__t == __u); }\n-\n-  template<typename... _TElements, typename... _UElements>\n-    bool\n-    operator>(const tuple<_TElements...>& __t,\n-\t      const tuple<_UElements...>& __u)\n-    { return __u < __t; }\n-\n-  template<typename... _TElements, typename... _UElements>\n-    bool\n-    operator<=(const tuple<_TElements...>& __t,\n-\t       const tuple<_UElements...>& __u)\n-    { return !(__u < __t); }\n-\n-  template<typename... _TElements, typename... _UElements>\n-    bool\n-    operator>=(const tuple<_TElements...>& __t,\n-\t       const tuple<_UElements...>& __u)\n-    { return !(__t < __u); }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_TR1\n-  template<typename _Tp>\n-    class reference_wrapper;\n-\n-  // Helper which adds a reference to a type when given a reference_wrapper\n-  template<typename _Tp>\n-    struct __strip_reference_wrapper\n-    {\n-      typedef _Tp __type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __strip_reference_wrapper<reference_wrapper<_Tp> >\n-    {\n-      typedef _Tp& __type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >\n-    {\n-      typedef _Tp& __type;\n-    };\n-#endif\n-\n-  template<typename... _Elements>\n-    inline tuple<typename __strip_reference_wrapper<_Elements>::__type...>\n-    make_tuple(_Elements... __args)\n-    {\n-      typedef tuple<typename __strip_reference_wrapper<_Elements>::__type...>\n-        __result_type;\n-      return __result_type(__args...);\n-    }\n-\n-  template<typename... _Elements>\n-    inline tuple<_Elements&...>\n-    tie(_Elements&... __args)\n-    {\n-      return tuple<_Elements&...>(__args...);\n-    }\n-\n-  // A class (and instance) which can be used in 'tie' when an element\n-  // of a tuple is not required\n-  struct _Swallow_assign\n-  {\n-    template<class _Tp>\n-      _Swallow_assign&\n-      operator=(const _Tp&)\n-      { return *this; }\n-  };\n-\n-  // TODO: Put this in some kind of shared file.\n-  namespace\n-  {\n-    _Swallow_assign ignore;\n-  }; // anonymous namespace\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}"}]}