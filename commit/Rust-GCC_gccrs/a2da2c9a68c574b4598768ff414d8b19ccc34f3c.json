{"sha": "a2da2c9a68c574b4598768ff414d8b19ccc34f3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJkYTJjOWE2OGM1NzRiNDU5ODc2OGZmNDE0ZDhiMTljY2MzNGYzYw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2005-03-07T21:10:49Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2005-03-07T21:10:49Z"}, "message": "[multiple changes]\n\n2005-03-04  Bryce McKinlay  <mckinlay@redhat.com>\n\n\t* verify-glue.c (vfy_is_assignable_from): Perform static check using\n\tcan_widen_reference_to if the C++ ABI is in use.\n\t(vfy_get_interface_count, vfy_get_interface): Remove unused functions.\n\t* verify-impl.c (debug_print, make_utf8_const, init_type, copy_type,\n\ttype_isresolved, init_state, set_pc, state_get_pc,\n\t_Jv_BytecodeVerifier): Clean up unused and disabled functions.\n\t(verify_fail): Report the current PC from the verifier context.\n\t(free_state): Remove #if 0 block to enable this function.\n\t(free_verifier_context): Call free_state on state_list iterator\n\tvalues before freeing them.\n\t* expr.c (pop_type_0): Pop correct type for error message when stack\n\tcontains a multi-word type.\n\n2005-03-04  Ranjit Mathew  <rmathew@hotmail.com>\n\n\t* expr.c (build_java_array_length_access): Remove !flag_new_verifier\n\tfor known NULL array length access.\n\nFrom-SVN: r96044", "tree": {"sha": "9d0e7f2e3d8eea9278d7553dc439c5ea0969d3da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d0e7f2e3d8eea9278d7553dc439c5ea0969d3da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2da2c9a68c574b4598768ff414d8b19ccc34f3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2da2c9a68c574b4598768ff414d8b19ccc34f3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2da2c9a68c574b4598768ff414d8b19ccc34f3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2da2c9a68c574b4598768ff414d8b19ccc34f3c/comments", "author": null, "committer": null, "parents": [{"sha": "c80d391c3e2fba4f444d759d146e5ef6e5326613", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c80d391c3e2fba4f444d759d146e5ef6e5326613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c80d391c3e2fba4f444d759d146e5ef6e5326613"}], "stats": {"total": 228, "additions": 37, "deletions": 191}, "files": [{"sha": "298bd725b85843cd0ff091fdaba3ece0ddf985dd", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2da2c9a68c574b4598768ff414d8b19ccc34f3c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2da2c9a68c574b4598768ff414d8b19ccc34f3c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=a2da2c9a68c574b4598768ff414d8b19ccc34f3c", "patch": "@@ -1,3 +1,23 @@\n+2005-03-07  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* verify-glue.c (vfy_is_assignable_from): Perform static check using\n+\tcan_widen_reference_to if the C++ ABI is in use.\n+\t(vfy_get_interface_count, vfy_get_interface): Remove unused functions.\n+\t* verify-impl.c (debug_print, make_utf8_const, init_type, copy_type,\n+\ttype_isresolved, init_state, set_pc, state_get_pc,\n+\t_Jv_BytecodeVerifier): Clean up unused and disabled functions.\n+\t(verify_fail): Report the current PC from the verifier context.\n+\t(free_state): Remove #if 0 block to enable this function.\n+\t(free_verifier_context): Call free_state on state_list iterator\n+\tvalues before freeing them.\n+\t* expr.c (pop_type_0): Pop correct type for error message when stack\n+\tcontains a multi-word type.\n+\n+2005-03-07  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\t* expr.c (build_java_array_length_access): Remove !flag_new_verifier\n+\tfor known NULL array length access.\n+\n 2005-03-07  Tom Tromey  <tromey@redhat.com>\n \n \t* gcj.texi (Invoking gcj-dbtool): Document '-f'."}, {"sha": "eaf5fd04292e4e9f9cd8615ec6c40f343bb08f21", "filename": "gcc/java/expr.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2da2c9a68c574b4598768ff414d8b19ccc34f3c/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2da2c9a68c574b4598768ff414d8b19ccc34f3c/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=a2da2c9a68c574b4598768ff414d8b19ccc34f3c", "patch": "@@ -383,6 +383,10 @@ pop_type_0 (tree type, char **messagep)\n  fail:\n   {\n     char *temp = xstrdup (lang_printable_name (type, 0));\n+    /* If the stack contains a multi-word type, keep popping the stack until \n+       the real type is found.  */\n+    while (t == void_type_node)\n+      t = stack_type_map[--stack_pointer];\n     *messagep = concat (\"expected type '\", temp,\n \t\t\t\"' but stack contains '\", lang_printable_name (t, 0),\n \t\t\t\"'\", NULL);\n@@ -818,7 +822,7 @@ build_java_array_length_access (tree node)\n      throws a NullPointerException.  The only way we could get a node\n      of type ptr_type_node at this point is `aconst_null; arraylength'\n      or something equivalent.  */\n-  if (!flag_new_verifier && type == ptr_type_node)\n+  if (type == ptr_type_node)\n     return build3 (CALL_EXPR, int_type_node, \n \t\t   build_address_of (soft_nullpointer_node),\n \t\t   NULL_TREE, NULL_TREE);"}, {"sha": "67bc0e48e1ee9f74466a8f53167a479a9d57d01b", "filename": "gcc/java/lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2da2c9a68c574b4598768ff414d8b19ccc34f3c/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2da2c9a68c574b4598768ff414d8b19ccc34f3c/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=a2da2c9a68c574b4598768ff414d8b19ccc34f3c", "patch": "@@ -134,7 +134,7 @@ int flag_deprecated = 1;\n int flag_verify_invocations = 0; \n \n /* True if the new bytecode verifier should be used.  */\n-int flag_new_verifier = 0;\n+int flag_new_verifier = 1;\n \n /* When nonzero, print extra version information.  */\n static int v_flag = 0;"}, {"sha": "b1664ba991a3342e38d62dd9450602aaed5e5aca", "filename": "gcc/java/verify-glue.c", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2da2c9a68c574b4598768ff414d8b19ccc34f3c/gcc%2Fjava%2Fverify-glue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2da2c9a68c574b4598768ff414d8b19ccc34f3c/gcc%2Fjava%2Fverify-glue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-glue.c?ref=a2da2c9a68c574b4598768ff414d8b19ccc34f3c", "patch": "@@ -231,17 +231,18 @@ vfy_get_class_name (vfy_jclass klass)\n bool\n vfy_is_assignable_from (vfy_jclass target, vfy_jclass source)\n {\n-  /* At compile time, for the BC-ABI we assume that reference types are always \n-  compatible.  However, a type assertion table entry is emitted so that the\n-  runtime can detect binary-incompatible changes.  */\n-\n-  /* FIXME: implement real test for old ABI.  */\n-\n   /* Any class is always assignable to itself, or java.lang.Object. */\n   if (source == target || target == object_type_node)\n     return true;\n \n-  /* Otherwise, a type assertion is required.  */\n+  /* For the C++ ABI, perform this test statically. */\n+  if (! flag_indirect_dispatch)\n+    return can_widen_reference_to (source, target);\n+\n+  /* For the BC-ABI, we assume at compile time that reference types are always \n+  compatible.  However, a type assertion table entry is emitted so that the\n+  runtime can detect binary-incompatible changes.  */\n+\n   add_type_assertion (current_class, JV_ASSERT_TYPES_COMPATIBLE, source,\n \t\t      target);\n   return true;\n@@ -257,28 +258,6 @@ vfy_get_primitive_char (vfy_jclass klass)\n   return (IDENTIFIER_POINTER (sig))[0];\n }\n \n-int\n-vfy_get_interface_count (vfy_jclass klass ATTRIBUTE_UNUSED)\n-{\n-  /* FIXME: Need to merge from mainline to get this. */\n-  #if 0\n-  return BINFO_N_BASE_BINFOS (klass);\n-  #endif\n-  return -1;\n-}\n-\n-vfy_jclass\n-vfy_get_interface (vfy_jclass klass ATTRIBUTE_UNUSED, int index ATTRIBUTE_UNUSED)\n-{\n-  /* FIXME: Need to merge from mainline to get this. */\n-  #if 0\n-  vfy_jclass k;\n-  k = BINFO_BASE_BINFO (klass, index);\n-  return k;\n-  #endif\n-  return NULL;\n-}\n-\n bool\n vfy_is_array (vfy_jclass klass)\n {"}, {"sha": "30d12209449c8cfe656d2aa1de724881dea705bc", "filename": "gcc/java/verify-impl.c", "status": "modified", "additions": 3, "deletions": 160, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2da2c9a68c574b4598768ff414d8b19ccc34f3c/gcc%2Fjava%2Fverify-impl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2da2c9a68c574b4598768ff414d8b19ccc34f3c/gcc%2Fjava%2Fverify-impl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-impl.c?ref=a2da2c9a68c574b4598768ff414d8b19ccc34f3c", "patch": "@@ -42,22 +42,6 @@ debug_print (const char *fmt ATTRIBUTE_UNUSED, ...)\n }    \n #endif /* VERIFY_DEBUG */\n \n-#if 0\n-static void debug_print (const char *fmt, ...)\n-  __attribute__ ((format (printf, 1, 2)));\n-\n-static void\n-debug_print (const char *fmt, ...)\n-{\n-#ifdef VERIFY_DEBUG\n-  va_list ap;\n-  va_start (ap, fmt);\n-  vfprintf (stderr, fmt, ap);\n-  va_end (ap);\n-#endif /* VERIFY_DEBUG */\n-}\n-#endif\n-\n /* This started as a fairly ordinary verifier, and for the most part\n    it remains so.  It works in the obvious way, by modeling the effect\n    of each opcode as it is encountered.  For most opcodes, this is a\n@@ -224,22 +208,6 @@ static GTY(()) verifier_context *vfr;\n bool type_initialized (type *t);\n int ref_count_dimensions (ref_intersection *ref);\n \n-#if 0\n-  /* Create a new Utf-8 constant and return it.  We do this to avoid\n-     having our Utf-8 constants prematurely collected.  */\n-  static vfy_string\n-  make_utf8_const (const char *s, int len)\n-  {\n-    vfy_string val = vfy_make_string (s, len);\n-    vfy_string_list *lu = vfy_alloc (sizeof (vfy_string_list));\n-    lu->val = val;\n-    lu->next = vfr->utf8_list;\n-    vfr->utf8_list = lu;\n-\n-    return val;\n-  }\n-#endif\n-\n static void\n verify_fail_pc (const char *s, int pc)\n {\n@@ -249,7 +217,7 @@ verify_fail_pc (const char *s, int pc)\n static void\n verify_fail (const char *s)\n {\n-  verify_fail_pc (s, -1);\n+  verify_fail_pc (s, vfr->PC);\n }\n \n /* This enum holds a list of tags for all the different types we\n@@ -554,17 +522,6 @@ struct type\n #define EITHER -3\n };\n \n-#if 0\n-/* Basic constructor.  */\n-static void\n-init_type (type *t)\n-{\n-  t->key = unsuitable_type;\n-  t->klass = NULL;\n-  t->pc = UNINIT;\n-}\n-#endif\n-\n /* Make a new instance given the type tag.  We assume a generic\n    `reference_type' means Object.  */\n static void\n@@ -626,26 +583,6 @@ make_type_from_string (vfy_string n)\n   return t;\n }\n \n-#if 0\n-    /* Make a new instance given the name of a class.  */\n-    type (vfy_string n)\n-    {\n-      key = reference_type;\n-      klass = new ref_intersection (n, verifier);\n-      pc = UNINIT;\n-    }\n-\n-    /* Copy constructor.  */\n-    static type copy_type (type *t)\n-    {\n-      type copy;\n-      copy.key = t->key;\n-      copy.klass = t->klass;\n-      copy.pc = t->pc;\n-      return copy;\n-    }\n-#endif\n-\n /* Promote a numeric type.  */\n static void\n vfy_promote_type (type *t)\n@@ -874,16 +811,6 @@ type_initialized (type *t)\n   return t->key == reference_type || t->key == null_type;\n }\n \n-#if 0\n-static bool\n-type_isresolved (type *t)\n-{\n-  return (t->key == reference_type\n-\t  || t->key == null_type\n-\t  || t->key == uninitialized_reference_type);\n-}\n-#endif\n-\n static void\n type_verify_dimensions (type *t, int ndims)\n {\n@@ -1018,16 +945,6 @@ struct state\n    acquired from the verification list.  */\n #define NO_NEXT -1\n \n-#if 0\n-static void\n-init_state (state *s)\n-{\n-  s->stack = NULL;\n-  s->locals = NULL;\n-  s->next = INVALID_STATE;  \n-}\n-#endif\n-\n static void\n init_state_with_stack (state *s, int max_stack, int max_locals)\n {\n@@ -1084,7 +1001,6 @@ make_state (int max_stack, int max_locals)\n   return s;\n }\n \n-#if 0\n static void\n free_state (state *s)\n {\n@@ -1093,29 +1009,6 @@ free_state (state *s)\n   if (s->locals != NULL)\n     vfy_free (s->locals);\n }\n-#endif\n-\n-#if 0\n-    void *operator new[] (size_t bytes)\n-    {\n-      return vfy_alloc (bytes);\n-    }\n-\n-    void operator delete[] (void *mem)\n-    {\n-      vfy_free (mem);\n-    }\n-\n-    void *operator new (size_t bytes)\n-    {\n-      return vfy_alloc (bytes);\n-    }\n-\n-    void operator delete (void *mem)\n-    {\n-      vfy_free (mem);\n-    }\n-#endif\n \n /* Modify this state to reflect entry to an exception handler.  */\n static void\n@@ -1129,20 +1022,6 @@ state_set_exception (state *s, type *t, int max_stack)\n     init_type_from_tag (&s->stack[i], unsuitable_type);\n }\n \n-static int\n-state_get_pc (state *s)\n-{\n-  return s->pc;\n-}\n-\n-#if 0\n-static void\n-set_pc (state *s, int npc)\n-{\n-  s->pc = npc;\n-}\n-#endif\n-\n /* Merge STATE_OLD into this state.  Destructively modifies this\n    state.  Returns true if the new state was in fact changed.\n    Will throw an exception if the states are not mergeable.  */\n@@ -2368,7 +2247,7 @@ verify_instructions_0 (void)\n \t  if (new_state == NULL)\n \t    break;\n \n-\t  vfr->PC = state_get_pc (new_state);\n+\t  vfr->PC = new_state->pc;\n \t  debug_print (\"== State pop from pending list\\n\");\n \t  /* Set up the current state.  */\n \t  copy_state (vfr->current_state, new_state, \n@@ -3259,32 +3138,6 @@ verify_instructions_0 (void)\n \t  handle_jsr_insn (get_int ());\n \t  break;\n \n-#if 0\n-\t/* These are unused here, but we call them out explicitly\n-\t   so that -Wswitch-enum doesn't complain.  */\n-\tcase op_putfield_1:\n-\tcase op_putfield_2:\n-\tcase op_putfield_4:\n-\tcase op_putfield_8:\n-\tcase op_putfield_a:\n-\tcase op_putstatic_1:\n-\tcase op_putstatic_2:\n-\tcase op_putstatic_4:\n-\tcase op_putstatic_8:\n-\tcase op_putstatic_a:\n-\tcase op_getfield_1:\n-\tcase op_getfield_2s:\n-\tcase op_getfield_2u:\n-\tcase op_getfield_4:\n-\tcase op_getfield_8:\n-\tcase op_getfield_a:\n-\tcase op_getstatic_1:\n-\tcase op_getstatic_2s:\n-\tcase op_getstatic_2u:\n-\tcase op_getstatic_4:\n-\tcase op_getstatic_8:\n-\tcase op_getstatic_a:\n-#endif\n \tdefault:\n \t  /* Unrecognized opcode.  */\n \t  verify_fail_pc (\"unrecognized instruction in verify_instructions_0\",\n@@ -3375,17 +3228,6 @@ verify_instructions (void)\n     }\n }\n \n-#if 0\n-_Jv_BytecodeVerifier (_Jv_InterpMethod *m)\n-{\n-  /* We just print the text as utf-8.  This is just for debugging\n-     anyway.  */\n-  debug_print (\"--------------------------------\\n\");\n-  debug_print (\"-- Verifying method `%s'\\n\", m->self->name->chars());\n-\n-}\n-#endif\n-\n static void\n make_verifier_context (vfy_method *m)\n {\n@@ -3436,6 +3278,7 @@ free_verifier_context (void)\n \t  while (iter != NULL)\n \t    {\n \t      state_list *next = iter->next;\n+\t      free_state (iter->val);\n \t      vfy_free (iter->val);\n \t      vfy_free (iter);\n \t      iter = next;"}]}