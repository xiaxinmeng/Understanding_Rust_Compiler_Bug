{"sha": "86dbed7d1bbbee6c0a5304091e089c48a20c0142", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZkYmVkN2QxYmJiZWU2YzBhNTMwNDA5MWUwODljNDhhMjBjMDE0Mg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-08-05T21:51:59Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-08-05T21:51:59Z"}, "message": "re PR fortran/37211 (TRANSFER to characters: Size checking)\n\n2011-08-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/37221\n\t* gfortran.h (gfc_calculate_transfer_sizes):  Add prototype.\n\t* target-memory.h (gfc_target_interpret_expr):  Add boolean\n\targument wether to convert wide characters.\n\t* target-memory.c (gfc_target_expr_size):  Also return length\n\tof characters for non-constant expressions if these can be\n\tdetermined from the cl.\n\t(interpret_array):  Add argument for gfc_target_interpret_expr.\n\t(gfc_interpret_derived):  Likewise.\n\t(gfc_target_interpret_expr):  Likewise.\n\t* check.c:  Include target-memory.h.\n\t(gfc_calculate_transfer_sizes):  New function.\n\t(gfc_check_transfer):  When -Wsurprising is in force, calculate\n\tsizes and warn if result is larger than size (check moved from\n\tgfc_simplify_transfer).\n\t* simplify.c (gfc_simplify_transfer):  Use\n\tgfc_calculate_transfer_sizes.  Remove warning.\n\n2011-08-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/37221\n\t* gfortran.dg/transfer_check_2.f90:  New test case.\n\nFrom-SVN: r177486", "tree": {"sha": "355e022c7c1cbec05a02dc85dd3da5320674d598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/355e022c7c1cbec05a02dc85dd3da5320674d598"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86dbed7d1bbbee6c0a5304091e089c48a20c0142", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86dbed7d1bbbee6c0a5304091e089c48a20c0142", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86dbed7d1bbbee6c0a5304091e089c48a20c0142", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86dbed7d1bbbee6c0a5304091e089c48a20c0142/comments", "author": null, "committer": null, "parents": [{"sha": "7cfea2ef26a3aab320c90d71c35c69a8c78404d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cfea2ef26a3aab320c90d71c35c69a8c78404d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cfea2ef26a3aab320c90d71c35c69a8c78404d7"}], "stats": {"total": 193, "additions": 144, "deletions": 49}, "files": [{"sha": "31696b3f25f9e27714f5db49677b590941877930", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=86dbed7d1bbbee6c0a5304091e089c48a20c0142", "patch": "@@ -1,3 +1,23 @@\n+2011-08-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/37221\n+\t* gfortran.h (gfc_calculate_transfer_sizes):  Add prototype.\n+\t* target-memory.h (gfc_target_interpret_expr):  Add boolean\n+\targument wether to convert wide characters.\n+\t* target-memory.c (gfc_target_expr_size):  Also return length\n+\tof characters for non-constant expressions if these can be\n+\tdetermined from the cl.\n+\t(interpret_array):  Add argument for gfc_target_interpret_expr.\n+\t(gfc_interpret_derived):  Likewise.\n+\t(gfc_target_interpret_expr):  Likewise.\n+\t* check.c:  Include target-memory.h.\n+\t(gfc_calculate_transfer_sizes):  New function.\n+\t(gfc_check_transfer):  When -Wsurprising is in force, calculate\n+\tsizes and warn if result is larger than size (check moved from\n+\tgfc_simplify_transfer).\n+\t* simplify.c (gfc_simplify_transfer):  Use\n+\tgfc_calculate_transfer_sizes.  Remove warning.\n+\n 2011-08-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR fortran/49957"}, {"sha": "3d4f4c883784fe0f91951dabc8ac8e9847322a32", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=86dbed7d1bbbee6c0a5304091e089c48a20c0142", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gfortran.h\"\n #include \"intrinsic.h\"\n #include \"constructor.h\"\n+#include \"target-memory.h\"\n \n \n /* Make sure an expression is a scalar.  */\n@@ -3864,11 +3865,68 @@ gfc_check_this_image (gfc_expr *coarray, gfc_expr *dim)\n   return SUCCESS;\n }\n \n+/* Calculate the sizes for transfer, used by gfc_check_transfer and also\n+   by gfc_simplify_transfer.  Return FAILURE if we cannot do so.  */\n \n gfc_try\n-gfc_check_transfer (gfc_expr *source ATTRIBUTE_UNUSED,\n-\t\t    gfc_expr *mold ATTRIBUTE_UNUSED, gfc_expr *size)\n+gfc_calculate_transfer_sizes (gfc_expr *source, gfc_expr *mold, gfc_expr *size,\n+\t\t\t      size_t *source_size, size_t *result_size,\n+\t\t\t      size_t *result_length_p)\n+\n+{\n+  size_t result_elt_size;\n+  mpz_t tmp;\n+  gfc_expr *mold_element;\n+\n+  if (source->expr_type == EXPR_FUNCTION)\n+    return FAILURE;\n+\n+    /* Calculate the size of the source.  */\n+  if (source->expr_type == EXPR_ARRAY\n+      && gfc_array_size (source, &tmp) == FAILURE)\n+    return FAILURE;\n+\n+  *source_size = gfc_target_expr_size (source);\n+\n+  mold_element = mold->expr_type == EXPR_ARRAY\n+\t\t ? gfc_constructor_first (mold->value.constructor)->expr\n+\t\t : mold;\n+\n+  /* Determine the size of the element.  */\n+  result_elt_size = gfc_target_expr_size (mold_element);\n+  if (result_elt_size == 0)\n+    return FAILURE;\n+\n+  if (mold->expr_type == EXPR_ARRAY || mold->rank || size)\n+    {\n+      int result_length;\n+\n+      if (size)\n+\tresult_length = (size_t)mpz_get_ui (size->value.integer);\n+      else\n+\t{\n+\t  result_length = *source_size / result_elt_size;\n+\t  if (result_length * result_elt_size < *source_size)\n+\t    result_length += 1;\n+\t}\n+\n+      *result_size = result_length * result_elt_size;\n+      if (result_length_p)\n+\t*result_length_p = result_length;\n+    }\n+  else\n+    *result_size = result_elt_size;\n+\n+  return SUCCESS;\n+}\n+\n+\n+gfc_try\n+gfc_check_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n {\n+  size_t source_size;\n+  size_t result_size;\n+\n   if (mold->ts.type == BT_HOLLERITH)\n     {\n       gfc_error (\"'MOLD' argument of 'TRANSFER' intrinsic at %L must not be %s\",\n@@ -3888,6 +3946,21 @@ gfc_check_transfer (gfc_expr *source ATTRIBUTE_UNUSED,\n \treturn FAILURE;\n     }\n \n+  if (!gfc_option.warn_surprising)\n+    return SUCCESS;\n+\n+  /* If we can't calculate the sizes, we cannot check any more.\n+     Return SUCCESS for that case.  */\n+\n+  if (gfc_calculate_transfer_sizes (source, mold, size, &source_size,\n+\t\t\t\t    &result_size, NULL) == FAILURE)\n+    return SUCCESS;\n+\n+  if (source_size < result_size)\n+    gfc_warning(\"Intrinsic TRANSFER at %L has partly undefined result: \"\n+\t\t\"source size %ld < result size %ld\", &source->where,\n+\t\t(long) source_size, (long) result_size);\n+\n   return SUCCESS;\n }\n "}, {"sha": "34afae433868f5075a24292920354c65065c8c90", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=86dbed7d1bbbee6c0a5304091e089c48a20c0142", "patch": "@@ -2896,6 +2896,8 @@ int gfc_dep_compare_expr (gfc_expr *, gfc_expr *);\n \n /* check.c */\n gfc_try gfc_check_same_strlen (const gfc_expr*, const gfc_expr*, const char*);\n+gfc_try gfc_calculate_transfer_sizes (gfc_expr*, gfc_expr*, gfc_expr*,\n+\t\t\t\t      size_t*, size_t*, size_t*);\n \n /* class.c */\n void gfc_add_component_ref (gfc_expr *, const char *);"}, {"sha": "e4ffc3b477fd396ab5b9ba536609721036f706c3", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=86dbed7d1bbbee6c0a5304091e089c48a20c0142", "patch": "@@ -6028,17 +6028,19 @@ gfc_simplify_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n   gfc_expr *mold_element;\n   size_t source_size;\n   size_t result_size;\n-  size_t result_elt_size;\n   size_t buffer_size;\n   mpz_t tmp;\n   unsigned char *buffer;\n+  size_t result_length;\n+\n \n   if (!gfc_is_constant_expr (source)\n \t|| (gfc_init_expr_flag && !gfc_is_constant_expr (mold))\n \t|| !gfc_is_constant_expr (size))\n     return NULL;\n \n-  if (source->expr_type == EXPR_FUNCTION)\n+  if (gfc_calculate_transfer_sizes (source, mold, size, &source_size,\n+\t\t\t\t    &result_size, &result_length) == FAILURE)\n     return NULL;\n \n   /* Calculate the size of the source.  */\n@@ -6064,44 +6066,16 @@ gfc_simplify_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n     result->value.character.length = mold_element->value.character.length;\n   \n   /* Set the number of elements in the result, and determine its size.  */\n-  result_elt_size = gfc_target_expr_size (mold_element);\n-  if (result_elt_size == 0)\n-    {\n-      gfc_free_expr (result);\n-      return NULL;\n-    }\n \n   if (mold->expr_type == EXPR_ARRAY || mold->rank || size)\n     {\n-      int result_length;\n-\n       result->expr_type = EXPR_ARRAY;\n       result->rank = 1;\n-\n-      if (size)\n-\tresult_length = (size_t)mpz_get_ui (size->value.integer);\n-      else\n-\t{\n-\t  result_length = source_size / result_elt_size;\n-\t  if (result_length * result_elt_size < source_size)\n-\t    result_length += 1;\n-\t}\n-\n       result->shape = gfc_get_shape (1);\n       mpz_init_set_ui (result->shape[0], result_length);\n-\n-      result_size = result_length * result_elt_size;\n     }\n   else\n-    {\n-      result->rank = 0;\n-      result_size = result_elt_size;\n-    }\n-\n-  if (gfc_option.warn_surprising && source_size < result_size)\n-    gfc_warning(\"Intrinsic TRANSFER at %L has partly undefined result: \"\n-\t\t\"source size %ld < result size %ld\", &source->where,\n-\t\t(long) source_size, (long) result_size);\n+    result->rank = 0;\n \n   /* Allocate the buffer to store the binary version of the source.  */\n   buffer_size = MAX (source_size, result_size);\n@@ -6112,7 +6086,7 @@ gfc_simplify_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n   gfc_target_encode_expr (source, buffer, buffer_size);\n \n   /* And read the buffer back into the new expression.  */\n-  gfc_target_interpret_expr (buffer, buffer_size, result);\n+  gfc_target_interpret_expr (buffer, buffer_size, result, false);\n \n   return result;\n }"}, {"sha": "025bccf0b0cccc86687a8d06792c4a8ada70307b", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=86dbed7d1bbbee6c0a5304091e089c48a20c0142", "patch": "@@ -103,16 +103,20 @@ gfc_target_expr_size (gfc_expr *e)\n     case BT_LOGICAL:\n       return size_logical (e->ts.kind);\n     case BT_CHARACTER:\n-      if (e->expr_type == EXPR_SUBSTRING && e->ref)\n-        {\n-          int start, end;\n-\n-          gfc_extract_int (e->ref->u.ss.start, &start);\n-          gfc_extract_int (e->ref->u.ss.end, &end);\n-          return size_character (MAX(end - start + 1, 0), e->ts.kind);\n-        }\n+      if (e->expr_type == EXPR_CONSTANT)\n+\treturn size_character (e->value.character.length, e->ts.kind);\n+      else if (e->ts.u.cl != NULL && e->ts.u.cl->length != NULL\n+\t       && e->ts.u.cl->length->expr_type == EXPR_CONSTANT\n+\t       && e->ts.u.cl->length->ts.type == BT_INTEGER)\n+\t{\n+\t  int length;\n+\n+\t  gfc_extract_int (e->ts.u.cl->length, &length);\n+\t  return size_character (length, e->ts.kind);\n+\t}\n       else\n-        return size_character (e->value.character.length, e->ts.kind);\n+\treturn 0;\n+\n     case BT_HOLLERITH:\n       return e->representation.length;\n     case BT_DERIVED:\n@@ -330,7 +334,8 @@ interpret_array (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n \n       gfc_constructor_append_expr (&base, e, &result->where);\n \n-      ptr += gfc_target_interpret_expr (&buffer[ptr], buffer_size - ptr, e);\n+      ptr += gfc_target_interpret_expr (&buffer[ptr], buffer_size - ptr, e,\n+\t\t\t\t\ttrue);\n     }\n \n   result->value.constructor = base;\n@@ -456,7 +461,7 @@ gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *resu\n       e = gfc_get_constant_expr (cmp->ts.type, cmp->ts.kind, &result->where); \n       c = gfc_constructor_append_expr (&result->value.constructor, e, NULL);\n       c->n.component = cmp;\n-      gfc_target_interpret_expr (buffer, buffer_size, e);\n+      gfc_target_interpret_expr (buffer, buffer_size, e, true);\n       e->ts.is_iso_c = 1;\n       return int_size_in_bytes (ptr_type_node);\n     }\n@@ -506,7 +511,7 @@ gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *resu\n       gcc_assert (ptr % 8 == 0);\n       ptr = ptr/8 + TREE_INT_CST_LOW (DECL_FIELD_OFFSET (cmp->backend_decl));\n \n-      gfc_target_interpret_expr (&buffer[ptr], buffer_size - ptr, e);\n+      gfc_target_interpret_expr (&buffer[ptr], buffer_size - ptr, e, true);\n     }\n     \n   return int_size_in_bytes (type);\n@@ -516,7 +521,7 @@ gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *resu\n /* Read a binary buffer to a constant expression.  */\n int\n gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,\n-\t\t\t   gfc_expr *result)\n+\t\t\t   gfc_expr *result, bool convert_widechar)\n {\n   if (result->expr_type == EXPR_ARRAY)\n     return interpret_array (buffer, buffer_size, result);\n@@ -562,7 +567,7 @@ gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,\n       break;\n     }\n \n-  if (result->ts.type == BT_CHARACTER)\n+  if (result->ts.type == BT_CHARACTER && convert_widechar)\n     result->representation.string\n       = gfc_widechar_to_char (result->value.character.string,\n \t\t\t      result->value.character.length);"}, {"sha": "6ebffe86521eece12610b96149044f9bb893d44e", "filename": "gcc/fortran/target-memory.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ffortran%2Ftarget-memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ffortran%2Ftarget-memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.h?ref=86dbed7d1bbbee6c0a5304091e089c48a20c0142", "patch": "@@ -41,7 +41,7 @@ int gfc_interpret_complex (int, unsigned char *, size_t, mpc_t);\n int gfc_interpret_logical (int, unsigned char *, size_t, int *);\n int gfc_interpret_character (unsigned char *, size_t, gfc_expr *);\n int gfc_interpret_derived (unsigned char *, size_t, gfc_expr *);\n-int gfc_target_interpret_expr (unsigned char *, size_t, gfc_expr *);\n+int gfc_target_interpret_expr (unsigned char *, size_t, gfc_expr *, bool);\n \n /* Merge overlapping equivalence initializers for trans-common.c. */\n size_t gfc_merge_initializers (gfc_typespec, gfc_expr *,"}, {"sha": "3b5a17fbf19625e85ba30fee73a18355103edd25", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=86dbed7d1bbbee6c0a5304091e089c48a20c0142", "patch": "@@ -1,3 +1,8 @@\n+2011-08-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/37221\n+\t* gfortran.dg/transfer_check_2.f90:  New test case.\n+\n 2011-08-05  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/49494"}, {"sha": "3f2e1bfb5c95a42f8bc5d51b33fd075a013509a4", "filename": "gcc/testsuite/gfortran.dg/transfer_check_2.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_check_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86dbed7d1bbbee6c0a5304091e089c48a20c0142/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_check_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_check_2.f90?ref=86dbed7d1bbbee6c0a5304091e089c48a20c0142", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+! { dg-options \"-Wsurprising\" }\n+! PR 37221 - also warn about too-long MOLD for TRANSFER if not simplifying.\n+! Test case based on contribution by Tobias Burnus.\n+program main\n+  character(len=10) :: str\n+  integer :: i\n+  str = transfer(65+66*2**8+67*2**16+68*2**24,str) ! { dg-warning \"has partly undefined result\" }\n+  write (*,*) str(1:4)\n+  i = 65+66*2**8+67*2**16+68*2**24\n+  str = transfer(i,str)  ! { dg-warning \"has partly undefined result\" }\n+  write (*,*) str(1:4)\n+  str = transfer(i,str(1:4))\n+  write (*,*) str(1:4)\n+end program\n+"}]}