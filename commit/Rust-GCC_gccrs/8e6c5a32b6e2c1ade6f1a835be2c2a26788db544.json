{"sha": "8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "node_id": "C_kwDOANBUbNoAKDhlNmM1YTMyYjZlMmMxYWRlNmYxYTgzNWJlMmMyYTI2Nzg4ZGI1NDQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-22T11:08:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-22T11:08:44Z"}, "message": "Merge #752\n\n752: Bugfix ICE in trait resolution r=philberty a=philberty\n\nThis is a series of patches which need to go in order to fix the linked bugs.\r\n\r\n- Fix type resolution of associated types in the generic context\r\n- Ensure autoderef is applied on generic receivers\r\n- Support generic substitutions on type-bounds\r\n\r\nFixes #743 #753 #744 #741 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "ccc8b527c45cfecc42e26a052f5fce21d0117e99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccc8b527c45cfecc42e26a052f5fce21d0117e99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhcpu8CRBK7hj4Ov3rIwAA4XwIAHjvsDj86Jk/DDVgP6gky/y+\npvB62uWwC4qBjVxlctvzaUN+Ae/kCeoYvctgN/RwYjSB/YMwlnMhPWZFjwvhOPKO\nnGkjLlIDw9oLxWT5lNki6N0rELXtR0a2v19aP++EltRuUiQ4zWq4wvKXowKLSO4c\niZIhQovRsmAQW42eeDC4mAik8IuwIJj7MSDYPgss5/SNA+6xJR7AfzeLkg/uAgCT\nn4L0NDGfAu3McMUJxB36HESh3azrWexr/J4srULopxM3WIFAURgq12EDhxFrpWV6\nhOeXFiTwGQ2qWyCQ1STFr3wPtwc+QxzqKtDw5IUk+GJ4e05ti4TKJ0DEcFYNjJI=\n=tEk8\n-----END PGP SIGNATURE-----\n", "payload": "tree ccc8b527c45cfecc42e26a052f5fce21d0117e99\nparent df61b8f0ee5c419c4d1b1dcdfc06812646d9f2f9\nparent 92a31969774e1e9b46800c6475d1a58ccc5ca436\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1634900924 +0000\ncommitter GitHub <noreply@github.com> 1634900924 +0000\n\nMerge #752\n\n752: Bugfix ICE in trait resolution r=philberty a=philberty\n\nThis is a series of patches which need to go in order to fix the linked bugs.\r\n\r\n- Fix type resolution of associated types in the generic context\r\n- Ensure autoderef is applied on generic receivers\r\n- Support generic substitutions on type-bounds\r\n\r\nFixes #743 #753 #744 #741 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df61b8f0ee5c419c4d1b1dcdfc06812646d9f2f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df61b8f0ee5c419c4d1b1dcdfc06812646d9f2f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df61b8f0ee5c419c4d1b1dcdfc06812646d9f2f9"}, {"sha": "92a31969774e1e9b46800c6475d1a58ccc5ca436", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a31969774e1e9b46800c6475d1a58ccc5ca436", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92a31969774e1e9b46800c6475d1a58ccc5ca436"}], "stats": {"total": 1034, "additions": 778, "deletions": 256}, "files": [{"sha": "98ae5ab65d9c9179fd6d78a091e4dc56990f28e9", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -115,7 +115,7 @@ class MethodResolution\n \t    if (fn->is_method ())\n \t      {\n \t\tTyTy::BaseType *fn_self = fn->get_self_type ();\n-\t\tif (receiver->can_eq (fn_self, false))\n+\t\tif (receiver->can_eq (fn_self, false, true))\n \t\t  {\n \t\t    return &c;\n \t\t  }\n@@ -143,7 +143,7 @@ class MethodResolution\n \t    if (fn->is_method ())\n \t      {\n \t\tTyTy::BaseType *fn_self = fn->get_self_type ();\n-\t\tif (receiver->can_eq (fn_self, false))\n+\t\tif (receiver->can_eq (fn_self, false, true))\n \t\t  {\n \t\t    return &c;\n \t\t  }\n@@ -165,7 +165,7 @@ class MethodResolution\n \t    if (fn->is_method ())\n \t      {\n \t\tTyTy::BaseType *fn_self = fn->get_self_type ();\n-\t\tif (receiver->can_eq (fn_self, false))\n+\t\tif (receiver->can_eq (fn_self, false, true))\n \t\t  {\n \t\t    return &c;\n \t\t  }"}, {"sha": "eac86b01cdccdfba67fb3674db9717da0e1e91d1", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -122,7 +122,7 @@ class OverlappingImplItemPass : public TypeCheckBase\n \t    if (query == candidate)\n \t      continue;\n \n-\t    if (query->can_eq (candidate, false))\n+\t    if (query->can_eq (candidate, false, false))\n \t      possible_collision (it->second, iy->second);\n \t  }\n       }"}, {"sha": "6e39fa3d35135210409329d5b0b840f51eb80780", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 133, "deletions": 89, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -130,24 +130,26 @@ class PathProbeType : public TypeCheckBase\n     if (!probe_bounds)\n       return probe.candidates;\n \n-    std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> probed_bounds\n-      = TypeBoundsProbe::Probe (receiver);\n+    if (!probe.is_reciever_generic ())\n+      {\n+\tstd::vector<std::pair<TraitReference *, HIR::ImplBlock *>> probed_bounds\n+\t  = TypeBoundsProbe::Probe (receiver);\n+\tfor (auto &candidate : probed_bounds)\n+\t  {\n+\t    const TraitReference *trait_ref = candidate.first;\n+\t    HIR::ImplBlock *impl = candidate.second;\n+\t    probe.process_associated_trait_for_candidates (\n+\t      trait_ref, impl, ignore_mandatory_trait_items);\n+\t  }\n+      }\n \n-    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n-      specified_bounds;\n     for (const TyTy::TypeBoundPredicate &predicate :\n \t receiver->get_specified_bounds ())\n       {\n-\tconst TraitReference *trait_item = predicate.get ();\n-\n-\t// FIXME lookup impl_block for this trait impl for this receiver\n-\tspecified_bounds.push_back ({trait_item, nullptr});\n+\tprobe.process_predicate_for_candidates (predicate,\n+\t\t\t\t\t\tignore_mandatory_trait_items);\n       }\n \n-    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n-      union_type_bounds = probe.union_bounds (probed_bounds, specified_bounds);\n-    probe.process_traits_for_candidates (union_type_bounds,\n-\t\t\t\t\t ignore_mandatory_trait_items);\n     return probe.candidates;\n   }\n \n@@ -227,103 +229,137 @@ class PathProbeType : public TypeCheckBase\n     bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n     rust_assert (ok);\n \n-    if (!receiver->can_eq (impl_block_ty, false))\n+    if (!receiver->can_eq (impl_block_ty, false, false))\n       return;\n \n     // lets visit the impl_item\n     item->accept_vis (*this);\n   }\n \n-  void process_traits_for_candidates (\n-    const std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n-      traits,\n-    bool ignore_mandatory_trait_items)\n+  void\n+  process_associated_trait_for_candidates (const TraitReference *trait_ref,\n+\t\t\t\t\t   HIR::ImplBlock *impl,\n+\t\t\t\t\t   bool ignore_mandatory_trait_items)\n   {\n-    for (auto &ref : traits)\n+    const TraitItemReference *trait_item_ref = nullptr;\n+    if (!trait_ref->lookup_trait_item (search.as_string (), &trait_item_ref))\n+      return;\n+\n+    bool trait_item_needs_implementation = !trait_item_ref->is_optional ();\n+    if (ignore_mandatory_trait_items && trait_item_needs_implementation)\n+      return;\n+\n+    PathProbeCandidate::CandidateType candidate_type;\n+    switch (trait_item_ref->get_trait_item_type ())\n       {\n-\tconst TraitReference *trait_ref = ref.first;\n-\tHIR::ImplBlock *impl = ref.second;\n+      case TraitItemReference::TraitItemType::FN:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+\tbreak;\n+      case TraitItemReference::TraitItemType::CONST:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n+\tbreak;\n+      case TraitItemReference::TraitItemType::TYPE:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n+\tbreak;\n+\n+      case TraitItemReference::TraitItemType::ERROR:\n+      default:\n+\tgcc_unreachable ();\n+\tbreak;\n+      }\n \n-\tconst TraitItemReference *trait_item_ref = nullptr;\n-\tif (!trait_ref->lookup_trait_item (search.as_string (),\n-\t\t\t\t\t   &trait_item_ref))\n-\t  continue;\n+    TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n+    if (impl != nullptr && !is_reciever_generic ())\n \n-\tbool trait_item_needs_implementation = !trait_item_ref->is_optional ();\n-\tif (ignore_mandatory_trait_items && trait_item_needs_implementation)\n-\t  continue;\n+      {\n+\tHirId impl_block_id = impl->get_mappings ().get_hirid ();\n+\tAssociatedImplTrait *lookup_associated = nullptr;\n+\tbool found_impl_trait\n+\t  = context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t\t   &lookup_associated);\n+\t// see testsuite/rust/compile/torture/traits10.rs this can be false\n+\tif (found_impl_trait)\n+\t  lookup_associated->setup_associated_types ();\n+      }\n \n-\tPathProbeCandidate::CandidateType candidate_type;\n-\tswitch (trait_item_ref->get_trait_item_type ())\n+    // we can substitute the Self with the receiver here\n+    if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+      {\n+\tTyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n+\tTyTy::SubstitutionParamMapping *param = nullptr;\n+\tfor (auto &param_mapping : fn->get_substs ())\n \t  {\n-\t  case TraitItemReference::TraitItemType::FN:\n-\t    candidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n-\t    break;\n-\t  case TraitItemReference::TraitItemType::CONST:\n-\t    candidate_type\n-\t      = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n-\t    break;\n-\t  case TraitItemReference::TraitItemType::TYPE:\n-\t    candidate_type\n-\t      = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n-\t    break;\n-\n-\t  case TraitItemReference::TraitItemType::ERROR:\n-\t  default:\n-\t    gcc_unreachable ();\n-\t    break;\n+\t    const HIR::TypeParam &type_param\n+\t      = param_mapping.get_generic_param ();\n+\t    if (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t      {\n+\t\tparam = &param_mapping;\n+\t\tbreak;\n+\t      }\n \t  }\n+\trust_assert (param != nullptr);\n \n-\tTyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n+\tstd::vector<TyTy::SubstitutionArg> mappings;\n+\tmappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n \n-\tif (impl != nullptr)\n-\t  {\n-\t    HirId impl_block_id = impl->get_mappings ().get_hirid ();\n-\t    AssociatedImplTrait *lookup_associated = nullptr;\n-\t    bool found_impl_trait\n-\t      = context->lookup_associated_trait_impl (impl_block_id,\n-\t\t\t\t\t\t       &lookup_associated);\n-\t    // see testsuite/rust/compile/torture/traits10.rs this can be false\n-\t    if (found_impl_trait)\n-\t      lookup_associated->setup_associated_types ();\n-\t  }\n+\tLocation locus; // FIXME\n+\tTyTy::SubstitutionArgumentMappings args (std::move (mappings), locus);\n+\ttrait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n+      }\n \n-\t// we can substitute the Self with the receiver here\n-\tif (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n-\t  {\n-\t    TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n-\t    TyTy::SubstitutionParamMapping *param = nullptr;\n-\t    for (auto &param_mapping : fn->get_substs ())\n-\t      {\n-\t\tconst HIR::TypeParam &type_param\n-\t\t  = param_mapping.get_generic_param ();\n-\t\tif (type_param.get_type_representation ().compare (\"Self\") == 0)\n-\t\t  {\n-\t\t    param = &param_mapping;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t    rust_assert (param != nullptr);\n+    PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n+\t\t\t\t\t\t\t\ttrait_item_ref,\n+\t\t\t\t\t\t\t\timpl};\n+    PathProbeCandidate candidate{candidate_type,\n+\t\t\t\t trait_item_tyty,\n+\t\t\t\t trait_ref->get_locus (),\n+\t\t\t\t {trait_item_candidate}};\n+    candidates.push_back (std::move (candidate));\n+  }\n \n-\t    std::vector<TyTy::SubstitutionArg> mappings;\n-\t    mappings.push_back (\n-\t      TyTy::SubstitutionArg (param, receiver->clone ()));\n+  void\n+  process_predicate_for_candidates (const TyTy::TypeBoundPredicate &predicate,\n+\t\t\t\t    bool ignore_mandatory_trait_items)\n+  {\n+    const TraitReference *trait_ref = predicate.get ();\n \n-\t    Location locus; // FIXME\n-\t    TyTy::SubstitutionArgumentMappings args (std::move (mappings),\n-\t\t\t\t\t\t     locus);\n-\t    trait_item_tyty\n-\t      = SubstMapperInternal::Resolve (trait_item_tyty, args);\n-\t  }\n+    TyTy::TypeBoundPredicateItem item\n+      = predicate.lookup_associated_item (search.as_string ());\n+    if (item.is_error ())\n+      return;\n \n-\tPathProbeCandidate::TraitItemCandidate trait_item_candidate{\n-\t  trait_ref, trait_item_ref, impl};\n-\tPathProbeCandidate candidate{candidate_type,\n-\t\t\t\t     trait_item_tyty,\n-\t\t\t\t     trait_ref->get_locus (),\n-\t\t\t\t     {trait_item_candidate}};\n-\tcandidates.push_back (std::move (candidate));\n+    if (ignore_mandatory_trait_items && item.needs_implementation ())\n+      return;\n+\n+    const TraitItemReference *trait_item_ref = item.get_raw_item ();\n+    PathProbeCandidate::CandidateType candidate_type;\n+    switch (trait_item_ref->get_trait_item_type ())\n+      {\n+      case TraitItemReference::TraitItemType::FN:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+\tbreak;\n+      case TraitItemReference::TraitItemType::CONST:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n+\tbreak;\n+      case TraitItemReference::TraitItemType::TYPE:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n+\tbreak;\n+\n+      case TraitItemReference::TraitItemType::ERROR:\n+      default:\n+\tgcc_unreachable ();\n+\tbreak;\n       }\n+\n+    TyTy::BaseType *trait_item_tyty = item.get_tyty_for_receiver (receiver);\n+    PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n+\t\t\t\t\t\t\t\ttrait_item_ref,\n+\t\t\t\t\t\t\t\tnullptr};\n+    PathProbeCandidate candidate{candidate_type,\n+\t\t\t\t trait_item_tyty,\n+\t\t\t\t trait_item_ref->get_locus (),\n+\t\t\t\t {trait_item_candidate}};\n+    candidates.push_back (std::move (candidate));\n   }\n \n protected:\n@@ -358,6 +394,14 @@ class PathProbeType : public TypeCheckBase\n     return union_set;\n   }\n \n+  bool is_reciever_generic () const\n+  {\n+    const TyTy::BaseType *root = receiver->get_root ();\n+    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n+    bool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n+    return receiver_is_type_param || receiver_is_dyn;\n+  }\n+\n   const TyTy::BaseType *receiver;\n   const HIR::PathIdentSegment &search;\n   std::vector<PathProbeCandidate> candidates;"}, {"sha": "8c415ebd4460db33af0299dc3633f0679e5f33ff", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -320,7 +320,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t    // always be at the end of the list\n \n \t    auto s = fn->get_self_type ()->get_root ();\n-\t    rust_assert (s->can_eq (adt, false));\n+\t    rust_assert (s->can_eq (adt, false, false));\n \t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n \t    const TyTy::ADTType *self_adt\n \t      = static_cast<const TyTy::ADTType *> (s);"}, {"sha": "f3a08707dfd916e600ff1d36c5a23f3e181f4c02", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -377,7 +377,7 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n       return;\n \n     // check the types are compatible\n-    if (!resolved_trait_item.get_tyty ()->can_eq (lookup, true))\n+    if (!resolved_trait_item.get_tyty ()->can_eq (lookup, true, false))\n       {\n \tRichLocation r (constant.get_locus ());\n \tr.add_range (resolved_trait_item.get_locus ());\n@@ -413,7 +413,7 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n       return;\n \n     // check the types are compatible\n-    if (!resolved_trait_item.get_tyty ()->can_eq (lookup, true))\n+    if (!resolved_trait_item.get_tyty ()->can_eq (lookup, true, false))\n       {\n \tRichLocation r (type.get_locus ());\n \tr.add_range (resolved_trait_item.get_locus ());\n@@ -487,7 +487,7 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n       = trait_item_fntype->handle_substitions (implicit_self_substs);\n \n     // check the types are compatible\n-    if (!trait_item_fntype->can_eq (fntype, true))\n+    if (!trait_item_fntype->can_eq (fntype, true, false))\n       {\n \tRichLocation r (function.get_locus ());\n \tr.add_range (resolved_trait_item.get_locus ());"}, {"sha": "c74ac85ae7e20d8c7d4dd1617f23295988a5a23d", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -376,9 +376,12 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t      AssociatedImplTrait *lookup_associated = nullptr;\n \t      bool found_impl_trait = context->lookup_associated_trait_impl (\n \t\timpl->get_mappings ().get_hirid (), &lookup_associated);\n-\t      rust_assert (found_impl_trait);\n \n-\t      lookup_associated->setup_associated_types ();\n+\t      // setup associated mappings if possible we might be resolving a\n+\t      // path within a default implementation of a trait function\n+\t      // see: testsuite/rust/compile/torture/traits16.rs\n+\t      if (found_impl_trait)\n+\t\tlookup_associated->setup_associated_types ();\n \n \t      // we need a new ty_ref_id for this trait item\n \t      tyseg = tyseg->clone ();"}, {"sha": "ed21d5391bb074d13f15cfa89b0b95808ce94b02", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -445,7 +445,7 @@ TypeCheckType::resolve_segments (\n \n \t  // lookup the associated-impl-trait\n \t  HIR::ImplBlock *impl = candidate.item.trait.impl;\n-\t  if (impl != nullptr)\n+\t  if (impl != nullptr && !reciever_is_generic)\n \t    {\n \t      AssociatedImplTrait *lookup_associated = nullptr;\n \t      bool found_impl_trait = context->lookup_associated_trait_impl ("}, {"sha": "91c49e0eb4c52aa8be23e23c54525176cdc89a05", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -234,10 +234,28 @@ class TypeResolveGenericParam : public TypeCheckBase\n \t\t  HIR::TraitBound *b\n \t\t    = static_cast<HIR::TraitBound *> (bound.get ());\n \n-\t\t  TraitReference *trait = resolve_trait_path (b->get_path ());\n+\t\t  auto &type_path = b->get_path ();\n+\t\t  TraitReference *trait = resolve_trait_path (type_path);\n \t\t  TyTy::TypeBoundPredicate predicate (\n \t\t    trait->get_mappings ().get_defid (), b->get_locus ());\n \n+\t\t  auto &final_seg = type_path.get_final_segment ();\n+\t\t  if (final_seg->is_generic_segment ())\n+\t\t    {\n+\t\t      auto final_generic_seg\n+\t\t\t= static_cast<HIR::TypePathSegmentGeneric *> (\n+\t\t\t  final_seg.get ());\n+\t\t      if (final_generic_seg->has_generic_args ())\n+\t\t\t{\n+\t\t\t  HIR::GenericArgs &generic_args\n+\t\t\t    = final_generic_seg->get_generic_args ();\n+\n+\t\t\t  // this is applying generic arguments to a trait\n+\t\t\t  // reference\n+\t\t\t  predicate.apply_generic_arguments (&generic_args);\n+\t\t\t}\n+\t\t    }\n+\n \t\t  specified_bounds.push_back (std::move (predicate));\n \t\t}\n \t\tbreak;"}, {"sha": "5760c4e9c5d5dc30878d1d311f00f2564b0e89c2", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -187,7 +187,7 @@ class TypeCheckContext\n \n     for (auto &item : it->second)\n       {\n-\tif (item.first->can_eq (self, false))\n+\tif (item.first->can_eq (self, false, false))\n \t  {\n \t    *mapping = item.second;\n \t    return true;"}, {"sha": "88c94d25111d328cc019d45f99ce3b1086548460", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 80, "deletions": 1, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -40,7 +40,7 @@ TypeBoundsProbe::scan ()\n       if (!ok)\n \treturn true;\n \n-      if (!receiver->can_eq (impl_type, false))\n+      if (!receiver->can_eq (impl_type, false, false))\n \treturn true;\n \n       possible_trait_paths.push_back ({impl->get_trait_ref ().get (), impl});\n@@ -108,5 +108,84 @@ TypeBoundPredicate::is_object_safe (bool emit_error, Location locus) const\n   return trait->is_object_safe (emit_error, locus);\n }\n \n+void\n+TypeBoundPredicate::apply_generic_arguments (HIR::GenericArgs *generic_args)\n+{\n+  args = generic_args;\n+  // TODO verify these arguments are valid and not too many were added\n+}\n+\n+bool\n+TypeBoundPredicate::contains_item (const std::string &search) const\n+{\n+  auto trait_ref = get ();\n+  const Resolver::TraitItemReference *trait_item_ref = nullptr;\n+  return trait_ref->lookup_trait_item (search, &trait_item_ref);\n+}\n+\n+TypeBoundPredicateItem\n+TypeBoundPredicate::lookup_associated_item (const std::string &search) const\n+{\n+  auto trait_ref = get ();\n+  const Resolver::TraitItemReference *trait_item_ref = nullptr;\n+  if (!trait_ref->lookup_trait_item (search, &trait_item_ref))\n+    return TypeBoundPredicateItem::error ();\n+\n+  return TypeBoundPredicateItem (this, trait_item_ref);\n+}\n+\n+BaseType *\n+TypeBoundPredicateItem::get_tyty_for_receiver (const TyTy::BaseType *receiver)\n+{\n+  TyTy::BaseType *trait_item_tyty = get_raw_item ()->get_tyty ();\n+  if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n+      TyTy::SubstitutionParamMapping *param = nullptr;\n+      for (auto &param_mapping : fn->get_substs ())\n+\t{\n+\t  const HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n+\t  if (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t    {\n+\t      param = &param_mapping;\n+\t      break;\n+\t    }\n+\t}\n+      rust_assert (param != nullptr);\n+\n+      std::vector<TyTy::SubstitutionArg> mappings;\n+      mappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n+\n+      Location locus; // FIXME\n+      TyTy::SubstitutionArgumentMappings args (std::move (mappings), locus);\n+      trait_item_tyty\n+\t= Resolver::SubstMapperInternal::Resolve (trait_item_tyty, args);\n+    }\n+\n+  if (!parent->has_generic_args ())\n+    return trait_item_tyty;\n+\n+  // FIXME LEAK this should really be const\n+  const HIR::GenericArgs *args = parent->get_generic_args ();\n+  HIR::GenericArgs *generic_args = new HIR::GenericArgs (*args);\n+  TyTy::BaseType *resolved\n+    = Resolver::SubstMapper::Resolve (trait_item_tyty, parent->get_locus (),\n+\t\t\t\t      generic_args);\n+\n+  return resolved;\n+}\n+\n+const Resolver::TraitItemReference *\n+TypeBoundPredicateItem::get_raw_item () const\n+{\n+  return trait_item_ref;\n+}\n+\n+bool\n+TypeBoundPredicateItem::needs_implementation () const\n+{\n+  return !get_raw_item ()->is_optional ();\n+}\n+\n } // namespace TyTy\n } // namespace Rust"}, {"sha": "9ebd5647cc11723035812f252df551d4dca9a601", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 149, "deletions": 78, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -371,8 +371,18 @@ class BaseCmp : public TyConstVisitor\n \n   virtual void visit (const ParamType &type) override\n   {\n-    // it is ok for types to can eq to a ParamType\n-    ok = true;\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n   }\n \n   virtual void visit (const DynamicObjectType &type) override\n@@ -408,17 +418,18 @@ class BaseCmp : public TyConstVisitor\n   }\n \n protected:\n-  BaseCmp (const BaseType *base, bool emit_errors)\n+  BaseCmp (const BaseType *base, bool emit_errors, bool autoderef_mode)\n     : mappings (Analysis::Mappings::get ()),\n       context (Resolver::TypeCheckContext::get ()), ok (false),\n-      emit_error_flag (emit_errors)\n+      emit_error_flag (emit_errors), autoderef_mode_flag (autoderef_mode)\n   {}\n \n   Analysis::Mappings *mappings;\n   Resolver::TypeCheckContext *context;\n \n   bool ok;\n   bool emit_error_flag;\n+  bool autoderef_mode_flag;\n \n private:\n   /* Returns a pointer to the ty that created this rule. */\n@@ -430,8 +441,8 @@ class InferCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  InferCmp (const InferType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  InferCmp (const InferType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const BoolType &type) override\n@@ -641,18 +652,7 @@ class InferCmp : public BaseCmp\n     BaseCmp::visit (type);\n   }\n \n-  void visit (const ParamType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tok = true;\n-\treturn;\n-      }\n-\n-    BaseCmp::visit (type);\n-  }\n+  void visit (const ParamType &) override { ok = true; }\n \n   void visit (const DynamicObjectType &type) override\n   {\n@@ -690,8 +690,8 @@ class FnCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  FnCmp (const FnType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  FnCmp (const FnType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -712,7 +712,7 @@ class FnCmp : public BaseCmp\n \tauto a = base->param_at (i).second;\n \tauto b = type.param_at (i).second;\n \n-\tif (!a->can_eq (b, emit_error_flag))\n+\tif (!a->can_eq (b, emit_error_flag, autoderef_mode_flag))\n \t  {\n \t    emit_error_flag = false;\n \t    BaseCmp::visit (type);\n@@ -721,7 +721,8 @@ class FnCmp : public BaseCmp\n       }\n \n     if (!base->get_return_type ()->can_eq (type.get_return_type (),\n-\t\t\t\t\t   emit_error_flag))\n+\t\t\t\t\t   emit_error_flag,\n+\t\t\t\t\t   autoderef_mode_flag))\n       {\n \temit_error_flag = false;\n \tBaseCmp::visit (type);\n@@ -741,8 +742,8 @@ class FnptrCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  FnptrCmp (const FnPtr *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  FnptrCmp (const FnPtr *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -766,7 +767,8 @@ class FnptrCmp : public BaseCmp\n \n     auto this_ret_type = base->get_return_type ();\n     auto other_ret_type = type.get_return_type ();\n-    if (!this_ret_type->can_eq (other_ret_type, emit_error_flag))\n+    if (!this_ret_type->can_eq (other_ret_type, emit_error_flag,\n+\t\t\t\tautoderef_mode_flag))\n       {\n \tBaseCmp::visit (type);\n \treturn;\n@@ -776,7 +778,8 @@ class FnptrCmp : public BaseCmp\n       {\n \tauto this_param = base->param_at (i);\n \tauto other_param = type.param_at (i);\n-\tif (!this_param->can_eq (other_param, emit_error_flag))\n+\tif (!this_param->can_eq (other_param, emit_error_flag,\n+\t\t\t\t autoderef_mode_flag))\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n@@ -796,7 +799,8 @@ class FnptrCmp : public BaseCmp\n \n     auto this_ret_type = base->get_return_type ();\n     auto other_ret_type = type.get_return_type ();\n-    if (!this_ret_type->can_eq (other_ret_type, emit_error_flag))\n+    if (!this_ret_type->can_eq (other_ret_type, emit_error_flag,\n+\t\t\t\tautoderef_mode_flag))\n       {\n \tBaseCmp::visit (type);\n \treturn;\n@@ -806,7 +810,8 @@ class FnptrCmp : public BaseCmp\n       {\n \tauto this_param = base->param_at (i);\n \tauto other_param = type.param_at (i).second;\n-\tif (!this_param->can_eq (other_param, emit_error_flag))\n+\tif (!this_param->can_eq (other_param, emit_error_flag,\n+\t\t\t\t autoderef_mode_flag))\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n@@ -826,8 +831,8 @@ class ClosureCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ClosureCmp (const ClosureType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  ClosureCmp (const ClosureType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n private:\n@@ -840,8 +845,8 @@ class ArrayCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ArrayCmp (const ArrayType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  ArrayCmp (const ArrayType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const ArrayType &type) override\n@@ -856,7 +861,8 @@ class ArrayCmp : public BaseCmp\n     // check base type\n     const BaseType *base_element = base->get_element_type ();\n     const BaseType *other_element = type.get_element_type ();\n-    if (!base_element->can_eq (other_element, emit_error_flag))\n+    if (!base_element->can_eq (other_element, emit_error_flag,\n+\t\t\t       autoderef_mode_flag))\n       {\n \tBaseCmp::visit (type);\n \treturn;\n@@ -865,6 +871,8 @@ class ArrayCmp : public BaseCmp\n     ok = true;\n   }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const ArrayType *base;\n@@ -875,8 +883,8 @@ class BoolCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  BoolCmp (const BoolType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  BoolCmp (const BoolType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const BoolType &type) override { ok = true; }\n@@ -886,6 +894,8 @@ class BoolCmp : public BaseCmp\n     ok = type.get_infer_kind () == InferType::InferTypeKind::GENERAL;\n   }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const BoolType *base;\n@@ -896,8 +906,8 @@ class IntCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  IntCmp (const IntType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  IntCmp (const IntType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -910,6 +920,8 @@ class IntCmp : public BaseCmp\n     ok = type.get_int_kind () == base->get_int_kind ();\n   }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const IntType *base;\n@@ -920,8 +932,8 @@ class UintCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  UintCmp (const UintType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  UintCmp (const UintType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -934,6 +946,8 @@ class UintCmp : public BaseCmp\n     ok = type.get_uint_kind () == base->get_uint_kind ();\n   }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const UintType *base;\n@@ -944,8 +958,8 @@ class FloatCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  FloatCmp (const FloatType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  FloatCmp (const FloatType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -958,6 +972,8 @@ class FloatCmp : public BaseCmp\n     ok = type.get_float_kind () == base->get_float_kind ();\n   }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const FloatType *base;\n@@ -968,8 +984,8 @@ class ADTCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ADTCmp (const ADTType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  ADTCmp (const ADTType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const ADTType &type) override\n@@ -994,7 +1010,8 @@ class ADTCmp : public BaseCmp\n \tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n \tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n \n-\tif (!this_field_ty->can_eq (other_field_ty, emit_error_flag))\n+\tif (!this_field_ty->can_eq (other_field_ty, emit_error_flag,\n+\t\t\t\t    autoderef_mode_flag))\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n@@ -1004,6 +1021,8 @@ class ADTCmp : public BaseCmp\n     ok = true;\n   }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const ADTType *base;\n@@ -1014,8 +1033,8 @@ class TupleCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  TupleCmp (const TupleType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  TupleCmp (const TupleType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const TupleType &type) override\n@@ -1031,7 +1050,7 @@ class TupleCmp : public BaseCmp\n \tBaseType *bo = base->get_field (i);\n \tBaseType *fo = type.get_field (i);\n \n-\tif (!bo->can_eq (fo, emit_error_flag))\n+\tif (!bo->can_eq (fo, emit_error_flag, autoderef_mode_flag))\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n@@ -1041,6 +1060,8 @@ class TupleCmp : public BaseCmp\n     ok = true;\n   }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const TupleType *base;\n@@ -1051,8 +1072,8 @@ class USizeCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  USizeCmp (const USizeType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  USizeCmp (const USizeType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -1062,6 +1083,8 @@ class USizeCmp : public BaseCmp\n \n   void visit (const USizeType &type) override { ok = true; }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const USizeType *base;\n@@ -1072,8 +1095,8 @@ class ISizeCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ISizeCmp (const ISizeType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  ISizeCmp (const ISizeType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -1083,6 +1106,8 @@ class ISizeCmp : public BaseCmp\n \n   void visit (const ISizeType &type) override { ok = true; }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const ISizeType *base;\n@@ -1093,8 +1118,8 @@ class CharCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  CharCmp (const CharType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  CharCmp (const CharType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -1104,6 +1129,8 @@ class CharCmp : public BaseCmp\n \n   void visit (const CharType &type) override { ok = true; }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const CharType *base;\n@@ -1114,16 +1141,18 @@ class ReferenceCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ReferenceCmp (const ReferenceType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  ReferenceCmp (const ReferenceType *base, bool emit_errors,\n+\t\tbool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const ReferenceType &type) override\n   {\n     auto base_type = base->get_base ();\n     auto other_base_type = type.get_base ();\n \n-    ok = base_type->can_eq (other_base_type, emit_error_flag)\n+    ok = base_type->can_eq (other_base_type, emit_error_flag,\n+\t\t\t    autoderef_mode_flag)\n \t && (base->is_mutable () == type.is_mutable ());\n   }\n \n@@ -1137,16 +1166,17 @@ class PointerCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  PointerCmp (const PointerType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  PointerCmp (const PointerType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const ReferenceType &type) override\n   {\n     auto base_type = base->get_base ();\n     auto other_base_type = type.get_base ();\n \n-    ok = base_type->can_eq (other_base_type, emit_error_flag)\n+    ok = base_type->can_eq (other_base_type, emit_error_flag,\n+\t\t\t    autoderef_mode_flag)\n \t && (base->is_mutable () == type.is_mutable ());\n   }\n \n@@ -1160,8 +1190,8 @@ class ParamCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ParamCmp (const ParamType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  ParamCmp (const ParamType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   // param types are a placeholder we shouldn't have cases where we unify\n@@ -1183,13 +1213,7 @@ class ParamCmp : public BaseCmp\n     bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n     rust_assert (ok);\n \n-    if (lookup->get_kind () == TypeKind::PARAM)\n-      {\n-\tInferType infer (UNKNOWN_HIRID, InferType::InferTypeKind::GENERAL);\n-\treturn infer.can_eq (other, emit_error_flag);\n-      }\n-\n-    return lookup->can_eq (other, emit_error_flag);\n+    return lookup->can_eq (other, emit_error_flag, autoderef_mode_flag);\n   }\n \n   // imagine the case where we have:\n@@ -1198,7 +1222,46 @@ class ParamCmp : public BaseCmp\n   // impl <X>Foo<X> { ... }\n   // both of these types are compatible so we mostly care about the number of\n   // generic arguments\n-  void visit (const ParamType &type) override { ok = true; }\n+  void visit (const ParamType &) override { ok = true; }\n+\n+  void visit (const TupleType &) override { ok = true; }\n+\n+  void visit (const ADTType &) override { ok = true; }\n+\n+  void visit (const InferType &) override { ok = true; }\n+\n+  void visit (const FnType &) override { ok = true; }\n+\n+  void visit (const FnPtr &) override { ok = true; }\n+\n+  void visit (const ArrayType &) override { ok = true; }\n+\n+  void visit (const BoolType &) override { ok = true; }\n+\n+  void visit (const IntType &) override { ok = true; }\n+\n+  void visit (const UintType &) override { ok = true; }\n+\n+  void visit (const USizeType &) override { ok = true; }\n+\n+  void visit (const ISizeType &) override { ok = true; }\n+\n+  void visit (const FloatType &) override { ok = true; }\n+\n+  void visit (const CharType &) override { ok = true; }\n+\n+  void visit (const ReferenceType &) override { ok = !autoderef_mode_flag; }\n+\n+  void visit (const PointerType &) override { ok = !autoderef_mode_flag; }\n+\n+  void visit (const StrType &) override { ok = true; }\n+\n+  void visit (const NeverType &) override { ok = true; }\n+\n+  void visit (const PlaceholderType &type) override\n+  {\n+    ok = base->get_symbol ().compare (type.get_symbol ()) == 0;\n+  }\n \n private:\n   const BaseType *get_base () const override { return base; }\n@@ -1211,12 +1274,14 @@ class StrCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  StrCmp (const StrType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  StrCmp (const StrType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const StrType &type) override { ok = true; }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const StrType *base;\n@@ -1227,12 +1292,14 @@ class NeverCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  NeverCmp (const NeverType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  NeverCmp (const NeverType *base, bool emit_errors, bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const NeverType &type) override { ok = true; }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const NeverType *base;\n@@ -1243,8 +1310,9 @@ class PlaceholderCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  PlaceholderCmp (const PlaceholderType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  PlaceholderCmp (const PlaceholderType *base, bool emit_errors,\n+\t\t  bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   bool can_eq (const BaseType *other) override\n@@ -1253,7 +1321,7 @@ class PlaceholderCmp : public BaseCmp\n       return BaseCmp::can_eq (other);\n \n     BaseType *lookup = base->resolve ();\n-    return lookup->can_eq (other, emit_error_flag);\n+    return lookup->can_eq (other, emit_error_flag, autoderef_mode_flag);\n   }\n \n   void visit (const TupleType &) override { ok = true; }\n@@ -1308,8 +1376,9 @@ class DynamicCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  DynamicCmp (const DynamicObjectType *base, bool emit_errors)\n-    : BaseCmp (base, emit_errors), base (base)\n+  DynamicCmp (const DynamicObjectType *base, bool emit_errors,\n+\t      bool autoderef_mode)\n+    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n   {}\n \n   void visit (const DynamicObjectType &type) override\n@@ -1324,6 +1393,8 @@ class DynamicCmp : public BaseCmp\n     ok = base->bounds_compatible (type, ref_locus, false);\n   }\n \n+  void visit (const ParamType &type) override { ok = true; }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n "}, {"sha": "37f93b40cf4ed81172fbe90c7c9f73cbc4e6f7d1", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 117, "deletions": 48, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -201,9 +201,10 @@ InferType::unify (BaseType *other)\n }\n \n bool\n-InferType::can_eq (const BaseType *other, bool emit_errors) const\n+InferType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t   bool autoderef_mode) const\n {\n-  InferCmp r (this, emit_errors);\n+  InferCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -278,7 +279,8 @@ ErrorType::unify (BaseType *other)\n }\n \n bool\n-ErrorType::can_eq (const BaseType *other, bool emit_errors) const\n+ErrorType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t   bool autoderef_mode) const\n {\n   return get_kind () == other->get_kind ();\n }\n@@ -331,17 +333,19 @@ StructFieldType::clone () const\n \t\t\t      get_field_type ()->clone ());\n }\n \n-void\n+bool\n SubstitutionParamMapping::fill_param_ty (BaseType &type, Location locus)\n {\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n   if (type.get_kind () == TyTy::TypeKind::INFER)\n     {\n       type.inherit_bounds (*param);\n     }\n   else\n     {\n       if (!param->bounds_compatible (type, locus, true))\n-\treturn;\n+\treturn false;\n     }\n \n   if (type.get_kind () == TypeKind::PARAM)\n@@ -351,8 +355,52 @@ SubstitutionParamMapping::fill_param_ty (BaseType &type, Location locus)\n     }\n   else\n     {\n+      // check the substitution is compatible with bounds\n+      if (!param->bounds_compatible (type, locus, true))\n+\treturn false;\n+\n+      // setup any associated type mappings for the specified bonds and this\n+      // type\n+      auto candidates = Resolver::TypeBoundsProbe::Probe (&type);\n+      for (auto &specified_bound : param->get_specified_bounds ())\n+\t{\n+\t  const Resolver::TraitReference *specified_bound_ref\n+\t    = specified_bound.get ();\n+\n+\t  // since the bounds_compatible check has occurred we should be able to\n+\t  // assert on finding the trait references\n+\t  HirId associated_impl_block_id = UNKNOWN_HIRID;\n+\t  bool found = false;\n+\t  for (auto &bound : candidates)\n+\t    {\n+\t      const Resolver::TraitReference *bound_trait_ref = bound.first;\n+\t      const HIR::ImplBlock *associated_impl = bound.second;\n+\n+\t      found = specified_bound_ref->is_equal (*bound_trait_ref);\n+\t      if (found)\n+\t\t{\n+\t\t  rust_assert (associated_impl != nullptr);\n+\t\t  associated_impl_block_id\n+\t\t    = associated_impl->get_mappings ().get_hirid ();\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (found && associated_impl_block_id != UNKNOWN_HIRID)\n+\t    {\n+\t      Resolver::AssociatedImplTrait *lookup_associated = nullptr;\n+\t      bool found_impl_trait = context->lookup_associated_trait_impl (\n+\t\tassociated_impl_block_id, &lookup_associated);\n+\n+\t      if (found_impl_trait)\n+\t\tlookup_associated->setup_associated_types ();\n+\t    }\n+\t}\n+\n       param->set_ty_ref (type.get_ref ());\n     }\n+\n+  return true;\n }\n \n void\n@@ -595,9 +643,10 @@ ADTType::cast (BaseType *other)\n }\n \n bool\n-ADTType::can_eq (const BaseType *other, bool emit_errors) const\n+ADTType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t bool autoderef_mode) const\n {\n-  ADTCmp r (this, emit_errors);\n+  ADTCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -776,9 +825,10 @@ TupleType::cast (BaseType *other)\n }\n \n bool\n-TupleType::can_eq (const BaseType *other, bool emit_errors) const\n+TupleType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t   bool autoderef_mode) const\n {\n-  TupleCmp r (this, emit_errors);\n+  TupleCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -880,9 +930,10 @@ FnType::cast (BaseType *other)\n }\n \n bool\n-FnType::can_eq (const BaseType *other, bool emit_errors) const\n+FnType::can_eq (const BaseType *other, bool emit_errors,\n+\t\tbool autoderef_mode) const\n {\n-  FnCmp r (this, emit_errors);\n+  FnCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1097,9 +1148,10 @@ FnPtr::cast (BaseType *other)\n }\n \n bool\n-FnPtr::can_eq (const BaseType *other, bool emit_errors) const\n+FnPtr::can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const\n {\n-  FnptrCmp r (this, emit_errors);\n+  FnptrCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1163,9 +1215,10 @@ ClosureType::unify (BaseType *other)\n }\n \n bool\n-ClosureType::can_eq (const BaseType *other, bool emit_errors) const\n+ClosureType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t     bool autoderef_mode) const\n {\n-  ClosureCmp r (this, emit_errors);\n+  ClosureCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1251,9 +1304,10 @@ ArrayType::cast (BaseType *other)\n }\n \n bool\n-ArrayType::can_eq (const BaseType *other, bool emit_errors) const\n+ArrayType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t   bool autoderef_mode) const\n {\n-  ArrayCmp r (this, emit_errors);\n+  ArrayCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1326,9 +1380,10 @@ BoolType::cast (BaseType *other)\n }\n \n bool\n-BoolType::can_eq (const BaseType *other, bool emit_errors) const\n+BoolType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t  bool autoderef_mode) const\n {\n-  BoolCmp r (this, emit_errors);\n+  BoolCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1392,9 +1447,10 @@ IntType::cast (BaseType *other)\n }\n \n bool\n-IntType::can_eq (const BaseType *other, bool emit_errors) const\n+IntType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t bool autoderef_mode) const\n {\n-  IntCmp r (this, emit_errors);\n+  IntCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1469,9 +1525,10 @@ UintType::cast (BaseType *other)\n }\n \n bool\n-UintType::can_eq (const BaseType *other, bool emit_errors) const\n+UintType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t  bool autoderef_mode) const\n {\n-  UintCmp r (this, emit_errors);\n+  UintCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1540,9 +1597,10 @@ FloatType::cast (BaseType *other)\n }\n \n bool\n-FloatType::can_eq (const BaseType *other, bool emit_errors) const\n+FloatType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t   bool autoderef_mode) const\n {\n-  FloatCmp r (this, emit_errors);\n+  FloatCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1603,9 +1661,10 @@ USizeType::cast (BaseType *other)\n }\n \n bool\n-USizeType::can_eq (const BaseType *other, bool emit_errors) const\n+USizeType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t   bool autoderef_mode) const\n {\n-  USizeCmp r (this, emit_errors);\n+  USizeCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1655,9 +1714,10 @@ ISizeType::cast (BaseType *other)\n }\n \n bool\n-ISizeType::can_eq (const BaseType *other, bool emit_errors) const\n+ISizeType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t   bool autoderef_mode) const\n {\n-  ISizeCmp r (this, emit_errors);\n+  ISizeCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1707,9 +1767,10 @@ CharType::cast (BaseType *other)\n }\n \n bool\n-CharType::can_eq (const BaseType *other, bool emit_errors) const\n+CharType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t  bool autoderef_mode) const\n {\n-  CharCmp r (this, emit_errors);\n+  CharCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1760,9 +1821,10 @@ ReferenceType::cast (BaseType *other)\n }\n \n bool\n-ReferenceType::can_eq (const BaseType *other, bool emit_errors) const\n+ReferenceType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t       bool autoderef_mode) const\n {\n-  ReferenceCmp r (this, emit_errors);\n+  ReferenceCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1846,9 +1908,10 @@ PointerType::cast (BaseType *other)\n }\n \n bool\n-PointerType::can_eq (const BaseType *other, bool emit_errors) const\n+PointerType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t     bool autoderef_mode) const\n {\n-  PointerCmp r (this, emit_errors);\n+  PointerCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1941,9 +2004,10 @@ ParamType::cast (BaseType *other)\n }\n \n bool\n-ParamType::can_eq (const BaseType *other, bool emit_errors) const\n+ParamType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t   bool autoderef_mode) const\n {\n-  ParamCmp r (this, emit_errors);\n+  ParamCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -1998,7 +2062,7 @@ ParamType::is_equal (const BaseType &other) const\n     return false;\n \n   if (can_resolve ())\n-    return resolve ()->can_eq (other2.resolve (), false);\n+    return resolve ()->can_eq (other2.resolve (), false, false);\n \n   return get_symbol ().compare (other2.get_symbol ()) == 0;\n }\n@@ -2062,9 +2126,10 @@ StrType::cast (BaseType *other)\n }\n \n bool\n-StrType::can_eq (const BaseType *other, bool emit_errors) const\n+StrType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t bool autoderef_mode) const\n {\n-  StrCmp r (this, emit_errors);\n+  StrCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -2114,9 +2179,10 @@ NeverType::cast (BaseType *other)\n }\n \n bool\n-NeverType::can_eq (const BaseType *other, bool emit_errors) const\n+NeverType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t   bool autoderef_mode) const\n {\n-  NeverCmp r (this, emit_errors);\n+  NeverCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -2169,9 +2235,10 @@ PlaceholderType::cast (BaseType *other)\n }\n \n bool\n-PlaceholderType::can_eq (const BaseType *other, bool emit_errors) const\n+PlaceholderType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t\t bool autoderef_mode) const\n {\n-  PlaceholderCmp r (this, emit_errors);\n+  PlaceholderCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n \n@@ -2269,9 +2336,10 @@ ProjectionType::cast (BaseType *other)\n }\n \n bool\n-ProjectionType::can_eq (const BaseType *other, bool emit_errors) const\n+ProjectionType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t\tbool autoderef_mode) const\n {\n-  return base->can_eq (other, emit_errors);\n+  return base->can_eq (other, emit_errors, autoderef_mode);\n }\n \n BaseType *\n@@ -2375,9 +2443,10 @@ DynamicObjectType::unify (BaseType *other)\n }\n \n bool\n-DynamicObjectType::can_eq (const BaseType *other, bool emit_errors) const\n+DynamicObjectType::can_eq (const BaseType *other, bool emit_errors,\n+\t\t\t   bool autoderef_mode) const\n {\n-  DynamicCmp r (this, emit_errors);\n+  DynamicCmp r (this, emit_errors, autoderef_mode);\n   return r.can_eq (other);\n }\n "}, {"sha": "20bad107e1ddc0845dbfc8f59e480af15325e7ff", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 104, "deletions": 27, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -146,11 +146,42 @@ class TypeKindFormat\n   }\n };\n \n+class BaseType;\n+class TypeBoundPredicate;\n+class TypeBoundPredicateItem\n+{\n+public:\n+  TypeBoundPredicateItem (const TypeBoundPredicate *parent,\n+\t\t\t  const Resolver::TraitItemReference *trait_item_ref)\n+    : parent (parent), trait_item_ref (trait_item_ref)\n+  {}\n+\n+  static TypeBoundPredicateItem error ()\n+  {\n+    return TypeBoundPredicateItem (nullptr, nullptr);\n+  }\n+\n+  bool is_error () const\n+  {\n+    return parent == nullptr || trait_item_ref == nullptr;\n+  }\n+\n+  BaseType *get_tyty_for_receiver (const TyTy::BaseType *receiver);\n+\n+  const Resolver::TraitItemReference *get_raw_item () const;\n+\n+  bool needs_implementation () const;\n+\n+private:\n+  const TypeBoundPredicate *parent;\n+  const Resolver::TraitItemReference *trait_item_ref;\n+};\n+\n class TypeBoundPredicate\n {\n public:\n   TypeBoundPredicate (DefId reference, Location locus)\n-    : reference (reference), locus (locus)\n+    : reference (reference), locus (locus), args (nullptr)\n   {}\n \n   std::string as_string () const;\n@@ -165,9 +196,29 @@ class TypeBoundPredicate\n   // https://doc.rust-lang.org/reference/items/traits.html#object-safety\n   bool is_object_safe (bool emit_error, Location locus) const;\n \n+  void apply_generic_arguments (HIR::GenericArgs *generic_args);\n+\n+  bool contains_item (const std::string &search) const;\n+\n+  TypeBoundPredicateItem\n+  lookup_associated_item (const std::string &search) const;\n+\n+  HIR::GenericArgs *get_generic_args () { return args; }\n+\n+  const HIR::GenericArgs *get_generic_args () const { return args; }\n+\n+  bool has_generic_args () const\n+  {\n+    if (args == nullptr)\n+      return false;\n+\n+    return args->has_generic_args ();\n+  }\n+\n private:\n   DefId reference;\n   Location locus;\n+  HIR::GenericArgs *args;\n };\n \n class TypeBoundsMappings\n@@ -259,7 +310,8 @@ class BaseType : public TypeBoundsMappings\n   //\n   // It can also be used to optional emit errors for trait item compatibility\n   // checks\n-  virtual bool can_eq (const BaseType *other, bool emit_errors) const = 0;\n+  virtual bool can_eq (const BaseType *other, bool emit_errors,\n+\t\t       bool autoderef_mode) const = 0;\n \n   // this is the base coercion interface for types\n   virtual BaseType *coerce (BaseType *other) = 0;\n@@ -404,7 +456,8 @@ class InferType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n \n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n \n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n@@ -442,7 +495,8 @@ class ErrorType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -476,7 +530,8 @@ class ParamType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -564,7 +619,8 @@ class TupleType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -626,7 +682,7 @@ class SubstitutionParamMapping\n \n   std::string as_string () const { return param->as_string (); }\n \n-  void fill_param_ty (BaseType &type, Location locus);\n+  bool fill_param_ty (BaseType &type, Location locus);\n \n   SubstitutionParamMapping clone () const\n   {\n@@ -998,7 +1054,8 @@ class ADTType : public BaseType, public SubstitutionRef\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1126,7 +1183,8 @@ class FnType : public BaseType, public SubstitutionRef\n   std::string get_identifier () const { return identifier; }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1234,7 +1292,8 @@ class FnPtr : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1294,7 +1353,8 @@ class ClosureType : public BaseType, public SubstitutionRef\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1346,7 +1406,8 @@ class ArrayType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1388,7 +1449,8 @@ class BoolType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1424,7 +1486,8 @@ class IntType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1467,7 +1530,8 @@ class UintType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1508,7 +1572,8 @@ class FloatType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1541,7 +1606,8 @@ class USizeType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1567,7 +1633,8 @@ class ISizeType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1593,7 +1660,8 @@ class CharType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1623,7 +1691,8 @@ class ReferenceType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1670,7 +1739,8 @@ class PointerType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1715,7 +1785,8 @@ class StrType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1751,7 +1822,8 @@ class NeverType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1784,7 +1856,8 @@ class PlaceholderType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1812,7 +1885,9 @@ class PlaceholderType : public BaseType\n \n   bool contains_type_parameters () const override\n   {\n-    rust_assert (can_resolve ());\n+    if (!can_resolve ())\n+      return false;\n+\n     return resolve ()->contains_type_parameters ();\n   }\n \n@@ -1850,7 +1925,8 @@ class ProjectionType : public BaseType, public SubstitutionRef\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1910,7 +1986,8 @@ class DynamicObjectType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors,\n+\t       bool autoderef_mode) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n   bool is_equal (const BaseType &other) const override;"}, {"sha": "54023d291febc1023b9ed84fd7ea27291b95fbe5", "filename": "gcc/testsuite/rust/execute/torture/trait6.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait6.rs?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+pub trait Foo {\n+    type A;\n+\n+    fn bar(self) -> Self::A;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+struct S(i32);\n+impl Foo for S {\n+    type A = i32;\n+\n+    fn bar(self) -> Self::A {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        self.0\n+    }\n+}\n+\n+fn test_bar<T: Foo>(x: T) -> T::A {\n+    x.bar()\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = S(123);\n+\n+    let bar: i32 = test_bar::<S>(a);\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, bar);\n+    }\n+\n+    0\n+}"}, {"sha": "059ba15b69d621f42796eb5651b96dee5aa09483", "filename": "gcc/testsuite/rust/execute/torture/trait7.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait7.rs?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+pub trait Foo {\n+    type A;\n+\n+    fn bar(self) -> Self::A;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+struct S(i32);\n+impl Foo for S {\n+    type A = i32;\n+\n+    fn bar(self) -> Self::A {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        self.0\n+    }\n+}\n+\n+fn test_bar<T: Foo>(x: T) -> T::A {\n+    x.bar()\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = S(123);\n+\n+    let bar: i32 = test_bar(a);\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, bar);\n+    }\n+\n+    0\n+}"}, {"sha": "da8a560388e20a710ba86840a28fd7b1bfa43302", "filename": "gcc/testsuite/rust/execute/torture/trait8.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait8.rs?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+pub trait Foo {\n+    type A;\n+\n+    fn bar(&self) -> Self::A;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+struct S(i32);\n+impl Foo for S {\n+    type A = i32;\n+\n+    fn bar(&self) -> Self::A {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        self.0\n+    }\n+}\n+\n+fn test_bar<T: Foo>(x: T) -> T::A {\n+    x.bar()\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = S(123);\n+\n+    let bar: i32 = test_bar(a);\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, bar);\n+    }\n+\n+    0\n+}"}, {"sha": "1fe77e3a60c49f042c18d435b847db6c7b55d75e", "filename": "gcc/testsuite/rust/execute/torture/trait9.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6c5a32b6e2c1ade6f1a835be2c2a26788db544/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait9.rs?ref=8e6c5a32b6e2c1ade6f1a835be2c2a26788db544", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-output \"3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+trait FnLike<A, R> {\n+    fn call(&self, arg: A) -> R;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .arg.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct S;\n+impl<T> FnLike<&T, &T> for S {\n+    fn call(&self, arg: &T) -> &T {\n+        // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+        // { dg-warning \"unused name .<S as FnLike>::call.\" \"\" { target *-*-* } .-2 }\n+        arg\n+    }\n+}\n+\n+fn indirect<F: FnLike<&isize, &isize>>(f: F) {\n+    let x = 3;\n+    let y = f.call(&x);\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, *y);\n+    }\n+}\n+\n+fn main() -> i32 {\n+    indirect(S);\n+\n+    0\n+}"}]}