{"sha": "70826cbbef8e6392e3d961e0054af937bcb56a16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA4MjZjYmJlZjhlNjM5MmUzZDk2MWUwMDU0YWY5MzdiY2I1NmExNg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebpop@gmail.com", "date": "2007-06-21T21:25:27Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2007-06-21T21:25:27Z"}, "message": "re PR middle-end/20623 (ICE: fold check: original tree changed by fold with --enable-checking=fold)\n\n\tPR middle-end/20623\n\t* tree.h (debug_fold_checksum): Declared.\n\t* fold-const.c (build_fold_addr_expr_with_type_1): New.\n\t(build_fold_addr_expr_with_type, build_fold_addr_expr): Use \n\tbuild_fold_addr_expr_with_type_1.\n\t(fold_addr_expr, debug_fold_checksum): New.\n\t(fold_checksum_tree): Don't fold TREE_CHAIN of an SSA_NAME.\n\t(fold_unary, fold_comparison, split_address_to_core_and_offset):\n\tUse fold_addr_expr.\n\nFrom-SVN: r125929", "tree": {"sha": "de4d9a9684d60fb199d16f061e7404ba4f39ed0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de4d9a9684d60fb199d16f061e7404ba4f39ed0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70826cbbef8e6392e3d961e0054af937bcb56a16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70826cbbef8e6392e3d961e0054af937bcb56a16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70826cbbef8e6392e3d961e0054af937bcb56a16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70826cbbef8e6392e3d961e0054af937bcb56a16/comments", "author": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f1c9cd02fe6c75045024074dc9edf59c2981042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1c9cd02fe6c75045024074dc9edf59c2981042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f1c9cd02fe6c75045024074dc9edf59c2981042"}], "stats": {"total": 158, "additions": 114, "deletions": 44}, "files": [{"sha": "bafa24edd1bf66616e408599478f84e2c98e8ac8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70826cbbef8e6392e3d961e0054af937bcb56a16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70826cbbef8e6392e3d961e0054af937bcb56a16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70826cbbef8e6392e3d961e0054af937bcb56a16", "patch": "@@ -1,3 +1,15 @@\n+2007-06-21  Sebastian Pop  <sebpop@gmail.com>\n+\n+\tPR middle-end/20623\n+\t* tree.h (debug_fold_checksum): Declared.\n+\t* fold-const.c (build_fold_addr_expr_with_type_1): New.\n+\t(build_fold_addr_expr_with_type, build_fold_addr_expr): Use \n+\tbuild_fold_addr_expr_with_type_1.\n+\t(fold_addr_expr, debug_fold_checksum): New.\n+\t(fold_checksum_tree): Don't fold TREE_CHAIN of an SSA_NAME.\n+\t(fold_unary, fold_comparison, split_address_to_core_and_offset):\n+\tUse fold_addr_expr.\n+\t\n 2007-06-21  Sebastian Pop  <sebpop@gmail.com>\n \n \tPR tree-optimization/19590"}, {"sha": "c3b77d47e0c4a03cccce40ed057330ae3d035994", "filename": "gcc/fold-const.c", "status": "modified", "additions": 101, "deletions": 44, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70826cbbef8e6392e3d961e0054af937bcb56a16/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70826cbbef8e6392e3d961e0054af937bcb56a16/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=70826cbbef8e6392e3d961e0054af937bcb56a16", "patch": "@@ -7552,6 +7552,77 @@ fold_view_convert_expr (tree type, tree expr)\n   return native_interpret_expr (type, buffer, len);\n }\n \n+/* Build an expression for the address of T.  Folds away INDIRECT_REF\n+   to avoid confusing the gimplify process.  When IN_FOLD is true\n+   avoid modifications of T.  */\n+\n+static tree\n+build_fold_addr_expr_with_type_1 (tree t, tree ptrtype, bool in_fold)\n+{\n+  /* The size of the object is not relevant when talking about its address.  */\n+  if (TREE_CODE (t) == WITH_SIZE_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+\n+  /* Note: doesn't apply to ALIGN_INDIRECT_REF */\n+  if (TREE_CODE (t) == INDIRECT_REF\n+      || TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n+    {\n+      t = TREE_OPERAND (t, 0);\n+\n+      if (TREE_TYPE (t) != ptrtype)\n+\tt = build1 (NOP_EXPR, ptrtype, t);\n+    }\n+  else if (!in_fold)\n+    {\n+      tree base = t;\n+\n+      while (handled_component_p (base))\n+\tbase = TREE_OPERAND (base, 0);\n+\n+      if (DECL_P (base))\n+\tTREE_ADDRESSABLE (base) = 1;\n+\n+      t = build1 (ADDR_EXPR, ptrtype, t);\n+    }\n+  else\n+    t = build1 (ADDR_EXPR, ptrtype, t);\n+\n+  return t;\n+}\n+\n+/* Build an expression for the address of T with type PTRTYPE.  This\n+   function modifies the input parameter 'T' by sometimes setting the\n+   TREE_ADDRESSABLE flag.  */\n+\n+tree\n+build_fold_addr_expr_with_type (tree t, tree ptrtype)\n+{\n+  return build_fold_addr_expr_with_type_1 (t, ptrtype, false);\n+}\n+\n+/* Build an expression for the address of T.  This function modifies\n+   the input parameter 'T' by sometimes setting the TREE_ADDRESSABLE\n+   flag.  When called from fold functions, use fold_addr_expr instead.  */\n+\n+tree\n+build_fold_addr_expr (tree t)\n+{\n+  return build_fold_addr_expr_with_type_1 (t, \n+\t\t\t\t\t   build_pointer_type (TREE_TYPE (t)),\n+\t\t\t\t\t   false);\n+}\n+\n+/* Same as build_fold_addr_expr, builds an expression for the address\n+   of T, but avoids touching the input node 't'.  Fold functions\n+   should use this version.  */\n+\n+static tree\n+fold_addr_expr (tree t)\n+{\n+  tree ptrtype = build_pointer_type (TREE_TYPE (t));\n+\n+  return build_fold_addr_expr_with_type_1 (t, ptrtype, true);\n+}\n \n /* Fold a unary expression of code CODE and type TYPE with operand\n    OP0.  Return the folded expression if folding is successful.\n@@ -7787,7 +7858,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t  if (! offset && bitpos == 0\n \t      && TYPE_MAIN_VARIANT (TREE_TYPE (type))\n \t\t  == TYPE_MAIN_VARIANT (TREE_TYPE (base)))\n-\t    return fold_convert (type, build_fold_addr_expr (base));\n+\t    return fold_convert (type, fold_addr_expr (base));\n         }\n \n       if ((TREE_CODE (op0) == MODIFY_EXPR\n@@ -8864,8 +8935,8 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t  tree op0 = TREE_OPERAND (cref0, 0);\n \t  tree op1 = TREE_OPERAND (cref1, 0);\n \t  return fold_build2 (code, type,\n-\t\t\t      build_fold_addr_expr (op0),\n-\t\t\t      build_fold_addr_expr (op1));\n+\t\t\t      fold_addr_expr (op0),\n+\t\t\t      fold_addr_expr (op1));\n \t}\n     }\n \n@@ -12775,7 +12846,8 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n   fold_checksum_tree (TREE_TYPE (expr), ctx, ht);\n   if (TREE_CODE_CLASS (code) != tcc_type\n       && TREE_CODE_CLASS (code) != tcc_declaration\n-      && code != TREE_LIST)\n+      && code != TREE_LIST\n+      && code != SSA_NAME)\n     fold_checksum_tree (TREE_CHAIN (expr), ctx, ht);\n   switch (TREE_CODE_CLASS (code))\n     {\n@@ -12910,6 +12982,30 @@ fold_build1_stat (enum tree_code code, tree type, tree op0 MEM_STAT_DECL)\n   return tem;\n }\n \n+/* Helper function for outputting the checksum of a tree T.  When\n+   debugging with gdb, you can \"define mynext\" to be \"next\" followed\n+   by \"call debug_fold_checksum (op0)\", then just trace down till the\n+   outputs differ.  */\n+\n+void\n+debug_fold_checksum (tree t)\n+{\n+  int i;\n+  unsigned char checksum[16];\n+  struct md5_ctx ctx;\n+  htab_t ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n+  \n+  md5_init_ctx (&ctx);\n+  fold_checksum_tree (t, &ctx, ht);\n+  md5_finish_ctx (&ctx, checksum);\n+  htab_empty (ht);\n+\n+  for (i = 0; i < 16; i++)\n+    fprintf (stderr, \"%d \", checksum[i]);\n+\n+  fprintf (stderr, \"\\n\");\n+}\n+\n /* Fold a binary tree expression with code CODE of type TYPE with\n    operands OP0 and OP1.  Return a folded expression if successful.\n    Otherwise, return a tree expression with code CODE of type TYPE\n@@ -14171,45 +14267,6 @@ fold_build_cleanup_point_expr (tree type, tree expr)\n   return build1 (CLEANUP_POINT_EXPR, type, expr);\n }\n \n-/* Build an expression for the address of T.  Folds away INDIRECT_REF to\n-   avoid confusing the gimplify process.  */\n-\n-tree\n-build_fold_addr_expr_with_type (tree t, tree ptrtype)\n-{\n-  /* The size of the object is not relevant when talking about its address.  */\n-  if (TREE_CODE (t) == WITH_SIZE_EXPR)\n-    t = TREE_OPERAND (t, 0);\n-\n-  /* Note: doesn't apply to ALIGN_INDIRECT_REF */\n-  if (TREE_CODE (t) == INDIRECT_REF\n-      || TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n-    {\n-      t = TREE_OPERAND (t, 0);\n-      if (TREE_TYPE (t) != ptrtype)\n-\tt = build1 (NOP_EXPR, ptrtype, t);\n-    }\n-  else\n-    {\n-      tree base = t;\n-\n-      while (handled_component_p (base))\n-\tbase = TREE_OPERAND (base, 0);\n-      if (DECL_P (base))\n-\tTREE_ADDRESSABLE (base) = 1;\n-\n-      t = build1 (ADDR_EXPR, ptrtype, t);\n-    }\n-\n-  return t;\n-}\n-\n-tree\n-build_fold_addr_expr (tree t)\n-{\n-  return build_fold_addr_expr_with_type (t, build_pointer_type (TREE_TYPE (t)));\n-}\n-\n /* Given a pointer value OP0 and a type TYPE, return a simplified version\n    of an indirection through OP0, or NULL_TREE if no simplification is\n    possible.  */\n@@ -14513,7 +14570,7 @@ split_address_to_core_and_offset (tree exp,\n       core = get_inner_reference (TREE_OPERAND (exp, 0), &bitsize, pbitpos,\n \t\t\t\t  poffset, &mode, &unsignedp, &volatilep,\n \t\t\t\t  false);\n-      core = build_fold_addr_expr (core);\n+      core = fold_addr_expr (core);\n     }\n   else\n     {"}, {"sha": "5bee34cf1dbe7818b1d61b70e2cc25ecfc15f562", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70826cbbef8e6392e3d961e0054af937bcb56a16/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70826cbbef8e6392e3d961e0054af937bcb56a16/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=70826cbbef8e6392e3d961e0054af937bcb56a16", "patch": "@@ -4539,6 +4539,7 @@ extern enum built_in_function builtin_mathfn_code (tree);\n extern tree build_function_call_expr (tree, tree);\n extern tree fold_build_call_expr (tree, tree, tree, tree);\n extern tree fold_builtin_call_array (tree, tree, int, tree *);\n+extern void debug_fold_checksum (tree);\n extern tree build_call_expr (tree, int, ...);\n extern tree mathfn_built_in (tree, enum built_in_function fn);\n extern tree strip_float_extensions (tree);"}]}