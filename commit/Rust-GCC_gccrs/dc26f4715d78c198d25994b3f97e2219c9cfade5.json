{"sha": "dc26f4715d78c198d25994b3f97e2219c9cfade5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMyNmY0NzE1ZDc4YzE5OGQyNTk5NGIzZjk3ZTIyMTljOWNmYWRlNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-04-10T03:38:27Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-10T03:38:27Z"}, "message": "sig.c (build_signature_pointer_constructor): Don't set TREE_HAS_CONSTRUCTOR for a signature pointer.\n\n\t* sig.c (build_signature_pointer_constructor): Don't set\n\tTREE_HAS_CONSTRUCTOR for a signature pointer.\n\t* cvt.c (ocp_convert): Don't force a temporary for internal structs.\n\t* init.c (resolve_offset_ref): Warn about implicit & on pmfs\n\there, too.\n\t* typeck.c (build_unary_op): Only allow taking the address of a\n\treal constructor.\n\t* typeck2.c (digest_init): Simplify.\n\t(store_init_value): Don't pedwarn about using { } for pmfs.\n\nFrom-SVN: r19079", "tree": {"sha": "b5f953cac859b397058f9932dff3f71ebd03d28d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5f953cac859b397058f9932dff3f71ebd03d28d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc26f4715d78c198d25994b3f97e2219c9cfade5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc26f4715d78c198d25994b3f97e2219c9cfade5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc26f4715d78c198d25994b3f97e2219c9cfade5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc26f4715d78c198d25994b3f97e2219c9cfade5/comments", "author": null, "committer": null, "parents": [{"sha": "34a4c46602286492977989248419f834ee9f6ffc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34a4c46602286492977989248419f834ee9f6ffc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34a4c46602286492977989248419f834ee9f6ffc"}], "stats": {"total": 118, "additions": 38, "deletions": 80}, "files": [{"sha": "2a93633061c2d0308767c9344b6e2a151a8c21f7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc26f4715d78c198d25994b3f97e2219c9cfade5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc26f4715d78c198d25994b3f97e2219c9cfade5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dc26f4715d78c198d25994b3f97e2219c9cfade5", "patch": "@@ -1,3 +1,15 @@\n+Thu Apr  9 02:40:48 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* sig.c (build_signature_pointer_constructor): Don't set\n+\tTREE_HAS_CONSTRUCTOR for a signature pointer.\n+\t* cvt.c (ocp_convert): Don't force a temporary for internal structs.\n+\t* init.c (resolve_offset_ref): Warn about implicit & on pmfs \n+\there, too.\n+\t* typeck.c (build_unary_op): Only allow taking the address of a \n+\treal constructor.\n+\t* typeck2.c (digest_init): Simplify.\n+\t(store_init_value): Don't pedwarn about using { } for pmfs.\n+\n Thu Apr  9 22:16:57 1998  Per Bothner  <bothner@cygnus.com>\n \n         * cp-tree.h (start_decl):  Update prototype."}, {"sha": "92dce8beb7079fede67f98237247e21df2d377c3", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc26f4715d78c198d25994b3f97e2219c9cfade5/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc26f4715d78c198d25994b3f97e2219c9cfade5/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=dc26f4715d78c198d25994b3f97e2219c9cfade5", "patch": "@@ -656,7 +656,11 @@ ocp_convert (type, expr, convtype, flags)\n   if (TREE_READONLY_DECL_P (e))\n     e = decl_constant_value (e);\n \n-  if (IS_AGGR_TYPE (type) && (convtype & CONV_FORCE_TEMP))\n+  if (IS_AGGR_TYPE (type) && (convtype & CONV_FORCE_TEMP)\n+      /* Some internal structures (vtable_entry_type, sigtbl_ptr_type)\n+\t don't go through finish_struct, so they don't have the synthesized\n+\t constructors.  So don't force a temporary.  */\n+      && TYPE_HAS_CONSTRUCTOR (type))\n     /* We need a new temporary; don't take this shortcut.  */;\n   else if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (e)))\n     /* Trivial conversion: cv-qualifiers do not matter on rvalues.  */"}, {"sha": "a783fe5c00d4c045c577f5604a3505b460dd3891", "filename": "gcc/cp/init.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc26f4715d78c198d25994b3f97e2219c9cfade5/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc26f4715d78c198d25994b3f97e2219c9cfade5/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=dc26f4715d78c198d25994b3f97e2219c9cfade5", "patch": "@@ -1808,7 +1808,10 @@ resolve_offset_ref (exp)\n   tree basetype, addr;\n \n   if (TREE_CODE (exp) == TREE_LIST)\n-    return build_unary_op (ADDR_EXPR, exp, 0);\n+    {\n+      cp_pedwarn (\"assuming & on overloaded member function\");\n+      return build_unary_op (ADDR_EXPR, exp, 0);\n+    }\n \n   if (TREE_CODE (exp) == OFFSET_REF)\n     {"}, {"sha": "f1e8ff9890cf72d6dd6d205671c558678305ac5e", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc26f4715d78c198d25994b3f97e2219c9cfade5/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc26f4715d78c198d25994b3f97e2219c9cfade5/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=dc26f4715d78c198d25994b3f97e2219c9cfade5", "patch": "@@ -880,7 +880,6 @@ build_signature_pointer_constructor (lhs, rhs)\n       result = tree_cons (NULL_TREE, optr_expr,\n \t\t\t  build_tree_list (NULL_TREE, sptr_expr));\n       result = build_nt (CONSTRUCTOR, NULL_TREE, result);\n-      TREE_HAS_CONSTRUCTOR (result) = 1;\n       result = digest_init (lhstype, result, 0);\n     }\n   else"}, {"sha": "e13a312f020a24a125ce5cceb21b41fcf624c2bb", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc26f4715d78c198d25994b3f97e2219c9cfade5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc26f4715d78c198d25994b3f97e2219c9cfade5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=dc26f4715d78c198d25994b3f97e2219c9cfade5", "patch": "@@ -3062,8 +3062,6 @@ build_x_binary_op (code, arg1, arg2)\n      enum tree_code code;\n      tree arg1, arg2;\n {\n-  tree rval;\n-\n   if (processing_template_decl)\n     return build_min_nt (code, arg1, arg2);\n \n@@ -4565,7 +4563,8 @@ build_unary_op (code, xarg, noconvert)\n \n       /* Allow the address of a constructor if all the elements\n \t are constant.  */\n-      if (TREE_CODE (arg) == CONSTRUCTOR && TREE_CONSTANT (arg))\n+      if (TREE_CODE (arg) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (arg)\n+\t  && TREE_CONSTANT (arg))\n \t;\n       /* Anything not already handled and not a true memory reference\n \t is an error.  */"}, {"sha": "c135537f3713198526af4e9ff0abf70d9e3f9cf8", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 15, "deletions": 74, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc26f4715d78c198d25994b3f97e2219c9cfade5/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc26f4715d78c198d25994b3f97e2219c9cfade5/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=dc26f4715d78c198d25994b3f97e2219c9cfade5", "patch": "@@ -669,10 +669,6 @@ store_init_value (decl, init)\n \t}\n     }\n \n-  if (TYPE_PTRMEMFUNC_P (type) && TREE_CODE (init) == CONSTRUCTOR\n-      && TREE_TYPE (init) == NULL_TREE)\n-    cp_pedwarn (\"initializer list for `%T'\", type);\n-\n   /* End of special C++ code.  */\n \n   /* Digest the specified initializer into an expression.  */\n@@ -763,24 +759,9 @@ digest_init (type, init, tail)\n   if (TREE_CODE (init) == NON_LVALUE_EXPR)\n     init = TREE_OPERAND (init, 0);\n \n-  if (init && TREE_TYPE (init) && TYPE_PTRMEMFUNC_P (type))\n-    init = default_conversion (init);\n-\n-  if (init && TYPE_PTRMEMFUNC_P (type)\n-      && ((TREE_CODE (init) == ADDR_EXPR\n-\t   && ((TREE_CODE (TREE_TYPE (init)) == POINTER_TYPE\n-\t\t&& TREE_CODE (TREE_TYPE (TREE_TYPE (init))) == METHOD_TYPE)\n-\t       || TREE_CODE (TREE_OPERAND (init, 0)) == TREE_LIST))\n-\t  || TREE_CODE (init) == TREE_LIST\n-\t  || integer_zerop (init)\n-\t  || (TREE_TYPE (init) && TYPE_PTRMEMFUNC_P (TREE_TYPE (init)))))\n-    {\n-      return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), init, 0);\n-    }\n-\n   raw_constructor = TREE_CODE (init) == CONSTRUCTOR && TREE_TYPE (init) == 0;\n \n-  if (init && raw_constructor\n+  if (raw_constructor\n       && CONSTRUCTOR_ELTS (init) != 0\n       && TREE_CHAIN (CONSTRUCTOR_ELTS (init)) == 0)\n     {\n@@ -792,41 +773,6 @@ digest_init (type, init, tail)\n \treturn element;\n     }\n \n-  /* Any type can be initialized from an expression of the same type,\n-     optionally with braces.  */\n-\n-  if (init && TREE_TYPE (init)\n-      && (TYPE_MAIN_VARIANT (TREE_TYPE (init)) == type\n-\t  || (code == ARRAY_TYPE && comptypes (TREE_TYPE (init), type, 1))))\n-    {\n-      if (pedantic && code == ARRAY_TYPE\n-\t  && TREE_CODE (init) != STRING_CST)\n-\tpedwarn (\"ANSI C++ forbids initializing array from array expression\");\n-      if (TREE_CODE (init) == CONST_DECL)\n-\tinit = DECL_INITIAL (init);\n-      else if (TREE_READONLY_DECL_P (init))\n-\tinit = decl_constant_value (init);\n-      else if (IS_AGGR_TYPE (type) && TYPE_NEEDS_CONSTRUCTING (type))\n-\tinit = ocp_convert (type, init, CONV_IMPLICIT|CONV_FORCE_TEMP,\n-\t\t\t    LOOKUP_NORMAL);\n-      return init;\n-    }\n-\n-  if (element && (TREE_TYPE (element) == type\n-\t\t  || (code == ARRAY_TYPE && TREE_TYPE (element)\n-\t\t      && comptypes (TREE_TYPE (element), type, 1))))\n-    {\n-      if (pedantic && code == ARRAY_TYPE)\n-\tpedwarn (\"ANSI C++ forbids initializing array from array expression\");\n-      if (pedantic && (code == RECORD_TYPE || code == UNION_TYPE))\n-\tpedwarn (\"ANSI C++ forbids single nonscalar initializer with braces\");\n-      if (TREE_CODE (element) == CONST_DECL)\n-\telement = DECL_INITIAL (element);\n-      else if (TREE_READONLY_DECL_P (element))\n-\telement = decl_constant_value (element);\n-      return element;\n-    }\n-\n   /* Initialization of an array of chars from a string constant\n      optionally enclosed in braces.  */\n \n@@ -858,11 +804,6 @@ digest_init (type, init, tail)\n \t      return error_mark_node;\n \t    }\n \n-\t  if (pedantic\n-\t      && typ1 != char_type_node\n-\t      && typ1 != signed_char_type_node\n-\t      && typ1 != unsigned_char_type_node)\n-\t    pedwarn (\"ANSI C++ forbids string initializer except for `char' elements\");\n \t  TREE_TYPE (string) = type;\n \t  if (TYPE_DOMAIN (type) != 0\n \t      && TREE_CONSTANT (TYPE_SIZE (type)))\n@@ -887,6 +828,7 @@ digest_init (type, init, tail)\n   if (code == INTEGER_TYPE || code == REAL_TYPE || code == POINTER_TYPE\n       || code == ENUMERAL_TYPE || code == REFERENCE_TYPE\n       || code == BOOLEAN_TYPE || code == COMPLEX_TYPE\n+      || TYPE_PTRMEMFUNC_P (type)\n       || (code == RECORD_TYPE && ! raw_constructor\n \t  && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type))))\n     {\n@@ -899,9 +841,7 @@ digest_init (type, init, tail)\n \t    }\n \t  init = element;\n \t}\n-      while (TREE_CODE (init) == CONSTRUCTOR\n-\t     && ! (TREE_TYPE (init)\n-\t\t   && TYPE_PTRMEMFUNC_P (TREE_TYPE (init))))\n+      while (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))\n \t{\n \t  cp_pedwarn (\"braces around scalar initializer for `%T'\", type);\n \t  init = CONSTRUCTOR_ELTS (init);\n@@ -933,24 +873,25 @@ digest_init (type, init, tail)\n \t}\n       else if (raw_constructor)\n \treturn process_init_constructor (type, init, (tree *)0);\n-      else if (TYPE_NON_AGGREGATE_CLASS (type))\n-\t{\n-\t  int flags = LOOKUP_NORMAL;\n-\t  /* Initialization from { } is copy-initialization.  */\n-\t  if (tail)\n-\t    flags |= LOOKUP_ONLYCONVERTING;\n-\t  return convert_for_initialization (0, type, init, flags,\n-\t\t\t\t\t     \"initialization\", NULL_TREE, 0);\n-\t}\n+      else if (can_convert_arg (type, TREE_TYPE (init), init)\n+\t       || TYPE_NON_AGGREGATE_CLASS (type))\n+\t/* These are never initialized from multiple constructor elements.  */;\n       else if (tail != 0)\n \t{\n \t  *tail = old_tail_contents;\n \t  return process_init_constructor (type, 0, tail);\n \t}\n \n       if (code != ARRAY_TYPE)\n-\treturn convert_for_initialization (NULL_TREE, type, init, LOOKUP_NORMAL,\n-\t\t\t\t\t   \"initialization\", NULL_TREE, 0);\n+\t{\n+\t  int flags = LOOKUP_NORMAL;\n+\t  /* Initialization from { } is copy-initialization.  */\n+\t  if (tail)\n+\t    flags |= LOOKUP_ONLYCONVERTING;\n+\n+\t  return convert_for_initialization (NULL_TREE, type, init, flags,\n+\t\t\t\t\t     \"initialization\", NULL_TREE, 0);\n+\t}\n     }\n \n   error (\"invalid initializer\");"}]}