{"sha": "b6398823e7ff715272f35ceae58da3d3219523cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYzOTg4MjNlN2ZmNzE1MjcyZjM1Y2VhZTU4ZGEzZDMyMTk1MjNjYw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-05-15T17:16:26Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-05-15T17:16:26Z"}, "message": "re PR fortran/25090 (Bad automatic character length)\n\n2006-05-15  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/25090\n\t* resolve.c: Static resolving_index_expr initialized.\n\t(entry_parameter): New function to emit errors for variables\n\tthat are not entry parameters.\n\t(gfc_resolve_expr): Call entry_parameter, when resolving\n\tvariables, if the namespace has entries and resolving_index_expr\n\tis set.\n\t(resolve_charlen): Set resolving_index_expr before the call to\n\tresolve_index_expr and reset it afterwards.\n\t(resolve_fl_variable): The same before and after the call to\n\tis_non_constant_shape_array, which ultimately makes a call to\n\tgfc_resolve_expr.\n\n\tPR fortran/25082\n\t* resolve.c (resolve_code): Add error condition that the return\n\texpression must be scalar.\n\n\tPR fortran/24711\n\t* matchexp.c (gfc_get_parentheses): New function.\n\t(match_primary): Remove inline code and call above.\n\t* gfortran.h: Provide prototype for gfc_get_parentheses.\n\t* resolve.c (resolve_array_ref): Call the above, when start is a\n\tderived type variable array reference.\n\n2006-05-15  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/25090\n\t* gfortran.dg/entry_dummy_ref_1.f90: New test.\n\n\tPR fortran/25082\n\t* gfortran.dg/scalar_return_1.f90: New test.\n\n\tPR fortran/24711\n\t* gfortran.dg/derived_comp_array_ref_1.f90: New test.\n\nFrom-SVN: r113796", "tree": {"sha": "fedad2a76662472ff4fb41499498b3e8a81eb3b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fedad2a76662472ff4fb41499498b3e8a81eb3b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6398823e7ff715272f35ceae58da3d3219523cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6398823e7ff715272f35ceae58da3d3219523cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6398823e7ff715272f35ceae58da3d3219523cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6398823e7ff715272f35ceae58da3d3219523cc/comments", "author": null, "committer": null, "parents": [{"sha": "a01456333d6e310a0ba2f46ed1ade2d46a8a789b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01456333d6e310a0ba2f46ed1ade2d46a8a789b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a01456333d6e310a0ba2f46ed1ade2d46a8a789b"}], "stats": {"total": 221, "additions": 195, "deletions": 26}, "files": [{"sha": "11b3b629942fa047512ed60735e0d7f230b73e3e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b6398823e7ff715272f35ceae58da3d3219523cc", "patch": "@@ -1,3 +1,29 @@\n+2006-05-15  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25090\n+\t* resolve.c: Static resolving_index_expr initialized.\n+\t(entry_parameter): New function to emit errors for variables\n+\tthat are not entry parameters.\n+\t(gfc_resolve_expr): Call entry_parameter, when resolving\n+\tvariables, if the namespace has entries and resolving_index_expr\n+\tis set.\n+\t(resolve_charlen): Set resolving_index_expr before the call to\n+\tresolve_index_expr and reset it afterwards.\n+\t(resolve_fl_variable): The same before and after the call to\n+\tis_non_constant_shape_array, which ultimately makes a call to\n+\tgfc_resolve_expr.\n+\n+\tPR fortran/25082\n+\t* resolve.c (resolve_code): Add error condition that the return\n+\texpression must be scalar.\n+\n+\tPR fortran/24711\n+\t* matchexp.c (gfc_get_parentheses): New function.\n+\t(match_primary): Remove inline code and call above.\n+\t* gfortran.h: Provide prototype for gfc_get_parentheses.\n+\t* resolve.c (resolve_array_ref): Call the above, when start is a\n+\tderived type variable array reference.\n+\n 2006-05-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/27446"}, {"sha": "b1b68171b3e5518a4385285449ad9cf21ab3ffae", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=b6398823e7ff715272f35ceae58da3d3219523cc", "patch": "@@ -1941,6 +1941,9 @@ void gfc_free_equiv (gfc_equiv *);\n void gfc_free_data (gfc_data *);\n void gfc_free_case_list (gfc_case *);\n \n+/* matchexp.c -- FIXME too?  */\n+gfc_expr *gfc_get_parentheses (gfc_expr *);\n+\n /* openmp.c */\n void gfc_free_omp_clauses (gfc_omp_clauses *);\n void gfc_resolve_omp_directive (gfc_code *, gfc_namespace *);"}, {"sha": "b319c24e9851f473ba03caf86e5475fb328add50", "filename": "gcc/fortran/matchexp.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ffortran%2Fmatchexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ffortran%2Fmatchexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatchexp.c?ref=b6398823e7ff715272f35ceae58da3d3219523cc", "patch": "@@ -123,6 +123,26 @@ next_operator (gfc_intrinsic_op t)\n }\n \n \n+/* Call the INTRINSIC_PARENTHESES function.  This is both\n+   used explicitly, as below, or by resolve.c to generate\n+   temporaries.  */\n+gfc_expr *\n+gfc_get_parentheses (gfc_expr *e)\n+{\n+  gfc_expr *e2;\n+\n+  e2 = gfc_get_expr();\n+  e2->expr_type = EXPR_OP;\n+  e2->ts = e->ts;\n+  e2->rank = e->rank;\n+  e2->where = e->where;\n+  e2->value.op.operator = INTRINSIC_PARENTHESES;\n+  e2->value.op.op1 = e;\n+  e2->value.op.op2 = NULL;\n+  return e2;\n+}\n+\n+\n /* Match a primary expression.  */\n \n static match\n@@ -167,18 +187,7 @@ match_primary (gfc_expr ** result)\n   if(!gfc_numeric_ts(&e->ts))\n     *result = e;\n   else\n-    {\n-      gfc_expr *e2 = gfc_get_expr();\n-\n-      e2->expr_type = EXPR_OP;\n-      e2->ts = e->ts;\n-      e2->rank = e->rank;\n-      e2->where = where;\n-      e2->value.op.operator = INTRINSIC_PARENTHESES;\n-      e2->value.op.op1 = e;\n-      e2->value.op.op2 = NULL;\n-      *result = e2;\n-    }\n+    *result = gfc_get_parentheses (e);\n \n   if (m != MATCH_YES)\n     {"}, {"sha": "7020491fafb5ed515e29650868344c012e9ba8bb", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 76, "deletions": 14, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=b6398823e7ff715272f35ceae58da3d3219523cc", "patch": "@@ -60,6 +60,9 @@ static int omp_workshare_flag;\n    resets the flag each time that it is read.  */\n static int formal_arg_flag = 0;\n \n+/* True if we are resolving a specification expression.  */\n+static int resolving_index_expr = 0;\n+\n int\n gfc_is_formal_arg (void)\n {\n@@ -2284,6 +2287,7 @@ static try\n resolve_array_ref (gfc_array_ref * ar)\n {\n   int i, check_scalar;\n+  gfc_expr *e;\n \n   for (i = 0; i < ar->dimen; i++)\n     {\n@@ -2296,20 +2300,25 @@ resolve_array_ref (gfc_array_ref * ar)\n       if (gfc_resolve_index (ar->stride[i], check_scalar) == FAILURE)\n \treturn FAILURE;\n \n+      e = ar->start[i];\n+\n       if (ar->dimen_type[i] == DIMEN_UNKNOWN)\n-\tswitch (ar->start[i]->rank)\n+\tswitch (e->rank)\n \t  {\n \t  case 0:\n \t    ar->dimen_type[i] = DIMEN_ELEMENT;\n \t    break;\n \n \t  case 1:\n \t    ar->dimen_type[i] = DIMEN_VECTOR;\n+\t    if (e->expr_type == EXPR_VARIABLE\n+\t\t   && e->symtree->n.sym->ts.type == BT_DERIVED)\n+\t      ar->start[i] = gfc_get_parentheses (e);\n \t    break;\n \n \t  default:\n \t    gfc_error (\"Array index at %L is an array of rank %d\",\n-\t\t       &ar->c_where[i], ar->start[i]->rank);\n+\t\t       &ar->c_where[i], e->rank);\n \t    return FAILURE;\n \t  }\n     }\n@@ -2626,6 +2635,43 @@ resolve_variable (gfc_expr * e)\n }\n \n \n+/* Emits an error if the expression is a variable that is not a parameter\n+   in all entry formal argument lists for the namespace.  */\n+\n+static void\n+entry_parameter (gfc_expr *e)\n+{\n+  gfc_symbol *sym, *esym;\n+  gfc_entry_list *entry;\n+  gfc_formal_arglist *f;\n+  bool p;\n+\n+\n+  sym = e->symtree->n.sym;\n+\n+  if (sym->attr.use_assoc\n+\t|| !sym->attr.dummy\n+\t|| sym->ns != gfc_current_ns)\n+    return;\n+\n+  entry = sym->ns->entries;\n+  for (; entry; entry = entry->next)\n+    {\n+      esym = entry->sym;\n+      p = false;\n+      for (f = esym->formal; f && !p; f = f->next)\n+\t{\n+\t  if (f->sym && f->sym->name && sym->name == f->sym->name)\n+\t    p = true;\n+\t}\n+      if (!p)\n+\tgfc_error (\"%s at %L must be a parameter of the entry at %L\",\n+\t\t   sym->name, &e->where, &esym->declared_at);\n+    }\n+  return;\n+}\n+\n+\n /* Resolve an expression.  That is, make sure that types of operands agree\n    with their operators, intrinsic operators are converted to function calls\n    for overloaded types and unresolved function references are resolved.  */\n@@ -2650,6 +2696,10 @@ gfc_resolve_expr (gfc_expr * e)\n \n     case EXPR_VARIABLE:\n       t = resolve_variable (e);\n+\n+      if (gfc_current_ns->entries && resolving_index_expr)\n+\tentry_parameter (e);\n+\n       if (t == SUCCESS)\n \texpression_rank (e);\n       break;\n@@ -4345,9 +4395,10 @@ resolve_code (gfc_code * code, gfc_namespace * ns)\n \t  break;\n \n \tcase EXEC_RETURN:\n-\t  if (code->expr != NULL && code->expr->ts.type != BT_INTEGER)\n-\t    gfc_error (\"Alternate RETURN statement at %L requires an INTEGER \"\n-\t\t       \"return specifier\", &code->expr->where);\n+\t  if (code->expr != NULL\n+\t\t&& (code->expr->ts.type != BT_INTEGER || code->expr->rank))\n+\t    gfc_error (\"Alternate RETURN statement at %L requires a SCALAR-\"\n+\t\t       \"INTEGER return specifier\", &code->expr->where);\n \t  break;\n \n \tcase EXEC_ASSIGN:\n@@ -4600,7 +4651,6 @@ resolve_values (gfc_symbol * sym)\n static try\n resolve_index_expr (gfc_expr * e)\n {\n-\n   if (gfc_resolve_expr (e) == FAILURE)\n     return FAILURE;\n \n@@ -4623,9 +4673,12 @@ resolve_charlen (gfc_charlen *cl)\n \n   cl->resolved = 1;\n \n+  resolving_index_expr = 1;\n+\n   if (resolve_index_expr (cl->length) == FAILURE)\n     return FAILURE;\n \n+  resolving_index_expr = 0;\n   return SUCCESS;\n }\n \n@@ -4712,20 +4765,29 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n   if (resolve_fl_var_and_proc (sym, mp_flag) == FAILURE)\n     return FAILURE;\n \n-  /* The shape of a main program or module array needs to be constant.  */\n-  if (sym->ns->proc_name\n-\t&& (sym->ns->proc_name->attr.flavor == FL_MODULE\n-\t     || sym->ns->proc_name->attr.is_main_program)\n-\t&& !sym->attr.use_assoc\n+  /* Set this flag to check that variables are parameters of all entries.\n+     This check is effected by the call to gfc_resolve_expr through\n+     is_non_contant_shape_array.  */\n+  resolving_index_expr = 1;\n+\n+  if (!sym->attr.use_assoc\n \t&& !sym->attr.allocatable\n \t&& !sym->attr.pointer\n \t&& is_non_constant_shape_array (sym))\n     {\n-       gfc_error (\"The module or main program array '%s' at %L must \"\n-\t\t     \"have constant shape\", sym->name, &sym->declared_at);\n-\t  return FAILURE;\n+\t/* The shape of a main program or module array needs to be constant.  */\n+\tif (sym->ns->proc_name\n+\t      && (sym->ns->proc_name->attr.flavor == FL_MODULE\n+\t\t    || sym->ns->proc_name->attr.is_main_program))\n+\t  {\n+\t    gfc_error (\"The module or main program array '%s' at %L must \"\n+\t\t       \"have constant shape\", sym->name, &sym->declared_at);\n+\t    return FAILURE;\n+\t  }\n     }\n \n+  resolving_index_expr = 0;\n+\n   if (sym->ts.type == BT_CHARACTER)\n     {\n       /* Make sure that character string variables with assumed length are"}, {"sha": "1c3b1a85bf0b5ff726288ef882ff8985aab539ad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b6398823e7ff715272f35ceae58da3d3219523cc", "patch": "@@ -1,3 +1,14 @@\n+2006-05-15  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25090\n+\t* gfortran.dg/entry_dummy_ref_1.f90: New test.\n+\n+\tPR fortran/25082\n+\t* gfortran.dg/scalar_return_1.f90: New test.\n+\n+\tPR fortran/24711\n+\t* gfortran.dg/derived_comp_array_ref_1.f90: New test.\n+\n 2006-05-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/gomp/critical-4.c: New test."}, {"sha": "1a868f3910e2cc639dff655806705668cf5786ca", "filename": "gcc/testsuite/gfortran.dg/derived_comp_array_ref_1.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_comp_array_ref_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_comp_array_ref_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_comp_array_ref_1.f90?ref=b6398823e7ff715272f35ceae58da3d3219523cc", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do run }\n+! Tests the fix for PR27411, in which the array reference on line\n+! 18 caused an ICE because the derived type, rather than its integer\n+! component, was appearing in the index expression.\n+!\n+! Contributed by Richard Maine  <1fhcwee02@sneakemail.com>\n+!\n+module gd_calc\n+  type calc_signal_type\n+    integer :: dummy\n+    logical :: used\n+    integer :: signal_number\n+  end type\n+contains\n+  subroutine activate_gd_calcs (used, outputs)\n+    logical, intent(inout) :: used(:)\n+    type(calc_signal_type), pointer :: outputs(:)\n+      outputs%used = used(outputs%signal_number)\n+    return\n+  end subroutine activate_gd_calcs\n+end module gd_calc\n+\n+  use gd_calc\n+  integer, parameter :: ndim = 4\n+  integer :: i\n+  logical :: used_(ndim)\n+  type(calc_signal_type), pointer :: outputs_(:)\n+  allocate (outputs_(ndim))\n+  forall (i = 1:ndim) outputs_(i)%signal_number = ndim + 1 - i\n+  used_ = (/.true., .false., .true., .true./)\n+  call activate_gd_calcs (used_, outputs_)\n+  if (any (outputs_(ndim:1:-1)%used .neqv. used_)) call abort ()\n+end\n+\n+! { dg-final { cleanup-modules \"gd_calc\" } }"}, {"sha": "c6ee1cc606013699a3fc3fed8e6cdbfea95509bc", "filename": "gcc/testsuite/gfortran.dg/entry_dummy_ref_1.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_dummy_ref_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_dummy_ref_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_dummy_ref_1.f90?ref=b6398823e7ff715272f35ceae58da3d3219523cc", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! Tests fix for PR25090 in which references in specification\n+! expressions to variables that were not entry formal arguments\n+! would be missed.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+   SUBROUTINE S1(I) ! { dg-error \"must be a parameter of the entry\" }\n+   CHARACTER(LEN=I+J) :: a ! { dg-error \"must be a parameter of the entry\" }\n+   real :: x(i:j) ! { dg-error \"must be a parameter of the entry\" }\n+   ENTRY E1(J) ! { dg-error \"must be a parameter of the entry\" }\n+   END SUBROUTINE S1\n+   END"}, {"sha": "d7583bc10b446412d8ac55ab3bce122775ea0112", "filename": "gcc/testsuite/gfortran.dg/scalar_return_1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ftestsuite%2Fgfortran.dg%2Fscalar_return_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6398823e7ff715272f35ceae58da3d3219523cc/gcc%2Ftestsuite%2Fgfortran.dg%2Fscalar_return_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fscalar_return_1.f90?ref=b6398823e7ff715272f35ceae58da3d3219523cc", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+! tests the fix for pr25082 in which the return of an array by a\n+! subroutine went undremarked.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+SUBROUTINE S1(*)\n+INTEGER :: a(2)\n+RETURN a ! { dg-error \" requires a SCALAR\" }\n+END SUBROUTINE S1"}]}