{"sha": "11309337c4056975c0fbd83a8caee7663617bef2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEzMDkzMzdjNDA1Njk3NWMwZmJkODNhOGNhZWU3NjYzNjE3YmVmMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-05-31T21:42:53Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-05-31T21:42:53Z"}, "message": "libgo: update to Go 1.10.2 release\n    \n    Reviewed-on: https://go-review.googlesource.com/115196\n\nFrom-SVN: r261041", "tree": {"sha": "1d3b985ef7b1360b336c30a1d687a849a70ecc4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d3b985ef7b1360b336c30a1d687a849a70ecc4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11309337c4056975c0fbd83a8caee7663617bef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11309337c4056975c0fbd83a8caee7663617bef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11309337c4056975c0fbd83a8caee7663617bef2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11309337c4056975c0fbd83a8caee7663617bef2/comments", "author": null, "committer": null, "parents": [{"sha": "8b0b334af3439179947522206b2478a28b908e61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b0b334af3439179947522206b2478a28b908e61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b0b334af3439179947522206b2478a28b908e61"}], "stats": {"total": 1011, "additions": 853, "deletions": 158}, "files": [{"sha": "618004c6d8d084d5f03d56e812135aa03ccb955d", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -1,4 +1,4 @@\n-9731580e76c065b76e3a103356bb8920da05a685\n+79eca4fd642724d89e9bec8f79889451f6632a46\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "6f31fab2265ac6f1fae341f7541a63a9bffab357", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -1,4 +1,4 @@\n-bf86aec25972f3a100c3aa58a6abcbcc35bdea49\n+71bdbf431b79dff61944f22c25c7e085ccfc25d5\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "98736c7cde066677a1e9093df736db72d765e37d", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -1 +1 @@\n-go1.10\n+go1.10.2"}, {"sha": "82a08c6554d26d17b094cec4098a8b81d4b11552", "filename": "libgo/check-packages.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fcheck-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fcheck-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fcheck-packages.txt?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -122,6 +122,7 @@ net/http/httptest\n net/http/httptrace\n net/http/httputil\n net/http/internal\n+net/http/pprof\n net/internal/socktest\n net/mail\n net/rpc"}, {"sha": "2444106ba69e9e9b2fc194933b4d39b89ab311f2", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -366,7 +366,7 @@ parseExtras:\n \t\t\t\tepoch := time.Date(1601, time.January, 1, 0, 0, 0, 0, time.UTC)\n \t\t\t\tmodified = time.Unix(epoch.Unix()+secs, nsecs)\n \t\t\t}\n-\t\tcase unixExtraID:\n+\t\tcase unixExtraID, infoZipUnixExtraID:\n \t\t\tif len(fieldBuf) < 8 {\n \t\t\t\tcontinue parseExtras\n \t\t\t}\n@@ -379,12 +379,6 @@ parseExtras:\n \t\t\t}\n \t\t\tts := int64(fieldBuf.uint32()) // ModTime since Unix epoch\n \t\t\tmodified = time.Unix(ts, 0)\n-\t\tcase infoZipUnixExtraID:\n-\t\t\tif len(fieldBuf) < 4 {\n-\t\t\t\tcontinue parseExtras\n-\t\t\t}\n-\t\t\tts := int64(fieldBuf.uint32()) // ModTime since Unix epoch\n-\t\t\tmodified = time.Unix(ts, 0)\n \t\t}\n \t}\n "}, {"sha": "1e58b26b6e981cce0cf7578957050f30c914d2b9", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -414,7 +414,7 @@ var tests = []ZipTest{\n \t\t\t\tName:     \"test.txt\",\n \t\t\t\tContent:  []byte{},\n \t\t\t\tSize:     1<<32 - 1,\n-\t\t\t\tModified: time.Date(2017, 10, 31, 21, 17, 27, 0, timeZone(-7*time.Hour)),\n+\t\t\t\tModified: time.Date(2017, 10, 31, 21, 11, 57, 0, timeZone(-7*time.Hour)),\n \t\t\t\tMode:     0644,\n \t\t\t},\n \t\t},"}, {"sha": "f6d6f4250eb903cfe734dc2f2826902ac0f4d8f7", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -3265,6 +3265,20 @@ func TestGoVetWithOnlyTestFiles(t *testing.T) {\n \ttg.run(\"vet\", \"p\")\n }\n \n+// Issue 24193.\n+func TestVetWithOnlyCgoFiles(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"src/p/p.go\", \"package p; import \\\"C\\\"; func F() {}\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"vet\", \"p\")\n+}\n+\n // Issue 9767, 19769.\n func TestGoGetDotSlashDownload(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n@@ -5099,6 +5113,28 @@ func TestCacheOutput(t *testing.T) {\n \t}\n }\n \n+func TestCacheListStale(t *testing.T) {\n+\ttooSlow(t)\n+\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\t\tt.Skip(\"GODEBUG gocacheverify\")\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOCACHE\", tg.path(\"cache\"))\n+\ttg.tempFile(\"gopath/src/p/p.go\", \"package p; import _ \\\"q\\\"; func F(){}\\n\")\n+\ttg.tempFile(\"gopath/src/q/q.go\", \"package q; func F(){}\\n\")\n+\ttg.tempFile(\"gopath/src/m/m.go\", \"package main; import _ \\\"q\\\"; func main(){}\\n\")\n+\n+\ttg.setenv(\"GOPATH\", tg.path(\"gopath\"))\n+\ttg.run(\"install\", \"p\", \"m\")\n+\ttg.run(\"list\", \"-f={{.ImportPath}} {{.Stale}}\", \"m\", \"q\", \"p\")\n+\ttg.grepStdout(\"^m false\", \"m should not be stale\")\n+\ttg.grepStdout(\"^q true\", \"q should be stale\")\n+\ttg.grepStdout(\"^p false\", \"p should not be stale\")\n+}\n+\n func TestCacheCoverage(t *testing.T) {\n \ttooSlow(t)\n \n@@ -5792,6 +5828,22 @@ func TestAtomicCoverpkgAll(t *testing.T) {\n \t}\n }\n \n+// Issue 23882.\n+func TestCoverpkgAllRuntime(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\n+\ttg.tempFile(\"src/x/x.go\", `package x; import _ \"runtime\"; func F() {}`)\n+\ttg.tempFile(\"src/x/x_test.go\", `package x; import \"testing\"; func TestF(t *testing.T) { F() }`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"test\", \"-coverpkg=all\", \"x\")\n+\tif canRace {\n+\t\ttg.run(\"test\", \"-coverpkg=all\", \"-race\", \"x\")\n+\t}\n+}\n+\n func TestBadCommandLines(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -5949,3 +6001,36 @@ func TestBadCgoDirectives(t *testing.T) {\n \ttg.run(\"build\", \"-n\", \"x\")\n \ttg.grepStderr(\"-D@foo\", \"did not find -D@foo in commands\")\n }\n+\n+func TestTwoPkgConfigs(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"no cgo\")\n+\t}\n+\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n+\t\tt.Skipf(\"no shell scripts on %s\", runtime.GOOS)\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"src/x/a.go\", `package x\n+\t\t// #cgo pkg-config: --static a\n+\t\timport \"C\"\n+\t`)\n+\ttg.tempFile(\"src/x/b.go\", `package x\n+\t\t// #cgo pkg-config: --static a\n+\t\timport \"C\"\n+\t`)\n+\ttg.tempFile(\"pkg-config.sh\", `#!/bin/sh\n+echo $* >>`+tg.path(\"pkg-config.out\"))\n+\ttg.must(os.Chmod(tg.path(\"pkg-config.sh\"), 0755))\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.setenv(\"PKG_CONFIG\", tg.path(\"pkg-config.sh\"))\n+\ttg.run(\"build\", \"x\")\n+\tout, err := ioutil.ReadFile(tg.path(\"pkg-config.out\"))\n+\ttg.must(err)\n+\tout = bytes.TrimSpace(out)\n+\twant := \"--cflags --static --static -- a a\\n--libs --static --static -- a a\"\n+\tif !bytes.Equal(out, []byte(want)) {\n+\t\tt.Errorf(\"got %q want %q\", out, want)\n+\t}\n+}"}, {"sha": "0b2a04e04f81ba472dedcf3058be87831dd7bd09", "filename": "libgo/go/cmd/go/internal/get/vcs.go", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -809,8 +809,8 @@ func repoRootForImportDynamic(importPath string, security web.SecurityMode) (*re\n \t\t}\n \t}\n \n-\tif !strings.Contains(mmi.RepoRoot, \"://\") {\n-\t\treturn nil, fmt.Errorf(\"%s: invalid repo root %q; no scheme\", urlStr, mmi.RepoRoot)\n+\tif err := validateRepoRootScheme(mmi.RepoRoot); err != nil {\n+\t\treturn nil, fmt.Errorf(\"%s: invalid repo root %q: %v\", urlStr, mmi.RepoRoot, err)\n \t}\n \trr := &repoRoot{\n \t\tvcs:      vcsByCmd(mmi.VCS),\n@@ -824,6 +824,36 @@ func repoRootForImportDynamic(importPath string, security web.SecurityMode) (*re\n \treturn rr, nil\n }\n \n+// validateRepoRootScheme returns an error if repoRoot does not seem\n+// to have a valid URL scheme. At this point we permit things that\n+// aren't valid URLs, although later, if not using -insecure, we will\n+// restrict repoRoots to be valid URLs. This is only because we've\n+// historically permitted them, and people may depend on that.\n+func validateRepoRootScheme(repoRoot string) error {\n+\tend := strings.Index(repoRoot, \"://\")\n+\tif end <= 0 {\n+\t\treturn errors.New(\"no scheme\")\n+\t}\n+\n+\t// RFC 3986 section 3.1.\n+\tfor i := 0; i < end; i++ {\n+\t\tc := repoRoot[i]\n+\t\tswitch {\n+\t\tcase 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z':\n+\t\t\t// OK.\n+\t\tcase '0' <= c && c <= '9' || c == '+' || c == '-' || c == '.':\n+\t\t\t// OK except at start.\n+\t\t\tif i == 0 {\n+\t\t\t\treturn errors.New(\"invalid scheme\")\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn errors.New(\"invalid scheme\")\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n var fetchGroup singleflight.Group\n var (\n \tfetchCacheMu sync.Mutex"}, {"sha": "a6f8642026cc12dffef168b54f710d4bd8295a2d", "filename": "libgo/go/cmd/go/internal/get/vcs_test.go", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -408,3 +408,46 @@ func TestMatchGoImport(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestValidateRepoRootScheme(t *testing.T) {\n+\ttests := []struct {\n+\t\troot string\n+\t\terr  string\n+\t}{\n+\t\t{\n+\t\t\troot: \"\",\n+\t\t\terr:  \"no scheme\",\n+\t\t},\n+\t\t{\n+\t\t\troot: \"http://\",\n+\t\t\terr:  \"\",\n+\t\t},\n+\t\t{\n+\t\t\troot: \"a://\",\n+\t\t\terr:  \"\",\n+\t\t},\n+\t\t{\n+\t\t\troot: \"a#://\",\n+\t\t\terr:  \"invalid scheme\",\n+\t\t},\n+\t\t{\n+\t\t\troot: \"-config://\",\n+\t\t\terr:  \"invalid scheme\",\n+\t\t},\n+\t}\n+\n+\tfor _, test := range tests {\n+\t\terr := validateRepoRootScheme(test.root)\n+\t\tif err == nil {\n+\t\t\tif test.err != \"\" {\n+\t\t\t\tt.Errorf(\"validateRepoRootScheme(%q) = nil, want %q\", test.root, test.err)\n+\t\t\t}\n+\t\t} else if test.err == \"\" {\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"validateRepoRootScheme(%q) = %q, want nil\", test.root, test.err)\n+\t\t\t}\n+\t\t} else if err.Error() != test.err {\n+\t\t\tt.Errorf(\"validateRepoRootScheme(%q) = %q, want %q\", test.root, err, test.err)\n+\t\t}\n+\t}\n+}"}, {"sha": "72415ccd095062aa9bebb212ec7310c663b7f834", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -673,6 +673,14 @@ func runTest(cmd *base.Command, args []string) {\n \t\t\t\tcontinue\n \t\t\t}\n \n+\t\t\t// If using the race detector, silently ignore\n+\t\t\t// attempts to run coverage on the runtime\n+\t\t\t// packages. It will cause the race detector\n+\t\t\t// to be invoked before it has been initialized.\n+\t\t\tif cfg.BuildRace && p.Standard && (p.ImportPath == \"runtime\" || strings.HasPrefix(p.ImportPath, \"runtime/internal\")) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n \t\t\tif haveMatch {\n \t\t\t\ttestCoverPkgs = append(testCoverPkgs, p)\n \t\t\t}"}, {"sha": "a737ebd669ffcc8dae856c8f0b191f48c987aca3", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -62,11 +62,11 @@ func runVet(cmd *base.Command, args []string) {\n \t\t\tbase.Errorf(\"%v\", err)\n \t\t\tcontinue\n \t\t}\n-\t\tif len(ptest.GoFiles) == 0 && pxtest == nil {\n+\t\tif len(ptest.GoFiles) == 0 && len(ptest.CgoFiles) == 0 && pxtest == nil {\n \t\t\tbase.Errorf(\"go vet %s: no Go files in %s\", p.ImportPath, p.Dir)\n \t\t\tcontinue\n \t\t}\n-\t\tif len(ptest.GoFiles) > 0 {\n+\t\tif len(ptest.GoFiles) > 0 || len(ptest.CgoFiles) > 0 {\n \t\t\troot.Deps = append(root.Deps, b.VetAction(work.ModeBuild, work.ModeBuild, ptest))\n \t\t}\n \t\tif pxtest != nil {"}, {"sha": "733938e0adebd5155ca53da8cd5fd3620d2a5628", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -461,15 +461,7 @@ func (b *Builder) useCache(a *Action, p *load.Package, actionHash cache.ActionID\n \t// If so, it's up to date and we can reuse it instead of rebuilding it.\n \tvar buildID string\n \tif target != \"\" && !cfg.BuildA {\n-\t\tvar err error\n-\t\tbuildID, err = buildid.ReadFile(target)\n-\t\tif err != nil && b.ComputeStaleOnly {\n-\t\t\tif p != nil && !p.Stale {\n-\t\t\t\tp.Stale = true\n-\t\t\t\tp.StaleReason = \"target missing\"\n-\t\t\t}\n-\t\t\treturn true\n-\t\t}\n+\t\tbuildID, _ = buildid.ReadFile(target)\n \t\tif strings.HasPrefix(buildID, actionID+buildIDSeparator) {\n \t\t\ta.buildID = buildID\n \t\t\ta.built = target\n@@ -546,7 +538,10 @@ func (b *Builder) useCache(a *Action, p *load.Package, actionHash cache.ActionID\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\treturn true\n+\n+\t\t// Fall through to update a.buildID from the build artifact cache,\n+\t\t// which will affect the computation of buildIDs for targets\n+\t\t// higher up in the dependency graph.\n \t}\n \n \t// Check the build artifact cache.\n@@ -574,6 +569,10 @@ func (b *Builder) useCache(a *Action, p *load.Package, actionHash cache.ActionID\n \t\t\t\t\t\ta.built = file\n \t\t\t\t\t\ta.Target = \"DO NOT USE - using cache\"\n \t\t\t\t\t\ta.buildID = buildID\n+\t\t\t\t\t\tif p := a.Package; p != nil {\n+\t\t\t\t\t\t\t// Clearer than explaining that something else is stale.\n+\t\t\t\t\t\t\tp.StaleReason = \"not installed but available in build cache\"\n+\t\t\t\t\t\t}\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -584,6 +583,10 @@ func (b *Builder) useCache(a *Action, p *load.Package, actionHash cache.ActionID\n \t\ta.output = []byte{}\n \t}\n \n+\tif b.ComputeStaleOnly {\n+\t\treturn true\n+\t}\n+\n \treturn false\n }\n "}, {"sha": "5994dbc702f1b1791d54eed56d6bb9c91da0526b", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -956,11 +956,19 @@ func splitPkgConfigOutput(out []byte) []string {\n \n // Calls pkg-config if needed and returns the cflags/ldflags needed to build the package.\n func (b *Builder) getPkgConfigFlags(p *load.Package) (cflags, ldflags []string, err error) {\n-\tif pkgs := p.CgoPkgConfig; len(pkgs) > 0 {\n+\tif pcargs := p.CgoPkgConfig; len(pcargs) > 0 {\n+\t\t// pkg-config permits arguments to appear anywhere in\n+\t\t// the command line. Move them all to the front, before --.\n \t\tvar pcflags []string\n-\t\tfor len(pkgs) > 0 && strings.HasPrefix(pkgs[0], \"--\") {\n-\t\t\tpcflags = append(pcflags, pkgs[0])\n-\t\t\tpkgs = pkgs[1:]\n+\t\tvar pkgs []string\n+\t\tfor _, pcarg := range pcargs {\n+\t\t\tif pcarg == \"--\" {\n+\t\t\t\t// We're going to add our own \"--\" argument.\n+\t\t\t} else if strings.HasPrefix(pcarg, \"--\") {\n+\t\t\t\tpcflags = append(pcflags, pcarg)\n+\t\t\t} else {\n+\t\t\t\tpkgs = append(pkgs, pcarg)\n+\t\t\t}\n \t\t}\n \t\tfor _, pkg := range pkgs {\n \t\t\tif !load.SafeArg(pkg) {\n@@ -1107,7 +1115,7 @@ func BuildInstallFunc(b *Builder, a *Action) (err error) {\n \t\t// We want to hide that awful detail as much as possible, so don't\n \t\t// advertise it by touching the mtimes (usually the libraries are up\n \t\t// to date).\n-\t\tif !a.buggyInstall {\n+\t\tif !a.buggyInstall && !b.ComputeStaleOnly {\n \t\t\tnow := time.Now()\n \t\t\tos.Chtimes(a.Target, now, now)\n \t\t}"}, {"sha": "5c67aa945eff71d0fd926adf2b35240c8df89e5f", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -46,12 +46,19 @@ var validCompilerFlags = []*regexp.Regexp{\n \tre(`-O([^@\\-].*)`),\n \tre(`-W`),\n \tre(`-W([^@,]+)`), // -Wall but not -Wa,-foo.\n+\tre(`-Wa,-mbig-obj`),\n+\tre(`-ansi`),\n \tre(`-f(no-)?blocks`),\n \tre(`-f(no-)?common`),\n \tre(`-f(no-)?constant-cfstrings`),\n+\tre(`-fdiagnostics-show-note-include-stack`),\n \tre(`-f(no-)?exceptions`),\n+\tre(`-f(no-)?inline-functions`),\n \tre(`-finput-charset=([^@\\-].*)`),\n+\tre(`-f(no-)?fat-lto-objects`),\n \tre(`-f(no-)?lto`),\n+\tre(`-fmacro-backtrace-limit=(.+)`),\n+\tre(`-fmessage-length=(.+)`),\n \tre(`-f(no-)?modules`),\n \tre(`-f(no-)?objc-arc`),\n \tre(`-f(no-)?omit-frame-pointer`),\n@@ -62,71 +69,108 @@ var validCompilerFlags = []*regexp.Regexp{\n \tre(`-f(no-)?split-stack`),\n \tre(`-f(no-)?stack-(.+)`),\n \tre(`-f(no-)?strict-aliasing`),\n+\tre(`-f(un)signed-char`),\n+\tre(`-f(no-)?use-linker-plugin`), // safe if -B is not used; we don't permit -B\n \tre(`-fsanitize=(.+)`),\n+\tre(`-ftemplate-depth-(.+)`),\n+\tre(`-fvisibility=(.+)`),\n \tre(`-g([^@\\-].*)?`),\n+\tre(`-m32`),\n+\tre(`-m64`),\n \tre(`-m(arch|cpu|fpu|tune)=([^@\\-].*)`),\n \tre(`-m(no-)?avx[0-9a-z.]*`),\n \tre(`-m(no-)?ms-bitfields`),\n \tre(`-m(no-)?stack-(.+)`),\n \tre(`-mmacosx-(.+)`),\n+\tre(`-mios-simulator-version-min=(.+)`),\n+\tre(`-miphoneos-version-min=(.+)`),\n \tre(`-mnop-fun-dllimport`),\n \tre(`-m(no-)?sse[0-9.]*`),\n+\tre(`-mwindows`),\n \tre(`-pedantic(-errors)?`),\n \tre(`-pipe`),\n \tre(`-pthread`),\n \tre(`-?-std=([^@\\-].*)`),\n+\tre(`-?-stdlib=([^@\\-].*)`),\n+\tre(`-w`),\n \tre(`-x([^@\\-].*)`),\n }\n \n var validCompilerFlagsWithNextArg = []string{\n+\t\"-arch\",\n \t\"-D\",\n \t\"-I\",\n-\t\"-isystem\",\n \t\"-framework\",\n+\t\"-isysroot\",\n+\t\"-isystem\",\n+\t\"--sysroot\",\n+\t\"-target\",\n \t\"-x\",\n }\n \n var validLinkerFlags = []*regexp.Regexp{\n \tre(`-F([^@\\-].*)`),\n \tre(`-l([^@\\-].*)`),\n \tre(`-L([^@\\-].*)`),\n+\tre(`-O`),\n+\tre(`-O([^@\\-].*)`),\n \tre(`-f(no-)?(pic|PIC|pie|PIE)`),\n \tre(`-fsanitize=([^@\\-].*)`),\n \tre(`-g([^@\\-].*)?`),\n \tre(`-m(arch|cpu|fpu|tune)=([^@\\-].*)`),\n+\tre(`-mmacosx-(.+)`),\n+\tre(`-mios-simulator-version-min=(.+)`),\n+\tre(`-miphoneos-version-min=(.+)`),\n+\tre(`-mwindows`),\n \tre(`-(pic|PIC|pie|PIE)`),\n \tre(`-pthread`),\n+\tre(`-shared`),\n \tre(`-?-static([-a-z0-9+]*)`),\n+\tre(`-?-stdlib=([^@\\-].*)`),\n \n \t// Note that any wildcards in -Wl need to exclude comma,\n \t// since -Wl splits its argument at commas and passes\n \t// them all to the linker uninterpreted. Allowing comma\n \t// in a wildcard would allow tunnelling arbitrary additional\n \t// linker arguments through one of these.\n+\tre(`-Wl,--(no-)?allow-multiple-definition`),\n \tre(`-Wl,--(no-)?as-needed`),\n \tre(`-Wl,-Bdynamic`),\n \tre(`-Wl,-Bstatic`),\n+\tre(`-Wl,-d[ny]`),\n \tre(`-Wl,--disable-new-dtags`),\n \tre(`-Wl,--enable-new-dtags`),\n \tre(`-Wl,--end-group`),\n \tre(`-Wl,-framework,[^,@\\-][^,]+`),\n \tre(`-Wl,-headerpad_max_install_names`),\n \tre(`-Wl,--no-undefined`),\n-\tre(`-Wl,-rpath,([^,@\\-][^,]+)`),\n+\tre(`-Wl,-rpath[=,]([^,@\\-][^,]+)`),\n \tre(`-Wl,-search_paths_first`),\n+\tre(`-Wl,-sectcreate,([^,@\\-][^,]+),([^,@\\-][^,]+),([^,@\\-][^,]+)`),\n \tre(`-Wl,--start-group`),\n+\tre(`-Wl,-?-static`),\n+\tre(`-Wl,--subsystem,(native|windows|console|posix|xbox)`),\n+\tre(`-Wl,-undefined[=,]([^,@\\-][^,]+)`),\n \tre(`-Wl,-?-unresolved-symbols=[^,]+`),\n \tre(`-Wl,--(no-)?warn-([^,]+)`),\n+\tre(`-Wl,-z,(no)?execstack`),\n+\tre(`-Wl,-z,relro`),\n \n \tre(`[a-zA-Z0-9_/].*\\.(a|o|obj|dll|dylib|so)`), // direct linker inputs: x.o or libfoo.so (but not -foo.o or @foo.o)\n }\n \n var validLinkerFlagsWithNextArg = []string{\n+\t\"-arch\",\n \t\"-F\",\n \t\"-l\",\n \t\"-L\",\n \t\"-framework\",\n+\t\"-isysroot\",\n+\t\"--sysroot\",\n+\t\"-target\",\n \t\"-Wl,-framework\",\n+\t\"-Wl,-rpath\",\n+\t\"-Wl,-undefined\",\n }\n \n func checkCompilerFlags(name, source string, list []string) error {"}, {"sha": "bd898c9de6c17dabd670df76d5799363235753cb", "filename": "libgo/go/cmd/go/internal/work/security_test.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -140,9 +140,6 @@ var goodLinkerFlags = [][]string{\n var badLinkerFlags = [][]string{\n \t{\"-DFOO\"},\n \t{\"-Dfoo=bar\"},\n-\t{\"-O\"},\n-\t{\"-O2\"},\n-\t{\"-Osmall\"},\n \t{\"-W\"},\n \t{\"-Wall\"},\n \t{\"-fobjc-arc\"},\n@@ -155,7 +152,6 @@ var badLinkerFlags = [][]string{\n \t{\"-fno-stack-xxx\"},\n \t{\"-mstack-overflow\"},\n \t{\"-mno-stack-overflow\"},\n-\t{\"-mmacosx-version\"},\n \t{\"-mnop-fun-dllimport\"},\n \t{\"-std=c99\"},\n \t{\"-xc\"},"}, {"sha": "55f1328ba8462a52e0c2f1104ffc060a1080c984", "filename": "libgo/go/cmd/internal/objabi/funcid.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncid.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package objabi\n+\n+// A FuncID identifies particular functions that need to be treated\n+// specially by the runtime.\n+// Note that in some situations involving plugins, there may be multiple\n+// copies of a particular special runtime function.\n+// Note: this list must match the list in runtime/symtab.go.\n+type FuncID uint32\n+\n+const (\n+\tFuncID_normal FuncID = iota // not a special function\n+\tFuncID_goexit\n+\tFuncID_jmpdefer\n+\tFuncID_mcall\n+\tFuncID_morestack\n+\tFuncID_mstart\n+\tFuncID_rt0_go\n+\tFuncID_asmcgocall\n+\tFuncID_sigpanic\n+\tFuncID_runfinq\n+\tFuncID_bgsweep\n+\tFuncID_forcegchelper\n+\tFuncID_timerproc\n+\tFuncID_gcBgMarkWorker\n+\tFuncID_systemstack_switch\n+\tFuncID_systemstack\n+\tFuncID_cgocallback_gofunc\n+\tFuncID_gogo\n+\tFuncID_externalthreadhandler\n+)"}, {"sha": "bad488f89fb47958276a7fbacd81e083a7b16183", "filename": "libgo/go/crypto/x509/name_constraints_test.go", "status": "modified", "additions": 129, "deletions": 6, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcrypto%2Fx509%2Fname_constraints_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcrypto%2Fx509%2Fname_constraints_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fname_constraints_test.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"crypto/rand\"\n \t\"crypto/x509/pkix\"\n \t\"encoding/asn1\"\n+\t\"encoding/hex\"\n \t\"encoding/pem\"\n \t\"fmt\"\n \t\"io/ioutil\"\n@@ -42,6 +43,7 @@ type nameConstraintsTest struct {\n \troots         []constraintsSpec\n \tintermediates [][]constraintsSpec\n \tleaf          leafSpec\n+\trequestedEKUs []ExtKeyUsage\n \texpectedError string\n \tnoOpenSSL     bool\n }\n@@ -1444,6 +1446,118 @@ var nameConstraintsTests = []nameConstraintsTest{\n \t\t},\n \t\texpectedError: \"\\\"https://example.com/test\\\" is excluded\",\n \t},\n+\n+\t// #75: While serverAuth in a CA certificate permits clientAuth in a leaf,\n+\t// serverAuth in a leaf shouldn't permit clientAuth when requested in\n+\t// VerifyOptions.\n+\tnameConstraintsTest{\n+\t\troots: []constraintsSpec{\n+\t\t\tconstraintsSpec{},\n+\t\t},\n+\t\tintermediates: [][]constraintsSpec{\n+\t\t\t[]constraintsSpec{\n+\t\t\t\tconstraintsSpec{},\n+\t\t\t},\n+\t\t},\n+\t\tleaf: leafSpec{\n+\t\t\tsans: []string{\"dns:example.com\"},\n+\t\t\tekus: []string{\"serverAuth\"},\n+\t\t},\n+\t\trequestedEKUs: []ExtKeyUsage{ExtKeyUsageClientAuth},\n+\t\texpectedError: \"incompatible key usage\",\n+\t},\n+\n+\t// #76: However, MSSGC in a leaf should match a request for serverAuth.\n+\tnameConstraintsTest{\n+\t\troots: []constraintsSpec{\n+\t\t\tconstraintsSpec{},\n+\t\t},\n+\t\tintermediates: [][]constraintsSpec{\n+\t\t\t[]constraintsSpec{\n+\t\t\t\tconstraintsSpec{},\n+\t\t\t},\n+\t\t},\n+\t\tleaf: leafSpec{\n+\t\t\tsans: []string{\"dns:example.com\"},\n+\t\t\tekus: []string{\"msSGC\"},\n+\t\t},\n+\t\trequestedEKUs: []ExtKeyUsage{ExtKeyUsageServerAuth},\n+\t},\n+\n+\t// An invalid DNS SAN should be detected only at validation time so\n+\t// that we can process CA certificates in the wild that have invalid SANs.\n+\t// See https://github.com/golang/go/issues/23995\n+\n+\t// #77: an invalid DNS or mail SAN will not be detected if name constaint\n+\t// checking is not triggered.\n+\tnameConstraintsTest{\n+\t\troots: []constraintsSpec{\n+\t\t\tconstraintsSpec{},\n+\t\t},\n+\t\tintermediates: [][]constraintsSpec{\n+\t\t\t[]constraintsSpec{\n+\t\t\t\tconstraintsSpec{},\n+\t\t\t},\n+\t\t},\n+\t\tleaf: leafSpec{\n+\t\t\tsans: []string{\"dns:this is invalid\", \"email:this @ is invalid\"},\n+\t\t},\n+\t},\n+\n+\t// #78: an invalid DNS SAN will be detected if any name constraint checking\n+\t// is triggered.\n+\tnameConstraintsTest{\n+\t\troots: []constraintsSpec{\n+\t\t\tconstraintsSpec{\n+\t\t\t\tbad: []string{\"uri:\"},\n+\t\t\t},\n+\t\t},\n+\t\tintermediates: [][]constraintsSpec{\n+\t\t\t[]constraintsSpec{\n+\t\t\t\tconstraintsSpec{},\n+\t\t\t},\n+\t\t},\n+\t\tleaf: leafSpec{\n+\t\t\tsans: []string{\"dns:this is invalid\"},\n+\t\t},\n+\t\texpectedError: \"cannot parse dnsName\",\n+\t},\n+\n+\t// #79: an invalid email SAN will be detected if any name constraint\n+\t// checking is triggered.\n+\tnameConstraintsTest{\n+\t\troots: []constraintsSpec{\n+\t\t\tconstraintsSpec{\n+\t\t\t\tbad: []string{\"uri:\"},\n+\t\t\t},\n+\t\t},\n+\t\tintermediates: [][]constraintsSpec{\n+\t\t\t[]constraintsSpec{\n+\t\t\t\tconstraintsSpec{},\n+\t\t\t},\n+\t\t},\n+\t\tleaf: leafSpec{\n+\t\t\tsans: []string{\"email:this @ is invalid\"},\n+\t\t},\n+\t\texpectedError: \"cannot parse rfc822Name\",\n+\t},\n+\n+\t// #80: if several EKUs are requested, satisfying any of them is sufficient.\n+\tnameConstraintsTest{\n+\t\troots: []constraintsSpec{\n+\t\t\tconstraintsSpec{},\n+\t\t},\n+\t\tintermediates: [][]constraintsSpec{\n+\t\t\t[]constraintsSpec{\n+\t\t\t\tconstraintsSpec{},\n+\t\t\t},\n+\t\t},\n+\t\tleaf: leafSpec{\n+\t\t\tsans: []string{\"dns:example.com\"},\n+\t\t\tekus: []string{\"email\"},\n+\t\t},\n+\t\trequestedEKUs: []ExtKeyUsage{ExtKeyUsageClientAuth, ExtKeyUsageEmailProtection},\n+\t},\n }\n \n func makeConstraintsCACert(constraints constraintsSpec, name string, key *ecdsa.PrivateKey, parent *Certificate, parentKey *ecdsa.PrivateKey) (*Certificate, error) {\n@@ -1459,7 +1573,7 @@ func makeConstraintsCACert(constraints constraintsSpec, name string, key *ecdsa.\n \t\tNotAfter:              time.Unix(2000, 0),\n \t\tKeyUsage:              KeyUsageCertSign,\n \t\tBasicConstraintsValid: true,\n-\t\tIsCA: true,\n+\t\tIsCA:                  true,\n \t}\n \n \tif err := addConstraintsToTemplate(constraints, template); err != nil {\n@@ -1497,7 +1611,7 @@ func makeConstraintsLeafCert(leaf leafSpec, key *ecdsa.PrivateKey, parent *Certi\n \t\tNotAfter:              time.Unix(2000, 0),\n \t\tKeyUsage:              KeyUsageDigitalSignature,\n \t\tBasicConstraintsValid: true,\n-\t\tIsCA: false,\n+\t\tIsCA:                  false,\n \t}\n \n \tfor _, name := range leaf.sans {\n@@ -1512,6 +1626,13 @@ func makeConstraintsLeafCert(leaf leafSpec, key *ecdsa.PrivateKey, parent *Certi\n \t\t\t}\n \t\t\ttemplate.IPAddresses = append(template.IPAddresses, ip)\n \n+\t\tcase strings.HasPrefix(name, \"invalidip:\"):\n+\t\t\tipBytes, err := hex.DecodeString(name[10:])\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"cannot parse invalid IP: %s\", err)\n+\t\t\t}\n+\t\t\ttemplate.IPAddresses = append(template.IPAddresses, net.IP(ipBytes))\n+\n \t\tcase strings.HasPrefix(name, \"email:\"):\n \t\t\ttemplate.EmailAddresses = append(template.EmailAddresses, name[6:])\n \n@@ -1781,6 +1902,7 @@ func TestConstraintCases(t *testing.T) {\n \t\t\tRoots:         rootPool,\n \t\t\tIntermediates: intermediatePool,\n \t\t\tCurrentTime:   time.Unix(1500, 0),\n+\t\t\tKeyUsages:     test.requestedEKUs,\n \t\t}\n \t\t_, err = leafCert.Verify(verifyOpts)\n \n@@ -1972,12 +2094,13 @@ func TestBadNamesInConstraints(t *testing.T) {\n }\n \n func TestBadNamesInSANs(t *testing.T) {\n-\t// Bad names in SANs should not parse.\n+\t// Bad names in URI and IP SANs should not parse. Bad DNS and email SANs\n+\t// will parse and are tested in name constraint tests at the top of this\n+\t// file.\n \tbadNames := []string{\n-\t\t\"dns:foo.com.\",\n-\t\t\"email:abc@foo.com.\",\n-\t\t\"email:foo.com.\",\n \t\t\"uri:https://example.com./dsf\",\n+\t\t\"invalidip:0102\",\n+\t\t\"invalidip:0102030405\",\n \t}\n \n \tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)"}, {"sha": "0ea214bd2e02a9e4996e702dd1fc71d67c2ac0c8", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 68, "deletions": 20, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -6,12 +6,14 @@ package x509\n \n import (\n \t\"bytes\"\n+\t\"encoding/asn1\"\n \t\"errors\"\n \t\"fmt\"\n \t\"net\"\n \t\"net/url\"\n \t\"reflect\"\n \t\"runtime\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"time\"\n \t\"unicode/utf8\"\n@@ -178,10 +180,14 @@ type VerifyOptions struct {\n \tIntermediates *CertPool\n \tRoots         *CertPool // if nil, the system roots are used\n \tCurrentTime   time.Time // if zero, the current time is used\n-\t// KeyUsage specifies which Extended Key Usage values are acceptable.\n-\t// An empty list means ExtKeyUsageServerAuth. Key usage is considered a\n-\t// constraint down the chain which mirrors Windows CryptoAPI behavior,\n-\t// but not the spec. To accept any key usage, include ExtKeyUsageAny.\n+\t// KeyUsage specifies which Extended Key Usage values are acceptable. A leaf\n+\t// certificate is accepted if it contains any of the listed values. An empty\n+\t// list means ExtKeyUsageServerAuth. To accept any key usage, include\n+\t// ExtKeyUsageAny.\n+\t//\n+\t// Certificate chains are required to nest extended key usage values,\n+\t// irrespective of this value. This matches the Windows CryptoAPI behavior,\n+\t// but not the spec.\n \tKeyUsages []ExtKeyUsage\n \t// MaxConstraintComparisions is the maximum number of comparisons to\n \t// perform when checking a given certificate's name constraints. If\n@@ -543,11 +549,16 @@ func (c *Certificate) checkNameConstraints(count *int,\n \treturn nil\n }\n \n+const (\n+\tcheckingAgainstIssuerCert = iota\n+\tcheckingAgainstLeafCert\n+)\n+\n // ekuPermittedBy returns true iff the given extended key usage is permitted by\n // the given EKU from a certificate. Normally, this would be a simple\n // comparison plus a special case for the \u201cany\u201d EKU. But, in order to support\n // existing certificates, some exceptions are made.\n-func ekuPermittedBy(eku, certEKU ExtKeyUsage) bool {\n+func ekuPermittedBy(eku, certEKU ExtKeyUsage, context int) bool {\n \tif certEKU == ExtKeyUsageAny || eku == certEKU {\n \t\treturn true\n \t}\n@@ -564,18 +575,23 @@ func ekuPermittedBy(eku, certEKU ExtKeyUsage) bool {\n \teku = mapServerAuthEKUs(eku)\n \tcertEKU = mapServerAuthEKUs(certEKU)\n \n-\tif eku == certEKU ||\n-\t\t// ServerAuth in a CA permits ClientAuth in the leaf.\n-\t\t(eku == ExtKeyUsageClientAuth && certEKU == ExtKeyUsageServerAuth) ||\n+\tif eku == certEKU {\n+\t\treturn true\n+\t}\n+\n+\t// If checking a requested EKU against the list in a leaf certificate there\n+\t// are fewer exceptions.\n+\tif context == checkingAgainstLeafCert {\n+\t\treturn false\n+\t}\n+\n+\t// ServerAuth in a CA permits ClientAuth in the leaf.\n+\treturn (eku == ExtKeyUsageClientAuth && certEKU == ExtKeyUsageServerAuth) ||\n \t\t// Any CA may issue an OCSP responder certificate.\n \t\teku == ExtKeyUsageOCSPSigning ||\n \t\t// Code-signing CAs can use Microsoft's commercial and\n \t\t// kernel-mode EKUs.\n-\t\t((eku == ExtKeyUsageMicrosoftCommercialCodeSigning || eku == ExtKeyUsageMicrosoftKernelCodeSigning) && certEKU == ExtKeyUsageCodeSigning) {\n-\t\treturn true\n-\t}\n-\n-\treturn false\n+\t\t(eku == ExtKeyUsageMicrosoftCommercialCodeSigning || eku == ExtKeyUsageMicrosoftKernelCodeSigning) && certEKU == ExtKeyUsageCodeSigning\n }\n \n // isValid performs validity checks on c given that it is a candidate to append\n@@ -630,8 +646,7 @@ func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *V\n \t\t\t\tname := string(data)\n \t\t\t\tmailbox, ok := parseRFC2821Mailbox(name)\n \t\t\t\tif !ok {\n-\t\t\t\t\t// This certificate should not have parsed.\n-\t\t\t\t\treturn errors.New(\"x509: internal error: rfc822Name SAN failed to parse\")\n+\t\t\t\t\treturn fmt.Errorf(\"x509: cannot parse rfc822Name %q\", mailbox)\n \t\t\t\t}\n \n \t\t\t\tif err := c.checkNameConstraints(&comparisonCount, maxConstraintComparisons, \"email address\", name, mailbox,\n@@ -643,6 +658,10 @@ func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *V\n \n \t\t\tcase nameTypeDNS:\n \t\t\t\tname := string(data)\n+\t\t\t\tif _, ok := domainToReverseLabels(name); !ok {\n+\t\t\t\t\treturn fmt.Errorf(\"x509: cannot parse dnsName %q\", name)\n+\t\t\t\t}\n+\n \t\t\t\tif err := c.checkNameConstraints(&comparisonCount, maxConstraintComparisons, \"DNS name\", name, name,\n \t\t\t\t\tfunc(parsedName, constraint interface{}) (bool, error) {\n \t\t\t\t\t\treturn matchDomainConstraint(parsedName.(string), constraint.(string))\n@@ -716,7 +735,7 @@ func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *V\n \n \t\t\tfor _, caEKU := range c.ExtKeyUsage {\n \t\t\t\tcomparisonCount++\n-\t\t\t\tif ekuPermittedBy(eku, caEKU) {\n+\t\t\t\tif ekuPermittedBy(eku, caEKU, checkingAgainstIssuerCert) {\n \t\t\t\t\tcontinue NextEKU\n \t\t\t\t}\n \t\t\t}\n@@ -773,6 +792,18 @@ func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *V\n \treturn nil\n }\n \n+// formatOID formats an ASN.1 OBJECT IDENTIFER in the common, dotted style.\n+func formatOID(oid asn1.ObjectIdentifier) string {\n+\tret := \"\"\n+\tfor i, v := range oid {\n+\t\tif i > 0 {\n+\t\t\tret += \".\"\n+\t\t}\n+\t\tret += strconv.Itoa(v)\n+\t}\n+\treturn ret\n+}\n+\n // Verify attempts to verify c by building one or more chains from c to a\n // certificate in opts.Roots, using certificates in opts.Intermediates if\n // needed. If successful, it returns one or more chains where the first\n@@ -847,16 +878,33 @@ func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err e\n \t}\n \n \tif checkEKU {\n+\t\tfoundMatch := false\n \tNextUsage:\n \t\tfor _, eku := range requestedKeyUsages {\n \t\t\tfor _, leafEKU := range c.ExtKeyUsage {\n-\t\t\t\tif ekuPermittedBy(eku, leafEKU) {\n-\t\t\t\t\tcontinue NextUsage\n+\t\t\t\tif ekuPermittedBy(eku, leafEKU, checkingAgainstLeafCert) {\n+\t\t\t\t\tfoundMatch = true\n+\t\t\t\t\tbreak NextUsage\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n \n-\t\t\toid, _ := oidFromExtKeyUsage(eku)\n-\t\t\treturn nil, CertificateInvalidError{c, IncompatibleUsage, fmt.Sprintf(\"%#v\", oid)}\n+\t\tif !foundMatch {\n+\t\t\tmsg := \"leaf contains the following, recognized EKUs: \"\n+\n+\t\t\tfor i, leafEKU := range c.ExtKeyUsage {\n+\t\t\t\toid, ok := oidFromExtKeyUsage(leafEKU)\n+\t\t\t\tif !ok {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tif i > 0 {\n+\t\t\t\t\tmsg += \", \"\n+\t\t\t\t}\n+\t\t\t\tmsg += formatOID(oid)\n+\t\t\t}\n+\n+\t\t\treturn nil, CertificateInvalidError{c, IncompatibleUsage, msg}\n \t\t}\n \t}\n "}, {"sha": "ee08dd9797e2ac972053c4216035f2be1f10bad9", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -706,7 +706,9 @@ type Certificate struct {\n \tOCSPServer            []string\n \tIssuingCertificateURL []string\n \n-\t// Subject Alternate Name values\n+\t// Subject Alternate Name values. (Note that these values may not be valid\n+\t// if invalid values were contained within a parsed certificate. For\n+\t// example, an element of DNSNames may not be a valid DNS domain name.)\n \tDNSNames       []string\n \tEmailAddresses []string\n \tIPAddresses    []net.IP\n@@ -1126,17 +1128,9 @@ func parseSANExtension(value []byte) (dnsNames, emailAddresses []string, ipAddre\n \terr = forEachSAN(value, func(tag int, data []byte) error {\n \t\tswitch tag {\n \t\tcase nameTypeEmail:\n-\t\t\tmailbox := string(data)\n-\t\t\tif _, ok := parseRFC2821Mailbox(mailbox); !ok {\n-\t\t\t\treturn fmt.Errorf(\"x509: cannot parse rfc822Name %q\", mailbox)\n-\t\t\t}\n-\t\t\temailAddresses = append(emailAddresses, mailbox)\n+\t\t\temailAddresses = append(emailAddresses, string(data))\n \t\tcase nameTypeDNS:\n-\t\t\tdomain := string(data)\n-\t\t\tif _, ok := domainToReverseLabels(domain); !ok {\n-\t\t\t\treturn fmt.Errorf(\"x509: cannot parse dnsName %q\", string(data))\n-\t\t\t}\n-\t\t\tdnsNames = append(dnsNames, domain)\n+\t\t\tdnsNames = append(dnsNames, string(data))\n \t\tcase nameTypeURI:\n \t\t\turi, err := url.Parse(string(data))\n \t\t\tif err != nil {\n@@ -1153,7 +1147,7 @@ func parseSANExtension(value []byte) (dnsNames, emailAddresses []string, ipAddre\n \t\t\tcase net.IPv4len, net.IPv6len:\n \t\t\t\tipAddresses = append(ipAddresses, data)\n \t\t\tdefault:\n-\t\t\t\treturn errors.New(\"x509: certificate contained IP address of length \" + strconv.Itoa(len(data)))\n+\t\t\t\treturn errors.New(\"x509: cannot parse IP address of length \" + strconv.Itoa(len(data)))\n \t\t\t}\n \t\t}\n \n@@ -2543,7 +2537,7 @@ func ParseCertificateRequest(asn1Data []byte) (*CertificateRequest, error) {\n \n func parseCertificateRequest(in *certificateRequest) (*CertificateRequest, error) {\n \tout := &CertificateRequest{\n-\t\tRaw: in.Raw,\n+\t\tRaw:                      in.Raw,\n \t\tRawTBSCertificateRequest: in.TBSCSR.Raw,\n \t\tRawSubjectPublicKeyInfo:  in.TBSCSR.PublicKey.Raw,\n \t\tRawSubject:               in.TBSCSR.Subject.FullBytes,"}, {"sha": "730fb920ebd088ffccfe86d0d9d31e1f46fe6006", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -443,10 +443,25 @@ func (d *decodeState) valueQuoted() interface{} {\n // if it encounters an Unmarshaler, indirect stops and returns that.\n // if decodingNull is true, indirect stops at the last pointer so it can be set to nil.\n func (d *decodeState) indirect(v reflect.Value, decodingNull bool) (Unmarshaler, encoding.TextUnmarshaler, reflect.Value) {\n+\t// Issue #24153 indicates that it is generally not a guaranteed property\n+\t// that you may round-trip a reflect.Value by calling Value.Addr().Elem()\n+\t// and expect the value to still be settable for values derived from\n+\t// unexported embedded struct fields.\n+\t//\n+\t// The logic below effectively does this when it first addresses the value\n+\t// (to satisfy possible pointer methods) and continues to dereference\n+\t// subsequent pointers as necessary.\n+\t//\n+\t// After the first round-trip, we set v back to the original value to\n+\t// preserve the original RW flags contained in reflect.Value.\n+\tv0 := v\n+\thaveAddr := false\n+\n \t// If v is a named type and is addressable,\n \t// start with its address, so that if the type has pointer methods,\n \t// we find them.\n \tif v.Kind() != reflect.Ptr && v.Type().Name() != \"\" && v.CanAddr() {\n+\t\thaveAddr = true\n \t\tv = v.Addr()\n \t}\n \tfor {\n@@ -455,6 +470,7 @@ func (d *decodeState) indirect(v reflect.Value, decodingNull bool) (Unmarshaler,\n \t\tif v.Kind() == reflect.Interface && !v.IsNil() {\n \t\t\te := v.Elem()\n \t\t\tif e.Kind() == reflect.Ptr && !e.IsNil() && (!decodingNull || e.Elem().Kind() == reflect.Ptr) {\n+\t\t\t\thaveAddr = false\n \t\t\t\tv = e\n \t\t\t\tcontinue\n \t\t\t}\n@@ -480,7 +496,13 @@ func (d *decodeState) indirect(v reflect.Value, decodingNull bool) (Unmarshaler,\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tv = v.Elem()\n+\n+\t\tif haveAddr {\n+\t\t\tv = v0 // restore original value after round-trip Value.Addr().Elem()\n+\t\t\thaveAddr = false\n+\t\t} else {\n+\t\t\tv = v.Elem()\n+\t\t}\n \t}\n \treturn nil, nil, v\n }"}, {"sha": "fa1531f3761db596bab7af7702dfeed400edec6f", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 56, "deletions": 14, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -615,9 +615,9 @@ var unmarshalTests = []unmarshalTest{\n \t\tout: S5{S8: S8{S9: S9{Y: 2}}},\n \t},\n \t{\n-\t\tin:  `{\"X\": 1,\"Y\":2}`,\n-\t\tptr: new(S5),\n-\t\terr: fmt.Errorf(\"json: unknown field \\\"X\\\"\"),\n+\t\tin:                    `{\"X\": 1,\"Y\":2}`,\n+\t\tptr:                   new(S5),\n+\t\terr:                   fmt.Errorf(\"json: unknown field \\\"X\\\"\"),\n \t\tdisallowUnknownFields: true,\n \t},\n \t{\n@@ -626,9 +626,9 @@ var unmarshalTests = []unmarshalTest{\n \t\tout: S10{S13: S13{S8: S8{S9: S9{Y: 2}}}},\n \t},\n \t{\n-\t\tin:  `{\"X\": 1,\"Y\":2}`,\n-\t\tptr: new(S10),\n-\t\terr: fmt.Errorf(\"json: unknown field \\\"X\\\"\"),\n+\t\tin:                    `{\"X\": 1,\"Y\":2}`,\n+\t\tptr:                   new(S10),\n+\t\terr:                   fmt.Errorf(\"json: unknown field \\\"X\\\"\"),\n \t\tdisallowUnknownFields: true,\n \t},\n \n@@ -835,8 +835,8 @@ var unmarshalTests = []unmarshalTest{\n \t\t\t\"Q\": 18,\n \t\t\t\"extra\": true\n \t\t}`,\n-\t\tptr: new(Top),\n-\t\terr: fmt.Errorf(\"json: unknown field \\\"extra\\\"\"),\n+\t\tptr:                   new(Top),\n+\t\terr:                   fmt.Errorf(\"json: unknown field \\\"extra\\\"\"),\n \t\tdisallowUnknownFields: true,\n \t},\n \t{\n@@ -862,8 +862,8 @@ var unmarshalTests = []unmarshalTest{\n \t\t\t\"Z\": 17,\n \t\t\t\"Q\": 18\n \t\t}`,\n-\t\tptr: new(Top),\n-\t\terr: fmt.Errorf(\"json: unknown field \\\"extra\\\"\"),\n+\t\tptr:                   new(Top),\n+\t\terr:                   fmt.Errorf(\"json: unknown field \\\"extra\\\"\"),\n \t\tdisallowUnknownFields: true,\n \t},\n }\n@@ -2089,10 +2089,14 @@ func TestInvalidStringOption(t *testing.T) {\n \t}\n }\n \n-// Test unmarshal behavior with regards to embedded pointers to unexported structs.\n-// If unallocated, this returns an error because unmarshal cannot set the field.\n-// Issue 21357.\n-func TestUnmarshalEmbeddedPointerUnexported(t *testing.T) {\n+// Test unmarshal behavior with regards to embedded unexported structs.\n+//\n+// (Issue 21357) If the embedded struct is a pointer and is unallocated,\n+// this returns an error because unmarshal cannot set the field.\n+//\n+// (Issue 24152) If the embedded struct is given an explicit name,\n+// ensure that the normal unmarshal logic does not panic in reflect.\n+func TestUnmarshalEmbeddedUnexported(t *testing.T) {\n \ttype (\n \t\tembed1 struct{ Q int }\n \t\tembed2 struct{ Q int }\n@@ -2119,6 +2123,18 @@ func TestUnmarshalEmbeddedPointerUnexported(t *testing.T) {\n \t\t\t*embed3\n \t\t\tR int\n \t\t}\n+\t\tS6 struct {\n+\t\t\tembed1 `json:\"embed1\"`\n+\t\t}\n+\t\tS7 struct {\n+\t\t\tembed1 `json:\"embed1\"`\n+\t\t\tembed2\n+\t\t}\n+\t\tS8 struct {\n+\t\t\tembed1 `json:\"embed1\"`\n+\t\t\tembed2 `json:\"embed2\"`\n+\t\t\tQ      int\n+\t\t}\n \t)\n \n \ttests := []struct {\n@@ -2154,6 +2170,32 @@ func TestUnmarshalEmbeddedPointerUnexported(t *testing.T) {\n \t\tptr: new(S5),\n \t\tout: &S5{R: 2},\n \t\terr: fmt.Errorf(\"json: cannot set embedded pointer to unexported struct: json.embed3\"),\n+\t}, {\n+\t\t// Issue 24152, ensure decodeState.indirect does not panic.\n+\t\tin:  `{\"embed1\": {\"Q\": 1}}`,\n+\t\tptr: new(S6),\n+\t\tout: &S6{embed1{1}},\n+\t}, {\n+\t\t// Issue 24153, check that we can still set forwarded fields even in\n+\t\t// the presence of a name conflict.\n+\t\t//\n+\t\t// This relies on obscure behavior of reflect where it is possible\n+\t\t// to set a forwarded exported field on an unexported embedded struct\n+\t\t// even though there is a name conflict, even when it would have been\n+\t\t// impossible to do so according to Go visibility rules.\n+\t\t// Go forbids this because it is ambiguous whether S7.Q refers to\n+\t\t// S7.embed1.Q or S7.embed2.Q. Since embed1 and embed2 are unexported,\n+\t\t// it should be impossible for an external package to set either Q.\n+\t\t//\n+\t\t// It is probably okay for a future reflect change to break this.\n+\t\tin:  `{\"embed1\": {\"Q\": 1}, \"Q\": 2}`,\n+\t\tptr: new(S7),\n+\t\tout: &S7{embed1{1}, embed2{2}},\n+\t}, {\n+\t\t// Issue 24153, similar to the S7 case.\n+\t\tin:  `{\"embed1\": {\"Q\": 1}, \"embed2\": {\"Q\": 2}, \"Q\": 3}`,\n+\t\tptr: new(S8),\n+\t\tout: &S8{embed1{1}, embed2{2}, 3},\n \t}}\n \n \tfor i, tt := range tests {"}, {"sha": "9ed7e5e4dca6f98bdd61184cc6a85261b78e5658", "filename": "libgo/go/go/internal/srcimporter/srcimporter.go", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -44,9 +44,9 @@ func New(ctxt *build.Context, fset *token.FileSet, packages map[string]*types.Pa\n // for a package that is in the process of being imported.\n var importing types.Package\n \n-// Import(path) is a shortcut for ImportFrom(path, \"\", 0).\n+// Import(path) is a shortcut for ImportFrom(path, \".\", 0).\n func (p *Importer) Import(path string) (*types.Package, error) {\n-\treturn p.ImportFrom(path, \"\", 0)\n+\treturn p.ImportFrom(path, \".\", 0) // use \".\" rather than \"\" (see issue #24441)\n }\n \n // ImportFrom imports the package with the given import path resolved from the given srcDir,\n@@ -60,23 +60,10 @@ func (p *Importer) ImportFrom(path, srcDir string, mode types.ImportMode) (*type\n \t\tpanic(\"non-zero import mode\")\n \t}\n \n-\t// determine package path (do vendor resolution)\n-\tvar bp *build.Package\n-\tvar err error\n-\tswitch {\n-\tdefault:\n-\t\tif abs, err := p.absPath(srcDir); err == nil { // see issue #14282\n-\t\t\tsrcDir = abs\n-\t\t}\n-\t\tbp, err = p.ctxt.Import(path, srcDir, build.FindOnly)\n-\n-\tcase build.IsLocalImport(path):\n-\t\t// \"./x\" -> \"srcDir/x\"\n-\t\tbp, err = p.ctxt.ImportDir(filepath.Join(srcDir, path), build.FindOnly)\n-\n-\tcase p.isAbsPath(path):\n-\t\treturn nil, fmt.Errorf(\"invalid absolute import path %q\", path)\n+\tif abs, err := p.absPath(srcDir); err == nil { // see issue #14282\n+\t\tsrcDir = abs\n \t}\n+\tbp, err := p.ctxt.Import(path, srcDir, 0)\n \tif err != nil {\n \t\treturn nil, err // err may be *build.NoGoError - return as is\n \t}\n@@ -113,11 +100,6 @@ func (p *Importer) ImportFrom(path, srcDir string, mode types.ImportMode) (*type\n \t\t}\n \t}()\n \n-\t// collect package files\n-\tbp, err = p.ctxt.ImportDir(bp.Dir, 0)\n-\tif err != nil {\n-\t\treturn nil, err // err may be *build.NoGoError - return as is\n-\t}\n \tvar filenames []string\n \tfilenames = append(filenames, bp.GoFiles...)\n \tfilenames = append(filenames, bp.CgoFiles...)"}, {"sha": "dd4d56ad17dd612079a32808abb137f1c2ec6f03", "filename": "libgo/go/go/internal/srcimporter/srcimporter_test.go", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter_test.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"go/types\"\n \t\"internal/testenv\"\n \t\"io/ioutil\"\n+\t\"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n \t\"strings\"\n@@ -162,3 +163,34 @@ func TestIssue20855(t *testing.T) {\n \t\tt.Error(\"got no package despite no hard errors\")\n \t}\n }\n+\n+func testImportPath(t *testing.T, pkgPath string) {\n+\tif !testenv.HasSrc() {\n+\t\tt.Skip(\"no source code available\")\n+\t}\n+\n+\tpkgName := path.Base(pkgPath)\n+\n+\tpkg, err := importer.Import(pkgPath)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif pkg.Name() != pkgName {\n+\t\tt.Errorf(\"got %q; want %q\", pkg.Name(), pkgName)\n+\t}\n+\n+\tif pkg.Path() != pkgPath {\n+\t\tt.Errorf(\"got %q; want %q\", pkg.Path(), pkgPath)\n+\t}\n+}\n+\n+// TestIssue23092 tests relative imports.\n+func TestIssue23092(t *testing.T) {\n+\ttestImportPath(t, \"./testdata/issue23092\")\n+}\n+\n+// TestIssue24392 tests imports against a path containing 'testdata'.\n+func TestIssue24392(t *testing.T) {\n+\ttestImportPath(t, \"go/internal/srcimporter/testdata/issue24392\")\n+}"}, {"sha": "608698bfc51b3a4e4e0011541dbf4ebf28340147", "filename": "libgo/go/go/internal/srcimporter/testdata/issue23092/issue23092.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Ftestdata%2Fissue23092%2Fissue23092.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Ftestdata%2Fissue23092%2Fissue23092.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Ftestdata%2Fissue23092%2Fissue23092.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -0,0 +1,5 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package issue23092"}, {"sha": "8ad52218fc348624ae713f0f59a9f26e6b342c99", "filename": "libgo/go/go/internal/srcimporter/testdata/issue24392/issue24392.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Ftestdata%2Fissue24392%2Fissue24392.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Ftestdata%2Fissue24392%2Fissue24392.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Ftestdata%2Fissue24392%2Fissue24392.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -0,0 +1,5 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package issue24392"}, {"sha": "b2d82e26c29c6b8890dd7e0590299179c4090486", "filename": "libgo/go/internal/singleflight/singleflight.go", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Finternal%2Fsingleflight%2Fsingleflight.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Finternal%2Fsingleflight%2Fsingleflight.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fsingleflight%2Fsingleflight.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -103,11 +103,21 @@ func (g *Group) doCall(c *call, key string, fn func() (interface{}, error)) {\n \tg.mu.Unlock()\n }\n \n-// Forget tells the singleflight to forget about a key.  Future calls\n-// to Do for this key will call the function rather than waiting for\n-// an earlier call to complete.\n-func (g *Group) Forget(key string) {\n+// ForgetUnshared tells the singleflight to forget about a key if it is not\n+// shared with any other goroutines. Future calls to Do for a forgotten key\n+// will call the function rather than waiting for an earlier call to complete.\n+// Returns whether the key was forgotten or unknown--that is, whether no\n+// other goroutines are waiting for the result.\n+func (g *Group) ForgetUnshared(key string) bool {\n \tg.mu.Lock()\n-\tdelete(g.m, key)\n-\tg.mu.Unlock()\n+\tdefer g.mu.Unlock()\n+\tc, ok := g.m[key]\n+\tif !ok {\n+\t\treturn true\n+\t}\n+\tif c.dups == 0 {\n+\t\tdelete(g.m, key)\n+\t\treturn true\n+\t}\n+\treturn false\n }"}, {"sha": "77e0bcdf4f6e6fb425dc67c5d8764038a70dec83", "filename": "libgo/go/net/http/pprof/pprof.go", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -80,6 +80,7 @@ func init() {\n // command line, with arguments separated by NUL bytes.\n // The package initialization registers it as /debug/pprof/cmdline.\n func Cmdline(w http.ResponseWriter, r *http.Request) {\n+\tw.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n \tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n \tfmt.Fprintf(w, strings.Join(os.Args, \"\\x00\"))\n }\n@@ -100,33 +101,36 @@ func durationExceedsWriteTimeout(r *http.Request, seconds float64) bool {\n \treturn ok && srv.WriteTimeout != 0 && seconds >= srv.WriteTimeout.Seconds()\n }\n \n+func serveError(w http.ResponseWriter, status int, txt string) {\n+\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n+\tw.Header().Set(\"X-Go-Pprof\", \"1\")\n+\tw.Header().Del(\"Content-Disposition\")\n+\tw.WriteHeader(status)\n+\tfmt.Fprintln(w, txt)\n+}\n+\n // Profile responds with the pprof-formatted cpu profile.\n // The package initialization registers it as /debug/pprof/profile.\n func Profile(w http.ResponseWriter, r *http.Request) {\n+\tw.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n \tsec, _ := strconv.ParseInt(r.FormValue(\"seconds\"), 10, 64)\n \tif sec == 0 {\n \t\tsec = 30\n \t}\n \n \tif durationExceedsWriteTimeout(r, float64(sec)) {\n-\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n-\t\tw.Header().Set(\"X-Go-Pprof\", \"1\")\n-\t\tw.WriteHeader(http.StatusBadRequest)\n-\t\tfmt.Fprintln(w, \"profile duration exceeds server's WriteTimeout\")\n+\t\tserveError(w, http.StatusBadRequest, \"profile duration exceeds server's WriteTimeout\")\n \t\treturn\n \t}\n \n \t// Set Content Type assuming StartCPUProfile will work,\n \t// because if it does it starts writing.\n \tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n+\tw.Header().Set(\"Content-Disposition\", `attachment; filename=\"profile\"`)\n \tif err := pprof.StartCPUProfile(w); err != nil {\n \t\t// StartCPUProfile failed, so no writes yet.\n-\t\t// Can change header back to text content\n-\t\t// and send error code.\n-\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n-\t\tw.Header().Set(\"X-Go-Pprof\", \"1\")\n-\t\tw.WriteHeader(http.StatusInternalServerError)\n-\t\tfmt.Fprintf(w, \"Could not enable CPU profiling: %s\\n\", err)\n+\t\tserveError(w, http.StatusInternalServerError,\n+\t\t\tfmt.Sprintf(\"Could not enable CPU profiling: %s\", err))\n \t\treturn\n \t}\n \tsleep(w, time.Duration(sec)*time.Second)\n@@ -137,29 +141,25 @@ func Profile(w http.ResponseWriter, r *http.Request) {\n // Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\n // The package initialization registers it as /debug/pprof/trace.\n func Trace(w http.ResponseWriter, r *http.Request) {\n+\tw.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n \tsec, err := strconv.ParseFloat(r.FormValue(\"seconds\"), 64)\n \tif sec <= 0 || err != nil {\n \t\tsec = 1\n \t}\n \n \tif durationExceedsWriteTimeout(r, sec) {\n-\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n-\t\tw.Header().Set(\"X-Go-Pprof\", \"1\")\n-\t\tw.WriteHeader(http.StatusBadRequest)\n-\t\tfmt.Fprintln(w, \"profile duration exceeds server's WriteTimeout\")\n+\t\tserveError(w, http.StatusBadRequest, \"profile duration exceeds server's WriteTimeout\")\n \t\treturn\n \t}\n \n \t// Set Content Type assuming trace.Start will work,\n \t// because if it does it starts writing.\n \tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n+\tw.Header().Set(\"Content-Disposition\", `attachment; filename=\"trace\"`)\n \tif err := trace.Start(w); err != nil {\n \t\t// trace.Start failed, so no writes yet.\n-\t\t// Can change header back to text content and send error code.\n-\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n-\t\tw.Header().Set(\"X-Go-Pprof\", \"1\")\n-\t\tw.WriteHeader(http.StatusInternalServerError)\n-\t\tfmt.Fprintf(w, \"Could not enable tracing: %s\\n\", err)\n+\t\tserveError(w, http.StatusInternalServerError,\n+\t\t\tfmt.Sprintf(\"Could not enable tracing: %s\", err))\n \t\treturn\n \t}\n \tsleep(w, time.Duration(sec*float64(time.Second)))\n@@ -170,6 +170,7 @@ func Trace(w http.ResponseWriter, r *http.Request) {\n // responding with a table mapping program counters to function names.\n // The package initialization registers it as /debug/pprof/symbol.\n func Symbol(w http.ResponseWriter, r *http.Request) {\n+\tw.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n \tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n \n \t// We have to read the whole POST body before\n@@ -222,18 +223,23 @@ func Handler(name string) http.Handler {\n type handler string\n \n func (name handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n-\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n-\tdebug, _ := strconv.Atoi(r.FormValue(\"debug\"))\n+\tw.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n \tp := pprof.Lookup(string(name))\n \tif p == nil {\n-\t\tw.WriteHeader(404)\n-\t\tfmt.Fprintf(w, \"Unknown profile: %s\\n\", name)\n+\t\tserveError(w, http.StatusNotFound, \"Unknown profile\")\n \t\treturn\n \t}\n \tgc, _ := strconv.Atoi(r.FormValue(\"gc\"))\n \tif name == \"heap\" && gc > 0 {\n \t\truntime.GC()\n \t}\n+\tdebug, _ := strconv.Atoi(r.FormValue(\"debug\"))\n+\tif debug != 0 {\n+\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n+\t} else {\n+\t\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n+\t\tw.Header().Set(\"Content-Disposition\", fmt.Sprintf(`attachment; filename=\"%s\"`, name))\n+\t}\n \tp.WriteTo(w, debug)\n }\n "}, {"sha": "47dd35b9b07c8180d20af6951ff2d86b95209405", "filename": "libgo/go/net/http/pprof/pprof_test.go", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof_test.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package pprof\n+\n+import (\n+\t\"bytes\"\n+\t\"io/ioutil\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"testing\"\n+)\n+\n+func TestHandlers(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tpath               string\n+\t\thandler            http.HandlerFunc\n+\t\tstatusCode         int\n+\t\tcontentType        string\n+\t\tcontentDisposition string\n+\t\tresp               []byte\n+\t}{\n+\t\t{\"/debug/pprof/<script>scripty<script>\", Index, http.StatusNotFound, \"text/plain; charset=utf-8\", \"\", []byte(\"Unknown profile\\n\")},\n+\t\t{\"/debug/pprof/heap\", Index, http.StatusOK, \"application/octet-stream\", `attachment; filename=\"heap\"`, nil},\n+\t\t{\"/debug/pprof/heap?debug=1\", Index, http.StatusOK, \"text/plain; charset=utf-8\", \"\", nil},\n+\t\t{\"/debug/pprof/cmdline\", Cmdline, http.StatusOK, \"text/plain; charset=utf-8\", \"\", nil},\n+\t\t{\"/debug/pprof/profile?seconds=1\", Profile, http.StatusOK, \"application/octet-stream\", `attachment; filename=\"profile\"`, nil},\n+\t\t{\"/debug/pprof/symbol\", Symbol, http.StatusOK, \"text/plain; charset=utf-8\", \"\", nil},\n+\t\t{\"/debug/pprof/trace\", Trace, http.StatusOK, \"application/octet-stream\", `attachment; filename=\"trace\"`, nil},\n+\t}\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.path, func(t *testing.T) {\n+\t\t\treq := httptest.NewRequest(\"GET\", \"http://example.com\"+tc.path, nil)\n+\t\t\tw := httptest.NewRecorder()\n+\t\t\ttc.handler(w, req)\n+\n+\t\t\tresp := w.Result()\n+\t\t\tif got, want := resp.StatusCode, tc.statusCode; got != want {\n+\t\t\t\tt.Errorf(\"status code: got %d; want %d\", got, want)\n+\t\t\t}\n+\n+\t\t\tbody, err := ioutil.ReadAll(resp.Body)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"when reading response body, expected non-nil err; got %v\", err)\n+\t\t\t}\n+\t\t\tif got, want := resp.Header.Get(\"X-Content-Type-Options\"), \"nosniff\"; got != want {\n+\t\t\t\tt.Errorf(\"X-Content-Type-Options: got %q; want %q\", got, want)\n+\t\t\t}\n+\t\t\tif got, want := resp.Header.Get(\"Content-Type\"), tc.contentType; got != want {\n+\t\t\t\tt.Errorf(\"Content-Type: got %q; want %q\", got, want)\n+\t\t\t}\n+\t\t\tif got, want := resp.Header.Get(\"Content-Disposition\"), tc.contentDisposition; got != want {\n+\t\t\t\tt.Errorf(\"Content-Disposition: got %q; want %q\", got, want)\n+\t\t\t}\n+\n+\t\t\tif resp.StatusCode == http.StatusOK {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif got, want := resp.Header.Get(\"X-Go-Pprof\"), \"1\"; got != want {\n+\t\t\t\tt.Errorf(\"X-Go-Pprof: got %q; want %q\", got, want)\n+\t\t\t}\n+\t\t\tif !bytes.Equal(body, tc.resp) {\n+\t\t\t\tt.Errorf(\"response: got %q; want %q\", body, tc.resp)\n+\t\t\t}\n+\t\t})\n+\t}\n+\n+}"}, {"sha": "a65b735f92193210d648f26f0285ffeb8460842a", "filename": "libgo/go/net/lookup.go", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fnet%2Flookup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fnet%2Flookup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -194,31 +194,45 @@ func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, err\n \t\tresolverFunc = alt\n \t}\n \n+\t// We don't want a cancelation of ctx to affect the\n+\t// lookupGroup operation. Otherwise if our context gets\n+\t// canceled it might cause an error to be returned to a lookup\n+\t// using a completely different context.\n+\tlookupGroupCtx, lookupGroupCancel := context.WithCancel(context.Background())\n+\n \tdnsWaitGroup.Add(1)\n \tch, called := lookupGroup.DoChan(host, func() (interface{}, error) {\n \t\tdefer dnsWaitGroup.Done()\n-\t\treturn testHookLookupIP(ctx, resolverFunc, host)\n+\t\treturn testHookLookupIP(lookupGroupCtx, resolverFunc, host)\n \t})\n \tif !called {\n \t\tdnsWaitGroup.Done()\n \t}\n \n \tselect {\n \tcase <-ctx.Done():\n-\t\t// If the DNS lookup timed out for some reason, force\n-\t\t// future requests to start the DNS lookup again\n-\t\t// rather than waiting for the current lookup to\n-\t\t// complete. See issue 8602.\n-\t\tctxErr := ctx.Err()\n-\t\tif ctxErr == context.DeadlineExceeded {\n-\t\t\tlookupGroup.Forget(host)\n+\t\t// Our context was canceled. If we are the only\n+\t\t// goroutine looking up this key, then drop the key\n+\t\t// from the lookupGroup and cancel the lookup.\n+\t\t// If there are other goroutines looking up this key,\n+\t\t// let the lookup continue uncanceled, and let later\n+\t\t// lookups with the same key share the result.\n+\t\t// See issues 8602, 20703, 22724.\n+\t\tif lookupGroup.ForgetUnshared(host) {\n+\t\t\tlookupGroupCancel()\n+\t\t} else {\n+\t\t\tgo func() {\n+\t\t\t\t<-ch\n+\t\t\t\tlookupGroupCancel()\n+\t\t\t}()\n \t\t}\n-\t\terr := mapErr(ctxErr)\n+\t\terr := mapErr(ctx.Err())\n \t\tif trace != nil && trace.DNSDone != nil {\n \t\t\ttrace.DNSDone(nil, false, err)\n \t\t}\n \t\treturn nil, err\n \tcase r := <-ch:\n+\t\tlookupGroupCancel()\n \t\tif trace != nil && trace.DNSDone != nil {\n \t\t\taddrs, _ := r.Val.([]IPAddr)\n \t\t\ttrace.DNSDone(ipAddrsEface(addrs), r.Shared, r.Err)"}, {"sha": "24787ccf2b68503d149dbb5144d01f5c8f53cc2b", "filename": "libgo/go/net/lookup_test.go", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fnet%2Flookup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fnet%2Flookup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_test.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -791,3 +791,28 @@ func TestLookupNonLDH(t *testing.T) {\n \t\tt.Fatalf(\"lookup error = %v, want %v\", err, errNoSuchHost)\n \t}\n }\n+\n+func TestLookupContextCancel(t *testing.T) {\n+\tif testenv.Builder() == \"\" {\n+\t\ttestenv.MustHaveExternalNetwork(t)\n+\t}\n+\tif runtime.GOOS == \"nacl\" {\n+\t\tt.Skip(\"skip on nacl\")\n+\t}\n+\n+\tdefer dnsWaitGroup.Wait()\n+\n+\tctx, ctxCancel := context.WithCancel(context.Background())\n+\tctxCancel()\n+\t_, err := DefaultResolver.LookupIPAddr(ctx, \"google.com\")\n+\tif err != errCanceled {\n+\t\ttestenv.SkipFlakyNet(t)\n+\t\tt.Fatal(err)\n+\t}\n+\tctx = context.Background()\n+\t_, err = DefaultResolver.LookupIPAddr(ctx, \"google.com\")\n+\tif err != nil {\n+\t\ttestenv.SkipFlakyNet(t)\n+\t\tt.Fatal(err)\n+\t}\n+}"}, {"sha": "95c02d272118565d0b78a05c5f82e8854cbfd8bb", "filename": "libgo/go/net/tcpsock_unix_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fnet%2Ftcpsock_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fnet%2Ftcpsock_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_unix_test.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -87,6 +87,7 @@ func TestTCPSpuriousConnSetupCompletionWithCancel(t *testing.T) {\n \tif testenv.Builder() == \"\" {\n \t\ttestenv.MustHaveExternalNetwork(t)\n \t}\n+\tdefer dnsWaitGroup.Wait()\n \tt.Parallel()\n \tconst tries = 10000\n \tvar wg sync.WaitGroup"}, {"sha": "1a038cfcd5eb892d35a024dd23a95c0a83d5dfee", "filename": "libgo/go/runtime/error.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fruntime%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fruntime%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ferror.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -139,14 +139,12 @@ func typestring(x interface{}) string {\n }\n \n // printany prints an argument passed to panic.\n+// If panic is called with a value that has a String or Error method,\n+// it has already been converted into a string by preprintpanics.\n func printany(i interface{}) {\n \tswitch v := i.(type) {\n \tcase nil:\n \t\tprint(\"nil\")\n-\tcase stringer:\n-\t\tprint(v.String())\n-\tcase error:\n-\t\tprint(v.Error())\n \tcase bool:\n \t\tprint(v)\n \tcase int:"}, {"sha": "6b490b7b3c238e6ccdfdb1f9d082cd4d6d4a7b55", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -384,7 +384,6 @@ func Goexit() {\n \n // Call all Error and String methods before freezing the world.\n // Used when crashing with panicking.\n-// This must match types handled by printany.\n func preprintpanics(p *_panic) {\n \tdefer func() {\n \t\tif recover() != nil {\n@@ -410,8 +409,6 @@ func printpanics(p *_panic) {\n \t\tprint(\"\\t\")\n \t}\n \tprint(\"panic: \")\n-\t// Because of preprintpanics, p.arg cannot be an error or\n-\t// stringer, so this won't call into user code.\n \tprintany(p.arg)\n \tif p.recovered {\n \t\tprint(\" [recovered]\")"}, {"sha": "a6746c9f0a8d19619c4c5a183387d78a92b6774b", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -423,6 +423,12 @@ func releaseSudog(s *sudog) {\n \n // funcPC returns the entry PC of the function f.\n // It assumes that f is a func value. Otherwise the behavior is undefined.\n+// CAREFUL: In programs with plugins, funcPC can return different values\n+// for the same function (because there are actually multiple copies of\n+// the same function in the address space). To be safe, don't use the\n+// results of this function in any == expression. It is only safe to\n+// use the result as an address at which to start executing code.\n+//\n // For gccgo note that this differs from the gc implementation; the gc\n // implementation adds sys.PtrSize to the address of the interface\n // value, but GCC's alias analysis decides that that can not be a"}, {"sha": "12dc672bc0cfbb54f14447b9dd411dd8bc9311a8", "filename": "libgo/go/runtime/symtab.go", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fruntime%2Fsymtab.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fgo%2Fruntime%2Fsymtab.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsymtab.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -115,6 +115,35 @@ type Func struct {\n \tentry uintptr\n }\n \n+// A FuncID identifies particular functions that need to be treated\n+// specially by the runtime.\n+// Note that in some situations involving plugins, there may be multiple\n+// copies of a particular special runtime function.\n+// Note: this list must match the list in cmd/internal/objabi/funcid.go.\n+type funcID uint32\n+\n+const (\n+\tfuncID_normal funcID = iota // not a special function\n+\tfuncID_goexit\n+\tfuncID_jmpdefer\n+\tfuncID_mcall\n+\tfuncID_morestack\n+\tfuncID_mstart\n+\tfuncID_rt0_go\n+\tfuncID_asmcgocall\n+\tfuncID_sigpanic\n+\tfuncID_runfinq\n+\tfuncID_bgsweep\n+\tfuncID_forcegchelper\n+\tfuncID_timerproc\n+\tfuncID_gcBgMarkWorker\n+\tfuncID_systemstack_switch\n+\tfuncID_systemstack\n+\tfuncID_cgocallback_gofunc\n+\tfuncID_gogo\n+\tfuncID_externalthreadhandler\n+)\n+\n // FuncForPC returns a *Func describing the function that contains the\n // given program counter address, or else nil.\n //"}, {"sha": "4107adff7b476cb69db6e58ef00c774bb91fe576", "filename": "libgo/misc/cgo/testplugin/src/issue24351/main.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue24351%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue24351%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue24351%2Fmain.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"plugin\"\n+\n+func main() {\n+\tp, err := plugin.Open(\"issue24351.so\")\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tf, err := p.Lookup(\"B\")\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tc := make(chan bool)\n+\tf.(func(chan bool))(c)\n+\t<-c\n+}"}, {"sha": "db17e0a6097c29686d7f782054f3ad14e7fc10d4", "filename": "libgo/misc/cgo/testplugin/src/issue24351/plugin.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue24351%2Fplugin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue24351%2Fplugin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue24351%2Fplugin.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"fmt\"\n+\n+func B(c chan bool) {\n+\tgo func() {\n+\t\tfmt.Println(1.5)\n+\t\tc <- true\n+\t}()\n+}"}, {"sha": "df38204a4e9512353a138dc429acb17110b7485c", "filename": "libgo/misc/cgo/testplugin/test.bash", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftest.bash", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftest.bash", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftest.bash?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -85,3 +85,8 @@ GOPATH=$(pwd) go build -gcflags \"$GO_GCFLAGS\" -o issue22175 src/issue22175/main.\n GOPATH=$(pwd) go build -gcflags \"$GO_GCFLAGS\" -buildmode=plugin -o issue.22295.so issue22295.pkg\n GOPATH=$(pwd) go build -gcflags \"$GO_GCFLAGS\" -o issue22295 src/issue22295.pkg/main.go\n ./issue22295\n+\n+# Test for issue 24351\n+GOPATH=$(pwd) go build -gcflags \"$GO_GCFLAGS\" -buildmode=plugin -o issue24351.so src/issue24351/plugin.go\n+GOPATH=$(pwd) go build -gcflags \"$GO_GCFLAGS\" -o issue24351 src/issue24351/main.go\n+./issue24351"}, {"sha": "a2960057809117f7b3c0cb68e8dc111889e231b9", "filename": "libgo/misc/cgo/testshared/shared_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11309337c4056975c0fbd83a8caee7663617bef2/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go?ref=11309337c4056975c0fbd83a8caee7663617bef2", "patch": "@@ -790,6 +790,7 @@ func TestRebuilding(t *testing.T) {\n \t// If the .a file is newer than the .so, the .so is rebuilt (but not the .a)\n \tt.Run(\"newarchive\", func(t *testing.T) {\n \t\tresetFileStamps()\n+\t\tAssertNotRebuilt(t, \"new .a file before build\", filepath.Join(gopathInstallDir, \"depBase.a\"))\n \t\tgoCmd(t, \"list\", \"-linkshared\", \"-f={{.ImportPath}} {{.Stale}} {{.StaleReason}} {{.Target}}\", \"depBase\")\n \t\tAssertNotRebuilt(t, \"new .a file before build\", filepath.Join(gopathInstallDir, \"depBase.a\"))\n \t\tcleanup := touch(t, filepath.Join(gopathInstallDir, \"depBase.a\"))"}]}