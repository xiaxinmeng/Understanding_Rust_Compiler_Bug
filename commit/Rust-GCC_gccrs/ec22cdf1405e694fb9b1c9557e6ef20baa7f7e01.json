{"sha": "ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMyMmNkZjE0MDVlNjk0ZmI5YjFjOTU1N2U2ZWYyMGJhYTdmN2UwMQ==", "commit": {"author": {"name": "Thomas Fitzsimmons", "email": "fitzsim@redhat.com", "date": "2003-12-01T15:28:22Z"}, "committer": {"name": "Thomas Fitzsimmons", "email": "fitzsim@gcc.gnu.org", "date": "2003-12-01T15:28:22Z"}, "message": "GtkImage.java (setDimensions, [...]): Check that io is not null before calling io.imageUpdate.\n\n2003-12-01  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkImage.java (setDimensions,\n\tsetProperties): Check that io is not null before calling\n\tio.imageUpdate.\n\t* java/awt/image/ImageConsumer.java (setPixels, imageComplete):\n\tUpdate javadocs.\n\t* java/awt/image/PixelGrabber.java: Fix implementation and\n\tupdate javadocs.\n\nFrom-SVN: r74103", "tree": {"sha": "53e474c9d243bac09d5515a8964831099978c9dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53e474c9d243bac09d5515a8964831099978c9dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01/comments", "author": null, "committer": null, "parents": [{"sha": "a1ff4c64785af6d603ed708841fdda887771e727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ff4c64785af6d603ed708841fdda887771e727", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ff4c64785af6d603ed708841fdda887771e727"}], "stats": {"total": 1019, "additions": 668, "deletions": 351}, "files": [{"sha": "bd51ea3b493c6fb9b42629385696717bf3820c42", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01", "patch": "@@ -1,3 +1,13 @@\n+2003-12-01  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkImage.java (setDimensions,\n+\tsetProperties): Check that io is not null before calling\n+\tio.imageUpdate.\n+\t* java/awt/image/ImageConsumer.java (setPixels, imageComplete):\n+\tUpdate javadocs.\n+\t* java/awt/image/PixelGrabber.java: Fix implementation and\n+\tupdate javadocs.\n+\n 2003-12-01  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/net/natPlainSocketImplPosix.cc\n@@ -572,7 +582,7 @@\n \tattributes for character.\n \t(quoteChar): Likewise.\n \n-2003-11-14  Tom Fitzsimmons  <fitzsim@redhat.com>\n+2003-11-14  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* java/awt/GridBagLayout.java (getLayoutDimensions): Return array of two\n \tzero-length int arrays when layoutInfo is null.\n@@ -606,7 +616,7 @@\n \t(helper_put_filedescriptors): Change to static linkage.\n \t(helper_get_filedescriptors): Likewise.\n \n-2003-11-12  Tom Fitzsimmons  <fitzsim@redhat.com>\n+2003-11-12  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* gnu/java/awt/peer/gtk/GtkComponentPeer.java (prepareImage): Remove\n \tnull check."}, {"sha": "fa81b912589ae3e82624ea8659785844be12652f", "filename": "libjava/gnu/java/awt/peer/gtk/GtkImage.java", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImage.java?ref=ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01", "patch": "@@ -1,5 +1,5 @@\n /* GtkImage.java\n-   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -168,13 +168,15 @@ public void setObserver (ImageObserver observer)\n     for (int i = 0; i < widthObservers.size (); i++)\n       {\n \tImageObserver io = (ImageObserver) widthObservers.elementAt (i);\n-\tio.imageUpdate (this, ImageObserver.WIDTH, -1, -1, width, height);\n+\tif (io != null)\n+\t  io.imageUpdate (this, ImageObserver.WIDTH, -1, -1, width, height);\n       }\n \n     for (int i = 0; i < heightObservers.size (); i++)\n       {\n \tImageObserver io = (ImageObserver) heightObservers.elementAt (i);\n-\tio.imageUpdate (this, ImageObserver.HEIGHT, -1, -1, width, height);\n+\tif (io != null)\n+\t  io.imageUpdate (this, ImageObserver.HEIGHT, -1, -1, width, height);\n       }\n \n     if (observer != null)\n@@ -192,7 +194,8 @@ public void setObserver (ImageObserver observer)\n     for (int i = 0; i < propertyObservers.size (); i++)\n       {\n \tImageObserver io = (ImageObserver) propertyObservers.elementAt (i);\n-\tio.imageUpdate (this, ImageObserver.PROPERTIES, -1, -1, width, height);\n+\tif (io != null)\n+\t  io.imageUpdate (this, ImageObserver.PROPERTIES, -1, -1, width, height);\n       }\n   }\n "}, {"sha": "9ac67d5cf36d3d8668670b9d08e689ba2a3f921d", "filename": "libjava/java/awt/image/ImageConsumer.java", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01/libjava%2Fjava%2Fawt%2Fimage%2FImageConsumer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01/libjava%2Fjava%2Fawt%2Fimage%2FImageConsumer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FImageConsumer.java?ref=ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01", "patch": "@@ -1,5 +1,5 @@\n /* ImageConsumer.java -- Java interface for image consumption\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -160,17 +160,45 @@\n     void setHints(int flags);\n \n     /**\n-     * This function delivers a rectangle of pixels where any\n-     * pixel(m,n) is stored in the array as a <code>byte</code> at\n-     * index (n * scansize + m + offset).  \n+     * Deliver a subset of an ImageProducer's pixels to this ImageConsumer.\n+     *\n+     * Each element of the pixels array represents one pixel.  The\n+     * pixel data is formatted according to the color model model.\n+     * The x and y parameters are the coordinates of the block of\n+     * pixels being delivered to this ImageConsumer.  They are\n+     * specified relative to the top left corner of the image being\n+     * produced.  Likewise, w and h are the pixel block's dimensions.\n+     *\n+     * @param x x coordinate of pixel block\n+     * @param y y coordinate of pixel block\n+     * @param w width of pixel block\n+     * @param h height of pixel block\n+     * @param model color model used to interpret pixel data\n+     * @param pixels pixel block data\n+     * @param offset offset into pixels array\n+     * @param scansize width of one row in the pixel block\n      */\n     void setPixels(int x, int y, int w, int h, \n \t   ColorModel model, byte[] pixels, int offset, int scansize);\n \n     /**\n-     * This function delivers a rectangle of pixels where any\n-     * pixel(m,n) is stored in the array as an <code>int</code> at\n-     * index (n * scansize + m + offset).  \n+     * Deliver a subset of an ImageProducer's pixels to this ImageConsumer.\n+     *\n+     * Each element of the pixels array represents one pixel.  The\n+     * pixel data is formatted according to the color model model.\n+     * The x and y parameters are the coordinates of the rectangular\n+     * region of pixels being delivered to this ImageConsumer,\n+     * specified relative to the top left corner of the image being\n+     * produced.  Likewise, w and h are the pixel region's dimensions.\n+     *\n+     * @param x x coordinate of pixel block\n+     * @param y y coordinate of pixel block\n+     * @param w width of pixel block\n+     * @param h height of pixel block\n+     * @param model color model used to interpret pixel data\n+     * @param pixels pixel block data\n+     * @param offset offset into pixels array\n+     * @param scansize width of one row in the pixel block\n      */\n     void setPixels(int x, int y, int w, int h, \n            ColorModel model, int[] pixels, int offset, int scansize);\n@@ -180,7 +208,9 @@ void setPixels(int x, int y, int w, int h,\n      * single frame or the entire image is complete.  The method is\n      * also used to indicate an error in loading or producing the\n      * image.  \n+     *\n+     * @param status the status of image production, represented by a\n+     * bitwise OR of ImageConsumer flags\n      */\n     void imageComplete(int status);\n }\n-"}, {"sha": "d6d2403399ed6d59c5d258f0e5360c42ade1a9e0", "filename": "libjava/java/awt/image/PixelGrabber.java", "status": "modified", "additions": 611, "deletions": 337, "changes": 948, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01/libjava%2Fjava%2Fawt%2Fimage%2FPixelGrabber.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01/libjava%2Fjava%2Fawt%2Fimage%2FPixelGrabber.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FPixelGrabber.java?ref=ec22cdf1405e694fb9b1c9557e6ef20baa7f7e01", "patch": "@@ -1,39 +1,39 @@\n-/* PixelGrabber.java -- Java class for providing image data \n-   Copyright (C) 1999 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n+/* PixelGrabber.java -- retrieve a subset of an image's data\n+   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n+\n+   This file is part of GNU Classpath.\n+\n+   GNU Classpath is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU Classpath is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU Classpath; see the file COPYING.  If not, write to the\n+   Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.\n+\n+   Linking this library statically or dynamically with other modules is\n+   making a combined work based on this library.  Thus, the terms and\n+   conditions of the GNU General Public License cover the whole\n+   combination.\n+\n+   As a special exception, the copyright holders of this library give you\n+   permission to link this library with independent modules to produce an\n+   executable, regardless of the license terms of these independent\n+   modules, and to copy and distribute the resulting executable under\n+   terms of your choice, provided that you also meet, for each linked\n+   independent module, the terms and conditions of the license of that\n+   module.  An independent module is a module which is not derived from\n+   or based on this library.  If you modify this library, you may extend\n+   this exception to your version of the library, but you are not\n+   obligated to do so.  If you do not wish to do so, delete this\n+   exception statement from your version. */\n \n \n package java.awt.image;\n@@ -42,309 +42,583 @@\n import java.util.Hashtable;\n \n /**\n-   PixelGrabber is an ImageConsumer designed to extract a rectangular region of pixels\n-   from an Image\n+ * PixelGrabber is an ImageConsumer that extracts a rectangular region\n+ * of pixels from an Image.\n  */\n-public class PixelGrabber implements ImageConsumer \n+public class PixelGrabber implements ImageConsumer\n {\n-    int x, y, width, height, status, scansize, offset;\n-    ColorModel model = ColorModel.getRGBdefault();\n-    //int hints;\n-    //Hashtable props;\n-    int pixel_bufferi[];\n-    byte pixel_bufferb[];\n-    boolean grabbing;\n-    ImageProducer ip;\n-\n-    /**\n-     * Create a PixelGrabber used to grab pixels from the specified Image \n-     * in the specified rectangle\n-     *\n-     * @param img the Image to grab pixels from\n-     * @param x the x coordinate of the rectangle\n-     * @param y the y coordinate of the rectangle\n-     * @param w the width of the rectangle\n-     * @param h the height of the rectangle\n-     * @param pixels the array of pixel values\n-     * @param offset the index of the first pixels in the <code>pixels</code> array\n-     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n-     */\n-    public PixelGrabber(Image img, int x, int y, int w, int h,\n-\t\t\tint pix[], int off, int scansize)\n-    {\n-\tthis( img.getSource(), x, y, w, h, pix, off, scansize );\n-    }\n-\n-    /**\n-     * Create a PixelGrabber used to grab pixels from the specified ImageProducer\n-     * in the specified rectangle\n-     *\n-     * @param ip the ImageProducer to grab pixels from\n-     * @param x the x coordinate of the rectangle\n-     * @param y the y coordinate of the rectangle\n-     * @param w the width of the rectangle\n-     * @param h the height of the rectangle\n-     * @param pixels the array of pixel values\n-     * @param offset the index of the first pixels in the <code>pixels</code> array\n-     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n-     */\n-    public PixelGrabber(ImageProducer ip, int x, int y, int w, int h,\n-\t\t\tint pix[], int off, int scansize)\n-    {\n-\tthis.ip = ip;\n-\tthis.x = x;\n-\tthis.y = y;\n-\tthis.width = w;\n-\tthis.height = h;\n-\tthis.pixel_bufferi = pix;\n-\tthis.offset = off;\n-\tthis.scansize = scansize;\n-\tpixel_bufferb = new byte[pix.length * 4];\n-    }\n-\n-\n-    /**\n-     * Create a PixelGrabber used to grab pixels from the specified Image \n-     * in the specified rectangle\n-     *\n-     * @param img the Image to grab pixels from\n-     * @param x the x coordinate of the rectangle\n-     * @param y the y coordinate of the rectangle\n-     * @param w the width of the rectangle\n-     * @param h the height of the rectangle\n-     * @param forceRGB true to force conversion to RGB\n-     */\n-    public PixelGrabber(Image img,\n-\t\t\tint x, int y,\n-\t\t\tint w, int h,\n-\t\t\tboolean forceRGB)\n-    {\n-\t//FIXME\n-    }\n-\n-    /**\n-       Start Grabbing Pixels\n-     */\n-    public synchronized void startGrabbing()\n-    {\n-\tif ( grabbing == false )\n+  int x, y, offset;\n+  int width = -1;\n+  int height = -1;\n+  int scansize = -1;\n+  boolean forceRGB = true;\n+\n+  ColorModel model = ColorModel.getRGBdefault();\n+  int hints;\n+  Hashtable props;\n+\n+  int int_pixel_buffer[];\n+  boolean ints_delivered = false;\n+  byte byte_pixel_buffer[];\n+  boolean bytes_delivered = false;\n+\n+  ImageProducer ip;\n+  int observerStatus;\n+  int consumerStatus;\n+\n+  private Thread grabberThread;\n+  boolean grabbing = false;\n+\n+  /**\n+   * Construct a PixelGrabber that will retrieve RGB data from a given\n+   * Image.\n+   *\n+   * The RGB data will be retrieved from a rectangular region\n+   * <code>(x, y, w, h)</code> within the image.  The data will be\n+   * stored in the provided <code>pix</code> array, which must have\n+   * been initialized to a size of at least <code>w * h</code>.  The\n+   * data for a pixel (m, n) in the grab rectangle will be stored at\n+   * <code>pix[(n - y) * scansize + (m - x) + off]</code>.\n+   *\n+   * @param img the Image from which to grab pixels\n+   * @param x the x coordinate, relative to <code>img</code>'s\n+   * top-left corner, of the grab rectangle's top-left pixel\n+   * @param y the y coordinate, relative to <code>img</code>'s\n+   * top-left corner, of the grab rectangle's top-left pixel\n+   * @param w the width of the grab rectangle, in pixels\n+   * @param h the height of the grab rectangle, in pixels\n+   * @param pix the array in which to store grabbed RGB pixel data\n+   * @param off the offset into the <code>pix</code> array at which to\n+   * start storing RGB data\n+   * @param scansize a set of <code>scansize</code> consecutive\n+   * elements in the <code>pix</code> array represents one row of\n+   * pixels in the grab rectangle\n+   */\n+  public PixelGrabber(Image img, int x, int y, int w, int h,\n+\t\t      int pix[], int off, int scansize)\n+  {\n+    this (img.getSource(), x, y, w, h, pix, off, scansize);\n+  }\n+\n+  /**\n+   * Construct a PixelGrabber that will retrieve RGB data from a given\n+   * ImageProducer.\n+   *\n+   * The RGB data will be retrieved from a rectangular region\n+   * <code>(x, y, w, h)</code> within the image produced by\n+   * <code>ip</code>.  The data will be stored in the provided\n+   * <code>pix</code> array, which must have been initialized to a\n+   * size of at least <code>w * h</code>.  The data for a pixel (m, n)\n+   * in the grab rectangle will be stored at\n+   * <code>pix[(n - y) * scansize + (m - x) + off]</code>.\n+   *\n+   * @param ip the ImageProducer from which to grab pixels\n+   * @param x the x coordinate of the grab rectangle's top-left pixel,\n+   * specified relative to the top-left corner of the image produced\n+   * by <code>ip</code>\n+   * @param y the y coordinate of the grab rectangle's top-left pixel,\n+   * specified relative to the top-left corner of the image produced\n+   * by <code>ip</code>\n+   * @param w the width of the grab rectangle, in pixels\n+   * @param h the height of the grab rectangle, in pixels\n+   * @param pix the array in which to store grabbed RGB pixel data\n+   * @param off the offset into the <code>pix</code> array at which to\n+   * start storing RGB data\n+   * @param scansize a set of <code>scansize</code> consecutive\n+   * elements in the <code>pix</code> array represents one row of\n+   * pixels in the grab rectangle\n+   */\n+  public PixelGrabber(ImageProducer ip, int x, int y, int w, int h,\n+\t\t      int pix[], int off, int scansize)\n+  {\n+    this.ip = ip;\n+    this.x = x;\n+    this.y = y;\n+    this.width = w;\n+    this.height = h;\n+    this.offset = off;\n+    this.scansize = scansize;\n+\n+    int_pixel_buffer = pix;\n+    // Initialize the byte array in case ip sends us byte-formatted\n+    // pixel data.\n+    byte_pixel_buffer = new byte[pix.length * 4];\n+  }\n+\n+  /**\n+   * Construct a PixelGrabber that will retrieve data from a given\n+   * Image.\n+   *\n+   * The RGB data will be retrieved from a rectangular region\n+   * <code>(x, y, w, h)</code> within the image.  The data will be\n+   * stored in an internal array which can be accessed by calling\n+   * <code>getPixels</code>.  The data for a pixel (m, n) in the grab\n+   * rectangle will be stored in the returned array at index\n+   * <code>(n - y) * scansize + (m - x) + off</code>.\n+   * If forceRGB is false, then the returned data will be not be\n+   * converted to RGB from its format in <code>img</code>.\n+   *\n+   * If <code>w</code> is negative, the width of the grab region will\n+   * be from x to the right edge of the image.  Likewise, if\n+   * <code>h</code> is negative, the height of the grab region will be\n+   * from y to the bottom edge of the image.\n+   *\n+   * @param img the Image from which to grab pixels\n+   * @param x the x coordinate, relative to <code>img</code>'s\n+   * top-left corner, of the grab rectangle's top-left pixel\n+   * @param y the y coordinate, relative to <code>img</code>'s\n+   * top-left corner, of the grab rectangle's top-left pixel\n+   * @param w the width of the grab rectangle, in pixels\n+   * @param h the height of the grab rectangle, in pixels\n+   * @param forceRGB true to force conversion of the rectangular\n+   * region's pixel data to RGB\n+   */\n+  public PixelGrabber(Image img,\n+\t\t      int x, int y,\n+\t\t      int w, int h,\n+\t\t      boolean forceRGB)\n+  {\n+    this.ip = img.getSource();\n+    this.x = x;\n+    this.y = y;\n+    width = w;\n+    height = h;\n+    // If width or height is negative, postpone pixel buffer\n+    // initialization until setDimensions is called back by ip.\n+    if (width >= 0 && height >= 0)\n+      {\n+\tint_pixel_buffer = new int[width * height];\n+\tbyte_pixel_buffer = new byte[width * height];\n+      }\n+    this.forceRGB = forceRGB;\n+  }\n+\n+  /**\n+   * Start grabbing pixels.\n+   *\n+   * Spawns an image production thread that calls back to this\n+   * PixelGrabber's ImageConsumer methods.\n+   */\n+  public synchronized void startGrabbing()\n+  {\n+    // Make sure we're not already grabbing.\n+    if (grabbing == false)\n+      {\n+\tgrabbing = true;\n+\tgrabberThread = new Thread ()\n+\t  {\n+\t    public void run ()\n \t    {\n-\t\tgrabbing = true;\n-\t\tip.startProduction( this );\n+\t      ip.startProduction (PixelGrabber.this);\n \t    }\n-    }\n-\n-    /**\n-       Abort the grabbing of pixels\n-     */\n-    public synchronized void abortGrabbing()\n-    {\n-\tif ( grabbing == true )\n-\t    {\n-\t\tgrabbing = false;\n-\t\tip.removeConsumer( this );\n-\t    }\n-    }\n-\n-    /**\n-       Grab the Pixels.\n-\n-       @return true if successful\n-\n-       @throws InterruptedException if interrupted by another thread.\n-     */\n-    public boolean grabPixels() throws InterruptedException\n-    {\n-      return grabPixels(0);\n-    }\n-\n-    /**\n-       Grab the Pixels and abort if it takes too long\n-\n-       @return true if successful\n-\n-       @throws InterruptedException if interrupted by another thread.\n-               or time runs out\n-     */\n-    public synchronized boolean grabPixels(long ms) throws InterruptedException\n-    {\n-\tstartGrabbing();\n-\t\n-\tif (ms < 0)\n-\t  return (status == ImageObserver.ALLBITS);\n-\t\n-\twait(ms);\n-\t\n-\tif (status == ImageObserver.ALLBITS)\n-\t    return true;\n-\telse\n-\t    return false;\n-    }\n-\n-    /**\n-       Get the status of the pixel grabbing representing by ImageObserver flags\n-\n-       @return the status\n-    */\n-    public synchronized int getStatus()\n-    {\n-\treturn status;\n-    }\n-\n-    /**\n-       Return width of pixel region\n-\n-       @return width of region\n-    */\n-    public synchronized int getWidth()\n-    {\n-\treturn width;\n-    }\n-\n-    /**\n-       Return height of pixel region\n-       \n-       @return height of region\n-    */\n-    public synchronized int getHeight()\n-    {\n-\treturn height;\n-    }\n-\n-    /**\n-       Returns the grabbed pixel buffer \n-\n-       @return a byte or int array\n-    */\n-    public synchronized Object getPixels()\n-    {\n-\tif( pixel_bufferi != null )\n-\t    return pixel_bufferi;\n-\treturn pixel_bufferb;\n-    }\n-\n-    /**\n-       Get the ColorModel of the image\n-       \n-       @return the ColorModel\n-    */\n-    public synchronized ColorModel getColorModel()\n-    {\n-\treturn model;\n-    }\n-\n-    /**\n-     * An <code>ImageProducer</code> indicates the size of the image\n-     * being produced using this method.\n-     * \n-     * @param width the width of the image\n-     * @param height the height of the image \n-     */\n-    public  void setDimensions(int width, int height)\n-    {\n-    }\n-\n-    /**\n-     * An <code>ImageProducer</code> can set a list of properties\n-     * associated with this image by using this method.\n-     *\n-     * @param props the list of properties associated with this image \n-     */\n-    public  void setProperties(Hashtable props)\n-    {\n-\t//this.props = props; //FIXME - DO WE NEED THIS\n-    }\n-\n-    /**\n-     * This <code>ColorModel</code> should indicate the model used by\n-     * the majority of calls to <code>setPixels</code>.  Each call to\n-     * <code>setPixels</code> could however indicate a different\n-     * <code>ColorModel</code>.\n-     *\n-     * @param model the color model to be used most often by setPixels\n-     * @see ColorModel \n-     */\n-    public  void setColorModel(ColorModel model)\n-    {\n-\tthis.model = model;\n-    }\n-\n-    /**\n-     * The <code>ImageProducer</code> should call this method with a\n-     * bit mask of hints from any of <code>RANDOMPIXELORDER</code>,\n-     * <code>TOPDOWNLEFTRIGHT</code>, <code>COMPLETESCANLINES</code>,\n-     * <code>SINGLEPASS</code>, <code>SINGLEFRAME</code>.\n-     * \n-     * @param flags a bit mask of hints\n-     */\n-    public  void setHints(int flags)\n-    {\n-\t//hints = flags; // FIXME - DO NOT KNOW WHAT TO DO WITH THE HINTS\n-    }\n-\n-    /**\n-     * This function delivers a rectangle of pixels where any\n-     * pixel(m,n) is stored in the array as a <code>byte</code> at\n-     * index (n * scansize + m + offset).  \n-     */\n-    public  void setPixels(int x, int y, int w, int h, \n-\t\t\t   ColorModel model, byte[] pixels, int offset, int scansize)\n-    {\n-\t//FIXME - I hate bytes\n-\tint xp, yp;\n-\tfor( xp = x; xp < ( x + w); xp++ )\n-\t    for( yp = y; yp < (y + h); yp++ )\n-\t\tif( xp >= this.x && \n-\t\t    yp >= this.y && \n-\t\t    xp <= ( this.x + this.width ) && \n-\t\t    yp <= ( this.y + this.height ) ) {\n-\t\t    pixel_bufferb[(yp - this.y) * this.scansize + (xp - this.x) + this.offset] =\n-\t\t\tpixels[ offset + yp * scansize + xp ];\n-\t\t}\n-\n-    }\n-\n-    /**\n-     * This function delivers a rectangle of pixels where any\n-     * pixel(m,n) is stored in the array as an <code>int</code> at\n-     * index (n * scansize + m + offset).  \n-     */\n-    public  void setPixels(int x, int y, int w, int h, \n-\t\t\t   ColorModel model, int[] pixels, int offset, int scansize)\n-    {\n-\tint xp, yp;\n-\tfor( xp = x; xp < ( x + w); xp++ )\n-\t    for( yp = y; yp < (y + h); yp++ )\n-\t\tif( xp >= this.x && \n-\t\t    yp >= this.y && \n-\t\t    xp <= ( this.x + this.width ) && \n-\t\t    yp <= ( this.y + this.height ) ) {\n-\t\t    pixel_bufferi[(yp - this.y) * this.scansize + (xp - this.x) + this.offset] =\n-\t\t\tpixels[ offset + yp * scansize + xp ];\n-\t\t}\n-    }\n-\n-    /**\n-     * The <code>ImageProducer</code> calls this method to indicate a\n-     * single frame or the entire image is complete.  The method is\n-     * also used to indicate an error in loading or producing the\n-     * image.  \n-     */\n-    public synchronized void imageComplete(int status)\n-    {\n-\tthis.status = status;\n-    }\n-\n-    /**\n-       Get the status of the pixel grabbing representing by ImageObserver flags\n-\n-       @return the status\n-       \n-       @specnote This method is not deprecated but getStatus is preferred to use\n-     */\n-    public synchronized int status()\n-    {\n-\treturn getStatus();\n-    }\n-\n+\t  };\n+\tgrabberThread.start ();\n+      }\n+  }\n+\n+  /**\n+   * Abort pixel grabbing.\n+   */\n+  public synchronized void abortGrabbing()\n+  {\n+    if (grabbing)\n+      {\n+\t// Interrupt the grabbing thread.\n+        Thread moribund = grabberThread;\n+        grabberThread = null;\n+        moribund.interrupt();\n+\n+\timageComplete (ImageConsumer.IMAGEABORTED);\n+      }\n+  }\n+\n+  /**\n+   * Have our Image or ImageProducer start sending us pixels via our\n+   * ImageConsumer methods and wait for all pixels in the grab\n+   * rectangle to be delivered.\n+   *\n+   * @return true if successful, false on abort or error\n+   *\n+   * @throws InterruptedException if interrupted by another thread.\n+   */\n+  public synchronized boolean grabPixels() throws InterruptedException\n+  {\n+    return grabPixels(0);\n+  }\n+\n+  /**\n+   * grabPixels's behavior depends on the value of <code>ms</code>.\n+   *\n+   * If ms < 0, return true if all pixels from the source image have\n+   * been delivered, false otherwise.  Do not wait.\n+   *\n+   * If ms >= 0 then we request that our Image or ImageProducer start\n+   * delivering pixels to us via our ImageConsumer methods.\n+   *\n+   * If ms > 0, wait at most <code>ms</code> milliseconds for\n+   * delivery of all pixels within the grab rectangle.\n+   *\n+   * If ms == 0, wait until all pixels have been delivered.\n+   *\n+   * @return true if all pixels from the source image have been\n+   * delivered, false otherwise\n+   *\n+   * @throws InterruptedException if this thread is interrupted while\n+   * we are waiting for pixels to be delivered\n+   */\n+  public synchronized boolean grabPixels(long ms) throws InterruptedException\n+  {\n+    if (ms < 0)\n+      return ((observerStatus & (ImageObserver.FRAMEBITS\n+\t\t\t\t | ImageObserver.ALLBITS)) != 0);\n+\n+    // Spawn a new ImageProducer thread to send us the image data via\n+    // our ImageConsumer methods.\n+    startGrabbing();\n+\n+    if (ms > 0)\n+      {\n+\tlong stop_time = System.currentTimeMillis() + ms;\n+\tlong time_remaining;\n+\twhile (grabbing)\n+\t  {\n+\t    time_remaining = stop_time - System.currentTimeMillis();\n+\t    if (time_remaining <= 0)\n+\t      break;\n+\t    wait (time_remaining);\n+\t  }\n+\tabortGrabbing ();\n+      }\n+    else\n+      wait ();\n+\n+    // If consumerStatus is non-zero then the image is done loading or\n+    // an error has occurred.\n+    if (consumerStatus != 0)\n+      return setObserverStatus ();\n+\n+    return ((observerStatus & (ImageObserver.FRAMEBITS\n+\t\t\t       | ImageObserver.ALLBITS)) != 0);\n+  }\n+\n+  // Set observer status flags based on the current consumer status\n+  // flags.  Return true if the consumer flags indicate that the\n+  // image was loaded successfully, or false otherwise.\n+  private synchronized boolean setObserverStatus ()\n+  {\n+    boolean retval = false;\n+\n+    if ((consumerStatus & IMAGEERROR) != 0)\n+      observerStatus |= ImageObserver.ERROR;\n+\n+    if ((consumerStatus & IMAGEABORTED) != 0)\n+      observerStatus |= ImageObserver.ABORT;\n+\n+    if ((consumerStatus & STATICIMAGEDONE) != 0)\n+      {\n+\tobserverStatus |= ImageObserver.ALLBITS;\n+\tretval = true;\n+      }\n+\n+    if ((consumerStatus & SINGLEFRAMEDONE) != 0)\n+      {\n+\tobserverStatus |= ImageObserver.FRAMEBITS;\n+\tretval = true;\n+      }\n+\n+    return retval;\n+  }\n+\n+  /**\n+   * @return the status of the pixel grabbing thread, represented by a\n+   * bitwise OR of ImageObserver flags\n+   */\n+  public synchronized int getStatus()\n+  {\n+    return observerStatus;\n+  }\n+\n+  /**\n+   * @return the width of the grab rectangle in pixels, or a negative\n+   * number if the ImageProducer has not yet called our setDimensions\n+   * method\n+   */\n+  public synchronized int getWidth()\n+  {\n+    return width;\n+  }\n+\n+  /**\n+   * @return the height of the grab rectangle in pixels, or a negative\n+   * number if the ImageProducer has not yet called our setDimensions\n+   * method\n+   */\n+  public synchronized int getHeight()\n+  {\n+    return height;\n+  }\n+\n+  /**\n+   * @return a byte array of pixel data if ImageProducer delivered\n+   * pixel data using the byte[] variant of setPixels, or an int array\n+   * otherwise\n+   */\n+  public synchronized Object getPixels()\n+  {\n+    if (ints_delivered)\n+      return int_pixel_buffer;\n+    else if (bytes_delivered)\n+      return byte_pixel_buffer;\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * @return the ColorModel currently being used for the majority of\n+   * pixel data conversions\n+   */\n+  public synchronized ColorModel getColorModel()\n+  {\n+    return model;\n+  }\n+\n+  /**\n+   * Our <code>ImageProducer</code> calls this method to indicate the\n+   * size of the image being produced.\n+   *\n+   * setDimensions is an ImageConsumer method.  None of PixelGrabber's\n+   * ImageConsumer methods should be called by code that instantiates\n+   * a PixelGrabber.  They are only made public so they can be called\n+   * by the PixelGrabber's ImageProducer.\n+   * \n+   * @param width the width of the image\n+   * @param height the height of the image\n+   */\n+  public synchronized void setDimensions(int width, int height)\n+  {\n+    // Our width wasn't set when we were constructed.  Set our width\n+    // so that the grab region includes all pixels from x to the right\n+    // edge of the source image.\n+    if (this.width < 0)\n+      this.width = width - x;\n+\n+    // Our height wasn't set when we were constructed.  Set our height\n+    // so that the grab region includes all pixels from y to the\n+    // bottom edge of the source image.\n+    if (this.height < 0)\n+      this.height = height - y;\n+\n+    if (scansize < 0)\n+      scansize = this.width;\n+\n+    if (int_pixel_buffer == null)\n+      int_pixel_buffer = new int[this.width * this.height];\n+\n+    if (byte_pixel_buffer == null)\n+      byte_pixel_buffer = new byte[this.width * this.height];\n+  }\n+\n+  /**\n+   * Our <code>ImageProducer</code> may call this method to send us a\n+   * list of its image's properties.\n+   *\n+   * setProperties is an ImageConsumer method.  None of PixelGrabber's\n+   * ImageConsumer methods should be called by code that instantiates\n+   * a PixelGrabber.  They are only made public so they can be called\n+   * by the PixelGrabber's ImageProducer.\n+   *\n+   * @param props a list of properties associated with the image being\n+   * produced\n+   */\n+  public synchronized void setProperties(Hashtable props)\n+  {\n+    this.props = props;\n+  }\n+\n+  /**\n+   * Our ImageProducer will call <code>setColorModel</code> to\n+   * indicate the model used by the majority of calls to\n+   * <code>setPixels</code>.  Each call to <code>setPixels</code>\n+   * could however indicate a different <code>ColorModel</code>.\n+   *\n+   * setColorModel is an ImageConsumer method.  None of PixelGrabber's\n+   * ImageConsumer methods should be called by code that instantiates\n+   * a PixelGrabber.  They are only made public so they can be called\n+   * by the PixelGrabber's ImageProducer.\n+   *\n+   * @param model the color model to be used most often by setPixels\n+   *\n+   * @see ColorModel\n+   */\n+  public synchronized void setColorModel(ColorModel model)\n+  {\n+    this.model = model;\n+  }\n+\n+  /**\n+   * Our <code>ImageProducer</code> may call this method with a\n+   * bit mask of hints from any of <code>RANDOMPIXELORDER</code>,\n+   * <code>TOPDOWNLEFTRIGHT</code>, <code>COMPLETESCANLINES</code>,\n+   * <code>SINGLEPASS</code>, <code>SINGLEFRAME</code>.\n+   * \n+   * setHints is an ImageConsumer method.  None of PixelGrabber's\n+   * ImageConsumer methods should be called by code that instantiates\n+   * a PixelGrabber.  They are only made public so they can be called\n+   * by the PixelGrabber's ImageProducer.\n+   *\n+   * @param flags a bit mask of hints\n+   */\n+  public synchronized void setHints(int flags)\n+  {\n+    hints = flags;\n+  }\n+\n+  /**\n+   * Our ImageProducer calls setPixels to deliver a subset of its\n+   * pixels.\n+   *\n+   * Each element of the pixels array represents one pixel.  The\n+   * pixel data is formatted according to the color model model.\n+   * The x and y parameters are the coordinates of the rectangular\n+   * region of pixels being delivered to this ImageConsumer,\n+   * specified relative to the top left corner of the image being\n+   * produced.  Likewise, w and h are the pixel region's dimensions.\n+   *\n+   * @param x x coordinate of pixel block\n+   * @param y y coordinate of pixel block\n+   * @param w width of pixel block\n+   * @param h height of pixel block\n+   * @param model color model used to interpret pixel data\n+   * @param pixels pixel block data\n+   * @param offset offset into pixels array\n+   * @param scansize width of one row in the pixel block\n+   */\n+  public synchronized void setPixels(int x, int y, int w, int h, \n+\t\t\t\t     ColorModel model, byte[] pixels,\n+\t\t\t\t     int offset, int scansize)\n+  {\n+    ColorModel currentModel;\n+    if (model != null)\n+      currentModel = model;\n+    else\n+      currentModel = this.model;\n+\n+    for(int yp = y; yp < (y + h); yp++)\n+      {\n+\tfor(int xp = x; xp < (x + w); xp++)\n+\t  {\n+\t    // Check if the coordinates (xp, yp) are within the\n+\t    // pixel block that we are grabbing.\n+\t    if(xp >= this.x\n+\t       && yp >= this.y\n+\t       && xp < (this.x + this.width)\n+\t       && yp < (this.y + this.height))\n+\t      {\n+\t\tint i = (yp - this.y) * this.scansize + (xp - this.x) + this.offset;\n+\t\tint p = (yp - y) * scansize + (xp - x) + offset;\n+\t\tif (forceRGB)\n+\t\t  {\n+\t\t    ints_delivered = true;\n+\n+\t\t    assert (i >= 0 && i < int_pixel_buffer.length);\n+\t\t    assert (p >= 0 && p < pixels.length);\n+\t\t    int_pixel_buffer[i] = currentModel.getRGB (pixels[p]);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    bytes_delivered = true;\n+\n+\t\t    assert (i >= 0 && i < byte_pixel_buffer.length);\n+\t\t    assert (p >= 0 && p < pixels.length);\n+\t\t    byte_pixel_buffer[i] = pixels[p];\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Our ImageProducer calls setPixels to deliver a subset of its\n+   * pixels.\n+   *\n+   * Each element of the pixels array represents one pixel.  The\n+   * pixel data is formatted according to the color model model.\n+   * The x and y parameters are the coordinates of the rectangular\n+   * region of pixels being delivered to this ImageConsumer,\n+   * specified relative to the top left corner of the image being\n+   * produced.  Likewise, w and h are the pixel region's dimensions.\n+   *\n+   * @param x x coordinate of pixel block\n+   * @param y y coordinate of pixel block\n+   * @param w width of pixel block\n+   * @param h height of pixel block\n+   * @param model color model used to interpret pixel data\n+   * @param pixels pixel block data\n+   * @param offset offset into pixels array\n+   * @param scansize width of one row in the pixel block\n+   */\n+  public synchronized void setPixels(int x, int y, int w, int h, \n+\t\t\t\t     ColorModel model, int[] pixels,\n+\t\t\t\t     int offset, int scansize)\n+  {\n+    ColorModel currentModel;\n+    if (model != null)\n+      currentModel = model;\n+    else\n+      currentModel = this.model;\n+\n+    ints_delivered = true;\n+\n+    for(int yp = y; yp < (y + h); yp++)\n+      {\n+\tfor(int xp = x; xp < (x + w); xp++)\n+\t  {\n+\t    // Check if the coordinates (xp, yp) are within the\n+\t    // pixel block that we are grabbing.\n+\t    if(xp >= this.x\n+\t       && yp >= this.y\n+\t       && xp < (this.x + this.width)\n+\t       && yp < (this.y + this.height))\n+\t      {\n+\t\tint i = (yp - this.y) * this.scansize + (xp - this.x) + this.offset;\n+\t\tint p = (yp - y) * scansize + (xp - x) + offset;\n+\t\tassert (i >= 0 && i < int_pixel_buffer.length);\n+\t\tassert (p >= 0 && p < pixels.length);\n+\t\tif (forceRGB)\n+\t\t  int_pixel_buffer[i] = currentModel.getRGB (pixels[p]);\n+\t\telse\n+\t\t  int_pixel_buffer[i] = pixels[p];\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Our <code>ImageProducer</code> calls this method to inform us\n+   * that a single frame or the entire image is complete.  The method\n+   * is also used to inform us of an error in loading or producing the\n+   * image.\n+   *\n+   * @param status the status of image production, represented by a\n+   * bitwise OR of ImageConsumer flags\n+   */\n+  public synchronized void imageComplete(int status)\n+  {\n+    consumerStatus = status;\n+    setObserverStatus ();\n+    grabbing = false;\n+    ip.removeConsumer (this);\n+\n+    notifyAll ();\n+  }\n+\n+  /**\n+   * @return the return value of getStatus\n+   *\n+   * @specnote The newer getStatus should be used in place of status.\n+   */\n+  public synchronized int status()\n+  {\n+    return getStatus();\n+  }\n }"}]}