{"sha": "b6c03bcd80e0128009dad84f8cf891c5df22029c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZjMDNiY2Q4MGUwMTI4MDA5ZGFkODRmOGNmODkxYzVkZjIyMDI5Yw==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-07-07T00:13:14Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-07-07T00:13:14Z"}, "message": "re PR target/27968 (gcc emits (undefined) ffreep opcode which is not understood by Solaris' /usr/ccs/bin/as when tuning for Athlon or Opteron CPUs)\n\n\n\tPR target/27968\n\t* configure.ac (HAVE_AS_IX86_FFREEP): On x86 targets check whether \n\tthe configured assembler supports the x87's ffreep mnemonic.\n\t* configure: Regenerate.\n\t* config.in: Regenerate.\n\n\t* config/i386/i386.c (output_387_ffreep): New function.\n\t(output_fp_compare): Use output_387_ffreep to emit ffreep insns.\n\t(output_387_reg_move): Likewise.\n\nFrom-SVN: r115237", "tree": {"sha": "184927de213b7f5deec32e4f23bb6484e24ec6ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/184927de213b7f5deec32e4f23bb6484e24ec6ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6c03bcd80e0128009dad84f8cf891c5df22029c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c03bcd80e0128009dad84f8cf891c5df22029c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6c03bcd80e0128009dad84f8cf891c5df22029c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c03bcd80e0128009dad84f8cf891c5df22029c/comments", "author": null, "committer": null, "parents": [{"sha": "33251a2dc31fe5157741af51027ea0a145465dfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33251a2dc31fe5157741af51027ea0a145465dfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33251a2dc31fe5157741af51027ea0a145465dfc"}], "stats": {"total": 99, "additions": 92, "deletions": 7}, "files": [{"sha": "58763d81195c682adb6559934ec2e45fec184d4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c03bcd80e0128009dad84f8cf891c5df22029c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c03bcd80e0128009dad84f8cf891c5df22029c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6c03bcd80e0128009dad84f8cf891c5df22029c", "patch": "@@ -1,3 +1,15 @@\n+2006-07-06  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR target/27968\n+\t* configure.ac (HAVE_AS_IX86_FFREEP): On x86 targets check whether \n+\tthe configured assembler supports the x87's ffreep mnemonic.\n+\t* configure: Regenerate.\n+\t* config.in: Regenerate.\n+\n+\t* config/i386/i386.c (output_387_ffreep): New function.\n+\t(output_fp_compare): Use output_387_ffreep to emit ffreep insns.\n+\t(output_387_reg_move): Likewise.\n+\n 2006-07-06  Paul Eggert  <eggert@cs.ucla.edu>\n \n \tPort to hosts whose 'sort' and 'tail' implementations\n@@ -10,7 +22,8 @@\n \n 2006-07-06  Zdenek Dvorak <dvorakz@suse.cz>\n \n-\t* tree-ssa-loop-niter.c (scev_probably_wraps_p): Fix typo in argument name.\n+\t* tree-ssa-loop-niter.c (scev_probably_wraps_p): Fix typo in\n+\targument name.\n \n 2006-07-06  David Edelsohn  <edelsohn@gnu.org>\n "}, {"sha": "47ba85080c2b5ae5b21b71cd15a96c30781ec751", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c03bcd80e0128009dad84f8cf891c5df22029c/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c03bcd80e0128009dad84f8cf891c5df22029c/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=b6c03bcd80e0128009dad84f8cf891c5df22029c", "patch": "@@ -203,6 +203,12 @@\n #endif\n \n \n+/* Define if your assembler supports the ffreep mnemonic. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_IX86_FFREEP\n+#endif\n+\n+\n /* Define if your assembler supports the lituse_jsrdirect relocation. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_AS_JSRDIRECT_RELOCS"}, {"sha": "fe0d516c05ee0bfd87703d0573b96dd5c6fa5ca0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c03bcd80e0128009dad84f8cf891c5df22029c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c03bcd80e0128009dad84f8cf891c5df22029c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b6c03bcd80e0128009dad84f8cf891c5df22029c", "patch": "@@ -8641,6 +8641,34 @@ output_fix_trunc (rtx insn, rtx *operands, int fisttp)\n   return \"\";\n }\n \n+/* Output code for x87 ffreep insn.  The OPNO argument, which may only\n+   have the values zero or one, indicates the ffreep insn's operand\n+   from the OPERANDS array.  */\n+\n+static const char *\n+output_387_ffreep (rtx *operands ATTRIBUTE_UNUSED, int opno)\n+{\n+  if (TARGET_USE_FFREEP)\n+#if HAVE_AS_IX86_FFREEP\n+    return opno ? \"ffreep\\t%y1\" : \"ffreep\\t%y0\";\n+#else\n+    switch (REGNO (operands[opno]))\n+      {\n+      case FIRST_STACK_REG + 0: return \".word\\t0xc0df\";\n+      case FIRST_STACK_REG + 1: return \".word\\t0xc1df\";\n+      case FIRST_STACK_REG + 2: return \".word\\t0xc2df\";\n+      case FIRST_STACK_REG + 3: return \".word\\t0xc3df\";\n+      case FIRST_STACK_REG + 4: return \".word\\t0xc4df\";\n+      case FIRST_STACK_REG + 5: return \".word\\t0xc5df\";\n+      case FIRST_STACK_REG + 6: return \".word\\t0xc6df\";\n+      case FIRST_STACK_REG + 7: return \".word\\t0xc7df\";\n+      }\n+#endif\n+\n+  return opno ? \"fstp\\t%y1\" : \"fstp\\t%y0\";\n+}\n+\n+\n /* Output code for INSN to compare OPERANDS.  EFLAGS_P is 1 when fcomi\n    should be used.  UNORDERED_P is true when fucom should be used.  */\n \n@@ -8685,7 +8713,7 @@ output_fp_compare (rtx insn, rtx *operands, int eflags_p, int unordered_p)\n       if (stack_top_dies)\n \t{\n \t  output_asm_insn (\"ftst\\n\\tfnstsw\\t%0\", operands);\n-\t  return TARGET_USE_FFREEP ? \"ffreep\\t%y1\" : \"fstp\\t%y1\";\n+\t  return output_387_ffreep (operands, 1);\n \t}\n       else\n \treturn \"ftst\\n\\tfnstsw\\t%0\";\n@@ -8708,7 +8736,7 @@ output_fp_compare (rtx insn, rtx *operands, int eflags_p, int unordered_p)\n \t    output_asm_insn (\"fucomip\\t{%y1, %0|%0, %y1}\", operands);\n \t  else\n \t    output_asm_insn (\"fcomip\\t{%y1, %0|%0, %y1}\", operands);\n-\t  return TARGET_USE_FFREEP ? \"ffreep\\t%y0\" : \"fstp\\t%y0\";\n+\t  return output_387_ffreep (operands, 0);\n \t}\n       else\n \t{\n@@ -18807,9 +18835,8 @@ output_387_reg_move (rtx insn, rtx *operands)\n   if (REG_P (operands[1])\n       && find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n     {\n-      if (REGNO (operands[0]) == FIRST_STACK_REG\n-\t  && TARGET_USE_FFREEP)\n-\treturn \"ffreep\\t%y0\";\n+      if (REGNO (operands[0]) == FIRST_STACK_REG)\n+\treturn output_387_ffreep (operands, 0);\n       return \"fstp\\t%y0\";\n     }\n   if (STACK_TOP_P (operands[0]))"}, {"sha": "507b4c3ecbe16af6eba0df0805a8cdd520c2c991", "filename": "gcc/configure", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c03bcd80e0128009dad84f8cf891c5df22029c/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c03bcd80e0128009dad84f8cf891c5df22029c/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=b6c03bcd80e0128009dad84f8cf891c5df22029c", "patch": "@@ -15046,6 +15046,39 @@ cat >>confdefs.h <<\\_ACEOF\n #define HAVE_AS_IX86_CMOV_SUN_SYNTAX 1\n _ACEOF\n \n+fi\n+\n+    echo \"$as_me:$LINENO: checking assembler for ffreep mnemonic\" >&5\n+echo $ECHO_N \"checking assembler for ffreep mnemonic... $ECHO_C\" >&6\n+if test \"${gcc_cv_as_ix86_ffreep+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  gcc_cv_as_ix86_ffreep=no\n+  if test x$gcc_cv_as != x; then\n+    echo 'ffreep %st(1)' > conftest.s\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }\n+    then\n+\tgcc_cv_as_ix86_ffreep=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+echo \"$as_me:$LINENO: result: $gcc_cv_as_ix86_ffreep\" >&5\n+echo \"${ECHO_T}$gcc_cv_as_ix86_ffreep\" >&6\n+if test $gcc_cv_as_ix86_ffreep = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_AS_IX86_FFREEP 1\n+_ACEOF\n+\n fi\n \n     # This one is used unconditionally by i386.[ch]; it is to be defined"}, {"sha": "5841da9bc87893711e365d0210fc521d8bff70c3", "filename": "gcc/configure.ac", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c03bcd80e0128009dad84f8cf891c5df22029c/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c03bcd80e0128009dad84f8cf891c5df22029c/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=b6c03bcd80e0128009dad84f8cf891c5df22029c", "patch": "@@ -1,7 +1,7 @@\n # configure.ac for GCC\n # Process this file with autoconf to generate a configuration script.\n \n-# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n # Free Software Foundation, Inc.\n \n #This file is part of GCC.\n@@ -2815,6 +2815,12 @@ foo:\tnop\n       [AC_DEFINE(HAVE_AS_IX86_CMOV_SUN_SYNTAX, 1,\n         [Define if your assembler supports the Sun syntax for cmov.])])\n \n+    gcc_GAS_CHECK_FEATURE([ffreep mnemonic],\n+      gcc_cv_as_ix86_ffreep,,,\n+      [ffreep %st(1)],,\n+      [AC_DEFINE(HAVE_AS_IX86_FFREEP, 1,\n+        [Define if your assembler supports the ffreep mnemonic.])])\n+\n     # This one is used unconditionally by i386.[ch]; it is to be defined\n     # to 1 if the feature is present, 0 otherwise.\n     gcc_GAS_CHECK_FEATURE([GOTOFF in data],"}]}