{"sha": "0be7287d81cd5d2aaea649e43818cc75eedf636d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJlNzI4N2Q4MWNkNWQyYWFlYTY0OWU0MzgxOGNjNzVlZWRmNjM2ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-05-03T19:19:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-05-03T19:19:56Z"}, "message": "lra-constraints.c (valid_address_p): Move earlier in file.\n\ngcc/\n\t* lra-constraints.c (valid_address_p): Move earlier in file.\n\tAdd a constraint argument to the address_info version.\n\t(satisfies_memory_constraint_p): New function.\n\t(satisfies_address_constraint_p): Likewise.\n\t(process_alt_operands, curr_insn_transform): Use them.\n\t(process_address): Pass the constraint to valid_address_p when\n\tchecking address operands.\n\nFrom-SVN: r210039", "tree": {"sha": "4e166c0a8fdd608ceb000def76d3f0c354ad87c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e166c0a8fdd608ceb000def76d3f0c354ad87c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0be7287d81cd5d2aaea649e43818cc75eedf636d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be7287d81cd5d2aaea649e43818cc75eedf636d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0be7287d81cd5d2aaea649e43818cc75eedf636d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be7287d81cd5d2aaea649e43818cc75eedf636d/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad782bc910e236c900a322542621eab056551ddd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad782bc910e236c900a322542621eab056551ddd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad782bc910e236c900a322542621eab056551ddd"}], "stats": {"total": 160, "additions": 102, "deletions": 58}, "files": [{"sha": "bcf7870ce41c296f4d8e5785840666e5eb1540b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be7287d81cd5d2aaea649e43818cc75eedf636d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be7287d81cd5d2aaea649e43818cc75eedf636d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0be7287d81cd5d2aaea649e43818cc75eedf636d", "patch": "@@ -1,3 +1,13 @@\n+2014-05-03  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* lra-constraints.c (valid_address_p): Move earlier in file.\n+\tAdd a constraint argument to the address_info version.\n+\t(satisfies_memory_constraint_p): New function.\n+\t(satisfies_address_constraint_p): Likewise.\n+\t(process_alt_operands, curr_insn_transform): Use them.\n+\t(process_address): Pass the constraint to valid_address_p when\n+\tchecking address operands.\n+\n 2014-05-03  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/mips/mips.c (mips_isa_rev): New variable."}, {"sha": "f59bf555544331af605cc095b5e8fc022ec0cc2b", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 92, "deletions": 58, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be7287d81cd5d2aaea649e43818cc75eedf636d/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be7287d81cd5d2aaea649e43818cc75eedf636d/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=0be7287d81cd5d2aaea649e43818cc75eedf636d", "patch": "@@ -317,6 +317,94 @@ in_mem_p (int regno)\n   return get_reg_class (regno) == NO_REGS;\n }\n \n+/* Return 1 if ADDR is a valid memory address for mode MODE in address\n+   space AS, and check that each pseudo has the proper kind of hard\n+   reg.\t */\n+static int\n+valid_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t rtx addr, addr_space_t as)\n+{\n+#ifdef GO_IF_LEGITIMATE_ADDRESS\n+  lra_assert (ADDR_SPACE_GENERIC_P (as));\n+  GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n+  return 0;\n+\n+ win:\n+  return 1;\n+#else\n+  return targetm.addr_space.legitimate_address_p (mode, addr, 0, as);\n+#endif\n+}\n+\n+/* Return whether address AD is valid.  If CONSTRAINT is null,\n+   check for general addresses, otherwise check the extra constraint\n+   CONSTRAINT.  */\n+static bool\n+valid_address_p (struct address_info *ad, const char *constraint = 0)\n+{\n+  /* Some ports do not check displacements for eliminable registers,\n+     so we replace them temporarily with the elimination target.  */\n+  rtx saved_base_reg = NULL_RTX;\n+  rtx saved_index_reg = NULL_RTX;\n+  rtx *base_term = strip_subreg (ad->base_term);\n+  rtx *index_term = strip_subreg (ad->index_term);\n+  if (base_term != NULL)\n+    {\n+      saved_base_reg = *base_term;\n+      lra_eliminate_reg_if_possible (base_term);\n+      if (ad->base_term2 != NULL)\n+\t*ad->base_term2 = *ad->base_term;\n+    }\n+  if (index_term != NULL)\n+    {\n+      saved_index_reg = *index_term;\n+      lra_eliminate_reg_if_possible (index_term);\n+    }\n+  bool ok_p = (constraint\n+#ifdef EXTRA_CONSTRAINT_STR\n+\t       ? EXTRA_CONSTRAINT_STR (*ad->outer, constraint[0], constraint)\n+#else\n+\t       ? false\n+#endif\n+\t       : valid_address_p (ad->mode, *ad->outer, ad->as));\n+  if (saved_base_reg != NULL_RTX)\n+    {\n+      *base_term = saved_base_reg;\n+      if (ad->base_term2 != NULL)\n+\t*ad->base_term2 = *ad->base_term;\n+    }\n+  if (saved_index_reg != NULL_RTX)\n+    *index_term = saved_index_reg;\n+  return ok_p;\n+}\n+\n+#ifdef EXTRA_CONSTRAINT_STR\n+/* Return true if, after elimination, OP satisfies extra memory constraint\n+   CONSTRAINT.  */\n+static bool\n+satisfies_memory_constraint_p (rtx op, const char *constraint)\n+{\n+  struct address_info ad;\n+\n+  if (!MEM_P (op))\n+    return false;\n+\n+  decompose_mem_address (&ad, op);\n+  return valid_address_p (&ad, constraint);\n+}\n+\n+/* Return true if, after elimination, OP satisfies extra address constraint\n+   CONSTRAINT.  */\n+static bool\n+satisfies_address_constraint_p (rtx op, const char *constraint)\n+{\n+  struct address_info ad;\n+\n+  decompose_lea_address (&ad, &op);\n+  return valid_address_p (&ad, constraint);\n+}\n+#endif\n+\n /* Initiate equivalences for LRA.  As we keep original equivalences\n    before any elimination, we need to make copies otherwise any change\n    in insns might change the equivalences.  */\n@@ -1941,7 +2029,7 @@ process_alt_operands (int only_alternative)\n #ifdef EXTRA_CONSTRAINT_STR\n \t\t      if (EXTRA_MEMORY_CONSTRAINT (c, p))\n \t\t\t{\n-\t\t\t  if (EXTRA_CONSTRAINT_STR (op, c, p))\n+\t\t\t  if (satisfies_memory_constraint_p (op, p))\n \t\t\t    win = true;\n \t\t\t  else if (spilled_pseudo_p (op))\n \t\t\t    win = true;\n@@ -1960,7 +2048,7 @@ process_alt_operands (int only_alternative)\n \t\t\t}\n \t\t      if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n \t\t\t{\n-\t\t\t  if (EXTRA_CONSTRAINT_STR (op, c, p))\n+\t\t\t  if (satisfies_address_constraint_p (op, p))\n \t\t\t    win = true;\n \n \t\t\t  /* If we didn't already win, we can reload\n@@ -2576,60 +2664,6 @@ process_alt_operands (int only_alternative)\n   return ok_p;\n }\n \n-/* Return 1 if ADDR is a valid memory address for mode MODE in address\n-   space AS, and check that each pseudo has the proper kind of hard\n-   reg.\t */\n-static int\n-valid_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t rtx addr, addr_space_t as)\n-{\n-#ifdef GO_IF_LEGITIMATE_ADDRESS\n-  lra_assert (ADDR_SPACE_GENERIC_P (as));\n-  GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n-  return 0;\n-\n- win:\n-  return 1;\n-#else\n-  return targetm.addr_space.legitimate_address_p (mode, addr, 0, as);\n-#endif\n-}\n-\n-/* Return whether address AD is valid.  */\n-\n-static bool\n-valid_address_p (struct address_info *ad)\n-{\n-  /* Some ports do not check displacements for eliminable registers,\n-     so we replace them temporarily with the elimination target.  */\n-  rtx saved_base_reg = NULL_RTX;\n-  rtx saved_index_reg = NULL_RTX;\n-  rtx *base_term = strip_subreg (ad->base_term);\n-  rtx *index_term = strip_subreg (ad->index_term);\n-  if (base_term != NULL)\n-    {\n-      saved_base_reg = *base_term;\n-      lra_eliminate_reg_if_possible (base_term);\n-      if (ad->base_term2 != NULL)\n-\t*ad->base_term2 = *ad->base_term;\n-    }\n-  if (index_term != NULL)\n-    {\n-      saved_index_reg = *index_term;\n-      lra_eliminate_reg_if_possible (index_term);\n-    }\n-  bool ok_p = valid_address_p (ad->mode, *ad->outer, ad->as);\n-  if (saved_base_reg != NULL_RTX)\n-    {\n-      *base_term = saved_base_reg;\n-      if (ad->base_term2 != NULL)\n-\t*ad->base_term2 = *ad->base_term;\n-    }\n-  if (saved_index_reg != NULL_RTX)\n-    *index_term = saved_index_reg;\n-  return ok_p;\n-}\n-\n /* Make reload base reg + disp from address AD.  Return the new pseudo.  */\n static rtx\n base_plus_disp_to_reg (struct address_info *ad)\n@@ -2832,7 +2866,7 @@ process_address (int nop, rtx *before, rtx *after)\n      EXTRA_CONSTRAINT_STR for the validation.  */\n   if (constraint[0] != 'p'\n       && EXTRA_ADDRESS_CONSTRAINT (constraint[0], constraint)\n-      && EXTRA_CONSTRAINT_STR (op, constraint[0], constraint))\n+      && valid_address_p (&ad, constraint))\n     return change_p;\n #endif\n \n@@ -3539,7 +3573,7 @@ curr_insn_transform (void)\n \t\t  break;\n #ifdef EXTRA_CONSTRAINT_STR\n \t\tif (EXTRA_MEMORY_CONSTRAINT (c, constraint)\n-\t\t    && EXTRA_CONSTRAINT_STR (tem, c, constraint))\n+\t\t    && satisfies_memory_constraint_p (tem, constraint))\n \t\t  break;\n #endif\n \t      }"}]}