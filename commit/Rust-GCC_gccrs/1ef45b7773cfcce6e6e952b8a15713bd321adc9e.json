{"sha": "1ef45b7773cfcce6e6e952b8a15713bd321adc9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVmNDViNzc3M2NmY2NlNmU2ZTk1MmI4YTE1NzEzYmQzMjFhZGM5ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-04-14T23:42:50Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-04-14T23:42:50Z"}, "message": "i386.c (x86_cmpxchg, x86_xadd): New.\n\n        * config/i386/i386.c (x86_cmpxchg, x86_xadd): New.\n        (ix86_compare_emitted): New.\n        (ix86_expand_compare): Use ix86_compare_emitted if set.\n        (ix86_expand_setcc): Only emit REG_EQUAL if both ix86_compare_op0\n        and ix86_compare_op0 are set.\n        * config/i386/i386.h (x86_cmpxchg, x86_xadd): Declare.\n        (TARGET_CMPXCHG, TARGET_XADD): New.\n        (ix86_compare_emitted): Declare.\n        * config/i386/i386.md: Include sync.md\n        (UNSPECV_CMPXCHG_1, UNSPECV_CMPXCHG_2): New.\n        (UNSPECV_XCHG, UNSPECV_LOCK): New.\n        * config/i386/sync.md: New file.\n\nFrom-SVN: r98155", "tree": {"sha": "4e525ea00c5d64969cf58aac3b3103b4bb6779d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e525ea00c5d64969cf58aac3b3103b4bb6779d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ef45b7773cfcce6e6e952b8a15713bd321adc9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef45b7773cfcce6e6e952b8a15713bd321adc9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ef45b7773cfcce6e6e952b8a15713bd321adc9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef45b7773cfcce6e6e952b8a15713bd321adc9e/comments", "author": null, "committer": null, "parents": [{"sha": "48ae6c138ca30c4c5e876a0be47c9a0b5c8bf5c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48ae6c138ca30c4c5e876a0be47c9a0b5c8bf5c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48ae6c138ca30c4c5e876a0be47c9a0b5c8bf5c2"}], "stats": {"total": 206, "additions": 201, "deletions": 5}, "files": [{"sha": "2e0aa6cd7492399d8ee563ca661c2cf629a3ac37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef45b7773cfcce6e6e952b8a15713bd321adc9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef45b7773cfcce6e6e952b8a15713bd321adc9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ef45b7773cfcce6e6e952b8a15713bd321adc9e", "patch": "@@ -1,3 +1,18 @@\n+2004-04-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (x86_cmpxchg, x86_xadd): New.\n+\t(ix86_compare_emitted): New.\n+\t(ix86_expand_compare): Use ix86_compare_emitted if set.\n+\t(ix86_expand_setcc): Only emit REG_EQUAL if both ix86_compare_op0\n+\tand ix86_compare_op0 are set.\n+\t* config/i386/i386.h (x86_cmpxchg, x86_xadd): Declare.\n+\t(TARGET_CMPXCHG, TARGET_XADD): New.\n+\t(ix86_compare_emitted): Declare.\n+\t* config/i386/i386.md: Include sync.md\n+\t(UNSPECV_CMPXCHG_1, UNSPECV_CMPXCHG_2): New.\n+\t(UNSPECV_XCHG, UNSPECV_LOCK): New.\n+\t* config/i386/sync.md: New file.\n+\n 2004-04-14  Richard Henderson  <rth@redhat.com>\n \n \tPR middle-end/14311"}, {"sha": "b543a7afe32269fea2cd6e03278469abc00051ab", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef45b7773cfcce6e6e952b8a15713bd321adc9e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef45b7773cfcce6e6e952b8a15713bd321adc9e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1ef45b7773cfcce6e6e952b8a15713bd321adc9e", "patch": "@@ -584,6 +584,10 @@ const int x86_ext_80387_constants = m_K6 | m_ATHLON | m_PENT4 | m_NOCONA | m_PPR\n const int x86_four_jump_limit = m_PPRO | m_ATHLON_K8 | m_PENT4 | m_NOCONA;\n const int x86_schedule = m_PPRO | m_ATHLON_K8 | m_K6 | m_PENT;\n const int x86_use_bt = m_ATHLON_K8;\n+/* Compare and exchange was added for 80486.  */\n+const int x86_cmpxchg = ~m_386;\n+/* Exchange and add was added for 80486.  */\n+const int x86_xadd = ~m_386;\n \n /* In case the average insn count for single function invocation is\n    lower than this constant, emit fast (but longer) prologue and\n@@ -727,6 +731,7 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n \n rtx ix86_compare_op0 = NULL_RTX;\n rtx ix86_compare_op1 = NULL_RTX;\n+rtx ix86_compare_emitted = NULL_RTX;\n \n #define MAX_386_STACK_LOCALS 3\n /* Size of the register save area.  */\n@@ -9049,7 +9054,12 @@ ix86_expand_compare (enum rtx_code code, rtx *second_test, rtx *bypass_test)\n   if (bypass_test)\n     *bypass_test = NULL_RTX;\n \n-  if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n+  if (ix86_compare_emitted)\n+    {\n+      ret = gen_rtx_fmt_ee (code, VOIDmode, ix86_compare_emitted, const0_rtx);\n+      ix86_compare_emitted = NULL_RTX;\n+    }\n+  else if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n     ret = ix86_expand_fp_compare (code, op0, op1, NULL_RTX,\n \t\t\t\t  second_test, bypass_test);\n   else\n@@ -9378,10 +9388,13 @@ ix86_expand_setcc (enum rtx_code code, rtx dest)\n     }\n \n   /* Attach a REG_EQUAL note describing the comparison result.  */\n-  equiv = simplify_gen_relational (code, QImode,\n-\t\t\t\t   GET_MODE (ix86_compare_op0),\n-\t\t\t\t   ix86_compare_op0, ix86_compare_op1);\n-  set_unique_reg_note (get_last_insn (), REG_EQUAL, equiv);\n+  if (ix86_compare_op0 && ix86_compare_op1)\n+    {\n+      equiv = simplify_gen_relational (code, QImode,\n+\t\t\t\t       GET_MODE (ix86_compare_op0),\n+\t\t\t\t       ix86_compare_op0, ix86_compare_op1);\n+      set_unique_reg_note (get_last_insn (), REG_EQUAL, equiv);\n+    }\n \n   return 1; /* DONE */\n }"}, {"sha": "5854944c8ec2b7b054a6c9f3aacb35778c46e67c", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef45b7773cfcce6e6e952b8a15713bd321adc9e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef45b7773cfcce6e6e952b8a15713bd321adc9e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=1ef45b7773cfcce6e6e952b8a15713bd321adc9e", "patch": "@@ -253,6 +253,7 @@ extern const int x86_sse_typeless_stores, x86_sse_load0_by_pxor;\n extern const int x86_use_ffreep;\n extern const int x86_inter_unit_moves, x86_schedule;\n extern const int x86_use_bt;\n+extern const int x86_cmpxchg, x86_xadd;\n extern int x86_prefetch_sse;\n \n #define TARGET_USE_LEAVE (x86_use_leave & TUNEMASK)\n@@ -333,6 +334,9 @@ extern int x86_prefetch_sse;\n #define TARGET_GNU_TLS (ix86_tls_dialect == TLS_DIALECT_GNU)\n #define TARGET_SUN_TLS (ix86_tls_dialect == TLS_DIALECT_SUN)\n \n+#define TARGET_CMPXCHG (x86_cmpxchg & (1 << ix86_arch))\n+#define TARGET_XADD (x86_xadd & (1 << ix86_arch))\n+\n /* WARNING: Do not mark empty strings for translation, as calling\n             gettext on an empty string does NOT return an empty\n             string.  */\n@@ -2463,6 +2467,7 @@ extern enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER];\n \n extern rtx ix86_compare_op0;\t/* operand 0 for comparisons */\n extern rtx ix86_compare_op1;\t/* operand 1 for comparisons */\n+extern rtx ix86_compare_emitted;\n \f\n /* To properly truncate FP values into integers, we need to set i387 control\n    word.  We can't emit proper mode switching code before reload, as spills"}, {"sha": "f60d3d2be25d0d16df4e9b6965f2e84cc2e37a36", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef45b7773cfcce6e6e952b8a15713bd321adc9e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef45b7773cfcce6e6e952b8a15713bd321adc9e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=1ef45b7773cfcce6e6e952b8a15713bd321adc9e", "patch": "@@ -151,6 +151,10 @@\n    (UNSPECV_ALIGN\t\t7)\n    (UNSPECV_MONITOR\t\t8)\n    (UNSPECV_MWAIT\t\t9)\n+   (UNSPECV_CMPXCHG_1\t\t10)\n+   (UNSPECV_CMPXCHG_2\t\t11)\n+   (UNSPECV_XCHG\t\t12)\n+   (UNSPECV_LOCK\t\t13)\n   ])\n \n ;; Registers by name.\n@@ -19757,3 +19761,4 @@\n \n (include \"sse.md\")\n (include \"mmx.md\")\n+(include \"sync.md\")"}, {"sha": "477b398185b2c9aa03c2b3705faf736503227bf7", "filename": "gcc/config/i386/sync.md", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef45b7773cfcce6e6e952b8a15713bd321adc9e/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef45b7773cfcce6e6e952b8a15713bd321adc9e/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=1ef45b7773cfcce6e6e952b8a15713bd321adc9e", "patch": "@@ -0,0 +1,158 @@\n+;; GCC machine description for i386 synchronization instructions.\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+(define_mode_macro IMODE [QI HI SI (DI \"TARGET_64BIT\")])\n+(define_mode_attr modesuffix [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n+(define_mode_attr modeconstraint [(QI \"q\") (HI \"r\") (SI \"r\") (DI \"r\")])\n+(define_mode_attr immconstraint [(QI \"i\") (HI \"i\") (SI \"i\") (DI \"e\")])\n+\n+;; ??? It would be possible to use cmpxchg8b on pentium for DImode\n+;; changes.  It's complicated because the insn uses ecx:ebx as the\n+;; new value; note that the registers are reversed from the order\n+;; that they'd be in with (reg:DI 2 ecx).  Similarly for TImode \n+;; data in 64-bit mode.\n+\n+(define_insn \"sync_compare_and_swap<mode>\"\n+  [(set (match_operand:IMODE 0 \"register_operand\" \"=a\")\n+\t(unspec_volatile:IMODE\n+\t  [(match_operand:IMODE 1 \"memory_operand\" \"+m\")\n+\t   (match_operand:IMODE 2 \"register_operand\" \"a\")\n+\t   (match_operand:IMODE 3 \"register_operand\" \"<modeconstraint>\")]\n+\t  UNSPECV_CMPXCHG_1))\n+   (set (match_dup 1)\n+\t(unspec_volatile:IMODE\n+\t  [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG_2))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_CMPXCHG\"\n+  \"lock\\;cmpxchg{<modesuffix>}\\t{%3, %1|%1, %3}\")\n+\n+(define_expand \"sync_compare_and_swap_cc<mode>\"\n+  [(parallel\n+    [(set (match_operand:IMODE 0 \"register_operand\" \"\")\n+\t  (unspec_volatile:IMODE\n+\t    [(match_operand:IMODE 1 \"memory_operand\" \"\")\n+\t     (match_operand:IMODE 2 \"register_operand\" \"\")\n+\t     (match_operand:IMODE 3 \"register_operand\" \"\")]\n+\t    UNSPECV_CMPXCHG_1))\n+     (set (match_dup 1)\n+\t  (unspec_volatile:IMODE\n+\t    [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG_2))\n+     (set (match_dup 4)\n+\t  (compare:CCZ\n+\t    (unspec_volatile:IMODE\n+\t      [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG_1)\n+\t    (match_dup 3)))])]\n+  \"TARGET_CMPXCHG\"\n+{\n+  operands[4] = gen_rtx_REG (CCZmode, FLAGS_REG);\n+  ix86_compare_op0 = operands[3];\n+  ix86_compare_op1 = NULL;\n+  ix86_compare_emitted = operands[4];\n+})\n+\n+(define_insn \"*sync_compare_and_swap_cc<mode>\"\n+  [(set (match_operand:IMODE 0 \"register_operand\" \"=a\")\n+\t(unspec_volatile:IMODE\n+\t  [(match_operand:IMODE 1 \"memory_operand\" \"+m\")\n+\t   (match_operand:IMODE 2 \"register_operand\" \"a\")\n+\t   (match_operand:IMODE 3 \"register_operand\" \"<modeconstraint>\")]\n+\t  UNSPECV_CMPXCHG_1))\n+   (set (match_dup 1)\n+\t(unspec_volatile:IMODE\n+\t  [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG_2))\n+   (set (reg:CCZ FLAGS_REG)\n+\t(compare:CCZ\n+\t  (unspec_volatile:IMODE\n+\t    [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG_1)\n+\t  (match_dup 3)))]\n+  \"TARGET_CMPXCHG\"\n+  \"lock\\;cmpxchg{<modesuffix>}\\t{%3, %1|%1, %3}\")\n+\n+(define_insn \"sync_old_add<mode>\"\n+  [(set (match_operand:IMODE 0 \"register_operand\" \"=<modeconstraint>\")\n+\t(unspec_volatile:IMODE\n+\t  [(match_operand:IMODE 1 \"memory_operand\" \"+m\")] UNSPECV_XCHG))\n+   (set (match_dup 1)\n+\t(plus:IMODE (match_dup 1)\n+\t\t    (match_operand:IMODE 2 \"register_operand\" \"0\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_XADD\"\n+  \"lock\\;xadd{<modesuffix>}\\t{%0, %1|%1, %0}\")\n+\n+;; Recall that xchg implicitly sets LOCK#, so adding it again wastes space.\n+(define_insn \"sync_lock_test_and_set<mode>\"\n+  [(set (match_operand:IMODE 0 \"register_operand\" \"=<modeconstraint>\")\n+\t(unspec_volatile:IMODE\n+\t  [(match_operand:IMODE 1 \"memory_operand\" \"+m\")] UNSPECV_XCHG))\n+   (set (match_dup 1)\n+\t(match_operand:IMODE 2 \"register_operand\" \"0\"))]\n+  \"\"\n+  \"xchg{<modesuffix>}\\t{%1, %0|%0, %1}\")\n+\n+(define_insn \"sync_add<mode>\"\n+  [(set (match_operand:IMODE 0 \"memory_operand\" \"=m\")\n+\t(unspec_volatile:IMODE\n+\t  [(plus:IMODE (match_dup 0)\n+\t     (match_operand:IMODE 1 \"nonmemory_operand\" \"r<immconstraint>\"))]\n+\t  UNSPECV_LOCK))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"lock\\;add{<modesuffix>}\\t{%1, %0|%0, %1}\")\n+\n+(define_insn \"sync_sub<mode>\"\n+  [(set (match_operand:IMODE 0 \"memory_operand\" \"=m\")\n+\t(unspec_volatile:IMODE\n+\t  [(minus:IMODE (match_dup 0)\n+\t     (match_operand:IMODE 1 \"nonmemory_operand\" \"r<immconstraint>\"))]\n+\t  UNSPECV_LOCK))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"lock\\;sub{<modesuffix>}\\t{%1, %0|%0, %1}\")\n+\n+(define_insn \"sync_ior<mode>\"\n+  [(set (match_operand:IMODE 0 \"memory_operand\" \"=m\")\n+\t(unspec_volatile:IMODE\n+\t  [(ior:IMODE (match_dup 0)\n+\t     (match_operand:IMODE 1 \"nonmemory_operand\" \"r<immconstraint>\"))]\n+\t  UNSPECV_LOCK))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"lock\\;or{<modesuffix>}\\t{%1, %0|%0, %1}\")\n+\n+(define_insn \"sync_and<mode>\"\n+  [(set (match_operand:IMODE 0 \"memory_operand\" \"=m\")\n+\t(unspec_volatile:IMODE\n+\t  [(and:IMODE (match_dup 0)\n+\t     (match_operand:IMODE 1 \"nonmemory_operand\" \"r<immconstraint>\"))]\n+\t  UNSPECV_LOCK))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"lock\\;and{<modesuffix>}\\t{%1, %0|%0, %1}\")\n+\n+(define_insn \"sync_xor<mode>\"\n+  [(set (match_operand:IMODE 0 \"memory_operand\" \"=m\")\n+\t(unspec_volatile:IMODE\n+\t  [(xor:IMODE (match_dup 0)\n+\t     (match_operand:IMODE 1 \"nonmemory_operand\" \"r<immconstraint>\"))]\n+\t  UNSPECV_LOCK))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"lock\\;xor{<modesuffix>}\\t{%1, %0|%0, %1}\")"}]}