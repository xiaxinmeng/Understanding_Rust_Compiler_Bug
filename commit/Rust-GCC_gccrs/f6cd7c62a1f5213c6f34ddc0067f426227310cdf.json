{"sha": "f6cd7c62a1f5213c6f34ddc0067f426227310cdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZjZDdjNjJhMWY1MjEzYzZmMzRkZGMwMDY3ZjQyNjIyNzMxMGNkZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "r.sandiford@redhat.com", "date": "2000-12-06T03:56:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-12-06T03:56:43Z"}, "message": "mn10300.c (mn10300_print_reg_list): Added.\n\n2000-12-05  Richard Sandiford  <r.sandiford@redhat.com>\n\n\t* config/mn10300/mn10300.c (mn10300_print_reg_list): Added.\n\t(mn10300_get_live_callee_saved_regs): Likewise.\n\t(mn10300_gen_multiple_store): Likewise.\n\t(store_multiple_operation): Likewise.\n\t(expand_prologue): Use mn10300_gen_multiple_store().\n\t* config/mn10300/mn10300-protos.h (mn10300_print_reg_list): Added.\n\t(mn10300_get_live_callee_saved_regs): Likewise.\n\t(mn10300_gen_multiple_store): Likewise.\n\t(store_multiple_operation): Likewise.\n\t* config/mn10300/mn10300.md (store_movm): Use a MATCH_PARALLEL\n\ttied to store_multiple_operation().\n\nFrom-SVN: r38062", "tree": {"sha": "abea5247ce4be47b3e7df3bbcaf8a24e8b2bfe46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abea5247ce4be47b3e7df3bbcaf8a24e8b2bfe46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6cd7c62a1f5213c6f34ddc0067f426227310cdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6cd7c62a1f5213c6f34ddc0067f426227310cdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6cd7c62a1f5213c6f34ddc0067f426227310cdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6cd7c62a1f5213c6f34ddc0067f426227310cdf/comments", "author": null, "committer": null, "parents": [{"sha": "598730fe6e7b2da6bbc72a7a5a1cdd189381e9e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598730fe6e7b2da6bbc72a7a5a1cdd189381e9e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/598730fe6e7b2da6bbc72a7a5a1cdd189381e9e7"}], "stats": {"total": 336, "additions": 239, "deletions": 97}, "files": [{"sha": "69b5ecccf41ad89a25ecdf5776ceed8f157675bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cd7c62a1f5213c6f34ddc0067f426227310cdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cd7c62a1f5213c6f34ddc0067f426227310cdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6cd7c62a1f5213c6f34ddc0067f426227310cdf", "patch": "@@ -1,3 +1,17 @@\n+2000-12-05  Richard Sandiford  <r.sandiford@redhat.com>\n+\n+\t* config/mn10300/mn10300.c (mn10300_print_reg_list): Added.\n+\t(mn10300_get_live_callee_saved_regs): Likewise.\n+\t(mn10300_gen_multiple_store): Likewise.\n+\t(store_multiple_operation): Likewise.\n+\t(expand_prologue): Use mn10300_gen_multiple_store().\n+\t* config/mn10300/mn10300-protos.h (mn10300_print_reg_list): Added.\n+\t(mn10300_get_live_callee_saved_regs): Likewise.\n+\t(mn10300_gen_multiple_store): Likewise.\n+\t(store_multiple_operation): Likewise.\n+\t* config/mn10300/mn10300.md (store_movm): Use a MATCH_PARALLEL\n+\ttied to store_multiple_operation().\n+\n Tue Dec  5 20:09:14 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* builtins.c (expand_builtin_setjmp_setup): Set"}, {"sha": "ee4a443cc03e1fd26c2e6fab79e097a7fbda1b53", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cd7c62a1f5213c6f34ddc0067f426227310cdf/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cd7c62a1f5213c6f34ddc0067f426227310cdf/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=f6cd7c62a1f5213c6f34ddc0067f426227310cdf", "patch": "@@ -28,10 +28,14 @@ extern void mn10300_va_start PARAMS ((int, tree, rtx));\n extern struct rtx_def *legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n+extern void mn10300_print_reg_list PARAMS ((FILE *, int));\n+extern int mn10300_get_live_callee_saved_regs PARAMS ((void));\n+extern void mn10300_gen_multiple_store PARAMS ((int));\n extern void notice_update_cc PARAMS ((rtx, rtx));\n extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t      enum machine_mode, rtx));\n extern char *output_tst PARAMS ((rtx, rtx));\n+extern int store_multiple_operation PARAMS ((rtx, enum machine_mode));\n extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int call_address_operand PARAMS ((rtx, enum machine_mode));\n extern int impossible_plus_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "bc6b1fc3c87670f12d388660722bc8820a08f733", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 210, "deletions": 8, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cd7c62a1f5213c6f34ddc0067f426227310cdf/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cd7c62a1f5213c6f34ddc0067f426227310cdf/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=f6cd7c62a1f5213c6f34ddc0067f426227310cdf", "patch": "@@ -361,6 +361,45 @@ print_operand_address (file, addr)\n     }\n }\n \n+/* Print a set of registers in the format required by \"movm\" and \"ret\".\n+   Register K is saved if bit K of MASK is set.  The data and address\n+   registers can be stored individually, but the extended registers cannot.\n+   We assume that the mask alread takes that into account.  For instance,\n+   bits 14 to 17 must have the same value. */\n+\n+void\n+mn10300_print_reg_list (file, mask)\n+     FILE *file;\n+     int mask;\n+{\n+  int need_comma;\n+  int i;\n+\n+  need_comma = 0;\n+  fputc ('[', file);\n+\n+  for (i = 0; i < FIRST_EXTENDED_REGNUM; i++)\n+    if ((mask & (1 << i)) != 0)\n+      {\n+\tif (need_comma)\n+\t  fputc (',', file);\n+\tfputs (reg_names [i], file);\n+\tneed_comma = 1;\n+      }\n+\n+  if ((mask & 0x3c000) != 0)\n+    {\n+      if ((mask & 0x3c000) != 0x3c000)\n+\tabort();\n+      if (need_comma)\n+\tfputc (',', file);\n+      fputs (\"exreg1\", file);\n+      need_comma = 1;\n+    }\n+\n+  fputc (']', file);\n+}\n+\n int\n can_use_return_insn ()\n {\n@@ -383,6 +422,94 @@ can_use_return_insn ()\n \t  && !frame_pointer_needed);\n }\n \n+/* Returns the set of live, callee-saved registers as a bitmask.  The\n+   callee-saved extended registers cannot be stored individually, so\n+   all of them will be included in the mask if any one of them is used. */\n+\n+int\n+mn10300_get_live_callee_saved_regs ()\n+{\n+  int mask;\n+  int i;\n+\n+  mask = 0;\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (regs_ever_live[i] && ! call_used_regs[i])\n+      mask |= (1 << i);\n+  if ((mask & 0x3c000) != 0)\n+    mask |= 0x3c000;\n+\n+  return mask;\n+}\n+\n+/* Generate an instruction that pushes several registers onto the stack.\n+   Register K will be saved if bit K in MASK is set.  The function does\n+   nothing if MASK is zero.\n+\n+   To be compatible with the \"movm\" instruction, the lowest-numbered\n+   register must be stored in the lowest slot.  If MASK is the set\n+   { R1,...,RN }, where R1...RN are ordered least first, the generated\n+   instruction will have the form:\n+\n+       (parallel\n+         (set (reg:SI 9) (plus:SI (reg:SI 9) (const_int -N*4)))\n+\t (set (mem:SI (plus:SI (reg:SI 9)\n+\t                       (const_int -1*4)))\n+\t      (reg:SI RN))\n+\t ...\n+\t (set (mem:SI (plus:SI (reg:SI 9)\n+\t                       (const_int -N*4)))\n+\t      (reg:SI R1))) */\n+\n+void\n+mn10300_gen_multiple_store (mask)\n+     int mask;\n+{\n+  if (mask != 0)\n+    {\n+      int i;\n+      int count;\n+      rtx par;\n+      int pari;\n+\n+      /* Count how many registers need to be saved. */\n+      count = 0;\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif ((mask & (1 << i)) != 0)\n+\t  count += 1;\n+\n+      /* We need one PARALLEL element to update the stack pointer and\n+\t an additional element for each register that is stored. */\n+      par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 1));\n+\n+      /* Create the instruction that updates the stack pointer. */\n+      XVECEXP (par, 0, 0)\n+\t= gen_rtx_SET (SImode,\n+\t\t       stack_pointer_rtx,\n+\t\t       gen_rtx_PLUS (SImode,\n+\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t     GEN_INT (-count * 4)));\n+\n+      /* Create each store. */\n+      pari = 1;\n+      for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n+\tif ((mask & (1 << i)) != 0)\n+\t  {\n+\t    rtx address = gen_rtx_PLUS (SImode,\n+\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (-pari * 4));\n+\t    XVECEXP(par, 0, pari)\n+\t      = gen_rtx_SET (VOIDmode,\n+\t\t\t     gen_rtx_MEM (SImode, address),\n+\t\t\t     gen_rtx_REG (SImode, i));\n+\t    pari += 1;\n+\t  }\n+\n+      par = emit_insn (par);\n+      RTX_FRAME_RELATED_P (par) = 1;\n+    }\n+}\n+\n void\n expand_prologue ()\n {\n@@ -404,14 +531,8 @@ expand_prologue ()\n \t\t      gen_rtx_REG (SImode, 1));\n     }\n \n-  /* And now store all the registers onto the stack with a\n-     single two byte instruction.  */\n-  if (regs_ever_live[2] || regs_ever_live[3]\n-      || regs_ever_live[6] || regs_ever_live[7]\n-      || regs_ever_live[14] || regs_ever_live[15]\n-      || regs_ever_live[16] || regs_ever_live[17]\n-      || frame_pointer_needed)\n-    emit_insn (gen_store_movm ());\n+  /* If we use any of the callee-saved registers, save them now. */\n+  mn10300_gen_multiple_store (mn10300_get_live_callee_saved_regs ());\n \n   /* Now put the frame pointer into the frame pointer register.  */\n   if (frame_pointer_needed)\n@@ -532,6 +653,87 @@ notice_update_cc (body, insn)\n     }\n }\n \n+/* Recognise the PARALLEL rtx generated by mn10300_gen_multiple_store().\n+   This function is for MATCH_PARALLEL and so assumes OP is known to be\n+   parallel.  If OP is a multiple store, return a mask indicating which\n+   registers it saves.  Return 0 otherwise.  */\n+\n+int\n+store_multiple_operation (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  int count;\n+  int mask;\n+  int i;\n+  unsigned int last;\n+  rtx elt;\n+\n+  count = XVECLEN (op, 0);\n+  if (count < 2)\n+    return 0;\n+\n+  /* Check that first instruction has the form (set (sp) (plus A B)) */\n+  elt = XVECEXP (op, 0, 0);\n+  if (GET_CODE (elt) != SET\n+      || GET_CODE (SET_DEST (elt)) != REG\n+      || REGNO (SET_DEST (elt)) != STACK_POINTER_REGNUM\n+      || GET_CODE (SET_SRC (elt)) != PLUS)\n+    return 0;\n+\n+  /* Check that A is the stack pointer and B is the expected stack size.\n+     For OP to match, each subsequent instruction should push a word onto\n+     the stack.  We therefore expect the first instruction to create\n+     COUNT-1 stack slots. */\n+  elt = SET_SRC (elt);\n+  if (GET_CODE (XEXP (elt, 0)) != REG\n+      || REGNO (XEXP (elt, 0)) != STACK_POINTER_REGNUM\n+      || GET_CODE (XEXP (elt, 1)) != CONST_INT\n+      || INTVAL (XEXP (elt, 1)) != -(count - 1) * 4)\n+    return 0;\n+\n+  /* Now go through the rest of the vector elements.  They must be\n+     ordered so that the first instruction stores the highest-numbered\n+     register to the highest stack slot and that subsequent instructions\n+     store a lower-numbered register to the slot below.\n+\n+     LAST keeps track of the smallest-numbered register stored so far.\n+     MASK is the set of stored registers. */\n+  last = FIRST_PSEUDO_REGISTER;\n+  mask = 0;\n+  for (i = 1; i < count; i++)\n+    {\n+      /* Check that element i is a (set (mem M) R) and that R is valid. */\n+      elt = XVECEXP (op, 0, i);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || REGNO (SET_SRC (elt)) >= last)\n+\treturn 0;\n+\n+      /* R was OK, so provisionally add it to MASK.  We return 0 in any\n+\t case if the rest of the instruction has a flaw. */\n+      last = REGNO (SET_SRC (elt));\n+      mask |= (1 << last);\n+\n+      /* Check that M has the form (plus (sp) (const_int -I*4)) */\n+      elt = XEXP (SET_DEST (elt), 0);\n+      if (GET_CODE (elt) != PLUS\n+\t  || GET_CODE (XEXP (elt, 0)) != REG\n+\t  || REGNO (XEXP (elt, 0)) != STACK_POINTER_REGNUM\n+\t  || GET_CODE (XEXP (elt, 1)) != CONST_INT\n+\t  || INTVAL (XEXP (elt, 1)) != -i * 4)\n+\treturn 0;\n+    }\n+\n+  /* All or none of the callee-saved extended registers must be in the set. */\n+  if ((mask & 0x3c000) != 0\n+      && (mask & 0x3c000) != 0x3c000)\n+    return 0;\n+\n+  return mask;\n+}\n+\n /* Return true if OP is a valid call operand.  */\n \n int"}, {"sha": "564a4c95d34c1627c2ed76aee53bf3bc0051d720", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 11, "deletions": 89, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cd7c62a1f5213c6f34ddc0067f426227310cdf/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cd7c62a1f5213c6f34ddc0067f426227310cdf/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=f6cd7c62a1f5213c6f34ddc0067f426227310cdf", "patch": "@@ -1996,106 +1996,28 @@\n   \"\"\n   \"*\n {\n-  int need_comma;\n-\n-  need_comma = 0;\n-  fputs (\\\"\\\\tret [\\\", asm_out_file);\n-  if (regs_ever_live[2])\n-    {\n-      fputs (\\\"d2\\\", asm_out_file);\n-      need_comma = 1;\n-    }\n-  if (regs_ever_live[3])\n-    {\n-      if (need_comma)\n-\tfputc (',', asm_out_file); \n-      fputs (\\\"d3\\\", asm_out_file);\n-      need_comma = 1;\n-    }\n-  if (regs_ever_live[6])\n-    {\n-      if (need_comma)\n-\tfputc (',', asm_out_file); \n-      fputs (\\\"a2\\\", asm_out_file);\n-      need_comma = 1;\n-    }\n-  if (regs_ever_live[7])\n-    {\n-      if (need_comma)\n-\tfputc (',', asm_out_file); \n-      fputs (\\\"a3\\\", asm_out_file);\n-      need_comma = 1;\n-    }\n-  if (regs_ever_live[14] || regs_ever_live[15]\n-      || regs_ever_live[16] || regs_ever_live[17])\n-    {\n-      if (need_comma)\n-\tfputc (',', asm_out_file); \n-      fputs (\\\"exreg1\\\", asm_out_file);\n-      need_comma = 1;\n-    }\n-  fprintf (asm_out_file, \\\"],%d\\\\n\\\", INTVAL (operands[0]));\n+  fputs (\\\"\\\\tret \\\", asm_out_file);\n+  mn10300_print_reg_list (asm_out_file, mn10300_get_live_callee_saved_regs ());\n+  fprintf (asm_out_file, \\\",%d\\\\n\\\", (int) INTVAL (operands[0]));\n   return \\\"\\\";\n }\"\n   [(set_attr \"cc\" \"clobber\")])\n \n+;; This instruction matches one generated by mn10300_gen_multiple_store()\n (define_insn \"store_movm\"\n-  [(const_int 1)\n-   (use (reg:SI 2))\n-   (use (reg:SI 3))\n-   (use (reg:SI 6))\n-   (use (reg:SI 7))\n-   (use (reg:SI 14))\n-   (use (reg:SI 15))\n-   (use (reg:SI 16))\n-   (use (reg:SI 17))\n-   (clobber (reg:SI 9))]\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (reg:SI 9) (plus:SI (reg:SI 9) (match_operand 1 \"\" \"\")))])]\n   \"\"\n   \"*\n {\n-  int need_comma;\n-\n-  need_comma = 0;\n-  fputs (\\\"\\\\tmovm [\\\", asm_out_file);\n-  if (regs_ever_live[2])\n-    {\n-      fputs (\\\"d2\\\", asm_out_file);\n-      need_comma = 1;\n-    }\n-  if (regs_ever_live[3])\n-    {\n-      if (need_comma)\n-\tfputc (',', asm_out_file); \n-      fputs (\\\"d3\\\", asm_out_file);\n-      need_comma = 1;\n-    }\n-  if (regs_ever_live[6])\n-    {\n-      if (need_comma)\n-\tfputc (',', asm_out_file); \n-      fputs (\\\"a2\\\", asm_out_file);\n-      need_comma = 1;\n-    }\n-  if (regs_ever_live[7])\n-    {\n-      if (need_comma)\n-\tfputc (',', asm_out_file); \n-      fputs (\\\"a3\\\", asm_out_file);\n-      need_comma = 1;\n-    }\n-  if (regs_ever_live[14] || regs_ever_live[15]\n-      || regs_ever_live[16] || regs_ever_live[17])\n-    {\n-      if (need_comma)\n-\tfputc (',', asm_out_file); \n-      fputs (\\\"exreg1\\\", asm_out_file);\n-      need_comma = 1;\n-    }\n-  fputs (\\\"],(sp)\\\\n\\\", asm_out_file);\n+  fputs (\\\"\\\\tmovm \\\", asm_out_file);\n+  mn10300_print_reg_list (asm_out_file,\n+                          store_multiple_operation (operands[0], VOIDmode));\n+  fprintf (asm_out_file, \\\",(sp)\\\\n\\\");\n   return \\\"\\\";\n }\"\n   [(set_attr \"cc\" \"clobber\")])\n-\n+  \n (define_insn \"return\"\n   [(return)]\n   \"can_use_return_insn ()\""}]}