{"sha": "874d42b93e5926d5b225b97be7608a8c8836614b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc0ZDQyYjkzZTU5MjZkNWIyMjViOTdiZTc2MDhhOGM4ODM2NjE0Yg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2008-08-07T16:58:29Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2008-08-07T16:58:29Z"}, "message": "arm.c (output_move_neon): Update comment describing big-endian vector layout.\n\n\t* config/arm/arm.c (output_move_neon): Update comment describing\n\tbig-endian vector layout.\n\t(arm_assemble_integer): Do not handle big-endian NEON vectors\n\tspecially.\n\t* config/arm/neon.md (vec_set<mode>_internal, vec_extract<mode>,\n\tneon_vget_lane<mode>_sext_internal,\n\tneon_vget_lane<mode>_zext_internal, neon_vget_lane<mode>): Adjust\n\telement indices for big-endian.\n\nFrom-SVN: r138847", "tree": {"sha": "1bd392ba1acdeacf8eb608a911fce0a4c62b053d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bd392ba1acdeacf8eb608a911fce0a4c62b053d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/874d42b93e5926d5b225b97be7608a8c8836614b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874d42b93e5926d5b225b97be7608a8c8836614b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/874d42b93e5926d5b225b97be7608a8c8836614b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874d42b93e5926d5b225b97be7608a8c8836614b/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "058514b381c9f8225cfd63731d90006c37a83139", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058514b381c9f8225cfd63731d90006c37a83139", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058514b381c9f8225cfd63731d90006c37a83139"}], "stats": {"total": 124, "additions": 88, "deletions": 36}, "files": [{"sha": "aeef7844547d3edd97d615d12e4a2667dd82e473", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874d42b93e5926d5b225b97be7608a8c8836614b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874d42b93e5926d5b225b97be7608a8c8836614b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=874d42b93e5926d5b225b97be7608a8c8836614b", "patch": "@@ -1,3 +1,14 @@\n+2008-08-07  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config/arm/arm.c (output_move_neon): Update comment describing\n+\tbig-endian vector layout.\n+\t(arm_assemble_integer): Do not handle big-endian NEON vectors\n+\tspecially.\n+\t* config/arm/neon.md (vec_set<mode>_internal, vec_extract<mode>,\n+\tneon_vget_lane<mode>_sext_internal,\n+\tneon_vget_lane<mode>_zext_internal, neon_vget_lane<mode>): Adjust\n+\telement indices for big-endian.\n+\n 2008-08-07  Richard Henderson  <rth@redhat.com>\n \n \t* configure.ac (HAVE_GAS_CFI_PERSONALITY_DIRECTIVE): New."}, {"sha": "a3a49f7242b3a0f5a870ceaf64d92aa1be998d9e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874d42b93e5926d5b225b97be7608a8c8836614b/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874d42b93e5926d5b225b97be7608a8c8836614b/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=874d42b93e5926d5b225b97be7608a8c8836614b", "patch": "@@ -10335,30 +10335,28 @@ output_move_vfp (rtx *operands)\n }\n \n /* Output a Neon quad-word load or store, or a load or store for\n-   larger structure modes. We could also support post-modify forms using\n-   VLD1/VST1 (for the vectorizer, and perhaps otherwise), but we don't do that\n-   yet.\n-   WARNING: The ordering of elements in memory is weird in big-endian mode,\n-   because we use VSTM instead of VST1, to make it easy to make vector stores\n-   via ARM registers write values in the same order as stores direct from Neon\n-   registers.  For example, the byte ordering of a quadword vector with 16-byte\n-   elements like this:\n+   larger structure modes.\n \n-     [e7:e6:e5:e4:e3:e2:e1:e0]  (highest-numbered element first)\n+   WARNING: The ordering of elements is weird in big-endian mode,\n+   because we use VSTM, as required by the EABI.  GCC RTL defines\n+   element ordering based on in-memory order.  This can be differ\n+   from the architectural ordering of elements within a NEON register.\n+   The intrinsics defined in arm_neon.h use the NEON register element\n+   ordering, not the GCC RTL element ordering.\n \n-   will be (with lowest address first, h = most-significant byte,\n-   l = least-significant byte of element):\n+   For example, the in-memory ordering of a big-endian a quadword\n+   vector with 16-bit elements when stored from register pair {d0,d1}\n+   will be (lowest address first, d0[N] is NEON register element N):\n \n-     [e3h, e3l, e2h, e2l, e1h, e1l, e0h, e0l,\n-      e7h, e7l, e6h, e6l, e5h, e5l, e4h, e4l]\n+     [d0[3], d0[2], d0[1], d0[0], d1[7], d1[6], d1[5], d1[4]]\n \n-   When necessary, quadword registers (dN, dN+1) are moved to ARM registers from\n-   rN in the order:\n+   When necessary, quadword registers (dN, dN+1) are moved to ARM\n+   registers from rN in the order:\n \n      dN -> (rN+1, rN), dN+1 -> (rN+3, rN+2)\n \n-   So that STM/LDM can be used on vectors in ARM registers, and the same memory\n-   layout will result as if VSTM/VLDM were used.  */\n+   So that STM/LDM can be used on vectors in ARM registers, and the\n+   same memory layout will result as if VSTM/VLDM were used.  */\n \n const char *\n output_move_neon (rtx *operands)\n@@ -13326,28 +13324,16 @@ arm_assemble_integer (rtx x, unsigned int size, int aligned_p)\n   if (arm_vector_mode_supported_p (mode))\n     {\n       int i, units;\n-      unsigned int invmask = 0, parts_per_word;\n \n       gcc_assert (GET_CODE (x) == CONST_VECTOR);\n \n       units = CONST_VECTOR_NUNITS (x);\n       size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n \n-      /* For big-endian Neon vectors, we must permute the vector to the form\n-         which, when loaded by a VLDR or VLDM instruction, will give a vector\n-         with the elements in the right order.  */\n-      if (TARGET_NEON && WORDS_BIG_ENDIAN)\n-        {\n-          parts_per_word = UNITS_PER_WORD / size;\n-          /* FIXME: This might be wrong for 64-bit vector elements, but we don't\n-             support those anywhere yet.  */\n-          invmask = (parts_per_word == 0) ? 0 : (1 << (parts_per_word - 1)) - 1;\n-        }\n-\n       if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n         for (i = 0; i < units; i++)\n \t  {\n-\t    rtx elt = CONST_VECTOR_ELT (x, i ^ invmask);\n+\t    rtx elt = CONST_VECTOR_ELT (x, i);\n \t    assemble_integer\n \t      (elt, size, i == 0 ? BIGGEST_ALIGNMENT : size * BITS_PER_UNIT, 1);\n \t  }"}, {"sha": "8d10c1e5b421911443cb84ee1b5e187b8f206e86", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874d42b93e5926d5b225b97be7608a8c8836614b/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874d42b93e5926d5b225b97be7608a8c8836614b/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=874d42b93e5926d5b225b97be7608a8c8836614b", "patch": "@@ -735,7 +735,10 @@\n           (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"TARGET_NEON\"\n {\n-  operands[2] = GEN_INT (ffs ((int) INTVAL (operands[2]) - 1));\n+  int elt = ffs ((int) INTVAL (operands[2]) - 1);\n+  if (BYTES_BIG_ENDIAN)\n+    elt = GET_MODE_NUNITS (<MODE>mode) - 1 - elt;\n+  operands[2] = GEN_INT (elt);\n   \n   return \"vmov%?.<V_uf_sclr>\\t%P0[%c2], %1\";\n }\n@@ -757,6 +760,9 @@\n   int hi = (elem / half_elts) * 2;\n   int regno = REGNO (operands[0]);\n \n+  if (BYTES_BIG_ENDIAN)\n+    elt = half_elts - 1 - elt;\n+\n   operands[0] = gen_rtx_REG (<V_HALF>mode, regno + hi);\n   operands[2] = GEN_INT (elt);\n \n@@ -804,7 +810,15 @@\n           (match_operand:VD 1 \"s_register_operand\" \"w\")\n           (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")])))]\n   \"TARGET_NEON\"\n-  \"vmov%?.<V_uf_sclr>\\t%0, %P1[%c2]\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      int elt = INTVAL (operands[2]);\n+      elt = GET_MODE_NUNITS (<MODE>mode) - 1 - elt;\n+      operands[2] = GEN_INT (elt);\n+    }\n+  return \"vmov%?.<V_uf_sclr>\\t%0, %P1[%c2]\";\n+}\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n@@ -821,6 +835,9 @@\n   int hi = (INTVAL (operands[2]) / half_elts) * 2;\n   int regno = REGNO (operands[1]);\n \n+  if (BYTES_BIG_ENDIAN)\n+    elt = half_elts - 1 - elt;\n+\n   operands[1] = gen_rtx_REG (<V_HALF>mode, regno + hi);\n   operands[2] = GEN_INT (elt);\n \n@@ -2413,7 +2430,15 @@\n \t    (match_operand:VD 1 \"s_register_operand\" \"w\")\n \t    (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n   \"TARGET_NEON\"\n-  \"vmov%?.s<V_sz_elem>\\t%0, %P1[%c2]\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      int elt = INTVAL (operands[2]);\n+      elt = GET_MODE_NUNITS (<MODE>mode) - 1 - elt;\n+      operands[2] = GEN_INT (elt);\n+    }\n+  return \"vmov%?.s<V_sz_elem>\\t%0, %P1[%c2]\";\n+}\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n@@ -2425,7 +2450,15 @@\n \t    (match_operand:VD 1 \"s_register_operand\" \"w\")\n \t    (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n   \"TARGET_NEON\"\n-  \"vmov%?.u<V_sz_elem>\\t%0, %P1[%c2]\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      int elt = INTVAL (operands[2]);\n+      elt = GET_MODE_NUNITS (<MODE>mode) - 1 - elt;\n+      operands[2] = GEN_INT (elt);\n+    }\n+  return \"vmov%?.u<V_sz_elem>\\t%0, %P1[%c2]\";\n+}\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n@@ -2442,10 +2475,14 @@\n   int regno = REGNO (operands[1]);\n   unsigned int halfelts = GET_MODE_NUNITS (<MODE>mode) / 2;\n   unsigned int elt = INTVAL (operands[2]);\n+  unsigned int elt_adj = elt % halfelts;\n+\n+  if (BYTES_BIG_ENDIAN)\n+    elt_adj = halfelts - 1 - elt_adj;\n \n   ops[0] = operands[0];\n   ops[1] = gen_rtx_REG (<V_HALF>mode, regno + 2 * (elt / halfelts));\n-  ops[2] = GEN_INT (elt % halfelts);\n+  ops[2] = GEN_INT (elt_adj);\n   output_asm_insn (\"vmov%?.s<V_sz_elem>\\t%0, %P1[%c2]\", ops);\n \n   return \"\";\n@@ -2466,10 +2503,14 @@\n   int regno = REGNO (operands[1]);\n   unsigned int halfelts = GET_MODE_NUNITS (<MODE>mode) / 2;\n   unsigned int elt = INTVAL (operands[2]);\n+  unsigned int elt_adj = elt % halfelts;\n+\n+  if (BYTES_BIG_ENDIAN)\n+    elt_adj = halfelts - 1 - elt_adj;\n \n   ops[0] = operands[0];\n   ops[1] = gen_rtx_REG (<V_HALF>mode, regno + 2 * (elt / halfelts));\n-  ops[2] = GEN_INT (elt % halfelts);\n+  ops[2] = GEN_INT (elt_adj);\n   output_asm_insn (\"vmov%?.u<V_sz_elem>\\t%0, %P1[%c2]\", ops);\n \n   return \"\";\n@@ -2490,6 +2531,20 @@\n \n   neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<MODE>mode));\n \n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      /* The intrinsics are defined in terms of a model where the\n+\t element ordering in memory is vldm order, whereas the generic\n+\t RTL is defined in terms of a model where the element ordering\n+\t in memory is array order.  Convert the lane number to conform\n+\t to this model.  */\n+      unsigned int elt = INTVAL (operands[2]);\n+      unsigned int reg_nelts\n+\t= 64 / GET_MODE_BITSIZE (GET_MODE_INNER (<MODE>mode));\n+      elt ^= reg_nelts - 1;\n+      operands[2] = GEN_INT (elt);\n+    }\n+\n   if ((magic & 3) == 3 || GET_MODE_BITSIZE (GET_MODE_INNER (<MODE>mode)) == 32)\n     insn = gen_vec_extract<mode> (operands[0], operands[1], operands[2]);\n   else"}]}