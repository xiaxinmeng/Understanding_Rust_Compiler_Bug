{"sha": "5656a184e839836bcacf8f8ed4b94b565159c190", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY1NmExODRlODM5ODM2YmNhY2Y4ZjhlZDRiOTRiNTY1MTU5YzE5MA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2006-06-29T20:42:54Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2006-06-29T20:42:54Z"}, "message": "predicates.md (vector_all_ones_operand): New.\n\n2006-06-29  Eric Christopher  <echristo@apple.com>\n            Evan Cheng  <evan.cheng@apple.com>\n\n        * predicates.md (vector_all_ones_operand): New.\n        (nonimmediate_or_sse_const_operand): Ditto.\n        * config/i386/i386-protos.h (standard_sse_constant_opcode): Declare.\n        * config/i386/i386.c (standard_sse_constant_opcode): Define.\n        (standard_sse_mode_p): Ditto.\n        (standard_sse_constant_p): Add case for -1 vector.\n        (ix86_expand_vector_move): Try to use.\n        * sse.md (*mov<mode>_internal): Use nonimmediate_or_sse_const_operand.\n        Call standard_sse_constant_opcode.\n        (*movv4sf_internal): Ditto.\n        (*movv2df_internal): Ditto.\n\nFrom-SVN: r115077", "tree": {"sha": "bdbc0fc4139526168815d26977ec3edc0a3f6db5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdbc0fc4139526168815d26977ec3edc0a3f6db5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5656a184e839836bcacf8f8ed4b94b565159c190", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5656a184e839836bcacf8f8ed4b94b565159c190", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5656a184e839836bcacf8f8ed4b94b565159c190", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5656a184e839836bcacf8f8ed4b94b565159c190/comments", "author": null, "committer": null, "parents": [{"sha": "c8d560fa808c83063ffc3696ad829d1f30ff57f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8d560fa808c83063ffc3696ad829d1f30ff57f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8d560fa808c83063ffc3696ad829d1f30ff57f2"}], "stats": {"total": 234, "additions": 166, "deletions": 68}, "files": [{"sha": "fdcc4b8b7a45c2f9c0e80af9ee0779de67cedf38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5656a184e839836bcacf8f8ed4b94b565159c190/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5656a184e839836bcacf8f8ed4b94b565159c190/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5656a184e839836bcacf8f8ed4b94b565159c190", "patch": "@@ -1,3 +1,18 @@\n+2006-06-29  Eric Christopher  <echristo@apple.com>\n+\t    Evan Cheng  <evan.cheng@apple.com>\n+\n+\t* predicates.md (vector_all_ones_operand): New.\n+\t(nonimmediate_or_sse_const_operand): Ditto.\n+\t* config/i386/i386-protos.h (standard_sse_constant_opcode): Declare.\n+\t* config/i386/i386.c (standard_sse_constant_opcode): Define.\n+\t(standard_sse_mode_p): Ditto.\n+\t(standard_sse_constant_p): Add case for -1 vector.\n+\t(ix86_expand_vector_move): Try to use.\n+\t* sse.md (*mov<mode>_internal): Use nonimmediate_or_sse_const_operand.\n+\tCall standard_sse_constant_opcode.\n+\t(*movv4sf_internal): Ditto.\n+\t(*movv2df_internal): Ditto.\n+\n 2006-06-29  Roger Sayle  <roger@eyesopen.com>\n \n \t* genpreds.c (write_match_code_switch): Correctly use XSTR instead\n@@ -51,7 +66,7 @@\n \t* config/m32c/mov.md (SI mov peephole): New.\n \t* config/m32c/m32.c (m32c_immd_dbl_mov): New.\n \t* config/m32c/m32c-protos.h (m32c_immd_dbl_mov): New.\n-\t\n+\n 2006-06-26  Olivier Hainque  <hainque@adacore.com>\n \n \t* function.c (aggregate_value_p): Honor DECL_BY_REFERENCE on\n@@ -239,7 +254,7 @@\n \tfunction.\n \t* alloc-pool.c (free_alloc_pool_if_empty): New function.\n \t* et-forest.h (et_free_pools): Prototype new function.\n-\t* et-forest.c (et_free_tree_force): Free parent occurrence. \n+\t* et-forest.c (et_free_tree_force): Free parent occurrence.\n \t(et_free_pools): New function.\n \t* dominance.c (free_dominance_info): Free et-forest alloc\n \tpools.\n@@ -325,19 +340,19 @@\n \tFix PR tree-optimization/27341\n \t* tree-cfg.c (gimplify_val): Call mark_new_vars_to_rename on the\n \tstatement we get.\n-\t* tree-complex.c (pass_lower_complex): Update SMT usage.\t\n+\t* tree-complex.c (pass_lower_complex): Update SMT usage.\n \n 2006-06-19  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n-\t* config/s390/s390.md (\"doloop_si64\", \"doloop_si31\", \"doloop_di\"): \n+\t* config/s390/s390.md (\"doloop_si64\", \"doloop_si31\", \"doloop_di\"):\n \tAdd a new alternative to the constraint strings. Add move of\n \toperand 1 to 3 to the splitter definition.\n \t(\"doloop_si_long\"): Second contraint alternative removed.\n \n 2006-06-08  Anatoly Sokolov <aesok@post.ru>\n \n \t* config/avr/avr.h (avr_have_movw_lpmx_p): Declare.\n-\t(TARGET_CPU_CPP_BUILTINS): Add __AVR_HAVE_MOVW__ and \n+\t(TARGET_CPU_CPP_BUILTINS): Add __AVR_HAVE_MOVW__ and\n \t__AVR_HAVE_LPMX__.\n \t(AVR_HAVE_MOVW) Define.\n \t(ASSEMBLER_DIALECT): Use AVR_HAVE_MOVW.\n@@ -350,7 +365,7 @@\n \tattiny44, attiny84, attiny25, attiny45, attiny85, attiny261,\n \tattiny461, attiny861 and at86rf401 in 'avr25' arhitecture.\n \t(avr_override_options): Init 'avr_have_movw_lpmx_p'.\n-\t(output_movhi, output_movsisf, ashlsi3_out, avr_rtx_costs): Use \n+\t(output_movhi, output_movsisf, ashlsi3_out, avr_rtx_costs): Use\n \tAVR_HAVE_MOVW.\n \t(avr_file_start): Do not output '.arh' derective.\n \t* config/avr/libgcc.S (mov_l): Use __AVR_HAVE_MOVW__.\n@@ -361,7 +376,7 @@\n \t(call_insn, call_value_insn): Use 'call_insn' and __AVR_HAVE_MOVW__.\n \t* config/avr/t-avr(MULTILIB_OPTIONS, MULTILIB_DIRNAMES): Add avr25.\n \t(MULTILIB_MATCHES): Add attiny13, attiny2313, attiny24, attiny44,\n-\tattiny84, attiny25, attiny45, attiny85, attiny261, attiny461, \n+\tattiny84, attiny25, attiny45, attiny85, attiny261, attiny461,\n \tattiny861 and at86rf401 devices.\n \n 2006-06-18  Jie Zhang  <jie.zhang@analog.com>\n@@ -450,7 +465,7 @@\n \tbind locally.\n \n 2006-06-15  Andrew MacLeod  <amacleod@redhat.com>\n-\t\n+\n \tPR middle-end/27793\n \t* tree-dfa.c (referenced_vars_dup_list): Remove.\n \t(find_referenced_vars): Remove assert.\n@@ -502,12 +517,12 @@\n \n \t* Makefile.in: Define HTMLS_BUILD, HTMLS_INSTALL,\n \thtml__strip_dir, html__mkdir_p. Enhance install-html target.\n-\t* configure.ac: AC_SUBST datarootdir, docdir and htmldir. \n+\t* configure.ac: AC_SUBST datarootdir, docdir and htmldir.\n \t* configure: Regenerate.\n \n 2006-06-13  Fariborz Jahanian <fjahanian@apple.com>\n \n-\t* fold-const.c (fold_cond_expr_with_comparison): Check for \n+\t* fold-const.c (fold_cond_expr_with_comparison): Check for\n \tObjective-C++ as language in deciding COND_EXPR transformation.\n \n 2006-06-06  J\"orn Rennecke <joern.rennecke@st.com>"}, {"sha": "6b9ed89c75ba76053e2da6631678a6d630083c5a", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5656a184e839836bcacf8f8ed4b94b565159c190/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5656a184e839836bcacf8f8ed4b94b565159c190/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=5656a184e839836bcacf8f8ed4b94b565159c190", "patch": "@@ -43,6 +43,7 @@ extern int standard_80387_constant_p (rtx);\n extern const char *standard_80387_constant_opcode (rtx);\n extern rtx standard_80387_constant_rtx (int);\n extern int standard_sse_constant_p (rtx);\n+extern const char *standard_sse_constant_opcode (rtx, rtx);\n extern int symbolic_reference_mentioned_p (rtx);\n extern bool extended_reg_mentioned_p (rtx);\n extern bool x86_extended_QIreg_mentioned_p (rtx);\n@@ -173,7 +174,7 @@ extern int ix86_data_alignment (tree, int);\n extern int ix86_local_alignment (tree, int);\n extern int ix86_constant_alignment (tree, int);\n extern tree ix86_handle_shared_attribute (tree *, tree, tree, int, bool *);\n-extern tree ix86_handle_selectany_attribute (tree *, tree, tree, int, bool *); \n+extern tree ix86_handle_selectany_attribute (tree *, tree, tree, int, bool *);\n \n extern unsigned int i386_pe_section_type_flags (tree, const char *, int);\n extern void i386_pe_asm_named_section (const char *, unsigned int, tree);"}, {"sha": "bce7991ad09744fea4bc2f603a8451dc9ff600fb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 88, "deletions": 41, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5656a184e839836bcacf8f8ed4b94b565159c190/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5656a184e839836bcacf8f8ed4b94b565159c190/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5656a184e839836bcacf8f8ed4b94b565159c190", "patch": "@@ -742,7 +742,7 @@ const int x86_movx = m_ATHLON_K8 | m_PPRO | m_PENT4 | m_NOCONA | m_GENERIC /* m_\n const int x86_double_with_add = ~m_386;\n const int x86_use_bit_test = m_386;\n const int x86_unroll_strlen = m_486 | m_PENT | m_PPRO | m_ATHLON_K8 | m_K6 | m_GENERIC;\n-const int x86_cmove = m_PPRO | m_ATHLON_K8 | m_PENT4 | m_NOCONA; \n+const int x86_cmove = m_PPRO | m_ATHLON_K8 | m_PENT4 | m_NOCONA;\n const int x86_fisttp = m_NOCONA;\n const int x86_3dnow_a = m_ATHLON_K8;\n const int x86_deep_branch = m_PPRO | m_K6 | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_GENERIC;\n@@ -2784,7 +2784,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n    When we have only some of our vector isa extensions enabled, then there\n    are some modes for which vector_mode_supported_p is false.  For these\n    modes, the generic vector support in gcc will choose some non-vector mode\n-   in order to implement the type.  By computing the natural mode, we'll \n+   in order to implement the type.  By computing the natural mode, we'll\n    select the proper ABI location for the operand and not depend on whatever\n    the middle-end decides to do with these vector types.  */\n \n@@ -3026,10 +3026,10 @@ classify_argument (enum machine_mode mode, tree type,\n \t      subclasses[0] = X86_64_SSE_CLASS;\n \t    if (subclasses[0] == X86_64_INTEGERSI_CLASS && bytes != 4)\n \t      subclasses[0] = X86_64_INTEGER_CLASS;\n-\t    \n+\n \t    for (i = 0; i < words; i++)\n \t      classes[i] = subclasses[i % num];\n-\t    \n+\n \t    break;\n \t  }\n \tcase UNION_TYPE:\n@@ -3187,12 +3187,12 @@ classify_argument (enum machine_mode mode, tree type,\n       return 0;\n     default:\n       gcc_assert (VECTOR_MODE_P (mode));\n-      \n+\n       if (bytes > 16)\n \treturn 0;\n-      \n+\n       gcc_assert (GET_MODE_CLASS (GET_MODE_INNER (mode)) == MODE_INT);\n-      \n+\n       if (bit_offset + GET_MODE_BITSIZE (mode) <= 32)\n \tclasses[0] = X86_64_INTEGERSI_CLASS;\n       else\n@@ -3726,12 +3726,12 @@ contains_128bit_aligned_vector_p (tree type)\n \tcase QUAL_UNION_TYPE:\n \t  {\n \t    tree field;\n-\t    \n+\n \t    if (TYPE_BINFO (type))\n \t      {\n \t\ttree binfo, base_binfo;\n \t\tint i;\n-\t\t\n+\n \t\tfor (binfo = TYPE_BINFO (type), i = 0;\n \t\t     BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t\t  if (contains_128bit_aligned_vector_p\n@@ -3753,7 +3753,7 @@ contains_128bit_aligned_vector_p (tree type)\n \t  if (contains_128bit_aligned_vector_p (TREE_TYPE (type)))\n \t    return true;\n \t  break;\n-\t  \n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -4622,14 +4622,60 @@ standard_80387_constant_rtx (int idx)\n \t\t\t\t       XFmode);\n }\n \n+/* Return 1 if mode is a valid mode for sse.  */\n+static int\n+standard_sse_mode_p (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case V16QImode:\n+    case V8HImode:\n+    case V4SImode:\n+    case V2DImode:\n+    case V4SFmode:\n+    case V2DFmode:\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n /* Return 1 if X is FP constant we can load to SSE register w/o using memory.\n  */\n int\n standard_sse_constant_p (rtx x)\n {\n-  if (x == const0_rtx)\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  if (x == const0_rtx || x == CONST0_RTX (GET_MODE (x)))\n     return 1;\n-  return (x == CONST0_RTX (GET_MODE (x)));\n+  if (vector_all_ones_operand (x, mode)\n+      && standard_sse_mode_p (mode))\n+    return TARGET_SSE2 ? 2 : -1;\n+\n+  return 0;\n+}\n+\n+/* Return the opcode of the special instruction to be used to load\n+   the constant X.  */\n+\n+const char *\n+standard_sse_constant_opcode (rtx insn, rtx x)\n+{\n+  switch (standard_sse_constant_p (x))\n+    {\n+    case 1:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+        return \"xorps\\t%0, %0\";\n+      else if (get_attr_mode (insn) == MODE_V2DF)\n+        return \"xorpd\\t%0, %0\";\n+      else\n+        return \"pxor\\t%0, %0\";\n+    case 2:\n+      return \"pcmpeqd\\t%0, %0\";\n+    }\n+  gcc_unreachable ();\n }\n \n /* Returns 1 if OP contains a symbol reference */\n@@ -4978,7 +5024,7 @@ ix86_initial_elimination_offset (int from, int to)\n \n       if (from == ARG_POINTER_REGNUM)\n \treturn frame.stack_pointer_offset;\n-      \n+\n       gcc_assert (from == FRAME_POINTER_REGNUM);\n       return frame.stack_pointer_offset - frame.frame_pointer_offset;\n     }\n@@ -5318,7 +5364,7 @@ ix86_expand_prologue (void)\n       /* And here we cheat like madmen with the unwind info.  We force the\n \t cfa register back to sp+4, which is exactly what it was at the\n \t start of the function.  Re-pushing the return address results in\n-\t the return at the same spot relative to the cfa, and thus is \n+\t the return at the same spot relative to the cfa, and thus is\n \t correct wrt the unwind info.  */\n       x = cfun->machine->force_align_arg_pointer;\n       x = gen_frame_mem (Pmode, plus_constant (x, -4));\n@@ -6243,7 +6289,7 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n     {\n       rtx reg;\n       reason_rtx = base;\n-  \n+\n       if (REG_P (base))\n   \treg = base;\n       else if (GET_CODE (base) == SUBREG\n@@ -6343,7 +6389,7 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n \t      goto is_legitimate_pic;\n \t    reason = \"64bit address unspec\";\n \t    goto report_error;\n- \n+\n \t  case UNSPEC_GOTPCREL:\n \t    gcc_assert (flag_pic);\n \t    goto is_legitimate_pic;\n@@ -7103,7 +7149,7 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n \t  putc ('+', file);\n \t  output_pic_addr_const (file, XEXP (x, 1), code);\n \t}\n-      else \n+      else\n \t{\n \t  gcc_assert (GET_CODE (XEXP (x, 1)) == CONST_INT);\n \t  output_pic_addr_const (file, XEXP (x, 1), code);\n@@ -7195,7 +7241,7 @@ i386_output_dwarf_dtprel (FILE *file, int size, rtx x)\n \n /* In the name of slightly smaller debug output, and to cater to\n    general assembler lossage, recognize PIC+GOTOFF and turn it back\n-   into a direct symbol reference.  \n+   into a direct symbol reference.\n \n    On Darwin, this is necessary to avoid a crash, because Darwin\n    has a different PIC label for each routine but the DWARF debugging\n@@ -7274,7 +7320,7 @@ ix86_delegitimize_address (rtx orig_x)\n \n   if (! result)\n     return orig_x;\n-  \n+\n   if (const_addend)\n     result = gen_rtx_PLUS (Pmode, result, const_addend);\n   if (reg_addend)\n@@ -8523,7 +8569,7 @@ emit_i387_cw_initialization (int mode)\n \t  emit_insn (gen_movsi_insv_1 (reg, GEN_INT (0x8)));\n \t  slot = SLOT_CW_CEIL;\n \t  break;\n- \n+\n \tcase I387_CW_MASK_PM:\n \t  /* mask precision exception for nearbyint() */\n \t  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0020)));\n@@ -8833,7 +8879,7 @@ ix86_expand_move (enum machine_mode mode, rtx operands[])\n #else\n       if (GET_CODE (op0) == MEM)\n \top1 = force_reg (Pmode, op1);\n-      else \n+      else\n \top1 = legitimize_address (op1, op1, Pmode);\n #endif /* TARGET_MACHO */\n     }\n@@ -8894,7 +8940,8 @@ ix86_expand_vector_move (enum machine_mode mode, rtx operands[])\n      to handle some of them more efficiently.  */\n   if ((reload_in_progress | reload_completed) == 0\n       && register_operand (op0, mode)\n-      && CONSTANT_P (op1) && op1 != CONST0_RTX (mode))\n+      && CONSTANT_P (op1)\n+      && standard_sse_constant_p (op1) <= 0)\n     op1 = validize_mem (force_const_mem (mode, op1));\n \n   /* Make operand1 a register if it isn't already.  */\n@@ -8909,7 +8956,7 @@ ix86_expand_vector_move (enum machine_mode mode, rtx operands[])\n   emit_insn (gen_rtx_SET (VOIDmode, op0, op1));\n }\n \n-/* Implement the movmisalign patterns for SSE.  Non-SSE modes go \n+/* Implement the movmisalign patterns for SSE.  Non-SSE modes go\n    straight to ix86_expand_vector_move.  */\n \n void\n@@ -11693,9 +11740,9 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n     {\n       /* The only non-offsetable memories we handle are pushes.  */\n       int ok = push_operand (operand, VOIDmode);\n-      \n+\n       gcc_assert (ok);\n-      \n+\n       operand = copy_rtx (operand);\n       PUT_MODE (operand, Pmode);\n       parts[0] = parts[1] = parts[2] = operand;\n@@ -11953,7 +12000,7 @@ ix86_split_long_move (rtx operands[])\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n-\t      \n+\n \t      if (GET_MODE (part[1][0]) == SImode)\n \t\tpart[1][0] = part[1][1];\n \t    }\n@@ -12118,7 +12165,7 @@ ix86_split_ashl (rtx *operands, rtx scratch, enum machine_mode mode)\n \t  ix86_expand_clear (low[0]);\n \t  ix86_expand_clear (high[0]);\n \t  emit_insn (gen_testqi_ccz_1 (operands[2], GEN_INT (single_width)));\n-\t  \n+\n \t  d = gen_lowpart (QImode, low[0]);\n \t  d = gen_rtx_STRICT_LOW_PART (VOIDmode, d);\n \t  s = gen_rtx_EQ (QImode, flags, const0_rtx);\n@@ -13591,9 +13638,9 @@ ix86_agi_dependent (rtx insn, rtx dep_insn, enum attr_type insn_type)\n \n       if (GET_CODE (addr) == PARALLEL)\n \taddr = XVECEXP (addr, 0, 0);\n-      \n+\n       gcc_assert (GET_CODE (addr) == SET);\n-      \n+\n       addr = SET_SRC (addr);\n     }\n   else\n@@ -15419,7 +15466,7 @@ ix86_init_mmx_sse_builtins (void)\n \t\t\t\t    integer_type_node, NULL_TREE);\n   def_builtin (MASK_SSE, \"__builtin_ia32_vec_set_v8hi\",\n \t       ftype, IX86_BUILTIN_VEC_SET_V8HI);\n-  \n+\n   ftype = build_function_type_list (V4HI_type_node, V4HI_type_node,\n \t\t\t\t    intHI_type_node,\n \t\t\t\t    integer_type_node, NULL_TREE);\n@@ -15732,7 +15779,7 @@ get_element_number (tree vec_type, tree arg)\n    instructions from inside the compiler, we can't allow the use of MMX\n    registers unless the user explicitly asks for it.  So we do *not* define\n    vec_set/vec_extract/vec_init patterns for MMX modes in mmx.md.  Instead\n-   we have builtins invoked by mmintrin.h that gives us license to emit \n+   we have builtins invoked by mmintrin.h that gives us license to emit\n    these sorts of instructions.  */\n \n static rtx\n@@ -16269,7 +16316,7 @@ rtx\n ix86_force_to_memory (enum machine_mode mode, rtx operand)\n {\n   rtx result;\n-  \n+\n   gcc_assert (reload_completed);\n   if (TARGET_RED_ZONE)\n     {\n@@ -16371,7 +16418,7 @@ ix86_preferred_reload_class (rtx x, enum reg_class class)\n {\n   enum machine_mode mode = GET_MODE (x);\n \n-  /* We're only allowed to return a subclass of CLASS.  Many of the \n+  /* We're only allowed to return a subclass of CLASS.  Many of the\n      following checks fail for NO_REGS, so eliminate that early.  */\n   if (class == NO_REGS)\n     return NO_REGS;\n@@ -16506,7 +16553,7 @@ ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n       if (!TARGET_SSE2)\n \treturn true;\n \n-      /* If the target says that inter-unit moves are more expensive \n+      /* If the target says that inter-unit moves are more expensive\n \t than moving through memory, then don't generate them.  */\n       if (!TARGET_INTER_UNIT_MOVES && !optimize_size)\n \treturn true;\n@@ -16516,7 +16563,7 @@ ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n \treturn true;\n \n       /* ??? For the cost of one register reformat penalty, we could use\n-\t the same instructions to move SFmode and DFmode data, but the \n+\t the same instructions to move SFmode and DFmode data, but the\n \t relevant move patterns don't support those alternatives.  */\n       if (mode == SFmode || mode == DFmode)\n \treturn true;\n@@ -16550,7 +16597,7 @@ ix86_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n \treturn true;\n \n       /* Vector registers do not support subreg with nonzero offsets, which\n-\t are otherwise valid for integer registers.  Since we can't see \n+\t are otherwise valid for integer registers.  Since we can't see\n \t whether we have a nonzero offset from here, prohibit all\n          nonparadoxical subregs changing size.  */\n       if (GET_MODE_SIZE (to) < GET_MODE_SIZE (from))\n@@ -16661,7 +16708,7 @@ ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n   else if (VALID_FP_MODE_P (mode))\n     return 1;\n   /* Lots of MMX code casts 8 byte vector modes to DImode.  If we then go\n-     on to use that value in smaller contexts, this can easily force a \n+     on to use that value in smaller contexts, this can easily force a\n      pseudo to be allocated to GENERAL_REGS.  Since this is no worse than\n      supporting DImode, allow it.  */\n   else if (VALID_MMX_REG_MODE_3DNOW (mode) || VALID_MMX_REG_MODE (mode))\n@@ -16670,7 +16717,7 @@ ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n   return 0;\n }\n \n-/* A subroutine of ix86_modes_tieable_p.  Return true if MODE is a \n+/* A subroutine of ix86_modes_tieable_p.  Return true if MODE is a\n    tieable integer mode.  */\n \n static bool\n@@ -16718,7 +16765,7 @@ ix86_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n   if (mode2 == DFmode)\n     return mode1 == SFmode;\n \n-  /* If MODE2 is only appropriate for an SSE register, then tie with \n+  /* If MODE2 is only appropriate for an SSE register, then tie with\n      any other mode acceptable to SSE registers.  */\n   if (GET_MODE_SIZE (mode2) >= 8\n       && ix86_hard_regno_mode_ok (FIRST_SSE_REG, mode2))\n@@ -18213,7 +18260,7 @@ ix86_expand_vector_init_general (bool mmx_ok, enum machine_mode mode,\n       if (!register_operand (op1, half_mode))\n \top1 = force_reg (half_mode, op1);\n \n-      emit_insn (gen_rtx_SET (VOIDmode, target, \n+      emit_insn (gen_rtx_SET (VOIDmode, target,\n \t\t\t      gen_rtx_VEC_CONCAT (mode, op0, op1)));\n     }\n   else\n@@ -18273,7 +18320,7 @@ ix86_expand_vector_init_general (bool mmx_ok, enum machine_mode mode,\n     }\n }\n \n-/* Initialize vector TARGET via VALS.  Suppress the use of MMX \n+/* Initialize vector TARGET via VALS.  Suppress the use of MMX\n    instructions unless MMX_OK is true.  */\n \n void"}, {"sha": "457f5563a7b0e9e6cdcc3dfe2edd92794f4e6ab8", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5656a184e839836bcacf8f8ed4b94b565159c190/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5656a184e839836bcacf8f8ed4b94b565159c190/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=5656a184e839836bcacf8f8ed4b94b565159c190", "patch": "@@ -678,11 +678,44 @@\n   return 1;\n })\n \n-;; Return 1 when OP is operand acceptable for standard SSE move.\n+/* Return true if operand is a vector constant that is all ones. */\n+(define_predicate \"vector_all_ones_operand\"\n+  (match_code \"const_vector\")\n+{\n+  int nunits = GET_MODE_NUNITS (mode);\n+\n+  if (GET_CODE (op) == CONST_VECTOR\n+      && CONST_VECTOR_NUNITS (op) == nunits)\n+    {\n+      int i;\n+      for (i = 0; i < nunits; ++i)\n+        {\n+          rtx x = CONST_VECTOR_ELT (op, i);\n+          if (x != constm1_rtx)\n+            return 0;\n+        }\n+      return 1;\n+    }\n+\n+  return 0;\n+})\n+\n+; Return 1 when OP is operand acceptable for standard SSE move.\n (define_predicate \"vector_move_operand\"\n   (ior (match_operand 0 \"nonimmediate_operand\")\n        (match_operand 0 \"const0_operand\")))\n \n+;; Return 1 when OP is nonimmediate or standard SSE constant.\n+(define_predicate \"nonimmediate_or_sse_const_operand\"\n+  (match_operand 0 \"general_operand\")\n+{\n+  if (nonimmediate_operand (op, mode))\n+    return 1;\n+  if (standard_sse_constant_p (op) > 0)\n+    return 1;\n+  return 0;\n+})\n+\n ;; Return true if OP is a register or a zero.\n (define_predicate \"reg_or_0_operand\"\n   (ior (match_operand 0 \"register_operand\")"}, {"sha": "8886e1f04879ca23bf73bce3cf45edb043a8251d", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5656a184e839836bcacf8f8ed4b94b565159c190/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5656a184e839836bcacf8f8ed4b94b565159c190/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=5656a184e839836bcacf8f8ed4b94b565159c190", "patch": "@@ -59,16 +59,13 @@\n \n (define_insn \"*mov<mode>_internal\"\n   [(set (match_operand:SSEMODEI 0 \"nonimmediate_operand\" \"=x,x ,m\")\n-\t(match_operand:SSEMODEI 1 \"vector_move_operand\"  \"C ,xm,x\"))]\n+\t(match_operand:SSEMODEI 1 \"nonimmediate_or_sse_const_operand\"  \"C ,xm,x\"))]\n   \"TARGET_SSE && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (which_alternative)\n     {\n     case 0:\n-      if (get_attr_mode (insn) == MODE_V4SF)\n-\treturn \"xorps\\t%0, %0\";\n-      else\n-\treturn \"pxor\\t%0, %0\";\n+      return standard_sse_constant_opcode (insn, operands[1]);\n     case 1:\n     case 2:\n       if (get_attr_mode (insn) == MODE_V4SF)\n@@ -101,12 +98,20 @@\n \n (define_insn \"*movv4sf_internal\"\n   [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=x,x,m\")\n-\t(match_operand:V4SF 1 \"vector_move_operand\" \"C,xm,x\"))]\n+\t(match_operand:V4SF 1 \"nonimmediate_or_sse_const_operand\" \"C,xm,x\"))]\n   \"TARGET_SSE\"\n-  \"@\n-   xorps\\t%0, %0\n-   movaps\\t{%1, %0|%0, %1}\n-   movaps\\t{%1, %0|%0, %1}\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return standard_sse_constant_opcode (insn, operands[1]);\n+    case 1:\n+    case 2:\n+      return \"movaps\\t{%1, %0|%0, %1}\";\n+    default:\n+      abort();\n+    }\n+}\n   [(set_attr \"type\" \"sselog1,ssemov,ssemov\")\n    (set_attr \"mode\" \"V4SF\")])\n \n@@ -135,16 +140,13 @@\n \n (define_insn \"*movv2df_internal\"\n   [(set (match_operand:V2DF 0 \"nonimmediate_operand\" \"=x,x,m\")\n-\t(match_operand:V2DF 1 \"vector_move_operand\" \"C,xm,x\"))]\n+\t(match_operand:V2DF 1 \"nonimmediate_or_sse_const_operand\" \"C,xm,x\"))]\n   \"TARGET_SSE && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (which_alternative)\n     {\n     case 0:\n-      if (get_attr_mode (insn) == MODE_V4SF)\n-\treturn \"xorps\\t%0, %0\";\n-      else\n-\treturn \"xorpd\\t%0, %0\";\n+      return standard_sse_constant_opcode (insn, operands[1]);\n     case 1:\n     case 2:\n       if (get_attr_mode (insn) == MODE_V4SF)"}]}