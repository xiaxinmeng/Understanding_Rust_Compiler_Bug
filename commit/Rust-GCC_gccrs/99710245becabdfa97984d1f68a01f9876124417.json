{"sha": "99710245becabdfa97984d1f68a01f9876124417", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk3MTAyNDViZWNhYmRmYTk3OTg0ZDFmNjhhMDFmOTg3NjEyNDQxNw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2011-03-28T01:53:24Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2011-03-28T01:53:24Z"}, "message": "re PR bootstrap/48307 (Bootstrap failure)\n\n2011-03-27  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR bootstrap/48307\n\tRevert the previous patch.\n\nFrom-SVN: r171589", "tree": {"sha": "761665b37aeeeb5eb4e3f9b4770772ea49679cc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/761665b37aeeeb5eb4e3f9b4770772ea49679cc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99710245becabdfa97984d1f68a01f9876124417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99710245becabdfa97984d1f68a01f9876124417", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99710245becabdfa97984d1f68a01f9876124417", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99710245becabdfa97984d1f68a01f9876124417/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0854e22029b6d45bc67140bf5d5493ee5c9294ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0854e22029b6d45bc67140bf5d5493ee5c9294ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0854e22029b6d45bc67140bf5d5493ee5c9294ef"}], "stats": {"total": 6849, "additions": 2536, "deletions": 4313}, "files": [{"sha": "d8bf12e4d349c9d8bf92359b331883fc7d782ba9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -1,3 +1,8 @@\n+2011-03-27  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR bootstrap/48307\n+\tRevert the previous patch.\n+\n 2011-03-27  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* regmove.c (regmove_optimize): Move ira_set_pseudo_classes call"}, {"sha": "3ce80611bf4d04eefedbb28f041383e8aaee041c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -3311,7 +3311,7 @@ ira-conflicts.o: ira-conflicts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n ira-color.o: ira-color.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TARGET_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \\\n    $(EXPR_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_CORE_H) $(TM_P_H) reload.h $(PARAMS_H) \\\n-   $(DF_H) $(IRA_INT_H)\n+   $(DF_H) $(SPLAY_TREE_H) $(IRA_INT_H)\n ira-emit.o: ira-emit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(REGS_H) $(RTL_H) $(TM_P_H) $(TARGET_H) $(FLAGS_H) hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(EXPR_H) $(RECOG_H) $(PARAMS_H) $(TIMEVAR_H) \\"}, {"sha": "14fc731ef24b604bb610fc27aaf6c3dd14fc2057", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -511,6 +511,19 @@ enum reg_class {\n   {0x00000000, 0x7fffffff},\t/* FLOAT_REGS */\t\\\n   {0xffffffff, 0xffffffff} }\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES\t\t\t\t\t\t     \\\n+{\t\t\t\t\t\t\t\t\t     \\\n+  GENERAL_REGS, FLOAT_REGS, LIM_REG_CLASSES\t\t\t\t     \\\n+}\n+\n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression"}, {"sha": "add8eced3ed567429aa098479051bd52556e72e9", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -1152,6 +1152,20 @@ enum reg_class\n    or could index an array.  */\n #define REGNO_REG_CLASS(REGNO)  arm_regno_class (REGNO)\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES\t\t\t\t\t\t     \\\n+{\t\t\t\t\t\t\t\t\t     \\\n+  GENERAL_REGS, FPA_REGS, CIRRUS_REGS, VFP_REGS, IWMMXT_GR_REGS, IWMMXT_REGS,\\\n+  LIM_REG_CLASSES\t\t\t\t\t\t\t     \\\n+}\n+\n /* FPA registers can't do subreg as all values are reformatted to internal\n    precision.  In VFPv1, VFP registers could only be accessed in the mode\n    they were set, so subregs would be invalid there too.  However, we don't"}, {"sha": "37fb3ed818a947b967adb7c6734aee7f0c784469", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -296,6 +296,19 @@ enum reg_class {\n \n #define REGNO_REG_CLASS(R) avr_regno_reg_class(R)\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES               \\\n+{                                       \\\n+  GENERAL_REGS, LIM_REG_CLASSES         \\\n+}\n+\n #define BASE_REG_CLASS (reload_completed ? BASE_POINTER_REGS : POINTER_REGS)\n \n #define INDEX_REG_CLASS NO_REGS"}, {"sha": "441e202fc5b008bed19659f0fd65e6156ba978a7", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -664,6 +664,19 @@ enum reg_class\n  : (REGNO) >= REG_RETS ? PROLOGUE_REGS\t\t\t\\\n  : NO_REGS)\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+    MOST_REGS, AREGS, CCREGS, LIM_REG_CLASSES\t\t\\\n+}\n+\n /* When this hook returns true for MODE, the compiler allows\n    registers explicitly used in the rtl to be used as spill registers\n    but prevents the compiler from extending the lifetime of these"}, {"sha": "e8172bb119535a6f69e44d5a61341a6dc7489724", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -550,6 +550,8 @@ enum reg_class\n \n #define INDEX_REG_CLASS GENERAL_REGS\n \n+#define IRA_COVER_CLASSES { GENERAL_REGS, SPECIAL_REGS, LIM_REG_CLASSES }\n+\n #define REG_CLASS_FROM_LETTER(C)\t\t\\\n   (\t\t\t\t\t\t\\\n    (C) == 'a' ? ACR_REGS :\t\t\t\\"}, {"sha": "d20d7fb79c3a27a0c6e767aa0b065b1bbda4c2c0", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -290,6 +290,11 @@ enum reg_class\n #define GENERAL_REGS \tREAL_REGS\n #define N_REG_CLASSES \t((int) LIM_REG_CLASSES)\n \n+#define IRA_COVER_CLASSES\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  REAL_REGS, MULTIPLY_64_REG, LIM_REG_CLASSES\t\t\\\n+}\n+\n /* An initializer containing the names of the register classes as C string\n    constants.  These names are used in writing some of the debugging dumps.  */\n #define REG_CLASS_NAMES \\"}, {"sha": "299a85676ba785a196470e9d333e88ee45a5da8e", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -970,6 +970,21 @@ enum reg_class\n   { 0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0x1fff}, /* ALL_REGS */\\\n }\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  GPR_REGS, FPR_REGS, ACC_REGS, ICR_REGS, FCR_REGS, ICC_REGS, FCC_REGS, \\\n+  ACCG_REGS, SPR_REGS,\t\t\t\t\t\t\t\\\n+  LIM_REG_CLASSES\t\t\t\t\t\t\t\\\n+}\n+\n /* A C expression whose value is a register class containing hard register\n    REGNO.  In general there is more than one such class; choose a class which\n    is \"minimal\", meaning that no smaller class also contains the register.  */"}, {"sha": "589b70f89a7392dc036c8b83008b93284dd2af96", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -330,6 +330,19 @@ enum reg_class {\n { \"NO_REGS\", \"COUNTER_REGS\", \"SOURCE_REGS\", \"DESTINATION_REGS\", \\\n   \"GENERAL_REGS\", \"MAC_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES \\\n+{\t\t\t\t\t\t\\\n+  GENERAL_REGS, MAC_REGS, LIM_REG_CLASSES\t\\\n+}\n+\n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */"}, {"sha": "a4ca762228ccb517d33ca9352fdba77cec4ff288", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -28434,6 +28434,22 @@ ix86_free_from_memory (enum machine_mode mode)\n     }\n }\n \n+/* Implement TARGET_IRA_COVER_CLASSES.  If -mfpmath=sse, we prefer\n+   SSE_REGS to FLOAT_REGS if their costs for a pseudo are the\n+   same.  */\n+static const reg_class_t *\n+i386_ira_cover_classes (void)\n+{\n+  static const reg_class_t sse_fpmath_classes[] = {\n+    GENERAL_REGS, SSE_REGS, MMX_REGS, FLOAT_REGS, LIM_REG_CLASSES\n+  };\n+  static const reg_class_t no_sse_fpmath_classes[] = {\n+    GENERAL_REGS, FLOAT_REGS, MMX_REGS, SSE_REGS, LIM_REG_CLASSES\n+  };\n+\n+ return TARGET_SSE_MATH ? sse_fpmath_classes : no_sse_fpmath_classes;\n+}\n+\n /* Implement TARGET_PREFERRED_RELOAD_CLASS.\n \n    Put float CONST_DOUBLE in the constant pool instead of fp regs.\n@@ -35333,6 +35349,9 @@ ix86_autovectorize_vector_sizes (void)\n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P ix86_legitimate_address_p\n \n+#undef TARGET_IRA_COVER_CLASSES\n+#define TARGET_IRA_COVER_CLASSES i386_ira_cover_classes\n+\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED ix86_frame_pointer_required\n "}, {"sha": "12edeba97f7ba29c507bc51e2aa9c9b891bec18b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -870,6 +870,9 @@ enum target_cpu_default\n    || ((MODE) == DFmode && !(TARGET_SSE2 && TARGET_SSE_MATH))\t\\\n    || (MODE) == XFmode)\n \n+/* Cover class containing the stack registers.  */\n+#define STACK_REG_COVER_CLASS FLOAT_REGS\n+\n /* Number of actual hardware registers.\n    The hardware registers are assigned numbers for the compiler\n    from 0 to just below FIRST_PSEUDO_REGISTER."}, {"sha": "ed618f29fc274a80e5eef56065c3a65335a53e8f", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -774,6 +774,19 @@ enum reg_class\n     0xFFFFFFFF, 0xFFFFFFFF, 0x3FFF },\t\t\t\\\n }\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES\t\t\t\t\t\t     \\\n+{\t\t\t\t\t\t\t\t\t     \\\n+  PR_REGS, BR_REGS, AR_M_REGS, AR_I_REGS, GR_REGS, FR_REGS, LIM_REG_CLASSES  \\\n+}\n+\n /* A C expression whose value is a register class containing hard register\n    REGNO.  In general there is more than one such class; choose a class which\n    is \"minimal\", meaning that no smaller class also contains the register.  */"}, {"sha": "62cddea444e18ebf2553dbe118b10d4e78ee9f57", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -209,6 +209,11 @@ enum reg_class\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n+#define IRA_COVER_CLASSES\t\\\n+{\t\t\t\t\\\n+  GR_REGS, LIM_REG_CLASSES\t\\\n+}\n+\n #define REG_CLASS_NAMES\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   \"NO_REGS\",\t\t\t\t\t\t\t\\"}, {"sha": "a43e2956c94183c86f9d0304e6358768355da632", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -459,6 +459,11 @@ enum reg_class\n   NO_REGS, CARRY_REG, ACCUM_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n+#define IRA_COVER_CLASSES\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  ACCUM_REGS, GENERAL_REGS, LIM_REG_CLASSES\t\t\\\n+}\n+\n #define N_REG_CLASSES ((int) LIM_REG_CLASSES)\n \n /* Give names of register classes as strings for dump file.  */"}, {"sha": "71b7c4f273f3ed4304eb0d89f7d3ca0bb063dfc1", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -496,6 +496,10 @@ extern enum reg_class regno_reg_class[];\n #define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)\t\\\n   ((((CLASS1) == FP_REGS) != ((CLASS2) == FP_REGS)) ? 4 : 2)\n \n+#define IRA_COVER_CLASSES\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  ALL_REGS, LIM_REG_CLASSES\t\t\t\t\t\t\\\n+}\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "54c12ef3dd87011eadf6f822f7d883fa73336261", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -324,6 +324,11 @@ enum reg_class\n \n #define N_REG_CLASSES  (int) LIM_REG_CLASSES\n \n+#define IRA_COVER_CLASSES\t\t\\\n+{\t\t\t\t\t\\\n+  GENERAL_REGS, C_REGS, LIM_REG_CLASSES\t\\\n+}\n+\n \n /* Give names of register classes as strings for dump file.  */\n #define REG_CLASS_NAMES  \\"}, {"sha": "5244bb38a4bdfbfb74e61e6f73713bbc41d3882a", "filename": "gcc/config/mep/mep.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fmep%2Fmep.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fmep%2Fmep.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -407,6 +407,8 @@ enum reg_class\n \n #define REGNO_REG_CLASS(REGNO) (enum reg_class) mep_regno_reg_class (REGNO)\n \n+#define IRA_COVER_CLASSES { GENERAL_REGS, CONTROL_REGS, CR_REGS, CCR_REGS, LIM_REG_CLASSES }\n+\n #define BASE_REG_CLASS GENERAL_REGS\n #define INDEX_REG_CLASS GENERAL_REGS\n "}, {"sha": "0692902e8458ac0c0d0191c2dc0180ac2042e7ec", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -11017,6 +11017,29 @@ mips_memory_move_cost (enum machine_mode mode, reg_class_t rclass, bool in)\n \t  + memory_move_secondary_cost (mode, rclass, in));\n } \n \n+/* Implement TARGET_IRA_COVER_CLASSES.  */\n+\n+static const reg_class_t *\n+mips_ira_cover_classes (void)\n+{\n+  static const reg_class_t acc_classes[] = {\n+    GR_AND_ACC_REGS, FP_REGS, COP0_REGS, COP2_REGS, COP3_REGS,\n+    ST_REGS, LIM_REG_CLASSES\n+  };\n+  static const reg_class_t no_acc_classes[] = {\n+    GR_REGS, FP_REGS, COP0_REGS, COP2_REGS, COP3_REGS,\n+    ST_REGS, LIM_REG_CLASSES\n+  };\n+\n+  /* Don't allow the register allocators to use LO and HI in MIPS16 mode,\n+     which has no MTLO or MTHI instructions.  Also, using GR_AND_ACC_REGS\n+     as a cover class only works well when we keep per-register costs.\n+     Using it when not optimizing can cause us to think accumulators\n+     have the same cost as GPRs in cases where GPRs are actually much\n+     cheaper.  */\n+  return TARGET_MIPS16 || !optimize ? no_acc_classes : acc_classes;\n+}\n+\n /* Return the register class required for a secondary register when\n    copying between one of the registers in RCLASS and value X, which\n    has mode MODE.  X is the source of the move if IN_P, otherwise it\n@@ -16595,6 +16618,9 @@ mips_shift_truncation_mask (enum machine_mode mode)\n #undef TARGET_DWARF_REGISTER_SPAN\n #define TARGET_DWARF_REGISTER_SPAN mips_dwarf_register_span\n \n+#undef TARGET_IRA_COVER_CLASSES\n+#define TARGET_IRA_COVER_CLASSES mips_ira_cover_classes\n+\n #undef TARGET_ASM_FINAL_POSTSCAN_INSN\n #define TARGET_ASM_FINAL_POSTSCAN_INSN mips_final_postscan_insn\n "}, {"sha": "ac23f5858617df55a1f48a2bdacbd6bdac41efd2", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -309,6 +309,19 @@ enum reg_class\n   { 0xffffffff, 0xfffff } /* ALL_REGS */\t\t\t\\\n }\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  GENERAL_REGS, FP_REGS, MDR_REGS, LIM_REG_CLASSES\t\t\\\n+}\n+\n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression"}, {"sha": "41f66cb6baa885babb96dc3f6e34ab0e407f7adf", "filename": "gcc/config/moxie/moxie.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -135,6 +135,15 @@ enum reg_class\n };\n \n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+#define IRA_COVER_CLASSES { GENERAL_REGS, LIM_REG_CLASSES }\n+\n #define REG_CLASS_CONTENTS \\\n { { 0x00000000 }, /* Empty */\t\t\t   \\\n   { 0x0003FFFF }, /* $fp, $sp, $r0 to $r13, ?fp */ \\"}, {"sha": "7e8e05df981ed342a5798590eef378e386bdbe99", "filename": "gcc/config/pa/pa32-regs.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -294,6 +294,19 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n   {0x00000000, 0x00000000, 0x01000000},\t/* SHIFT_REGS */\t\t\\\n   {0xfffffffe, 0xffffffff, 0x03ffffff}}\t/* ALL_REGS */\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  GENERAL_REGS, FP_REGS, SHIFT_REGS, LIM_REG_CLASSES\t\t\t\\\n+}\n+\n /* Defines invalid mode changes.  */\n \n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\"}, {"sha": "23dc7780e4e3b33fadea4415a399902cbd73d495", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -230,6 +230,19 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n   {0x00000000, 0x10000000},\t/* SHIFT_REGS */\t\t\\\n   {0xfffffffe, 0x3fffffff}}\t/* ALL_REGS */\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  GENERAL_REGS, FP_REGS, SHIFT_REGS, LIM_REG_CLASSES\t\t\t\\\n+}\n+\n /* Defines invalid mode changes.  */\n \n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\"}, {"sha": "5f6bc7b2c07432bbf34861469df3c107d71ae7fd", "filename": "gcc/config/picochip/picochip.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fpicochip%2Fpicochip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fpicochip%2Fpicochip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -292,6 +292,19 @@ enum reg_class\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES \t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  GR_REGS, LIM_REG_CLASSES\t\t\t\t\t\t\\\n+}\n+\n \n /* The names of the register classes  */\n #define REG_CLASS_NAMES\t\t\t\t\t\t\t\\"}, {"sha": "b1efc0dc9d332d07f50b4c6382cf31aef464a3a9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -1208,6 +1208,8 @@ static reg_class_t rs6000_secondary_reload (bool, rtx, reg_class_t,\n \t\t\t\t\t    enum machine_mode,\n \t\t\t\t\t    struct secondary_reload_info *);\n \n+static const reg_class_t *rs6000_ira_cover_classes (void);\n+\n const int INSN_NOT_AVAILABLE = -1;\n static enum machine_mode rs6000_eh_return_filter_mode (void);\n static bool rs6000_can_eliminate (const int, const int);\n@@ -1634,6 +1636,9 @@ static const struct default_options rs6000_option_optimization_table[] =\n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD rs6000_secondary_reload\n \n+#undef TARGET_IRA_COVER_CLASSES\n+#define TARGET_IRA_COVER_CLASSES rs6000_ira_cover_classes\n+\n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P rs6000_legitimate_address_p\n \n@@ -15283,6 +15288,26 @@ rs6000_secondary_reload_ppc64 (rtx reg, rtx mem, rtx scratch, bool store_p)\n   return;\n }\n \n+/* Target hook to return the cover classes for Integrated Register Allocator.\n+   Cover classes is a set of non-intersected register classes covering all hard\n+   registers used for register allocation purpose.  Any move between two\n+   registers of a cover class should be cheaper than load or store of the\n+   registers.  The value is array of register classes with LIM_REG_CLASSES used\n+   as the end marker.\n+\n+   We need two IRA_COVER_CLASSES, one for pre-VSX, and the other for VSX to\n+   account for the Altivec and Floating registers being subsets of the VSX\n+   register set under VSX, but distinct register sets on pre-VSX machines.  */\n+\n+static const reg_class_t *\n+rs6000_ira_cover_classes (void)\n+{\n+  static const reg_class_t cover_pre_vsx[] = IRA_COVER_CLASSES_PRE_VSX;\n+  static const reg_class_t cover_vsx[]     = IRA_COVER_CLASSES_VSX;\n+\n+  return (TARGET_VSX) ? cover_vsx : cover_pre_vsx;\n+}\n+\n /* Allocate a 64-bit stack slot to be used for copying SDmode\n    values through if this function has any SDmode references.  */\n "}, {"sha": "49134568b71359e1cd7aa17fc4ee92d401c02042", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -1252,6 +1252,34 @@ enum reg_class\n   { 0xffffffff, 0xffffffff, 0xffffffff, 0x0003ffff }  /* ALL_REGS */\t     \\\n }\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.\n+\n+   We need two IRA_COVER_CLASSES, one for pre-VSX, and the other for VSX to\n+   account for the Altivec and Floating registers being subsets of the VSX\n+   register set.  */\n+\n+#define IRA_COVER_CLASSES_PRE_VSX\t\t\t\t\t     \\\n+{\t\t\t\t\t\t\t\t\t     \\\n+  GENERAL_REGS, SPECIAL_REGS, FLOAT_REGS, ALTIVEC_REGS, /* VSX_REGS, */\t     \\\n+  /* VRSAVE_REGS,*/ VSCR_REGS, SPE_ACC_REGS, SPEFSCR_REGS,\t\t     \\\n+  /* MQ_REGS, LINK_REGS, CTR_REGS, */\t\t\t\t\t     \\\n+  CR_REGS, CA_REGS, LIM_REG_CLASSES\t\t\t\t\t     \\\n+}\n+\n+#define IRA_COVER_CLASSES_VSX\t\t\t\t\t\t     \\\n+{\t\t\t\t\t\t\t\t\t     \\\n+  GENERAL_REGS, SPECIAL_REGS, /* FLOAT_REGS, ALTIVEC_REGS, */ VSX_REGS,\t     \\\n+  /* VRSAVE_REGS,*/ VSCR_REGS, SPE_ACC_REGS, SPEFSCR_REGS,\t\t     \\\n+  /* MQ_REGS, LINK_REGS, CTR_REGS, */\t\t\t\t\t     \\\n+  CR_REGS, CA_REGS, LIM_REG_CLASSES\t\t\t\t\t     \\\n+}\n+\n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression"}, {"sha": "bd54a2b954f2a11e81e04232acf915c8750b48b2", "filename": "gcc/config/rx/rx.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Frx%2Frx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Frx%2Frx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -187,6 +187,11 @@ enum reg_class\n   { 0x0000ffff }\t/* All registers.  */\t\t\\\n }\n \n+#define IRA_COVER_CLASSES\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    GR_REGS, LIM_REG_CLASSES\t\t\t\t\\\n+  }\n+\n #define SMALL_REGISTER_CLASSES \t\t0\n #define N_REG_CLASSES\t\t\t(int) LIM_REG_CLASSES\n #define CLASS_MAX_NREGS(CLASS, MODE)    ((GET_MODE_SIZE (MODE) \\"}, {"sha": "c6ba4ff2453ae58715e49a2d504ab6e0dad94a65", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -468,6 +468,19 @@ enum reg_class\n   { 0xffffffff, 0x0000003f },\t/* ALL_REGS */\t\t\\\n }\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES\t\t\t\t\t\t     \\\n+{\t\t\t\t\t\t\t\t\t     \\\n+  GENERAL_REGS, FP_REGS, CC_REGS, ACCESS_REGS, LIM_REG_CLASSES\t\t     \\\n+}\n+\n /* In some case register allocation order is not enough for IRA to\n    generate a good code.  The following macro (if defined) increases\n    cost of REGNO for a pseudo approximately by pseudo usage frequency"}, {"sha": "4554e2673441ba8b38d0e743b0e4bcaca31f6a98", "filename": "gcc/config/score/score.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -390,6 +390,18 @@ enum reg_class\n    also contains the register.  */\n #define REGNO_REG_CLASS(REGNO) (enum reg_class) score_reg_class (REGNO)\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+#define IRA_COVER_CLASSES\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  G32_REGS, CE_REGS, SP_REGS, LIM_REG_CLASSES\t\t\t\\\n+}\n+\n /* A macro whose definition is the name of the class to which a\n    valid base register must belong.  A base register is one used in\n    an address which is the register value plus a displacement.  */"}, {"sha": "4579af32736573632dc9920127c258a024e313f4", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -1133,6 +1133,20 @@ enum reg_class\n extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define REGNO_REG_CLASS(REGNO) regno_reg_class[(REGNO)]\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES\t\t\t\t\t\t     \\\n+{\t\t\t\t\t\t\t\t\t     \\\n+  GENERAL_REGS, FP_REGS, PR_REGS, T_REGS, MAC_REGS, TARGET_REGS,  \t     \\\n+  FPUL_REGS, LIM_REG_CLASSES\t\t\t\t\t\t     \\\n+}\n+\n /* When this hook returns true for MODE, the compiler allows\n    registers explicitly used in the rtl to be used as spill registers\n    but prevents the compiler from extending the lifetime of these"}, {"sha": "297844fc0badfbc6c04b1d85c0e73635f2499db0", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -1008,6 +1008,19 @@ extern enum reg_class sparc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n #define REGNO_REG_CLASS(REGNO) sparc_regno_reg_class[(REGNO)]\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+\n+#define IRA_COVER_CLASSES\t\t\t\t\t\t     \\\n+{\t\t\t\t\t\t\t\t\t     \\\n+  GENERAL_REGS, EXTRA_FP_REGS, FPCC_REGS, LIM_REG_CLASSES\t\t     \\\n+}\n+\n /* Defines invalid mode changes.  Borrowed from pa64-regs.h.\n \n    SImode loads to floating-point registers are not zero-extended."}, {"sha": "51bfa5131aa3b362ad219086b914a36f8b004c16", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -196,6 +196,9 @@ enum reg_class {\n    LIM_REG_CLASSES \n };\n \n+/* SPU is simple, it really only has one class of registers.  */\n+#define IRA_COVER_CLASSES { GENERAL_REGS, LIM_REG_CLASSES }\n+\n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n #define REG_CLASS_NAMES \\"}, {"sha": "a838b8acf83705c2c98b9942bf187bb7f60a0334", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -179,6 +179,11 @@ enum reg_class\n \n #define N_REG_CLASSES ((int) LIM_REG_CLASSES)\n \n+#define IRA_COVER_CLASSES\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  GENERAL_REGS, LIM_REG_CLASSES\t\t\t\\\n+}\n+\n #define REG_CLASS_NAMES\t\t\t\t\\\n {\t\t\t\t\t\t\\\n   \"NO_REGS\", \t\t\t\t\t\\"}, {"sha": "d1c4320e39ebd30fe12f81bb129d9d3f89695caf", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -304,6 +304,11 @@ enum reg_class\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n+#define IRA_COVER_CLASSES\t\t\\\n+{\t\t\t\t\t\\\n+  GENERAL_REGS, LIM_REG_CLASSES\t\t\\\n+}\n+\n /* Give names of register classes as strings for dump file.  */\n \n #define REG_CLASS_NAMES \\"}, {"sha": "272dfbbc342223bf4b2399e948ac86556849d5c3", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -226,6 +226,15 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define REG_CLASS_NAMES\t\\\n   { \"NO_REGS\", \"ALL_REGS\" }\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+#define IRA_COVER_CLASSES { ALL_REGS, LIM_REG_CLASSES }\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\"}, {"sha": "0a096cdb5e434ffaad6d1e64993e2a1cc6a1a22d", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -432,6 +432,11 @@ enum reg_class\n   { 0xffffffff, 0x0000000f }  /* all registers */ \\\n }\n \n+#define IRA_COVER_CLASSES\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  BR_REGS, FP_REGS, ACC_REG, AR_REGS, LIM_REG_CLASSES\t\t\t\\\n+}\n+\n /* A C expression whose value is a register class containing hard\n    register REGNO.  In general there is more that one such class;\n    choose a class which is \"minimal\", meaning that no smaller class"}, {"sha": "bdd1dd3848ff79c5ca2d9bb0b740d2ddcfdf9308", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -2854,6 +2854,36 @@ as below:\n @end smallexample\n @end defmac\n \n+@deftypefn {Target Hook} {const reg_class_t *} TARGET_IRA_COVER_CLASSES (void)\n+Return an array of cover classes for the Integrated Register Allocator\n+(@acronym{IRA}).  Cover classes are a set of non-intersecting register\n+classes covering all hard registers used for register allocation\n+purposes.  If a move between two registers in the same cover class is\n+possible, it should be cheaper than a load or store of the registers.\n+The array is terminated by a @code{LIM_REG_CLASSES} element.\n+\n+The order of cover classes in the array is important.  If two classes\n+have the same cost of usage for a pseudo, the class occurred first in\n+the array is chosen for the pseudo.\n+\n+This hook is called once at compiler startup, after the command-line\n+options have been processed. It is then re-examined by every call to\n+@code{target_reinit}.\n+\n+The default implementation returns @code{IRA_COVER_CLASSES}, if defined,\n+otherwise there is no default implementation.  You must define either this\n+macro or @code{IRA_COVER_CLASSES} in order to use the integrated register\n+allocator with Chaitin-Briggs coloring. If the macro is not defined,\n+the only available coloring algorithm is Chow's priority coloring.\n+\n+This hook must not be modified from @code{NULL} to non-@code{NULL} or\n+vice versa by command-line option processing.\n+@end deftypefn\n+\n+@defmac IRA_COVER_CLASSES\n+See the documentation for @code{TARGET_IRA_COVER_CLASSES}.\n+@end defmac\n+\n @node Old Constraints\n @section Obsolete Macros for Defining Constraints\n @cindex defining constraints, obsolete method"}, {"sha": "654773ef328c38d077e1eb26297de753e855e961", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -2842,6 +2842,36 @@ as below:\n @end smallexample\n @end defmac\n \n+@hook TARGET_IRA_COVER_CLASSES\n+Return an array of cover classes for the Integrated Register Allocator\n+(@acronym{IRA}).  Cover classes are a set of non-intersecting register\n+classes covering all hard registers used for register allocation\n+purposes.  If a move between two registers in the same cover class is\n+possible, it should be cheaper than a load or store of the registers.\n+The array is terminated by a @code{LIM_REG_CLASSES} element.\n+\n+The order of cover classes in the array is important.  If two classes\n+have the same cost of usage for a pseudo, the class occurred first in\n+the array is chosen for the pseudo.\n+\n+This hook is called once at compiler startup, after the command-line\n+options have been processed. It is then re-examined by every call to\n+@code{target_reinit}.\n+\n+The default implementation returns @code{IRA_COVER_CLASSES}, if defined,\n+otherwise there is no default implementation.  You must define either this\n+macro or @code{IRA_COVER_CLASSES} in order to use the integrated register\n+allocator with Chaitin-Briggs coloring. If the macro is not defined,\n+the only available coloring algorithm is Chow's priority coloring.\n+\n+This hook must not be modified from @code{NULL} to non-@code{NULL} or\n+vice versa by command-line option processing.\n+@end deftypefn\n+\n+@defmac IRA_COVER_CLASSES\n+See the documentation for @code{TARGET_IRA_COVER_CLASSES}.\n+@end defmac\n+\n @node Old Constraints\n @section Obsolete Macros for Defining Constraints\n @cindex defining constraints, obsolete method"}, {"sha": "ea69254fc9544b630036707b383b303638638652", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 53, "deletions": 56, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -573,11 +573,11 @@ schedule_insns (void)\n    up.  */\n bool sched_pressure_p;\n \n-/* Map regno -> its pressure class.  The map defined only when\n+/* Map regno -> its cover class.  The map defined only when\n    SCHED_PRESSURE_P is true.  */\n-enum reg_class *sched_regno_pressure_class;\n+enum reg_class *sched_regno_cover_class;\n \n-/* The current register pressure.  Only elements corresponding pressure\n+/* The current register pressure.  Only elements corresponding cover\n    classes are defined.  */\n static int curr_reg_pressure[N_REG_CLASSES];\n \n@@ -607,41 +607,39 @@ sched_init_region_reg_pressure_info (void)\n static void\n mark_regno_birth_or_death (int regno, bool birth_p)\n {\n-  enum reg_class pressure_class;\n+  enum reg_class cover_class;\n \n-  pressure_class = sched_regno_pressure_class[regno];\n+  cover_class = sched_regno_cover_class[regno];\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n-      if (pressure_class != NO_REGS)\n+      if (cover_class != NO_REGS)\n \t{\n \t  if (birth_p)\n \t    {\n \t      bitmap_set_bit (curr_reg_live, regno);\n-\t      curr_reg_pressure[pressure_class]\n-\t\t+= (ira_reg_class_max_nregs\n-\t\t    [pressure_class][PSEUDO_REGNO_MODE (regno)]);\n+\t      curr_reg_pressure[cover_class]\n+\t\t+= ira_reg_class_nregs[cover_class][PSEUDO_REGNO_MODE (regno)];\n \t    }\n \t  else\n \t    {\n \t      bitmap_clear_bit (curr_reg_live, regno);\n-\t      curr_reg_pressure[pressure_class]\n-\t\t-= (ira_reg_class_max_nregs\n-\t\t    [pressure_class][PSEUDO_REGNO_MODE (regno)]);\n+\t      curr_reg_pressure[cover_class]\n+\t\t-= ira_reg_class_nregs[cover_class][PSEUDO_REGNO_MODE (regno)];\n \t    }\n \t}\n     }\n-  else if (pressure_class != NO_REGS\n+  else if (cover_class != NO_REGS\n \t   && ! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n     {\n       if (birth_p)\n \t{\n \t  bitmap_set_bit (curr_reg_live, regno);\n-\t  curr_reg_pressure[pressure_class]++;\n+\t  curr_reg_pressure[cover_class]++;\n \t}\n       else\n \t{\n \t  bitmap_clear_bit (curr_reg_live, regno);\n-\t  curr_reg_pressure[pressure_class]--;\n+\t  curr_reg_pressure[cover_class]--;\n \t}\n     }\n }\n@@ -655,8 +653,8 @@ initiate_reg_pressure_info (bitmap live)\n   unsigned int j;\n   bitmap_iterator bi;\n \n-  for (i = 0; i < ira_pressure_classes_num; i++)\n-    curr_reg_pressure[ira_pressure_classes[i]] = 0;\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    curr_reg_pressure[ira_reg_class_cover[i]] = 0;\n   bitmap_clear (curr_reg_live);\n   EXECUTE_IF_SET_IN_BITMAP (live, 0, j, bi)\n     if (current_nr_blocks == 1 || bitmap_bit_p (region_ref_regs, j))\n@@ -725,9 +723,9 @@ save_reg_pressure (void)\n {\n   int i;\n \n-  for (i = 0; i < ira_pressure_classes_num; i++)\n-    saved_reg_pressure[ira_pressure_classes[i]]\n-      = curr_reg_pressure[ira_pressure_classes[i]];\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    saved_reg_pressure[ira_reg_class_cover[i]]\n+      = curr_reg_pressure[ira_reg_class_cover[i]];\n   bitmap_copy (saved_reg_live, curr_reg_live);\n }\n \n@@ -737,9 +735,9 @@ restore_reg_pressure (void)\n {\n   int i;\n \n-  for (i = 0; i < ira_pressure_classes_num; i++)\n-    curr_reg_pressure[ira_pressure_classes[i]]\n-      = saved_reg_pressure[ira_pressure_classes[i]];\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    curr_reg_pressure[ira_reg_class_cover[i]]\n+      = saved_reg_pressure[ira_reg_class_cover[i]];\n   bitmap_copy (curr_reg_live, saved_reg_live);\n }\n \n@@ -757,17 +755,17 @@ dying_use_p (struct reg_use_data *use)\n }\n \n /* Print info about the current register pressure and its excess for\n-   each pressure class.  */\n+   each cover class.  */\n static void\n print_curr_reg_pressure (void)\n {\n   int i;\n   enum reg_class cl;\n \n   fprintf (sched_dump, \";;\\t\");\n-  for (i = 0; i < ira_pressure_classes_num; i++)\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n-      cl = ira_pressure_classes[i];\n+      cl = ira_reg_class_cover[i];\n       gcc_assert (curr_reg_pressure[cl] >= 0);\n       fprintf (sched_dump, \"  %s:%d(%d)\", reg_class_names[cl],\n \t       curr_reg_pressure[cl],\n@@ -1110,24 +1108,23 @@ setup_insn_reg_pressure_info (rtx insn)\n   gcc_checking_assert (!DEBUG_INSN_P (insn));\n \n   excess_cost_change = 0;\n-  for (i = 0; i < ira_pressure_classes_num; i++)\n-    death[ira_pressure_classes[i]] = 0;\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    death[ira_reg_class_cover[i]] = 0;\n   for (use = INSN_REG_USE_LIST (insn); use != NULL; use = use->next_insn_use)\n     if (dying_use_p (use))\n       {\n-\tcl = sched_regno_pressure_class[use->regno];\n+\tcl = sched_regno_cover_class[use->regno];\n \tif (use->regno < FIRST_PSEUDO_REGISTER)\n \t  death[cl]++;\n \telse\n-\t  death[cl]\n-\t    += ira_reg_class_max_nregs[cl][PSEUDO_REGNO_MODE (use->regno)];\n+\t  death[cl] += ira_reg_class_nregs[cl][PSEUDO_REGNO_MODE (use->regno)];\n       }\n   pressure_info = INSN_REG_PRESSURE (insn);\n   max_reg_pressure = INSN_MAX_REG_PRESSURE (insn);\n   gcc_assert (pressure_info != NULL && max_reg_pressure != NULL);\n-  for (i = 0; i < ira_pressure_classes_num; i++)\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n-      cl = ira_pressure_classes[i];\n+      cl = ira_reg_class_cover[i];\n       gcc_assert (curr_reg_pressure[cl] >= 0);\n       change = (int) pressure_info[i].set_increase - death[cl];\n       before = MAX (0, max_reg_pressure[i] - ira_available_class_regs[cl]);\n@@ -1572,34 +1569,34 @@ setup_insn_max_reg_pressure (rtx after, bool update_p)\n   static int max_reg_pressure[N_REG_CLASSES];\n \n   save_reg_pressure ();\n-  for (i = 0; i < ira_pressure_classes_num; i++)\n-    max_reg_pressure[ira_pressure_classes[i]]\n-      = curr_reg_pressure[ira_pressure_classes[i]];\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    max_reg_pressure[ira_reg_class_cover[i]]\n+      = curr_reg_pressure[ira_reg_class_cover[i]];\n   for (insn = NEXT_INSN (after);\n        insn != NULL_RTX && ! BARRIER_P (insn)\n \t && BLOCK_FOR_INSN (insn) == BLOCK_FOR_INSN (after);\n        insn = NEXT_INSN (insn))\n     if (NONDEBUG_INSN_P (insn))\n       {\n \teq_p = true;\n-\tfor (i = 0; i < ira_pressure_classes_num; i++)\n+\tfor (i = 0; i < ira_reg_class_cover_size; i++)\n \t  {\n-\t    p = max_reg_pressure[ira_pressure_classes[i]];\n+\t    p = max_reg_pressure[ira_reg_class_cover[i]];\n \t    if (INSN_MAX_REG_PRESSURE (insn)[i] != p)\n \t      {\n \t\teq_p = false;\n \t\tINSN_MAX_REG_PRESSURE (insn)[i]\n-\t\t  = max_reg_pressure[ira_pressure_classes[i]];\n+\t\t  = max_reg_pressure[ira_reg_class_cover[i]];\n \t      }\n \t  }\n \tif (update_p && eq_p)\n \t  break;\n \tupdate_register_pressure (insn);\n-\tfor (i = 0; i < ira_pressure_classes_num; i++)\n-\t  if (max_reg_pressure[ira_pressure_classes[i]]\n-\t      < curr_reg_pressure[ira_pressure_classes[i]])\n-\t    max_reg_pressure[ira_pressure_classes[i]]\n-\t      = curr_reg_pressure[ira_pressure_classes[i]];\n+\tfor (i = 0; i < ira_reg_class_cover_size; i++)\n+\t  if (max_reg_pressure[ira_reg_class_cover[i]]\n+\t      < curr_reg_pressure[ira_reg_class_cover[i]])\n+\t    max_reg_pressure[ira_reg_class_cover[i]]\n+\t      = curr_reg_pressure[ira_reg_class_cover[i]];\n       }\n   restore_reg_pressure ();\n }\n@@ -1613,13 +1610,13 @@ update_reg_and_insn_max_reg_pressure (rtx insn)\n   int i;\n   int before[N_REG_CLASSES];\n \n-  for (i = 0; i < ira_pressure_classes_num; i++)\n-    before[i] = curr_reg_pressure[ira_pressure_classes[i]];\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    before[i] = curr_reg_pressure[ira_reg_class_cover[i]];\n   update_register_pressure (insn);\n-  for (i = 0; i < ira_pressure_classes_num; i++)\n-    if (curr_reg_pressure[ira_pressure_classes[i]] != before[i])\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    if (curr_reg_pressure[ira_reg_class_cover[i]] != before[i])\n       break;\n-  if (i < ira_pressure_classes_num)\n+  if (i < ira_reg_class_cover_size)\n     setup_insn_max_reg_pressure (insn, true);\n }\n \n@@ -1665,9 +1662,9 @@ schedule_insn (rtx insn)\n       if (pressure_info != NULL)\n \t{\n \t  fputc (':', sched_dump);\n-\t  for (i = 0; i < ira_pressure_classes_num; i++)\n+\t  for (i = 0; i < ira_reg_class_cover_size; i++)\n \t    fprintf (sched_dump, \"%s%+d(%d)\",\n-\t\t     reg_class_names[ira_pressure_classes[i]],\n+\t\t     reg_class_names[ira_reg_class_cover[i]],\n \t\t     pressure_info[i].set_increase, pressure_info[i].change);\n \t}\n       fputc ('\\n', sched_dump);\n@@ -3512,13 +3509,13 @@ sched_init (void)\n       int i, max_regno = max_reg_num ();\n \n       ira_set_pseudo_classes (sched_verbose ? sched_dump : NULL);\n-      sched_regno_pressure_class\n+      sched_regno_cover_class\n \t= (enum reg_class *) xmalloc (max_regno * sizeof (enum reg_class));\n       for (i = 0; i < max_regno; i++)\n-\tsched_regno_pressure_class[i]\n+\tsched_regno_cover_class[i]\n \t  = (i < FIRST_PSEUDO_REGISTER\n-\t     ? ira_pressure_class_translate[REGNO_REG_CLASS (i)]\n-\t     : ira_pressure_class_translate[reg_allocno_class (i)]);\n+\t     ? ira_class_translate[REGNO_REG_CLASS (i)]\n+\t     : reg_cover_class (i));\n       curr_reg_live = BITMAP_ALLOC (NULL);\n       saved_reg_live = BITMAP_ALLOC (NULL);\n       region_ref_regs = BITMAP_ALLOC (NULL);\n@@ -3623,7 +3620,7 @@ sched_finish (void)\n   haifa_finish_h_i_d ();\n   if (sched_pressure_p)\n     {\n-      free (sched_regno_pressure_class);\n+      free (sched_regno_cover_class);\n       BITMAP_FREE (region_ref_regs);\n       BITMAP_FREE (saved_reg_live);\n       BITMAP_FREE (curr_reg_live);"}, {"sha": "b3c1e14f8f756ca1b04a4d9859f15219479cfbca", "filename": "gcc/ira-build.c", "status": "modified", "additions": 161, "deletions": 188, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -415,16 +415,15 @@ initiate_allocnos (void)\n     = VEC_alloc (ira_object_t, heap, max_reg_num () * 2);\n   ira_object_id_map = NULL;\n   ira_regno_allocno_map\n-    = (ira_allocno_t *) ira_allocate (max_reg_num ()\n-\t\t\t\t      * sizeof (ira_allocno_t));\n+    = (ira_allocno_t *) ira_allocate (max_reg_num () * sizeof (ira_allocno_t));\n   memset (ira_regno_allocno_map, 0, max_reg_num () * sizeof (ira_allocno_t));\n }\n \n /* Create and return an object corresponding to a new allocno A.  */\n static ira_object_t\n ira_create_object (ira_allocno_t a, int subword)\n {\n-  enum reg_class aclass = ALLOCNO_CLASS (a);\n+  enum reg_class cover_class = ALLOCNO_COVER_CLASS (a);\n   ira_object_t obj = (ira_object_t) pool_alloc (object_pool);\n \n   OBJECT_ALLOCNO (obj) = a;\n@@ -436,13 +435,12 @@ ira_create_object (ira_allocno_t a, int subword)\n   COPY_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), ira_no_alloc_regs);\n   COPY_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), ira_no_alloc_regs);\n   IOR_COMPL_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n-\t\t\t  reg_class_contents[aclass]);\n+\t\t\t  reg_class_contents[cover_class]);\n   IOR_COMPL_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t  reg_class_contents[aclass]);\n+\t\t\t  reg_class_contents[cover_class]);\n   OBJECT_MIN (obj) = INT_MAX;\n   OBJECT_MAX (obj) = -1;\n   OBJECT_LIVE_RANGES (obj) = NULL;\n-  OBJECT_ADD_DATA (obj) = NULL;\n \n   VEC_safe_push (ira_object_t, heap, ira_object_id_map_vec, obj);\n   ira_object_id_map\n@@ -456,8 +454,7 @@ ira_create_object (ira_allocno_t a, int subword)\n    LOOP_TREE_NODE.  Add the allocno to the list of allocnos with the\n    same regno if CAP_P is FALSE.  */\n ira_allocno_t\n-ira_create_allocno (int regno, bool cap_p,\n-\t\t    ira_loop_tree_node_t loop_tree_node)\n+ira_create_allocno (int regno, bool cap_p, ira_loop_tree_node_t loop_tree_node)\n {\n   ira_allocno_t a;\n \n@@ -487,47 +484,47 @@ ira_create_allocno (int regno, bool cap_p,\n   ALLOCNO_NO_STACK_REG_P (a) = false;\n   ALLOCNO_TOTAL_NO_STACK_REG_P (a) = false;\n #endif\n+  ALLOCNO_MEM_OPTIMIZED_DEST (a) = NULL;\n+  ALLOCNO_MEM_OPTIMIZED_DEST_P (a) = false;\n+  ALLOCNO_SOMEWHERE_RENAMED_P (a) = false;\n+  ALLOCNO_CHILD_RENAMED_P (a) = false;\n   ALLOCNO_DONT_REASSIGN_P (a) = false;\n   ALLOCNO_BAD_SPILL_P (a) = false;\n+  ALLOCNO_IN_GRAPH_P (a) = false;\n   ALLOCNO_ASSIGNED_P (a) = false;\n+  ALLOCNO_MAY_BE_SPILLED_P (a) = false;\n+  ALLOCNO_SPLAY_REMOVED_P (a) = false;\n   ALLOCNO_MODE (a) = (regno < 0 ? VOIDmode : PSEUDO_REGNO_MODE (regno));\n   ALLOCNO_COPIES (a) = NULL;\n   ALLOCNO_HARD_REG_COSTS (a) = NULL;\n   ALLOCNO_CONFLICT_HARD_REG_COSTS (a) = NULL;\n   ALLOCNO_UPDATED_HARD_REG_COSTS (a) = NULL;\n   ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a) = NULL;\n-  ALLOCNO_CLASS (a) = NO_REGS;\n-  ALLOCNO_UPDATED_CLASS_COST (a) = 0;\n-  ALLOCNO_CLASS_COST (a) = 0;\n+  ALLOCNO_LEFT_CONFLICTS_SIZE (a) = -1;\n+  ALLOCNO_COVER_CLASS (a) = NO_REGS;\n+  ALLOCNO_UPDATED_COVER_CLASS_COST (a) = 0;\n+  ALLOCNO_COVER_CLASS_COST (a) = 0;\n   ALLOCNO_MEMORY_COST (a) = 0;\n   ALLOCNO_UPDATED_MEMORY_COST (a) = 0;\n   ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a) = 0;\n+  ALLOCNO_NEXT_BUCKET_ALLOCNO (a) = NULL;\n+  ALLOCNO_PREV_BUCKET_ALLOCNO (a) = NULL;\n+  ALLOCNO_FIRST_COALESCED_ALLOCNO (a) = a;\n+  ALLOCNO_NEXT_COALESCED_ALLOCNO (a) = a;\n   ALLOCNO_NUM_OBJECTS (a) = 0;\n \n-  ALLOCNO_ADD_DATA (a) = NULL;\n   VEC_safe_push (ira_allocno_t, heap, allocno_vec, a);\n   ira_allocnos = VEC_address (ira_allocno_t, allocno_vec);\n   ira_allocnos_num = VEC_length (ira_allocno_t, allocno_vec);\n \n   return a;\n }\n \n-/* Set up register class for A and update its conflict hard\n-   registers.  */\n+/* Set up cover class for A and update its conflict hard registers.  */\n void\n-ira_set_allocno_class (ira_allocno_t a, enum reg_class aclass)\n+ira_set_allocno_cover_class (ira_allocno_t a, enum reg_class cover_class)\n {\n-  ira_allocno_object_iterator oi;\n-  ira_object_t obj;\n-\n-  ALLOCNO_CLASS (a) = aclass;\n-  FOR_EACH_ALLOCNO_OBJECT (a, obj, oi)\n-    {\n-      IOR_COMPL_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n-\t\t\t      reg_class_contents[aclass]);\n-      IOR_COMPL_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t      reg_class_contents[aclass]);\n-    }\n+  ALLOCNO_COVER_CLASS (a) = cover_class;\n }\n \n /* Determine the number of objects we should associate with allocno A\n@@ -536,8 +533,8 @@ void\n ira_create_allocno_objects (ira_allocno_t a)\n {\n   enum machine_mode mode = ALLOCNO_MODE (a);\n-  enum reg_class aclass = ALLOCNO_CLASS (a);\n-  int n = ira_reg_class_max_nregs[aclass][mode];\n+  enum reg_class cover_class = ALLOCNO_COVER_CLASS (a);\n+  int n = ira_reg_class_nregs[cover_class][mode];\n   int i;\n \n   if (GET_MODE_SIZE (mode) != 2 * UNITS_PER_WORD || n != 2)\n@@ -549,7 +546,7 @@ ira_create_allocno_objects (ira_allocno_t a)\n }\n \n /* For each allocno, set ALLOCNO_NUM_OBJECTS and create the\n-   ALLOCNO_OBJECT structures.  This must be called after the allocno\n+   ALLOCNO_OBJECT structures.  This must be called after the cover\n    classes are known.  */\n static void\n create_allocno_objects (void)\n@@ -574,7 +571,6 @@ merge_hard_reg_conflicts (ira_allocno_t from, ira_allocno_t to,\n     {\n       ira_object_t from_obj = ALLOCNO_OBJECT (from, i);\n       ira_object_t to_obj = ALLOCNO_OBJECT (to, i);\n-\n       if (!total_only)\n \tIOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (to_obj),\n \t\t\t  OBJECT_CONFLICT_HARD_REGS (from_obj));\n@@ -596,7 +592,6 @@ ior_hard_reg_conflicts (ira_allocno_t a, HARD_REG_SET *set)\n {\n   ira_allocno_object_iterator i;\n   ira_object_t obj;\n-\n   FOR_EACH_ALLOCNO_OBJECT (a, obj, i)\n     {\n       IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), *set);\n@@ -854,22 +849,25 @@ create_cap_allocno (ira_allocno_t a)\n {\n   ira_allocno_t cap;\n   ira_loop_tree_node_t parent;\n-  enum reg_class aclass;\n+  enum reg_class cover_class;\n \n+  ira_assert (ALLOCNO_FIRST_COALESCED_ALLOCNO (a) == a\n+\t      && ALLOCNO_NEXT_COALESCED_ALLOCNO (a) == a);\n   parent = ALLOCNO_LOOP_TREE_NODE (a)->parent;\n   cap = ira_create_allocno (ALLOCNO_REGNO (a), true, parent);\n   ALLOCNO_MODE (cap) = ALLOCNO_MODE (a);\n-  aclass = ALLOCNO_CLASS (a);\n-  ira_set_allocno_class (cap, aclass);\n+  cover_class = ALLOCNO_COVER_CLASS (a);\n+  ira_set_allocno_cover_class (cap, cover_class);\n   ira_create_allocno_objects (cap);\n+  ALLOCNO_AVAILABLE_REGS_NUM (cap) = ALLOCNO_AVAILABLE_REGS_NUM (a);\n   ALLOCNO_CAP_MEMBER (cap) = a;\n   ALLOCNO_CAP (a) = cap;\n-  ALLOCNO_CLASS_COST (cap) = ALLOCNO_CLASS_COST (a);\n+  ALLOCNO_COVER_CLASS_COST (cap) = ALLOCNO_COVER_CLASS_COST (a);\n   ALLOCNO_MEMORY_COST (cap) = ALLOCNO_MEMORY_COST (a);\n   ira_allocate_and_copy_costs\n-    (&ALLOCNO_HARD_REG_COSTS (cap), aclass, ALLOCNO_HARD_REG_COSTS (a));\n+    (&ALLOCNO_HARD_REG_COSTS (cap), cover_class, ALLOCNO_HARD_REG_COSTS (a));\n   ira_allocate_and_copy_costs\n-    (&ALLOCNO_CONFLICT_HARD_REG_COSTS (cap), aclass,\n+    (&ALLOCNO_CONFLICT_HARD_REG_COSTS (cap), cover_class,\n      ALLOCNO_CONFLICT_HARD_REG_COSTS (a));\n   ALLOCNO_BAD_SPILL_P (cap) = ALLOCNO_BAD_SPILL_P (a);\n   ALLOCNO_NREFS (cap) = ALLOCNO_NREFS (a);\n@@ -1065,24 +1063,23 @@ ira_finish_live_range_list (live_range_t r)\n void\n ira_free_allocno_updated_costs (ira_allocno_t a)\n {\n-  enum reg_class aclass;\n+  enum reg_class cover_class;\n \n-  aclass = ALLOCNO_CLASS (a);\n+  cover_class = ALLOCNO_COVER_CLASS (a);\n   if (ALLOCNO_UPDATED_HARD_REG_COSTS (a) != NULL)\n-    ira_free_cost_vector (ALLOCNO_UPDATED_HARD_REG_COSTS (a), aclass);\n+    ira_free_cost_vector (ALLOCNO_UPDATED_HARD_REG_COSTS (a), cover_class);\n   ALLOCNO_UPDATED_HARD_REG_COSTS (a) = NULL;\n   if (ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a) != NULL)\n     ira_free_cost_vector (ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a),\n-\t\t\t  aclass);\n+\t\t\t  cover_class);\n   ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a) = NULL;\n }\n \n-/* Free and nullify all cost vectors allocated earlier for allocno\n-   A.  */\n+/* Free the memory allocated for allocno A.  */\n static void\n-ira_free_allocno_costs (ira_allocno_t a)\n+finish_allocno (ira_allocno_t a)\n {\n-  enum reg_class aclass = ALLOCNO_CLASS (a);\n+  enum reg_class cover_class = ALLOCNO_COVER_CLASS (a);\n   ira_object_t obj;\n   ira_allocno_object_iterator oi;\n \n@@ -1097,25 +1094,14 @@ ira_free_allocno_costs (ira_allocno_t a)\n \n   ira_allocnos[ALLOCNO_NUM (a)] = NULL;\n   if (ALLOCNO_HARD_REG_COSTS (a) != NULL)\n-    ira_free_cost_vector (ALLOCNO_HARD_REG_COSTS (a), aclass);\n+    ira_free_cost_vector (ALLOCNO_HARD_REG_COSTS (a), cover_class);\n   if (ALLOCNO_CONFLICT_HARD_REG_COSTS (a) != NULL)\n-    ira_free_cost_vector (ALLOCNO_CONFLICT_HARD_REG_COSTS (a), aclass);\n+    ira_free_cost_vector (ALLOCNO_CONFLICT_HARD_REG_COSTS (a), cover_class);\n   if (ALLOCNO_UPDATED_HARD_REG_COSTS (a) != NULL)\n-    ira_free_cost_vector (ALLOCNO_UPDATED_HARD_REG_COSTS (a), aclass);\n+    ira_free_cost_vector (ALLOCNO_UPDATED_HARD_REG_COSTS (a), cover_class);\n   if (ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a) != NULL)\n     ira_free_cost_vector (ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a),\n-\t\t\t  aclass);\n-  ALLOCNO_HARD_REG_COSTS (a) = NULL;\n-  ALLOCNO_CONFLICT_HARD_REG_COSTS (a) = NULL;\n-  ALLOCNO_UPDATED_HARD_REG_COSTS (a) = NULL;\n-  ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a) = NULL;\n-}\n-\n-/* Free the memory allocated for allocno A.  */\n-static void\n-finish_allocno (ira_allocno_t a)\n-{\n-  ira_free_allocno_costs (a);\n+\t\t\t  cover_class);\n   pool_free (allocno_pool, a);\n }\n \n@@ -1379,54 +1365,55 @@ finish_copies (void)\n \n \f\n \n-/* Pools for cost vectors.  It is defined only for allocno classes.  */\n+/* Pools for cost vectors.  It is defined only for cover classes.  */\n static alloc_pool cost_vector_pool[N_REG_CLASSES];\n \n /* The function initiates work with hard register cost vectors.  It\n-   creates allocation pool for each allocno class.  */\n+   creates allocation pool for each cover class.  */\n static void\n initiate_cost_vectors (void)\n {\n   int i;\n-  enum reg_class aclass;\n+  enum reg_class cover_class;\n \n-  for (i = 0; i < ira_allocno_classes_num; i++)\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n-      aclass = ira_allocno_classes[i];\n-      cost_vector_pool[aclass]\n+      cover_class = ira_reg_class_cover[i];\n+      cost_vector_pool[cover_class]\n \t= create_alloc_pool (\"cost vectors\",\n-\t\t\t     sizeof (int) * ira_class_hard_regs_num[aclass],\n+\t\t\t     sizeof (int)\n+\t\t\t     * ira_class_hard_regs_num[cover_class],\n \t\t\t     100);\n     }\n }\n \n-/* Allocate and return a cost vector VEC for ACLASS.  */\n+/* Allocate and return a cost vector VEC for COVER_CLASS.  */\n int *\n-ira_allocate_cost_vector (enum reg_class aclass)\n+ira_allocate_cost_vector (enum reg_class cover_class)\n {\n-  return (int *) pool_alloc (cost_vector_pool[aclass]);\n+  return (int *) pool_alloc (cost_vector_pool[cover_class]);\n }\n \n-/* Free a cost vector VEC for ACLASS.  */\n+/* Free a cost vector VEC for COVER_CLASS.  */\n void\n-ira_free_cost_vector (int *vec, enum reg_class aclass)\n+ira_free_cost_vector (int *vec, enum reg_class cover_class)\n {\n   ira_assert (vec != NULL);\n-  pool_free (cost_vector_pool[aclass], vec);\n+  pool_free (cost_vector_pool[cover_class], vec);\n }\n \n /* Finish work with hard register cost vectors.  Release allocation\n-   pool for each allocno class.  */\n+   pool for each cover class.  */\n static void\n finish_cost_vectors (void)\n {\n   int i;\n-  enum reg_class aclass;\n+  enum reg_class cover_class;\n \n-  for (i = 0; i < ira_allocno_classes_num; i++)\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n-      aclass = ira_allocno_classes[i];\n-      free_alloc_pool (cost_vector_pool[aclass]);\n+      cover_class = ira_reg_class_cover[i];\n+      free_alloc_pool (cost_vector_pool[cover_class]);\n     }\n }\n \n@@ -1657,7 +1644,7 @@ propagate_allocno_info (void)\n   int i;\n   ira_allocno_t a, parent_a;\n   ira_loop_tree_node_t parent;\n-  enum reg_class aclass;\n+  enum reg_class cover_class;\n \n   if (flag_ira_region != IRA_REGION_ALL\n       && flag_ira_region != IRA_REGION_MIXED)\n@@ -1683,17 +1670,17 @@ propagate_allocno_info (void)\n \t    += ALLOCNO_CALLS_CROSSED_NUM (a);\n \t  ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n \t    += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n-\t  aclass = ALLOCNO_CLASS (a);\n-\t  ira_assert (aclass == ALLOCNO_CLASS (parent_a));\n+\t  cover_class = ALLOCNO_COVER_CLASS (a);\n+\t  ira_assert (cover_class == ALLOCNO_COVER_CLASS (parent_a));\n \t  ira_allocate_and_accumulate_costs\n-\t    (&ALLOCNO_HARD_REG_COSTS (parent_a), aclass,\n+\t    (&ALLOCNO_HARD_REG_COSTS (parent_a), cover_class,\n \t     ALLOCNO_HARD_REG_COSTS (a));\n \t  ira_allocate_and_accumulate_costs\n \t    (&ALLOCNO_CONFLICT_HARD_REG_COSTS (parent_a),\n-\t     aclass,\n+\t     cover_class,\n \t     ALLOCNO_CONFLICT_HARD_REG_COSTS (a));\n-\t  ALLOCNO_CLASS_COST (parent_a)\n-\t    += ALLOCNO_CLASS_COST (a);\n+\t  ALLOCNO_COVER_CLASS_COST (parent_a)\n+\t    += ALLOCNO_COVER_CLASS_COST (a);\n \t  ALLOCNO_MEMORY_COST (parent_a) += ALLOCNO_MEMORY_COST (a);\n \t}\n }\n@@ -1791,16 +1778,16 @@ static bool\n low_pressure_loop_node_p (ira_loop_tree_node_t node)\n {\n   int i;\n-  enum reg_class pclass;\n+  enum reg_class cover_class;\n \n   if (node->bb != NULL)\n     return false;\n \n-  for (i = 0; i < ira_pressure_classes_num; i++)\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n-      pclass = ira_pressure_classes[i];\n-      if (node->reg_pressure[pclass] > ira_available_class_regs[pclass]\n-\t  && ira_available_class_regs[pclass] > 1)\n+      cover_class = ira_reg_class_cover[i];\n+      if (node->reg_pressure[cover_class]\n+\t  > ira_available_class_regs[cover_class])\n \treturn false;\n     }\n   return true;\n@@ -2016,7 +2003,7 @@ ira_rebuild_regno_allocno_list (int regno)\n static void\n propagate_some_info_from_allocno (ira_allocno_t a, ira_allocno_t from_a)\n {\n-  enum reg_class aclass;\n+  enum reg_class cover_class;\n \n   merge_hard_reg_conflicts (from_a, a, false);\n   ALLOCNO_NREFS (a) += ALLOCNO_NREFS (from_a);\n@@ -2027,14 +2014,14 @@ propagate_some_info_from_allocno (ira_allocno_t a, ira_allocno_t from_a)\n     += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (from_a);\n   if (! ALLOCNO_BAD_SPILL_P (from_a))\n     ALLOCNO_BAD_SPILL_P (a) = false;\n-  aclass = ALLOCNO_CLASS (from_a);\n-  ira_assert (aclass == ALLOCNO_CLASS (a));\n-  ira_allocate_and_accumulate_costs (&ALLOCNO_HARD_REG_COSTS (a), aclass,\n+  cover_class = ALLOCNO_COVER_CLASS (from_a);\n+  ira_assert (cover_class == ALLOCNO_COVER_CLASS (a));\n+  ira_allocate_and_accumulate_costs (&ALLOCNO_HARD_REG_COSTS (a), cover_class,\n \t\t\t\t     ALLOCNO_HARD_REG_COSTS (from_a));\n   ira_allocate_and_accumulate_costs (&ALLOCNO_CONFLICT_HARD_REG_COSTS (a),\n-\t\t\t\t     aclass,\n+\t\t\t\t     cover_class,\n \t\t\t\t     ALLOCNO_CONFLICT_HARD_REG_COSTS (from_a));\n-  ALLOCNO_CLASS_COST (a) += ALLOCNO_CLASS_COST (from_a);\n+  ALLOCNO_COVER_CLASS_COST (a) += ALLOCNO_COVER_CLASS_COST (from_a);\n   ALLOCNO_MEMORY_COST (a) += ALLOCNO_MEMORY_COST (from_a);\n }\n \n@@ -2186,8 +2173,8 @@ remove_low_level_allocnos (void)\n /* Remove loops from consideration.  We remove all loops except for\n    root if ALL_P or loops for which a separate allocation will not\n    improve the result.  We have to do this after allocno creation and\n-   their costs and allocno class evaluation because only after that\n-   the register pressure can be known and is calculated.  */\n+   their costs and cover class evaluation because only after that the\n+   register pressure can be known and is calculated.  */\n static void\n remove_unnecessary_regions (bool all_p)\n {\n@@ -2236,27 +2223,27 @@ update_bad_spill_attribute (void)\n   ira_allocno_object_iterator aoi;\n   ira_object_t obj;\n   live_range_t r;\n-  enum reg_class aclass;\n+  enum reg_class cover_class;\n   bitmap_head dead_points[N_REG_CLASSES];\n \n-  for (i = 0; i < ira_allocno_classes_num; i++)\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n-      aclass = ira_allocno_classes[i];\n-      bitmap_initialize (&dead_points[aclass], &reg_obstack);\n+      cover_class = ira_reg_class_cover[i];\n+      bitmap_initialize (&dead_points[cover_class], &reg_obstack);\n     }\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      aclass = ALLOCNO_CLASS (a);\n-      if (aclass == NO_REGS)\n+      cover_class = ALLOCNO_COVER_CLASS (a);\n+      if (cover_class == NO_REGS)\n \tcontinue;\n       FOR_EACH_ALLOCNO_OBJECT (a, obj, aoi)\n \tfor (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n-\t  bitmap_set_bit (&dead_points[aclass], r->finish);\n+\t  bitmap_set_bit (&dead_points[cover_class], r->finish);\n     }\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      aclass = ALLOCNO_CLASS (a);\n-      if (aclass == NO_REGS)\n+      cover_class = ALLOCNO_COVER_CLASS (a);\n+      if (cover_class == NO_REGS)\n \tcontinue;\n       if (! ALLOCNO_BAD_SPILL_P (a))\n \tcontinue;\n@@ -2265,7 +2252,7 @@ update_bad_spill_attribute (void)\n \t  for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n \t    {\n \t      for (i = r->start + 1; i < r->finish; i++)\n-\t\tif (bitmap_bit_p (&dead_points[aclass], i))\n+\t\tif (bitmap_bit_p (&dead_points[cover_class], i))\n \t\t  break;\n \t      if (i < r->finish)\n \t\tbreak;\n@@ -2277,10 +2264,10 @@ update_bad_spill_attribute (void)\n \t    }\n \t}\n     }\n-  for (i = 0; i < ira_allocno_classes_num; i++)\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n-      aclass = ira_allocno_classes[i];\n-      bitmap_clear (&dead_points[aclass]);\n+      cover_class = ira_reg_class_cover[i];\n+      bitmap_clear (&dead_points[cover_class]);\n     }\n }\n \n@@ -2303,7 +2290,6 @@ setup_min_max_allocno_live_range_point (void)\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n       int n = ALLOCNO_NUM_OBJECTS (a);\n-\n       for (i = 0; i < n; i++)\n \t{\n \t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n@@ -2323,7 +2309,6 @@ setup_min_max_allocno_live_range_point (void)\n       {\n \tint j;\n \tint n = ALLOCNO_NUM_OBJECTS (a);\n-\n \tfor (j = 0; j < n; j++)\n \t  {\n \t    ira_object_t obj = ALLOCNO_OBJECT (a, j);\n@@ -2367,10 +2352,10 @@ setup_min_max_allocno_live_range_point (void)\n }\n \n /* Sort allocnos according to their live ranges.  Allocnos with\n-   smaller allocno class are put first unless we use priority\n-   coloring.  Allocnos with the same class are ordered according\n-   their start (min).  Allocnos with the same start are ordered\n-   according their finish (max).  */\n+   smaller cover class are put first unless we use priority coloring.\n+   Allocnos with the same cover class are ordered according their start\n+   (min).  Allocnos with the same start are ordered according their\n+   finish (max).  */\n static int\n object_range_compare_func (const void *v1p, const void *v2p)\n {\n@@ -2380,6 +2365,9 @@ object_range_compare_func (const void *v1p, const void *v2p)\n   ira_allocno_t a1 = OBJECT_ALLOCNO (obj1);\n   ira_allocno_t a2 = OBJECT_ALLOCNO (obj2);\n \n+  if (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n+      && (diff = ALLOCNO_COVER_CLASS (a1) - ALLOCNO_COVER_CLASS (a2)) != 0)\n+    return diff;\n   if ((diff = OBJECT_MIN (obj1) - OBJECT_MIN (obj2)) != 0)\n     return diff;\n   if ((diff = OBJECT_MAX (obj1) - OBJECT_MAX (obj2)) != 0)\n@@ -2409,7 +2397,6 @@ sort_conflict_id_map (void)\n   for (i = 0; i < num; i++)\n     {\n       ira_object_t obj = ira_object_id_map[i];\n-\n       gcc_assert (obj != NULL);\n       OBJECT_CONFLICT_ID (obj) = i;\n     }\n@@ -2422,28 +2409,29 @@ sort_conflict_id_map (void)\n static void\n setup_min_max_conflict_allocno_ids (void)\n {\n-  int aclass;\n+  int cover_class;\n   int i, j, min, max, start, finish, first_not_finished, filled_area_start;\n   int *live_range_min, *last_lived;\n   int word0_min, word0_max;\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n \n   live_range_min = (int *) ira_allocate (sizeof (int) * ira_objects_num);\n-  aclass = -1;\n+  cover_class = -1;\n   first_not_finished = -1;\n   for (i = 0; i < ira_objects_num; i++)\n     {\n       ira_object_t obj = ira_object_id_map[i];\n-\n       if (obj == NULL)\n \tcontinue;\n \n       a = OBJECT_ALLOCNO (obj);\n \n-      if (aclass < 0)\n+      if (cover_class < 0\n+\t  || (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n+\t      && cover_class != (int) ALLOCNO_COVER_CLASS (a)))\n \t{\n-\t  aclass = ALLOCNO_CLASS (a);\n+\t  cover_class = ALLOCNO_COVER_CLASS (a);\n \t  min = i;\n \t  first_not_finished = i;\n \t}\n@@ -2468,19 +2456,20 @@ setup_min_max_conflict_allocno_ids (void)\n       OBJECT_MIN (obj) = min;\n     }\n   last_lived = (int *) ira_allocate (sizeof (int) * ira_max_point);\n-  aclass = -1;\n+  cover_class = -1;\n   filled_area_start = -1;\n   for (i = ira_objects_num - 1; i >= 0; i--)\n     {\n       ira_object_t obj = ira_object_id_map[i];\n-\n       if (obj == NULL)\n \tcontinue;\n \n       a = OBJECT_ALLOCNO (obj);\n-      if (aclass < 0)\n+      if (cover_class < 0\n+\t  || (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n+\t      && cover_class != (int) ALLOCNO_COVER_CLASS (a)))\n \t{\n-\t  aclass = ALLOCNO_CLASS (a);\n+\t  cover_class = ALLOCNO_COVER_CLASS (a);\n \t  for (j = 0; j < ira_max_point; j++)\n \t    last_lived[j] = -1;\n \t  filled_area_start = ira_max_point;\n@@ -2518,7 +2507,6 @@ setup_min_max_conflict_allocno_ids (void)\n     {\n       int n = ALLOCNO_NUM_OBJECTS (a);\n       ira_object_t obj0;\n-\n       if (n < 2)\n \tcontinue;\n       obj0 = ALLOCNO_OBJECT (a, 0);\n@@ -2531,7 +2519,6 @@ setup_min_max_conflict_allocno_ids (void)\n     {\n       int n = ALLOCNO_NUM_OBJECTS (a);\n       ira_object_t obj0;\n-\n       if (n < 2)\n \tcontinue;\n       obj0 = ALLOCNO_OBJECT (a, 0);\n@@ -2624,7 +2611,7 @@ copy_info_to_removed_store_destinations (int regno)\n        a != NULL;\n        a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n     {\n-      if (a != regno_top_level_allocno_map[REGNO (allocno_emit_reg (a))])\n+      if (a != regno_top_level_allocno_map[REGNO (ALLOCNO_REG (a))])\n \t/* This allocno will be removed.  */\n \tcontinue;\n \n@@ -2634,10 +2621,9 @@ copy_info_to_removed_store_destinations (int regno)\n \t   parent != NULL;\n \t   parent = parent->parent)\n \tif ((parent_a = parent->regno_allocno_map[regno]) == NULL\n-\t    || (parent_a\n-\t\t== regno_top_level_allocno_map[REGNO\n-\t\t\t\t\t       (allocno_emit_reg (parent_a))]\n-\t\t&& ALLOCNO_EMIT_DATA (parent_a)->mem_optimized_dest_p))\n+\t    || (parent_a == regno_top_level_allocno_map[REGNO (ALLOCNO_REG\n+\t\t\t\t\t\t\t       (parent_a))]\n+\t\t&& ALLOCNO_MEM_OPTIMIZED_DEST_P (parent_a)))\n \t  break;\n       if (parent == NULL || parent_a == NULL)\n \tcontinue;\n@@ -2669,7 +2655,7 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n   int hard_regs_num;\n   bool new_pseudos_p, merged_p, mem_dest_p;\n   unsigned int n;\n-  enum reg_class aclass;\n+  enum reg_class cover_class;\n   ira_allocno_t a, parent_a, first, second, node_first, node_second;\n   ira_copy_t cp;\n   ira_loop_tree_node_t node;\n@@ -2678,16 +2664,14 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n   ira_copy_iterator ci;\n \n   regno_top_level_allocno_map\n-    = (ira_allocno_t *) ira_allocate (max_reg_num ()\n-\t\t\t\t      * sizeof (ira_allocno_t));\n+    = (ira_allocno_t *) ira_allocate (max_reg_num () * sizeof (ira_allocno_t));\n   memset (regno_top_level_allocno_map, 0,\n \t  max_reg_num () * sizeof (ira_allocno_t));\n   new_pseudos_p = merged_p = false;\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n       ira_allocno_object_iterator oi;\n       ira_object_t obj;\n-\n       if (ALLOCNO_CAP_MEMBER (a) != NULL)\n \t/* Caps are not in the regno allocno maps and they are never\n \t   will be transformed into allocnos existing after IR\n@@ -2708,31 +2692,28 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t   a != NULL;\n \t   a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n \t{\n-\t  ira_emit_data_t parent_data, data = ALLOCNO_EMIT_DATA (a);\n-\n \t  ira_assert (ALLOCNO_CAP_MEMBER (a) == NULL);\n-\t  if (data->somewhere_renamed_p)\n+\t  if (ALLOCNO_SOMEWHERE_RENAMED_P (a))\n \t    new_pseudos_p = true;\n \t  parent_a = ira_parent_allocno (a);\n \t  if (parent_a == NULL)\n \t    {\n \t      ALLOCNO_COPIES (a) = NULL;\n-\t      regno_top_level_allocno_map[REGNO (data->reg)] = a;\n+\t      regno_top_level_allocno_map[REGNO (ALLOCNO_REG (a))] = a;\n \t      continue;\n \t    }\n \t  ira_assert (ALLOCNO_CAP_MEMBER (parent_a) == NULL);\n \n-\t  if (data->mem_optimized_dest != NULL)\n+\t  if (ALLOCNO_MEM_OPTIMIZED_DEST (a) != NULL)\n \t    mem_dest_p = true;\n-\t  parent_data = ALLOCNO_EMIT_DATA (parent_a);\n-\t  if (REGNO (data->reg) == REGNO (parent_data->reg))\n+\t  if (REGNO (ALLOCNO_REG (a)) == REGNO (ALLOCNO_REG (parent_a)))\n \t    {\n \t      merge_hard_reg_conflicts (a, parent_a, true);\n \t      move_allocno_live_ranges (a, parent_a);\n \t      merged_p = true;\n-\t      parent_data->mem_optimized_dest_p\n-\t\t= (parent_data->mem_optimized_dest_p\n-\t\t   || data->mem_optimized_dest_p);\n+\t      ALLOCNO_MEM_OPTIMIZED_DEST_P (parent_a)\n+\t\t= (ALLOCNO_MEM_OPTIMIZED_DEST_P (parent_a)\n+\t\t   || ALLOCNO_MEM_OPTIMIZED_DEST_P (a));\n \t      continue;\n \t    }\n \t  new_pseudos_p = true;\n@@ -2748,8 +2729,8 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t      ira_assert (ALLOCNO_CALLS_CROSSED_NUM (parent_a) >= 0\n \t\t\t  && ALLOCNO_NREFS (parent_a) >= 0\n \t\t\t  && ALLOCNO_FREQ (parent_a) >= 0);\n-\t      aclass = ALLOCNO_CLASS (parent_a);\n-\t      hard_regs_num = ira_class_hard_regs_num[aclass];\n+\t      cover_class = ALLOCNO_COVER_CLASS (parent_a);\n+\t      hard_regs_num = ira_class_hard_regs_num[cover_class];\n \t      if (ALLOCNO_HARD_REG_COSTS (a) != NULL\n \t\t  && ALLOCNO_HARD_REG_COSTS (parent_a) != NULL)\n \t\tfor (j = 0; j < hard_regs_num; j++)\n@@ -2760,15 +2741,15 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t\tfor (j = 0; j < hard_regs_num; j++)\n \t\t  ALLOCNO_CONFLICT_HARD_REG_COSTS (parent_a)[j]\n \t\t    -= ALLOCNO_CONFLICT_HARD_REG_COSTS (a)[j];\n-\t      ALLOCNO_CLASS_COST (parent_a)\n-\t\t-= ALLOCNO_CLASS_COST (a);\n+\t      ALLOCNO_COVER_CLASS_COST (parent_a)\n+\t\t-= ALLOCNO_COVER_CLASS_COST (a);\n \t      ALLOCNO_MEMORY_COST (parent_a) -= ALLOCNO_MEMORY_COST (a);\n \t      parent_a = ira_parent_allocno (parent_a);\n \t      if (parent_a == NULL)\n \t\tbreak;\n \t    }\n \t  ALLOCNO_COPIES (a) = NULL;\n-\t  regno_top_level_allocno_map[REGNO (data->reg)] = a;\n+\t  regno_top_level_allocno_map[REGNO (ALLOCNO_REG (a))] = a;\n \t}\n       if (mem_dest_p && copy_info_to_removed_store_destinations (i))\n \tmerged_p = true;\n@@ -2785,8 +2766,7 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t{\n \t  ira_allocno_object_iterator oi;\n \t  ira_object_t obj;\n-\n-\t  if (a != regno_top_level_allocno_map[REGNO (allocno_emit_reg (a))]\n+\t  if (a != regno_top_level_allocno_map[REGNO (ALLOCNO_REG (a))]\n \t      || ALLOCNO_CAP_MEMBER (a) != NULL)\n \t    continue;\n \t  FOR_EACH_ALLOCNO_OBJECT (a, obj, oi)\n@@ -2802,21 +2782,19 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t  for (r = ira_start_point_ranges[i]; r != NULL; r = r->start_next)\n \t    {\n \t      ira_object_t obj = r->object;\n-\n \t      a = OBJECT_ALLOCNO (obj);\n-\t      if (a != regno_top_level_allocno_map[REGNO (allocno_emit_reg (a))]\n+\t      if (a != regno_top_level_allocno_map[REGNO (ALLOCNO_REG (a))]\n \t\t  || ALLOCNO_CAP_MEMBER (a) != NULL)\n \t\tcontinue;\n \n-\t      aclass = ALLOCNO_CLASS (a);\n+\t      cover_class = ALLOCNO_COVER_CLASS (a);\n \t      sparseset_set_bit (objects_live, OBJECT_CONFLICT_ID (obj));\n \t      EXECUTE_IF_SET_IN_SPARSESET (objects_live, n)\n \t\t{\n \t\t  ira_object_t live_obj = ira_object_id_map[n];\n \t\t  ira_allocno_t live_a = OBJECT_ALLOCNO (live_obj);\n-\t\t  enum reg_class live_aclass = ALLOCNO_CLASS (live_a);\n-\n-\t\t  if (ira_reg_classes_intersect_p[aclass][live_aclass]\n+\t\t  enum reg_class live_cover = ALLOCNO_COVER_CLASS (live_a);\n+\t\t  if (ira_reg_classes_intersect_p[cover_class][live_cover]\n \t\t      /* Don't set up conflict for the allocno with itself.  */\n \t\t      && live_a != a)\n \t\t    ira_add_conflict (obj, live_obj);\n@@ -2840,18 +2818,14 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t    fprintf\n \t      (ira_dump_file, \"      Remove cp%d:%c%dr%d-%c%dr%d\\n\",\n \t       cp->num, ALLOCNO_CAP_MEMBER (cp->first) != NULL ? 'c' : 'a',\n-\t       ALLOCNO_NUM (cp->first),\n-\t       REGNO (allocno_emit_reg (cp->first)),\n+\t       ALLOCNO_NUM (cp->first), REGNO (ALLOCNO_REG (cp->first)),\n \t       ALLOCNO_CAP_MEMBER (cp->second) != NULL ? 'c' : 'a',\n-\t       ALLOCNO_NUM (cp->second),\n-\t       REGNO (allocno_emit_reg (cp->second)));\n+\t       ALLOCNO_NUM (cp->second), REGNO (ALLOCNO_REG (cp->second)));\n \t  cp->loop_tree_node = NULL;\n \t  continue;\n \t}\n-      first\n-\t= regno_top_level_allocno_map[REGNO (allocno_emit_reg (cp->first))];\n-      second\n-\t= regno_top_level_allocno_map[REGNO (allocno_emit_reg (cp->second))];\n+      first = regno_top_level_allocno_map[REGNO (ALLOCNO_REG (cp->first))];\n+      second = regno_top_level_allocno_map[REGNO (ALLOCNO_REG (cp->second))];\n       node = cp->loop_tree_node;\n       if (node == NULL)\n \tkeep_p = true; /* It copy generated in ira-emit.c.  */\n@@ -2861,10 +2835,10 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t     which we will have different pseudos.  */\n \t  node_first = node->regno_allocno_map[ALLOCNO_REGNO (cp->first)];\n \t  node_second = node->regno_allocno_map[ALLOCNO_REGNO (cp->second)];\n-\t  keep_p = ((REGNO (allocno_emit_reg (first))\n-\t\t     == REGNO (allocno_emit_reg (node_first)))\n-\t\t     && (REGNO (allocno_emit_reg (second))\n-\t\t\t == REGNO (allocno_emit_reg (node_second))));\n+\t  keep_p = ((REGNO (ALLOCNO_REG (first))\n+\t\t     == REGNO (ALLOCNO_REG (node_first)))\n+\t\t     && (REGNO (ALLOCNO_REG (second))\n+\t\t\t == REGNO (ALLOCNO_REG (node_second))));\n \t}\n       if (keep_p)\n \t{\n@@ -2878,29 +2852,28 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t  if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n \t    fprintf (ira_dump_file, \"      Remove cp%d:a%dr%d-a%dr%d\\n\",\n \t\t     cp->num, ALLOCNO_NUM (cp->first),\n-\t\t     REGNO (allocno_emit_reg (cp->first)),\n-\t\t     ALLOCNO_NUM (cp->second),\n-\t\t     REGNO (allocno_emit_reg (cp->second)));\n+\t\t     REGNO (ALLOCNO_REG (cp->first)), ALLOCNO_NUM (cp->second),\n+\t\t     REGNO (ALLOCNO_REG (cp->second)));\n \t}\n     }\n   /* Remove unnecessary allocnos on lower levels of the loop tree.  */\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      if (a != regno_top_level_allocno_map[REGNO (allocno_emit_reg (a))]\n+      if (a != regno_top_level_allocno_map[REGNO (ALLOCNO_REG (a))]\n \t  || ALLOCNO_CAP_MEMBER (a) != NULL)\n \t{\n \t  if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n \t    fprintf (ira_dump_file, \"      Remove a%dr%d\\n\",\n-\t\t     ALLOCNO_NUM (a), REGNO (allocno_emit_reg (a)));\n+\t\t     ALLOCNO_NUM (a), REGNO (ALLOCNO_REG (a)));\n \t  finish_allocno (a);\n \t  continue;\n \t}\n       ALLOCNO_LOOP_TREE_NODE (a) = ira_loop_tree_root;\n-      ALLOCNO_REGNO (a) = REGNO (allocno_emit_reg (a));\n+      ALLOCNO_REGNO (a) = REGNO (ALLOCNO_REG (a));\n       ALLOCNO_CAP (a) = NULL;\n       /* Restore updated costs for assignments from reload.  */\n       ALLOCNO_UPDATED_MEMORY_COST (a) = ALLOCNO_MEMORY_COST (a);\n-      ALLOCNO_UPDATED_CLASS_COST (a) = ALLOCNO_CLASS_COST (a);\n+      ALLOCNO_UPDATED_COVER_CLASS_COST (a) = ALLOCNO_COVER_CLASS_COST (a);\n       if (! ALLOCNO_ASSIGNED_P (a))\n \tira_free_allocno_updated_costs (a);\n       ira_assert (ALLOCNO_UPDATED_HARD_REG_COSTS (a) == NULL);\n@@ -2969,28 +2942,29 @@ update_conflict_hard_reg_costs (void)\n \n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      enum reg_class aclass = ALLOCNO_CLASS (a);\n+      enum reg_class cover_class = ALLOCNO_COVER_CLASS (a);\n       enum reg_class pref = reg_preferred_class (ALLOCNO_REGNO (a));\n \n       if (reg_class_size[pref] != 1)\n \tcontinue;\n-      index = ira_class_hard_reg_index[aclass][ira_class_hard_regs[pref][0]];\n+      index = (ira_class_hard_reg_index[cover_class]\n+\t       [ira_class_hard_regs[pref][0]]);\n       if (index < 0)\n \tcontinue;\n       if (ALLOCNO_CONFLICT_HARD_REG_COSTS (a) == NULL\n \t  || ALLOCNO_HARD_REG_COSTS (a) == NULL)\n \tcontinue;\n       min = INT_MAX;\n-      for (i = ira_class_hard_regs_num[aclass] - 1; i >= 0; i--)\n-\tif (ALLOCNO_HARD_REG_COSTS (a)[i] > ALLOCNO_CLASS_COST (a)\n+      for (i = ira_class_hard_regs_num[cover_class] - 1; i >= 0; i--)\n+\tif (ALLOCNO_HARD_REG_COSTS (a)[i] > ALLOCNO_COVER_CLASS_COST (a)\n \t    && min > ALLOCNO_HARD_REG_COSTS (a)[i])\n \t  min = ALLOCNO_HARD_REG_COSTS (a)[i];\n       if (min == INT_MAX)\n \tcontinue;\n       ira_allocate_and_set_costs (&ALLOCNO_CONFLICT_HARD_REG_COSTS (a),\n-\t\t\t\t  aclass, 0);\n+\t\t\t\t  cover_class, 0);\n       ALLOCNO_CONFLICT_HARD_REG_COSTS (a)[index]\n-\t-= min - ALLOCNO_CLASS_COST (a);\n+\t-= min - ALLOCNO_COVER_CLASS_COST (a);\n     }\n }\n \n@@ -3026,7 +3000,7 @@ ira_build (bool loops_p)\n       propagate_allocno_info ();\n       create_caps ();\n     }\n-  ira_tune_allocno_costs ();\n+  ira_tune_allocno_costs_and_cover_classes ();\n #ifdef ENABLE_IRA_CHECKING\n   check_allocno_creation ();\n #endif\n@@ -3068,7 +3042,6 @@ ira_build (bool loops_p)\n       FOR_EACH_ALLOCNO (a, ai)\n \t{\n \t  int j, nobj = ALLOCNO_NUM_OBJECTS (a);\n-\n \t  if (nobj > 1)\n \t    nr_big++;\n \t  for (j = 0; j < nobj; j++)"}, {"sha": "6024f7d9563d66ec2fd11d3ba8cf07b52f13e9d7", "filename": "gcc/ira-color.c", "status": "modified", "additions": 768, "deletions": 1980, "changes": 2748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=99710245becabdfa97984d1f68a01f9876124417"}, {"sha": "498b38b3bd6a9c60fa315a1fc3903d2c259ee47f", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -97,7 +97,7 @@ build_conflict_bit_table (void)\n {\n   int i;\n   unsigned int j;\n-  enum reg_class aclass;\n+  enum reg_class cover_class;\n   int object_set_words, allocated_words_num, conflict_bit_vec_words_num;\n   live_range_t r;\n   ira_allocno_t allocno;\n@@ -170,15 +170,15 @@ build_conflict_bit_table (void)\n \n \t  gcc_assert (id < ira_objects_num);\n \n-\t  aclass = ALLOCNO_CLASS (allocno);\n+\t  cover_class = ALLOCNO_COVER_CLASS (allocno);\n \t  sparseset_set_bit (objects_live, id);\n \t  EXECUTE_IF_SET_IN_SPARSESET (objects_live, j)\n \t    {\n \t      ira_object_t live_obj = ira_object_id_map[j];\n \t      ira_allocno_t live_a = OBJECT_ALLOCNO (live_obj);\n-\t      enum reg_class live_aclass = ALLOCNO_CLASS (live_a);\n+\t      enum reg_class live_cover_class = ALLOCNO_COVER_CLASS (live_a);\n \n-\t      if (ira_reg_classes_intersect_p[aclass][live_aclass]\n+\t      if (ira_reg_classes_intersect_p[cover_class][live_cover_class]\n \t\t  /* Don't set up conflict for the allocno with itself.  */\n \t\t  && live_a != allocno)\n \t\t{\n@@ -205,7 +205,6 @@ allocnos_conflict_for_copy_p (ira_allocno_t a1, ira_allocno_t a2)\n      the lowest order words.  */\n   ira_object_t obj1 = ALLOCNO_OBJECT (a1, 0);\n   ira_object_t obj2 = ALLOCNO_OBJECT (a2, 0);\n-\n   return OBJECTS_CONFLICT_P (obj1, obj2);\n }\n \n@@ -390,7 +389,7 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n   int allocno_preferenced_hard_regno, cost, index, offset1, offset2;\n   bool only_regs_p;\n   ira_allocno_t a;\n-  enum reg_class rclass, aclass;\n+  enum reg_class rclass, cover_class;\n   enum machine_mode mode;\n   ira_copy_t cp;\n \n@@ -427,37 +426,35 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n \treturn false;\n     }\n \n-  if (! IN_RANGE (allocno_preferenced_hard_regno,\n-\t\t  0, FIRST_PSEUDO_REGISTER - 1))\n+  if (! IN_RANGE (allocno_preferenced_hard_regno, 0, FIRST_PSEUDO_REGISTER - 1))\n     /* Can not be tied.  */\n     return false;\n   rclass = REGNO_REG_CLASS (allocno_preferenced_hard_regno);\n   mode = ALLOCNO_MODE (a);\n-  aclass = ALLOCNO_CLASS (a);\n+  cover_class = ALLOCNO_COVER_CLASS (a);\n   if (only_regs_p && insn != NULL_RTX\n       && reg_class_size[rclass] <= (unsigned) CLASS_MAX_NREGS (rclass, mode))\n     /* It is already taken into account in ira-costs.c.  */\n     return false;\n-  index = ira_class_hard_reg_index[aclass][allocno_preferenced_hard_regno];\n+  index = ira_class_hard_reg_index[cover_class][allocno_preferenced_hard_regno];\n   if (index < 0)\n-    /* Can not be tied.  It is not in the allocno class.  */\n+    /* Can not be tied.  It is not in the cover class.  */\n     return false;\n-  ira_init_register_move_cost_if_necessary (mode);\n   if (HARD_REGISTER_P (reg1))\n-    cost = ira_register_move_cost[mode][aclass][rclass] * freq;\n+    cost = ira_get_register_move_cost (mode, cover_class, rclass) * freq;\n   else\n-    cost = ira_register_move_cost[mode][rclass][aclass] * freq;\n+    cost = ira_get_register_move_cost (mode, rclass, cover_class) * freq;\n   do\n     {\n       ira_allocate_and_set_costs\n-\t(&ALLOCNO_HARD_REG_COSTS (a), aclass,\n-\t ALLOCNO_CLASS_COST (a));\n+\t(&ALLOCNO_HARD_REG_COSTS (a), cover_class,\n+\t ALLOCNO_COVER_CLASS_COST (a));\n       ira_allocate_and_set_costs\n-\t(&ALLOCNO_CONFLICT_HARD_REG_COSTS (a), aclass, 0);\n+\t(&ALLOCNO_CONFLICT_HARD_REG_COSTS (a), cover_class, 0);\n       ALLOCNO_HARD_REG_COSTS (a)[index] -= cost;\n       ALLOCNO_CONFLICT_HARD_REG_COSTS (a)[index] -= cost;\n-      if (ALLOCNO_HARD_REG_COSTS (a)[index] < ALLOCNO_CLASS_COST (a))\n-\tALLOCNO_CLASS_COST (a) = ALLOCNO_HARD_REG_COSTS (a)[index];\n+      if (ALLOCNO_HARD_REG_COSTS (a)[index] < ALLOCNO_COVER_CLASS_COST (a))\n+\tALLOCNO_COVER_CLASS_COST (a) = ALLOCNO_HARD_REG_COSTS (a)[index];\n       a = ira_parent_or_cap_allocno (a);\n     }\n   while (a != NULL);\n@@ -510,8 +507,7 @@ add_insn_allocno_copies (rtx insn)\n \t\t\t? SET_SRC (set)\n \t\t\t: SUBREG_REG (SET_SRC (set))) != NULL_RTX)\n     {\n-      process_regs_for_copy (SET_DEST (set), SET_SRC (set),\n-\t\t\t     false, insn, freq);\n+      process_regs_for_copy (SET_DEST (set), SET_SRC (set), false, insn, freq);\n       return;\n     }\n   /* Fast check of possibility of constraint or shuffle copies.  If\n@@ -612,7 +608,6 @@ build_object_conflicts (ira_object_t obj)\n   ira_allocno_t a = OBJECT_ALLOCNO (obj);\n   IRA_INT_TYPE *object_conflicts;\n   minmax_set_iterator asi;\n-  int parent_min, parent_max;\n \n   object_conflicts = conflicts[OBJECT_CONFLICT_ID (obj)];\n   px = 0;\n@@ -621,9 +616,8 @@ build_object_conflicts (ira_object_t obj)\n     {\n       ira_object_t another_obj = ira_object_id_map[i];\n       ira_allocno_t another_a = OBJECT_ALLOCNO (obj);\n-\n       ira_assert (ira_reg_classes_intersect_p\n-\t\t  [ALLOCNO_CLASS (a)][ALLOCNO_CLASS (another_a)]);\n+\t\t  [ALLOCNO_COVER_CLASS (a)][ALLOCNO_COVER_CLASS (another_a)]);\n       collected_conflict_objects[px++] = another_obj;\n     }\n   if (ira_conflict_vector_profitable_p (obj, px))\n@@ -638,7 +632,6 @@ build_object_conflicts (ira_object_t obj)\n   else\n     {\n       int conflict_bit_vec_words_num;\n-\n       OBJECT_CONFLICT_ARRAY (obj) = object_conflicts;\n       if (OBJECT_MAX (obj) < OBJECT_MIN (obj))\n \tconflict_bit_vec_words_num = 0;\n@@ -653,12 +646,10 @@ build_object_conflicts (ira_object_t obj)\n   parent_a = ira_parent_or_cap_allocno (a);\n   if (parent_a == NULL)\n     return;\n-  ira_assert (ALLOCNO_CLASS (a) == ALLOCNO_CLASS (parent_a));\n+  ira_assert (ALLOCNO_COVER_CLASS (a) == ALLOCNO_COVER_CLASS (parent_a));\n   ira_assert (ALLOCNO_NUM_OBJECTS (a) == ALLOCNO_NUM_OBJECTS (parent_a));\n   parent_obj = ALLOCNO_OBJECT (parent_a, OBJECT_SUBWORD (obj));\n   parent_num = OBJECT_CONFLICT_ID (parent_obj);\n-  parent_min = OBJECT_MIN (parent_obj);\n-  parent_max = OBJECT_MAX (parent_obj);\n   FOR_EACH_BIT_IN_MINMAX_SET (object_conflicts,\n \t\t\t      OBJECT_MIN (obj), OBJECT_MAX (obj), i, asi)\n     {\n@@ -667,20 +658,21 @@ build_object_conflicts (ira_object_t obj)\n       int another_word = OBJECT_SUBWORD (another_obj);\n \n       ira_assert (ira_reg_classes_intersect_p\n-\t\t  [ALLOCNO_CLASS (a)][ALLOCNO_CLASS (another_a)]);\n+\t\t  [ALLOCNO_COVER_CLASS (a)][ALLOCNO_COVER_CLASS (another_a)]);\n \n       another_parent_a = ira_parent_or_cap_allocno (another_a);\n       if (another_parent_a == NULL)\n \tcontinue;\n       ira_assert (ALLOCNO_NUM (another_parent_a) >= 0);\n-      ira_assert (ALLOCNO_CLASS (another_a)\n-\t\t  == ALLOCNO_CLASS (another_parent_a));\n+      ira_assert (ALLOCNO_COVER_CLASS (another_a)\n+\t\t  == ALLOCNO_COVER_CLASS (another_parent_a));\n       ira_assert (ALLOCNO_NUM_OBJECTS (another_a)\n \t\t  == ALLOCNO_NUM_OBJECTS (another_parent_a));\n       SET_MINMAX_SET_BIT (conflicts[parent_num],\n \t\t\t  OBJECT_CONFLICT_ID (ALLOCNO_OBJECT (another_parent_a,\n-\t\t\t\t\t\t\t      another_word)),\n-\t\t\t  parent_min, parent_max);\n+\t\t\t\t\t\t     another_word)),\n+\t\t\t  OBJECT_MIN (parent_obj),\n+\t\t\t  OBJECT_MAX (parent_obj));\n     }\n }\n \n@@ -800,14 +792,14 @@ print_allocno_conflicts (FILE * file, bool reg_p, ira_allocno_t a)\n       COPY_HARD_REG_SET (conflicting_hard_regs, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n       AND_COMPL_HARD_REG_SET (conflicting_hard_regs, ira_no_alloc_regs);\n       AND_HARD_REG_SET (conflicting_hard_regs,\n-\t\t\treg_class_contents[ALLOCNO_CLASS (a)]);\n+\t\t\treg_class_contents[ALLOCNO_COVER_CLASS (a)]);\n       print_hard_reg_set (file, \"\\n;;     total conflict hard regs:\",\n \t\t\t  conflicting_hard_regs);\n \n       COPY_HARD_REG_SET (conflicting_hard_regs, OBJECT_CONFLICT_HARD_REGS (obj));\n       AND_COMPL_HARD_REG_SET (conflicting_hard_regs, ira_no_alloc_regs);\n       AND_HARD_REG_SET (conflicting_hard_regs,\n-\t\t\treg_class_contents[ALLOCNO_CLASS (a)]);\n+\t\t\treg_class_contents[ALLOCNO_COVER_CLASS (a)]);\n       print_hard_reg_set (file, \";;     conflict hard regs:\",\n \t\t\t  conflicting_hard_regs);\n       putc ('\\n', file);\n@@ -884,7 +876,6 @@ ira_build_conflicts (void)\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n       int i, n = ALLOCNO_NUM_OBJECTS (a);\n-\n       for (i = 0; i < n; i++)\n \t{\n \t  ira_object_t obj = ALLOCNO_OBJECT (a, i);"}, {"sha": "6db5bf29b529d1f3713309d79fa9b6d24adf15fa", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 261, "deletions": 613, "changes": 874, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -62,7 +62,8 @@ struct costs\n {\n   int mem_cost;\n   /* Costs for register classes start here.  We process only some\n-     allocno classes.  */\n+     register classes (cover classes on the 1st cost calculation\n+     iteration and important classes on the 2nd iteration).  */\n   int cost[1];\n };\n \n@@ -76,13 +77,22 @@ struct costs\n   (this_target_ira_int->x_op_costs)\n #define this_op_costs \\\n   (this_target_ira_int->x_this_op_costs)\n+#define cost_classes \\\n+  (this_target_ira_int->x_cost_classes)\n \n /* Costs of each class for each allocno or pseudo.  */\n static struct costs *costs;\n \n /* Accumulated costs of each class for each allocno.  */\n static struct costs *total_allocno_costs;\n \n+/* The size of the previous array.  */\n+static int cost_classes_num;\n+\n+/* Map: cost class -> order number (they start with 0) of the cost\n+   class.  The order number is negative for non-cost classes.  */\n+static int cost_class_nums[N_REG_CLASSES];\n+\n /* It is the current size of struct costs.  */\n static int struct_costs_size;\n \n@@ -92,8 +102,8 @@ static int struct_costs_size;\n   ((struct costs *) ((char *) (arr) + (num) * struct_costs_size))\n \n /* Return index in COSTS when processing reg with REGNO.  */\n-#define COST_INDEX(regno) (allocno_p \t\t\t\t\t     \\\n-                           ? ALLOCNO_NUM (ira_curr_regno_allocno_map[regno]) \\\n+#define COST_INDEX(regno) (allocno_p \t\t\t\t\t      \\\n+                           ? ALLOCNO_NUM (ira_curr_regno_allocno_map[regno])  \\\n \t\t\t   : (int) regno)\n \n /* Record register class preferences of each allocno or pseudo.  Null\n@@ -104,8 +114,8 @@ static enum reg_class *pref;\n /* Allocated buffers for pref.  */\n static enum reg_class *pref_buffer;\n \n-/* Record allocno class of each allocno with the same regno.  */\n-static enum reg_class *regno_aclass;\n+/* Record cover register class of each allocno with the same regno.  */\n+static enum reg_class *regno_cover_class;\n \n /* Record cost gains for not allocating a register with an invariant\n    equivalence.  */\n@@ -116,204 +126,6 @@ static int frequency;\n \n \f\n \n-/* Info about reg classes whose costs are calculated for a pseudo.  */\n-struct cost_classes\n-{\n-  /* Number of the cost classes in the subsequent array.  */\n-  int num;\n-  /* Container of the cost classes.  */\n-  enum reg_class classes[N_REG_CLASSES];\n-  /* Map reg class -> index of the reg class in the previous array.\n-     -1 if it is not a cost classe.  */\n-  int index[N_REG_CLASSES];\n-  /* Map hard regno index of first class in array CLASSES containing\n-     the hard regno, -1 otherwise.  */\n-  int hard_regno_index[FIRST_PSEUDO_REGISTER];\n-};\n-\n-/* Types of pointers to the structure above.  */\n-typedef struct cost_classes *cost_classes_t;\n-typedef const struct cost_classes *const_cost_classes_t;\n-\n-/* Info about cost classes for each pseudo.  */\n-static cost_classes_t *regno_cost_classes;\n-\n-/* Returns hash value for cost classes info V.  */\n-static hashval_t\n-cost_classes_hash (const void *v)\n-{\n-  const_cost_classes_t hv = (const_cost_classes_t) v;\n-\n-  return iterative_hash (&hv->classes, sizeof (enum reg_class) * hv->num, 0);\n-}\n-\n-/* Compares cost classes info V1 and V2.  */\n-static int\n-cost_classes_eq (const void *v1, const void *v2)\n-{\n-  const_cost_classes_t hv1 = (const_cost_classes_t) v1;\n-  const_cost_classes_t hv2 = (const_cost_classes_t) v2;\n-\n-  return hv1->num == hv2->num && memcmp (hv1->classes, hv2->classes,\n-\t\t\t\t\t sizeof (enum reg_class) * hv1->num);\n-}\n-\n-/* Delete cost classes info V from the hash table.  */\n-static void\n-cost_classes_del (void *v)\n-{\n-  ira_free (v);\n-}\n-\n-/* Hash table of unique cost classes.  */\n-static htab_t cost_classes_htab;\n-\n-/* Map allocno class -> cost classes for pseudo of given allocno\n-   class.  */\n-static cost_classes_t cost_classes_aclass_cache[N_REG_CLASSES];\n-\n-/* Map mode -> cost classes for pseudo of give mode.  */\n-static cost_classes_t cost_classes_mode_cache[MAX_MACHINE_MODE];\n-\n-/* Initialize info about the cost classes for each pseudo.  */\n-static void\n-initiate_regno_cost_classes (void)\n-{\n-  int size = sizeof (cost_classes_t) * max_reg_num ();\n-\n-  regno_cost_classes = (cost_classes_t *) ira_allocate (size);\n-  memset (regno_cost_classes, 0, size);\n-  memset (cost_classes_aclass_cache, 0,\n-\t  sizeof (cost_classes_t) * N_REG_CLASSES);\n-  memset (cost_classes_mode_cache, 0,\n-\t  sizeof (cost_classes_t) * MAX_MACHINE_MODE);\n-  cost_classes_htab\n-    = htab_create (200, cost_classes_hash, cost_classes_eq, cost_classes_del);\n-}\n-\n-/* Create new cost classes from cost classes FROM and set up members\n-   index and hard_regno_index.  Return the new classes.  The function\n-   implements some common code of two functions\n-   setup_regno_cost_classes_by_aclass and\n-   setup_regno_cost_classes_by_mode.  */\n-static cost_classes_t\n-setup_cost_classes (cost_classes_t from)\n-{\n-  cost_classes_t classes_ptr;\n-  enum reg_class cl;\n-  int i, j, hard_regno;\n-\n-  classes_ptr = (cost_classes_t) ira_allocate (sizeof (struct cost_classes));\n-  classes_ptr->num = from->num;\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    classes_ptr->index[i] = -1;\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    classes_ptr->hard_regno_index[i] = -1;\n-  for (i = 0; i < from->num; i++)\n-    {\n-      cl = classes_ptr->classes[i] = from->classes[i];\n-      classes_ptr->index[cl] = i;\n-      for (j = ira_class_hard_regs_num[cl] - 1; j >= 0; j--)\n-\t{\n-\t  hard_regno = ira_class_hard_regs[cl][j];\n-\t  if (classes_ptr->hard_regno_index[hard_regno] < 0)\n-\t    classes_ptr->hard_regno_index[hard_regno] = i;\n-\t}\n-    }\n-  return classes_ptr;\n-}\n-\n-/* Setup cost classes for pseudo REGNO whose allocno class is ACLASS.\n-   This function is used when we know an initial approximation of\n-   allocno class of the pseudo already, e.g. on the second iteration\n-   of class cost calculation or after class cost calculation in\n-   register-pressure sensitive insn scheduling or register-pressure\n-   sensitive loop-invariant motion.  */\n-static void\n-setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n-{\n-  static struct cost_classes classes;\n-  cost_classes_t classes_ptr;\n-  enum reg_class cl;\n-  int i;\n-  PTR *slot;\n-  HARD_REG_SET temp, temp2;\n-\n-  if ((classes_ptr = cost_classes_aclass_cache[aclass]) == NULL)\n-    {\n-      COPY_HARD_REG_SET (temp, reg_class_contents[aclass]);\n-      AND_COMPL_HARD_REG_SET (temp, ira_no_alloc_regs);\n-      classes.num = 0;\n-      for (i = 0; i < ira_important_classes_num; i++)\n-\t{\n-\t  cl = ira_important_classes[i];\n-\t  COPY_HARD_REG_SET (temp2, reg_class_contents[cl]);\n-\t  AND_COMPL_HARD_REG_SET (temp2, ira_no_alloc_regs);\n-\t  if (! ira_reg_pressure_class_p[cl]\n-\t      && hard_reg_set_subset_p (temp2, temp) && cl != aclass)\n-\t    continue;\n-\t  classes.classes[classes.num++] = cl;\n-\t}\n-      slot = htab_find_slot (cost_classes_htab, &classes, INSERT);\n-      if (*slot == NULL)\n-\t{\n-\t  classes_ptr = setup_cost_classes (&classes);\n-\t  *slot = classes_ptr;\n-\t}\n-      classes_ptr = cost_classes_aclass_cache[aclass] = (cost_classes_t) *slot;\n-    }\n-  regno_cost_classes[regno] = classes_ptr;\n-}\n-\n-/* Setup cost classes for pseudo REGNO with MODE.  Usage of MODE can\n-   decrease number of cost classes for the pseudo, if hard registers\n-   of some important classes can not hold a value of MODE.  So the\n-   pseudo can not get hard register of some important classes and cost\n-   calculation for such important classes is only waisting CPU\n-   time.  */\n-static void\n-setup_regno_cost_classes_by_mode (int regno, enum machine_mode mode)\n-{\n-  static struct cost_classes classes;\n-  cost_classes_t classes_ptr;\n-  enum reg_class cl;\n-  int i;\n-  PTR *slot;\n-  HARD_REG_SET temp;\n-\n-  if ((classes_ptr = cost_classes_mode_cache[mode]) == NULL)\n-    {\n-      classes.num = 0;\n-      for (i = 0; i < ira_important_classes_num; i++)\n-\t{\n-\t  cl = ira_important_classes[i];\n-\t  COPY_HARD_REG_SET (temp, ira_prohibited_class_mode_regs[cl][mode]);\n-\t  IOR_HARD_REG_SET (temp, ira_no_alloc_regs);\n-\t  if (hard_reg_set_subset_p (reg_class_contents[cl], temp))\n-\t    continue;\n-\t  classes.classes[classes.num++] = cl;\n-\t}\n-      slot = htab_find_slot (cost_classes_htab, &classes, INSERT);\n-      if (*slot == NULL)\n-\t{\n-\t  classes_ptr = setup_cost_classes (&classes);\n-\t  *slot = classes_ptr;\n-\t}\n-      cost_classes_mode_cache[mode] = (cost_classes_t) *slot;\n-    }\n-  regno_cost_classes[regno] = classes_ptr;\n-}\n-\n-/* Finilize info about the cost classes for each pseudo.  */\n-static void\n-finish_regno_cost_classes (void)\n-{\n-  ira_free (regno_cost_classes);\n-  htab_delete (cost_classes_htab);\n-}\n-\n-\f\n-\n /* Compute the cost of loading X into (if TO_P is TRUE) or from (if\n    TO_P is FALSE) a register of class RCLASS in mode MODE.  X must not\n    be a pseudo register.  */\n@@ -501,78 +313,53 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     Moreover, if we cannot tie them, this alternative\n \t\t     needs to do a copy, which is one insn.  */\n \t\t  struct costs *pp = this_op_costs[i];\n-\t\t  int *pp_costs = pp->cost;\n-\t\t  cost_classes_t cost_classes_ptr\n-\t\t    = regno_cost_classes[REGNO (op)];\n-\t\t  enum reg_class *cost_classes = cost_classes_ptr->classes;\n-\t\t  bool in_p = recog_data.operand_type[i] != OP_OUT;\n-\t\t  bool out_p = recog_data.operand_type[i] != OP_IN;\n-\t\t  enum reg_class op_class = classes[i];\n-\t\t  move_table *move_in_cost, *move_out_cost;\n-\n-\t\t  ira_init_register_move_cost_if_necessary (mode);\n-\t\t  if (! in_p)\n-\t\t    {\n-\t\t      ira_assert (out_p);\n-\t\t      move_out_cost = ira_may_move_out_cost[mode];\n-\t\t      for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t\t\t{\n-\t\t\t  rclass = cost_classes[k];\n-\t\t\t  pp_costs[k]\n-\t\t\t    = move_out_cost[op_class][rclass] * frequency;\n-\t\t\t}\n-\t\t    }\n-\t\t  else if (! out_p)\n-\t\t    {\n-\t\t      ira_assert (in_p);\n-\t\t      move_in_cost = ira_may_move_in_cost[mode];\n-\t\t      for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t\t\t{\n-\t\t\t  rclass = cost_classes[k];\n-\t\t\t  pp_costs[k]\n-\t\t\t    = move_in_cost[rclass][op_class] * frequency;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n+\n+\t\t  for (k = 0; k < cost_classes_num; k++)\n \t\t    {\n-\t\t      move_in_cost = ira_may_move_in_cost[mode];\n-\t\t      move_out_cost = ira_may_move_out_cost[mode];\n-\t\t      for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t\t\t{\n-\t\t\t  rclass = cost_classes[k];\n-\t\t\t  pp_costs[k] = ((move_in_cost[rclass][op_class]\n-\t\t\t\t\t  + move_out_cost[op_class][rclass])\n-\t\t\t\t\t * frequency);\n-\t\t\t}\n+\t\t      rclass = cost_classes[k];\n+\t\t      pp->cost[k]\n+\t\t\t= (((recog_data.operand_type[i] != OP_OUT\n+\t\t\t     ? ira_get_may_move_cost (mode, rclass,\n+\t\t\t\t\t\t      classes[i], true) : 0)\n+\t\t\t    + (recog_data.operand_type[i] != OP_IN\n+\t\t\t       ? ira_get_may_move_cost (mode, classes[i],\n+\t\t\t\t\t\t\trclass, false) : 0))\n+\t\t\t   * frequency);\n \t\t    }\n \n \t\t  /* If the alternative actually allows memory, make\n \t\t     things a bit cheaper since we won't need an extra\n \t\t     insn to load it.  */\n \t\t  pp->mem_cost\n-\t\t    = ((out_p ? ira_memory_move_cost[mode][op_class][0] : 0)\n-\t\t       + (in_p ? ira_memory_move_cost[mode][op_class][1] : 0)\n+\t\t    = ((recog_data.operand_type[i] != OP_IN\n+\t\t\t? ira_memory_move_cost[mode][classes[i]][0] : 0)\n+\t\t       + (recog_data.operand_type[i] != OP_OUT\n+\t\t\t  ? ira_memory_move_cost[mode][classes[i]][1] : 0)\n \t\t       - allows_mem[i]) * frequency;\n \n-\t\t  /* If we have assigned a class to this allocno in\n-\t\t     our first pass, add a cost to this alternative\n-\t\t     corresponding to what we would add if this\n-\t\t     allocno were not in the appropriate class.  */\n+\t\t  /* If we have assigned a class to this allocno in our\n+\t\t     first pass, add a cost to this alternative\n+\t\t     corresponding to what we would add if this allocno\n+\t\t     were not in the appropriate class.  We could use\n+\t\t     cover class here but it is less accurate\n+\t\t     approximation.  */\n \t\t  if (pref)\n \t\t    {\n \t\t      enum reg_class pref_class = pref[COST_INDEX (REGNO (op))];\n \n \t\t      if (pref_class == NO_REGS)\n \t\t\talt_cost\n-\t\t\t  += ((out_p\n-\t\t\t       ? ira_memory_move_cost[mode][op_class][0] : 0)\n-\t\t\t      + (in_p\n-\t\t\t\t ? ira_memory_move_cost[mode][op_class][1]\n+\t\t\t  += ((recog_data.operand_type[i] != OP_IN\n+\t\t\t       ? ira_memory_move_cost[mode][classes[i]][0]\n+\t\t\t       : 0)\n+\t\t\t      + (recog_data.operand_type[i] != OP_OUT\n+\t\t\t\t ? ira_memory_move_cost[mode][classes[i]][1]\n \t\t\t\t : 0));\n \t\t      else if (ira_reg_class_intersect\n-\t\t\t       [pref_class][op_class] == NO_REGS)\n-\t\t\talt_cost\n-\t\t\t  += ira_register_move_cost[mode][pref_class][op_class];\n+\t\t\t       [pref_class][classes[i]] == NO_REGS)\n+\t\t\talt_cost += ira_get_register_move_cost (mode,\n+\t\t\t\t\t\t\t\tpref_class,\n+\t\t\t\t\t\t\t\tclasses[i]);\n \t\t    }\n \t\t  if (REGNO (ops[i]) != REGNO (ops[j])\n \t\t      && ! find_reg_note (insn, REG_DEAD, op))\n@@ -618,7 +405,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     to be allocated to a register that can be the\n \t\t     base of an address, i.e. BASE_REG_CLASS.  */\n \t\t  classes[i]\n-\t\t    = ira_reg_class_subunion[classes[i]]\n+\t\t    = ira_reg_class_union[classes[i]]\n \t\t      [base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n \t\t  break;\n \n@@ -704,12 +491,12 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t    win = 1;\n \t\t  insn_allows_mem[i] = allows_mem[i] = 1;\n \t\tcase 'r':\n-\t\t  classes[i] = ira_reg_class_subunion[classes[i]][GENERAL_REGS];\n+\t\t  classes[i] = ira_reg_class_union[classes[i]][GENERAL_REGS];\n \t\t  break;\n \n \t\tdefault:\n \t\t  if (REG_CLASS_FROM_CONSTRAINT (c, p) != NO_REGS)\n-\t\t    classes[i] = ira_reg_class_subunion[classes[i]]\n+\t\t    classes[i] = ira_reg_class_union[classes[i]]\n \t\t                 [REG_CLASS_FROM_CONSTRAINT (c, p)];\n #ifdef EXTRA_CONSTRAINT_STR\n \t\t  else if (EXTRA_CONSTRAINT_STR (op, c, p))\n@@ -733,7 +520,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t\t that can be the base of an address,\n \t\t\t i.e. BASE_REG_CLASS.  */\n \t\t      classes[i]\n-\t\t\t= ira_reg_class_subunion[classes[i]]\n+\t\t\t= ira_reg_class_union[classes[i]]\n \t\t\t  [base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n \t\t    }\n #endif\n@@ -767,77 +554,53 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t}\n \t      else\n \t\t{\n-\t\t  unsigned int regno = REGNO (op);\n \t\t  struct costs *pp = this_op_costs[i];\n-\t\t  int *pp_costs = pp->cost;\n-\t\t  cost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n-\t\t  enum reg_class *cost_classes = cost_classes_ptr->classes;\n-\t\t  bool in_p = recog_data.operand_type[i] != OP_OUT;\n-\t\t  bool out_p = recog_data.operand_type[i] != OP_IN;\n-\t\t  enum reg_class op_class = classes[i];\n-\t\t  move_table *move_in_cost, *move_out_cost;\n-\n-\t\t  ira_init_register_move_cost_if_necessary (mode);\n-\t\t  if (! in_p)\n-\t\t    {\n-\t\t      ira_assert (out_p);\n-\t\t      move_out_cost = ira_may_move_out_cost[mode];\n-\t\t      for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t\t\t{\n-\t\t\t  rclass = cost_classes[k];\n-\t\t\t  pp_costs[k]\n-\t\t\t    = move_out_cost[op_class][rclass] * frequency;\n-\t\t\t}\n-\t\t    }\n-\t\t  else if (! out_p)\n-\t\t    {\n-\t\t      ira_assert (in_p);\n-\t\t      move_in_cost = ira_may_move_in_cost[mode];\n-\t\t      for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t\t\t{\n-\t\t\t  rclass = cost_classes[k];\n-\t\t\t  pp_costs[k]\n-\t\t\t    = move_in_cost[rclass][op_class] * frequency;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n+\n+\t\t  for (k = 0; k < cost_classes_num; k++)\n \t\t    {\n-\t\t      move_in_cost = ira_may_move_in_cost[mode];\n-\t\t      move_out_cost = ira_may_move_out_cost[mode];\n-\t\t      for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t\t\t{\n-\t\t\t  rclass = cost_classes[k];\n-\t\t\t  pp_costs[k] = ((move_in_cost[rclass][op_class]\n-\t\t\t\t\t  + move_out_cost[op_class][rclass])\n-\t\t\t\t\t * frequency);\n-\t\t\t}\n+\t\t      rclass = cost_classes[k];\n+\t\t      pp->cost[k]\n+\t\t\t= (((recog_data.operand_type[i] != OP_OUT\n+\t\t\t     ? ira_get_may_move_cost (mode, rclass,\n+\t\t\t\t\t\t      classes[i], true) : 0)\n+\t\t\t    + (recog_data.operand_type[i] != OP_IN\n+\t\t\t       ? ira_get_may_move_cost (mode, classes[i],\n+\t\t\t\t\t\t\trclass, false) : 0))\n+\t\t\t   * frequency);\n \t\t    }\n \n \t\t  /* If the alternative actually allows memory, make\n \t\t     things a bit cheaper since we won't need an extra\n \t\t     insn to load it.  */\n \t\t  pp->mem_cost\n-\t\t    = ((out_p ? ira_memory_move_cost[mode][op_class][0] : 0)\n-\t\t       + (in_p ? ira_memory_move_cost[mode][op_class][1] : 0)\n+\t\t    = ((recog_data.operand_type[i] != OP_IN\n+\t\t\t? ira_memory_move_cost[mode][classes[i]][0] : 0)\n+\t\t       + (recog_data.operand_type[i] != OP_OUT\n+\t\t\t  ? ira_memory_move_cost[mode][classes[i]][1] : 0)\n \t\t       - allows_mem[i]) * frequency;\n-\t\t  /* If we have assigned a class to this allocno in\n-\t\t     our first pass, add a cost to this alternative\n-\t\t     corresponding to what we would add if this\n-\t\t     allocno were not in the appropriate class.  */\n+\t\t  /* If we have assigned a class to this allocno in our\n+\t\t     first pass, add a cost to this alternative\n+\t\t     corresponding to what we would add if this allocno\n+\t\t     were not in the appropriate class.  We could use\n+\t\t     cover class here but it is less accurate\n+\t\t     approximation.  */\n \t\t  if (pref)\n \t\t    {\n \t\t      enum reg_class pref_class = pref[COST_INDEX (REGNO (op))];\n \n \t\t      if (pref_class == NO_REGS)\n \t\t\talt_cost\n-\t\t\t  += ((out_p\n-\t\t\t       ? ira_memory_move_cost[mode][op_class][0] : 0)\n-\t\t\t      + (in_p\n-\t\t\t\t ? ira_memory_move_cost[mode][op_class][1]\n+\t\t\t  += ((recog_data.operand_type[i] != OP_IN\n+\t\t\t       ? ira_memory_move_cost[mode][classes[i]][0]\n+\t\t\t       : 0)\n+\t\t\t      + (recog_data.operand_type[i] != OP_OUT\n+\t\t\t\t ? ira_memory_move_cost[mode][classes[i]][1]\n \t\t\t\t : 0));\n-\t\t      else if (ira_reg_class_intersect[pref_class][op_class]\n+\t\t      else if (ira_reg_class_intersect[pref_class][classes[i]]\n \t\t\t       == NO_REGS)\n-\t\t\talt_cost += ira_register_move_cost[mode][pref_class][op_class];\n+\t\t\talt_cost += ira_get_register_move_cost (mode,\n+\t\t\t\t\t\t\t\tpref_class,\n+\t\t\t\t\t\t\t\tclasses[i]);\n \t\t    }\n \t\t}\n \t    }\n@@ -880,17 +643,14 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \tif (REG_P (ops[i]) && REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER)\n \t  {\n \t    struct costs *pp = op_costs[i], *qq = this_op_costs[i];\n-\t    int *pp_costs = pp->cost, *qq_costs = qq->cost;\n \t    int scale = 1 + (recog_data.operand_type[i] == OP_INOUT);\n-\t    cost_classes_t cost_classes_ptr\n-\t      = regno_cost_classes[REGNO (ops[i])];\n \n \t    pp->mem_cost = MIN (pp->mem_cost,\n \t\t\t\t(qq->mem_cost + op_cost_add) * scale);\n \n-\t    for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t      pp_costs[k]\n-\t\t= MIN (pp_costs[k], (qq_costs[k] + op_cost_add) * scale);\n+\t    for (k = 0; k < cost_classes_num; k++)\n+\t      pp->cost[k]\n+\t\t= MIN (pp->cost[k], (qq->cost[k] + op_cost_add) * scale);\n \t  }\n     }\n \n@@ -926,40 +686,37 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n       && REG_P (ops[0]) && REG_P (ops[1])\n       && find_regno_note (insn, REG_DEAD, REGNO (ops[1])))\n     for (i = 0; i <= 1; i++)\n-      if (REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER\n-\t  && REGNO (ops[!i]) < FIRST_PSEUDO_REGISTER)\n+      if (REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER)\n \t{\n-\t  unsigned int regno = REGNO (ops[i]);\n-\t  unsigned int other_regno = REGNO (ops[!i]);\n+\t  unsigned int regno = REGNO (ops[!i]);\n \t  enum machine_mode mode = GET_MODE (ops[!i]);\n-\t  cost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n-\t  enum reg_class *cost_classes = cost_classes_ptr->classes;\n \t  enum reg_class rclass;\n-\t  int nr;\n+\t  unsigned int nr;\n \n-\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t    {\n-\t      rclass = cost_classes[k];\n-\t      if (TEST_HARD_REG_BIT (reg_class_contents[rclass], other_regno)\n-\t\t  && (reg_class_size[rclass]\n-\t\t      == (unsigned) CLASS_MAX_NREGS (rclass, mode)))\n-\t\t{\n-\t\t  if (reg_class_size[rclass] == 1)\n-\t\t    op_costs[i]->cost[k] = -frequency;\n-\t\t  else\n-\t\t    {\n-\t\t      for (nr = 0;\n-\t\t\t   nr < hard_regno_nregs[other_regno][mode];\n-\t\t\t   nr++)\n-\t\t\tif (! TEST_HARD_REG_BIT (reg_class_contents[rclass],\n-\t\t\t\t\t\t other_regno + nr))\n-\t\t\t  break;\n-\t\t      \n-\t\t      if (nr == hard_regno_nregs[other_regno][mode])\n-\t\t\top_costs[i]->cost[k] = -frequency;\n-\t\t    }\n-\t\t}\n-\t    }\n+\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t    for (k = 0; k < cost_classes_num; k++)\n+\t      {\n+\t\trclass = cost_classes[k];\n+\t\tif (TEST_HARD_REG_BIT (reg_class_contents[rclass], regno)\n+\t\t    && (reg_class_size[rclass]\n+\t\t\t== (unsigned) CLASS_MAX_NREGS (rclass, mode)))\n+\t\t  {\n+\t\t    if (reg_class_size[rclass] == 1)\n+\t\t      op_costs[i]->cost[k] = -frequency;\n+\t\t    else\n+\t\t      {\n+\t\t\tfor (nr = 0;\n+\t\t\t     nr < (unsigned) hard_regno_nregs[regno][mode];\n+\t\t\t     nr++)\n+\t\t\t  if (! TEST_HARD_REG_BIT (reg_class_contents[rclass],\n+\t\t\t\t\t\t   regno + nr))\n+\t\t\t    break;\n+\n+\t\t\tif (nr == (unsigned) hard_regno_nregs[regno][mode])\n+\t\t\t  op_costs[i]->cost[k] = -frequency;\n+\t\t      }\n+\t\t  }\n+\t      }\n \t}\n }\n \n@@ -1146,38 +903,21 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n     case REG:\n       {\n \tstruct costs *pp;\n-\tint *pp_costs;\n \tenum reg_class i;\n-\tint k, regno, add_cost;\n-\tcost_classes_t cost_classes_ptr;\n-\tenum reg_class *cost_classes;\n-\tmove_table *move_in_cost;\n+\tint k;\n \n \tif (REGNO (x) < FIRST_PSEUDO_REGISTER)\n \t  break;\n \n-\tregno = REGNO (x);\n \tif (allocno_p)\n-\t  ALLOCNO_BAD_SPILL_P (ira_curr_regno_allocno_map[regno]) = true;\n-\tpp = COSTS (costs, COST_INDEX (regno));\n-\tadd_cost = (ira_memory_move_cost[Pmode][rclass][1] * scale) / 2;\n-\tif (INT_MAX - add_cost < pp->mem_cost)\n-\t  pp->mem_cost = INT_MAX;\n-\telse\n-\t  pp->mem_cost += add_cost;\n-\tcost_classes_ptr = regno_cost_classes[regno];\n-\tcost_classes = cost_classes_ptr->classes;\n-\tpp_costs = pp->cost;\n-\tira_init_register_move_cost_if_necessary (Pmode);\n-\tmove_in_cost = ira_may_move_in_cost[Pmode];\n-\tfor (k = cost_classes_ptr->num - 1; k >= 0; k--)\n+\t  ALLOCNO_BAD_SPILL_P (ira_curr_regno_allocno_map[REGNO (x)]) = true;\n+\tpp = COSTS (costs, COST_INDEX (REGNO (x)));\n+\tpp->mem_cost += (ira_memory_move_cost[Pmode][rclass][1] * scale) / 2;\n+\tfor (k = 0; k < cost_classes_num; k++)\n \t  {\n \t    i = cost_classes[k];\n-\t    add_cost = (move_in_cost[i][rclass] * scale) / 2;\n-\t    if (INT_MAX - add_cost < pp_costs[k])\n-\t      pp_costs[k] = INT_MAX;\n-\t    else \n-\t      pp_costs[k] += add_cost;\n+\t    pp->cost[k]\n+\t      += (ira_get_may_move_cost (Pmode, i, rclass, true) * scale) / 2;\n \t  }\n       }\n       break;\n@@ -1232,7 +972,7 @@ record_operand_costs (rtx insn, enum reg_class *pref)\n \trecord_address_regs (VOIDmode, recog_data.operand[i], 0, ADDRESS,\n \t\t\t     SCRATCH, frequency * 2);\n     }\n-  \n+\n   /* Check for commutative in a separate loop so everything will have\n      been initialized.  We must do this even if one operand is a\n      constant--see addsi3 in m68k.md.  */\n@@ -1301,6 +1041,8 @@ scan_one_insn (rtx insn)\n       rtx reg = SET_DEST (set);\n       int num = COST_INDEX (REGNO (reg));\n \n+      if (pref)\n+\tcl = pref[num];\n       COSTS (costs, num)->mem_cost\n \t-= ira_memory_move_cost[GET_MODE (reg)][cl][1] * frequency;\n       record_address_regs (GET_MODE (SET_SRC (set)), XEXP (SET_SRC (set), 0),\n@@ -1319,28 +1061,13 @@ scan_one_insn (rtx insn)\n \tint regno = REGNO (recog_data.operand[i]);\n \tstruct costs *p = COSTS (costs, COST_INDEX (regno));\n \tstruct costs *q = op_costs[i];\n-\tint *p_costs = p->cost, *q_costs = q->cost;\n-\tcost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n-\tint add_cost;\n \n \t/* If the already accounted for the memory \"cost\" above, don't\n \t   do so again.  */\n \tif (!counted_mem)\n-\t  {\n-\t    add_cost = q->mem_cost;\n-\t    if (add_cost > 0 && INT_MAX - add_cost < p->mem_cost)\n-\t      p->mem_cost = INT_MAX;\n-\t    else\n-\t      p->mem_cost += add_cost;\n-\t  }\n-\tfor (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t  {\n-\t    add_cost = q_costs[k];\n-\t    if (add_cost > 0 && INT_MAX - add_cost < p_costs[k])\n-\t      p_costs[k] = INT_MAX;\n-\t    else\n-\t      p_costs[k] += add_cost;\n-\t  }\n+\t  p->mem_cost += q->mem_cost;\n+\tfor (k = 0; k < cost_classes_num; k++)\n+\t  p->cost[k] += q->cost[k];\n       }\n \n   return insn;\n@@ -1363,8 +1090,6 @@ print_allocno_costs (FILE *f)\n       int i, rclass;\n       basic_block bb;\n       int regno = ALLOCNO_REGNO (a);\n-      cost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n-      enum reg_class *cost_classes = cost_classes_ptr->classes;\n \n       i = ALLOCNO_NUM (a);\n       fprintf (f, \"  a%d(r%d,\", i, regno);\n@@ -1373,7 +1098,7 @@ print_allocno_costs (FILE *f)\n       else\n \tfprintf (f, \"l%d\", ALLOCNO_LOOP_TREE_NODE (a)->loop->num);\n       fprintf (f, \") costs:\");\n-      for (k = 0; k < cost_classes_ptr->num; k++)\n+      for (k = 0; k < cost_classes_num; k++)\n \t{\n \t  rclass = cost_classes[k];\n \t  if (contains_reg_of_mode[rclass][PSEUDO_REGNO_MODE (regno)]\n@@ -1392,11 +1117,7 @@ print_allocno_costs (FILE *f)\n \t\tfprintf (f, \",%d\", COSTS (total_allocno_costs, i)->cost[k]);\n \t    }\n \t}\n-      fprintf (f, \" MEM:%i\", COSTS (costs, i)->mem_cost);\n-      if (flag_ira_region == IRA_REGION_ALL\n-\t  || flag_ira_region == IRA_REGION_MIXED)\n-\tfprintf (f, \",%d\", COSTS (total_allocno_costs, i)->mem_cost);\n-      fprintf (f, \"\\n\");\n+      fprintf (f, \" MEM:%i\\n\", COSTS (costs, i)->mem_cost);\n     }\n }\n \n@@ -1406,19 +1127,15 @@ print_pseudo_costs (FILE *f)\n {\n   int regno, k;\n   int rclass;\n-  cost_classes_t cost_classes_ptr;\n-  enum reg_class *cost_classes;\n \n   ira_assert (! allocno_p);\n   fprintf (f, \"\\n\");\n   for (regno = max_reg_num () - 1; regno >= FIRST_PSEUDO_REGISTER; regno--)\n     {\n-      if (REG_N_REFS (regno) <= 0)\n+      if (regno_reg_rtx[regno] == NULL_RTX)\n \tcontinue;\n-      cost_classes_ptr = regno_cost_classes[regno];\n-      cost_classes = cost_classes_ptr->classes;\n       fprintf (f, \"  r%d costs:\", regno);\n-      for (k = 0; k < cost_classes_ptr->num; k++)\n+      for (k = 0; k < cost_classes_num; k++)\n \t{\n \t  rclass = cost_classes[k];\n \t  if (contains_reg_of_mode[rclass][PSEUDO_REGNO_MODE (regno)]\n@@ -1463,54 +1180,31 @@ process_bb_node_for_costs (ira_loop_tree_node_t loop_tree_node)\n }\n \n /* Find costs of register classes and memory for allocnos or pseudos\n-   and their best costs.  Set up preferred, alternative and allocno\n+   and their best costs.  Set up preferred, alternative and cover\n    classes for pseudos.  */\n static void\n find_costs_and_classes (FILE *dump_file)\n {\n-  int i, k, start, max_cost_classes_num;\n+  int i, k, start;\n   int pass;\n   basic_block bb;\n-  enum reg_class *regno_best_class;\n \n   init_recog ();\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n   in_inc_dec = ira_allocate (sizeof (bool) * cost_elements_num);\n #endif /* FORBIDDEN_INC_DEC_CLASSES */\n-  regno_best_class\n-    = (enum reg_class *) ira_allocate (max_reg_num ()\n-\t\t\t\t       * sizeof (enum reg_class));\n-  for (i = max_reg_num () - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n-    regno_best_class[i] = NO_REGS;\n-  if (!resize_reg_info () && allocno_p\n-      && pseudo_classes_defined_p && flag_expensive_optimizations)\n+  pref = NULL;\n+  start = 0;\n+  if (!resize_reg_info () && allocno_p && pseudo_classes_defined_p)\n     {\n       ira_allocno_t a;\n       ira_allocno_iterator ai;\n \n       pref = pref_buffer;\n-      max_cost_classes_num = 1;\n       FOR_EACH_ALLOCNO (a, ai)\n-\t{\n-\t  pref[ALLOCNO_NUM (a)] = reg_preferred_class (ALLOCNO_REGNO (a));\n-\t  setup_regno_cost_classes_by_aclass\n-\t    (ALLOCNO_REGNO (a), pref[ALLOCNO_NUM (a)]);\n-\t  max_cost_classes_num\n-\t    = MAX (max_cost_classes_num,\n-\t\t   regno_cost_classes[ALLOCNO_REGNO (a)]->num);\n-\t}\n-      start = 1;\n-    }\n-  else\n-    {\n-      pref = NULL;\n-      max_cost_classes_num = ira_important_classes_num;\n-      for (i = max_reg_num () - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n-\tif (regno_reg_rtx[i] != NULL_RTX)\n- \t  setup_regno_cost_classes_by_mode (i, PSEUDO_REGNO_MODE (i));\n-\telse\n-\t  setup_regno_cost_classes_by_aclass (i, ALL_REGS);\n-      start = 0;\n+\tpref[ALLOCNO_NUM (a)] = reg_preferred_class (ALLOCNO_REGNO (a));\n+      if (flag_expensive_optimizations)\n+\tstart = 1;\n     }\n   if (allocno_p)\n     /* Clear the flag for the next compiled function.  */\n@@ -1524,20 +1218,22 @@ find_costs_and_classes (FILE *dump_file)\n       if ((!allocno_p || internal_flag_ira_verbose > 0) && dump_file)\n \tfprintf (dump_file,\n \t\t \"\\nPass %i for finding pseudo/allocno costs\\n\\n\", pass);\n-\n-      if (pass != start)\n+      /* We could use only cover classes.  Unfortunately it does not\n+\t work well for some targets where some subclass of cover class\n+\t is costly and wrong cover class is chosen.  */\n+      for (i = 0; i < N_REG_CLASSES; i++)\n+\tcost_class_nums[i] = -1;\n+      for (cost_classes_num = 0;\n+\t   cost_classes_num < ira_important_classes_num;\n+\t   cost_classes_num++)\n \t{\n-\t  max_cost_classes_num = 1;\n-\t  for (i = max_reg_num () - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n-\t    {\n-\t      setup_regno_cost_classes_by_aclass (i, regno_best_class[i]);\n-\t      max_cost_classes_num\n-\t\t= MAX (max_cost_classes_num, regno_cost_classes[i]->num);\n-\t    }\n+\t  cost_classes[cost_classes_num]\n+\t    = ira_important_classes[cost_classes_num];\n+\t  cost_class_nums[cost_classes[cost_classes_num]]\n+\t    = cost_classes_num;\n \t}\n-\n       struct_costs_size\n-\t= sizeof (struct costs) + sizeof (int) * (max_cost_classes_num - 1);\n+\t= sizeof (struct costs) + sizeof (int) * (cost_classes_num - 1);\n       /* Zero out our accumulation of the cost of each class for each\n \t allocno.  */\n       memset (costs, 0, cost_elements_num * struct_costs_size);\n@@ -1571,17 +1267,13 @@ find_costs_and_classes (FILE *dump_file)\n       for (i = max_reg_num () - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n \t{\n \t  ira_allocno_t a, parent_a;\n-\t  int rclass, a_num, parent_a_num, add_cost;\n+\t  int rclass, a_num, parent_a_num;\n \t  ira_loop_tree_node_t parent;\n \t  int best_cost, allocno_cost;\n \t  enum reg_class best, alt_class;\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \t  int inc_dec_p = false;\n #endif\n-\t  cost_classes_t cost_classes_ptr = regno_cost_classes[i];\n-\t  enum reg_class *cost_classes = cost_classes_ptr->classes;\n-\t  int *i_costs = temp_costs->cost;\n-\t  int i_mem_cost;\n \t  int equiv_savings = regno_equiv_gains[i];\n \n \t  if (! allocno_p)\n@@ -1592,21 +1284,17 @@ find_costs_and_classes (FILE *dump_file)\n \t      inc_dec_p = in_inc_dec[i];\n #endif\n \t      memcpy (temp_costs, COSTS (costs, i), struct_costs_size);\n-\t      i_mem_cost = temp_costs->mem_cost;\n \t    }\n \t  else\n \t    {\n \t      if (ira_regno_allocno_map[i] == NULL)\n \t\tcontinue;\n \t      memset (temp_costs, 0, struct_costs_size);\n-\t      i_mem_cost = 0;\n \t      /* Find cost of all allocnos with the same regno.  */\n \t      for (a = ira_regno_allocno_map[i];\n \t\t   a != NULL;\n \t\t   a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n \t\t{\n-\t\t  int *a_costs, *p_costs;\n-\t\t      \n \t\t  a_num = ALLOCNO_NUM (a);\n \t\t  if ((flag_ira_region == IRA_REGION_ALL\n \t\t       || flag_ira_region == IRA_REGION_MIXED)\n@@ -1620,42 +1308,15 @@ find_costs_and_classes (FILE *dump_file)\n \t\t      /* Propagate costs to upper levels in the region\n \t\t\t tree.  */\n \t\t      parent_a_num = ALLOCNO_NUM (parent_a);\n-\t\t      a_costs = COSTS (total_allocno_costs, a_num)->cost;\n-\t\t      p_costs = COSTS (total_allocno_costs, parent_a_num)->cost;\n-\t\t      for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t\t\t{\n-\t\t\t  add_cost = a_costs[k];\n-\t\t\t  if (add_cost > 0 && INT_MAX - add_cost < p_costs[k])\n-\t\t\t    p_costs[k] = INT_MAX;\n-\t\t\t  else\n-\t\t\t    p_costs[k] += add_cost;\n-\t\t\t}\n-\t\t      add_cost = COSTS (total_allocno_costs, a_num)->mem_cost;\n-\t\t      if (add_cost > 0\n-\t\t\t  && (INT_MAX - add_cost\n-\t\t\t      < COSTS (total_allocno_costs,\n-\t\t\t\t       parent_a_num)->mem_cost))\n-\t\t\tCOSTS (total_allocno_costs, parent_a_num)->mem_cost\n-\t\t\t  = INT_MAX;\n-\t\t      else\n-\t\t\tCOSTS (total_allocno_costs, parent_a_num)->mem_cost\n-\t\t\t  += add_cost;\n-\n+\t\t      for (k = 0; k < cost_classes_num; k++)\n+\t\t\tCOSTS (total_allocno_costs, parent_a_num)->cost[k]\n+\t\t\t  += COSTS (total_allocno_costs, a_num)->cost[k];\n+\t\t      COSTS (total_allocno_costs, parent_a_num)->mem_cost\n+\t\t\t+= COSTS (total_allocno_costs, a_num)->mem_cost;\n \t\t    }\n-\t\t  a_costs = COSTS (costs, a_num)->cost;\n-\t\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t\t    {\n-\t\t      add_cost = a_costs[k];\n-\t\t      if (add_cost > 0 && INT_MAX - add_cost < i_costs[k])\n-\t\t\ti_costs[k] = INT_MAX;\n-\t\t      else\n-\t\t\ti_costs[k] += add_cost;\n-\t\t    }\n-\t\t  add_cost = COSTS (costs, a_num)->mem_cost;\n-\t\t  if (add_cost && INT_MAX - add_cost < i_mem_cost)\n-\t\t    i_mem_cost = INT_MAX;\n-\t\t  else\n-\t\t    i_mem_cost += add_cost;\n+\t\t  for (k = 0; k < cost_classes_num; k++)\n+\t\t    temp_costs->cost[k] += COSTS (costs, a_num)->cost[k];\n+\t\t  temp_costs->mem_cost += COSTS (costs, a_num)->mem_cost;\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \t\t  if (in_inc_dec[a_num])\n \t\t    inc_dec_p = true;\n@@ -1667,16 +1328,16 @@ find_costs_and_classes (FILE *dump_file)\n \t  else if (equiv_savings > 0)\n \t    {\n \t      temp_costs->mem_cost = 0;\n-\t      for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t\ti_costs[k] += equiv_savings;\n+\t      for (k = 0; k < cost_classes_num; k++)\n+\t\ttemp_costs->cost[k] += equiv_savings;\n \t    }\n \n \t  best_cost = (1 << (HOST_BITS_PER_INT - 2)) - 1;\n \t  best = ALL_REGS;\n \t  alt_class = NO_REGS;\n \t  /* Find best common class for all allocnos with the same\n \t     regno.  */\n-\t  for (k = 0; k < cost_classes_ptr->num; k++)\n+\t  for (k = 0; k < cost_classes_num; k++)\n \t    {\n \t      rclass = cost_classes[k];\n \t      /* Ignore classes that are too small for this operand or\n@@ -1690,72 +1351,68 @@ find_costs_and_classes (FILE *dump_file)\n #endif\n \t\t  )\n \t\tcontinue;\n-\t      if (i_costs[k] < best_cost)\n+\t      if (temp_costs->cost[k] < best_cost)\n \t\t{\n-\t\t  best_cost = i_costs[k];\n+\t\t  best_cost = temp_costs->cost[k];\n \t\t  best = (enum reg_class) rclass;\n \t\t}\n-\t      else if (i_costs[k] == best_cost)\n-\t\tbest = ira_reg_class_subunion[best][rclass];\n+\t      else if (temp_costs->cost[k] == best_cost)\n+\t\tbest = ira_reg_class_union[best][rclass];\n \t      if (pass == flag_expensive_optimizations\n-\t\t  && i_costs[k] < i_mem_cost\n+\t\t  && temp_costs->cost[k] < temp_costs->mem_cost\n \t\t  && (reg_class_size[reg_class_subunion[alt_class][rclass]]\n \t\t      > reg_class_size[alt_class]))\n \t\talt_class = reg_class_subunion[alt_class][rclass];\n \t    }\n-\t  alt_class = ira_allocno_class_translate[alt_class];\n-\t  if (best_cost > i_mem_cost)\n-\t    regno_aclass[i] = NO_REGS;\n+\t  alt_class = ira_class_translate[alt_class];\n+\t  if (best_cost > temp_costs->mem_cost)\n+\t    regno_cover_class[i] = NO_REGS;\n+\t  else if (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY)\n+\t    /* Make the common class the biggest class of best and\n+\t       alt_class.  */\n+\t    regno_cover_class[i] = alt_class == NO_REGS ? best : alt_class;\n \t  else\n-\t    {\n-\t      /* Make the common class the biggest class of best and\n-\t\t alt_class.  */\n-\t      regno_aclass[i]\n-\t\t= ira_reg_class_superunion[best][alt_class];\n-\t      ira_assert (regno_aclass[i] != NO_REGS\n-\t\t\t  && ira_reg_allocno_class_p[regno_aclass[i]]);\n-\t    }\n+\t    /* Make the common class a cover class.  Remember all\n+\t       allocnos with the same regno should have the same cover\n+\t       class.  */\n+\t    regno_cover_class[i] = ira_class_translate[best];\n \t  if (pass == flag_expensive_optimizations)\n \t    {\n-\t      if (best_cost > i_mem_cost)\n+\t      if (best_cost > temp_costs->mem_cost)\n \t\tbest = alt_class = NO_REGS;\n \t      else if (best == alt_class)\n \t\talt_class = NO_REGS;\n-\t      setup_reg_classes (i, best, alt_class, regno_aclass[i]);\n+\t      setup_reg_classes (i, best, alt_class, regno_cover_class[i]);\n \t      if ((!allocno_p || internal_flag_ira_verbose > 2)\n \t\t  && dump_file != NULL)\n \t\tfprintf (dump_file,\n-\t\t\t \"    r%d: preferred %s, alternative %s, allocno %s\\n\",\n+\t\t\t \"    r%d: preferred %s, alternative %s, cover %s\\n\",\n \t\t\t i, reg_class_names[best], reg_class_names[alt_class],\n-\t\t\t reg_class_names[regno_aclass[i]]);\n+\t\t\t reg_class_names[regno_cover_class[i]]);\n \t    }\n-\t  regno_best_class[i] = best;\n \t  if (! allocno_p)\n \t    {\n-\t      pref[i] = best_cost > i_mem_cost ? NO_REGS : best;\n+\t      pref[i] = best_cost > temp_costs->mem_cost ? NO_REGS : best;\n \t      continue;\n \t    }\n \t  for (a = ira_regno_allocno_map[i];\n \t       a != NULL;\n \t       a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n \t    {\n \t      a_num = ALLOCNO_NUM (a);\n-\t      if (regno_aclass[i] == NO_REGS)\n+\t      if (regno_cover_class[i] == NO_REGS)\n \t\tbest = NO_REGS;\n \t      else\n \t\t{\n-\t\t  int *total_a_costs = COSTS (total_allocno_costs, a_num)->cost;\n-\t\t  int *a_costs = COSTS (costs, a_num)->cost;\n-\t\t  \n \t\t  /* Finding best class which is subset of the common\n \t\t     class.  */\n \t\t  best_cost = (1 << (HOST_BITS_PER_INT - 2)) - 1;\n \t\t  allocno_cost = best_cost;\n \t\t  best = ALL_REGS;\n-\t\t  for (k = 0; k < cost_classes_ptr->num; k++)\n+\t\t  for (k = 0; k < cost_classes_num; k++)\n \t\t    {\n \t\t      rclass = cost_classes[k];\n-\t\t      if (! ira_class_subset_p[rclass][regno_aclass[i]])\n+\t\t      if (! ira_class_subset_p[rclass][regno_cover_class[i]])\n \t\t\tcontinue;\n \t\t      /* Ignore classes that are too small for this\n \t\t\t operand or invalid for an operand that was\n@@ -1769,20 +1426,26 @@ find_costs_and_classes (FILE *dump_file)\n #endif\n \t\t\t  )\n \t\t\t;\n-\t\t      else if (total_a_costs[k] < best_cost)\n+\t\t      else if (COSTS (total_allocno_costs, a_num)->cost[k]\n+\t\t\t       < best_cost)\n \t\t\t{\n-\t\t\t  best_cost = total_a_costs[k];\n-\t\t\t  allocno_cost = a_costs[k];\n+\t\t\t  best_cost\n+\t\t\t    = COSTS (total_allocno_costs, a_num)->cost[k];\n+\t\t\t  allocno_cost = COSTS (costs, a_num)->cost[k];\n \t\t\t  best = (enum reg_class) rclass;\n \t\t\t}\n-\t\t      else if (total_a_costs[k] == best_cost)\n+\t\t      else if (COSTS (total_allocno_costs, a_num)->cost[k]\n+\t\t\t       == best_cost)\n \t\t\t{\n-\t\t\t  best = ira_reg_class_subunion[best][rclass];\n-\t\t\t  allocno_cost = MAX (allocno_cost, a_costs[k]);\n+\t\t\t  best = ira_reg_class_union[best][rclass];\n+\t\t\t  allocno_cost\n+\t\t\t    = MAX (allocno_cost, COSTS (costs, a_num)->cost[k]);\n \t\t\t}\n \t\t    }\n-\t\t  ALLOCNO_CLASS_COST (a) = allocno_cost;\n+\t\t  ALLOCNO_COVER_CLASS_COST (a) = allocno_cost;\n \t\t}\n+\t      ira_assert (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY\n+\t\t\t  || ira_class_translate[best] == regno_cover_class[i]);\n \t      if (internal_flag_ira_verbose > 2 && dump_file != NULL\n \t\t  && (pass == 0 || pref[a_num] != best))\n \t\t{\n@@ -1792,14 +1455,14 @@ find_costs_and_classes (FILE *dump_file)\n \t\t  else\n \t\t    fprintf (dump_file, \"l%d\",\n \t\t\t     ALLOCNO_LOOP_TREE_NODE (a)->loop->num);\n-\t\t  fprintf (dump_file, \") best %s, allocno %s\\n\",\n+\t\t  fprintf (dump_file, \") best %s, cover %s\\n\",\n \t\t\t   reg_class_names[best],\n-\t\t\t   reg_class_names[regno_aclass[i]]);\n+\t\t\t   reg_class_names[regno_cover_class[i]]);\n \t\t}\n \t      pref[a_num] = best;\n \t    }\n \t}\n-      \n+\n       if (internal_flag_ira_verbose > 4 && dump_file)\n \t{\n \t  if (allocno_p)\n@@ -1809,7 +1472,6 @@ find_costs_and_classes (FILE *dump_file)\n \t  fprintf (dump_file,\"\\n\");\n \t}\n     }\n-  ira_free (regno_best_class);\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n   ira_free (in_inc_dec);\n #endif\n@@ -1818,8 +1480,8 @@ find_costs_and_classes (FILE *dump_file)\n \f\n \n /* Process moves involving hard regs to modify allocno hard register\n-   costs.  We can do this only after determining allocno class.  If a\n-   hard register forms a register class, than moves with the hard\n+   costs.  We can do this only after determining allocno cover class.\n+   If a hard register forms a register class, than moves with the hard\n    register are already taken into account in class costs for the\n    allocno.  */\n static void\n@@ -1868,72 +1530,73 @@ process_bb_node_for_hard_reg_moves (ira_loop_tree_node_t loop_tree_node)\n \t}\n       else\n \tcontinue;\n-      rclass = ALLOCNO_CLASS (a);\n+      rclass = ALLOCNO_COVER_CLASS (a);\n       if (! TEST_HARD_REG_BIT (reg_class_contents[rclass], hard_regno))\n \tcontinue;\n       i = ira_class_hard_reg_index[rclass][hard_regno];\n       if (i < 0)\n \tcontinue;\n       mode = ALLOCNO_MODE (a);\n       hard_reg_class = REGNO_REG_CLASS (hard_regno);\n-      ira_init_register_move_cost_if_necessary (mode);\n       cost\n-\t= (to_p ? ira_register_move_cost[mode][hard_reg_class][rclass]\n-\t   : ira_register_move_cost[mode][rclass][hard_reg_class]) * freq;\n+\t= (to_p ? ira_get_register_move_cost (mode, hard_reg_class, rclass)\n+\t   : ira_get_register_move_cost (mode, rclass, hard_reg_class)) * freq;\n       ira_allocate_and_set_costs (&ALLOCNO_HARD_REG_COSTS (a), rclass,\n-\t\t\t\t  ALLOCNO_CLASS_COST (a));\n+\t\t\t\t  ALLOCNO_COVER_CLASS_COST (a));\n       ira_allocate_and_set_costs (&ALLOCNO_CONFLICT_HARD_REG_COSTS (a),\n \t\t\t\t  rclass, 0);\n       ALLOCNO_HARD_REG_COSTS (a)[i] -= cost;\n       ALLOCNO_CONFLICT_HARD_REG_COSTS (a)[i] -= cost;\n-      ALLOCNO_CLASS_COST (a) = MIN (ALLOCNO_CLASS_COST (a),\n+      ALLOCNO_COVER_CLASS_COST (a) = MIN (ALLOCNO_COVER_CLASS_COST (a),\n \t\t\t\t\t  ALLOCNO_HARD_REG_COSTS (a)[i]);\n     }\n }\n \n /* After we find hard register and memory costs for allocnos, define\n-   its class and modify hard register cost because insns moving\n+   its cover class and modify hard register cost because insns moving\n    allocno to/from hard registers.  */\n static void\n-setup_allocno_class_and_costs (void)\n+setup_allocno_cover_class_and_costs (void)\n {\n-  int i, j, n, regno, hard_regno, num;\n+  int i, j, n, regno, num;\n   int *reg_costs;\n-  enum reg_class aclass, rclass;\n+  enum reg_class cover_class, rclass;\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n-  cost_classes_t cost_classes_ptr;\n \n   ira_assert (allocno_p);\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n       i = ALLOCNO_NUM (a);\n-      regno = ALLOCNO_REGNO (a);\n-      aclass = regno_aclass[regno];\n-      cost_classes_ptr = regno_cost_classes[regno];\n-      ira_assert (pref[i] == NO_REGS || aclass != NO_REGS);\n+      cover_class = regno_cover_class[ALLOCNO_REGNO (a)];\n+      ira_assert (pref[i] == NO_REGS || cover_class != NO_REGS);\n       ALLOCNO_MEMORY_COST (a) = COSTS (costs, i)->mem_cost;\n-      ira_set_allocno_class (a, aclass);\n-      if (aclass == NO_REGS)\n+      ira_set_allocno_cover_class (a, cover_class);\n+      if (cover_class == NO_REGS)\n \tcontinue;\n-      if (optimize && ALLOCNO_CLASS (a) != pref[i])\n+      ALLOCNO_AVAILABLE_REGS_NUM (a) = ira_available_class_regs[cover_class];\n+      if (optimize && ALLOCNO_COVER_CLASS (a) != pref[i])\n \t{\n-\t  n = ira_class_hard_regs_num[aclass];\n+\t  n = ira_class_hard_regs_num[cover_class];\n \t  ALLOCNO_HARD_REG_COSTS (a)\n-\t    = reg_costs = ira_allocate_cost_vector (aclass);\n+\t    = reg_costs = ira_allocate_cost_vector (cover_class);\n \t  for (j = n - 1; j >= 0; j--)\n \t    {\n-\t      hard_regno = ira_class_hard_regs[aclass][j];\n-\t      if (TEST_HARD_REG_BIT (reg_class_contents[pref[i]], hard_regno))\n-\t\treg_costs[j] = ALLOCNO_CLASS_COST (a);\n+\t      regno = ira_class_hard_regs[cover_class][j];\n+\t      if (TEST_HARD_REG_BIT (reg_class_contents[pref[i]], regno))\n+\t\treg_costs[j] = ALLOCNO_COVER_CLASS_COST (a);\n \t      else\n \t\t{\n-\t\t  rclass = REGNO_REG_CLASS (hard_regno);\n-\t\t  num = cost_classes_ptr->index[rclass];\n+\t\t  rclass = REGNO_REG_CLASS (regno);\n+\t\t  num = cost_class_nums[rclass];\n \t\t  if (num < 0)\n \t\t    {\n-\t\t      num = cost_classes_ptr->hard_regno_index[hard_regno];\n-\t\t      ira_assert (num >= 0);\n+\t\t      /* The hard register class is not a cover class or a\n+\t\t\t class not fully inside in a cover class -- use\n+\t\t\t the allocno cover class.  */\n+\t\t      ira_assert (ira_hard_regno_cover_class[regno]\n+\t\t\t\t  == cover_class);\n+\t\t      num = cost_class_nums[cover_class];\n \t\t    }\n \t\t  reg_costs[j] = COSTS (costs, i)->cost[num];\n \t\t}\n@@ -1960,6 +1623,7 @@ ira_init_costs_once (void)\n       this_op_costs[i] = NULL;\n     }\n   temp_costs = NULL;\n+  cost_classes = NULL;\n }\n \n /* Free allocated temporary cost vectors.  */\n@@ -1982,6 +1646,9 @@ free_ira_costs (void)\n   if (temp_costs != NULL)\n     free (temp_costs);\n   temp_costs = NULL;\n+  if (cost_classes != NULL)\n+    free (cost_classes);\n+  cost_classes = NULL;\n }\n \n /* This is called each time register related information is\n@@ -1994,8 +1661,7 @@ ira_init_costs (void)\n   free_ira_costs ();\n   max_struct_costs_size\n     = sizeof (struct costs) + sizeof (int) * (ira_important_classes_num - 1);\n-  /* Don't use ira_allocate because vectors live through several IRA\n-     calls.  */\n+  /* Don't use ira_allocate because vectors live through several IRA calls.  */\n   init_cost = (struct costs *) xmalloc (max_struct_costs_size);\n   init_cost->mem_cost = 1000000;\n   for (i = 0; i < ira_important_classes_num; i++)\n@@ -2006,6 +1672,8 @@ ira_init_costs (void)\n       this_op_costs[i] = (struct costs *) xmalloc (max_struct_costs_size);\n     }\n   temp_costs = (struct costs *) xmalloc (max_struct_costs_size);\n+  cost_classes = (enum reg_class *) xmalloc (sizeof (enum reg_class)\n+\t\t\t\t\t     * ira_important_classes_num);\n }\n \n /* Function called once at the end of compiler work.  */\n@@ -2025,10 +1693,12 @@ init_costs (void)\n   init_subregs_of_mode ();\n   costs = (struct costs *) ira_allocate (max_struct_costs_size\n \t\t\t\t\t * cost_elements_num);\n-  pref_buffer = (enum reg_class *) ira_allocate (sizeof (enum reg_class)\n-\t\t\t\t\t\t * cost_elements_num);\n-  regno_aclass = (enum reg_class *) ira_allocate (sizeof (enum reg_class)\n-\t\t\t\t\t\t * max_reg_num ());\n+  pref_buffer\n+    = (enum reg_class *) ira_allocate (sizeof (enum reg_class)\n+\t\t\t\t       * cost_elements_num);\n+  regno_cover_class\n+    = (enum reg_class *) ira_allocate (sizeof (enum reg_class)\n+\t\t\t\t       * max_reg_num ());\n   regno_equiv_gains = (int *) ira_allocate (sizeof (int) * max_reg_num ());\n   memset (regno_equiv_gains, 0, sizeof (int) * max_reg_num ());\n }\n@@ -2040,13 +1710,13 @@ finish_costs (void)\n {\n   finish_subregs_of_mode ();\n   ira_free (regno_equiv_gains);\n-  ira_free (regno_aclass);\n+  ira_free (regno_cover_class);\n   ira_free (pref_buffer);\n   ira_free (costs);\n }\n \n-/* Entry function which defines register class, memory and hard\n-   register costs for each allocno.  */\n+/* Entry function which defines cover class, memory and hard register\n+   costs for each allocno.  */\n void\n ira_costs (void)\n {\n@@ -2055,11 +1725,9 @@ ira_costs (void)\n   init_costs ();\n   total_allocno_costs = (struct costs *) ira_allocate (max_struct_costs_size\n \t\t\t\t\t\t       * ira_allocnos_num);\n-  initiate_regno_cost_classes ();\n   calculate_elim_costs_all_insns ();\n   find_costs_and_classes (ira_dump_file);\n-  setup_allocno_class_and_costs ();\n-  finish_regno_cost_classes ();\n+  setup_allocno_cover_class_and_costs ();\n   finish_costs ();\n   ira_free (total_allocno_costs);\n }\n@@ -2072,9 +1740,7 @@ ira_set_pseudo_classes (FILE *dump_file)\n   internal_flag_ira_verbose = flag_ira_verbose;\n   cost_elements_num = max_reg_num ();\n   init_costs ();\n-  initiate_regno_cost_classes ();\n   find_costs_and_classes (dump_file);\n-  finish_regno_cost_classes ();\n   pseudo_classes_defined_p = true;\n   finish_costs ();\n }\n@@ -2085,48 +1751,32 @@ ira_set_pseudo_classes (FILE *dump_file)\n    function calls.  This is called only when we found all intersected\n    calls during building allocno live ranges.  */\n void\n-ira_tune_allocno_costs (void)\n+ira_tune_allocno_costs_and_cover_classes (void)\n {\n   int j, n, regno;\n   int cost, min_cost, *reg_costs;\n-  enum reg_class aclass, rclass;\n+  enum reg_class cover_class, rclass;\n   enum machine_mode mode;\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n-  ira_allocno_object_iterator oi;\n-  ira_object_t obj;\n-  bool skip_p;\n \n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      aclass = ALLOCNO_CLASS (a);\n-      if (aclass == NO_REGS)\n+      cover_class = ALLOCNO_COVER_CLASS (a);\n+      if (cover_class == NO_REGS)\n \tcontinue;\n       mode = ALLOCNO_MODE (a);\n-      n = ira_class_hard_regs_num[aclass];\n+      n = ira_class_hard_regs_num[cover_class];\n       min_cost = INT_MAX;\n       if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n \t{\n \t  ira_allocate_and_set_costs\n-\t    (&ALLOCNO_HARD_REG_COSTS (a), aclass,\n-\t     ALLOCNO_CLASS_COST (a));\n+\t    (&ALLOCNO_HARD_REG_COSTS (a), cover_class,\n+\t     ALLOCNO_COVER_CLASS_COST (a));\n \t  reg_costs = ALLOCNO_HARD_REG_COSTS (a);\n \t  for (j = n - 1; j >= 0; j--)\n \t    {\n-\t      regno = ira_class_hard_regs[aclass][j];\n-\t      skip_p = false;\n-\t      FOR_EACH_ALLOCNO_OBJECT (a, obj, oi)\n-\t\t{\n-\t\t  if (! ira_hard_reg_not_in_set_p (regno, mode,\n-\t\t\t\t\t\t   OBJECT_CONFLICT_HARD_REGS\n-\t\t\t\t\t\t   (obj)))\n-\t\t    {\n-\t\t      skip_p = true;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      if (skip_p)\n-\t\tcontinue;\n+\t      regno = ira_class_hard_regs[cover_class][j];\n \t      rclass = REGNO_REG_CLASS (regno);\n \t      cost = 0;\n \t      if (! ira_hard_reg_not_in_set_p (regno, mode, call_used_reg_set)\n@@ -2140,35 +1790,33 @@ ira_tune_allocno_costs (void)\n \t\t       * ALLOCNO_FREQ (a)\n \t\t       * IRA_HARD_REGNO_ADD_COST_MULTIPLIER (regno) / 2);\n #endif\n-\t      if (INT_MAX - cost < reg_costs[j])\n-\t\treg_costs[j] = INT_MAX;\n-\t      else\n-\t\treg_costs[j] += cost;\n+\t      reg_costs[j] += cost;\n \t      if (min_cost > reg_costs[j])\n \t\tmin_cost = reg_costs[j];\n \t    }\n \t}\n       if (min_cost != INT_MAX)\n-\tALLOCNO_CLASS_COST (a) = min_cost;\n+\tALLOCNO_COVER_CLASS_COST (a) = min_cost;\n \n       /* Some targets allow pseudos to be allocated to unaligned sequences\n \t of hard registers.  However, selecting an unaligned sequence can\n \t unnecessarily restrict later allocations.  So increase the cost of\n \t unaligned hard regs to encourage the use of aligned hard regs.  */\n       {\n-\tconst int nregs = ira_reg_class_max_nregs[aclass][ALLOCNO_MODE (a)];\n+\tconst int nregs = ira_reg_class_nregs[cover_class][ALLOCNO_MODE (a)];\n \n \tif (nregs > 1)\n \t  {\n \t    ira_allocate_and_set_costs\n-\t      (&ALLOCNO_HARD_REG_COSTS (a), aclass, ALLOCNO_CLASS_COST (a));\n+\t      (&ALLOCNO_HARD_REG_COSTS (a), cover_class,\n+\t       ALLOCNO_COVER_CLASS_COST (a));\n \t    reg_costs = ALLOCNO_HARD_REG_COSTS (a);\n \t    for (j = n - 1; j >= 0; j--)\n \t      {\n-\t\tregno = ira_non_ordered_class_hard_regs[aclass][j];\n+\t\tregno = ira_non_ordered_class_hard_regs[cover_class][j];\n \t\tif ((regno % nregs) != 0)\n \t\t  {\n-\t\t    int index = ira_class_hard_reg_index[aclass][regno];\n+\t\t    int index = ira_class_hard_reg_index[cover_class][regno];\n \t\t    ira_assert (index != -1);\n \t\t    reg_costs[index] += ALLOCNO_FREQ (a);\n \t\t  }"}, {"sha": "b90adb71da3747694765ef1b5aa4207b7da22d19", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 46, "deletions": 165, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -1,5 +1,5 @@\n /* Integrated Register Allocator.  Changing code and generating moves.\n-   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Vladimir Makarov <vmakarov@redhat.com>.\n \n@@ -19,52 +19,6 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* When we have more one region, we need to change the original RTL\n-   code after coloring.  Let us consider two allocnos representing the\n-   same pseudo-register outside and inside a region respectively.\n-   They can get different hard-registers.  The reload pass works on\n-   pseudo registers basis and there is no way to say the reload that\n-   pseudo could be in different registers and it is even more\n-   difficult to say in what places of the code the pseudo should have\n-   particular hard-registers.  So in this case IRA has to create and\n-   use a new pseudo-register inside the region and adds code to move\n-   allocno values on the region's borders.  This is done by the code\n-   in this file.\n-\n-   The code makes top-down traversal of the regions and generate new\n-   pseudos and the move code on the region borders.  In some\n-   complicated cases IRA can create a new pseudo used temporarily to\n-   move allocno values when a swap of values stored in two\n-   hard-registers is needed (e.g. two allocnos representing different\n-   pseudos outside region got respectively hard registers 1 and 2 and\n-   the corresponding allocnos inside the region got respectively hard\n-   registers 2 and 1).  At this stage, the new pseudo is marked as\n-   spilled.\n-\n-   IRA still creates the pseudo-register and the moves on the region\n-   borders even when the both corresponding allocnos were assigned to\n-   the same hard-register.  It is done because, if the reload pass for\n-   some reason spills a pseudo-register representing the original\n-   pseudo outside or inside the region, the effect will be smaller\n-   because another pseudo will still be in the hard-register.  In most\n-   cases, this is better then spilling the original pseudo in its\n-   whole live-range.  If reload does not change the allocation for the\n-   two pseudo-registers, the trivial move will be removed by\n-   post-reload optimizations.\n-\n-   IRA does not generate a new pseudo and moves for the allocno values\n-   if the both allocnos representing an original pseudo inside and\n-   outside region assigned to the same hard register when the register\n-   pressure in the region for the corresponding pressure class is less\n-   than number of available hard registers for given pressure class.\n-\n-   IRA also does some optimizations to remove redundant moves which is\n-   transformed into stores by the reload pass on CFG edges\n-   representing exits from the region.\n-\n-   IRA tries to reduce duplication of code generated on CFG edges\n-   which are enters and exits to/from regions by moving some code to\n-   the edge sources or destinations when it is possible.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -90,73 +44,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ira-int.h\"\n \n \n-/* Data used to emit live range split insns and to flattening IR.  */\n-ira_emit_data_t ira_allocno_emit_data;\n-\n-/* Definitions for vectors of pointers.  */\n-typedef void *void_p;\n-DEF_VEC_P (void_p);\n-DEF_VEC_ALLOC_P (void_p,heap);\n-\n-/* Pointers to data allocated for allocnos being created during\n-   emitting.  Usually there are quite few such allocnos because they\n-   are created only for resolving loop in register shuffling.  */\n-static VEC(void_p, heap) *new_allocno_emit_data_vec;\n-\n-/* Allocate and initiate the emit data.  */\n-void\n-ira_initiate_emit_data (void)\n-{\n-  ira_allocno_t a;\n-  ira_allocno_iterator ai;\n-\n-  ira_allocno_emit_data\n-    = (ira_emit_data_t) ira_allocate (ira_allocnos_num\n-\t\t\t\t      * sizeof (struct ira_emit_data));\n-  memset (ira_allocno_emit_data, 0,\n-\t  ira_allocnos_num * sizeof (struct ira_emit_data));\n-  FOR_EACH_ALLOCNO (a, ai)\n-    ALLOCNO_ADD_DATA (a) = ira_allocno_emit_data + ALLOCNO_NUM (a);\n-  new_allocno_emit_data_vec = VEC_alloc (void_p, heap, 50);\n-\n-}\n-\n-/* Free the emit data.  */\n-void\n-ira_finish_emit_data (void)\n-{\n-  void_p p;\n-  ira_allocno_t a;\n-  ira_allocno_iterator ai;\n-\n-  ira_free (ira_allocno_emit_data);\n-  FOR_EACH_ALLOCNO (a, ai)\n-    ALLOCNO_ADD_DATA (a) = NULL;\n-  for (;VEC_length (void_p, new_allocno_emit_data_vec) != 0;)\n-    {\n-      p = VEC_pop (void_p, new_allocno_emit_data_vec);\n-      ira_free (p);\n-    }\n-  VEC_free (void_p, heap, new_allocno_emit_data_vec);\n-}\n-\n-/* Create and return a new allocno with given REGNO and\n-   LOOP_TREE_NODE.  Allocate emit data for it.  */\n-static ira_allocno_t\n-create_new_allocno (int regno, ira_loop_tree_node_t loop_tree_node)\n-{\n-  ira_allocno_t a;\n-\n-  a = ira_create_allocno (regno, false, loop_tree_node);\n-  ALLOCNO_ADD_DATA (a) = ira_allocate (sizeof (struct ira_emit_data));\n-  memset (ALLOCNO_ADD_DATA (a), 0, sizeof (struct ira_emit_data));\n-  VEC_safe_push (void_p, heap, new_allocno_emit_data_vec, ALLOCNO_ADD_DATA (a));\n-  return a;\n-}\n-\n-\f\n-\n-/* See comments below.  */\n typedef struct move *move_t;\n \n /* The structure represents an allocno move.  Both allocnos have the\n@@ -284,7 +171,7 @@ change_regs (rtx *loc)\n \treturn false;\n       if (ira_curr_regno_allocno_map[regno] == NULL)\n \treturn false;\n-      reg = allocno_emit_reg (ira_curr_regno_allocno_map[regno]);\n+      reg = ALLOCNO_REG (ira_curr_regno_allocno_map[regno]);\n       if (reg == *loc)\n \treturn false;\n       *loc = reg;\n@@ -371,9 +258,9 @@ set_allocno_reg (ira_allocno_t allocno, rtx reg)\n        a != NULL;\n        a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n     if (subloop_tree_node_p (ALLOCNO_LOOP_TREE_NODE (a), node))\n-      ALLOCNO_EMIT_DATA (a)->reg = reg;\n+      ALLOCNO_REG (a) = reg;\n   for (a = ALLOCNO_CAP (allocno); a != NULL; a = ALLOCNO_CAP (a))\n-    ALLOCNO_EMIT_DATA (a)->reg = reg;\n+    ALLOCNO_REG (a) = reg;\n   regno = ALLOCNO_REGNO (allocno);\n   for (a = allocno;;)\n     {\n@@ -386,9 +273,9 @@ set_allocno_reg (ira_allocno_t allocno, rtx reg)\n \t}\n       if (a == NULL)\n \tcontinue;\n-      if (ALLOCNO_EMIT_DATA (a)->child_renamed_p)\n+      if (ALLOCNO_CHILD_RENAMED_P (a))\n \tbreak;\n-      ALLOCNO_EMIT_DATA (a)->child_renamed_p = true;\n+      ALLOCNO_CHILD_RENAMED_P (a) = true;\n     }\n }\n \n@@ -402,9 +289,7 @@ entered_from_non_parent_p (ira_loop_tree_node_t loop_node)\n   edge e;\n   edge_iterator ei;\n \n-  for (bb_node = loop_node->children;\n-       bb_node != NULL;\n-       bb_node = bb_node->next)\n+  for (bb_node = loop_node->children; bb_node != NULL; bb_node = bb_node->next)\n     if (bb_node->bb != NULL)\n       {\n \tFOR_EACH_EDGE (e, ei, bb_node->bb->preds)\n@@ -459,14 +344,14 @@ store_can_be_removed_p (ira_allocno_t src_allocno, ira_allocno_t dest_allocno)\n   ira_assert (ALLOCNO_CAP_MEMBER (src_allocno) == NULL\n \t      && ALLOCNO_CAP_MEMBER (dest_allocno) == NULL);\n   orig_regno = ALLOCNO_REGNO (src_allocno);\n-  regno = REGNO (allocno_emit_reg (dest_allocno));\n+  regno = REGNO (ALLOCNO_REG (dest_allocno));\n   for (node = ALLOCNO_LOOP_TREE_NODE (src_allocno);\n        node != NULL;\n        node = node->parent)\n     {\n       a = node->regno_allocno_map[orig_regno];\n       ira_assert (a != NULL);\n-      if (REGNO (allocno_emit_reg (a)) == (unsigned) regno)\n+      if (REGNO (ALLOCNO_REG (a)) == (unsigned) regno)\n \t/* We achieved the destination and everything is ok.  */\n \treturn true;\n       else if (bitmap_bit_p (node->modified_regnos, orig_regno))\n@@ -511,8 +396,8 @@ generate_edge_moves (edge e)\n       {\n \tsrc_allocno = src_map[regno];\n \tdest_allocno = dest_map[regno];\n-\tif (REGNO (allocno_emit_reg (src_allocno))\n-\t    == REGNO (allocno_emit_reg (dest_allocno)))\n+\tif (REGNO (ALLOCNO_REG (src_allocno))\n+\t    == REGNO (ALLOCNO_REG (dest_allocno)))\n \t  continue;\n \t/* Remove unnecessary stores at the region exit.  We should do\n \t   this for readonly memory for sure and this is guaranteed by\n@@ -523,8 +408,8 @@ generate_edge_moves (edge e)\n \t    && ALLOCNO_HARD_REGNO (src_allocno) >= 0\n \t    && store_can_be_removed_p (src_allocno, dest_allocno))\n \t  {\n-\t    ALLOCNO_EMIT_DATA (src_allocno)->mem_optimized_dest = dest_allocno;\n-\t    ALLOCNO_EMIT_DATA (dest_allocno)->mem_optimized_dest_p = true;\n+\t    ALLOCNO_MEM_OPTIMIZED_DEST (src_allocno) = dest_allocno;\n+\t    ALLOCNO_MEM_OPTIMIZED_DEST_P (dest_allocno) = true;\n \t    if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n \t      fprintf (ira_dump_file, \"      Remove r%d:a%d->a%d(mem)\\n\",\n \t\t       regno, ALLOCNO_NUM (src_allocno),\n@@ -560,7 +445,7 @@ change_loop (ira_loop_tree_node_t node)\n   bool used_p;\n   ira_allocno_t allocno, parent_allocno, *map;\n   rtx insn, original_reg;\n-  enum reg_class aclass, pclass;\n+  enum reg_class cover_class;\n   ira_loop_tree_node_t parent;\n \n   if (node != ira_loop_tree_root)\n@@ -589,8 +474,7 @@ change_loop (ira_loop_tree_node_t node)\n \t{\n \t  allocno = ira_allocnos[i];\n \t  regno = ALLOCNO_REGNO (allocno);\n-\t  aclass = ALLOCNO_CLASS (allocno);\n-\t  pclass = ira_pressure_class_translate[aclass];\n+\t  cover_class = ALLOCNO_COVER_CLASS (allocno);\n \t  parent_allocno = map[regno];\n \t  ira_assert (regno < ira_reg_equiv_len);\n \t  /* We generate the same hard register move because the\n@@ -603,8 +487,8 @@ change_loop (ira_loop_tree_node_t node)\n \t      && (ALLOCNO_HARD_REGNO (allocno)\n \t\t  == ALLOCNO_HARD_REGNO (parent_allocno))\n \t      && (ALLOCNO_HARD_REGNO (allocno) < 0\n-\t\t  || (parent->reg_pressure[pclass] + 1\n-\t\t      <= ira_available_class_regs[pclass])\n+\t\t  || (parent->reg_pressure[cover_class] + 1\n+\t\t      <= ira_available_class_regs[cover_class])\n \t\t  || TEST_HARD_REG_BIT (ira_prohibited_mode_move_regs\n \t\t\t\t\t[ALLOCNO_MODE (allocno)],\n \t\t\t\t\tALLOCNO_HARD_REGNO (allocno))\n@@ -614,10 +498,9 @@ change_loop (ira_loop_tree_node_t node)\n \t\t  || ira_reg_equiv_invariant_p[regno]\n \t\t  || ira_reg_equiv_const[regno] != NULL_RTX))\n \t    continue;\n-\t  original_reg = allocno_emit_reg (allocno);\n+\t  original_reg = ALLOCNO_REG (allocno);\n \t  if (parent_allocno == NULL\n-\t      || (REGNO (allocno_emit_reg (parent_allocno))\n-\t\t  == REGNO (original_reg)))\n+\t      || REGNO (ALLOCNO_REG (parent_allocno)) == REGNO (original_reg))\n \t    {\n \t      if (internal_flag_ira_verbose > 3 && ira_dump_file)\n \t\tfprintf (ira_dump_file, \"  %i vs parent %i:\",\n@@ -640,11 +523,11 @@ change_loop (ira_loop_tree_node_t node)\n       if (ALLOCNO_CAP_MEMBER (allocno) != NULL)\n \tcontinue;\n       used_p = !bitmap_set_bit (used_regno_bitmap, regno);\n-      ALLOCNO_EMIT_DATA (allocno)->somewhere_renamed_p = true;\n+      ALLOCNO_SOMEWHERE_RENAMED_P (allocno) = true;\n       if (! used_p)\n \tcontinue;\n       bitmap_set_bit (renamed_regno_bitmap, regno);\n-      set_allocno_reg (allocno, create_new_reg (allocno_emit_reg (allocno)));\n+      set_allocno_reg (allocno, create_new_reg (ALLOCNO_REG (allocno)));\n     }\n }\n \n@@ -660,8 +543,8 @@ set_allocno_somewhere_renamed_p (void)\n     {\n       regno = ALLOCNO_REGNO (allocno);\n       if (bitmap_bit_p (renamed_regno_bitmap, regno)\n-\t  && REGNO (allocno_emit_reg (allocno)) == regno)\n-\tALLOCNO_EMIT_DATA (allocno)->somewhere_renamed_p = true;\n+\t  && REGNO (ALLOCNO_REG (allocno)) == regno)\n+\tALLOCNO_SOMEWHERE_RENAMED_P (allocno) = true;\n     }\n }\n \n@@ -841,16 +724,16 @@ modify_move_list (move_t list)\n \t\t   subsequent IRA internal representation\n \t\t   flattening.  */\n \t\tnew_allocno\n-\t\t  = create_new_allocno (ALLOCNO_REGNO (set_move->to),\n+\t\t  = ira_create_allocno (ALLOCNO_REGNO (set_move->to), false,\n \t\t\t\t\tALLOCNO_LOOP_TREE_NODE (set_move->to));\n \t\tALLOCNO_MODE (new_allocno) = ALLOCNO_MODE (set_move->to);\n-\t\tira_set_allocno_class (new_allocno,\n-\t\t\t\t       ALLOCNO_CLASS (set_move->to));\n+\t\tira_set_allocno_cover_class\n+\t\t  (new_allocno, ALLOCNO_COVER_CLASS (set_move->to));\n \t\tira_create_allocno_objects (new_allocno);\n \t\tALLOCNO_ASSIGNED_P (new_allocno) = true;\n \t\tALLOCNO_HARD_REGNO (new_allocno) = -1;\n-\t\tALLOCNO_EMIT_DATA (new_allocno)->reg\n-\t\t  = create_new_reg (allocno_emit_reg (set_move->to));\n+\t\tALLOCNO_REG (new_allocno)\n+\t\t  = create_new_reg (ALLOCNO_REG (set_move->to));\n \n \t\t/* Make it possibly conflicting with all earlier\n \t\t   created allocnos.  Cases where temporary allocnos\n@@ -873,7 +756,7 @@ modify_move_list (move_t list)\n \t\t  fprintf (ira_dump_file,\n \t\t\t   \"    Creating temporary allocno a%dr%d\\n\",\n \t\t\t   ALLOCNO_NUM (new_allocno),\n-\t\t\t   REGNO (allocno_emit_reg (new_allocno)));\n+\t\t\t   REGNO (ALLOCNO_REG (new_allocno)));\n \t      }\n \t}\n       if ((hard_regno = ALLOCNO_HARD_REGNO (to)) < 0)\n@@ -903,14 +786,13 @@ emit_move_list (move_t list, int freq)\n   int cost;\n   rtx result, insn;\n   enum machine_mode mode;\n-  enum reg_class aclass;\n+  enum reg_class cover_class;\n \n   start_sequence ();\n   for (; list != NULL; list = list->next)\n     {\n       start_sequence ();\n-      emit_move_insn (allocno_emit_reg (list->to),\n-\t\t      allocno_emit_reg (list->from));\n+      emit_move_insn (ALLOCNO_REG (list->to), ALLOCNO_REG (list->from));\n       list->insn = get_insns ();\n       end_sequence ();\n       /* The reload needs to have set up insn codes.  If the reload\n@@ -921,28 +803,28 @@ emit_move_list (move_t list, int freq)\n \trecog_memoized (insn);\n       emit_insn (list->insn);\n       mode = ALLOCNO_MODE (list->to);\n-      aclass = ALLOCNO_CLASS (list->to);\n+      cover_class = ALLOCNO_COVER_CLASS (list->to);\n       cost = 0;\n       if (ALLOCNO_HARD_REGNO (list->to) < 0)\n \t{\n \t  if (ALLOCNO_HARD_REGNO (list->from) >= 0)\n \t    {\n-\t      cost = ira_memory_move_cost[mode][aclass][0] * freq;\n+\t      cost = ira_memory_move_cost[mode][cover_class][0] * freq;\n \t      ira_store_cost += cost;\n \t    }\n \t}\n       else if (ALLOCNO_HARD_REGNO (list->from) < 0)\n \t{\n \t  if (ALLOCNO_HARD_REGNO (list->to) >= 0)\n \t    {\n-\t      cost = ira_memory_move_cost[mode][aclass][0] * freq;\n+\t      cost = ira_memory_move_cost[mode][cover_class][0] * freq;\n \t      ira_load_cost += cost;\n \t    }\n \t}\n       else\n \t{\n-\t  ira_init_register_move_cost_if_necessary (mode);\n-\t  cost = ira_register_move_cost[mode][aclass][aclass] * freq;\n+\t  cost = (ira_get_register_move_cost (mode, cover_class, cover_class)\n+\t\t  * freq);\n \t  ira_shuffle_cost += cost;\n \t}\n       ira_overall_cost += cost;\n@@ -1020,7 +902,7 @@ update_costs (ira_allocno_t a, bool read_p, int freq)\n       ALLOCNO_NREFS (a)++;\n       ALLOCNO_FREQ (a) += freq;\n       ALLOCNO_MEMORY_COST (a)\n-\t+= (ira_memory_move_cost[ALLOCNO_MODE (a)][ALLOCNO_CLASS (a)]\n+\t+= (ira_memory_move_cost[ALLOCNO_MODE (a)][ALLOCNO_COVER_CLASS (a)]\n \t    [read_p ? 1 : 0] * freq);\n       if (ALLOCNO_CAP (a) != NULL)\n \ta = ALLOCNO_CAP (a);\n@@ -1074,7 +956,7 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n \t    {\n \t      if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n \t\tfprintf (ira_dump_file, \"    Allocate conflicts for a%dr%d\\n\",\n-\t\t\t ALLOCNO_NUM (to), REGNO (allocno_emit_reg (to)));\n+\t\t\t ALLOCNO_NUM (to), REGNO (ALLOCNO_REG (to)));\n \t      ira_allocate_object_conflicts (to_obj, n);\n \t    }\n \t}\n@@ -1087,9 +969,8 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n       if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n \tfprintf (ira_dump_file, \"    Adding cp%d:a%dr%d-a%dr%d\\n\",\n \t\t cp->num, ALLOCNO_NUM (cp->first),\n-\t\t REGNO (allocno_emit_reg (cp->first)),\n-\t\t ALLOCNO_NUM (cp->second),\n-\t\t REGNO (allocno_emit_reg (cp->second)));\n+\t\t REGNO (ALLOCNO_REG (cp->first)), ALLOCNO_NUM (cp->second),\n+\t\t REGNO (ALLOCNO_REG (cp->second)));\n \n       nr = ALLOCNO_NUM_OBJECTS (from);\n       for (i = 0; i < nr; i++)\n@@ -1103,7 +984,7 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n \t\tfprintf (ira_dump_file,\n \t\t\t \"    Adding range [%d..%d] to allocno a%dr%d\\n\",\n \t\t\t start, ira_max_point, ALLOCNO_NUM (from),\n-\t\t\t REGNO (allocno_emit_reg (from)));\n+\t\t\t REGNO (ALLOCNO_REG (from)));\n \t    }\n \t  else\n \t    {\n@@ -1112,7 +993,7 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n \t\tfprintf (ira_dump_file,\n \t\t\t \"    Adding range [%d..%d] to allocno a%dr%d\\n\",\n \t\t\t r->start, ira_max_point, ALLOCNO_NUM (from),\n-\t\t\t REGNO (allocno_emit_reg (from)));\n+\t\t\t REGNO (ALLOCNO_REG (from)));\n \t    }\n \t}\n       ira_max_point++;\n@@ -1139,7 +1020,7 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n \t\tfprintf (ira_dump_file,\n \t\t\t \"    Adding range [%d..%d] to allocno a%dr%d\\n\",\n \t\t\t r->start, r->finish, ALLOCNO_NUM (move->to),\n-\t\t\t REGNO (allocno_emit_reg (move->to)));\n+\t\t\t REGNO (ALLOCNO_REG (move->to)));\n \t    }\n \t}\n     }\n@@ -1149,7 +1030,7 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n       int nr, i;\n \n       a = node->regno_allocno_map[regno];\n-      if ((to = ALLOCNO_EMIT_DATA (a)->mem_optimized_dest) != NULL)\n+      if ((to = ALLOCNO_MEM_OPTIMIZED_DEST (a)) != NULL)\n \ta = to;\n       nr = ALLOCNO_NUM_OBJECTS (a);\n       for (i = 0; i < nr; i++)\n@@ -1163,7 +1044,7 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n \t   \"    Adding range [%d..%d] to live through %s allocno a%dr%d\\n\",\n \t   start, ira_max_point - 1,\n \t   to != NULL ? \"upper level\" : \"\",\n-\t   ALLOCNO_NUM (a), REGNO (allocno_emit_reg (a)));\n+\t   ALLOCNO_NUM (a), REGNO (ALLOCNO_REG (a)));\n     }\n }\n \n@@ -1216,7 +1097,7 @@ ira_emit (bool loops_p)\n   ira_allocno_iterator ai;\n \n   FOR_EACH_ALLOCNO (a, ai)\n-    ALLOCNO_EMIT_DATA (a)->reg = regno_reg_rtx[ALLOCNO_REGNO (a)];\n+    ALLOCNO_REG (a) = regno_reg_rtx[ALLOCNO_REGNO (a)];\n   if (! loops_p)\n     return;\n   at_bb_start = (move_t *) ira_allocate (sizeof (move_t) * last_basic_block);"}, {"sha": "049a07f89d5b5d5859858b96516b007f82068991", "filename": "gcc/ira-int.h", "status": "modified", "additions": 208, "deletions": 240, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -43,9 +43,9 @@ along with GCC; see the file COPYING3.  If not see\n    profile driven feedback is available and the function is never\n    executed, frequency is always equivalent.  Otherwise rescale the\n    edge frequency.  */\n-#define REG_FREQ_FROM_EDGE_FREQ(freq)\t\t\t\t\t   \\\n-  (optimize_size || (flag_branch_probabilities && !ENTRY_BLOCK_PTR->count) \\\n-   ? REG_FREQ_MAX : (freq * REG_FREQ_MAX / BB_FREQ_MAX)\t\t\t   \\\n+#define REG_FREQ_FROM_EDGE_FREQ(freq)\t\t\t\t\t      \\\n+  (optimize_size || (flag_branch_probabilities && !ENTRY_BLOCK_PTR->count)    \\\n+   ? REG_FREQ_MAX : (freq * REG_FREQ_MAX / BB_FREQ_MAX)\t\t\t      \\\n    ? (freq * REG_FREQ_MAX / BB_FREQ_MAX) : 1)\n \n /* All natural loops.  */\n@@ -122,7 +122,7 @@ struct ira_loop_tree_node\n   bool entered_from_non_parent_p;\n \n   /* Maximal register pressure inside loop for given register class\n-     (defined only for the pressure classes).  */\n+     (defined only for the cover classes).  */\n   int reg_pressure[N_REG_CLASSES];\n \n   /* Numbers of allocnos referred or living in the loop node (except\n@@ -193,8 +193,11 @@ extern ira_loop_tree_node_t ira_loop_nodes;\n \n \f\n /* The structure describes program points where a given allocno lives.\n-   If the live ranges of two allocnos are intersected, the allocnos\n-   are in conflict.  */\n+   To save memory we store allocno conflicts only for the same cover\n+   class allocnos which is enough to assign hard registers.  To find\n+   conflicts for other allocnos (e.g. to assign stack memory slot) we\n+   use the live ranges.  If the live ranges of two allocnos are\n+   intersected, the allocnos are in conflict.  */\n struct live_range\n {\n   /* Object whose live range is described by given structure.  */\n@@ -229,7 +232,8 @@ struct ira_object\n   ira_allocno_t allocno;\n   /* Vector of accumulated conflicting conflict_redords with NULL end\n      marker (if OBJECT_CONFLICT_VEC_P is true) or conflict bit vector\n-     otherwise.  */\n+     otherwise.  Only ira_objects belonging to allocnos with the\n+     same cover class are in the vector or in the bit vector.  */\n   void *conflicts_array;\n   /* Pointer to structures describing at what program point the\n      object lives.  We always maintain the list in such way that *the\n@@ -252,7 +256,7 @@ struct ira_object\n   int min, max;\n   /* Initial and accumulated hard registers conflicting with this\n      object and as a consequences can not be assigned to the allocno.\n-     All non-allocatable hard regs and hard regs of register classes\n+     All non-allocatable hard regs and hard regs of cover classes\n      different from given allocno one are included in the sets.  */\n   HARD_REG_SET conflict_hard_regs, total_conflict_hard_regs;\n   /* Number of accumulated conflicts in the vector of conflicting\n@@ -262,9 +266,6 @@ struct ira_object\n      ira_object structures.  Otherwise, we use a bit vector indexed\n      by conflict ID numbers.  */\n   unsigned int conflict_vec_p : 1;\n-  /* Different additional data.  It is used to decrease size of\n-     allocno data footprint.  */\n-  void *add_data;\n };\n \n /* A structure representing an allocno (allocation entity).  Allocno\n@@ -284,40 +285,16 @@ struct ira_allocno\n   int regno;\n   /* Mode of the allocno which is the mode of the corresponding\n      pseudo-register.  */\n-  ENUM_BITFIELD (machine_mode) mode : 8;\n-  /* Register class which should be used for allocation for given\n-     allocno.  NO_REGS means that we should use memory.  */\n-  ENUM_BITFIELD (reg_class) aclass : 16;\n-  /* During the reload, value TRUE means that we should not reassign a\n-     hard register to the allocno got memory earlier.  It is set up\n-     when we removed memory-memory move insn before each iteration of\n-     the reload.  */\n-  unsigned int dont_reassign_p : 1;\n-#ifdef STACK_REGS\n-  /* Set to TRUE if allocno can't be assigned to the stack hard\n-     register correspondingly in this region and area including the\n-     region and all its subregions recursively.  */\n-  unsigned int no_stack_reg_p : 1, total_no_stack_reg_p : 1;\n-#endif\n-  /* TRUE value means that there is no sense to spill the allocno\n-     during coloring because the spill will result in additional\n-     reloads in reload pass.  */\n-  unsigned int bad_spill_p : 1;\n-  /* TRUE if a hard register or memory has been assigned to the\n-     allocno.  */\n-  unsigned int assigned_p : 1;\n-  /* TRUE if conflicts for given allocno are represented by vector of\n-     pointers to the conflicting allocnos.  Otherwise, we use a bit\n-     vector where a bit with given index represents allocno with the\n-     same number.  */\n-  unsigned int conflict_vec_p : 1;\n+  enum machine_mode mode;\n   /* Hard register assigned to given allocno.  Negative value means\n      that memory was allocated to the allocno.  During the reload,\n      spilled allocno has value equal to the corresponding stack slot\n      number (0, ...) - 2.  Value -1 is used for allocnos spilled by the\n      reload (at this point pseudo-register has only one allocno) which\n      did not get stack slot yet.  */\n-  short int hard_regno;\n+  int hard_regno;\n+  /* Final rtx representation of the allocno.  */\n+  rtx reg;\n   /* Allocnos with the same regno are linked by the following member.\n      Allocnos corresponding to inner loops are first in the list (it\n      corresponds to depth-first traverse of the loops).  */\n@@ -335,9 +312,12 @@ struct ira_allocno\n   int nrefs;\n   /* Accumulated frequency of usage of the allocno.  */\n   int freq;\n+  /* Register class which should be used for allocation for given\n+     allocno.  NO_REGS means that we should use memory.  */\n+  enum reg_class cover_class;\n   /* Minimal accumulated and updated costs of usage register of the\n-     allocno class.  */\n-  int class_cost, updated_class_cost;\n+     cover class for the allocno.  */\n+  int cover_class_cost, updated_cover_class_cost;\n   /* Minimal accumulated, and updated costs of memory for the allocno.\n      At the allocation start, the original and updated costs are\n      equal.  The updated cost may be changed after finishing\n@@ -362,6 +342,11 @@ struct ira_allocno\n   /* It is a link to allocno (cap) on lower loop level represented by\n      given cap.  Null if given allocno is not a cap.  */\n   ira_allocno_t cap_member;\n+  /* Coalesced allocnos form a cyclic list.  One allocno given by\n+     FIRST_COALESCED_ALLOCNO represents all coalesced allocnos.  The\n+     list is chained by NEXT_COALESCED_ALLOCNO.  */\n+  ira_allocno_t first_coalesced_allocno;\n+  ira_allocno_t next_coalesced_allocno;\n   /* The number of objects tracked in the following array.  */\n   int num_objects;\n   /* An array of structures describing conflict information and live\n@@ -374,34 +359,86 @@ struct ira_allocno\n   int call_freq;\n   /* Accumulated number of the intersected calls.  */\n   int calls_crossed_num;\n+  /* TRUE if the allocno assigned to memory was a destination of\n+     removed move (see ira-emit.c) at loop exit because the value of\n+     the corresponding pseudo-register is not changed inside the\n+     loop.  */\n+  unsigned int mem_optimized_dest_p : 1;\n+  /* TRUE if the corresponding pseudo-register has disjoint live\n+     ranges and the other allocnos of the pseudo-register except this\n+     one changed REG.  */\n+  unsigned int somewhere_renamed_p : 1;\n+  /* TRUE if allocno with the same REGNO in a subregion has been\n+     renamed, in other words, got a new pseudo-register.  */\n+  unsigned int child_renamed_p : 1;\n+  /* During the reload, value TRUE means that we should not reassign a\n+     hard register to the allocno got memory earlier.  It is set up\n+     when we removed memory-memory move insn before each iteration of\n+     the reload.  */\n+  unsigned int dont_reassign_p : 1;\n+#ifdef STACK_REGS\n+  /* Set to TRUE if allocno can't be assigned to the stack hard\n+     register correspondingly in this region and area including the\n+     region and all its subregions recursively.  */\n+  unsigned int no_stack_reg_p : 1, total_no_stack_reg_p : 1;\n+#endif\n+  /* TRUE value means that there is no sense to spill the allocno\n+     during coloring because the spill will result in additional\n+     reloads in reload pass.  */\n+  unsigned int bad_spill_p : 1;\n+  /* TRUE value means that the allocno was not removed yet from the\n+     conflicting graph during colouring.  */\n+  unsigned int in_graph_p : 1;\n+  /* TRUE if a hard register or memory has been assigned to the\n+     allocno.  */\n+  unsigned int assigned_p : 1;\n+  /* TRUE if it is put on the stack to make other allocnos\n+     colorable.  */\n+  unsigned int may_be_spilled_p : 1;\n+  /* TRUE if the allocno was removed from the splay tree used to\n+     choose allocn for spilling (see ira-color.c::.  */\n+  unsigned int splay_removed_p : 1;\n+  /* Non NULL if we remove restoring value from given allocno to\n+     MEM_OPTIMIZED_DEST at loop exit (see ira-emit.c) because the\n+     allocno value is not changed inside the loop.  */\n+  ira_allocno_t mem_optimized_dest;\n   /* Array of usage costs (accumulated and the one updated during\n-     coloring) for each hard register of the allocno class.  The\n+     coloring) for each hard register of the allocno cover class.  The\n      member value can be NULL if all costs are the same and equal to\n-     CLASS_COST.  For example, the costs of two different hard\n+     COVER_CLASS_COST.  For example, the costs of two different hard\n      registers can be different if one hard register is callee-saved\n      and another one is callee-used and the allocno lives through\n      calls.  Another example can be case when for some insn the\n      corresponding pseudo-register value should be put in specific\n      register class (e.g. AREG for x86) which is a strict subset of\n-     the allocno class (GENERAL_REGS for x86).  We have updated costs\n-     to reflect the situation when the usage cost of a hard register\n-     is decreased because the allocno is connected to another allocno\n-     by a copy and the another allocno has been assigned to the hard\n-     register.  */\n+     the allocno cover class (GENERAL_REGS for x86).  We have updated\n+     costs to reflect the situation when the usage cost of a hard\n+     register is decreased because the allocno is connected to another\n+     allocno by a copy and the another allocno has been assigned to\n+     the hard register.  */\n   int *hard_reg_costs, *updated_hard_reg_costs;\n   /* Array of decreasing costs (accumulated and the one updated during\n      coloring) for allocnos conflicting with given allocno for hard\n-     regno of the allocno class.  The member value can be NULL if all\n-     costs are the same.  These costs are used to reflect preferences\n-     of other allocnos not assigned yet during assigning to given\n-     allocno.  */\n+     regno of the allocno cover class.  The member value can be NULL\n+     if all costs are the same.  These costs are used to reflect\n+     preferences of other allocnos not assigned yet during assigning\n+     to given allocno.  */\n   int *conflict_hard_reg_costs, *updated_conflict_hard_reg_costs;\n-  /* Different additional data.  It is used to decrease size of\n-     allocno data footprint.  */\n-  void *add_data;\n+  /* Size (in hard registers) of the same cover class allocnos with\n+     TRUE in_graph_p value and conflicting with given allocno during\n+     each point of graph coloring.  */\n+  int left_conflicts_size;\n+  /* Number of hard registers of the allocno cover class really\n+     available for the allocno allocation.  */\n+  int available_regs_num;\n+  /* Allocnos in a bucket (used in coloring) chained by the following\n+     two members.  */\n+  ira_allocno_t next_bucket_allocno;\n+  ira_allocno_t prev_bucket_allocno;\n+  /* Used for temporary purposes.  */\n+  int temp;\n };\n \n-\n /* All members of the allocno structures should be accessed only\n    through the following macros.  */\n #define ALLOCNO_NUM(A) ((A)->num)\n@@ -426,7 +463,10 @@ struct ira_allocno\n #define ALLOCNO_TOTAL_NO_STACK_REG_P(A) ((A)->total_no_stack_reg_p)\n #endif\n #define ALLOCNO_BAD_SPILL_P(A) ((A)->bad_spill_p)\n+#define ALLOCNO_IN_GRAPH_P(A) ((A)->in_graph_p)\n #define ALLOCNO_ASSIGNED_P(A) ((A)->assigned_p)\n+#define ALLOCNO_MAY_BE_SPILLED_P(A) ((A)->may_be_spilled_p)\n+#define ALLOCNO_SPLAY_REMOVED_P(A) ((A)->splay_removed_p)\n #define ALLOCNO_MODE(A) ((A)->mode)\n #define ALLOCNO_COPIES(A) ((A)->allocno_copies)\n #define ALLOCNO_HARD_REG_COSTS(A) ((A)->hard_reg_costs)\n@@ -435,71 +475,36 @@ struct ira_allocno\n   ((A)->conflict_hard_reg_costs)\n #define ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS(A) \\\n   ((A)->updated_conflict_hard_reg_costs)\n-#define ALLOCNO_CLASS(A) ((A)->aclass)\n-#define ALLOCNO_CLASS_COST(A) ((A)->class_cost)\n-#define ALLOCNO_UPDATED_CLASS_COST(A) ((A)->updated_class_cost)\n+#define ALLOCNO_LEFT_CONFLICTS_SIZE(A) ((A)->left_conflicts_size)\n+#define ALLOCNO_COVER_CLASS(A) ((A)->cover_class)\n+#define ALLOCNO_COVER_CLASS_COST(A) ((A)->cover_class_cost)\n+#define ALLOCNO_UPDATED_COVER_CLASS_COST(A) ((A)->updated_cover_class_cost)\n #define ALLOCNO_MEMORY_COST(A) ((A)->memory_cost)\n #define ALLOCNO_UPDATED_MEMORY_COST(A) ((A)->updated_memory_cost)\n-#define ALLOCNO_EXCESS_PRESSURE_POINTS_NUM(A) \\\n-  ((A)->excess_pressure_points_num)\n+#define ALLOCNO_EXCESS_PRESSURE_POINTS_NUM(A) ((A)->excess_pressure_points_num)\n+#define ALLOCNO_AVAILABLE_REGS_NUM(A) ((A)->available_regs_num)\n+#define ALLOCNO_NEXT_BUCKET_ALLOCNO(A) ((A)->next_bucket_allocno)\n+#define ALLOCNO_PREV_BUCKET_ALLOCNO(A) ((A)->prev_bucket_allocno)\n+#define ALLOCNO_TEMP(A) ((A)->temp)\n+#define ALLOCNO_FIRST_COALESCED_ALLOCNO(A) ((A)->first_coalesced_allocno)\n+#define ALLOCNO_NEXT_COALESCED_ALLOCNO(A) ((A)->next_coalesced_allocno)\n #define ALLOCNO_OBJECT(A,N) ((A)->objects[N])\n #define ALLOCNO_NUM_OBJECTS(A) ((A)->num_objects)\n-#define ALLOCNO_ADD_DATA(A) ((A)->add_data)\n \n-/* Typedef for pointer to the subsequent structure.  */\n-typedef struct ira_emit_data *ira_emit_data_t;\n-\n-/* Allocno bound data used for emit pseudo live range split insns and\n-   to flattening IR.  */\n-struct ira_emit_data\n-{\n-  /* TRUE if the allocno assigned to memory was a destination of\n-     removed move (see ira-emit.c) at loop exit because the value of\n-     the corresponding pseudo-register is not changed inside the\n-     loop.  */\n-  unsigned int mem_optimized_dest_p : 1;\n-  /* TRUE if the corresponding pseudo-register has disjoint live\n-     ranges and the other allocnos of the pseudo-register except this\n-     one changed REG.  */\n-  unsigned int somewhere_renamed_p : 1;\n-  /* TRUE if allocno with the same REGNO in a subregion has been\n-     renamed, in other words, got a new pseudo-register.  */\n-  unsigned int child_renamed_p : 1;\n-  /* Final rtx representation of the allocno.  */\n-  rtx reg;\n-  /* Non NULL if we remove restoring value from given allocno to\n-     MEM_OPTIMIZED_DEST at loop exit (see ira-emit.c) because the\n-     allocno value is not changed inside the loop.  */\n-  ira_allocno_t mem_optimized_dest;\n-};\n-\n-#define ALLOCNO_EMIT_DATA(a) ((ira_emit_data_t) ALLOCNO_ADD_DATA (a))\n-\n-/* Data used to emit live range split insns and to flattening IR.  */\n-extern ira_emit_data_t ira_allocno_emit_data;\n-\n-/* Abbreviation for frequent emit data access.  */\n-static inline rtx\n-allocno_emit_reg (ira_allocno_t a)\n-{\n-  return ALLOCNO_EMIT_DATA (a)->reg;\n-}\n-\n-#define OBJECT_ALLOCNO(O) ((O)->allocno)\n-#define OBJECT_SUBWORD(O) ((O)->subword)\n-#define OBJECT_CONFLICT_ARRAY(O) ((O)->conflicts_array)\n-#define OBJECT_CONFLICT_VEC(O) ((ira_object_t *)(O)->conflicts_array)\n-#define OBJECT_CONFLICT_BITVEC(O) ((IRA_INT_TYPE *)(O)->conflicts_array)\n-#define OBJECT_CONFLICT_ARRAY_SIZE(O) ((O)->conflicts_array_size)\n-#define OBJECT_CONFLICT_VEC_P(O) ((O)->conflict_vec_p)\n-#define OBJECT_NUM_CONFLICTS(O) ((O)->num_accumulated_conflicts)\n-#define OBJECT_CONFLICT_HARD_REGS(O) ((O)->conflict_hard_regs)\n-#define OBJECT_TOTAL_CONFLICT_HARD_REGS(O) ((O)->total_conflict_hard_regs)\n-#define OBJECT_MIN(O) ((O)->min)\n-#define OBJECT_MAX(O) ((O)->max)\n-#define OBJECT_CONFLICT_ID(O) ((O)->id)\n-#define OBJECT_LIVE_RANGES(O) ((O)->live_ranges)\n-#define OBJECT_ADD_DATA(O) ((O)->add_data)\n+#define OBJECT_ALLOCNO(C) ((C)->allocno)\n+#define OBJECT_SUBWORD(C) ((C)->subword)\n+#define OBJECT_CONFLICT_ARRAY(C) ((C)->conflicts_array)\n+#define OBJECT_CONFLICT_VEC(C) ((ira_object_t *)(C)->conflicts_array)\n+#define OBJECT_CONFLICT_BITVEC(C) ((IRA_INT_TYPE *)(C)->conflicts_array)\n+#define OBJECT_CONFLICT_ARRAY_SIZE(C) ((C)->conflicts_array_size)\n+#define OBJECT_CONFLICT_VEC_P(C) ((C)->conflict_vec_p)\n+#define OBJECT_NUM_CONFLICTS(C) ((C)->num_accumulated_conflicts)\n+#define OBJECT_CONFLICT_HARD_REGS(C) ((C)->conflict_hard_regs)\n+#define OBJECT_TOTAL_CONFLICT_HARD_REGS(C) ((C)->total_conflict_hard_regs)\n+#define OBJECT_MIN(C) ((C)->min)\n+#define OBJECT_MAX(C) ((C)->max)\n+#define OBJECT_CONFLICT_ID(C) ((C)->id)\n+#define OBJECT_LIVE_RANGES(A) ((A)->live_ranges)\n \n /* Map regno -> allocnos with given regno (see comments for\n    allocno member `next_regno_allocno').  */\n@@ -585,7 +590,6 @@ extern int ira_overall_cost;\n extern int ira_reg_cost, ira_mem_cost;\n extern int ira_load_cost, ira_store_cost, ira_shuffle_cost;\n extern int ira_move_loops_num, ira_additional_jumps_num;\n-\n \f\n /* This page contains a bitset implementation called 'min/max sets' used to\n    record conflicts in IRA.\n@@ -753,6 +757,11 @@ struct target_ira_int {\n   struct costs *x_op_costs[MAX_RECOG_OPERANDS];\n   struct costs *x_this_op_costs[MAX_RECOG_OPERANDS];\n \n+  /* Classes used for cost calculation.  They may be different on\n+     different iterations of the cost calculations or in different\n+     optimization modes.  */\n+  enum reg_class *x_cost_classes;\n+\n   /* Hard registers that can not be used for the register allocator for\n      all functions of the current compilation unit.  */\n   HARD_REG_SET x_no_unit_alloc_regs;\n@@ -767,12 +776,6 @@ struct target_ira_int {\n      ira_get_may_move_cost instead.  */\n   move_table *x_ira_register_move_cost[MAX_MACHINE_MODE];\n \n-  /* Array analogs of the macros MEMORY_MOVE_COST and\n-     REGISTER_MOVE_COST but they contain maximal cost not minimal as\n-     the previous two ones do.  */\n-  short int x_ira_max_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];\n-  move_table *x_ira_max_register_move_cost[MAX_MACHINE_MODE];\n-\n   /* Similar to may_move_in_cost but it is calculated in IRA instead of\n      regclass.  Another difference we take only available hard registers\n      into account to figure out that one register class is a subset of\n@@ -787,18 +790,6 @@ struct target_ira_int {\n      ira_get_may_move_cost instead.  */\n   move_table *x_ira_may_move_out_cost[MAX_MACHINE_MODE];\n \n-/* Similar to ira_may_move_in_cost and ira_may_move_out_cost but they\n-   return maximal cost.  */\n-  move_table *x_ira_max_may_move_in_cost[MAX_MACHINE_MODE];\n-  move_table *x_ira_max_may_move_out_cost[MAX_MACHINE_MODE];\n-\n-  /* Map class->true if class is a possible allocno class, false\n-     otherwise. */\n-  bool x_ira_reg_allocno_class_p[N_REG_CLASSES];\n-\n-  /* Map class->true if class is a pressure class, false otherwise. */\n-  bool x_ira_reg_pressure_class_p[N_REG_CLASSES];\n-\n   /* Register class subset relation: TRUE if the first class is a subset\n      of the second one considering only hard registers available for the\n      allocation.  */\n@@ -818,20 +809,16 @@ struct target_ira_int {\n   /* Array whose values are hard regset of hard registers available for\n      the allocation of given register class whose HARD_REGNO_MODE_OK\n      values for given mode are zero.  */\n-  HARD_REG_SET x_ira_prohibited_class_mode_regs[N_REG_CLASSES][NUM_MACHINE_MODES];\n+  HARD_REG_SET x_prohibited_class_mode_regs[N_REG_CLASSES][NUM_MACHINE_MODES];\n \n   /* The value is number of elements in the subsequent array.  */\n   int x_ira_important_classes_num;\n \n-  /* The array containing all non-empty classes.  Such classes is\n+  /* The array containing non-empty classes (including non-empty cover\n+     classes; which are subclasses of cover classes.  Such classes is\n      important for calculation of the hard register usage costs.  */\n   enum reg_class x_ira_important_classes[N_REG_CLASSES];\n \n-  /* The array containing indexes of important classes in the previous\n-     array.  The array elements are defined only for important\n-     classes.  */\n-  int x_ira_important_class_nums[N_REG_CLASSES];\n-\n   /* The biggest important class inside of intersection of the two\n      classes (that is calculated taking only hard registers available\n      for allocation into account;.  If the both classes contain no hard\n@@ -850,15 +837,14 @@ struct target_ira_int {\n      allocation into account.  */\n   enum reg_class x_ira_reg_class_super_classes[N_REG_CLASSES][N_REG_CLASSES];\n \n-  /* The biggest (smallest) important class inside of (covering) union\n-     of the two classes (that is calculated taking only hard registers\n-     available for allocation into account).  If the both classes\n-     contain no hard registers available for allocation, the value is\n-     calculated with taking all hard-registers including fixed ones\n-     into account.  In other words, the value is the corresponding\n-     reg_class_subunion (reg_class_superunion) value.  */\n-  enum reg_class x_ira_reg_class_subunion[N_REG_CLASSES][N_REG_CLASSES];\n-  enum reg_class x_ira_reg_class_superunion[N_REG_CLASSES][N_REG_CLASSES];\n+  /* The biggest important class inside of union of the two classes\n+     (that is calculated taking only hard registers available for\n+     allocation into account;.  If the both classes contain no hard\n+     registers available for allocation, the value is calculated with\n+     taking all hard-registers including fixed ones into account.  In\n+     other words, the value is the corresponding reg_class_subunion\n+     value.  */\n+  enum reg_class x_ira_reg_class_union[N_REG_CLASSES][N_REG_CLASSES];\n \n   /* For each reg class, table listing all the classes contained in it\n      (excluding the class itself.  Non-allocatable registers are\n@@ -885,58 +871,43 @@ extern struct target_ira_int *this_target_ira_int;\n   (this_target_ira_int->x_ira_reg_mode_hard_regset)\n #define ira_register_move_cost \\\n   (this_target_ira_int->x_ira_register_move_cost)\n-#define ira_max_memory_move_cost \\\n-  (this_target_ira_int->x_ira_max_memory_move_cost)\n-#define ira_max_register_move_cost \\\n-  (this_target_ira_int->x_ira_max_register_move_cost)\n #define ira_may_move_in_cost \\\n   (this_target_ira_int->x_ira_may_move_in_cost)\n #define ira_may_move_out_cost \\\n   (this_target_ira_int->x_ira_may_move_out_cost)\n-#define ira_max_may_move_in_cost \\\n-  (this_target_ira_int->x_ira_max_may_move_in_cost)\n-#define ira_max_may_move_out_cost \\\n-  (this_target_ira_int->x_ira_max_may_move_out_cost)\n-#define ira_reg_allocno_class_p \\\n-  (this_target_ira_int->x_ira_reg_allocno_class_p)\n-#define ira_reg_pressure_class_p \\\n-  (this_target_ira_int->x_ira_reg_pressure_class_p)\n #define ira_class_subset_p \\\n   (this_target_ira_int->x_ira_class_subset_p)\n #define ira_non_ordered_class_hard_regs \\\n   (this_target_ira_int->x_ira_non_ordered_class_hard_regs)\n #define ira_class_hard_reg_index \\\n   (this_target_ira_int->x_ira_class_hard_reg_index)\n-#define ira_prohibited_class_mode_regs \\\n-  (this_target_ira_int->x_ira_prohibited_class_mode_regs)\n+#define prohibited_class_mode_regs \\\n+  (this_target_ira_int->x_prohibited_class_mode_regs)\n #define ira_important_classes_num \\\n   (this_target_ira_int->x_ira_important_classes_num)\n #define ira_important_classes \\\n   (this_target_ira_int->x_ira_important_classes)\n-#define ira_important_class_nums \\\n-  (this_target_ira_int->x_ira_important_class_nums)\n #define ira_reg_class_intersect \\\n   (this_target_ira_int->x_ira_reg_class_intersect)\n #define ira_reg_classes_intersect_p \\\n   (this_target_ira_int->x_ira_reg_classes_intersect_p)\n #define ira_reg_class_super_classes \\\n   (this_target_ira_int->x_ira_reg_class_super_classes)\n-#define ira_reg_class_subunion \\\n-  (this_target_ira_int->x_ira_reg_class_subunion)\n-#define ira_reg_class_superunion \\\n-  (this_target_ira_int->x_ira_reg_class_superunion)\n+#define ira_reg_class_union \\\n+  (this_target_ira_int->x_ira_reg_class_union)\n #define ira_prohibited_mode_move_regs \\\n   (this_target_ira_int->x_ira_prohibited_mode_move_regs)\n \f\n /* ira.c: */\n \n extern void *ira_allocate (size_t);\n+extern void *ira_reallocate (void *, size_t);\n extern void ira_free (void *addr);\n extern bitmap ira_allocate_bitmap (void);\n extern void ira_free_bitmap (bitmap);\n extern void ira_print_disposition (FILE *);\n extern void ira_debug_disposition (void);\n-extern void ira_debug_allocno_classes (void);\n+extern void ira_debug_class_cover (void);\n extern void ira_init_register_move_cost (enum machine_mode);\n \n /* The length of the two following arrays.  */\n@@ -967,7 +938,7 @@ extern ira_allocno_t ira_parent_allocno (ira_allocno_t);\n extern ira_allocno_t ira_parent_or_cap_allocno (ira_allocno_t);\n extern ira_allocno_t ira_create_allocno (int, bool, ira_loop_tree_node_t);\n extern void ira_create_allocno_objects (ira_allocno_t);\n-extern void ira_set_allocno_class (ira_allocno_t, enum reg_class);\n+extern void ira_set_allocno_cover_class (ira_allocno_t, enum reg_class);\n extern bool ira_conflict_vector_profitable_p (ira_object_t, int);\n extern void ira_allocate_conflict_vec (ira_object_t, int);\n extern void ira_allocate_object_conflicts (ira_object_t, int);\n@@ -1001,7 +972,7 @@ extern void ira_init_costs_once (void);\n extern void ira_init_costs (void);\n extern void ira_finish_costs_once (void);\n extern void ira_costs (void);\n-extern void ira_tune_allocno_costs (void);\n+extern void ira_tune_allocno_costs_and_cover_classes (void);\n \n /* ira-lives.c */\n \n@@ -1019,26 +990,41 @@ extern void ira_debug_conflicts (bool);\n extern void ira_build_conflicts (void);\n \n /* ira-color.c */\n-extern void ira_debug_hard_regs_forest (void);\n extern int ira_loop_edge_freq (ira_loop_tree_node_t, int, bool);\n extern void ira_reassign_conflict_allocnos (int);\n extern void ira_initiate_assign (void);\n extern void ira_finish_assign (void);\n extern void ira_color (void);\n \n /* ira-emit.c */\n-extern void ira_initiate_emit_data (void);\n-extern void ira_finish_emit_data (void);\n extern void ira_emit (bool);\n \n \f\n \n-/* Initialize register costs for MODE if necessary.  */\n-static inline void\n-ira_init_register_move_cost_if_necessary (enum machine_mode mode)\n+/* Return cost of moving value of MODE from register of class FROM to\n+   register of class TO.  */\n+static inline int\n+ira_get_register_move_cost (enum machine_mode mode,\n+\t\t\t    enum reg_class from, enum reg_class to)\n+{\n+  if (ira_register_move_cost[mode] == NULL)\n+    ira_init_register_move_cost (mode);\n+  return ira_register_move_cost[mode][from][to];\n+}\n+\n+/* Return cost of moving value of MODE from register of class FROM to\n+   register of class TO.  Return zero if IN_P is true and FROM is\n+   subset of TO or if IN_P is false and FROM is superset of TO.  */\n+static inline int\n+ira_get_may_move_cost (enum machine_mode mode,\n+\t\t       enum reg_class from, enum reg_class to,\n+\t\t       bool in_p)\n {\n   if (ira_register_move_cost[mode] == NULL)\n     ira_init_register_move_cost (mode);\n+  return (in_p\n+\t  ? ira_may_move_in_cost[mode][from][to]\n+\t  : ira_may_move_out_cost[mode][from][to]);\n }\n \n \f\n@@ -1251,77 +1237,58 @@ ira_object_conflict_iter_cond (ira_object_conflict_iterator *i,\n \n   if (i->conflict_vec_p)\n     {\n-      obj = ((ira_object_t *) i->vec)[i->word_num++];\n+      obj = ((ira_object_t *) i->vec)[i->word_num];\n       if (obj == NULL)\n \treturn false;\n     }\n   else\n     {\n-      unsigned IRA_INT_TYPE word = i->word;\n-      unsigned int bit_num = i->bit_num;\n-\n       /* Skip words that are zeros.  */\n-      for (; word == 0; word = ((IRA_INT_TYPE *) i->vec)[i->word_num])\n+      for (; i->word == 0; i->word = ((IRA_INT_TYPE *) i->vec)[i->word_num])\n \t{\n \t  i->word_num++;\n \n \t  /* If we have reached the end, break.  */\n \t  if (i->word_num * sizeof (IRA_INT_TYPE) >= i->size)\n \t    return false;\n \n-\t  bit_num = i->word_num * IRA_INT_BITS;\n+\t  i->bit_num = i->word_num * IRA_INT_BITS;\n \t}\n \n       /* Skip bits that are zero.  */\n-      for (; (word & 1) == 0; word >>= 1)\n-\tbit_num++;\n+      for (; (i->word & 1) == 0; i->word >>= 1)\n+\ti->bit_num++;\n \n-      obj = ira_object_id_map[bit_num + i->base_conflict_id];\n-      i->bit_num = bit_num + 1;\n-      i->word = word >> 1;\n+      obj = ira_object_id_map[i->bit_num + i->base_conflict_id];\n     }\n \n   *pobj = obj;\n   return true;\n }\n \n+/* Advance to the next conflicting allocno.  */\n+static inline void\n+ira_object_conflict_iter_next (ira_object_conflict_iterator *i)\n+{\n+  if (i->conflict_vec_p)\n+    i->word_num++;\n+  else\n+    {\n+      i->word >>= 1;\n+      i->bit_num++;\n+    }\n+}\n+\n /* Loop over all objects conflicting with OBJ.  In each iteration,\n    CONF is set to the next conflicting object.  ITER is an instance\n    of ira_object_conflict_iterator used to iterate the conflicts.  */\n #define FOR_EACH_OBJECT_CONFLICT(OBJ, CONF, ITER)\t\t\t\\\n   for (ira_object_conflict_iter_init (&(ITER), (OBJ));\t\t\t\\\n-       ira_object_conflict_iter_cond (&(ITER), &(CONF));)\n+       ira_object_conflict_iter_cond (&(ITER), &(CONF));\t\t\\\n+       ira_object_conflict_iter_next (&(ITER)))\n \n \f\n \n-/* The function returns TRUE if at least one hard register from ones\n-   starting with HARD_REGNO and containing value of MODE are in set\n-   HARD_REGSET.  */\n-static inline bool\n-ira_hard_reg_set_intersection_p (int hard_regno, enum machine_mode mode,\n-\t\t\t\t HARD_REG_SET hard_regset)\n-{\n-  int i;\n-\n-  gcc_assert (hard_regno >= 0);\n-  for (i = hard_regno_nregs[hard_regno][mode] - 1; i >= 0; i--)\n-    if (TEST_HARD_REG_BIT (hard_regset, hard_regno + i))\n-      return true;\n-  return false;\n-}\n-\n-/* Return number of hard registers in hard register SET.  */\n-static inline int\n-hard_reg_set_size (HARD_REG_SET set)\n-{\n-  int i, size;\n-\n-  for (size = i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (TEST_HARD_REG_BIT (set, i))\n-      size++;\n-  return size;\n-}\n-\n /* The function returns TRUE if hard registers starting with\n    HARD_REGNO and containing value of MODE are not in set\n    HARD_REGSET.  */\n@@ -1344,69 +1311,70 @@ ira_hard_reg_not_in_set_p (int hard_regno, enum machine_mode mode,\n    initialization of the cost vectors.  We do this only when it is\n    really necessary.  */\n \n-/* Allocate cost vector *VEC for hard registers of ACLASS and\n+/* Allocate cost vector *VEC for hard registers of COVER_CLASS and\n    initialize the elements by VAL if it is necessary */\n static inline void\n-ira_allocate_and_set_costs (int **vec, enum reg_class aclass, int val)\n+ira_allocate_and_set_costs (int **vec, enum reg_class cover_class, int val)\n {\n   int i, *reg_costs;\n   int len;\n \n   if (*vec != NULL)\n     return;\n-  *vec = reg_costs = ira_allocate_cost_vector (aclass);\n-  len = ira_class_hard_regs_num[aclass];\n+  *vec = reg_costs = ira_allocate_cost_vector (cover_class);\n+  len = ira_class_hard_regs_num[cover_class];\n   for (i = 0; i < len; i++)\n     reg_costs[i] = val;\n }\n \n-/* Allocate cost vector *VEC for hard registers of ACLASS and copy\n-   values of vector SRC into the vector if it is necessary */\n+/* Allocate cost vector *VEC for hard registers of COVER_CLASS and\n+   copy values of vector SRC into the vector if it is necessary */\n static inline void\n-ira_allocate_and_copy_costs (int **vec, enum reg_class aclass, int *src)\n+ira_allocate_and_copy_costs (int **vec, enum reg_class cover_class, int *src)\n {\n   int len;\n \n   if (*vec != NULL || src == NULL)\n     return;\n-  *vec = ira_allocate_cost_vector (aclass);\n-  len = ira_class_hard_regs_num[aclass];\n+  *vec = ira_allocate_cost_vector (cover_class);\n+  len = ira_class_hard_regs_num[cover_class];\n   memcpy (*vec, src, sizeof (int) * len);\n }\n \n-/* Allocate cost vector *VEC for hard registers of ACLASS and add\n-   values of vector SRC into the vector if it is necessary */\n+/* Allocate cost vector *VEC for hard registers of COVER_CLASS and\n+   add values of vector SRC into the vector if it is necessary */\n static inline void\n-ira_allocate_and_accumulate_costs (int **vec, enum reg_class aclass, int *src)\n+ira_allocate_and_accumulate_costs (int **vec, enum reg_class cover_class,\n+\t\t\t\t   int *src)\n {\n   int i, len;\n \n   if (src == NULL)\n     return;\n-  len = ira_class_hard_regs_num[aclass];\n+  len = ira_class_hard_regs_num[cover_class];\n   if (*vec == NULL)\n     {\n-      *vec = ira_allocate_cost_vector (aclass);\n+      *vec = ira_allocate_cost_vector (cover_class);\n       memset (*vec, 0, sizeof (int) * len);\n     }\n   for (i = 0; i < len; i++)\n     (*vec)[i] += src[i];\n }\n \n-/* Allocate cost vector *VEC for hard registers of ACLASS and copy\n-   values of vector SRC into the vector or initialize it by VAL (if\n-   SRC is null).  */\n+/* Allocate cost vector *VEC for hard registers of COVER_CLASS and\n+   copy values of vector SRC into the vector or initialize it by VAL\n+   (if SRC is null).  */\n static inline void\n-ira_allocate_and_set_or_copy_costs (int **vec, enum reg_class aclass,\n+ira_allocate_and_set_or_copy_costs (int **vec, enum reg_class cover_class,\n \t\t\t\t    int val, int *src)\n {\n   int i, *reg_costs;\n   int len;\n \n   if (*vec != NULL)\n     return;\n-  *vec = reg_costs = ira_allocate_cost_vector (aclass);\n-  len = ira_class_hard_regs_num[aclass];\n+  *vec = reg_costs = ira_allocate_cost_vector (cover_class);\n+  len = ira_class_hard_regs_num[cover_class];\n   if (src != NULL)\n     memcpy (reg_costs, src, sizeof (int) * len);\n   else"}, {"sha": "5c5c41581dec62e0d38198259af3358e458b0f5e", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 69, "deletions": 88, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -64,8 +64,8 @@ static int curr_point;\n    register pressure excess.  Excess pressure for a register class at\n    some point means that there are more allocnos of given register\n    class living at the point than number of hard-registers of the\n-   class available for the allocation.  It is defined only for\n-   pressure classes.  */\n+   class available for the allocation.  It is defined only for cover\n+   classes.  */\n static int high_pressure_start_point[N_REG_CLASSES];\n \n /* Objects live at current point in the scan.  */\n@@ -97,7 +97,6 @@ make_hard_regno_born (int regno)\n   EXECUTE_IF_SET_IN_SPARSESET (objects_live, i)\n     {\n       ira_object_t obj = ira_object_id_map[i];\n-\n       SET_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (obj), regno);\n       SET_HARD_REG_BIT (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), regno);\n     }\n@@ -135,17 +134,14 @@ update_allocno_pressure_excess_length (ira_object_t obj)\n {\n   ira_allocno_t a = OBJECT_ALLOCNO (obj);\n   int start, i;\n-  enum reg_class aclass, pclass, cl;\n+  enum reg_class cover_class, cl;\n   live_range_t p;\n \n-  aclass = ALLOCNO_CLASS (a);\n-  pclass = ira_pressure_class_translate[aclass];\n+  cover_class = ALLOCNO_COVER_CLASS (a);\n   for (i = 0;\n-       (cl = ira_reg_class_super_classes[pclass][i]) != LIM_REG_CLASSES;\n+       (cl = ira_reg_class_super_classes[cover_class][i]) != LIM_REG_CLASSES;\n        i++)\n     {\n-      if (! ira_reg_pressure_class_p[cl])\n-\tcontinue;\n       if (high_pressure_start_point[cl] < 0)\n \tcontinue;\n       p = OBJECT_LIVE_RANGES (obj);\n@@ -170,26 +166,24 @@ make_object_dead (ira_object_t obj)\n   update_allocno_pressure_excess_length (obj);\n }\n \n-/* The current register pressures for each pressure class for the current\n+/* The current register pressures for each cover class for the current\n    basic block.  */\n static int curr_reg_pressure[N_REG_CLASSES];\n \n-/* Record that register pressure for PCLASS increased by N registers.\n-   Update the current register pressure, maximal register pressure for\n-   the current BB and the start point of the register pressure\n-   excess.  */\n+/* Record that register pressure for COVER_CLASS increased by N\n+   registers.  Update the current register pressure, maximal register\n+   pressure for the current BB and the start point of the register\n+   pressure excess.  */\n static void\n-inc_register_pressure (enum reg_class pclass, int n)\n+inc_register_pressure (enum reg_class cover_class, int n)\n {\n   int i;\n   enum reg_class cl;\n \n   for (i = 0;\n-       (cl = ira_reg_class_super_classes[pclass][i]) != LIM_REG_CLASSES;\n+       (cl = ira_reg_class_super_classes[cover_class][i]) != LIM_REG_CLASSES;\n        i++)\n     {\n-      if (! ira_reg_pressure_class_p[cl])\n-\tcontinue;\n       curr_reg_pressure[cl] += n;\n       if (high_pressure_start_point[cl] < 0\n \t  && (curr_reg_pressure[cl] > ira_available_class_regs[cl]))\n@@ -199,25 +193,23 @@ inc_register_pressure (enum reg_class pclass, int n)\n     }\n }\n \n-/* Record that register pressure for PCLASS has decreased by NREGS\n-   registers; update current register pressure, start point of the\n-   register pressure excess, and register pressure excess length for\n-   living allocnos.  */\n+/* Record that register pressure for COVER_CLASS has decreased by\n+   NREGS registers; update current register pressure, start point of\n+   the register pressure excess, and register pressure excess length\n+   for living allocnos.  */\n \n static void\n-dec_register_pressure (enum reg_class pclass, int nregs)\n+dec_register_pressure (enum reg_class cover_class, int nregs)\n {\n   int i;\n   unsigned int j;\n   enum reg_class cl;\n   bool set_p = false;\n \n   for (i = 0;\n-       (cl = ira_reg_class_super_classes[pclass][i]) != LIM_REG_CLASSES;\n+       (cl = ira_reg_class_super_classes[cover_class][i]) != LIM_REG_CLASSES;\n        i++)\n     {\n-      if (! ira_reg_pressure_class_p[cl])\n-\tcontinue;\n       curr_reg_pressure[cl] -= nregs;\n       ira_assert (curr_reg_pressure[cl] >= 0);\n       if (high_pressure_start_point[cl] >= 0\n@@ -229,15 +221,12 @@ dec_register_pressure (enum reg_class pclass, int nregs)\n       EXECUTE_IF_SET_IN_SPARSESET (objects_live, j)\n \tupdate_allocno_pressure_excess_length (ira_object_id_map[j]);\n       for (i = 0;\n-\t   (cl = ira_reg_class_super_classes[pclass][i]) != LIM_REG_CLASSES;\n+\t   (cl = ira_reg_class_super_classes[cover_class][i])\n+\t     != LIM_REG_CLASSES;\n \t   i++)\n-\t{\n-\t  if (! ira_reg_pressure_class_p[cl])\n-\t    continue;\n-\t  if (high_pressure_start_point[cl] >= 0\n-\t      && curr_reg_pressure[cl] <= ira_available_class_regs[cl])\n-\t    high_pressure_start_point[cl] = -1;\n-\t}\n+\tif (high_pressure_start_point[cl] >= 0\n+\t    && curr_reg_pressure[cl] <= ira_available_class_regs[cl])\n+\t  high_pressure_start_point[cl] = -1;\n     }\n }\n \n@@ -247,8 +236,8 @@ static void\n mark_pseudo_regno_live (int regno)\n {\n   ira_allocno_t a = ira_curr_regno_allocno_map[regno];\n-  enum reg_class pclass;\n   int i, n, nregs;\n+  enum reg_class cl;\n \n   if (a == NULL)\n     return;\n@@ -257,8 +246,8 @@ mark_pseudo_regno_live (int regno)\n   allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n \n   n = ALLOCNO_NUM_OBJECTS (a);\n-  pclass = ira_pressure_class_translate[ALLOCNO_CLASS (a)];\n-  nregs = ira_reg_class_max_nregs[ALLOCNO_CLASS (a)][ALLOCNO_MODE (a)];\n+  cl = ALLOCNO_COVER_CLASS (a);\n+  nregs = ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n   if (n > 1)\n     {\n       /* We track every subobject separately.  */\n@@ -269,11 +258,10 @@ mark_pseudo_regno_live (int regno)\n   for (i = 0; i < n; i++)\n     {\n       ira_object_t obj = ALLOCNO_OBJECT (a, i);\n-\n       if (sparseset_bit_p (objects_live, OBJECT_CONFLICT_ID (obj)))\n \tcontinue;\n \n-      inc_register_pressure (pclass, nregs);\n+      inc_register_pressure (cl, nregs);\n       make_object_born (obj);\n     }\n }\n@@ -286,7 +274,7 @@ mark_pseudo_regno_subword_live (int regno, int subword)\n {\n   ira_allocno_t a = ira_curr_regno_allocno_map[regno];\n   int n, nregs;\n-  enum reg_class pclass;\n+  enum reg_class cl;\n   ira_object_t obj;\n \n   if (a == NULL)\n@@ -302,15 +290,15 @@ mark_pseudo_regno_subword_live (int regno, int subword)\n       return;\n     }\n \n-  pclass = ira_pressure_class_translate[ALLOCNO_CLASS (a)];\n-  nregs = ira_reg_class_max_nregs[pclass][ALLOCNO_MODE (a)];\n+  cl = ALLOCNO_COVER_CLASS (a);\n+  nregs = ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n   gcc_assert (nregs == n);\n   obj = ALLOCNO_OBJECT (a, subword);\n \n   if (sparseset_bit_p (objects_live, OBJECT_CONFLICT_ID (obj)))\n     return;\n \n-  inc_register_pressure (pclass, nregs);\n+  inc_register_pressure (cl, nregs);\n   make_object_born (obj);\n }\n \n@@ -325,16 +313,14 @@ mark_hard_reg_live (rtx reg)\n   if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n     {\n       int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n-      enum reg_class aclass, pclass;\n \n       while (regno < last)\n \t{\n \t  if (! TEST_HARD_REG_BIT (hard_regs_live, regno)\n \t      && ! TEST_HARD_REG_BIT (eliminable_regset, regno))\n \t    {\n-\t      aclass = ira_hard_regno_allocno_class[regno];\n-\t      pclass = ira_pressure_class_translate[aclass];\n-\t      inc_register_pressure (pclass, 1);\n+\t      enum reg_class cover_class = ira_hard_regno_cover_class[regno];\n+\t      inc_register_pressure (cover_class, 1);\n \t      make_hard_regno_born (regno);\n \t    }\n \t  regno++;\n@@ -389,8 +375,8 @@ mark_pseudo_regno_dead (int regno)\n   allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n \n   n = ALLOCNO_NUM_OBJECTS (a);\n-  cl = ira_pressure_class_translate[ALLOCNO_CLASS (a)];\n-  nregs = ira_reg_class_max_nregs[ALLOCNO_CLASS (a)][ALLOCNO_MODE (a)];\n+  cl = ALLOCNO_COVER_CLASS (a);\n+  nregs = ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n   if (n > 1)\n     {\n       /* We track every subobject separately.  */\n@@ -429,8 +415,8 @@ mark_pseudo_regno_subword_dead (int regno, int subword)\n     /* The allocno as a whole doesn't die in this case.  */\n     return;\n \n-  cl = ira_pressure_class_translate[ALLOCNO_CLASS (a)];\n-  nregs = ira_reg_class_max_nregs[cl][ALLOCNO_MODE (a)];\n+  cl = ALLOCNO_COVER_CLASS (a);\n+  nregs = ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n   gcc_assert (nregs == n);\n \n   obj = ALLOCNO_OBJECT (a, subword);\n@@ -451,15 +437,13 @@ mark_hard_reg_dead (rtx reg)\n   if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n     {\n       int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n-      enum reg_class aclass, pclass;\n \n       while (regno < last)\n \t{\n \t  if (TEST_HARD_REG_BIT (hard_regs_live, regno))\n \t    {\n-\t      aclass = ira_hard_regno_allocno_class[regno];\n-\t      pclass = ira_pressure_class_translate[aclass];\n-\t      dec_register_pressure (pclass, 1);\n+\t      enum reg_class cover_class = ira_hard_regno_cover_class[regno];\n+\t      dec_register_pressure (cover_class, 1);\n \t      make_hard_regno_dead (regno);\n \t    }\n \t  regno++;\n@@ -528,7 +512,7 @@ make_pseudo_conflict (rtx reg, enum reg_class cl, rtx dreg, rtx orig_dreg,\n     return advance_p;\n \n   a = ira_curr_regno_allocno_map[REGNO (reg)];\n-  if (! reg_classes_intersect_p (cl, ALLOCNO_CLASS (a)))\n+  if (! reg_classes_intersect_p (cl, ALLOCNO_COVER_CLASS (a)))\n     return advance_p;\n \n   if (advance_p)\n@@ -601,7 +585,7 @@ check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n     return;\n \n   a = ira_curr_regno_allocno_map[REGNO (dreg)];\n-  acl = ALLOCNO_CLASS (a);\n+  acl = ALLOCNO_COVER_CLASS (a);\n   if (! reg_classes_intersect_p (acl, def_cl))\n     return;\n \n@@ -831,7 +815,7 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \t\t     : REG_CLASS_FROM_CONSTRAINT (c, constraints));\n \t  if ((cl != NO_REGS && next_cl != cl)\n \t      || (ira_available_class_regs[next_cl]\n-\t\t  > ira_reg_class_max_nregs[next_cl][GET_MODE (op)]))\n+\t\t  > ira_reg_class_nregs[next_cl][GET_MODE (op)]))\n \t    return NO_REGS;\n \t  cl = next_cl;\n \t  break;\n@@ -844,7 +828,7 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \t  if ((cl != NO_REGS && next_cl != cl)\n \t      || next_cl == NO_REGS\n \t      || (ira_available_class_regs[next_cl]\n-\t\t  > ira_reg_class_max_nregs[next_cl][GET_MODE (op)]))\n+\t\t  > ira_reg_class_nregs[next_cl][GET_MODE (op)]))\n \t    return NO_REGS;\n \t  cl = next_cl;\n \t  break;\n@@ -919,7 +903,7 @@ ira_implicitly_set_insn_hard_regs (HARD_REG_SET *set)\n \t\t\t regs in this class are fixed.  */\n \t\t      && ira_available_class_regs[cl] != 0\n \t\t      && (ira_available_class_regs[cl]\n-\t\t\t  <= ira_reg_class_max_nregs[cl][mode]))\n+\t\t\t  <= ira_reg_class_nregs[cl][mode]))\n \t\t    IOR_HARD_REG_SET (*set, reg_class_contents[cl]);\n \t\t  break;\n \t\t}\n@@ -960,11 +944,11 @@ process_single_reg_class_operands (bool in_p, int freq)\n       if (REG_P (operand)\n \t  && (regno = REGNO (operand)) >= FIRST_PSEUDO_REGISTER)\n \t{\n-\t  enum reg_class aclass;\n+\t  enum reg_class cover_class;\n \n \t  operand_a = ira_curr_regno_allocno_map[regno];\n-\t  aclass = ALLOCNO_CLASS (operand_a);\n-\t  if (ira_class_subset_p[cl][aclass]\n+\t  cover_class = ALLOCNO_COVER_CLASS (operand_a);\n+\t  if (ira_class_subset_p[cl][cover_class]\n \t      && ira_class_hard_regs_num[cl] != 0)\n \t    {\n \t      /* View the desired allocation of OPERAND as:\n@@ -984,19 +968,21 @@ process_single_reg_class_operands (bool in_p, int freq)\n \t      offset = subreg_lowpart_offset (ymode, xmode);\n \t      yregno = simplify_subreg_regno (xregno, xmode, offset, ymode);\n \t      if (yregno >= 0\n-\t\t  && ira_class_hard_reg_index[aclass][yregno] >= 0)\n+\t\t  && ira_class_hard_reg_index[cover_class][yregno] >= 0)\n \t\t{\n \t\t  int cost;\n \n \t\t  ira_allocate_and_set_costs\n \t\t    (&ALLOCNO_CONFLICT_HARD_REG_COSTS (operand_a),\n-\t\t     aclass, 0);\n-\t\t  ira_init_register_move_cost_if_necessary (xmode);\n-\t\t  cost = freq * (in_p\n-\t\t\t\t ? ira_register_move_cost[xmode][aclass][cl]\n-\t\t\t\t : ira_register_move_cost[xmode][cl][aclass]);\n+\t\t     cover_class, 0);\n+\t\t  cost\n+\t\t    = (freq\n+\t\t       * (in_p\n+\t\t\t  ? ira_get_register_move_cost (xmode, cover_class, cl)\n+\t\t\t  : ira_get_register_move_cost (xmode, cl,\n+\t\t\t\t\t\t\tcover_class)));\n \t\t  ALLOCNO_CONFLICT_HARD_REG_COSTS (operand_a)\n-\t\t    [ira_class_hard_reg_index[aclass][yregno]] -= cost;\n+\t\t    [ira_class_hard_reg_index[cover_class][yregno]] -= cost;\n \t\t}\n \t    }\n \t}\n@@ -1054,10 +1040,10 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n   bb = loop_tree_node->bb;\n   if (bb != NULL)\n     {\n-      for (i = 0; i < ira_pressure_classes_num; i++)\n+      for (i = 0; i < ira_reg_class_cover_size; i++)\n \t{\n-\t  curr_reg_pressure[ira_pressure_classes[i]] = 0;\n-\t  high_pressure_start_point[ira_pressure_classes[i]] = -1;\n+\t  curr_reg_pressure[ira_reg_class_cover[i]] = 0;\n+\t  high_pressure_start_point[ira_reg_class_cover[i]] = -1;\n \t}\n       curr_bb_node = loop_tree_node;\n       reg_live_out = DF_LR_OUT (bb);\n@@ -1068,17 +1054,14 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (hard_regs_live, i))\n \t  {\n-\t    enum reg_class aclass, pclass, cl;\n+\t    enum reg_class cover_class, cl;\n \n-\t    aclass = ira_allocno_class_translate[REGNO_REG_CLASS (i)];\n-\t    pclass = ira_pressure_class_translate[aclass];\n+\t    cover_class = ira_class_translate[REGNO_REG_CLASS (i)];\n \t    for (j = 0;\n-\t\t (cl = ira_reg_class_super_classes[pclass][j])\n+\t\t (cl = ira_reg_class_super_classes[cover_class][j])\n \t\t   != LIM_REG_CLASSES;\n \t\t j++)\n \t      {\n-\t\tif (! ira_reg_pressure_class_p[cl])\n-\t\t  continue;\n \t\tcurr_reg_pressure[cl]++;\n \t\tif (curr_bb_node->reg_pressure[cl] < curr_reg_pressure[cl])\n \t\t  curr_bb_node->reg_pressure[cl] = curr_reg_pressure[cl];\n@@ -1278,7 +1261,6 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  EXECUTE_IF_SET_IN_SPARSESET (objects_live, px)\n \t    {\n \t      ira_allocno_t a = OBJECT_ALLOCNO (ira_object_id_map[px]);\n-\n \t      ALLOCNO_NO_STACK_REG_P (a) = true;\n \t      ALLOCNO_TOTAL_NO_STACK_REG_P (a) = true;\n \t    }\n@@ -1302,15 +1284,15 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n     }\n   /* Propagate register pressure to upper loop tree nodes: */\n   if (loop_tree_node != ira_loop_tree_root)\n-    for (i = 0; i < ira_pressure_classes_num; i++)\n+    for (i = 0; i < ira_reg_class_cover_size; i++)\n       {\n-\tenum reg_class pclass;\n+\tenum reg_class cover_class;\n \n-\tpclass = ira_pressure_classes[i];\n-\tif (loop_tree_node->reg_pressure[pclass]\n-\t    > loop_tree_node->parent->reg_pressure[pclass])\n-\t  loop_tree_node->parent->reg_pressure[pclass]\n-\t    = loop_tree_node->reg_pressure[pclass];\n+\tcover_class = ira_reg_class_cover[i];\n+\tif (loop_tree_node->reg_pressure[cover_class]\n+\t    > loop_tree_node->parent->reg_pressure[cover_class])\n+\t  loop_tree_node->parent->reg_pressure[cover_class]\n+\t    = loop_tree_node->reg_pressure[cover_class];\n       }\n }\n \n@@ -1442,7 +1424,6 @@ print_allocno_live_ranges (FILE *f, ira_allocno_t a)\n {\n   int n = ALLOCNO_NUM_OBJECTS (a);\n   int i;\n-\n   for (i = 0; i < n; i++)\n     {\n       fprintf (f, \" a%d(r%d\", ALLOCNO_NUM (a), ALLOCNO_REGNO (a));"}, {"sha": "f2b871f0251a407b4b346e17f550fa8ee092cec3", "filename": "gcc/ira.c", "status": "modified", "additions": 343, "deletions": 778, "changes": 1121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -38,51 +38,40 @@ along with GCC; see the file COPYING3.  If not see\n        the other regions.  Therefore data structure representing a\n        region is called loop_tree_node.\n \n-     o *Allocno class* is a register class used for allocation of\n-       given allocno.  It means that only hard register of given\n-       register class can be assigned to given allocno.  In reality,\n-       even smaller subset of (*profitable*) hard registers can be\n-       assigned.  In rare cases, the subset can be even smaller\n-       because our modification of Chaitin-Briggs algorithm requires\n-       that sets of hard registers can be assigned to allocnos forms a\n-       forest, i.e. the sets can be ordered in a way where any\n-       previous set is not intersected with given set or is a superset\n-       of given set.\n-\n-     o *Pressure class* is a register class belonging to a set of\n-       register classes containing all of the hard-registers available\n-       for register allocation.  The set of all pressure classes for a\n-       target is defined in the corresponding machine-description file\n-       according some criteria.  Register pressure is calculated only\n-       for pressure classes and it affects some IRA decisions as\n-       forming allocation regions.\n+     o *Cover class* is a register class belonging to a set of\n+       non-intersecting register classes containing all of the\n+       hard-registers available for register allocation.  The set of\n+       all cover classes for a target is defined in the corresponding\n+       machine-description file according some criteria.  Such notion\n+       is needed because Chaitin-Briggs algorithm works on\n+       non-intersected register classes.\n \n      o *Allocno* represents the live range of a pseudo-register in a\n        region.  Besides the obvious attributes like the corresponding\n-       pseudo-register number, allocno class, conflicting allocnos and\n+       pseudo-register number, cover class, conflicting allocnos and\n        conflicting hard-registers, there are a few allocno attributes\n        which are important for understanding the allocation algorithm:\n \n-       - *Live ranges*.  This is a list of ranges of *program points*\n-         where the allocno lives.  Program points represent places\n-         where a pseudo can be born or become dead (there are\n+       - *Live ranges*.  This is a list of ranges of *program\n+         points* where the allocno lives.  Program points represent\n+         places where a pseudo can be born or become dead (there are\n          approximately two times more program points than the insns)\n          and they are represented by integers starting with 0.  The\n-         live ranges are used to find conflicts between allocnos.\n-         They also play very important role for the transformation of\n-         the IRA internal representation of several regions into a one\n-         region representation.  The later is used during the reload\n-         pass work because each allocno represents all of the\n-         corresponding pseudo-registers.\n+         live ranges are used to find conflicts between allocnos of\n+         different cover classes.  They also play very important role\n+         for the transformation of the IRA internal representation of\n+         several regions into a one region representation.  The later is\n+         used during the reload pass work because each allocno\n+         represents all of the corresponding pseudo-registers.\n \n        - *Hard-register costs*.  This is a vector of size equal to the\n-         number of available hard-registers of the allocno class.  The\n-         cost of a callee-clobbered hard-register for an allocno is\n-         increased by the cost of save/restore code around the calls\n-         through the given allocno's life.  If the allocno is a move\n-         instruction operand and another operand is a hard-register of\n-         the allocno class, the cost of the hard-register is decreased\n-         by the move cost.\n+         number of available hard-registers of the allocno's cover\n+         class.  The cost of a callee-clobbered hard-register for an\n+         allocno is increased by the cost of save/restore code around\n+         the calls through the given allocno's life.  If the allocno\n+         is a move instruction operand and another operand is a\n+         hard-register of the allocno's cover class, the cost of the\n+         hard-register is decreased by the move cost.\n \n          When an allocno is assigned, the hard-register with minimal\n          full cost is used.  Initially, a hard-register's full cost is\n@@ -150,12 +139,12 @@ along with GCC; see the file COPYING3.  If not see\n        * First, IRA builds regions and creates allocnos (file\n          ira-build.c) and initializes most of their attributes.\n \n-       * Then IRA finds an allocno class for each allocno and\n-         calculates its initial (non-accumulated) cost of memory and\n-         each hard-register of its allocno class (file ira-cost.c).\n+       * Then IRA finds a cover class for each allocno and calculates\n+         its initial (non-accumulated) cost of memory and each\n+         hard-register of its cover class (file ira-cost.c).\n \n        * IRA creates live ranges of each allocno, calulates register\n-         pressure for each pressure class in each region, sets up\n+         pressure for each cover class in each region, sets up\n          conflict hard registers for each allocno and info about calls\n          the allocno lives through (file ira-lives.c).\n \n@@ -168,63 +157,23 @@ along with GCC; see the file COPYING3.  If not see\n \n        * IRA creates all caps (file ira-build.c).\n \n-       * Having live-ranges of allocnos and their classes, IRA creates\n-         conflicting allocnos for each allocno.  Conflicting allocnos\n-         are stored as a bit vector or array of pointers to the\n-         conflicting allocnos whatever is more profitable (file\n-         ira-conflicts.c).  At this point IRA creates allocno copies.\n+       * Having live-ranges of allocnos and their cover classes, IRA\n+         creates conflicting allocnos of the same cover class for each\n+         allocno.  Conflicting allocnos are stored as a bit vector or\n+         array of pointers to the conflicting allocnos whatever is\n+         more profitable (file ira-conflicts.c).  At this point IRA\n+         creates allocno copies.\n \n      o Coloring.  Now IRA has all necessary info to start graph coloring\n        process.  It is done in each region on top-down traverse of the\n        region tree (file ira-color.c).  There are following subpasses:\n \n-       * Finding profitable hard registers of corresponding allocno\n-         class for each allocno.  For example, only callee-saved hard\n-         registers are frequently profitable for allocnos living\n-         through colors.  If the profitable hard register set of\n-         allocno does not form a tree based on subset relation, we use\n-         some approximation to form the tree.  This approximation is\n-         used to figure out trivial colorability of allocnos.  The\n-         approximation is a pretty rare case.\n-\n        * Putting allocnos onto the coloring stack.  IRA uses Briggs\n          optimistic coloring which is a major improvement over\n          Chaitin's coloring.  Therefore IRA does not spill allocnos at\n          this point.  There is some freedom in the order of putting\n          allocnos on the stack which can affect the final result of\n-         the allocation.  IRA uses some heuristics to improve the\n-         order.\n-\t \n-\t We also use a modification of Chaitin-Briggs algorithm which\n-         works for intersected register classes of allocnos.  To\n-         figure out trivial colorability of allocnos, the mentioned\n-         above tree of hard register sets is used.  To get an idea how\n-         the algorithm works in i386 example, let us consider an\n-         allocno to which any general hard register can be assigned.\n-         If the allocno conflicts with eight allocnos to which only\n-         EAX register can be assigned, given allocno is still\n-         trivially colorable because all conflicting allocnos might be\n-         assigned only to EAX and all other general hard registers are\n-         still free.\n-\n-\t To get an idea of the used trivial colorability criterion, it\n-\t is also useful to read article \"Graph-Coloring Register\n-\t Allocation for Irregular Architectures\" by Michael D. Smith\n-\t and Glen Holloway.  Major difference between the article\n-\t approach and approach used in IRA is that Smith's approach\n-\t takes register classes only from machine description and IRA\n-\t calculate register classes from intermediate code too\n-\t (e.g. an explicit usage of hard registers in RTL code for\n-\t parameter passing can result in creation of additional\n-\t register classes which contain or exclude the hard\n-\t registers).  That makes IRA approach useful for improving\n-\t coloring even for architectures with regular register files\n-\t and in fact some benchmarking shows the improvement for\n-\t regular class architectures is even bigger than for irregular\n-\t ones.  Another difference is that Smith's approach chooses\n-\t intersection of classes of all insn operands in which a given\n-\t pseudo occurs.  IRA can use bigger classes if it is still\n-\t more profitable than memory usage.\n+         the allocation.  IRA uses some heuristics to improve the order.\n \n        * Popping the allocnos from the stack and assigning them hard\n          registers.  If IRA can not assign a hard register to an\n@@ -238,22 +187,15 @@ along with GCC; see the file COPYING3.  If not see\n          hard-register for the allocno and cost of usage of the\n          hard-register for allocnos conflicting with given allocno.\n \n-       * Chaitin-Briggs coloring assigns as many pseudos as possible\n-         to hard registers.  After coloringh we try to improve\n-         allocation with cost point of view.  We improve the\n-         allocation by spilling some allocnos and assigning the freed\n-         hard registers to other allocnos if it decreases the overall\n-         allocation cost.\n-\n        * After allono assigning in the region, IRA modifies the hard\n          register and memory costs for the corresponding allocnos in\n          the subregions to reflect the cost of possible loads, stores,\n          or moves on the border of the region and its subregions.\n          When default regional allocation algorithm is used\n          (-fira-algorithm=mixed), IRA just propagates the assignment\n          for allocnos if the register pressure in the region for the\n-         corresponding pressure class is less than number of available\n-         hard registers for given pressure class.\n+         corresponding cover class is less than number of available\n+         hard registers for given cover class.\n \n      o Spill/restore code moving.  When IRA performs an allocation\n        by traversing regions in top-down order, it does not know what\n@@ -268,29 +210,28 @@ along with GCC; see the file COPYING3.  If not see\n        practice, so there is no real need for a better time complexity\n        algorithm.\n \n-     o Code change.  After coloring, two allocnos representing the\n-       same pseudo-register outside and inside a region respectively\n-       may be assigned to different locations (hard-registers or\n-       memory).  In this case IRA creates and uses a new\n-       pseudo-register inside the region and adds code to move allocno\n-       values on the region's borders.  This is done during top-down\n-       traversal of the regions (file ira-emit.c).  In some\n-       complicated cases IRA can create a new allocno to move allocno\n-       values (e.g. when a swap of values stored in two hard-registers\n-       is needed).  At this stage, the new allocno is marked as\n-       spilled.  IRA still creates the pseudo-register and the moves\n-       on the region borders even when both allocnos were assigned to\n-       the same hard-register.  If the reload pass spills a\n-       pseudo-register for some reason, the effect will be smaller\n-       because another allocno will still be in the hard-register.  In\n-       most cases, this is better then spilling both allocnos.  If\n-       reload does not change the allocation for the two\n-       pseudo-registers, the trivial move will be removed by\n-       post-reload optimizations.  IRA does not generate moves for\n+     o Code change.  After coloring, two allocnos representing the same\n+       pseudo-register outside and inside a region respectively may be\n+       assigned to different locations (hard-registers or memory).  In\n+       this case IRA creates and uses a new pseudo-register inside the\n+       region and adds code to move allocno values on the region's\n+       borders.  This is done during top-down traversal of the regions\n+       (file ira-emit.c).  In some complicated cases IRA can create a\n+       new allocno to move allocno values (e.g. when a swap of values\n+       stored in two hard-registers is needed).  At this stage, the\n+       new allocno is marked as spilled.  IRA still creates the\n+       pseudo-register and the moves on the region borders even when\n+       both allocnos were assigned to the same hard-register.  If the\n+       reload pass spills a pseudo-register for some reason, the\n+       effect will be smaller because another allocno will still be in\n+       the hard-register.  In most cases, this is better then spilling\n+       both allocnos.  If reload does not change the allocation\n+       for the two pseudo-registers, the trivial move will be removed\n+       by post-reload optimizations.  IRA does not generate moves for\n        allocnos assigned to the same hard register when the default\n        regional allocation algorithm is used and the register pressure\n-       in the region for the corresponding pressure class is less than\n-       number of available hard registers for given pressure class.\n+       in the region for the corresponding allocno cover class is less\n+       than number of available hard registers for given cover class.\n        IRA also does some optimizations to remove redundant stores and\n        to reduce code duplication on the region borders.\n \n@@ -346,9 +287,6 @@ along with GCC; see the file COPYING3.  If not see\n    o Guei-Yuan Lueh, Thomas Gross, and Ali-Reza Adl-Tabatabai. Global\n      Register Allocation Based on Graph Fusion.\n \n-   o Michael D. Smith and Glenn Holloway.  Graph-Coloring Register\n-     Allocation for Irregular Architectures\n-\n    o Vladimir Makarov. The Integrated Register Allocator for GCC.\n \n    o Vladimir Makarov.  The top-down register allocator for irregular\n@@ -523,53 +461,11 @@ setup_alloc_regs (bool use_hard_frame_p)\n \n \f\n \n-#define alloc_reg_class_subclasses \\\n-  (this_target_ira_int->x_alloc_reg_class_subclasses)\n-\n-/* Initialize the table of subclasses of each reg class.  */\n-static void\n-setup_reg_subclasses (void)\n-{\n-  int i, j;\n-  HARD_REG_SET temp_hard_regset2;\n-\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    for (j = 0; j < N_REG_CLASSES; j++)\n-      alloc_reg_class_subclasses[i][j] = LIM_REG_CLASSES;\n-\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    {\n-      if (i == (int) NO_REGS)\n-\tcontinue;\n-\n-      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[i]);\n-      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-      if (hard_reg_set_empty_p (temp_hard_regset))\n-\tcontinue;\n-      for (j = 0; j < N_REG_CLASSES; j++)\n-\tif (i != j)\n-\t  {\n-\t    enum reg_class *p;\n-\n-\t    COPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[j]);\n-\t    AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n-\t    if (! hard_reg_set_subset_p (temp_hard_regset,\n-\t\t\t\t\t temp_hard_regset2))\n-\t      continue;\n-\t    p = &alloc_reg_class_subclasses[j][0];\n-\t    while (*p != LIM_REG_CLASSES) p++;\n-\t    *p = (enum reg_class) i;\n-\t  }\n-    }\n-}\n-\n-\f\n-\n-/* Set up IRA_MEMORY_MOVE_COST and IRA_MAX_MEMORY_MOVE_COST.  */\n+/* Set up IRA_MEMORY_MOVE_COST, IRA_REGISTER_MOVE_COST.  */\n static void\n setup_class_subset_and_memory_move_costs (void)\n {\n-  int cl, cl2, mode, cost;\n+  int cl, cl2, mode;\n   HARD_REG_SET temp_hard_regset2;\n \n   for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n@@ -580,60 +476,34 @@ setup_class_subset_and_memory_move_costs (void)\n       if (cl != (int) NO_REGS)\n \tfor (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n \t  {\n-\t    ira_max_memory_move_cost[mode][cl][0]\n-\t      = ira_memory_move_cost[mode][cl][0]\n-\t      = memory_move_cost ((enum machine_mode) mode,\n-\t\t\t\t  (enum reg_class) cl, false);\n-\t    ira_max_memory_move_cost[mode][cl][1]\n-\t      = ira_memory_move_cost[mode][cl][1]\n-\t      = memory_move_cost ((enum machine_mode) mode,\n-\t\t\t\t  (enum reg_class) cl, true);\n+\t    ira_memory_move_cost[mode][cl][0] =\n+\t      memory_move_cost ((enum machine_mode) mode,\n+\t\t\t\t(enum reg_class) cl, false);\n+\t    ira_memory_move_cost[mode][cl][1] =\n+\t      memory_move_cost ((enum machine_mode) mode,\n+\t\t\t\t(enum reg_class) cl, true);\n \t    /* Costs for NO_REGS are used in cost calculation on the\n \t       1st pass when the preferred register classes are not\n \t       known yet.  In this case we take the best scenario.  */\n \t    if (ira_memory_move_cost[mode][NO_REGS][0]\n \t\t> ira_memory_move_cost[mode][cl][0])\n-\t      ira_max_memory_move_cost[mode][NO_REGS][0]\n-\t\t= ira_memory_move_cost[mode][NO_REGS][0]\n+\t      ira_memory_move_cost[mode][NO_REGS][0]\n \t\t= ira_memory_move_cost[mode][cl][0];\n \t    if (ira_memory_move_cost[mode][NO_REGS][1]\n \t\t> ira_memory_move_cost[mode][cl][1])\n-\t      ira_max_memory_move_cost[mode][NO_REGS][1]\n-\t\t= ira_memory_move_cost[mode][NO_REGS][1]\n+\t      ira_memory_move_cost[mode][NO_REGS][1]\n \t\t= ira_memory_move_cost[mode][cl][1];\n \t  }\n+      for (cl2 = (int) N_REG_CLASSES - 1; cl2 >= 0; cl2--)\n+\t{\n+\t  COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\t  COPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl2]);\n+\t  AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n+\t  ira_class_subset_p[cl][cl2]\n+\t    = hard_reg_set_subset_p (temp_hard_regset, temp_hard_regset2);\n+\t}\n     }\n-  for (cl = (int) N_REG_CLASSES - 1; cl >= 0; cl--)\n-    for (cl2 = (int) N_REG_CLASSES - 1; cl2 >= 0; cl2--)\n-      {\n-\tCOPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n-\tAND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\tCOPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl2]);\n-\tAND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n-\tira_class_subset_p[cl][cl2]\n-\t  = hard_reg_set_subset_p (temp_hard_regset, temp_hard_regset2);\n-\tif (! hard_reg_set_empty_p (temp_hard_regset2)\n-\t    && hard_reg_set_subset_p (reg_class_contents[cl2],\n-\t\t\t\t      reg_class_contents[cl]))\n-\t  for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n-\t    {\n-\t      cost = ira_memory_move_cost[mode][cl2][0];\n-\t      if (cost > ira_max_memory_move_cost[mode][cl][0])\n-\t\tira_max_memory_move_cost[mode][cl][0] = cost;\n-\t      cost = ira_memory_move_cost[mode][cl2][1];\n-\t      if (cost > ira_max_memory_move_cost[mode][cl][1])\n-\t\tira_max_memory_move_cost[mode][cl][1] = cost;\n-\t    }\n-      }\n-  for (cl = (int) N_REG_CLASSES - 1; cl >= 0; cl--)\n-    for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n-      {\n-\tira_memory_move_cost[mode][cl][0]\n-\t  = ira_max_memory_move_cost[mode][cl][0];\n-\tira_memory_move_cost[mode][cl][1]\n-\t  = ira_max_memory_move_cost[mode][cl][1];\n-      }\n-  setup_reg_subclasses ();\n }\n \n \f\n@@ -665,6 +535,20 @@ ira_allocate (size_t len)\n   return res;\n }\n \n+/* Reallocate memory PTR of size LEN for IRA data.  */\n+void *\n+ira_reallocate (void *ptr, size_t len)\n+{\n+  void *res;\n+\n+#ifndef IRA_NO_OBSTACK\n+  res = obstack_alloc (&ira_obstack, len);\n+#else\n+  res = xrealloc (ptr, len);\n+#endif\n+  return res;\n+}\n+\n /* Free memory ADDR allocated for IRA data.  */\n void\n ira_free (void *addr ATTRIBUTE_UNUSED)\n@@ -734,322 +618,216 @@ ira_debug_disposition (void)\n }\n \n \f\n+#define alloc_reg_class_subclasses \\\n+  (this_target_ira_int->x_alloc_reg_class_subclasses)\n \n-/* Set up ira_stack_reg_pressure_class which is the biggest pressure\n-   register class containing stack registers or NO_REGS if there are\n-   no stack registers.  To find this class, we iterate through all\n-   register pressure classes and choose the first register pressure\n-   class containing all the stack registers and having the biggest\n-   size.  */\n-static void\n-setup_stack_reg_pressure_class (void)\n-{\n-  ira_stack_reg_pressure_class = NO_REGS;\n-#ifdef STACK_REGS\n-  {\n-    int i, best, size;\n-    enum reg_class cl;\n-    HARD_REG_SET temp_hard_regset2;\n-\n-    CLEAR_HARD_REG_SET (temp_hard_regset);\n-    for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n-      SET_HARD_REG_BIT (temp_hard_regset, i);\n-    best = 0;\n-    for (i = 0; i < ira_pressure_classes_num; i++)\n-      {\n-\tcl = ira_pressure_classes[i];\n-\tCOPY_HARD_REG_SET (temp_hard_regset2, temp_hard_regset);\n-\tAND_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl]);\n-\tsize = hard_reg_set_size (temp_hard_regset2);\n-\tif (best < size)\n-\t  {\n-\t    best = size;\n-\t    ira_stack_reg_pressure_class = cl;\n-\t  }\n-      }\n-  }\n-#endif\n-}\n-\n-/* Find pressure classes which are register classes for which we\n-   calculate register pressure in IRA, register pressure sensitive\n-   insn scheduling, and register pressure sensitive loop invariant\n-   motion.\n-\n-   To make register pressure calculation easy, we always use\n-   non-intersected register pressure classes.  A move of hard\n-   registers from one register pressure class is not more expensive\n-   than load and store of the hard registers.  Most likely an allocno\n-   class will be a subset of a register pressure class and in many\n-   cases a register pressure class.  That makes usage of register\n-   pressure classes a good approximation to find a high register\n-   pressure.  */\n+/* Initialize the table of subclasses of each reg class.  */\n static void\n-setup_pressure_classes (void)\n+setup_reg_subclasses (void)\n {\n-  int cost, i, n, curr;\n-  int cl, cl2;\n-  enum reg_class pressure_classes[N_REG_CLASSES];\n-  int m;\n+  int i, j;\n   HARD_REG_SET temp_hard_regset2;\n-  bool insert_p;\n \n-  n = 0;\n-  for (cl = 0; cl < N_REG_CLASSES; cl++)\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    for (j = 0; j < N_REG_CLASSES; j++)\n+      alloc_reg_class_subclasses[i][j] = LIM_REG_CLASSES;\n+\n+  for (i = 0; i < N_REG_CLASSES; i++)\n     {\n-      if (ira_available_class_regs[cl] == 0)\n-\tcontinue;\n-      /* Check that the moves between any hard registers of the\n-\t current class are not more expensive for a legal mode than\n-\t load/store of the hard registers of the current class.  Such\n-\t class is a potential candidate to be a register pressure\n-\t class.  */\n-      for (m = 0; m < NUM_MACHINE_MODES; m++)\n-\t{\n-\t  COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n-\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\t  AND_COMPL_HARD_REG_SET (temp_hard_regset,\n-\t\t\t\t  ira_prohibited_class_mode_regs[cl][m]);\n-\t  if (hard_reg_set_empty_p (temp_hard_regset))\n-\t    continue;\n-\t  ira_init_register_move_cost_if_necessary ((enum machine_mode) m);\n-\t  cost = ira_register_move_cost[m][cl][cl];\n-\t  if (cost <= ira_max_memory_move_cost[m][cl][1]\n-\t      || cost <= ira_max_memory_move_cost[m][cl][0])\n-\t    break;\n-\t}\n-      if (m >= NUM_MACHINE_MODES)\n+      if (i == (int) NO_REGS)\n \tcontinue;\n-      curr = 0;\n-      insert_p = true;\n-      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\n+      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[i]);\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-      /* Remove so far added pressure classes which are subset of the\n-\t current candidate class.  Prefer GENERAL_REGS as a pressure\n-\t register class to another class containing the same\n-\t allocatable hard registers.  We do this because machine\n-\t dependent cost hooks might give wrong costs for the latter\n-\t class but always give the right cost for the former class\n-\t (GENERAL_REGS).  */\n-      for (i = 0; i < n; i++)\n-\t{\n-\t  cl2 = pressure_classes[i];\n-\t  COPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl2]);\n-\t  AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n-\t  if (hard_reg_set_subset_p (temp_hard_regset, temp_hard_regset2)\n-\t      && (! hard_reg_set_equal_p (temp_hard_regset, temp_hard_regset2)\n-\t\t  || cl2 == (int) GENERAL_REGS))\n-\t    {\n-\t      pressure_classes[curr++] = (enum reg_class) cl2;\n-\t      insert_p = false;\n+      if (hard_reg_set_empty_p (temp_hard_regset))\n+\tcontinue;\n+      for (j = 0; j < N_REG_CLASSES; j++)\n+\tif (i != j)\n+\t  {\n+\t    enum reg_class *p;\n+\n+\t    COPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[j]);\n+\t    AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n+\t    if (! hard_reg_set_subset_p (temp_hard_regset,\n+\t\t\t\t\t temp_hard_regset2))\n \t      continue;\n-\t    }\n-\t  if (hard_reg_set_subset_p (temp_hard_regset2, temp_hard_regset)\n-\t      && (! hard_reg_set_equal_p (temp_hard_regset2, temp_hard_regset)\n-\t\t  || cl == (int) GENERAL_REGS))\n-\t    continue;\n-\t  pressure_classes[curr++] = (enum reg_class) cl2;\n-\t}\n-      /* If the current candidate is a subset of a so far added\n-\t pressure class, don't add it to the list of the pressure\n-\t classes.  */\n-      if (insert_p)\n-\tpressure_classes[curr++] = (enum reg_class) cl;\n-      n = curr;\n-    }\n-#ifdef ENABLE_IRA_CHECKING\n-  /* Check pressure classes correctness: here we check that hard\n-     registers from all register pressure classes contains all hard\n-     registers available for the allocation.  */\n-  CLEAR_HARD_REG_SET (temp_hard_regset);\n-  CLEAR_HARD_REG_SET (temp_hard_regset2);\n-  for (cl = 0; cl <= LIM_REG_CLASSES; cl++)\n-    {\n-      for (i = 0; i < n; i++)\n-\tif ((int) pressure_classes[i] == cl)\n-\t  break;\n-      IOR_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl]);\n-      if (i >= n)\n-\tIOR_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n-    }\n-  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-  AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n-  ira_assert (hard_reg_set_subset_p (temp_hard_regset2, temp_hard_regset));\n-#endif\n-  ira_pressure_classes_num = 0;\n-  for (i = 0; i < n; i++)\n-    {\n-      cl = (int) pressure_classes[i];\n-      ira_reg_pressure_class_p[cl] = true;\n-      ira_pressure_classes[ira_pressure_classes_num++] = (enum reg_class) cl;\n+\t    p = &alloc_reg_class_subclasses[j][0];\n+\t    while (*p != LIM_REG_CLASSES) p++;\n+\t    *p = (enum reg_class) i;\n+\t  }\n     }\n-  setup_stack_reg_pressure_class ();\n-}\n-\n-/* Set up IRA_ALLOCNO_CLASSES, IRA_ALLOCNO_CLASSES_NUM,\n-   IRA_IMPORTANT_CLASSES, and IRA_IMPORTANT_CLASSES_NUM.\n-\n-   Target may have many subtargets and not all target hard regiters can\n-   be used for allocation, e.g. x86 port in 32-bit mode can not use\n-   hard registers introduced in x86-64 like r8-r15).  Some classes\n-   might have the same allocatable hard registers, e.g.  INDEX_REGS\n-   and GENERAL_REGS in x86 port in 32-bit mode.  To decrease different\n-   calculations efforts we introduce allocno classes which contain\n-   unique non-empty sets of allocatable hard-registers.\n-\n-   Pseudo class cost calculation in ira-costs.c is very expensive.\n-   Therefore we are trying to decrease number of classes involved in\n-   such calculation.  Register classes used in the cost calculation\n-   are called important classes.  They are allocno classes and other\n-   non-empty classes whose allocatable hard register sets are inside\n-   of an allocno class hard register set.  From the first sight, it\n-   looks like that they are just allocno classes.  It is not true.  In\n-   example of x86-port in 32-bit mode, allocno classes will contain\n-   GENERAL_REGS but not LEGACY_REGS (because allocatable hard\n-   registers are the same for the both classes).  The important\n-   classes will contain GENERAL_REGS and LEGACY_REGS.  It is done\n-   because a machine description insn constraint may refers for\n-   LEGACY_REGS and code in ira-costs.c is mostly base on investigation\n-   of the insn constraints.  */\n+}\n+\n+\f\n+\n+/* Set the four global variables defined above.  */\n static void\n-setup_allocno_and_important_classes (void)\n+setup_cover_and_important_classes (void)\n {\n   int i, j, n, cl;\n   bool set_p;\n+  const reg_class_t *cover_classes;\n   HARD_REG_SET temp_hard_regset2;\n   static enum reg_class classes[LIM_REG_CLASSES + 1];\n \n-  n = 0;\n-  /* Collect classes which contain unique sets of allocatable hard\n-     registers.  Prefer GENERAL_REGS to other classes containing the\n-     same set of hard registers.  */\n-  for (i = 0; i <= LIM_REG_CLASSES; i++)\n+  if (targetm.ira_cover_classes == NULL)\n+    cover_classes = NULL;\n+  else\n+    cover_classes = targetm.ira_cover_classes ();\n+  if (cover_classes == NULL)\n+    ira_assert (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY);\n+  else\n     {\n-      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[i]);\n-      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-      for (j = 0; j < n; j++)\n+      for (i = 0; (cl = cover_classes[i]) != LIM_REG_CLASSES; i++)\n+\tclasses[i] = (enum reg_class) cl;\n+      classes[i] = LIM_REG_CLASSES;\n+    }\n+\n+  if (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY)\n+    {\n+      n = 0;\n+      for (i = 0; i <= LIM_REG_CLASSES; i++)\n \t{\n-\t  cl = classes[j];\n-\t  COPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl]);\n-\t  AND_COMPL_HARD_REG_SET (temp_hard_regset2,\n-\t\t\t\t  no_unit_alloc_regs);\n-\t  if (hard_reg_set_equal_p (temp_hard_regset,\n-\t\t\t\t    temp_hard_regset2))\n-\t    break;\n+\t  if (i == NO_REGS)\n+\t    continue;\n+#ifdef CONSTRAINT_NUM_DEFINED_P\n+\t  for (j = 0; j < CONSTRAINT__LIMIT; j++)\n+\t    if ((int) REG_CLASS_FOR_CONSTRAINT ((enum constraint_num) j) == i)\n+\t      break;\n+\t  if (j < CONSTRAINT__LIMIT)\n+\t    {\n+\t      classes[n++] = (enum reg_class) i;\n+\t      continue;\n+\t    }\n+#endif\n+\t  COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[i]);\n+\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\t  for (j = 0; j < LIM_REG_CLASSES; j++)\n+\t    {\n+\t      if (i == j)\n+\t\tcontinue;\n+\t      COPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[j]);\n+\t      AND_COMPL_HARD_REG_SET (temp_hard_regset2,\n+\t\t\t\t      no_unit_alloc_regs);\n+\t      if (hard_reg_set_equal_p (temp_hard_regset,\n+\t\t\t\t\ttemp_hard_regset2))\n+\t\t    break;\n+\t    }\n+\t  if (j >= i)\n+\t    classes[n++] = (enum reg_class) i;\n \t}\n-      if (j >= n)\n-\tclasses[n++] = (enum reg_class) i;\n-      else if (i == GENERAL_REGS)\n-\t/* Prefer general regs.  For i386 example, it means that\n-\t   we prefer GENERAL_REGS over INDEX_REGS or LEGACY_REGS\n-\t   (all of them consists of the same available hard\n-\t   registers).  */\n-\tclasses[j] = (enum reg_class) i;\n+      classes[n] = LIM_REG_CLASSES;\n     }\n-  classes[n] = LIM_REG_CLASSES;\n \n-  /* Set up classes which can be used for allocnos as classes\n-     conatining non-empty unique sets of allocatable hard\n-     registers.  */\n-  ira_allocno_classes_num = 0;\n+  ira_reg_class_cover_size = 0;\n   for (i = 0; (cl = classes[i]) != LIM_REG_CLASSES; i++)\n     {\n+      for (j = 0; j < i; j++)\n+\tif (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n+\t    && reg_classes_intersect_p ((enum reg_class) cl, classes[j]))\n+\t  gcc_unreachable ();\n       COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-      if (hard_reg_set_empty_p (temp_hard_regset))\n-\tcontinue;\n-      ira_allocno_classes[ira_allocno_classes_num++] = (enum reg_class) cl;\n+      if (! hard_reg_set_empty_p (temp_hard_regset))\n+\tira_reg_class_cover[ira_reg_class_cover_size++] = (enum reg_class) cl;\n     }\n   ira_important_classes_num = 0;\n-  /* Add non-allocno classes containing to non-empty set of\n-     allocatable hard regs.  */\n   for (cl = 0; cl < N_REG_CLASSES; cl++)\n     {\n       COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n       if (! hard_reg_set_empty_p (temp_hard_regset))\n \t{\n \t  set_p = false;\n-\t  for (j = 0; j < ira_allocno_classes_num; j++)\n+\t  for (j = 0; j < ira_reg_class_cover_size; j++)\n \t    {\n+\t      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\t      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n \t      COPY_HARD_REG_SET (temp_hard_regset2,\n-\t\t\t\t reg_class_contents[ira_allocno_classes[j]]);\n+\t\t\t\t reg_class_contents[ira_reg_class_cover[j]]);\n \t      AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n-\t      if ((enum reg_class) cl == ira_allocno_classes[j])\n+\t      if ((enum reg_class) cl == ira_reg_class_cover[j]\n+\t\t  || hard_reg_set_equal_p (temp_hard_regset,\n+\t\t\t\t\t   temp_hard_regset2))\n \t\tbreak;\n \t      else if (hard_reg_set_subset_p (temp_hard_regset,\n \t\t\t\t\t      temp_hard_regset2))\n \t\tset_p = true;\n \t    }\n-\t  if (set_p && j >= ira_allocno_classes_num)\n+\t  if (set_p && j >= ira_reg_class_cover_size)\n \t    ira_important_classes[ira_important_classes_num++]\n \t      = (enum reg_class) cl;\n \t}\n     }\n-  /* Now add allocno classes to the important classes.  */\n-  for (j = 0; j < ira_allocno_classes_num; j++)\n+  for (j = 0; j < ira_reg_class_cover_size; j++)\n     ira_important_classes[ira_important_classes_num++]\n-      = ira_allocno_classes[j];\n-  for (cl = 0; cl < N_REG_CLASSES; cl++)\n-    {\n-      ira_reg_allocno_class_p[cl] = false;\n-      ira_reg_pressure_class_p[cl] = false;\n-    }\n-  for (j = 0; j < ira_allocno_classes_num; j++)\n-    ira_reg_allocno_class_p[ira_allocno_classes[j]] = true;\n-  setup_pressure_classes ();\n-}\n-\n-/* Setup translation in CLASS_TRANSLATE of all classes into a class\n-   given by array CLASSES of length CLASSES_NUM.  The function is used\n-   make translation any reg class to an allocno class or to an\n-   pressure class.  This translation is necessary for some\n-   calculations when we can use only allocno or pressure classes and\n-   such translation represents an approximate representation of all\n-   classes.\n-\n-   The translation in case when allocatable hard register set of a\n-   given class is subset of allocatable hard register set of a class\n-   in CLASSES is pretty simple.  We use smallest classes from CLASSES\n-   containing a given class.  If allocatable hard register set of a\n-   given class is not a subset of any corresponding set of a class\n-   from CLASSES, we use the cheapest (with load/store point of view)\n-   class from CLASSES whose set intersects with given class set */\n+      = ira_reg_class_cover[j];\n+}\n+\n+/* Set up array IRA_CLASS_TRANSLATE.  */\n static void\n-setup_class_translate_array (enum reg_class *class_translate,\n-\t\t\t     int classes_num, enum reg_class *classes)\n+setup_class_translate (void)\n {\n   int cl, mode;\n-  enum reg_class aclass, best_class, *cl_ptr;\n+  enum reg_class cover_class, best_class, *cl_ptr;\n   int i, cost, min_cost, best_cost;\n \n   for (cl = 0; cl < N_REG_CLASSES; cl++)\n-    class_translate[cl] = NO_REGS;\n+    ira_class_translate[cl] = NO_REGS;\n \n-  for (i = 0; i < classes_num; i++)\n+  if (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY)\n+    for (cl = 0; cl < LIM_REG_CLASSES; cl++)\n+      {\n+\tCOPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\tAND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\tfor (i = 0; i < ira_reg_class_cover_size; i++)\n+\t  {\n+\t    HARD_REG_SET temp_hard_regset2;\n+\n+\t    cover_class = ira_reg_class_cover[i];\n+\t    COPY_HARD_REG_SET (temp_hard_regset2,\n+\t\t\t       reg_class_contents[cover_class]);\n+\t    AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n+\t    if (hard_reg_set_equal_p (temp_hard_regset, temp_hard_regset2))\n+\t      ira_class_translate[cl] = cover_class;\n+\t  }\n+      }\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n-      aclass = classes[i];\n-      for (cl_ptr = &alloc_reg_class_subclasses[aclass][0];\n-\t   (cl = *cl_ptr) != LIM_REG_CLASSES;\n-\t   cl_ptr++)\n-\tif (class_translate[cl] == NO_REGS)\n-\t  class_translate[cl] = aclass;\n-      class_translate[aclass] = aclass;\n+      cover_class = ira_reg_class_cover[i];\n+      if (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY)\n+\tfor (cl_ptr = &alloc_reg_class_subclasses[cover_class][0];\n+\t     (cl = *cl_ptr) != LIM_REG_CLASSES;\n+\t     cl_ptr++)\n+\t  {\n+\t    if (ira_class_translate[cl] == NO_REGS)\n+\t      ira_class_translate[cl] = cover_class;\n+#ifdef ENABLE_IRA_CHECKING\n+\t    else\n+\t      {\n+\t\tCOPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\t\tAND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\t\tif (! hard_reg_set_empty_p (temp_hard_regset))\n+\t\t  gcc_unreachable ();\n+\t      }\n+#endif\n+\t  }\n+      ira_class_translate[cover_class] = cover_class;\n     }\n-  /* For classes which are not fully covered by one of given classes\n-     (in other words covered by more one given class), use the\n-     cheapest class.  */\n+  /* For classes which are not fully covered by a cover class (in\n+     other words covered by more one cover class), use the cheapest\n+     cover class.  */\n   for (cl = 0; cl < N_REG_CLASSES; cl++)\n     {\n-      if (cl == NO_REGS || class_translate[cl] != NO_REGS)\n+      if (cl == NO_REGS || ira_class_translate[cl] != NO_REGS)\n \tcontinue;\n       best_class = NO_REGS;\n       best_cost = INT_MAX;\n-      for (i = 0; i < classes_num; i++)\n+      for (i = 0; i < ira_reg_class_cover_size; i++)\n \t{\n-\t  aclass = classes[i];\n+\t  cover_class = ira_reg_class_cover[i];\n \t  COPY_HARD_REG_SET (temp_hard_regset,\n-\t\t\t     reg_class_contents[aclass]);\n+\t\t\t     reg_class_contents[cover_class]);\n \t  AND_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n \t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n \t  if (! hard_reg_set_empty_p (temp_hard_regset))\n@@ -1064,77 +842,52 @@ setup_class_translate_array (enum reg_class *class_translate,\n \t\t}\n \t      if (best_class == NO_REGS || best_cost > min_cost)\n \t\t{\n-\t\t  best_class = aclass;\n+\t\t  best_class = cover_class;\n \t\t  best_cost = min_cost;\n \t\t}\n \t    }\n \t}\n-      class_translate[cl] = best_class;\n+      ira_class_translate[cl] = best_class;\n     }\n }\n \n-/* Set up array IRA_ALLOCNO_CLASS_TRANSLATE and\n-   IRA_PRESSURE_CLASS_TRANSLATE.  */\n-static void\n-setup_class_translate (void)\n-{\n-  setup_class_translate_array (ira_allocno_class_translate,\n-\t\t\t       ira_allocno_classes_num, ira_allocno_classes);\n-  setup_class_translate_array (ira_pressure_class_translate,\n-\t\t\t       ira_pressure_classes_num, ira_pressure_classes);\n-}\n-\n-/* Order numbers of allocno classes in original target allocno class\n-   array, -1 for non-allocno classes.  */\n-static int allocno_class_order[N_REG_CLASSES];\n+/* Order numbers of cover classes in original target cover class\n+   array, -1 for non-cover classes.  This is only live during\n+   reorder_important_classes.  */\n+static int cover_class_order[N_REG_CLASSES];\n \n /* The function used to sort the important classes.  */\n static int\n comp_reg_classes_func (const void *v1p, const void *v2p)\n {\n   enum reg_class cl1 = *(const enum reg_class *) v1p;\n   enum reg_class cl2 = *(const enum reg_class *) v2p;\n-  enum reg_class tcl1, tcl2;\n   int diff;\n \n-  tcl1 = ira_allocno_class_translate[cl1];\n-  tcl2 = ira_allocno_class_translate[cl2];\n-  if (tcl1 != NO_REGS && tcl2 != NO_REGS\n-      && (diff = allocno_class_order[tcl1] - allocno_class_order[tcl2]) != 0)\n+  cl1 = ira_class_translate[cl1];\n+  cl2 = ira_class_translate[cl2];\n+  if (cl1 != NO_REGS && cl2 != NO_REGS\n+      && (diff = cover_class_order[cl1] - cover_class_order[cl2]) != 0)\n     return diff;\n   return (int) cl1 - (int) cl2;\n }\n \n-/* For correct work of function setup_reg_class_relation we need to\n-   reorder important classes according to the order of their allocno\n-   classes.  It places important classes containing the same\n-   allocatable hard register set adjacent to each other and allocno\n-   class with the allocatable hard register set right after the other\n-   important classes with the same set.\n-\n-   In example from comments of function\n-   setup_allocno_and_important_classes, it places LEGACY_REGS and\n-   GENERAL_REGS close to each other and GENERAL_REGS is after\n-   LEGACY_REGS.  */\n+/* Reorder important classes according to the order of their cover\n+   classes.  */\n static void\n reorder_important_classes (void)\n {\n   int i;\n \n   for (i = 0; i < N_REG_CLASSES; i++)\n-    allocno_class_order[i] = -1;\n-  for (i = 0; i < ira_allocno_classes_num; i++)\n-    allocno_class_order[ira_allocno_classes[i]] = i;\n+    cover_class_order[i] = -1;\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    cover_class_order[ira_reg_class_cover[i]] = i;\n   qsort (ira_important_classes, ira_important_classes_num,\n \t sizeof (enum reg_class), comp_reg_classes_func);\n-  for (i = 0; i < ira_important_classes_num; i++)\n-    ira_important_class_nums[ira_important_classes[i]] = i;\n }\n \n-/* Set up IRA_REG_CLASS_SUBUNION, IRA_REG_CLASS_SUPERUNION,\n-   IRA_REG_CLASS_SUPER_CLASSES, IRA_REG_CLASSES_INTERSECT, and\n-   IRA_REG_CLASSES_INTERSECT_P.  For the meaning of the relations,\n-   please see corresponding comments in ira-int.h.  */\n+/* Set up the above reg class relations.  */\n static void\n setup_reg_class_relations (void)\n {\n@@ -1159,9 +912,6 @@ setup_reg_class_relations (void)\n \t  if (hard_reg_set_empty_p (temp_hard_regset)\n \t      && hard_reg_set_empty_p (temp_set2))\n \t    {\n-\t      /* The both classes have no allocatable hard registers\n-\t\t -- take all class hard registers into account and use\n-\t\t reg_class_subunion and reg_class_superunion.  */\n \t      for (i = 0;; i++)\n \t\t{\n \t\t  cl3 = reg_class_subclasses[cl1][i];\n@@ -1171,18 +921,14 @@ setup_reg_class_relations (void)\n \t\t\t\t\t  (enum reg_class) cl3))\n \t\t    ira_reg_class_intersect[cl1][cl2] = (enum reg_class) cl3;\n \t\t}\n-\t      ira_reg_class_subunion[cl1][cl2] = reg_class_subunion[cl1][cl2];\n-\t      ira_reg_class_superunion[cl1][cl2] = reg_class_superunion[cl1][cl2];\n+\t      ira_reg_class_union[cl1][cl2] = reg_class_subunion[cl1][cl2];\n \t      continue;\n \t    }\n \t  ira_reg_classes_intersect_p[cl1][cl2]\n \t    = hard_reg_set_intersect_p (temp_hard_regset, temp_set2);\n \t  if (important_class_p[cl1] && important_class_p[cl2]\n \t      && hard_reg_set_subset_p (temp_hard_regset, temp_set2))\n \t    {\n-\t      /* CL1 and CL2 are important classes and CL1 allocatable\n-\t\t hard register set is inside of CL2 allocatable hard\n-\t\t registers -- make CL1 a superset of CL2.  */\n \t      enum reg_class *p;\n \n \t      p = &ira_reg_class_super_classes[cl1][0];\n@@ -1191,8 +937,7 @@ setup_reg_class_relations (void)\n \t      *p++ = (enum reg_class) cl2;\n \t      *p = LIM_REG_CLASSES;\n \t    }\n-\t  ira_reg_class_subunion[cl1][cl2] = NO_REGS;\n-\t  ira_reg_class_superunion[cl1][cl2] = NO_REGS;\n+\t  ira_reg_class_union[cl1][cl2] = NO_REGS;\n \t  COPY_HARD_REG_SET (intersection_set, reg_class_contents[cl1]);\n \t  AND_HARD_REG_SET (intersection_set, reg_class_contents[cl2]);\n \t  AND_COMPL_HARD_REG_SET (intersection_set, no_unit_alloc_regs);\n@@ -1206,121 +951,77 @@ setup_reg_class_relations (void)\n \t      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n \t      if (hard_reg_set_subset_p (temp_hard_regset, intersection_set))\n \t\t{\n-\t\t  /* CL3 allocatable hard register set is inside of\n-\t\t     intersection of allocatable hard register sets\n-\t\t     of CL1 and CL2.  */\n \t\t  COPY_HARD_REG_SET\n \t\t    (temp_set2,\n \t\t     reg_class_contents[(int)\n \t\t\t\t\tira_reg_class_intersect[cl1][cl2]]);\n \t\t  AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n \t \t  if (! hard_reg_set_subset_p (temp_hard_regset, temp_set2)\n-\t\t      /* If the allocatable hard register sets are the\n-\t\t\t same, prefer GENERAL_REGS or the smallest\n-\t\t\t class for debugging purposes.  */\n+\t\t      /* Ignore unavailable hard registers and prefer\n+\t\t\t smallest class for debugging purposes.  */\n \t\t      || (hard_reg_set_equal_p (temp_hard_regset, temp_set2)\n-\t\t\t  && (cl3 == GENERAL_REGS\n-\t\t\t      || (ira_reg_class_intersect[cl1][cl2] != GENERAL_REGS\n-\t\t\t\t  && hard_reg_set_subset_p\n-\t\t\t\t     (reg_class_contents[cl3],\n-\t\t\t\t      reg_class_contents\n-\t\t\t\t      [(int) ira_reg_class_intersect[cl1][cl2]])))))\n+\t\t\t  && hard_reg_set_subset_p\n+\t\t\t     (reg_class_contents[cl3],\n+\t\t\t      reg_class_contents\n+\t\t\t      [(int) ira_reg_class_intersect[cl1][cl2]])))\n \t\t    ira_reg_class_intersect[cl1][cl2] = (enum reg_class) cl3;\n \t\t}\n \t      if (hard_reg_set_subset_p (temp_hard_regset, union_set))\n \t\t{\n-\t\t  /* CL3 allocatbale hard register set is inside of\n-\t\t     union of allocatable hard register sets of CL1\n-\t\t     and CL2.  */\n \t\t  COPY_HARD_REG_SET\n \t\t    (temp_set2,\n-\t\t     reg_class_contents[(int) ira_reg_class_subunion[cl1][cl2]]);\n+\t\t     reg_class_contents[(int) ira_reg_class_union[cl1][cl2]]);\n \t\t  AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n-\t \t  if (ira_reg_class_subunion[cl1][cl2] == NO_REGS\n+\t \t  if (ira_reg_class_union[cl1][cl2] == NO_REGS\n \t\t      || (hard_reg_set_subset_p (temp_set2, temp_hard_regset)\n-\t\t\t  \n-\t\t\t  && (! hard_reg_set_equal_p (temp_set2,\n-\t\t\t\t\t\t      temp_hard_regset)\n-\t\t\t      || cl3 == GENERAL_REGS\n-\t\t\t      /* If the allocatable hard register sets are the\n-\t\t\t\t same, prefer GENERAL_REGS or the smallest\n-\t\t\t\t class for debugging purposes.  */\n-\t\t\t      || (ira_reg_class_subunion[cl1][cl2] != GENERAL_REGS\n-\t\t\t\t  && hard_reg_set_subset_p\n-\t\t\t\t     (reg_class_contents[cl3],\n-\t\t\t\t      reg_class_contents\n-\t\t\t\t      [(int) ira_reg_class_subunion[cl1][cl2]])))))\n-\t\t    ira_reg_class_subunion[cl1][cl2] = (enum reg_class) cl3;\n-\t\t}\n-\t      if (hard_reg_set_subset_p (union_set, temp_hard_regset))\n-\t\t{\n-\t\t  /* CL3 allocatable hard register set contains union\n-\t\t     of allocatable hard register sets of CL1 and\n-\t\t     CL2.  */\n-\t\t  COPY_HARD_REG_SET\n-\t\t    (temp_set2,\n-\t\t     reg_class_contents[(int) ira_reg_class_superunion[cl1][cl2]]);\n-\t\t  AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n-\t \t  if (ira_reg_class_superunion[cl1][cl2] == NO_REGS\n-\t\t      || (hard_reg_set_subset_p (temp_hard_regset, temp_set2)\n \n \t\t\t  && (! hard_reg_set_equal_p (temp_set2,\n \t\t\t\t\t\t      temp_hard_regset)\n-\t\t\t      || cl3 == GENERAL_REGS\n-\t\t\t      /* If the allocatable hard register sets are the\n-\t\t\t\t same, prefer GENERAL_REGS or the smallest\n-\t\t\t\t class for debugging purposes.  */\n-\t\t\t      || (ira_reg_class_superunion[cl1][cl2] != GENERAL_REGS\n-\t\t\t\t  && hard_reg_set_subset_p\n-\t\t\t\t     (reg_class_contents[cl3],\n-\t\t\t\t      reg_class_contents\n-\t\t\t\t      [(int) ira_reg_class_superunion[cl1][cl2]])))))\n-\t\t    ira_reg_class_superunion[cl1][cl2] = (enum reg_class) cl3;\n+\t\t\t      /* Ignore unavailable hard registers and\n+\t\t\t\t prefer smallest class for debugging\n+\t\t\t\t purposes.  */\n+\t\t\t      || hard_reg_set_subset_p\n+\t\t\t         (reg_class_contents[cl3],\n+\t\t\t\t  reg_class_contents\n+\t\t\t\t  [(int) ira_reg_class_union[cl1][cl2]]))))\n+\t\t    ira_reg_class_union[cl1][cl2] = (enum reg_class) cl3;\n \t\t}\n \t    }\n \t}\n     }\n }\n \n-/* Output all possible allocno classes and the translation map into\n-   file F.  */\n+/* Output all cover classes and the translation map into file F.  */\n static void\n-print_classes (FILE *f, bool pressure_p)\n-{\n-  int classes_num = (pressure_p\n-\t\t     ? ira_pressure_classes_num : ira_allocno_classes_num);\n-  enum reg_class *classes = (pressure_p\n-\t\t\t     ? ira_pressure_classes : ira_allocno_classes);\n-  enum reg_class *class_translate = (pressure_p\n-\t\t\t\t     ? ira_pressure_class_translate\n-\t\t\t\t     : ira_allocno_class_translate);\n+print_class_cover (FILE *f)\n+{\n   static const char *const reg_class_names[] = REG_CLASS_NAMES;\n   int i;\n \n-  fprintf (f, \"%s classes:\\n\", pressure_p ? \"Pressure\" : \"Allocno\");\n-  for (i = 0; i < classes_num; i++)\n-    fprintf (f, \" %s\", reg_class_names[classes[i]]);\n+  fprintf (f, \"Class cover:\\n\");\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    fprintf (f, \" %s\", reg_class_names[ira_reg_class_cover[i]]);\n   fprintf (f, \"\\nClass translation:\\n\");\n   for (i = 0; i < N_REG_CLASSES; i++)\n     fprintf (f, \" %s -> %s\\n\", reg_class_names[i],\n-\t     reg_class_names[class_translate[i]]);\n+\t     reg_class_names[ira_class_translate[i]]);\n }\n \n-/* Output all possible allocno and translation classes and the\n-   translation maps into stderr.  */\n+/* Output all cover classes and the translation map into\n+   stderr.  */\n void\n-ira_debug_allocno_classes (void)\n+ira_debug_class_cover (void)\n {\n-  print_classes (stderr, false);\n-  print_classes (stderr, true);\n+  print_class_cover (stderr);\n }\n \n-/* Set up different arrays concerning class subsets, allocno and\n+/* Set up different arrays concerning class subsets, cover and\n    important classes.  */\n static void\n-find_reg_classes (void)\n+find_reg_class_closure (void)\n {\n-  setup_allocno_and_important_classes ();\n+  setup_reg_subclasses ();\n+  setup_cover_and_important_classes ();\n   setup_class_translate ();\n   reorder_important_classes ();\n   setup_reg_class_relations ();\n@@ -1330,158 +1031,77 @@ find_reg_classes (void)\n \n /* Set up the array above.  */\n static void\n-setup_hard_regno_aclass (void)\n+setup_hard_regno_cover_class (void)\n {\n   int i;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-#if 1\n-      ira_hard_regno_allocno_class[i]\n+      ira_hard_regno_cover_class[i]\n \t= (TEST_HARD_REG_BIT (no_unit_alloc_regs, i)\n \t   ? NO_REGS\n-\t   : ira_allocno_class_translate[REGNO_REG_CLASS (i)]);\n-#else\n-      int j;\n-      enum reg_class cl;\n-      ira_hard_regno_allocno_class[i] = NO_REGS;\n-      for (j = 0; j < ira_allocno_classes_num; j++)\n- \t{\n-\t  cl = ira_allocno_classes[j];\n- \t  if (ira_class_hard_reg_index[cl][i] >= 0)\n- \t    {\n-\t      ira_hard_regno_allocno_class[i] = cl;\n- \t      break;\n- \t    }\n- \t}\n-#endif\n+\t   : ira_class_translate[REGNO_REG_CLASS (i)]);\n     }\n }\n \n \f\n \n-/* Form IRA_REG_CLASS_MAX_NREGS and IRA_REG_CLASS_MIN_NREGS maps.  */\n+/* Form IRA_REG_CLASS_NREGS map.  */\n static void\n setup_reg_class_nregs (void)\n {\n-  int i, cl, cl2, m;\n+  int cl, m;\n \n-  for (m = 0; m < MAX_MACHINE_MODE; m++)\n-    {\n-      for (cl = 0; cl < N_REG_CLASSES; cl++)\n-\tira_reg_class_max_nregs[cl][m]\n-\t  = ira_reg_class_min_nregs[cl][m]\n-\t  = CLASS_MAX_NREGS ((enum reg_class) cl, (enum machine_mode) m);\n-      for (cl = 0; cl < N_REG_CLASSES; cl++)\n-\tfor (i = 0;\n-\t     (cl2 = alloc_reg_class_subclasses[cl][i]) != LIM_REG_CLASSES;\n-\t     i++)\n-\t  if (ira_reg_class_min_nregs[cl2][m]\n-\t      < ira_reg_class_min_nregs[cl][m])\n-\t    ira_reg_class_min_nregs[cl][m] = ira_reg_class_min_nregs[cl2][m];\n-    }\n+  for (cl = 0; cl < N_REG_CLASSES; cl++)\n+    for (m = 0; m < MAX_MACHINE_MODE; m++)\n+      ira_reg_class_nregs[cl][m] = CLASS_MAX_NREGS ((enum reg_class) cl,\n+\t\t\t\t\t\t    (enum machine_mode) m);\n }\n \n \f\n \n-/* Set up IRA_PROHIBITED_CLASS_MODE_REGS.  */\n+/* Set up PROHIBITED_CLASS_MODE_REGS.  */\n static void\n setup_prohibited_class_mode_regs (void)\n {\n-  int j, k, hard_regno, cl;\n+  int i, j, k, hard_regno;\n+  enum reg_class cl;\n \n-  for (cl = (int) N_REG_CLASSES - 1; cl >= 0; cl--)\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n+      cl = ira_reg_class_cover[i];\n       for (j = 0; j < NUM_MACHINE_MODES; j++)\n \t{\n-\t  CLEAR_HARD_REG_SET (ira_prohibited_class_mode_regs[cl][j]);\n+\t  CLEAR_HARD_REG_SET (prohibited_class_mode_regs[cl][j]);\n \t  for (k = ira_class_hard_regs_num[cl] - 1; k >= 0; k--)\n \t    {\n \t      hard_regno = ira_class_hard_regs[cl][k];\n \t      if (! HARD_REGNO_MODE_OK (hard_regno, (enum machine_mode) j))\n-\t\tSET_HARD_REG_BIT (ira_prohibited_class_mode_regs[cl][j],\n+\t\tSET_HARD_REG_BIT (prohibited_class_mode_regs[cl][j],\n \t\t\t\t  hard_regno);\n \t    }\n \t}\n     }\n }\n \n-/* Clarify IRA_PROHIBITED_CLASS_MODE_REGS by excluding hard registers\n-   spanning from one register pressure class to another one.  It is\n-   called after defining the pressure classes.  */\n-static void\n-clarify_prohibited_class_mode_regs (void)\n-{\n-  int j, k, hard_regno, cl, pclass, nregs;\n-\n-  for (cl = (int) N_REG_CLASSES - 1; cl >= 0; cl--)\n-    for (j = 0; j < NUM_MACHINE_MODES; j++)\n-      for (k = ira_class_hard_regs_num[cl] - 1; k >= 0; k--)\n-\t{\n-\t  hard_regno = ira_class_hard_regs[cl][k];\n-\t  if (TEST_HARD_REG_BIT (ira_prohibited_class_mode_regs[cl][j], hard_regno))\n-\t    continue;\n-\t  nregs = hard_regno_nregs[hard_regno][j];\n-\t  pclass = ira_pressure_class_translate[REGNO_REG_CLASS (hard_regno)];\n-\t  for (nregs-- ;nregs >= 0; nregs--)\n-\t    if (((enum reg_class) pclass\n-\t\t != ira_pressure_class_translate[REGNO_REG_CLASS\n-\t\t\t\t\t\t (hard_regno + nregs)]))\n-\t      {\n-\t\tSET_HARD_REG_BIT (ira_prohibited_class_mode_regs[cl][j],\n-\t\t\t\t  hard_regno);\n-\t\tbreak;\n-\t      }\n-\t}\n-}\n-\n \f\n \n /* Allocate and initialize IRA_REGISTER_MOVE_COST,\n-   IRA_MAX_REGISTER_MOVE_COST, IRA_MAY_MOVE_IN_COST,\n-   IRA_MAY_MOVE_OUT_COST, IRA_MAX_MAY_MOVE_IN_COST, and\n-   IRA_MAX_MAY_MOVE_OUT_COST for MODE if it is not done yet.  */\n+   IRA_MAY_MOVE_IN_COST, and IRA_MAY_MOVE_OUT_COST for MODE if it is\n+   not done yet.  */\n void\n ira_init_register_move_cost (enum machine_mode mode)\n {\n-  int cl1, cl2, cl3;\n+  int cl1, cl2;\n \n   ira_assert (ira_register_move_cost[mode] == NULL\n-\t      && ira_max_register_move_cost[mode] == NULL\n \t      && ira_may_move_in_cost[mode] == NULL\n-\t      && ira_may_move_out_cost[mode] == NULL\n-\t      && ira_max_may_move_in_cost[mode] == NULL\n-\t      && ira_max_may_move_out_cost[mode] == NULL);\n+\t      && ira_may_move_out_cost[mode] == NULL);\n   if (move_cost[mode] == NULL)\n     init_move_cost (mode);\n   ira_register_move_cost[mode] = move_cost[mode];\n   /* Don't use ira_allocate because the tables exist out of scope of a\n      IRA call.  */\n-  ira_max_register_move_cost[mode]\n-    = (move_table *) xmalloc (sizeof (move_table) * N_REG_CLASSES);\n-  memcpy (ira_max_register_move_cost[mode], ira_register_move_cost[mode],\n-\t  sizeof (move_table) * N_REG_CLASSES);\n-  for (cl1 = 0; cl1 < N_REG_CLASSES; cl1++)\n-    {\n-      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl1]);\n-      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-      if (hard_reg_set_empty_p (temp_hard_regset))\n-\tcontinue;\n-      for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n-\tif (hard_reg_set_subset_p (reg_class_contents[cl1],\n-\t\t\t\t   reg_class_contents[cl2]))\n-\t  for (cl3 = 0; cl3 < N_REG_CLASSES; cl3++)\n-\t    {\n-\t      if (ira_max_register_move_cost[mode][cl2][cl3]\n-\t\t  < ira_register_move_cost[mode][cl1][cl3])\n-\t\tira_max_register_move_cost[mode][cl2][cl3]\n-\t\t  = ira_register_move_cost[mode][cl1][cl3];\n-\t      if (ira_max_register_move_cost[mode][cl3][cl2]\n-\t\t  < ira_register_move_cost[mode][cl3][cl1])\n-\t\tira_max_register_move_cost[mode][cl3][cl2]\n-\t\t  = ira_register_move_cost[mode][cl3][cl1];\n-\t    }\n-    }\n   ira_may_move_in_cost[mode]\n     = (move_table *) xmalloc (sizeof (move_table) * N_REG_CLASSES);\n   memcpy (ira_may_move_in_cost[mode], may_move_in_cost[mode],\n@@ -1490,36 +1110,14 @@ ira_init_register_move_cost (enum machine_mode mode)\n     = (move_table *) xmalloc (sizeof (move_table) * N_REG_CLASSES);\n   memcpy (ira_may_move_out_cost[mode], may_move_out_cost[mode],\n \t  sizeof (move_table) * N_REG_CLASSES);\n-  ira_max_may_move_in_cost[mode]\n-    = (move_table *) xmalloc (sizeof (move_table) * N_REG_CLASSES);\n-  memcpy (ira_max_may_move_in_cost[mode], ira_max_register_move_cost[mode],\n-\t  sizeof (move_table) * N_REG_CLASSES);\n-  ira_max_may_move_out_cost[mode]\n-    = (move_table *) xmalloc (sizeof (move_table) * N_REG_CLASSES);\n-  memcpy (ira_max_may_move_out_cost[mode], ira_max_register_move_cost[mode],\n-\t  sizeof (move_table) * N_REG_CLASSES);\n   for (cl1 = 0; cl1 < N_REG_CLASSES; cl1++)\n     {\n       for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n \t{\n-\t  COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl2]);\n-\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\t  if (hard_reg_set_empty_p (temp_hard_regset))\n-\t    continue;\n \t  if (ira_class_subset_p[cl1][cl2])\n \t    ira_may_move_in_cost[mode][cl1][cl2] = 0;\n \t  if (ira_class_subset_p[cl2][cl1])\n \t    ira_may_move_out_cost[mode][cl1][cl2] = 0;\n-\t  if (ira_class_subset_p[cl1][cl2])\n-\t    ira_max_may_move_in_cost[mode][cl1][cl2] = 0;\n-\t  if (ira_class_subset_p[cl2][cl1])\n-\t    ira_max_may_move_out_cost[mode][cl1][cl2] = 0;\n-\t  ira_register_move_cost[mode][cl1][cl2]\n-\t    = ira_max_register_move_cost[mode][cl1][cl2];\n-\t  ira_may_move_in_cost[mode][cl1][cl2]\n-\t    = ira_max_may_move_in_cost[mode][cl1][cl2];\n-\t  ira_may_move_out_cost[mode][cl1][cl2]\n-\t    = ira_max_may_move_out_cost[mode][cl1][cl2];\n \t}\n     }\n }\n@@ -1537,41 +1135,28 @@ ira_init_once (void)\n   for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n     {\n       ira_register_move_cost[mode] = NULL;\n-      ira_max_register_move_cost[mode] = NULL;\n       ira_may_move_in_cost[mode] = NULL;\n       ira_may_move_out_cost[mode] = NULL;\n-      ira_max_may_move_in_cost[mode] = NULL;\n-      ira_max_may_move_out_cost[mode] = NULL;\n     }\n   ira_init_costs_once ();\n }\n \n-/* Free ira_max_register_move_cost, ira_may_move_in_cost,\n-   ira_may_move_out_cost, ira_max_may_move_in_cost, and\n-   ira_max_may_move_out_cost for each mode.  */\n+/* Free ira_register_move_cost, ira_may_move_in_cost, and\n+   ira_may_move_out_cost for each mode.  */\n static void\n free_register_move_costs (void)\n {\n   int mode;\n \n   for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n     {\n-      if (ira_max_register_move_cost[mode] != NULL)\n-\tfree (ira_max_register_move_cost[mode]);\n       if (ira_may_move_in_cost[mode] != NULL)\n \tfree (ira_may_move_in_cost[mode]);\n       if (ira_may_move_out_cost[mode] != NULL)\n \tfree (ira_may_move_out_cost[mode]);\n-      if (ira_max_may_move_in_cost[mode] != NULL)\n-\tfree (ira_max_may_move_in_cost[mode]);\n-      if (ira_max_may_move_out_cost[mode] != NULL)\n-\tfree (ira_max_may_move_out_cost[mode]);\n       ira_register_move_cost[mode] = NULL;\n-      ira_max_register_move_cost[mode] = NULL;\n       ira_may_move_in_cost[mode] = NULL;\n       ira_may_move_out_cost[mode] = NULL;\n-      ira_max_may_move_in_cost[mode] = NULL;\n-      ira_max_may_move_out_cost[mode] = NULL;\n     }\n }\n \n@@ -1584,11 +1169,10 @@ ira_init (void)\n   setup_reg_mode_hard_regset ();\n   setup_alloc_regs (flag_omit_frame_pointer != 0);\n   setup_class_subset_and_memory_move_costs ();\n+  find_reg_class_closure ();\n+  setup_hard_regno_cover_class ();\n   setup_reg_class_nregs ();\n   setup_prohibited_class_mode_regs ();\n-  find_reg_classes ();\n-  clarify_prohibited_class_mode_regs ();\n-  setup_hard_regno_aclass ();\n   ira_init_costs ();\n }\n \n@@ -1687,6 +1271,10 @@ ira_bad_reload_regno (int regno, rtx in, rtx out)\n \t  || ira_bad_reload_regno_1 (regno, out));\n }\n \n+/* Function specific hard registers that can not be used for the\n+   register allocation.  */\n+HARD_REG_SET ira_no_alloc_regs;\n+\n /* Return TRUE if *LOC contains an asm.  */\n static int\n insn_contains_asm_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n@@ -1909,32 +1497,17 @@ setup_reg_renumber (void)\n \tALLOCNO_ASSIGNED_P (a) = true;\n       ira_free_allocno_updated_costs (a);\n       hard_regno = ALLOCNO_HARD_REGNO (a);\n-      regno = ALLOCNO_REGNO (a);\n+      regno = (int) REGNO (ALLOCNO_REG (a));\n       reg_renumber[regno] = (hard_regno < 0 ? -1 : hard_regno);\n-      if (hard_regno >= 0)\n+      if (hard_regno >= 0 && ALLOCNO_CALLS_CROSSED_NUM (a) != 0\n+\t  && ! ira_hard_reg_not_in_set_p (hard_regno, ALLOCNO_MODE (a),\n+\t\t\t\t\t  call_used_reg_set))\n \t{\n-\t  int i, nwords;\n-\t  enum reg_class pclass;\n-\t  ira_object_t obj;\n-\t  \n-\t  pclass = ira_pressure_class_translate[REGNO_REG_CLASS (hard_regno)];\n-\t  nwords = ALLOCNO_NUM_OBJECTS (a);\n-\t  for (i = 0; i < nwords; i++)\n-\t    {\n-\t      obj = ALLOCNO_OBJECT (a, i);\n-\t      IOR_COMPL_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t\t      reg_class_contents[pclass]);\n-\t    }\n-\t  if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0\n-\t      && ! ira_hard_reg_not_in_set_p (hard_regno, ALLOCNO_MODE (a),\n-\t\t\t\t\t      call_used_reg_set))\n-\t    {\n-\t      ira_assert (!optimize || flag_caller_saves\n-\t\t\t  || regno >= ira_reg_equiv_len\n-\t\t\t  || ira_reg_equiv_const[regno]\n-\t\t\t  || ira_reg_equiv_invariant_p[regno]);\n-\t      caller_save_needed = 1;\n-\t    }\n+\t  ira_assert (!optimize || flag_caller_saves\n+\t\t      || regno >= ira_reg_equiv_len\n+\t\t      || ira_reg_equiv_const[regno]\n+\t\t      || ira_reg_equiv_invariant_p[regno]);\n+\t  caller_save_needed = 1;\n \t}\n     }\n }\n@@ -1962,13 +1535,13 @@ setup_allocno_assignment_flags (void)\n \t allocnos because the cost info and info about intersected\n \t calls are incorrect for them.  */\n       ALLOCNO_ASSIGNED_P (a) = (hard_regno >= 0\n-\t\t\t\t|| ALLOCNO_EMIT_DATA (a)->mem_optimized_dest_p\n+\t\t\t\t|| ALLOCNO_MEM_OPTIMIZED_DEST_P (a)\n \t\t\t\t|| (ALLOCNO_MEMORY_COST (a)\n-\t\t\t\t    - ALLOCNO_CLASS_COST (a)) < 0);\n+\t\t\t\t    - ALLOCNO_COVER_CLASS_COST (a)) < 0);\n       ira_assert (hard_regno < 0\n \t\t  || ! ira_hard_reg_not_in_set_p (hard_regno, ALLOCNO_MODE (a),\n \t\t\t\t\t\t  reg_class_contents\n-\t\t\t\t\t\t  [ALLOCNO_CLASS (a)]));\n+\t\t\t\t\t\t  [ALLOCNO_COVER_CLASS (a)]));\n     }\n }\n \n@@ -1988,7 +1561,7 @@ calculate_allocation_cost (void)\n       ira_assert (hard_regno < 0\n \t\t  || ! ira_hard_reg_not_in_set_p\n \t\t       (hard_regno, ALLOCNO_MODE (a),\n-\t\t\treg_class_contents[ALLOCNO_CLASS (a)]));\n+\t\t\treg_class_contents[ALLOCNO_COVER_CLASS (a)]));\n       if (hard_regno < 0)\n \t{\n \t  cost = ALLOCNO_MEMORY_COST (a);\n@@ -1998,12 +1571,12 @@ calculate_allocation_cost (void)\n \t{\n \t  cost = (ALLOCNO_HARD_REG_COSTS (a)\n \t\t  [ira_class_hard_reg_index\n-\t\t   [ALLOCNO_CLASS (a)][hard_regno]]);\n+\t\t   [ALLOCNO_COVER_CLASS (a)][hard_regno]]);\n \t  ira_reg_cost += cost;\n \t}\n       else\n \t{\n-\t  cost = ALLOCNO_CLASS_COST (a);\n+\t  cost = ALLOCNO_COVER_CLASS_COST (a);\n \t  ira_reg_cost += cost;\n \t}\n       ira_overall_cost += cost;\n@@ -2195,7 +1768,7 @@ setup_preferred_alternate_classes_for_new_pseudos (int start)\n       ira_assert (i != old_regno);\n       setup_reg_classes (i, reg_preferred_class (old_regno),\n \t\t\t reg_alternate_class (old_regno),\n-\t\t\t reg_allocno_class (old_regno));\n+\t\t\t reg_cover_class (old_regno));\n       if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n \tfprintf (ira_dump_file,\n \t\t \"    New r%d: setting preferred %s, alternative %s\\n\",\n@@ -2225,12 +1798,12 @@ static bool\n too_high_register_pressure_p (void)\n {\n   int i;\n-  enum reg_class pclass;\n+  enum reg_class cover_class;\n \n-  for (i = 0; i < ira_pressure_classes_num; i++)\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n-      pclass = ira_pressure_classes[i];\n-      if (ira_loop_tree_root->reg_pressure[pclass] > 10000)\n+      cover_class = ira_reg_class_cover[i];\n+      if (ira_loop_tree_root->reg_pressure[cover_class] > 10000)\n \treturn true;\n     }\n   return false;\n@@ -2442,10 +2015,9 @@ equiv_init_movable_p (rtx x, int regno)\n       return 0;\n \n     case REG:\n-      return ((reg_equiv[REGNO (x)].loop_depth >= reg_equiv[regno].loop_depth\n-\t       && reg_equiv[REGNO (x)].replace)\n-\t      || (REG_BASIC_BLOCK (REGNO (x)) < NUM_FIXED_BLOCKS\n-\t\t  && ! rtx_varies_p (x, 0)));\n+      return (reg_equiv[REGNO (x)].loop_depth >= reg_equiv[regno].loop_depth\n+\t      && reg_equiv[REGNO (x)].replace)\n+\t     || (REG_BASIC_BLOCK (REGNO (x)) < NUM_FIXED_BLOCKS && ! rtx_varies_p (x, 0));\n \n     case UNSPEC_VOLATILE:\n       return 0;\n@@ -2478,8 +2050,7 @@ equiv_init_movable_p (rtx x, int regno)\n   return 1;\n }\n \n-/* TRUE if X uses any registers for which reg_equiv[REGNO].replace is\n-   true.  */\n+/* TRUE if X uses any registers for which reg_equiv[REGNO].replace is true.  */\n static int\n contains_replace_regs (rtx x)\n {\n@@ -2627,8 +2198,7 @@ memref_used_between_p (rtx memref, rtx start, rtx end)\n    assignment - a SET, CLOBBER or REG_INC note.  It is currently not used,\n    but needs to be there because this function is called from note_stores.  */\n static void\n-no_equiv (rtx reg, const_rtx store ATTRIBUTE_UNUSED,\n-\t  void *data ATTRIBUTE_UNUSED)\n+no_equiv (rtx reg, const_rtx store ATTRIBUTE_UNUSED, void *data ATTRIBUTE_UNUSED)\n {\n   int regno;\n   rtx list;\n@@ -2673,13 +2243,12 @@ adjust_cleared_regs (rtx loc, const_rtx old_rtx ATTRIBUTE_UNUSED, void *data)\n static int recorded_label_ref;\n \n /* Find registers that are equivalent to a single value throughout the\n-   compilation (either because they can be referenced in memory or are\n-   set once from a single constant).  Lower their priority for a\n-   register.\n+   compilation (either because they can be referenced in memory or are set once\n+   from a single constant).  Lower their priority for a register.\n \n-   If such a register is only referenced once, try substituting its\n-   value into the using insn.  If it succeeds, we can eliminate the\n-   register completely.\n+   If such a register is only referenced once, try substituting its value\n+   into the using insn.  If it succeeds, we can eliminate the register\n+   completely.\n \n    Initialize the REG_EQUIV_INIT array of initializing insns.\n \n@@ -3622,8 +3191,6 @@ ira (FILE *f)\n \n   ira_max_point_before_emit = ira_max_point;\n \n-  ira_initiate_emit_data ();\n-\n   ira_emit (loops_p);\n \n   if (ira_conflicts_p)\n@@ -3656,8 +3223,6 @@ ira (FILE *f)\n \t}\n     }\n \n-  ira_finish_emit_data ();\n-\n   setup_reg_renumber ();\n \n   calculate_allocation_cost ();"}, {"sha": "f6cac367180d0e443c276e7aa01756851956a1ec", "filename": "gcc/ira.h", "status": "modified", "additions": 33, "deletions": 61, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -20,6 +20,10 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+/* Function specific hard registers can not be used for the register\n+   allocation.  */\n+extern HARD_REG_SET ira_no_alloc_regs;\n+\n /* True if we have allocno conflicts.  It is false for non-optimized\n    mode or when the conflict table is too big.  */\n extern bool ira_conflicts_p;\n@@ -29,47 +33,31 @@ struct target_ira {\n      allocation for given classes.  */\n   int x_ira_available_class_regs[N_REG_CLASSES];\n \n-  /* Map: hard register number -> allocno class it belongs to.  If the\n+  /* Map: hard register number -> cover class it belongs to.  If the\n      corresponding class is NO_REGS, the hard register is not available\n      for allocation.  */\n-  enum reg_class x_ira_hard_regno_allocno_class[FIRST_PSEUDO_REGISTER];\n-\n-  /* Number of allocno classes.  Allocno classes are register classes\n-     which can be used for allocations of allocnos.  */\n-  int x_ira_allocno_classes_num;\n-\n-  /* The array containing allocno classes.  Only first\n-     IRA_ALLOCNO_CLASSES_NUM elements are used for this.  */\n-  enum reg_class x_ira_allocno_classes[N_REG_CLASSES];\n-\n-  /* Map of all register classes to corresponding allocno classes\n-     containing the given class.  If given class is not a subset of an\n-     allocno class, we translate it into the cheapest allocno class.  */\n-  enum reg_class x_ira_allocno_class_translate[N_REG_CLASSES];\n-\n-  /* Number of pressure classes.  Pressure classes are register\n-     classes for which we calculate register pressure.  */\n-  int x_ira_pressure_classes_num;\n+  enum reg_class x_ira_hard_regno_cover_class[FIRST_PSEUDO_REGISTER];\n \n-  /* The array containing pressure classes.  Only first\n-     IRA_PRESSURE_CLASSES_NUM elements are used for this.  */\n-  enum reg_class x_ira_pressure_classes[N_REG_CLASSES];\n+  /* Number of cover classes.  Cover classes is non-intersected register\n+     classes containing all hard-registers available for the\n+     allocation.  */\n+  int x_ira_reg_class_cover_size;\n \n-  /* Map of all register classes to corresponding pressure classes\n-     containing the given class.  If given class is not a subset of an\n-     pressure class, we translate it into the cheapest pressure\n-     class.  */\n-  enum reg_class x_ira_pressure_class_translate[N_REG_CLASSES];\n+  /* The array containing cover classes (see also comments for macro\n+     IRA_COVER_CLASSES;.  Only first IRA_REG_CLASS_COVER_SIZE elements are\n+     used for this.  */\n+  enum reg_class x_ira_reg_class_cover[N_REG_CLASSES];\n \n-  /* Bigest pressure register class containing stack registers.\n-     NO_REGS if there are no stack registers.  */\n-  enum reg_class x_ira_stack_reg_pressure_class;\n+  /* Map of all register classes to corresponding cover class containing\n+     the given class.  If given class is not a subset of a cover class,\n+     we translate it into the cheapest cover class.  */\n+  enum reg_class x_ira_class_translate[N_REG_CLASSES];\n \n-  /* Maps: register class x machine mode -> maximal/minimal number of\n-     hard registers of given class needed to store value of given\n-     mode.  */\n-  int x_ira_reg_class_max_nregs[N_REG_CLASSES][MAX_MACHINE_MODE];\n-  int x_ira_reg_class_min_nregs[N_REG_CLASSES][MAX_MACHINE_MODE];\n+  /* Map: register class x machine mode -> number of hard registers of\n+     given class needed to store value of given mode.  If the number for\n+     some hard-registers of the register class is different, the size\n+     will be negative.  */\n+  int x_ira_reg_class_nregs[N_REG_CLASSES][MAX_MACHINE_MODE];\n \n   /* Array analogous to target hook TARGET_MEMORY_MOVE_COST.  */\n   short x_ira_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];\n@@ -82,10 +70,6 @@ struct target_ira {\n   /* The number of elements of the above array for given register\n      class.  */\n   int x_ira_class_hard_regs_num[N_REG_CLASSES];\n-\n-  /* Function specific hard registers can not be used for the register\n-     allocation.  */\n-  HARD_REG_SET x_ira_no_alloc_regs;\n };\n \n extern struct target_ira default_target_ira;\n@@ -97,34 +81,22 @@ extern struct target_ira *this_target_ira;\n \n #define ira_available_class_regs \\\n   (this_target_ira->x_ira_available_class_regs)\n-#define ira_hard_regno_allocno_class \\\n-  (this_target_ira->x_ira_hard_regno_allocno_class)\n-#define ira_allocno_classes_num \\\n-  (this_target_ira->x_ira_allocno_classes_num)\n-#define ira_allocno_classes \\\n-  (this_target_ira->x_ira_allocno_classes)\n-#define ira_allocno_class_translate \\\n-  (this_target_ira->x_ira_allocno_class_translate)\n-#define ira_pressure_classes_num \\\n-  (this_target_ira->x_ira_pressure_classes_num)\n-#define ira_pressure_classes \\\n-  (this_target_ira->x_ira_pressure_classes)\n-#define ira_pressure_class_translate \\\n-  (this_target_ira->x_ira_pressure_class_translate)\n-#define ira_stack_reg_pressure_class \\\n-  (this_target_ira->x_ira_stack_reg_pressure_class)\n-#define ira_reg_class_max_nregs \\\n-  (this_target_ira->x_ira_reg_class_max_nregs)\n-#define ira_reg_class_min_nregs \\\n-  (this_target_ira->x_ira_reg_class_min_nregs)\n+#define ira_hard_regno_cover_class \\\n+  (this_target_ira->x_ira_hard_regno_cover_class)\n+#define ira_reg_class_cover_size \\\n+  (this_target_ira->x_ira_reg_class_cover_size)\n+#define ira_reg_class_cover \\\n+  (this_target_ira->x_ira_reg_class_cover)\n+#define ira_class_translate \\\n+  (this_target_ira->x_ira_class_translate)\n+#define ira_reg_class_nregs \\\n+  (this_target_ira->x_ira_reg_class_nregs)\n #define ira_memory_move_cost \\\n   (this_target_ira->x_ira_memory_move_cost)\n #define ira_class_hard_regs \\\n   (this_target_ira->x_ira_class_hard_regs)\n #define ira_class_hard_regs_num \\\n   (this_target_ira->x_ira_class_hard_regs_num)\n-#define ira_no_alloc_regs \\\n-  (this_target_ira->x_ira_no_alloc_regs)\n \n extern void ira_init_once (void);\n extern void ira_init (void);"}, {"sha": "77fd4aef6f1e2efec32affe43cb68594dd73f59d", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 67, "deletions": 76, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -64,7 +64,7 @@ struct loop_data\n   struct loop *outermost_exit;\t/* The outermost exit of the loop.  */\n   bool has_call;\t\t/* True if the loop contains a call.  */\n   /* Maximal register pressure inside loop for given register class\n-     (defined only for the pressure classes).  */\n+     (defined only for the cover classes).  */\n   int max_reg_pressure[N_REG_CLASSES];\n   /* Loop regs referenced and live pseudo-registers.  */\n   bitmap_head regs_ref;\n@@ -1012,13 +1012,13 @@ free_use_list (struct use *use)\n     }\n }\n \n-/* Return pressure class and number of hard registers (through *NREGS)\n+/* Return cover class and number of hard registers (through *NREGS)\n    for destination of INSN. */\n static enum reg_class\n-get_pressure_class_and_nregs (rtx insn, int *nregs)\n+get_cover_class_and_nregs (rtx insn, int *nregs)\n {\n   rtx reg;\n-  enum reg_class pressure_class;\n+  enum reg_class cover_class;\n   rtx set = single_set (insn);\n \n   /* Considered invariant insns have only one set.  */\n@@ -1029,23 +1029,19 @@ get_pressure_class_and_nregs (rtx insn, int *nregs)\n   if (MEM_P (reg))\n     {\n       *nregs = 0;\n-      pressure_class = NO_REGS;\n+      cover_class = NO_REGS;\n     }\n   else\n     {\n       if (! REG_P (reg))\n \treg = NULL_RTX;\n       if (reg == NULL_RTX)\n-\tpressure_class = GENERAL_REGS;\n+\tcover_class = GENERAL_REGS;\n       else\n-\t{\n-\t  pressure_class = reg_allocno_class (REGNO (reg));\n-\t  pressure_class = ira_pressure_class_translate[pressure_class];\n-\t}\n-      *nregs\n-\t= ira_reg_class_max_nregs[pressure_class][GET_MODE (SET_SRC (set))];\n+\tcover_class = reg_cover_class (REGNO (reg));\n+      *nregs = ira_reg_class_nregs[cover_class][GET_MODE (SET_SRC (set))];\n     }\n-  return pressure_class;\n+  return cover_class;\n }\n \n /* Calculates cost and number of registers needed for moving invariant INV\n@@ -1068,8 +1064,8 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n     regs_needed[0] = 0;\n   else\n     {\n-      for (i = 0; i < ira_pressure_classes_num; i++)\n-\tregs_needed[ira_pressure_classes[i]] = 0;\n+      for (i = 0; i < ira_reg_class_cover_size; i++)\n+\tregs_needed[ira_reg_class_cover[i]] = 0;\n     }\n \n   if (inv->move\n@@ -1082,10 +1078,10 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n   else\n     {\n       int nregs;\n-      enum reg_class pressure_class;\n+      enum reg_class cover_class;\n \n-      pressure_class = get_pressure_class_and_nregs (inv->insn, &nregs);\n-      regs_needed[pressure_class] += nregs;\n+      cover_class = get_cover_class_and_nregs (inv->insn, &nregs);\n+      regs_needed[cover_class] += nregs;\n     }\n \n   if (!inv->cheap_address\n@@ -1116,7 +1112,7 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n \t&& constant_pool_constant_p (SET_SRC (set)))\n       {\n \tif (flag_ira_loop_pressure)\n-\t  regs_needed[ira_stack_reg_pressure_class] += 2;\n+\t  regs_needed[STACK_REG_COVER_CLASS] += 2;\n \telse\n \t  regs_needed[0] += 2;\n       }\n@@ -1135,10 +1131,10 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n \tcheck_p = aregs_needed[0] != 0;\n       else\n \t{\n-\t  for (i = 0; i < ira_pressure_classes_num; i++)\n-\t    if (aregs_needed[ira_pressure_classes[i]] != 0)\n+\t  for (i = 0; i < ira_reg_class_cover_size; i++)\n+\t    if (aregs_needed[ira_reg_class_cover[i]] != 0)\n \t      break;\n-\t  check_p = i < ira_pressure_classes_num;\n+\t  check_p = i < ira_reg_class_cover_size;\n \t}\n       if (check_p\n \t  /* We need to check always_executed, since if the original value of\n@@ -1155,20 +1151,20 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n \t  else\n \t    {\n \t      int nregs;\n-\t      enum reg_class pressure_class;\n+\t      enum reg_class cover_class;\n \n-\t      pressure_class = get_pressure_class_and_nregs (inv->insn, &nregs);\n-\t      aregs_needed[pressure_class] -= nregs;\n+\t      cover_class = get_cover_class_and_nregs (inv->insn, &nregs);\n+\t      aregs_needed[cover_class] -= nregs;\n \t    }\n \t}\n \n       if (! flag_ira_loop_pressure)\n \tregs_needed[0] += aregs_needed[0];\n       else\n \t{\n-\t  for (i = 0; i < ira_pressure_classes_num; i++)\n-\t    regs_needed[ira_pressure_classes[i]]\n-\t      += aregs_needed[ira_pressure_classes[i]];\n+\t  for (i = 0; i < ira_reg_class_cover_size; i++)\n+\t    regs_needed[ira_reg_class_cover[i]]\n+\t      += aregs_needed[ira_reg_class_cover[i]];\n \t}\n       (*comp_cost) += acomp_cost;\n     }\n@@ -1201,19 +1197,19 @@ gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n   else\n     {\n       int i;\n-      enum reg_class pressure_class;\n+      enum reg_class cover_class;\n \n-      for (i = 0; i < ira_pressure_classes_num; i++)\n+      for (i = 0; i < ira_reg_class_cover_size; i++)\n \t{\n-\t  pressure_class = ira_pressure_classes[i];\n-\t  if ((int) new_regs[pressure_class]\n-\t      + (int) regs_needed[pressure_class]\n-\t      + LOOP_DATA (curr_loop)->max_reg_pressure[pressure_class]\n+\t  cover_class = ira_reg_class_cover[i];\n+\t  if ((int) new_regs[cover_class]\n+\t      + (int) regs_needed[cover_class]\n+\t      + LOOP_DATA (curr_loop)->max_reg_pressure[cover_class]\n \t      + IRA_LOOP_RESERVED_REGS\n-\t      > ira_available_class_regs[pressure_class])\n+\t      > ira_available_class_regs[cover_class])\n \t    break;\n \t}\n-      if (i < ira_pressure_classes_num)\n+      if (i < ira_reg_class_cover_size)\n \t/* There will be register pressure excess and we want not to\n \t   make this loop invariant motion.  All loop invariants with\n \t   non-positive gains will be rejected in function\n@@ -1277,9 +1273,9 @@ best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n \t    regs_needed[0] = aregs_needed[0];\n \t  else\n \t    {\n-\t      for (i = 0; i < ira_pressure_classes_num; i++)\n-\t\tregs_needed[ira_pressure_classes[i]]\n-\t\t  = aregs_needed[ira_pressure_classes[i]];\n+\t      for (i = 0; i < ira_reg_class_cover_size; i++)\n+\t\tregs_needed[ira_reg_class_cover[i]]\n+\t\t  = aregs_needed[ira_reg_class_cover[i]];\n \t    }\n \t}\n     }\n@@ -1356,8 +1352,8 @@ find_invariants_to_move (bool speed, bool call_p)\n     new_regs[0] = regs_needed[0] = 0;\n   else\n     {\n-      for (i = 0; (int) i < ira_pressure_classes_num; i++)\n-\tnew_regs[ira_pressure_classes[i]] = 0;\n+      for (i = 0; (int) i < ira_reg_class_cover_size; i++)\n+\tnew_regs[ira_reg_class_cover[i]] = 0;\n     }\n   while ((gain = best_gain_for_invariant (&inv, regs_needed,\n \t\t\t\t\t  new_regs, regs_used,\n@@ -1368,9 +1364,9 @@ find_invariants_to_move (bool speed, bool call_p)\n \tnew_regs[0] += regs_needed[0];\n       else\n \t{\n-\t  for (i = 0; (int) i < ira_pressure_classes_num; i++)\n-\t    new_regs[ira_pressure_classes[i]]\n-\t      += regs_needed[ira_pressure_classes[i]];\n+\t  for (i = 0; (int) i < ira_reg_class_cover_size; i++)\n+\t    new_regs[ira_reg_class_cover[i]]\n+\t      += regs_needed[ira_reg_class_cover[i]];\n \t}\n     }\n }\n@@ -1523,7 +1519,7 @@ move_invariants (struct loop *loop)\n \t      setup_reg_classes (REGNO (inv->reg),\n \t\t\t\t reg_preferred_class (inv->orig_regno),\n \t\t\t\t reg_alternate_class (inv->orig_regno),\n-\t\t\t\t reg_allocno_class (inv->orig_regno));\n+\t\t\t\t reg_cover_class (inv->orig_regno));\n \t    else\n \t      setup_reg_classes (REGNO (inv->reg),\n \t\t\t\t GENERAL_REGS, NO_REGS, GENERAL_REGS);\n@@ -1608,7 +1604,7 @@ free_loop_data (struct loop *loop)\n /* Registers currently living.  */\n static bitmap_head curr_regs_live;\n \n-/* Current reg pressure for each pressure class.  */\n+/* Current reg pressure for each cover class.  */\n static int curr_reg_pressure[N_REG_CLASSES];\n \n /* Record all regs that are set in any one insn.  Communication from\n@@ -1619,26 +1615,23 @@ static rtx regs_set[(FIRST_PSEUDO_REGISTER > MAX_RECOG_OPERANDS\n /* Number of regs stored in the previous array.  */\n static int n_regs_set;\n \n-/* Return pressure class and number of needed hard registers (through\n+/* Return cover class and number of needed hard registers (through\n    *NREGS) of register REGNO.  */\n static enum reg_class\n-get_regno_pressure_class (int regno, int *nregs)\n+get_regno_cover_class (int regno, int *nregs)\n {\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n-      enum reg_class pressure_class;\n+      enum reg_class cover_class = reg_cover_class (regno);\n \n-      pressure_class = reg_allocno_class (regno);\n-      pressure_class = ira_pressure_class_translate[pressure_class];\n-      *nregs\n-\t= ira_reg_class_max_nregs[pressure_class][PSEUDO_REGNO_MODE (regno)];\n-      return pressure_class;\n+      *nregs = ira_reg_class_nregs[cover_class][PSEUDO_REGNO_MODE (regno)];\n+      return cover_class;\n     }\n   else if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno)\n \t   && ! TEST_HARD_REG_BIT (eliminable_regset, regno))\n     {\n       *nregs = 1;\n-      return ira_pressure_class_translate[REGNO_REG_CLASS (regno)];\n+      return ira_class_translate[REGNO_REG_CLASS (regno)];\n     }\n   else\n     {\n@@ -1653,18 +1646,18 @@ static void\n change_pressure (int regno, bool incr_p)\n {\n   int nregs;\n-  enum reg_class pressure_class;\n+  enum reg_class cover_class;\n \n-  pressure_class = get_regno_pressure_class (regno, &nregs);\n+  cover_class = get_regno_cover_class (regno, &nregs);\n   if (! incr_p)\n-    curr_reg_pressure[pressure_class] -= nregs;\n+    curr_reg_pressure[cover_class] -= nregs;\n   else\n     {\n-      curr_reg_pressure[pressure_class] += nregs;\n-      if (LOOP_DATA (curr_loop)->max_reg_pressure[pressure_class]\n-\t  < curr_reg_pressure[pressure_class])\n-\tLOOP_DATA (curr_loop)->max_reg_pressure[pressure_class]\n-\t  = curr_reg_pressure[pressure_class];\n+      curr_reg_pressure[cover_class] += nregs;\n+      if (LOOP_DATA (curr_loop)->max_reg_pressure[cover_class]\n+\t  < curr_reg_pressure[cover_class])\n+\tLOOP_DATA (curr_loop)->max_reg_pressure[cover_class]\n+\t  = curr_reg_pressure[cover_class];\n     }\n }\n \n@@ -1820,8 +1813,8 @@ calculate_loop_reg_pressure (void)\n \tbitmap_ior_into (&LOOP_DATA (loop)->regs_live, DF_LR_IN (bb));\n \n       bitmap_copy (&curr_regs_live, DF_LR_IN (bb));\n-      for (i = 0; i < ira_pressure_classes_num; i++)\n-\tcurr_reg_pressure[ira_pressure_classes[i]] = 0;\n+      for (i = 0; i < ira_reg_class_cover_size; i++)\n+\tcurr_reg_pressure[ira_reg_class_cover[i]] = 0;\n       EXECUTE_IF_SET_IN_BITMAP (&curr_regs_live, 0, j, bi)\n \tchange_pressure (j, true);\n \n@@ -1871,11 +1864,11 @@ calculate_loop_reg_pressure (void)\n \tEXECUTE_IF_SET_IN_BITMAP (&LOOP_DATA (loop)->regs_live, 0, j, bi)\n \t  if (! bitmap_bit_p (&LOOP_DATA (loop)->regs_ref, j))\n \t    {\n-\t      enum reg_class pressure_class;\n+\t      enum reg_class cover_class;\n \t      int nregs;\n \n-\t      pressure_class = get_regno_pressure_class (j, &nregs);\n-\t      LOOP_DATA (loop)->max_reg_pressure[pressure_class] -= nregs;\n+\t      cover_class = get_regno_cover_class (j, &nregs);\n+\t      LOOP_DATA (loop)->max_reg_pressure[cover_class] -= nregs;\n \t    }\n       }\n   if (dump_file == NULL)\n@@ -1893,15 +1886,15 @@ calculate_loop_reg_pressure (void)\n       EXECUTE_IF_SET_IN_BITMAP (&LOOP_DATA (loop)->regs_live, 0, j, bi)\n \tfprintf (dump_file, \" %d\", j);\n       fprintf (dump_file, \"\\n    Pressure:\");\n-      for (i = 0; (int) i < ira_pressure_classes_num; i++)\n+      for (i = 0; (int) i < ira_reg_class_cover_size; i++)\n \t{\n-\t  enum reg_class pressure_class;\n+\t  enum reg_class cover_class;\n \n-\t  pressure_class = ira_pressure_classes[i];\n-\t  if (LOOP_DATA (loop)->max_reg_pressure[pressure_class] == 0)\n+\t  cover_class = ira_reg_class_cover[i];\n+\t  if (LOOP_DATA (loop)->max_reg_pressure[cover_class] == 0)\n \t    continue;\n-\t  fprintf (dump_file, \" %s=%d\", reg_class_names[pressure_class],\n-\t\t   LOOP_DATA (loop)->max_reg_pressure[pressure_class]);\n+\t  fprintf (dump_file, \" %s=%d\", reg_class_names[cover_class],\n+\t\t   LOOP_DATA (loop)->max_reg_pressure[cover_class]);\n \t}\n       fprintf (dump_file, \"\\n\");\n     }\n@@ -1920,10 +1913,8 @@ move_loop_invariants (void)\n   if (flag_ira_loop_pressure)\n     {\n       df_analyze ();\n-      regstat_init_n_sets_and_refs ();\n       ira_set_pseudo_classes (dump_file);\n       calculate_loop_reg_pressure ();\n-      regstat_free_n_sets_and_refs ();\n     }\n   df_set_flags (DF_EQ_NOTES + DF_DEFER_INSN_RESCAN);\n   /* Process the loops, innermost first.  */"}, {"sha": "165d7ec3a553113971b9ffe5f683ad75fa2e52f4", "filename": "gcc/opts.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -289,6 +289,11 @@ init_options_struct (struct gcc_options *opts, struct gcc_options *opts_set)\n   opts_set->x_param_values = XCNEWVEC (int, num_params);\n   init_param_values (opts->x_param_values);\n \n+  /* Use priority coloring if cover classes is not defined for the\n+     target.  */\n+  if (targetm.ira_cover_classes == NULL)\n+    opts->x_flag_ira_algorithm = IRA_ALGORITHM_PRIORITY;\n+\n   /* Initialize whether `char' is signed.  */\n   opts->x_flag_signed_char = DEFAULT_SIGNED_CHAR;\n   /* Set this to a special \"uninitialized\" value.  The actual default\n@@ -753,6 +758,14 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n   if (!opts->x_flag_sel_sched_pipelining)\n     opts->x_flag_sel_sched_pipelining_outer_loops = 0;\n \n+  if (!targetm.ira_cover_classes\n+      && opts->x_flag_ira_algorithm == IRA_ALGORITHM_CB)\n+    {\n+      inform (loc,\n+\t      \"-fira-algorithm=CB does not work on this architecture\");\n+      opts->x_flag_ira_algorithm = IRA_ALGORITHM_PRIORITY;\n+    }\n+\n   if (opts->x_flag_conserve_stack)\n     {\n       maybe_set_param_value (PARAM_LARGE_STACK_FRAME, 100,"}, {"sha": "83ac4499b517ae59be6e237c7bac533eaaebe678", "filename": "gcc/reginfo.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -890,9 +890,9 @@ struct reg_pref\n      union of most major pair of classes, that generality is not required.  */\n   char altclass;\n \n-  /* allocnoclass is a register class that IRA uses for allocating\n+  /* coverclass is a register class that IRA uses for allocating\n      the pseudo.  */\n-  char allocnoclass;\n+  char coverclass;\n };\n \n /* Record preferences of each pseudo.  This is available after RA is\n@@ -925,12 +925,12 @@ reg_alternate_class (int regno)\n \n /* Return the reg_class which is used by IRA for its allocation.  */\n enum reg_class\n-reg_allocno_class (int regno)\n+reg_cover_class (int regno)\n {\n   if (reg_pref == 0)\n     return NO_REGS;\n \n-  return (enum reg_class) reg_pref[regno].allocnoclass;\n+  return (enum reg_class) reg_pref[regno].coverclass;\n }\n \n \f\n@@ -1027,18 +1027,18 @@ struct rtl_opt_pass pass_reginfo_init =\n \f\n \n /* Set up preferred, alternate, and cover classes for REGNO as\n-   PREFCLASS, ALTCLASS, and ALLOCNOCLASS.  */\n+   PREFCLASS, ALTCLASS, and COVERCLASS.  */\n void\n setup_reg_classes (int regno,\n \t\t   enum reg_class prefclass, enum reg_class altclass,\n-\t\t   enum reg_class allocnoclass)\n+\t\t   enum reg_class coverclass)\n {\n   if (reg_pref == NULL)\n     return;\n   gcc_assert (reg_info_size == max_reg_num ());\n   reg_pref[regno].prefclass = prefclass;\n   reg_pref[regno].altclass = altclass;\n-  reg_pref[regno].allocnoclass = allocnoclass;\n+  reg_pref[regno].coverclass = coverclass;\n }\n \n \f"}, {"sha": "48a583fa2158f3ed826789e3946a75d464f0306a", "filename": "gcc/regmove.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -1236,12 +1236,12 @@ regmove_optimize (void)\n   df_note_add_problem ();\n   df_analyze ();\n \n-  regstat_init_n_sets_and_refs ();\n-  regstat_compute_ri ();\n-\n   if (flag_ira_loop_pressure)\n     ira_set_pseudo_classes (dump_file);\n \n+  regstat_init_n_sets_and_refs ();\n+  regstat_compute_ri ();\n+\n   regno_src_regno = XNEWVEC (int, nregs);\n   for (i = nregs; --i >= 0; )\n     regno_src_regno[i] = -1;"}, {"sha": "73739c4f781b1c70c332ed6e273f772f36859fa3", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -1992,7 +1992,7 @@ extern const char *decode_asm_operands (rtx, rtx *, rtx **, const char **,\n \n extern enum reg_class reg_preferred_class (int);\n extern enum reg_class reg_alternate_class (int);\n-extern enum reg_class reg_allocno_class (int);\n+extern enum reg_class reg_cover_class (int);\n extern void setup_reg_classes (int, enum reg_class, enum reg_class,\n \t\t\t       enum reg_class);\n "}, {"sha": "7293fc3c972c976365e04b94c8b561af8977ffdf", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -1821,10 +1821,10 @@ mark_insn_pseudo_birth (rtx insn, int regno, bool clobber_p, bool unused_p)\n   enum reg_class cl;\n \n   gcc_assert (regno >= FIRST_PSEUDO_REGISTER);\n-  cl = sched_regno_pressure_class[regno];\n+  cl = sched_regno_cover_class[regno];\n   if (cl != NO_REGS)\n     {\n-      incr = ira_reg_class_max_nregs[cl][PSEUDO_REGNO_MODE (regno)];\n+      incr = ira_reg_class_nregs[cl][PSEUDO_REGNO_MODE (regno)];\n       if (clobber_p)\n \t{\n \t  new_incr = reg_pressure_info[cl].clobber_increase + incr;\n@@ -1861,7 +1861,7 @@ mark_insn_hard_regno_birth (rtx insn, int regno, int nregs,\n       gcc_assert (regno < FIRST_PSEUDO_REGISTER);\n       if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n \t{\n-\t  cl = sched_regno_pressure_class[regno];\n+\t  cl = sched_regno_cover_class[regno];\n \t  if (cl != NO_REGS)\n \t    {\n \t      if (clobber_p)\n@@ -1922,10 +1922,10 @@ mark_pseudo_death (int regno)\n   enum reg_class cl;\n \n   gcc_assert (regno >= FIRST_PSEUDO_REGISTER);\n-  cl = sched_regno_pressure_class[regno];\n+  cl = sched_regno_cover_class[regno];\n   if (cl != NO_REGS)\n     {\n-      incr = ira_reg_class_max_nregs[cl][PSEUDO_REGNO_MODE (regno)];\n+      incr = ira_reg_class_nregs[cl][PSEUDO_REGNO_MODE (regno)];\n       reg_pressure_info[cl].change -= incr;\n     }\n }\n@@ -1943,7 +1943,7 @@ mark_hard_regno_death (int regno, int nregs)\n       gcc_assert (regno < FIRST_PSEUDO_REGISTER);\n       if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n \t{\n-\t  cl = sched_regno_pressure_class[regno];\n+\t  cl = sched_regno_cover_class[regno];\n \t  if (cl != NO_REGS)\n \t    reg_pressure_info[cl].change -= 1;\n \t}\n@@ -2004,9 +2004,9 @@ setup_insn_reg_pressure_info (rtx insn)\n   if (! INSN_P (insn))\n     return;\n \n-  for (i = 0; i < ira_pressure_classes_num; i++)\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n-      cl = ira_pressure_classes[i];\n+      cl = ira_reg_class_cover[i];\n       reg_pressure_info[cl].clobber_increase = 0;\n       reg_pressure_info[cl].set_increase = 0;\n       reg_pressure_info[cl].unused_set_increase = 0;\n@@ -2027,14 +2027,14 @@ setup_insn_reg_pressure_info (rtx insn)\n     if (REG_NOTE_KIND (link) == REG_DEAD)\n       mark_reg_death (XEXP (link, 0));\n \n-  len = sizeof (struct reg_pressure_data) * ira_pressure_classes_num;\n+  len = sizeof (struct reg_pressure_data) * ira_reg_class_cover_size;\n   pressure_info\n     = INSN_REG_PRESSURE (insn) = (struct reg_pressure_data *) xmalloc (len);\n-  INSN_MAX_REG_PRESSURE (insn) = (int *) xcalloc (ira_pressure_classes_num\n+  INSN_MAX_REG_PRESSURE (insn) = (int *) xcalloc (ira_reg_class_cover_size\n \t\t\t\t\t\t  * sizeof (int), 1);\n-  for (i = 0; i < ira_pressure_classes_num; i++)\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n-      cl = ira_pressure_classes[i];\n+      cl = ira_reg_class_cover[i];\n       pressure_info[i].clobber_increase\n \t= reg_pressure_info[cl].clobber_increase;\n       pressure_info[i].set_increase = reg_pressure_info[cl].set_increase;"}, {"sha": "9077c881ce69a73c673286af9c40dab1c053b5ea", "filename": "gcc/sched-int.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -653,9 +653,9 @@ extern struct haifa_sched_info *current_sched_info;\n    up.  */\n extern bool sched_pressure_p;\n \n-/* Map regno -> its pressure class.  The map defined only when\n+/* Map regno -> its cover class.  The map defined only when\n    SCHED_PRESSURE_P is true.  */\n-extern enum reg_class *sched_regno_pressure_class;\n+extern enum reg_class *sched_regno_cover_class;\n \n /* Indexed by INSN_UID, the collection of all data associated with\n    a single instruction.  */\n@@ -707,7 +707,7 @@ struct _haifa_deps_insn_data\n #define INCREASE_BITS 8\n \n /* The structure describes how the corresponding insn increases the\n-   register pressure for each pressure class.  */\n+   register pressure for each cover class.  */\n struct reg_pressure_data\n {\n   /* Pressure increase for given class because of clobber.  */\n@@ -736,7 +736,7 @@ struct reg_use_data\n };\n \n /* The following structure describes used sets of registers by insns.\n-   Registers are pseudos whose pressure class is not NO_REGS or hard\n+   Registers are pseudos whose cover class is not NO_REGS or hard\n    registers available for allocations.  */\n struct reg_set_data\n {\n@@ -804,7 +804,7 @@ struct _haifa_insn_data\n   struct reg_pressure_data *reg_pressure;\n   /* The following array contains maximal reg pressure between last\n      scheduled insn and given insn.  There is an element for each\n-     pressure class of pseudos referenced in insns.  This info updated\n+     cover class of pseudos referenced in insns.  This info updated\n      after scheduling each insn for each insn between the two\n      mentioned insns.  */\n   int *max_reg_pressure;"}, {"sha": "630b4283b31ae48a2bce0d9438e6a291162a3574", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -829,7 +829,7 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tHANDLE_SYSV_PRAGMA HANDLE_PRAGMA_WEAK CONDITIONAL_REGISTER_USAGE   \\\n \tFUNCTION_ARG_BOUNDARY MUST_USE_SJLJ_EXCEPTIONS US_SOFTWARE_GOFAST  \\\n \tUSING_SVR4_H SVR4_ASM_SPEC FUNCTION_ARG FUNCTION_ARG_ADVANCE\t   \\\n-\tFUNCTION_INCOMING_ARG IRA_COVER_CLASSES\n+\tFUNCTION_INCOMING_ARG\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\\n@@ -840,8 +840,7 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tLANG_HOOKS_POPLEVEL LANG_HOOKS_TRUTHVALUE_CONVERSION \\\n \tTARGET_PROMOTE_FUNCTION_ARGS TARGET_PROMOTE_FUNCTION_RETURN \\\n \tLANG_HOOKS_MISSING_ARGUMENT LANG_HOOKS_HASH_TYPES \\\n-\tTARGET_HANDLE_OFAST TARGET_OPTION_OPTIMIZATION \\\n-        TARGET_IRA_COVER_CLASSES\n+\tTARGET_HANDLE_OFAST TARGET_OPTION_OPTIMIZATION\n \n /* Hooks into libgcc2.  */\n  #pragma GCC poison LIBGCC2_DOUBLE_TYPE_SIZE LIBGCC2_WORDS_BIG_ENDIAN \\"}, {"sha": "123173505405b2c2c451ae5136424f881db8bee0", "filename": "gcc/target-def.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -104,6 +104,10 @@\n \t\t\tTARGET_ASM_UNALIGNED_DI_OP,\t\t\\\n \t\t\tTARGET_ASM_UNALIGNED_TI_OP}\n \n+#ifndef IRA_COVER_CLASSES\n+#define TARGET_IRA_COVER_CLASSES 0\n+#endif\n+\n #if !defined (TARGET_FUNCTION_INCOMING_ARG)\n #define TARGET_FUNCTION_INCOMING_ARG TARGET_FUNCTION_ARG\n #endif"}, {"sha": "584bb7df52eae8f7634e3cdea5edb05dddf6a84a", "filename": "gcc/target.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -2224,6 +2224,13 @@ DEFHOOK\n  tree, (tree type, tree expr),\n  hook_tree_tree_tree_null)\n \n+/* Return the array of IRA cover classes for the current target.  */\n+DEFHOOK\n+(ira_cover_classes,\n+ \"\",\n+ const reg_class_t *, (void),\n+ default_ira_cover_classes)\n+\n /* Return the class for a secondary reload, and fill in extra information.  */\n DEFHOOK\n (secondary_reload,"}, {"sha": "f36a15e540ea9b9ab5ad999f557cd80771548824", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -841,6 +841,15 @@ default_branch_target_register_class (void)\n   return NO_REGS;\n }\n \n+#ifdef IRA_COVER_CLASSES\n+const reg_class_t *\n+default_ira_cover_classes (void)\n+{\n+  static reg_class_t classes[] = IRA_COVER_CLASSES;\n+  return classes;\n+}\n+#endif\n+\n reg_class_t\n default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n \t\t\t  reg_class_t reload_class_i ATTRIBUTE_UNUSED,"}, {"sha": "a2d2075ea35a5b93ba7a22f87e9314ce07328c0a", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99710245becabdfa97984d1f68a01f9876124417/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99710245becabdfa97984d1f68a01f9876124417/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=99710245becabdfa97984d1f68a01f9876124417", "patch": "@@ -124,6 +124,9 @@ extern rtx default_static_chain (const_tree, bool);\n extern void default_trampoline_init (rtx, tree, rtx);\n extern int default_return_pops_args (tree, tree, int);\n extern reg_class_t default_branch_target_register_class (void);\n+#ifdef IRA_COVER_CLASSES\n+extern const reg_class_t *default_ira_cover_classes (void);\n+#endif\n extern reg_class_t default_secondary_reload (bool, rtx, reg_class_t,\n \t\t\t\t\t     enum machine_mode,\n \t\t\t\t\t     secondary_reload_info *);"}]}