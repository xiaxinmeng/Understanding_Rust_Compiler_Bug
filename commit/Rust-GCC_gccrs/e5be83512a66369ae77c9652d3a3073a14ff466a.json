{"sha": "e5be83512a66369ae77c9652d3a3073a14ff466a", "node_id": "C_kwDOANBUbNoAKGU1YmU4MzUxMmE2NjM2OWFlNzdjOTY1MmQzYTMwNzNhMTRmZjQ2NmE", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2021-12-16T15:42:36Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-11T13:24:46Z"}, "message": "[Ada] Proof of System.Vectors.Boolean_Operations\n\ngcc/ada/\n\n\t* libgnat/s-veboop.adb: Add ghost code for proof.\n\t* libgnat/s-veboop.ads: Add specification.", "tree": {"sha": "ec60839541fd858f961dab3436fec0adb2e5fb74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec60839541fd858f961dab3436fec0adb2e5fb74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5be83512a66369ae77c9652d3a3073a14ff466a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5be83512a66369ae77c9652d3a3073a14ff466a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5be83512a66369ae77c9652d3a3073a14ff466a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5be83512a66369ae77c9652d3a3073a14ff466a/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb8e35819dada2d120817c9dae95703c0bb5841b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb8e35819dada2d120817c9dae95703c0bb5841b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb8e35819dada2d120817c9dae95703c0bb5841b"}], "stats": {"total": 217, "additions": 207, "deletions": 10}, "files": [{"sha": "7bb0b5eebdd83aec02982ecb0d64c715652b74eb", "filename": "gcc/ada/libgnat/s-veboop.adb", "status": "modified", "additions": 105, "deletions": 1, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5be83512a66369ae77c9652d3a3073a14ff466a/gcc%2Fada%2Flibgnat%2Fs-veboop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5be83512a66369ae77c9652d3a3073a14ff466a/gcc%2Fada%2Flibgnat%2Fs-veboop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-veboop.adb?ref=e5be83512a66369ae77c9652d3a3073a14ff466a", "patch": "@@ -29,7 +29,17 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body System.Vectors.Boolean_Operations is\n+--  Ghost code, loop invariants and assertions in this unit are meant for\n+--  analysis only, not for run-time checking, as it would be too costly\n+--  otherwise. This is enforced by setting the assertion policy to Ignore.\n+\n+pragma Assertion_Policy (Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n+package body System.Vectors.Boolean_Operations\n+  with SPARK_Mode\n+is\n \n    SU : constant := Storage_Unit;\n    --  Convenient short hand, used throughout\n@@ -76,7 +86,26 @@ package body System.Vectors.Boolean_Operations is\n    -----------\n \n    function \"not\" (Item : Vectors.Vector) return Vectors.Vector is\n+\n+      procedure Prove_Not (Result : Vectors.Vector)\n+      with\n+        Ghost,\n+        Pre  => Valid (Item)\n+          and then Result = (Item xor True_Val),\n+        Post => Valid (Result)\n+          and then (for all J in 1 .. Vector_Boolean_Size =>\n+                      Model (Result) (J) = not Model (Item) (J));\n+\n+      procedure Prove_Not (Result : Vectors.Vector) is\n+      begin\n+         for J in 1 .. Vector_Boolean_Size loop\n+            pragma Assert\n+              (Element (Result, J) = 1 - Element (Item, J));\n+         end loop;\n+      end Prove_Not;\n+\n    begin\n+      Prove_Not (Item xor True_Val);\n       return Item xor True_Val;\n    end \"not\";\n \n@@ -90,7 +119,32 @@ package body System.Vectors.Boolean_Operations is\n    end Nand;\n \n    function Nand (Left, Right : Vectors.Vector) return Vectors.Vector is\n+\n+      procedure Prove_And (Result : Vectors.Vector)\n+      with\n+        Ghost,\n+        Pre  => Valid (Left)\n+          and then Valid (Right)\n+          and then Result = (Left and Right),\n+          Post => Valid (Result)\n+            and then (for all J in 1 .. Vector_Boolean_Size =>\n+                        Model (Result) (J) =\n+                          (Model (Left) (J) and Model (Right) (J)));\n+\n+      procedure Prove_And (Result : Vectors.Vector) is\n+      begin\n+         for J in 1 .. Vector_Boolean_Size loop\n+            pragma Assert\n+              (Element (Result, J) =\n+                 (if Element (Left, J) = 1\n+                    and Element (Right, J) = 1\n+                  then 1\n+                  else 0));\n+         end loop;\n+      end Prove_And;\n+\n    begin\n+      Prove_And (Left and Right);\n       return not (Left and Right);\n    end Nand;\n \n@@ -104,7 +158,32 @@ package body System.Vectors.Boolean_Operations is\n    end Nor;\n \n    function Nor (Left, Right : Vectors.Vector) return Vectors.Vector is\n+\n+      procedure Prove_Or (Result : Vectors.Vector)\n+      with\n+        Ghost,\n+        Pre  => Valid (Left)\n+          and then Valid (Right)\n+          and then Result = (Left or Right),\n+          Post => Valid (Result)\n+            and then (for all J in 1 .. Vector_Boolean_Size =>\n+                        Model (Result) (J) =\n+                          (Model (Left) (J) or Model (Right) (J)));\n+\n+      procedure Prove_Or (Result : Vectors.Vector) is\n+      begin\n+         for J in 1 .. Vector_Boolean_Size loop\n+            pragma Assert\n+              (Element (Result, J) =\n+                 (if Element (Left, J) = 1\n+                    or Element (Right, J) = 1\n+                  then 1\n+                  else 0));\n+         end loop;\n+      end Prove_Or;\n+\n    begin\n+      Prove_Or (Left or Right);\n       return not (Left or Right);\n    end Nor;\n \n@@ -118,7 +197,32 @@ package body System.Vectors.Boolean_Operations is\n    end Nxor;\n \n    function Nxor (Left, Right : Vectors.Vector) return Vectors.Vector is\n+\n+      procedure Prove_Xor (Result : Vectors.Vector)\n+      with\n+        Ghost,\n+        Pre  => Valid (Left)\n+          and then Valid (Right)\n+          and then Result = (Left xor Right),\n+          Post => Valid (Result)\n+            and then (for all J in 1 .. Vector_Boolean_Size =>\n+                        Model (Result) (J) =\n+                          (Model (Left) (J) xor Model (Right) (J)));\n+\n+      procedure Prove_Xor (Result : Vectors.Vector) is\n+      begin\n+         for J in 1 .. Vector_Boolean_Size loop\n+            pragma Assert\n+              (Element (Result, J) =\n+                 (if Element (Left, J) = 1\n+                    xor Element (Right, J) = 1\n+                  then 1\n+                  else 0));\n+         end loop;\n+      end Prove_Xor;\n+\n    begin\n+      Prove_Xor (Left xor Right);\n       return not (Left xor Right);\n    end Nxor;\n "}, {"sha": "461475947e58c7a2ae45125585a2a4e0094c9bc3", "filename": "gcc/ada/libgnat/s-veboop.ads", "status": "modified", "additions": 102, "deletions": 9, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5be83512a66369ae77c9652d3a3073a14ff466a/gcc%2Fada%2Flibgnat%2Fs-veboop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5be83512a66369ae77c9652d3a3073a14ff466a/gcc%2Fada%2Flibgnat%2Fs-veboop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-veboop.ads?ref=e5be83512a66369ae77c9652d3a3073a14ff466a", "patch": "@@ -31,15 +31,77 @@\n \n --  This package contains functions for runtime operations on boolean vectors\n \n-package System.Vectors.Boolean_Operations is\n-   pragma Pure;\n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Contract_Cases => Ignore,\n+                         Ghost          => Ignore);\n+\n+package System.Vectors.Boolean_Operations\n+  with Pure, SPARK_Mode\n+is\n+   pragma Warnings (Off, \"aspect \"\"Pre\"\" not enforced on inlined subprogram\",\n+                    Reason => \"Pre only used in proof\");\n+   pragma Warnings (Off, \"aspect \"\"Post\"\" not enforced on inlined subprogram\",\n+                    Reason => \"Post only used in proof\");\n+\n+   --  Type Vectors.Vector represents an array of Boolean, each of which\n+   --  takes 8 bits of the representation, with the 7 msb set to zero. Express\n+   --  in contracts the constraint on valid vectors and the model that they\n+   --  represent, and the relationship between input models and output model.\n+\n+   Vector_Boolean_Size : constant Positive :=\n+     System.Word_Size / System.Storage_Unit\n+   with Ghost;\n+\n+   type Vector_Element is mod 2 ** System.Storage_Unit with Ghost;\n+\n+   type Vector_Boolean_Array is array (1 .. Vector_Boolean_Size) of Boolean\n+   with Ghost;\n+\n+   function Shift_Right (V : Vectors.Vector; N : Natural) return Vectors.Vector\n+   with Ghost, Import, Convention => Intrinsic;\n+\n+   function Element (V : Vectors.Vector; N : Positive) return Vector_Element is\n+     (Vector_Element (Shift_Right (V, (N - 1) * System.Storage_Unit)\n+                        and (2 ** System.Storage_Unit - 1)))\n+   with\n+     Ghost,\n+     Pre => N <= Vector_Boolean_Size;\n+   --  Return the Nth element represented by the vector\n+\n+   function Valid (V : Vectors.Vector) return Boolean is\n+     (for all J in 1 .. Vector_Boolean_Size =>\n+        Element (V, J) in 0 .. 1)\n+   with Ghost;\n+   --  A valid vector is one for which all elements are 0 (representing False)\n+   --  or 1 (representing True).\n+\n+   function Model (V : Vectors.Vector) return Vector_Boolean_Array\n+   with\n+     Ghost,\n+     Pre => Valid (V);\n+\n+   function Model (V : Vectors.Vector) return Vector_Boolean_Array is\n+     (for J in 1 .. Vector_Boolean_Size => Element (V, J) = 1);\n+   --  The model of a valid vector is the corresponding array of Boolean values\n \n    --  Although in general the boolean operations on arrays of booleans are\n    --  identical to operations on arrays of unsigned words of the same size,\n    --  for the \"not\" operator this is not the case as False is typically\n    --  represented by 0 and true by 1.\n \n-   function \"not\" (Item : Vectors.Vector) return Vectors.Vector;\n+   function \"not\" (Item : Vectors.Vector) return Vectors.Vector\n+   with\n+     Pre  => Valid (Item),\n+     Post => Valid (\"not\"'Result)\n+       and then (for all J in 1 .. Vector_Boolean_Size =>\n+                   Model (\"not\"'Result) (J) = not Model (Item) (J));\n \n    --  The three boolean operations \"nand\", \"nor\" and \"nxor\" are needed\n    --  for cases where the compiler moves boolean array operations into\n@@ -51,13 +113,44 @@ package System.Vectors.Boolean_Operations is\n    --    (not X) xor (not Y)  =  X xor Y\n    --    X       xor (not Y)  =  not (X xor Y)  =  Nxor (X, Y)\n \n-   function Nand (Left, Right : Boolean) return Boolean;\n-   function Nor  (Left, Right : Boolean) return Boolean;\n-   function Nxor (Left, Right : Boolean) return Boolean;\n+   function Nand (Left, Right : Boolean) return Boolean\n+   with\n+     Post => Nand'Result = not (Left and Right);\n+\n+   function Nor  (Left, Right : Boolean) return Boolean\n+   with\n+     Post => Nor'Result = not (Left or Right);\n+\n+   function Nxor (Left, Right : Boolean) return Boolean\n+   with\n+     Post => Nxor'Result = not (Left xor Right);\n+\n+   function Nand (Left, Right : Vectors.Vector) return Vectors.Vector\n+   with\n+     Pre  => Valid (Left)\n+       and then Valid (Right),\n+     Post => Valid (Nand'Result)\n+       and then (for all J in 1 .. Vector_Boolean_Size =>\n+                   Model (Nand'Result) (J) =\n+                     Nand (Model (Left) (J), Model (Right) (J)));\n+\n+   function Nor (Left, Right : Vectors.Vector) return Vectors.Vector\n+   with\n+     Pre  => Valid (Left)\n+       and then Valid (Right),\n+     Post => Valid (Nor'Result)\n+       and then (for all J in 1 .. Vector_Boolean_Size =>\n+                   Model (Nor'Result) (J) =\n+                     Nor (Model (Left) (J), Model (Right) (J)));\n \n-   function Nand (Left, Right : Vectors.Vector) return Vectors.Vector;\n-   function Nor (Left, Right : Vectors.Vector) return Vectors.Vector;\n-   function Nxor (Left, Right : Vectors.Vector) return Vectors.Vector;\n+   function Nxor (Left, Right : Vectors.Vector) return Vectors.Vector\n+   with\n+     Pre  => Valid (Left)\n+       and then Valid (Right),\n+     Post => Valid (Nxor'Result)\n+       and then (for all J in 1 .. Vector_Boolean_Size =>\n+                   Model (Nxor'Result) (J) =\n+                     Nxor (Model (Left) (J), Model (Right) (J)));\n \n    pragma Inline_Always (\"not\");\n    pragma Inline_Always (Nand);"}]}