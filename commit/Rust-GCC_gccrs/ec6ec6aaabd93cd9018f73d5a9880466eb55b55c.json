{"sha": "ec6ec6aaabd93cd9018f73d5a9880466eb55b55c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM2ZWM2YWFhYmQ5M2NkOTAxOGY3M2Q1YTk4ODA0NjZlYjU1YjU1Yw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-09-15T01:55:53Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2003-09-15T01:55:53Z"}, "message": "re PR rtl-optimization/10914 (unswitch loops does not work on powerpc)\n\n2003-09-12  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n\n        PR optimization/10914\n        * expr.h (get_condition, canonicalize_condition): Declaration changed.\n        * cfgloopanal.c (simple_loop_exit_p): Add parameter to a get_condition\n        and canonicalize_condition calls.\n        * gcse.c (fis_get_condition, delete_null_pointer_checks_1,\n        delete_null_pointer_checks): Ditto.\n        * ifcvt.c (noce_get_alt_condition, noce_get_condition): Ditto.\n        * predict.c (estimate_probability, expected_value_to_br_prob): Ditto.\n        * loop.c (check_dbra_loop, get_condition_for_loop): Ditto.\n        (canonicalize_condition, get_condition): Allow to return comparisons\n        of cc mode registers.\n        * loop-unswitch.c (may_unswitch_on_p, unswitch_single_loop): Allow\n        cc mode registers comparison in condition.\n\nFrom-SVN: r71398", "tree": {"sha": "5fc7d2c4a708b456af258e9327bbdd9d5d81f936", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fc7d2c4a708b456af258e9327bbdd9d5d81f936"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/comments", "author": null, "committer": null, "parents": [{"sha": "a7e8c268ed44dd8f09259ba8000be311af7562e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e8c268ed44dd8f09259ba8000be311af7562e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e8c268ed44dd8f09259ba8000be311af7562e7"}], "stats": {"total": 73, "additions": 50, "deletions": 23}, "files": [{"sha": "362e6d56b331637ff6fe949e4b1464253502721e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec6ec6aaabd93cd9018f73d5a9880466eb55b55c", "patch": "@@ -1,3 +1,19 @@\n+2003-09-12  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\tPR optimization/10914\n+\t* expr.h (get_condition, canonicalize_condition): Declaration changed.\n+\t* cfgloopanal.c (simple_loop_exit_p): Add parameter to a get_condition\n+\tand canonicalize_condition calls.\n+\t* gcse.c (fis_get_condition, delete_null_pointer_checks_1,\n+\tdelete_null_pointer_checks): Ditto.\n+\t* ifcvt.c (noce_get_alt_condition, noce_get_condition): Ditto.\n+\t* predict.c (estimate_probability, expected_value_to_br_prob): Ditto.\n+\t* loop.c (check_dbra_loop, get_condition_for_loop): Ditto.\n+\t(canonicalize_condition, get_condition): Allow to return comparisons\n+\tof cc mode registers.\n+\t* loop-unswitch.c (may_unswitch_on_p, unswitch_single_loop): Allow\n+\tcc mode registers comparison in condition.\n+\n 2003-09-12  Mark Mitchell  <mark@codesourcery.com>\n \n \t* coverage.c (create_coverage): Do not call pushlevel/poplevel."}, {"sha": "68dd928233344f3af3c7e72f427bc94be25c2f48", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=ec6ec6aaabd93cd9018f73d5a9880466eb55b55c", "patch": "@@ -775,7 +775,7 @@ simple_loop_exit_p (struct loops *loops, struct loop *loop, edge exit_edge,\n \n   /* Condition must be a simple comparison in that one of operands\n      is register and the other one is invariant.  */\n-  if (!(condition = get_condition (exit_bb->end, NULL)))\n+  if (!(condition = get_condition (exit_bb->end, NULL, false)))\n     return false;\n \n   if (!simple_condition_p (loop, condition, invariant_regs, desc))"}, {"sha": "2037119df34da506f0b675f5ccb477ef417e5aae", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ec6ec6aaabd93cd9018f73d5a9880466eb55b55c", "patch": "@@ -317,11 +317,11 @@ extern rtx emit_store_flag_force (rtx, enum rtx_code, rtx, rtx,\n \n /* Given an insn and condition, return a canonical description of\n    the test being made.  */\n-extern rtx canonicalize_condition (rtx, rtx, int, rtx *, rtx);\n+extern rtx canonicalize_condition (rtx, rtx, int, rtx *, rtx, int);\n \n /* Given a JUMP_INSN, return a canonical description of the test\n    being made.  */\n-extern rtx get_condition (rtx, rtx *);\n+extern rtx get_condition (rtx, rtx *, int);\n \n /* Generate a conditional trap instruction.  */\n extern rtx gen_cond_trap (enum rtx_code, rtx, rtx, rtx);"}, {"sha": "3ea5411e17a0abf63821865bb5f08bba867621b3", "filename": "gcc/gcse.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=ec6ec6aaabd93cd9018f73d5a9880466eb55b55c", "patch": "@@ -4480,7 +4480,8 @@ fis_get_condition (rtx jump)\n \n   /* Use canonicalize_condition to do the dirty work of manipulating\n      MODE_CC values and COMPARE rtx codes.  */\n-  tmp = canonicalize_condition (jump, cond, reverse, &earliest, NULL_RTX);\n+  tmp = canonicalize_condition (jump, cond, reverse, &earliest, NULL_RTX,\n+\t\t\t\tfalse);\n   if (!tmp)\n     return NULL_RTX;\n \n@@ -4498,7 +4499,8 @@ fis_get_condition (rtx jump)\n   tmp = XEXP (tmp, 0);\n   if (!REG_P (tmp) || GET_MODE_CLASS (GET_MODE (tmp)) != MODE_INT)\n     return NULL_RTX;\n-  tmp = canonicalize_condition (jump, cond, reverse, &earliest, tmp);\n+  tmp = canonicalize_condition (jump, cond, reverse, &earliest, tmp,\n+\t\t\t\tfalse);\n   if (!tmp)\n     return NULL_RTX;\n \n@@ -5880,7 +5882,7 @@ delete_null_pointer_checks_1 (unsigned int *block_reg, sbitmap *nonnull_avin,\n \tcontinue;\n \n       /* LAST_INSN is a conditional jump.  Get its condition.  */\n-      condition = get_condition (last_insn, &earliest);\n+      condition = get_condition (last_insn, &earliest, false);\n \n       /* If we can't determine the condition then skip.  */\n       if (! condition)\n@@ -5994,7 +5996,7 @@ delete_null_pointer_checks (rtx f ATTRIBUTE_UNUSED)\n \tcontinue;\n \n       /* LAST_INSN is a conditional jump.  Get its condition.  */\n-      condition = get_condition (last_insn, &earliest);\n+      condition = get_condition (last_insn, &earliest, false);\n \n       /* If we were unable to get the condition, or it is not an equality\n \t comparison against zero then there's nothing we can do.  */"}, {"sha": "782960bac664be0653f7552c5522a9674c8f9291", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ec6ec6aaabd93cd9018f73d5a9880466eb55b55c", "patch": "@@ -1397,7 +1397,7 @@ noce_get_alt_condition (struct noce_if_info *if_info, rtx target,\n     }\n \n   cond = canonicalize_condition (if_info->jump, cond, reverse,\n-\t\t\t\t earliest, target);\n+\t\t\t\t earliest, target, false);\n   if (! cond || ! reg_mentioned_p (target, cond))\n     return NULL;\n \n@@ -1671,7 +1671,8 @@ noce_get_condition (rtx jump, rtx *earliest)\n   /* Otherwise, fall back on canonicalize_condition to do the dirty\n      work of manipulating MODE_CC values and COMPARE rtx codes.  */\n \n-  tmp = canonicalize_condition (jump, cond, reverse, earliest, NULL_RTX);\n+  tmp = canonicalize_condition (jump, cond, reverse, earliest, NULL_RTX,\n+\t\t\t\tfalse);\n   if (!tmp)\n     return NULL_RTX;\n \n@@ -1690,7 +1691,8 @@ noce_get_condition (rtx jump, rtx *earliest)\n   tmp = XEXP (tmp, 0);\n   if (!REG_P (tmp) || GET_MODE_CLASS (GET_MODE (tmp)) != MODE_INT)\n     return NULL_RTX;\n-  tmp = canonicalize_condition (jump, cond, reverse, earliest, tmp);\n+  tmp = canonicalize_condition (jump, cond, reverse, earliest, tmp,\n+\t\t\t\tfalse);\n   if (!tmp)\n     return NULL_RTX;\n "}, {"sha": "c1971c6f4c0ec3baf58aa257ba07b82c3263a064", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=ec6ec6aaabd93cd9018f73d5a9880466eb55b55c", "patch": "@@ -141,7 +141,7 @@ may_unswitch_on_p (struct loops *loops, basic_block bb, struct loop *loop,\n \n   /* Condition must be invariant.  We use just a stupid test of invariantness\n      of the condition: all used regs must not be modified inside loop body.  */\n-  test = get_condition (bb->end, NULL);\n+  test = get_condition (bb->end, NULL, true);\n   if (!test)\n     return false;\n \n@@ -248,7 +248,7 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n \t  return;\n \t}\n \n-      if (!(cond = get_condition (bbs[i]->end, &split_before)))\n+      if (!(cond = get_condition (bbs[i]->end, &split_before, true)))\n \tabort ();\n       rcond = reversed_condition (cond);\n "}, {"sha": "9d41e071d1f7c01f1ed47596f566bbe96aed6e58", "filename": "gcc/loop.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=ec6ec6aaabd93cd9018f73d5a9880466eb55b55c", "patch": "@@ -7980,7 +7980,7 @@ check_dbra_loop (struct loop *loop, int insn_count)\n \n   /* Try to compute whether the compare/branch at the loop end is one or\n      two instructions.  */\n-  get_condition (jump, &first_compare);\n+  get_condition (jump, &first_compare, false);\n   if (first_compare == jump)\n     compare_and_branch = 1;\n   else if (first_compare == prev_nonnote_insn (jump))\n@@ -9143,11 +9143,12 @@ update_reg_last_use (rtx x, rtx insn)\n \n    If WANT_REG is nonzero, we wish the condition to be relative to that\n    register, if possible.  Therefore, do not canonicalize the condition\n-   further.  */\n+   further.  If ALLOW_CC_MODE is nonzero, allow the condition returned \n+   to be a compare to a CC mode register.  */\n \n rtx\n canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n-\t\t\trtx want_reg)\n+\t\t\trtx want_reg, int allow_cc_mode)\n {\n   enum rtx_code code;\n   rtx prev = insn;\n@@ -9326,14 +9327,16 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \n   /* If OP0 is the result of a comparison, we weren't able to find what\n      was really being compared, so fail.  */\n-  if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)\n+  if (!allow_cc_mode\n+      && GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)\n     return 0;\n \n   /* Canonicalize any ordered comparison with integers involving equality\n      if we can do computations in the relevant mode and we do not\n      overflow.  */\n \n-  if (GET_CODE (op1) == CONST_INT\n+  if (GET_MODE_CLASS (GET_MODE (op0)) != MODE_CC\n+      && GET_CODE (op1) == CONST_INT\n       && GET_MODE (op0) != VOIDmode\n       && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT)\n     {\n@@ -9388,10 +9391,13 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n    If EARLIEST is nonzero, it is a pointer to a place where the earliest\n    insn used in locating the condition was found.  If a replacement test\n    of the condition is desired, it should be placed in front of that\n-   insn and we will be sure that the inputs are still valid.  */\n+   insn and we will be sure that the inputs are still valid.  \n+\n+   If ALLOW_CC_MODE is nonzero, allow the condition returned to be a\n+   compare CC mode register.  */\n \n rtx\n-get_condition (rtx jump, rtx *earliest)\n+get_condition (rtx jump, rtx *earliest, int allow_cc_mode)\n {\n   rtx cond;\n   int reverse;\n@@ -9411,7 +9417,8 @@ get_condition (rtx jump, rtx *earliest)\n     = GET_CODE (XEXP (SET_SRC (set), 2)) == LABEL_REF\n       && XEXP (XEXP (SET_SRC (set), 2), 0) == JUMP_LABEL (jump);\n \n-  return canonicalize_condition (jump, cond, reverse, earliest, NULL_RTX);\n+  return canonicalize_condition (jump, cond, reverse, earliest, NULL_RTX,\n+\t\t\t\t allow_cc_mode);\n }\n \n /* Similar to above routine, except that we also put an invariant last\n@@ -9420,7 +9427,7 @@ get_condition (rtx jump, rtx *earliest)\n rtx\n get_condition_for_loop (const struct loop *loop, rtx x)\n {\n-  rtx comparison = get_condition (x, (rtx*) 0);\n+  rtx comparison = get_condition (x, (rtx*) 0, false);\n \n   if (comparison == 0\n       || ! loop_invariant_p (loop, XEXP (comparison, 0))"}, {"sha": "243c814775d5213f5569683e4dba7699e732619f", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6ec6aaabd93cd9018f73d5a9880466eb55b55c/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ec6ec6aaabd93cd9018f73d5a9880466eb55b55c", "patch": "@@ -522,7 +522,7 @@ estimate_probability (struct loops *loops_info)\n \t    }\n \t}\n \n-      cond = get_condition (last_insn, &earliest);\n+      cond = get_condition (last_insn, &earliest, false);\n       if (! cond)\n \tcontinue;\n \n@@ -678,7 +678,7 @@ expected_value_to_br_prob (void)\n \t\t(lt r70, r71)\n \t Could use cselib to try and reduce this further.  */\n       cond = XEXP (SET_SRC (pc_set (insn)), 0);\n-      cond = canonicalize_condition (insn, cond, 0, NULL, ev_reg);\n+      cond = canonicalize_condition (insn, cond, 0, NULL, ev_reg, false);\n       if (! cond || XEXP (cond, 0) != ev_reg\n \t  || GET_CODE (XEXP (cond, 1)) != CONST_INT)\n \tcontinue;"}]}