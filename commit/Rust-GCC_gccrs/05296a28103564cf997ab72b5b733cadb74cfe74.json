{"sha": "05296a28103564cf997ab72b5b733cadb74cfe74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUyOTZhMjgxMDM1NjRjZjk5N2FiNzJiNWI3MzNjYWRiNzRjZmU3NA==", "commit": {"author": {"name": "Kyle Galloway", "email": "kgallowa@gcc.gnu.org", "date": "2007-01-25T14:19:05Z"}, "committer": {"name": "Kyle Galloway", "email": "kgallowa@gcc.gnu.org", "date": "2007-01-25T14:19:05Z"}, "message": "jvmti-interp.exp: New file.\n\n2007-01-25  Kyle Galloway  <kgallowa@redhat.com>\n\n    * libjava/testsuite/libjava.jvmti/jvmti-interp.exp: New file.\n    * libjava/testsuite/libjava.jvmti/interp: New folder.\n    * libjava/testsuite/lib/libjava.exp (exec_gij): New Method.\n\nFrom-SVN: r121172", "tree": {"sha": "70a7ee7248f268a6818681493213cb640b51ef17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70a7ee7248f268a6818681493213cb640b51ef17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05296a28103564cf997ab72b5b733cadb74cfe74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05296a28103564cf997ab72b5b733cadb74cfe74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05296a28103564cf997ab72b5b733cadb74cfe74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05296a28103564cf997ab72b5b733cadb74cfe74/comments", "author": null, "committer": null, "parents": [{"sha": "6bfcbf0d48e8e9e71abb7302f677ab5bd32286e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bfcbf0d48e8e9e71abb7302f677ab5bd32286e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bfcbf0d48e8e9e71abb7302f677ab5bd32286e0"}], "stats": {"total": 202, "additions": 202, "deletions": 0}, "files": [{"sha": "e20365a881dafc9ad15b16784a37e973fe135744", "filename": "libjava/testsuite/lib/libjava.exp", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05296a28103564cf997ab72b5b733cadb74cfe74/libjava%2Ftestsuite%2Flib%2Flibjava.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05296a28103564cf997ab72b5b733cadb74cfe74/libjava%2Ftestsuite%2Flib%2Flibjava.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flib%2Flibjava.exp?ref=05296a28103564cf997ab72b5b733cadb74cfe74", "patch": "@@ -494,6 +494,50 @@ proc gcj_invoke {program expectFile ld_library_additions} {\n   }\n }\n \n+proc exec_gij {jarfile expectFile ld_library_additions} {\n+  global env\n+  global libjava_ld_library_path\n+  global ld_library_path\n+\n+  set ld_library_path \"$libjava_ld_library_path\"\n+  if {[llength $ld_library_additions] > 0} {\n+  append ld_library_path :[join $ld_library_additions :]\n+  }\n+\t\n+  set_ld_library_path_env_vars\n+  if [info exists env(LD_LIBRARY_PATH)] {\n+    verbose \"LD_LIBRARY_PATH=$env(LD_LIBRARY_PATH)\"\n+  }\n+  \n+  set gij [libjava_find_gij]\n+  set classname [file rootname [file tail $jarfile]]\n+\t\n+  set result [libjava_load $gij \"-cp $jarfile\" \"$classname\"]\n+  set status [lindex $result 0]\n+  set output [lindex $result 1]\n+\n+  restore_ld_library_path_env_vars\n+\n+  if {$status != \"pass\"} {\n+    verbose \"got $output\"\n+    fail \"$classname run\"\n+    untested \"$classname output\"\n+    return 0\n+  }\n+\n+  set id [open $expectFile r]\n+  set expected [read $id]\n+  close $id\n+\n+  if [! [string compare $output $expected]] {\n+    pass \"$classname output\"\n+    return 1\n+  } else {\n+\tfail \"$classname output\"\n+\treturn 0\n+  }\n+}\n+\n # Invoke a program and check its output.  EXECUTABLE is the program;\n # ARGS are the arguments to the program.  Returns 1 if tests passed\n # (or things were left untested), 0 otherwise."}, {"sha": "0c0fca1137ee6843c420e16f62fb4f660639dc2a", "filename": "libjava/testsuite/libjava.jvmti/jvmti-interp.exp", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05296a28103564cf997ab72b5b733cadb74cfe74/libjava%2Ftestsuite%2Flibjava.jvmti%2Fjvmti-interp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05296a28103564cf997ab72b5b733cadb74cfe74/libjava%2Ftestsuite%2Flibjava.jvmti%2Fjvmti-interp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jvmti%2Fjvmti-interp.exp?ref=05296a28103564cf997ab72b5b733cadb74cfe74", "patch": "@@ -0,0 +1,158 @@\n+# Interpreted Tests for JVMTI code.\n+# These tests are used to test JVMTI functions in a purley interpreted setting\n+# This file compiles the JNI code into a shared object, then invokes gij to run\n+# the test.\n+\n+\n+# Compile a single C file and produce a .so file.  OPTIONS is a list\n+# of options to pass to the compiler.  Returns 0 on failure, 1 on\n+# success.\n+proc gcj_jni_compile_c_to_so {file {options {}}} {\n+  global srcdir subdir\n+  global host_triplet\n+  verbose \"options: $options\"\n+  set options_cxx $options\n+  set options \"\"\n+\n+# Apple uses a different extension for shared/dynamic libraries\n+# so we check against powerpc-apple-darwin and set them to\n+# dylib.\n+# HP-UX uses sl, so we check this too, otherwise we take so.\n+\n+  if { [istarget \"*-*-darwin*\"] } {\n+      set so_extension \"dylib\"\n+      set so_flag \"-dynamiclib\"\n+  } elseif { [istarget \"hppa*-hp-hpux*\"] } {\n+      set so_extension \"sl\"\n+      set so_flag \"-shared\"\n+  } else {\n+      set so_extension \"so\"\n+      set so_flag \"-shared\"\n+  }\n+    \n+  set filename [file tail $file]\n+  set name [file rootname $filename]\n+  set soname lib${name}.${so_extension}\n+\n+  lappend options \"additional_flags=${so_flag} -fPIC\"\n+  # Find the generated header.\n+  lappend options \"additional_flags=-I. -I.. -I$srcdir/$subdir\"\n+\n+  # Ensure that the generated header has correct prototypes.\n+  set cfile [file rootname $file].c\n+  if { [file exists $cfile] } {\n+      # This option is only valid for C sources.\n+      lappend options \"additional_flags=-Wmissing-prototypes\"\n+  }\n+\n+  # Find jni.h and jni_md.h.\n+  lappend options \"additional_flags=-I$srcdir/../include  \\\n+                   -I$srcdir/../classpath/include\"\n+\n+  # Append C++ options\n+  lappend options \"additional_flags=$options_cxx\"\n+\n+  set x [libjava_prune_warnings \\\n+\t     [target_compile $file $soname executable $options]]\n+  if {$x != \"\"} {\n+      verbose \"target_compile failed: $x\" 2\n+      fail \"$filename compilation\"\n+      return 0\n+  }\n+\n+  pass \"$filename compilation\"\n+  return 1\n+}\n+\n+# Do all the work for a single JVMTI test.  Return 0 on failure.\n+proc gij_jvmti_test_one {file} {\n+  global runtests\n+\n+  # The base name.  We use it for several purposes.\n+  set main [file rootname [file tail $file]]\n+  if {! [runtest_file_p $runtests $main] } {\n+      # Simply skip it.\n+      return 1\n+  }\n+\n+#  if {! [bytecompile_file $file [pwd]] } {\n+#     fail \"bytecompile $file\"\n+#     # FIXME - should use `untested' on all remaining tests.\n+#     # But that is hard.\n+#     return 0\n+#   }\n+#   pass \"bytecompile $file\"\n+\n+#   if {! [gcj_jvmti_build_headers $file] } {\n+#     # FIXME\n+#     return 0\n+#   }\n+  \n+  set cfile [file join [file dirname $file] nat$main.c]\n+  set cxxflags \"\"\n+  set cxxldlibflags {}\n+  # If there is no `.c' file, assume there is a `.cc' file.\n+  if {! [file exists $cfile] } {\n+      set cfile [file join [file dirname $file] nat$main.cc]\n+\n+      set cxxflaglist {}\n+      foreach arg [split [libjava_find_lib libstdc++-v3/src stdc++] \" \"] {\n+          switch -glob -- $arg {\n+\t          \"-L*\" {\n+\t              set arg [string range $arg 2 end]\n+\t              lappend cxxldlibflags $arg\n+\t              # Strip the `.libs' directory; we link with libtool which\n+\t              # doesn't need it.\n+\t              set arg \"-L[file dirname $arg]\"\n+       \t            }\n+          }\n+      \n+          lappend cxxflaglist $arg\n+          # In case the libstdc++ is not installed yet, we pass the build\n+          # directory of it to the cxxflaglist.\n+          lappend cxxflaglist \"-L$cxxldlibflags\"\n+      }\n+\t\n+      lappend cxxflaglist \"-lstdc++\"\n+\n+      set cxxflags [join $cxxflaglist]\n+  }\n+\n+  if {! [gcj_jni_compile_c_to_so $cfile $cxxflags] } {\n+      # FIXME\n+      return 0\n+  }\n+\n+  libjava_arguments\n+  \n+  set jarfile [file join [file dirname $file] $main.jar]\n+  if {! [exec_gij $jarfile [file rootname $file].out {}]} {\n+      return 0\n+  }\n+\n+  # When we succeed we remove all our clutter.\n+  eval gcj_cleanup [glob -nocomplain -- ${main}.*]  \\\n+                   [list $main.class libnat$main.so]\n+\n+  return 1\n+}\n+\n+# Run the JVMTI tests.\n+proc gij_jvmti_run {} {\n+  global srcdir subdir\n+  global build_triplet host_triplet\n+\n+  # For now we only test JVMTI on native builds.\n+  if {$build_triplet == $host_triplet} {\n+      catch { lsort [glob -nocomplain ${srcdir}/${subdir}/interp/*.jar] \\\n+             } srcfiles\n+\n+      foreach x $srcfiles {\n+        gij_jvmti_test_one $x\n+      }\n+  } else {\n+      verbose \"JVMTI tests not run in cross-compilation environment\"\n+  }\n+}\n+\n+gij_jvmti_run"}]}