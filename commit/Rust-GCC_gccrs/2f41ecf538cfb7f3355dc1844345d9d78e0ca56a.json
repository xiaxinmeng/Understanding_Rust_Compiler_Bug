{"sha": "2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY0MWVjZjUzOGNmYjdmMzM1NWRjMTg0NDM0NWQ5ZDc4ZTBjYTU2YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-05T10:21:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-05T10:21:42Z"}, "message": "lto-cgraph.c (output_varpool): Forward declare; work on encoder.\n\n\n\t* lto-cgraph.c (output_varpool): Forward declare; work on encoder.\n\t(lto_varpool_encoder_new, lto_varpool_encoder_delete, lto_varpool_encoder_encode\n\tlto_varpool_encoder_lookup, lto_varpool_encoder_deref, lto_varpool_encoder_size,\n\tlto_varpool_encoder_encode_initializer_p,\n\tlto_set_varpool_encoder_encode_initializer): New functions.\n\t(lto_output_cgraph): Take vset parameter too; compute varpool encoder;\n\tcall output_varpool.\n\t(input_varpool_node): Do not always set analyzed.\n\t(input_cgraph_1): Return vector of cgraph nodes.\n\t(input_varpool_1): Return vector of varpools.\n\t(input_cgraph): Free the vectors.\n\t* lto-streamer-out.c (lto_output_ts_decl_common_tree_pointers):\n\toutput only initializers needed.\n\t(lto_output): Only call output_cgraph.\n\t(produce_asm_for_decls): Call lto_varpool_encoder_delete.\n\t* lto-section-out.c (lto_new_out_decl_state): Initialize\n\tstate->varpool_node_encoder.\n\t* lto-streamer.h (lto_varpool_encoder_d): New.\n\t(lto_out_decl_state, lto_file_decl_data): Add varpool_node_encoder.\t\n\t(lto_cgraph_encoder_delete, output_cgraph): Update prototype.\n\t(lto_varpool_encoder_deref, lto_varpool_encoder_lookup,\n\tlto_varpool_encoder_encode, lto_varpool_encoder_delete,\n\tlto_varpool_encoder_encode_initializer_p, lto_varpool_encoder_new):\n\tDeclare.\n\t(output_varpool, input_varpool): Remove declarations.\n\n\t* lto.c (lto_1_to_1_map): Partition only needed nodes.\n\nFrom-SVN: r159062", "tree": {"sha": "875c06ba015ae9aa913d0e3eeea54506464b244d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/875c06ba015ae9aa913d0e3eeea54506464b244d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/comments", "author": null, "committer": null, "parents": [{"sha": "9e0546efa363b5cd7d4cb55c314cfed979dcb21b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e0546efa363b5cd7d4cb55c314cfed979dcb21b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e0546efa363b5cd7d4cb55c314cfed979dcb21b"}], "stats": {"total": 274, "additions": 243, "deletions": 31}, "files": [{"sha": "3d751d2dbccd2de538b8a2836f8e76e1da94c470", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "patch": "@@ -1,3 +1,31 @@\n+2010-05-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-cgraph.c (output_varpool): Forward declare; work on encoder.\n+\t(lto_varpool_encoder_new, lto_varpool_encoder_delete, lto_varpool_encoder_encode\n+\tlto_varpool_encoder_lookup, lto_varpool_encoder_deref, lto_varpool_encoder_size,\n+\tlto_varpool_encoder_encode_initializer_p,\n+\tlto_set_varpool_encoder_encode_initializer): New functions.\n+\t(lto_output_cgraph): Take vset parameter too; compute varpool encoder;\n+\tcall output_varpool.\n+\t(input_varpool_node): Do not always set analyzed.\n+\t(input_cgraph_1): Return vector of cgraph nodes.\n+\t(input_varpool_1): Return vector of varpools.\n+\t(input_cgraph): Free the vectors.\n+\t* lto-streamer-out.c (lto_output_ts_decl_common_tree_pointers):\n+\toutput only initializers needed.\n+\t(lto_output): Only call output_cgraph.\n+\t(produce_asm_for_decls): Call lto_varpool_encoder_delete.\n+\t* lto-section-out.c (lto_new_out_decl_state): Initialize\n+\tstate->varpool_node_encoder.\n+\t* lto-streamer.h (lto_varpool_encoder_d): New.\n+\t(lto_out_decl_state, lto_file_decl_data): Add varpool_node_encoder.\t\n+\t(lto_cgraph_encoder_delete, output_cgraph): Update prototype.\n+\t(lto_varpool_encoder_deref, lto_varpool_encoder_lookup,\n+\tlto_varpool_encoder_encode, lto_varpool_encoder_delete,\n+\tlto_varpool_encoder_encode_initializer_p, lto_varpool_encoder_new):\n+\tDeclare.\n+\t(output_varpool, input_varpool): Remove declarations.\n+\n 2010-05-05  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-symtab.c (lto_symtab_resolve_can_prevail_p): Alias of variable"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/ipa-ref-inline.h", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Fipa-ref-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Fipa-ref-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref-inline.h?ref=2f41ecf538cfb7f3355dc1844345d9d78e0ca56a"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/ipa-ref.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=2f41ecf538cfb7f3355dc1844345d9d78e0ca56a"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/ipa-ref.h", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=2f41ecf538cfb7f3355dc1844345d9d78e0ca56a"}, {"sha": "2c67fcba52499c9c5863d3e37da2226057889f2c", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 161, "deletions": 23, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "patch": "@@ -46,6 +46,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-streamer.h\"\n #include \"gcov-io.h\"\n \n+static void output_varpool (varpool_node_set);\n+\n /* Cgraph streaming is organized as set of record whose type\n    is indicated by a tag.  */\n enum LTO_cgraph_tags\n@@ -143,6 +145,105 @@ lto_cgraph_encoder_size (lto_cgraph_encoder_t encoder)\n   return VEC_length (cgraph_node_ptr, encoder->nodes);\n }\n \n+/* Create a new varpool encoder.  */\n+\n+lto_varpool_encoder_t\n+lto_varpool_encoder_new (void)\n+{\n+  lto_varpool_encoder_t encoder = XCNEW (struct lto_varpool_encoder_d);\n+  encoder->map = pointer_map_create ();\n+  encoder->initializer = pointer_set_create ();\n+  encoder->nodes = NULL;\n+  return encoder;\n+}\n+\n+\n+/* Delete ENCODER and its components.  */\n+\n+void\n+lto_varpool_encoder_delete (lto_varpool_encoder_t encoder)\n+{\n+   VEC_free (varpool_node_ptr, heap, encoder->nodes);\n+   pointer_map_destroy (encoder->map);\n+   pointer_set_destroy (encoder->initializer);\n+   free (encoder);\n+}\n+\n+\n+/* Return the existing reference number of NODE in the varpool encoder in\n+   output block OB.  Assign a new reference if this is the first time\n+   NODE is encoded.  */\n+\n+int\n+lto_varpool_encoder_encode (lto_varpool_encoder_t encoder,\n+\t\t\t   struct varpool_node *node)\n+{\n+  int ref;\n+  void **slot;\n+\n+  slot = pointer_map_contains (encoder->map, node);\n+  if (!slot)\n+    {\n+      ref = VEC_length (varpool_node_ptr, encoder->nodes);\n+      slot = pointer_map_insert (encoder->map, node);\n+      *slot = (void *) (intptr_t) ref;\n+      VEC_safe_push (varpool_node_ptr, heap, encoder->nodes, node);\n+    }\n+  else\n+    ref = (int) (intptr_t) *slot;\n+\n+  return ref;\n+}\n+\n+/* Look up NODE in encoder.  Return NODE's reference if it has been encoded\n+   or LCC_NOT_FOUND if it is not there.  */\n+\n+int\n+lto_varpool_encoder_lookup (lto_varpool_encoder_t encoder,\n+\t\t\t   struct varpool_node *node)\n+{\n+  void **slot = pointer_map_contains (encoder->map, node);\n+  return (slot ? (int) (intptr_t) *slot : LCC_NOT_FOUND);\n+}\n+\n+\n+/* Return the varpool node corresponding to REF using ENCODER.  */\n+\n+struct varpool_node *\n+lto_varpool_encoder_deref (lto_varpool_encoder_t encoder, int ref)\n+{\n+  if (ref == LCC_NOT_FOUND)\n+    return NULL;\n+\n+  return VEC_index (varpool_node_ptr, encoder->nodes, ref);\n+}\n+\n+\n+/* Return number of encoded nodes in ENCODER.  */\n+\n+static int\n+lto_varpool_encoder_size (lto_varpool_encoder_t encoder)\n+{\n+  return VEC_length (varpool_node_ptr, encoder->nodes);\n+}\n+\n+/* Return TRUE if we should encode initializer of NODE (if any).  */\n+\n+bool\n+lto_varpool_encoder_encode_initializer_p (lto_varpool_encoder_t encoder,\n+\t\t\t\t\t  struct varpool_node *node)\n+{\n+  return pointer_set_contains (encoder->initializer, node);\n+}\n+\n+/* Return TRUE if we should encode initializer of NODE (if any).  */\n+\n+static void\n+lto_set_varpool_encoder_encode_initializer (lto_varpool_encoder_t encoder,\n+\t\t\t\t\t    struct varpool_node *node)\n+{\n+  pointer_set_insert (encoder->initializer, node);\n+}\n \n /* Output the cgraph EDGE to OB using ENCODER.  */\n \n@@ -454,16 +555,19 @@ output_outgoing_cgraph_edges (struct cgraph_edge *edge,\n /* Output the part of the cgraph in SET.  */\n \n void\n-output_cgraph (cgraph_node_set set)\n+output_cgraph (cgraph_node_set set, varpool_node_set vset)\n {\n   struct cgraph_node *node;\n   struct lto_simple_output_block *ob;\n   cgraph_node_set_iterator csi;\n+  varpool_node_set_iterator vsi;\n   struct cgraph_edge *edge;\n   int i, n_nodes;\n   bitmap written_decls;\n   lto_cgraph_encoder_t encoder;\n+  lto_varpool_encoder_t varpool_encoder;\n   struct cgraph_asm_node *can;\n+  struct varpool_node *vnode;\n \n   ob = lto_create_simple_output_block (LTO_section_cgraph);\n \n@@ -472,7 +576,9 @@ output_cgraph (cgraph_node_set set)\n   /* An encoder for cgraph nodes should have been created by\n      ipa_write_summaries_1.  */\n   gcc_assert (ob->decl_state->cgraph_node_encoder);\n+  gcc_assert (ob->decl_state->varpool_node_encoder);\n   encoder = ob->decl_state->cgraph_node_encoder;\n+  varpool_encoder = ob->decl_state->varpool_node_encoder;\n \n   /* The FUNCTION_DECLs for which we have written a node.  The first\n      node found is written as the \"original\" node, the remaining nodes\n@@ -485,6 +591,33 @@ output_cgraph (cgraph_node_set set)\n       node = csi_node (csi);\n       add_node_to (encoder, node);\n     }\n+  for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n+    {\n+      struct varpool_node *vnode = vsi_node (vsi);\n+      gcc_assert (!vnode->alias);\n+      lto_varpool_encoder_encode (varpool_encoder, vnode);\n+      lto_set_varpool_encoder_encode_initializer (varpool_encoder, vnode);\n+    }\n+  /* FIXME: We do not track references, so for now we need to include all possibly\n+     used variables in the encoder set.  */\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    if (vnode->needed)\n+      lto_varpool_encoder_encode (varpool_encoder, vnode);\n+  /* Pickle in also the initializer of all referenced readonly variables\n+     to help folding.  Constant pool variables are not shared, so we must\n+     pickle those too.  */\n+  for (i = 0; i < lto_varpool_encoder_size (varpool_encoder); i++)\n+    {\n+      struct varpool_node *vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n+      if (DECL_INITIAL (vnode->decl)\n+\t  && !lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n+\t\t\t\t\t\t        vnode)\n+\t  && (DECL_IN_CONSTANT_POOL (vnode->decl)\n+\t      ||  TREE_READONLY (vnode->decl)))\n+\t{\n+\t  lto_set_varpool_encoder_encode_initializer (varpool_encoder, vnode);\n+\t}\n+    }\n \n   /* Go over all the nodes again to include callees that are not in\n      SET.  */\n@@ -538,6 +671,7 @@ output_cgraph (cgraph_node_set set)\n   lto_output_uleb128_stream (ob->main_stream, 0);\n \n   lto_destroy_simple_output_block (ob);\n+  output_varpool (vset);\n }\n \n /* Overwrite the information in NODE based on FILE_DATA, TAG, FLAGS,\n@@ -591,27 +725,23 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n \n /* Output the part of the cgraph in SET.  */\n \n-void\n-output_varpool (varpool_node_set set)\n+static void\n+output_varpool (varpool_node_set vset)\n {\n-  struct varpool_node *node;\n-  struct lto_simple_output_block *ob;\n-  int len = 0;\n-\n-  ob = lto_create_simple_output_block (LTO_section_varpool);\n-\n-  for (node = varpool_nodes; node; node = node->next)\n-    if (node->needed && node->analyzed)\n-      len++;\n+  struct lto_simple_output_block *ob = lto_create_simple_output_block (LTO_section_varpool);\n+  lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n+  int len = lto_varpool_encoder_size (varpool_encoder), i;\n \n   lto_output_uleb128_stream (ob->main_stream, len);\n \n   /* Write out the nodes.  We must first output a node and then its clones,\n      otherwise at a time reading back the node there would be nothing to clone\n      from.  */\n-  for (node = varpool_nodes; node; node = node->next)\n-    if (node->needed && node->analyzed)\n-      lto_output_varpool_node (ob, node, set);\n+  for (i = 0; i < len; i++)\n+    {\n+      lto_output_varpool_node (ob, lto_varpool_encoder_deref (varpool_encoder, i),\n+\t\t\t       vset);\n+    }\n \n   lto_destroy_simple_output_block (ob);\n }\n@@ -737,7 +867,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->externally_visible = bp_unpack_value (bp, 1);\n   node->force_output = bp_unpack_value (bp, 1);\n   node->finalized = bp_unpack_value (bp, 1);\n-  node->analyzed = 1; \n+  node->analyzed = node->finalized; \n   node->used_from_other_partition = bp_unpack_value (bp, 1);\n   node->in_other_partition = bp_unpack_value (bp, 1);\n   aliases_p = bp_unpack_value (bp, 1);\n@@ -822,7 +952,7 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n \n /* Read a cgraph from IB using the info in FILE_DATA.  */\n \n-static void\n+static VEC(cgraph_node_ptr, heap) *\n input_cgraph_1 (struct lto_file_decl_data *file_data,\n \t\tstruct lto_input_block *ib)\n {\n@@ -882,26 +1012,29 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n       else\n \tnode->same_comdat_group = NULL;\n     }\n-\n-  VEC_free (cgraph_node_ptr, heap, nodes);\n+  return nodes;\n }\n \n /* Read a varpool from IB using the info in FILE_DATA.  */\n \n-static void\n+static VEC(varpool_node_ptr, heap) *\n input_varpool_1 (struct lto_file_decl_data *file_data,\n \t\tstruct lto_input_block *ib)\n {\n   unsigned HOST_WIDE_INT len;\n+  VEC(varpool_node_ptr, heap) *varpool = NULL;\n \n   len = lto_input_uleb128 (ib);\n   while (len)\n     {\n-      input_varpool_node (file_data, ib);\n+      VEC_safe_push (varpool_node_ptr, heap, varpool,\n+\t\t     input_varpool_node (file_data, ib));\n       len--;\n     }\n+  return varpool;\n }\n \n+\n static struct gcov_ctr_summary lto_gcov_summary;\n \n /* Input profile_info from IB.  */\n@@ -948,20 +1081,25 @@ input_cgraph (void)\n       const char *data;\n       size_t len;\n       struct lto_input_block *ib;\n+      VEC(cgraph_node_ptr, heap) *nodes;\n+      VEC(varpool_node_ptr, heap) *varpool;\n \n       ib = lto_create_simple_input_block (file_data, LTO_section_cgraph,\n \t\t\t\t\t  &data, &len);\n       input_profile_summary (ib);\n       file_data->cgraph_node_encoder = lto_cgraph_encoder_new ();\n-      input_cgraph_1 (file_data, ib);\n+      nodes = input_cgraph_1 (file_data, ib);\n       lto_destroy_simple_input_block (file_data, LTO_section_cgraph,\n \t\t\t\t      ib, data, len);\n \n       ib = lto_create_simple_input_block (file_data, LTO_section_varpool,\n \t\t\t\t\t  &data, &len);\n-      input_varpool_1 (file_data, ib);\n+      varpool = input_varpool_1 (file_data, ib);\n       lto_destroy_simple_input_block (file_data, LTO_section_varpool,\n \t\t\t\t      ib, data, len);\n+\n+      VEC_free (cgraph_node_ptr, heap, nodes);\n+      VEC_free (varpool_node_ptr, heap, varpool);\n     }\n \n   /* Clear out the aux field that was used to store enough state to"}, {"sha": "8bcbdd7e0e70668a8c0e8707a1604809bd0191a8", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "patch": "@@ -543,6 +543,7 @@ lto_new_out_decl_state (void)\n     }\n \n   state->cgraph_node_encoder = lto_cgraph_encoder_new ();\n+  state->varpool_node_encoder = lto_varpool_encoder_new ();\n \n   return state;\n }"}, {"sha": "cffaee58f8b3f0e357b8b1eda299c948e25dc35c", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "patch": "@@ -844,7 +844,23 @@ lto_output_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n   lto_output_tree_or_ref (ob, DECL_SIZE_UNIT (expr), ref_p);\n \n   if (TREE_CODE (expr) != FUNCTION_DECL)\n-    lto_output_tree_or_ref (ob, DECL_INITIAL (expr), ref_p);\n+    {\n+      tree initial = DECL_INITIAL (expr);\n+      if (TREE_CODE (expr) == VAR_DECL\n+\t  && (TREE_STATIC (expr) || DECL_EXTERNAL (expr))\n+\t  && initial)\n+\t{\n+\t  lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n+\t  struct varpool_node *vnode = varpool_get_node (expr);\n+\t  if (!vnode)\n+\t    initial = error_mark_node;\n+\t  else if (!lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n+\t\t\t\t\t\t\t      vnode))\n+\t    initial = NULL;\n+\t}\n+    \n+      lto_output_tree_or_ref (ob, initial, ref_p);\n+    }\n \n   lto_output_tree_or_ref (ob, DECL_ATTRIBUTES (expr), ref_p);\n   lto_output_tree_or_ref (ob, DECL_ABSTRACT_ORIGIN (expr), ref_p);\n@@ -2102,8 +2118,7 @@ lto_output (cgraph_node_set set, varpool_node_set vset)\n      be done now to make sure that all the statements in every function\n      have been renumbered so that edges can be associated with call\n      statements using the statement UIDs.  */\n-  output_cgraph (set);\n-  output_varpool (vset);\n+  output_cgraph (set, vset);\n \n   lto_bitmap_free (output);\n }\n@@ -2507,6 +2522,7 @@ produce_asm_for_decls (cgraph_node_set set, varpool_node_set vset)\n \n   /* Deallocate memory and clean up.  */\n   lto_cgraph_encoder_delete (ob->decl_state->cgraph_node_encoder);\n+  lto_varpool_encoder_delete (ob->decl_state->varpool_node_encoder);\n   VEC_free (lto_out_decl_state_ptr, heap, lto_function_decl_states);\n   lto_function_decl_states = NULL;\n   destroy_output_block (ob);"}, {"sha": "3d8617bd96d9383667b065b63f8b020e09e77fd7", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "patch": "@@ -466,6 +466,20 @@ struct lto_cgraph_encoder_d\n \n typedef struct lto_cgraph_encoder_d *lto_cgraph_encoder_t;\n \n+/* Encoder data structure used to stream callgraph nodes.  */\n+struct lto_varpool_encoder_d\n+{\n+  /* Map nodes to reference number. */\n+  struct pointer_map_t *map;\n+\n+  /* Map reference number to node. */\n+  VEC(varpool_node_ptr,heap) *nodes;\n+\n+  /* Map of nodes where we want to output initializer.  */\n+  struct pointer_set_t *initializer;\n+};\n+typedef struct lto_varpool_encoder_d *lto_varpool_encoder_t;\n+\n /* Mapping from indices to trees.  */\n struct GTY(()) lto_tree_ref_table\n {\n@@ -520,6 +534,9 @@ struct lto_out_decl_state\n   /* Encoder for cgraph nodes.  */\n   lto_cgraph_encoder_t cgraph_node_encoder;\n \n+  /* Encoder for varpool nodes.  */\n+  lto_varpool_encoder_t varpool_node_encoder;\n+\n   /* If this out-decl state belongs to a function, fn_decl points to that\n      function.  Otherwise, it is NULL. */\n   tree fn_decl;\n@@ -546,6 +563,9 @@ struct GTY(()) lto_file_decl_data\n   /* Table of cgraph nodes present in this file.  */\n   lto_cgraph_encoder_t GTY((skip)) cgraph_node_encoder;\n \n+  /* Table of varpool nodes present in this file.  */\n+  lto_varpool_encoder_t GTY((skip)) varpool_node_encoder;\n+\n   /* Hash table maps lto-related section names to location in file.  */\n   htab_t GTY((param_is (struct lto_in_decl_state))) function_decl_states;\n \n@@ -825,11 +845,16 @@ struct cgraph_node *lto_cgraph_encoder_deref (lto_cgraph_encoder_t, int);\n int lto_cgraph_encoder_lookup (lto_cgraph_encoder_t, struct cgraph_node *);\n lto_cgraph_encoder_t lto_cgraph_encoder_new (void);\n int lto_cgraph_encoder_encode (lto_cgraph_encoder_t, struct cgraph_node *);\n-void lto_cgraph_encoder_delete (lto_cgraph_encoder_t encoder);\n-void output_cgraph (cgraph_node_set);\n+void lto_cgraph_encoder_delete (lto_cgraph_encoder_t);\n+struct varpool_node *lto_varpool_encoder_deref (lto_varpool_encoder_t, int);\n+int lto_varpool_encoder_lookup (lto_varpool_encoder_t, struct varpool_node *);\n+lto_varpool_encoder_t lto_varpool_encoder_new (void);\n+int lto_varpool_encoder_encode (lto_varpool_encoder_t, struct varpool_node *);\n+void lto_varpool_encoder_delete (lto_varpool_encoder_t);\n+bool lto_varpool_encoder_encode_initializer_p (lto_varpool_encoder_t,\n+\t\t\t\t\t       struct varpool_node *);\n+void output_cgraph (cgraph_node_set, varpool_node_set);\n void input_cgraph (void);\n-void output_varpool (varpool_node_set);\n-void input_varpool (void);\n \n \n /* In lto-symtab.c.  */"}, {"sha": "72a8028f5010dcc449721064ad24da52c109ffd2", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "patch": "@@ -1,3 +1,7 @@\n+2010-05-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_1_to_1_map): Partition only needed nodes.\n+\n 2010-04-30  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (get_filename_for_set): Look for cgraph node and if none found, use"}, {"sha": "d653b04e55fcab03dc543bc4c6a71b50f6f47b29", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "patch": "@@ -584,7 +584,7 @@ lto_1_to_1_map (void)\n \n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n     {\n-      if (vnode->alias)\n+      if (vnode->alias || !vnode->needed)\n \tcontinue;\n       slot = pointer_map_contains (vpmap, file_data);\n       if (slot)"}]}