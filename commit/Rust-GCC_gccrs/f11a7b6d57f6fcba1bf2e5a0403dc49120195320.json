{"sha": "f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjExYTdiNmQ1N2Y2ZmNiYTFiZjJlNWEwNDAzZGM0OTEyMDE5NTMyMA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2015-09-27T09:02:00Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2015-09-27T09:02:00Z"}, "message": "revert to assign_parms assignments using default defs\n\nRevert the fragile and complicated changes to assign_parms designed to\nenable it to use RTL assigments chosen by cfgexpand, and instead have\ncfgexpand use the RTL assignments by assign_parms, keying them off of\nthe default defs that are now necessarily introduced for each parm and\nresult.  The possible lack of a default def was already a problem, and\nthe fallbacks in place were not enough, as shown by PR67312.  We now\nhave checking asserts in set_rtl that verify that we're assigning to\neach var a piece of RTL that matches the expectations set forth by\nuse_register_for_decl.\n\nfor  gcc/ChangeLog\n\n\tPR rtl-optimization/64164\n\tPR tree-optimization/67312\n\tPR middle-end/67340\n\tPR middle-end/67490\n\tPR bootstrap/67597\n\t* cfgexpand.c (parm_in_stack_slot_p): Remove.\n\t(ssa_default_def_partition): Remove.\n\t(get_rtl_for_parm_ssa_default_def): Remove.\n\t(set_rtl): Check that RTL assignments match expectations.\n\tLoop on SUBREGs, CONCATs and PARALLELs subexprs.  Set only the\n\tdefault def location for params and results.  Record SSA names\n\tor types in REG and MEM attrs, respectively.\n\t(set_parm_rtl): New.\n\t(expand_one_ssa_partition): Drop logic that assigned MEMs with\n\tunassigned addresses.\n\t(adjust_one_expanded_partition_var): Don't accept NULL RTL on\n\tdeferred stack alloc vars.\n\t(expand_used_vars): Skip partitions holding parm default defs.\n\tMove adjust_one_expanded_partition_var loop...\n\t(pass_expand::execute): ... here.  Drop redundant assert.\n\tAdjust comments before the final loop over all ssa names.\n\tRequire assigned rtl of parms and results to match exactly.\n\tReset its attributes to match them, not any other variables in\n\tthe same partition.\n\t(expand_debug_expr): Use entry value for PARM's default defs\n\tonly iff they have zero nondebug uses.\n\t* cfgexpand.h (parm_in_stack_slot_p): Remove.\n\t(get_rtl_for_parm_ssa_default_def): Remove.\n\t(set_parm_rtl): Declare.\n\t* doc/invoke.texi: Improve wording.\n\t* explow.c (promote_decl_mode): Fix promote_function_mode for\n\tresult decls not by reference.\n\t(promote_ssa_mode): Disregard BLKmode from promote_decl, and\n\tbypass TYPE_MODE to get the actual vector mode.\n\t* function.c: Include tree-dfa.h.  Revert 2015-08-14's and\n\t2015-08-19's changes as follows.  Drop include of\n\tbasic-block.h and df.h.\n\t(rtl_for_parm): Remove.\n\t(maybe_reset_rtl_for_parm): Remove.\n\t(parm_in_unassigned_mem_p): Remove.\n\t(use_register_for_decl): Add logic for RESULT_DECLs matching\n\tassign_parms' behavior.\n\t(split_complex_args): Revert.\n\t(assign_parms_augmented_arg_list): Revert.  Add comment\n\treferencing the logic above.\n\t(assign_parm_adjust_stack_rtl): Revert.\n\t(assign_parm_setup_block): Revert.  Use set_parm_rtl instead\n\tof SET_DECL_RTL.  Set up a REG if the parm demands so.\n\t(assign_parm_setup_reg): Revert.  Consolidated SET_DECL_RTL\n\tcalls into a single set_parm_rtl.  Set up a temporary RTL\n\ttemporarily for expand_assignment.\n\t(assign_parm_setup_stack): Revert.  Use set_parm_rtl.\n\t(assign_parms_unsplit_complex): Revert.  Use set_parm_rtl.\n\t(assign_bounds): Revert.\n\t(assign_parms): Revert.  Use set_parm_rtl.\n\t(allocate_struct_function): Relayout result and parms of\n\tnon-abstruct functions.\n\t(expand_function_start): Revert.  Use set_parm_rtl.  If the\n\tresult is not a hard reg, create a pseudo from the promoted\n\tmode of the default def.  Promote static chain mode.\n\t* tree-outof-ssa.c (remove_ssa_form): Drop unused\n\tpartition_has_default_def.  Set up\n\tpartitions_for_parm_default_defs.\n\t(finish_out_of_ssa): Remove partition_has_default_def.\n\tRelease partitions_for_parm_default_defs.\n\t* tree-outof-ssa.h (struct ssaexpand): Remove\n\tpartition_has_default_def.  Add\n\tpartitions_for_parm_default_defs.\n\t* tree-ssa-coalesce.c: Include tree-dfa.h, tm_p.h and\n\tstor-layout.h.\n\t(build_ssa_conflict_graph): Fix conflict-detection of default\n\tdefs of even unused default defs of params and results.\n\t(for_all_parms): New.\n\t(create_default_def): New.\n\t(register_default_def): New.\n\t(coalesce_with_default): New.\n\t(create_outofssa_var_map): Create default defs for all parms\n\tand results, and register their partitions.  Add GIMPLE_RETURN\n\toperands as coalesce candidates with results.  Add default\n\tdefs of each parm or result as coalesce candidates with its\n\tother defs.  Mark each result def, and each default def of\n\tparms, as used_in_copy.\n\t(gimple_can_coalesce_p): Call it.  Call use_register_for_decl\n\twith the ssa names, even anonymous ones.  Drop\n\tparm_in_stack_slot_p calls.  Require same signedness and\n\talignment.\n\t(coalesce_ssa_name): Add coalesce candidates for all defs of\n\teach parm and result, even unused ones.\n\t(parm_default_def_partition_arg): New type.\n\t(set_parm_default_def_partition): New.\n\t(get_parm_default_def_partitions): New.\n\t* tree-ssa-coalesce.h (get_parm_default_def_partitions): New.\n\t* tree-ssa-live.c (partition_view_init): Regard unused defs of\n\tparms and results as used.\n\t(verify_live_on_entry): Don't error out just because they're\n\tnot live.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR rtl-optimization/64164\n\tPR tree-optimization/67312\n\t* gcc.dg/pr67312.c: New.  From Zdenek Sojka.\n\t* gcc.target/i386/stackalign/return-4.c: Add -O.\n\nFrom-SVN: r228175", "tree": {"sha": "0f5ba4acabc38f459581c262648b0feb65f83a32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f5ba4acabc38f459581c262648b0feb65f83a32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/comments", "author": null, "committer": null, "parents": [{"sha": "edfc19ab2bf68516aa9697d11949637af884148e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edfc19ab2bf68516aa9697d11949637af884148e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edfc19ab2bf68516aa9697d11949637af884148e"}], "stats": {"total": 1225, "additions": 688, "deletions": 537}, "files": [{"sha": "6e4fbe4c03d8bcd299d4e9b45d05362393af222e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -1,3 +1,102 @@\n+2015-09-27  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR rtl-optimization/64164\n+\tPR tree-optimization/67312\n+\tPR middle-end/67340\n+\tPR middle-end/67490\n+\tPR bootstrap/67597\n+\t* cfgexpand.c (parm_in_stack_slot_p): Remove.\n+\t(ssa_default_def_partition): Remove.\n+\t(get_rtl_for_parm_ssa_default_def): Remove.\n+\t(set_rtl): Check that RTL assignments match expectations.\n+\tLoop on SUBREGs, CONCATs and PARALLELs subexprs.  Set only the\n+\tdefault def location for params and results.  Record SSA names\n+\tor types in REG and MEM attrs, respectively.\n+\t(set_parm_rtl): New.\n+\t(expand_one_ssa_partition): Drop logic that assigned MEMs with\n+\tunassigned addresses.\n+\t(adjust_one_expanded_partition_var): Don't accept NULL RTL on\n+\tdeferred stack alloc vars.\n+\t(expand_used_vars): Skip partitions holding parm default defs.\n+\tMove adjust_one_expanded_partition_var loop...\n+\t(pass_expand::execute): ... here.  Drop redundant assert.\n+\tAdjust comments before the final loop over all ssa names.\n+\tRequire assigned rtl of parms and results to match exactly.\n+\tReset its attributes to match them, not any other variables in\n+\tthe same partition.\n+\t(expand_debug_expr): Use entry value for PARM's default defs\n+\tonly iff they have zero nondebug uses.\n+\t* cfgexpand.h (parm_in_stack_slot_p): Remove.\n+\t(get_rtl_for_parm_ssa_default_def): Remove.\n+\t(set_parm_rtl): Declare.\n+\t* doc/invoke.texi: Improve wording.\n+\t* explow.c (promote_decl_mode): Fix promote_function_mode for\n+\tresult decls not by reference.\n+\t(promote_ssa_mode): Disregard BLKmode from promote_decl, and\n+\tbypass TYPE_MODE to get the actual vector mode.\n+\t* function.c: Include tree-dfa.h.  Revert 2015-08-14's and\n+\t2015-08-19's changes as follows.  Drop include of\n+\tbasic-block.h and df.h.\n+\t(rtl_for_parm): Remove.\n+\t(maybe_reset_rtl_for_parm): Remove.\n+\t(parm_in_unassigned_mem_p): Remove.\n+\t(use_register_for_decl): Add logic for RESULT_DECLs matching\n+\tassign_parms' behavior.\n+\t(split_complex_args): Revert.\n+\t(assign_parms_augmented_arg_list): Revert.  Add comment\n+\treferencing the logic above.\n+\t(assign_parm_adjust_stack_rtl): Revert.\n+\t(assign_parm_setup_block): Revert.  Use set_parm_rtl instead\n+\tof SET_DECL_RTL.  Set up a REG if the parm demands so.\n+\t(assign_parm_setup_reg): Revert.  Consolidated SET_DECL_RTL\n+\tcalls into a single set_parm_rtl.  Set up a temporary RTL\n+\ttemporarily for expand_assignment.\n+\t(assign_parm_setup_stack): Revert.  Use set_parm_rtl.\n+\t(assign_parms_unsplit_complex): Revert.  Use set_parm_rtl.\n+\t(assign_bounds): Revert.\n+\t(assign_parms): Revert.  Use set_parm_rtl.\n+\t(allocate_struct_function): Relayout result and parms of\n+\tnon-abstruct functions.\n+\t(expand_function_start): Revert.  Use set_parm_rtl.  If the\n+\tresult is not a hard reg, create a pseudo from the promoted\n+\tmode of the default def.  Promote static chain mode.\n+\t* tree-outof-ssa.c (remove_ssa_form): Drop unused\n+\tpartition_has_default_def.  Set up\n+\tpartitions_for_parm_default_defs.\n+\t(finish_out_of_ssa): Remove partition_has_default_def.\n+\tRelease partitions_for_parm_default_defs.\n+\t* tree-outof-ssa.h (struct ssaexpand): Remove\n+\tpartition_has_default_def.  Add\n+\tpartitions_for_parm_default_defs.\n+\t* tree-ssa-coalesce.c: Include tree-dfa.h, tm_p.h and\n+\tstor-layout.h.\n+\t(build_ssa_conflict_graph): Fix conflict-detection of default\n+\tdefs of even unused default defs of params and results.\n+\t(for_all_parms): New.\n+\t(create_default_def): New.\n+\t(register_default_def): New.\n+\t(coalesce_with_default): New.\n+\t(create_outofssa_var_map): Create default defs for all parms\n+\tand results, and register their partitions.  Add GIMPLE_RETURN\n+\toperands as coalesce candidates with results.  Add default\n+\tdefs of each parm or result as coalesce candidates with its\n+\tother defs.  Mark each result def, and each default def of\n+\tparms, as used_in_copy.\n+\t(gimple_can_coalesce_p): Call it.  Call use_register_for_decl\n+\twith the ssa names, even anonymous ones.  Drop\n+\tparm_in_stack_slot_p calls.  Require same signedness and\n+\talignment.\n+\t(coalesce_ssa_name): Add coalesce candidates for all defs of\n+\teach parm and result, even unused ones.\n+\t(parm_default_def_partition_arg): New type.\n+\t(set_parm_default_def_partition): New.\n+\t(get_parm_default_def_partitions): New.\n+\t* tree-ssa-coalesce.h (get_parm_default_def_partitions): New.\n+\t* tree-ssa-live.c (partition_view_init): Regard unused defs of\n+\tparms and results as used.\n+\t(verify_live_on_entry): Don't error out just because they're\n+\tnot live.\n+\n 2015-09-26  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* dwarf2out.c (XCOFF_DEBUGGING_INFO): Default 0 definition."}, {"sha": "58e55d26341ae7196fdf8276b8e0024075cd9fd7", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 171, "deletions": 161, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -99,6 +99,8 @@ static rtx expand_debug_expr (tree);\n \n static bool defer_stack_allocation (tree, bool);\n \n+static void record_alignment_for_reg_var (unsigned int);\n+\n /* Return an expression tree corresponding to the RHS of GIMPLE\n    statement STMT.  */\n \n@@ -172,111 +174,86 @@ leader_merge (tree cur, tree next)\n   return cur;\n }\n \n-/* Return true if VAR is a PARM_DECL or a RESULT_DECL that ought to be\n-   assigned to a stack slot.  We can't have expand_one_ssa_partition\n-   choose their address: the pseudo holding the address would be set\n-   up too late for assign_params to copy the parameter if needed.\n-\n-   Such parameters are likely passed as a pointer to the value, rather\n-   than as a value, and so we must not coalesce them, nor allocate\n-   stack space for them before determining the calling conventions for\n-   them.\n-\n-   For their SSA_NAMEs, expand_one_ssa_partition emits RTL as MEMs\n-   with pc_rtx as the address, and then it replaces the pc_rtx with\n-   NULL so as to make sure the MEM is not used before it is adjusted\n-   in assign_parm_setup_reg.  */\n-\n-bool\n-parm_in_stack_slot_p (tree var)\n-{\n-  if (!var || VAR_P (var))\n-    return false;\n-\n-  gcc_assert (TREE_CODE (var) == PARM_DECL\n-\t      || TREE_CODE (var) == RESULT_DECL);\n-\n-  return !use_register_for_decl (var);\n-}\n-\n-/* Return the partition of the default SSA_DEF for decl VAR.  */\n-\n-static int\n-ssa_default_def_partition (tree var)\n-{\n-  tree name = ssa_default_def (cfun, var);\n-\n-  if (!name)\n-    return NO_PARTITION;\n-\n-  return var_to_partition (SA.map, name);\n-}\n-\n-/* Return the RTL for the default SSA def of a PARM or RESULT, if\n-   there is one.  */\n-\n-rtx\n-get_rtl_for_parm_ssa_default_def (tree var)\n-{\n-  gcc_assert (TREE_CODE (var) == PARM_DECL || TREE_CODE (var) == RESULT_DECL);\n-\n-  if (!is_gimple_reg (var))\n-    return NULL_RTX;\n-\n-  /* If we've already determined RTL for the decl, use it.  This is\n-     not just an optimization: if VAR is a PARM whose incoming value\n-     is unused, we won't find a default def to use its partition, but\n-     we still want to use the location of the parm, if it was used at\n-     all.  During assign_parms, until a location is assigned for the\n-     VAR, RTL can only for a parm or result if we're not coalescing\n-     across variables, when we know we're coalescing all SSA_NAMEs of\n-     each parm or result, and we're not coalescing them with names\n-     pertaining to other variables, such as other parms' default\n-     defs.  */\n-  if (DECL_RTL_SET_P (var))\n-    {\n-      gcc_assert (DECL_RTL (var) != pc_rtx);\n-      return DECL_RTL (var);\n-    }\n-\n-  int part = ssa_default_def_partition (var);\n-  if (part == NO_PARTITION)\n-    return NULL_RTX;\n-\n-  return SA.partition_to_pseudo[part];\n-}\n-\n /* Associate declaration T with storage space X.  If T is no\n    SSA name this is exactly SET_DECL_RTL, otherwise make the\n    partition of T associated with X.  */\n static inline void\n set_rtl (tree t, rtx x)\n {\n-  if (x && SSAVAR (t))\n+  gcc_checking_assert (!x\n+\t\t       || !(TREE_CODE (t) == SSA_NAME || is_gimple_reg (t))\n+\t\t       || (use_register_for_decl (t)\n+\t\t\t   ? (REG_P (x)\n+\t\t\t      || (GET_CODE (x) == CONCAT\n+\t\t\t\t  && (REG_P (XEXP (x, 0))\n+\t\t\t\t      || SUBREG_P (XEXP (x, 0)))\n+\t\t\t\t  && (REG_P (XEXP (x, 1))\n+\t\t\t\t      || SUBREG_P (XEXP (x, 1))))\n+\t\t\t      || (GET_CODE (x) == PARALLEL\n+\t\t\t\t  && SSAVAR (t)\n+\t\t\t\t  && TREE_CODE (SSAVAR (t)) == RESULT_DECL\n+\t\t\t\t  && !flag_tree_coalesce_vars))\n+\t\t\t   : (MEM_P (x) || x == pc_rtx\n+\t\t\t      || (GET_CODE (x) == CONCAT\n+\t\t\t\t  && MEM_P (XEXP (x, 0))\n+\t\t\t\t  && MEM_P (XEXP (x, 1))))));\n+  /* Check that the RTL for SSA_NAMEs and gimple-reg PARM_DECLs and\n+     RESULT_DECLs has the expected mode.  For memory, we accept\n+     unpromoted modes, since that's what we're likely to get.  For\n+     PARM_DECLs and RESULT_DECLs, we'll have been called by\n+     set_parm_rtl, which will give us the default def, so we don't\n+     have to compute it ourselves.  For RESULT_DECLs, we accept mode\n+     mismatches too, as long as we're not coalescing across variables,\n+     so that we don't reject BLKmode PARALLELs or unpromoted REGs.  */\n+  gcc_checking_assert (!x || x == pc_rtx || TREE_CODE (t) != SSA_NAME\n+\t\t       || (SSAVAR (t) && TREE_CODE (SSAVAR (t)) == RESULT_DECL\n+\t\t\t   && !flag_tree_coalesce_vars)\n+\t\t       || !use_register_for_decl (t)\n+\t\t       || GET_MODE (x) == promote_ssa_mode (t, NULL));\n+\n+  if (x)\n     {\n       bool skip = false;\n       tree cur = NULL_TREE;\n-\n-      if (MEM_P (x))\n-\tcur = MEM_EXPR (x);\n-      else if (REG_P (x))\n-\tcur = REG_EXPR (x);\n-      else if (GET_CODE (x) == CONCAT\n-\t       && REG_P (XEXP (x, 0)))\n-\tcur = REG_EXPR (XEXP (x, 0));\n-      else if (GET_CODE (x) == PARALLEL)\n-\tcur = REG_EXPR (XVECEXP (x, 0, 0));\n-      else if (x == pc_rtx)\n+      rtx xm = x;\n+\n+    retry:\n+      if (MEM_P (xm))\n+\tcur = MEM_EXPR (xm);\n+      else if (REG_P (xm))\n+\tcur = REG_EXPR (xm);\n+      else if (SUBREG_P (xm))\n+\t{\n+\t  gcc_assert (subreg_lowpart_p (xm));\n+\t  xm = SUBREG_REG (xm);\n+\t  goto retry;\n+\t}\n+      else if (GET_CODE (xm) == CONCAT)\n+\t{\n+\t  xm = XEXP (xm, 0);\n+\t  goto retry;\n+\t}\n+      else if (GET_CODE (xm) == PARALLEL)\n+\t{\n+\t  xm = XVECEXP (xm, 0, 0);\n+\t  gcc_assert (GET_CODE (xm) == EXPR_LIST);\n+\t  xm = XEXP (xm, 0);\n+\t  goto retry;\n+\t}\n+      else if (xm == pc_rtx)\n \tskip = true;\n       else\n \tgcc_unreachable ();\n \n-      tree next = skip ? cur : leader_merge (cur, SSAVAR (t));\n+      tree next = skip ? cur : leader_merge (cur, SSAVAR (t) ? SSAVAR (t) : t);\n \n       if (cur != next)\n \t{\n \t  if (MEM_P (x))\n-\t    set_mem_attributes (x, next, true);\n+\t    set_mem_attributes (x,\n+\t\t\t\tnext && TREE_CODE (next) == SSA_NAME\n+\t\t\t\t? TREE_TYPE (next)\n+\t\t\t\t: next, true);\n \t  else\n \t    set_reg_attrs_for_decl_rtl (next, x);\n \t}\n@@ -294,13 +271,11 @@ set_rtl (tree t, rtx x)\n \t}\n       /* For the benefit of debug information at -O0 (where\n          vartracking doesn't run) record the place also in the base\n-         DECL.  For PARMs and RESULTs, we may end up resetting these\n-         in function.c:maybe_reset_rtl_for_parm, but in some rare\n-         cases we may need them (unused and overwritten incoming\n-         value, that at -O0 must share the location with the other\n-         uses in spite of the missing default def), and this may be\n-         the only chance to preserve them.  */\n-      if (x && x != pc_rtx && SSA_NAME_VAR (t))\n+         DECL.  For PARMs and RESULTs, do so only when setting the\n+         default def.  */\n+      if (x && x != pc_rtx && SSA_NAME_VAR (t)\n+\t  && (VAR_P (SSA_NAME_VAR (t))\n+\t      || SSA_NAME_IS_DEFAULT_DEF (t)))\n \t{\n \t  tree var = SSA_NAME_VAR (t);\n \t  /* If we don't yet have something recorded, just record it now.  */\n@@ -1242,6 +1217,49 @@ account_stack_vars (void)\n   return size;\n }\n \n+/* Record the RTL assignment X for the default def of PARM.  */\n+\n+extern void\n+set_parm_rtl (tree parm, rtx x)\n+{\n+  gcc_assert (TREE_CODE (parm) == PARM_DECL\n+\t      || TREE_CODE (parm) == RESULT_DECL);\n+\n+  if (x && !MEM_P (x))\n+    {\n+      unsigned int align = MINIMUM_ALIGNMENT (TREE_TYPE (parm),\n+\t\t\t\t\t      TYPE_MODE (TREE_TYPE (parm)),\n+\t\t\t\t\t      TYPE_ALIGN (TREE_TYPE (parm)));\n+\n+      /* If the variable alignment is very large we'll dynamicaly\n+\t allocate it, which means that in-frame portion is just a\n+\t pointer.  ??? We've got a pseudo for sure here, do we\n+\t actually dynamically allocate its spilling area if needed?\n+\t ??? Isn't it a problem when POINTER_SIZE also exceeds\n+\t MAX_SUPPORTED_STACK_ALIGNMENT, as on cris and lm32?  */\n+      if (align > MAX_SUPPORTED_STACK_ALIGNMENT)\n+\talign = POINTER_SIZE;\n+\n+      record_alignment_for_reg_var (align);\n+    }\n+\n+  if (!is_gimple_reg (parm))\n+    return set_rtl (parm, x);\n+\n+  tree ssa = ssa_default_def (cfun, parm);\n+  if (!ssa)\n+    return set_rtl (parm, x);\n+\n+  int part = var_to_partition (SA.map, ssa);\n+  gcc_assert (part != NO_PARTITION);\n+\n+  bool changed = bitmap_bit_p (SA.partitions_for_parm_default_defs, part);\n+  gcc_assert (changed);\n+\n+  set_rtl (ssa, x);\n+  gcc_assert (DECL_RTL (parm) == x);\n+}\n+\n /* A subroutine of expand_one_var.  Called to immediately assign rtl\n    to a variable to be allocated in the stack frame.  */\n \n@@ -1349,37 +1367,7 @@ expand_one_ssa_partition (tree var)\n \n   if (!use_register_for_decl (var))\n     {\n-      /* We can't risk having the parm assigned to a MEM location\n-\t whose address references a pseudo, for the pseudo will only\n-\t be set up after arguments are copied to the stack slot.\n-\n-\t If the parm doesn't have a default def (e.g., because its\n-\t incoming value is unused), then we want to let assign_params\n-\t do the allocation, too.  In this case we want to make sure\n-\t SSA_NAMEs associated with the parm don't get assigned to more\n-\t than one partition, lest we'd create two unassigned stac\n-\t slots for the same parm, thus the assert at the end of the\n-\t block.  */\n-      if (parm_in_stack_slot_p (SSA_NAME_VAR (var))\n-\t  && (ssa_default_def_partition (SSA_NAME_VAR (var)) == part\n-\t      || !ssa_default_def (cfun, SSA_NAME_VAR (var))))\n-\t{\n-\t  expand_one_stack_var_at (var, pc_rtx, 0, 0);\n-\t  rtx x = SA.partition_to_pseudo[part];\n-\t  gcc_assert (GET_CODE (x) == MEM);\n-\t  gcc_assert (XEXP (x, 0) == pc_rtx);\n-\t  /* Reset the address, so that any attempt to use it will\n-\t     ICE.  It will be adjusted in assign_parm_setup_reg.  */\n-\t  XEXP (x, 0) = NULL_RTX;\n-\t  /* If the RTL associated with the parm is not what we have\n-\t     just created, the parm has been split over multiple\n-\t     partitions.  In order for this to work, we must have a\n-\t     default def for the parm, otherwise assign_params won't\n-\t     know what to do.  */\n-\t  gcc_assert (DECL_RTL_IF_SET (SSA_NAME_VAR (var)) == x\n-\t\t      || ssa_default_def (cfun, SSA_NAME_VAR (var)));\n-\t}\n-      else if (defer_stack_allocation (var, true))\n+      if (defer_stack_allocation (var, true))\n \tadd_stack_var (var);\n       else\n \texpand_one_stack_var_1 (var);\n@@ -1393,8 +1381,8 @@ expand_one_ssa_partition (tree var)\n   set_rtl (var, x);\n }\n \n-/* Record the association between the RTL generated for a partition\n-   and the underlying variable of the SSA_NAME.  */\n+/* Record the association between the RTL generated for partition PART\n+   and the underlying variable of the SSA_NAME VAR.  */\n \n static void\n adjust_one_expanded_partition_var (tree var)\n@@ -1410,12 +1398,7 @@ adjust_one_expanded_partition_var (tree var)\n \n   rtx x = SA.partition_to_pseudo[part];\n \n-  if (!x)\n-    {\n-      /* This var will get a stack slot later.  */\n-      gcc_assert (defer_stack_allocation (var, true));\n-      return;\n-    }\n+  gcc_assert (x);\n \n   set_rtl (var, x);\n \n@@ -2040,16 +2023,16 @@ expand_used_vars (void)\n \n   for (i = 0; i < SA.map->num_partitions; i++)\n     {\n+      if (bitmap_bit_p (SA.partitions_for_parm_default_defs, i))\n+\tcontinue;\n+\n       tree var = partition_to_var (SA.map, i);\n \n       gcc_assert (!virtual_operand_p (var));\n \n       expand_one_ssa_partition (var);\n     }\n \n-  for (i = 1; i < num_ssa_names; i++)\n-    adjust_one_expanded_partition_var (ssa_name (i));\n-\n   if (flag_stack_protect == SPCT_FLAG_STRONG)\n       gen_stack_protect_signal\n \t= stack_protect_decl_p () || stack_protect_return_slot_p ();\n@@ -4947,26 +4930,27 @@ expand_debug_expr (tree exp)\n \t  }\n \telse\n \t  {\n+\t    /* If this is a reference to an incoming value of\n+\t       parameter that is never used in the code or where the\n+\t       incoming value is never used in the code, use\n+\t       PARM_DECL's DECL_RTL if set.  */\n+\t    if (SSA_NAME_IS_DEFAULT_DEF (exp)\n+\t\t&& SSA_NAME_VAR (exp)\n+\t\t&& TREE_CODE (SSA_NAME_VAR (exp)) == PARM_DECL\n+\t\t&& has_zero_uses (exp))\n+\t      {\n+\t\top0 = expand_debug_parm_decl (SSA_NAME_VAR (exp));\n+\t\tif (op0)\n+\t\t  goto adjust_mode;\n+\t\top0 = expand_debug_expr (SSA_NAME_VAR (exp));\n+\t\tif (op0)\n+\t\t  goto adjust_mode;\n+\t      }\n+\n \t    int part = var_to_partition (SA.map, exp);\n \n \t    if (part == NO_PARTITION)\n-\t      {\n-\t\t/* If this is a reference to an incoming value of parameter\n-\t\t   that is never used in the code or where the incoming\n-\t\t   value is never used in the code, use PARM_DECL's\n-\t\t   DECL_RTL if set.  */\n-\t\tif (SSA_NAME_IS_DEFAULT_DEF (exp)\n-\t\t    && TREE_CODE (SSA_NAME_VAR (exp)) == PARM_DECL)\n-\t\t  {\n-\t\t    op0 = expand_debug_parm_decl (SSA_NAME_VAR (exp));\n-\t\t    if (op0)\n-\t\t      goto adjust_mode;\n-\t\t    op0 = expand_debug_expr (SSA_NAME_VAR (exp));\n-\t\t    if (op0)\n-\t\t      goto adjust_mode;\n-\t\t  }\n-\t\treturn NULL;\n-\t      }\n+\t      return NULL;\n \n \t    gcc_assert (part >= 0 && (unsigned)part < SA.map->num_partitions);\n \n@@ -6216,9 +6200,26 @@ pass_expand::execute (function *fun)\n       parm_birth_insn = var_seq;\n     }\n \n-  /* If we have a class containing differently aligned pointers\n-     we need to merge those into the corresponding RTL pointer\n-     alignment.  */\n+  /* Now propagate the RTL assignment of each partition to the\n+     underlying var of each SSA_NAME.  */\n+  for (i = 1; i < num_ssa_names; i++)\n+    {\n+      tree name = ssa_name (i);\n+\n+      if (!name\n+\t  /* We might have generated new SSA names in\n+\t     update_alias_info_with_stack_vars.  They will have a NULL\n+\t     defining statements, and won't be part of the partitioning,\n+\t     so ignore those.  */\n+\t  || !SSA_NAME_DEF_STMT (name))\n+\tcontinue;\n+\n+      adjust_one_expanded_partition_var (name);\n+    }\n+\n+  /* Clean up RTL of variables that straddle across multiple\n+     partitions, and check that the rtl of any PARM_DECLs that are not\n+     cleaned up is that of their default defs.  */\n   for (i = 1; i < num_ssa_names; i++)\n     {\n       tree name = ssa_name (i);\n@@ -6235,9 +6236,6 @@ pass_expand::execute (function *fun)\n       if (part == NO_PARTITION)\n \tcontinue;\n \n-      gcc_assert (SA.partition_to_pseudo[part]\n-\t\t  || defer_stack_allocation (name, true));\n-\n       /* If this decl was marked as living in multiple places, reset\n \t this now to NULL.  */\n       tree var = SSA_NAME_VAR (name);\n@@ -6252,7 +6250,19 @@ pass_expand::execute (function *fun)\n \t  rtx in = DECL_RTL_IF_SET (var);\n \t  gcc_assert (in);\n \t  rtx out = SA.partition_to_pseudo[part];\n-\t  gcc_assert (in == out || rtx_equal_p (in, out));\n+\t  gcc_assert (in == out);\n+\n+\t  /* Now reset VAR's RTL to IN, so that the _EXPR attrs match\n+\t     those expected by debug backends for each parm and for\n+\t     the result.  This is particularly important for stabs,\n+\t     whose register elimination from parm's DECL_RTL may cause\n+\t     -fcompare-debug differences as SET_DECL_RTL changes reg's\n+\t     attrs.  So, make sure the RTL already has the parm as the\n+\t     EXPR, so that it won't change.  */\n+\t  SET_DECL_RTL (var, NULL_RTX);\n+\t  if (MEM_P (in))\n+\t    set_mem_attributes (in, var, true);\n+\t  SET_DECL_RTL (var, in);\n \t}\n     }\n "}, {"sha": "88524114cb68a85b414321017e0292a778214667", "filename": "gcc/cfgexpand.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Fcfgexpand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Fcfgexpand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.h?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -22,8 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n extern tree gimple_assign_rhs_to_tree (gimple *);\n extern HOST_WIDE_INT estimated_stack_frame_size (struct cgraph_node *);\n-extern bool parm_in_stack_slot_p (tree);\n-extern rtx get_rtl_for_parm_ssa_default_def (tree var);\n+extern void set_parm_rtl (tree, rtx);\n \n \n #endif /* GCC_CFGEXPAND_H */"}, {"sha": "407eb8e8fa130d0830894a8832089c3810fd1ed1", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -8867,12 +8867,13 @@ profitable to parallelize the loops.\n \n @item -ftree-coalesce-vars\n @opindex ftree-coalesce-vars\n-Tell the compiler to attempt to combine small user-defined variables\n-too, instead of just compiler temporaries.  This may severely limit the\n-ability to debug an optimized program compiled with\n+While transforming the program out of the SSA representation, attempt to\n+reduce copying by coalescing versions of different user-defined\n+variables, instead of just compiler temporaries.  This may severely\n+limit the ability to debug an optimized program compiled with\n @option{-fno-var-tracking-assignments}.  In the negated form, this flag\n prevents SSA coalescing of user variables.  This option is enabled by\n-default if optimization is enabled.\n+default if optimization is enabled, and it does very little otherwise.\n \n @item -ftree-loop-if-convert\n @opindex ftree-loop-if-convert"}, {"sha": "d104a7939a24f11b2854a45f886c541dd1182513", "filename": "gcc/explow.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -830,8 +830,10 @@ promote_decl_mode (const_tree decl, int *punsignedp)\n   machine_mode mode = DECL_MODE (decl);\n   machine_mode pmode;\n \n-  if (TREE_CODE (decl) == RESULT_DECL\n-      || TREE_CODE (decl) == PARM_DECL)\n+  if (TREE_CODE (decl) == RESULT_DECL && !DECL_BY_REFERENCE (decl))\n+    pmode = promote_function_mode (type, mode, &unsignedp,\n+                                   TREE_TYPE (current_function_decl), 1);\n+  else if (TREE_CODE (decl) == RESULT_DECL || TREE_CODE (decl) == PARM_DECL)\n     pmode = promote_function_mode (type, mode, &unsignedp,\n                                    TREE_TYPE (current_function_decl), 2);\n   else\n@@ -857,12 +859,23 @@ promote_ssa_mode (const_tree name, int *punsignedp)\n   if (SSA_NAME_VAR (name)\n       && (TREE_CODE (SSA_NAME_VAR (name)) == PARM_DECL\n \t  || TREE_CODE (SSA_NAME_VAR (name)) == RESULT_DECL))\n-    return promote_decl_mode (SSA_NAME_VAR (name), punsignedp);\n+    {\n+      machine_mode mode = promote_decl_mode (SSA_NAME_VAR (name), punsignedp);\n+      if (mode != BLKmode)\n+\treturn mode;\n+    }\n \n   tree type = TREE_TYPE (name);\n   int unsignedp = TYPE_UNSIGNED (type);\n   machine_mode mode = TYPE_MODE (type);\n \n+  /* Bypass TYPE_MODE when it maps vector modes to BLKmode.  */\n+  if (mode == BLKmode)\n+    {\n+      gcc_assert (VECTOR_TYPE_P (type));\n+      mode = type->type_common.mode;\n+    }\n+\n   machine_mode pmode = promote_mode (type, mode, &unsignedp);\n   if (punsignedp)\n     *punsignedp = unsignedp;"}, {"sha": "e7b85328f3b334b308bbcb4b5aff8bbae48bab53", "filename": "gcc/function.c", "status": "modified", "additions": 166, "deletions": 311, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -74,15 +74,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgbuild.h\"\n #include \"cfgcleanup.h\"\n #include \"cfgexpand.h\"\n-#include \"basic-block.h\"\n-#include \"df.h\"\n #include \"params.h\"\n #include \"bb-reorder.h\"\n #include \"shrink-wrap.h\"\n #include \"toplev.h\"\n #include \"rtl-iter.h\"\n #include \"tree-chkp.h\"\n #include \"rtl-chkp.h\"\n+#include \"tree-dfa.h\"\n \n /* So we can assign to cfun in this file.  */\n #undef cfun\n@@ -152,9 +151,6 @@ static bool contains (const_rtx, hash_table<insn_cache_hasher> *);\n static void prepare_function_start (void);\n static void do_clobber_return_reg (rtx, void *);\n static void do_use_return_reg (rtx, void *);\n-static rtx rtl_for_parm (struct assign_parm_data_all *, tree);\n-static void maybe_reset_rtl_for_parm (tree);\n-static bool parm_in_unassigned_mem_p (tree, rtx);\n \n \f\n /* Stack of nested functions.  */\n@@ -2145,6 +2141,47 @@ use_register_for_decl (const_tree decl)\n   if (TREE_ADDRESSABLE (decl))\n     return false;\n \n+  /* RESULT_DECLs are a bit special in that they're assigned without\n+     regard to use_register_for_decl, but we generally only store in\n+     them.  If we coalesce their SSA NAMEs, we'd better return a\n+     result that matches the assignment in expand_function_start.  */\n+  if (TREE_CODE (decl) == RESULT_DECL)\n+    {\n+      /* If it's not an aggregate, we're going to use a REG or a\n+\t PARALLEL containing a REG.  */\n+      if (!aggregate_value_p (decl, current_function_decl))\n+\treturn true;\n+\n+      /* If expand_function_start determines the return value, we'll\n+\t use MEM if it's not by reference.  */\n+      if (cfun->returns_pcc_struct\n+\t  || (targetm.calls.struct_value_rtx\n+\t      (TREE_TYPE (current_function_decl), 1)))\n+\treturn DECL_BY_REFERENCE (decl);\n+\n+      /* Otherwise, we're taking an extra all.function_result_decl\n+\t argument.  It's set up in assign_parms_augmented_arg_list,\n+\t under the (negated) conditions above, and then it's used to\n+\t set up the RESULT_DECL rtl in assign_params, after looping\n+\t over all parameters.  Now, if the RESULT_DECL is not by\n+\t reference, we'll use a MEM either way.  */\n+      if (!DECL_BY_REFERENCE (decl))\n+\treturn false;\n+\n+      /* Otherwise, if RESULT_DECL is DECL_BY_REFERENCE, it will take\n+\t the function_result_decl's assignment.  Since it's a pointer,\n+\t we can short-circuit a number of the tests below, and we must\n+\t duplicat e them because we don't have the\n+\t function_result_decl to test.  */\n+      if (!targetm.calls.allocate_stack_slots_for_args ())\n+\treturn true;\n+      /* We don't set DECL_IGNORED_P for the function_result_decl.  */\n+      if (optimize)\n+\treturn true;\n+      /* We don't set DECL_REGISTER for the function_result_decl.  */\n+      return false;\n+    }\n+\n   /* Decl is implicitly addressible by bound stores and loads\n      if it is an aggregate holding bounds.  */\n   if (chkp_function_instrumented_p (current_function_decl)\n@@ -2272,7 +2309,7 @@ assign_parms_initialize_all (struct assign_parm_data_all *all)\n    needed, else the old list.  */\n \n static void\n-split_complex_args (struct assign_parm_data_all *all, vec<tree> *args)\n+split_complex_args (vec<tree> *args)\n {\n   unsigned i;\n   tree p;\n@@ -2283,7 +2320,6 @@ split_complex_args (struct assign_parm_data_all *all, vec<tree> *args)\n       if (TREE_CODE (type) == COMPLEX_TYPE\n \t  && targetm.calls.split_complex_arg (type))\n \t{\n-\t  tree cparm = p;\n \t  tree decl;\n \t  tree subtype = TREE_TYPE (type);\n \t  bool addressable = TREE_ADDRESSABLE (p);\n@@ -2302,9 +2338,6 @@ split_complex_args (struct assign_parm_data_all *all, vec<tree> *args)\n \t  DECL_ARTIFICIAL (p) = addressable;\n \t  DECL_IGNORED_P (p) = addressable;\n \t  TREE_ADDRESSABLE (p) = 0;\n-\t  /* Reset the RTL before layout_decl, or it may change the\n-\t     mode of the RTL of the original argument copied to P.  */\n-\t  SET_DECL_RTL (p, NULL_RTX);\n \t  layout_decl (p, 0);\n \t  (*args)[i] = p;\n \n@@ -2316,41 +2349,6 @@ split_complex_args (struct assign_parm_data_all *all, vec<tree> *args)\n \t  DECL_IGNORED_P (decl) = addressable;\n \t  layout_decl (decl, 0);\n \t  args->safe_insert (++i, decl);\n-\n-\t  /* If we are expanding a function, rather than gimplifying\n-\t     it, propagate the RTL of the complex parm to the split\n-\t     declarations, and set their contexts so that\n-\t     maybe_reset_rtl_for_parm can recognize them and refrain\n-\t     from resetting their RTL.  */\n-\t  if (currently_expanding_to_rtl)\n-\t    {\n-\t      maybe_reset_rtl_for_parm (cparm);\n-\t      rtx rtl = rtl_for_parm (all, cparm);\n-\t      if (rtl)\n-\t\t{\n-\t\t  /* If this is parm is unassigned, assign it now: the\n-\t\t     newly-created decls wouldn't expect the need for\n-\t\t     assignment, and if they were assigned\n-\t\t     independently, they might not end up in adjacent\n-\t\t     slots, so unsplit wouldn't be able to fill in the\n-\t\t     unassigned address of the complex MEM.  */\n-\t\t  if (parm_in_unassigned_mem_p (cparm, rtl))\n-\t\t    {\n-\t\t      int align = STACK_SLOT_ALIGNMENT\n-\t\t\t(TREE_TYPE (cparm), GET_MODE (rtl), MEM_ALIGN (rtl));\n-\t\t      rtx loc = assign_stack_local\n-\t\t\t(GET_MODE (rtl), GET_MODE_SIZE (GET_MODE (rtl)),\n-\t\t\t align);\n-\t\t      XEXP (rtl, 0) = XEXP (loc, 0);\n-\t\t    }\n-\n-\t\t  SET_DECL_RTL (p, read_complex_part (rtl, false));\n-\t\t  SET_DECL_RTL (decl, read_complex_part (rtl, true));\n-\n-\t\t  DECL_CONTEXT (p) = cparm;\n-\t\t  DECL_CONTEXT (decl) = cparm;\n-\t\t}\n-\t    }\n \t}\n     }\n }\n@@ -2386,6 +2384,9 @@ assign_parms_augmented_arg_list (struct assign_parm_data_all *all)\n       DECL_ARTIFICIAL (decl) = 1;\n       DECL_NAMELESS (decl) = 1;\n       TREE_CONSTANT (decl) = 1;\n+      /* We don't set DECL_IGNORED_P or DECL_REGISTER here.  If this\n+\t changes, the end of the RESULT_DECL handling block in\n+\t use_register_for_decl must be adjusted to match.  */\n \n       DECL_CHAIN (decl) = all->orig_fnargs;\n       all->orig_fnargs = decl;\n@@ -2413,7 +2414,7 @@ assign_parms_augmented_arg_list (struct assign_parm_data_all *all)\n \n   /* If the target wants to split complex arguments into scalars, do so.  */\n   if (targetm.calls.split_complex_arg)\n-    split_complex_args (all, &fnargs);\n+    split_complex_args (&fnargs);\n \n   return fnargs;\n }\n@@ -2816,98 +2817,23 @@ assign_parm_remove_parallels (struct assign_parm_data_one *data)\n   data->entry_parm = entry_parm;\n }\n \n-/* Wrapper for use_register_for_decl, that special-cases the\n-   .result_ptr as the function's RESULT_DECL when the RESULT_DECL is\n-   passed by reference.  */\n-\n-static bool\n-use_register_for_parm_decl (struct assign_parm_data_all *all, tree parm)\n-{\n-  if (parm == all->function_result_decl)\n-    {\n-      tree result = DECL_RESULT (current_function_decl);\n-\n-      if (DECL_BY_REFERENCE (result))\n-\tparm = result;\n-    }\n-\n-  return use_register_for_decl (parm);\n-}\n-\n-/* Wrapper for get_rtl_for_parm_ssa_default_def, that special-cases\n-   the .result_ptr as the function's RESULT_DECL when the RESULT_DECL\n-   is passed by reference.  */\n-\n-static rtx\n-rtl_for_parm (struct assign_parm_data_all *all, tree parm)\n-{\n-  if (parm == all->function_result_decl)\n-    {\n-      tree result = DECL_RESULT (current_function_decl);\n-\n-      if (!DECL_BY_REFERENCE (result))\n-\treturn NULL_RTX;\n-\n-      parm = result;\n-    }\n-\n-  return get_rtl_for_parm_ssa_default_def (parm);\n-}\n-\n-/* Reset the location of PARM_DECLs and RESULT_DECLs that had\n-   SSA_NAMEs in multiple partitions, so that assign_parms will choose\n-   the default def, if it exists, or create new RTL to hold the unused\n-   entry value.  If we are coalescing across variables, we want to\n-   reset the location too, because a parm without a default def\n-   (incoming value unused) might be coalesced with one with a default\n-   def, and then assign_parms would copy both incoming values to the\n-   same location, which might cause the wrong value to survive.  */\n-static void\n-maybe_reset_rtl_for_parm (tree parm)\n-{\n-  gcc_assert (TREE_CODE (parm) == PARM_DECL\n-\t      || TREE_CODE (parm) == RESULT_DECL);\n-\n-  /* This is a split complex parameter, and its context was set to its\n-     original PARM_DECL in split_complex_args so that we could\n-     recognize it here and not reset its RTL.  */\n-  if (DECL_CONTEXT (parm) && TREE_CODE (DECL_CONTEXT (parm)) == PARM_DECL)\n-    {\n-      DECL_CONTEXT (parm) = DECL_CONTEXT (DECL_CONTEXT (parm));\n-      return;\n-    }\n-\n-  if ((flag_tree_coalesce_vars\n-       || (DECL_RTL_SET_P (parm) && DECL_RTL (parm) == pc_rtx))\n-      && is_gimple_reg (parm))\n-    SET_DECL_RTL (parm, NULL_RTX);\n-}\n-\n /* A subroutine of assign_parms.  Adjust DATA->STACK_RTL such that it's\n    always valid and properly aligned.  */\n \n static void\n-assign_parm_adjust_stack_rtl (struct assign_parm_data_all *all, tree parm,\n-\t\t\t      struct assign_parm_data_one *data)\n+assign_parm_adjust_stack_rtl (struct assign_parm_data_one *data)\n {\n   rtx stack_parm = data->stack_parm;\n \n-  /* If out-of-SSA assigned RTL to the parm default def, make sure we\n-     don't use what we might have computed before.  */\n-  rtx ssa_assigned = rtl_for_parm (all, parm);\n-  if (ssa_assigned)\n-    stack_parm = NULL;\n-\n   /* If we can't trust the parm stack slot to be aligned enough for its\n      ultimate type, don't use that slot after entry.  We'll make another\n      stack slot, if we need one.  */\n-  else if (stack_parm\n-\t   && ((STRICT_ALIGNMENT\n-\t\t&& (GET_MODE_ALIGNMENT (data->nominal_mode)\n-\t\t    > MEM_ALIGN (stack_parm)))\n-\t       || (data->nominal_type\n-\t\t   && TYPE_ALIGN (data->nominal_type) > MEM_ALIGN (stack_parm)\n-\t\t   && MEM_ALIGN (stack_parm) < PREFERRED_STACK_BOUNDARY)))\n+  if (stack_parm\n+      && ((STRICT_ALIGNMENT\n+\t   && GET_MODE_ALIGNMENT (data->nominal_mode) > MEM_ALIGN (stack_parm))\n+\t  || (data->nominal_type\n+\t      && TYPE_ALIGN (data->nominal_type) > MEM_ALIGN (stack_parm)\n+\t      && MEM_ALIGN (stack_parm) < PREFERRED_STACK_BOUNDARY)))\n     stack_parm = NULL;\n \n   /* If parm was passed in memory, and we need to convert it on entry,\n@@ -2952,27 +2878,6 @@ assign_parm_setup_block_p (struct assign_parm_data_one *data)\n   return false;\n }\n \n-/* Return true if FROM_EXPAND is a MEM with an address to be filled in\n-   by assign_params.  This should be the case if, and only if,\n-   parm_in_stack_slot_p holds for the parm DECL that expanded to\n-   FROM_EXPAND, so we check that, too.  */\n-\n-static bool\n-parm_in_unassigned_mem_p (tree decl, rtx from_expand)\n-{\n-  bool result = MEM_P (from_expand) && !XEXP (from_expand, 0);\n-\n-  gcc_assert (result == parm_in_stack_slot_p (decl)\n-\t      /* Maybe it was already assigned.  That's ok, especially\n-\t\t for split complex args.  */\n-\t      || (!result && MEM_P (from_expand)\n-\t\t  && (XEXP (from_expand, 0) == virtual_stack_vars_rtx\n-\t\t      || (GET_CODE (XEXP (from_expand, 0)) == PLUS\n-\t\t\t  && XEXP (XEXP (from_expand, 0), 0) == virtual_stack_vars_rtx))));\n-\n-  return result;\n-}\n-\n /* A subroutine of assign_parms.  Arrange for the parameter to be\n    present and valid in DATA->STACK_RTL.  */\n \n@@ -2982,38 +2887,39 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n {\n   rtx entry_parm = data->entry_parm;\n   rtx stack_parm = data->stack_parm;\n+  rtx target_reg = NULL_RTX;\n   HOST_WIDE_INT size;\n   HOST_WIDE_INT size_stored;\n \n   if (GET_CODE (entry_parm) == PARALLEL)\n     entry_parm = emit_group_move_into_temps (entry_parm);\n \n+  /* If we want the parameter in a pseudo, don't use a stack slot.  */\n+  if (is_gimple_reg (parm) && use_register_for_decl (parm))\n+    {\n+      tree def = ssa_default_def (cfun, parm);\n+      gcc_assert (def);\n+      machine_mode mode = promote_ssa_mode (def, NULL);\n+      rtx reg = gen_reg_rtx (mode);\n+      if (GET_CODE (reg) != CONCAT)\n+\tstack_parm = reg;\n+      else\n+\t/* This will use or allocate a stack slot that we'd rather\n+\t   avoid.  FIXME: Could we avoid it in more cases?  */\n+\ttarget_reg = reg;\n+      data->stack_parm = NULL;\n+    }\n+\n   size = int_size_in_bytes (data->passed_type);\n   size_stored = CEIL_ROUND (size, UNITS_PER_WORD);\n-\n   if (stack_parm == 0)\n     {\n       DECL_ALIGN (parm) = MAX (DECL_ALIGN (parm), BITS_PER_WORD);\n-      rtx from_expand = rtl_for_parm (all, parm);\n-      if (from_expand && !parm_in_unassigned_mem_p (parm, from_expand))\n-\tstack_parm = copy_rtx (from_expand);\n-      else\n-\t{\n-\t  stack_parm = assign_stack_local (BLKmode, size_stored,\n-\t\t\t\t\t   DECL_ALIGN (parm));\n-\t  if (GET_MODE_SIZE (GET_MODE (entry_parm)) == size)\n-\t    PUT_MODE (stack_parm, GET_MODE (entry_parm));\n-\t  if (from_expand)\n-\t    {\n-\t      gcc_assert (GET_CODE (stack_parm) == MEM);\n-\t      gcc_assert (parm_in_unassigned_mem_p (parm, from_expand));\n-\t      XEXP (from_expand, 0) = XEXP (stack_parm, 0);\n-\t      PUT_MODE (from_expand, GET_MODE (stack_parm));\n-\t      stack_parm = copy_rtx (from_expand);\n-\t    }\n-\t  else\n-\t    set_mem_attributes (stack_parm, parm, 1);\n-\t}\n+      stack_parm = assign_stack_local (BLKmode, size_stored,\n+\t\t\t\t       DECL_ALIGN (parm));\n+      if (GET_MODE_SIZE (GET_MODE (entry_parm)) == size)\n+\tPUT_MODE (stack_parm, GET_MODE (entry_parm));\n+      set_mem_attributes (stack_parm, parm, 1);\n     }\n \n   /* If a BLKmode arrives in registers, copy it to a stack slot.  Handle\n@@ -3054,11 +2960,6 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n       else if (size == 0)\n \t;\n \n-      /* MEM may be a REG if coalescing assigns the param's partition\n-\t to a pseudo.  */\n-      else if (REG_P (mem))\n-\temit_move_insn (mem, entry_parm);\n-\n       /* If SIZE is that of a mode no bigger than a word, just use\n \t that mode's store operation.  */\n       else if (size <= UNITS_PER_WORD)\n@@ -3113,10 +3014,14 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \t      tem = change_address (mem, word_mode, 0);\n \t      emit_move_insn (tem, x);\n \t    }\n+\t  else if (!MEM_P (mem))\n+\t    emit_move_insn (mem, entry_parm);\n \t  else\n \t    move_block_from_reg (REGNO (entry_parm), mem,\n \t\t\t\t size_stored / UNITS_PER_WORD);\n \t}\n+      else if (!MEM_P (mem))\n+\temit_move_insn (mem, entry_parm);\n       else\n \tmove_block_from_reg (REGNO (entry_parm), mem,\n \t\t\t     size_stored / UNITS_PER_WORD);\n@@ -3131,8 +3036,14 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n       end_sequence ();\n     }\n \n+  if (target_reg)\n+    {\n+      emit_move_insn (target_reg, stack_parm);\n+      stack_parm = target_reg;\n+    }\n+\n   data->stack_parm = stack_parm;\n-  SET_DECL_RTL (parm, stack_parm);\n+  set_parm_rtl (parm, stack_parm);\n }\n \n /* A subroutine of assign_parms.  Allocate a pseudo to hold the current\n@@ -3148,6 +3059,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (parm));\n   bool did_conversion = false;\n   bool need_conversion, moved;\n+  rtx rtl;\n \n   /* Store the parm in a pseudoregister during the function, but we may\n      need to do it in a wider mode.  Using 2 here makes the result\n@@ -3156,54 +3068,30 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n     = promote_function_mode (data->nominal_type, data->nominal_mode, &unsignedp,\n \t\t\t     TREE_TYPE (current_function_decl), 2);\n \n-  rtx from_expand = parmreg = rtl_for_parm (all, parm);\n-\n-  if (from_expand && !data->passed_pointer)\n-    {\n-      if (GET_MODE (parmreg) != promoted_nominal_mode)\n-\tparmreg = gen_lowpart (promoted_nominal_mode, parmreg);\n-    }\n-  else if (!from_expand || parm_in_unassigned_mem_p (parm, from_expand))\n-    {\n-      parmreg = gen_reg_rtx (promoted_nominal_mode);\n-      if (!DECL_ARTIFICIAL (parm))\n-\tmark_user_reg (parmreg);\n-\n-      if (from_expand)\n-\t{\n-\t  gcc_assert (data->passed_pointer);\n-\t  gcc_assert (GET_CODE (from_expand) == MEM\n-\t\t      && XEXP (from_expand, 0) == NULL_RTX);\n-\t  XEXP (from_expand, 0) = parmreg;\n-\t}\n-    }\n+  parmreg = gen_reg_rtx (promoted_nominal_mode);\n+  if (!DECL_ARTIFICIAL (parm))\n+    mark_user_reg (parmreg);\n \n   /* If this was an item that we received a pointer to,\n-     set DECL_RTL appropriately.  */\n-  if (from_expand)\n-    SET_DECL_RTL (parm, from_expand);\n-  else if (data->passed_pointer)\n+     set rtl appropriately.  */\n+  if (data->passed_pointer)\n     {\n-      rtx x = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (data->passed_type)), parmreg);\n-      set_mem_attributes (x, parm, 1);\n-      SET_DECL_RTL (parm, x);\n+      rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (data->passed_type)), parmreg);\n+      set_mem_attributes (rtl, parm, 1);\n     }\n   else\n-    SET_DECL_RTL (parm, parmreg);\n+    rtl = parmreg;\n \n   assign_parm_remove_parallels (data);\n \n   /* Copy the value into the register, thus bridging between\n      assign_parm_find_data_types and expand_expr_real_1.  */\n \n   equiv_stack_parm = data->stack_parm;\n-  if (!equiv_stack_parm)\n-    equiv_stack_parm = data->entry_parm;\n   validated_mem = validize_mem (copy_rtx (data->entry_parm));\n \n   need_conversion = (data->nominal_mode != data->passed_mode\n \t\t     || promoted_nominal_mode != data->promoted_mode);\n-  gcc_assert (!(need_conversion && data->passed_pointer && from_expand));\n   moved = false;\n \n   if (need_conversion\n@@ -3327,36 +3215,26 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \n       /* TREE_USED gets set erroneously during expand_assignment.  */\n       save_tree_used = TREE_USED (parm);\n+      SET_DECL_RTL (parm, rtl);\n       expand_assignment (parm, make_tree (data->nominal_type, tempreg), false);\n+      SET_DECL_RTL (parm, NULL_RTX);\n       TREE_USED (parm) = save_tree_used;\n       all->first_conversion_insn = get_insns ();\n       all->last_conversion_insn = get_last_insn ();\n       end_sequence ();\n \n       did_conversion = true;\n     }\n-  /* We don't want to copy the incoming pointer to a parmreg expected\n-     to hold the value rather than the pointer.  */\n-  else if (!data->passed_pointer || parmreg != from_expand)\n+  else\n     emit_move_insn (parmreg, validated_mem);\n \n   /* If we were passed a pointer but the actual value can safely live\n      in a register, retrieve it and use it directly.  */\n-  if (data->passed_pointer\n-      && (from_expand || TYPE_MODE (TREE_TYPE (parm)) != BLKmode))\n+  if (data->passed_pointer && TYPE_MODE (TREE_TYPE (parm)) != BLKmode)\n     {\n-      rtx src = DECL_RTL (parm);\n-\n       /* We can't use nominal_mode, because it will have been set to\n \t Pmode above.  We must use the actual mode of the parm.  */\n-      if (from_expand)\n-\t{\n-\t  parmreg = from_expand;\n-\t  gcc_assert (GET_MODE (parmreg) == TYPE_MODE (TREE_TYPE (parm)));\n-\t  src = gen_rtx_MEM (GET_MODE (parmreg), validated_mem);\n-\t  set_mem_attributes (src, parm, 1);\n-\t}\n-      else if (use_register_for_decl (parm))\n+      if (use_register_for_decl (parm))\n \t{\n \t  parmreg = gen_reg_rtx (TYPE_MODE (TREE_TYPE (parm)));\n \t  mark_user_reg (parmreg);\n@@ -3373,14 +3251,14 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t  set_mem_attributes (parmreg, parm, 1);\n \t}\n \n-      if (GET_MODE (parmreg) != GET_MODE (src))\n+      if (GET_MODE (parmreg) != GET_MODE (rtl))\n \t{\n-\t  rtx tempreg = gen_reg_rtx (GET_MODE (src));\n+\t  rtx tempreg = gen_reg_rtx (GET_MODE (rtl));\n \t  int unsigned_p = TYPE_UNSIGNED (TREE_TYPE (parm));\n \n \t  push_to_sequence2 (all->first_conversion_insn,\n \t\t\t     all->last_conversion_insn);\n-\t  emit_move_insn (tempreg, src);\n+\t  emit_move_insn (tempreg, rtl);\n \t  tempreg = convert_to_mode (GET_MODE (parmreg), tempreg, unsigned_p);\n \t  emit_move_insn (parmreg, tempreg);\n \t  all->first_conversion_insn = get_insns ();\n@@ -3389,30 +3267,30 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \n \t  did_conversion = true;\n \t}\n-      else if (GET_MODE (parmreg) == BLKmode)\n-\tgcc_assert (parm_in_stack_slot_p (parm));\n       else\n-\temit_move_insn (parmreg, src);\n+\temit_move_insn (parmreg, rtl);\n \n-      SET_DECL_RTL (parm, parmreg);\n+      rtl = parmreg;\n \n       /* STACK_PARM is the pointer, not the parm, and PARMREG is\n \t now the parm.  */\n-      data->stack_parm = equiv_stack_parm = NULL;\n+      data->stack_parm = NULL;\n     }\n \n+  set_parm_rtl (parm, rtl);\n+\n   /* Mark the register as eliminable if we did no conversion and it was\n      copied from memory at a fixed offset, and the arg pointer was not\n      copied to a pseudo-reg.  If the arg pointer is a pseudo reg or the\n      offset formed an invalid address, such memory-equivalences as we\n      make here would screw up life analysis for it.  */\n   if (data->nominal_mode == data->passed_mode\n       && !did_conversion\n-      && equiv_stack_parm != 0\n-      && MEM_P (equiv_stack_parm)\n+      && data->stack_parm != 0\n+      && MEM_P (data->stack_parm)\n       && data->locate.offset.var == 0\n       && reg_mentioned_p (virtual_incoming_args_rtx,\n-\t\t\t  XEXP (equiv_stack_parm, 0)))\n+\t\t\t  XEXP (data->stack_parm, 0)))\n     {\n       rtx_insn *linsn = get_last_insn ();\n       rtx_insn *sinsn;\n@@ -3425,8 +3303,8 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t    = GET_MODE_INNER (GET_MODE (parmreg));\n \t  int regnor = REGNO (XEXP (parmreg, 0));\n \t  int regnoi = REGNO (XEXP (parmreg, 1));\n-\t  rtx stackr = adjust_address_nv (equiv_stack_parm, submode, 0);\n-\t  rtx stacki = adjust_address_nv (equiv_stack_parm, submode,\n+\t  rtx stackr = adjust_address_nv (data->stack_parm, submode, 0);\n+\t  rtx stacki = adjust_address_nv (data->stack_parm, submode,\n \t\t\t\t\t  GET_MODE_SIZE (submode));\n \n \t  /* Scan backwards for the set of the real and\n@@ -3444,7 +3322,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t\tset_unique_reg_note (sinsn, REG_EQUIV, stackr);\n \t    }\n \t}\n-      else \n+      else\n \tset_dst_reg_note (linsn, REG_EQUIV, equiv_stack_parm, parmreg);\n     }\n \n@@ -3496,16 +3374,6 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n   if (data->entry_parm != data->stack_parm)\n     {\n       rtx src, dest;\n-      rtx from_expand = NULL_RTX;\n-\n-      if (data->stack_parm == 0)\n-\t{\n-\t  from_expand = rtl_for_parm (all, parm);\n-\t  if (from_expand)\n-\t    gcc_assert (GET_MODE (from_expand) == GET_MODE (data->entry_parm));\n-\t  if (from_expand && !parm_in_unassigned_mem_p (parm, from_expand))\n-\t    data->stack_parm = from_expand;\n-\t}\n \n       if (data->stack_parm == 0)\n \t{\n@@ -3516,16 +3384,7 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n \t    = assign_stack_local (GET_MODE (data->entry_parm),\n \t\t\t\t  GET_MODE_SIZE (GET_MODE (data->entry_parm)),\n \t\t\t\t  align);\n-\t  if (!from_expand)\n-\t    set_mem_attributes (data->stack_parm, parm, 1);\n-\t  else\n-\t    {\n-\t      gcc_assert (GET_CODE (data->stack_parm) == MEM);\n-\t      gcc_assert (parm_in_unassigned_mem_p (parm, from_expand));\n-\t      XEXP (from_expand, 0) = XEXP (data->stack_parm, 0);\n-\t      PUT_MODE (from_expand, GET_MODE (data->stack_parm));\n-\t      data->stack_parm = copy_rtx (from_expand);\n-\t    }\n+\t  set_mem_attributes (data->stack_parm, parm, 1);\n \t}\n \n       dest = validize_mem (copy_rtx (data->stack_parm));\n@@ -3554,7 +3413,7 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n       end_sequence ();\n     }\n \n-  SET_DECL_RTL (parm, data->stack_parm);\n+  set_parm_rtl (parm, data->stack_parm);\n }\n \n /* A subroutine of assign_parms.  If the ABI splits complex arguments, then\n@@ -3580,21 +3439,11 @@ assign_parms_unsplit_complex (struct assign_parm_data_all *all,\n \t  imag = DECL_RTL (fnargs[i + 1]);\n \t  if (inner != GET_MODE (real))\n \t    {\n-\t      real = simplify_gen_subreg (inner, real, GET_MODE (real),\n-\t\t\t\t\t  subreg_lowpart_offset\n-\t\t\t\t\t  (inner, GET_MODE (real)));\n-\t      imag = simplify_gen_subreg (inner, imag, GET_MODE (imag),\n-\t\t\t\t\t  subreg_lowpart_offset\n-\t\t\t\t\t  (inner, GET_MODE (imag)));\n+\t      real = gen_lowpart_SUBREG (inner, real);\n+\t      imag = gen_lowpart_SUBREG (inner, imag);\n \t    }\n \n-\t  if ((tmp = rtl_for_parm (all, parm)) != NULL_RTX\n-\t      && rtx_equal_p (real,\n-\t\t\t      read_complex_part (tmp, false))\n-\t      && rtx_equal_p (imag,\n-\t\t\t      read_complex_part (tmp, true)))\n-\t    ; /* We now have the right rtl in tmp.  */\n-\t  else if (TREE_ADDRESSABLE (parm))\n+\t  if (TREE_ADDRESSABLE (parm))\n \t    {\n \t      rtx rmem, imem;\n \t      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (parm));\n@@ -3618,7 +3467,7 @@ assign_parms_unsplit_complex (struct assign_parm_data_all *all,\n \t    }\n \t  else\n \t    tmp = gen_rtx_CONCAT (DECL_MODE (parm), real, imag);\n-\t  SET_DECL_RTL (parm, tmp);\n+\t  set_parm_rtl (parm, tmp);\n \n \t  real = DECL_INCOMING_RTL (fnargs[i]);\n \t  imag = DECL_INCOMING_RTL (fnargs[i + 1]);\n@@ -3740,7 +3589,7 @@ assign_bounds (vec<bounds_parm_data> &bndargs,\n \t  assign_parm_setup_block (&all, pbdata->bounds_parm,\n \t\t\t\t   &pbdata->parm_data);\n \telse if (pbdata->parm_data.passed_pointer\n-\t\t || use_register_for_parm_decl (&all, pbdata->bounds_parm))\n+\t\t || use_register_for_decl (pbdata->bounds_parm))\n \t  assign_parm_setup_reg (&all, pbdata->bounds_parm,\n \t\t\t\t &pbdata->parm_data);\n \telse\n@@ -3784,8 +3633,6 @@ assign_parms (tree fndecl)\n \t  DECL_INCOMING_RTL (parm) = DECL_RTL (parm);\n \t  continue;\n \t}\n-      else\n-\tmaybe_reset_rtl_for_parm (parm);\n \n       /* Estimate stack alignment from parameter alignment.  */\n       if (SUPPORTS_STACK_ALIGNMENT)\n@@ -3835,7 +3682,7 @@ assign_parms (tree fndecl)\n       else\n \tset_decl_incoming_rtl (parm, data.entry_parm, false);\n \n-      assign_parm_adjust_stack_rtl (&all, parm, &data);\n+      assign_parm_adjust_stack_rtl (&data);\n \n       /* Bounds should be loaded in the particular order to\n \t have registers allocated correctly.  Collect info about\n@@ -3856,8 +3703,7 @@ assign_parms (tree fndecl)\n \t{\n \t  if (assign_parm_setup_block_p (&data))\n \t    assign_parm_setup_block (&all, parm, &data);\n-\t  else if (data.passed_pointer\n-\t\t   || use_register_for_parm_decl (&all, parm))\n+\t  else if (data.passed_pointer || use_register_for_decl (parm))\n \t    assign_parm_setup_reg (&all, parm, &data);\n \t  else\n \t    assign_parm_setup_stack (&all, parm, &data);\n@@ -3954,7 +3800,7 @@ assign_parms (tree fndecl)\n \n       DECL_HAS_VALUE_EXPR_P (result) = 1;\n \n-      SET_DECL_RTL (result, x);\n+      set_parm_rtl (result, x);\n     }\n \n   /* We have aligned all the args, so add space for the pretend args.  */\n@@ -4986,6 +4832,18 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n   if (fndecl != NULL_TREE)\n     {\n       tree result = DECL_RESULT (fndecl);\n+\n+      if (!abstract_p)\n+\t{\n+\t  /* Now that we have activated any function-specific attributes\n+\t     that might affect layout, particularly vector modes, relayout\n+\t     each of the parameters and the result.  */\n+\t  relayout_decl (result);\n+\t  for (tree parm = DECL_ARGUMENTS (fndecl); parm;\n+\t       parm = DECL_CHAIN (parm))\n+\t    relayout_decl (parm);\n+\t}\n+\n       if (!abstract_p && aggregate_value_p (result, fndecl))\n \t{\n #ifdef PCC_STATIC_STRUCT_RETURN\n@@ -5189,7 +5047,6 @@ expand_function_start (tree subr)\n \n   /* Decide whether to return the value in memory or in a register.  */\n   tree res = DECL_RESULT (subr);\n-  maybe_reset_rtl_for_parm (res);\n   if (aggregate_value_p (res, subr))\n     {\n       /* Returning something that won't go in a register.  */\n@@ -5210,10 +5067,7 @@ expand_function_start (tree subr)\n \t     it.  */\n \t  if (sv)\n \t    {\n-\t      if (DECL_BY_REFERENCE (res))\n-\t\tvalue_address = get_rtl_for_parm_ssa_default_def (res);\n-\t      if (!value_address)\n-\t\tvalue_address = gen_reg_rtx (Pmode);\n+\t      value_address = gen_reg_rtx (Pmode);\n \t      emit_move_insn (value_address, sv);\n \t    }\n \t}\n@@ -5222,33 +5076,35 @@ expand_function_start (tree subr)\n \t  rtx x = value_address;\n \t  if (!DECL_BY_REFERENCE (res))\n \t    {\n-\t      x = get_rtl_for_parm_ssa_default_def (res);\n-\t      if (!x)\n-\t\t{\n-\t\t  x = gen_rtx_MEM (DECL_MODE (res), value_address);\n-\t\t  set_mem_attributes (x, res, 1);\n-\t\t}\n+\t      x = gen_rtx_MEM (DECL_MODE (res), x);\n+\t      set_mem_attributes (x, res, 1);\n \t    }\n-\t  SET_DECL_RTL (res, x);\n+\t  set_parm_rtl (res, x);\n \t}\n     }\n   else if (DECL_MODE (res) == VOIDmode)\n     /* If return mode is void, this decl rtl should not be used.  */\n-    SET_DECL_RTL (res, NULL_RTX);\n-  else\n+    set_parm_rtl (res, NULL_RTX);\n+  else \n     {\n       /* Compute the return values into a pseudo reg, which we will copy\n \t into the true return register after the cleanups are done.  */\n       tree return_type = TREE_TYPE (res);\n-      rtx x = get_rtl_for_parm_ssa_default_def (res);\n-      if (x)\n-\t/* Use it.  */;\n+      /* If we may coalesce this result, make sure it has the expected\n+\t mode.  */\n+      if (flag_tree_coalesce_vars && is_gimple_reg (res))\n+\t{\n+\t  tree def = ssa_default_def (cfun, res);\n+\t  gcc_assert (def);\n+\t  machine_mode mode = promote_ssa_mode (def, NULL);\n+\t  set_parm_rtl (res, gen_reg_rtx (mode));\n+\t}\n       else if (TYPE_MODE (return_type) != BLKmode\n \t       && targetm.calls.return_in_msb (return_type))\n \t/* expand_function_end will insert the appropriate padding in\n \t   this case.  Use the return value's natural (unpadded) mode\n \t   within the function proper.  */\n-\tx = gen_reg_rtx (TYPE_MODE (return_type));\n+\tset_parm_rtl (res, gen_reg_rtx (TYPE_MODE (return_type)));\n       else\n \t{\n \t  /* In order to figure out what mode to use for the pseudo, we\n@@ -5259,16 +5115,14 @@ expand_function_start (tree subr)\n \t  /* Structures that are returned in registers are not\n \t     aggregate_value_p, so we may see a PARALLEL or a REG.  */\n \t  if (REG_P (hard_reg))\n-\t    x = gen_reg_rtx (GET_MODE (hard_reg));\n+\t    set_parm_rtl (res, gen_reg_rtx (GET_MODE (hard_reg)));\n \t  else\n \t    {\n \t      gcc_assert (GET_CODE (hard_reg) == PARALLEL);\n-\t      x = gen_group_rtx (hard_reg);\n+\t      set_parm_rtl (res, gen_group_rtx (hard_reg));\n \t    }\n \t}\n \n-      SET_DECL_RTL (res, x);\n-\n       /* Set DECL_REGISTER flag so that expand_function_end will copy the\n \t result to the real return register(s).  */\n       DECL_REGISTER (res) = 1;\n@@ -5291,22 +5145,23 @@ expand_function_start (tree subr)\n     {\n       tree parm = cfun->static_chain_decl;\n       rtx local, chain;\n-     rtx_insn *insn;\n+      rtx_insn *insn;\n+      int unsignedp;\n \n-      local = get_rtl_for_parm_ssa_default_def (parm);\n-      if (!local)\n-\tlocal = gen_reg_rtx (Pmode);\n+      local = gen_reg_rtx (promote_decl_mode (parm, &unsignedp));\n       chain = targetm.calls.static_chain (current_function_decl, true);\n \n       set_decl_incoming_rtl (parm, chain, false);\n-      SET_DECL_RTL (parm, local);\n+      set_parm_rtl (parm, local);\n       mark_reg_pointer (local, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm))));\n \n-      if (GET_MODE (local) != Pmode)\n-\tlocal = convert_to_mode (Pmode, local,\n-\t\t\t\t TYPE_UNSIGNED (TREE_TYPE (parm)));\n-\n-      insn = emit_move_insn (local, chain);\n+      if (GET_MODE (local) != GET_MODE (chain))\n+\t{\n+\t  convert_move (local, chain, unsignedp);\n+\t  insn = get_last_insn ();\n+\t}\n+      else\n+\tinsn = emit_move_insn (local, chain);\n \n       /* Mark the register as eliminable, similar to parameters.  */\n       if (MEM_P (chain)"}, {"sha": "36bc937664eca7812f8f6c0981d2e17133df9d79", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -1,3 +1,10 @@\n+2015-09-27  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR rtl-optimization/64164\n+\tPR tree-optimization/67312\n+\t* gcc.dg/pr67312.c: New.  From Zdenek Sojka.\n+\t* gcc.target/i386/stackalign/return-4.c: Add -O.\n+\n 2015-09-27  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* g++.dg/debug/dwarf2/pr44641.C: Add one to expected line numbers."}, {"sha": "f1c9fdedbd5191b3f3e7b6949011a6cdaf1afc4d", "filename": "gcc/testsuite/gcc.dg/pr67312.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftestsuite%2Fgcc.dg%2Fpr67312.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftestsuite%2Fgcc.dg%2Fpr67312.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr67312.c?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -ftree-coalesce-vars\" } */\n+\n+void foo (int x, int y)\n+{\n+    y = x;\n+}"}, {"sha": "d14eb2fa9df0409dd212a7d36d7f22e2345798f3", "filename": "gcc/testsuite/gcc.target/i386/stackalign/return-4.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstackalign%2Freturn-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstackalign%2Freturn-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstackalign%2Freturn-4.c?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -1,6 +1,13 @@\n /* { dg-do compile } */\n-/* { dg-options \"-mpreferred-stack-boundary=4\" } */\n+/* { dg-options \"-mpreferred-stack-boundary=4 -O\" } */\n /* { dg-final { scan-assembler-not \"and\\[lq\\]?\\[^\\\\n\\]*-64,\\[^\\\\n\\]*sp\" } } */\n+/* We only guarantee we won't generate the stack alignment when\n+   optimizing.  When not optimizing, the return value will be assigned\n+   to a pseudo with the specified alignment, which in turn will force\n+   stack alignment since the pseudo might have to be spilled.  Without\n+   optimization, we wouldn't compute the actual stack requirements\n+   after register allocation and reload, and just use the conservative\n+   estimate.  */\n \n /* This compile only test is to detect an assertion failure in stack branch\n    development.  */"}, {"sha": "8dc4908038a48644af9990804a68dcbd10941c6b", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -980,7 +980,6 @@ remove_ssa_form (bool perform_ter, struct ssaexpand *sa)\n {\n   bitmap values = NULL;\n   var_map map;\n-  unsigned i;\n \n   map = coalesce_ssa_name ();\n \n@@ -1005,17 +1004,7 @@ remove_ssa_form (bool perform_ter, struct ssaexpand *sa)\n \n   sa->map = map;\n   sa->values = values;\n-  sa->partition_has_default_def = BITMAP_ALLOC (NULL);\n-  for (i = 1; i < num_ssa_names; i++)\n-    {\n-      tree t = ssa_name (i);\n-      if (t && SSA_NAME_IS_DEFAULT_DEF (t))\n-\t{\n-\t  int p = var_to_partition (map, t);\n-\t  if (p != NO_PARTITION)\n-\t    bitmap_set_bit (sa->partition_has_default_def, p);\n-\t}\n-    }\n+  sa->partitions_for_parm_default_defs = get_parm_default_def_partitions (map);\n }\n \n \n@@ -1190,7 +1179,7 @@ finish_out_of_ssa (struct ssaexpand *sa)\n   if (sa->values)\n     BITMAP_FREE (sa->values);\n   delete_var_map (sa->map);\n-  BITMAP_FREE (sa->partition_has_default_def);\n+  BITMAP_FREE (sa->partitions_for_parm_default_defs);\n   memset (sa, 0, sizeof *sa);\n }\n "}, {"sha": "60b637980735a9e2da9d88699d9664dd775cbbe7", "filename": "gcc/tree-outof-ssa.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftree-outof-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftree-outof-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.h?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -39,9 +39,9 @@ struct ssaexpand\n      a pseudos REG).  */\n   rtx *partition_to_pseudo;\n \n-  /* If partition I contains an SSA name that has a default def,\n-     bit I will be set in this bitmap.  */\n-  bitmap partition_has_default_def;\n+  /* If partition I contains an SSA name that has a default def for a\n+     parameter, bit I will be set in this bitmap.  */\n+  bitmap partitions_for_parm_default_defs;\n };\n \n /* This is the singleton described above.  */"}, {"sha": "ff7587742b82f0ba7ca3befe00003b08704ff4c7", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 193, "deletions": 38, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -39,7 +39,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgexpand.h\"\n #include \"explow.h\"\n #include \"diagnostic-core.h\"\n-\n+#include \"tree-dfa.h\"\n+#include \"tm_p.h\"\n+#include \"stor-layout.h\"\n \n /* This set of routines implements a coalesce_list.  This is an object which\n    is used to track pairs of ssa_names which are desirable to coalesce\n@@ -877,26 +879,30 @@ build_ssa_conflict_graph (tree_live_info_p liveinfo)\n \t}\n \n       /* Pretend there are defs for params' default defs at the start\n-\t of the (post-)entry block.  */\n+\t of the (post-)entry block.  This will prevent PARM_DECLs from\n+\t coalescing into the same partition.  Although RESULT_DECLs'\n+\t default defs don't have a useful initial value, we have to\n+\t prevent them from coalescing with PARM_DECLs' default defs\n+\t too, otherwise assign_parms would attempt to assign different\n+\t RTL to the same partition.  */\n       if (bb == entry)\n \t{\n-\t  unsigned base;\n-\t  bitmap_iterator bi;\n-\t  EXECUTE_IF_SET_IN_BITMAP (live->live_base_var, 0, base, bi)\n+\t  unsigned i;\n+\t  for (i = 1; i < num_ssa_names; i++)\n \t    {\n-\t      bitmap_iterator bi2;\n-\t      unsigned part;\n-\t      EXECUTE_IF_SET_IN_BITMAP (live->live_base_partitions[base],\n-\t\t\t\t\t0, part, bi2)\n-\t\t{\n-\t\t  tree var = partition_to_var (map, part);\n-\t\t  if (!SSA_NAME_VAR (var)\n-\t\t      || (TREE_CODE (SSA_NAME_VAR (var)) != PARM_DECL\n-\t\t\t  && TREE_CODE (SSA_NAME_VAR (var)) != RESULT_DECL)\n-\t\t      || !SSA_NAME_IS_DEFAULT_DEF (var))\n-\t\t    continue;\n-\t\t  live_track_process_def (live, var, graph);\n-\t\t}\n+\t      tree var = ssa_name (i);\n+\n+\t      if (!var\n+\t\t  || !SSA_NAME_IS_DEFAULT_DEF (var)\n+\t\t  || !SSA_NAME_VAR (var)\n+\t\t  || VAR_P (SSA_NAME_VAR (var)))\n+\t\tcontinue;\n+\n+\t      live_track_process_def (live, var, graph);\n+\t      /* Process a use too, so that it remains live and\n+\t\t conflicts with other parms' default defs, even unused\n+\t\t ones.  */\n+\t      live_track_process_use (live, var);\n \t    }\n \t}\n \n@@ -937,6 +943,71 @@ fail_abnormal_edge_coalesce (int x, int y)\n   internal_error (\"SSA corruption\");\n }\n \n+/* Call CALLBACK for all PARM_DECLs and RESULT_DECLs for which\n+   assign_parms may ask for a default partition.  */\n+\n+static void\n+for_all_parms (void (*callback)(tree var, void *arg), void *arg)\n+{\n+  for (tree var = DECL_ARGUMENTS (current_function_decl); var;\n+       var = DECL_CHAIN (var))\n+    callback (var, arg);\n+  if (!VOID_TYPE_P (TREE_TYPE (DECL_RESULT (current_function_decl))))\n+    callback (DECL_RESULT (current_function_decl), arg);\n+  if (cfun->static_chain_decl)\n+    callback (cfun->static_chain_decl, arg);\n+}\n+\n+/* Create a default def for VAR.  */\n+\n+static void\n+create_default_def (tree var, void *arg ATTRIBUTE_UNUSED)\n+{\n+  if (!is_gimple_reg (var))\n+    return;\n+\n+  tree ssa = get_or_create_ssa_default_def (cfun, var);\n+  gcc_assert (ssa);\n+}\n+\n+/* Register VAR's default def in MAP.  */\n+\n+static void\n+register_default_def (tree var, void *map_)\n+{\n+  var_map map = (var_map)map_;\n+\n+  if (!is_gimple_reg (var))\n+    return;\n+\n+  tree ssa = ssa_default_def (cfun, var);\n+  gcc_assert (ssa);\n+\n+  register_ssa_partition (map, ssa);\n+}\n+\n+/* If VAR is an SSA_NAME associated with a PARM_DECL or a RESULT_DECL,\n+   and the DECL's default def is unused (i.e., it was introduced by\n+   create_default_def), mark VAR and the default def for\n+   coalescing.  */\n+\n+static void\n+coalesce_with_default (tree var, coalesce_list_p cl, bitmap used_in_copy)\n+{\n+  if (SSA_NAME_IS_DEFAULT_DEF (var)\n+      || !SSA_NAME_VAR (var)\n+      || VAR_P (SSA_NAME_VAR (var)))\n+    return;\n+\n+  tree ssa = ssa_default_def (cfun, SSA_NAME_VAR (var));\n+  if (!has_zero_uses (ssa))\n+    return;\n+\n+  add_cost_one_coalesce (cl, SSA_NAME_VERSION (ssa), SSA_NAME_VERSION (var));\n+  bitmap_set_bit (used_in_copy, SSA_NAME_VERSION (var));\n+  /* Default defs will have their used_in_copy bits set at the end of\n+     create_outofssa_var_map.  */\n+}\n \n /* This function creates a var_map for the current function as well as creating\n    a coalesce list for use later in the out of ssa process.  */\n@@ -954,8 +1025,12 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n   int v1, v2, cost;\n   unsigned i;\n \n+  for_all_parms (create_default_def, NULL);\n+\n   map = init_var_map (num_ssa_names);\n \n+  for_all_parms (register_default_def, map);\n+\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       tree arg;\n@@ -1034,6 +1109,30 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t      }\n \t      break;\n \n+\t    case GIMPLE_RETURN:\n+\t      {\n+\t\ttree res = DECL_RESULT (current_function_decl);\n+\t\tif (VOID_TYPE_P (TREE_TYPE (res))\n+\t\t    || !is_gimple_reg (res))\n+\t\t  break;\n+\t\ttree rhs1 = gimple_return_retval (as_a <greturn *> (stmt));\n+\t\tif (!rhs1)\n+\t\t  break;\n+\t\ttree lhs = ssa_default_def (cfun, res);\n+\t\tgcc_assert (lhs);\n+\t\tif (TREE_CODE (rhs1) == SSA_NAME\n+\t\t    && gimple_can_coalesce_p (lhs, rhs1))\n+\t\t  {\n+\t\t    v1 = SSA_NAME_VERSION (lhs);\n+\t\t    v2 = SSA_NAME_VERSION (rhs1);\n+\t\t    cost = coalesce_cost_bb (bb);\n+\t\t    add_coalesce (cl, v1, v2, cost);\n+\t\t    bitmap_set_bit (used_in_copy, v1);\n+\t\t    bitmap_set_bit (used_in_copy, v2);\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\n \t    case GIMPLE_ASM:\n \t      {\n \t\tgasm *asm_stmt = as_a <gasm *> (stmt);\n@@ -1100,19 +1199,20 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n       var = ssa_name (i);\n       if (var != NULL_TREE && !virtual_operand_p (var))\n         {\n+\t  coalesce_with_default (var, cl, used_in_copy);\n+\n \t  /* Add coalesces between all the result decls.  */\n \t  if (SSA_NAME_VAR (var)\n \t      && TREE_CODE (SSA_NAME_VAR (var)) == RESULT_DECL)\n \t    {\n+\t      bitmap_set_bit (used_in_copy, SSA_NAME_VERSION (var));\n \t      if (first == NULL_TREE)\n \t\tfirst = var;\n \t      else\n \t\t{\n \t\t  gcc_assert (gimple_can_coalesce_p (var, first));\n \t\t  v1 = SSA_NAME_VERSION (first);\n \t\t  v2 = SSA_NAME_VERSION (var);\n-\t\t  bitmap_set_bit (used_in_copy, v1);\n-\t\t  bitmap_set_bit (used_in_copy, v2);\n \t\t  cost = coalesce_cost_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));\n \t\t  add_coalesce (cl, v1, v2, cost);\n \t\t}\n@@ -1121,7 +1221,9 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t     since they will have to be coalesced with the base variable.  If\n \t     not marked as present, they won't be in the coalesce view. */\n \t  if (SSA_NAME_IS_DEFAULT_DEF (var)\n-\t      && !has_zero_uses (var))\n+\t      && (!has_zero_uses (var)\n+\t\t  || (SSA_NAME_VAR (var)\n+\t\t      && !VAR_P (SSA_NAME_VAR (var)))))\n \t    bitmap_set_bit (used_in_copy, SSA_NAME_VERSION (var));\n \t}\n     }\n@@ -1367,30 +1469,38 @@ gimple_can_coalesce_p (tree name1, tree name2)\n \n       /* We don't want to coalesce two SSA names if one of the base\n \t variables is supposed to be a register while the other is\n-\t supposed to be on the stack.  Anonymous SSA names take\n-\t registers, but when not optimizing, user variables should go\n-\t on the stack, so coalescing them with the anonymous variable\n-\t as the partition leader would end up assigning the user\n-\t variable to a register.  Don't do that!  */\n-      bool reg1 = !var1 || use_register_for_decl (var1);\n-      bool reg2 = !var2 || use_register_for_decl (var2);\n+\t supposed to be on the stack.  Anonymous SSA names most often\n+\t take registers, but when not optimizing, user variables\n+\t should go on the stack, so coalescing them with the anonymous\n+\t variable as the partition leader would end up assigning the\n+\t user variable to a register.  Don't do that!  */\n+      bool reg1 = use_register_for_decl (name1);\n+      bool reg2 = use_register_for_decl (name2);\n       if (reg1 != reg2)\n \treturn false;\n \n-      /* Check that the promoted modes are the same.  We don't want to\n-\t coalesce if the promoted modes would be different.  Only\n+      /* Check that the promoted modes and unsignedness are the same.\n+\t We don't want to coalesce if the promoted modes would be\n+\t different, or if they would sign-extend differently.  Only\n \t PARM_DECLs and RESULT_DECLs have different promotion rules,\n \t so skip the test if both are variables, or both are anonymous\n-\t SSA_NAMEs.  Now, if a parm or result has BLKmode, do not\n-\t coalesce its SSA versions with those of any other variables,\n-\t because it may be passed by reference.  */\n+\t SSA_NAMEs.  */\n+      int unsigned1, unsigned2;\n       return ((!var1 || VAR_P (var1)) && (!var2 || VAR_P (var2)))\n-\t|| (/* The case var1 == var2 is already covered above.  */\n-\t    !parm_in_stack_slot_p (var1)\n-\t    && !parm_in_stack_slot_p (var2)\n-\t    && promote_ssa_mode (name1, NULL) == promote_ssa_mode (name2, NULL));\n+\t|| ((promote_ssa_mode (name1, &unsigned1)\n+\t     == promote_ssa_mode (name2, &unsigned2))\n+\t    && unsigned1 == unsigned2);\n     }\n \n+  /* If alignment requirements are different, we can't coalesce.  */\n+  if (MINIMUM_ALIGNMENT (t1,\n+\t\t\t var1 ? DECL_MODE (var1) : TYPE_MODE (t1),\n+\t\t\t var1 ? LOCAL_DECL_ALIGNMENT (var1) : TYPE_ALIGN (t1))\n+      != MINIMUM_ALIGNMENT (t2,\n+\t\t\t    var2 ? DECL_MODE (var2) : TYPE_MODE (t2),\n+\t\t\t    var2 ? LOCAL_DECL_ALIGNMENT (var2) : TYPE_ALIGN (t2)))\n+    return false;\n+\n   /* If the types are not the same, check for a canonical type match.  This\n      (for example) allows coalescing when the types are fundamentally the\n      same, but just have different names. \n@@ -1639,7 +1749,8 @@ coalesce_ssa_name (void)\n \t  if (a\n \t      && SSA_NAME_VAR (a)\n \t      && !DECL_IGNORED_P (SSA_NAME_VAR (a))\n-\t      && (!has_zero_uses (a) || !SSA_NAME_IS_DEFAULT_DEF (a)))\n+\t      && (!has_zero_uses (a) || !SSA_NAME_IS_DEFAULT_DEF (a)\n+\t\t  || !VAR_P (SSA_NAME_VAR (a))))\n \t    {\n \t      tree *slot = ssa_name_hash.find_slot (a, INSERT);\n \n@@ -1721,3 +1832,47 @@ coalesce_ssa_name (void)\n \n   return map;\n }\n+\n+/* We need to pass two arguments to set_parm_default_def_partition,\n+   but for_all_parms only supports one.  Use a pair.  */\n+\n+typedef std::pair<var_map, bitmap> parm_default_def_partition_arg;\n+\n+/* Set in ARG's PARTS bitmap the bit corresponding to the partition in\n+   ARG's MAP containing VAR's default def.  */\n+\n+static void\n+set_parm_default_def_partition (tree var, void *arg_)\n+{\n+  parm_default_def_partition_arg *arg = (parm_default_def_partition_arg *)arg_;\n+  var_map map = arg->first;\n+  bitmap parts = arg->second;\n+\n+  if (!is_gimple_reg (var))\n+    return;\n+\n+  tree ssa = ssa_default_def (cfun, var);\n+  gcc_assert (ssa);\n+\n+  int version = var_to_partition (map, ssa);\n+  gcc_assert (version != NO_PARTITION);\n+\n+  bool changed = bitmap_set_bit (parts, version);\n+  gcc_assert (changed);\n+}\n+\n+/* Allocate and return a bitmap that has a bit set for each partition\n+   that contains a default def for a parameter.  */\n+\n+extern bitmap\n+get_parm_default_def_partitions (var_map map)\n+{\n+  bitmap parm_default_def_parts = BITMAP_ALLOC (NULL);\n+\n+  parm_default_def_partition_arg\n+    arg = std::make_pair (map, parm_default_def_parts);\n+\n+  for_all_parms (set_parm_default_def_partition, &arg);\n+\n+  return parm_default_def_parts;\n+}"}, {"sha": "8316f3485e083264dbb36ddcaa0f096df59378c6", "filename": "gcc/tree-ssa-coalesce.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftree-ssa-coalesce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftree-ssa-coalesce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.h?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -22,5 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n \n extern var_map coalesce_ssa_name (void);\n extern bool gimple_can_coalesce_p (tree, tree);\n+extern bitmap get_parm_default_def_partitions (var_map);\n \n #endif /* GCC_TREE_SSA_COALESCE_H */"}, {"sha": "25b548b89c7ccdfcbd1a40cf73b8bee6d07c5292", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f11a7b6d57f6fcba1bf2e5a0403dc49120195320/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "patch": "@@ -200,7 +200,9 @@ partition_view_init (var_map map)\n       tmp = partition_find (map->var_partition, x);\n       if (ssa_name (tmp) != NULL_TREE && !virtual_operand_p (ssa_name (tmp))\n \t  && (!has_zero_uses (ssa_name (tmp))\n-\t      || !SSA_NAME_IS_DEFAULT_DEF (ssa_name (tmp))))\n+\t      || !SSA_NAME_IS_DEFAULT_DEF (ssa_name (tmp))\n+\t      || (SSA_NAME_VAR (ssa_name (tmp))\n+\t\t  && !VAR_P (SSA_NAME_VAR (ssa_name (tmp))))))\n \tbitmap_set_bit (used, tmp);\n     }\n \n@@ -1404,6 +1406,12 @@ verify_live_on_entry (tree_live_info_p live)\n \t\t  }\n \t\tif (ok)\n \t\t  continue;\n+\t\t/* Expand adds unused default defs for PARM_DECLs and\n+\t\t   RESULT_DECLs.  They're ok.  */\n+\t\tif (has_zero_uses (var)\n+\t\t    && SSA_NAME_VAR (var)\n+\t\t    && !VAR_P (SSA_NAME_VAR (var)))\n+\t\t  continue;\n \t        num++;\n \t\tprint_generic_expr (stderr, var, TDF_SLIM);\n \t\tfprintf (stderr, \" is not marked live-on-entry to entry BB%d \","}]}