{"sha": "9edfa4c015a3ae0451a30259ef654c632f9f4ca5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVkZmE0YzAxNWEzYWUwNDUxYTMwMjU5ZWY2NTRjNjMyZjlmNGNhNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-05-07T09:36:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-05-07T09:36:05Z"}, "message": "tree-ssa-alias.c (aliasing_component_refs_p): Continue looking for comparaible types in the second direction even if...\n\n\t* tree-ssa-alias.c (aliasing_component_refs_p): Continue looking\n\tfor comparaible types in the second direction even if first one\n\thits incomparable type.\n\nFrom-SVN: r270938", "tree": {"sha": "85cfd477da08953247df27f386a476e664dd4d88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85cfd477da08953247df27f386a476e664dd4d88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9edfa4c015a3ae0451a30259ef654c632f9f4ca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9edfa4c015a3ae0451a30259ef654c632f9f4ca5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9edfa4c015a3ae0451a30259ef654c632f9f4ca5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9edfa4c015a3ae0451a30259ef654c632f9f4ca5/comments", "author": null, "committer": null, "parents": [{"sha": "fe26771191ab959eab1b92ac8a574a900a2a3f4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe26771191ab959eab1b92ac8a574a900a2a3f4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe26771191ab959eab1b92ac8a574a900a2a3f4c"}], "stats": {"total": 31, "additions": 20, "deletions": 11}, "files": [{"sha": "ac9a600912d169472106217d46adf22e791435e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9edfa4c015a3ae0451a30259ef654c632f9f4ca5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9edfa4c015a3ae0451a30259ef654c632f9f4ca5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9edfa4c015a3ae0451a30259ef654c632f9f4ca5", "patch": "@@ -1,3 +1,9 @@\n+2019-05-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-alias.c (aliasing_component_refs_p): Continue looking\n+\tfor comparaible types in the second direction even if first one\n+\thits incomparable type.\n+\n 2019-05-07  Richard Biener  <rguenther@suse.de>\n \n \tPR lto/90369\n@@ -189,6 +195,7 @@\n \tand macros.\n \t* config/i386/t-i386: Define dependencies for new files.\n \n+>>>>>>> .r270937\n 2019-05-03  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/89400"}, {"sha": "1947710eba6a80b8451da68a85f4a5f8b723147c", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9edfa4c015a3ae0451a30259ef654c632f9f4ca5/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9edfa4c015a3ae0451a30259ef654c632f9f4ca5/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=9edfa4c015a3ae0451a30259ef654c632f9f4ca5", "patch": "@@ -795,7 +795,7 @@ aliasing_component_refs_p (tree ref1,\n   tree base1, base2;\n   tree type1, type2;\n   tree *refp;\n-  int same_p;\n+  int same_p, same_p2;\n \n   /* Choose bases and base types to search for.  */\n   base1 = ref1;\n@@ -814,10 +814,7 @@ aliasing_component_refs_p (tree ref1,\n \t && same_type_for_tbaa (TREE_TYPE (*refp), type1) == 0)\n     refp = &TREE_OPERAND (*refp, 0);\n   same_p = same_type_for_tbaa (TREE_TYPE (*refp), type1);\n-  /* If we couldn't compare types we have to bail out.  */\n-  if (same_p == -1)\n-    return true;\n-  else if (same_p == 1)\n+  if (same_p == 1)\n     {\n       poly_int64 offadj, sztmp, msztmp;\n       bool reverse;\n@@ -827,26 +824,31 @@ aliasing_component_refs_p (tree ref1,\n       offset1 -= offadj;\n       return ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2);\n     }\n+\n   /* If we didn't find a common base, try the other way around.  */\n   refp = &ref1;\n   while (handled_component_p (*refp)\n \t && same_type_for_tbaa (TREE_TYPE (*refp), type2) == 0)\n     refp = &TREE_OPERAND (*refp, 0);\n-  same_p = same_type_for_tbaa (TREE_TYPE (*refp), type2);\n-  /* If we couldn't compare types we have to bail out.  */\n-  if (same_p == -1)\n-    return true;\n-  else if (same_p == 1)\n+  same_p2 = same_type_for_tbaa (TREE_TYPE (*refp), type2);\n+  if (same_p2 == 1)\n     {\n       poly_int64 offadj, sztmp, msztmp;\n       bool reverse;\n+\n       get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n       offset1 -= offadj;\n       get_ref_base_and_extent (base2, &offadj, &sztmp, &msztmp, &reverse);\n       offset2 -= offadj;\n-      return ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2);\n+      return ranges_maybe_overlap_p (offset1, max_size1,\n+\t\t\t\t     offset2, max_size2);\n     }\n \n+  /* In the remaining test we assume that there is no overlapping type\n+     at all.  So if we are unsure, we need to give up.  */\n+  if (same_p == -1 || same_p2 == -1)\n+    return true;\n+\n   /* If we have two type access paths B1.path1 and B2.path2 they may\n      only alias if either B1 is in B2.path2 or B2 is in B1.path1.\n      But we can still have a path that goes B1.path1...B2.path2 with"}]}