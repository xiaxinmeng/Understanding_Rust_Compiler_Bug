{"sha": "56f62793be7b655f02889ef04f58df0d6e8fb1af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZmNjI3OTNiZTdiNjU1ZjAyODg5ZWYwNGY1OGRmMGQ2ZThmYjFhZg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-19T14:31:20Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-19T14:31:20Z"}, "message": "Clean-up usage of ipa_fn_summary and ipa_call_summary summaries.\n\n2018-06-19  Martin Liska  <mliska@suse.cz>\n\n\t* config/i386/i386.c (ix86_can_inline_p): Do not use\n        ipa_fn_summaries::get_create.\n\t* ipa-cp.c (ipcp_cloning_candidate_p): Replace get_create with\n        get.\n\t(devirtualization_time_bonus): Likewise.\n\t(ipcp_propagate_stage): Likewise.\n\t* ipa-fnsummary.c (redirect_to_unreachable): Likewise.\n\t(edge_set_predicate): Likewise.\n\t(evaluate_conditions_for_known_args): Likewise.\n\t(evaluate_properties_for_edge): Likewise.\n\t(ipa_call_summary::reset): Tranform to ...\n\t(ipa_call_summary::~ipa_call_summary): ... this.\n\t(ipa_fn_summary::reset): Transform to ...\n\t(ipa_fn_summary::~ipa_fn_summary): ... this.\n\t(ipa_fn_summary_t::remove): Rename to ...\n\t(ipa_fn_summary_t::remove_callees): ... this.\n\t(ipa_fn_summary_t::duplicate): Use placement new\n        instead of memory copy.\n\t(ipa_call_summary_t::duplicate): Likewise.\n\t(ipa_call_summary_t::remove): Remove.\n\t(dump_ipa_call_summary): Change get_create to get.\n\t(ipa_dump_fn_summary): Dump only when summary exists.\n\t(analyze_function_body): Use symbol_summary::get instead\n        of get_create.\n\t(compute_fn_summary): Likewise.\n\t(estimate_edge_devirt_benefit): Likewise.\n\t(estimate_edge_size_and_time): Likewise.\n\t(inline_update_callee_summaries): Likewise.\n\t(remap_edge_change_prob): Likewise.\n\t(remap_edge_summaries): Likewise.\n\t(ipa_merge_fn_summary_after_inlining): Likewise.\n\t(write_ipa_call_summary): Likewise.\n\t(ipa_fn_summary_write): Likewise.\n\t(ipa_free_fn_summary): Likewise.\n\t* ipa-fnsummary.h (struct GTY): Add new ctor and copy ctor.\n\t(struct ipa_call_summary): Likewise.\n\t* ipa-icf.c (sem_function::merge): Use symbol_summary::get instead\n        of get_create.\n\t* ipa-inline-analysis.c (do_estimate_edge_time): Likewise.\n\t(estimate_size_after_inlining): Likewise.\n\t(estimate_growth): Likewise.\n\t(growth_likely_positive): Likewise.\n\t* ipa-inline-transform.c (clone_inlined_nodes): Likewise.\n\t(inline_call): Likewise.\n\t* ipa-inline.c (caller_growth_limits): Likewise.\n\t(can_inline_edge_p): Likewise.\n\t(can_inline_edge_by_limits_p): Likewise.\n\t(compute_uninlined_call_time): Likewise.\n\t(compute_inlined_call_time): Likewise.\n\t(want_inline_small_function_p): Likewise.\n\t(edge_badness): Likewise.\n\t(update_caller_keys): Likewise.\n\t(update_callee_keys): Likewise.\n\t(inline_small_functions): Likewise.\n\t(inline_to_all_callers_1): Likewise.\n\t(dump_overall_stats): Likewise.\n\t(early_inline_small_functions): Likewise.\n\t(early_inliner): Likewise.\n\t* ipa-profile.c (ipa_propagate_frequency_1): Likewise.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Likewise.\n\t* ipa-pure-const.c (malloc_candidate_p): Likewise.\n\t* ipa-split.c (execute_split_functions): Likewise.\n\t* symbol-summary.h: Likewise.\n\t* tree-sra.c (ipa_sra_preliminary_function_checks): Likewise.\n2018-06-19  Martin Liska  <mliska@suse.cz>\n\n\t* lto-partition.c (add_symbol_to_partition_1): Use symbol_summary::get instead\n        of get_create.\n\t(undo_partition): Likewise.\n\t(lto_balanced_map): Likewise.\n\nFrom-SVN: r261744", "tree": {"sha": "da7e8d5740c33deef542777f2e070540666b5575", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da7e8d5740c33deef542777f2e070540666b5575"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56f62793be7b655f02889ef04f58df0d6e8fb1af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56f62793be7b655f02889ef04f58df0d6e8fb1af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56f62793be7b655f02889ef04f58df0d6e8fb1af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56f62793be7b655f02889ef04f58df0d6e8fb1af/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ed0eb0c55ae33aae3ff6c076dc59d5cab8b4b02c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed0eb0c55ae33aae3ff6c076dc59d5cab8b4b02c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed0eb0c55ae33aae3ff6c076dc59d5cab8b4b02c"}], "stats": {"total": 589, "additions": 343, "deletions": 246}, "files": [{"sha": "c4a48f068c74ed295c29936c7ca0336f05b0accd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -1,3 +1,70 @@\n+2018-06-19  Martin Liska  <mliska@suse.cz>\n+\n+\t* config/i386/i386.c (ix86_can_inline_p): Do not use\n+        ipa_fn_summaries::get_create.\n+\t* ipa-cp.c (ipcp_cloning_candidate_p): Replace get_create with\n+        get.\n+\t(devirtualization_time_bonus): Likewise.\n+\t(ipcp_propagate_stage): Likewise.\n+\t* ipa-fnsummary.c (redirect_to_unreachable): Likewise.\n+\t(edge_set_predicate): Likewise.\n+\t(evaluate_conditions_for_known_args): Likewise.\n+\t(evaluate_properties_for_edge): Likewise.\n+\t(ipa_call_summary::reset): Tranform to ...\n+\t(ipa_call_summary::~ipa_call_summary): ... this.\n+\t(ipa_fn_summary::reset): Transform to ...\n+\t(ipa_fn_summary::~ipa_fn_summary): ... this.\n+\t(ipa_fn_summary_t::remove): Rename to ...\n+\t(ipa_fn_summary_t::remove_callees): ... this.\n+\t(ipa_fn_summary_t::duplicate): Use placement new\n+        instead of memory copy.\n+\t(ipa_call_summary_t::duplicate): Likewise.\n+\t(ipa_call_summary_t::remove): Remove.\n+\t(dump_ipa_call_summary): Change get_create to get.\n+\t(ipa_dump_fn_summary): Dump only when summary exists.\n+\t(analyze_function_body): Use symbol_summary::get instead\n+        of get_create.\n+\t(compute_fn_summary): Likewise.\n+\t(estimate_edge_devirt_benefit): Likewise.\n+\t(estimate_edge_size_and_time): Likewise.\n+\t(inline_update_callee_summaries): Likewise.\n+\t(remap_edge_change_prob): Likewise.\n+\t(remap_edge_summaries): Likewise.\n+\t(ipa_merge_fn_summary_after_inlining): Likewise.\n+\t(write_ipa_call_summary): Likewise.\n+\t(ipa_fn_summary_write): Likewise.\n+\t(ipa_free_fn_summary): Likewise.\n+\t* ipa-fnsummary.h (struct GTY): Add new ctor and copy ctor.\n+\t(struct ipa_call_summary): Likewise.\n+\t* ipa-icf.c (sem_function::merge): Use symbol_summary::get instead\n+        of get_create.\n+\t* ipa-inline-analysis.c (do_estimate_edge_time): Likewise.\n+\t(estimate_size_after_inlining): Likewise.\n+\t(estimate_growth): Likewise.\n+\t(growth_likely_positive): Likewise.\n+\t* ipa-inline-transform.c (clone_inlined_nodes): Likewise.\n+\t(inline_call): Likewise.\n+\t* ipa-inline.c (caller_growth_limits): Likewise.\n+\t(can_inline_edge_p): Likewise.\n+\t(can_inline_edge_by_limits_p): Likewise.\n+\t(compute_uninlined_call_time): Likewise.\n+\t(compute_inlined_call_time): Likewise.\n+\t(want_inline_small_function_p): Likewise.\n+\t(edge_badness): Likewise.\n+\t(update_caller_keys): Likewise.\n+\t(update_callee_keys): Likewise.\n+\t(inline_small_functions): Likewise.\n+\t(inline_to_all_callers_1): Likewise.\n+\t(dump_overall_stats): Likewise.\n+\t(early_inline_small_functions): Likewise.\n+\t(early_inliner): Likewise.\n+\t* ipa-profile.c (ipa_propagate_frequency_1): Likewise.\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): Likewise.\n+\t* ipa-pure-const.c (malloc_candidate_p): Likewise.\n+\t* ipa-split.c (execute_split_functions): Likewise.\n+\t* symbol-summary.h: Likewise.\n+\t* tree-sra.c (ipa_sra_preliminary_function_checks): Likewise.\n+\n 2018-06-19  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vectorizer.c (try_vectorize_loop_1): Split out of ..."}, {"sha": "ba23cd0a1abc47cd7396003ecda11dd1783df233", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -5760,6 +5760,7 @@ ix86_can_inline_p (tree caller, tree callee)\n       && lookup_attribute (\"always_inline\",\n \t\t\t   DECL_ATTRIBUTES (callee)));\n \n+  cgraph_node *callee_node = cgraph_node::get (callee);\n   /* Callee's isa options should be a subset of the caller's, i.e. a SSE4\n      function can inline a SSE2 function but a SSE2 function can't inline\n      a SSE4 function.  */\n@@ -5789,8 +5790,8 @@ ix86_can_inline_p (tree caller, tree callee)\n \t      for multi-versioning call optimization, so beware of\n \t      ipa_fn_summaries not available.  */\n \t   && (! ipa_fn_summaries\n-\t       || ipa_fn_summaries->get_create\n-\t       (cgraph_node::get (callee))->fp_expressions))\n+\t       || ipa_fn_summaries->get (callee_node) == NULL\n+\t       || ipa_fn_summaries->get (callee_node)->fp_expressions))\n     ret = false;\n \n   else if (!always_inline"}, {"sha": "c192e84f452ce3fb940bc75d44b0fd4eed9c6589", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -736,7 +736,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   init_caller_stats (&stats);\n   node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats, false);\n \n-  if (ipa_fn_summaries->get_create (node)->self_size < stats.n_calls)\n+  if (ipa_fn_summaries->get (node)->self_size < stats.n_calls)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Considering %s for cloning; code might shrink.\\n\",\n@@ -2583,7 +2583,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       callee = callee->function_symbol (&avail);\n       if (avail < AVAIL_AVAILABLE)\n \tcontinue;\n-      isummary = ipa_fn_summaries->get_create (callee);\n+      isummary = ipa_fn_summaries->get (callee);\n       if (!isummary->inlinable)\n \tcontinue;\n \n@@ -3287,8 +3287,9 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n \t\t\t\t   ipa_get_param_count (info));\n \tinitialize_node_lattices (node);\n       }\n-    if (node->definition && !node->alias)\n-      overall_size += ipa_fn_summaries->get_create (node)->self_size;\n+    ipa_fn_summary *s = ipa_fn_summaries->get (node);\n+    if (node->definition && !node->alias && s != NULL)\n+      overall_size += s->self_size;\n     max_count = max_count.max (node->count.ipa ());\n   }\n "}, {"sha": "c99718a265f3ca034f1b13bb855cd24cd7841925", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 106, "deletions": 142, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -241,7 +241,7 @@ redirect_to_unreachable (struct cgraph_edge *e)\n     e->make_direct (target);\n   else\n     e->redirect_callee (target);\n-  struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n   e->inline_failed = CIF_UNREACHABLE;\n   e->count = profile_count::zero ();\n   es->call_stmt_size = 0;\n@@ -266,7 +266,7 @@ edge_set_predicate (struct cgraph_edge *e, predicate *predicate)\n       && (!e->speculative || e->callee))\n     e = redirect_to_unreachable (e);\n \n-  struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n   if (predicate && *predicate != true)\n     {\n       if (!es->predicate)\n@@ -328,7 +328,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n {\n   clause_t clause = inline_p ? 0 : 1 << predicate::not_inlined_condition;\n   clause_t nonspec_clause = 1 << predicate::not_inlined_condition;\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n   int i;\n   struct condition *c;\n \n@@ -428,7 +428,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t\t      vec<ipa_agg_jump_function_p> *known_aggs_ptr)\n {\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (callee);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get (callee);\n   vec<tree> known_vals = vNULL;\n   vec<ipa_agg_jump_function_p> known_aggs = vNULL;\n \n@@ -445,7 +445,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n     {\n       struct ipa_node_params *caller_parms_info, *callee_pi;\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n-      struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n       int i, count = ipa_get_cs_argument_count (args);\n \n       if (e->caller->global.inlined_to)\n@@ -535,66 +535,34 @@ ipa_fn_summary_alloc (void)\n   ipa_call_summaries = new ipa_call_summary_t (symtab, false);\n }\n \n-/* We are called multiple time for given function; clear\n-   data from previous run so they are not cumulated.  */\n-\n-void\n-ipa_call_summary::reset ()\n+ipa_call_summary::~ipa_call_summary ()\n {\n-  call_stmt_size = call_stmt_time = 0;\n-  is_return_callee_uncaptured = false;\n   if (predicate)\n     edge_predicate_pool.remove (predicate);\n-  predicate = NULL;\n+\n   param.release ();\n }\n \n-/* We are called multiple time for given function; clear\n-   data from previous run so they are not cumulated.  */\n-\n-void\n-ipa_fn_summary::reset (struct cgraph_node *node)\n+ipa_fn_summary::~ipa_fn_summary ()\n {\n-  struct cgraph_edge *e;\n-\n-  self_size = 0;\n-  estimated_stack_size = 0;\n-  estimated_self_stack_size = 0;\n-  stack_frame_offset = 0;\n-  size = 0;\n-  time = 0;\n-  growth = 0;\n-  scc_no = 0;\n   if (loop_iterations)\n-    {\n-      edge_predicate_pool.remove (loop_iterations);\n-      loop_iterations = NULL;\n-    }\n+    edge_predicate_pool.remove (loop_iterations);\n   if (loop_stride)\n-    {\n-      edge_predicate_pool.remove (loop_stride);\n-      loop_stride = NULL;\n-    }\n+    edge_predicate_pool.remove (loop_stride);\n   if (array_index)\n-    {\n-      edge_predicate_pool.remove (array_index);\n-      array_index = NULL;\n-    }\n+    edge_predicate_pool.remove (array_index);\n   vec_free (conds);\n   vec_free (size_time_table);\n-  for (e = node->callees; e; e = e->next_callee)\n-    ipa_call_summaries->get_create (e)->reset ();\n-  for (e = node->indirect_calls; e; e = e->next_callee)\n-    ipa_call_summaries->get_create (e)->reset ();\n-  fp_expressions = false;\n }\n \n-/* Hook that is called by cgraph.c when a node is removed.  */\n-\n void\n-ipa_fn_summary_t::remove (cgraph_node *node, ipa_fn_summary *info)\n+ipa_fn_summary_t::remove_callees (cgraph_node *node)\n {\n-  info->reset (node);\n+  cgraph_edge *e;\n+  for (e = node->callees; e; e = e->next_callee)\n+    ipa_call_summaries->remove (e);\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    ipa_call_summaries->remove (e);\n }\n \n /* Same as remap_predicate_after_duplication but handle hint predicate *P.\n@@ -625,7 +593,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t\t\t     ipa_fn_summary *,\n \t\t\t     ipa_fn_summary *info)\n {\n-  memcpy (info, ipa_fn_summaries->get_create (src), sizeof (ipa_fn_summary));\n+  new (info) ipa_fn_summary (*ipa_fn_summaries->get (src));\n   /* TODO: as an optimization, we may avoid copying conditions\n      that are known to be false or true.  */\n   info->conds = vec_safe_copy (info->conds);\n@@ -779,7 +747,7 @@ ipa_call_summary_t::duplicate (struct cgraph_edge *src,\n \t\t\t       struct ipa_call_summary *srcinfo,\n \t\t\t       struct ipa_call_summary *info)\n {\n-  *info = *srcinfo;\n+  new (info) ipa_call_summary (*srcinfo);\n   info->predicate = NULL;\n   edge_set_predicate (dst, srcinfo->predicate);\n   info->param = srcinfo->param.copy ();\n@@ -792,17 +760,6 @@ ipa_call_summary_t::duplicate (struct cgraph_edge *src,\n     }\n }\n \n-\n-/* Keep edge cache consistent across edge removal.  */\n-\n-void\n-ipa_call_summary_t::remove (struct cgraph_edge *,\n-\t\t\t    struct ipa_call_summary *sum)\n-{\n-  sum->reset ();\n-}\n-\n-\n /* Dump edge summaries associated to NODE and recursively to all clones.\n    Indent by INDENT.  */\n \n@@ -813,21 +770,23 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n   struct cgraph_edge *edge;\n   for (edge = node->callees; edge; edge = edge->next_callee)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n       struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n       int i;\n \n       fprintf (f,\n-\t       \"%*s%s/%i %s\\n%*s  loop depth:%2i freq:%4.2f size:%2i\"\n-\t       \" time: %2i callee size:%2i stack:%2i\",\n+\t       \"%*s%s/%i %s\\n%*s  loop depth:%2i freq:%4.2f size:%2i time: %2i\",\n \t       indent, \"\", callee->name (), callee->order,\n \t       !edge->inline_failed\n \t       ? \"inlined\" : cgraph_inline_failed_string (edge-> inline_failed),\n \t       indent, \"\", es->loop_depth, edge->sreal_frequency ().to_double (),\n-\t       es->call_stmt_size, es->call_stmt_time,\n-\t       (int) (ipa_fn_summaries->get_create (callee)->size\n-\t\t      / ipa_fn_summary::size_scale),\n-\t       (int) ipa_fn_summaries->get_create (callee)->estimated_stack_size);\n+\t       es->call_stmt_size, es->call_stmt_time);\n+\n+      ipa_fn_summary *s = ipa_fn_summaries->get (callee);\n+      if (s != NULL)\n+\tfprintf (f, \"callee size:%2i stack:%2i\",\n+\t\t (int) (s->size / ipa_fn_summary::size_scale),\n+\t\t (int) s->estimated_stack_size);\n \n       if (es->predicate)\n \t{\n@@ -862,7 +821,7 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n     }\n   for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n       fprintf (f, \"%*sindirect call loop depth:%2i freq:%4.2f size:%2i\"\n \t       \" time: %2i\",\n \t       indent, \"\",\n@@ -885,63 +844,67 @@ ipa_dump_fn_summary (FILE *f, struct cgraph_node *node)\n {\n   if (node->definition)\n     {\n-      struct ipa_fn_summary *s = ipa_fn_summaries->get_create (node);\n-      size_time_entry *e;\n-      int i;\n-      fprintf (f, \"IPA function summary for %s/%i\", node->name (),\n-\t       node->order);\n-      if (DECL_DISREGARD_INLINE_LIMITS (node->decl))\n-\tfprintf (f, \" always_inline\");\n-      if (s->inlinable)\n-\tfprintf (f, \" inlinable\");\n-      if (s->fp_expressions)\n-\tfprintf (f, \" fp_expression\");\n-      fprintf (f, \"\\n  global time:     %f\\n\", s->time.to_double ());\n-      fprintf (f, \"  self size:       %i\\n\", s->self_size);\n-      fprintf (f, \"  global size:     %i\\n\", s->size);\n-      fprintf (f, \"  min size:       %i\\n\", s->min_size);\n-      fprintf (f, \"  self stack:      %i\\n\",\n-\t       (int) s->estimated_self_stack_size);\n-      fprintf (f, \"  global stack:    %i\\n\", (int) s->estimated_stack_size);\n-      if (s->growth)\n-\tfprintf (f, \"  estimated growth:%i\\n\", (int) s->growth);\n-      if (s->scc_no)\n-\tfprintf (f, \"  In SCC:          %i\\n\", (int) s->scc_no);\n-      for (i = 0; vec_safe_iterate (s->size_time_table, i, &e); i++)\n+      struct ipa_fn_summary *s = ipa_fn_summaries->get (node);\n+      if (s != NULL)\n \t{\n-\t  fprintf (f, \"    size:%f, time:%f\",\n-\t\t   (double) e->size / ipa_fn_summary::size_scale,\n-\t\t   e->time.to_double ());\n-\t  if (e->exec_predicate != true)\n+\t  size_time_entry *e;\n+\t  int i;\n+\t  fprintf (f, \"IPA function summary for %s\", node->dump_name ());\n+\t  if (DECL_DISREGARD_INLINE_LIMITS (node->decl))\n+\t    fprintf (f, \" always_inline\");\n+\t  if (s->inlinable)\n+\t    fprintf (f, \" inlinable\");\n+\t  if (s->fp_expressions)\n+\t    fprintf (f, \" fp_expression\");\n+\t  fprintf (f, \"\\n  global time:     %f\\n\", s->time.to_double ());\n+\t  fprintf (f, \"  self size:       %i\\n\", s->self_size);\n+\t  fprintf (f, \"  global size:     %i\\n\", s->size);\n+\t  fprintf (f, \"  min size:       %i\\n\", s->min_size);\n+\t  fprintf (f, \"  self stack:      %i\\n\",\n+\t\t   (int) s->estimated_self_stack_size);\n+\t  fprintf (f, \"  global stack:    %i\\n\", (int) s->estimated_stack_size);\n+\t  if (s->growth)\n+\t    fprintf (f, \"  estimated growth:%i\\n\", (int) s->growth);\n+\t  if (s->scc_no)\n+\t    fprintf (f, \"  In SCC:          %i\\n\", (int) s->scc_no);\n+\t  for (i = 0; vec_safe_iterate (s->size_time_table, i, &e); i++)\n+\t    {\n+\t      fprintf (f, \"    size:%f, time:%f\",\n+\t\t       (double) e->size / ipa_fn_summary::size_scale,\n+\t\t       e->time.to_double ());\n+\t      if (e->exec_predicate != true)\n+\t\t{\n+\t\t  fprintf (f, \",  executed if:\");\n+\t\t  e->exec_predicate.dump (f, s->conds, 0);\n+\t\t}\n+\t      if (e->exec_predicate != e->nonconst_predicate)\n+\t\t{\n+\t\t  fprintf (f, \",  nonconst if:\");\n+\t\t  e->nonconst_predicate.dump (f, s->conds, 0);\n+\t\t}\n+\t      fprintf (f, \"\\n\");\n+\t    }\n+\t  if (s->loop_iterations)\n \t    {\n-\t      fprintf (f, \",  executed if:\");\n-\t      e->exec_predicate.dump (f, s->conds, 0);\n+\t      fprintf (f, \"  loop iterations:\");\n+\t      s->loop_iterations->dump (f, s->conds);\n \t    }\n-\t  if (e->exec_predicate != e->nonconst_predicate)\n+\t  if (s->loop_stride)\n \t    {\n-\t      fprintf (f, \",  nonconst if:\");\n-\t      e->nonconst_predicate.dump (f, s->conds, 0);\n+\t      fprintf (f, \"  loop stride:\");\n+\t      s->loop_stride->dump (f, s->conds);\n \t    }\n+\t  if (s->array_index)\n+\t    {\n+\t      fprintf (f, \"  array index:\");\n+\t      s->array_index->dump (f, s->conds);\n+\t    }\n+\t  fprintf (f, \"  calls:\\n\");\n+\t  dump_ipa_call_summary (f, 4, node, s);\n \t  fprintf (f, \"\\n\");\n \t}\n-      if (s->loop_iterations)\n-\t{\n-\t  fprintf (f, \"  loop iterations:\");\n-\t  s->loop_iterations->dump (f, s->conds);\n-\t}\n-      if (s->loop_stride)\n-\t{\n-\t  fprintf (f, \"  loop stride:\");\n-\t  s->loop_stride->dump (f, s->conds);\n-\t}\n-      if (s->array_index)\n-\t{\n-\t  fprintf (f, \"  array index:\");\n-\t  s->array_index->dump (f, s->conds);\n-\t}\n-      fprintf (f, \"  calls:\\n\");\n-      dump_ipa_call_summary (f, 4, node, s);\n-      fprintf (f, \"\\n\");\n+      else\n+\tfprintf (f, \"IPA summary for %s is missing.\\n\", node->dump_name ());\n     }\n }\n \n@@ -2365,7 +2328,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t    }\n \t  free (body);\n \t}\n-      ipa_fn_summary *s = ipa_fn_summaries->get_create (node);\n+      ipa_fn_summary *s = ipa_fn_summaries->get (node);\n       set_hint_predicate (&s->loop_iterations, loop_iterations);\n       set_hint_predicate (&s->loop_stride, loop_stride);\n       scev_finalize ();\n@@ -2385,7 +2348,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t  e->aux = NULL;\n \t}\n     }\n-  ipa_fn_summary *s = ipa_fn_summaries->get_create (node);\n+  ipa_fn_summary *s = ipa_fn_summaries->get (node);\n   s->time = time;\n   s->self_size = size;\n   nonconstant_names.release ();\n@@ -2421,8 +2384,10 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n   if (!ipa_fn_summaries)\n     ipa_fn_summary_alloc ();\n \n+  /* Create a new ipa_fn_summary.  */\n+  ((ipa_fn_summary_t *)ipa_fn_summaries)->remove_callees (node);\n+  ipa_fn_summaries->remove (node);\n   info = ipa_fn_summaries->get_create (node);\n-  info->reset (node);\n \n   /* Estimate the stack size for the function if we're optimizing.  */\n   self_stack_size = optimize && !node->thunk.thunk_p\n@@ -2577,7 +2542,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n   callee = callee->function_symbol (&avail);\n   if (avail < AVAIL_AVAILABLE)\n     return false;\n-  isummary = ipa_fn_summaries->get_create (callee);\n+  isummary = ipa_fn_summaries->get (callee);\n   return isummary->inlinable;\n }\n \n@@ -2596,7 +2561,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n \t\t\t     ipa_hints *hints)\n {\n-  struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n   int call_size = es->call_stmt_size;\n   int call_time = es->call_stmt_time;\n   int cur_size;\n@@ -2853,9 +2818,8 @@ static void\n inline_update_callee_summaries (struct cgraph_node *node, int depth)\n {\n   struct cgraph_edge *e;\n-  ipa_fn_summary *callee_info = ipa_fn_summaries->get_create (node);\n-  ipa_fn_summary *caller_info\n-    = ipa_fn_summaries->get_create (node->callers->caller);\n+  ipa_fn_summary *callee_info = ipa_fn_summaries->get (node);\n+  ipa_fn_summary *caller_info = ipa_fn_summaries->get (node->callers->caller);\n   HOST_WIDE_INT peak;\n \n   callee_info->stack_frame_offset\n@@ -2864,18 +2828,18 @@ inline_update_callee_summaries (struct cgraph_node *node, int depth)\n   peak = callee_info->stack_frame_offset\n     + callee_info->estimated_self_stack_size;\n \n-  ipa_fn_summary *s = ipa_fn_summaries->get_create (node->global.inlined_to);\n+  ipa_fn_summary *s = ipa_fn_summaries->get (node->global.inlined_to);\n   if (s->estimated_stack_size < peak)\n     s->estimated_stack_size = peak;\n   ipa_propagate_frequency (node);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       if (!e->inline_failed)\n \tinline_update_callee_summaries (e->callee, depth);\n-      ipa_call_summaries->get_create (e)->loop_depth += depth;\n+      ipa_call_summaries->get (e)->loop_depth += depth;\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n-    ipa_call_summaries->get_create (e)->loop_depth += depth;\n+    ipa_call_summaries->get (e)->loop_depth += depth;\n }\n \n /* Update change_prob of EDGE after INLINED_EDGE has been inlined.\n@@ -2892,9 +2856,9 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n     {\n       int i;\n       struct ipa_edge_args *args = IPA_EDGE_REF (edge);\n-      struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n       struct ipa_call_summary *inlined_es\n-\t= ipa_call_summaries->get_create (inlined_edge);\n+\t= ipa_call_summaries->get (inlined_edge);\n \n       for (i = 0; i < ipa_get_cs_argument_count (args); i++)\n \t{\n@@ -2941,7 +2905,7 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n   struct cgraph_edge *e, *next;\n   for (e = node->callees; e; e = next)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n       predicate p;\n       next = e->next_callee;\n \n@@ -2967,7 +2931,7 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n     }\n   for (e = node->indirect_calls; e; e = next)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n       predicate p;\n       next = e->next_callee;\n \n@@ -3017,18 +2981,18 @@ remap_hint_predicate (struct ipa_fn_summary *info,\n void\n ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n {\n-  ipa_fn_summary *callee_info = ipa_fn_summaries->get_create (edge->callee);\n+  ipa_fn_summary *callee_info = ipa_fn_summaries->get (edge->callee);\n   struct cgraph_node *to = (edge->caller->global.inlined_to\n \t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (to);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get (to);\n   clause_t clause = 0;\t/* not_inline is known to be false.  */\n   size_time_entry *e;\n   vec<int> operand_map = vNULL;\n   vec<int> offset_map = vNULL;\n   int i;\n   predicate toplev_predicate;\n   predicate true_p = true;\n-  struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n \n   if (es->predicate)\n     toplev_predicate = *es->predicate;\n@@ -3117,7 +3081,7 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n \t\t\t&callee_info->array_index,\n \t\t\toperand_map, offset_map, clause, &toplev_predicate);\n \n-  ipa_call_summary *s = ipa_call_summaries->get_create (edge);\n+  ipa_call_summary *s = ipa_call_summaries->get (edge);\n   inline_update_callee_summaries (edge->callee, s->loop_depth);\n \n   /* We do not maintain predicates of inlined edges, free it.  */\n@@ -3392,7 +3356,7 @@ ipa_fn_summary_read (void)\n static void\n write_ipa_call_summary (struct output_block *ob, struct cgraph_edge *e)\n {\n-  struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n   int i;\n \n   streamer_write_uhwi (ob, es->call_stmt_size);\n@@ -3440,7 +3404,7 @@ ipa_fn_summary_write (void)\n       cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n       if (cnode && cnode->definition && !cnode->alias)\n \t{\n-\t  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (cnode);\n+\t  struct ipa_fn_summary *info = ipa_fn_summaries->get (cnode);\n \t  struct bitpack_d bp;\n \t  struct cgraph_edge *edge;\n \t  int i;\n@@ -3515,7 +3479,7 @@ ipa_free_fn_summary (void)\n     return;\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->alias)\n-      ipa_fn_summaries->get_create (node)->reset (node);\n+      ipa_fn_summaries->remove (node);\n   ipa_fn_summaries->release ();\n   ipa_fn_summaries = NULL;\n   ipa_call_summaries->release ();"}, {"sha": "9e79594423635e68ba6c947176ba10b67451f13d", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 54, "deletions": 29, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -87,6 +87,34 @@ struct GTY(()) size_time_entry\n /* Function inlining information.  */\n struct GTY(()) ipa_fn_summary\n {\n+  /* Keep all field empty so summary dumping works during its computation.\n+     This is useful for debugging.  */\n+  ipa_fn_summary ()\n+    : estimated_self_stack_size (0), self_size (0), min_size (0),\n+      inlinable (false), single_caller (false),\n+      fp_expressions (false), estimated_stack_size (false),\n+      stack_frame_offset (false), time (0), size (0), conds (NULL),\n+      size_time_table (NULL), loop_iterations (NULL), loop_stride (NULL),\n+      array_index (NULL), growth (0), scc_no (0)\n+  {\n+  }\n+\n+  /* Copy constructor.  */\n+  ipa_fn_summary (const ipa_fn_summary &s)\n+    : estimated_self_stack_size (s.estimated_self_stack_size),\n+    self_size (s.self_size), min_size (s.min_size),\n+    inlinable (s.inlinable), single_caller (s.single_caller),\n+    fp_expressions (s.fp_expressions),\n+    estimated_stack_size (s.estimated_stack_size),\n+    stack_frame_offset (s.stack_frame_offset), time (s.time), size (s.size),\n+    conds (s.conds), size_time_table (s.size_time_table),\n+    loop_iterations (s.loop_iterations), loop_stride (s.loop_stride),\n+    array_index (s.array_index), growth (s.growth), scc_no (s.scc_no)\n+  {}\n+\n+  /* Default constructor.  */\n+  ~ipa_fn_summary ();\n+\n   /* Information about the function body itself.  */\n \n   /* Estimated stack frame consumption by the function.  */\n@@ -138,24 +166,9 @@ struct GTY(()) ipa_fn_summary\n   /* Number of SCC on the beginning of inlining process.  */\n   int scc_no;\n \n-  /* Keep all field empty so summary dumping works during its computation.\n-     This is useful for debugging.  */\n-  ipa_fn_summary ()\n-    : estimated_self_stack_size (0), self_size (0), min_size (0),\n-      inlinable (false), single_caller (false),\n-      fp_expressions (false), estimated_stack_size (false),\n-      stack_frame_offset (false), time (0), size (0), conds (NULL),\n-      size_time_table (NULL), loop_iterations (NULL), loop_stride (NULL),\n-      array_index (NULL), growth (0), scc_no (0)\n-    {\n-    }\n-\n   /* Record time and size under given predicates.  */\n   void account_size_time (int, sreal, const predicate &, const predicate &);\n \n-  /* Reset summary to empty state.  */\n-  void reset (struct cgraph_node *node);\n-\n   /* We keep values scaled up, so fractional sizes can be accounted.  */\n   static const int size_scale = 2;\n };\n@@ -174,9 +187,15 @@ class GTY((user)) ipa_fn_summary_t: public function_summary <ipa_fn_summary *>\n     return summary;\n   }\n \n+  /* Remove ipa_fn_summary for all callees of NODE.  */\n+  void remove_callees (cgraph_node *node);\n \n   virtual void insert (cgraph_node *, ipa_fn_summary *);\n-  virtual void remove (cgraph_node *node, ipa_fn_summary *);\n+  virtual void remove (cgraph_node *node, ipa_fn_summary *)\n+  {\n+    remove_callees (node);\n+  }\n+\n   virtual void duplicate (cgraph_node *src, cgraph_node *dst,\n \t\t\t  ipa_fn_summary *src_data, ipa_fn_summary *dst_data);\n };\n@@ -186,6 +205,25 @@ extern GTY(()) function_summary <ipa_fn_summary *> *ipa_fn_summaries;\n /* Information kept about callgraph edges.  */\n struct ipa_call_summary\n {\n+  /* Keep all field empty so summary dumping works during its computation.\n+     This is useful for debugging.  */\n+  ipa_call_summary ()\n+    : predicate (NULL), param (vNULL), call_stmt_size (0), call_stmt_time (0),\n+      loop_depth (0), is_return_callee_uncaptured (false)\n+    {\n+    }\n+\n+  /* Copy constructor.  */\n+  ipa_call_summary (const ipa_call_summary &s):\n+    predicate (s.predicate), param (s.param), call_stmt_size (s.call_stmt_size),\n+    call_stmt_time (s.call_stmt_time), loop_depth (s.loop_depth),\n+    is_return_callee_uncaptured (s.is_return_callee_uncaptured)\n+  {\n+  }\n+\n+  /* Default destructor.  */\n+  ~ipa_call_summary ();\n+\n   class predicate *predicate;\n   /* Vector indexed by parameters.  */\n   vec<inline_param_summary> param;\n@@ -196,17 +234,6 @@ struct ipa_call_summary\n   unsigned int loop_depth;\n   /* Indicates whether the caller returns the value of it's callee.  */\n   bool is_return_callee_uncaptured;\n-\n-  /* Keep all field empty so summary dumping works during its computation.\n-     This is useful for debugging.  */\n-  ipa_call_summary ()\n-    : predicate (NULL), param (vNULL), call_stmt_size (0), call_stmt_time (0),\n-      loop_depth (0)\n-    {\n-    }\n-\n-  /* Reset inline summary to empty state.  */\n-  void reset ();\n };\n \n class ipa_call_summary_t: public call_summary <ipa_call_summary *>\n@@ -215,8 +242,6 @@ class ipa_call_summary_t: public call_summary <ipa_call_summary *>\n   ipa_call_summary_t (symbol_table *symtab, bool ggc):\n     call_summary <ipa_call_summary *> (symtab, ggc) {}\n \n-  /* Hook that is called by summary when an edge is duplicated.  */\n-  virtual void remove (cgraph_edge *cs, ipa_call_summary *);\n   /* Hook that is called by summary when an edge is duplicated.  */\n   virtual void duplicate (cgraph_edge *src, cgraph_edge *dst,\n \t\t\t  ipa_call_summary *src_data,"}, {"sha": "90d1e17e5cd4d9b6824f0f671a3d9c6e2e77969b", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -1199,7 +1199,8 @@ sem_function::merge (sem_item *alias_item)\n \t\t     \"can not create wrapper of stdarg function.\\n\");\n \t}\n       else if (ipa_fn_summaries\n-\t       && ipa_fn_summaries->get_create (alias)->self_size <= 2)\n+\t       && ipa_fn_summaries->get (alias) != NULL\n+\t       && ipa_fn_summaries->get (alias)->self_size <= 2)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Wrapper creation is not \""}, {"sha": "c967eaa91b58431d8526a0a4bcfabac85dacbeb1", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -128,7 +128,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   vec<tree> known_vals;\n   vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function_p> known_aggs;\n-  struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n   int min_size;\n \n   callee = edge->callee->ultimate_alias_target ();\n@@ -264,8 +264,8 @@ int\n estimate_size_after_inlining (struct cgraph_node *node,\n \t\t\t      struct cgraph_edge *edge)\n {\n-  struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n-  ipa_fn_summary *s = ipa_fn_summaries->get_create (node);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+  ipa_fn_summary *s = ipa_fn_summaries->get (node);\n   if (!es->predicate || *es->predicate != false)\n     {\n       int size = s->size + estimate_edge_growth (edge);\n@@ -321,7 +321,7 @@ int\n estimate_growth (struct cgraph_node *node)\n {\n   struct growth_data d = { node, false, false, 0 };\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n \n   node->call_for_symbol_and_aliases (do_estimate_growth_1, &d, true);\n \n@@ -396,7 +396,7 @@ growth_likely_positive (struct cgraph_node *node,\n       || node->address_taken)\n     return true;\n \n-  max_callers = ipa_fn_summaries->get_create (node)->size * 4 / edge_growth + 2;\n+  max_callers = ipa_fn_summaries->get (node)->size * 4 / edge_growth + 2;\n \n   for (e = node->callers; e; e = e->next_caller)\n     {"}, {"sha": "0e7499852911e43794c6562a3f99b22b8f2a0aec", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -200,7 +200,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t    {\n \t      gcc_assert (!e->callee->alias);\n \t      if (overall_size)\n-\t\t*overall_size -= ipa_fn_summaries->get_create (e->callee)->size;\n+\t\t*overall_size -= ipa_fn_summaries->get (e->callee)->size;\n \t      nfunctions_inlined++;\n \t    }\n \t  duplicate = false;\n@@ -351,8 +351,8 @@ inline_call (struct cgraph_edge *e, bool update_original,\n       reload_optimization_node = true;\n     }\n \n-  ipa_fn_summary *caller_info = ipa_fn_summaries->get_create (to);\n-  ipa_fn_summary *callee_info = ipa_fn_summaries->get_create (callee);\n+  ipa_fn_summary *caller_info = ipa_fn_summaries->get (to);\n+  ipa_fn_summary *callee_info = ipa_fn_summaries->get (callee);\n   if (!caller_info->fp_expressions && callee_info->fp_expressions)\n     {\n       caller_info->fp_expressions = true;\n@@ -444,7 +444,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \n   gcc_assert (curr->callee->global.inlined_to == to);\n \n-  old_size = ipa_fn_summaries->get_create (to)->size;\n+  old_size = ipa_fn_summaries->get (to)->size;\n   ipa_merge_fn_summary_after_inlining (e);\n   if (e->in_polymorphic_cdtor)\n     mark_all_inlined_calls_cdtor (e->callee);\n@@ -458,8 +458,8 @@ inline_call (struct cgraph_edge *e, bool update_original,\n        work for further inlining into this function.  Before inlining\n        the function we inlined to again we expect the caller to update\n        the overall summary.  */\n-    ipa_fn_summaries->get_create (to)->size += estimated_growth;\n-  new_size = ipa_fn_summaries->get_create (to)->size;\n+    ipa_fn_summaries->get (to)->size += estimated_growth;\n+  new_size = ipa_fn_summaries->get (to)->size;\n \n   if (callee->calls_comdat_local)\n     to->calls_comdat_local = true;"}, {"sha": "a62c1ffd3b0164dd3a6e71487ffb685f72be8fd0", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 52, "deletions": 37, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -151,7 +151,7 @@ caller_growth_limits (struct cgraph_edge *e)\n   int limit = 0;\n   HOST_WIDE_INT stack_size_limit = 0, inlined_stack;\n   ipa_fn_summary *info, *what_info;\n-  ipa_fn_summary *outer_info = ipa_fn_summaries->get_create (to);\n+  ipa_fn_summary *outer_info = ipa_fn_summaries->get (to);\n \n   /* Look for function e->caller is inlined to.  While doing\n      so work out the largest function body on the way.  As\n@@ -163,7 +163,7 @@ caller_growth_limits (struct cgraph_edge *e)\n      too much in order to prevent compiler from exploding\".  */\n   while (true)\n     {\n-      info = ipa_fn_summaries->get_create (to);\n+      info = ipa_fn_summaries->get (to);\n       if (limit < info->self_size)\n \tlimit = info->self_size;\n       if (stack_size_limit < info->estimated_self_stack_size)\n@@ -174,7 +174,7 @@ caller_growth_limits (struct cgraph_edge *e)\n \tbreak;\n     }\n \n-  what_info = ipa_fn_summaries->get_create (what);\n+  what_info = ipa_fn_summaries->get (what);\n \n   if (limit < what_info->self_size)\n     limit = what_info->self_size;\n@@ -364,7 +364,8 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       e->inline_failed = CIF_TARGET_OPTION_MISMATCH;\n       inlinable = false;\n     }\n-  else if (!ipa_fn_summaries->get_create (callee)->inlinable)\n+  else if (ipa_fn_summaries->get (callee) == NULL\n+\t   || !ipa_fn_summaries->get (callee)->inlinable)\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n       inlinable = false;\n@@ -426,8 +427,8 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n \t     (DECL_DISREGARD_INLINE_LIMITS (callee->decl)\n \t      && lookup_attribute (\"always_inline\",\n \t\t\t\t   DECL_ATTRIBUTES (callee->decl)));\n-      ipa_fn_summary *caller_info = ipa_fn_summaries->get_create (caller);\n-      ipa_fn_summary *callee_info = ipa_fn_summaries->get_create (callee);\n+      ipa_fn_summary *caller_info = ipa_fn_summaries->get (caller);\n+      ipa_fn_summary *callee_info = ipa_fn_summaries->get (callee);\n \n      /* Until GCC 4.9 we did not check the semantics alterning flags\n \tbellow and inline across optimization boundry.\n@@ -530,7 +531,7 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n \t\t   > opt_for_fn (caller->decl, optimize)))\n \t{\n \t  if (estimate_edge_time (e)\n-\t      >= 20 + ipa_call_summaries->get_create (e)->call_stmt_time)\n+\t      >= 20 + ipa_call_summaries->get (e)->call_stmt_time)\n \t    {\n \t      e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t      inlinable = false;\n@@ -680,7 +681,7 @@ compute_uninlined_call_time (struct cgraph_edge *edge,\n   else\n     uninlined_call_time = uninlined_call_time >> 11;\n \n-  sreal caller_time = ipa_fn_summaries->get_create (caller)->time;\n+  sreal caller_time = ipa_fn_summaries->get (caller)->time;\n   return uninlined_call_time + caller_time;\n }\n \n@@ -694,7 +695,7 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n   cgraph_node *caller = (edge->caller->global.inlined_to \n \t\t\t ? edge->caller->global.inlined_to\n \t\t\t : edge->caller);\n-  sreal caller_time = ipa_fn_summaries->get_create (caller)->time;\n+  sreal caller_time = ipa_fn_summaries->get (caller)->time;\n \n   sreal freq = edge->sreal_frequency ();\n   if (freq > 0)\n@@ -704,7 +705,7 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n \n   /* This calculation should match one in ipa-inline-analysis.c\n      (estimate_edge_size_and_time).  */\n-  time -= (sreal)ipa_call_summaries->get_create (edge)->call_stmt_time * freq;\n+  time -= (sreal)ipa_call_summaries->get (edge)->call_stmt_time * freq;\n   time += caller_time;\n   if (time <= 0)\n     time = ((sreal) 1) >> 8;\n@@ -756,17 +757,17 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n      MAX_INLINE_INSNS_SINGLE 16-fold for inline functions.  */\n   else if ((!DECL_DECLARED_INLINE_P (callee->decl)\n \t   && (!e->count.ipa ().initialized_p () || !e->maybe_hot_p ()))\n-\t   && ipa_fn_summaries->get_create (callee)->min_size\n-\t\t- ipa_call_summaries->get_create (e)->call_stmt_size\n+\t   && ipa_fn_summaries->get (callee)->min_size\n+\t\t- ipa_call_summaries->get (e)->call_stmt_size\n \t      > MAX (MAX_INLINE_INSNS_SINGLE, MAX_INLINE_INSNS_AUTO))\n     {\n       e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n       want_inline = false;\n     }\n   else if ((DECL_DECLARED_INLINE_P (callee->decl)\n \t    || e->count.ipa ().nonzero_p ())\n-\t   && ipa_fn_summaries->get_create (callee)->min_size\n-\t\t- ipa_call_summaries->get_create (e)->call_stmt_size\n+\t   && ipa_fn_summaries->get (callee)->min_size\n+\t\t- ipa_call_summaries->get (e)->call_stmt_size\n \t      > 16 * MAX_INLINE_INSNS_SINGLE)\n     {\n       e->inline_failed = (DECL_DECLARED_INLINE_P (callee->decl)\n@@ -1018,7 +1019,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   int growth;\n   sreal edge_time, unspec_edge_time;\n   struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n-  struct ipa_fn_summary *callee_info = ipa_fn_summaries->get_create (callee);\n+  struct ipa_fn_summary *callee_info = ipa_fn_summaries->get (callee);\n   ipa_hints hints;\n   cgraph_node *caller = (edge->caller->global.inlined_to \n \t\t\t ? edge->caller->global.inlined_to\n@@ -1131,7 +1132,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t  && (!DECL_DECLARED_INLINE_P (edge->callee->decl)\n \t\t      || DECL_DECLARED_INLINE_P (caller->decl)))))\n \t{\n-\t  ipa_fn_summary *caller_info = ipa_fn_summaries->get_create (caller);\n+\t  ipa_fn_summary *caller_info = ipa_fn_summaries->get (caller);\n \t  int caller_growth = caller_info->growth;\n \n \t  /* Only apply the penalty when caller looks like inline candidate,\n@@ -1190,7 +1191,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n      of functions fully inlined in program.  */\n   else\n     {\n-      int nest = MIN (ipa_call_summaries->get_create (edge)->loop_depth, 8);\n+      int nest = MIN (ipa_call_summaries->get (edge)->loop_depth, 8);\n       badness = growth;\n \n       /* Decrease badness if call is nested.  */\n@@ -1334,7 +1335,7 @@ update_caller_keys (edge_heap_t *heap, struct cgraph_node *node,\n   struct cgraph_edge *edge;\n   struct ipa_ref *ref;\n \n-  if ((!node->alias && !ipa_fn_summaries->get_create (node)->inlinable)\n+  if ((!node->alias && !ipa_fn_summaries->get (node)->inlinable)\n       || node->global.inlined_to)\n     return;\n   if (!bitmap_set_bit (updated_nodes, node->get_uid ()))\n@@ -1393,7 +1394,8 @@ update_callee_keys (edge_heap_t *heap, struct cgraph_node *node,\n            don't need updating.  */\n \tif (e->inline_failed\n \t    && (callee = e->callee->ultimate_alias_target (&avail, e->caller))\n-\t    && ipa_fn_summaries->get_create (callee)->inlinable\n+\t    && ipa_fn_summaries->get (callee) != NULL\n+\t    && ipa_fn_summaries->get (callee)->inlinable\n \t    && avail >= AVAIL_AVAILABLE\n \t    && !bitmap_bit_p (updated_nodes, callee->get_uid ()))\n \t  {\n@@ -1769,7 +1771,7 @@ inline_small_functions (void)\n \t    && (node->has_gimple_body_p () || node->thunk.thunk_p)\n \t    && opt_for_fn (node->decl, optimize))\n \t  {\n-\t    struct ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n+\t    struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n \t    struct ipa_dfs_info *dfs = (struct ipa_dfs_info *) node->aux;\n \n \t    /* Do not account external functions, they will be optimized out\n@@ -1791,7 +1793,7 @@ inline_small_functions (void)\n \t\t     n2 = ((struct ipa_dfs_info *) n2->aux)->next_cycle)\n \t\t  if (opt_for_fn (n2->decl, optimize))\n \t\t    {\n-\t\t      ipa_fn_summary *info2 = ipa_fn_summaries->get_create (n2);\n+\t\t      ipa_fn_summary *info2 = ipa_fn_summaries->get (n2);\n \t\t      if (info2->scc_no)\n \t\t\tbreak;\n \t\t      info2->scc_no = id;\n@@ -1952,7 +1954,7 @@ inline_small_functions (void)\n \t  fprintf (dump_file,\n \t\t   \"\\nConsidering %s with %i size\\n\",\n \t\t   callee->dump_name (),\n-\t\t   ipa_fn_summaries->get_create (callee)->size);\n+\t\t   ipa_fn_summaries->get (callee)->size);\n \t  fprintf (dump_file,\n \t\t   \" to be inlined into %s in %s:%i\\n\"\n \t\t   \" Estimated badness is %f, frequency %.2f.\\n\",\n@@ -2078,7 +2080,7 @@ inline_small_functions (void)\n \n       if (dump_file)\n \t{\n-\t  ipa_fn_summary *s = ipa_fn_summaries->get_create (edge->caller);\n+\t  ipa_fn_summary *s = ipa_fn_summaries->get (edge->caller);\n \t  fprintf (dump_file,\n \t\t   \" Inlined %s into %s which now has time %f and size %i, \"\n \t\t   \"net change of %+i.\\n\",\n@@ -2220,11 +2222,11 @@ inline_to_all_callers_1 (struct cgraph_node *node, void *data,\n \t  fprintf (dump_file,\n \t\t   \"\\nInlining %s size %i.\\n\",\n \t\t   node->name (),\n-\t\t   ipa_fn_summaries->get_create (node)->size);\n+\t\t   ipa_fn_summaries->get (node)->size);\n \t  fprintf (dump_file,\n \t\t   \" Called once from %s %i insns.\\n\",\n \t\t   node->callers->caller->name (),\n-\t\t   ipa_fn_summaries->get_create (node->callers->caller)->size);\n+\t\t   ipa_fn_summaries->get (node->callers->caller)->size);\n \t}\n \n       /* Remember which callers we inlined to, delaying updating the\n@@ -2235,7 +2237,7 @@ inline_to_all_callers_1 (struct cgraph_node *node, void *data,\n \tfprintf (dump_file,\n \t\t \" Inlined into %s which now has %i size\\n\",\n \t\t caller->name (),\n-\t\t ipa_fn_summaries->get_create (caller)->size);\n+\t\t ipa_fn_summaries->get (caller)->size);\n       if (!(*num_calls)--)\n \t{\n \t  if (dump_file)\n@@ -2276,10 +2278,13 @@ dump_overall_stats (void)\n     if (!node->global.inlined_to\n \t&& !node->alias)\n       {\n-\tsreal time = ipa_fn_summaries->get_create (node)->time;\n-\tsum += time;\n-\tif (node->count.ipa ().initialized_p ())\n-\t  sum_weighted += time * node->count.ipa ().to_gcov_type ();\n+\tipa_fn_summary *s = ipa_fn_summaries->get (node);\n+\tif (s != NULL)\n+\t  {\n+\t  sum += s->time;\n+\t  if (node->count.ipa ().initialized_p ())\n+\t    sum_weighted += s->time * node->count.ipa ().to_gcov_type ();\n+\t  }\n       }\n   fprintf (dump_file, \"Overall time estimate: \"\n \t   \"%f weighted by profile: \"\n@@ -2655,8 +2660,12 @@ early_inline_small_functions (struct cgraph_node *node)\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n-      if (!ipa_fn_summaries->get_create (callee)->inlinable\n-\t  || !e->inline_failed)\n+\n+      /* We can enounter not-yet-analyzed function during\n+\t early inlining on callgraphs with strongly\n+\t connected components.  */\n+      ipa_fn_summary *s = ipa_fn_summaries->get (callee);\n+      if (s == NULL || !s->inlinable || !e->inline_failed)\n \tcontinue;\n \n       /* Do not consider functions not declared inline.  */\n@@ -2765,6 +2774,9 @@ early_inliner (function *fun)\n \t     statements that don't have inline parameters computed.  */\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n \t    {\n+\t      /* We can enounter not-yet-analyzed function during\n+\t\t early inlining on callgraphs with strongly\n+\t\t connected components.  */\n \t      ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n \t      es->call_stmt_size\n \t\t= estimate_num_insns (edge->call_stmt, &eni_size_weights);\n@@ -2790,11 +2802,14 @@ early_inliner (function *fun)\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n \t    {\n \t      /* We have no summary for new bound store calls yet.  */\n-\t      ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n-\t      es->call_stmt_size\n-\t\t= estimate_num_insns (edge->call_stmt, &eni_size_weights);\n-\t      es->call_stmt_time\n-\t\t= estimate_num_insns (edge->call_stmt, &eni_time_weights);\n+\t      ipa_call_summary *es = ipa_call_summaries->get (edge);\n+\t      if (es != NULL)\n+\t\t{\n+\t\t  es->call_stmt_size\n+\t\t    = estimate_num_insns (edge->call_stmt, &eni_size_weights);\n+\t\t  es->call_stmt_time\n+\t\t    = estimate_num_insns (edge->call_stmt, &eni_time_weights);\n+\t\t}\n \n \t      if (edge->callee->decl\n \t\t  && !gimple_check_call_matching_types ("}, {"sha": "f921d1bb6f4f6683da60d7dd577b421a5ece9a90", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -345,17 +345,20 @@ ipa_propagate_frequency_1 (struct cgraph_node *node, void *data)\n \tcase NODE_FREQUENCY_UNLIKELY_EXECUTED:\n \t  break;\n \tcase NODE_FREQUENCY_EXECUTED_ONCE:\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"  Called by %s that is executed once\\n\",\n-\t\t     edge->caller->name ());\n-\t  d->maybe_unlikely_executed = false;\n-\t  if (ipa_call_summaries->get_create (edge)->loop_depth)\n-\t    {\n-\t      d->maybe_executed_once = false;\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t        fprintf (dump_file, \"  Called in loop\\n\");\n-\t    }\n-\t  break;\n+\t  {\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      fprintf (dump_file, \"  Called by %s that is executed once\\n\",\n+\t\t       edge->caller->name ());\n+\t    d->maybe_unlikely_executed = false;\n+\t    ipa_call_summary *s = ipa_call_summaries->get (edge);\n+\t    if (s != NULL && s->loop_depth)\n+\t      {\n+\t\td->maybe_executed_once = false;\n+\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t  fprintf (dump_file, \"  Called in loop\\n\");\n+\t      }\n+\t    break;\n+\t  }\n \tcase NODE_FREQUENCY_HOT:\n \tcase NODE_FREQUENCY_NORMAL:\n \t  if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "000c05ffd89d37bad72301304395a1bc5b437cd0", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -2819,7 +2819,6 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t\t\t\tbool speculative)\n {\n   struct cgraph_node *callee;\n-  struct ipa_call_summary *es = ipa_call_summaries->get_create (ie);\n   bool unreachable = false;\n \n   if (TREE_CODE (target) == ADDR_EXPR)\n@@ -2957,7 +2956,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t for direct call (adjusted by inline_edge_duplication_hook).  */\n       if (ie == orig)\n \t{\n-\t  es = ipa_call_summaries->get_create (ie);\n+\t  ipa_call_summary *es = ipa_call_summaries->get (ie);\n \t  es->call_stmt_size -= (eni_size_weights.indirect_call_cost\n \t\t\t\t - eni_size_weights.call_cost);\n \t  es->call_stmt_time -= (eni_time_weights.indirect_call_cost"}, {"sha": "4de609e7ca158d38ae11ea48ab4036348deb7e11", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -923,7 +923,7 @@ malloc_candidate_p (function *fun, bool ipa)\n \t  cgraph_edge *cs = node->get_edge (call_stmt);\n \t  if (cs)\n \t    {\n-\t      ipa_call_summary *es = ipa_call_summaries->get_create (cs);\n+\t      ipa_call_summary *es = ipa_call_summaries->get (cs);\n \t      gcc_assert (es);\n \t      es->is_return_callee_uncaptured = true;\n \t    }\n@@ -959,7 +959,7 @@ malloc_candidate_p (function *fun, bool ipa)\n \t      cgraph_edge *cs = node->get_edge (call_stmt);\n \t      if (cs)\n \t\t{\n-\t\t  ipa_call_summary *es = ipa_call_summaries->get_create (cs);\n+\t\t  ipa_call_summary *es = ipa_call_summaries->get (cs);\n \t\t  gcc_assert (es);\n \t\t  es->is_return_callee_uncaptured = true;\n \t\t}"}, {"sha": "0e6440f8997c54b8b92e3c69e04af3ae196271cf", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -1691,7 +1691,8 @@ execute_split_functions (void)\n   /* This can be relaxed; function might become inlinable after splitting\n      away the uninlinable part.  */\n   if (ipa_fn_summaries\n-      && !ipa_fn_summaries->get_create (node)->inlinable)\n+      && ipa_fn_summaries->get (node)\n+      && !ipa_fn_summaries->get (node)->inlinable)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not splitting: not inlinable.\\n\");"}, {"sha": "67db280d4004f6bd1b196fc484cd9e3285b58a97", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -1,3 +1,10 @@\n+2018-06-19  Martin Liska  <mliska@suse.cz>\n+\n+\t* lto-partition.c (add_symbol_to_partition_1): Use symbol_summary::get instead\n+        of get_create.\n+\t(undo_partition): Likewise.\n+\t(lto_balanced_map): Likewise.\n+\n 2018-06-19  Martin Liska  <mliska@suse.cz>\n \n \t* config-lang.in: Remove stagestuff."}, {"sha": "c7a5710f776c09f852a014fb5d51d595acd6d74e", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -171,7 +171,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n     {\n       struct cgraph_edge *e;\n       if (!node->alias && c == SYMBOL_PARTITION)\n-        part->insns += ipa_fn_summaries->get_create (cnode)->size;\n+\tpart->insns += ipa_fn_summaries->get (cnode)->size;\n \n       /* Add all inline clones and callees that are duplicated.  */\n       for (e = cnode->callees; e; e = e->next_callee)\n@@ -291,7 +291,7 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n \n       if (!node->alias && (cnode = dyn_cast <cgraph_node *> (node))\n           && node->get_partitioning_class () == SYMBOL_PARTITION)\n-        partition->insns -= ipa_fn_summaries->get_create (cnode)->size;\n+\tpartition->insns -= ipa_fn_summaries->get (cnode)->size;\n       lto_symtab_encoder_delete_node (partition->encoder, node);\n       node->aux = (void *)((size_t)node->aux - 1);\n     }\n@@ -528,7 +528,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \telse\n \t  order.safe_push (node);\n \tif (!node->alias)\n-\t  total_size += ipa_fn_summaries->get_create (node)->size;\n+\t  total_size += ipa_fn_summaries->get (node)->size;\n       }\n \n   original_total_size = total_size;"}, {"sha": "bf32810abd7b010c08add7bad0f86fe2aacad0fc", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -99,6 +99,18 @@ class GTY((user)) function_summary <T *>\n     return get (node->get_uid (), false);\n   }\n \n+  /* Remove node from summary.  */\n+  void remove (cgraph_node *node)\n+  {\n+    int uid = node->get_uid ();\n+    T **v = m_map.get (uid);\n+    if (v)\n+      {\n+\tm_map.remove (uid);\n+\trelease (*v);\n+      }\n+  }\n+\n   /* Return number of elements handled by data structure.  */\n   size_t elements ()\n   {"}, {"sha": "3e30f6bc3d437a3786a08bb0afae953a01b098b6", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f62793be7b655f02889ef04f58df0d6e8fb1af/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=56f62793be7b655f02889ef04f58df0d6e8fb1af", "patch": "@@ -5458,7 +5458,8 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n     }\n \n   if ((DECL_ONE_ONLY (node->decl) || DECL_EXTERNAL (node->decl))\n-      && ipa_fn_summaries->get_create (node)->size >= MAX_INLINE_INSNS_AUTO)\n+      && ipa_fn_summaries->get (node)\n+      && ipa_fn_summaries->get (node)->size >= MAX_INLINE_INSNS_AUTO)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Function too big to be made truly local.\\n\");"}]}