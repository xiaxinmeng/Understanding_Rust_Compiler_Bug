{"sha": "3d79abbdf8a8a92943b15628b72c04c2dec15348", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q3OWFiYmRmOGE4YTkyOTQzYjE1NjI4YjcyYzA0YzJkZWMxNTM0OA==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-08-17T15:34:12Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-17T15:34:12Z"}, "message": "re PR fortran/13082 (Function entries and entries with alternate returns not implemented)\n\n2004-08-17  Paul Brook  <paul@codesourcery.com>\n\tTobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n\n\tPR fortran/13082\n\t* decl.c (get_proc_name): Update mystery comment.\n\t(gfc_match_entry): Check for errors earlier.  Add entry point to list.\n\t* dump-parse-tree.c (gfc_show_code_node): Print EXEC_ENTRY nodes.\n\t* gfortran.h (symbol_attribute): Add entry_master.  Document entry.\n\t(struct gfc_entry_list): Define.\n\t(gfc_get_entry_list): Define.\n\t(struct gfc_namespace): Add refs and entries.\n\t(enum gfc_exec_op): Add EXEC_ENTRY.\n\t(struct gfc_code): Add ext.entry.\n\t* module.c (ab_attribute, attr_bits): Remove AB_ENTRY.\n\t(mio_symbol_attribute): Don't save/reture addr->entry.\n\t(mio_namespace_ref): Refcount namespaces.\n\t* parse.c (accept_statement): Handle ST_ENTRY.\n\t(gfc_fixup_sibling_symbols): Mark symbol as referenced.\n\t(parse_contained): Fixup sibling references to entry points\n\tafter parsing the procedure body.\n\t* resolve.c (resolve_contained_fntype): New function.\n\t(merge_argument_lists, resolve_entries): New functions.\n\t(resolve_contained_functions): Use them.\n\t(resolve_code): Handle EXEC_ENTRY.\n\t(gfc_resolve): Call resolve_entries.\n\t* st.c (gfc_free_statement): Handle EXEC_ENTRY.\n\t* symbol.c (gfc_get_namespace): Refcount namespaces.\n\t(gfc_free_namespace): Ditto.\n\t* trans-array.c (gfc_trans_dummy_array_bias): Treat all args as\n\toptional when multiple entry points are present.\n\t* trans-decl.c (gfc_get_symbol_decl): Remove incorrect check.\n\t(gfc_get_extern_function_decl): Add assertion.  Fix coment.\n\t(create_function_arglist, trans_function_start, build_entry_thunks):\n\tNew functions.\n\t(gfc_build_function_decl): Rename ...\n\t(build_function_decl): ... to this.\n\t(gfc_create_function_decl): New function.\n\t(gfc_generate_contained_functions): Use it.\n\t(gfc_trans_entry_master_switch): New function.\n\t(gfc_generate_function_code): Use new functions.\n\t* trans-stmt.c (gfc_trans_entry): New function.\n\t* trans-stmt.h (gfc_trans_entry): Add prototype.\n\t* trans-types.c (gfc_get_function_type): Add entry point argument.\n\t* trans.c (gfc_trans_code): Handle EXEC_ENTRY.\n\t(gfc_generate_module_code): Call gfc_create_function_decl.\n\t* trans.h (gfc_build_function_decl): Remove.\n\t(gfc_create_function_decl): Add prototype.\ntestsuite/\n\t* gfortran.dg/entry_1.f90: New test.\n\nCo-Authored-By: Tobias Schl\u00fcter <tobias.schlueter@physik.uni-muenchen.de>\n\nFrom-SVN: r86128", "tree": {"sha": "7d8312b4f1a046c12f0c41b27b061fef7c8e4adb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d8312b4f1a046c12f0c41b27b061fef7c8e4adb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d79abbdf8a8a92943b15628b72c04c2dec15348", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d79abbdf8a8a92943b15628b72c04c2dec15348", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d79abbdf8a8a92943b15628b72c04c2dec15348", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d79abbdf8a8a92943b15628b72c04c2dec15348/comments", "author": null, "committer": null, "parents": [{"sha": "4c7cb3ea1eae8ed094f6f4b8ed5ec5f44edb2a19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c7cb3ea1eae8ed094f6f4b8ed5ec5f44edb2a19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c7cb3ea1eae8ed094f6f4b8ed5ec5f44edb2a19"}], "stats": {"total": 894, "additions": 718, "deletions": 176}, "files": [{"sha": "e8af2270fd80ff6eb290a2cff5b4ea1633e7d78c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -1,3 +1,51 @@\n+2004-08-17  Paul Brook  <paul@codesourcery.com>\n+\tTobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/13082\n+\t* decl.c (get_proc_name): Update mystery comment.\n+\t(gfc_match_entry): Check for errors earlier.  Add entry point to list.\n+\t* dump-parse-tree.c (gfc_show_code_node): Print EXEC_ENTRY nodes.\n+\t* gfortran.h (symbol_attribute): Add entry_master.  Document entry.\n+\t(struct gfc_entry_list): Define.\n+\t(gfc_get_entry_list): Define.\n+\t(struct gfc_namespace): Add refs and entries.\n+\t(enum gfc_exec_op): Add EXEC_ENTRY.\n+\t(struct gfc_code): Add ext.entry.\n+\t* module.c (ab_attribute, attr_bits): Remove AB_ENTRY.\n+\t(mio_symbol_attribute): Don't save/reture addr->entry.\n+\t(mio_namespace_ref): Refcount namespaces.\n+\t* parse.c (accept_statement): Handle ST_ENTRY.\n+\t(gfc_fixup_sibling_symbols): Mark symbol as referenced.\n+\t(parse_contained): Fixup sibling references to entry points\n+\tafter parsing the procedure body.\n+\t* resolve.c (resolve_contained_fntype): New function.\n+\t(merge_argument_lists, resolve_entries): New functions.\n+\t(resolve_contained_functions): Use them.\n+\t(resolve_code): Handle EXEC_ENTRY.\n+\t(gfc_resolve): Call resolve_entries.\n+\t* st.c (gfc_free_statement): Handle EXEC_ENTRY.\n+\t* symbol.c (gfc_get_namespace): Refcount namespaces.\n+\t(gfc_free_namespace): Ditto.\n+\t* trans-array.c (gfc_trans_dummy_array_bias): Treat all args as\n+\toptional when multiple entry points are present.\n+\t* trans-decl.c (gfc_get_symbol_decl): Remove incorrect check.\n+\t(gfc_get_extern_function_decl): Add assertion.  Fix coment.\n+\t(create_function_arglist, trans_function_start, build_entry_thunks):\n+\tNew functions.\n+\t(gfc_build_function_decl): Rename ...\n+\t(build_function_decl): ... to this.\n+\t(gfc_create_function_decl): New function.\n+\t(gfc_generate_contained_functions): Use it.\n+\t(gfc_trans_entry_master_switch): New function.\n+\t(gfc_generate_function_code): Use new functions.\n+\t* trans-stmt.c (gfc_trans_entry): New function.\n+\t* trans-stmt.h (gfc_trans_entry): Add prototype.\n+\t* trans-types.c (gfc_get_function_type): Add entry point argument.\n+\t* trans.c (gfc_trans_code): Handle EXEC_ENTRY.\n+\t(gfc_generate_module_code): Call gfc_create_function_decl.\n+\t* trans.h (gfc_build_function_decl): Remove.\n+\t(gfc_create_function_decl): Add prototype.\n+\n 2004-08-15  Andrew Pinski  <apinski@apple.com>\n \n \tPR fortran/17030"}, {"sha": "e00a614cd0694e834628226b80892d0d73ebbeda", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 49, "deletions": 29, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -186,7 +186,7 @@ get_proc_name (const char *name, gfc_symbol ** result)\n   if (*result == NULL)\n     return rc;\n \n-  /* Deal with ENTRY problem */\n+  /* ??? Deal with ENTRY problem */\n \n   st = gfc_new_symtree (&gfc_current_ns->sym_root, name);\n \n@@ -1871,44 +1871,59 @@ gfc_match_function_decl (void)\n match\n gfc_match_entry (void)\n {\n-  gfc_symbol *function, *result, *entry;\n+  gfc_symbol *proc;\n+  gfc_symbol *result;\n+  gfc_symbol *entry;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_compile_state state;\n   match m;\n+  gfc_entry_list *el;\n \n   m = gfc_match_name (name);\n   if (m != MATCH_YES)\n     return m;\n \n+  state = gfc_current_state ();\n+  if (state != COMP_SUBROUTINE\n+      && state != COMP_FUNCTION)\n+    {\n+      gfc_error (\"ENTRY statement at %C cannot appear within %s\",\n+\t\t gfc_state_name (gfc_current_state ()));\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_current_ns->parent != NULL\n+      && gfc_current_ns->parent->proc_name\n+      && gfc_current_ns->parent->proc_name->attr.flavor != FL_MODULE)\n+    {\n+      gfc_error(\"ENTRY statement at %C cannot appear in a \"\n+\t\t\"contained procedure\");\n+      return MATCH_ERROR;\n+    }\n+\n   if (get_proc_name (name, &entry))\n     return MATCH_ERROR;\n \n-  gfc_enclosing_unit (&state);\n-  switch (state)\n+  proc = gfc_current_block ();\n+\n+  if (state == COMP_SUBROUTINE)\n     {\n-    case COMP_SUBROUTINE:\n+      /* And entry in a subroutine.  */\n       m = gfc_match_formal_arglist (entry, 0, 1);\n       if (m != MATCH_YES)\n \treturn MATCH_ERROR;\n \n-      if (gfc_current_state () != COMP_SUBROUTINE)\n-\tgoto exec_construct;\n-\n       if (gfc_add_entry (&entry->attr, NULL) == FAILURE\n \t  || gfc_add_subroutine (&entry->attr, NULL) == FAILURE)\n \treturn MATCH_ERROR;\n-\n-      break;\n-\n-    case COMP_FUNCTION:\n+    }\n+  else\n+    {\n+      /* An entry in a function.  */\n       m = gfc_match_formal_arglist (entry, 0, 0);\n       if (m != MATCH_YES)\n \treturn MATCH_ERROR;\n \n-      if (gfc_current_state () != COMP_FUNCTION)\n-\tgoto exec_construct;\n-      function = gfc_state_stack->sym;\n-\n       result = NULL;\n \n       if (gfc_match_eos () == MATCH_YES)\n@@ -1917,12 +1932,12 @@ gfc_match_entry (void)\n \t      || gfc_add_function (&entry->attr, NULL) == FAILURE)\n \t    return MATCH_ERROR;\n \n-\t  entry->result = function->result;\n+\t  entry->result = proc->result;\n \n \t}\n       else\n \t{\n-\t  m = match_result (function, &result);\n+\t  m = match_result (proc, &result);\n \t  if (m == MATCH_NO)\n \t    gfc_syntax_error (ST_ENTRY);\n \t  if (m != MATCH_YES)\n@@ -1934,16 +1949,11 @@ gfc_match_entry (void)\n \t    return MATCH_ERROR;\n \t}\n \n-      if (function->attr.recursive && result == NULL)\n+      if (proc->attr.recursive && result == NULL)\n \t{\n \t  gfc_error (\"RESULT attribute required in ENTRY statement at %C\");\n \t  return MATCH_ERROR;\n \t}\n-\n-      break;\n-\n-    default:\n-      goto exec_construct;\n     }\n \n   if (gfc_match_eos () != MATCH_YES)\n@@ -1952,13 +1962,23 @@ gfc_match_entry (void)\n       return MATCH_ERROR;\n     }\n \n-  return MATCH_YES;\n+  entry->attr.recursive = proc->attr.recursive;\n+  entry->attr.elemental = proc->attr.elemental;\n+  entry->attr.pure = proc->attr.pure;\n \n-exec_construct:\n-  gfc_error (\"ENTRY statement at %C cannot appear within %s\",\n-\t     gfc_state_name (gfc_current_state ()));\n+  el = gfc_get_entry_list ();\n+  el->sym = entry;\n+  el->next = gfc_current_ns->entries;\n+  gfc_current_ns->entries = el;\n+  if (el->next)\n+    el->id = el->next->id + 1;\n+  else\n+    el->id = 1;\n \n-  return MATCH_ERROR;\n+  new_st.op = EXEC_ENTRY;\n+  new_st.ext.entry = el;\n+\n+  return MATCH_YES;\n }\n \n "}, {"sha": "e5e56db3fce5c4a9b724a77e4bb7db3f195df4b0", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -800,12 +800,17 @@ gfc_show_code_node (int level, gfc_code * c)\n       gfc_status (\"CONTINUE\");\n       break;\n \n+    case EXEC_ENTRY:\n+      gfc_status (\"ENTRY %s\", c->ext.entry->sym->name);\n+      break;\n+\n     case EXEC_ASSIGN:\n       gfc_status (\"ASSIGN \");\n       gfc_show_expr (c->expr);\n       gfc_status_char (' ');\n       gfc_show_expr (c->expr2);\n       break;\n+\n     case EXEC_LABEL_ASSIGN:\n       gfc_status (\"LABEL ASSIGN \");\n       gfc_show_expr (c->expr);"}, {"sha": "45851610e38d476d8bae67b52467f7e9d1994555", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -386,7 +386,7 @@ typedef struct\n   /* Variable attributes.  */\n   unsigned allocatable:1, dimension:1, external:1, intrinsic:1,\n     optional:1, pointer:1, save:1, target:1,\n-    dummy:1, result:1, entry:1, assign:1;\n+    dummy:1, result:1, assign:1;\n \n   unsigned data:1,\t\t/* Symbol is named in a DATA statement.  */\n     use_assoc:1;\t\t/* Symbol has been use-associated.  */\n@@ -399,6 +399,14 @@ typedef struct\n   unsigned sequence:1, elemental:1, pure:1, recursive:1;\n   unsigned unmaskable:1, masked:1, contained:1;\n \n+  /* Set if this procedure is an alternate entry point.  These procedures\n+     don't have any code associated, and the backend will turn them into\n+     thunks to the master function.  */\n+  unsigned entry:1;\n+  /* Set if this is the master function for a procedure with multiple\n+     entry points.  */\n+  unsigned entry_master:1;\n+\n   /* Set if a function must always be referenced by an explicit interface.  */\n   unsigned always_explicit:1;\n \n@@ -668,7 +676,6 @@ typedef struct gfc_symbol\n   struct gfc_namespace *ns;\t/* namespace containing this symbol */\n \n   tree backend_decl;\n-\n }\n gfc_symbol;\n \n@@ -687,6 +694,23 @@ gfc_common_head;\n #define gfc_get_common_head() gfc_getmem(sizeof(gfc_common_head))\n \n \n+/* A list of all the alternate entry points for a procedure.  */\n+\n+typedef struct gfc_entry_list\n+{\n+  /* The symbol for this entry point.  */\n+  gfc_symbol *sym;\n+  /* The zero-based id of this entry point.  */\n+  int id;\n+  /* The LABEL_EXPR marking this entry point.  */\n+  tree label;\n+  /* The nest item in the list.  */\n+  struct gfc_entry_list *next;\n+}\n+gfc_entry_list;\n+\n+#define gfc_get_entry_list() \\\n+  (gfc_entry_list *) gfc_getmem(sizeof(gfc_entry_list))\n \n /* Within a namespace, symbols are pointed to by symtree nodes that\n    are linked together in a balanced binary tree.  There can be\n@@ -712,6 +736,10 @@ typedef struct gfc_symtree\n gfc_symtree;\n \n \n+/* A namespace describes the contents of procedure, module or\n+   interface block.  */\n+/* ??? Anything else use these?  */\n+\n typedef struct gfc_namespace\n {\n   /* Tree containing all the symbols in this namespace.  */\n@@ -755,6 +783,14 @@ typedef struct gfc_namespace\n   gfc_charlen *cl_list;\n \n   int save_all, seen_save;\n+\n+  /* Normally we don't need to refcount namespaces.  However when we read\n+     a module containing a function with multiple entry points, this\n+     will appear as several functions with the same formal namespace.  */\n+  int refs;\n+\n+  /* A list of all alternate entry points to this procedure (or NULL).  */\n+  gfc_entry_list *entries;\n }\n gfc_namespace;\n \n@@ -1204,7 +1240,8 @@ gfc_forall_iterator;\n typedef enum\n {\n   EXEC_NOP = 1, EXEC_ASSIGN, EXEC_LABEL_ASSIGN, EXEC_POINTER_ASSIGN,\n-  EXEC_GOTO, EXEC_CALL, EXEC_RETURN, EXEC_PAUSE, EXEC_STOP, EXEC_CONTINUE,\n+  EXEC_GOTO, EXEC_CALL, EXEC_RETURN, EXEC_ENTRY,\n+  EXEC_PAUSE, EXEC_STOP, EXEC_CONTINUE,\n   EXEC_IF, EXEC_ARITHMETIC_IF, EXEC_DO, EXEC_DO_WHILE, EXEC_SELECT,\n   EXEC_FORALL, EXEC_WHERE, EXEC_CYCLE, EXEC_EXIT,\n   EXEC_ALLOCATE, EXEC_DEALLOCATE,\n@@ -1243,6 +1280,7 @@ typedef struct gfc_code\n     gfc_forall_iterator *forall_iterator;\n     struct gfc_code *whichloop;\n     int stop_code;\n+    gfc_entry_list *entry;\n   }\n   ext;\t\t/* Points to additional structures required by statement */\n "}, {"sha": "cd41e6640f27b3ec8f6fa1fdce37e3f009d84551", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -1367,7 +1367,7 @@ mio_internal_string (char *string)\n typedef enum\n { AB_ALLOCATABLE, AB_DIMENSION, AB_EXTERNAL, AB_INTRINSIC, AB_OPTIONAL,\n   AB_POINTER, AB_SAVE, AB_TARGET, AB_DUMMY, AB_RESULT,\n-  AB_ENTRY, AB_DATA, AB_IN_NAMELIST, AB_IN_COMMON, \n+  AB_DATA, AB_IN_NAMELIST, AB_IN_COMMON, \n   AB_FUNCTION, AB_SUBROUTINE, AB_SEQUENCE, AB_ELEMENTAL, AB_PURE,\n   AB_RECURSIVE, AB_GENERIC, AB_ALWAYS_EXPLICIT\n }\n@@ -1385,7 +1385,6 @@ static const mstring attr_bits[] =\n     minit (\"TARGET\", AB_TARGET),\n     minit (\"DUMMY\", AB_DUMMY),\n     minit (\"RESULT\", AB_RESULT),\n-    minit (\"ENTRY\", AB_ENTRY),\n     minit (\"DATA\", AB_DATA),\n     minit (\"IN_NAMELIST\", AB_IN_NAMELIST),\n     minit (\"IN_COMMON\", AB_IN_COMMON),\n@@ -1455,8 +1454,7 @@ mio_symbol_attribute (symbol_attribute * attr)\n \tMIO_NAME(ab_attribute) (AB_DUMMY, attr_bits);\n       if (attr->result)\n \tMIO_NAME(ab_attribute) (AB_RESULT, attr_bits);\n-      if (attr->entry)\n-\tMIO_NAME(ab_attribute) (AB_ENTRY, attr_bits);\n+      /* We deliberately don't preserve the \"entry\" flag.  */\n \n       if (attr->data)\n \tMIO_NAME(ab_attribute) (AB_DATA, attr_bits);\n@@ -1529,9 +1527,6 @@ mio_symbol_attribute (symbol_attribute * attr)\n \t    case AB_RESULT:\n \t      attr->result = 1;\n \t      break;\n-\t    case AB_ENTRY:\n-\t      attr->entry = 1;\n-\t      break;\n \t    case AB_DATA:\n \t      attr->data = 1;\n \t      break;\n@@ -2628,10 +2623,16 @@ mio_namespace_ref (gfc_namespace ** nsp)\n   if (p->type == P_UNKNOWN)\n     p->type = P_NAMESPACE;\n \n-  if (iomode == IO_INPUT && p->integer != 0 && p->u.pointer == NULL)\n+  if (iomode == IO_INPUT && p->integer != 0)\n     {\n-      ns = gfc_get_namespace (NULL);\n-      associate_integer_pointer (p, ns);\n+      ns = (gfc_namespace *)p->u.pointer;\n+      if (ns == NULL)\n+\t{\n+\t  ns = gfc_get_namespace (NULL);\n+\t  associate_integer_pointer (p, ns);\n+\t}\n+      else\n+\tns->refs++;\n     }\n }\n "}, {"sha": "abc3c290d75092da319d6c49870171c7b362d530", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -1076,6 +1076,7 @@ accept_statement (gfc_statement st)\n \n       break;\n \n+    case ST_ENTRY:\n     case_executable:\n     case_exec_markers:\n       add_statement ();\n@@ -2140,6 +2141,7 @@ gfc_fixup_sibling_symbols (gfc_symbol * sym, gfc_namespace * siblings)\n   gfc_symtree *st;\n   gfc_symbol *old_sym;\n \n+  sym->attr.referenced = 1;\n   for (ns = siblings; ns; ns = ns->sibling)\n     {\n       gfc_find_sym_tree (sym->name, ns, 0, &st);\n@@ -2174,6 +2176,7 @@ parse_contained (int module)\n   gfc_state_data s1, s2;\n   gfc_statement st;\n   gfc_symbol *sym;\n+  gfc_entry_list *el;\n \n   push_state (&s1, COMP_CONTAINS, NULL);\n   parent_ns = gfc_current_ns;\n@@ -2234,10 +2237,13 @@ parse_contained (int module)\n           sym->attr.contained = 1;\n \t  sym->attr.referenced = 1;\n \n+\t  parse_progunit (ST_NONE);\n+\n           /* Fix up any sibling functions that refer to this one.  */\n           gfc_fixup_sibling_symbols (sym, gfc_current_ns);\n-\n-\t  parse_progunit (ST_NONE);\n+\t  /* Or refer to any of its alternate entry points.  */\n+\t  for (el = gfc_current_ns->entries; el; el = el->next)\n+\t    gfc_fixup_sibling_symbols (el->sym, gfc_current_ns);\n \n \t  gfc_current_ns->code = s2.head;\n \t  gfc_current_ns = parent_ns;"}, {"sha": "1dc4db8a35d7b4e480c2e866b41519854160f8d8", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 166, "deletions": 52, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -247,6 +247,162 @@ resolve_formal_arglists (gfc_namespace * ns)\n }\n \n \n+static void\n+resolve_contained_fntype (gfc_symbol * sym, gfc_namespace * ns)\n+{\n+  try t;\n+  \n+  /* If this namespace is not a function, ignore it.  */\n+  if (! sym\n+      || !(sym->attr.function\n+\t   || sym->attr.flavor == FL_VARIABLE))\n+    return;\n+\n+  /* Try to find out of what type the function is.  If there was an\n+     explicit RESULT clause, try to get the type from it.  If the\n+     function is never defined, set it to the implicit type.  If\n+     even that fails, give up.  */\n+  if (sym->result != NULL)\n+    sym = sym->result;\n+\n+  if (sym->ts.type == BT_UNKNOWN)\n+    {\n+      /* Assume we can find an implicit type.  */\n+      t = SUCCESS;\n+\n+      if (sym->result == NULL)\n+\tt = gfc_set_default_type (sym, 0, ns);\n+      else\n+\t{\n+\t  if (sym->result->ts.type == BT_UNKNOWN)\n+\t    t = gfc_set_default_type (sym->result, 0, NULL);\n+\n+\t  sym->ts = sym->result->ts;\n+\t}\n+\n+      if (t == FAILURE)\n+\tgfc_error (\"Contained function '%s' at %L has no IMPLICIT type\",\n+\t\t    sym->name, &sym->declared_at); /* FIXME */\n+    }\n+}\n+\n+\n+/* Add NEW_ARGS to the formal argument list of PROC, taking care not to\n+   introduce duplicates.   */\n+\n+static void\n+merge_argument_lists (gfc_symbol *proc, gfc_formal_arglist *new_args)\n+{\n+  gfc_formal_arglist *f, *new_arglist;\n+  gfc_symbol *new_sym;\n+\n+  for (; new_args != NULL; new_args = new_args->next)\n+    {\n+      new_sym = new_args->sym;\n+      /* See if ths arg is already in the formal argument list.  */\n+      for (f = proc->formal; f; f = f->next)\n+\t{\n+\t  if (new_sym == f->sym)\n+\t    break;\n+\t}\n+\n+      if (f)\n+\tcontinue;\n+\n+      /* Add a new argument.  Argument order is not important.  */\n+      new_arglist = gfc_get_formal_arglist ();\n+      new_arglist->sym = new_sym;\n+      new_arglist->next = proc->formal;\n+      proc->formal  = new_arglist;\n+    }\n+}\n+\n+\n+/* Resolve alternate entry points.  If a symbol has multiple entry points we\n+   create a new master symbol for the main routine, and turn the existing\n+   symbol into an entry point.  */\n+\n+static void\n+resolve_entries (gfc_namespace * ns)\n+{\n+  gfc_namespace *old_ns;\n+  gfc_code *c;\n+  gfc_symbol *proc;\n+  gfc_entry_list *el;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  static int master_count = 0;\n+\n+  if (ns->proc_name == NULL)\n+    return;\n+\n+  /* No need to do anything if this procedure doesn't have alternate entry\n+     points.  */\n+  if (!ns->entries)\n+    return;\n+\n+  /* We may already have resolved alternate entry points.  */\n+  if (ns->proc_name->attr.entry_master)\n+    return;\n+\n+  /* If this isn't a procedure something as gone horribly wrong.   */\n+  assert (ns->proc_name->attr.flavor == FL_PROCEDURE);\n+  \n+  /* Remember the current namespace.  */\n+  old_ns = gfc_current_ns;\n+\n+  gfc_current_ns = ns;\n+\n+  /* Add the main entry point to the list of entry points.  */\n+  el = gfc_get_entry_list ();\n+  el->sym = ns->proc_name;\n+  el->id = 0;\n+  el->next = ns->entries;\n+  ns->entries = el;\n+  ns->proc_name->attr.entry = 1;\n+\n+  /* Add an entry statement for it.  */\n+  c = gfc_get_code ();\n+  c->op = EXEC_ENTRY;\n+  c->ext.entry = el;\n+  c->next = ns->code;\n+  ns->code = c;\n+\n+  /* Create a new symbol for the master function.  */\n+  /* Give the internal function a unique name (within this file).\n+     Also include teh function name so the user has some hope of figuring\n+     out whats going on.  */\n+  snprintf (name, GFC_MAX_SYMBOL_LEN, \"master.%d.%s\",\n+\t    master_count++, ns->proc_name->name);\n+  name[GFC_MAX_SYMBOL_LEN] = '\\0';\n+  gfc_get_ha_symbol (name, &proc);\n+  assert (proc != NULL);\n+\n+  gfc_add_procedure (&proc->attr, PROC_INTERNAL, NULL);\n+  if (ns->proc_name->attr.subroutine)\n+    gfc_add_subroutine (&proc->attr, NULL);\n+  else\n+    {\n+      gfc_add_function (&proc->attr, NULL);\n+      gfc_internal_error (\"TODO: Functions with alternate entry points\");\n+    }\n+  proc->attr.access = ACCESS_PRIVATE;\n+  proc->attr.entry_master = 1;\n+\n+  /* Merge all the entry point arguments.  */\n+  for (el = ns->entries; el; el = el->next)\n+    merge_argument_lists (proc, el->sym->formal);\n+\n+  /* And use it for the function body.  */\n+  ns->proc_name = proc;\n+\n+  /* FInalize the new symbols.  */\n+  gfc_commit_symbols ();\n+\n+  /* Restore the original namespace.  */\n+  gfc_current_ns = old_ns;\n+}\n+\n+\n /* Resolve contained function types.  Because contained functions can call one\n    another, they have to be worked out before any of the contained procedures\n    can be resolved.\n@@ -259,65 +415,20 @@ resolve_formal_arglists (gfc_namespace * ns)\n static void\n resolve_contained_functions (gfc_namespace * ns)\n {\n-  gfc_symbol *contained_sym, *sym_lower;\n   gfc_namespace *child;\n-  try t;\n+  gfc_entry_list *el;\n \n   resolve_formal_arglists (ns);\n \n   for (child = ns->contained; child; child = child->sibling)\n     {\n-      sym_lower = child->proc_name;\n-\n-      /* If this namespace is not a function, ignore it.  */\n-      if (! sym_lower\n-\t  || !( sym_lower->attr.function\n-\t\t|| sym_lower->attr.flavor == FL_VARIABLE))\n-\tcontinue;\n-\n-      /* Find the contained symbol in the current namespace.  */\n-      gfc_find_symbol (sym_lower->name, ns, 0, &contained_sym);\n-\n-      if (contained_sym == NULL)\n-\tgfc_internal_error (\"resolve_contained_functions(): Contained \"\n-\t\t\t    \"function not found in parent namespace\");\n-\n-      /* Try to find out of what type the function is.  If there was an\n-\t explicit RESULT clause, try to get the type from it.  If the\n-\t function is never defined, set it to the implicit type.  If\n-\t even that fails, give up.  */\n-      if (sym_lower->result != NULL)\n-\tsym_lower = sym_lower->result;\n-\n-      if (sym_lower->ts.type == BT_UNKNOWN)\n-\t{\n-\t  /* Assume we can find an implicit type.  */\n-\t  t = SUCCESS;\n-\n-\t  if (sym_lower->result == NULL)\n-\t    t = gfc_set_default_type (sym_lower, 0, child);\n-\t  else\n-\t    {\n-\t      if (sym_lower->result->ts.type == BT_UNKNOWN)\n-\t\tt = gfc_set_default_type (sym_lower->result, 0, NULL);\n-\n-\t      sym_lower->ts = sym_lower->result->ts;\n-\t    }\n-\n-\t  if (t == FAILURE)\n-\t    gfc_error (\"Contained function '%s' at %L has no IMPLICIT type\",\n-\t\t\tsym_lower->name, &sym_lower->declared_at); /* FIXME */\n-\t}\n+      /* Resolve alternate entry points first.  */\n+      resolve_entries (child); \n \n-      /* If the symbol in the parent of the contained namespace is not\n-\t the same as the one in contained namespace itself, copy over\n-\t the type information.  */\n-      /* ??? Shouldn't we replace the symbol with the parent symbol instead?  */\n-      if (contained_sym != sym_lower)\n-\t{\n-\t  contained_sym->ts = sym_lower->ts;\n-\t  contained_sym->as = gfc_copy_array_spec (sym_lower->as);\n-\t}\n+      /* Then check function return types.  */\n+      resolve_contained_fntype (child->proc_name, child);\n+      for (el = child->entries; el; el = el->next)\n+\tresolve_contained_fntype (el->sym, child);\n     }\n }\n \n@@ -3458,6 +3569,7 @@ resolve_code (gfc_code * code, gfc_namespace * ns)\n \tcase EXEC_CONTINUE:\n \tcase EXEC_DT_END:\n \tcase EXEC_TRANSFER:\n+\tcase EXEC_ENTRY:\n \t  break;\n \n \tcase EXEC_WHERE:\n@@ -4440,6 +4552,8 @@ gfc_resolve (gfc_namespace * ns)\n   old_ns = gfc_current_ns;\n   gfc_current_ns = ns;\n \n+  resolve_entries (ns);\n+\n   resolve_contained_functions (ns);\n \n   gfc_traverse_ns (ns, resolve_symbol);"}, {"sha": "f3e3671cac844d74e600484d8de06f987ec88254", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -106,7 +106,7 @@ gfc_free_statement (gfc_code * p)\n     case EXEC_CONTINUE:\n     case EXEC_TRANSFER:\n     case EXEC_LABEL_ASSIGN:\n-\n+    case EXEC_ENTRY:\n     case EXEC_ARITHMETIC_IF:\n       break;\n "}, {"sha": "c12586557746750d3407102bac27bf49743b397c", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -25,6 +25,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include <string.h>\n #include <stdio.h>\n #include <stdlib.h>\n+#include <assert.h>\n \n #include \"gfortran.h\"\n #include \"parse.h\"\n@@ -1614,6 +1615,8 @@ gfc_get_namespace (gfc_namespace * parent)\n \t}\n     }\n \n+  ns->refs = 1;\n+\n   return ns;\n }\n \n@@ -2228,6 +2231,11 @@ gfc_free_namespace (gfc_namespace * ns)\n   if (ns == NULL)\n     return;\n \n+  ns->refs--;\n+  if (ns->refs > 0)\n+    return;\n+  assert (ns->refs == 0);\n+\n   gfc_free_statements (ns->code);\n \n   free_sym_tree (ns->sym_root);"}, {"sha": "3abb1959ebe1760db6a4d494d0f2fac9165919c8", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -3074,6 +3074,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n   int n;\n   int checkparm;\n   int no_repack;\n+  bool optional_arg;\n \n   /* Do nothing for pointer and allocatable arrays.  */\n   if (sym->attr.pointer || sym->attr.allocatable)\n@@ -3281,7 +3282,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \n   /* Only do the entry/initialization code if the arg is present.  */\n   dumdesc = GFC_DECL_SAVED_DESCRIPTOR (tmpdesc);\n-  if (sym->attr.optional)\n+  optional_arg = sym->attr.optional || sym->ns->proc_name->attr.entry_master;\n+  if (optional_arg)\n     {\n       tmp = gfc_conv_expr_present (sym);\n       stmt = build_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n@@ -3318,7 +3320,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       tmp = build (NE_EXPR, boolean_type_node, tmp, tmpdesc);\n       stmt = build_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n \n-      if (sym->attr.optional)\n+      if (optional_arg)\n         {\n           tmp = gfc_conv_expr_present (sym);\n           stmt = build_v (COND_EXPR, tmp, stmt, build_empty_stmt ());"}, {"sha": "9dfcc186f0ff90adf0e95b26bac458d937c5313c", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 306, "deletions": 75, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -740,9 +740,6 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n   if (sym->backend_decl)\n     return sym->backend_decl;\n \n-  if (sym->attr.entry)\n-    gfc_todo_error (\"alternate entry\");\n-\n   /* Catch function declarations.  Only used for actual parameters.  */\n   if (sym->attr.flavor == FL_PROCEDURE)\n     {\n@@ -876,6 +873,11 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n   if (sym->backend_decl)\n     return sym->backend_decl;\n \n+  /* We should never be creating external decls for alternate entry points.\n+     The procedure may be an alternate entry point, but we don't want/need\n+     to know that.  */\n+  assert (!(sym->attr.entry || sym->attr.entry_master));\n+\n   if (sym->attr.intrinsic)\n     {\n       /* Call the resolution function to get the actual name.  This is\n@@ -949,7 +951,7 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n       /* TODO: check if pure SUBROUTINEs don't have INTENT(OUT)\n \t parameters and don't use alternate returns (is this\n \t allowed?). In that case, calls to them are meaningless, and\n-\t can be optimized away. See also in gfc_build_function_decl().  */\n+\t can be optimized away. See also in build_function_decl().  */\n       TREE_SIDE_EFFECTS (fndecl) = 0;\n     }\n \n@@ -963,16 +965,16 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n \n \n /* Create a declaration for a procedure.  For external functions (in the C\n-   sense) use gfc_get_extern_function_decl.  */\n+   sense) use gfc_get_extern_function_decl.  HAS_ENTRIES is true if this is\n+   a master function with alternate entry points.  */\n \n-void\n-gfc_build_function_decl (gfc_symbol * sym)\n+static void\n+build_function_decl (gfc_symbol * sym)\n {\n-  tree fndecl, type, result_decl, typelist, arglist;\n-  tree length;\n+  tree fndecl, type;\n   symbol_attribute attr;\n+  tree result_decl;\n   gfc_formal_arglist *f;\n-  tree parm;\n \n   assert (!sym->backend_decl);\n   assert (!sym->attr.external);\n@@ -1048,7 +1050,8 @@ gfc_build_function_decl (gfc_symbol * sym)\n \n   /* This specifies if a function is globaly visible, ie. it is\n      the opposite of declaring static in C.  */\n-  if (DECL_CONTEXT (fndecl) == NULL_TREE)\n+  if (DECL_CONTEXT (fndecl) == NULL_TREE\n+      && !sym->attr.entry_master)\n     TREE_PUBLIC (fndecl) = 1;\n \n   /* TREE_STATIC means the function body is defined here.  */\n@@ -1070,11 +1073,45 @@ gfc_build_function_decl (gfc_symbol * sym)\n   /* Layout the function declaration and put it in the binding level\n      of the current function.  */\n   pushdecl (fndecl);\n+\n+  sym->backend_decl = fndecl;\n+}\n+\n+\n+/* Create the DECL_ARGUMENTS for a procedure.  */\n+\n+static void\n+create_function_arglist (gfc_symbol * sym)\n+{\n+  tree fndecl;\n+  gfc_formal_arglist *f;\n+  tree typelist;\n+  tree arglist;\n+  tree length;\n+  tree type;\n+  tree parm;\n+\n+  fndecl = sym->backend_decl;\n+\n   /* Build formal argument list. Make sure that their TREE_CONTEXT is\n      the new FUNCTION_DECL node.  */\n-  current_function_decl = fndecl;\n   arglist = NULL_TREE;\n   typelist = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+\n+  if (sym->attr.entry_master)\n+    {\n+      type = TREE_VALUE (typelist);\n+      parm = build_decl (PARM_DECL, get_identifier (\"__entry\"), type);\n+      \n+      DECL_CONTEXT (parm) = fndecl;\n+      DECL_ARG_TYPE (parm) = type;\n+      TREE_READONLY (parm) = 1;\n+      gfc_finish_decl (parm, NULL_TREE);\n+\n+      arglist = chainon (arglist, parm);\n+      typelist = TREE_CHAIN (typelist);\n+    }\n+\n   if (gfc_return_by_reference (sym))\n     {\n       type = TREE_VALUE (typelist);\n@@ -1201,14 +1238,224 @@ gfc_build_function_decl (gfc_symbol * sym)\n \n   assert (TREE_VALUE (typelist) == void_type_node);\n   DECL_ARGUMENTS (fndecl) = arglist;\n+}\n \n-  /* Restore the old context.  */\n-  current_function_decl = DECL_CONTEXT (fndecl);\n \n-  sym->backend_decl = fndecl;\n+/* Finalize DECL and all nested functions with cgraph.  */\n+\n+static void\n+gfc_finalize (tree decl)\n+{\n+  struct cgraph_node *cgn;\n+\n+  cgn = cgraph_node (decl);\n+  for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n+    gfc_finalize (cgn->decl);\n+\n+  cgraph_finalize_function (decl, false);\n }\n \n \n+/* Convert FNDECL's code to GIMPLE and handle any nested functions.  */\n+\n+static void\n+gfc_gimplify_function (tree fndecl)\n+{\n+  struct cgraph_node *cgn;\n+\n+  gimplify_function_tree (fndecl);\n+  dump_function (TDI_generic, fndecl);\n+\n+  /* Convert all nested functions to GIMPLE now.  We do things in this order\n+     so that items like VLA sizes are expanded properly in the context of the\n+     correct function.  */\n+  cgn = cgraph_node (fndecl);\n+  for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n+    gfc_gimplify_function (cgn->decl);\n+}\n+\n+\n+/* Do the setup necessary before generating the body of a function.  */\n+\n+static void\n+trans_function_start (gfc_symbol * sym)\n+{\n+  tree fndecl;\n+\n+  fndecl = sym->backend_decl;\n+\n+  /* let GCC know the current scope is this function */\n+  current_function_decl = fndecl;\n+\n+  /* Let the world know what e're about to do.  */\n+  announce_function (fndecl);\n+\n+  if (DECL_CONTEXT (fndecl) == NULL_TREE)\n+    {\n+      /* create RTL for function declaration */\n+      rest_of_decl_compilation (fndecl, 1, 0);\n+    }\n+\n+  /* create RTL for function definition */\n+  make_decl_rtl (fndecl);\n+\n+  /* Set the line and filename.  sym->decalred_at seems to point to the\n+     last statement for subroutines, but it'll do for now.  */\n+  gfc_set_backend_locus (&sym->declared_at);\n+\n+  init_function_start (fndecl);\n+\n+  /* Even though we're inside a function body, we still don't want to\n+     call expand_expr to calculate the size of a variable-sized array.\n+     We haven't necessarily assigned RTL to all variables yet, so it's\n+     not safe to try to expand expressions involving them.  */\n+  cfun->x_dont_save_pending_sizes_p = 1;\n+\n+  /* function.c requires a push at the start of the function */\n+  pushlevel (0);\n+}\n+\n+/* Create thunks for alternate entry points.  */\n+\n+static void\n+build_entry_thunks (gfc_namespace * ns)\n+{\n+  gfc_formal_arglist *formal;\n+  gfc_formal_arglist *thunk_formal;\n+  gfc_entry_list *el;\n+  gfc_symbol *thunk_sym;\n+  stmtblock_t body;\n+  tree thunk_fndecl;\n+  tree args;\n+  tree string_args;\n+  tree tmp;\n+\n+  /* This should always be a toplevel function.  */\n+  assert (current_function_decl == NULL_TREE);\n+\n+  /* Remeber the master function argument decls.  */\n+  for (formal = ns->proc_name->formal; formal; formal = formal->next)\n+    {\n+    }\n+  \n+  for (el = ns->entries; el; el = el->next)\n+    {\n+      thunk_sym = el->sym;\n+      \n+      build_function_decl (thunk_sym);\n+      create_function_arglist (thunk_sym);\n+\n+      trans_function_start (thunk_sym);\n+\n+      thunk_fndecl = thunk_sym->backend_decl;\n+\n+      gfc_start_block (&body);\n+\n+      /* Pass extra parater identifying this entry point.  */\n+      tmp = build_int_cst (gfc_array_index_type, el->id, 0);\n+      args = tree_cons (NULL_TREE, tmp, NULL_TREE);\n+      string_args = NULL_TREE;\n+\n+      /* TODO: Pass return by reference parameters.  */\n+      if (ns->proc_name->attr.function)\n+\tgfc_todo_error (\"Functons with multiple entry points\");\n+      \n+      for (formal = ns->proc_name->formal; formal; formal = formal->next)\n+\t{\n+\t  /* We don't have a clever way of identifying arguments, so resort to\n+\t     a brute-force search.  */\n+\t  for (thunk_formal = thunk_sym->formal;\n+\t       thunk_formal;\n+\t       thunk_formal = thunk_formal->next)\n+\t    {\n+\t      if (thunk_formal->sym == formal->sym)\n+\t\tbreak;\n+\t    }\n+\n+\t  if (thunk_formal)\n+\t    {\n+\t      /* Pass the argument.  */\n+\t      args = tree_cons (NULL_TREE, thunk_formal->sym->backend_decl,\n+\t\t\t\targs);\n+\t      if (formal->sym->ts.type == BT_CHARACTER)\n+\t\t{\n+\t\t  tmp = thunk_formal->sym->ts.cl->backend_decl;\n+\t\t  string_args = tree_cons (NULL_TREE, tmp, string_args);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Pass NULL for a missing argument.  */\n+\t      args = tree_cons (NULL_TREE, null_pointer_node, args);\n+\t      if (formal->sym->ts.type == BT_CHARACTER)\n+\t\t{\n+\t\t  tmp = convert (gfc_strlen_type_node, integer_zero_node);\n+\t\t  string_args = tree_cons (NULL_TREE, tmp, string_args);\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Call the master function.  */\n+      args = nreverse (args);\n+      args = chainon (args, nreverse (string_args));\n+      tmp = ns->proc_name->backend_decl;\n+      tmp = gfc_build_function_call (tmp, args);\n+      /* TODO: function return value.  */\n+      gfc_add_expr_to_block (&body, tmp);\n+\n+      /* Finish off this function and send it for code generation.  */\n+      DECL_SAVED_TREE (thunk_fndecl) = gfc_finish_block (&body);\n+      poplevel (1, 0, 1);\n+      BLOCK_SUPERCONTEXT (DECL_INITIAL (thunk_fndecl)) = thunk_fndecl;\n+\n+      /* Output the GENERIC tree.  */\n+      dump_function (TDI_original, thunk_fndecl);\n+\n+      /* Store the end of the function, so that we get good line number\n+\t info for the epilogue.  */\n+      cfun->function_end_locus = input_location;\n+\n+      /* We're leaving the context of this function, so zap cfun.\n+\t It's still in DECL_STRUCT_FUNCTION, and we'll restore it in\n+\t tree_rest_of_compilation.  */\n+      cfun = NULL;\n+\n+      current_function_decl = NULL_TREE;\n+\n+      gfc_gimplify_function (thunk_fndecl);\n+      lower_nested_functions (thunk_fndecl);\n+      gfc_finalize (thunk_fndecl);\n+\n+      /* We share the symbols in the formal argument list with other entry\n+\t points and the master function.  Clear them so that they are\n+\t recreated for each function.  */\n+      for (formal = thunk_sym->formal; formal; formal = formal->next)\n+\t{\n+\t  formal->sym->backend_decl = NULL_TREE;\n+\t  if (formal->sym->ts.type == BT_CHARACTER)\n+\t    formal->sym->ts.cl->backend_decl = NULL_TREE;\n+\t}\n+    }\n+}\n+\n+\n+/* Create a decl for a function, and create any thunks for alternate entry\n+   points.  */\n+\n+void\n+gfc_create_function_decl (gfc_namespace * ns)\n+{\n+  /* Create a declaration for the master function.  */\n+  build_function_decl (ns->proc_name);\n+\n+  /* Compile teh entry thunks.  */\n+  if (ns->entries)\n+    build_entry_thunks (ns);\n+\n+  /* Now create the read argument list.  */\n+  create_function_arglist (ns->proc_name);\n+}\n+\n /* Return the decl used to hold the function return value.  */\n \n tree\n@@ -1811,7 +2058,7 @@ gfc_generate_contained_functions (gfc_namespace * parent)\n       if (ns->parent != parent)\n \tcontinue;\n \n-      gfc_build_function_decl (ns->proc_name);\n+      gfc_create_function_decl (ns);\n     }\n \n   for (ns = parent->contained; ns; ns = ns->sibling)\n@@ -1856,37 +2103,44 @@ generate_local_vars (gfc_namespace * ns)\n }\n \n \n-/* Finalize DECL and all nested functions with cgraph.  */\n+/* Generate a switch statement to jump to the correct entry point.  Also\n+   creates the label decls for the entry points.  */\n \n-static void\n-gfc_finalize (tree decl)\n+static tree\n+gfc_trans_entry_master_switch (gfc_entry_list * el)\n {\n-  struct cgraph_node *cgn;\n-\n-  cgn = cgraph_node (decl);\n-  for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n-    gfc_finalize (cgn->decl);\n+  stmtblock_t block;\n+  tree label;\n+  tree tmp;\n+  tree val;\n \n-  cgraph_finalize_function (decl, false);\n+  gfc_init_block (&block);\n+  for (; el; el = el->next)\n+    {\n+      /* Add the case label.  */\n+      label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+      DECL_CONTEXT (label) = current_function_decl;\n+      val = build_int_cst (gfc_array_index_type, el->id, 0);\n+      tmp = build_v (CASE_LABEL_EXPR, val, NULL_TREE, label);\n+      gfc_add_expr_to_block (&block, tmp);\n+      \n+      /* And jump to the actual entry point.  */\n+      label = gfc_build_label_decl (NULL_TREE);\n+      TREE_USED (label) = 1;\n+      DECL_CONTEXT (label) = current_function_decl;\n+      tmp = build1_v (GOTO_EXPR, label);\n+      gfc_add_expr_to_block (&block, tmp);\n+\n+      /* Save the label decl.  */\n+      el->label = label;\n+    }\n+  tmp = gfc_finish_block (&block);\n+  /* The first argument selects the entry point.  */\n+  val = DECL_ARGUMENTS (current_function_decl);\n+  tmp = build_v (SWITCH_EXPR, val, tmp, NULL_TREE);\n+  return tmp;\n }\n \n-/* Convert FNDECL's code to GIMPLE and handle any nested functions.  */\n-\n-static void\n-gfc_gimplify_function (tree fndecl)\n-{\n-  struct cgraph_node *cgn;\n-\n-  gimplify_function_tree (fndecl);\n-  dump_function (TDI_generic, fndecl);\n-\n-  /* Convert all nested functions to GIMPLE now.  We do things in this order\n-     so that items like VLA sizes are expanded properly in the context of the\n-     correct function.  */\n-  cgn = cgraph_node (fndecl);\n-  for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n-    gfc_gimplify_function (cgn->decl);\n-}\n \n /* Generate code for a function.  */\n \n@@ -1903,14 +2157,14 @@ gfc_generate_function_code (gfc_namespace * ns)\n   gfc_symbol *sym;\n \n   sym = ns->proc_name;\n+\n   /* Check that the frontend isn't still using this.  */\n   assert (sym->tlink == NULL);\n-\n   sym->tlink = sym;\n \n   /* Create the declaration for functions with global scope.  */\n   if (!sym->backend_decl)\n-    gfc_build_function_decl (ns->proc_name);\n+    gfc_create_function_decl (ns);\n \n   fndecl = sym->backend_decl;\n   old_context = current_function_decl;\n@@ -1922,41 +2176,11 @@ gfc_generate_function_code (gfc_namespace * ns)\n       saved_function_decls = NULL_TREE;\n     }\n \n-  /* let GCC know the current scope is this function */\n-  current_function_decl = fndecl;\n-\n-  /* print function name on the console at compile time\n-     (unless this feature was switched of by command line option \"-quiet\" */\n-  announce_function (fndecl);\n-\n-  if (DECL_CONTEXT (fndecl) == NULL_TREE)\n-    {\n-      /* create RTL for function declaration */\n-      rest_of_decl_compilation (fndecl, 1, 0);\n-    }\n-\n-  /* create RTL for function definition */\n-  make_decl_rtl (fndecl);\n-\n-  /* Set the line and filename.  sym->decalred_at seems to point to the last\n-     statement for subroutines, but it'll do for now.  */\n-  gfc_set_backend_locus (&sym->declared_at);\n-\n-  /* line and file should not be 0 */\n-  init_function_start (fndecl);\n-\n-  /* Even though we're inside a function body, we still don't want to\n-     call expand_expr to calculate the size of a variable-sized array.\n-     We haven't necessarily assigned RTL to all variables yet, so it's\n-     not safe to try to expand expressions involving them.  */\n-  cfun->x_dont_save_pending_sizes_p = 1;\n+  trans_function_start (sym);\n \n   /* Will be created as needed.  */\n   current_fake_result_decl = NULL_TREE;\n \n-  /* function.c requires a push at the start of the function */\n-  pushlevel (0);\n-\n   gfc_start_block (&block);\n \n   gfc_generate_contained_functions (ns);\n@@ -1979,6 +2203,13 @@ gfc_generate_function_code (gfc_namespace * ns)\n       gfc_add_modify_expr (&body, alternate_return, integer_zero_node);\n     }\n \n+  if (ns->entries)\n+    {\n+      /* Jump to the correct entry point.  */\n+      tmp = gfc_trans_entry_master_switch (ns->entries);\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n   tmp = gfc_trans_code (ns->code);\n   gfc_add_expr_to_block (&body, tmp);\n "}, {"sha": "dbe4422356fd3f70a4b3fd5a5b08230695ebdb39", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -179,6 +179,14 @@ gfc_trans_goto (gfc_code * code)\n }\n \n \n+/* Translate an ENTRY statement.  Just adds a label for this entry point.  */\n+tree\n+gfc_trans_entry (gfc_code * code)\n+{\n+  return build1_v (LABEL_EXPR, code->ext.entry->label);\n+}\n+\n+\n /* Translate the CALL statement.  Builds a call to an F95 subroutine.  */\n \n tree"}, {"sha": "c7dc229784ea35aa213b6805ad37ce33f601b0d7", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -35,6 +35,7 @@ tree gfc_trans_exit (gfc_code *);\n tree gfc_trans_label_assign (gfc_code *);\n tree gfc_trans_label_here (gfc_code *);\n tree gfc_trans_goto (gfc_code *);\n+tree gfc_trans_entry (gfc_code *);\n tree gfc_trans_pause (gfc_code *);\n tree gfc_trans_stop (gfc_code *);\n tree gfc_trans_call (gfc_code *);"}, {"sha": "85c13fa1a21ef7677a5e92d888e3a687c7c4b044", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -1155,6 +1155,13 @@ gfc_get_function_type (gfc_symbol * sym)\n   nstr = 0;\n   alternate_return = 0;\n   typelist = NULL_TREE;\n+\n+  if (sym->attr.entry_master)\n+    {\n+      /* Additional parameter for selecting an entry point.  */\n+      typelist = gfc_chainon_list (typelist, gfc_array_index_type);\n+    }\n+\n   /* Some functions we use an extra parameter for the return value.  */\n   if (gfc_return_by_reference (sym))\n     {"}, {"sha": "1ac8931bd4ef0c9c12d3b6e068a4906c211659e7", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -516,6 +516,10 @@ gfc_trans_code (gfc_code * code)\n \t  res = gfc_trans_goto (code);\n \t  break;\n \n+\tcase EXEC_ENTRY:\n+\t  res = gfc_trans_entry (code);\n+\t  break;\n+\n \tcase EXEC_PAUSE:\n \t  res = gfc_trans_pause (code);\n \t  break;\n@@ -679,7 +683,7 @@ gfc_generate_module_code (gfc_namespace * ns)\n       if (!n->proc_name)\n         continue;\n \n-      gfc_build_function_decl (n->proc_name);\n+      gfc_create_function_decl (n);\n     }\n \n   for (n = ns->contained; n; n = n->sibling)"}, {"sha": "3faf4001b87a0aa6bbe28b1e8893ff868d281709", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -394,7 +394,7 @@ void gfc_allocate_lang_decl (tree);\n tree gfc_advance_chain (tree, int);\n \n /* Create a decl for a function.  */\n-void gfc_build_function_decl (gfc_symbol *);\n+void gfc_create_function_decl (gfc_namespace *);\n /* Generate the code for a function.  */\n void gfc_generate_function_code (gfc_namespace *);\n /* Output a decl for a module variable.  */"}, {"sha": "7ceee259881f3446b80f1243ae8a57a7832dde11", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -1,3 +1,8 @@\n+2004-08-17  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/13082\n+\t* gfortran.dg/entry_1.f90: New test.\n+\n 2004-08-17  Andrew Pinski  <apinski@apple.com>\n \n \t* gcc.dg/darwin-20040812-1.c: Compile only on darwin."}, {"sha": "0e7f296ce1b085c698073d0326b08bdd77121aae", "filename": "gcc/testsuite/gfortran.dg/entry_1.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d79abbdf8a8a92943b15628b72c04c2dec15348/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_1.f90?ref=3d79abbdf8a8a92943b15628b72c04c2dec15348", "patch": "@@ -0,0 +1,44 @@\n+! Test alternate entry points in a module procedure\n+! Also check that references to sibling entry points are resolved correctly.\n+module m\n+contains\n+subroutine indirecta (p)\n+  call p (3, 4)\n+end subroutine\n+subroutine indirectb (p)\n+  call p (5)\n+end subroutine\n+\n+subroutine test1\n+  implicit none\n+  call indidecta (foo)\n+  call indirectb (bar)\n+end subroutine\n+\n+subroutine foo(a, b)\n+  integer a, b\n+  logical, save :: was_foo = .false.\n+  if ((a .ne. 3) .or. (b .ne. 4)) call abort\n+  was_foo = .true.\n+entry bar(a)\n+  if (was_foo) then\n+    if ((a .ne. 3) .or. (b .ne. 4)) call abort\n+  else\n+    if (a .ne. 5) call abort\n+  end if\n+  was_foo = .false.\n+end subroutine\n+\n+subroutine test2\n+  call foo (3, 4)\n+  call bar (5)\n+end subroutine\n+end module\n+\n+program p\n+  use m\n+  call foo (3, 4)\n+  call bar (5)\n+  call test1 ()\n+  call test2 ()\n+end program"}]}