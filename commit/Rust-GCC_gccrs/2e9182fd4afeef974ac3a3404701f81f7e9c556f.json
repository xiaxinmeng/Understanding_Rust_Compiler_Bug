{"sha": "2e9182fd4afeef974ac3a3404701f81f7e9c556f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU5MTgyZmQ0YWZlZWY5NzRhYzNhMzQwNDcwMWY4MWY3ZTljNTU2Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2006-09-11T19:28:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-09-11T19:28:11Z"}, "message": "re PR rtl-optimization/28726 (-fsched2-use-superblock produces wrong code)\n\n\tPR rtl-optimization/28726\n\t* sched-deps.c (sched_analyze_reg): New function extracted from...\n\t(sched_analyze_1): ...here.  Call it to analyze references to\n\tregisters.  Treat again writes to a stack register as writing to the\n\tregister.\n\t(sched_analyze_2): ...and here.  Call it to analyze references to\n\tregisters.  Treat again reads of a stack register as reading the\n\tregister.\n\nFrom-SVN: r116855", "tree": {"sha": "74dbbe65149d2c089f7ca72ba460cd78dd473966", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74dbbe65149d2c089f7ca72ba460cd78dd473966"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e9182fd4afeef974ac3a3404701f81f7e9c556f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e9182fd4afeef974ac3a3404701f81f7e9c556f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e9182fd4afeef974ac3a3404701f81f7e9c556f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e9182fd4afeef974ac3a3404701f81f7e9c556f/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c2b448c6553891317dfd1849d0019639b64ab3ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b448c6553891317dfd1849d0019639b64ab3ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b448c6553891317dfd1849d0019639b64ab3ee"}], "stats": {"total": 221, "additions": 131, "deletions": 90}, "files": [{"sha": "defc9d5918831edcc0d9cafdda4bcef455ae55ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e9182fd4afeef974ac3a3404701f81f7e9c556f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e9182fd4afeef974ac3a3404701f81f7e9c556f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e9182fd4afeef974ac3a3404701f81f7e9c556f", "patch": "@@ -1,3 +1,14 @@\n+2006-09-11  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR rtl-optimization/28726\n+\t* sched-deps.c (sched_analyze_reg): New function extracted from...\n+\t(sched_analyze_1): ...here.  Call it to analyze references to\n+\tregisters.  Treat again writes to a stack register as writing to the\n+\tregister.\n+\t(sched_analyze_2): ...and here.  Call it to analyze references to\n+\tregisters.  Treat again reads of a stack register as reading the\n+\tregister.\n+\n 2006-09-11  Guenter Roeck  <guenter@roeck-us.net>\n \t    David Edelsohn  <edelsohn@gnu.org>\n "}, {"sha": "0cde4f2e94f9c9d15025ad99267a6c9b00162939", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 87, "deletions": 90, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e9182fd4afeef974ac3a3404701f81f7e9c556f/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e9182fd4afeef974ac3a3404701f81f7e9c556f/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=2e9182fd4afeef974ac3a3404701f81f7e9c556f", "patch": "@@ -715,14 +715,85 @@ flush_pending_lists (struct deps *deps, rtx insn, int for_read,\n   deps->pending_flush_length = 1;\n }\n \f\n+/* Analyze a single reference to register (reg:MODE REGNO) in INSN.\n+   The type of the reference is specified by REF and can be SET,\n+   CLOBBER, PRE_DEC, POST_DEC, PRE_INC, POST_INC or USE.  */\n+\n+static void\n+sched_analyze_reg (struct deps *deps, int regno, enum machine_mode mode,\n+\t\t   enum rtx_code ref, rtx insn)\n+{\n+  /* A hard reg in a wide mode may really be multiple registers.\n+     If so, mark all of them just like the first.  */\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      int i = hard_regno_nregs[regno][mode];\n+      if (ref == SET)\n+\t{\n+\t  while (--i >= 0)\n+\t    SET_REGNO_REG_SET (reg_pending_sets, regno + i);\n+\t}\n+      else if (ref == USE)\n+\t{\n+\t  while (--i >= 0)\n+\t    SET_REGNO_REG_SET (reg_pending_uses, regno + i);\n+\t}\n+      else\n+\t{\n+\t  while (--i >= 0)\n+\t    SET_REGNO_REG_SET (reg_pending_clobbers, regno + i);\n+\t}\n+    }\n+\n+  /* ??? Reload sometimes emits USEs and CLOBBERs of pseudos that\n+     it does not reload.  Ignore these as they have served their\n+     purpose already.  */\n+  else if (regno >= deps->max_reg)\n+    {\n+      enum rtx_code code = GET_CODE (PATTERN (insn));\n+      gcc_assert (code == USE || code == CLOBBER);\n+    }\n+\n+  else\n+    {\n+      if (ref == SET)\n+\tSET_REGNO_REG_SET (reg_pending_sets, regno);\n+      else if (ref == USE)\n+\tSET_REGNO_REG_SET (reg_pending_uses, regno);\n+      else\n+\tSET_REGNO_REG_SET (reg_pending_clobbers, regno);\n+\n+      /* Pseudos that are REG_EQUIV to something may be replaced\n+\t by that during reloading.  We need only add dependencies for\n+\tthe address in the REG_EQUIV note.  */\n+      if (!reload_completed && get_reg_known_equiv_p (regno))\n+\t{\n+\t  rtx t = get_reg_known_value (regno);\n+\t  if (MEM_P (t))\n+\t    sched_analyze_2 (deps, XEXP (t, 0), insn);\n+\t}\n+\n+      /* Don't let it cross a call after scheduling if it doesn't\n+\t already cross one.  */\n+      if (REG_N_CALLS_CROSSED (regno) == 0)\n+\t{\n+\t  if (ref == USE)\n+\t    deps->sched_before_next_call\n+\t      = alloc_INSN_LIST (insn, deps->sched_before_next_call);\n+\t  else\n+\t    add_dependence_list (insn, deps->last_function_call, 1,\n+\t\t\t\t REG_DEP_ANTI);\n+\t}\n+    }\n+}\n+\n /* Analyze a single SET, CLOBBER, PRE_DEC, POST_DEC, PRE_INC or POST_INC\n    rtx, X, creating all dependencies generated by the write to the\n    destination of X, and reads of everything mentioned.  */\n \n static void\n sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n {\n-  int regno;\n   rtx dest = XEXP (x, 0);\n   enum rtx_code code = GET_CODE (x);\n \n@@ -771,64 +842,21 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n \n   if (REG_P (dest))\n     {\n-      regno = REGNO (dest);\n+      int regno = REGNO (dest);\n+      enum machine_mode mode = GET_MODE (dest);\n+\n+      sched_analyze_reg (deps, regno, mode, code, insn);\n \n #ifdef STACK_REGS\n       /* Treat all writes to a stack register as modifying the TOS.  */\n       if (regno >= FIRST_STACK_REG && regno <= LAST_STACK_REG)\n \t{\n-\t  SET_REGNO_REG_SET (reg_pending_uses, FIRST_STACK_REG);\n-\t  regno = FIRST_STACK_REG;\n+\t  /* Avoid analyzing the same register twice.  */\n+\t  if (regno != FIRST_STACK_REG)\n+\t    sched_analyze_reg (deps, FIRST_STACK_REG, mode, code, insn);\n+\t  sched_analyze_reg (deps, FIRST_STACK_REG, mode, USE, insn);\n \t}\n #endif\n-\n-      /* A hard reg in a wide mode may really be multiple registers.\n-         If so, mark all of them just like the first.  */\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  int i = hard_regno_nregs[regno][GET_MODE (dest)];\n-\t  if (code == SET)\n-\t    {\n-\t      while (--i >= 0)\n-\t\tSET_REGNO_REG_SET (reg_pending_sets, regno + i);\n-\t    }\n-\t  else\n-\t    {\n-\t      while (--i >= 0)\n-\t\tSET_REGNO_REG_SET (reg_pending_clobbers, regno + i);\n-\t    }\n-\t}\n-      /* ??? Reload sometimes emits USEs and CLOBBERs of pseudos that\n-\t it does not reload.  Ignore these as they have served their\n-\t purpose already.  */\n-      else if (regno >= deps->max_reg)\n-\t{\n-\t  gcc_assert (GET_CODE (PATTERN (insn)) == USE\n-\t\t      || GET_CODE (PATTERN (insn)) == CLOBBER);\n-\t}\n-      else\n-\t{\n-\t  if (code == SET)\n-\t    SET_REGNO_REG_SET (reg_pending_sets, regno);\n-\t  else\n-\t    SET_REGNO_REG_SET (reg_pending_clobbers, regno);\n-\n-\t  /* Pseudos that are REG_EQUIV to something may be replaced\n-\t     by that during reloading.  We need only add dependencies for\n-\t     the address in the REG_EQUIV note.  */\n-\t  if (!reload_completed && get_reg_known_equiv_p (regno))\n-\t    {\n-\t      rtx t = get_reg_known_value (regno);\n-\t      if (MEM_P (t))\n-\t        sched_analyze_2 (deps, XEXP (t, 0), insn);\n-\t    }\n-\n-\t  /* Don't let it cross a call after scheduling if it doesn't\n-\t     already cross one.  */\n-\t  if (REG_N_CALLS_CROSSED (regno) == 0)\n-\t    add_dependence_list (insn, deps->last_function_call, 1,\n-\t\t\t\t REG_DEP_ANTI);\n-\t}\n     }\n   else if (MEM_P (dest))\n     {\n@@ -935,51 +963,20 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n     case REG:\n       {\n \tint regno = REGNO (x);\n+\tenum machine_mode mode = GET_MODE (x);\n+\n+\tsched_analyze_reg (deps, regno, mode, USE, insn);\n \n #ifdef STACK_REGS\n       /* Treat all reads of a stack register as modifying the TOS.  */\n       if (regno >= FIRST_STACK_REG && regno <= LAST_STACK_REG)\n \t{\n-\t  SET_REGNO_REG_SET (reg_pending_sets, FIRST_STACK_REG);\n-\t  regno = FIRST_STACK_REG;\n+\t  /* Avoid analyzing the same register twice.  */\n+\t  if (regno != FIRST_STACK_REG)\n+\t    sched_analyze_reg (deps, FIRST_STACK_REG, mode, USE, insn);\n+\t  sched_analyze_reg (deps, FIRST_STACK_REG, mode, SET, insn);\n \t}\n #endif\n-\n-\tif (regno < FIRST_PSEUDO_REGISTER)\n-\t  {\n-\t    int i = hard_regno_nregs[regno][GET_MODE (x)];\n-\t    while (--i >= 0)\n-\t      SET_REGNO_REG_SET (reg_pending_uses, regno + i);\n-\t  }\n-\t/* ??? Reload sometimes emits USEs and CLOBBERs of pseudos that\n-\t   it does not reload.  Ignore these as they have served their\n-\t   purpose already.  */\n-\telse if (regno >= deps->max_reg)\n-\t  {\n-\t    gcc_assert (GET_CODE (PATTERN (insn)) == USE\n-\t\t\t|| GET_CODE (PATTERN (insn)) == CLOBBER);\n-\t  }\n-\telse\n-\t  {\n-\t    SET_REGNO_REG_SET (reg_pending_uses, regno);\n-\n-\t    /* Pseudos that are REG_EQUIV to something may be replaced\n-\t       by that during reloading.  We need only add dependencies for\n-\t       the address in the REG_EQUIV note.  */\n-\t    if (!reload_completed && get_reg_known_equiv_p (regno))\n-\t      {\n-\t\trtx t = get_reg_known_value (regno);\n-\t\tif (MEM_P (t))\n-\t\t  sched_analyze_2 (deps, XEXP (t, 0), insn);\n-\t      }\n-\n-\t    /* If the register does not already cross any calls, then add this\n-\t       insn to the sched_before_next_call list so that it will still\n-\t       not cross calls after scheduling.  */\n-\t    if (REG_N_CALLS_CROSSED (regno) == 0)\n-\t      deps->sched_before_next_call\n-\t\t= alloc_INSN_LIST (insn, deps->sched_before_next_call);\n-\t  }\n \treturn;\n       }\n "}, {"sha": "3be624e205d128cd1f898c5bfcaf0e8bb67a3d37", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e9182fd4afeef974ac3a3404701f81f7e9c556f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e9182fd4afeef974ac3a3404701f81f7e9c556f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2e9182fd4afeef974ac3a3404701f81f7e9c556f", "patch": "@@ -1,3 +1,7 @@\n+2006-09-11  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* gcc.dg/pr28726.c: New test.\n+\n 2006-09-11  Josh Conner  <jconner@apple.com>\n \n \t* gcc.dg/nrv3.c: Increase size of structure."}, {"sha": "11232ac86a2851fee8303280edcecaddc02285bf", "filename": "gcc/testsuite/gcc.dg/pr28726.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e9182fd4afeef974ac3a3404701f81f7e9c556f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28726.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e9182fd4afeef974ac3a3404701f81f7e9c556f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28726.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28726.c?ref=2e9182fd4afeef974ac3a3404701f81f7e9c556f", "patch": "@@ -0,0 +1,29 @@\n+/* PR rtl-optimization/28726 */\n+/* Origin: Sigurd Schneider <sg313d@gmail.com> */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fsched2-use-superblocks\" } */\n+\n+extern void abort (void);\n+\n+static double my_loop(void) __attribute__((noinline));\n+\n+static double my_loop(void)\n+{\n+  double retval = 0.0;\n+  const unsigned char *start = \"\\005\\b\\000\";\n+  const unsigned char *const end = start + 2;\n+\n+  while (start < end)\n+    retval += *start++;\n+\n+  return retval;\n+}\n+\n+int main(void)\n+{\n+  if (my_loop() != 13.0)\n+    abort ();\n+\n+  return 0;\n+}"}]}