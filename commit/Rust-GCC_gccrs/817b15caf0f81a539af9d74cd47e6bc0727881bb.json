{"sha": "817b15caf0f81a539af9d74cd47e6bc0727881bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE3YjE1Y2FmMGY4MWE1MzlhZjlkNzRjZDQ3ZTZiYzA3Mjc4ODFiYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-05-05T05:22:12Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-05-05T05:22:12Z"}, "message": "Use backend interface for slice types.\n\nFrom-SVN: r173415", "tree": {"sha": "9431f70a212177b301cdcd08958d3469585bcf5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9431f70a212177b301cdcd08958d3469585bcf5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/817b15caf0f81a539af9d74cd47e6bc0727881bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/817b15caf0f81a539af9d74cd47e6bc0727881bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/817b15caf0f81a539af9d74cd47e6bc0727881bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/817b15caf0f81a539af9d74cd47e6bc0727881bb/comments", "author": null, "committer": null, "parents": [{"sha": "a78079c49b556474080ef7336be1afa0e50b3ab1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a78079c49b556474080ef7336be1afa0e50b3ab1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a78079c49b556474080ef7336be1afa0e50b3ab1"}], "stats": {"total": 164, "additions": 54, "deletions": 110}, "files": [{"sha": "2ff94f64e5bcc54296e8db4c15d23ccbf51f983d", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/817b15caf0f81a539af9d74cd47e6bc0727881bb/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/817b15caf0f81a539af9d74cd47e6bc0727881bb/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=817b15caf0f81a539af9d74cd47e6bc0727881bb", "patch": "@@ -1936,38 +1936,6 @@ Gogo::ptr_go_string_constant_tree(const std::string& val)\n   return build_fold_addr_expr(decl);\n }\n \n-// Build the type of the struct that holds a slice for the given\n-// element type.\n-\n-tree\n-Gogo::slice_type_tree(tree element_type_tree)\n-{\n-  // We use int for the count and capacity fields in a slice header.\n-  // This matches 6g.  The language definition guarantees that we\n-  // can't allocate space of a size which does not fit in int\n-  // anyhow. FIXME: integer_type_node is the the C type \"int\" but is\n-  // not necessarily the Go type \"int\".  They will differ when the C\n-  // type \"int\" has fewer than 32 bits.\n-  return Gogo::builtin_struct(NULL, \"__go_slice\", NULL_TREE, 3,\n-\t\t\t      \"__values\",\n-\t\t\t      build_pointer_type(element_type_tree),\n-\t\t\t      \"__count\",\n-\t\t\t      integer_type_node,\n-\t\t\t      \"__capacity\",\n-\t\t\t      integer_type_node);\n-}\n-\n-// Given the tree for a slice type, return the tree for the type of\n-// the elements of the slice.\n-\n-tree\n-Gogo::slice_element_type_tree(tree slice_type_tree)\n-{\n-  go_assert(TREE_CODE(slice_type_tree) == RECORD_TYPE\n-\t     && POINTER_TYPE_P(TREE_TYPE(TYPE_FIELDS(slice_type_tree))));\n-  return TREE_TYPE(TREE_TYPE(TYPE_FIELDS(slice_type_tree)));\n-}\n-\n // Build a constructor for a slice.  SLICE_TYPE_TREE is the type of\n // the slice.  VALUES is the value pointer and COUNT is the number of\n // entries.  If CAPACITY is not NULL, it is the capacity; otherwise\n@@ -2011,21 +1979,6 @@ Gogo::slice_constructor(tree slice_type_tree, tree values, tree count,\n   return build_constructor(slice_type_tree, init);\n }\n \n-// Build a constructor for an empty slice.\n-\n-tree\n-Gogo::empty_slice_constructor(tree slice_type_tree)\n-{\n-  tree element_field = TYPE_FIELDS(slice_type_tree);\n-  tree ret = Gogo::slice_constructor(slice_type_tree,\n-\t\t\t\t     fold_convert(TREE_TYPE(element_field),\n-\t\t\t\t\t\t  null_pointer_node),\n-\t\t\t\t     size_zero_node,\n-\t\t\t\t     size_zero_node);\n-  TREE_CONSTANT(ret) = 1;\n-  return ret;\n-}\n-\n // Build a map descriptor for a map of type MAPTYPE.\n \n tree"}, {"sha": "0c524f029fccf82058fa2281e354063f5e4109f8", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/817b15caf0f81a539af9d74cd47e6bc0727881bb/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/817b15caf0f81a539af9d74cd47e6bc0727881bb/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=817b15caf0f81a539af9d74cd47e6bc0727881bb", "patch": "@@ -465,16 +465,6 @@ class Gogo\n   static void\n   mark_fndecl_as_builtin_library(tree fndecl);\n \n-  // Build the type of the struct that holds a slice for the given\n-  // element type.\n-  tree\n-  slice_type_tree(tree element_type_tree);\n-\n-  // Given a tree for a slice type, return the tree for the element\n-  // type.\n-  static tree\n-  slice_element_type_tree(tree slice_type_tree);\n-\n   // Build a constructor for a slice.  SLICE_TYPE_TREE is the type of\n   // the slice.  VALUES points to the values.  COUNT is the size,\n   // CAPACITY is the capacity.  If CAPACITY is NULL, it is set to\n@@ -483,11 +473,6 @@ class Gogo\n   slice_constructor(tree slice_type_tree, tree values, tree count,\n \t\t    tree capacity);\n \n-  // Build a constructor for an empty slice.  SLICE_TYPE_TREE is the\n-  // type of the slice.\n-  static tree\n-  empty_slice_constructor(tree slice_type_tree);\n-\n   // Build a map descriptor.\n   tree\n   map_descriptor(Map_type*);"}, {"sha": "667f3e5909512c6878ba4f48557282a1e6f3a359", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 54, "deletions": 44, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/817b15caf0f81a539af9d74cd47e6bc0727881bb/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/817b15caf0f81a539af9d74cd47e6bc0727881bb/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=817b15caf0f81a539af9d74cd47e6bc0727881bb", "patch": "@@ -4399,6 +4399,41 @@ Array_type::get_length_tree(Gogo* gogo)\n   return this->length_tree_;\n }\n \n+// Get the backend representation of the fields of a slice.  This is\n+// not declared in types.h so that types.h doesn't have to #include\n+// backend.h.\n+//\n+// We use int for the count and capacity fields.  This matches 6g.\n+// The language more or less assumes that we can't allocate space of a\n+// size which does not fit in int.\n+\n+static void\n+get_backend_slice_fields(Gogo* gogo, Array_type* type,\n+\t\t\t std::vector<Backend::Btyped_identifier>* bfields)\n+{\n+  bfields->resize(3);\n+\n+  Type* pet = Type::make_pointer_type(type->element_type());\n+  Btype* pbet = tree_to_type(pet->get_tree(gogo));\n+\n+  Backend::Btyped_identifier* p = &(*bfields)[0];\n+  p->name = \"__values\";\n+  p->btype = pbet;\n+  p->location = UNKNOWN_LOCATION;\n+\n+  Type* int_type = Type::lookup_integer_type(\"int\");\n+\n+  p = &(*bfields)[1];\n+  p->name = \"__count\";\n+  p->btype = tree_to_type(int_type->get_tree(gogo));\n+  p->location = UNKNOWN_LOCATION;\n+\n+  p = &(*bfields)[2];\n+  p->name = \"__capacity\";\n+  p->btype = tree_to_type(int_type->get_tree(gogo));\n+  p->location = UNKNOWN_LOCATION;\n+}\n+\n // Get a tree for the type of this array.  A fixed array is simply\n // represented as ARRAY_TYPE with the appropriate index--i.e., it is\n // just like an array in C.  An open array is a struct with three\n@@ -4409,8 +4444,9 @@ Array_type::do_get_tree(Gogo* gogo)\n {\n   if (this->length_ == NULL)\n     {\n-      tree struct_type = gogo->slice_type_tree(void_type_node);\n-      return this->fill_in_slice_tree(gogo, struct_type);\n+      std::vector<Backend::Btyped_identifier> bfields;\n+      get_backend_slice_fields(gogo, this, &bfields);\n+      return type_to_tree(gogo->backend()->struct_type(bfields));\n     }\n   else\n     {\n@@ -4436,26 +4472,6 @@ Array_type::get_backend_length(Gogo* gogo)\n   return tree_to_expr(this->get_length_tree(gogo));\n }\n \n-// Fill in the fields for a slice type.  This is used for named slice\n-// types.\n-\n-tree\n-Array_type::fill_in_slice_tree(Gogo* gogo, tree struct_type)\n-{\n-  go_assert(this->length_ == NULL);\n-\n-  tree element_type_tree = this->element_type_->get_tree(gogo);\n-  if (element_type_tree == error_mark_node)\n-    return error_mark_node;\n-  tree field = TYPE_FIELDS(struct_type);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n-  go_assert(POINTER_TYPE_P(TREE_TYPE(field))\n-\t     && TREE_TYPE(TREE_TYPE(field)) == void_type_node);\n-  TREE_TYPE(field) = build_pointer_type(element_type_tree);\n-\n-  return struct_type;\n-}\n-\n // Return an initializer for an array type.\n \n tree\n@@ -7168,13 +7184,12 @@ Named_type::create_placeholder(Gogo* gogo)\n \n     case TYPE_ARRAY:\n       if (base->is_open_array_type())\n-\tbt = tree_to_type(gogo->slice_type_tree(void_type_node));\n+\tbt = gogo->backend()->placeholder_struct_type(this->name(),\n+\t\t\t\t\t\t      this->location_);\n       else\n-\t{\n-\t  bt = gogo->backend()->placeholder_array_type(this->name(),\n-\t\t\t\t\t\t       this->location_);\n-\t  set_name = false;\n-\t}\n+\tbt = gogo->backend()->placeholder_array_type(this->name(),\n+\t\t\t\t\t\t     this->location_);\n+      set_name = false;\n       break;\n \n     case TYPE_INTERFACE:\n@@ -7199,6 +7214,16 @@ Named_type::create_placeholder(Gogo* gogo)\n     bt = gogo->backend()->named_type(this->name(), bt, this->location_);\n \n   this->named_btype_ = bt;\n+\n+  if (base->is_open_array_type())\n+    {\n+      // We do not record slices as dependencies of other types,\n+      // because we can fill them in completely here.\n+      std::vector<Backend::Btyped_identifier> bfields;\n+      get_backend_slice_fields(gogo, base->array_type(), &bfields);\n+      if (!gogo->backend()->set_placeholder_struct_type(bt, bfields))\n+\tthis->named_btype_ = gogo->backend()->error_type();\n+    }\n }\n \n // Get a tree for a named type.\n@@ -7255,6 +7280,7 @@ Named_type::do_get_tree(Gogo* gogo)\n     case TYPE_MAP:\n     case TYPE_CHANNEL:\n     case TYPE_STRUCT:\n+    case TYPE_ARRAY:\n     case TYPE_INTERFACE:\n       return type_to_tree(bt);\n \n@@ -7294,22 +7320,6 @@ Named_type::do_get_tree(Gogo* gogo)\n \tbt = gogo->backend()->error_type();\n       return type_to_tree(bt);\n \n-    case TYPE_ARRAY:\n-      if (base->is_open_array_type())\n-\t{\n-\t  if (this->seen_ > 0)\n-\t    return type_to_tree(bt);\n-\t  else\n-\t    {\n-\t      ++this->seen_;\n-\t      tree t = base->array_type()->fill_in_slice_tree(gogo,\n-\t\t\t\t\t\t\t      type_to_tree(bt));\n-\t      bt = tree_to_type(t);\n-\t      --this->seen_;\n-\t    }\n-\t}\n-      return type_to_tree(bt);\n-\n     default:\n     case TYPE_SINK:\n     case TYPE_CALL_MULTIPLE_RESULT:"}, {"sha": "37199de7808f8ecbe4a57b2236d07fc748e69c55", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/817b15caf0f81a539af9d74cd47e6bc0727881bb/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/817b15caf0f81a539af9d74cd47e6bc0727881bb/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=817b15caf0f81a539af9d74cd47e6bc0727881bb", "patch": "@@ -2068,10 +2068,6 @@ class Array_type : public Type\n   Bexpression*\n   get_backend_length(Gogo*);\n \n-  // Fill in the fields for a named slice type.\n-  tree\n-  fill_in_slice_tree(Gogo*, tree);\n-\n   static Type*\n   make_array_type_descriptor_type();\n "}]}