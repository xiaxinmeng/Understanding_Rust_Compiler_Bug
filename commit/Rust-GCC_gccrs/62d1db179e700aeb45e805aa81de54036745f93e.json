{"sha": "62d1db179e700aeb45e805aa81de54036745f93e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJkMWRiMTc5ZTcwMGFlYjQ1ZTgwNWFhODFkZTU0MDM2NzQ1ZjkzZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-06-24T06:48:44Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-06-24T06:48:44Z"}, "message": "Make-lang.in (cp/lex.o): Do not depend on cp/lex.h.\n\n\t* Make-lang.in (cp/lex.o): Do not depend on cp/lex.h.\n\t(cp/decl.o): Likewise.\n\t(cp/decl2.o): Likewise.\n\t(cp/pt.o): Likewise.\n\t(cp/semantics.o): Likewise.\n\t* config-lang.in (gtfiles): Do not reference cp/lex.h.\n\t* class.c: Do not include lex.h.\n\t(add_implicitly_declared_members): Do not use\n\tadding_implicit_members.\n\t(check_bases_and_members): Do not talk about grok_x_components.\n\t* cp/cp-tree.h (adding_implicit_members): Remove.\n\t(cp_storage_class): New type.\n\t(cp_decl_spec): Likewise.\n\t(cp_decl_specifier_seq): Likewise.\n\t(cp_parameter_declarator): Use it for the decl_specifiers field.\n\t(check_tag_decl): Adjust prototype.\n\t(shadow_tag): Likewise.\n\t(groktypename): Likewise.\n\t(start_decl): Likewise.\n\t(start_function): Likewise.\n\t(start_method): Likewise.\n\t(grok_x_components): Remove.\n\t(grokfield): Adjust prototype.\n\t(grokbitfield): Likewise.\n\t(finish_member_class_template): Remove.\n\t* decl.c: Do not include lex.h.\n\t(adding_implicit_members): Do not define.\n\t(check_tag_decl): Do not use trees to represent decl-specifiers.\n\t(shadow_tag): Likewise.\n\t(groktypename): Likewise.\n\t(start_decl): Likewise.\n\t(grokvardecl): Likewise.\n\t(grokdeclarator): Likewise.\n\t(grokparms): Likewise.\n\t(start_function): Likewise.\n\t(start_method): Likewise.\n\t* decl.h (grokdeclarator): Adjust prototype.\n\t* decl2.c: Do not include lex.h.\n\t(grok_x_components): Remove.\n\t(grokfield): Do not use trees to represent decl-specifiers.\n\t(grokbitfield): Likewise.\n\t* lex.c: Do not include lex.h.\n\t* lex.h: Remove.\n\t* parser.c: Include target.h.\n\t(clear_decl_specs): New function.\n\t(cp_parser_translation_unit): Do not use trees to represent\n\tdecl-specifiers.\n\t(cp_parser_postfix_expression): Likewise.\n\t(cp_parser_new_type_id): Likewise.\n\t(cp_parser_condition): Likewise.\n\t(cp_parser_simple_declaration): Likewise.\n\t(cp_parser_decl_specifier_seq): Likewise.\n\t(cp_parser_function_specifier_opt): Likewise.\n\t(cp_parser_conversion_type_id): Likewise.\n\t(cp_parser_template_parameter): Likewise.\n\t(cp_parser_explicit_instantiation): Likewise.\n\t(cp_parser_type_specifier): Likewise.\n\t(cp_parser_simple_type_specifier): Likewise.\n\t(cp_parser_init_declarator): Likewise.\n\t(cp_parser_type_id): Likewise.\n\t(cp_parser_type_specifier_seq): Likewise.\n\t(cp_parser_parameter_declaration): Likewise.\n\t(cp_parser_member_declaration): Likewise.\n\t(cp_parser_exception_declaration): Likewise.\n\t(cp_parser_function_definition_from_specifiers_and_declarator):\n\tLikewise.\n\t(cp_parser_single_declaration): Likewise.\n\t(cp_parser_save_member_function_body): Likewise.\n\t(cp_parser_friend_p): Likewise.\n\t(cp_parser_set_storage_class): New function.\n\t(cp_parser_set_decl_spec_type): Likewise.\n\t* pt.c: Do not include lex.h.\n\t* semantics.c: Likewise.\n\t(finish_member_class_template): Remove.\n\nFrom-SVN: r83584", "tree": {"sha": "efeed5c5b030d6643cfc05fbd9f3969526cbbaa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efeed5c5b030d6643cfc05fbd9f3969526cbbaa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62d1db179e700aeb45e805aa81de54036745f93e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62d1db179e700aeb45e805aa81de54036745f93e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62d1db179e700aeb45e805aa81de54036745f93e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62d1db179e700aeb45e805aa81de54036745f93e/comments", "author": null, "committer": null, "parents": [{"sha": "3a4d587b32145384beb79942f6ba1137a1409656", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a4d587b32145384beb79942f6ba1137a1409656", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a4d587b32145384beb79942f6ba1137a1409656"}], "stats": {"total": 1594, "additions": 768, "deletions": 826}, "files": [{"sha": "5a18b46170500daa6210863df7e4a0b002a30d9e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=62d1db179e700aeb45e805aa81de54036745f93e", "patch": "@@ -1,3 +1,80 @@\n+2004-06-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Make-lang.in (cp/lex.o): Do not depend on cp/lex.h.\n+\t(cp/decl.o): Likewise.\n+\t(cp/decl2.o): Likewise.\n+\t(cp/pt.o): Likewise.\n+\t(cp/semantics.o): Likewise.\n+\t* config-lang.in (gtfiles): Do not reference cp/lex.h.\n+\t* class.c: Do not include lex.h.\n+\t(add_implicitly_declared_members): Do not use\n+\tadding_implicit_members.\n+\t(check_bases_and_members): Do not talk about grok_x_components.\n+\t* cp/cp-tree.h (adding_implicit_members): Remove.\n+\t(cp_storage_class): New type.\n+\t(cp_decl_spec): Likewise.\n+\t(cp_decl_specifier_seq): Likewise.\n+\t(cp_parameter_declarator): Use it for the decl_specifiers field.\n+\t(check_tag_decl): Adjust prototype.\n+\t(shadow_tag): Likewise.\n+\t(groktypename): Likewise.\n+\t(start_decl): Likewise.\n+\t(start_function): Likewise.\n+\t(start_method): Likewise.\n+\t(grok_x_components): Remove.\n+\t(grokfield): Adjust prototype.\n+\t(grokbitfield): Likewise.\n+\t(finish_member_class_template): Remove.\n+\t* decl.c: Do not include lex.h.\n+\t(adding_implicit_members): Do not define.\n+\t(check_tag_decl): Do not use trees to represent decl-specifiers.\n+\t(shadow_tag): Likewise.\n+\t(groktypename): Likewise.\n+\t(start_decl): Likewise.\n+\t(grokvardecl): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t(grokparms): Likewise.\n+\t(start_function): Likewise.\n+\t(start_method): Likewise.\n+\t* decl.h (grokdeclarator): Adjust prototype.\n+\t* decl2.c: Do not include lex.h.\n+\t(grok_x_components): Remove.\n+\t(grokfield): Do not use trees to represent decl-specifiers.\n+\t(grokbitfield): Likewise.\n+\t* lex.c: Do not include lex.h.\n+\t* lex.h: Remove.\n+\t* parser.c: Include target.h.\n+\t(clear_decl_specs): New function.\n+\t(cp_parser_translation_unit): Do not use trees to represent\n+\tdecl-specifiers.\n+\t(cp_parser_postfix_expression): Likewise.\n+\t(cp_parser_new_type_id): Likewise.\n+\t(cp_parser_condition): Likewise.\n+\t(cp_parser_simple_declaration): Likewise.\n+\t(cp_parser_decl_specifier_seq): Likewise.\n+\t(cp_parser_function_specifier_opt): Likewise.\n+\t(cp_parser_conversion_type_id): Likewise.\n+\t(cp_parser_template_parameter): Likewise.\n+\t(cp_parser_explicit_instantiation): Likewise.\n+\t(cp_parser_type_specifier): Likewise.\n+\t(cp_parser_simple_type_specifier): Likewise.\n+\t(cp_parser_init_declarator): Likewise.\n+\t(cp_parser_type_id): Likewise.\n+\t(cp_parser_type_specifier_seq): Likewise.\n+\t(cp_parser_parameter_declaration): Likewise.\n+\t(cp_parser_member_declaration): Likewise.\n+\t(cp_parser_exception_declaration): Likewise.\n+\t(cp_parser_function_definition_from_specifiers_and_declarator):\n+\tLikewise.\n+\t(cp_parser_single_declaration): Likewise.\n+\t(cp_parser_save_member_function_body): Likewise.\n+\t(cp_parser_friend_p): Likewise.\n+\t(cp_parser_set_storage_class): New function.\n+\t(cp_parser_set_decl_spec_type): Likewise.\n+\t* pt.c: Do not include lex.h.\n+\t* semantics.c: Likewise.\n+\t(finish_member_class_template): Remove.\t\n+\t\n 2004-06-23  Roger Sayle  <roger@eyesopen.com>\n \n \t* call.c (build_cxx_call): Don't call expand_tree_builtin.  No"}, {"sha": "997b8aac4a8926a67eb83cf0b0cc69099d57a44a", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=62d1db179e700aeb45e805aa81de54036745f93e", "patch": "@@ -216,15 +216,15 @@ CXX_TREE_H = $(TREE_H) cp/name-lookup.h cp/cp-tree.h c-common.h \\\n \n CXX_PRETTY_PRINT_H = cp/cxx-pretty-print.h $(C_PRETTY_PRINT_H)\n \n-cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h \\\n+cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) flags.h \\\n   c-pragma.h toplev.h output.h input.h cp/operators.def $(TM_P_H)\n cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) toplev.h langhooks.h \\\n   $(LANGHOOKS_DEF_H) c-common.h $(CXX_PRETTY_PRINT_H) $(DIAGNOSTIC_H)\n-cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h cp/decl.h stack.h \\\n+cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) flags.h cp/decl.h stack.h \\\n   output.h $(EXPR_H) except.h toplev.h $(HASHTAB_H) $(RTL_H) \\\n   cp/operators.def $(TM_P_H) tree-inline.h diagnostic.h c-pragma.h \\\n   debug.h gt-cp-decl.h gtype-cp.h timevar.h $(TREE_FLOW_H)\n-cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h cp/decl.h $(EXPR_H) \\\n+cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) flags.h cp/decl.h $(EXPR_H) \\\n   output.h except.h toplev.h $(RTL_H) c-common.h gt-cp-decl2.h cgraph.h\n cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h output.h $(TM_P_H) \\\n    diagnostic.h\n@@ -248,13 +248,13 @@ cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) except.h toplev.\n   cp/cfns.h $(EXPR_H) libfuncs.h tree-inline.h\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(RTL_H) flags.h $(EXPR_H) toplev.h \\\n   except.h $(TM_P_H)\n-cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h cp/lex.h \\\n+cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h \\\n   toplev.h $(RTL_H) except.h tree-inline.h gt-cp-pt.h\n cp/error.o: cp/error.c $(CXX_TREE_H) $(TM_H) toplev.h $(DIAGNOSTIC_H) \\\n   flags.h real.h $(LANGHOOKS_DEF_H) $(CXX_PRETTY_PRINT_H)\n cp/repo.o: cp/repo.c $(CXX_TREE_H) $(TM_H) toplev.h diagnostic.h \\\n   gt-cp-repo.h\n-cp/semantics.o: cp/semantics.c $(CXX_TREE_H) $(TM_H) cp/lex.h except.h toplev.h \\\n+cp/semantics.o: cp/semantics.c $(CXX_TREE_H) $(TM_H) except.h toplev.h \\\n   flags.h debug.h output.h $(RTL_H) $(TIMEVAR_H) $(EXPR_H) \\\n   tree-inline.h cgraph.h\n cp/dump.o: cp/dump.c $(CXX_TREE_H) $(TM_H) tree-dump.h"}, {"sha": "c2d654123f5fd33f9debc8b2d8f51bafc4841716", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=62d1db179e700aeb45e805aa81de54036745f93e", "patch": "@@ -33,7 +33,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n-#include \"lex.h\"\n #include \"target.h\"\n #include \"convert.h\"\n \n@@ -2624,8 +2623,6 @@ add_implicitly_declared_members (tree t,\n   tree virtual_dtor = NULL_TREE;\n   tree *f;\n \n-  ++adding_implicit_members;\n-\n   /* Destructor.  */\n   if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) && !TYPE_HAS_DESTRUCTOR (t))\n     {\n@@ -2700,8 +2697,6 @@ add_implicitly_declared_members (tree t,\n       *f = TYPE_METHODS (t);\n       TYPE_METHODS (t) = implicit_fns;\n     }\n-\n-  --adding_implicit_members;\n }\n \n /* Subroutine of finish_struct_1.  Recursively count the number of fields\n@@ -4206,8 +4201,7 @@ check_bases_and_members (tree t)\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n     |= TYPE_HAS_ASSIGN_REF (t) || TYPE_CONTAINS_VPTR_P (t);\n \n-  /* Synthesize any needed methods.  Note that methods will be synthesized\n-     for anonymous unions; grok_x_components undoes that.  */\n+  /* Synthesize any needed methods.   */\n   add_implicitly_declared_members (t, cant_have_default_ctor,\n \t\t\t\t   cant_have_const_ctor,\n \t\t\t\t   no_const_asn_ref);"}, {"sha": "0d0c38f0f4290b41efe9ca6a907760e84357ae2a", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=62d1db179e700aeb45e805aa81de54036745f93e", "patch": "@@ -34,4 +34,4 @@ stagestuff=\"g++\\$(exeext) g++-cross\\$(exeext) cc1plus\\$(exeext)\"\n \n target_libs=\"target-libstdc++-v3 target-gperf\"\n \n-gtfiles=\"\\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/lex.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-lex.c \\$(srcdir)/c-pragma.c\"\n+gtfiles=\"\\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-lex.c \\$(srcdir)/c-pragma.c\""}, {"sha": "ecd9b18380282cd187444fb1c00160a10b273013", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 77, "deletions": 16, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=62d1db179e700aeb45e805aa81de54036745f93e", "patch": "@@ -3082,11 +3082,6 @@ typedef enum base_kind {\n \t\t\t     binfo.  */\n } base_kind;\n \n-/* Set by add_implicitly_declared_members() to keep those members from\n-   being flagged as deprecated or reported as using deprecated\n-   types.  */\n-extern int adding_implicit_members;\n-\n /* in decl{2}.c */\n /* A node that is a list (length 1) of error_mark_nodes.  */\n extern GTY(()) tree error_mark_list;\n@@ -3508,6 +3503,74 @@ extern GTY(()) operator_name_info_t operator_name_info\n extern GTY(()) operator_name_info_t assignment_operator_name_info\n   [(int) LAST_CPLUS_TREE_CODE];\n \n+/* A storage class.  */\n+\n+typedef enum cp_storage_class {\n+  /* sc_none must be zero so that zeroing a cp_decl_specifier_seq\n+     sets the storage_class field to sc_none.  */\n+  sc_none = 0,\n+  sc_auto,\n+  sc_register,\n+  sc_static,\n+  sc_extern,\n+  sc_mutable,\n+} cp_storage_class;\n+\n+/* An individual decl-specifier.  */\n+\n+typedef enum cp_decl_spec {\n+  ds_first,\n+  ds_signed = ds_first,\n+  ds_unsigned,\n+  ds_short,\n+  ds_long,\n+  ds_const,\n+  ds_volatile,\n+  ds_restrict,\n+  ds_inline,\n+  ds_virtual,\n+  ds_explicit,\n+  ds_friend,\n+  ds_typedef,\n+  ds_complex,\n+  ds_thread,\n+  ds_last\n+} cp_decl_spec;\n+\n+/* A decl-specifier-seq.  */\n+\n+typedef struct cp_decl_specifier_seq {\n+  /* The number of times each of the keywords has been seen.  */\n+  unsigned specs[(int) ds_last];\n+  /* The primary type, if any, given by the decl-specifier-seq.\n+     Modifiers, like \"short\", \"const\", and \"unsigned\" are not\n+     reflected here.  This field will be a TYPE, unless a typedef-name\n+     was used, in which case it will be a TYPE_DECL.  */\n+  tree type;\n+  /* The attributes, if any, provided with the specifier sequence.  */\n+  tree attributes;\n+  /* If non-NULL, a built-in type that the user attempted to redefine\n+     to some other type.  */\n+  tree redefined_builtin_type;\n+  /* The storage class specified -- or sc_none if no storage class was\n+     explicitly specified.  */\n+  cp_storage_class storage_class;\n+  /* True iff TYPE_SPEC indicates a user-defined type.  */\n+  BOOL_BITFIELD user_defined_type_p : 1;\n+  /* True iff multiple types were (erroneously) specified for this\n+     decl-specifier-seq.  */\n+  BOOL_BITFIELD multiple_types_p : 1;\n+  /* True iff multiple storage classes were (erroneously) specified\n+     for this decl-specifier-seq.  */\n+  BOOL_BITFIELD multiple_storage_classes_p : 1;\n+  /* True iff at least one decl-specifier was found.  */\n+  BOOL_BITFIELD any_specifiers_p : 1;\n+  /* True iff \"int\" was explicitly provided.  */\n+  BOOL_BITFIELD explicit_int_p : 1;\n+  /* True iff \"char\" was explicitly provided.  */\n+  BOOL_BITFIELD explicit_char_p : 1;\n+} cp_decl_specifier_seq;\n+\n /* The various kinds of declarators.  */\n \n typedef enum cp_declarator_kind {\n@@ -3531,7 +3594,7 @@ struct cp_parameter_declarator {\n   /* The next parameter, or NULL_TREE if none.  */\n   cp_parameter_declarator *next;\n   /* The decl-specifiers-seq for the parameter.  */\n-  tree decl_specifiers;\n+  cp_decl_specifier_seq decl_specifiers;\n   /* The declarator for the parameter.  */\n   cp_declarator *declarator;\n   /* The default-argument expression, or NULL_TREE, if none.  */\n@@ -3735,10 +3798,10 @@ extern tree push_library_fn\t\t\t(tree, tree);\n extern tree push_void_library_fn\t\t(tree, tree);\n extern tree push_throw_library_fn\t\t(tree, tree);\n extern int init_type_desc\t\t\t(void);\n-extern tree check_tag_decl\t\t\t(tree);\n-extern tree shadow_tag\t\t\t\t(tree);\n-extern tree groktypename\t\t\t(tree, const cp_declarator *);\n-extern tree start_decl\t\t\t\t(const cp_declarator *, tree, int, tree, tree);\n+extern tree check_tag_decl\t\t\t(cp_decl_specifier_seq *);\n+extern tree shadow_tag\t\t\t\t(cp_decl_specifier_seq *);\n+extern tree groktypename\t\t\t(cp_decl_specifier_seq *, const cp_declarator *);\n+extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int, tree, tree);\n extern void start_decl_1\t\t\t(tree);\n extern void cp_finish_decl\t\t\t(tree, tree, tree, int);\n extern void finish_decl\t\t\t\t(tree, tree, tree);\n@@ -3759,11 +3822,11 @@ extern tree start_enum\t\t\t\t(tree);\n extern void finish_enum\t\t\t\t(tree);\n extern void build_enumerator\t\t\t(tree, tree, tree);\n extern void start_preparsed_function            (tree, tree, int);\n-extern int start_function\t\t\t(tree, const cp_declarator *, tree);\n+extern int start_function\t\t\t(cp_decl_specifier_seq *, const cp_declarator *, tree);\n extern tree begin_function_body\t\t\t(void);\n extern void finish_function_body\t\t(tree);\n extern tree finish_function\t\t\t(int);\n-extern tree start_method\t\t\t(tree, const cp_declarator *, tree);\n+extern tree start_method\t\t\t(cp_decl_specifier_seq *, const cp_declarator *, tree);\n extern tree finish_method\t\t\t(tree);\n extern void maybe_register_incomplete_var       (tree);\n extern void complete_vars\t\t\t(tree);\n@@ -3804,16 +3867,15 @@ extern bool have_extern_spec;\n /* in decl2.c */\n extern bool check_java_method (tree);\n extern int grok_method_quals (tree, tree, tree);\n-extern void grok_x_components (tree);\n extern void maybe_retrofit_in_chrg (tree);\n extern void maybe_make_one_only\t(tree);\n extern void grokclassfn\t(tree, tree, enum overload_flags, tree);\n extern tree grok_array_decl (tree, tree);\n extern tree delete_sanity (tree, tree, bool, int);\n extern tree check_classfn (tree, tree, tree);\n extern void check_member_template (tree);\n-extern tree grokfield (const cp_declarator *, tree, tree, tree, tree);\n-extern tree grokbitfield (const cp_declarator *, tree, tree);\n+extern tree grokfield (const cp_declarator *, cp_decl_specifier_seq *, tree, tree, tree);\n+extern tree grokbitfield (const cp_declarator *, cp_decl_specifier_seq *, tree);\n extern tree groktypefield\t\t\t(tree, tree);\n extern void cplus_decl_attributes (tree *, tree, int);\n extern void finish_anon_union (tree);\n@@ -4157,7 +4219,6 @@ extern tree finish_template_type_parm           (tree, tree);\n extern tree finish_template_template_parm       (tree, tree);\n extern tree begin_class_definition              (tree);\n extern void finish_default_args                 (void);\n-extern tree finish_member_class_template        (tree);\n extern void finish_template_decl                (tree);\n extern tree finish_template_type                (tree, tree, int);\n extern tree finish_base_specifier               (tree, tree, bool);"}, {"sha": "e986cb7aa7c9b82e1c48471a39e5e67e93ea3b8c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 225, "deletions": 393, "changes": 618, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=62d1db179e700aeb45e805aa81de54036745f93e", "patch": "@@ -39,7 +39,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"cp-tree.h\"\n #include \"tree-inline.h\"\n #include \"decl.h\"\n-#include \"lex.h\"\n #include \"output.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n@@ -53,7 +52,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"timevar.h\"\n #include \"tree-flow.h\"\n \n-static tree grokparms (const cp_parameter_declarator *, tree *);\n+static tree grokparms (cp_parameter_declarator *, tree *);\n static const char *redeclaration_error_message (tree, tree);\n \n static int decl_jump_unsafe (tree);\n@@ -65,7 +64,7 @@ static tree grok_reference_init (tree, tree, tree, tree *);\n static tree grokfndecl (tree, tree, tree, tree, tree, int,\n \t\t\tenum overload_flags, tree,\n \t\t\ttree, int, int, int, int, int, int, tree);\n-static tree grokvardecl (tree, tree, RID_BIT_TYPE *, int, int, tree);\n+static tree grokvardecl (tree, tree, cp_decl_specifier_seq *, int, int, tree);\n static void record_unknown_type (tree, const char *);\n static tree builtin_function_1 (const char *, tree, tree, int,\n                                 enum built_in_class, const char *,\n@@ -242,11 +241,6 @@ enum deprecated_states {\n \n static enum deprecated_states deprecated_state = DEPRECATED_NORMAL;\n \n-/* Set by add_implicitly_declared_members() to keep those members from\n-   being flagged as deprecated or reported as using deprecated\n-   types.  */\n-int adding_implicit_members = 0;\n-\n /* True if a declaration with an `extern' linkage specifier is being\n    processed.  */\n bool have_extern_spec;\n@@ -3410,73 +3404,34 @@ fixup_anonymous_aggr (tree t)\n    Returns the type declared; or NULL_TREE if none.  */\n \n tree\n-check_tag_decl (tree declspecs)\n+check_tag_decl (cp_decl_specifier_seq *declspecs)\n {\n-  int found_type = 0;\n-  int saw_friend = 0;\n-  int saw_typedef = 0;\n-  tree ob_modifier = NULL_TREE;\n-  tree link;\n+  int saw_friend = declspecs->specs[(int)ds_friend] != 0;\n+  int saw_typedef = declspecs->specs[(int)ds_typedef] != 0;\n   /* If a class, struct, or enum type is declared by the DECLSPECS\n      (i.e, if a class-specifier, enum-specifier, or non-typename\n      elaborated-type-specifier appears in the DECLSPECS),\n      DECLARED_TYPE is set to the corresponding type.  */\n   tree declared_type = NULL_TREE;\n   bool error_p = false;\n \n-  for (link = declspecs; link; link = TREE_CHAIN (link))\n-    {\n-      tree value = TREE_VALUE (link);\n-\n-      if (TYPE_P (value) || TREE_CODE (value) == TYPE_DECL\n-\t  || (TREE_CODE (value) == IDENTIFIER_NODE\n-\t      && is_typename_at_global_scope (value)))\n-\t{\n-\t  ++found_type;\n-\n-\t  if (found_type == 2 && TREE_CODE (value) == IDENTIFIER_NODE)\n-\t    {\n-\t      if (! in_system_header)\n-\t\tpedwarn (\"redeclaration of C++ built-in type `%T'\", value);\n-\t      return NULL_TREE;\n-\t    }\n-\n-\t  if (TYPE_P (value)\n-\t      && ((TREE_CODE (value) != TYPENAME_TYPE && IS_AGGR_TYPE (value))\n-\t\t  || TREE_CODE (value) == ENUMERAL_TYPE))\n-\t    {\n-\t      my_friendly_assert (TYPE_MAIN_DECL (value) != NULL_TREE, 261);\n-\t      declared_type = value;\n-\t    }\n-\t}\n-      else if (value == ridpointers[(int) RID_TYPEDEF])\n-        saw_typedef = 1;\n-      else if (value == ridpointers[(int) RID_FRIEND])\n-\t{\n-\t  if (current_class_type == NULL_TREE\n-\t      || current_scope () != current_class_type)\n-\t    ob_modifier = value;\n-\t  else\n-\t    saw_friend = 1;\n-\t}\n-      else if (value == ridpointers[(int) RID_STATIC]\n-\t       || value == ridpointers[(int) RID_EXTERN]\n-\t       || value == ridpointers[(int) RID_AUTO]\n-\t       || value == ridpointers[(int) RID_REGISTER]\n-\t       || value == ridpointers[(int) RID_INLINE]\n-\t       || value == ridpointers[(int) RID_VIRTUAL]\n-\t       || value == ridpointers[(int) RID_CONST]\n-\t       || value == ridpointers[(int) RID_VOLATILE]\n-\t       || value == ridpointers[(int) RID_EXPLICIT]\n-\t       || value == ridpointers[(int) RID_THREAD])\n-\tob_modifier = value;\n-      else if (value == error_mark_node)\n-\terror_p = true;\n-    }\n-\n-  if (found_type > 1)\n+  if (declspecs->multiple_types_p)\n     error (\"multiple types in one declaration\");\n+  else if (declspecs->redefined_builtin_type)\n+    {\n+      if (!in_system_header)\n+\tpedwarn (\"redeclaration of C++ built-in type\",\n+\t\t declspecs->redefined_builtin_type);\n+      return NULL_TREE;\n+    }\n \n+  if (TYPE_P (declspecs->type)\n+      && ((TREE_CODE (declspecs->type) != TYPENAME_TYPE \n+\t   && IS_AGGR_TYPE (declspecs->type))\n+\t  || TREE_CODE (declspecs->type) == ENUMERAL_TYPE))\n+    declared_type = declspecs->type;\n+  else if (declspecs->type == error_mark_node)\n+    error_p = true;\n   if (declared_type == NULL_TREE && ! saw_friend && !error_p)\n     pedwarn (\"declaration does not declare anything\");\n   /* Check for an anonymous union.  */\n@@ -3512,19 +3467,28 @@ check_tag_decl (tree declspecs)\n \tpedwarn (\"ISO C++ prohibits anonymous structs\");\n     }\n \n-  else if (ob_modifier)\n+  else\n     {\n-      if (ob_modifier == ridpointers[(int) RID_INLINE]\n-\t  || ob_modifier == ridpointers[(int) RID_VIRTUAL])\n-\terror (\"`%D' can only be specified for functions\", ob_modifier);\n-      else if (ob_modifier == ridpointers[(int) RID_FRIEND])\n-\terror (\"`%D' can only be specified inside a class\", ob_modifier);\n-      else if (ob_modifier == ridpointers[(int) RID_EXPLICIT])\n-\terror (\"`%D' can only be specified for constructors\",\n-\t\t  ob_modifier);\n-      else\n-\terror (\"`%D' can only be specified for objects and functions\",\n-\t\t  ob_modifier);\n+      if (declspecs->specs[(int)ds_inline]\n+\t  || declspecs->specs[(int)ds_virtual])\n+\terror (\"`%s' can only be specified for functions\", \n+\t       declspecs->specs[(int)ds_inline] \n+\t       ? \"inline\" : \"virtual\");\n+      else if (saw_friend\n+\t       && (!current_class_type \n+\t\t   || current_scope () != current_class_type))\n+\terror (\"`friend' can only be specified inside a class\");\n+      else if (declspecs->specs[(int)ds_explicit])\n+\terror (\"`explicit' can only be specified for constructors\");\n+      else if (declspecs->storage_class)\n+\terror (\"a storage class can only be specified for objects \"\n+\t       \"and functions\");\n+      else if (declspecs->specs[(int)ds_const]\n+\t       || declspecs->specs[(int)ds_volatile]\n+\t       || declspecs->specs[(int)ds_restrict]\n+\t       || declspecs->specs[(int)ds_thread])\n+\terror (\"qualifiers can only be specified for objects \"\n+\t       \"and functions\");\n     }\n \n   return declared_type;\n@@ -3544,7 +3508,7 @@ check_tag_decl (tree declspecs)\n    Returns the TYPE declared -- or NULL_TREE if none.  */\n \n tree\n-shadow_tag (tree declspecs)\n+shadow_tag (cp_decl_specifier_seq *declspecs)\n {\n   tree t = check_tag_decl (declspecs);\n \n@@ -3576,12 +3540,14 @@ shadow_tag (tree declspecs)\n /* Decode a \"typename\", such as \"int **\", returning a ..._TYPE node.  */\n \n tree\n-groktypename (tree type_specifiers, const cp_declarator *declarator)\n+groktypename (cp_decl_specifier_seq *type_specifiers, \n+\t      const cp_declarator *declarator)\n {\n-  tree specs, attrs;\n+  tree attrs;\n   tree type;\n-  split_specs_attrs (type_specifiers, &specs, &attrs);\n-  type = grokdeclarator (declarator, specs, TYPENAME, 0, &attrs);\n+  attrs = type_specifiers->attributes;\n+  type_specifiers->attributes = NULL_TREE;\n+  type = grokdeclarator (declarator, type_specifiers, TYPENAME, 0, &attrs);\n   if (attrs)\n     cplus_decl_attributes (&type, attrs, 0);\n   return type;\n@@ -3604,7 +3570,7 @@ groktypename (tree type_specifiers, const cp_declarator *declarator)\n \n tree\n start_decl (const cp_declarator *declarator, \n-            tree declspecs, \n+\t    cp_decl_specifier_seq *declspecs,\n             int initialized, \n             tree attributes, \n             tree prefix_attributes)\n@@ -3616,8 +3582,7 @@ start_decl (const cp_declarator *declarator,\n   /* This should only be done once on the top most decl.  */\n   if (have_extern_spec)\n     {\n-      declspecs = tree_cons (NULL_TREE, get_identifier (\"extern\"),\n-\t\t\t     declspecs);\n+      declspecs->storage_class = sc_extern;\n       have_extern_spec = false;\n     }\n \n@@ -5758,25 +5723,22 @@ grokfndecl (tree ctype,\n static tree\n grokvardecl (tree type,\n              tree name,\n-             RID_BIT_TYPE * specbits_in,\n+\t     cp_decl_specifier_seq *declspecs,\n              int initialized,\n              int constp,\n              tree scope)\n {\n   tree decl;\n-  RID_BIT_TYPE specbits;\n \n   my_friendly_assert (!name || TREE_CODE (name) == IDENTIFIER_NODE, \n \t\t      20020808);\n \n-  specbits = *specbits_in;\n-\n   /* Compute the scope in which to place the variable.  */\n   if (!scope)\n     {\n       /* An explicit \"extern\" specifier indicates a namespace-scope\n \t variable.  */\n-      if (RIDBIT_SETP (RID_EXTERN, specbits))\n+      if (declspecs->storage_class == sc_extern)\n \tscope = current_namespace;\n       else if (!at_function_scope_p ())\n \t{\n@@ -5805,7 +5767,7 @@ grokvardecl (tree type,\n   else\n     DECL_CONTEXT (decl) = scope;\n \n-  if (RIDBIT_SETP (RID_EXTERN, specbits))\n+  if (declspecs->storage_class == sc_extern)\n     {\n       DECL_THIS_EXTERN (decl) = 1;\n       DECL_EXTERNAL (decl) = !initialized;\n@@ -5823,18 +5785,18 @@ grokvardecl (tree type,\n      (perhaps tentative), and absence of `static' makes it public.  */\n   else if (toplevel_bindings_p ())\n     {\n-      TREE_PUBLIC (decl) = (RIDBIT_NOTSETP (RID_STATIC, specbits)\n+      TREE_PUBLIC (decl) = (declspecs->storage_class != sc_static\n \t\t\t    && (DECL_THIS_EXTERN (decl) || ! constp));\n       TREE_STATIC (decl) = ! DECL_EXTERNAL (decl);\n     }\n   /* Not at top level, only `static' makes a static definition.  */\n   else\n     {\n-      TREE_STATIC (decl) = !! RIDBIT_SETP (RID_STATIC, specbits);\n+      TREE_STATIC (decl) = declspecs->storage_class == sc_static;\n       TREE_PUBLIC (decl) = DECL_EXTERNAL (decl);\n     }\n \n-  if (RIDBIT_SETP (RID_THREAD, specbits))\n+  if (declspecs->specs[(int)ds_thread])\n     {\n       if (targetm.have_tls)\n \tDECL_THREAD_LOCAL (decl) = 1;\n@@ -6292,22 +6254,18 @@ check_special_function_return_type (special_function_kind sfk,\n \n tree\n grokdeclarator (const cp_declarator *declarator,\n-                tree declspecs,\n+\t\tcp_decl_specifier_seq *declspecs,\n                 enum decl_context decl_context,\n                 int initialized,\n                 tree* attrlist)\n {\n-  RID_BIT_TYPE specbits;\n-  int nclasses = 0;\n-  tree spec;\n   tree type = NULL_TREE;\n   int longlong = 0;\n   int type_quals;\n   int virtualp, explicitp, friendp, inlinep, staticp;\n   int explicit_int = 0;\n   int explicit_char = 0;\n   int defaulted_int = 0;\n-  int extern_langp = 0;\n   tree dependant_name = NULL_TREE;\n   \n   tree typedef_decl = NULL_TREE;\n@@ -6348,8 +6306,8 @@ grokdeclarator (const cp_declarator *declarator,\n      this value will be NULL_TREE, even if the entity is located at\n      namespace scope.  */ \n   tree in_namespace = NULL_TREE;\n+  cp_decl_spec ds;\n \n-  RIDBIT_RESET_ALL (specbits);\n   if (decl_context == FUNCDEF)\n     funcdef_flag = 1, decl_context = NORMAL;\n   else if (decl_context == MEMFUNCDEF)\n@@ -6503,7 +6461,7 @@ grokdeclarator (const cp_declarator *declarator,\n \n   if (((dname && IDENTIFIER_OPNAME_P (dname)) || flags == TYPENAME_FLAG)\n       && innermost_code != cdk_function\n-      && ! (ctype && declspecs == NULL_TREE))\n+      && ! (ctype && !declspecs->any_specifiers_p))\n     {\n       error (\"declaration of `%D' as non-function\", dname);\n       return void_type_node;\n@@ -6535,143 +6493,59 @@ grokdeclarator (const cp_declarator *declarator,\n   if (name == NULL)\n     name = decl_context == PARM ? \"parameter\" : \"type name\";\n \n-  /* Look through the decl specs and record which ones appear.\n-     Some typespecs are defined as built-in typenames.\n-     Others, the ones that are modifiers of other types,\n-     are represented by bits in SPECBITS: set the bits for\n-     the modifiers that appear.  Storage class keywords are also in SPECBITS.\n-\n-     If there is a typedef name or a type, store the type in TYPE.\n-     This includes builtin typedefs such as `int'.\n-\n-     Set EXPLICIT_INT if the type is `int' or `char' and did not\n-     come from a user typedef.\n-\n-     Set LONGLONG if `long' is mentioned twice.\n-\n-     For C++, constructors and destructors have their own fast treatment.  */\n-\n-  for (spec = declspecs; spec; spec = TREE_CHAIN (spec))\n+  /* If there were multiple types specified in the decl-specifier-seq,\n+     issue an error message.  */\n+  if (declspecs->multiple_types_p)\n+    error (\"two or more data types in declaration of `%s'\", name);\n+  /* Extract the basic type from the decl-specifier-seq.  */\n+  type = declspecs->type;\n+  if (type == error_mark_node)\n+    type = NULL_TREE;\n+  /* If the entire declaration is itself tagged as deprecated then\n+     suppress reports of deprecated items.  */\n+  if (type && TREE_DEPRECATED (type)\n+      && deprecated_state != DEPRECATED_SUPPRESS)\n+    warn_deprecated_use (type);\n+  if (type && TREE_CODE (type) == TYPE_DECL)\n     {\n-      int i;\n-      tree id;\n-\n-      /* Certain parse errors slip through.  For example,\n-\t `int class;' is not caught by the parser. Try\n-\t weakly to recover here.  */\n-      if (TREE_CODE (spec) != TREE_LIST)\n-\treturn 0;\n-\n-      id = TREE_VALUE (spec);\n-\n-      /* If the entire declaration is itself tagged as deprecated then\n-         suppress reports of deprecated items.  */\n-      if (!adding_implicit_members && id && TREE_DEPRECATED (id))\n-        {\n-\t  if (deprecated_state != DEPRECATED_SUPPRESS)\n-\t    warn_deprecated_use (id);\n-        }\n-\n-      if (TREE_CODE (id) == IDENTIFIER_NODE)\n-\t{\n-\t  if (id == ridpointers[(int) RID_INT]\n-\t      || id == ridpointers[(int) RID_CHAR]\n-\t      || id == ridpointers[(int) RID_BOOL]\n-\t      || id == ridpointers[(int) RID_WCHAR])\n-\t    {\n-\t      if (type)\n-\t\t{\n-\t\t  if (id == ridpointers[(int) RID_BOOL])\n-\t\t    error (\"`bool' is now a keyword\");\n-\t\t  else\n-\t\t    error (\"extraneous `%T' ignored\", id);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (id == ridpointers[(int) RID_INT])\n-\t\t    explicit_int = 1;\n-\t\t  else if (id == ridpointers[(int) RID_CHAR])\n-\t\t    explicit_char = 1;\n-\t\t  type = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (id));\n-\t\t}\n-\t      goto found;\n-\t    }\n-\t  /* C++ aggregate types.  */\n-\t  if (IDENTIFIER_HAS_TYPE_VALUE (id))\n-\t    {\n-\t      if (type)\n-\t\terror (\"multiple declarations `%T' and `%T'\", type, id);\n-\t      else\n-\t\ttype = IDENTIFIER_TYPE_VALUE (id);\n-\t      goto found;\n-\t    }\n-\n-\t  for (i = (int) RID_FIRST_MODIFIER; i <= (int) RID_LAST_MODIFIER; i++)\n-\t    {\n-\t      if (ridpointers[i] == id)\n-\t\t{\n-\t\t  if (i == (int) RID_LONG && RIDBIT_SETP (i, specbits))\n-\t\t    {\n-\t\t      if (pedantic && ! in_system_header && warn_long_long)\n-\t\t\tpedwarn (\"ISO C++ does not support `long long'\");\n-\t\t      if (longlong)\n-\t\t\terror (\"`long long long' is too long for GCC\");\n-\t\t      else\n-\t\t\tlonglong = 1;\n-\t\t    }\n-\t\t  else if (RIDBIT_SETP (i, specbits))\n-\t\t    pedwarn (\"duplicate `%E'\", id);\n-\n-\t\t  /* Diagnose \"__thread extern\" or \"__thread static\".  */\n-\t\t  if (RIDBIT_SETP (RID_THREAD, specbits))\n-\t\t    {\n-\t\t      if (i == (int)RID_EXTERN)\n-\t\t\terror (\"`__thread' before `extern'\");\n-\t\t      else if (i == (int)RID_STATIC)\n-\t\t\terror (\"`__thread' before `static'\");\n-\t\t    }\n-\n-\t\t  if (i == (int)RID_EXTERN\n-\t\t      && TREE_PURPOSE (spec) == error_mark_node)\n-\t\t    /* This extern was part of a language linkage.  */\n-\t\t    extern_langp = 1;\n+      typedef_decl = type;\n+      type = TREE_TYPE (typedef_decl);\n+    }\n+  /* No type at all: default to `int', and set DEFAULTED_INT\n+     because it was not a user-defined typedef.  */\n+  if (type == NULL_TREE\n+      && (declspecs->specs[(int)ds_signed]\n+\t  || declspecs->specs[(int)ds_unsigned]\n+\t  || declspecs->specs[(int)ds_long]\n+\t  || declspecs->specs[(int)ds_short]))\n+    {\n+      /* These imply 'int'.  */\n+      type = integer_type_node;\n+      defaulted_int = 1;\n+    }\n+  /* Gather flags.  */\n+  explicit_int = declspecs->explicit_int_p;\n+  explicit_char = declspecs->explicit_char_p;\n \n-\t\t  RIDBIT_SET (i, specbits);\n-\t\t  goto found;\n-\t\t}\n-\t    }\n-\t}\n-      else if (TREE_CODE (id) == TYPE_DECL)\n-\t{\n-\t  if (type)\n-\t    error (\"multiple declarations `%T' and `%T'\", type,\n-\t\t      TREE_TYPE (id));\n-\t  else\n-\t    {\n-\t      type = TREE_TYPE (id);\n-\t      TREE_VALUE (spec) = type;\n-\t      typedef_decl = id;\n-\t    }\n-\t  goto found;\n-\t}\n-      if (type)\n-\terror (\"two or more data types in declaration of `%s'\", name);\n-      else if (TREE_CODE (id) == IDENTIFIER_NODE)\n+  /* Check for repeated decl-specifiers.  */\n+  for (ds = ds_first; ds != ds_last; ++ds) \n+    {\n+      unsigned count = declspecs->specs[(int)ds];\n+      if (count < 2)\n+\tcontinue;\n+      /* The \"long\" specifier is a special case because of \n+\t \"long long\".  */\n+      if (ds == ds_long)\n \t{\n-\t  tree t = lookup_name (id, 1);\n-\t  if (!t || TREE_CODE (t) != TYPE_DECL)\n-\t    error (\"`%E' fails to be a typedef or built in type\", id);\n+\t  if (count > 2)\n+\t    error (\"`long long long' is too long for GCC\");\n+\t  else if (pedantic && !in_system_header && warn_long_long)\n+\t    pedwarn (\"ISO C++ does not support `long long'\");\n \t  else\n-\t    {\n-\t      type = TREE_TYPE (t);\n-\t      typedef_decl = t;\n-\t    }\n-\t}\n-      else if (id != error_mark_node)\n-\t/* Can't change CLASS nodes into RECORD nodes here!  */\n-\ttype = id;\n-\n-    found: ;\n+\t    longlong = 1;\n+\t} \n+      else if (declspecs->specs[(int)ds] > 1)\n+\terror (\"duplicate decl-specifier\");\n     }\n \n #if 0\n@@ -6681,19 +6555,6 @@ grokdeclarator (const cp_declarator *declarator,\n #endif\n   typedef_type = type;\n \n-  /* No type at all: default to `int', and set DEFAULTED_INT\n-     because it was not a user-defined typedef.  */\n-\n-  if (type == NULL_TREE\n-      && (RIDBIT_SETP (RID_SIGNED, specbits)\n-\t  || RIDBIT_SETP (RID_UNSIGNED, specbits)\n-\t  || RIDBIT_SETP (RID_LONG, specbits)\n-\t  || RIDBIT_SETP (RID_SHORT, specbits)))\n-    {\n-      /* These imply 'int'.  */\n-      type = integer_type_node;\n-      defaulted_int = 1;\n-    }\n \n   if (sfk != sfk_none)\n     type = check_special_function_return_type (sfk, type,\n@@ -6731,41 +6592,40 @@ grokdeclarator (const cp_declarator *declarator,\n      and check for invalid combinations.  */\n \n   /* Long double is a special combination.  */\n-\n-  if (RIDBIT_SETP (RID_LONG, specbits)\n+  if (declspecs->specs[(int)ds_long]\n       && TYPE_MAIN_VARIANT (type) == double_type_node)\n     {\n-      RIDBIT_RESET (RID_LONG, specbits);\n+      declspecs->specs[(int)ds_long] = 0;\n       type = build_qualified_type (long_double_type_node,\n \t\t\t\t   cp_type_quals (type));\n     }\n \n   /* Check all other uses of type modifiers.  */\n \n-  if (RIDBIT_SETP (RID_UNSIGNED, specbits)\n-      || RIDBIT_SETP (RID_SIGNED, specbits)\n-      || RIDBIT_SETP (RID_LONG, specbits)\n-      || RIDBIT_SETP (RID_SHORT, specbits))\n+  if (declspecs->specs[(int)ds_unsigned]\n+      || declspecs->specs[(int)ds_signed]\n+      || declspecs->specs[(int)ds_long]\n+      || declspecs->specs[(int)ds_short])\n     {\n       int ok = 0;\n \n       if (TREE_CODE (type) == REAL_TYPE)\n \terror (\"short, signed or unsigned invalid for `%s'\", name);\n       else if (TREE_CODE (type) != INTEGER_TYPE)\n \terror (\"long, short, signed or unsigned invalid for `%s'\", name);\n-      else if (RIDBIT_SETP (RID_LONG, specbits)\n-\t       && RIDBIT_SETP (RID_SHORT, specbits))\n+      else if (declspecs->specs[(int)ds_long]\n+\t       && declspecs->specs[(int)ds_short])\n \terror (\"long and short specified together for `%s'\", name);\n-      else if ((RIDBIT_SETP (RID_LONG, specbits)\n-\t\t|| RIDBIT_SETP (RID_SHORT, specbits))\n+      else if ((declspecs->specs[(int)ds_long]\n+\t\t|| declspecs->specs[(int)ds_short])\n \t       && explicit_char)\n \terror (\"long or short specified with char for `%s'\", name);\n-      else if ((RIDBIT_SETP (RID_LONG, specbits)\n-\t\t|| RIDBIT_SETP (RID_SHORT, specbits))\n+      else if ((declspecs->specs[(int)ds_long]\n+\t\t|| declspecs->specs[(int)ds_short])\n \t       && TREE_CODE (type) == REAL_TYPE)\n \terror (\"long or short specified with floating type for `%s'\", name);\n-      else if (RIDBIT_SETP (RID_SIGNED, specbits)\n-\t       && RIDBIT_SETP (RID_UNSIGNED, specbits))\n+      else if (declspecs->specs[(int)ds_signed]\n+\t       && declspecs->specs[(int)ds_unsigned])\n \terror (\"signed and unsigned given together for `%s'\", name);\n       else\n \t{\n@@ -6782,24 +6642,24 @@ grokdeclarator (const cp_declarator *declarator,\n       /* Discard the type modifiers if they are invalid.  */\n       if (! ok)\n \t{\n-\t  RIDBIT_RESET (RID_UNSIGNED, specbits);\n-\t  RIDBIT_RESET (RID_SIGNED, specbits);\n-\t  RIDBIT_RESET (RID_LONG, specbits);\n-\t  RIDBIT_RESET (RID_SHORT, specbits);\n+\t  declspecs->specs[(int)ds_unsigned] = 0;\n+\t  declspecs->specs[(int)ds_signed] = 0;\n+\t  declspecs->specs[(int)ds_long] = 0;\n+\t  declspecs->specs[(int)ds_short] = 0;\n \t  longlong = 0;\n \t}\n     }\n \n-  if (RIDBIT_SETP (RID_COMPLEX, specbits)\n+  if (declspecs->specs[(int)ds_complex]\n       && TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != REAL_TYPE)\n     {\n       error (\"complex invalid for `%s'\", name);\n-      RIDBIT_RESET (RID_COMPLEX, specbits);\n+      declspecs->specs[(int)ds_complex] = 0;\n     }\n \n   /* Decide whether an integer type is signed or not.\n      Optionally treat bitfields as signed by default.  */\n-  if (RIDBIT_SETP (RID_UNSIGNED, specbits)\n+  if (declspecs->specs[(int)ds_unsigned]\n       /* [class.bit]\n \n \t It is implementation-defined whether a plain (neither\n@@ -6809,7 +6669,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t Naturally, we extend this to long long as well.  Note that\n \t this does not include wchar_t.  */\n       || (bitfield && !flag_signed_bitfields\n-\t  && RIDBIT_NOTSETP (RID_SIGNED, specbits)\n+\t  && !declspecs->specs[(int)ds_signed]\n \t  /* A typedef for plain `int' without `signed' can be\n \t     controlled just like plain `int', but a typedef for\n \t     `signed int' cannot be so controlled.  */\n@@ -6821,9 +6681,9 @@ grokdeclarator (const cp_declarator *declarator,\n     {\n       if (longlong)\n \ttype = long_long_unsigned_type_node;\n-      else if (RIDBIT_SETP (RID_LONG, specbits))\n+      else if (declspecs->specs[(int)ds_long])\n \ttype = long_unsigned_type_node;\n-      else if (RIDBIT_SETP (RID_SHORT, specbits))\n+      else if (declspecs->specs[(int)ds_short])\n \ttype = short_unsigned_type_node;\n       else if (type == char_type_node)\n \ttype = unsigned_char_type_node;\n@@ -6832,28 +6692,28 @@ grokdeclarator (const cp_declarator *declarator,\n       else\n \ttype = unsigned_type_node;\n     }\n-  else if (RIDBIT_SETP (RID_SIGNED, specbits)\n+  else if (declspecs->specs[(int)ds_signed]\n \t   && type == char_type_node)\n     type = signed_char_type_node;\n   else if (longlong)\n     type = long_long_integer_type_node;\n-  else if (RIDBIT_SETP (RID_LONG, specbits))\n+  else if (declspecs->specs[(int)ds_long])\n     type = long_integer_type_node;\n-  else if (RIDBIT_SETP (RID_SHORT, specbits))\n+  else if (declspecs->specs[(int)ds_short])\n     type = short_integer_type_node;\n \n-  if (RIDBIT_SETP (RID_COMPLEX, specbits))\n+  if (declspecs->specs[(int)ds_complex])\n     {\n       /* If we just have \"complex\", it is equivalent to\n \t \"complex double\", but if any modifiers at all are specified it is\n \t the complex form of TYPE.  E.g, \"complex short\" is\n \t \"complex short int\".  */\n \n       if (defaulted_int && ! longlong\n-\t  && ! (RIDBIT_SETP (RID_LONG, specbits)\n-\t\t|| RIDBIT_SETP (RID_SHORT, specbits)\n-\t\t|| RIDBIT_SETP (RID_SIGNED, specbits)\n-\t\t|| RIDBIT_SETP (RID_UNSIGNED, specbits)))\n+\t  && ! (declspecs->specs[(int)ds_long]\n+\t\t|| declspecs->specs[(int)ds_short]\n+\t\t|| declspecs->specs[(int)ds_signed]\n+\t\t|| declspecs->specs[(int)ds_unsigned]))\n \ttype = complex_double_type_node;\n       else if (type == integer_type_node)\n \ttype = complex_integer_type_node;\n@@ -6868,11 +6728,11 @@ grokdeclarator (const cp_declarator *declarator,\n     }\n \n   type_quals = TYPE_UNQUALIFIED;\n-  if (RIDBIT_SETP (RID_CONST, specbits))\n+  if (declspecs->specs[(int)ds_const])\n     type_quals |= TYPE_QUAL_CONST;\n-  if (RIDBIT_SETP (RID_VOLATILE, specbits))\n+  if (declspecs->specs[(int)ds_volatile])\n     type_quals |= TYPE_QUAL_VOLATILE;\n-  if (RIDBIT_SETP (RID_RESTRICT, specbits))\n+  if (declspecs->specs[(int)ds_restrict])\n     type_quals |= TYPE_QUAL_RESTRICT;\n   if (sfk == sfk_conversion && type_quals != TYPE_UNQUALIFIED)\n     error (\"qualifiers are not allowed on declaration of `operator %T'\",\n@@ -6886,13 +6746,11 @@ grokdeclarator (const cp_declarator *declarator,\n   type_quals = cp_type_quals (type);\n   \n   staticp = 0;\n-  inlinep = !! RIDBIT_SETP (RID_INLINE, specbits);\n-  virtualp = !! RIDBIT_SETP (RID_VIRTUAL, specbits);\n-  RIDBIT_RESET (RID_VIRTUAL, specbits);\n-  explicitp = !! RIDBIT_SETP (RID_EXPLICIT, specbits);\n-  RIDBIT_RESET (RID_EXPLICIT, specbits);\n+  inlinep = !! declspecs->specs[(int)ds_inline];\n+  virtualp = !! declspecs->specs[(int)ds_virtual];\n+  explicitp = !! declspecs->specs[(int)ds_explicit];\n \n-  if (RIDBIT_SETP (RID_STATIC, specbits))\n+  if (declspecs->storage_class == sc_static)\n     staticp = 1 + (decl_context == FIELD);\n \n   if (virtualp && staticp == 2)\n@@ -6901,34 +6759,23 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tdname);\n       staticp = 0;\n     }\n-  friendp = !! RIDBIT_SETP (RID_FRIEND, specbits);\n-  RIDBIT_RESET (RID_FRIEND, specbits);\n+  friendp = !! declspecs->specs[(int)ds_friend];\n \n   if (dependant_name && !friendp)\n     {\n       error (\"`%T::%D' is not a valid declarator\", ctype, dependant_name);\n       return void_type_node;\n     }\n-  \n-  /* Warn if two storage classes are given. Default to `auto'.  */\n \n-  if (RIDBIT_ANY_SET (specbits))\n+  /* Issue errors about use of storage classes for parameters.  */\n+  if (decl_context == PARM)\n     {\n-      if (RIDBIT_SETP (RID_STATIC, specbits)) nclasses++;\n-      if (RIDBIT_SETP (RID_EXTERN, specbits) && !extern_langp) nclasses++;\n-      if (RIDBIT_SETP (RID_THREAD, specbits)) nclasses++;\n-      if (decl_context == PARM && nclasses > 0)\n+      if (declspecs->specs[(int)ds_typedef])\n+\terror (\"typedef declaration invalid in parameter declaration\");\n+      else if (declspecs->storage_class == sc_static\n+\t       || declspecs->storage_class == sc_extern\n+\t       || declspecs->specs[(int)ds_thread])\n \terror (\"storage class specifiers invalid in parameter declarations\");\n-      if (RIDBIT_SETP (RID_TYPEDEF, specbits))\n-\t{\n-\t  if (decl_context == PARM)\n-\t    error (\"typedef declaration invalid in parameter declaration\");\n-\t  nclasses++;\n-\t}\n-      if (RIDBIT_SETP (RID_AUTO, specbits)) nclasses++;\n-      if (RIDBIT_SETP (RID_REGISTER, specbits)) nclasses++;\n-      if (!nclasses && !friendp && extern_langp)\n-\tnclasses++;\n     }\n \n   /* Give error if `virtual' is used outside of class declaration.  */\n@@ -6941,33 +6788,27 @@ grokdeclarator (const cp_declarator *declarator,\n \n   /* Static anonymous unions are dealt with here.  */\n   if (staticp && decl_context == TYPENAME\n-      && TREE_CODE (declspecs) == TREE_LIST\n-      && ANON_AGGR_TYPE_P (TREE_VALUE (declspecs)))\n+      && declspecs->type\n+      && ANON_AGGR_TYPE_P (declspecs->type))\n     decl_context = FIELD;\n \n   /* Warn about storage classes that are invalid for certain\n      kinds of declarations (parameters, typenames, etc.).  */\n-\n-  /* \"static __thread\" and \"extern __thread\" are allowed.  */\n-  if (nclasses == 2\n-      && RIDBIT_SETP (RID_THREAD, specbits)\n-      && (RIDBIT_SETP (RID_EXTERN, specbits)\n-\t  || RIDBIT_SETP (RID_STATIC, specbits)))\n-    nclasses = 1;\n-    \n-  if (nclasses > 1)\n+  if (declspecs->multiple_storage_classes_p)\n     error (\"multiple storage classes in declaration of `%s'\", name);\n-  else if (decl_context != NORMAL && nclasses > 0)\n+  else if (decl_context != NORMAL \n+\t   && declspecs->storage_class != sc_none\n+\t   && declspecs->storage_class != sc_mutable)\n     {\n       if ((decl_context == PARM || decl_context == CATCHPARM)\n-\t  && (RIDBIT_SETP (RID_REGISTER, specbits)\n-\t      || RIDBIT_SETP (RID_AUTO, specbits)))\n+\t  && (declspecs->storage_class == sc_register\n+\t      || declspecs->storage_class == sc_auto))\n \t;\n-      else if (RIDBIT_SETP (RID_TYPEDEF, specbits))\n+      else if (declspecs->specs[(int)ds_typedef])\n \t;\n       else if (decl_context == FIELD\n \t       /* C++ allows static class elements.  */\n-\t       && RIDBIT_SETP (RID_STATIC, specbits))\n+\t       && declspecs->storage_class == sc_static)\n \t/* C++ also allows inlines and signed and unsigned elements,\n \t   but in those cases we don't come in here.  */\n \t;\n@@ -7005,13 +6846,15 @@ grokdeclarator (const cp_declarator *declarator,\n \t      else\n \t\terror (\"storage class specified for typename\");\n \t    }\n-\t  RIDBIT_RESET (RID_REGISTER, specbits);\n-\t  RIDBIT_RESET (RID_AUTO, specbits);\n-\t  RIDBIT_RESET (RID_EXTERN, specbits);\n-\t  RIDBIT_RESET (RID_THREAD, specbits);\n+\t  if (declspecs->storage_class == sc_register\n+\t      || declspecs->storage_class == sc_auto\n+\t      || declspecs->storage_class == sc_extern\n+\t      || declspecs->specs[(int)ds_thread])\n+\t    declspecs->storage_class = sc_none;\n \t}\n     }\n-  else if (RIDBIT_SETP (RID_EXTERN, specbits) && initialized && !funcdef_flag)\n+  else if (declspecs->storage_class == sc_extern && initialized \n+\t   && !funcdef_flag)\n     {\n       if (toplevel_bindings_p ())\n \t{\n@@ -7023,24 +6866,24 @@ grokdeclarator (const cp_declarator *declarator,\n       else\n \terror (\"`%s' has both `extern' and initializer\", name);\n     }\n-  else if (RIDBIT_SETP (RID_EXTERN, specbits) && funcdef_flag\n+  else if (declspecs->storage_class == sc_extern && funcdef_flag\n \t   && ! toplevel_bindings_p ())\n     error (\"nested function `%s' declared `extern'\", name);\n   else if (toplevel_bindings_p ())\n     {\n-      if (RIDBIT_SETP (RID_AUTO, specbits))\n+      if (declspecs->storage_class == sc_auto)\n \terror (\"top-level declaration of `%s' specifies `auto'\", name);\n     }\n-  else if (RIDBIT_SETP (RID_THREAD, specbits)\n-\t   && !RIDBIT_SETP (RID_EXTERN, specbits)\n-\t   && !RIDBIT_SETP (RID_STATIC, specbits))\n+  else if (declspecs->specs[(int)ds_thread]\n+\t   && declspecs->storage_class != sc_extern\n+\t   && declspecs->storage_class != sc_static)\n     {\n       error (\"function-scope `%s' implicitly auto and declared `__thread'\",\n \t     name);\n-      RIDBIT_RESET (RID_THREAD, specbits);\n+      declspecs->specs[(int)ds_thread] = 0;\n     }\n \n-  if (nclasses > 0 && friendp)\n+  if (declspecs->storage_class && friendp)\n     error (\"storage class specifiers invalid in friend function declarations\");\n \n   if (!id_declarator)\n@@ -7211,14 +7054,6 @@ grokdeclarator (const cp_declarator *declarator,\n                                TREE_VALUE (quals));\n \t\t\tquals = NULL_TREE;\n \t\t      }\n-\t\t    {\n-\t\t      RID_BIT_TYPE tmp_bits;\n-\t\t      memcpy (&tmp_bits, &specbits, sizeof (RID_BIT_TYPE));\n-\t\t      RIDBIT_RESET (RID_INLINE, tmp_bits);\n-\t\t      RIDBIT_RESET (RID_STATIC, tmp_bits);\n-\t\t      if (RIDBIT_ANY_SET (tmp_bits))\n-\t\t\terror (\"return value type specifier for constructor ignored\");\n-\t\t    }\n \t\t    if (decl_context == FIELD)\n \t\t      {\n \t\t\tif (! member_function_or_else (ctype,\n@@ -7241,7 +7076,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  {\n \t\t    /* Cannot be both friend and virtual.  */\n \t\t    error (\"virtual functions cannot be friends\");\n-\t\t    RIDBIT_RESET (RID_FRIEND, specbits);\n \t\t    friendp = 0;\n \t\t  }\n \t\tif (decl_context == NORMAL)\n@@ -7453,7 +7287,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t      return error_mark_node;\n \t    }\n \t}\n-      else if (RIDBIT_SETP (RID_TYPEDEF, specbits)\n+      else if (declspecs->specs[(int)ds_typedef]\n \t       || COMPLETE_TYPE_P (complete_type (ctype)))\n \t{\n \t  /* Have to move this code elsewhere in this function.\n@@ -7516,38 +7350,38 @@ grokdeclarator (const cp_declarator *declarator,\n       explicitp = 0;\n     }\n \n-  if (RIDBIT_SETP (RID_MUTABLE, specbits))\n+  if (declspecs->storage_class == sc_mutable)\n     {\n       if (decl_context != FIELD || friendp)\n         {\n \t  error (\"non-member `%s' cannot be declared `mutable'\", name);\n-          RIDBIT_RESET (RID_MUTABLE, specbits);\n+\t  declspecs->storage_class = sc_none;\n         }\n-      else if (decl_context == TYPENAME || RIDBIT_SETP (RID_TYPEDEF, specbits))\n+      else if (decl_context == TYPENAME || declspecs->specs[(int)ds_typedef])\n \t{\n \t  error (\"non-object member `%s' cannot be declared `mutable'\", name);\n-\t  RIDBIT_RESET (RID_MUTABLE, specbits);\n+\t  declspecs->storage_class = sc_none;\n \t}\n       else if (TREE_CODE (type) == FUNCTION_TYPE\n                || TREE_CODE (type) == METHOD_TYPE)\n         {\n \t  error (\"function `%s' cannot be declared `mutable'\", name);\n-\t  RIDBIT_RESET (RID_MUTABLE, specbits);\n+\t  declspecs->storage_class = sc_none;\n         }\n       else if (staticp)\n \t{\n \t  error (\"static `%s' cannot be declared `mutable'\", name);\n-\t  RIDBIT_RESET (RID_MUTABLE, specbits);\n+\t  declspecs->storage_class = sc_none;\n \t}\n       else if (type_quals & TYPE_QUAL_CONST)\n \t{\n \t  error (\"const `%s' cannot be declared `mutable'\", name);\n- \t  RIDBIT_RESET (RID_MUTABLE, specbits);\n+\t  declspecs->storage_class = sc_none;\n \t}\n     }\n \n   /* If this is declaring a typedef name, return a TYPE_DECL.  */\n-  if (RIDBIT_SETP (RID_TYPEDEF, specbits) && decl_context != TYPENAME)\n+  if (declspecs->specs[(int)ds_typedef] && decl_context != TYPENAME)\n     {\n       tree decl;\n \n@@ -7622,7 +7456,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    grok_method_quals (ctype, decl, quals);\n \t}\n \n-      if (RIDBIT_SETP (RID_SIGNED, specbits)\n+      if (declspecs->specs[(int)ds_signed]\n \t  || (typedef_decl && C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl)))\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n \n@@ -7944,8 +7778,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t    if (current_class_type\n \t\t&& TYPE_NAME (current_class_type)\n \t\t&& IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (current_class_type))\n-\t\t&& declspecs && TREE_VALUE (declspecs)\n-\t\t&& TREE_TYPE (TREE_VALUE (declspecs)) == type)\n+\t\t&& declspecs->type\n+\t\t&& declspecs->type == type)\n \t      error (\"  in instantiation of template `%T'\",\n \t\t\tcurrent_class_type);\n \n@@ -8039,10 +7873,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t      {\n \t\tdecl = build_decl (FIELD_DECL, unqualified_id, type);\n \t\tDECL_NONADDRESSABLE_P (decl) = bitfield;\n-\t\tif (RIDBIT_SETP (RID_MUTABLE, specbits))\n+\t\tif (declspecs->storage_class == sc_mutable)\n \t\t  {\n \t\t    DECL_MUTABLE_P (decl) = 1;\n-\t\t    RIDBIT_RESET (RID_MUTABLE, specbits);\n+\t\t    declspecs->storage_class = sc_none;\n \t\t  }\n \t      }\n \n@@ -8064,25 +7898,25 @@ grokdeclarator (const cp_declarator *declarator,\n \telse\n \t  original_name = unqualified_id;\n \n-\tif (RIDBIT_SETP (RID_AUTO, specbits))\n+\tif (declspecs->storage_class == sc_auto)\n \t  error (\"storage class `auto' invalid for function `%s'\", name);\n-\telse if (RIDBIT_SETP (RID_REGISTER, specbits))\n+\telse if (declspecs->storage_class == sc_register)\n \t  error (\"storage class `register' invalid for function `%s'\", name);\n-\telse if (RIDBIT_SETP (RID_THREAD, specbits))\n+\telse if (declspecs->specs[(int)ds_thread])\n \t  error (\"storage class `__thread' invalid for function `%s'\", name);\n \n \t/* Function declaration not at top level.\n \t   Storage classes other than `extern' are not allowed\n \t   and `extern' makes no difference.  */\n \tif (! toplevel_bindings_p ()\n-\t    && (RIDBIT_SETP (RID_STATIC, specbits)\n-\t\t|| RIDBIT_SETP (RID_INLINE, specbits))\n+\t    && (declspecs->storage_class == sc_static\n+\t\t|| declspecs->specs[(int)ds_inline])\n \t    && pedantic)\n \t  {\n-\t    if (RIDBIT_SETP (RID_STATIC, specbits))\n-\t      pedwarn (\"storage class `static' invalid for function `%s' declared out of global scope\", name);\n+\t    if (declspecs->storage_class == sc_static)\n+\t      pedwarn (\"`static' specified invalid for function `%s' declared out of global scope\", name);\n \t    else\n-\t      pedwarn (\"storage class `inline' invalid for function `%s' declared out of global scope\", name);\n+\t      pedwarn (\"`inline' specifier invalid for function `%s' declared out of global scope\", name);\n \t  }\n \n \tif (ctype == NULL_TREE)\n@@ -8101,8 +7935,8 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t/* Record presence of `static'.  */\n \tpublicp = (ctype != NULL_TREE\n-\t\t   || RIDBIT_SETP (RID_EXTERN, specbits)\n-\t\t   || !RIDBIT_SETP (RID_STATIC, specbits));\n+\t\t   || declspecs->storage_class == sc_extern\n+\t\t   || declspecs->storage_class != sc_static);\n \n \tdecl = grokfndecl (ctype, type, original_name, parms, unqualified_id,\n \t\t\t   virtualp, flags, quals, raises,\n@@ -8133,7 +7967,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    if (invalid_static)\n \t      {\n \t\tstaticp = 0;\n-\t\tRIDBIT_RESET (RID_STATIC, specbits);\n+\t\tdeclspecs->storage_class = sc_none;\n \t      }\n \t  }\n       }\n@@ -8142,7 +7976,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t/* It's a variable.  */\n \n \t/* An uninitialized decl with `extern' is a reference.  */\n-\tdecl = grokvardecl (type, unqualified_id, &specbits,\n+\tdecl = grokvardecl (type, unqualified_id, \n+\t\t\t    declspecs,\n \t\t\t    initialized,\n \t\t\t    (type_quals & TYPE_QUAL_CONST) != 0,\n \t\t\t    ctype ? ctype : in_namespace);\n@@ -8156,34 +7991,30 @@ grokdeclarator (const cp_declarator *declarator,\n \t      {\n                 pedwarn (\"`static' may not be used when defining (as opposed to declaring) a static data member\");\n \t        staticp = 0;\n-\t\tRIDBIT_RESET (RID_STATIC, specbits);\n+\t\tdeclspecs->storage_class = sc_none;\n \t      }\n-\t    if (RIDBIT_SETP (RID_REGISTER, specbits) && TREE_STATIC (decl))\n+\t    if (declspecs->storage_class == sc_register && TREE_STATIC (decl))\n \t      {\n \t\terror (\"static member `%D' declared `register'\", decl);\n-\t\tRIDBIT_RESET (RID_REGISTER, specbits);\n+\t\tdeclspecs->storage_class = sc_none;\n \t      }\n-\t    if (RIDBIT_SETP (RID_EXTERN, specbits) && pedantic)\n+\t    if (declspecs->storage_class == sc_extern && pedantic)\n \t      {\n \t        pedwarn (\"cannot explicitly declare member `%#D' to have extern linkage\",\n \t\t\t    decl);\n-\t\tRIDBIT_RESET (RID_EXTERN, specbits);\n+\t\tdeclspecs->storage_class = sc_none;\n \t      }\n \t  }\n       }\n \n-    my_friendly_assert (!RIDBIT_SETP (RID_MUTABLE, specbits), 19990927);\n-\n     /* Record `register' declaration for warnings on &\n        and in case doing stupid register allocation.  */\n \n-    if (RIDBIT_SETP (RID_REGISTER, specbits))\n+    if (declspecs->storage_class == sc_register)\n       DECL_REGISTER (decl) = 1;\n-\n-    if (RIDBIT_SETP (RID_EXTERN, specbits))\n+    else if (declspecs->storage_class == sc_extern)\n       DECL_THIS_EXTERN (decl) = 1;\n-\n-    if (RIDBIT_SETP (RID_STATIC, specbits))\n+    else if (declspecs->storage_class == sc_static)\n       DECL_THIS_STATIC (decl) = 1;\n \n     /* Record constancy and volatility.  There's no need to do this\n@@ -8348,27 +8179,27 @@ check_default_argument (tree decl, tree arg)\n    *PARMS is set to the chain of PARM_DECLs created.  */\n \n static tree\n-grokparms (const cp_parameter_declarator *first_parm, tree *parms)\n+grokparms (cp_parameter_declarator *first_parm, tree *parms)\n {\n   tree result = NULL_TREE;\n   tree decls = NULL_TREE;\n   int ellipsis = !first_parm || first_parm->ellipsis_p;\n-  const cp_parameter_declarator *parm;\n+  cp_parameter_declarator *parm;\n   int any_error = 0;\n \n   for (parm = first_parm; parm != NULL; parm = parm->next)\n     {\n       tree type = NULL_TREE;\n-      tree decl_specifiers = parm->decl_specifiers;\n       tree init = parm->default_argument;\n-      tree specs, attrs;\n+      tree attrs;\n       tree decl;\n \n       if (parm == no_parameters)\n         break;\n \n-      split_specs_attrs (decl_specifiers, &specs, &attrs);\n-      decl = grokdeclarator (parm->declarator, specs,\n+      attrs = parm->decl_specifiers.attributes;\n+      parm->decl_specifiers.attributes = NULL_TREE;\n+      decl = grokdeclarator (parm->declarator, &parm->decl_specifiers,\n \t\t\t     PARM, init != NULL_TREE, &attrs);\n       if (! decl || TREE_TYPE (decl) == error_mark_node)\n         continue;\n@@ -10070,15 +9901,15 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n    yyparse to report a parse error.  */\n \n int\n-start_function (tree declspecs, const cp_declarator *declarator,\n+start_function (cp_decl_specifier_seq *declspecs, \n+\t\tconst cp_declarator *declarator,\n \t\ttree attrs)\n {\n   tree decl1;\n \n   if (have_extern_spec)\n     {\n-      declspecs = tree_cons (NULL_TREE, get_identifier (\"extern\"), \n-\t\t\t     declspecs);\n+      declspecs->storage_class = sc_extern;\n       /* This should only be done once on the outermost decl.  */\n       have_extern_spec = false;\n     }\n@@ -10598,7 +10429,8 @@ finish_function (int flags)\n    CHANGES TO CODE IN `grokfield'.  */\n \n tree\n-start_method (tree declspecs, const cp_declarator *declarator, tree attrlist)\n+start_method (cp_decl_specifier_seq *declspecs, \n+              const cp_declarator *declarator, tree attrlist)\n {\n   tree fndecl = grokdeclarator (declarator, declspecs, MEMFUNCDEF, 0,\n \t\t\t\t&attrlist);"}, {"sha": "fae386e71331142da557d067321c90f3ef1233d1", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=62d1db179e700aeb45e805aa81de54036745f93e", "patch": "@@ -31,7 +31,9 @@ enum decl_context\n };\n \n /* We need this in here to get the decl_context definition.  */\n-extern tree grokdeclarator (const cp_declarator *, tree, enum decl_context, int, tree*);\n+extern tree grokdeclarator (const cp_declarator *, \n+\t\t\t    cp_decl_specifier_seq *, \n+\t\t\t    enum decl_context, int, tree*);\n \n #ifdef DEBUG_CP_BINDING_LEVELS\n /* Purely for debugging purposes.  */"}, {"sha": "10384b3b9b61b574b10e619dfce12d56dc3480b5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=62d1db179e700aeb45e805aa81de54036745f93e", "patch": "@@ -38,7 +38,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"cp-tree.h\"\n #include \"decl.h\"\n-#include \"lex.h\"\n #include \"output.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n@@ -157,27 +156,6 @@ grok_method_quals (tree ctype, tree function, tree quals)\n   return this_quals;\n }\n \n-/* A subroutine of the parser, to handle a component list.  */\n-\n-void\n-grok_x_components (tree specs)\n-{\n-  tree t;\n-\n-  specs = strip_attrs (specs);\n-\n-  check_tag_decl (specs);\n-  t = groktypename (specs, /*declarator=*/NULL);\n-\n-  /* The only case where we need to do anything additional here is an\n-     anonymous union field, e.g.: `struct S { union { int i; }; };'.  */\n-  if (t == NULL_TREE || !ANON_AGGR_TYPE_P (t))\n-    return;\n-\n-  fixup_anonymous_aggr (t);\n-  finish_member_declaration (build_decl (FIELD_DECL, NULL_TREE, t)); \n-}\n-\n /* Build a PARM_DECL with NAME and TYPE, and set DECL_ARG_TYPE\n    appropriately.  */\n \n@@ -840,15 +818,16 @@ finish_static_data_member_decl (tree decl, tree init, tree asmspec_tree,\n    CHANGES TO CODE IN `start_method'.  */\n \n tree\n-grokfield (const cp_declarator *declarator, tree declspecs, \n+grokfield (const cp_declarator *declarator, \n+\t   cp_decl_specifier_seq *declspecs, \n \t   tree init, tree asmspec_tree,\n            tree attrlist)\n {\n   tree value;\n   const char *asmspec = 0;\n   int flags = LOOKUP_ONLYCONVERTING;\n \n-  if (declspecs == NULL_TREE\n+  if (!declspecs->any_specifiers_p\n       && declarator->kind == cdk_id\n       && TREE_CODE (declarator->u.id.name) == SCOPE_REF\n       && (TREE_CODE (TREE_OPERAND (declarator->u.id.name, 1)) \n@@ -1023,7 +1002,8 @@ grokfield (const cp_declarator *declarator, tree declspecs,\n    WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.  */\n \n tree\n-grokbitfield (const cp_declarator *declarator, tree declspecs, tree width)\n+grokbitfield (const cp_declarator *declarator, \n+\t      cp_decl_specifier_seq *declspecs, tree width)\n {\n   tree value = grokdeclarator (declarator, declspecs, BITFIELD, 0, NULL);\n "}, {"sha": "c9422696f4b16f4aeefe2cbaf1055be5797d5069", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=62d1db179e700aeb45e805aa81de54036745f93e", "patch": "@@ -31,7 +31,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"cp-tree.h\"\n #include \"cpplib.h\"\n-#include \"lex.h\"\n #include \"flags.h\"\n #include \"c-pragma.h\"\n #include \"toplev.h\""}, {"sha": "35c3503ea41779346a9d2e7b508330c0c1840668", "filename": "gcc/cp/lex.h", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4d587b32145384beb79942f6ba1137a1409656/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4d587b32145384beb79942f6ba1137a1409656/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=3a4d587b32145384beb79942f6ba1137a1409656", "patch": "@@ -1,68 +0,0 @@\n-/* Define constants and variables for communication with the parser.\n-   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n-   Hacked by Michael Tiemann (tiemann@cygnus.com)\n-   and by Brendan Kehoe (brendan@cygnus.com).\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to the Free\n-   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-   02111-1307, USA.  */\n-\n-\n-#ifndef GCC_CP_LEX_H\n-#define GCC_CP_LEX_H\n-\n-#if 0\n-/* Formerly, the RID_* values used as mask bits did not fit into a\n-   single 32-bit word.  Now they do, but let's preserve the old logic\n-   in case they ever stop fitting again.  -zw, 8 Aug 2000 */\n-\n-/* The type that can represent all values of RIDBIT.  */\n-/* We assume that we can stick in at least 32 bits into this.  */\n-typedef struct { unsigned long idata[2]; }\n-     RID_BIT_TYPE;\n-\n-/* Be careful, all these modify N twice.  */\n-#define RIDBIT_SETP(N, V) (((unsigned long)1 << (int) ((N)%32))\t\t      \\\n-\t\t\t    & (V).idata[(N)/32])\n-#define RIDBIT_NOTSETP(NN, VV) (! RIDBIT_SETP (NN, VV))\n-#define RIDBIT_SET(N, V) do {\t\t\t\t\t\t      \\\n-\t\t\t\t(V).idata[(N)/32]\t\t\t      \\\n-\t\t\t\t  |= ((unsigned long)1 << (int) ((N)%32));    \\\n-\t\t\t      } while (0)\n-#define RIDBIT_RESET(N, V) do {\t\t\t\t\t\t      \\\n-\t\t\t\t  (V).idata[(N)/32]\t\t\t      \\\n-\t\t\t\t    &= ~((unsigned long)1 << (int) ((N)%32)); \\\n-\t\t\t\t} while (0)\n-#define RIDBIT_RESET_ALL(V) do {\t\t\t\t\t      \\\n-\t\t\t\t   (V).idata[0] = 0;     \t\t      \\\n-\t\t\t\t   (V).idata[1] = 0;\t\t\t      \\\n-\t\t\t\t } while (0)\n-#define RIDBIT_ANY_SET(V) ((V).idata[0] || (V).idata[1])\n-#else\n-typedef unsigned long RID_BIT_TYPE;\t/* assumed at least 32 bits */\n-#define RIDBIT_OF(R) ((unsigned long)1 << (int) (R))\n-\n-#define RIDBIT_SETP(N, V) ((V) & RIDBIT_OF (N))\n-#define RIDBIT_NOTSETP(N, V) (! ((V) & RIDBIT_OF (N)))\n-#define RIDBIT_ANY_SET(V) (V)\n-\n-#define RIDBIT_SET(N, V) do { (V) |= RIDBIT_OF (N); } while (0)\n-#define RIDBIT_RESET(N, V) do { (V) &= ~RIDBIT_OF (N); } while (0)\n-#define RIDBIT_RESET_ALL(V) do { (V) = 0; } while (0)\n-#endif\n-\n-#endif /* ! GCC_CP_LEX_H */"}, {"sha": "ffaf0c85c99ca7958c9b52d71a202466885660ad", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 374, "deletions": 277, "changes": 651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=62d1db179e700aeb45e805aa81de54036745f93e", "patch": "@@ -34,6 +34,7 @@\n #include \"diagnostic.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n+#include \"target.h\"\n \n \f\n /* The lexer.  */\n@@ -995,6 +996,19 @@ cp_lexer_stop_debugging (cp_lexer* lexer)\n }\n \n \f\n+/* Decl-specifiers.  */\n+\n+static void clear_decl_specs\n+  (cp_decl_specifier_seq *);\n+\n+/* Set *DECL_SPECS to represent an empty decl-specifier-seq.  */\n+\n+static void\n+clear_decl_specs (cp_decl_specifier_seq *decl_specs)\n+{\n+  memset (decl_specs, 0, sizeof (cp_decl_specifier_seq));\n+}\n+\n /* Declarators.  */\n \n /* Nothing other than the parser should be creating declarators;\n@@ -1013,7 +1027,7 @@ static cp_declarator *make_pointer_declarator\n static cp_declarator *make_reference_declarator\t\n   (tree, cp_declarator *);\n static cp_parameter_declarator *make_parameter_declarator \n-  (tree, cp_declarator *, tree);\n+  (cp_decl_specifier_seq *, cp_declarator *, tree);\n static cp_declarator *make_ptrmem_declarator\t\n   (tree, tree, cp_declarator *);\n \n@@ -1153,7 +1167,7 @@ cp_parameter_declarator *no_parameters;\n    DECLARATOR and DEFAULT_ARGUMENT.  */\n \n cp_parameter_declarator *\n-make_parameter_declarator (tree decl_specifiers, \n+make_parameter_declarator (cp_decl_specifier_seq *decl_specifiers, \n \t\t\t   cp_declarator *declarator,\n \t\t\t   tree default_argument)\n {\n@@ -1162,7 +1176,10 @@ make_parameter_declarator (tree decl_specifiers,\n   parameter = ((cp_parameter_declarator *) \n \t       alloc_declarator (sizeof (cp_parameter_declarator)));\n   parameter->next = NULL;\n-  parameter->decl_specifiers = decl_specifiers;\n+  if (decl_specifiers)\n+    parameter->decl_specifiers = *decl_specifiers;\n+  else\n+    clear_decl_specs (&parameter->decl_specifiers);\n   parameter->declarator = declarator;\n   parameter->default_argument = default_argument;\n   parameter->ellipsis_p = false;\n@@ -1627,16 +1644,17 @@ static void cp_parser_block_declaration\n   (cp_parser *, bool);\n static void cp_parser_simple_declaration\n   (cp_parser *, bool);\n-static tree cp_parser_decl_specifier_seq\n-  (cp_parser *, cp_parser_flags, tree *, int *);\n+static void cp_parser_decl_specifier_seq\n+  (cp_parser *, cp_parser_flags, cp_decl_specifier_seq *, int *);\n static tree cp_parser_storage_class_specifier_opt\n   (cp_parser *);\n static tree cp_parser_function_specifier_opt\n-  (cp_parser *);\n+  (cp_parser *, cp_decl_specifier_seq *);\n static tree cp_parser_type_specifier\n-  (cp_parser *, cp_parser_flags, bool, bool, int *, bool *);\n+  (cp_parser *, cp_parser_flags, cp_decl_specifier_seq *, bool, \n+   int *, bool *);\n static tree cp_parser_simple_type_specifier\n-  (cp_parser *, cp_parser_flags, bool);\n+  (cp_parser *, cp_decl_specifier_seq *, cp_parser_flags);\n static tree cp_parser_type_name\n   (cp_parser *);\n static tree cp_parser_elaborated_type_specifier\n@@ -1669,7 +1687,7 @@ static void cp_parser_linkage_specification\n /* Declarators [gram.dcl.decl] */\n \n static tree cp_parser_init_declarator\n-  (cp_parser *, tree, tree, bool, bool, int, bool *);\n+  (cp_parser *, cp_decl_specifier_seq *, bool, bool, int, bool *);\n static cp_declarator *cp_parser_declarator\n   (cp_parser *, cp_parser_declarator_kind, int *, bool *);\n static cp_declarator *cp_parser_direct_declarator\n@@ -1684,8 +1702,8 @@ static tree cp_parser_declarator_id\n   (cp_parser *);\n static tree cp_parser_type_id\n   (cp_parser *);\n-static tree cp_parser_type_specifier_seq\n-  (cp_parser *);\n+static void cp_parser_type_specifier_seq\n+  (cp_parser *, cp_decl_specifier_seq *);\n static cp_parameter_declarator *cp_parser_parameter_declaration_clause\n   (cp_parser *);\n static cp_parameter_declarator *cp_parser_parameter_declaration_list\n@@ -1834,7 +1852,7 @@ static tree cp_parser_global_scope_opt\n static bool cp_parser_constructor_declarator_p\n   (cp_parser *, bool);\n static tree cp_parser_function_definition_from_specifiers_and_declarator\n-  (cp_parser *, tree, tree, const cp_declarator *);\n+  (cp_parser *, cp_decl_specifier_seq *, tree, const cp_declarator *);\n static tree cp_parser_function_definition_after_declarator\n   (cp_parser *, bool);\n static void cp_parser_template_declaration_after_export\n@@ -1844,7 +1862,7 @@ static tree cp_parser_single_declaration\n static tree cp_parser_functional_cast\n   (cp_parser *, tree);\n static tree cp_parser_save_member_function_body\n-  (cp_parser *, tree, cp_declarator *, tree);\n+  (cp_parser *, cp_decl_specifier_seq *, cp_declarator *, tree);\n static tree cp_parser_enclosed_template_argument_list\n   (cp_parser *);\n static void cp_parser_save_default_args\n@@ -1857,8 +1875,12 @@ static tree cp_parser_sizeof_operand\n   (cp_parser *, enum rid);\n static bool cp_parser_declares_only_class_p\n   (cp_parser *);\n+static void cp_parser_set_storage_class\n+  (cp_decl_specifier_seq *, cp_storage_class);\n+static void cp_parser_set_decl_spec_type \n+  (cp_decl_specifier_seq *, tree, bool);\n static bool cp_parser_friend_p\n-  (tree);\n+  (const cp_decl_specifier_seq *);\n static cp_token *cp_parser_require\n   (cp_parser *, enum cpp_ttype, const char *);\n static cp_token *cp_parser_require_keyword\n@@ -2612,7 +2634,7 @@ cp_parser_translation_unit (cp_parser* parser)\n       /* Create the error declarator.  */\n       cp_error_declarator = make_declarator (cdk_error);\n       /* Create the empty parameter list.  */\n-      no_parameters = make_parameter_declarator (NULL_TREE, NULL, NULL_TREE);\n+      no_parameters = make_parameter_declarator (NULL, NULL, NULL_TREE);\n       /* Remember where the base of the declarator obstack lies.  */\n       declarator_obstack_base = obstack_next_free (&declarator_obstack);\n     }\n@@ -3880,8 +3902,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \tcp_parser_parse_tentatively (parser);\n \t/* Look for the simple-type-specifier.  */\n \ttype = cp_parser_simple_type_specifier (parser,\n-\t\t\t\t\t\tCP_PARSER_FLAGS_NONE,\n-\t\t\t\t\t\t/*identifier_p=*/false);\n+\t\t\t\t\t\t/*decl_specs=*/NULL,\n+\t\t\t\t\t\tCP_PARSER_FLAGS_NONE);\n \t/* Parse the cast itself.  */\n \tif (!cp_parser_error_occurred (parser))\n \t  postfix_expression\n@@ -4850,7 +4872,7 @@ cp_parser_new_placement (cp_parser* parser)\n static tree\n cp_parser_new_type_id (cp_parser* parser, tree *nelts)\n {\n-  tree type_specifier_seq;\n+  cp_decl_specifier_seq type_specifier_seq;\n   cp_declarator *new_declarator;\n   cp_declarator *declarator;\n   cp_declarator *outer_declarator;\n@@ -4865,7 +4887,7 @@ cp_parser_new_type_id (cp_parser* parser, tree *nelts)\n   parser->type_definition_forbidden_message\n     = \"types may not be defined in a new-type-id\";\n   /* Parse the type-specifier-seq.  */\n-  type_specifier_seq = cp_parser_type_specifier_seq (parser);\n+  cp_parser_type_specifier_seq (parser, &type_specifier_seq);\n   /* Restore the old message.  */\n   parser->type_definition_forbidden_message = saved_message;\n   /* Parse the new-declarator.  */\n@@ -4912,7 +4934,7 @@ cp_parser_new_type_id (cp_parser* parser, tree *nelts)\n \tnew_declarator = NULL;\n     }\n \n-  type = groktypename (type_specifier_seq, new_declarator);\n+  type = groktypename (&type_specifier_seq, new_declarator);\n   if (TREE_CODE (type) == ARRAY_TYPE && *nelts == NULL_TREE)\n     {\n       *nelts = array_type_nelts_top (type);\n@@ -6257,7 +6279,7 @@ cp_parser_selection_statement (cp_parser* parser)\n static tree\n cp_parser_condition (cp_parser* parser)\n {\n-  tree type_specifiers;\n+  cp_decl_specifier_seq type_specifiers;\n   const char *saved_message;\n \n   /* Try the declaration first.  */\n@@ -6268,7 +6290,7 @@ cp_parser_condition (cp_parser* parser)\n   parser->type_definition_forbidden_message\n     = \"types may not be defined in conditions\";\n   /* Parse the type-specifier-seq.  */\n-  type_specifiers = cp_parser_type_specifier_seq (parser);\n+  cp_parser_type_specifier_seq (parser, &type_specifiers);\n   /* Restore the saved message.  */\n   parser->type_definition_forbidden_message = saved_message;\n   /* If all is well, we might be looking at a declaration.  */\n@@ -6301,7 +6323,7 @@ cp_parser_condition (cp_parser* parser)\n       if (cp_parser_parse_definitely (parser))\n \t{\n \t  /* Create the declaration.  */\n-\t  decl = start_decl (declarator, type_specifiers,\n+\t  decl = start_decl (declarator, &type_specifiers,\n \t\t\t     /*initialized_p=*/true,\n \t\t\t     attributes, /*prefix_attributes=*/NULL_TREE);\n \t  /* Parse the assignment-expression.  */\n@@ -6911,8 +6933,7 @@ static void\n cp_parser_simple_declaration (cp_parser* parser,\n                               bool function_definition_allowed_p)\n {\n-  tree decl_specifiers;\n-  tree attributes;\n+  cp_decl_specifier_seq decl_specifiers;\n   int declares_class_or_enum;\n   bool saw_declarator;\n \n@@ -6932,18 +6953,18 @@ cp_parser_simple_declaration (cp_parser* parser,\n      omitted only when declaring a class or enumeration, that is when\n      the decl-specifier-seq contains either a class-specifier, an\n      elaborated-type-specifier, or an enum-specifier.  */\n-  decl_specifiers\n-    = cp_parser_decl_specifier_seq (parser,\n-\t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n-\t\t\t\t    &attributes,\n-\t\t\t\t    &declares_class_or_enum);\n+  cp_parser_decl_specifier_seq (parser,\n+\t\t\t\tCP_PARSER_FLAGS_OPTIONAL,\n+\t\t\t\t&decl_specifiers,\n+\t\t\t\t&declares_class_or_enum);\n   /* We no longer need to defer access checks.  */\n   stop_deferring_access_checks ();\n \n   /* In a block scope, a valid declaration must always have a\n      decl-specifier-seq.  By not trying to parse declarators, we can\n      resolve the declaration/expression ambiguity more quickly.  */\n-  if (!function_definition_allowed_p && !decl_specifiers)\n+  if (!function_definition_allowed_p \n+      && !decl_specifiers.any_specifiers_p)\n     {\n       cp_parser_error (parser, \"expected declaration\");\n       goto done;\n@@ -6976,7 +6997,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n \n       saw_declarator = true;\n       /* Parse the init-declarator.  */\n-      decl = cp_parser_init_declarator (parser, decl_specifiers, attributes,\n+      decl = cp_parser_init_declarator (parser, &decl_specifiers,\n \t\t\t\t\tfunction_definition_allowed_p,\n \t\t\t\t\t/*member_p=*/false,\n \t\t\t\t\tdeclares_class_or_enum,\n@@ -7039,7 +7060,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n   if (!saw_declarator)\n     {\n       if (cp_parser_declares_only_class_p (parser))\n-\tshadow_tag (decl_specifiers);\n+\tshadow_tag (&decl_specifiers);\n       /* Perform any deferred access checks.  */\n       perform_deferred_access_checks ();\n     }\n@@ -7068,14 +7089,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n    decl-specifier:\n      attributes\n \n-   Returns a TREE_LIST, giving the decl-specifiers in the order they\n-   appear in the source code.  The TREE_VALUE of each node is the\n-   decl-specifier.  For a keyword (such as `auto' or `friend'), the\n-   TREE_VALUE is simply the corresponding TREE_IDENTIFIER.  For the\n-   representation of a type-specifier, see cp_parser_type_specifier.\n-\n-   If there are attributes, they will be stored in *ATTRIBUTES,\n-   represented as described above cp_parser_attributes.\n+   Set *DECL_SPECS to a representation of the decl-specifier-seq.\n \n    If FRIEND_IS_NOT_CLASS_P is non-NULL, and the `friend' specifier\n    appears, and the entity that will be a friend is not going to be a\n@@ -7090,30 +7104,28 @@ cp_parser_simple_declaration (cp_parser* parser,\n         (i.e., a type declaration)\n      2: one of the decl-specifiers is an enum-specifier or a\n         class-specifier (i.e., a type definition)\n-\n+   \n    */\n \n-static tree\n+static void\n cp_parser_decl_specifier_seq (cp_parser* parser,\n-                              cp_parser_flags flags,\n-                              tree* attributes,\n+\t\t\t      cp_parser_flags flags,\n+\t\t\t      cp_decl_specifier_seq *decl_specs,\n \t\t\t      int* declares_class_or_enum)\n {\n-  tree decl_specs = NULL_TREE;\n-  bool friend_p = false;\n   bool constructor_possible_p = !parser->in_declarator_p;\n \n+  /* Clear DECL_SPECS.  */\n+  clear_decl_specs (decl_specs);\n+\n   /* Assume no class or enumeration type is declared.  */\n   *declares_class_or_enum = 0;\n \n-  /* Assume there are no attributes.  */\n-  *attributes = NULL_TREE;\n-\n   /* Keep reading specifiers until there are no more to read.  */\n   while (true)\n     {\n-      tree decl_spec = NULL_TREE;\n       bool constructor_p;\n+      bool found_decl_spec;\n       cp_token *token;\n \n       /* Peek at the next token.  */\n@@ -7122,25 +7134,22 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n       if (token->keyword == RID_ATTRIBUTE)\n \t{\n \t  /* Parse the attributes.  */\n-\t  decl_spec = cp_parser_attributes_opt (parser);\n-\t  /* Add them to the list.  */\n-\t  *attributes = chainon (*attributes, decl_spec);\n+\t  decl_specs->attributes \n+\t    = chainon (decl_specs->attributes,\n+\t\t       cp_parser_attributes_opt (parser));\n \t  continue;\n \t}\n+      /* Assume we will find a decl-specifier keyword.  */\n+      found_decl_spec = true;\n       /* If the next token is an appropriate keyword, we can simply\n \t add it to the list.  */\n       switch (token->keyword)\n \t{\n-\tcase RID_FRIEND:\n \t  /* decl-specifier:\n \t       friend  */\n-\t  if (friend_p)\n+\tcase RID_FRIEND:\n+\t  if (decl_specs->specs[(int) ds_friend]++)\n \t    error (\"duplicate `friend'\");\n-\t  else\n-\t    friend_p = true;\n-\t  /* The representation of the specifier is simply the\n-\t     appropriate TREE_IDENTIFIER node.  */\n-\t  decl_spec = token->value;\n \t  /* Consume the token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  break;\n@@ -7152,15 +7161,13 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \tcase RID_INLINE:\n \tcase RID_VIRTUAL:\n \tcase RID_EXPLICIT:\n-\t  decl_spec = cp_parser_function_specifier_opt (parser);\n+\t  cp_parser_function_specifier_opt (parser, decl_specs);\n \t  break;\n \n \t  /* decl-specifier:\n \t       typedef  */\n \tcase RID_TYPEDEF:\n-\t  /* The representation of the specifier is simply the\n-\t     appropriate TREE_IDENTIFIER node.  */\n-\t  decl_spec = token->value;\n+\t  ++decl_specs->specs[(int) ds_typedef];\n \t  /* Consume the token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* A constructor declarator cannot appear in a typedef.  */\n@@ -7180,35 +7187,67 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n              GNU Extension:\n \t       thread  */\n \tcase RID_AUTO:\n+\t  /* Consume the token.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_parser_set_storage_class (decl_specs, sc_auto);\n+\t  break;\n \tcase RID_REGISTER:\n+\t  /* Consume the token.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_parser_set_storage_class (decl_specs, sc_register);\n+\t  break;\n \tcase RID_STATIC:\n+\t  /* Consume the token.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (decl_specs->specs[(int) ds_thread])\n+\t    error (\"`__thread' before `static'\");\n+\t  else\n+\t    cp_parser_set_storage_class (decl_specs, sc_static);\n+\t  break;\n \tcase RID_EXTERN:\n+\t  /* Consume the token.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (decl_specs->specs[(int) ds_thread])\n+\t    error (\"`__thread' before `extern'\");\n+\t  else\n+\t    cp_parser_set_storage_class (decl_specs, sc_extern);\n+\t  break;\n \tcase RID_MUTABLE:\n+\t  /* Consume the token.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_parser_set_storage_class (decl_specs, sc_mutable);\n+\t  break;\n \tcase RID_THREAD:\n-\t  decl_spec = cp_parser_storage_class_specifier_opt (parser);\n+\t  /* Consume the token.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  ++decl_specs->specs[(int) ds_thread];\n \t  break;\n \n \tdefault:\n+\t  /* We did not yet find a decl-specifier yet.  */\n+\t  found_decl_spec = false;\n \t  break;\n \t}\n \n       /* Constructors are a special case.  The `S' in `S()' is not a\n \t decl-specifier; it is the beginning of the declarator.  */\n-      constructor_p = (!decl_spec\n-\t\t       && constructor_possible_p\n-\t\t       && cp_parser_constructor_declarator_p (parser,\n-\t\t\t\t\t\t\t      friend_p));\n+      constructor_p \n+\t= (!found_decl_spec\n+\t   && constructor_possible_p\n+\t   && (cp_parser_constructor_declarator_p \n+\t       (parser, decl_specs->specs[(int) ds_friend] != 0)));\n \n       /* If we don't have a DECL_SPEC yet, then we must be looking at\n \t a type-specifier.  */\n-      if (!decl_spec && !constructor_p)\n+      if (!found_decl_spec && !constructor_p)\n \t{\n \t  int decl_spec_declares_class_or_enum;\n \t  bool is_cv_qualifier;\n+\t  tree type_spec;\n \n-\t  decl_spec\n+\t  type_spec\n \t    = cp_parser_type_specifier (parser, flags,\n-\t\t\t\t\tfriend_p,\n+\t\t\t\t\tdecl_specs,\n \t\t\t\t\t/*is_declaration=*/true,\n \t\t\t\t\t&decl_spec_declares_class_or_enum,\n \t\t\t\t\t&is_cv_qualifier);\n@@ -7251,44 +7290,31 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t     user-defined types.  We *do* still allow things like `int\n \t     int' to be considered a decl-specifier-seq, and issue the\n \t     error message later.  */\n-\t  if (decl_spec && !is_cv_qualifier)\n+\t  if (type_spec && !is_cv_qualifier)\n \t    flags |= CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES;\n \t  /* A constructor declarator cannot follow a type-specifier.  */\n-\t  if (decl_spec)\n-\t    constructor_possible_p = false;\n-\t}\n-\n-      /* If we still do not have a DECL_SPEC, then there are no more\n-\t decl-specifiers.  */\n-      if (!decl_spec)\n-\t{\n-\t  /* Issue an error message, unless the entire construct was\n-             optional.  */\n-\t  if (!(flags & CP_PARSER_FLAGS_OPTIONAL))\n+\t  if (type_spec)\n \t    {\n-\t      cp_parser_error (parser, \"expected decl specifier\");\n-\t      return error_mark_node;\n+\t      constructor_possible_p = false;\n+\t      found_decl_spec = true;\n \t    }\n-\n-\t  break;\n \t}\n \n-      /* Add the DECL_SPEC to the list of specifiers.  */\n-      if (decl_specs == NULL || TREE_VALUE (decl_specs) != error_mark_node)\n-\tdecl_specs = tree_cons (NULL_TREE, decl_spec, decl_specs);\n+      /* If we still do not have a DECL_SPEC, then there are no more\n+\t decl-specifiers.  */\n+      if (!found_decl_spec)\n+\tbreak;\n \n+      decl_specs->any_specifiers_p = true;\n       /* After we see one decl-specifier, further decl-specifiers are\n \t always optional.  */\n       flags |= CP_PARSER_FLAGS_OPTIONAL;\n     }\n \n   /* Don't allow a friend specifier with a class definition.  */\n-  if (friend_p && (*declares_class_or_enum & 2))\n+  if (decl_specs->specs[(int) ds_friend] != 0\n+      && (*declares_class_or_enum & 2))\n     error (\"class definition may not be declared a friend\");\n-\n-  /* We have built up the DECL_SPECS in reverse order.  Return them in\n-     the correct order.  */\n-  return nreverse (decl_specs);\n }\n \n /* Parse an (optional) storage-class-specifier.\n@@ -7333,22 +7359,36 @@ cp_parser_storage_class_specifier_opt (cp_parser* parser)\n      virtual\n      explicit\n \n-   Returns an IDENTIFIER_NODE corresponding to the keyword used.  */\n+   Returns an IDENTIFIER_NODE corresponding to the keyword used.\n+   Updates DECL_SPECS, if it is non-NULL.  */\n \n static tree\n-cp_parser_function_specifier_opt (cp_parser* parser)\n+cp_parser_function_specifier_opt (cp_parser* parser,\n+\t\t\t\t  cp_decl_specifier_seq *decl_specs)\n {\n   switch (cp_lexer_peek_token (parser->lexer)->keyword)\n     {\n     case RID_INLINE:\n+      if (decl_specs)\n+\t++decl_specs->specs[(int) ds_inline];\n+      break;\n+\n     case RID_VIRTUAL:\n+      if (decl_specs)\n+\t++decl_specs->specs[(int) ds_virtual];\n+      break;\n+\n     case RID_EXPLICIT:\n-      /* Consume the token.  */\n-      return cp_lexer_consume_token (parser->lexer)->value;\n+      if (decl_specs)\n+\t++decl_specs->specs[(int) ds_explicit];\n+      break;\n \n     default:\n       return NULL_TREE;\n     }\n+\n+  /* Consume the token.  */\n+  return cp_lexer_consume_token (parser->lexer)->value;\n }\n \n /* Parse a linkage-specification.\n@@ -7497,20 +7537,20 @@ static tree\n cp_parser_conversion_type_id (cp_parser* parser)\n {\n   tree attributes;\n-  tree type_specifiers;\n+  cp_decl_specifier_seq type_specifiers;\n   cp_declarator *declarator;\n \n   /* Parse the attributes.  */\n   attributes = cp_parser_attributes_opt (parser);\n   /* Parse the type-specifiers.  */\n-  type_specifiers = cp_parser_type_specifier_seq (parser);\n+  cp_parser_type_specifier_seq (parser, &type_specifiers);\n   /* If that didn't work, stop.  */\n-  if (type_specifiers == error_mark_node)\n+  if (type_specifiers.type == error_mark_node)\n     return error_mark_node;\n   /* Parse the conversion-declarator.  */\n   declarator = cp_parser_conversion_declarator_opt (parser);\n \n-  return grokdeclarator (declarator, type_specifiers, TYPENAME,\n+  return grokdeclarator (declarator, &type_specifiers, TYPENAME,\n \t\t\t /*initialized=*/0, &attributes);\n }\n \n@@ -8114,7 +8154,7 @@ static tree\n cp_parser_template_parameter (cp_parser* parser, bool *is_non_type)\n {\n   cp_token *token;\n-  const cp_parameter_declarator *parameter_declarator;\n+  cp_parameter_declarator *parameter_declarator;\n \n   /* Assume it is a type parameter or a template parameter.  */\n   *is_non_type = false;\n@@ -8166,7 +8206,7 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type)\n   return (build_tree_list \n \t  (parameter_declarator->default_argument,\n \t   grokdeclarator (parameter_declarator->declarator,\n-\t\t\t   parameter_declarator->decl_specifiers,\n+\t\t\t   &parameter_declarator->decl_specifiers,\n \t\t\t   PARM, /*initialized=*/0, \n \t\t\t   /*attrlist=*/NULL)));\n }\n@@ -9005,8 +9045,7 @@ static void\n cp_parser_explicit_instantiation (cp_parser* parser)\n {\n   int declares_class_or_enum;\n-  tree decl_specifiers;\n-  tree attributes;\n+  cp_decl_specifier_seq decl_specifiers;\n   tree extension_specifier = NULL_TREE;\n \n   /* Look for an (optional) storage-class-specifier or\n@@ -9016,7 +9055,9 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n       extension_specifier\n \t= cp_parser_storage_class_specifier_opt (parser);\n       if (!extension_specifier)\n-\textension_specifier = cp_parser_function_specifier_opt (parser);\n+\textension_specifier \n+\t  = cp_parser_function_specifier_opt (parser,\n+\t\t\t\t\t      /*decl_specs=*/NULL);\n     }\n \n   /* Look for the `template' keyword.  */\n@@ -9028,19 +9069,18 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n      control while processing explicit instantiation directives.  */\n   push_deferring_access_checks (dk_no_check);\n   /* Parse a decl-specifier-seq.  */\n-  decl_specifiers\n-    = cp_parser_decl_specifier_seq (parser,\n-\t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n-\t\t\t\t    &attributes,\n-\t\t\t\t    &declares_class_or_enum);\n+  cp_parser_decl_specifier_seq (parser,\n+\t\t\t\tCP_PARSER_FLAGS_OPTIONAL,\n+\t\t\t\t&decl_specifiers,\n+\t\t\t\t&declares_class_or_enum);\n   /* If there was exactly one decl-specifier, and it declared a class,\n      and there's no declarator, then we have an explicit type\n      instantiation.  */\n   if (declares_class_or_enum && cp_parser_declares_only_class_p (parser))\n     {\n       tree type;\n \n-      type = check_tag_decl (decl_specifiers);\n+      type = check_tag_decl (&decl_specifiers);\n       /* Turn access control back on for names used during\n \t template instantiation.  */\n       pop_deferring_access_checks ();\n@@ -9061,7 +9101,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n \t\t\t\t\t\t     declares_class_or_enum);\n       if (declarator != cp_error_declarator)\n \t{\n-\t  decl = grokdeclarator (declarator, decl_specifiers,\n+\t  decl = grokdeclarator (declarator, &decl_specifiers,\n \t\t\t\t NORMAL, 0, NULL);\n \t  /* Turn access control back on for names used during\n \t     template instantiation.  */\n@@ -9146,11 +9186,9 @@ cp_parser_explicit_specialization (cp_parser* parser)\n    type-specifier:\n      __complex__\n \n-   Returns a representation of the type-specifier.  If the\n-   type-specifier is a keyword (like `int' or `const', or\n-   `__complex__') then the corresponding IDENTIFIER_NODE is returned.\n-   For a class-specifier, enum-specifier, or elaborated-type-specifier\n-   a TREE_TYPE is returned; otherwise, a TYPE_DECL is returned.\n+   Returns a representation of the type-specifier.  For a\n+   class-specifier, enum-specifier, or elaborated-type-specifier, a\n+   TREE_TYPE is returned; otherwise, a TYPE_DECL is returned.\n \n    If IS_FRIEND is TRUE then this type-specifier is being declared a\n    `friend'.  If IS_DECLARATION is TRUE, then this type-specifier is\n@@ -9169,14 +9207,15 @@ cp_parser_explicit_specialization (cp_parser* parser)\n static tree\n cp_parser_type_specifier (cp_parser* parser,\n \t\t\t  cp_parser_flags flags,\n-\t\t\t  bool is_friend,\n+\t\t\t  cp_decl_specifier_seq *decl_specs,\n \t\t\t  bool is_declaration,\n \t\t\t  int* declares_class_or_enum,\n \t\t\t  bool* is_cv_qualifier)\n {\n   tree type_spec = NULL_TREE;\n   cp_token *token;\n   enum rid keyword;\n+  cp_decl_spec ds = ds_last;\n \n   /* Assume this type-specifier does not declare a new type.  */\n   if (declares_class_or_enum)\n@@ -9212,47 +9251,75 @@ cp_parser_type_specifier (cp_parser* parser,\n \t{\n \t  if (declares_class_or_enum)\n \t    *declares_class_or_enum = 2;\n+\t  if (decl_specs)\n+\t    cp_parser_set_decl_spec_type (decl_specs,\n+\t\t\t\t\t  type_spec,\n+\t\t\t\t\t  /*user_defined_p=*/true);\n \t  return type_spec;\n \t}\n \n       /* Fall through.  */\n \n     case RID_TYPENAME:\n       /* Look for an elaborated-type-specifier.  */\n-      type_spec = cp_parser_elaborated_type_specifier (parser,\n-\t\t\t\t\t\t       is_friend,\n-\t\t\t\t\t\t       is_declaration);\n+      type_spec \n+\t= (cp_parser_elaborated_type_specifier \n+\t   (parser,\n+\t    decl_specs && decl_specs->specs[(int) ds_friend],\n+\t    is_declaration));\n       /* We're declaring a class or enum -- unless we're using\n \t `typename'.  */\n       if (declares_class_or_enum && keyword != RID_TYPENAME)\n \t*declares_class_or_enum = 1;\n+      if (decl_specs)\n+\tcp_parser_set_decl_spec_type (decl_specs,\n+\t\t\t\t      type_spec,\n+\t\t\t\t      /*user_defined_p=*/true);\n       return type_spec;\n \n     case RID_CONST:\n+      ds = ds_const;\n+      if (is_cv_qualifier)\n+\t*is_cv_qualifier = true;\n+      break;\n+      \n     case RID_VOLATILE:\n-    case RID_RESTRICT:\n-      type_spec = cp_parser_cv_qualifier_opt (parser);\n-      /* Even though we call a routine that looks for an optional\n-\t qualifier, we know that there should be one.  */\n-      my_friendly_assert (type_spec != NULL, 20000328);\n-      /* This type-specifier was a cv-qualified.  */\n+      ds = ds_volatile;\n       if (is_cv_qualifier)\n \t*is_cv_qualifier = true;\n+      break;\n \n-      return type_spec;\n+    case RID_RESTRICT:\n+      ds = ds_restrict;\n+      if (is_cv_qualifier)\n+\t*is_cv_qualifier = true;\n+      break;\n \n     case RID_COMPLEX:\n       /* The `__complex__' keyword is a GNU extension.  */\n-      return cp_lexer_consume_token (parser->lexer)->value;\n+      ds = ds_complex;\n+      break;\n \n     default:\n       break;\n     }\n \n+  /* Handle simple keywords.  */\n+  if (ds != ds_last)\n+    {\n+      if (decl_specs)\n+\t{\n+\t  ++decl_specs->specs[(int)ds];\n+\t  decl_specs->any_specifiers_p = true;\n+\t}\n+      return cp_lexer_consume_token (parser->lexer)->value;\n+    }\n+\n   /* If we do not already have a type-specifier, assume we are looking\n      at a simple-type-specifier.  */\n-  type_spec = cp_parser_simple_type_specifier (parser, flags,\n-\t\t\t\t\t       /*identifier_p=*/true);\n+  type_spec = cp_parser_simple_type_specifier (parser, \n+\t\t\t\t\t       decl_specs,\n+\t\t\t\t\t       flags);\n \n   /* If we didn't find a type-specifier, and a type-specifier was not\n      optional in this context, issue an error message.  */\n@@ -9288,14 +9355,13 @@ cp_parser_type_specifier (cp_parser* parser,\n      __typeof__ unary-expression\n      __typeof__ ( type-id )\n \n-   For the various keywords, the value returned is simply the\n-   TREE_IDENTIFIER representing the keyword if IDENTIFIER_P is true.\n-   For the first two productions, and if IDENTIFIER_P is false, the\n-   value returned is the indicated TYPE_DECL.  */\n+   Returns the indicated TYPE_DECL.  If DECL_SPECS is not NULL, it is\n+   appropriately updated.  */\n \n static tree\n-cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n-\t\t\t\t bool identifier_p)\n+cp_parser_simple_type_specifier (cp_parser* parser, \n+\t\t\t\t cp_decl_specifier_seq *decl_specs,\n+\t\t\t\t cp_parser_flags flags)\n {\n   tree type = NULL_TREE;\n   cp_token *token;\n@@ -9307,6 +9373,8 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n   switch (token->keyword)\n     {\n     case RID_CHAR:\n+      if (decl_specs)\n+\tdecl_specs->explicit_char_p = true;\n       type = char_type_node;\n       break;\n     case RID_WCHAR:\n@@ -9316,18 +9384,28 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n       type = boolean_type_node;\n       break;\n     case RID_SHORT:\n+      if (decl_specs)\n+\t++decl_specs->specs[(int) ds_short];\n       type = short_integer_type_node;\n       break;\n     case RID_INT:\n+      if (decl_specs)\n+\tdecl_specs->explicit_int_p = true;\n       type = integer_type_node;\n       break;\n     case RID_LONG:\n+      if (decl_specs)\n+\t++decl_specs->specs[(int) ds_long];\n       type = long_integer_type_node;\n       break;\n     case RID_SIGNED:\n+      if (decl_specs)\n+\t++decl_specs->specs[(int) ds_signed];\n       type = integer_type_node;\n       break;\n     case RID_UNSIGNED:\n+      if (decl_specs)\n+\t++decl_specs->specs[(int) ds_unsigned];\n       type = unsigned_type_node;\n       break;\n     case RID_FLOAT:\n@@ -9341,19 +9419,19 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n       break;\n \n     case RID_TYPEOF:\n-      {\n-\ttree operand;\n-\n-\t/* Consume the `typeof' token.  */\n-\tcp_lexer_consume_token (parser->lexer);\n-\t/* Parse the operand to `typeof'.  */\n-\toperand = cp_parser_sizeof_operand (parser, RID_TYPEOF);\n-\t/* If it is not already a TYPE, take its type.  */\n-\tif (!TYPE_P (operand))\n-\t  operand = finish_typeof (operand);\n-\n-\treturn operand;\n-      }\n+      /* Consume the `typeof' token.  */\n+      cp_lexer_consume_token (parser->lexer);\n+      /* Parse the operand to `typeof'.  */\n+      type = cp_parser_sizeof_operand (parser, RID_TYPEOF);\n+      /* If it is not already a TYPE, take its type.  */\n+      if (!TYPE_P (type))\n+\ttype = finish_typeof (type);\n+\n+      if (decl_specs)\n+\tcp_parser_set_decl_spec_type (decl_specs, type,\n+\t\t\t\t      /*user_defined_p=*/true);\n+\t\n+      return type;\n \n     default:\n       break;\n@@ -9364,6 +9442,18 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n     {\n       tree id;\n \n+      /* Record the type.  */\n+      if (decl_specs\n+\t  && (token->keyword != RID_SIGNED\n+\t      && token->keyword != RID_UNSIGNED\n+\t      && token->keyword != RID_SHORT\n+\t      && token->keyword != RID_LONG))\n+\tcp_parser_set_decl_spec_type (decl_specs, \n+\t\t\t\t      type,\n+\t\t\t\t      /*user_defined=*/false);\n+      if (decl_specs)\n+\tdecl_specs->any_specifiers_p = true;\n+\n       /* Consume the token.  */\n       id = cp_lexer_consume_token (parser->lexer)->value;\n \n@@ -9372,7 +9462,7 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n \t that the type was a template.  */\n       cp_parser_check_for_invalid_template_id (parser, type);\n \n-      return identifier_p ? id : TYPE_NAME (type);\n+      return TYPE_NAME (type);\n     }\n \n   /* The type-specifier must be a user-defined type.  */\n@@ -9427,6 +9517,9 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n       if ((flags & CP_PARSER_FLAGS_OPTIONAL)\n \t  && !cp_parser_parse_definitely (parser))\n \ttype = NULL_TREE;\n+      if (type && decl_specs)\n+\tcp_parser_set_decl_spec_type (decl_specs, type,\n+\t\t\t\t      /*user_defined=*/true);\n     }\n \n   /* If we didn't get a type-name, issue an error message.  */\n@@ -10370,15 +10463,15 @@ cp_parser_asm_definition (cp_parser* parser)\n \n static tree\n cp_parser_init_declarator (cp_parser* parser,\n-\t\t\t   tree decl_specifiers,\n-\t\t\t   tree prefix_attributes,\n+\t\t\t   cp_decl_specifier_seq *decl_specifiers,\n \t\t\t   bool function_definition_allowed_p,\n \t\t\t   bool member_p,\n \t\t\t   int declares_class_or_enum,\n \t\t\t   bool* function_definition_p)\n {\n   cp_token *token;\n   cp_declarator *declarator;\n+  tree prefix_attributes;\n   tree attributes;\n   tree asm_specification;\n   tree initializer;\n@@ -10391,6 +10484,11 @@ cp_parser_init_declarator (cp_parser* parser,\n   bool friend_p;\n   bool pop_p = false;\n \n+  /* Gather the attributes that were provided with the\n+     decl-specifiers.  */\n+  prefix_attributes = decl_specifiers->attributes;\n+  decl_specifiers->attributes = NULL_TREE;\n+\n   /* Assume that this is not the declarator for a function\n      definition.  */\n   if (function_definition_p)\n@@ -10485,7 +10583,7 @@ cp_parser_init_declarator (cp_parser* parser,\n      We explicitly postpone this check past the point where we handle\n      function-definitions because we tolerate function-definitions\n      that are missing their return types in some modes.  */\n-  if (!decl_specifiers && ctor_dtor_or_conv_p <= 0)\n+  if (!decl_specifiers->any_specifiers_p && ctor_dtor_or_conv_p <= 0)\n     {\n       cp_parser_error (parser,\n \t\t       \"expected constructor, destructor, or type conversion\");\n@@ -10514,11 +10612,11 @@ cp_parser_init_declarator (cp_parser* parser,\n      sure this was intended to be a declarator.  Then continue\n      declaring the variable(s), as int, to try to cut down on further\n      errors.  */\n-  if (decl_specifiers != NULL\n-      && TREE_VALUE (decl_specifiers) == error_mark_node)\n+  if (decl_specifiers->any_specifiers_p\n+      && decl_specifiers->type == error_mark_node)\n     {\n       cp_parser_error (parser, \"invalid type in declaration\");\n-      TREE_VALUE (decl_specifiers) = integer_type_node;\n+      decl_specifiers->type = integer_type_node;\n     }\n \n   /* Check to see whether or not this declaration is a friend.  */\n@@ -10535,9 +10633,7 @@ cp_parser_init_declarator (cp_parser* parser,\n     {\n       if (parser->in_unbraced_linkage_specification_p)\n \t{\n-\t  decl_specifiers = tree_cons (error_mark_node,\n-\t\t\t\t       get_identifier (\"extern\"),\n-\t\t\t\t       decl_specifiers);\n+\t  decl_specifiers->storage_class = sc_extern;\n \t  have_extern_spec = false;\n \t}\n       decl = start_decl (declarator, decl_specifiers,\n@@ -11331,13 +11427,12 @@ cp_parser_declarator_id (cp_parser* parser)\n static tree\n cp_parser_type_id (cp_parser* parser)\n {\n-  tree type_specifier_seq;\n+  cp_decl_specifier_seq type_specifier_seq;\n   cp_declarator *abstract_declarator;\n \n   /* Parse the type-specifier-seq.  */\n-  type_specifier_seq\n-    = cp_parser_type_specifier_seq (parser);\n-  if (type_specifier_seq == error_mark_node)\n+  cp_parser_type_specifier_seq (parser, &type_specifier_seq);\n+  if (type_specifier_seq.type == error_mark_node)\n     return error_mark_node;\n \n   /* There might or might not be an abstract declarator.  */\n@@ -11350,7 +11445,7 @@ cp_parser_type_id (cp_parser* parser)\n   if (!cp_parser_parse_definitely (parser))\n     abstract_declarator = NULL;\n \n-  return groktypename (type_specifier_seq, abstract_declarator);\n+  return groktypename (&type_specifier_seq, abstract_declarator);\n }\n \n /* Parse a type-specifier-seq.\n@@ -11363,14 +11458,16 @@ cp_parser_type_id (cp_parser* parser)\n    type-specifier-seq:\n      attributes type-specifier-seq [opt]\n \n-   Returns a TREE_LIST.  Either the TREE_VALUE of each node is a\n-   type-specifier, or the TREE_PURPOSE is a list of attributes.  */\n+   Sets *TYPE_SPECIFIER_SEQ to represent the sequence.  */\n \n-static tree\n-cp_parser_type_specifier_seq (cp_parser* parser)\n+static void\n+cp_parser_type_specifier_seq (cp_parser* parser,\n+\t\t\t      cp_decl_specifier_seq *type_specifier_seq)\n {\n   bool seen_type_specifier = false;\n-  tree type_specifier_seq = NULL_TREE;\n+\n+  /* Clear the TYPE_SPECIFIER_SEQ.  */\n+  clear_decl_specs (type_specifier_seq);\n \n   /* Parse the type-specifiers and attributes.  */\n   while (true)\n@@ -11380,39 +11477,36 @@ cp_parser_type_specifier_seq (cp_parser* parser)\n       /* Check for attributes first.  */\n       if (cp_lexer_next_token_is_keyword (parser->lexer, RID_ATTRIBUTE))\n \t{\n-\t  type_specifier_seq = tree_cons (cp_parser_attributes_opt (parser),\n-\t\t\t\t\t  NULL_TREE,\n-\t\t\t\t\t  type_specifier_seq);\n+\t  type_specifier_seq->attributes = \n+\t    chainon (type_specifier_seq->attributes,\n+\t\t     cp_parser_attributes_opt (parser));\n \t  continue;\n \t}\n \n-      /* After the first type-specifier, others are optional.  */\n-      if (seen_type_specifier)\n-\tcp_parser_parse_tentatively (parser);\n       /* Look for the type-specifier.  */\n       type_specifier = cp_parser_type_specifier (parser,\n-\t\t\t\t\t\t CP_PARSER_FLAGS_NONE,\n-\t\t\t\t\t\t /*is_friend=*/false,\n+\t\t\t\t\t\t CP_PARSER_FLAGS_OPTIONAL,\n+\t\t\t\t\t\t type_specifier_seq,\n \t\t\t\t\t\t /*is_declaration=*/false,\n \t\t\t\t\t\t NULL,\n \t\t\t\t\t\t NULL);\n       /* If the first type-specifier could not be found, this is not a\n \t type-specifier-seq at all.  */\n-      if (!seen_type_specifier && type_specifier == error_mark_node)\n-\treturn error_mark_node;\n+      if (!seen_type_specifier && !type_specifier)\n+\t{\n+\t  cp_parser_error (parser, \"expected type-specifier\");\n+\t  type_specifier_seq->type = error_mark_node;\n+\t  return;\n+\t}\n       /* If subsequent type-specifiers could not be found, the\n \t type-specifier-seq is complete.  */\n-      else if (seen_type_specifier && !cp_parser_parse_definitely (parser))\n+      else if (seen_type_specifier && !type_specifier)\n \tbreak;\n \n-      /* Add the new type-specifier to the list.  */\n-      type_specifier_seq\n-\t= tree_cons (NULL_TREE, type_specifier, type_specifier_seq);\n       seen_type_specifier = true;\n     }\n \n-  /* We built up the list in reverse order.  */\n-  return nreverse (type_specifier_seq);\n+  return;\n }\n \n /* Parse a parameter-declaration-clause.\n@@ -11625,8 +11719,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n {\n   int declares_class_or_enum;\n   bool greater_than_is_operator_p;\n-  tree decl_specifiers;\n-  tree attributes;\n+  cp_decl_specifier_seq decl_specifiers;\n   cp_declarator *declarator;\n   tree default_argument;\n   cp_token *token;\n@@ -11648,11 +11741,10 @@ cp_parser_parameter_declaration (cp_parser *parser,\n     = \"types may not be defined in parameter types\";\n \n   /* Parse the declaration-specifiers.  */\n-  decl_specifiers\n-    = cp_parser_decl_specifier_seq (parser,\n-\t\t\t\t    CP_PARSER_FLAGS_NONE,\n-\t\t\t\t    &attributes,\n-\t\t\t\t    &declares_class_or_enum);\n+  cp_parser_decl_specifier_seq (parser,\n+\t\t\t\tCP_PARSER_FLAGS_NONE,\n+\t\t\t\t&decl_specifiers,\n+\t\t\t\t&declares_class_or_enum);\n   /* If an error occurred, there's no reason to attempt to parse the\n      rest of the declaration.  */\n   if (cp_parser_error_occurred (parser))\n@@ -11705,7 +11797,9 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t\t\t\t\t parenthesized_p);\n       parser->default_arg_ok_p = saved_default_arg_ok_p;\n       /* After the declarator, allow more attributes.  */\n-      attributes = chainon (attributes, cp_parser_attributes_opt (parser));\n+      decl_specifiers.attributes\n+\t= chainon (decl_specifiers.attributes, \n+\t\t   cp_parser_attributes_opt (parser));\n     }\n \n   /* The restriction on defining new types applies only to the type\n@@ -11846,11 +11940,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n   else\n     default_argument = NULL_TREE;\n \n-  /* Create the representation of the parameter.  */\n-  if (attributes)\n-    decl_specifiers = tree_cons (attributes, NULL_TREE, decl_specifiers);\n-\n-  return make_parameter_declarator (decl_specifiers,\n+  return make_parameter_declarator (&decl_specifiers,\n \t\t\t\t    declarator,\n \t\t\t\t    default_argument);\n }\n@@ -12809,7 +12899,7 @@ cp_parser_member_specification_opt (cp_parser* parser)\n static void\n cp_parser_member_declaration (cp_parser* parser)\n {\n-  tree decl_specifiers;\n+  cp_decl_specifier_seq decl_specifiers;\n   tree prefix_attributes;\n   tree decl;\n   int declares_class_or_enum;\n@@ -12847,11 +12937,12 @@ cp_parser_member_declaration (cp_parser* parser)\n     }\n \n   /* Parse the decl-specifier-seq.  */\n-  decl_specifiers\n-    = cp_parser_decl_specifier_seq (parser,\n-\t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n-\t\t\t\t    &prefix_attributes,\n-\t\t\t\t    &declares_class_or_enum);\n+  cp_parser_decl_specifier_seq (parser,\n+\t\t\t\tCP_PARSER_FLAGS_OPTIONAL,\n+\t\t\t\t&decl_specifiers,\n+\t\t\t\t&declares_class_or_enum);\n+  prefix_attributes = decl_specifiers.attributes;\n+  decl_specifiers.attributes = NULL_TREE;\n   /* Check for an invalid type-name.  */\n   if (cp_parser_parse_and_diagnose_invalid_type_name (parser))\n     return;\n@@ -12868,7 +12959,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \n \t Each member-declaration shall declare at least one member\n \t name of the class.  */\n-      if (!decl_specifiers)\n+      if (!decl_specifiers.any_specifiers_p)\n \t{\n \t  if (pedantic)\n \t    pedwarn (\"extra semicolon\");\n@@ -12878,10 +12969,10 @@ cp_parser_member_declaration (cp_parser* parser)\n \t  tree type;\n \n \t  /* See if this declaration is a friend.  */\n-\t  friend_p = cp_parser_friend_p (decl_specifiers);\n+\t  friend_p = cp_parser_friend_p (&decl_specifiers);\n \t  /* If there were decl-specifiers, check to see if there was\n \t     a class-declaration.  */\n-\t  type = check_tag_decl (decl_specifiers);\n+\t  type = check_tag_decl (&decl_specifiers);\n \t  /* Nested classes have already been added to the class, but\n \t     a `friend' needs to be explicitly registered.  */\n \t  if (friend_p)\n@@ -12898,27 +12989,10 @@ cp_parser_member_declaration (cp_parser* parser)\n \n \t\t  A<T>::B will be represented by a TYPENAME_TYPE, and\n \t\t  therefore not recognized by check_tag_decl.  */\n-\t       if (!type)\n-\t\t {\n-\t\t   tree specifier;\n-\n-\t\t   for (specifier = decl_specifiers;\n-\t\t\tspecifier;\n-\t\t\tspecifier = TREE_CHAIN (specifier))\n-\t\t     {\n-\t\t       tree s = TREE_VALUE (specifier);\n-\n-\t\t       if (TREE_CODE (s) == IDENTIFIER_NODE)\n-                         get_global_value_if_present (s, &type);\n-\t\t       if (TREE_CODE (s) == TYPE_DECL)\n-\t\t\t s = TREE_TYPE (s);\n-\t\t       if (TYPE_P (s))\n-\t\t\t {\n-\t\t\t   type = s;\n-\t\t\t   break;\n-\t\t\t }\n-\t\t     }\n-\t\t }\n+\t       if (!type \n+\t\t   && decl_specifiers.type\n+\t\t   && TYPE_P (decl_specifiers.type))\n+\t\t type = decl_specifiers.type;\n \t       if (!type || !TYPE_P (type))\n \t\t error (\"friend declaration does not name a class or \"\n \t\t\t\"function\");\n@@ -12928,7 +13002,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t    }\n \t  /* If there is no TYPE, an error message will already have\n \t     been issued.  */\n-\t  else if (!type)\n+\t  else if (!type || type == error_mark_node)\n \t    ;\n \t  /* An anonymous aggregate has to be handled specially; such\n \t     a declaration really declares a data member (with a\n@@ -12950,7 +13024,7 @@ cp_parser_member_declaration (cp_parser* parser)\n   else\n     {\n       /* See if these declarations will be friends.  */\n-      friend_p = cp_parser_friend_p (decl_specifiers);\n+      friend_p = cp_parser_friend_p (&decl_specifiers);\n \n       /* Keep going until we hit the `;' at the end of the\n \t declaration.  */\n@@ -12999,7 +13073,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      decl = grokbitfield (identifier \n \t\t\t\t   ? make_id_declarator (identifier)\n \t\t\t\t   : NULL,\n-\t\t\t\t   decl_specifiers,\n+\t\t\t\t   &decl_specifiers,\n \t\t\t\t   width);\n \t      /* Apply the attributes.  */\n \t      cplus_decl_attributes (&decl, attributes, /*flags=*/0);\n@@ -13095,7 +13169,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t  if (initializer)\n \t\t    error (\"pure-specifier on function-definition\");\n \t\t  decl = cp_parser_save_member_function_body (parser,\n-\t\t\t\t\t\t\t      decl_specifiers,\n+\t\t\t\t\t\t\t      &decl_specifiers,\n \t\t\t\t\t\t\t      declarator,\n \t\t\t\t\t\t\t      attributes);\n \t\t  /* If the member was not a friend, declare it here.  */\n@@ -13111,7 +13185,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      else\n \t\t{\n \t\t  /* Create the declaration.  */\n-\t\t  decl = grokfield (declarator, decl_specifiers,\n+\t\t  decl = grokfield (declarator, &decl_specifiers,\n \t\t\t\t    initializer, asm_specification,\n \t\t\t\t    attributes);\n \t\t  /* Any initialization must have been from a\n@@ -13607,7 +13681,7 @@ static tree\n cp_parser_exception_declaration (cp_parser* parser)\n {\n   tree decl;\n-  tree type_specifiers;\n+  cp_decl_specifier_seq type_specifiers;\n   cp_declarator *declarator;\n   const char *saved_message;\n \n@@ -13625,7 +13699,7 @@ cp_parser_exception_declaration (cp_parser* parser)\n     = \"types may not be defined in exception-declarations\";\n \n   /* Parse the type-specifier-seq.  */\n-  type_specifiers = cp_parser_type_specifier_seq (parser);\n+  cp_parser_type_specifier_seq (parser, &type_specifiers);\n   /* If it's a `)', then there is no declarator.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n     declarator = NULL;\n@@ -13637,9 +13711,9 @@ cp_parser_exception_declaration (cp_parser* parser)\n   /* Restore the saved message.  */\n   parser->type_definition_forbidden_message = saved_message;\n \n-  if (type_specifiers)\n+  if (type_specifiers.any_specifiers_p)\n     {\n-      decl = grokdeclarator (declarator, type_specifiers, CATCHPARM, 1, NULL);\n+      decl = grokdeclarator (declarator, &type_specifiers, CATCHPARM, 1, NULL);\n       if (decl == NULL_TREE)\n \terror (\"invalid catch parameter\");\n     }\n@@ -14628,7 +14702,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t  /* Look for the type-specifier.  */\n \t  cp_parser_type_specifier (parser,\n \t\t\t\t    CP_PARSER_FLAGS_NONE,\n-\t\t\t\t    /*is_friend=*/false,\n+\t\t\t\t    /*decl_specs=*/NULL,\n \t\t\t\t    /*is_declarator=*/true,\n \t\t\t\t    /*declares_class_or_enum=*/NULL,\n \t\t\t\t    /*is_cv_qualifier=*/NULL);\n@@ -14660,7 +14734,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n static tree\n cp_parser_function_definition_from_specifiers_and_declarator\n   (cp_parser* parser,\n-   tree decl_specifiers,\n+   cp_decl_specifier_seq *decl_specifiers,\n    tree attributes,\n    const cp_declarator *declarator)\n {\n@@ -14859,22 +14933,20 @@ cp_parser_single_declaration (cp_parser* parser,\n {\n   int declares_class_or_enum;\n   tree decl = NULL_TREE;\n-  tree decl_specifiers;\n-  tree attributes;\n+  cp_decl_specifier_seq decl_specifiers;\n   bool function_definition_p = false;\n \n   /* Defer access checks until we know what is being declared.  */\n   push_deferring_access_checks (dk_deferred);\n \n   /* Try the `decl-specifier-seq [opt] init-declarator [opt]'\n      alternative.  */\n-  decl_specifiers\n-    = cp_parser_decl_specifier_seq (parser,\n-\t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n-\t\t\t\t    &attributes,\n-\t\t\t\t    &declares_class_or_enum);\n+  cp_parser_decl_specifier_seq (parser,\n+\t\t\t\tCP_PARSER_FLAGS_OPTIONAL,\n+\t\t\t\t&decl_specifiers,\n+\t\t\t\t&declares_class_or_enum);\n   if (friend_p)\n-    *friend_p = cp_parser_friend_p (decl_specifiers);\n+    *friend_p = cp_parser_friend_p (&decl_specifiers);\n   /* Gather up the access checks that occurred the\n      decl-specifier-seq.  */\n   stop_deferring_access_checks ();\n@@ -14884,8 +14956,8 @@ cp_parser_single_declaration (cp_parser* parser,\n     {\n       if (cp_parser_declares_only_class_p (parser))\n \t{\n-\t  decl = shadow_tag (decl_specifiers);\n-\t  if (decl)\n+\t  decl = shadow_tag (&decl_specifiers);\n+\t  if (decl && decl != error_mark_node)\n \t    decl = TYPE_NAME (decl);\n \t  else\n \t    decl = error_mark_node;\n@@ -14900,10 +14972,9 @@ cp_parser_single_declaration (cp_parser* parser,\n      In that case, there's no need to warn about a missing declarator.  */\n   if (!decl\n       && (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON)\n-\t  || !value_member (error_mark_node, decl_specifiers)))\n+\t  || decl_specifiers.type != error_mark_node))\n     decl = cp_parser_init_declarator (parser,\n-\t\t\t\t      decl_specifiers,\n-\t\t\t\t      attributes,\n+\t\t\t\t      &decl_specifiers,\n \t\t\t\t      /*function_definition_allowed_p=*/true,\n \t\t\t\t      member_p,\n \t\t\t\t      declares_class_or_enum,\n@@ -14966,7 +15037,7 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n \n static tree\n cp_parser_save_member_function_body (cp_parser* parser,\n-\t\t\t\t     tree decl_specifiers,\n+\t\t\t\t     cp_decl_specifier_seq *decl_specifiers,\n \t\t\t\t     cp_declarator *declarator,\n \t\t\t\t     tree attributes)\n {\n@@ -15304,14 +15375,15 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n       /* If all went well, then we're done.  */\n       if (cp_parser_parse_definitely (parser))\n \t{\n-\t  /* Build a list of decl-specifiers; right now, we have only\n-\t     a single type-specifier.  */\n-\t  type = build_tree_list (NULL_TREE,\n-\t\t\t\t  type);\n+\t  cp_decl_specifier_seq decl_specs;\n+\n+\t  /* Build a trivial decl-specifier-seq.  */\n+\t  clear_decl_specs (&decl_specs);\n+\t  decl_specs.type = type;\n \n \t  /* Call grokdeclarator to figure out what type this is.  */\n \t  expr = grokdeclarator (NULL,\n-\t\t\t\t type,\n+\t\t\t\t &decl_specs,\n \t\t\t\t TYPENAME,\n \t\t\t\t /*initialized=*/0,\n \t\t\t\t /*attrlist=*/NULL);\n@@ -15345,24 +15417,49 @@ cp_parser_declares_only_class_p (cp_parser *parser)\n \t  || cp_lexer_next_token_is (parser->lexer, CPP_COMMA));\n }\n \n-/* DECL_SPECIFIERS is the representation of a decl-specifier-seq.\n-   Returns TRUE iff `friend' appears among the DECL_SPECIFIERS.  */\n+/* Update the DECL_SPECS to reflect the STORAGE_CLASS.  */\n \n-static bool\n-cp_parser_friend_p (tree decl_specifiers)\n+static void\n+cp_parser_set_storage_class (cp_decl_specifier_seq *decl_specs,\n+\t\t\t     cp_storage_class storage_class)\n {\n-  while (decl_specifiers)\n-    {\n-      /* See if this decl-specifier is `friend'.  */\n-      if (TREE_CODE (TREE_VALUE (decl_specifiers)) == IDENTIFIER_NODE\n-\t  && C_RID_CODE (TREE_VALUE (decl_specifiers)) == RID_FRIEND)\n-\treturn true;\n+  if (decl_specs->storage_class != sc_none)\n+    decl_specs->multiple_storage_classes_p = true;\n+  else\n+    decl_specs->storage_class = storage_class;\n+}\n+\n+/* Update the DECL_SPECS to reflect the TYPE_SPEC.  If USER_DEFINED_P\n+   is true, the type is a user-defined type; otherwise it is a\n+   built-in type specified by a keyword.  */\n \n-      /* Go on to the next decl-specifier.  */\n-      decl_specifiers = TREE_CHAIN (decl_specifiers);\n+static void\n+cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,\n+\t\t\t      tree type_spec,\n+\t\t\t      bool user_defined_p)\n+{\n+  decl_specs->any_specifiers_p = true;\n+  if (decl_specs->type)\n+    {\n+      if (decl_specs->specs[(int)ds_typedef] && !user_defined_p)\n+\tdecl_specs->redefined_builtin_type = type_spec;\n+      else\n+\tdecl_specs->multiple_types_p = true;\n+    }\n+  else\n+    {\n+      decl_specs->type = type_spec;\n+      decl_specs->user_defined_type_p = user_defined_p;\n     }\n+}\n \n-  return false;\n+/* DECL_SPECIFIERS is the representation of a decl-specifier-seq.\n+   Returns TRUE iff `friend' appears among the DECL_SPECIFIERS.  */\n+\n+static bool\n+cp_parser_friend_p (const cp_decl_specifier_seq *decl_specifiers)\n+{\n+  return decl_specifiers->specs[(int) ds_friend] != 0;\n }\n \n /* If the next token is of the indicated TYPE, consume it.  Otherwise,"}, {"sha": "da2b306af7757663e445bee1c95b95ab81c7879b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=62d1db179e700aeb45e805aa81de54036745f93e", "patch": "@@ -36,7 +36,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"cp-tree.h\"\n #include \"tree-inline.h\"\n #include \"decl.h\"\n-#include \"lex.h\"\n #include \"output.h\"\n #include \"except.h\"\n #include \"toplev.h\""}, {"sha": "c9f66d9dc1c1f52274f3c5dfa11efc97438a65b5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d1db179e700aeb45e805aa81de54036745f93e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=62d1db179e700aeb45e805aa81de54036745f93e", "patch": "@@ -34,7 +34,6 @@\n #include \"tree-inline.h\"\n #include \"tree-mudflap.h\"\n #include \"except.h\"\n-#include \"lex.h\"\n #include \"toplev.h\"\n #include \"flags.h\"\n #include \"rtl.h\"\n@@ -2147,36 +2146,6 @@ finish_member_declaration (tree decl)\n     }\n }\n \n-/* Finish processing the declaration of a member class template\n-   TYPES whose template parameters are given by PARMS.  */\n-\n-tree\n-finish_member_class_template (tree types)\n-{\n-  tree t;\n-\n-  /* If there are declared, but undefined, partial specializations\n-     mixed in with the typespecs they will not yet have passed through\n-     maybe_process_partial_specialization, so we do that here.  */\n-  for (t = types; t != NULL_TREE; t = TREE_CHAIN (t))\n-    if (IS_AGGR_TYPE_CODE (TREE_CODE (TREE_VALUE (t))))\n-      maybe_process_partial_specialization (TREE_VALUE (t));\n-\n-  grok_x_components (types);\n-  if (TYPE_CONTEXT (TREE_VALUE (types)) != current_class_type)\n-    /* The component was in fact a friend declaration.  We avoid\n-       finish_member_template_decl performing certain checks by\n-       unsetting TYPES.  */\n-    types = NULL_TREE;\n-  \n-  finish_member_template_decl (types);\n-\n-  /* As with other component type declarations, we do\n-     not store the new DECL on the list of\n-     component_decls.  */\n-  return NULL_TREE;\n-}\n-\n /* Finish processing a complete template declaration.  The PARMS are\n    the template parameters.  */\n "}]}