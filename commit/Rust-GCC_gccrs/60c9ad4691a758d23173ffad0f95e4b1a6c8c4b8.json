{"sha": "60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBjOWFkNDY5MWE3NThkMjMxNzNmZmFkMGY5NWU0YjFhNmM4YzRiOA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2006-03-08T22:07:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2006-03-08T22:07:37Z"}, "message": "tree-vrp.c (infer_value_range): Only count pointer uses and dereferences if -fdelete-null-pointer-checks is enabled.\n\n\n\t* tree-vrp.c (infer_value_range): Only count pointer uses\n\tand dereferences if -fdelete-null-pointer-checks is enabled.\n\n\t* tree-vrp.c (find_assert_locations): Infer value ranges for\n\tsingle use pointers, but do not create ASSERT_EXPRs for them.\n\tWhen a non-null range is inferred for a pointer, backwards\n\tpropagate that range to other equivalent pointers through the\n\tuse-def chain.\n\n\t* gcc.dg/tree-ssa/20030730-1.c: No longer expected to fail.\n\t* gcc.dg/tree-ssa/20030730-2.c: No longer expected to fail.\n\t* g++.dg/tree-ssa/pr26406.C: New test.\n\nFrom-SVN: r111848", "tree": {"sha": "fe11681f27645614115303f8349df8e8836f7a42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe11681f27645614115303f8349df8e8836f7a42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/comments", "author": null, "committer": null, "parents": [{"sha": "d6c122f73bdb73f53e4ebf913e5c0e402860f429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6c122f73bdb73f53e4ebf913e5c0e402860f429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6c122f73bdb73f53e4ebf913e5c0e402860f429"}], "stats": {"total": 92, "additions": 76, "deletions": 16}, "files": [{"sha": "cacec9a1dca491d522b39c74d94faad1ba220a08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8", "patch": "@@ -1,3 +1,14 @@\n+2006-03-08  Jeff Law  <law@redhat.com>\n+\n+\t* tree-vrp.c (infer_value_range): Only count pointer uses\n+\tand dereferences if -fdelete-null-pointer-checks is enabled.\n+\n+\t* tree-vrp.c (find_assert_locations): Infer value ranges for\n+\tsingle use pointers, but do not create ASSERT_EXPRs for them.\n+\tWhen a non-null range is inferred for a pointer, backwards\n+\tpropagate that range to other equivalent pointers through the\n+\tuse-def chain.\n+\n 2006-03-08  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR bootstrap/26500"}, {"sha": "bf0df239038fa6ce92c6379849f33bb951374e88", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8", "patch": "@@ -1,3 +1,9 @@\n+2006-03-08  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/20030730-1.c: No longer expected to fail.\n+\t* gcc.dg/tree-ssa/20030730-2.c: No longer expected to fail.\n+\t* g++.dg/tree-ssa/pr26406.C: New test.\n+\n 2006-03-07  Jeff Law  <law@redhat.com>\n \n \t* gcc.dg/tree-ssa/20030730-1.c: Temporarily xfail."}, {"sha": "c2d160508a67441d07b1e0c94ca176a5d026f0a4", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr26406.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr26406.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr26406.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr26406.C?ref=60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int *f(int *b)\n+{\n+  int * a = new int[104];\n+  *a = 1;\n+  if (a == 0)\n+    return b;\n+  return a;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"if\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "ded6ef764693916a381e3d080fe30ce6a73108f0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030730-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030730-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030730-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030730-1.c?ref=60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8", "patch": "@@ -19,6 +19,6 @@ foo (int attr_kind, unsigned long offset)\n }\n \n /* There should be no IF conditionals.  */\n-/* { dg-final { scan-tree-dump-times \"if \" 0 \"dom3\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"if \" 0 \"dom3\" } } */\n                                                                                 \n /* { dg-final { cleanup-tree-dump \"dom3\" } } */"}, {"sha": "8b53d818d27ff94786a6df810e91c684e6b83a99", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030730-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030730-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030730-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030730-2.c?ref=60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8", "patch": "@@ -19,6 +19,6 @@ foo (int attr_kind, unsigned long offset)\n }\n \n /* There should be no IF conditionals.  */\n-/* { dg-final { scan-tree-dump-times \"if \" 0 \"dom3\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"if \" 0 \"dom3\" } } */\n \n /* { dg-final { cleanup-tree-dump \"dom3\" } } */"}, {"sha": "e126fea8d7d0a7c3117c0ccce46a0a6dee3c6dfe", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 43, "deletions": 14, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=60c9ad4691a758d23173ffad0f95e4b1a6c8c4b8", "patch": "@@ -2440,16 +2440,16 @@ infer_value_range (tree stmt, tree op, enum tree_code *comp_code_p, tree *val_p)\n   if (stmt_ends_bb_p (stmt) && EDGE_COUNT (bb_for_stmt (stmt)->succs) == 0)\n     return false;\n \n-  if (POINTER_TYPE_P (TREE_TYPE (op)))\n+  /* We can only assume that a pointer dereference will yield\n+     non-NULL if -fdelete-null-pointer-checks is enabled.  */\n+  if (flag_delete_null_pointer_checks && POINTER_TYPE_P (TREE_TYPE (op)))\n     {\n       bool is_store;\n       unsigned num_uses, num_derefs;\n \n       count_uses_and_derefs (op, stmt, &num_uses, &num_derefs, &is_store);\n-      if (num_derefs > 0 && flag_delete_null_pointer_checks)\n+      if (num_derefs > 0)\n \t{\n-\t  /* We can only assume that a pointer dereference will yield\n-\t     non-NULL if -fdelete-null-pointer-checks is enabled.  */\n \t  *val_p = build_int_cst (TREE_TYPE (op), 0);\n \t  *comp_code_p = NE_EXPR;\n \t  return true;\n@@ -2952,21 +2952,50 @@ find_assert_locations (basic_block bb)\n \t     operands it was looking for was present in the sub-graph.  */\n \t  SET_BIT (found_in_subgraph, SSA_NAME_VERSION (op));\n \n-\t  /* If OP is used only once, namely in this STMT, don't\n-\t     bother creating an ASSERT_EXPR for it.  Such an\n-\t     ASSERT_EXPR would do nothing but increase compile time.\n-\t     Experiments show that with this simple check, we can save\n-\t     more than 20% of ASSERT_EXPRs.  */\n-\t  if (has_single_use (op))\n-\t    continue;\n-\n \t  /* If OP is used in such a way that we can infer a value\n \t     range for it, and we don't find a previous assertion for\n \t     it, create a new assertion location node for OP.  */\n \t  if (infer_value_range (stmt, op, &comp_code, &value))\n \t    {\n-\t      register_new_assert_for (op, comp_code, value, bb, NULL, si);\n-\t      need_assert = true;\n+\t      /* If we are able to infer a non-zero value range for OP,\n+\t\t then walk backwards through the use-def chain to see if OP\n+\t\t was set via a typecast.\n+\n+\t\t If so, then we can also infer a nonzero value range\n+\t\t for the operand of the NOP_EXPR.  */\n+\t      if (comp_code == NE_EXPR && integer_zerop (value))\n+\t\t{\n+\t\t  tree t = op;\n+\t\t  tree def_stmt = SSA_NAME_DEF_STMT (t);\n+\t\n+\t\t  while (TREE_CODE (def_stmt) == MODIFY_EXPR\n+\t\t\t && TREE_CODE (TREE_OPERAND (def_stmt, 1)) == NOP_EXPR\n+\t\t\t && TREE_CODE (TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0)) == SSA_NAME\n+\t\t\t && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0))))\n+\t\t    {\n+\t\t      t = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0);\n+\t\t      def_stmt = SSA_NAME_DEF_STMT (t);\n+\n+\t\t      /* Note we want to register the assert for the\n+\t\t\t operand of the NOP_EXPR after SI, not after the\n+\t\t\t conversion.  */\n+\t\t      if (! has_single_use (t))\n+\t\t\t{\n+\t\t\t  register_new_assert_for (t, comp_code, value,\n+\t\t\t\t\t\t   bb, NULL, si);\n+\t\t\t  need_assert = true;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      /* If OP is used only once, namely in this STMT, don't\n+\t\t bother creating an ASSERT_EXPR for it.  Such an\n+\t\t ASSERT_EXPR would do nothing but increase compile time.  */\n+\t      if (!has_single_use (op))\n+\t\t{\n+\t\t  register_new_assert_for (op, comp_code, value, bb, NULL, si);\n+\t\t  need_assert = true;\n+\t\t}\n \t    }\n \t}\n "}]}