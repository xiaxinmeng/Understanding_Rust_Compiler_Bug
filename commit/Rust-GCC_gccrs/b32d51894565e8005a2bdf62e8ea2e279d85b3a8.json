{"sha": "b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMyZDUxODk0NTY1ZTgwMDVhMmJkZjYyZThlYTJlMjc5ZDg1YjNhOA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-28T21:29:38Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-28T21:29:38Z"}, "message": "NEXT_INSN and PREV_INSN take a const rtx_insn\n\ngcc/\n2014-08-28  David Malcolm  <dmalcolm@redhat.com>\n\n\t* rtl.h (RTX_PREV): Added checked casts to uses of PREV_INSN and\n\tNEXT_INSN.\n\t(PREV_INSN): Strengthen param from const_rtx to const rtx_insn *.\n\t(NEXT_INSN): Likewise.\n\t(JUMP_LABEL_AS_INSN): Add a \"const\" modifier to param.\n\t(reg_used_between_p): Strengthen params 2 and 3 from const_rtx to\n\tconst rtx_insn *.\n\t(no_labels_between_p): Likewise for both params.\n\n\t* config/aarch64/aarch64.c (aarch64_output_casesi): Add a checked\n\tcast when using NEXT_INSN on operands[2].\n\t* config/alpha/alpha.c (alpha_set_memflags): Strengthen local\n\t\"insn\" from rtx to rtx_insn *, adding a checked cast.\n\t(alpha_handle_trap_shadows): Strengthen locals \"i\", \"n\" from rtx to\n\trtx_insn *.\n\t* config/arc/arc-protos.h (arc_ccfsm_record_condition): Likewise\n\tfor third param.\n\t(arc_text_label): Likewise for param \"insn\".\n\t* config/arc/arc.c (arc_expand_epilogue): Likewise for local\n\t\"insn\".\n\t(arc_ccfsm_record_condition): Likewise for param \"jump\".\n\t(arc_text_label): Likewise for local \"label\".\n\t* config/arc/arc.md (doloop_begin_i): Likewise for local \"scan\".\n\tIntroduce a local \"seq\" via a dyn_cast to rtx_sequence *, and use\n\ta method for typesafety.  Add a checked cast.\n\t* config/arc/constraints.md (Clb): Add a checked cast when getting\n\tthe CODE_LABEL from a LABEL_REF.\n\t* config/arm/arm.c (require_pic_register): Strengthen locals\n\t\"seq\", \"insn\" from rtx to rtx_insn *.\n\t(create_fix_barrier): Likewise for locals \"selected\", \"next\".\n\t(thumb1_reorg): Likewise for locals \"prev\", \"insn\".\n\t(arm_expand_prologue): Likewise for local \"last\".\n\t(thumb1_output_casesi): Add a checked cast when using NEXT_INSN on\n\toperands[0].\n\t(thumb2_output_casesi): Likewise for operands[2].\n\t* config/avr/avr-log.c (avr_log_vadump): Within 'L' case,\n\tstrengthen local \"insn\" from rtx to rtx_insn *.\n\t* config/bfin/bfin.c (find_next_insn_start): Likewise for return\n\ttype and param \"insn\".\n\t(find_prev_insn_start): Likewise.\n\t(hwloop_optimize): Likewise for locals \"insn\", \"last_insn\",\n\t\"prev\".\n\t(gen_one_bundle): Likewise for loal \"t\".\n\t(find_load): Likewise for param \"insn\".\n\t(workaround_speculation): Likewise for locals \"insn\", \"next\",\n\t\"target\", \"next_tgt\".\n\t* config/c6x/c6x.c (assign_reservations): Likewise for both params\n\tand for locals \"insn\", \"within\", \"last\".\n\t(count_unit_reqs): Likewise for params \"head\", \"tail\" and local\n\t\"insn\".\n\t(try_rename_operands): Likewise for params \"head\", \"tail\".\n\t(reshuffle_units): Likewise for locals \"head\", \"tail\", \"insn\".\n\t(struct c6x_sched_context): Likewise for fields\n\t\"last_scheduled_insn\", \"last_scheduled_iter0\".\n\t(init_sched_state): Replace NULL_RTX with NULL.\n\t(reorg_split_calls): Strengthen local \"new_cycle_first\" from rtx\n\tto rtx_insn *.\n\t(undo_split_delayed_nonbranch): Likewise for param and for local\n\t\"prev\".\n\t(conditionalize_after_sched): Likewise for local \"insn\".\n\t(bb_earliest_end_cycle): Likewise.\n\t(filter_insns_above): Likewise for locals \"insn\", \"next\".\n\t(hwloop_optimize): Remove redundant checked cast.\n\t(hwloop_fail): Strengthen local \"t\" from rtx to rtx_insn *.\n\t* config/cris/cris.c (cris_initial_frame_pointer_offset): Replace\n\tNULL_RTX with NULL.\n\t(cris_simple_epilogue): Likewise.\n\t(cris_expand_prologue): Likewise.\n\t(cris_expand_epilogue): Likewise.\n\t* config/frv/frv.c (frv_function_contains_far_jump): Strengthen\n\tlocal \"insn\" from rtx to rtx_insn *.\n\t(frv_ifcvt_modify_tests): Likewise for locals \"last_insn\", \"insn\".\n\t(struct frv_packet_group): Likewise for the elements within array\n\tfields \"insns\", \"sorted\", and for field \"nop\".\n\t(frv_packet): Likewise for the elements within array field\n\t\"insns\".\n\t(frv_add_insn_to_packet): Likewise for param \"insn\".\n\t(frv_insert_nop_in_packet): Likewise for param \"insn\" and local\n\t\"last\".\n\t(frv_for_each_packet): Likewise for locals \"insn\", \"next_insn\".\n\t(frv_sort_insn_group_1): Likewise for local \"insn\".\n\t(frv_optimize_membar_local): Likewise.\n\t(frv_align_label): Likewise for locals \"x\", \"last\", \"barrier\",\n\t\"label\".\n\t* config/ia64/ia64.c (last_scheduled_insn): Likewise for this\n\tlocal.\n\t(ia64_sched_init): Likewise for local \"insn\".\n\t(scheduled_good_insn): Likewise for param \"last\".\n\t(struct _ia64_sched_context): Likewise for field\n\t\"last_scheduled_insn\".\n\t(ia64_init_sched_context): Replace NULL_RTX with NULL.\n\t(struct bundle_state): Likewise for field \"insn\".\n\t(issue_nops_and_insn): Likewise for param \"insn\".\n\t(get_next_important_insn): Likewise for return type and both\n\tparams.\n\t(ia64_add_bundle_selector_before): Likewise for param \"insn\".\n\t(bundling): Likewise for params \"prev_head_insn\", \"tail\" and\n\tlocals \"insn\", \"next_insn\", \"b\".  Eliminate top-level local rtx\n\t\"nop\" in favor of new locals rtx \"nop_pat\" and rtx_insn *nop;\n\t* config/iq2000/iq2000-protos.h (iq2000_fill_delay_slot):\n\tStrengthen final param from rtx to rtx_insn *.\n\t(iq2000_move_1word): Likewise for second param.\n\t* config/iq2000/iq2000.c (iq2000_fill_delay_slot): Likewise for\n\tparam \"cur_insn\" and local \"next_insn\".\n\t(iq2000_move_1word): Likewise for param \"insn\".\n\t* config/iq2000/iq2000.md (insn before ADDR_DIFF_VEC): Add checked\n\tcasts when using NEXT_INSN on operands[1].\n\t* config/m32c/m32c.c (m32c_function_needs_enter): Strengthen local\n\t\"insn\" from rtx to rtx_insn *.\n\t* config/m68k/m68k.c (m68k_jump_table_ref_p): Split out uses of\n\t\"x\", introducing local rtx_insn * \"insn\" for when working with the\n\tCODE_LABEL of the LABEL_REF.\n\t(m68k_sched_md_init_global): Strengthen local \"insn\" from rtx to\n\trtx_insn *.\n\t* config/mcore/mcore-protos.h (mcore_is_dead): Likewise for first\n\tparam.\n\t* config/mcore/mcore.c (emit_new_cond_insn): Likewise for return\n\ttype.\n\t(conditionalize_block): Likewise for return type and param.\n\t(mcore_is_dead): Likewise for param \"first\" and local \"insn\".\n\t(emit_new_cond_insn): Likewise for return type.\n\t(conditionalize_block): Likewise for return type, param, and\n\tlocals \"insn\", \"blk_1_br\", \"end_blk_2_insn\", \"start_blk_3_lab\",\n\t\"newinsn\".\n\t(conditionalize_optimization): Likewise for local \"insn\".\n\t* config/mep/mep.c (mep_jmp_return_reorg): Add checked cast when\n\tusing NEXT_INSN.\n\t* config/microblaze/microblaze.md: Add checked casts when using\n\tNEXT_INSN.\n\t* config/mips/mips.c (mips_expand_prologue): Eliminate top-level\n\trtx \"insn\" in favor of various more tightly-scoped rtx \"insn\" and\n\tand rtx_insn * \"insn\".\n\t* config/mips/mips.md (casesi_internal_mips16_<mode>): Add a\n\tchecked cast when using NEXT_INSN on operands[2].\n\t* config/mn10300/mn10300.c (mn10300_insert_setlb_lcc): Strengthen\n\tlocal \"insn\" from rtx to rtx_insn *.\n\t* config/nds32/nds32-fp-as-gp.c (nds32_fp_as_gp_check_available):\n\tLikewise.\n\t* config/nds32/nds32-md-auxiliary.c (nds32_output_casesi_pc_relative):\n\tAdd a checked cast when using NEXT_INSN on operands[1].\n\t* config/pa/pa-protos.h (pa_following_call): Strengthen param from\n\trtx to rtx_insn *.\n\t(pa_output_cbranch): Likewise for final param.\n\t(pa_output_lbranch): Likewise for second param.\n\t(pa_output_bb): Likewise for third param.\n\t(pa_output_bvb): Likewise.\n\t(pa_output_dbra): Likewise for second param.\n\t(pa_output_movb): Likewise.\n\t(pa_output_parallel_movb): Likewise.\n\t(pa_output_parallel_addb): Likewise.\n\t(pa_output_millicode_call): Likewise for first param.\n\t(pa_output_mul_insn): Likewise for second param.\n\t(pa_output_div_insn): Likewise for third param.\n\t(pa_output_mod_insn): Likewise for second param.\n\t(pa_jump_in_call_delay): Likewise for param.\n\t* config/pa/pa.c (pa_output_mul_insn): Likewise for param \"insn\".\n\t(pa_output_div_insn): Likewise.\n\t(pa_output_mod_insn): Likewise.\n\t(pa_output_cbranch): Likewise.\n\t(pa_output_lbranch): Likewise.\n\t(pa_output_bb): Likewise.\n\t(pa_output_bvb): Likewise.\n\t(pa_output_dbra): Likewise.\n\t(pa_output_movb): Likewise.\n\t(pa_output_millicode_call): Likewise; use method of rtx_sequence *\n\tto simplify and for typesafety.\n\t(pa_output_call): Use method of rtx_sequence *.\n\t(forward_branch_p): Strengthen param \"insn\" from rtx to rtx_insn *.\n\t(pa_jump_in_call_delay): Likewise.\n\t(pa_output_parallel_movb): Likewise.\n\t(pa_output_parallel_addb): Likewise.\n\t(pa_following_call): Likewise.\n\t(pa_combine_instructions): Likewise for locals \"anchor\",\n\t\"floater\".\n\t(pa_can_combine_p): Likewise for params \"anchor\", \"floater\" and\n\tlocals \"start\", \"end\".\n\t* config/picochip/picochip.c (picochip_reset_vliw): Likewise for\n\tparam \"insn\" and local \"local_insn\".\n\t(picochip_final_prescan_insn): Likewise for local \"local_insn\".\n\t* config/rs6000/rs6000.c (compute_save_world_info): Likewise for\n\tlocal \"insn\".\n\t(uses_TOC): Likewise.\n\t* config/s390/s390.c (get_some_local_dynamic_name): Likewise.\n\t(s390_mainpool_finish): Eliminate top-level local rtx \"insn\",\n\tsplitting out to more tightly-scoped locals, 3 as rtx and one as\n\trtx_insn *.\n\t(s390_optimize_nonescaping_tx): Strengthen local \"tmp\" from rtx\n\tto rtx_insn *.\n\t(s390_emit_prologue): Introduce a local \"insn\" to be an rtx_insn *\n\twhere needed.\n\t* config/sh/sh-protos.h (barrier_align): Strenghten param from rtx\n\tto rtx_insn *.\n\t(fixup_addr_diff_vecs): Likewise.\n\t(reg_unused_after): Likewise for param 2.\n\t(sh_can_redirect_branch): Likewise for both params.\n\t(check_use_sfunc_addr): Likewise for param 1.\n\t* config/sh/sh.c (fixup_mova): Likewise for local \"worker\".\n\t(find_barrier): Likewise for local \"last_got\".\n\t(gen_block_redirect): Likewise for return type, param \"jump\" and\n\tlocals \"prev\", \"scan\", \"next\", \"insn\".\n\t(struct far_branch): Likewise for fields \"near_label\",\n\t\"insert_place\", \"far_label\".\n\t(gen_far_branch): Likewise for local \"jump\".\n\t(fixup_addr_diff_vecs): Likewise for param \"first\" and locals\n\t\"insn\", \"prev\".\n\t(barrier_align): Likewise for param and for locals \"prev\", \"x\".\n\tIntroduce local rtx_sequence * \"prev_seq\" and use insn method for\n\ttypesafety and clarity.\n\t(sh_reorg): Strengthen local \"scan\" from rtx to rtx_insn *.\n\t(get_dest_uid): Likewise for local \"dest\".\n\t(split_branches): Likewise for locals \"next\", \"beyond\", \"label\",\n\t\"block\", \"far_label\".  Add checked casts when assigning to\n\tbp->far_label and \"far_label\".\n\t(reg_unused_after): Strengthen param \"scan\" from rtx to rtx_insn *.\n\t(sequence_insn_p): Likewise.\n\t(mark_constant_pool_use): Likewise for locals \"insn\", \"lab\".  Add a\n\tmore loop-scoped rtx \"insn\" when walking LABEL_REFS.\n\t(sh_can_redirect_branch): Strengthen both params from rtx to\n\trtx_insn *.\n\t(check_use_sfunc_addr): Likewise for param \"insn\".  Introduce a\n\tnew local rtx_sequence * \"seq\" via a dyn_cast, and use a method\n\tfor clarity and typesafety.\n\t* config/sh/sh.md (define_expand \"epilogue\"): Strengthen local\n\t\"insn\" from rtx to rtx_insn *.\n\t(define_insn \"casesi_worker_1\"): Add a checked cast to rtx_insn *\n\twhen using NEXT_INSN on the CODE_LABEL in operands[2].\n\t(define_insn \"casesi_worker_2\"): Likewise.\n\t(define_insn \"casesi_shift_media\"): Likewise.\n\t(define_insn \"casesi_load_media\"): Likewise for the CODE_LABEL in\n\toperands[3].\n\t* config/sh/sh_optimize_sett_clrt.cc (struct ccreg_value):\n\tStrengthen field \"insn\" from rtx to rtx_insn *.\n\t(sh_optimize_sett_clrt::execute): Likewise for locals \"next_i\", \"i\".\n\t(sh_optimize_sett_clrt::find_last_ccreg_values): Likewise for\n\tparam \"start_insn\" and local \"start_insn\".\n\t* config/sh/sh_treg_combine.cc (struct set_of_reg): Likewise for\n\tfield \"insn\".\n\t(find_set_of_reg_bb): Likewise for param \"insn\".\n\t(trace_reg_uses_1): Likewise for param \"start_insn\" and local \"i\".\n\t(trace_reg_uses): Likewise for param \"start_insn\".\n\t(sh_treg_combine::cbranch_trace): Likewise for field\n\t\"cbranch_insn\".\n\t(sh_treg_combine::cbranch_trace::cbranch_trace): Likewise for\n\tparam \"insn\".\n\t(sh_treg_combine::record_set_of_reg): Likewise for param\n\t\"start_insn\" and local \"i\".\n\t(sh_treg_combine::can_remove_cstore): Likewise for local\n\t\"prev_insn\".\n\t(sh_treg_combine::try_optimize_cbranch): Likewise for param\n\t\"insn\".\n\t(sh_treg_combine::execute): Likewise for local \"i\".\n\t* config/sparc/sparc-protos.h (empty_delay_slot): Likewise for\n\tparam.\n\t(sparc_check_64): Likewise for second param.\n\t* config/sparc/sparc.c (sparc_do_work_around_errata): Likewise for\n\tlocals \"insn\", \"next\".  Introduce local rtx_sequence * \"seq\" via a\n\tdyn_cast, using its insn method for typesafety and clarity.\n\t(empty_delay_slot): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(set_extends): Likewise.\n\t(sparc_check_64): Likewise.\n\t* config/stormy16/stormy16.c (xstormy16_split_cbranch): Likewise\n\tfor locals \"seq\", \"last_insn\".\n\t(combine_bnp): Likewise for param \"insn\".\n\t(xstormy16_reorg): Likewise for local \"insn\".\n\t* config/v850/v850.c (substitute_ep_register): Likewise for params\n\t\"first_insn\", \"last_insn\" and local \"insn\".\n\t(v850_reorg): Likewise for fields \"first_insn\", \"last_insn\" within\n\telements of \"regs\" array, and local \"insn\".\n\t* except.c (emit_note_eh_region_end): Likewise for param \"insn\".\n\t* final.c (final_sequence): Strengthen this global from rtx to\n\trtx_sequence *.\n\t(shorten_branches): Strenthen locals \"rel_lab\", \"prev\" from rtx to\n\trtx_insn *.\n\t(final_scan_insn): Update assignment to \"final_sequence\" to be\n\tfrom \"seq\", the cast version of \"body\", for type-safety.\n\t* function.c (assign_parm_setup_reg): Strengthen locals \"insn\",\n\t\"insns\" from rtx to rtx_insn *.\n\t(thread_prologue_and_epilogue_insns): Likewise for local \"seq\".\n\t* genattr.c (main): When writing out generated insn-attr.h,\n\tstrengthen params 1 and 3 of eligible_for_delay,\n\teligible_for_annul_true, eligible_for_annul_false from rtx to\n\trtx_insn *.\n\t* genattrtab.c (write_eligible_delay): Likewise when writing out\n\tgenerated insn-attrtab.c; also local \"insn\" the generated\n\tfunctions.\n\t* hw-doloop.c (discover_loops): Strengthen local \"insn\" from rtx\n\tto rtx_insn *.\n\t* hw-doloop.h (struct GTY hwloop_info_d): Strengthen field\n\t\"start_label\" from rtx to rtx_insn *.\n\t* ira.c (decrease_live_ranges_number): Likewise for local \"p\".\n\t(ira_update_equiv_info_by_shuffle_insn): Likewise for param\n\t\"insns\" and local \"insn\".\n\t(validate_equiv_mem): Likewise for param \"start\" and local \"insn\".\n\t(memref_used_between_p): Likewise for params \"start\", \"end\" and\n\tlocal \"insn\".\n\t* ira.h (ira_update_equiv_info_by_shuffle_insn): Likewise for\n\tfinal param.\n\t* loop-doloop.c (doloop_optimize): Within region guarded by\n\tINSN_P (doloop_pat), introduce a new local rtx_insn *\n\t\"doloop_insn\" via a checked cast, and use it for typesafety,\n\teventually writing the value back into doloop_pat.\n\t* output.h (final_sequence): Strengthen this global from rtx to\n\trtx_sequence *.\n\t* recog.c (peep2_attempt): Rename param \"insn\" to \"uncast_insn\",\n\treintroducing \"insn\" as an rtx_insn * via a checked cast.\n\tStrengthen param \"attempt\" and local \"new_insn\"from rtx to\n\trtx_insn *.\n\t(peephole2_optimize): Strengthen locals \"insn\", \"attempt\" from rtx\n\tto rtx_insn *.\n\t* ree.c (emit_note_eh_region_end): Likewise for local \"insn\".\n\t* reload1.c (reload_as_needed): Eliminate top-level locals \"x\" and\n\t\"p\" in favor of more tightly-scoped replacements, sometimes rtx\n\tand sometimes rtx_insn *, as appropriate.\n\t(delete_output_reload): Eliminate top-level rtx \"i1\", splitting\n\tinto two loop-scoped locals, one an rtx, the other an rtx_insn *.\n\t* reorg.c (delete_scheduled_jump): Add checked cast.  Strengthen\n\tlocal \"trial\" from rtx to rtx_insn *.\n\t(redirect_with_delay_slots_safe_p): Strengthen param \"jump\" from\n\trtx to rtx_insn *.  Strenghten local \"pat\" from rtx to\n\trtx_sequence * and use methods for clarity and typesafety.\n\t(redirect_with_delay_list_safe_p): Strengthen param \"jump\" from\n\trtx to rtx_insn *.  Strenghten local \"li\" from rtx to\n\trtx_insn_list * and use its methods for clarity and typesafety.\n\t(steal_delay_list_from_target): Strengthen param \"insn\" from rtx\n\tto rtx_insn *.\n\t(steal_delay_list_from_fallthrough): Likewise.\n\t(try_merge_delay_insns): Likewise for param \"thread\" and locals\n\t\"trial\", \"next_trial\", \"delay_insn\".\n\t(redundant_insn): Likewise for param \"target\" and local \"trial\".\n\t(own_thread_p): Likewise for param \"thread\" and locals\n\t\"active_insn\", \"insn\".\n\t(get_label_before): Likewise for param \"insn\".\n\t(fill_simple_delay_slots): Likewise for local \"new_label\"; use\n\tJUMP_LABEL_AS_INSN as necessary when calling own_thread_p.\n\t(label_before_next_insn): Strengthen return type and local \"insn\"\n\tfrom rtx to rtx_insn *.\n\t(relax_delay_slots): Likewise for locals \"other\", \"tmp\".\n\t(make_return_insns): Likewise for param \"first\" and locals \"insn\",\n\t\"jump_insn\", \"prev\".  Move declaration of \"pat\" to its assignment\n\tand strengthen from rtx to rtx_sequence *.  Use its methods for\n\tclarity and typesafety.\n\t* rtlanal.c (no_labels_between_p): Strengthen params from\n\tconst_rtx to const rtx_insn *.  Strengthen local \"p\" from rtx to\n\trtx_insn *.\n\t(reg_used_between_p): Strengthen params \"from_insn\", \"to_insn\"\n\tfrom const_rtx to const rtx_insn *.\n\t(reg_set_between_p): Rename param \"from_insn\" to\n\t\"uncast_from_insn\", and reintroduce \"from_insn\" as a\n\tconst rtx_insn * via a checked cast.\n\t(modified_between_p): Likewise for param \"start\" as \"uncast_start\".\n\t(tablejump_p): Add a cast when invoking NEXT_INSN on \"label\".\n\t* sel-sched-ir.c (get_seqno_by_preds): Strengthen param and locals\n\t\"tmp\", head\" from rtx to rtx_insn *.\n\t(recompute_rev_top_order): Likewise for local \"insn\".\n\t* sel-sched-ir.h (get_seqno_by_preds): Likewise for param.\n\t* store-motion.c (build_store_vectors): Likewise for local \"insn\".\n\tStrengthen local \"st\" from rtx to rtx_insn_list * and use methods\n\tfor clarity and typesafety.\n\t* tree-ssa-loop-ivopts.c (seq_cost): Strengthen param \"seq\" from\n\trtx to rtx_insn *.\n\t(computation_cost): Likewise for local \"seq\".\n\t(get_address_cost): Likewise.\n\n/\n2014-08-28  David Malcolm  <dmalcolm@redhat.com>\n\n\t* rtx-classes-status.txt (TODO): NEXT_INSN/PREV_INSN are done.\n\nFrom-SVN: r214698", "tree": {"sha": "2f82edef7f4faf9220745bc1e1075133b95c95f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f82edef7f4faf9220745bc1e1075133b95c95f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c5241a21a366ef5d9dc1dce486af5423e484a630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5241a21a366ef5d9dc1dce486af5423e484a630", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5241a21a366ef5d9dc1dce486af5423e484a630"}], "stats": {"total": 1278, "additions": 840, "deletions": 438}, "files": [{"sha": "6bf441a8dd43dcae1f0fa23700c3fb29d59a5d8e", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -1,3 +1,7 @@\n+2014-08-28  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* rtx-classes-status.txt (TODO): NEXT_INSN/PREV_INSN are done.\n+\n 2014-08-27  Sebastian Pop  <s.pop@samsung.com>\n \n \t* config/isl.m4 (_ISL_CHECK_CT_PROG): Removed."}, {"sha": "297b0534597577ffd7f70b369abc70395811d379", "filename": "gcc/ChangeLog", "status": "modified", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -1,3 +1,369 @@\n+2014-08-28  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* rtl.h (RTX_PREV): Added checked casts to uses of PREV_INSN and\n+\tNEXT_INSN.\n+\t(PREV_INSN): Strengthen param from const_rtx to const rtx_insn *.\n+\t(NEXT_INSN): Likewise.\n+\t(JUMP_LABEL_AS_INSN): Add a \"const\" modifier to param.\n+\t(reg_used_between_p): Strengthen params 2 and 3 from const_rtx to\n+\tconst rtx_insn *.\n+\t(no_labels_between_p): Likewise for both params.\n+\n+\t* config/aarch64/aarch64.c (aarch64_output_casesi): Add a checked\n+\tcast when using NEXT_INSN on operands[2].\n+\t* config/alpha/alpha.c (alpha_set_memflags): Strengthen local\n+\t\"insn\" from rtx to rtx_insn *, adding a checked cast.\n+\t(alpha_handle_trap_shadows): Strengthen locals \"i\", \"n\" from rtx to\n+\trtx_insn *.\n+\t* config/arc/arc-protos.h (arc_ccfsm_record_condition): Likewise\n+\tfor third param.\n+\t(arc_text_label): Likewise for param \"insn\".\n+\t* config/arc/arc.c (arc_expand_epilogue): Likewise for local\n+\t\"insn\".\n+\t(arc_ccfsm_record_condition): Likewise for param \"jump\".\n+\t(arc_text_label): Likewise for local \"label\".\n+\t* config/arc/arc.md (doloop_begin_i): Likewise for local \"scan\".\n+\tIntroduce a local \"seq\" via a dyn_cast to rtx_sequence *, and use\n+\ta method for typesafety.  Add a checked cast.\n+\t* config/arc/constraints.md (Clb): Add a checked cast when getting\n+\tthe CODE_LABEL from a LABEL_REF.\n+\t* config/arm/arm.c (require_pic_register): Strengthen locals\n+\t\"seq\", \"insn\" from rtx to rtx_insn *.\n+\t(create_fix_barrier): Likewise for locals \"selected\", \"next\".\n+\t(thumb1_reorg): Likewise for locals \"prev\", \"insn\".\n+\t(arm_expand_prologue): Likewise for local \"last\".\n+\t(thumb1_output_casesi): Add a checked cast when using NEXT_INSN on\n+\toperands[0].\n+\t(thumb2_output_casesi): Likewise for operands[2].\n+\t* config/avr/avr-log.c (avr_log_vadump): Within 'L' case,\n+\tstrengthen local \"insn\" from rtx to rtx_insn *.\n+\t* config/bfin/bfin.c (find_next_insn_start): Likewise for return\n+\ttype and param \"insn\".\n+\t(find_prev_insn_start): Likewise.\n+\t(hwloop_optimize): Likewise for locals \"insn\", \"last_insn\",\n+\t\"prev\".\n+\t(gen_one_bundle): Likewise for loal \"t\".\n+\t(find_load): Likewise for param \"insn\".\n+\t(workaround_speculation): Likewise for locals \"insn\", \"next\",\n+\t\"target\", \"next_tgt\".\n+\t* config/c6x/c6x.c (assign_reservations): Likewise for both params\n+\tand for locals \"insn\", \"within\", \"last\".\n+\t(count_unit_reqs): Likewise for params \"head\", \"tail\" and local\n+\t\"insn\".\n+\t(try_rename_operands): Likewise for params \"head\", \"tail\".\n+\t(reshuffle_units): Likewise for locals \"head\", \"tail\", \"insn\".\n+\t(struct c6x_sched_context): Likewise for fields\n+\t\"last_scheduled_insn\", \"last_scheduled_iter0\".\n+\t(init_sched_state): Replace NULL_RTX with NULL.\n+\t(reorg_split_calls): Strengthen local \"new_cycle_first\" from rtx\n+\tto rtx_insn *.\n+\t(undo_split_delayed_nonbranch): Likewise for param and for local\n+\t\"prev\".\n+\t(conditionalize_after_sched): Likewise for local \"insn\".\n+\t(bb_earliest_end_cycle): Likewise.\n+\t(filter_insns_above): Likewise for locals \"insn\", \"next\".\n+\t(hwloop_optimize): Remove redundant checked cast.\n+\t(hwloop_fail): Strengthen local \"t\" from rtx to rtx_insn *.\n+\t* config/cris/cris.c (cris_initial_frame_pointer_offset): Replace\n+\tNULL_RTX with NULL.\n+\t(cris_simple_epilogue): Likewise.\n+\t(cris_expand_prologue): Likewise.\n+\t(cris_expand_epilogue): Likewise.\n+\t* config/frv/frv.c (frv_function_contains_far_jump): Strengthen\n+\tlocal \"insn\" from rtx to rtx_insn *.\n+\t(frv_ifcvt_modify_tests): Likewise for locals \"last_insn\", \"insn\".\n+\t(struct frv_packet_group): Likewise for the elements within array\n+\tfields \"insns\", \"sorted\", and for field \"nop\".\n+\t(frv_packet): Likewise for the elements within array field\n+\t\"insns\".\n+\t(frv_add_insn_to_packet): Likewise for param \"insn\".\n+\t(frv_insert_nop_in_packet): Likewise for param \"insn\" and local\n+\t\"last\".\n+\t(frv_for_each_packet): Likewise for locals \"insn\", \"next_insn\".\n+\t(frv_sort_insn_group_1): Likewise for local \"insn\".\n+\t(frv_optimize_membar_local): Likewise.\n+\t(frv_align_label): Likewise for locals \"x\", \"last\", \"barrier\",\n+\t\"label\".\n+\t* config/ia64/ia64.c (last_scheduled_insn): Likewise for this\n+\tlocal.\n+\t(ia64_sched_init): Likewise for local \"insn\".\n+\t(scheduled_good_insn): Likewise for param \"last\".\n+\t(struct _ia64_sched_context): Likewise for field\n+\t\"last_scheduled_insn\".\n+\t(ia64_init_sched_context): Replace NULL_RTX with NULL.\n+\t(struct bundle_state): Likewise for field \"insn\".\n+\t(issue_nops_and_insn): Likewise for param \"insn\".\n+\t(get_next_important_insn): Likewise for return type and both\n+\tparams.\n+\t(ia64_add_bundle_selector_before): Likewise for param \"insn\".\n+\t(bundling): Likewise for params \"prev_head_insn\", \"tail\" and\n+\tlocals \"insn\", \"next_insn\", \"b\".  Eliminate top-level local rtx\n+\t\"nop\" in favor of new locals rtx \"nop_pat\" and rtx_insn *nop;\n+\t* config/iq2000/iq2000-protos.h (iq2000_fill_delay_slot):\n+\tStrengthen final param from rtx to rtx_insn *.\n+\t(iq2000_move_1word): Likewise for second param.\n+\t* config/iq2000/iq2000.c (iq2000_fill_delay_slot): Likewise for\n+\tparam \"cur_insn\" and local \"next_insn\".\n+\t(iq2000_move_1word): Likewise for param \"insn\".\n+\t* config/iq2000/iq2000.md (insn before ADDR_DIFF_VEC): Add checked\n+\tcasts when using NEXT_INSN on operands[1].\n+\t* config/m32c/m32c.c (m32c_function_needs_enter): Strengthen local\n+\t\"insn\" from rtx to rtx_insn *.\n+\t* config/m68k/m68k.c (m68k_jump_table_ref_p): Split out uses of\n+\t\"x\", introducing local rtx_insn * \"insn\" for when working with the\n+\tCODE_LABEL of the LABEL_REF.\n+\t(m68k_sched_md_init_global): Strengthen local \"insn\" from rtx to\n+\trtx_insn *.\n+\t* config/mcore/mcore-protos.h (mcore_is_dead): Likewise for first\n+\tparam.\n+\t* config/mcore/mcore.c (emit_new_cond_insn): Likewise for return\n+\ttype.\n+\t(conditionalize_block): Likewise for return type and param.\n+\t(mcore_is_dead): Likewise for param \"first\" and local \"insn\".\n+\t(emit_new_cond_insn): Likewise for return type.\n+\t(conditionalize_block): Likewise for return type, param, and\n+\tlocals \"insn\", \"blk_1_br\", \"end_blk_2_insn\", \"start_blk_3_lab\",\n+\t\"newinsn\".\n+\t(conditionalize_optimization): Likewise for local \"insn\".\n+\t* config/mep/mep.c (mep_jmp_return_reorg): Add checked cast when\n+\tusing NEXT_INSN.\n+\t* config/microblaze/microblaze.md: Add checked casts when using\n+\tNEXT_INSN.\n+\t* config/mips/mips.c (mips_expand_prologue): Eliminate top-level\n+\trtx \"insn\" in favor of various more tightly-scoped rtx \"insn\" and\n+\tand rtx_insn * \"insn\".\n+\t* config/mips/mips.md (casesi_internal_mips16_<mode>): Add a\n+\tchecked cast when using NEXT_INSN on operands[2].\n+\t* config/mn10300/mn10300.c (mn10300_insert_setlb_lcc): Strengthen\n+\tlocal \"insn\" from rtx to rtx_insn *.\n+\t* config/nds32/nds32-fp-as-gp.c (nds32_fp_as_gp_check_available):\n+\tLikewise.\n+\t* config/nds32/nds32-md-auxiliary.c (nds32_output_casesi_pc_relative):\n+\tAdd a checked cast when using NEXT_INSN on operands[1].\n+\t* config/pa/pa-protos.h (pa_following_call): Strengthen param from\n+\trtx to rtx_insn *.\n+\t(pa_output_cbranch): Likewise for final param.\n+\t(pa_output_lbranch): Likewise for second param.\n+\t(pa_output_bb): Likewise for third param.\n+\t(pa_output_bvb): Likewise.\n+\t(pa_output_dbra): Likewise for second param.\n+\t(pa_output_movb): Likewise.\n+\t(pa_output_parallel_movb): Likewise.\n+\t(pa_output_parallel_addb): Likewise.\n+\t(pa_output_millicode_call): Likewise for first param.\n+\t(pa_output_mul_insn): Likewise for second param.\n+\t(pa_output_div_insn): Likewise for third param.\n+\t(pa_output_mod_insn): Likewise for second param.\n+\t(pa_jump_in_call_delay): Likewise for param.\n+\t* config/pa/pa.c (pa_output_mul_insn): Likewise for param \"insn\".\n+\t(pa_output_div_insn): Likewise.\n+\t(pa_output_mod_insn): Likewise.\n+\t(pa_output_cbranch): Likewise.\n+\t(pa_output_lbranch): Likewise.\n+\t(pa_output_bb): Likewise.\n+\t(pa_output_bvb): Likewise.\n+\t(pa_output_dbra): Likewise.\n+\t(pa_output_movb): Likewise.\n+\t(pa_output_millicode_call): Likewise; use method of rtx_sequence *\n+\tto simplify and for typesafety.\n+\t(pa_output_call): Use method of rtx_sequence *.\n+\t(forward_branch_p): Strengthen param \"insn\" from rtx to rtx_insn *.\n+\t(pa_jump_in_call_delay): Likewise.\n+\t(pa_output_parallel_movb): Likewise.\n+\t(pa_output_parallel_addb): Likewise.\n+\t(pa_following_call): Likewise.\n+\t(pa_combine_instructions): Likewise for locals \"anchor\",\n+\t\"floater\".\n+\t(pa_can_combine_p): Likewise for params \"anchor\", \"floater\" and\n+\tlocals \"start\", \"end\".\n+\t* config/picochip/picochip.c (picochip_reset_vliw): Likewise for\n+\tparam \"insn\" and local \"local_insn\".\n+\t(picochip_final_prescan_insn): Likewise for local \"local_insn\".\n+\t* config/rs6000/rs6000.c (compute_save_world_info): Likewise for\n+\tlocal \"insn\".\n+\t(uses_TOC): Likewise.\n+\t* config/s390/s390.c (get_some_local_dynamic_name): Likewise.\n+\t(s390_mainpool_finish): Eliminate top-level local rtx \"insn\",\n+\tsplitting out to more tightly-scoped locals, 3 as rtx and one as\n+\trtx_insn *.\n+\t(s390_optimize_nonescaping_tx): Strengthen local \"tmp\" from rtx\n+\tto rtx_insn *.\n+\t(s390_emit_prologue): Introduce a local \"insn\" to be an rtx_insn *\n+\twhere needed.\n+\t* config/sh/sh-protos.h (barrier_align): Strenghten param from rtx\n+\tto rtx_insn *.\n+\t(fixup_addr_diff_vecs): Likewise.\n+\t(reg_unused_after): Likewise for param 2.\n+\t(sh_can_redirect_branch): Likewise for both params.\n+\t(check_use_sfunc_addr): Likewise for param 1.\n+\t* config/sh/sh.c (fixup_mova): Likewise for local \"worker\".\n+\t(find_barrier): Likewise for local \"last_got\".\n+\t(gen_block_redirect): Likewise for return type, param \"jump\" and\n+\tlocals \"prev\", \"scan\", \"next\", \"insn\".\n+\t(struct far_branch): Likewise for fields \"near_label\",\n+\t\"insert_place\", \"far_label\".\n+\t(gen_far_branch): Likewise for local \"jump\".\n+\t(fixup_addr_diff_vecs): Likewise for param \"first\" and locals\n+\t\"insn\", \"prev\".\n+\t(barrier_align): Likewise for param and for locals \"prev\", \"x\".\n+\tIntroduce local rtx_sequence * \"prev_seq\" and use insn method for\n+\ttypesafety and clarity.\n+\t(sh_reorg): Strengthen local \"scan\" from rtx to rtx_insn *.\n+\t(get_dest_uid): Likewise for local \"dest\".\n+\t(split_branches): Likewise for locals \"next\", \"beyond\", \"label\",\n+\t\"block\", \"far_label\".  Add checked casts when assigning to\n+\tbp->far_label and \"far_label\".\n+\t(reg_unused_after): Strengthen param \"scan\" from rtx to rtx_insn *.\n+\t(sequence_insn_p): Likewise.\n+\t(mark_constant_pool_use): Likewise for locals \"insn\", \"lab\".  Add a\n+\tmore loop-scoped rtx \"insn\" when walking LABEL_REFS.\n+\t(sh_can_redirect_branch): Strengthen both params from rtx to\n+\trtx_insn *.\n+\t(check_use_sfunc_addr): Likewise for param \"insn\".  Introduce a\n+\tnew local rtx_sequence * \"seq\" via a dyn_cast, and use a method\n+\tfor clarity and typesafety.\n+\t* config/sh/sh.md (define_expand \"epilogue\"): Strengthen local\n+\t\"insn\" from rtx to rtx_insn *.\n+\t(define_insn \"casesi_worker_1\"): Add a checked cast to rtx_insn *\n+\twhen using NEXT_INSN on the CODE_LABEL in operands[2].\n+\t(define_insn \"casesi_worker_2\"): Likewise.\n+\t(define_insn \"casesi_shift_media\"): Likewise.\n+\t(define_insn \"casesi_load_media\"): Likewise for the CODE_LABEL in\n+\toperands[3].\n+\t* config/sh/sh_optimize_sett_clrt.cc (struct ccreg_value):\n+\tStrengthen field \"insn\" from rtx to rtx_insn *.\n+\t(sh_optimize_sett_clrt::execute): Likewise for locals \"next_i\", \"i\".\n+\t(sh_optimize_sett_clrt::find_last_ccreg_values): Likewise for\n+\tparam \"start_insn\" and local \"start_insn\".\n+\t* config/sh/sh_treg_combine.cc (struct set_of_reg): Likewise for\n+\tfield \"insn\".\n+\t(find_set_of_reg_bb): Likewise for param \"insn\".\n+\t(trace_reg_uses_1): Likewise for param \"start_insn\" and local \"i\".\n+\t(trace_reg_uses): Likewise for param \"start_insn\".\n+\t(sh_treg_combine::cbranch_trace): Likewise for field\n+\t\"cbranch_insn\".\n+\t(sh_treg_combine::cbranch_trace::cbranch_trace): Likewise for\n+\tparam \"insn\".\n+\t(sh_treg_combine::record_set_of_reg): Likewise for param\n+\t\"start_insn\" and local \"i\".\n+\t(sh_treg_combine::can_remove_cstore): Likewise for local\n+\t\"prev_insn\".\n+\t(sh_treg_combine::try_optimize_cbranch): Likewise for param\n+\t\"insn\".\n+\t(sh_treg_combine::execute): Likewise for local \"i\".\n+\t* config/sparc/sparc-protos.h (empty_delay_slot): Likewise for\n+\tparam.\n+\t(sparc_check_64): Likewise for second param.\n+\t* config/sparc/sparc.c (sparc_do_work_around_errata): Likewise for\n+\tlocals \"insn\", \"next\".  Introduce local rtx_sequence * \"seq\" via a\n+\tdyn_cast, using its insn method for typesafety and clarity.\n+\t(empty_delay_slot): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(set_extends): Likewise.\n+\t(sparc_check_64): Likewise.\n+\t* config/stormy16/stormy16.c (xstormy16_split_cbranch): Likewise\n+\tfor locals \"seq\", \"last_insn\".\n+\t(combine_bnp): Likewise for param \"insn\".\n+\t(xstormy16_reorg): Likewise for local \"insn\".\n+\t* config/v850/v850.c (substitute_ep_register): Likewise for params\n+\t\"first_insn\", \"last_insn\" and local \"insn\".\n+\t(v850_reorg): Likewise for fields \"first_insn\", \"last_insn\" within\n+\telements of \"regs\" array, and local \"insn\".\n+\t* except.c (emit_note_eh_region_end): Likewise for param \"insn\".\n+\t* final.c (final_sequence): Strengthen this global from rtx to\n+\trtx_sequence *.\n+\t(shorten_branches): Strenthen locals \"rel_lab\", \"prev\" from rtx to\n+\trtx_insn *.\n+\t(final_scan_insn): Update assignment to \"final_sequence\" to be\n+\tfrom \"seq\", the cast version of \"body\", for type-safety.\n+\t* function.c (assign_parm_setup_reg): Strengthen locals \"insn\",\n+\t\"insns\" from rtx to rtx_insn *.\n+\t(thread_prologue_and_epilogue_insns): Likewise for local \"seq\".\n+\t* genattr.c (main): When writing out generated insn-attr.h,\n+\tstrengthen params 1 and 3 of eligible_for_delay,\n+\teligible_for_annul_true, eligible_for_annul_false from rtx to\n+\trtx_insn *.\n+\t* genattrtab.c (write_eligible_delay): Likewise when writing out\n+\tgenerated insn-attrtab.c; also local \"insn\" the generated\n+\tfunctions.\n+\t* hw-doloop.c (discover_loops): Strengthen local \"insn\" from rtx\n+\tto rtx_insn *.\n+\t* hw-doloop.h (struct GTY hwloop_info_d): Strengthen field\n+\t\"start_label\" from rtx to rtx_insn *.\n+\t* ira.c (decrease_live_ranges_number): Likewise for local \"p\".\n+\t(ira_update_equiv_info_by_shuffle_insn): Likewise for param\n+\t\"insns\" and local \"insn\".\n+\t(validate_equiv_mem): Likewise for param \"start\" and local \"insn\".\n+\t(memref_used_between_p): Likewise for params \"start\", \"end\" and\n+\tlocal \"insn\".\n+\t* ira.h (ira_update_equiv_info_by_shuffle_insn): Likewise for\n+\tfinal param.\n+\t* loop-doloop.c (doloop_optimize): Within region guarded by\n+\tINSN_P (doloop_pat), introduce a new local rtx_insn *\n+\t\"doloop_insn\" via a checked cast, and use it for typesafety,\n+\teventually writing the value back into doloop_pat.\n+\t* output.h (final_sequence): Strengthen this global from rtx to\n+\trtx_sequence *.\n+\t* recog.c (peep2_attempt): Rename param \"insn\" to \"uncast_insn\",\n+\treintroducing \"insn\" as an rtx_insn * via a checked cast.\n+\tStrengthen param \"attempt\" and local \"new_insn\"from rtx to\n+\trtx_insn *.\n+\t(peephole2_optimize): Strengthen locals \"insn\", \"attempt\" from rtx\n+\tto rtx_insn *.\n+\t* ree.c (emit_note_eh_region_end): Likewise for local \"insn\".\n+\t* reload1.c (reload_as_needed): Eliminate top-level locals \"x\" and\n+\t\"p\" in favor of more tightly-scoped replacements, sometimes rtx\n+\tand sometimes rtx_insn *, as appropriate.\n+\t(delete_output_reload): Eliminate top-level rtx \"i1\", splitting\n+\tinto two loop-scoped locals, one an rtx, the other an rtx_insn *.\n+\t* reorg.c (delete_scheduled_jump): Add checked cast.  Strengthen\n+\tlocal \"trial\" from rtx to rtx_insn *.\n+\t(redirect_with_delay_slots_safe_p): Strengthen param \"jump\" from\n+\trtx to rtx_insn *.  Strenghten local \"pat\" from rtx to\n+\trtx_sequence * and use methods for clarity and typesafety.\n+\t(redirect_with_delay_list_safe_p): Strengthen param \"jump\" from\n+\trtx to rtx_insn *.  Strenghten local \"li\" from rtx to\n+\trtx_insn_list * and use its methods for clarity and typesafety.\n+\t(steal_delay_list_from_target): Strengthen param \"insn\" from rtx\n+\tto rtx_insn *.\n+\t(steal_delay_list_from_fallthrough): Likewise.\n+\t(try_merge_delay_insns): Likewise for param \"thread\" and locals\n+\t\"trial\", \"next_trial\", \"delay_insn\".\n+\t(redundant_insn): Likewise for param \"target\" and local \"trial\".\n+\t(own_thread_p): Likewise for param \"thread\" and locals\n+\t\"active_insn\", \"insn\".\n+\t(get_label_before): Likewise for param \"insn\".\n+\t(fill_simple_delay_slots): Likewise for local \"new_label\"; use\n+\tJUMP_LABEL_AS_INSN as necessary when calling own_thread_p.\n+\t(label_before_next_insn): Strengthen return type and local \"insn\"\n+\tfrom rtx to rtx_insn *.\n+\t(relax_delay_slots): Likewise for locals \"other\", \"tmp\".\n+\t(make_return_insns): Likewise for param \"first\" and locals \"insn\",\n+\t\"jump_insn\", \"prev\".  Move declaration of \"pat\" to its assignment\n+\tand strengthen from rtx to rtx_sequence *.  Use its methods for\n+\tclarity and typesafety.\n+\t* rtlanal.c (no_labels_between_p): Strengthen params from\n+\tconst_rtx to const rtx_insn *.  Strengthen local \"p\" from rtx to\n+\trtx_insn *.\n+\t(reg_used_between_p): Strengthen params \"from_insn\", \"to_insn\"\n+\tfrom const_rtx to const rtx_insn *.\n+\t(reg_set_between_p): Rename param \"from_insn\" to\n+\t\"uncast_from_insn\", and reintroduce \"from_insn\" as a\n+\tconst rtx_insn * via a checked cast.\n+\t(modified_between_p): Likewise for param \"start\" as \"uncast_start\".\n+\t(tablejump_p): Add a cast when invoking NEXT_INSN on \"label\".\n+\t* sel-sched-ir.c (get_seqno_by_preds): Strengthen param and locals\n+\t\"tmp\", head\" from rtx to rtx_insn *.\n+\t(recompute_rev_top_order): Likewise for local \"insn\".\n+\t* sel-sched-ir.h (get_seqno_by_preds): Likewise for param.\n+\t* store-motion.c (build_store_vectors): Likewise for local \"insn\".\n+\tStrengthen local \"st\" from rtx to rtx_insn_list * and use methods\n+\tfor clarity and typesafety.\n+\t* tree-ssa-loop-ivopts.c (seq_cost): Strengthen param \"seq\" from\n+\trtx to rtx_insn *.\n+\t(computation_cost): Likewise for local \"seq\".\n+\t(get_address_cost): Likewise.\n+\n 2014-08-28  David Malcolm  <dmalcolm@redhat.com>\n \n \t* rtl.h (tablejump_p): Strengthen first param from const_rtx to"}, {"sha": "3f66b8f067311d0392ea3ff1293d759a5266ec8e", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -4563,7 +4563,7 @@ aarch64_output_casesi (rtx *operands)\n {\n   char buf[100];\n   char label[100];\n-  rtx diff_vec = PATTERN (NEXT_INSN (operands[2]));\n+  rtx diff_vec = PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[2])));\n   int index;\n   static const char *const patterns[4][2] =\n   {"}, {"sha": "67b454aa0c08fb484b7a04b8d3fa2b14cdba9a50", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -1701,7 +1701,7 @@ alpha_set_memflags_1 (rtx *xp, void *data)\n void\n alpha_set_memflags (rtx seq, rtx ref)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (!MEM_P (ref))\n     return;\n@@ -1714,7 +1714,7 @@ alpha_set_memflags (rtx seq, rtx ref)\n       && !MEM_READONLY_P (ref))\n     return;\n \n-  for (insn = seq; insn; insn = NEXT_INSN (insn))\n+  for (insn = as_a <rtx_insn *> (seq); insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n       for_each_rtx (&PATTERN (insn), alpha_set_memflags_1, (void *) ref);\n     else\n@@ -8759,7 +8759,7 @@ alpha_handle_trap_shadows (void)\n {\n   struct shadow_summary shadow;\n   int trap_pending, exception_nesting;\n-  rtx i, n;\n+  rtx_insn *i, *n;\n \n   trap_pending = 0;\n   exception_nesting = 0;"}, {"sha": "64e1d25ff3815d47b8bb3e08d059797fc96d1726", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -88,7 +88,8 @@ extern rtx gen_mlo (void);\n extern rtx gen_mhi (void);\n extern bool arc_branch_size_unknown_p (void);\n struct arc_ccfsm;\n-extern void arc_ccfsm_record_condition (rtx, bool, rtx, struct arc_ccfsm *);\n+extern void arc_ccfsm_record_condition (rtx, bool, rtx_insn *,\n+\t\t\t\t\tstruct arc_ccfsm *);\n extern void arc_expand_prologue (void);\n extern void arc_expand_epilogue (int);\n extern void arc_init_expanders (void);\n@@ -108,7 +109,8 @@ extern bool arc_scheduling_not_expected (void);\n extern bool arc_sets_cc_p (rtx insn);\n extern int arc_label_align (rtx label);\n extern bool arc_need_delay (rtx_insn *insn);\n-extern bool arc_text_label (rtx);\n+extern bool arc_text_label (rtx_insn *insn);\n+\n extern int arc_decl_pretend_args (tree decl);\n extern bool arc_short_comparison_p (rtx, int);\n extern bool arc_epilogue_uses (int regno);"}, {"sha": "7cddab78bfbfa88b7c8a7f0c609fb685932d1d85", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -2464,7 +2464,7 @@ arc_expand_epilogue (int sibcall_p)\n  epilogue_done:\n   if (!TARGET_EPILOGUE_CFI)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n \n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \tRTX_FRAME_RELATED_P (insn) = 0;\n@@ -3735,7 +3735,7 @@ arc_ccfsm_at_label (const char *prefix, int num, struct arc_ccfsm *state)\n    the ccfsm state accordingly.\n    REVERSE says branch will branch when the condition is false.  */\n void\n-arc_ccfsm_record_condition (rtx cond, bool reverse, rtx jump,\n+arc_ccfsm_record_condition (rtx cond, bool reverse, rtx_insn *jump,\n \t\t\t    struct arc_ccfsm *state)\n {\n   rtx_insn *seq_insn = NEXT_INSN (PREV_INSN (jump));\n@@ -9177,7 +9177,7 @@ arc_label_align (rtx label)\n /* Return true if LABEL is in executable code.  */\n \n bool\n-arc_text_label (rtx label)\n+arc_text_label (rtx_insn *label)\n {\n   rtx_insn *next;\n "}, {"sha": "7abc38bd0ab67e92f28388059118973a76544a71", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -4771,7 +4771,7 @@\n    (use (match_operand 4 \"const_int_operand\" \"C_0,X,X\"))]\n   \"\"\n {\n-  rtx scan;\n+  rtx_insn *scan;\n   int len, size = 0;\n   int n_insns = 0;\n   rtx loop_start = operands[4];\n@@ -4812,16 +4812,16 @@\n     {\n       if (!INSN_P (scan))\n \tcontinue;\n-      if (GET_CODE (PATTERN (scan)) == SEQUENCE)\n-\tscan = XVECEXP (PATTERN (scan), 0, 0);\n+      if (rtx_sequence *seq = dyn_cast <rtx_sequence *> (PATTERN (scan)))\n+\tscan = seq->insn (0);\n       if (JUMP_P (scan))\n \t{\n \t  if (recog_memoized (scan) != CODE_FOR_doloop_end_i)\n \t    {\n \t      n_insns += 2;\n \t      if (simplejump_p (scan))\n \t\t{\n-\t\t  scan = XEXP (SET_SRC (PATTERN (scan)), 0);\n+\t\t  scan = as_a <rtx_insn *> (XEXP (SET_SRC (PATTERN (scan)), 0));\n \t\t  continue;\n \t\t}\n \t      if (JUMP_LABEL (scan)"}, {"sha": "5952a1cbb6173f17868b8600ef646820e61f582c", "filename": "gcc/config/arc/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Farc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Farc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fconstraints.md?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -308,7 +308,7 @@\n (define_constraint \"Clb\"\n   \"label\"\n   (and (match_code \"label_ref\")\n-       (match_test \"arc_text_label (XEXP (op, 0))\")))\n+       (match_test \"arc_text_label (as_a <rtx_insn *> (XEXP (op, 0)))\")))\n \n (define_constraint \"Cal\"\n   \"constant for arithmetic/logical operations\""}, {"sha": "d8bfda3aa98365b3d562566f4db2273e2d737cbe", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -6416,7 +6416,7 @@ require_pic_register (void)\n \t}\n       else\n \t{\n-\t  rtx seq, insn;\n+\t  rtx_insn *seq, *insn;\n \n \t  if (!cfun->machine->pic_reg)\n \t    cfun->machine->pic_reg = gen_reg_rtx (Pmode);\n@@ -16697,7 +16697,7 @@ create_fix_barrier (Mfix *fix, HOST_WIDE_INT max_address)\n   rtx_barrier *barrier;\n   rtx_insn *from = fix->insn;\n   /* The instruction after which we will insert the jump.  */\n-  rtx selected = NULL;\n+  rtx_insn *selected = NULL;\n   int selected_cost;\n   /* The address at which the jump instruction will be placed.  */\n   HOST_WIDE_INT selected_address;\n@@ -16767,7 +16767,7 @@ create_fix_barrier (Mfix *fix, HOST_WIDE_INT max_address)\n      CALL_ARG_LOCATION note.  */\n   if (CALL_P (selected))\n     {\n-      rtx next = NEXT_INSN (selected);\n+      rtx_insn *next = NEXT_INSN (selected);\n       if (next && NOTE_P (next)\n \t  && NOTE_KIND (next) == NOTE_INSN_CALL_ARG_LOCATION)\n \t  selected = next;\n@@ -17047,7 +17047,7 @@ thumb1_reorg (void)\n     {\n       rtx dest, src;\n       rtx pat, op0, set = NULL;\n-      rtx prev, insn = BB_END (bb);\n+      rtx_insn *prev, *insn = BB_END (bb);\n       bool insn_clobbered = false;\n \n       while (insn != BB_HEAD (bb) && !NONDEBUG_INSN_P (insn))\n@@ -21325,7 +21325,7 @@ arm_expand_prologue (void)\n     {\n       /* This add can produce multiple insns for a large constant, so we\n \t need to get tricky.  */\n-      rtx last = get_last_insn ();\n+      rtx_insn *last = get_last_insn ();\n \n       amount = GEN_INT (offsets->saved_args + saved_regs\n \t\t\t- offsets->outgoing_args);\n@@ -29739,7 +29739,7 @@ arm_output_iwmmxt_tinsr (rtx *operands)\n const char *\n thumb1_output_casesi (rtx *operands)\n {\n-  rtx diff_vec = PATTERN (NEXT_INSN (operands[0]));\n+  rtx diff_vec = PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[0])));\n \n   gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n \n@@ -29762,7 +29762,7 @@ thumb1_output_casesi (rtx *operands)\n const char *\n thumb2_output_casesi (rtx *operands)\n {\n-  rtx diff_vec = PATTERN (NEXT_INSN (operands[2]));\n+  rtx diff_vec = PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[2])));\n \n   gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n "}, {"sha": "ad51edca7a25d0f1d8c55432d4393cf9efe24943", "filename": "gcc/config/avr/avr-log.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Favr%2Favr-log.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Favr%2Favr-log.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-log.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -209,7 +209,7 @@ avr_log_vadump (FILE *file, const char *fmt, va_list ap)\n \n             case 'L':\n               {\n-                rtx insn = va_arg (ap, rtx);\n+                rtx_insn *insn = safe_as_a <rtx_insn *> (va_arg (ap, rtx));\n \n                 while (insn)\n                   {"}, {"sha": "6547f83d943f2fd0eaa1ab12562aa722168515e5", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -3348,8 +3348,8 @@ bfin_adjust_cost (rtx_insn *insn, rtx link, rtx_insn *dep_insn, int cost)\n /* This function acts like NEXT_INSN, but is aware of three-insn bundles and\n    skips all subsequent parallel instructions if INSN is the start of such\n    a group.  */\n-static rtx\n-find_next_insn_start (rtx insn)\n+static rtx_insn *\n+find_next_insn_start (rtx_insn *insn)\n {\n   if (GET_MODE (insn) == SImode)\n     {\n@@ -3362,8 +3362,8 @@ find_next_insn_start (rtx insn)\n /* This function acts like PREV_INSN, but is aware of three-insn bundles and\n    skips all subsequent parallel instructions if INSN is the start of such\n    a group.  */\n-static rtx\n-find_prev_insn_start (rtx insn)\n+static rtx_insn *\n+find_prev_insn_start (rtx_insn *insn)\n {\n   insn = PREV_INSN (insn);\n   gcc_assert (GET_MODE (insn) != SImode);\n@@ -3439,7 +3439,7 @@ static bool\n hwloop_optimize (hwloop_info loop)\n {\n   basic_block bb;\n-  rtx insn, last_insn;\n+  rtx_insn *insn, *last_insn;\n   rtx loop_init, start_label, end_label;\n   rtx iter_reg, scratchreg, scratch_init, scratch_init_insn;\n   rtx lc_reg, lt_reg, lb_reg;\n@@ -3614,7 +3614,7 @@ hwloop_optimize (hwloop_info loop)\n \t}\n       else\n \t{\n-\t  last_insn = NULL_RTX;\n+\t  last_insn = NULL;\n \t  break;\n \t}\n     }\n@@ -3657,7 +3657,7 @@ hwloop_optimize (hwloop_info loop)\n       last_insn = emit_insn_after (gen_forced_nop (), last_insn);\n     }\n \n-  loop->last_insn = safe_as_a <rtx_insn *> (last_insn);\n+  loop->last_insn = last_insn;\n \n   /* The loop is good for replacement.  */\n   start_label = loop->start_label;\n@@ -3772,7 +3772,7 @@ hwloop_optimize (hwloop_info loop)\n \n   if (loop->incoming_src)\n     {\n-      rtx prev = BB_END (loop->incoming_src);\n+      rtx_insn *prev = BB_END (loop->incoming_src);\n       if (vec_safe_length (loop->incoming) > 1\n \t  || !(loop->incoming->last ()->flags & EDGE_FALLTHRU))\n \t{\n@@ -3909,7 +3909,7 @@ gen_one_bundle (rtx_insn *slot[3])\n   /* Verify that we really can do the multi-issue.  */\n   if (slot[0])\n     {\n-      rtx t = NEXT_INSN (slot[0]);\n+      rtx_insn *t = NEXT_INSN (slot[0]);\n       while (t != slot[1])\n \t{\n \t  if (! NOTE_P (t) || NOTE_KIND (t) != NOTE_INSN_DELETED)\n@@ -4230,7 +4230,7 @@ trapping_loads_p (rtx insn, int np_reg, bool after_np_branch)\n    a three-insn bundle, see if one of them is a load and return that if so.\n    Return NULL_RTX if the insn does not contain loads.  */\n static rtx\n-find_load (rtx insn)\n+find_load (rtx_insn *insn)\n {\n   if (!NONDEBUG_INSN_P (insn))\n     return NULL_RTX;\n@@ -4285,7 +4285,7 @@ note_np_check_stores (rtx x, const_rtx pat ATTRIBUTE_UNUSED,\n static void\n workaround_speculation (void)\n {\n-  rtx insn, next;\n+  rtx_insn *insn, *next;\n   rtx last_condjump = NULL_RTX;\n   int cycles_since_jump = INT_MAX;\n   int delay_added = 0;\n@@ -4449,9 +4449,9 @@ workaround_speculation (void)\n \t  && (INSN_CODE (insn) == CODE_FOR_cbranch_predicted_taken\n \t      || cbranch_predicted_taken_p (insn)))\n \t{\n-\t  rtx target = JUMP_LABEL (insn);\n+\t  rtx_insn *target = JUMP_LABEL_AS_INSN (insn);\n \t  rtx label = target;\n-\t  rtx next_tgt;\n+\t  rtx_insn *next_tgt;\n \n \t  cycles_since_jump = 0;\n \t  for (; target && cycles_since_jump < 3; target = next_tgt)"}, {"sha": "91d5155758a78c7110f763955d90dfdd253dee85", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -3045,13 +3045,13 @@ get_insn_side (rtx insn, enum attr_units units)\n /* After scheduling, walk the insns between HEAD and END and assign unit\n    reservations.  */\n static void\n-assign_reservations (rtx head, rtx end)\n+assign_reservations (rtx_insn *head, rtx_insn *end)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   for (insn = head; insn != NEXT_INSN (end); insn = NEXT_INSN (insn))\n     {\n       unsigned int sched_mask, reserved;\n-      rtx within, last;\n+      rtx_insn *within, *last;\n       int pass;\n       int rsrv[2];\n       int rsrv_count[2][4];\n@@ -3061,7 +3061,7 @@ assign_reservations (rtx head, rtx end)\n \tcontinue;\n \n       reserved = 0;\n-      last = NULL_RTX;\n+      last = NULL;\n       /* Find the last insn in the packet.  It has a state recorded for it,\n \t which we can use to determine the units we should be using.  */\n       for (within = insn;\n@@ -3272,9 +3272,9 @@ get_unit_reqs (rtx insn, int *req1, int *side1, int *req2, int *side2)\n /* Walk the insns between and including HEAD and TAIL, and mark the\n    resource requirements in the unit_reqs table.  */\n static void\n-count_unit_reqs (unit_req_table reqs, rtx head, rtx tail)\n+count_unit_reqs (unit_req_table reqs, rtx_insn *head, rtx_insn *tail)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   memset (reqs, 0, sizeof (unit_req_table));\n \n@@ -3417,7 +3417,8 @@ get_unit_operand_masks (rtx insn, unsigned int *pmask1, unsigned int *pmask2)\n    We recompute this information locally after our transformation, and keep\n    it only if we managed to improve the balance.  */\n static void\n-try_rename_operands (rtx head, rtx tail, unit_req_table reqs, rtx insn,\n+try_rename_operands (rtx_insn *head, rtx_insn *tail, unit_req_table reqs,\n+\t\t     rtx insn,\n \t\t     insn_rr_info *info, unsigned int op_mask, int orig_side)\n {\n   enum reg_class super_class = orig_side == 0 ? B_REGS : A_REGS;\n@@ -3520,9 +3521,9 @@ try_rename_operands (rtx head, rtx tail, unit_req_table reqs, rtx insn,\n static void\n reshuffle_units (basic_block loop)\n {\n-  rtx head = BB_HEAD (loop);\n-  rtx tail = BB_END (loop);\n-  rtx insn;\n+  rtx_insn *head = BB_HEAD (loop);\n+  rtx_insn *tail = BB_END (loop);\n+  rtx_insn *insn;\n   unit_req_table reqs;\n   edge e;\n   edge_iterator ei;\n@@ -3613,7 +3614,7 @@ typedef struct c6x_sched_context\n   int delays_finished_at;\n \n   /* The following variable value is the last issued insn.  */\n-  rtx last_scheduled_insn;\n+  rtx_insn *last_scheduled_insn;\n   /* The last issued insn that isn't a shadow of another.  */\n   rtx_insn *last_scheduled_iter0;\n \n@@ -3844,7 +3845,7 @@ predicate_insn (rtx insn, rtx cond, bool doit)\n static void\n init_sched_state (c6x_sched_context_t sc)\n {\n-  sc->last_scheduled_insn = NULL_RTX;\n+  sc->last_scheduled_insn = NULL;\n   sc->last_scheduled_iter0 = NULL;\n   sc->issued_this_cycle = 0;\n   memset (sc->jump_cycles, 0, sizeof sc->jump_cycles);\n@@ -4954,7 +4955,7 @@ reorg_split_calls (rtx *call_labels)\n \t\t\t= INSN_INFO_ENTRY (INSN_UID (last_same_clock)).unit_mask;\n \t\t      if (GET_MODE (insn) == TImode)\n \t\t\t{\n-\t\t\t  rtx new_cycle_first = NEXT_INSN (insn);\n+\t\t\t  rtx_insn *new_cycle_first = NEXT_INSN (insn);\n \t\t\t  while (!NONDEBUG_INSN_P (new_cycle_first)\n \t\t\t\t || GET_CODE (PATTERN (new_cycle_first)) == USE\n \t\t\t\t || GET_CODE (PATTERN (new_cycle_first)) == CLOBBER)\n@@ -5332,11 +5333,12 @@ split_delayed_nonbranch (rtx_insn *insn)\n /* Examine if INSN is the result of splitting a load into a real load and a\n    shadow, and if so, undo the transformation.  */\n static void\n-undo_split_delayed_nonbranch (rtx insn)\n+undo_split_delayed_nonbranch (rtx_insn *insn)\n {\n   int icode = recog_memoized (insn);\n   enum attr_type type;\n-  rtx prev_pat, insn_pat, prev;\n+  rtx prev_pat, insn_pat;\n+  rtx_insn *prev;\n \n   if (icode < 0)\n     return;\n@@ -5388,7 +5390,7 @@ static void\n conditionalize_after_sched (void)\n {\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n   FOR_EACH_BB_FN (bb, cfun)\n     FOR_BB_INSNS (bb, insn)\n       {\n@@ -5432,7 +5434,7 @@ static int\n bb_earliest_end_cycle (basic_block bb, rtx ignore)\n {\n   int earliest = 0;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   FOR_BB_INSNS (bb, insn)\n     {\n@@ -5458,7 +5460,7 @@ bb_earliest_end_cycle (basic_block bb, rtx ignore)\n static void\n filter_insns_above (basic_block bb, int max_uid)\n {\n-  rtx insn, next;\n+  rtx_insn *insn, *next;\n   bool prev_ti = false;\n   int prev_cycle = -1;\n \n@@ -5729,7 +5731,7 @@ hwloop_optimize (hwloop_info loop)\n      require.  */\n   prev = NULL;\n   n_execute_packets = 0;\n-  for (insn = as_a <rtx_insn *> (loop->start_label);\n+  for (insn = loop->start_label;\n        insn != loop->loop_end;\n        insn = NEXT_INSN (insn))\n     {\n@@ -5869,7 +5871,7 @@ hwloop_fail (hwloop_info loop)\n     emit_insn_before (insn, loop->loop_end);\n   else\n     {\n-      rtx t = loop->start_label;\n+      rtx_insn *t = loop->start_label;\n       while (!NOTE_P (t) || NOTE_KIND (t) != NOTE_INSN_BASIC_BLOCK)\n \tt = NEXT_INSN (t);\n       emit_insn_after (insn, t);"}, {"sha": "260644d338c09985cb844d514ee837a40cc059bf", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -1303,7 +1303,7 @@ cris_initial_frame_pointer_offset (void)\n       push_topmost_sequence ();\n       got_really_used\n \t= reg_used_between_p (pic_offset_table_rtx, get_insns (),\n-\t\t\t      NULL_RTX);\n+\t\t\t      NULL);\n       pop_topmost_sequence ();\n     }\n \n@@ -2015,7 +2015,7 @@ cris_simple_epilogue (void)\n     {\n       push_topmost_sequence ();\n       got_really_used\n-\t= reg_used_between_p (pic_offset_table_rtx, get_insns (), NULL_RTX);\n+\t= reg_used_between_p (pic_offset_table_rtx, get_insns (), NULL);\n       pop_topmost_sequence ();\n     }\n \n@@ -3081,7 +3081,7 @@ cris_expand_prologue (void)\n \t it's still used.  */\n       push_topmost_sequence ();\n       got_really_used\n-\t= reg_used_between_p (pic_offset_table_rtx, get_insns (), NULL_RTX);\n+\t= reg_used_between_p (pic_offset_table_rtx, get_insns (), NULL);\n       pop_topmost_sequence ();\n     }\n \n@@ -3364,7 +3364,7 @@ cris_expand_epilogue (void)\n \t it's still used.  */\n       push_topmost_sequence ();\n       got_really_used\n-\t= reg_used_between_p (pic_offset_table_rtx, get_insns (), NULL_RTX);\n+\t= reg_used_between_p (pic_offset_table_rtx, get_insns (), NULL);\n       pop_topmost_sequence ();\n     }\n "}, {"sha": "a9e574c69dee1bbd14f570f4258047baee7038d9", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -337,8 +337,8 @@ static void frv_start_packet \t\t\t(void);\n static void frv_start_packet_block \t\t(void);\n static void frv_finish_packet \t\t\t(void (*) (void));\n static bool frv_pack_insn_p \t\t\t(rtx);\n-static void frv_add_insn_to_packet\t\t(rtx);\n-static void frv_insert_nop_in_packet\t\t(rtx);\n+static void frv_add_insn_to_packet\t\t(rtx_insn *);\n+static void frv_insert_nop_in_packet\t\t(rtx_insn *);\n static bool frv_for_each_packet \t\t(void (*) (void));\n static bool frv_sort_insn_group_1\t\t(enum frv_insn_group,\n \t\t\t\t\t\t unsigned int, unsigned int,\n@@ -1391,7 +1391,7 @@ static int frv_insn_packing_flag;\n static int\n frv_function_contains_far_jump (void)\n {\n-  rtx insn = get_insns ();\n+  rtx_insn *insn = get_insns ();\n   while (insn != NULL\n \t && !(JUMP_P (insn)\n \t      && get_attr_far_jump (insn) == FAR_JUMP_YES))\n@@ -5368,8 +5368,8 @@ frv_ifcvt_modify_tests (ce_if_block *ce_info, rtx *p_true, rtx *p_false)\n   /* Scan all of the blocks for registers that must not be allocated.  */\n   for (j = 0; j < num_bb; j++)\n     {\n-      rtx last_insn = BB_END (bb[j]);\n-      rtx insn = BB_HEAD (bb[j]);\n+      rtx_insn *last_insn = BB_END (bb[j]);\n+      rtx_insn *insn = BB_HEAD (bb[j]);\n       unsigned int regno;\n \n       if (dump_file)\n@@ -7101,15 +7101,15 @@ struct frv_packet_group {\n \n   /* A list of the instructions that belong to this group, in the order\n      they appear in the rtl stream.  */\n-  rtx insns[ARRAY_SIZE (frv_unit_codes)];\n+  rtx_insn *insns[ARRAY_SIZE (frv_unit_codes)];\n \n   /* The contents of INSNS after they have been sorted into the correct\n      assembly-language order.  Element X issues to unit X.  The list may\n      contain extra nops.  */\n-  rtx sorted[ARRAY_SIZE (frv_unit_codes)];\n+  rtx_insn *sorted[ARRAY_SIZE (frv_unit_codes)];\n \n   /* The member of frv_nops[] to use in sorted[].  */\n-  rtx nop;\n+  rtx_insn *nop;\n };\n \n /* The current state of the packing pass, implemented by frv_pack_insns.  */\n@@ -7140,7 +7140,7 @@ static struct {\n   struct frv_packet_group groups[NUM_GROUPS];\n \n   /* The instructions that make up the current packet.  */\n-  rtx insns[ARRAY_SIZE (frv_unit_codes)];\n+  rtx_insn *insns[ARRAY_SIZE (frv_unit_codes)];\n   unsigned int num_insns;\n } frv_packet;\n \n@@ -7388,7 +7388,7 @@ frv_pack_insn_p (rtx insn)\n /* Add instruction INSN to the current packet.  */\n \n static void\n-frv_add_insn_to_packet (rtx insn)\n+frv_add_insn_to_packet (rtx_insn *insn)\n {\n   struct frv_packet_group *packet_group;\n \n@@ -7405,10 +7405,10 @@ frv_add_insn_to_packet (rtx insn)\n    add to the end.  */\n \n static void\n-frv_insert_nop_in_packet (rtx insn)\n+frv_insert_nop_in_packet (rtx_insn *insn)\n {\n   struct frv_packet_group *packet_group;\n-  rtx last;\n+  rtx_insn *last;\n \n   packet_group = &frv_packet.groups[frv_unit_groups[frv_insn_unit (insn)]];\n   last = frv_packet.insns[frv_packet.num_insns - 1];\n@@ -7433,7 +7433,7 @@ frv_insert_nop_in_packet (rtx insn)\n static bool\n frv_for_each_packet (void (*handle_packet) (void))\n {\n-  rtx insn, next_insn;\n+  rtx_insn *insn, *next_insn;\n \n   frv_packet.issue_rate = frv_issue_rate ();\n \n@@ -7531,7 +7531,7 @@ frv_sort_insn_group_1 (enum frv_insn_group group,\n   unsigned int i;\n   state_t test_state;\n   size_t dfa_size;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   /* Early success if we've filled all the slots.  */\n   if (lower_slot == upper_slot)\n@@ -7870,7 +7870,8 @@ frv_optimize_membar_local (basic_block bb, struct frv_io *next_io,\n \t\t\t   rtx *last_membar)\n {\n   HARD_REG_SET used_regs;\n-  rtx next_membar, set, insn;\n+  rtx next_membar, set;\n+  rtx_insn *insn;\n   bool next_is_end_p;\n \n   /* NEXT_IO is the next I/O operation to be performed after the current\n@@ -8074,7 +8075,7 @@ static void\n frv_align_label (void)\n {\n   unsigned int alignment, target, nop;\n-  rtx x, last, barrier, label;\n+  rtx_insn *x, *last, *barrier, *label;\n \n   /* Walk forward to the start of the next packet.  Set ALIGNMENT to the\n      maximum alignment of that packet, LABEL to the last label between"}, {"sha": "2ed5ddd3bb91c634ab94163f5ed20236b04da5fc", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -275,14 +275,15 @@ static void initiate_bundle_state_table (void);\n static void finish_bundle_state_table (void);\n static int try_issue_nops (struct bundle_state *, int);\n static int try_issue_insn (struct bundle_state *, rtx);\n-static void issue_nops_and_insn (struct bundle_state *, int, rtx, int, int);\n+static void issue_nops_and_insn (struct bundle_state *, int, rtx_insn *,\n+\t\t\t\t int, int);\n static int get_max_pos (state_t);\n static int get_template (state_t, int);\n \n-static rtx get_next_important_insn (rtx, rtx);\n+static rtx_insn *get_next_important_insn (rtx_insn *, rtx_insn *);\n static bool important_for_bundling_p (rtx);\n static bool unknown_for_bundling_p (rtx);\n-static void bundling (FILE *, int, rtx, rtx);\n+static void bundling (FILE *, int, rtx_insn *, rtx_insn *);\n \n static void ia64_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t  HOST_WIDE_INT, tree);\n@@ -7087,7 +7088,7 @@ static rtx_insn *dfa_stop_insn;\n \n /* The following variable value is the last issued insn.  */\n \n-static rtx last_scheduled_insn;\n+static rtx_insn *last_scheduled_insn;\n \n /* The following variable value is pointer to a DFA state used as\n    temporary variable.  */\n@@ -7294,15 +7295,15 @@ ia64_sched_init (FILE *dump ATTRIBUTE_UNUSED,\n \t\t int max_ready ATTRIBUTE_UNUSED)\n {\n #ifdef ENABLE_CHECKING\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (!sel_sched_p () && reload_completed)\n     for (insn = NEXT_INSN (current_sched_info->prev_head);\n \t insn != current_sched_info->next_tail;\n \t insn = NEXT_INSN (insn))\n       gcc_assert (!SCHED_GROUP_P (insn));\n #endif\n-  last_scheduled_insn = NULL_RTX;\n+  last_scheduled_insn = NULL;\n   init_insn_group_barriers ();\n \n   current_cycle = 0;\n@@ -7567,7 +7568,7 @@ static rtx_insn *dfa_pre_cycle_insn;\n /* Returns 1 when a meaningful insn was scheduled between the last group\n    barrier and LAST.  */\n static int\n-scheduled_good_insn (rtx last)\n+scheduled_good_insn (rtx_insn *last)\n {\n   if (last && recog_memoized (last) >= 0)\n     return 1;\n@@ -7669,7 +7670,7 @@ ia64_h_i_d_extended (void)\n struct _ia64_sched_context\n {\n   state_t prev_cycle_state;\n-  rtx last_scheduled_insn;\n+  rtx_insn *last_scheduled_insn;\n   struct reg_write_state rws_sum[NUM_REGS];\n   struct reg_write_state rws_insn[NUM_REGS];\n   int first_instruction;\n@@ -7697,7 +7698,7 @@ ia64_init_sched_context (void *_sc, bool clean_p)\n   if (clean_p)\n     {\n       state_reset (sc->prev_cycle_state);\n-      sc->last_scheduled_insn = NULL_RTX;\n+      sc->last_scheduled_insn = NULL;\n       memset (sc->rws_sum, 0, sizeof (rws_sum));\n       memset (sc->rws_insn, 0, sizeof (rws_insn));\n       sc->first_instruction = 1;\n@@ -8458,7 +8459,7 @@ struct bundle_state\n   /* Unique bundle state number to identify them in the debugging\n      output  */\n   int unique_num;\n-  rtx insn;     /* corresponding insn, NULL for the 1st and the last state  */\n+  rtx_insn *insn; /* corresponding insn, NULL for the 1st and the last state  */\n   /* number nops before and after the insn  */\n   short before_nops_num, after_nops_num;\n   int insn_num; /* insn number (0 - for initial state, 1 - for the 1st\n@@ -8700,7 +8701,8 @@ try_issue_insn (struct bundle_state *curr_state, rtx insn)\n \n static void\n issue_nops_and_insn (struct bundle_state *originator, int before_nops_num,\n-\t\t     rtx insn, int try_bundle_end_p, int only_bundle_end_p)\n+\t\t     rtx_insn *insn, int try_bundle_end_p,\n+\t\t     int only_bundle_end_p)\n {\n   struct bundle_state *curr_state;\n \n@@ -8914,13 +8916,13 @@ important_for_bundling_p (rtx insn)\n /* The following function returns an insn important for insn bundling\n    followed by INSN and before TAIL.  */\n \n-static rtx\n-get_next_important_insn (rtx insn, rtx tail)\n+static rtx_insn *\n+get_next_important_insn (rtx_insn *insn, rtx_insn *tail)\n {\n   for (; insn && insn != tail; insn = NEXT_INSN (insn))\n     if (important_for_bundling_p (insn))\n       return insn;\n-  return NULL_RTX;\n+  return NULL;\n }\n \n /* True when INSN is unknown, but important, for bundling.  */\n@@ -8937,7 +8939,7 @@ unknown_for_bundling_p (rtx insn)\n /* Add a bundle selector TEMPLATE0 before INSN.  */\n \n static void\n-ia64_add_bundle_selector_before (int template0, rtx insn)\n+ia64_add_bundle_selector_before (int template0, rtx_insn *insn)\n {\n   rtx b = gen_bundle_selector (GEN_INT (template0));\n \n@@ -9017,15 +9019,14 @@ ia64_add_bundle_selector_before (int template0, rtx insn)\n    EBB.  */\n \n static void\n-bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n+bundling (FILE *dump, int verbose, rtx_insn *prev_head_insn, rtx_insn *tail)\n {\n   struct bundle_state *curr_state, *next_state, *best_state;\n-  rtx insn, next_insn;\n+  rtx_insn *insn, *next_insn;\n   int insn_num;\n   int i, bundle_end_p, only_bundle_end_p, asm_p;\n   int pos = 0, max_pos, template0, template1;\n-  rtx b;\n-  rtx nop;\n+  rtx_insn *b;\n   enum attr_type type;\n \n   insn_num = 0;\n@@ -9237,8 +9238,8 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t/* Emit nops after the current insn.  */\n \tfor (i = 0; i < curr_state->after_nops_num; i++)\n \t  {\n-\t    nop = gen_nop ();\n-\t    emit_insn_after (nop, insn);\n+\t    rtx nop_pat = gen_nop ();\n+\t    rtx_insn *nop = emit_insn_after (nop_pat, insn);\n \t    pos--;\n \t    gcc_assert (pos >= 0);\n \t    if (pos % 3 == 0)\n@@ -9281,9 +9282,9 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n       /* Emit nops after the current insn.  */\n       for (i = 0; i < curr_state->before_nops_num; i++)\n \t{\n-\t  nop = gen_nop ();\n-\t  ia64_emit_insn_before (nop, insn);\n-\t  nop = PREV_INSN (insn);\n+\t  rtx nop_pat = gen_nop ();\n+\t  ia64_emit_insn_before (nop_pat, insn);\n+\t  rtx_insn *nop = PREV_INSN (insn);\n \t  insn = nop;\n \t  pos--;\n \t  gcc_assert (pos >= 0);\n@@ -9317,7 +9318,7 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t  start_bundle = true;\n \telse\n \t  {\n-\t    rtx next_insn;\n+\t    rtx_insn *next_insn;\n \n \t    for (next_insn = NEXT_INSN (insn);\n \t\t next_insn && next_insn != tail;"}, {"sha": "673223497af14961724eba3a9fd3671f0a7219ef", "filename": "gcc/config/iq2000/iq2000-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -22,8 +22,8 @@\n \n extern int              iq2000_check_split (rtx, enum machine_mode);\n extern int              iq2000_reg_mode_ok_for_base_p (rtx, enum machine_mode, int);\n-extern const char *     iq2000_fill_delay_slot (const char *, enum delay_type, rtx *, rtx);\n-extern const char *     iq2000_move_1word (rtx *, rtx, int);\n+extern const char *     iq2000_fill_delay_slot (const char *, enum delay_type, rtx *, rtx_insn *);\n+extern const char *     iq2000_move_1word (rtx *, rtx_insn *, int);\n extern HOST_WIDE_INT    iq2000_debugger_offset (rtx, HOST_WIDE_INT);\n extern void             final_prescan_insn (rtx_insn *, rtx *, int);\n extern HOST_WIDE_INT    compute_frame_size (HOST_WIDE_INT);"}, {"sha": "e568a7c3d2bbd8cbc1aa3334d8c7b6176aea052b", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -369,11 +369,11 @@ iq2000_legitimate_address_p (enum machine_mode mode, rtx xinsn, bool strict)\n \n const char *\n iq2000_fill_delay_slot (const char *ret, enum delay_type type, rtx operands[],\n-\t\t\trtx cur_insn)\n+\t\t\trtx_insn *cur_insn)\n {\n   rtx set_reg;\n   enum machine_mode mode;\n-  rtx next_insn = cur_insn ? NEXT_INSN (cur_insn) : NULL_RTX;\n+  rtx_insn *next_insn = cur_insn ? NEXT_INSN (cur_insn) : NULL;\n   int num_nops;\n \n   if (type == DELAY_LOAD || type == DELAY_FCMP)\n@@ -552,7 +552,7 @@ abort_with_insn (rtx insn, const char * reason)\n /* Return the appropriate instructions to move one operand to another.  */\n \n const char *\n-iq2000_move_1word (rtx operands[], rtx insn, int unsignedp)\n+iq2000_move_1word (rtx operands[], rtx_insn *insn, int unsignedp)\n {\n   const char *ret = 0;\n   rtx op0 = operands[0];"}, {"sha": "4eb2eb1b38145d5ab18fed57d63c1707f27f39db", "filename": "gcc/config/iq2000/iq2000.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.md?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -1398,8 +1398,8 @@\n \t(plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n \t\t (label_ref:SI (match_operand 1 \"\" \"\"))))\n    (use (label_ref:SI (match_dup 1)))]\n-  \"!(Pmode == DImode) && NEXT_INSN (operands[1]) != 0\n-   && GET_CODE (PATTERN (NEXT_INSN (operands[1]))) == ADDR_DIFF_VEC\"\n+  \"!(Pmode == DImode) && NEXT_INSN (as_a <rtx_insn *> (operands[1])) != 0\n+   && GET_CODE (PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[1])))) == ADDR_DIFF_VEC\"\n   \"*\n {\n   return \\\"j\\\\t%0\\\";"}, {"sha": "73d459f0651997bdf1429ee897052eef8a57ca86", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -4072,7 +4072,7 @@ m32c_leaf_function_p (void)\n static bool\n m32c_function_needs_enter (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   struct sequence_stack *seq;\n   rtx sp = gen_rtx_REG (Pmode, SP_REGNO);\n   rtx fb = gen_rtx_REG (Pmode, FB_REGNO);"}, {"sha": "a8710622a9cc5016cafb92a6828531c4c9a0c778", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -1933,12 +1933,12 @@ m68k_jump_table_ref_p (rtx x)\n   if (GET_CODE (x) != LABEL_REF)\n     return false;\n \n-  x = XEXP (x, 0);\n-  if (!NEXT_INSN (x) && !PREV_INSN (x))\n+  rtx_insn *insn = as_a <rtx_insn *> (XEXP (x, 0));\n+  if (!NEXT_INSN (insn) && !PREV_INSN (insn))\n     return true;\n \n-  x = next_nonnote_insn (x);\n-  return x && JUMP_TABLE_DATA_P (x);\n+  insn = next_nonnote_insn (insn);\n+  return insn && JUMP_TABLE_DATA_P (insn);\n }\n \n /* Return true if X is a legitimate address for values of mode MODE.\n@@ -6126,12 +6126,12 @@ m68k_sched_md_init_global (FILE *sched_dump ATTRIBUTE_UNUSED,\n   /* Check that all instructions have DFA reservations and\n      that all instructions can be issued from a clean state.  */\n   {\n-    rtx insn;\n+    rtx_insn *insn;\n     state_t state;\n \n     state = alloca (state_size ());\n \n-    for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n+    for (insn = get_insns (); insn != NULL; insn = NEXT_INSN (insn))\n       {\n  \tif (INSN_P (insn) && recog_memoized (insn) >= 0)\n \t  {"}, {"sha": "833668da2a7a6bc837dacfa21ad0efbd8a112779", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -48,7 +48,7 @@ extern const char * mcore_output_bclri         \t\t(rtx, int);\n extern const char * mcore_output_bseti         \t\t(rtx, int);\n extern const char * mcore_output_cmov          \t\t(rtx *, int, const char *);\n extern char *       mcore_output_call          \t\t(rtx *, int);\n-extern int          mcore_is_dead                \t(rtx, rtx);\n+extern int          mcore_is_dead                \t(rtx_insn *, rtx);\n extern int          mcore_expand_insv            \t(rtx *);\n extern bool         mcore_expand_block_move      \t(rtx *);\n extern const char * mcore_output_andn          \t\t(rtx, rtx *);"}, {"sha": "b6e5f75c21878731e27f21ed95ef3ba5cdb42608", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -102,8 +102,8 @@ static const char *     output_inline_const     (enum machine_mode, rtx *);\n static void       layout_mcore_frame            (struct mcore_frame *);\n static void       mcore_setup_incoming_varargs\t(cumulative_args_t, enum machine_mode, tree, int *, int);\n static cond_type  is_cond_candidate             (rtx);\n-static rtx        emit_new_cond_insn            (rtx, int);\n-static rtx        conditionalize_block          (rtx);\n+static rtx_insn  *emit_new_cond_insn            (rtx, int);\n+static rtx_insn  *conditionalize_block          (rtx_insn *);\n static void       conditionalize_optimization   (void);\n static void       mcore_reorg                   (void);\n static rtx        handle_structs_in_regs        (enum machine_mode, const_tree, int);\n@@ -903,9 +903,9 @@ try_constant_tricks (HOST_WIDE_INT value, HOST_WIDE_INT * x, HOST_WIDE_INT * y)\n    can ignore subregs by extracting the actual register.  BRC  */\n \n int\n-mcore_is_dead (rtx first, rtx reg)\n+mcore_is_dead (rtx_insn *first, rtx reg)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   /* For mcore, subregs can't live independently of their parent regs.  */\n   if (GET_CODE (reg) == SUBREG)\n@@ -2321,7 +2321,7 @@ is_cond_candidate (rtx insn)\n /* Emit a conditional version of insn and replace the old insn with the\n    new one.  Return the new insn if emitted.  */\n \n-static rtx\n+static rtx_insn *\n emit_new_cond_insn (rtx insn, int cond)\n {\n   rtx c_insn = 0;\n@@ -2406,7 +2406,7 @@ emit_new_cond_insn (rtx insn, int cond)\n \n   delete_insn (insn);\n   \n-  return c_insn;\n+  return as_a <rtx_insn *> (c_insn);\n }\n \n /* Attempt to change a basic block into a series of conditional insns.  This\n@@ -2438,14 +2438,14 @@ emit_new_cond_insn (rtx insn, int cond)\n    we can delete the L2 label if NUSES==1 and re-apply the optimization\n    starting at the last instruction of block 2.  This may allow an entire\n    if-then-else statement to be conditionalized.  BRC  */\n-static rtx\n-conditionalize_block (rtx first)\n+static rtx_insn *\n+conditionalize_block (rtx_insn *first)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   rtx br_pat;\n-  rtx end_blk_1_br = 0;\n-  rtx end_blk_2_insn = 0;\n-  rtx start_blk_3_lab = 0;\n+  rtx_insn *end_blk_1_br = 0;\n+  rtx_insn *end_blk_2_insn = 0;\n+  rtx_insn *start_blk_3_lab = 0;\n   int cond;\n   int br_lab_num;\n   int blk_size = 0;\n@@ -2534,7 +2534,7 @@ conditionalize_block (rtx first)\n   for (insn = NEXT_INSN (end_blk_1_br); insn != start_blk_3_lab; \n        insn = NEXT_INSN (insn))\n     {\n-      rtx newinsn;\n+      rtx_insn *newinsn;\n \n       if (INSN_DELETED_P (insn))\n \tcontinue;\n@@ -2582,7 +2582,7 @@ conditionalize_block (rtx first)\n static void\n conditionalize_optimization (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   for (insn = get_insns (); insn; insn = conditionalize_block (insn))\n     continue;"}, {"sha": "df6bba5029679be80ab2b527a42291ce99f4c16d", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -5653,7 +5653,7 @@ mep_jmp_return_reorg (rtx_insn *insns)\n \t     && (NOTE_P (ret)\n \t\t || LABEL_P (ret)\n \t\t || GET_CODE (PATTERN (ret)) == USE))\n-\tret = NEXT_INSN (ret);\n+\tret = NEXT_INSN (as_a <rtx_insn *> (ret));\n \n       if (ret)\n \t{"}, {"sha": "b971737118abe5ea92497fac32c69db6aa0bab2f", "filename": "gcc/config/microblaze/microblaze.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -1829,8 +1829,8 @@\n \t(plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n \t\t (label_ref:SI (match_operand 1 \"\" \"\"))))\n   (use (label_ref:SI (match_dup 1)))]\n- \"NEXT_INSN (operands[1]) != 0\n-  && GET_CODE (PATTERN (NEXT_INSN (operands[1]))) == ADDR_DIFF_VEC\n+ \"NEXT_INSN (as_a <rtx_insn *> (operands[1])) != 0\n+  && GET_CODE (PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[1])))) == ADDR_DIFF_VEC\n   && flag_pic\"\n   {\n     output_asm_insn (\"addk\\t%0,%0,r20\",operands);"}, {"sha": "22afcadb070adaef7566bff0007ce609c9f5c319", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -11079,7 +11079,6 @@ mips_expand_prologue (void)\n   const struct mips_frame_info *frame;\n   HOST_WIDE_INT size;\n   unsigned int nargs;\n-  rtx insn;\n \n   if (cfun->machine->global_pointer != INVALID_REGNUM)\n     {\n@@ -11133,8 +11132,8 @@ mips_expand_prologue (void)\n \n \t  /* Build the save instruction.  */\n \t  mask = frame->mask;\n-\t  insn = mips16e_build_save_restore (false, &mask, &offset,\n-\t\t\t\t\t     nargs, step1);\n+\t  rtx insn = mips16e_build_save_restore (false, &mask, &offset,\n+\t\t\t\t\t\t nargs, step1);\n \t  RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n \t  mips_frame_barrier ();\n  \t  size -= step1;\n@@ -11174,8 +11173,8 @@ mips_expand_prologue (void)\n \t\t}\n \n \t      /* Allocate the first part of the frame.  */\n-\t      insn = gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t    GEN_INT (-step1));\n+\t      rtx insn = gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (-step1));\n \t      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n \t      mips_frame_barrier ();\n \t      size -= step1;\n@@ -11235,9 +11234,9 @@ mips_expand_prologue (void)\n \t    }\n \t  else\n \t    {\n-\t      insn = gen_add3_insn (stack_pointer_rtx,\n-\t\t\t\t    stack_pointer_rtx,\n-\t\t\t\t    GEN_INT (-step1));\n+\t      rtx insn = gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (-step1));\n \t      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n \t      mips_frame_barrier ();\n \t      size -= step1;\n@@ -11291,13 +11290,13 @@ mips_expand_prologue (void)\n       offset = frame->hard_frame_pointer_offset;\n       if (offset == 0)\n \t{\n-\t  insn = mips_emit_move (hard_frame_pointer_rtx, stack_pointer_rtx);\n+\t  rtx insn = mips_emit_move (hard_frame_pointer_rtx, stack_pointer_rtx);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n       else if (SMALL_OPERAND (offset))\n \t{\n-\t  insn = gen_add3_insn (hard_frame_pointer_rtx,\n-\t\t\t\tstack_pointer_rtx, GEN_INT (offset));\n+\t  rtx insn = gen_add3_insn (hard_frame_pointer_rtx,\n+\t\t\t\t    stack_pointer_rtx, GEN_INT (offset));\n \t  RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n \t}\n       else\n@@ -11338,6 +11337,7 @@ mips_expand_prologue (void)\n   /* We need to search back to the last use of K0 or K1.  */\n   if (cfun->machine->interrupt_handler_p)\n     {\n+      rtx_insn *insn;\n       for (insn = get_last_insn (); insn != NULL_RTX; insn = PREV_INSN (insn))\n \tif (INSN_P (insn)\n \t    && for_each_rtx (&PATTERN (insn), mips_kernel_reg_p, NULL))"}, {"sha": "9c404ddf923923b58ca9df8b5b2b798a0ce66c3e", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -6130,7 +6130,7 @@\n    (clobber (reg:SI MIPS16_T_REGNUM))]\n   \"TARGET_MIPS16_SHORT_JUMP_TABLES\"\n {\n-  rtx diff_vec = PATTERN (NEXT_INSN (operands[2]));\n+  rtx diff_vec = PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[2])));\n \n   gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n   "}, {"sha": "9a4fcacd597e2fbe7c48b27ce2eed0d5594e8b9c", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -3211,7 +3211,7 @@ mn10300_insert_setlb_lcc (rtx label, rtx branch)\n static bool\n mn10300_block_contains_call (basic_block block)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   FOR_BB_INSNS (block, insn)\n     if (CALL_P (insn))"}, {"sha": "0390e184080ab8b4bf07ad29bbf6b4456ce4c2a1", "filename": "gcc/config/nds32/nds32-fp-as-gp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fnds32%2Fnds32-fp-as-gp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fnds32%2Fnds32-fp-as-gp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-fp-as-gp.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -153,7 +153,7 @@ nds32_fp_as_gp_check_available (void)\n       int symbol_count  = 0;\n \n       int threshold;\n-      rtx insn;\n+      rtx_insn *insn;\n \n       /* We check if there already requires prologue.\n          Note that $gp will be saved in prologue for PIC code generation."}, {"sha": "047417cf27475b4af27308309d13259c76baedc0", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -773,7 +773,7 @@ nds32_output_casesi_pc_relative (rtx *operands)\n   enum machine_mode mode;\n   rtx diff_vec;\n \n-  diff_vec = PATTERN (NEXT_INSN (operands[1]));\n+  diff_vec = PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[1])));\n \n   gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n "}, {"sha": "579998453e35e693b08bfbf06aab2c331024f7ae", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n extern rtx pa_eh_return_handler_rtx (void);\n \n /* Used in insn-*.c.  */\n-extern int pa_following_call (rtx);\n+extern int pa_following_call (rtx_insn *);\n \n /* Define functions in pa.c and used in insn-output.c.  */\n \n@@ -34,20 +34,20 @@ extern const char *pa_output_move_double (rtx *);\n extern const char *pa_output_fp_move_double (rtx *);\n extern const char *pa_output_block_move (rtx *, int);\n extern const char *pa_output_block_clear (rtx *, int);\n-extern const char *pa_output_cbranch (rtx *, int, rtx);\n-extern const char *pa_output_lbranch (rtx, rtx, int);\n-extern const char *pa_output_bb (rtx *, int, rtx, int);\n-extern const char *pa_output_bvb (rtx *, int, rtx, int);\n-extern const char *pa_output_dbra (rtx *, rtx, int);\n-extern const char *pa_output_movb (rtx *, rtx, int, int);\n-extern const char *pa_output_parallel_movb (rtx *, rtx);\n-extern const char *pa_output_parallel_addb (rtx *, rtx);\n+extern const char *pa_output_cbranch (rtx *, int, rtx_insn *);\n+extern const char *pa_output_lbranch (rtx, rtx_insn *, int);\n+extern const char *pa_output_bb (rtx *, int, rtx_insn *, int);\n+extern const char *pa_output_bvb (rtx *, int, rtx_insn *, int);\n+extern const char *pa_output_dbra (rtx *, rtx_insn *, int);\n+extern const char *pa_output_movb (rtx *, rtx_insn *, int, int);\n+extern const char *pa_output_parallel_movb (rtx *, rtx_insn *);\n+extern const char *pa_output_parallel_addb (rtx *, rtx_insn *);\n extern const char *pa_output_call (rtx_insn *, rtx, int);\n extern const char *pa_output_indirect_call (rtx_insn *, rtx);\n-extern const char *pa_output_millicode_call (rtx, rtx);\n-extern const char *pa_output_mul_insn (int, rtx);\n-extern const char *pa_output_div_insn (rtx *, int, rtx);\n-extern const char *pa_output_mod_insn (int, rtx);\n+extern const char *pa_output_millicode_call (rtx_insn *, rtx);\n+extern const char *pa_output_mul_insn (int, rtx_insn *);\n+extern const char *pa_output_div_insn (rtx *, int, rtx_insn *);\n+extern const char *pa_output_mod_insn (int, rtx_insn *);\n extern const char *pa_singlemove_string (rtx *);\n extern void pa_output_addr_vec (rtx, rtx);\n extern void pa_output_addr_diff_vec (rtx, rtx);\n@@ -63,7 +63,7 @@ extern void pa_emit_bcond_fp (rtx[]);\n extern int pa_emit_move_sequence (rtx *, enum machine_mode, rtx);\n extern int pa_emit_hpdiv_const (rtx *, int);\n extern int pa_is_function_label_plus_const (rtx);\n-extern int pa_jump_in_call_delay (rtx);\n+extern int pa_jump_in_call_delay (rtx_insn *);\n extern int pa_fpstore_bypass_p (rtx, rtx);\n extern int pa_attr_length_millicode_call (rtx_insn *);\n extern int pa_attr_length_call (rtx_insn *, int);"}, {"sha": "fe76bd4be3b29a8d029b176c2ebfd712ad8b0730", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -99,8 +99,8 @@ static bool hppa_rtx_costs (rtx, int, int, int, int *, bool);\n static inline rtx force_mode (enum machine_mode, rtx);\n static void pa_reorg (void);\n static void pa_combine_instructions (void);\n-static int pa_can_combine_p (rtx, rtx, rtx, int, rtx, rtx, rtx);\n-static bool forward_branch_p (rtx);\n+static int pa_can_combine_p (rtx, rtx_insn *, rtx_insn *, int, rtx, rtx, rtx);\n+static bool forward_branch_p (rtx_insn *);\n static void compute_zdepwi_operands (unsigned HOST_WIDE_INT, unsigned *);\n static void compute_zdepdi_operands (unsigned HOST_WIDE_INT, unsigned *);\n static int compute_movmem_length (rtx);\n@@ -5693,7 +5693,7 @@ import_milli (enum millicodes code)\n    the proper registers.  */\n \n const char *\n-pa_output_mul_insn (int unsignedp ATTRIBUTE_UNUSED, rtx insn)\n+pa_output_mul_insn (int unsignedp ATTRIBUTE_UNUSED, rtx_insn *insn)\n {\n   import_milli (mulI);\n   return pa_output_millicode_call (insn, gen_rtx_SYMBOL_REF (Pmode, \"$$mulI\"));\n@@ -5741,7 +5741,7 @@ pa_emit_hpdiv_const (rtx *operands, int unsignedp)\n }\n \n const char *\n-pa_output_div_insn (rtx *operands, int unsignedp, rtx insn)\n+pa_output_div_insn (rtx *operands, int unsignedp, rtx_insn *insn)\n {\n   int divisor;\n \n@@ -5795,7 +5795,7 @@ pa_output_div_insn (rtx *operands, int unsignedp, rtx insn)\n /* Output a $$rem millicode to do mod.  */\n \n const char *\n-pa_output_mod_insn (int unsignedp, rtx insn)\n+pa_output_mod_insn (int unsignedp, rtx_insn *insn)\n {\n   if (unsignedp)\n     {\n@@ -6411,7 +6411,7 @@ use_skip_p (rtx insn)\n    parameters.  */\n \n const char *\n-pa_output_cbranch (rtx *operands, int negated, rtx insn)\n+pa_output_cbranch (rtx *operands, int negated, rtx_insn *insn)\n {\n   static char buf[100];\n   bool useskip;\n@@ -6622,7 +6622,7 @@ pa_output_cbranch (rtx *operands, int negated, rtx insn)\n    bytes for the portable runtime, non-PIC and PIC cases, respectively.  */\n \n const char *\n-pa_output_lbranch (rtx dest, rtx insn, int xdelay)\n+pa_output_lbranch (rtx dest, rtx_insn *insn, int xdelay)\n {\n   rtx xoperands[2];\n  \n@@ -6737,7 +6737,7 @@ pa_output_lbranch (rtx dest, rtx insn, int xdelay)\n    above.  it returns the appropriate output template to emit the branch.  */\n \n const char *\n-pa_output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n+pa_output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx_insn *insn, int which)\n {\n   static char buf[100];\n   bool useskip;\n@@ -6922,7 +6922,7 @@ pa_output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n    branch.  */\n \n const char *\n-pa_output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn,\n+pa_output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx_insn *insn,\n \t       int which)\n {\n   static char buf[100];\n@@ -7105,7 +7105,7 @@ pa_output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn,\n    Note it may perform some output operations on its own before\n    returning the final output string.  */\n const char *\n-pa_output_dbra (rtx *operands, rtx insn, int which_alternative)\n+pa_output_dbra (rtx *operands, rtx_insn *insn, int which_alternative)\n {\n   int length = get_attr_length (insn);\n \n@@ -7254,7 +7254,7 @@ pa_output_dbra (rtx *operands, rtx insn, int which_alternative)\n    Note it may perform some output operations on its own before\n    returning the final output string.  */\n const char *\n-pa_output_movb (rtx *operands, rtx insn, int which_alternative,\n+pa_output_movb (rtx *operands, rtx_insn *insn, int which_alternative,\n \t     int reverse_comparison)\n {\n   int length = get_attr_length (insn);\n@@ -7533,7 +7533,7 @@ pa_attr_length_millicode_call (rtx_insn *insn)\n    CALL_DEST is the routine we are calling.  */\n \n const char *\n-pa_output_millicode_call (rtx insn, rtx call_dest)\n+pa_output_millicode_call (rtx_insn *insn, rtx call_dest)\n {\n   int attr_length = get_attr_length (insn);\n   int seq_length = dbr_sequence_length ();\n@@ -7651,7 +7651,7 @@ pa_output_millicode_call (rtx insn, rtx call_dest)\n      sequence insn's address.  */\n   if (INSN_ADDRESSES_SET_P ())\n     {\n-      seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n+      seq_insn = NEXT_INSN (PREV_INSN (final_sequence->insn (0)));\n       distance = (INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))\n \t\t  - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8);\n \n@@ -8038,7 +8038,7 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)\n          sequence insn's address.  This would break the regular call/return@\n          relationship assumed by the table based eh unwinder, so only do that\n          if the call is not possibly throwing.  */\n-      rtx seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n+      rtx seq_insn = NEXT_INSN (PREV_INSN (final_sequence->insn (0)));\n       int distance = (INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))\n \t\t      - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8);\n \n@@ -8786,7 +8786,7 @@ pa_shadd_constant_p (int val)\n /* Return TRUE if INSN branches forward.  */\n \n static bool\n-forward_branch_p (rtx insn)\n+forward_branch_p (rtx_insn *insn)\n {\n   rtx lab = JUMP_LABEL (insn);\n \n@@ -8809,7 +8809,7 @@ forward_branch_p (rtx insn)\n \n /* Return 1 if INSN is in the delay slot of a call instruction.  */\n int\n-pa_jump_in_call_delay (rtx insn)\n+pa_jump_in_call_delay (rtx_insn *insn)\n {\n \n   if (! JUMP_P (insn))\n@@ -8832,7 +8832,7 @@ pa_jump_in_call_delay (rtx insn)\n /* Output an unconditional move and branch insn.  */\n \n const char *\n-pa_output_parallel_movb (rtx *operands, rtx insn)\n+pa_output_parallel_movb (rtx *operands, rtx_insn *insn)\n {\n   int length = get_attr_length (insn);\n \n@@ -8872,7 +8872,7 @@ pa_output_parallel_movb (rtx *operands, rtx insn)\n /* Output an unconditional add and branch insn.  */\n \n const char *\n-pa_output_parallel_addb (rtx *operands, rtx insn)\n+pa_output_parallel_addb (rtx *operands, rtx_insn *insn)\n {\n   int length = get_attr_length (insn);\n \n@@ -8907,7 +8907,7 @@ pa_output_parallel_addb (rtx *operands, rtx insn)\n    the delay slot of the call.  */\n \n int\n-pa_following_call (rtx insn)\n+pa_following_call (rtx_insn *insn)\n {\n   if (! TARGET_JUMP_IN_DELAY)\n     return 0;\n@@ -8989,7 +8989,8 @@ pa_reorg (void)\n static void\n pa_combine_instructions (void)\n {\n-  rtx anchor, new_rtx;\n+  rtx_insn *anchor;\n+  rtx new_rtx;\n \n   /* This can get expensive since the basic algorithm is on the\n      order of O(n^2) (or worse).  Only do it for -O2 or higher\n@@ -9023,7 +9024,7 @@ pa_combine_instructions (void)\n \t  || (anchor_attr == PA_COMBINE_TYPE_UNCOND_BRANCH\n \t      && ! forward_branch_p (anchor)))\n \t{\n-\t  rtx floater;\n+\t  rtx_insn *floater;\n \n \t  for (floater = PREV_INSN (anchor);\n \t       floater;\n@@ -9038,7 +9039,7 @@ pa_combine_instructions (void)\n \t      /* Anything except a regular INSN will stop our search.  */\n \t      if (! NONJUMP_INSN_P (floater))\n \t\t{\n-\t\t  floater = NULL_RTX;\n+\t\t  floater = NULL;\n \t\t  break;\n \t\t}\n \n@@ -9098,7 +9099,7 @@ pa_combine_instructions (void)\n \t\t  /* Anything except a regular INSN will stop our search.  */\n \t\t  if (! NONJUMP_INSN_P (floater))\n \t\t    {\n-\t\t      floater = NULL_RTX;\n+\t\t      floater = NULL;\n \t\t      break;\n \t\t    }\n \n@@ -9171,11 +9172,12 @@ pa_combine_instructions (void)\n }\n \n static int\n-pa_can_combine_p (rtx new_rtx, rtx anchor, rtx floater, int reversed, rtx dest,\n+pa_can_combine_p (rtx new_rtx, rtx_insn *anchor, rtx_insn *floater,\n+\t\t  int reversed, rtx dest,\n \t\t  rtx src1, rtx src2)\n {\n   int insn_code_number;\n-  rtx start, end;\n+  rtx_insn *start, *end;\n \n   /* Create a PARALLEL with the patterns of ANCHOR and\n      FLOATER, try to recognize it, then test constraints"}, {"sha": "fbcb63ff050f9866032598866ba55f47a457ea86", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -3435,9 +3435,9 @@ picochip_get_vliw_alu_id (void)\n \n /* Reset any information about the current VLIW packing status. */\n static void\n-picochip_reset_vliw (rtx insn)\n+picochip_reset_vliw (rtx_insn *insn)\n {\n-  rtx local_insn = insn;\n+  rtx_insn *local_insn = insn;\n \n   /* Nothing to do if VLIW scheduling isn't being used. */\n   if (picochip_schedule_type != DFA_TYPE_SPEED)\n@@ -3877,7 +3877,7 @@ void\n picochip_final_prescan_insn (rtx_insn *insn, rtx * opvec ATTRIBUTE_UNUSED,\n \t\t\t     int num_operands ATTRIBUTE_UNUSED)\n {\n-  rtx local_insn;\n+  rtx_insn *local_insn;\n \n   picochip_current_prescan_insn = insn;\n "}, {"sha": "d13e71e86a0c83a6947cd262cd727d35b6093950", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -20857,7 +20857,7 @@ compute_save_world_info (rs6000_stack_t *info_ptr)\n      are none.  (This check is expensive, but seldom executed.) */\n   if (WORLD_SAVE_P (info_ptr))\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n       for (insn = get_last_insn_anywhere (); insn; insn = PREV_INSN (insn))\n \tif (CALL_P (insn) && SIBLING_CALL_P (insn))\n \t  {\n@@ -22050,7 +22050,7 @@ get_TOC_alias_set (void)\n static int\n uses_TOC (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))"}, {"sha": "fbaef4594bd3f61fc799f5b5766c82a4791dcea3", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -5226,7 +5226,7 @@ get_some_local_dynamic_name_1 (rtx *px, void *data ATTRIBUTE_UNUSED)\n static const char *\n get_some_local_dynamic_name (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (cfun->machine->some_ld_name)\n     return cfun->machine->some_ld_name;\n@@ -6739,7 +6739,6 @@ static void\n s390_mainpool_finish (struct constant_pool *pool)\n {\n   rtx base_reg = cfun->machine->base_reg;\n-  rtx insn;\n \n   /* If the pool is empty, we're done.  */\n   if (pool->size == 0)\n@@ -6760,7 +6759,7 @@ s390_mainpool_finish (struct constant_pool *pool)\n      located in the .rodata section, so we emit it after the function.  */\n   if (TARGET_CPU_ZARCH)\n     {\n-      insn = gen_main_base_64 (base_reg, pool->label);\n+      rtx insn = gen_main_base_64 (base_reg, pool->label);\n       insn = emit_insn_after (insn, pool->pool_insn);\n       INSN_ADDRESSES_NEW (insn, -1);\n       remove_insn (pool->pool_insn);\n@@ -6778,7 +6777,7 @@ s390_mainpool_finish (struct constant_pool *pool)\n   else if (INSN_ADDRESSES (INSN_UID (pool->emit_pool_after))\n \t   + pool->size + 8 /* alignment slop */ < 4096)\n     {\n-      insn = gen_main_base_31_small (base_reg, pool->label);\n+      rtx insn = gen_main_base_31_small (base_reg, pool->label);\n       insn = emit_insn_after (insn, pool->pool_insn);\n       INSN_ADDRESSES_NEW (insn, -1);\n       remove_insn (pool->pool_insn);\n@@ -6803,7 +6802,7 @@ s390_mainpool_finish (struct constant_pool *pool)\n     {\n       rtx pool_end = gen_label_rtx ();\n \n-      insn = gen_main_base_31_large (base_reg, pool->label, pool_end);\n+      rtx insn = gen_main_base_31_large (base_reg, pool->label, pool_end);\n       insn = emit_jump_insn_after (insn, pool->pool_insn);\n       JUMP_LABEL (insn) = pool_end;\n       INSN_ADDRESSES_NEW (insn, -1);\n@@ -6824,7 +6823,7 @@ s390_mainpool_finish (struct constant_pool *pool)\n \n   /* Replace all literal pool references.  */\n \n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+  for (rtx_insn *insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n \treplace_ltrel_base (&PATTERN (insn));\n@@ -8002,7 +8001,7 @@ s390_optimize_nonescaping_tx (void)\n \n \t  if (XINT (SET_SRC (pat), 1) == UNSPECV_TBEGIN)\n \t    {\n-\t      rtx tmp;\n+\t      rtx_insn *tmp;\n \n \t      tbegin_insn = insn;\n \n@@ -8955,7 +8954,7 @@ s390_emit_prologue (void)\n     {\n       rtx_insn *insns = s390_load_got ();\n \n-      for (insn = insns; insn; insn = NEXT_INSN (insn))\n+      for (rtx_insn *insn = insns; insn; insn = NEXT_INSN (insn))\n \tannotate_constant_pool_refs (&PATTERN (insn));\n \n       emit_insn (insns);"}, {"sha": "1d34651ec11191509bd170aac33f06da9db139d3", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -103,7 +103,7 @@ extern const char *output_movepcrel (rtx, rtx[], enum machine_mode);\n extern const char *output_far_jump (rtx_insn *, rtx);\n \n extern rtx sfunc_uses_reg (rtx);\n-extern int barrier_align (rtx);\n+extern int barrier_align (rtx_insn *);\n extern int sh_loop_align (rtx);\n extern bool fp_zero_operand (rtx);\n extern bool fp_one_operand (rtx);\n@@ -144,18 +144,18 @@ extern int shl_sext_length (rtx);\n extern bool gen_shl_sext (rtx, rtx, rtx, rtx);\n extern rtx gen_datalabel_ref (rtx);\n extern int regs_used (rtx, int);\n-extern void fixup_addr_diff_vecs (rtx);\n+extern void fixup_addr_diff_vecs (rtx_insn *);\n extern int get_dest_uid (rtx, int);\n extern void final_prescan_insn (rtx_insn *, rtx *, int);\n extern enum tls_model tls_symbolic_operand (rtx, enum machine_mode);\n extern bool system_reg_operand (rtx, enum machine_mode);\n-extern bool reg_unused_after (rtx, rtx);\n+extern bool reg_unused_after (rtx, rtx_insn *);\n extern void expand_sf_unop (rtx (*)(rtx, rtx, rtx), rtx *);\n extern void expand_sf_binop (rtx (*)(rtx, rtx, rtx, rtx), rtx *);\n extern void expand_df_unop (rtx (*)(rtx, rtx, rtx), rtx *);\n extern void expand_df_binop (rtx (*)(rtx, rtx, rtx, rtx), rtx *);\n extern int sh_insn_length_adjustment (rtx_insn *);\n-extern bool sh_can_redirect_branch (rtx, rtx);\n+extern bool sh_can_redirect_branch (rtx_insn *, rtx_insn *);\n extern void sh_expand_unop_v2sf (enum rtx_code, rtx, rtx);\n extern void sh_expand_binop_v2sf (enum rtx_code, rtx, rtx, rtx);\n extern bool sh_expand_t_scc (rtx *);\n@@ -207,7 +207,7 @@ extern bool sh_cannot_change_mode_class\n \t      (enum machine_mode, enum machine_mode, enum reg_class);\n extern bool sh_small_register_classes_for_mode_p (enum machine_mode);\n extern void sh_mark_label (rtx, int);\n-extern bool check_use_sfunc_addr (rtx, rtx);\n+extern bool check_use_sfunc_addr (rtx_insn *, rtx);\n \n #ifdef HARD_CONST\n extern void fpscr_set_from_mem (int, HARD_REG_SET);"}, {"sha": "11657130595d9dd6f5336352de48878a32dfe957", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 53, "deletions": 49, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -191,7 +191,7 @@ static bool broken_move (rtx_insn *);\n static bool mova_p (rtx_insn *);\n static rtx_insn *find_barrier (int, rtx_insn *, rtx_insn *);\n static bool noncall_uses_reg (rtx, rtx, rtx *);\n-static rtx gen_block_redirect (rtx, int, int);\n+static rtx_insn *gen_block_redirect (rtx_insn *, int, int);\n static void sh_reorg (void);\n static void sh_option_override (void);\n static void output_stack_adjust (int, rtx, int, HARD_REG_SET *, bool);\n@@ -324,7 +324,7 @@ static void sh_conditional_register_usage (void);\n static bool sh_legitimate_constant_p (enum machine_mode, rtx);\n static int mov_insn_size (enum machine_mode, bool);\n static int mov_insn_alignment_mask (enum machine_mode, bool);\n-static bool sequence_insn_p (rtx);\n+static bool sequence_insn_p (rtx_insn *);\n static void sh_canonicalize_comparison (int *, rtx *, rtx *, bool);\n static void sh_canonicalize_comparison (enum rtx_code&, rtx&, rtx&,\n \t\t\t\t\tenum machine_mode, bool);\n@@ -4941,7 +4941,7 @@ fixup_mova (rtx_insn *mova)\n     }\n   else\n     {\n-      rtx worker = mova;\n+      rtx_insn *worker = mova;\n       rtx lab = gen_label_rtx ();\n       rtx wpat, wpat0, wpat1, wsrc, target, base, diff;\n \n@@ -5041,7 +5041,7 @@ find_barrier (int num_mova, rtx_insn *mova, rtx_insn *from)\n   int si_limit;\n   int hi_limit;\n   rtx_insn *orig = from;\n-  rtx last_got = NULL_RTX;\n+  rtx_insn *last_got = NULL;\n   rtx_insn *last_symoff = NULL;\n \n   /* For HImode: range is 510, add 4 because pc counts from address of\n@@ -5139,9 +5139,9 @@ find_barrier (int num_mova, rtx_insn *mova, rtx_insn *from)\n \t     instructions.  (plus add r0,r12).\n \t     Remember if we see one without the other.  */\n \t  if (GET_CODE (src) == UNSPEC && PIC_ADDR_P (XVECEXP (src, 0, 0)))\n-\t    last_got = last_got ? NULL_RTX : from;\n+\t    last_got = last_got ? NULL : from;\n \t  else if (PIC_ADDR_P (src))\n-\t    last_got = last_got ? NULL_RTX : from;\n+\t    last_got = last_got ? NULL : from;\n \n \t  /* We must explicitly check the mode, because sometimes the\n \t     front end will generate code to load unsigned constants into\n@@ -5562,11 +5562,11 @@ regs_used (rtx x, int is_dest)\n    pass 1.  Pass 2 if a definite blocking insn is needed.\n    -1 is used internally to avoid deep recursion.\n    If a blocking instruction is made or recognized, return it.  */\n-static rtx\n-gen_block_redirect (rtx jump, int addr, int need_block)\n+static rtx_insn *\n+gen_block_redirect (rtx_insn *jump, int addr, int need_block)\n {\n   int dead = 0;\n-  rtx prev = prev_nonnote_insn (jump);\n+  rtx_insn *prev = prev_nonnote_insn (jump);\n   rtx dest;\n \n   /* First, check if we already have an instruction that satisfies our need.  */\n@@ -5599,7 +5599,7 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n       && (INSN_ADDRESSES (INSN_UID (dest)) - addr + (unsigned) 4092\n \t  > 4092 + 4098))\n     {\n-      rtx scan;\n+      rtx_insn *scan;\n       /* Don't look for the stack pointer as a scratch register,\n \t it would cause trouble if an interrupt occurred.  */\n       unsigned attempt = 0x7fff, used;\n@@ -5627,7 +5627,7 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n \t      break;\n \t    }\n \t}\n-      for (used = dead = 0, scan = JUMP_LABEL (jump);\n+      for (used = dead = 0, scan = JUMP_LABEL_AS_INSN (jump);\n \t   (scan = NEXT_INSN (scan)); )\n \t{\n \t  enum rtx_code code;\n@@ -5649,7 +5649,7 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n \t      if (code == JUMP_INSN)\n \t\t{\n \t\t  if (jump_left-- && simplejump_p (scan))\n-\t\t    scan = JUMP_LABEL (scan);\n+\t\t    scan = JUMP_LABEL_AS_INSN (scan);\n \t\t  else\n \t\t    break;\n \t\t}\n@@ -5666,7 +5666,7 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n \n   else if (optimize && need_block >= 0)\n     {\n-      rtx next = next_active_insn (next_active_insn (dest));\n+      rtx_insn *next = next_active_insn (next_active_insn (dest));\n       if (next && JUMP_P (next)\n \t  && GET_CODE (PATTERN (next)) == SET\n \t  && recog_memoized (next) == CODE_FOR_jump_compact)\n@@ -5690,9 +5690,9 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n \t it should try to schedule instructions from the target of the\n \t branch; simplejump_p fails for indirect jumps even if they have\n \t a JUMP_LABEL.  */\n-      rtx insn = emit_insn_before (gen_indirect_jump_scratch\n-\t\t\t\t   (reg, GEN_INT (unspec_bbr_uid++)),\n-\t\t\t\t   jump);\n+      rtx_insn *insn = emit_insn_before (gen_indirect_jump_scratch\n+\t\t\t\t\t (reg, GEN_INT (unspec_bbr_uid++)),\n+\t\t\t\t\t jump);\n       /* ??? We would like this to have the scope of the jump, but that\n \t scope will change when a delay slot insn of an inner scope is added.\n \t Hence, after delay slot scheduling, we'll have to expect\n@@ -5718,12 +5718,12 @@ struct far_branch\n {\n   /* A label (to be placed) in front of the jump\n      that jumps to our ultimate destination.  */\n-  rtx near_label;\n+  rtx_insn *near_label;\n   /* Where we are going to insert it if we cannot move the jump any farther,\n      or the jump itself if we have picked up an existing jump.  */\n-  rtx insert_place;\n+  rtx_insn *insert_place;\n   /* The ultimate destination.  */\n-  rtx far_label;\n+  rtx_insn *far_label;\n   struct far_branch *prev;\n   /* If the branch has already been created, its address;\n      else the address of its first prospective user.  */\n@@ -5736,7 +5736,7 @@ static void\n gen_far_branch (struct far_branch *bp)\n {\n   rtx insn = bp->insert_place;\n-  rtx jump;\n+  rtx_insn *jump;\n   rtx label = gen_label_rtx ();\n   int ok;\n \n@@ -5786,13 +5786,14 @@ gen_far_branch (struct far_branch *bp)\n \n /* Fix up ADDR_DIFF_VECs.  */\n void\n-fixup_addr_diff_vecs (rtx first)\n+fixup_addr_diff_vecs (rtx_insn *first)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n-      rtx vec_lab, pat, prev, prevpat, x, braf_label;\n+      rtx vec_lab, pat, prevpat, x, braf_label;\n+      rtx_insn *prev;\n \n       if (! JUMP_TABLE_DATA_P (insn)\n \t  || GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n@@ -5801,7 +5802,7 @@ fixup_addr_diff_vecs (rtx first)\n       vec_lab = XEXP (XEXP (pat, 0), 0);\n \n       /* Search the matching casesi_jump_2.  */\n-      for (prev = vec_lab; ; prev = PREV_INSN (prev))\n+      for (prev = as_a <rtx_insn *> (vec_lab); ; prev = PREV_INSN (prev))\n \t{\n \t  if (!JUMP_P (prev))\n \t    continue;\n@@ -5834,7 +5835,7 @@ fixup_addr_diff_vecs (rtx first)\n /* BARRIER_OR_LABEL is either a BARRIER or a CODE_LABEL immediately following\n    a barrier.  Return the base 2 logarithm of the desired alignment.  */\n int\n-barrier_align (rtx barrier_or_label)\n+barrier_align (rtx_insn *barrier_or_label)\n {\n   rtx next, pat;\n \n@@ -5899,7 +5900,7 @@ barrier_align (rtx barrier_or_label)\n \n       /* Skip to the insn before the JUMP_INSN before the barrier under\n \t investigation.  */\n-      rtx prev = prev_real_insn (prev_active_insn (barrier_or_label));\n+      rtx_insn *prev = prev_real_insn (prev_active_insn (barrier_or_label));\n \n       for (slot = 2, credit = (1 << (CACHE_LOG - 2)) + 2;\n \t   credit >= 0 && prev && NONJUMP_INSN_P (prev);\n@@ -5909,9 +5910,9 @@ barrier_align (rtx barrier_or_label)\n \t  if (GET_CODE (PATTERN (prev)) == USE\n \t      || GET_CODE (PATTERN (prev)) == CLOBBER)\n \t    continue;\n-\t  if (GET_CODE (PATTERN (prev)) == SEQUENCE)\n+\t  if (rtx_sequence *prev_seq = dyn_cast <rtx_sequence *> (PATTERN (prev)))\n \t    {\n-\t      prev = XVECEXP (PATTERN (prev), 0, 1);\n+\t      prev = prev_seq->insn (1);\n \t      if (INSN_UID (prev) == INSN_UID (next))\n \t\t{\n \t  \t  /* Delay slot was filled with insn at jump target.  */\n@@ -5927,7 +5928,7 @@ barrier_align (rtx barrier_or_label)\n \t}\n       if (prev && jump_to_label_p (prev))\n \t{\n-\t  rtx x;\n+\t  rtx_insn *x;\n \t  if (jump_to_next\n \t      || next_real_insn (JUMP_LABEL (prev)) == next\n \t      /* If relax_delay_slots() decides NEXT was redundant\n@@ -6247,7 +6248,7 @@ sh_reorg (void)\n \t\t   || (prev_nonnote_insn (insn)\n \t\t       == XEXP (MOVA_LABELREF (mova), 0))))\n \t{\n-\t  rtx scan;\n+\t  rtx_insn *scan;\n \t  int total;\n \n \t  num_mova--;\n@@ -6448,7 +6449,7 @@ sh_reorg (void)\n int\n get_dest_uid (rtx label, int max_uid)\n {\n-  rtx dest = next_real_insn (label);\n+  rtx_insn *dest = next_real_insn (label);\n   int dest_uid;\n   if (! dest)\n     /* This can happen for an undefined label.  */\n@@ -6501,14 +6502,14 @@ split_branches (rtx_insn *first)\n \tenum attr_type type = get_attr_type (insn);\n \tif (type == TYPE_CBRANCH)\n \t  {\n-\t    rtx next, beyond;\n+\t    rtx_insn *next, *beyond;\n \n \t    if (get_attr_length (insn) > 4)\n \t      {\n \t\trtx src = SET_SRC (PATTERN (insn));\n \t\trtx olabel = XEXP (XEXP (src, 1), 0);\n \t\tint addr = INSN_ADDRESSES (INSN_UID (insn));\n-\t\trtx label = 0;\n+\t\trtx_insn *label = 0;\n \t\tint dest_uid = get_dest_uid (olabel, max_uid);\n \t\tstruct far_branch *bp = uid_branch[dest_uid];\n \n@@ -6529,16 +6530,17 @@ split_branches (rtx_insn *first)\n \t\t    uid_branch[dest_uid] = bp;\n \t\t    bp->prev = far_branch_list;\n \t\t    far_branch_list = bp;\n-\t\t    bp->far_label\n-\t\t      = XEXP (XEXP (SET_SRC (PATTERN (insn)), 1), 0);\n+\t\t    bp->far_label = as_a <rtx_insn *> (\n+\t\t\t\t      XEXP (XEXP (SET_SRC (PATTERN (insn)), 1),\n+\t\t\t\t\t    0));\n \t\t    LABEL_NUSES (bp->far_label)++;\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    label = bp->near_label;\n \t\t    if (! label && bp->address - addr >= CONDJUMP_MIN)\n \t\t      {\n-\t\t\trtx block = bp->insert_place;\n+\t\t\trtx_insn *block = bp->insert_place;\n \n \t\t\tif (GET_CODE (PATTERN (block)) == RETURN)\n \t\t\t  block = PREV_INSN (block);\n@@ -6611,13 +6613,14 @@ split_branches (rtx_insn *first)\n \telse if (type == TYPE_JUMP || type == TYPE_RETURN)\n \t  {\n \t    int addr = INSN_ADDRESSES (INSN_UID (insn));\n-\t    rtx far_label = 0;\n+\t    rtx_insn *far_label = 0;\n \t    int dest_uid = 0;\n \t    struct far_branch *bp;\n \n \t    if (type == TYPE_JUMP)\n \t      {\n-\t\tfar_label = XEXP (SET_SRC (PATTERN (insn)), 0);\n+\t\tfar_label = as_a <rtx_insn *> (\n+\t\t\t      XEXP (SET_SRC (PATTERN (insn)), 0));\n \t\tdest_uid = get_dest_uid (far_label, max_uid);\n \t\tif (! dest_uid)\n \t\t  {\n@@ -9907,7 +9910,7 @@ branch_dest (rtx branch)\n    We assume REG is a reload reg, and therefore does\n    not live past labels.  It may live past calls or jumps though.  */\n bool\n-reg_unused_after (rtx reg, rtx insn)\n+reg_unused_after (rtx reg, rtx_insn *insn)\n {\n   enum rtx_code code;\n   rtx set;\n@@ -10147,7 +10150,7 @@ fpscr_set_from_mem (int mode, HARD_REG_SET regs_live)\n #endif\n \n static bool\n-sequence_insn_p (rtx insn)\n+sequence_insn_p (rtx_insn *insn)\n {\n   rtx_insn *prev, *next;\n \n@@ -10668,7 +10671,8 @@ sh_delegitimize_address (rtx orig_x)\n static rtx\n mark_constant_pool_use (rtx x)\n {\n-  rtx insn, lab, pattern;\n+  rtx_insn *insn, *lab;\n+  rtx pattern;\n \n   if (x == NULL_RTX)\n     return x;\n@@ -10685,20 +10689,20 @@ mark_constant_pool_use (rtx x)\n \n   /* Get the first label in the list of labels for the same constant\n      and delete another labels in the list.  */\n-  lab = x;\n-  for (insn = PREV_INSN (x); insn; insn = PREV_INSN (insn))\n+  lab = as_a <rtx_insn *> (x);\n+  for (insn = PREV_INSN (lab); insn; insn = PREV_INSN (insn))\n     {\n       if (!LABEL_P (insn)\n \t  || LABEL_REFS (insn) != NEXT_INSN (insn))\n \tbreak;\n       lab = insn;\n     }\n \n-  for (insn = LABEL_REFS (lab); insn; insn = LABEL_REFS (insn))\n+  for (rtx insn = LABEL_REFS (lab); insn; insn = LABEL_REFS (insn))\n     INSN_DELETED_P (insn) = 1;\n \n   /* Mark constants in a window.  */\n-  for (insn = NEXT_INSN (x); insn; insn = NEXT_INSN (insn))\n+  for (insn = NEXT_INSN (as_a <rtx_insn *> (x)); insn; insn = NEXT_INSN (insn))\n     {\n       if (!NONJUMP_INSN_P (insn))\n \tcontinue;\n@@ -10732,7 +10736,7 @@ mark_constant_pool_use (rtx x)\n    of an unconditional jump BRANCH2.  We only want to do this if the\n    resulting branch will have a short displacement.  */\n bool\n-sh_can_redirect_branch (rtx branch1, rtx branch2)\n+sh_can_redirect_branch (rtx_insn *branch1, rtx_insn *branch2)\n {\n   if (flag_expensive_optimizations && simplejump_p (branch2))\n     {\n@@ -12702,7 +12706,7 @@ extract_sfunc_addr (rtx insn)\n    INSN is the use_sfunc_addr instruction, and REG is the register it\n    guards.  */\n bool\n-check_use_sfunc_addr (rtx insn, rtx reg)\n+check_use_sfunc_addr (rtx_insn *insn, rtx reg)\n {\n   /* Search for the sfunc.  It should really come right after INSN.  */\n   while ((insn = NEXT_INSN (insn)))\n@@ -12712,8 +12716,8 @@ check_use_sfunc_addr (rtx insn, rtx reg)\n       if (! INSN_P (insn))\n \tcontinue;\n \n-      if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\tinsn = XVECEXP (PATTERN (insn), 0, 0);\n+      if (rtx_sequence *seq = dyn_cast<rtx_sequence *> (PATTERN (insn)))\n+\tinsn = seq->insn (0);\n       if (GET_CODE (PATTERN (insn)) != PARALLEL\n \t  || get_attr_type (insn) != TYPE_SFUNC)\n \tcontinue;"}, {"sha": "3f92737b85b917b49af124fc2caa5584a83b1d0c", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -9996,7 +9996,8 @@ label:\n   sh_expand_epilogue (true);\n   if (TARGET_SHCOMPACT)\n     {\n-      rtx insn, set;\n+      rtx_insn *insn;\n+      rtx set;\n \n       /* If epilogue clobbers r0, preserve it in macl.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -10878,7 +10879,7 @@ label:\n    (clobber (match_scratch:SI 3 \"=X,1\"))]\n   \"TARGET_SH1\"\n {\n-  rtx diff_vec = PATTERN (NEXT_INSN (operands[2]));\n+  rtx diff_vec = PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[2])));\n \n   gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n \n@@ -10912,7 +10913,7 @@ label:\n    (clobber (match_operand:SI 4 \"\" \"=X,1\"))]\n   \"TARGET_SH2 && reload_completed && flag_pic\"\n {\n-  rtx diff_vec = PATTERN (NEXT_INSN (operands[2]));\n+  rtx diff_vec = PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[2])));\n   gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n \n   switch (GET_MODE (diff_vec))\n@@ -10950,7 +10951,7 @@ label:\n \t\t    UNSPEC_CASESI)))]\n   \"TARGET_SHMEDIA\"\n {\n-  rtx diff_vec = PATTERN (NEXT_INSN (operands[2]));\n+  rtx diff_vec = PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[2])));\n \n   gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n \n@@ -10977,7 +10978,7 @@ label:\n \t\t      (label_ref:DI (match_operand 3 \"\" \"\"))] UNSPEC_CASESI)))]\n   \"TARGET_SHMEDIA\"\n {\n-  rtx diff_vec = PATTERN (NEXT_INSN (operands[3]));\n+  rtx diff_vec = PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[3])));\n \n   gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n "}, {"sha": "f173cac58609c5291de91a04626fd5b0eff60d09", "filename": "gcc/config/sh/sh_optimize_sett_clrt.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsh%2Fsh_optimize_sett_clrt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsh%2Fsh_optimize_sett_clrt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh_optimize_sett_clrt.cc?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -88,9 +88,9 @@ class sh_optimize_sett_clrt : public rtl_opt_pass\n   struct ccreg_value\n   {\n     // The insn at which the ccreg value was determined.\n-    // Might be NULL_RTX if e.g. an unknown value is recorded for an\n+    // Might be NULL if e.g. an unknown value is recorded for an\n     // empty basic block.\n-    rtx insn;\n+    rtx_insn *insn;\n \n     // The basic block where the insn was discovered.\n     basic_block bb;\n@@ -111,7 +111,7 @@ class sh_optimize_sett_clrt : public rtl_opt_pass\n   // Given a start insn and its basic block, recursively determine all\n   // possible ccreg values in all basic block paths that can lead to the\n   // start insn.\n-  void find_last_ccreg_values (rtx start_insn, basic_block bb,\n+  void find_last_ccreg_values (rtx_insn *start_insn, basic_block bb,\n \t\t\t       std::vector<ccreg_value>& values_out,\n \t\t\t       std::vector<basic_block>& prev_visited_bb) const;\n \n@@ -205,7 +205,7 @@ sh_optimize_sett_clrt::execute (function* fun)\n   // be optimized.\n   basic_block bb;\n   FOR_EACH_BB_REVERSE_FN (bb, fun)\n-    for (rtx next_i, i = NEXT_INSN (BB_HEAD (bb));\n+    for (rtx_insn *next_i, *i = NEXT_INSN (BB_HEAD (bb));\n \t i != NULL_RTX && i != BB_END (bb); i = next_i)\n       {\n \tnext_i = NEXT_INSN (i);\n@@ -309,7 +309,7 @@ ::sh_cbranch_ccreg_value (rtx cbranch_insn, basic_block cbranch_insn_bb,\n \n void\n sh_optimize_sett_clrt\n-::find_last_ccreg_values (rtx start_insn, basic_block bb,\n+::find_last_ccreg_values (rtx_insn *start_insn, basic_block bb,\n \t\t\t  std::vector<ccreg_value>& values_out,\n \t\t\t  std::vector<basic_block>& prev_visited_bb) const\n {\n@@ -322,7 +322,7 @@ ::find_last_ccreg_values (rtx start_insn, basic_block bb,\n     log_msg (\"(prev visited [bb %d])\", prev_visited_bb.back ()->index);\n   log_msg (\"\\n\");\n \n-  for (rtx i = start_insn; i != NULL_RTX && i != PREV_INSN (BB_HEAD (bb));\n+  for (rtx_insn *i = start_insn; i != NULL && i != PREV_INSN (BB_HEAD (bb));\n        i = PREV_INSN (i))\n     {\n       if (!INSN_P (i))"}, {"sha": "1c0778978fb7d868efa1c4edef3b4a37a9e95b32", "filename": "gcc/config/sh/sh_treg_combine.cc", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsh%2Fsh_treg_combine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsh%2Fsh_treg_combine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh_treg_combine.cc?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -250,8 +250,8 @@ In order to handle cases such as above the RTL pass does the following:\n \n struct set_of_reg\n {\n-  // The insn where the search stopped or NULL_RTX.\n-  rtx insn;\n+  // The insn where the search stopped or NULL.\n+  rtx_insn *insn;\n \n   // The set rtx of the specified reg if found, NULL_RTX otherwise.\n   // Notice that the set rtx can also be in a parallel.\n@@ -281,14 +281,14 @@ struct set_of_reg\n // Given a reg rtx and a start insn find the insn (in the same basic block)\n // that sets the reg.\n static set_of_reg\n-find_set_of_reg_bb (rtx reg, rtx insn)\n+find_set_of_reg_bb (rtx reg, rtx_insn *insn)\n {\n   set_of_reg result = { insn, NULL_RTX };\n \n-  if (!REG_P (reg) || insn == NULL_RTX)\n+  if (!REG_P (reg) || insn == NULL)\n     return result;\n \n-  for (result.insn = insn; result.insn != NULL_RTX;\n+  for (result.insn = insn; result.insn != NULL;\n        result.insn = prev_nonnote_insn_bb (result.insn))\n     {\n       if (BARRIER_P (result.insn))\n@@ -338,7 +338,7 @@ is_adjacent_bb (basic_block a, basic_block b)\n \n // Internal function of trace_reg_uses.\n static void\n-trace_reg_uses_1 (rtx reg, rtx start_insn, basic_block bb, int& count,\n+trace_reg_uses_1 (rtx reg, rtx_insn *start_insn, basic_block bb, int& count,\n \t\t  std::vector<basic_block>& visited_bb, rtx abort_at_insn)\n {\n   if (bb == NULL)\n@@ -360,7 +360,7 @@ trace_reg_uses_1 (rtx reg, rtx start_insn, basic_block bb, int& count,\n   if (end_insn == NULL_RTX)\n     log_return_void (\"[bb %d] end_insn is null\\n\", bb->index);\n \n-  for (rtx i = NEXT_INSN (start_insn); i != end_insn; i = NEXT_INSN (i))\n+  for (rtx_insn *i = NEXT_INSN (start_insn); i != end_insn; i = NEXT_INSN (i))\n     {\n       if (INSN_P (i))\n \t{\n@@ -396,7 +396,7 @@ trace_reg_uses_1 (rtx reg, rtx start_insn, basic_block bb, int& count,\n // that insn.  If the insn 'abort_at_insn' uses the specified reg, it is also\n // counted.\n static int\n-trace_reg_uses (rtx reg, rtx start_insn, rtx abort_at_insn)\n+trace_reg_uses (rtx reg, rtx_insn *start_insn, rtx abort_at_insn)\n {\n   log_msg (\"\\ntrace_reg_uses\\nreg = \");\n   log_rtx (reg);\n@@ -463,7 +463,7 @@ class sh_treg_combine : public rtl_opt_pass\n   // A ccreg trace for a conditional branch.\n   struct cbranch_trace\n   {\n-    rtx cbranch_insn;\n+    rtx_insn *cbranch_insn;\n     branch_condition_type_t cbranch_type;\n \n     // The comparison against zero right before the conditional branch.\n@@ -473,7 +473,7 @@ class sh_treg_combine : public rtl_opt_pass\n     // the BB of the cbranch itself and might be empty.\n     std::list<bb_entry> bb_entries;\n \n-    cbranch_trace (rtx insn)\n+    cbranch_trace (rtx_insn *insn)\n     : cbranch_insn (insn),\n       cbranch_type (unknown_branch_condition),\n       setcc ()\n@@ -537,7 +537,8 @@ class sh_treg_combine : public rtl_opt_pass\n     set_not_found,\n     other_set_found\n   };\n-  record_return_t record_set_of_reg (rtx reg, rtx start_insn, bb_entry& e);\n+  record_return_t record_set_of_reg (rtx reg, rtx_insn *start_insn,\n+                                     bb_entry& e);\n \n   // Tells whether the cbranch insn of the specified bb_entry can be removed\n   // safely without triggering any side effects.\n@@ -584,7 +585,7 @@ class sh_treg_combine : public rtl_opt_pass\n \n   // Given a branch insn, try to optimize its branch condition.\n   // If any insns are modified or added they are added to 'm_touched_insns'.\n-  void try_optimize_cbranch (rtx i);\n+  void try_optimize_cbranch (rtx_insn *i);\n };\n \n \n@@ -670,7 +671,7 @@ sh_treg_combine::is_inverted_ccreg (const_rtx x) const\n }\n \n sh_treg_combine::record_return_t\n-sh_treg_combine::record_set_of_reg (rtx reg, rtx start_insn,\n+sh_treg_combine::record_set_of_reg (rtx reg, rtx_insn *start_insn,\n \t\t\t\t    bb_entry& new_entry)\n {\n   log_msg (\"\\n[bb %d]\\n\", new_entry.bb->index);\n@@ -680,7 +681,7 @@ sh_treg_combine::record_set_of_reg (rtx reg, rtx start_insn,\n \n   new_entry.cstore_type = cstore_unknown;\n \n-  for (rtx i = start_insn; i != NULL_RTX; )\n+  for (rtx_insn *i = start_insn; i != NULL; )\n     {\n       new_entry.cstore = find_set_of_reg_bb (reg, i);\n \n@@ -791,7 +792,7 @@ sh_treg_combine::can_remove_cstore (const bb_entry& e,\n   // must not be a usage of the copied regs between the reg-reg copies.\n   // Otherwise we assume that the result of the cstore is used in some\n   // other way.\n-  rtx prev_insn = e.cstore.insn;\n+  rtx_insn *prev_insn = e.cstore.insn;\n   for (std::vector<set_of_reg>::const_reverse_iterator i =\n \t   e.cstore_reg_reg_copies.rbegin ();\n        i != e.cstore_reg_reg_copies.rend (); ++i)\n@@ -1262,7 +1263,7 @@ sh_treg_combine::try_eliminate_cstores (cbranch_trace& trace,\n }\n \n void\n-sh_treg_combine::try_optimize_cbranch (rtx insn)\n+sh_treg_combine::try_optimize_cbranch (rtx_insn *insn)\n {\n   cbranch_trace trace (insn);\n \n@@ -1468,7 +1469,7 @@ sh_treg_combine::execute (function *fun)\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n-      rtx i = BB_END (bb);\n+      rtx_insn *i = BB_END (bb);\n       if (any_condjump_p (i) && onlyjump_p (i))\n \ttry_optimize_cbranch (i);\n     }"}, {"sha": "aab9376467a897c5b82588b82630ff97e0dbb5f7", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -83,7 +83,7 @@ extern void emit_conditional_branch_insn (rtx []);\n extern int registers_ok_for_ldd_peep (rtx, rtx);\n extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);\n extern rtx widen_mem_for_ldd_peep (rtx, rtx, enum machine_mode);\n-extern int empty_delay_slot (rtx);\n+extern int empty_delay_slot (rtx_insn *);\n extern int emit_cbcond_nop (rtx);\n extern int eligible_for_call_delay (rtx);\n extern int eligible_for_return_delay (rtx);\n@@ -99,7 +99,7 @@ extern int memory_ok_for_ldd (rtx);\n extern int v9_regcmp_p (enum rtx_code);\n /* Function used for V8+ code generation.  Returns 1 if the high\n    32 bits of REG are 0 before INSN.  */   \n-extern int sparc_check_64 (rtx, rtx);\n+extern int sparc_check_64 (rtx, rtx_insn *);\n extern rtx gen_df_reg (rtx, int);\n extern void sparc_expand_compare_and_swap (rtx op[]);\n extern void sparc_expand_vector_init (rtx, rtx);"}, {"sha": "ab79b5cebf66da2f98c3b241ade3721add9d4d98", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -550,7 +550,7 @@ static bool sparc_legitimate_constant_p (enum machine_mode, rtx);\n static rtx sparc_builtin_saveregs (void);\n static int epilogue_renumber (rtx *, int);\n static bool sparc_assemble_integer (rtx, unsigned int, int);\n-static int set_extends (rtx);\n+static int set_extends (rtx_insn *);\n static void sparc_asm_function_prologue (FILE *, HOST_WIDE_INT);\n static void sparc_asm_function_epilogue (FILE *, HOST_WIDE_INT);\n #ifdef TARGET_SOLARIS\n@@ -875,7 +875,7 @@ mem_ref (rtx x)\n static unsigned int\n sparc_do_work_around_errata (void)\n {\n-  rtx insn, next;\n+  rtx_insn *insn, *next;\n \n   /* Force all instructions to be split into their final form.  */\n   split_all_insns_noflow ();\n@@ -887,8 +887,9 @@ sparc_do_work_around_errata (void)\n       rtx set;\n \n       /* Look into the instruction in a delay slot.  */\n-      if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\tinsn = XVECEXP (PATTERN (insn), 0, 1);\n+      if (NONJUMP_INSN_P (insn))\n+\tif (rtx_sequence *seq = dyn_cast <rtx_sequence *> (PATTERN (insn)))\n+\t  insn = seq->insn (1);\n \n       /* Look for a single-word load into an odd-numbered FP register.  */\n       if (sparc_fix_at697f\n@@ -3425,7 +3426,7 @@ emit_tfmode_cvt (enum rtx_code code, rtx *operands)\n    nop into its delay slot.  */\n \n int\n-empty_delay_slot (rtx insn)\n+empty_delay_slot (rtx_insn *insn)\n {\n   rtx seq;\n \n@@ -9613,7 +9614,7 @@ sparc_issue_rate (void)\n }\n \n static int\n-set_extends (rtx insn)\n+set_extends (rtx_insn *insn)\n {\n   register rtx pat = PATTERN (insn);\n \n@@ -9779,7 +9780,7 @@ sparc_output_deferred_case_vectors (void)\n    unknown.  Return 1 if the high bits are zero, -1 if the register is\n    sign extended.  */\n int\n-sparc_check_64 (rtx x, rtx insn)\n+sparc_check_64 (rtx x, rtx_insn *insn)\n {\n   /* If a register is set only once it is safe to ignore insns this\n      code does not know how to handle.  The loop will either recognize"}, {"sha": "57e75d6fad7d9af58766f01c043f0387f2f53357", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -263,7 +263,7 @@ xstormy16_split_cbranch (enum machine_mode mode, rtx label, rtx comparison,\n {\n   rtx op0 = XEXP (comparison, 0);\n   rtx op1 = XEXP (comparison, 1);\n-  rtx seq, last_insn;\n+  rtx_insn *seq, *last_insn;\n   rtx compare;\n \n   start_sequence ();\n@@ -2389,7 +2389,7 @@ xstormy16_expand_builtin (tree exp, rtx target,\n    patterns.  */\n \n static void\n-combine_bnp (rtx insn)\n+combine_bnp (rtx_insn *insn)\n {\n   int insn_code, regno, need_extend;\n   unsigned int mask;\n@@ -2606,7 +2606,7 @@ combine_bnp (rtx insn)\n static void\n xstormy16_reorg (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {"}, {"sha": "0b2e3c5b9c9cb0ad1a167f968ed47651d15c6ca3", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -1114,15 +1114,15 @@ ep_memory_operand (rtx op, enum machine_mode mode, int unsigned_load)\n    taking care to save and preserve the ep.  */\n \n static void\n-substitute_ep_register (rtx first_insn,\n-                        rtx last_insn,\n+substitute_ep_register (rtx_insn *first_insn,\n+                        rtx_insn *last_insn,\n                         int uses,\n                         int regno,\n                         rtx * p_r1,\n                         rtx * p_ep)\n {\n   rtx reg = gen_rtx_REG (Pmode, regno);\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (!*p_r1)\n     {\n@@ -1227,16 +1227,16 @@ v850_reorg (void)\n   struct\n   {\n     int uses;\n-    rtx first_insn;\n-    rtx last_insn;\n+    rtx_insn *first_insn;\n+    rtx_insn *last_insn;\n   }\n   regs[FIRST_PSEUDO_REGISTER];\n \n   int i;\n   int use_ep = FALSE;\n   rtx r1 = NULL_RTX;\n   rtx ep = NULL_RTX;\n-  rtx insn;\n+  rtx_insn *insn;\n   rtx pattern;\n \n   /* If not ep mode, just return now.  */\n@@ -1246,8 +1246,8 @@ v850_reorg (void)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       regs[i].uses = 0;\n-      regs[i].first_insn = NULL_RTX;\n-      regs[i].last_insn = NULL_RTX;\n+      regs[i].first_insn = NULL;\n+      regs[i].last_insn = NULL;\n     }\n \n   for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n@@ -1280,8 +1280,8 @@ v850_reorg (void)\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t    {\n \t      regs[i].uses = 0;\n-\t      regs[i].first_insn = NULL_RTX;\n-\t      regs[i].last_insn = NULL_RTX;\n+\t      regs[i].first_insn = NULL;\n+\t      regs[i].last_insn = NULL;\n \t    }\n \t  break;\n \n@@ -1413,17 +1413,17 @@ v850_reorg (void)\n \t\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t\t\t    {\n \t\t\t      regs[i].uses = 0;\n-\t\t\t      regs[i].first_insn = NULL_RTX;\n-\t\t\t      regs[i].last_insn = NULL_RTX;\n+\t\t\t      regs[i].first_insn = NULL;\n+\t\t\t      regs[i].last_insn = NULL;\n \t\t\t    }\n \t\t\t}\n \t\t    }\n \n \t\t  for (i = regno; i < endregno; i++)\n \t\t    {\n \t\t      regs[i].uses = 0;\n-\t\t      regs[i].first_insn = NULL_RTX;\n-\t\t      regs[i].last_insn = NULL_RTX;\n+\t\t      regs[i].first_insn = NULL;\n+\t\t      regs[i].last_insn = NULL;\n \t\t    }\n \t\t}\n \t    }"}, {"sha": "1f57c3f5cd833c837bc08ac8d91d0b93aede6fcc", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -2465,7 +2465,7 @@ add_call_site (rtx landing_pad, int action, int section)\n }\n \n static rtx_note *\n-emit_note_eh_region_end (rtx insn)\n+emit_note_eh_region_end (rtx_insn *insn)\n {\n   rtx_insn *next = NEXT_INSN (insn);\n "}, {"sha": "d02222615c92855a47378c0879b64749198c8b24", "filename": "gcc/final.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -189,7 +189,7 @@ static int app_on;\n /* If we are outputting an insn sequence, this contains the sequence rtx.\n    Zero otherwise.  */\n \n-rtx final_sequence;\n+rtx_sequence *final_sequence;\n \n #ifdef ASSEMBLER_DIALECT\n \n@@ -1279,13 +1279,14 @@ shorten_branches (rtx_insn *first)\n \t    {\n \t      rtx body = PATTERN (insn);\n \t      int old_length = insn_lengths[uid];\n-\t      rtx rel_lab = XEXP (XEXP (body, 0), 0);\n+\t      rtx_insn *rel_lab =\n+\t\tsafe_as_a <rtx_insn *> (XEXP (XEXP (body, 0), 0));\n \t      rtx min_lab = XEXP (XEXP (body, 2), 0);\n \t      rtx max_lab = XEXP (XEXP (body, 3), 0);\n \t      int rel_addr = INSN_ADDRESSES (INSN_UID (rel_lab));\n \t      int min_addr = INSN_ADDRESSES (INSN_UID (min_lab));\n \t      int max_addr = INSN_ADDRESSES (INSN_UID (max_lab));\n-\t      rtx prev;\n+\t      rtx_insn *prev;\n \t      int rel_align = 0;\n \t      addr_diff_vec_flags flags;\n \t      enum machine_mode vec_mode;\n@@ -2619,7 +2620,7 @@ final_scan_insn (rtx uncast_insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    /* A delayed-branch sequence */\n \t    int i;\n \n-\t    final_sequence = body;\n+\t    final_sequence = seq;\n \n \t    /* The first insn in this SEQUENCE might be a JUMP_INSN that will\n \t       force the restoration of a comparison that was previously"}, {"sha": "54fb9b4b11b05418db621570e4123ed500936728", "filename": "gcc/function.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -3019,7 +3019,8 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t  && insn_operand_matches (icode, 1, op1))\n \t{\n \t  enum rtx_code code = unsignedp ? ZERO_EXTEND : SIGN_EXTEND;\n-\t  rtx insn, insns, t = op1;\n+\t  rtx_insn *insn, *insns;\n+\t  rtx t = op1;\n \t  HARD_REG_SET hardregs;\n \n \t  start_sequence ();\n@@ -3038,8 +3039,9 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t    }\n \t  else\n \t    t = op1;\n-\t  insn = gen_extend_insn (op0, t, promoted_nominal_mode,\n-\t\t\t\t  data->passed_mode, unsignedp);\n+\t  insn = as_a <rtx_insn *> (\n+\t\t   gen_extend_insn (op0, t, promoted_nominal_mode,\n+\t\t\t\t    data->passed_mode, unsignedp));\n \t  emit_insn (insn);\n \t  insns = get_insns ();\n "}, {"sha": "44c9863b70d99f8d00db6e5485d64271341a956b", "filename": "gcc/genattr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -177,7 +177,7 @@ main (int argc, char **argv)\n \t  if (! have_delay)\n \t    {\n \t      printf (\"extern int num_delay_slots (rtx);\\n\");\n-\t      printf (\"extern int eligible_for_delay (rtx, int, rtx, int);\\n\\n\");\n+\t      printf (\"extern int eligible_for_delay (rtx_insn *, int, rtx_insn *, int);\\n\\n\");\n \t      printf (\"extern int const_num_delay_slots (rtx);\\n\\n\");\n \t      have_delay = 1;\n \t    }\n@@ -187,14 +187,14 @@ main (int argc, char **argv)\n \t      if (XVECEXP (desc, 1, i + 1) && ! have_annul_true)\n \t\t{\n \t\t  printf (\"#define ANNUL_IFTRUE_SLOTS\\n\");\n-\t\t  printf (\"extern int eligible_for_annul_true (rtx, int, rtx, int);\\n\");\n+\t\t  printf (\"extern int eligible_for_annul_true (rtx_insn *, int, rtx_insn *, int);\\n\");\n \t\t  have_annul_true = 1;\n \t\t}\n \n \t      if (XVECEXP (desc, 1, i + 2) && ! have_annul_false)\n \t\t{\n \t\t  printf (\"#define ANNUL_IFFALSE_SLOTS\\n\");\n-\t\t  printf (\"extern int eligible_for_annul_false (rtx, int, rtx, int);\\n\");\n+\t\t  printf (\"extern int eligible_for_annul_false (rtx_insn *, int, rtx_insn *, int);\\n\");\n \t\t  have_annul_false = 1;\n \t\t}\n \t    }"}, {"sha": "4452b91a7f393fee90c4dba7b507ada1f5fd9e7b", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -4456,11 +4456,11 @@ write_eligible_delay (FILE *outf, const char *kind)\n   /* Write function prelude.  */\n \n   fprintf (outf, \"int\\n\");\n-  fprintf (outf, \"eligible_for_%s (rtx delay_insn ATTRIBUTE_UNUSED, int slot, \\n\"\n-\t\t \"\t\t   rtx candidate_insn, int flags ATTRIBUTE_UNUSED)\\n\",\n+  fprintf (outf, \"eligible_for_%s (rtx_insn *delay_insn ATTRIBUTE_UNUSED, int slot, \\n\"\n+\t\t \"\t\t   rtx_insn *candidate_insn, int flags ATTRIBUTE_UNUSED)\\n\",\n \t   kind);\n   fprintf (outf, \"{\\n\");\n-  fprintf (outf, \"  rtx insn;\\n\");\n+  fprintf (outf, \"  rtx_insn *insn;\\n\");\n   fprintf (outf, \"\\n\");\n   fprintf (outf, \"  gcc_assert (slot < %d);\\n\", max_slots);\n   fprintf (outf, \"\\n\");"}, {"sha": "745bfd1dc5fa242b246c16bd768c1c1d34d6353a", "filename": "gcc/hw-doloop.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fhw-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fhw-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -360,7 +360,8 @@ discover_loops (bitmap_obstack *loop_stack, struct hw_doloop_hooks *hooks)\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       rtx_insn *tail = BB_END (bb);\n-      rtx insn, reg;\n+      rtx_insn *insn;\n+      rtx reg;\n \n       while (tail && NOTE_P (tail) && tail != BB_HEAD (bb))\n \ttail = PREV_INSN (tail);\n@@ -378,7 +379,7 @@ discover_loops (bitmap_obstack *loop_stack, struct hw_doloop_hooks *hooks)\n \n       /* There's a degenerate case we can handle - an empty loop consisting\n \t of only a back branch.  Handle that by deleting the branch.  */\n-      insn = JUMP_LABEL (tail);\n+      insn = JUMP_LABEL_AS_INSN (tail);\n       while (insn && !NONDEBUG_INSN_P (insn))\n \tinsn = NEXT_INSN (insn);\n       if (insn == tail)"}, {"sha": "48072cfacc082c4793c1ec41cbd7df3629f6676d", "filename": "gcc/hw-doloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fhw-doloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fhw-doloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.h?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -75,7 +75,7 @@ struct GTY (()) hwloop_info_d\n   rtx iter_reg;\n \n   /* The new label placed at the beginning of the loop. */\n-  rtx start_label;\n+  rtx_insn *start_label;\n \n   /* The new label placed at the end of the loop. */\n   rtx end_label;"}, {"sha": "a48368ccced2d13f3e7b27f3267757103e290781", "filename": "gcc/ira.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -2016,7 +2016,8 @@ decrease_live_ranges_number (void)\n {\n   basic_block bb;\n   rtx_insn *insn;\n-  rtx set, src, dest, dest_death, p, q, note;\n+  rtx set, src, dest, dest_death, q, note;\n+  rtx_insn *p;\n   int sregno, dregno;\n \n   if (! flag_expensive_optimizations)\n@@ -2581,9 +2582,10 @@ setup_reg_equiv_init (void)\n    to update equiv info for register shuffles on the region borders\n    and for caller save/restore insns.  */\n void\n-ira_update_equiv_info_by_shuffle_insn (int to_regno, int from_regno, rtx insns)\n+ira_update_equiv_info_by_shuffle_insn (int to_regno, int from_regno, rtx_insn *insns)\n {\n-  rtx insn, x, note;\n+  rtx_insn *insn;\n+  rtx x, note;\n \n   if (! ira_reg_equiv[from_regno].defined_p\n       && (! ira_reg_equiv[to_regno].defined_p\n@@ -2932,9 +2934,9 @@ validate_equiv_mem_from_store (rtx dest, const_rtx set ATTRIBUTE_UNUSED,\n \n    Return 1 if MEMREF remains valid.  */\n static int\n-validate_equiv_mem (rtx start, rtx reg, rtx memref)\n+validate_equiv_mem (rtx_insn *start, rtx reg, rtx memref)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   rtx note;\n \n   equiv_mem = memref;\n@@ -3208,9 +3210,9 @@ memref_referenced_p (rtx memref, rtx x)\n /* TRUE if some insn in the range (START, END] references a memory location\n    that would be affected by a store to MEMREF.  */\n static int\n-memref_used_between_p (rtx memref, rtx start, rtx end)\n+memref_used_between_p (rtx memref, rtx_insn *start, rtx_insn *end)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n        insn = NEXT_INSN (insn))"}, {"sha": "138b763def3e4af895cf6375a5a361dea23f2177", "filename": "gcc/ira.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -183,7 +183,7 @@ extern rtx ira_eliminate_regs (rtx, enum machine_mode);\n extern void ira_set_pseudo_classes (bool, FILE *);\n extern void ira_implicitly_set_insn_hard_regs (HARD_REG_SET *);\n extern void ira_expand_reg_equiv (void);\n-extern void ira_update_equiv_info_by_shuffle_insn (int, int, rtx);\n+extern void ira_update_equiv_info_by_shuffle_insn (int, int, rtx_insn *);\n \n extern void ira_sort_regnos_for_alter_reg (int *, int, unsigned int *);\n extern void ira_mark_allocation_change (int);"}, {"sha": "f7cee7b14335c7b5c8676eae977b17dad128ad24", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -713,10 +713,12 @@ doloop_optimize (struct loop *loop)\n   doloop_pat = doloop_seq;\n   if (INSN_P (doloop_pat))\n     {\n-      while (NEXT_INSN (doloop_pat) != NULL_RTX)\n-\tdoloop_pat = NEXT_INSN (doloop_pat);\n-      if (!JUMP_P (doloop_pat))\n-\tdoloop_pat = NULL_RTX;\n+      rtx_insn *doloop_insn = as_a <rtx_insn *> (doloop_pat);\n+      while (NEXT_INSN (doloop_insn) != NULL_RTX)\n+\tdoloop_insn = NEXT_INSN (doloop_insn);\n+      if (!JUMP_P (doloop_insn))\n+\tdoloop_insn = NULL;\n+      doloop_pat = doloop_insn;\n     }\n \n   if (! doloop_pat"}, {"sha": "2c5c06a597ce9d479fed84b17bc46eb2321d93f0", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -296,7 +296,7 @@ extern void output_quoted_string (FILE *, const char *);\n    insn output code.\n \n    This variable is defined  in final.c.  */\n-extern rtx final_sequence;\n+extern rtx_sequence *final_sequence;\n \n /* The line number of the beginning of the current function.  Various\n    md code needs this so that it can output relative linenumbers.  */"}, {"sha": "469dfe68a08773ad72bf551c7d419de53b24f862", "filename": "gcc/recog.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -3161,12 +3161,14 @@ peep2_reinit_state (regset live)\n    if the replacement is rejected.  */\n \n static rtx\n-peep2_attempt (basic_block bb, rtx insn, int match_len, rtx attempt)\n+peep2_attempt (basic_block bb, rtx uncast_insn, int match_len, rtx_insn *attempt)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n   int i;\n   rtx_insn *last, *before_try, *x;\n   rtx eh_note, as_note;\n-  rtx old_insn, new_insn;\n+  rtx old_insn;\n+  rtx_insn *new_insn;\n   bool was_call = false;\n \n   /* If we are splitting an RTX_FRAME_RELATED_P insn, do not allow it to\n@@ -3471,7 +3473,7 @@ peep2_fill_buffer (basic_block bb, rtx insn, regset live)\n static void\n peephole2_optimize (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   bitmap live;\n   int i;\n   basic_block bb;\n@@ -3504,7 +3506,8 @@ peephole2_optimize (void)\n       insn = BB_HEAD (bb);\n       for (;;)\n \t{\n-\t  rtx attempt, head;\n+\t  rtx_insn *attempt;\n+\t  rtx head;\n \t  int match_len;\n \n \t  if (!past_end && !NONDEBUG_INSN_P (insn))\n@@ -3531,7 +3534,8 @@ peephole2_optimize (void)\n \n \t  /* Match the peephole.  */\n \t  head = peep2_insn_data[peep2_current].insn;\n-\t  attempt = peephole2_insns (PATTERN (head), head, &match_len);\n+\t  attempt = safe_as_a <rtx_insn *> (\n+\t\t      peephole2_insns (PATTERN (head), head, &match_len));\n \t  if (attempt != NULL)\n \t    {\n \t      rtx last = peep2_attempt (bb, head, match_len, attempt);"}, {"sha": "1431b7a0a88b8f977a6a95af0010047963987aff", "filename": "gcc/ree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -797,7 +797,7 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n                                  REGNO (SET_DEST (pat)));\n       emit_move_insn (new_dst, new_src);\n \n-      rtx insn = get_insns();\n+      rtx_insn *insn = get_insns();\n       end_sequence ();\n       if (NEXT_INSN (insn))\n \treturn false;"}, {"sha": "c18ee6703a8705c559514e2fabb8265821007bb5", "filename": "gcc/reload1.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -4573,7 +4573,6 @@ reload_as_needed (int live_known)\n #if defined (AUTO_INC_DEC)\n   int i;\n #endif\n-  rtx x;\n   rtx_note *marker;\n \n   memset (spill_reg_rtx, 0, sizeof spill_reg_rtx);\n@@ -4662,7 +4661,6 @@ reload_as_needed (int live_known)\n \t  if (n_reloads > 0)\n \t    {\n \t      rtx_insn *next = NEXT_INSN (insn);\n-\t      rtx p;\n \n \t      /* ??? PREV can get deleted by reload inheritance.\n \t\t Work around this by emitting a marker note.  */\n@@ -4693,7 +4691,7 @@ reload_as_needed (int live_known)\n \t\tfixup_eh_region_note (insn, prev, next);\n \n \t      /* Adjust the location of REG_ARGS_SIZE.  */\n-\t      p = find_reg_note (insn, REG_ARGS_SIZE, NULL_RTX);\n+\t      rtx p = find_reg_note (insn, REG_ARGS_SIZE, NULL_RTX);\n \t      if (p)\n \t\t{\n \t\t  remove_note (insn, p);\n@@ -4705,7 +4703,9 @@ reload_as_needed (int live_known)\n \t\t we have generated are valid.  If not, give an error\n \t\t and delete them.  */\n \t      if (asm_noperands (PATTERN (insn)) >= 0)\n-\t\tfor (p = NEXT_INSN (prev); p != next; p = NEXT_INSN (p))\n+\t\tfor (rtx_insn *p = NEXT_INSN (prev);\n+\t\t     p != next;\n+\t\t     p = NEXT_INSN (p))\n \t\t  if (p != insn && INSN_P (p)\n \t\t      && GET_CODE (PATTERN (p)) != USE\n \t\t      && (recog_memoized (p) < 0\n@@ -4732,7 +4732,7 @@ reload_as_needed (int live_known)\n \n \t  /* There may have been CLOBBER insns placed after INSN.  So scan\n \t     between INSN and NEXT and use them to forget old reloads.  */\n-\t  for (x = NEXT_INSN (insn); x != old_next; x = NEXT_INSN (x))\n+\t  for (rtx_insn *x = NEXT_INSN (insn); x != old_next; x = NEXT_INSN (x))\n \t    if (NONJUMP_INSN_P (x) && GET_CODE (PATTERN (x)) == CLOBBER)\n \t      note_stores (PATTERN (x), forget_old_reloads_1, NULL);\n \n@@ -4764,7 +4764,7 @@ reload_as_needed (int live_known)\n \t\t      rtx reload_reg = rld[i].reg_rtx;\n \t\t      enum machine_mode mode = GET_MODE (reload_reg);\n \t\t      int n = 0;\n-\t\t      rtx p;\n+\t\t      rtx_insn *p;\n \n \t\t      for (p = PREV_INSN (old_next); p != prev; p = PREV_INSN (p))\n \t\t\t{\n@@ -4846,7 +4846,8 @@ reload_as_needed (int live_known)\n \t\t\t  if (TEST_HARD_REG_BIT (reg_reloaded_valid,\n \t\t\t\t\t\t in_hard_regno))\n \t\t\t    {\n-\t\t\t      for (x = old_prev ? NEXT_INSN (old_prev) : insn;\n+\t\t\t      for (rtx_insn *x = (old_prev ?\n+\t\t\t\t\t\t  NEXT_INSN (old_prev) : insn);\n \t\t\t\t   x != old_next;\n \t\t\t\t   x = NEXT_INSN (x))\n \t\t\t\tif (x == reg_reloaded_insn[in_hard_regno])\n@@ -4874,7 +4875,7 @@ reload_as_needed (int live_known)\n \t  /* If a pseudo that got a hard register is auto-incremented,\n \t     we must purge records of copying it into pseudos without\n \t     hard registers.  */\n-\t  for (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n+\t  for (rtx x = REG_NOTES (insn); x; x = XEXP (x, 1))\n \t    if (REG_NOTE_KIND (x) == REG_INC)\n \t      {\n \t\t/* See if this pseudo reg was reloaded in this insn.\n@@ -8840,7 +8841,6 @@ delete_output_reload (rtx_insn *insn, int j, int last_reload_reg,\n   int k;\n   int n_occurrences;\n   int n_inherited = 0;\n-  rtx i1;\n   rtx substed;\n   unsigned regno;\n   int nregs;\n@@ -8887,7 +8887,7 @@ delete_output_reload (rtx_insn *insn, int j, int last_reload_reg,\n     n_occurrences += count_occurrences (PATTERN (insn),\n \t\t\t\t\teliminate_regs (substed, VOIDmode,\n \t\t\t\t\t\t\tNULL_RTX), 0);\n-  for (i1 = reg_equiv_alt_mem_list (REGNO (reg)); i1; i1 = XEXP (i1, 1))\n+  for (rtx i1 = reg_equiv_alt_mem_list (REGNO (reg)); i1; i1 = XEXP (i1, 1))\n     {\n       gcc_assert (!rtx_equal_p (XEXP (i1, 0), substed));\n       n_occurrences += count_occurrences (PATTERN (insn), XEXP (i1, 0), 0);\n@@ -8906,7 +8906,7 @@ delete_output_reload (rtx_insn *insn, int j, int last_reload_reg,\n      and we're within the same basic block, then the value can only\n      pass through the reload reg and end up here.\n      Otherwise, give up--return.  */\n-  for (i1 = NEXT_INSN (output_reload_insn);\n+  for (rtx_insn *i1 = NEXT_INSN (output_reload_insn);\n        i1 != insn; i1 = NEXT_INSN (i1))\n     {\n       if (NOTE_INSN_BASIC_BLOCK_P (i1))"}, {"sha": "4681e02aae9cc43ce3837cae160436cca67611ea", "filename": "gcc/reorg.c", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -219,27 +219,27 @@ static int get_jump_flags (rtx, rtx);\n static int mostly_true_jump (rtx);\n static rtx get_branch_condition (rtx, rtx);\n static int condition_dominates_p (rtx, rtx);\n-static int redirect_with_delay_slots_safe_p (rtx, rtx, rtx);\n-static int redirect_with_delay_list_safe_p (rtx, rtx, rtx);\n+static int redirect_with_delay_slots_safe_p (rtx_insn *, rtx, rtx);\n+static int redirect_with_delay_list_safe_p (rtx_insn *, rtx, rtx_insn_list *);\n static int check_annul_list_true_false (int, rtx);\n-static rtx_insn_list *steal_delay_list_from_target (rtx, rtx,\n+static rtx_insn_list *steal_delay_list_from_target (rtx_insn *, rtx,\n \t\t\t\t\t\t    rtx_sequence *,\n \t\t\t\t\t\t    rtx_insn_list *,\n \t\t\t\t\t\t    struct resources *,\n \t\t\t\t\t\t    struct resources *,\n \t\t\t\t\t\t    struct resources *,\n \t\t\t\t\t\t    int, int *, int *,\n \t\t\t\t\t\t    rtx_insn **);\n-static rtx_insn_list *steal_delay_list_from_fallthrough (rtx, rtx,\n+static rtx_insn_list *steal_delay_list_from_fallthrough (rtx_insn *, rtx,\n \t\t\t\t\t\t\t rtx_sequence *,\n \t\t\t\t\t\t\t rtx_insn_list *,\n \t\t\t\t\t\t\t struct resources *,\n \t\t\t\t\t\t\t struct resources *,\n \t\t\t\t\t\t\t struct resources *,\n \t\t\t\t\t\t\t int, int *, int *);\n-static void try_merge_delay_insns (rtx, rtx);\n-static rtx redundant_insn (rtx, rtx, rtx);\n-static int own_thread_p (rtx, rtx, int);\n+static void try_merge_delay_insns (rtx, rtx_insn *);\n+static rtx redundant_insn (rtx, rtx_insn *, rtx);\n+static int own_thread_p (rtx_insn *, rtx, int);\n static void update_block (rtx, rtx);\n static int reorg_redirect_jump (rtx, rtx);\n static void update_reg_dead_notes (rtx, rtx);\n@@ -252,7 +252,7 @@ static rtx_insn_list *fill_slots_from_thread (rtx_insn *, rtx,\n \t\t\t\t\t      int *, rtx_insn_list *);\n static void fill_eager_delay_slots (void);\n static void relax_delay_slots (rtx_insn *);\n-static void make_return_insns (rtx);\n+static void make_return_insns (rtx_insn *);\n \f\n /* A wrapper around next_active_insn which takes care to return ret_rtx\n    unchanged.  */\n@@ -978,63 +978,62 @@ condition_dominates_p (rtx condition, rtx insn)\n    any insns already in the delay slot of JUMP.  */\n \n static int\n-redirect_with_delay_slots_safe_p (rtx jump, rtx newlabel, rtx seq)\n+redirect_with_delay_slots_safe_p (rtx_insn *jump, rtx newlabel, rtx seq)\n {\n   int flags, i;\n-  rtx pat = PATTERN (seq);\n+  rtx_sequence *pat = as_a <rtx_sequence *> (PATTERN (seq));\n \n   /* Make sure all the delay slots of this jump would still\n      be valid after threading the jump.  If they are still\n      valid, then return nonzero.  */\n \n   flags = get_jump_flags (jump, newlabel);\n-  for (i = 1; i < XVECLEN (pat, 0); i++)\n+  for (i = 1; i < pat->len (); i++)\n     if (! (\n #ifdef ANNUL_IFFALSE_SLOTS\n \t   (INSN_ANNULLED_BRANCH_P (jump)\n-\t    && INSN_FROM_TARGET_P (XVECEXP (pat, 0, i)))\n-\t   ? eligible_for_annul_false (jump, i - 1,\n-\t\t\t\t       XVECEXP (pat, 0, i), flags) :\n+\t    && INSN_FROM_TARGET_P (pat->insn (i)))\n+\t   ? eligible_for_annul_false (jump, i - 1, pat->insn (i), flags) :\n #endif\n #ifdef ANNUL_IFTRUE_SLOTS\n \t   (INSN_ANNULLED_BRANCH_P (jump)\n \t    && ! INSN_FROM_TARGET_P (XVECEXP (pat, 0, i)))\n-\t   ? eligible_for_annul_true (jump, i - 1,\n-\t\t\t\t      XVECEXP (pat, 0, i), flags) :\n+\t   ? eligible_for_annul_true (jump, i - 1, pat->insn (i), flags) :\n #endif\n-\t   eligible_for_delay (jump, i - 1, XVECEXP (pat, 0, i), flags)))\n+\t   eligible_for_delay (jump, i - 1, pat->insn (i), flags)))\n       break;\n \n-  return (i == XVECLEN (pat, 0));\n+  return (i == pat->len ());\n }\n \n /* Return nonzero if redirecting JUMP to NEWLABEL does not invalidate\n    any insns we wish to place in the delay slot of JUMP.  */\n \n static int\n-redirect_with_delay_list_safe_p (rtx jump, rtx newlabel, rtx delay_list)\n+redirect_with_delay_list_safe_p (rtx_insn *jump, rtx newlabel,\n+\t\t\t\t rtx_insn_list *delay_list)\n {\n   int flags, i;\n-  rtx li;\n+  rtx_insn_list *li;\n \n   /* Make sure all the insns in DELAY_LIST would still be\n      valid after threading the jump.  If they are still\n      valid, then return nonzero.  */\n \n   flags = get_jump_flags (jump, newlabel);\n-  for (li = delay_list, i = 0; li; li = XEXP (li, 1), i++)\n+  for (li = delay_list, i = 0; li; li = li->next (), i++)\n     if (! (\n #ifdef ANNUL_IFFALSE_SLOTS\n \t   (INSN_ANNULLED_BRANCH_P (jump)\n-\t    && INSN_FROM_TARGET_P (XEXP (li, 0)))\n-\t   ? eligible_for_annul_false (jump, i, XEXP (li, 0), flags) :\n+\t    && INSN_FROM_TARGET_P (li->insn ()))\n+\t   ? eligible_for_annul_false (jump, i, li->insn (), flags) :\n #endif\n #ifdef ANNUL_IFTRUE_SLOTS\n \t   (INSN_ANNULLED_BRANCH_P (jump)\n \t    && ! INSN_FROM_TARGET_P (XEXP (li, 0)))\n-\t   ? eligible_for_annul_true (jump, i, XEXP (li, 0), flags) :\n+\t   ? eligible_for_annul_true (jump, i, li->insn (), flags) :\n #endif\n-\t   eligible_for_delay (jump, i, XEXP (li, 0), flags)))\n+\t   eligible_for_delay (jump, i, li->insn (), flags)))\n       break;\n \n   return (li == NULL);\n@@ -1085,7 +1084,7 @@ check_annul_list_true_false (int annul_true_p, rtx delay_list)\n    execution should continue.  */\n \n static rtx_insn_list *\n-steal_delay_list_from_target (rtx insn, rtx condition, rtx_sequence *seq,\n+steal_delay_list_from_target (rtx_insn *insn, rtx condition, rtx_sequence *seq,\n \t\t\t      rtx_insn_list *delay_list, struct resources *sets,\n \t\t\t      struct resources *needed,\n \t\t\t      struct resources *other_needed,\n@@ -1226,7 +1225,8 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx_sequence *seq,\n    for INSN since unconditional branches are much easier to fill.  */\n \n static rtx_insn_list *\n-steal_delay_list_from_fallthrough (rtx insn, rtx condition, rtx_sequence *seq,\n+steal_delay_list_from_fallthrough (rtx_insn *insn, rtx condition,\n+\t\t\t\t   rtx_sequence *seq,\n \t\t\t\t   rtx_insn_list *delay_list,\n \t\t\t\t   struct resources *sets,\n \t\t\t\t   struct resources *needed,\n@@ -1307,10 +1307,10 @@ steal_delay_list_from_fallthrough (rtx insn, rtx condition, rtx_sequence *seq,\n    we delete the merged insn.  */\n \n static void\n-try_merge_delay_insns (rtx insn, rtx thread)\n+try_merge_delay_insns (rtx insn, rtx_insn *thread)\n {\n-  rtx trial, next_trial;\n-  rtx delay_insn = XVECEXP (PATTERN (insn), 0, 0);\n+  rtx_insn *trial, *next_trial;\n+  rtx_insn *delay_insn = as_a <rtx_insn *> (XVECEXP (PATTERN (insn), 0, 0));\n   int annul_p = JUMP_P (delay_insn) && INSN_ANNULLED_BRANCH_P (delay_insn);\n   int slot_number = 1;\n   int num_slots = XVECLEN (PATTERN (insn), 0);\n@@ -1499,11 +1499,12 @@ try_merge_delay_insns (rtx insn, rtx thread)\n    gain in rare cases.  */\n \n static rtx\n-redundant_insn (rtx insn, rtx target, rtx delay_list)\n+redundant_insn (rtx insn, rtx_insn *target, rtx delay_list)\n {\n   rtx target_main = target;\n   rtx ipat = PATTERN (insn);\n-  rtx trial, pat;\n+  rtx_insn *trial;\n+  rtx pat;\n   struct resources needed, set;\n   int i;\n   unsigned insns_to_search;\n@@ -1714,10 +1715,10 @@ redundant_insn (rtx insn, rtx target, rtx delay_list)\n    finding an active insn, we do not own this thread.  */\n \n static int\n-own_thread_p (rtx thread, rtx label, int allow_fallthrough)\n+own_thread_p (rtx_insn *thread, rtx label, int allow_fallthrough)\n {\n-  rtx active_insn;\n-  rtx insn;\n+  rtx_insn *active_insn;\n+  rtx_insn *insn;\n \n   /* We don't own the function end.  */\n   if (thread == 0 || ANY_RETURN_P (thread))\n@@ -1884,7 +1885,7 @@ static vec <rtx> sibling_labels;\n    the new label.  */\n \n static rtx_insn *\n-get_label_before (rtx insn, rtx sibling)\n+get_label_before (rtx_insn *insn, rtx sibling)\n {\n   rtx_insn *label;\n \n@@ -2247,7 +2248,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t    {\n \t      /* See comment in relax_delay_slots about necessity of using\n \t\t next_real_insn here.  */\n-\t      rtx new_label = next_real_insn (next_trial);\n+\t      rtx_insn *new_label = next_real_insn (next_trial);\n \n \t      if (new_label != 0)\n \t\tnew_label = get_label_before (new_label, JUMP_LABEL (trial));\n@@ -2274,8 +2275,8 @@ fill_simple_delay_slots (int non_jumps_p)\n \t  = fill_slots_from_thread (insn, const_true_rtx,\n \t\t\t\t    next_active_insn (JUMP_LABEL (insn)),\n \t\t\t\t    NULL, 1, 1,\n-\t\t\t\t    own_thread_p (JUMP_LABEL (insn),\n-\t\t\t\t\t\t  JUMP_LABEL (insn), 0),\n+\t\t\t\t    own_thread_p (JUMP_LABEL_AS_INSN (insn),\n+\t\t\t\t\t\t  JUMP_LABEL_AS_INSN (insn), 0),\n \t\t\t\t    slots_to_fill, &slots_filled,\n \t\t\t\t    delay_list);\n \n@@ -3127,15 +3128,15 @@ delete_jump (rtx insn)\n     delete_computation (insn);\n }\n \n-static rtx\n+static rtx_insn *\n label_before_next_insn (rtx x, rtx scan_limit)\n {\n-  rtx insn = next_active_insn (x);\n+  rtx_insn *insn = next_active_insn (x);\n   while (insn)\n     {\n       insn = PREV_INSN (insn);\n       if (insn == scan_limit || insn == NULL_RTX)\n-\treturn NULL_RTX;\n+\treturn NULL;\n       if (LABEL_P (insn))\n \tbreak;\n     }\n@@ -3157,7 +3158,7 @@ relax_delay_slots (rtx_insn *first)\n   /* Look at every JUMP_INSN and see if we can improve it.  */\n   for (insn = first; insn; insn = next)\n     {\n-      rtx other;\n+      rtx_insn *other;\n       bool crossing;\n \n       next = next_active_insn (insn);\n@@ -3346,7 +3347,7 @@ relax_delay_slots (rtx_insn *first)\n \t{\n \t  /* Figure out where to emit the special USE insn so we don't\n \t     later incorrectly compute register live/death info.  */\n-\t  rtx tmp = next_active_insn (trial);\n+\t  rtx_insn *tmp = next_active_insn (trial);\n \t  if (tmp == 0)\n \t    tmp = find_end_label (simple_return_rtx);\n \n@@ -3520,9 +3521,10 @@ relax_delay_slots (rtx_insn *first)\n    RETURN as well.  */\n \n static void\n-make_return_insns (rtx first)\n+make_return_insns (rtx_insn *first)\n {\n-  rtx insn, jump_insn, pat;\n+  rtx_insn *insn;\n+  rtx_insn *jump_insn;\n   rtx real_return_label = function_return_label;\n   rtx real_simple_return_label = function_simple_return_label;\n   int slots, i;\n@@ -3577,8 +3579,8 @@ make_return_insns (rtx first)\n       else\n \tcontinue;\n \n-      pat = PATTERN (insn);\n-      jump_insn = XVECEXP (pat, 0, 0);\n+      rtx_sequence *pat = as_a <rtx_sequence *> (PATTERN (insn));\n+      jump_insn = pat->insn (0);\n \n       /* If we can't make the jump into a RETURN, try to redirect it to the best\n \t RETURN and go on to the next insn.  */\n@@ -3603,18 +3605,18 @@ make_return_insns (rtx first)\n \t    if (! (\n #ifdef ANNUL_IFFALSE_SLOTS\n \t\t   (INSN_ANNULLED_BRANCH_P (jump_insn)\n-\t\t    && INSN_FROM_TARGET_P (XVECEXP (pat, 0, i)))\n+\t\t    && INSN_FROM_TARGET_P (pat->insn (i)))\n \t\t   ? eligible_for_annul_false (jump_insn, i - 1,\n-\t\t\t\t\t       XVECEXP (pat, 0, i), flags) :\n+\t\t\t\t\t       pat->insn (i), flags) :\n #endif\n #ifdef ANNUL_IFTRUE_SLOTS\n \t\t   (INSN_ANNULLED_BRANCH_P (jump_insn)\n-\t\t    && ! INSN_FROM_TARGET_P (XVECEXP (pat, 0, i)))\n+\t\t    && ! INSN_FROM_TARGET_P (pat->insn (i)))\n \t\t   ? eligible_for_annul_true (jump_insn, i - 1,\n-\t\t\t\t\t      XVECEXP (pat, 0, i), flags) :\n+\t\t\t\t\t      pat->insn (i), flags) :\n #endif\n \t\t   eligible_for_delay (jump_insn, i - 1,\n-\t\t\t\t       XVECEXP (pat, 0, i), flags)))\n+\t\t\t\t       pat->insn (i), flags)))\n \t      break;\n \t}\n       else\n@@ -3629,7 +3631,7 @@ make_return_insns (rtx first)\n \t insns for its delay slots, if it needs some.  */\n       if (ANY_RETURN_P (PATTERN (jump_insn)))\n \t{\n-\t  rtx prev = PREV_INSN (insn);\n+\t  rtx_insn *prev = PREV_INSN (insn);\n \n \t  delete_related_insns (insn);\n \t  for (i = 1; i < XVECLEN (pat, 0); i++)"}, {"sha": "1c47c20abcca4bc013bab2d05cb7504b8fd3cb81", "filename": "gcc/rtl.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -635,9 +635,9 @@ class GTY(()) rtx_note : public rtx_insn\n                       || JUMP_TABLE_DATA_P (X)\t\t\\\n                       || BARRIER_P (X)        \t\t\\\n                       || LABEL_P (X))    \t\t\\\n-                     && PREV_INSN (X) != NULL           \\\n-                     && NEXT_INSN (PREV_INSN (X)) == X  \\\n-                     ? PREV_INSN (X) : NULL)\n+\t\t     && PREV_INSN (as_a <rtx_insn *> (X)) != NULL\t\\\n+                     && NEXT_INSN (PREV_INSN (as_a <rtx_insn *> (X))) == X \\\n+                     ? PREV_INSN (as_a <rtx_insn *> (X)) : NULL)\n \n /* Define macros to access the `code' field of the rtx.  */\n \n@@ -1321,7 +1321,7 @@ inline int& INSN_UID (rtx insn)\n    and an lvalue form:\n      SET_NEXT_INSN/SET_PREV_INSN.  */\n \n-inline rtx_insn *PREV_INSN (const_rtx insn)\n+inline rtx_insn *PREV_INSN (const rtx_insn *insn)\n {\n   rtx prev = XEXP (insn, 0);\n   return safe_as_a <rtx_insn *> (prev);\n@@ -1332,7 +1332,7 @@ inline rtx& SET_PREV_INSN (rtx_insn *insn)\n   return XEXP (insn, 0);\n }\n \n-inline rtx_insn *NEXT_INSN (const_rtx insn)\n+inline rtx_insn *NEXT_INSN (const rtx_insn *insn)\n {\n   rtx next = XEXP (insn, 1);\n   return safe_as_a <rtx_insn *> (next);\n@@ -1658,7 +1658,7 @@ enum label_kind\n    be decremented and possibly the label can be deleted.  */\n #define JUMP_LABEL(INSN)   XCEXP (INSN, 7, JUMP_INSN)\n \n-inline rtx_insn *JUMP_LABEL_AS_INSN (rtx_insn *insn)\n+inline rtx_insn *JUMP_LABEL_AS_INSN (const rtx_insn *insn)\n {\n   return safe_as_a <rtx_insn *> (JUMP_LABEL (insn));\n }\n@@ -2739,12 +2739,12 @@ extern bool unsigned_reg_p (rtx);\n extern int reg_mentioned_p (const_rtx, const_rtx);\n extern int count_occurrences (const_rtx, const_rtx, int);\n extern int reg_referenced_p (const_rtx, const_rtx);\n-extern int reg_used_between_p (const_rtx, const_rtx, const_rtx);\n+extern int reg_used_between_p (const_rtx, const rtx_insn *, const rtx_insn *);\n extern int reg_set_between_p (const_rtx, const_rtx, const_rtx);\n extern int commutative_operand_precedence (rtx);\n extern bool swap_commutative_operands_p (rtx, rtx);\n extern int modified_between_p (const_rtx, const_rtx, const_rtx);\n-extern int no_labels_between_p (const_rtx, const_rtx);\n+extern int no_labels_between_p (const rtx_insn *, const rtx_insn *);\n extern int modified_in_p (const_rtx, const_rtx);\n extern int reg_set_p (const_rtx, const_rtx);\n extern rtx single_set_2 (const_rtx, const_rtx);"}, {"sha": "e95082ccdaa9be9a47e23732917d16463ab4e34c", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -835,9 +835,9 @@ reg_mentioned_p (const_rtx reg, const_rtx in)\n    no CODE_LABEL insn.  */\n \n int\n-no_labels_between_p (const_rtx beg, const_rtx end)\n+no_labels_between_p (const rtx_insn *beg, const rtx_insn *end)\n {\n-  rtx p;\n+  rtx_insn *p;\n   if (beg == end)\n     return 0;\n   for (p = NEXT_INSN (beg); p != end; p = NEXT_INSN (p))\n@@ -850,7 +850,8 @@ no_labels_between_p (const_rtx beg, const_rtx end)\n    FROM_INSN and TO_INSN (exclusive of those two).  */\n \n int\n-reg_used_between_p (const_rtx reg, const_rtx from_insn, const_rtx to_insn)\n+reg_used_between_p (const_rtx reg, const rtx_insn *from_insn,\n+\t\t    const rtx_insn *to_insn)\n {\n   rtx_insn *insn;\n \n@@ -946,8 +947,10 @@ reg_referenced_p (const_rtx x, const_rtx body)\n    FROM_INSN and TO_INSN (exclusive of those two).  */\n \n int\n-reg_set_between_p (const_rtx reg, const_rtx from_insn, const_rtx to_insn)\n+reg_set_between_p (const_rtx reg, const_rtx uncast_from_insn, const_rtx to_insn)\n {\n+  const rtx_insn *from_insn =\n+    safe_as_a <const rtx_insn *> (uncast_from_insn);\n   const rtx_insn *insn;\n \n   if (from_insn == to_insn)\n@@ -984,8 +987,10 @@ reg_set_p (const_rtx reg, const_rtx insn)\n    X contains a MEM; this routine does use memory aliasing.  */\n \n int\n-modified_between_p (const_rtx x, const_rtx start, const_rtx end)\n+modified_between_p (const_rtx x, const_rtx uncast_start, const_rtx end)\n {\n+  const rtx_insn *start =\n+    safe_as_a <const rtx_insn *> (uncast_start);\n   const enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n   int i, j;\n@@ -2871,7 +2876,7 @@ tablejump_p (const rtx_insn *insn, rtx *labelp, rtx_jump_table_data **tablep)\n \n   label = JUMP_LABEL (insn);\n   if (label != NULL_RTX && !ANY_RETURN_P (label)\n-      && (table = NEXT_INSN (label)) != NULL_RTX\n+      && (table = NEXT_INSN (as_a <rtx_insn *> (label))) != NULL_RTX\n       && JUMP_TABLE_DATA_P (table))\n     {\n       if (labelp)"}, {"sha": "02dc8f20d2d5cf924c28cbf094cec0d9fc8322d8", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -4083,10 +4083,10 @@ get_seqno_for_a_jump (insn_t insn, int old_seqno)\n /*  Find the proper seqno for inserting at INSN.  Returns -1 if no predecessors\n     with positive seqno exist.  */\n int\n-get_seqno_by_preds (rtx insn)\n+get_seqno_by_preds (rtx_insn *insn)\n {\n   basic_block bb = BLOCK_FOR_INSN (insn);\n-  rtx tmp = insn, head = BB_HEAD (bb);\n+  rtx_insn *tmp = insn, *head = BB_HEAD (bb);\n   insn_t *preds;\n   int n, i, seqno;\n \n@@ -4950,7 +4950,7 @@ recompute_rev_top_order (void)\n void\n clear_outdated_rtx_info (basic_block bb)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   FOR_BB_INSNS (bb, insn)\n     if (INSN_P (insn))"}, {"sha": "9ac9e5b7c1565af59e45810bbc426d1a064319b7", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -1628,7 +1628,7 @@ extern struct succs_info * compute_succs_info (insn_t, short);\n extern void free_succs_info (struct succs_info *);\n extern bool sel_insn_has_single_succ_p (insn_t, int);\n extern bool sel_num_cfg_preds_gt_1 (insn_t);\n-extern int get_seqno_by_preds (rtx);\n+extern int get_seqno_by_preds (rtx_insn *);\n \n extern bool bb_ends_ebb_p (basic_block);\n extern bool in_same_ebb_p (insn_t, insn_t);"}, {"sha": "4c7d29e38b586914c1687b146dc982418bf249e0", "filename": "gcc/store-motion.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -1011,7 +1011,8 @@ build_store_vectors (void)\n {\n   basic_block bb;\n   int *regs_set_in_block;\n-  rtx insn, st;\n+  rtx_insn *insn;\n+  rtx_insn_list *st;\n   struct st_expr * ptr;\n   unsigned int max_gcse_regno = max_reg_num ();\n \n@@ -1027,9 +1028,9 @@ build_store_vectors (void)\n \n   for (ptr = first_st_expr (); ptr != NULL; ptr = next_st_expr (ptr))\n     {\n-      for (st = ptr->avail_stores; st != NULL; st = XEXP (st, 1))\n+      for (st = ptr->avail_stores; st != NULL; st = st->next ())\n \t{\n-\t  insn = XEXP (st, 0);\n+\t  insn = st->insn ();\n \t  bb = BLOCK_FOR_INSN (insn);\n \n \t  /* If we've already seen an available expression in this block,\n@@ -1047,9 +1048,9 @@ build_store_vectors (void)\n \t  bitmap_set_bit (st_avloc[bb->index], ptr->index);\n \t}\n \n-      for (st = ptr->antic_stores; st != NULL; st = XEXP (st, 1))\n+      for (st = ptr->antic_stores; st != NULL; st = st->next ())\n \t{\n-\t  insn = XEXP (st, 0);\n+\t  insn = st->insn ();\n \t  bb = BLOCK_FOR_INSN (insn);\n \t  bitmap_set_bit (st_antloc[bb->index], ptr->index);\n \t}"}, {"sha": "400798ab9158b343799fe29a52f4d7926194c2d5", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -2845,7 +2845,7 @@ get_use_iv_cost (struct ivopts_data *data, struct iv_use *use,\n /* Returns estimate on cost of computing SEQ.  */\n \n static unsigned\n-seq_cost (rtx seq, bool speed)\n+seq_cost (rtx_insn *seq, bool speed)\n {\n   unsigned cost = 0;\n   rtx set;\n@@ -2956,7 +2956,8 @@ prepare_decl_rtl (tree *expr_p, int *ws, void *data)\n static unsigned\n computation_cost (tree expr, bool speed)\n {\n-  rtx seq, rslt;\n+  rtx_insn *seq;\n+  rtx rslt;\n   tree type = TREE_TYPE (expr);\n   unsigned cost;\n   /* Avoid using hard regs in ways which may be unsupported.  */\n@@ -3286,7 +3287,8 @@ get_address_cost (bool symbol_present, bool var_present,\n       HOST_WIDE_INT rat, off = 0;\n       int old_cse_not_expected, width;\n       unsigned sym_p, var_p, off_p, rat_p, add_c;\n-      rtx seq, addr, base;\n+      rtx_insn *seq;\n+      rtx addr, base;\n       rtx reg0, reg1;\n \n       data = (address_cost_data) xcalloc (1, sizeof (*data));"}, {"sha": "733c91d3df7c3e69718b30f7f65c3e9d34e58b29", "filename": "rtx-classes-status.txt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/rtx-classes-status.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32d51894565e8005a2bdf62e8ea2e279d85b3a8/rtx-classes-status.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/rtx-classes-status.txt?ref=b32d51894565e8005a2bdf62e8ea2e279d85b3a8", "patch": "@@ -11,7 +11,3 @@ Phase 3: per-file commits within \"config\" subdirs: DONE\n Phase 4: removal of \"scaffolding\":                 DONE\n Phase 5: additional rtx_def subclasses:            DONE\n Phase 6: use extra rtx_def subclasses:             IN PROGRESS\n-\n-TODO: \"Scaffolding\" to be removed\n-=================================\n-* SET_NEXT_INSN, SET_PREV_INSN"}]}