{"sha": "0c20a65f04004843874f9e22c460207285dfdec1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMyMGE2NWYwNDAwNDg0Mzg3NGY5ZTIyYzQ2MDIwNzI4NWRmZGVjMQ==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-07-06T09:56:09Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-06T09:56:09Z"}, "message": "jump.c: Convert prototypes to ISO C90.\n\n\t* jump.c: Convert prototypes to ISO C90.\n\t* langhooks-def.h: Likewise.  Add extern to prototypes.\n\t* langhooks.c: Likewise.\n\t* langhooks.h: Likewise.\n\t* lcm.c: Likewise.\n\t* local-alloc.c: Likewise.\n\t* loop-init.c: Likewise.\n\t* loop-unroll.c: Likewise.\n\t* loop-unswitch.c: Likewise.\n\t* loop.c: Likewise.\n\t* loop.h: Likewise. Add extern to prototypes.\n\t* machmode.h: Likewise.\n\t* main.c: Likewise.\n\t* mbchar.c: Likewise.\n\t* mbchar.h: Likewise.\n\t* mkdeps.c: Likewise.\n\t* mkdeps.h: Likewise.\n\t* optabs.c: Likewise.\n\t* optabs.h: Likewise.\n\t* output.h: Likewise.\n\t* gccspec.c: Likwise.\n\t* postreload.c: Likewise.\n\t* prefix.c: Likewise.\n\t* prefix.h: Likewise.\n\t* print-rtl.c: Likewise.\n\t* print-tree.c: Likewise.\n\t* profile.c: Likewise.\n\t* read-rtl.c: Likewise.\n\t* real.c: Likewise.\n\t* real.h: Likewise.\n\t* recog.c: Likewise.\n\t* recog.h: Likewise.\n\t* reg-stack.c: Likewise.\n\t* regclass.c: Likewise.\n\t* regmove.c: Likewise.\n\t* regrename.c: Likewise.\n\t* regs.h: Likewise.\n\t* reload.c: Likewise.\n\t* reload.h: Likewise.\n\t* reload1.c: Likewise.\n\t* reorg.c: Likewise.\n\t* resource.c: Likewise.\n\t* resource.h: Likewise.\n\t* rtl-error.c: Likewise.\n\t* rtl.c: Likewise.\n\t* rtl.h: Likewise.\n\t* rtlanal.c: Likewise.\n\nFrom-SVN: r68998", "tree": {"sha": "4fb7a1aaa85c3c4aeda23d46346034b73d069df2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fb7a1aaa85c3c4aeda23d46346034b73d069df2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c20a65f04004843874f9e22c460207285dfdec1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c20a65f04004843874f9e22c460207285dfdec1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c20a65f04004843874f9e22c460207285dfdec1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c20a65f04004843874f9e22c460207285dfdec1/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "391cfc46896ec536a390f09b192b58c558e02b05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/391cfc46896ec536a390f09b192b58c558e02b05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/391cfc46896ec536a390f09b192b58c558e02b05"}], "stats": {"total": 8043, "additions": 3095, "deletions": 4948}, "files": [{"sha": "3db859173f737aaa41572e39abc957ff6b264149", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -20,6 +20,53 @@\n \t* integrate.c: Likewise.\n \t* input.h: Likewise.\n \t* ifcvt.c: Likewise.\n+\t* jump.c: Convert prototypes to ISO C90.\n+\t* langhooks-def.h: Likewise.  Add extern to prototypes.\n+\t* langhooks.c: Likewise.\n+\t* langhooks.h: Likewise.\n+\t* lcm.c: Likewise.\n+\t* local-alloc.c: Likewise.\n+\t* loop-init.c: Likewise.\n+\t* loop-unroll.c: Likewise.\n+\t* loop-unswitch.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* loop.h: Likewise. Add extern to prototypes.\n+\t* machmode.h: Likewise.\n+\t* main.c: Likewise.\n+\t* mbchar.c: Likewise.\n+\t* mbchar.h: Likewise.\n+\t* mkdeps.c: Likewise.\n+\t* mkdeps.h: Likewise.\n+\t* optabs.c: Likewise.\n+\t* optabs.h: Likewise.\n+\t* output.h: Likewise.\n+\t* gccspec.c: Likwise.\n+\t* postreload.c: Likewise.\n+\t* prefix.c: Likewise.\n+\t* prefix.h: Likewise.\n+\t* print-rtl.c: Likewise.\n+\t* print-tree.c: Likewise.\n+\t* profile.c: Likewise.\n+\t* read-rtl.c: Likewise.\n+\t* real.c: Likewise.\n+\t* real.h: Likewise.\n+\t* recog.c: Likewise.\n+\t* recog.h: Likewise.\n+\t* reg-stack.c: Likewise.\n+\t* regclass.c: Likewise.\n+\t* regmove.c: Likewise.\n+\t* regrename.c: Likewise.\n+\t* regs.h: Likewise.\n+\t* reload.c: Likewise.\n+\t* reload.h: Likewise.\n+\t* reload1.c: Likewise.\n+\t* reorg.c: Likewise.\n+\t* resource.c: Likewise.\n+\t* resource.h: Likewise.\n+\t* rtl-error.c: Likewise.\n+\t* rtl.c: Likewise.\n+\t* rtl.h: Likewise.\n+\t* rtlanal.c: Likewise.\n \n 2003-07-05  Kazu Hirata  <kazu@cs.umass.edu>\n "}, {"sha": "b893d6592828f10edfa6f7c9d12366e5467364d4", "filename": "gcc/gccspec.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fgccspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fgccspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgccspec.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Specific flags and argument handling of the C front-end.\n-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -26,10 +26,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Filter argc and argv before processing by the gcc driver proper.  */\n void\n-lang_specific_driver (in_argc, in_argv, in_added_libraries)\n-     int *in_argc ATTRIBUTE_UNUSED;\n-     const char *const **in_argv ATTRIBUTE_UNUSED;\n-     int *in_added_libraries ATTRIBUTE_UNUSED;\n+lang_specific_driver (int *in_argc ATTRIBUTE_UNUSED,\n+\t\t      const char *const **in_argv ATTRIBUTE_UNUSED,\n+\t\t      int *in_added_libraries ATTRIBUTE_UNUSED)\n {\n #ifdef ENABLE_SHARED_LIBGCC\n   int i;\n@@ -96,15 +95,15 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \n /* Called before linking.  Returns 0 on success and -1 on failure.  */\n int\n-lang_specific_pre_link ()\n+lang_specific_pre_link (void)\n {\n   return 0;  /* Not used for C.  */\n }\n \n /* Number of extra output files that lang_specific_pre_link may generate.  */\n int lang_specific_extra_outfiles = 0;  /* Not used for C.  */\n \n-/* Table of language-specific spec functions.  */ \n+/* Table of language-specific spec functions.  */\n const struct spec_function lang_specific_spec_functions[] =\n {\n   { 0, 0 }"}, {"sha": "2c98ad6131270bbb9cdaba1667e100246ed2d089", "filename": "gcc/jump.c", "status": "modified", "additions": 62, "deletions": 123, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -63,24 +63,23 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    or even change what is live at any point.\n    So perhaps let combiner do it.  */\n \n-static rtx next_nonnote_insn_in_loop\tPARAMS ((rtx));\n-static void init_label_info\t\tPARAMS ((rtx));\n-static void mark_all_labels\t\tPARAMS ((rtx));\n-static int duplicate_loop_exit_test\tPARAMS ((rtx));\n-static void delete_computation\t\tPARAMS ((rtx));\n-static void redirect_exp_1\t\tPARAMS ((rtx *, rtx, rtx, rtx));\n-static int redirect_exp\t\t\tPARAMS ((rtx, rtx, rtx));\n-static void invert_exp_1\t\tPARAMS ((rtx));\n-static int invert_exp\t\t\tPARAMS ((rtx));\n-static int returnjump_p_1\t        PARAMS ((rtx *, void *));\n-static void delete_prior_computation    PARAMS ((rtx, rtx));\n+static rtx next_nonnote_insn_in_loop (rtx);\n+static void init_label_info (rtx);\n+static void mark_all_labels (rtx);\n+static int duplicate_loop_exit_test (rtx);\n+static void delete_computation (rtx);\n+static void redirect_exp_1 (rtx *, rtx, rtx, rtx);\n+static int redirect_exp (rtx, rtx, rtx);\n+static void invert_exp_1 (rtx);\n+static int invert_exp (rtx);\n+static int returnjump_p_1 (rtx *, void *);\n+static void delete_prior_computation (rtx, rtx);\n \f\n /* Alternate entry into the jump optimizer.  This entry point only rebuilds\n    the JUMP_LABEL field in jumping insns and REG_LABEL notes in non-jumping\n    instructions.  */\n void\n-rebuild_jump_labels (f)\n-     rtx f;\n+rebuild_jump_labels (rtx f)\n {\n   rtx insn;\n \n@@ -107,7 +106,7 @@ rebuild_jump_labels (f)\n    old code is happy.\n  */\n void\n-cleanup_barriers ()\n+cleanup_barriers (void)\n {\n   rtx insn, next, prev;\n   for (insn = get_insns (); insn; insn = next)\n@@ -129,8 +128,7 @@ cleanup_barriers ()\n    This routine does not look inside SEQUENCEs.  */\n \n static rtx\n-next_nonnote_insn_in_loop (insn)\n-     rtx insn;\n+next_nonnote_insn_in_loop (rtx insn)\n {\n   while (insn)\n     {\n@@ -146,8 +144,7 @@ next_nonnote_insn_in_loop (insn)\n }\n \n void\n-copy_loop_headers (f)\n-     rtx f;\n+copy_loop_headers (rtx f)\n {\n   rtx insn, next;\n   /* Now iterate optimizing jumps until nothing changes over one pass.  */\n@@ -176,8 +173,7 @@ copy_loop_headers (f)\n }\n \n void\n-purge_line_number_notes (f)\n-     rtx f;\n+purge_line_number_notes (rtx f)\n {\n   rtx last_note = 0;\n   rtx insn;\n@@ -213,8 +209,7 @@ purge_line_number_notes (f)\n    notes whose labels don't occur in the insn any more.  Returns the\n    largest INSN_UID found.  */\n static void\n-init_label_info (f)\n-     rtx f;\n+init_label_info (rtx f)\n {\n   rtx insn;\n \n@@ -241,8 +236,7 @@ init_label_info (f)\n    Combine consecutive labels, and count uses of labels.  */\n \n static void\n-mark_all_labels (f)\n-     rtx f;\n+mark_all_labels (rtx f)\n {\n   rtx insn;\n \n@@ -306,8 +300,7 @@ mark_all_labels (f)\n    values of regno_first_uid and regno_last_uid.  */\n \n static int\n-duplicate_loop_exit_test (loop_start)\n-     rtx loop_start;\n+duplicate_loop_exit_test (rtx loop_start)\n {\n   rtx insn, set, reg, p, link;\n   rtx copy = 0, first_copy = 0;\n@@ -541,9 +534,7 @@ duplicate_loop_exit_test (loop_start)\n    Return true if there were only such notes and no real instructions.  */\n \n bool\n-squeeze_notes (startp, endp)\n-     rtx* startp;\n-     rtx* endp;\n+squeeze_notes (rtx* startp, rtx* endp)\n {\n   rtx start = *startp;\n   rtx end = *endp;\n@@ -595,8 +586,7 @@ squeeze_notes (startp, endp)\n /* Return the label before INSN, or put a new label there.  */\n \n rtx\n-get_label_before (insn)\n-     rtx insn;\n+get_label_before (rtx insn)\n {\n   rtx label;\n \n@@ -618,8 +608,7 @@ get_label_before (insn)\n /* Return the label after INSN, or put a new label there.  */\n \n rtx\n-get_label_after (insn)\n-     rtx insn;\n+get_label_after (rtx insn)\n {\n   rtx label;\n \n@@ -643,9 +632,7 @@ get_label_after (insn)\n    description should define REVERSIBLE_CC_MODE and REVERSE_CONDITION macros\n    to help this function avoid overhead in these cases.  */\n enum rtx_code\n-reversed_comparison_code_parts (code, arg0, arg1, insn)\n-     rtx insn, arg0, arg1;\n-     enum rtx_code code;\n+reversed_comparison_code_parts (enum rtx_code code, rtx arg0, rtx arg1, rtx insn)\n {\n   enum machine_mode mode;\n \n@@ -759,8 +746,7 @@ reversed_comparison_code_parts (code, arg0, arg1, insn)\n /* A wrapper around the previous function to take COMPARISON as rtx\n    expression.  This simplifies many callers.  */\n enum rtx_code\n-reversed_comparison_code (comparison, insn)\n-     rtx comparison, insn;\n+reversed_comparison_code (rtx comparison, rtx insn)\n {\n   if (GET_RTX_CLASS (GET_CODE (comparison)) != '<')\n     return UNKNOWN;\n@@ -778,8 +764,7 @@ reversed_comparison_code (comparison, insn)\n    Use reversed_comparison_code instead.  */\n \n enum rtx_code\n-reverse_condition (code)\n-     enum rtx_code code;\n+reverse_condition (enum rtx_code code)\n {\n   switch (code)\n     {\n@@ -826,8 +811,7 @@ reverse_condition (code)\n    that the target will support them too...  */\n \n enum rtx_code\n-reverse_condition_maybe_unordered (code)\n-     enum rtx_code code;\n+reverse_condition_maybe_unordered (enum rtx_code code)\n {\n   switch (code)\n     {\n@@ -869,8 +853,7 @@ reverse_condition_maybe_unordered (code)\n    This IS safe for IEEE floating-point.  */\n \n enum rtx_code\n-swap_condition (code)\n-     enum rtx_code code;\n+swap_condition (enum rtx_code code)\n {\n   switch (code)\n     {\n@@ -917,8 +900,7 @@ swap_condition (code)\n    CODE is returned.  */\n \n enum rtx_code\n-unsigned_condition (code)\n-     enum rtx_code code;\n+unsigned_condition (enum rtx_code code)\n {\n   switch (code)\n     {\n@@ -947,8 +929,7 @@ unsigned_condition (code)\n /* Similarly, return the signed version of a comparison.  */\n \n enum rtx_code\n-signed_condition (code)\n-     enum rtx_code code;\n+signed_condition (enum rtx_code code)\n {\n   switch (code)\n     {\n@@ -978,8 +959,7 @@ signed_condition (code)\n    truth of CODE1 implies the truth of CODE2.  */\n \n int\n-comparison_dominates_p (code1, code2)\n-     enum rtx_code code1, code2;\n+comparison_dominates_p (enum rtx_code code1, enum rtx_code code2)\n {\n   /* UNKNOWN comparison codes can happen as a result of trying to revert\n      comparison codes.\n@@ -1060,8 +1040,7 @@ comparison_dominates_p (code1, code2)\n /* Return 1 if INSN is an unconditional jump and nothing else.  */\n \n int\n-simplejump_p (insn)\n-     rtx insn;\n+simplejump_p (rtx insn)\n {\n   return (GET_CODE (insn) == JUMP_INSN\n \t  && GET_CODE (PATTERN (insn)) == SET\n@@ -1076,8 +1055,7 @@ simplejump_p (insn)\n    branch and compare insns.  Use any_condjump_p instead whenever possible.  */\n \n int\n-condjump_p (insn)\n-     rtx insn;\n+condjump_p (rtx insn)\n {\n   rtx x = PATTERN (insn);\n \n@@ -1107,8 +1085,7 @@ condjump_p (insn)\n    branch and compare insns.  Use any_condjump_p instead whenever possible.  */\n \n int\n-condjump_in_parallel_p (insn)\n-     rtx insn;\n+condjump_in_parallel_p (rtx insn)\n {\n   rtx x = PATTERN (insn);\n \n@@ -1139,8 +1116,7 @@ condjump_in_parallel_p (insn)\n /* Return set of PC, otherwise NULL.  */\n \n rtx\n-pc_set (insn)\n-     rtx insn;\n+pc_set (rtx insn)\n {\n   rtx pat;\n   if (GET_CODE (insn) != JUMP_INSN)\n@@ -1161,8 +1137,7 @@ pc_set (insn)\n    possibly bundled inside a PARALLEL.  */\n \n int\n-any_uncondjump_p (insn)\n-     rtx insn;\n+any_uncondjump_p (rtx insn)\n {\n   rtx x = pc_set (insn);\n   if (!x)\n@@ -1180,8 +1155,7 @@ any_uncondjump_p (insn)\n    Note that unlike condjump_p it returns false for unconditional jumps.  */\n \n int\n-any_condjump_p (insn)\n-     rtx insn;\n+any_condjump_p (rtx insn)\n {\n   rtx x = pc_set (insn);\n   enum rtx_code a, b;\n@@ -1201,8 +1175,7 @@ any_condjump_p (insn)\n /* Return the label of a conditional jump.  */\n \n rtx\n-condjump_label (insn)\n-     rtx insn;\n+condjump_label (rtx insn)\n {\n   rtx x = pc_set (insn);\n \n@@ -1223,9 +1196,7 @@ condjump_label (insn)\n /* Return true if INSN is a (possibly conditional) return insn.  */\n \n static int\n-returnjump_p_1 (loc, data)\n-     rtx *loc;\n-     void *data ATTRIBUTE_UNUSED;\n+returnjump_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n {\n   rtx x = *loc;\n \n@@ -1234,8 +1205,7 @@ returnjump_p_1 (loc, data)\n }\n \n int\n-returnjump_p (insn)\n-     rtx insn;\n+returnjump_p (rtx insn)\n {\n   if (GET_CODE (insn) != JUMP_INSN)\n     return 0;\n@@ -1246,8 +1216,7 @@ returnjump_p (insn)\n    nothing more.  */\n \n int\n-onlyjump_p (insn)\n-     rtx insn;\n+onlyjump_p (rtx insn)\n {\n   rtx set;\n \n@@ -1271,8 +1240,7 @@ onlyjump_p (insn)\n    and has no side effects.  */\n \n int\n-only_sets_cc0_p (x)\n-     rtx x;\n+only_sets_cc0_p (rtx x)\n {\n   if (! x)\n     return 0;\n@@ -1289,8 +1257,7 @@ only_sets_cc0_p (x)\n    but also does other things.  */\n \n int\n-sets_cc0_p (x)\n-     rtx x;\n+sets_cc0_p (rtx x)\n {\n   if (! x)\n     return 0;\n@@ -1329,8 +1296,7 @@ sets_cc0_p (x)\n    a USE or CLOBBER.  */\n \n rtx\n-follow_jumps (label)\n-     rtx label;\n+follow_jumps (rtx label)\n {\n   rtx insn;\n   rtx next;\n@@ -1393,10 +1359,7 @@ follow_jumps (label)\n    that loop-optimization is done with.  */\n \n void\n-mark_jump_label (x, insn, in_mem)\n-     rtx x;\n-     rtx insn;\n-     int in_mem;\n+mark_jump_label (rtx x, rtx insn, int in_mem)\n {\n   RTX_CODE code = GET_CODE (x);\n   int i;\n@@ -1501,8 +1464,7 @@ mark_jump_label (x, insn, in_mem)\n    if that's what the previous thing was.  */\n \n void\n-delete_jump (insn)\n-     rtx insn;\n+delete_jump (rtx insn)\n {\n   rtx set = single_set (insn);\n \n@@ -1513,8 +1475,7 @@ delete_jump (insn)\n /* Verify INSN is a BARRIER and delete it.  */\n \n void\n-delete_barrier (insn)\n-     rtx insn;\n+delete_barrier (rtx insn)\n {\n   if (GET_CODE (insn) != BARRIER)\n     abort ();\n@@ -1527,9 +1488,7 @@ delete_barrier (insn)\n    which is a REG_DEAD note associated with INSN.  */\n \n static void\n-delete_prior_computation (note, insn)\n-     rtx note;\n-     rtx insn;\n+delete_prior_computation (rtx note, rtx insn)\n {\n   rtx our_prev;\n   rtx reg = XEXP (note, 0);\n@@ -1655,8 +1614,7 @@ delete_prior_computation (note, insn)\n    delete the insn that set it.  */\n \n static void\n-delete_computation (insn)\n-     rtx insn;\n+delete_computation (rtx insn)\n {\n   rtx note, next;\n \n@@ -1708,8 +1666,7 @@ delete_computation (insn)\n    subsequent cfg_cleanup pass to delete unreachable code if needed.  */\n \n rtx\n-delete_related_insns (insn)\n-     rtx insn;\n+delete_related_insns (rtx insn)\n {\n   int was_code_label = (GET_CODE (insn) == CODE_LABEL);\n   rtx note;\n@@ -1837,8 +1794,7 @@ delete_related_insns (insn)\n    peephole insn that will replace them.  */\n \n void\n-delete_for_peephole (from, to)\n-     rtx from, to;\n+delete_for_peephole (rtx from, rtx to)\n {\n   rtx insn = from;\n \n@@ -1882,8 +1838,7 @@ delete_for_peephole (from, to)\n    spurious warnings from this.  */\n \n void\n-never_reached_warning (avoided_insn, finish)\n-     rtx avoided_insn, finish;\n+never_reached_warning (rtx avoided_insn, rtx finish)\n {\n   rtx insn;\n   rtx a_line_note = NULL;\n@@ -1946,10 +1901,7 @@ never_reached_warning (avoided_insn, finish)\n    NLABEL as a return.  Accrue modifications into the change group.  */\n \n static void\n-redirect_exp_1 (loc, olabel, nlabel, insn)\n-     rtx *loc;\n-     rtx olabel, nlabel;\n-     rtx insn;\n+redirect_exp_1 (rtx *loc, rtx olabel, rtx nlabel, rtx insn)\n {\n   rtx x = *loc;\n   RTX_CODE code = GET_CODE (x);\n@@ -2004,9 +1956,7 @@ redirect_exp_1 (loc, olabel, nlabel, insn)\n /* Similar, but apply the change group and report success or failure.  */\n \n static int\n-redirect_exp (olabel, nlabel, insn)\n-     rtx olabel, nlabel;\n-     rtx insn;\n+redirect_exp (rtx olabel, rtx nlabel, rtx insn)\n {\n   rtx *loc;\n \n@@ -2027,8 +1977,7 @@ redirect_exp (olabel, nlabel, insn)\n    not see how to do that.  */\n \n int\n-redirect_jump_1 (jump, nlabel)\n-     rtx jump, nlabel;\n+redirect_jump_1 (rtx jump, rtx nlabel)\n {\n   int ochanges = num_validated_changes ();\n   rtx *loc;\n@@ -2053,9 +2002,7 @@ redirect_jump_1 (jump, nlabel)\n    (this can only occur for NLABEL == 0).  */\n \n int\n-redirect_jump (jump, nlabel, delete_unused)\n-     rtx jump, nlabel;\n-     int delete_unused;\n+redirect_jump (rtx jump, rtx nlabel, int delete_unused)\n {\n   rtx olabel = JUMP_LABEL (jump);\n   rtx note;\n@@ -2113,8 +2060,7 @@ redirect_jump (jump, nlabel, delete_unused)\n    Accrue the modifications into the change group.  */\n \n static void\n-invert_exp_1 (insn)\n-     rtx insn;\n+invert_exp_1 (rtx insn)\n {\n   RTX_CODE code;\n   rtx x = pc_set (insn);\n@@ -2162,8 +2108,7 @@ invert_exp_1 (insn)\n    matches a pattern.  */\n \n static int\n-invert_exp (insn)\n-     rtx insn;\n+invert_exp (rtx insn)\n {\n   invert_exp_1 (insn);\n   if (num_validated_changes () == 0)\n@@ -2178,8 +2123,7 @@ invert_exp (insn)\n    inversion and redirection.  */\n \n int\n-invert_jump_1 (jump, nlabel)\n-     rtx jump, nlabel;\n+invert_jump_1 (rtx jump, rtx nlabel)\n {\n   int ochanges;\n \n@@ -2195,9 +2139,7 @@ invert_jump_1 (jump, nlabel)\n    NLABEL instead of where it jumps now.  Return true if successful.  */\n \n int\n-invert_jump (jump, nlabel, delete_unused)\n-     rtx jump, nlabel;\n-     int delete_unused;\n+invert_jump (rtx jump, rtx nlabel, int delete_unused)\n {\n   /* We have to either invert the condition and change the label or\n      do neither.  Either operation could fail.  We first try to invert\n@@ -2241,8 +2183,7 @@ invert_jump (jump, nlabel, delete_unused)\n    case when the PLUS is inside a MEM.  */\n \n int\n-rtx_renumbered_equal_p (x, y)\n-     rtx x, y;\n+rtx_renumbered_equal_p (rtx x, rtx y)\n {\n   int i;\n   RTX_CODE code = GET_CODE (x);\n@@ -2429,8 +2370,7 @@ rtx_renumbered_equal_p (x, y)\n    return -1.  Any rtx is valid for X.  */\n \n int\n-true_regnum (x)\n-     rtx x;\n+true_regnum (rtx x)\n {\n   if (GET_CODE (x) == REG)\n     {\n@@ -2451,8 +2391,7 @@ true_regnum (x)\n \n /* Return regno of the register REG and handle subregs too.  */\n unsigned int\n-reg_or_subregno (reg)\n-     rtx reg;\n+reg_or_subregno (rtx reg)\n {\n   if (REG_P (reg))\n     return REGNO (reg);"}, {"sha": "4995d4a61a15bb3ec064262248e7113367afe4b3", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 43, "deletions": 45, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Default macros to initialize the lang_hooks data structure.\n-   Copyright 2001, 2002 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Alexandre Oliva  <aoliva@redhat.com>\n \n This file is part of GCC.\n@@ -28,7 +28,7 @@ struct diagnostic_context;\n \n /* Provide a hook routine for alias sets that always returns 1.  This is\n    used by languages that haven't deal with alias sets yet.  */\n-extern HOST_WIDE_INT hook_get_alias_set_0\tPARAMS ((tree));\n+extern HOST_WIDE_INT hook_get_alias_set_0 (tree);\n \n /* Note to creators of new hooks:\n \n@@ -39,50 +39,48 @@ extern HOST_WIDE_INT hook_get_alias_set_0\tPARAMS ((tree));\n \n /* See langhooks.h for the definition and documentation of each hook.  */\n \n-extern void lhd_do_nothing PARAMS ((void));\n-extern void lhd_do_nothing_t PARAMS ((tree));\n-extern void lhd_do_nothing_i PARAMS ((int));\n-extern void lhd_do_nothing_f PARAMS ((struct function *));\n-extern bool lhd_post_options PARAMS ((const char **));\n-extern HOST_WIDE_INT lhd_get_alias_set PARAMS ((tree));\n-extern tree lhd_return_tree PARAMS ((tree));\n-extern tree lhd_return_null_tree PARAMS ((tree));\n-extern int lhd_safe_from_p PARAMS ((rtx, tree));\n-extern int lhd_staticp PARAMS ((tree));\n-extern int lhd_unsafe_for_reeval PARAMS ((tree));\n-extern void lhd_clear_binding_stack PARAMS ((void));\n-extern void lhd_print_tree_nothing PARAMS ((FILE *, tree, int));\n-extern const char *lhd_decl_printable_name PARAMS ((tree, int));\n-extern rtx lhd_expand_expr PARAMS ((tree, rtx, enum machine_mode, int));\n-extern void lhd_print_error_function PARAMS ((struct diagnostic_context *,\n-\t\t\t\t\t      const char *));\n-extern void lhd_set_decl_assembler_name PARAMS ((tree));\n-extern bool lhd_can_use_bit_fields_p PARAMS ((void));\n-extern bool lhd_warn_unused_global_decl PARAMS ((tree));\n-extern void lhd_incomplete_type_error PARAMS ((tree, tree));\n-extern tree lhd_type_promotes_to PARAMS ((tree));\n-extern bool lhd_decl_ok_for_sibcall PARAMS ((tree));\n-extern tree lhd_expr_size PARAMS ((tree));\n-extern size_t lhd_tree_size PARAMS ((enum tree_code));\n+extern void lhd_do_nothing (void);\n+extern void lhd_do_nothing_t (tree);\n+extern void lhd_do_nothing_i (int);\n+extern void lhd_do_nothing_f (struct function *);\n+extern bool lhd_post_options (const char **);\n+extern HOST_WIDE_INT lhd_get_alias_set (tree);\n+extern tree lhd_return_tree (tree);\n+extern tree lhd_return_null_tree (tree);\n+extern int lhd_safe_from_p (rtx, tree);\n+extern int lhd_staticp (tree);\n+extern int lhd_unsafe_for_reeval (tree);\n+extern void lhd_clear_binding_stack (void);\n+extern void lhd_print_tree_nothing (FILE *, tree, int);\n+extern const char *lhd_decl_printable_name (tree, int);\n+extern rtx lhd_expand_expr (tree, rtx, enum machine_mode, int);\n+extern void lhd_print_error_function (struct diagnostic_context *,\n+\t\t\t\t      const char *);\n+extern void lhd_set_decl_assembler_name (tree);\n+extern bool lhd_can_use_bit_fields_p (void);\n+extern bool lhd_warn_unused_global_decl (tree);\n+extern void lhd_incomplete_type_error (tree, tree);\n+extern tree lhd_type_promotes_to (tree);\n+extern bool lhd_decl_ok_for_sibcall (tree);\n+extern tree lhd_expr_size (tree);\n+extern size_t lhd_tree_size (enum tree_code);\n \n /* Declarations of default tree inlining hooks.  */\n-tree lhd_tree_inlining_walk_subtrees\t\tPARAMS ((tree *, int *,\n-\t\t\t\t\t\t\t walk_tree_fn,\n-\t\t\t\t\t\t\t void *, void *));\n-int lhd_tree_inlining_cannot_inline_tree_fn\tPARAMS ((tree *));\n-int lhd_tree_inlining_disregard_inline_limits\tPARAMS ((tree));\n-tree lhd_tree_inlining_add_pending_fn_decls\tPARAMS ((void *, tree));\n-int lhd_tree_inlining_tree_chain_matters_p\tPARAMS ((tree));\n-int lhd_tree_inlining_auto_var_in_fn_p\t\tPARAMS ((tree, tree));\n-tree lhd_tree_inlining_copy_res_decl_for_inlining PARAMS ((tree, tree,\n-\t\t\t\t\t\t\t   tree, void *,\n-\t\t\t\t\t\t\t   int *, tree));\n-int lhd_tree_inlining_anon_aggr_type_p\t\tPARAMS ((tree));\n-int lhd_tree_inlining_start_inlining\t\tPARAMS ((tree));\n-void lhd_tree_inlining_end_inlining\t\tPARAMS ((tree));\n-tree lhd_tree_inlining_convert_parm_for_inlining PARAMS ((tree, tree, tree));\n+extern tree lhd_tree_inlining_walk_subtrees (tree *, int *, walk_tree_fn,\n+\t\t\t\t\t     void *, void *);\n+extern int lhd_tree_inlining_cannot_inline_tree_fn (tree *);\n+extern int lhd_tree_inlining_disregard_inline_limits (tree);\n+extern tree lhd_tree_inlining_add_pending_fn_decls (void *, tree);\n+extern int lhd_tree_inlining_tree_chain_matters_p (tree);\n+extern int lhd_tree_inlining_auto_var_in_fn_p (tree, tree);\n+extern tree lhd_tree_inlining_copy_res_decl_for_inlining (tree, tree, tree,\n+\t\t\t\t\t\t\t  void *, int *, tree);\n+extern int lhd_tree_inlining_anon_aggr_type_p (tree);\n+extern int lhd_tree_inlining_start_inlining (tree);\n+extern void lhd_tree_inlining_end_inlining (tree);\n+extern tree lhd_tree_inlining_convert_parm_for_inlining (tree, tree, tree);\n \n-void write_global_declarations PARAMS ((void));\n+extern void write_global_declarations (void);\n \n #define LANG_HOOKS_NAME\t\t\t\"GNU unknown\"\n #define LANG_HOOKS_IDENTIFIER_SIZE\tsizeof (struct lang_identifier)\n@@ -184,8 +182,8 @@ void write_global_declarations PARAMS ((void));\n }\n \n /* Tree dump hooks.  */\n-bool lhd_tree_dump_dump_tree \t\t\tPARAMS ((void *, tree));\n-int lhd_tree_dump_type_quals\t\t\tPARAMS ((tree));\n+extern bool lhd_tree_dump_dump_tree (void *, tree);\n+extern int lhd_tree_dump_type_quals (tree);\n \n #define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN lhd_tree_dump_dump_tree\n #define LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN lhd_tree_dump_type_quals"}, {"sha": "6b0c5bdba08d420cd3046f4f609bd7bd749e0521", "filename": "gcc/langhooks.c", "status": "modified", "additions": 52, "deletions": 92, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Default language-specific hooks.\n-   Copyright 2001, 2002 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Alexandre Oliva  <aoliva@redhat.com>\n \n This file is part of GCC.\n@@ -36,104 +36,92 @@ Boston, MA 02111-1307, USA.  */\n /* Do nothing; in many cases the default hook.  */\n \n void\n-lhd_do_nothing ()\n+lhd_do_nothing (void)\n {\n }\n \n /* Do nothing (tree).  */\n \n void\n-lhd_do_nothing_t (t)\n-     tree t ATTRIBUTE_UNUSED;\n+lhd_do_nothing_t (tree t ATTRIBUTE_UNUSED)\n {\n }\n \n /* Do nothing (int).  */\n \n void\n-lhd_do_nothing_i (i)\n-     int i ATTRIBUTE_UNUSED;\n+lhd_do_nothing_i (int i ATTRIBUTE_UNUSED)\n {\n }\n \n /* Do nothing (function).  */\n \n void\n-lhd_do_nothing_f (f)\n-     struct function *f ATTRIBUTE_UNUSED;\n+lhd_do_nothing_f (struct function *f ATTRIBUTE_UNUSED)\n {\n }\n \n /* Do nothing (return the tree node passed).  */\n \n tree\n-lhd_return_tree (t)\n-     tree t;\n+lhd_return_tree (tree t)\n {\n   return t;\n }\n \n /* Do nothing (return NULL_TREE).  */\n \n tree\n-lhd_return_null_tree (t)\n-     tree t ATTRIBUTE_UNUSED;\n+lhd_return_null_tree (tree t ATTRIBUTE_UNUSED)\n {\n   return NULL_TREE;\n }\n \n /* The default post options hook.  */\n \n bool\n-lhd_post_options (pfilename)\n-     const char **pfilename ATTRIBUTE_UNUSED;\n+lhd_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n {\n   return false;\n }\n \n /* Called from by print-tree.c.  */\n \n void\n-lhd_print_tree_nothing (file, node, indent)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     tree node ATTRIBUTE_UNUSED;\n-     int indent ATTRIBUTE_UNUSED;\n+lhd_print_tree_nothing (FILE *file ATTRIBUTE_UNUSED,\n+\t\t\ttree node ATTRIBUTE_UNUSED,\n+\t\t\tint indent ATTRIBUTE_UNUSED)\n {\n }\n \n /* Called from safe_from_p.  */\n \n int\n-lhd_safe_from_p (x, exp)\n-     rtx x ATTRIBUTE_UNUSED;\n-     tree exp ATTRIBUTE_UNUSED;\n+lhd_safe_from_p (rtx x ATTRIBUTE_UNUSED, tree exp ATTRIBUTE_UNUSED)\n {\n   return 1;\n }\n \n /* Called from unsafe_for_reeval.  */\n \n int\n-lhd_unsafe_for_reeval (t)\n-     tree t ATTRIBUTE_UNUSED;\n+lhd_unsafe_for_reeval (tree t ATTRIBUTE_UNUSED)\n {\n   return -1;\n }\n \n /* Called from staticp.  */\n \n int\n-lhd_staticp (exp)\n-     tree exp ATTRIBUTE_UNUSED;\n+lhd_staticp (tree exp ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n \n /* Called from check_global_declarations.  */\n \n bool\n-lhd_warn_unused_global_decl (decl)\n-     tree decl;\n+lhd_warn_unused_global_decl (tree decl)\n {\n   /* This is what used to exist in check_global_declarations.  Probably\n      not many of these actually apply to non-C languages.  */\n@@ -150,8 +138,7 @@ lhd_warn_unused_global_decl (decl)\n \n /* Set the DECL_ASSEMBLER_NAME for DECL.  */\n void\n-lhd_set_decl_assembler_name (decl)\n-     tree decl;\n+lhd_set_decl_assembler_name (tree decl)\n {\n   /* The language-independent code should never use the\n      DECL_ASSEMBLER_NAME for lots of DECLs.  Only FUNCTION_DECLs and\n@@ -177,32 +164,30 @@ lhd_set_decl_assembler_name (decl)\n \n /* By default we always allow bit-field based optimizations.  */\n bool\n-lhd_can_use_bit_fields_p ()\n+lhd_can_use_bit_fields_p (void)\n {\n   return true;\n }\n \n /* Provide a default routine to clear the binding stack.  This is used\n    by languages that don't need to do anything special.  */\n void\n-lhd_clear_binding_stack ()\n+lhd_clear_binding_stack (void)\n {\n   while (! (*lang_hooks.decls.global_bindings_p) ())\n     poplevel (0, 0, 0);\n }\n \n /* Type promotion for variable arguments.  */\n tree\n-lhd_type_promotes_to (type)\n-     tree type ATTRIBUTE_UNUSED;\n+lhd_type_promotes_to (tree type ATTRIBUTE_UNUSED)\n {\n   abort ();\n }\n \n /* Invalid use of an incomplete type.  */\n void\n-lhd_incomplete_type_error (value, type)\n-     tree value ATTRIBUTE_UNUSED, type;\n+lhd_incomplete_type_error (tree value ATTRIBUTE_UNUSED, tree type)\n {\n   if (TREE_CODE (type) == ERROR_MARK)\n     return;\n@@ -214,8 +199,7 @@ lhd_incomplete_type_error (value, type)\n    is used by languages that don't need to do anything special.  */\n \n HOST_WIDE_INT\n-lhd_get_alias_set (t)\n-     tree t ATTRIBUTE_UNUSED;\n+lhd_get_alias_set (tree t ATTRIBUTE_UNUSED)\n {\n   return -1;\n }\n@@ -224,30 +208,25 @@ lhd_get_alias_set (t)\n    used by languages that haven't deal with alias sets yet.  */\n \n HOST_WIDE_INT\n-hook_get_alias_set_0 (t)\n-     tree t ATTRIBUTE_UNUSED;\n+hook_get_alias_set_0 (tree t ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n \n /* This is the default expand_expr function.  */\n \n rtx\n-lhd_expand_expr (t, r, mm, em)\n-     tree t ATTRIBUTE_UNUSED;\n-     rtx r ATTRIBUTE_UNUSED;\n-     enum machine_mode mm ATTRIBUTE_UNUSED;\n-     int em ATTRIBUTE_UNUSED;\n+lhd_expand_expr (tree t ATTRIBUTE_UNUSED, rtx r ATTRIBUTE_UNUSED,\n+\t\t enum machine_mode mm ATTRIBUTE_UNUSED,\n+\t\t int em ATTRIBUTE_UNUSED)\n {\n   abort ();\n }\n \n /* This is the default decl_printable_name function.  */\n \n const char *\n-lhd_decl_printable_name (decl, verbosity)\n-     tree decl;\n-     int verbosity ATTRIBUTE_UNUSED;\n+lhd_decl_printable_name (tree decl, int verbosity ATTRIBUTE_UNUSED)\n {\n   return IDENTIFIER_POINTER (DECL_NAME (decl));\n }\n@@ -264,12 +243,11 @@ lhd_decl_printable_name (decl, verbosity)\n    when the function is called.  */\n \n tree\n-lhd_tree_inlining_walk_subtrees (tp,subtrees,func,data,htab)\n-     tree *tp ATTRIBUTE_UNUSED;\n-     int *subtrees ATTRIBUTE_UNUSED;\n-     walk_tree_fn func ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n-     void *htab ATTRIBUTE_UNUSED;\n+lhd_tree_inlining_walk_subtrees (tree *tp ATTRIBUTE_UNUSED,\n+\t\t\t\t int *subtrees ATTRIBUTE_UNUSED,\n+\t\t\t\t walk_tree_fn func ATTRIBUTE_UNUSED,\n+\t\t\t\t void *data ATTRIBUTE_UNUSED,\n+\t\t\t\t void *htab ATTRIBUTE_UNUSED)\n {\n   return NULL_TREE;\n }\n@@ -279,8 +257,7 @@ lhd_tree_inlining_walk_subtrees (tp,subtrees,func,data,htab)\n    inlining a given function.  */\n \n int\n-lhd_tree_inlining_cannot_inline_tree_fn (fnp)\n-     tree *fnp;\n+lhd_tree_inlining_cannot_inline_tree_fn (tree *fnp)\n {\n   if (flag_really_no_inline\n       && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (*fnp)) == NULL)\n@@ -294,8 +271,7 @@ lhd_tree_inlining_cannot_inline_tree_fn (fnp)\n    if it would exceed inlining limits.  */\n \n int\n-lhd_tree_inlining_disregard_inline_limits (fn)\n-     tree fn;\n+lhd_tree_inlining_disregard_inline_limits (tree fn)\n {\n   if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) != NULL)\n     return 1;\n@@ -311,9 +287,7 @@ lhd_tree_inlining_disregard_inline_limits (fn)\n    returned.  */\n \n tree\n-lhd_tree_inlining_add_pending_fn_decls (vafnp, pfn)\n-     void *vafnp ATTRIBUTE_UNUSED;\n-     tree pfn;\n+lhd_tree_inlining_add_pending_fn_decls (void *vafnp ATTRIBUTE_UNUSED, tree pfn)\n {\n   return pfn;\n }\n@@ -323,8 +297,7 @@ lhd_tree_inlining_add_pending_fn_decls (vafnp, pfn)\n    whether it should be walked, copied and preserved across copies.  */\n \n int\n-lhd_tree_inlining_tree_chain_matters_p (t)\n-     tree t ATTRIBUTE_UNUSED;\n+lhd_tree_inlining_tree_chain_matters_p (tree t ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n@@ -333,8 +306,7 @@ lhd_tree_inlining_tree_chain_matters_p (t)\n    whether VT is an automatic variable defined in function FT.  */\n \n int\n-lhd_tree_inlining_auto_var_in_fn_p (var, fn)\n-     tree var, fn;\n+lhd_tree_inlining_auto_var_in_fn_p (tree var, tree fn)\n {\n   return (DECL_P (var) && DECL_CONTEXT (var) == fn\n \t  && (((TREE_CODE (var) == VAR_DECL || TREE_CODE (var) == PARM_DECL)\n@@ -353,12 +325,10 @@ lhd_tree_inlining_auto_var_in_fn_p (var, fn)\n    match RES.  */\n \n tree\n-lhd_tree_inlining_copy_res_decl_for_inlining (res, fn, caller,\n-\t\t\t\t\t      dm, ndp, return_slot_addr)\n-     tree res, fn, caller;\n-     void *dm ATTRIBUTE_UNUSED;\n-     int *ndp ATTRIBUTE_UNUSED;\n-     tree return_slot_addr ATTRIBUTE_UNUSED;\n+lhd_tree_inlining_copy_res_decl_for_inlining (tree res, tree fn, tree caller,\n+\t\t\t\t\t      void *dm ATTRIBUTE_UNUSED,\n+\t\t\t\t\t      int *ndp ATTRIBUTE_UNUSED,\n+\t\t\t\t\t      tree return_slot_addr ATTRIBUTE_UNUSED)\n {\n   if (return_slot_addr)\n     return build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (return_slot_addr)),\n@@ -372,8 +342,7 @@ lhd_tree_inlining_copy_res_decl_for_inlining (res, fn, caller,\n    i.e., one whose members are in the same scope as the union itself.  */\n \n int\n-lhd_tree_inlining_anon_aggr_type_p (t)\n-     tree t ATTRIBUTE_UNUSED;\n+lhd_tree_inlining_anon_aggr_type_p (tree t ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n@@ -387,26 +356,23 @@ lhd_tree_inlining_anon_aggr_type_p (t)\n    avoid infinite recursion.  */\n \n int\n-lhd_tree_inlining_start_inlining (fn)\n-     tree fn ATTRIBUTE_UNUSED;\n+lhd_tree_inlining_start_inlining (tree fn ATTRIBUTE_UNUSED)\n {\n   return 1;\n }\n \n void\n-lhd_tree_inlining_end_inlining (fn)\n-     tree fn ATTRIBUTE_UNUSED;\n+lhd_tree_inlining_end_inlining (tree fn ATTRIBUTE_UNUSED)\n {\n }\n \n /* lang_hooks.tree_inlining.convert_parm_for_inlining performs any\n    language-specific conversion before assigning VALUE to PARM.  */\n \n tree\n-lhd_tree_inlining_convert_parm_for_inlining (parm, value, fndecl)\n-     tree parm ATTRIBUTE_UNUSED;\n-     tree value;\n-     tree fndecl ATTRIBUTE_UNUSED;\n+lhd_tree_inlining_convert_parm_for_inlining (tree parm ATTRIBUTE_UNUSED,\n+\t\t\t\t\t     tree value,\n+\t\t\t\t\t     tree fndecl ATTRIBUTE_UNUSED)\n {\n   return value;\n }\n@@ -416,9 +382,7 @@ lhd_tree_inlining_convert_parm_for_inlining (parm, value, fndecl)\n    second argument.  */\n \n bool\n-lhd_tree_dump_dump_tree (di, t)\n-     void *di ATTRIBUTE_UNUSED;\n-     tree t ATTRIBUTE_UNUSED;\n+lhd_tree_dump_dump_tree (void *di ATTRIBUTE_UNUSED, tree t ATTRIBUTE_UNUSED)\n {\n   return false;\n }\n@@ -427,8 +391,7 @@ lhd_tree_dump_dump_tree (di, t)\n    language-specific way.  */\n \n int\n-lhd_tree_dump_type_quals (t)\n-     tree t;\n+lhd_tree_dump_type_quals (tree t)\n {\n   return TYPE_QUALS (t);\n }\n@@ -437,8 +400,7 @@ lhd_tree_dump_type_quals (t)\n    in a language-specific way.  Returns a tree for the size in bytes.  */\n \n tree\n-lhd_expr_size (exp)\n-     tree exp;\n+lhd_expr_size (tree exp)\n {\n   if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd'\n       && DECL_SIZE_UNIT (exp) != 0)\n@@ -451,8 +413,7 @@ lhd_expr_size (exp)\n    which is a language-specific tree code in category 'x'.  The\n    default expects never to be called.  */\n size_t\n-lhd_tree_size (c)\n-     enum tree_code c ATTRIBUTE_UNUSED;\n+lhd_tree_size (enum tree_code c ATTRIBUTE_UNUSED)\n {\n   abort ();\n   return 0;\n@@ -462,16 +423,15 @@ lhd_tree_size (c)\n    sibcall.  */\n \n bool\n-lhd_decl_ok_for_sibcall (decl)\n-     tree decl ATTRIBUTE_UNUSED;\n+lhd_decl_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED)\n {\n   return true;\n }\n \n /* lang_hooks.decls.final_write_globals: perform final processing on\n    global variables.  */\n void\n-write_global_declarations ()\n+write_global_declarations (void)\n {\n   /* Really define vars that have had only a tentative definition.\n      Really output inline functions that must actually be callable"}, {"sha": "df3dab1587dcc4c57bd45129e0d458342ea28a6b", "filename": "gcc/langhooks.h", "status": "modified", "additions": 75, "deletions": 79, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* The lang_hooks data structure.\n-   Copyright 2001, 2002 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -26,62 +26,59 @@ Boston, MA 02111-1307, USA.  */\n struct diagnostic_context;\n \n /* A print hook for print_tree ().  */\n-typedef void (*lang_print_tree_hook) PARAMS ((FILE *, tree, int indent));\n+typedef void (*lang_print_tree_hook) (FILE *, tree, int indent);\n \n /* The following hooks are documented in langhooks.c.  Must not be\n    NULL.  */\n \n struct lang_hooks_for_tree_inlining\n {\n-  union tree_node *(*walk_subtrees) PARAMS ((union tree_node **, int *,\n-\t\t\t\t\t     union tree_node *(*)\n-\t\t\t\t\t     (union tree_node **,\n-\t\t\t\t\t      int *, void *),\n-\t\t\t\t\t     void *, void *));\n-  int (*cannot_inline_tree_fn) PARAMS ((union tree_node **));\n-  int (*disregard_inline_limits) PARAMS ((union tree_node *));\n-  union tree_node *(*add_pending_fn_decls) PARAMS ((void *,\n-\t\t\t\t\t\t    union tree_node *));\n-  int (*tree_chain_matters_p) PARAMS ((union tree_node *));\n-  int (*auto_var_in_fn_p) PARAMS ((union tree_node *, union tree_node *));\n-  union tree_node *(*copy_res_decl_for_inlining) PARAMS ((union tree_node *,\n-\t\t\t\t\t\t\t  union tree_node *,\n-\t\t\t\t\t\t\t  union tree_node *,\n-\t\t\t\t\t\t\t  void *, int *,\n-\t\t\t\t\t\t\t  tree));\n-  int (*anon_aggr_type_p) PARAMS ((union tree_node *));\n-  bool (*var_mod_type_p) PARAMS ((union tree_node *));\n-  int (*start_inlining) PARAMS ((union tree_node *));\n-  void (*end_inlining) PARAMS ((union tree_node *));\n-  union tree_node *(*convert_parm_for_inlining) PARAMS ((union tree_node *,\n-\t\t\t\t\t\t\t union tree_node *,\n-\t\t\t\t\t\t\t union tree_node *));\n+  union tree_node *(*walk_subtrees) (union tree_node **, int *,\n+\t\t\t\t     union tree_node *(*)\n+\t\t\t\t     (union tree_node **, int *, void *),\n+\t\t\t\t     void *, void *);\n+  int (*cannot_inline_tree_fn) (union tree_node **);\n+  int (*disregard_inline_limits) (union tree_node *);\n+  union tree_node *(*add_pending_fn_decls) (void *, union tree_node *);\n+  int (*tree_chain_matters_p) (union tree_node *);\n+  int (*auto_var_in_fn_p) (union tree_node *, union tree_node *);\n+  union tree_node *(*copy_res_decl_for_inlining) (union tree_node *,\n+\t\t\t\t\t\t  union tree_node *,\n+\t\t\t\t\t\t  union tree_node *,\n+\t\t\t\t\t\t  void *, int *, tree);\n+  int (*anon_aggr_type_p) (union tree_node *);\n+  bool (*var_mod_type_p) (union tree_node *);\n+  int (*start_inlining) (union tree_node *);\n+  void (*end_inlining) (union tree_node *);\n+  union tree_node *(*convert_parm_for_inlining) (union tree_node *,\n+\t\t\t\t\t\t union tree_node *,\n+\t\t\t\t\t\t union tree_node *);\n };\n \n struct lang_hooks_for_callgraph\n {\n   /* Function passed as argument is needed and will be compiled.\n      Lower the representation so the calls are explicit.  */\n-  void (*lower_function) PARAMS ((union tree_node *));\n+  void (*lower_function) (union tree_node *);\n   /* Produce RTL for function passed as argument.  */\n-  void (*expand_function) PARAMS ((union tree_node *));\n+  void (*expand_function) (union tree_node *);\n };\n \n /* Lang hooks for management of language-specific data or status\n    when entering / leaving functions etc.  */\n struct lang_hooks_for_functions\n {\n   /* Called when entering a function.  */\n-  void (*init) PARAMS ((struct function *));\n+  void (*init) (struct function *);\n \n   /* Called when leaving a function.  */\n-  void (*final) PARAMS ((struct function *));\n+  void (*final) (struct function *);\n \n   /* Called when entering a nested function.  */\n-  void (*enter_nested) PARAMS ((struct function *));\n+  void (*enter_nested) (struct function *);\n \n   /* Called when leaving a nested function.  */\n-  void (*leave_nested) PARAMS ((struct function *));\n+  void (*leave_nested) (struct function *);\n };\n \n /* The following hooks are used by tree-dump.c.  */\n@@ -90,10 +87,10 @@ struct lang_hooks_for_tree_dump\n {\n   /* Dump language-specific parts of tree nodes.  Returns nonzero if it\n      does not want the usual dumping of the second argument.  */\n-  bool (*dump_tree) PARAMS ((void *, tree));\n+  bool (*dump_tree) (void *, tree);\n \n   /* Determine type qualifiers in a language-specific way.  */\n-  int (*type_quals) PARAMS ((tree));\n+  int (*type_quals) (tree);\n };\n \n /* Hooks related to types.  */\n@@ -102,39 +99,39 @@ struct lang_hooks_for_types\n {\n   /* Return a new type (with the indicated CODE), doing whatever\n      language-specific processing is required.  */\n-  tree (*make_type) PARAMS ((enum tree_code));\n+  tree (*make_type) (enum tree_code);\n \n   /* Given MODE and UNSIGNEDP, return a suitable type-tree with that\n      mode.  */\n-  tree (*type_for_mode) PARAMS ((enum machine_mode, int));\n+  tree (*type_for_mode) (enum machine_mode, int);\n \n   /* Given PRECISION and UNSIGNEDP, return a suitable type-tree for an\n      integer type with at least that precision.  */\n-  tree (*type_for_size) PARAMS ((unsigned, int));\n+  tree (*type_for_size) (unsigned, int);\n \n   /* Given an integer type T, return a type like T but unsigned.\n      If T is unsigned, the value is T.  */\n-  tree (*unsigned_type) PARAMS ((tree));\n+  tree (*unsigned_type) (tree);\n \n   /* Given an integer type T, return a type like T but signed.\n      If T is signed, the value is T.  */\n-  tree (*signed_type) PARAMS ((tree));\n+  tree (*signed_type) (tree);\n \n   /* Return a type the same as TYPE except unsigned or signed\n      according to UNSIGNEDP.  */\n-  tree (*signed_or_unsigned_type) PARAMS ((int, tree));\n+  tree (*signed_or_unsigned_type) (int, tree);\n \n   /* Given a type, apply default promotions to unnamed function\n      arguments and return the new type.  Return the same type if no\n      change.  Required by any language that supports variadic\n      arguments.  The default hook aborts.  */\n-  tree (*type_promotes_to) PARAMS ((tree));\n+  tree (*type_promotes_to) (tree);\n \n   /* This routine is called in tree.c to print an error message for\n      invalid use of an incomplete type.  VALUE is the expression that\n      was used (or 0 if that isn't known) and TYPE is the type that was\n      invalid.  */\n-  void (*incomplete_type_error) PARAMS ((tree value, tree type));\n+  void (*incomplete_type_error) (tree value, tree type);\n };\n \n /* Language hooks related to decls and the symbol table.  */\n@@ -143,49 +140,49 @@ struct lang_hooks_for_decls\n {\n   /* Enter a new lexical scope.  Argument is always zero when called\n      from outside the front end.  */\n-  void (*pushlevel) PARAMS ((int));\n+  void (*pushlevel) (int);\n \n   /* Exit a lexical scope and return a BINDING for that scope.\n      Takes three arguments:\n      KEEP -- nonzero if there were declarations in this scope.\n      REVERSE -- reverse the order of decls before returning them.\n      FUNCTIONBODY -- nonzero if this level is the body of a function.  */\n-  tree (*poplevel) PARAMS ((int, int, int));\n+  tree (*poplevel) (int, int, int);\n \n   /* Returns nonzero if we are in the global binding level.  Ada\n      returns -1 for an undocumented reason used in stor-layout.c.  */\n-  int (*global_bindings_p) PARAMS ((void));\n+  int (*global_bindings_p) (void);\n \n   /* Insert BLOCK at the end of the list of subblocks of the\n      current binding level.  This is used when a BIND_EXPR is expanded,\n      to handle the BLOCK node inside the BIND_EXPR.  */\n-  void (*insert_block) PARAMS ((tree));\n+  void (*insert_block) (tree);\n \n   /* Set the BLOCK node for the current scope level.  */\n-  void (*set_block) PARAMS ((tree));\n+  void (*set_block) (tree);\n \n   /* Function to add a decl to the current scope level.  Takes one\n      argument, a decl to add.  Returns that decl, or, if the same\n      symbol is already declared, may return a different decl for that\n      name.  */\n-  tree (*pushdecl) PARAMS ((tree));\n+  tree (*pushdecl) (tree);\n \n   /* Returns the chain of decls so far in the current scope level.  */\n-  tree (*getdecls) PARAMS ((void));\n+  tree (*getdecls) (void);\n \n   /* Returns true when we should warn for an unused global DECL.\n      We will already have checked that it has static binding.  */\n-  bool (*warn_unused_global) PARAMS ((tree));\n+  bool (*warn_unused_global) (tree);\n \n   /* Obtain a list of globals and do final output on them at end\n      of compilation */\n-  void (*final_write_globals) PARAMS ((void));\n+  void (*final_write_globals) (void);\n \n   /* Do necessary preparations before assemble_variable can proceed.  */\n-  void (*prepare_assemble_variable) PARAMS ((tree));\n+  void (*prepare_assemble_variable) (tree);\n \n   /* True if this decl may be called via a sibcall.  */\n-  bool (*ok_for_sibcall) PARAMS ((tree));\n+  bool (*ok_for_sibcall) (tree);\n };\n \n /* Language-specific hooks.  See langhooks-def.h for defaults.  */\n@@ -202,7 +199,7 @@ struct lang_hooks\n   /* Determines the size of any language-specific 'x' or 'c' nodes.\n      Since it is called from make_node, the only information available\n      is the tree code.  Expected to abort on unrecognized codes.  */\n-  size_t (*tree_size) PARAMS ((enum tree_code));\n+  size_t (*tree_size) (enum tree_code);\n \n   /* The first callback made to the front end, for simple\n      initialization needed before any calls to handle_option.  Return\n@@ -225,38 +222,38 @@ struct lang_hooks\n \n      Should return true to indicate that a compiler back-end is\n      not required, such as with the -E option.\n-     \n+\n      If errorcount is nonzero after this call the compiler exits\n      immediately and the finish hook is not called.  */\n-  bool (*post_options) PARAMS ((const char **));\n+  bool (*post_options) (const char **);\n \n   /* Called after post_options to initialize the front end.  Return\n      false to indicate that no further compilation be performed, in\n      which case the finish hook is called immediately.  */\n-  bool (*init) PARAMS ((void));\n+  bool (*init) (void);\n \n   /* Called at the end of compilation, as a finalizer.  */\n-  void (*finish) PARAMS ((void));\n+  void (*finish) (void);\n \n   /* Parses the entire file.  The argument is nonzero to cause bison\n      parsers to dump debugging information during parsing.  */\n-  void (*parse_file) PARAMS ((int));\n+  void (*parse_file) (int);\n \n   /* Called immediately after parsing to clear the binding stack.  */\n-  void (*clear_binding_stack) PARAMS ((void));\n+  void (*clear_binding_stack) (void);\n \n   /* Called to obtain the alias set to be used for an expression or type.\n      Returns -1 if the language does nothing special for it.  */\n-  HOST_WIDE_INT (*get_alias_set) PARAMS ((tree));\n+  HOST_WIDE_INT (*get_alias_set) (tree);\n \n   /* Called with an expression that is to be processed as a constant.\n      Returns either the same expression or a language-independent\n      constant equivalent to its input.  */\n-  tree (*expand_constant) PARAMS ((tree));\n+  tree (*expand_constant) (tree);\n \n   /* Called by expand_expr for language-specific tree codes.\n      Fourth argument is actually an enum expand_modifier.  */\n-  rtx (*expand_expr) PARAMS ((tree, rtx, enum machine_mode, int));\n+  rtx (*expand_expr) (tree, rtx, enum machine_mode, int);\n \n   /* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n      operation.\n@@ -269,11 +266,11 @@ struct lang_hooks\n \n      The result should be an expression of boolean type (if not an\n      error_mark_node).  */\n-  tree (*truthvalue_conversion) PARAMS ((tree));\n+  tree (*truthvalue_conversion) (tree);\n \n   /* Possibly apply default attributes to a function (represented by\n      a FUNCTION_DECL).  */\n-  void (*insert_default_attributes) PARAMS ((tree));\n+  void (*insert_default_attributes) (tree);\n \n   /* Hook called by safe_from_p for language-specific tree codes.  It is\n      up to the language front-end to install a hook if it has any such\n@@ -282,48 +279,48 @@ struct lang_hooks\n      should not reexamine those pieces.  This routine may recursively\n      call safe_from_p; it should always pass `0' as the TOP_P\n      parameter.  */\n-  int (*safe_from_p) PARAMS ((rtx, tree));\n+  int (*safe_from_p) (rtx, tree);\n \n   /* Function to finish handling an incomplete decl at the end of\n      compilation.  Default hook is does nothing.  */\n-  void (*finish_incomplete_decl) PARAMS ((tree));\n+  void (*finish_incomplete_decl) (tree);\n \n   /* Function used by unsafe_for_reeval.  A non-negative number is\n      returned directly from unsafe_for_reeval, a negative number falls\n      through.  The default hook returns a negative number.  */\n-  int (*unsafe_for_reeval) PARAMS ((tree));\n+  int (*unsafe_for_reeval) (tree);\n \n   /* Mark EXP saying that we need to be able to take the address of\n      it; it should not be allocated in a register.  Return true if\n      successful.  */\n-  bool (*mark_addressable) PARAMS ((tree));\n+  bool (*mark_addressable) (tree);\n \n   /* Hook called by staticp for language-specific tree codes.  */\n-  int (*staticp) PARAMS ((tree));\n+  int (*staticp) (tree);\n \n   /* Replace the DECL_LANG_SPECIFIC data, which may be NULL, of the\n      DECL_NODE with a newly GC-allocated copy.  */\n-  void (*dup_lang_specific_decl) PARAMS ((tree));\n+  void (*dup_lang_specific_decl) (tree);\n \n   /* Called before its argument, an UNSAVE_EXPR, is to be\n      unsaved.  Modify it in-place so that all the evaluate only once\n      things are cleared out.  */\n-  tree (*unsave_expr_now) PARAMS ((tree));\n+  tree (*unsave_expr_now) (tree);\n \n   /* Called by expand_expr to build and return the cleanup-expression\n      for the passed TARGET_EXPR.  Return NULL if there is none.  */\n-  tree (*maybe_build_cleanup) PARAMS ((tree));\n+  tree (*maybe_build_cleanup) (tree);\n \n   /* Set the DECL_ASSEMBLER_NAME for a node.  If it is the sort of\n      thing that the assembler should talk about, set\n      DECL_ASSEMBLER_NAME to an appropriate IDENTIFIER_NODE.\n      Otherwise, set it to the ERROR_MARK_NODE to ensure that the\n      assembler does not talk about it.  */\n-  void (*set_decl_assembler_name) PARAMS ((tree));\n+  void (*set_decl_assembler_name) (tree);\n \n   /* Return nonzero if fold-const is free to use bit-field\n      optimizations, for instance in fold_truthop().  */\n-  bool (*can_use_bit_fields_p) PARAMS ((void));\n+  bool (*can_use_bit_fields_p) (void);\n \n   /* Nonzero if TYPE_READONLY and TREE_READONLY should always be honored.  */\n   bool honor_readonly;\n@@ -335,7 +332,7 @@ struct lang_hooks\n \n   /* The front end can add its own statistics to -fmem-report with\n      this hook.  It should output to stderr.  */\n-  void (*print_statistics) PARAMS ((void));\n+  void (*print_statistics) (void);\n \n   /* Called by print_tree when there is a tree of class 'x' that it\n      doesn't know how to display.  */\n@@ -353,17 +350,16 @@ struct lang_hooks\n      necessary.  1: and scope information.  2: and any other\n      information that might be interesting, such as function parameter\n      types in C++.  */\n-  const char *(*decl_printable_name) PARAMS ((tree decl, int verbosity));\n+  const char *(*decl_printable_name) (tree decl, int verbosity);\n \n   /* Called by report_error_function to print out function name.  */\n-  void (*print_error_function) PARAMS ((struct diagnostic_context *,\n-\t\t\t\t\tconst char *));\n+  void (*print_error_function) (struct diagnostic_context *, const char *);\n \n   /* Called from expr_size to calculate the size of the value of an\n      expression in a language-dependent way.  Returns a tree for the size\n      in bytes.  A frontend can call lhd_expr_size to get the default\n      semantics in cases that it doesn't want to handle specially.  */\n-  tree (*expr_size) PARAMS ((tree));\n+  tree (*expr_size) (tree);\n \n   /* Pointers to machine-independent attribute tables, for front ends\n      using attribs.c.  If one is NULL, it is ignored.  Respectively, a"}, {"sha": "87e013300c3fa6d7e62006ef246ff820625a759f", "filename": "gcc/lcm.c", "status": "modified", "additions": 53, "deletions": 99, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,6 @@\n /* Generic partial redundancy elimination with lazy code motion support.\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -70,32 +71,22 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"insn-attr.h\"\n \n /* Edge based LCM routines.  */\n-static void compute_antinout_edge\tPARAMS ((sbitmap *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *, sbitmap *));\n-static void compute_earliest\t\tPARAMS ((struct edge_list *, int,\n-\t\t\t\t\t\t sbitmap *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *));\n-static void compute_laterin\t\tPARAMS ((struct edge_list *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *));\n-static void compute_insert_delete\tPARAMS ((struct edge_list *edge_list,\n-\t\t\t\t\t\t sbitmap *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *));\n+static void compute_antinout_edge (sbitmap *, sbitmap *, sbitmap *, sbitmap *);\n+static void compute_earliest (struct edge_list *, int, sbitmap *, sbitmap *,\n+\t\t\t      sbitmap *, sbitmap *, sbitmap *);\n+static void compute_laterin (struct edge_list *, sbitmap *, sbitmap *,\n+\t\t\t     sbitmap *, sbitmap *);\n+static void compute_insert_delete (struct edge_list *edge_list, sbitmap *,\n+\t\t\t\t   sbitmap *, sbitmap *, sbitmap *, sbitmap *);\n \n /* Edge based LCM routines on a reverse flowgraph.  */\n-static void compute_farthest\t\tPARAMS ((struct edge_list *, int,\n-\t\t\t\t\t\t sbitmap *, sbitmap *,\n-\t\t\t\t\t\t sbitmap*, sbitmap *,\n-\t\t\t\t\t\t sbitmap *));\n-static void compute_nearerout\t\tPARAMS ((struct edge_list *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *));\n-static void compute_rev_insert_delete\tPARAMS ((struct edge_list *edge_list,\n-\t\t\t\t\t\t sbitmap *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *));\n+static void compute_farthest (struct edge_list *, int, sbitmap *, sbitmap *,\n+\t\t\t      sbitmap*, sbitmap *, sbitmap *);\n+static void compute_nearerout (struct edge_list *, sbitmap *, sbitmap *,\n+\t\t\t       sbitmap *, sbitmap *);\n+static void compute_rev_insert_delete (struct edge_list *edge_list, sbitmap *,\n+\t\t\t\t       sbitmap *, sbitmap *, sbitmap *,\n+\t\t\t\t       sbitmap *);\n \f\n /* Edge based lcm routines.  */\n \n@@ -104,11 +95,8 @@ static void compute_rev_insert_delete\tPARAMS ((struct edge_list *edge_list,\n    Other than that, its pretty much identical to compute_antinout.  */\n \n static void\n-compute_antinout_edge (antloc, transp, antin, antout)\n-     sbitmap *antloc;\n-     sbitmap *transp;\n-     sbitmap *antin;\n-     sbitmap *antout;\n+compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n+\t\t       sbitmap *antout)\n {\n   basic_block bb;\n   edge e;\n@@ -189,10 +177,9 @@ compute_antinout_edge (antloc, transp, antin, antout)\n /* Compute the earliest vector for edge based lcm.  */\n \n static void\n-compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest)\n-     struct edge_list *edge_list;\n-     int n_exprs;\n-     sbitmap *antin, *antout, *avout, *kill, *earliest;\n+compute_earliest (struct edge_list *edge_list, int n_exprs, sbitmap *antin,\n+\t\t  sbitmap *antout, sbitmap *avout, sbitmap *kill,\n+\t\t  sbitmap *earliest)\n {\n   sbitmap difference, temp_bitmap;\n   int x, num_edges;\n@@ -258,9 +245,8 @@ compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest)\n      to compute it.  */\n \n static void\n-compute_laterin (edge_list, earliest, antloc, later, laterin)\n-     struct edge_list *edge_list;\n-     sbitmap *earliest, *antloc, *later, *laterin;\n+compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n+\t\t sbitmap *antloc, sbitmap *later, sbitmap *laterin)\n {\n   int num_edges, i;\n   edge e;\n@@ -361,10 +347,9 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n /* Compute the insertion and deletion points for edge based LCM.  */\n \n static void\n-compute_insert_delete (edge_list, antloc, later, laterin,\n-\t\t       insert, delete)\n-     struct edge_list *edge_list;\n-     sbitmap *antloc, *later, *laterin, *insert, *delete;\n+compute_insert_delete (struct edge_list *edge_list, sbitmap *antloc,\n+\t\t       sbitmap *later, sbitmap *laterin, sbitmap *insert,\n+\t\t       sbitmap *delete)\n {\n   int x;\n   basic_block bb;\n@@ -388,15 +373,9 @@ compute_insert_delete (edge_list, antloc, later, laterin,\n    map the insert vector to what edge an expression should be inserted on.  */\n \n struct edge_list *\n-pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     int n_exprs;\n-     sbitmap *transp;\n-     sbitmap *avloc;\n-     sbitmap *antloc;\n-     sbitmap *kill;\n-     sbitmap **insert;\n-     sbitmap **delete;\n+pre_edge_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n+\t      sbitmap *avloc, sbitmap *antloc, sbitmap *kill,\n+\t      sbitmap **insert, sbitmap **delete)\n {\n   sbitmap *antin, *antout, *earliest;\n   sbitmap *avin, *avout;\n@@ -491,8 +470,8 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n    Return the number of passes we performed to iterate to a solution.  */\n \n void\n-compute_available (avloc, kill, avout, avin)\n-     sbitmap *avloc, *kill, *avout, *avin;\n+compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n+\t\t   sbitmap *avin)\n {\n   edge e;\n   basic_block *worklist, *qin, *qout, *qend, bb;\n@@ -573,11 +552,9 @@ compute_available (avloc, kill, avout, avin)\n /* Compute the farthest vector for edge based lcm.  */\n \n static void\n-compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin,\n-\t\t  kill, farthest)\n-     struct edge_list *edge_list;\n-     int n_exprs;\n-     sbitmap *st_avout, *st_avin, *st_antin, *kill, *farthest;\n+compute_farthest (struct edge_list *edge_list, int n_exprs,\n+\t\t  sbitmap *st_avout, sbitmap *st_avin, sbitmap *st_antin,\n+\t\t  sbitmap *kill, sbitmap *farthest)\n {\n   sbitmap difference, temp_bitmap;\n   int x, num_edges;\n@@ -619,9 +596,8 @@ compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin,\n    implementation can be found before compute_laterin.  */\n \n static void\n-compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout)\n-     struct edge_list *edge_list;\n-     sbitmap *farthest, *st_avloc, *nearer, *nearerout;\n+compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n+\t\t   sbitmap *st_avloc, sbitmap *nearer, sbitmap *nearerout)\n {\n   int num_edges, i;\n   edge e;\n@@ -702,10 +678,9 @@ compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout)\n /* Compute the insertion and deletion points for edge based LCM.  */\n \n static void\n-compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,\n-\t\t\t   insert, delete)\n-     struct edge_list *edge_list;\n-     sbitmap *st_avloc, *nearer, *nearerout, *insert, *delete;\n+compute_rev_insert_delete (struct edge_list *edge_list, sbitmap *st_avloc,\n+\t\t\t   sbitmap *nearer, sbitmap *nearerout,\n+\t\t\t   sbitmap *insert, sbitmap *delete)\n {\n   int x;\n   basic_block bb;\n@@ -729,16 +704,9 @@ compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,\n    an expression should be inserted on.  */\n \n struct edge_list *\n-pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n-\t\t  insert, delete)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     int n_exprs;\n-     sbitmap *transp;\n-     sbitmap *st_avloc;\n-     sbitmap *st_antloc;\n-     sbitmap *kill;\n-     sbitmap **insert;\n-     sbitmap **delete;\n+pre_edge_rev_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n+\t\t  sbitmap *st_avloc, sbitmap *st_antloc, sbitmap *kill,\n+\t\t  sbitmap **insert, sbitmap **delete)\n {\n   sbitmap *st_antin, *st_antout;\n   sbitmap *st_avout, *st_avin, *farthest;\n@@ -887,11 +855,11 @@ static sbitmap *comp;\n static sbitmap *delete;\n static sbitmap *insert;\n \n-static struct seginfo * new_seginfo PARAMS ((int, rtx, int, HARD_REG_SET));\n-static void add_seginfo PARAMS ((struct bb_info *, struct seginfo *));\n-static void reg_dies PARAMS ((rtx, HARD_REG_SET));\n-static void reg_becomes_live PARAMS ((rtx, rtx, void *));\n-static void make_preds_opaque PARAMS ((basic_block, int));\n+static struct seginfo * new_seginfo (int, rtx, int, HARD_REG_SET);\n+static void add_seginfo (struct bb_info *, struct seginfo *);\n+static void reg_dies (rtx, HARD_REG_SET);\n+static void reg_becomes_live (rtx, rtx, void *);\n+static void make_preds_opaque (basic_block, int);\n #endif\n \f\n #ifdef OPTIMIZE_MODE_SWITCHING\n@@ -900,11 +868,7 @@ static void make_preds_opaque PARAMS ((basic_block, int));\n    with the MODE, INSN, and basic block BB parameters.  */\n \n static struct seginfo *\n-new_seginfo (mode, insn, bb, regs_live)\n-     int mode;\n-     rtx insn;\n-     int bb;\n-     HARD_REG_SET regs_live;\n+new_seginfo (int mode, rtx insn, int bb, HARD_REG_SET regs_live)\n {\n   struct seginfo *ptr;\n   ptr = xmalloc (sizeof (struct seginfo));\n@@ -921,9 +885,7 @@ new_seginfo (mode, insn, bb, regs_live)\n    INFO is the structure to be linked in.  */\n \n static void\n-add_seginfo (head, info)\n-     struct bb_info *head;\n-     struct seginfo *info;\n+add_seginfo (struct bb_info *head, struct seginfo *info)\n {\n   struct seginfo *ptr;\n \n@@ -945,9 +907,7 @@ add_seginfo (head, info)\n    we are currently handling mode-switching for.  */\n \n static void\n-make_preds_opaque (b, j)\n-     basic_block b;\n-     int j;\n+make_preds_opaque (basic_block b, int j)\n {\n   edge e;\n \n@@ -966,9 +926,7 @@ make_preds_opaque (b, j)\n /* Record in LIVE that register REG died.  */\n \n static void\n-reg_dies (reg, live)\n-     rtx reg;\n-     HARD_REG_SET live;\n+reg_dies (rtx reg, HARD_REG_SET live)\n {\n   int regno, nregs;\n \n@@ -986,10 +944,7 @@ reg_dies (reg, live)\n    This is called via note_stores.  */\n \n static void\n-reg_becomes_live (reg, setter, live)\n-     rtx reg;\n-     rtx setter ATTRIBUTE_UNUSED;\n-     void *live;\n+reg_becomes_live (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *live)\n {\n   int regno, nregs;\n \n@@ -1010,8 +965,7 @@ reg_becomes_live (reg, setter, live)\n    necessary mode switches.  Return true if we did work.  */\n \n int\n-optimize_mode_switching (file)\n-     FILE *file;\n+optimize_mode_switching (FILE *file)\n {\n   rtx insn;\n   int e;"}, {"sha": "3f240fafd1f47e8409c91918eb774305275b3214", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 61, "deletions": 116, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -271,43 +271,40 @@ static struct equivalence *reg_equiv;\n /* Nonzero if we recorded an equivalence for a LABEL_REF.  */\n static int recorded_label_ref;\n \n-static void alloc_qty\t\tPARAMS ((int, enum machine_mode, int, int));\n-static void validate_equiv_mem_from_store PARAMS ((rtx, rtx, void *));\n-static int validate_equiv_mem\tPARAMS ((rtx, rtx, rtx));\n-static int equiv_init_varies_p  PARAMS ((rtx));\n-static int equiv_init_movable_p PARAMS ((rtx, int));\n-static int contains_replace_regs PARAMS ((rtx));\n-static int memref_referenced_p\tPARAMS ((rtx, rtx));\n-static int memref_used_between_p PARAMS ((rtx, rtx, rtx));\n-static void update_equiv_regs\tPARAMS ((void));\n-static void no_equiv\t\tPARAMS ((rtx, rtx, void *));\n-static void block_alloc\t\tPARAMS ((int));\n-static int qty_sugg_compare    \tPARAMS ((int, int));\n-static int qty_sugg_compare_1\tPARAMS ((const void *, const void *));\n-static int qty_compare    \tPARAMS ((int, int));\n-static int qty_compare_1\tPARAMS ((const void *, const void *));\n-static int combine_regs\t\tPARAMS ((rtx, rtx, int, int, rtx, int));\n-static int reg_meets_class_p\tPARAMS ((int, enum reg_class));\n-static void update_qty_class\tPARAMS ((int, int));\n-static void reg_is_set\t\tPARAMS ((rtx, rtx, void *));\n-static void reg_is_born\t\tPARAMS ((rtx, int));\n-static void wipe_dead_reg\tPARAMS ((rtx, int));\n-static int find_free_reg\tPARAMS ((enum reg_class, enum machine_mode,\n-\t\t\t\t       int, int, int, int, int));\n-static void mark_life\t\tPARAMS ((int, enum machine_mode, int));\n-static void post_mark_life\tPARAMS ((int, enum machine_mode, int, int, int));\n-static int no_conflict_p\tPARAMS ((rtx, rtx, rtx));\n-static int requires_inout\tPARAMS ((const char *));\n+static void alloc_qty (int, enum machine_mode, int, int);\n+static void validate_equiv_mem_from_store (rtx, rtx, void *);\n+static int validate_equiv_mem (rtx, rtx, rtx);\n+static int equiv_init_varies_p (rtx);\n+static int equiv_init_movable_p (rtx, int);\n+static int contains_replace_regs (rtx);\n+static int memref_referenced_p (rtx, rtx);\n+static int memref_used_between_p (rtx, rtx, rtx);\n+static void update_equiv_regs (void);\n+static void no_equiv (rtx, rtx, void *);\n+static void block_alloc (int);\n+static int qty_sugg_compare (int, int);\n+static int qty_sugg_compare_1 (const void *, const void *);\n+static int qty_compare (int, int);\n+static int qty_compare_1 (const void *, const void *);\n+static int combine_regs (rtx, rtx, int, int, rtx, int);\n+static int reg_meets_class_p (int, enum reg_class);\n+static void update_qty_class (int, int);\n+static void reg_is_set (rtx, rtx, void *);\n+static void reg_is_born (rtx, int);\n+static void wipe_dead_reg (rtx, int);\n+static int find_free_reg (enum reg_class, enum machine_mode, int, int, int,\n+\t\t\t  int, int);\n+static void mark_life (int, enum machine_mode, int);\n+static void post_mark_life (int, enum machine_mode, int, int, int);\n+static int no_conflict_p (rtx, rtx, rtx);\n+static int requires_inout (const char *);\n \f\n /* Allocate a new quantity (new within current basic block)\n    for register number REGNO which is born at index BIRTH\n    within the block.  MODE and SIZE are info on reg REGNO.  */\n \n static void\n-alloc_qty (regno, mode, size, birth)\n-     int regno;\n-     enum machine_mode mode;\n-     int size, birth;\n+alloc_qty (int regno, enum machine_mode mode, int size, int birth)\n {\n   int qtyno = next_qty++;\n \n@@ -329,7 +326,7 @@ alloc_qty (regno, mode, size, birth)\n /* Main entry point of this file.  */\n \n int\n-local_alloc ()\n+local_alloc (void)\n {\n   int i;\n   int max_qty;\n@@ -449,10 +446,8 @@ static int equiv_mem_modified;\n    Called via note_stores.  */\n \n static void\n-validate_equiv_mem_from_store (dest, set, data)\n-     rtx dest;\n-     rtx set ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+validate_equiv_mem_from_store (rtx dest, rtx set ATTRIBUTE_UNUSED,\n+\t\t\t       void *data ATTRIBUTE_UNUSED)\n {\n   if ((GET_CODE (dest) == REG\n        && reg_overlap_mentioned_p (dest, equiv_mem))\n@@ -469,10 +464,7 @@ validate_equiv_mem_from_store (dest, set, data)\n    Return 1 if MEMREF remains valid.  */\n \n static int\n-validate_equiv_mem (start, reg, memref)\n-     rtx start;\n-     rtx reg;\n-     rtx memref;\n+validate_equiv_mem (rtx start, rtx reg, rtx memref)\n {\n   rtx insn;\n   rtx note;\n@@ -518,8 +510,7 @@ validate_equiv_mem (start, reg, memref)\n /* Returns zero if X is known to be invariant.  */\n \n static int\n-equiv_init_varies_p (x)\n-     rtx x;\n+equiv_init_varies_p (rtx x)\n {\n   RTX_CODE code = GET_CODE (x);\n   int i;\n@@ -578,9 +569,7 @@ equiv_init_varies_p (x)\n    or if they are not candidates for local_alloc and don't vary.  */\n \n static int\n-equiv_init_movable_p (x, regno)\n-     rtx x;\n-     int regno;\n+equiv_init_movable_p (rtx x, int regno)\n {\n   int i, j;\n   const char *fmt;\n@@ -642,8 +631,7 @@ equiv_init_movable_p (x, regno)\n /* TRUE if X uses any registers for which reg_equiv[REGNO].replace is true.  */\n \n static int\n-contains_replace_regs (x)\n-     rtx x;\n+contains_replace_regs (rtx x)\n {\n   int i, j;\n   const char *fmt;\n@@ -691,9 +679,7 @@ contains_replace_regs (x)\n    to MEMREF.  */\n \n static int\n-memref_referenced_p (memref, x)\n-     rtx x;\n-     rtx memref;\n+memref_referenced_p (rtx memref, rtx x)\n {\n   int i, j;\n   const char *fmt;\n@@ -762,10 +748,7 @@ memref_referenced_p (memref, x)\n    that would be affected by a store to MEMREF.  */\n \n static int\n-memref_used_between_p (memref, start, end)\n-     rtx memref;\n-     rtx start;\n-     rtx end;\n+memref_used_between_p (rtx memref, rtx start, rtx end)\n {\n   rtx insn;\n \n@@ -785,8 +768,7 @@ memref_used_between_p (memref, start, end)\n    go to spill these things to memory.  */\n \n int\n-function_invariant_p (x)\n-     rtx x;\n+function_invariant_p (rtx x)\n {\n   if (CONSTANT_P (x))\n     return 1;\n@@ -808,7 +790,7 @@ function_invariant_p (x)\n    completely.  */\n \n static void\n-update_equiv_regs ()\n+update_equiv_regs (void)\n {\n   rtx insn;\n   basic_block bb;\n@@ -1186,9 +1168,7 @@ update_equiv_regs ()\n    assignment - a SET, CLOBBER or REG_INC note.  It is currently not used,\n    but needs to be there because this function is called from note_stores.  */\n static void\n-no_equiv (reg, store, data)\n-     rtx reg, store ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+no_equiv (rtx reg, rtx store ATTRIBUTE_UNUSED, void *data ATTRIBUTE_UNUSED)\n {\n   int regno;\n   rtx list;\n@@ -1212,8 +1192,7 @@ no_equiv (reg, store, data)\n    Only the pseudos that die but once can be handled.  */\n \n static void\n-block_alloc (b)\n-     int b;\n+block_alloc (int b)\n {\n   int i, q;\n   rtx insn;\n@@ -1693,16 +1672,13 @@ block_alloc (b)\n \t  / (qty[q].death - qty[q].birth)) * (10000 / REG_FREQ_MAX)))\n \n static int\n-qty_compare (q1, q2)\n-     int q1, q2;\n+qty_compare (int q1, int q2)\n {\n   return QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n }\n \n static int\n-qty_compare_1 (q1p, q2p)\n-     const void *q1p;\n-     const void *q2p;\n+qty_compare_1 (const void *q1p, const void *q2p)\n {\n   int q1 = *(const int *) q1p, q2 = *(const int *) q2p;\n   int tem = QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n@@ -1728,8 +1704,7 @@ qty_compare_1 (q1p, q2p)\n     : qty_phys_num_sugg[q] * FIRST_PSEUDO_REGISTER)\n \n static int\n-qty_sugg_compare (q1, q2)\n-     int q1, q2;\n+qty_sugg_compare (int q1, int q2)\n {\n   int tem = QTY_CMP_SUGG (q1) - QTY_CMP_SUGG (q2);\n \n@@ -1740,9 +1715,7 @@ qty_sugg_compare (q1, q2)\n }\n \n static int\n-qty_sugg_compare_1 (q1p, q2p)\n-     const void *q1p;\n-     const void *q2p;\n+qty_sugg_compare_1 (const void *q1p, const void *q2p)\n {\n   int q1 = *(const int *) q1p, q2 = *(const int *) q2p;\n   int tem = QTY_CMP_SUGG (q1) - QTY_CMP_SUGG (q2);\n@@ -1785,12 +1758,8 @@ qty_sugg_compare_1 (q1p, q2p)\n    There are elaborate checks for the validity of combining.  */\n \n static int\n-combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n-     rtx usedreg, setreg;\n-     int may_save_copy;\n-     int insn_number;\n-     rtx insn;\n-     int already_dead;\n+combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n+\t      rtx insn, int already_dead)\n {\n   int ureg, sreg;\n   int offset = 0;\n@@ -1999,9 +1968,7 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n    True if REG's reg class either contains or is contained in CLASS.  */\n \n static int\n-reg_meets_class_p (reg, class)\n-     int reg;\n-     enum reg_class class;\n+reg_meets_class_p (int reg, enum reg_class class)\n {\n   enum reg_class rclass = reg_preferred_class (reg);\n   return (reg_class_subset_p (rclass, class)\n@@ -2011,9 +1978,7 @@ reg_meets_class_p (reg, class)\n /* Update the class of QTYNO assuming that REG is being tied to it.  */\n \n static void\n-update_qty_class (qtyno, reg)\n-     int qtyno;\n-     int reg;\n+update_qty_class (int qtyno, int reg)\n {\n   enum reg_class rclass = reg_preferred_class (reg);\n   if (reg_class_subset_p (rclass, qty[qtyno].min_class))\n@@ -2034,10 +1999,7 @@ update_qty_class (qtyno, reg)\n    carry info from `block_alloc'.  */\n \n static void\n-reg_is_set (reg, setter, data)\n-     rtx reg;\n-     rtx setter;\n-     void *data ATTRIBUTE_UNUSED;\n+reg_is_set (rtx reg, rtx setter, void *data ATTRIBUTE_UNUSED)\n {\n   /* Note that note_stores will only pass us a SUBREG if it is a SUBREG of\n      a hard register.  These may actually not exist any more.  */\n@@ -2057,9 +2019,7 @@ reg_is_set (reg, setter, data)\n    BIRTH is the index at which this is happening.  */\n \n static void\n-reg_is_born (reg, birth)\n-     rtx reg;\n-     int birth;\n+reg_is_born (rtx reg, int birth)\n {\n   int regno;\n \n@@ -2098,9 +2058,7 @@ reg_is_born (reg, birth)\n    If OUTPUT_P is 1, then we extend the life past the end of this insn.  */\n \n static void\n-wipe_dead_reg (reg, output_p)\n-     rtx reg;\n-     int output_p;\n+wipe_dead_reg (rtx reg, int output_p)\n {\n   int regno = REGNO (reg);\n \n@@ -2165,14 +2123,9 @@ wipe_dead_reg (reg, output_p)\n    register is available.  If not, return -1.  */\n \n static int\n-find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n-\t       born_index, dead_index)\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     int qtyno;\n-     int accept_call_clobbered;\n-     int just_try_suggested;\n-     int born_index, dead_index;\n+find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n+\t       int accept_call_clobbered, int just_try_suggested,\n+\t       int born_index, int dead_index)\n {\n   int i, ins;\n   HARD_REG_SET first_used, used;\n@@ -2318,10 +2271,7 @@ find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n    is zero).  */\n \n static void\n-mark_life (regno, mode, life)\n-     int regno;\n-     enum machine_mode mode;\n-     int life;\n+mark_life (int regno, enum machine_mode mode, int life)\n {\n   int j = HARD_REGNO_NREGS (regno, mode);\n   if (life)\n@@ -2337,10 +2287,8 @@ mark_life (regno, mode, life)\n    to insn number DEATH (exclusive).  */\n \n static void\n-post_mark_life (regno, mode, life, birth, death)\n-     int regno;\n-     enum machine_mode mode;\n-     int life, birth, death;\n+post_mark_life (int regno, enum machine_mode mode, int life, int birth,\n+\t\tint death)\n {\n   int j = HARD_REGNO_NREGS (regno, mode);\n #ifdef HARD_REG_SET\n@@ -2377,8 +2325,7 @@ post_mark_life (regno, mode, life, birth, death)\n    Otherwise, return 0.  */\n \n static int\n-no_conflict_p (insn, r0, r1)\n-     rtx insn, r0 ATTRIBUTE_UNUSED, r1;\n+no_conflict_p (rtx insn, rtx r0 ATTRIBUTE_UNUSED, rtx r1)\n {\n   int ok = 0;\n   rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n@@ -2418,8 +2365,7 @@ no_conflict_p (insn, r0, r1)\n    is acceptable.  */\n \n static int\n-requires_inout (p)\n-     const char *p;\n+requires_inout (const char *p)\n {\n   char c;\n   int found_zero = 0;\n@@ -2483,8 +2429,7 @@ requires_inout (p)\n }\n \f\n void\n-dump_local_alloc (file)\n-     FILE *file;\n+dump_local_alloc (FILE *file)\n {\n   int i;\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)"}, {"sha": "13285a31e614901dd419b8fea38651bacc822117", "filename": "gcc/loop-init.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -31,8 +31,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Initialize loop optimizer.  */\n \n struct loops *\n-loop_optimizer_init (dumpfile)\n-     FILE *dumpfile;\n+loop_optimizer_init (FILE *dumpfile)\n {\n   struct loops *loops = xcalloc (1, sizeof (struct loops));\n   edge e;\n@@ -91,9 +90,7 @@ loop_optimizer_init (dumpfile)\n \n /* Finalize loop optimizer.  */\n void\n-loop_optimizer_finalize (loops, dumpfile)\n-     struct loops *loops;\n-     FILE *dumpfile;\n+loop_optimizer_finalize (struct loops *loops, FILE *dumpfile)\n {\n   basic_block bb;\n \n@@ -109,7 +106,7 @@ loop_optimizer_finalize (loops, dumpfile)\n   /* Clean up.  */\n   flow_loops_free (loops);\n   free (loops);\n- \n+\n   /* Finalize changes.  */\n   cfg_layout_finalize ();\n \n@@ -118,4 +115,3 @@ loop_optimizer_finalize (loops, dumpfile)\n   verify_flow_info ();\n #endif\n }\n-"}, {"sha": "dde3c7439af8bb8c6abab27b46345e1724d3ac0e", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 56, "deletions": 86, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Loop unrolling and peeling.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -66,27 +66,25 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    showed that this choice may affect performance in order of several %.\n    */\n \n-static void decide_unrolling_and_peeling PARAMS ((struct loops *, int));\n-static void peel_loops_completely PARAMS ((struct loops *, int));\n-static void decide_peel_simple PARAMS ((struct loops *, struct loop *, int));\n-static void decide_peel_once_rolling PARAMS ((struct loops *, struct loop *, int));\n-static void decide_peel_completely PARAMS ((struct loops *, struct loop *, int));\n-static void decide_unroll_stupid PARAMS ((struct loops *, struct loop *, int));\n-static void decide_unroll_constant_iterations PARAMS ((struct loops *, struct loop *, int));\n-static void decide_unroll_runtime_iterations PARAMS ((struct loops *, struct loop *, int));\n-static void peel_loop_simple PARAMS ((struct loops *, struct loop *));\n-static void peel_loop_completely PARAMS ((struct loops *, struct loop *));\n-static void unroll_loop_stupid PARAMS ((struct loops *, struct loop *));\n-static void unroll_loop_constant_iterations PARAMS ((struct loops *,\n-\t\t\t\t\t\t     struct loop *));\n-static void unroll_loop_runtime_iterations PARAMS ((struct loops *,\n-\t\t\t\t\t\t    struct loop *));\n+static void decide_unrolling_and_peeling (struct loops *, int);\n+static void peel_loops_completely (struct loops *, int);\n+static void decide_peel_simple (struct loops *, struct loop *, int);\n+static void decide_peel_once_rolling (struct loops *, struct loop *, int);\n+static void decide_peel_completely (struct loops *, struct loop *, int);\n+static void decide_unroll_stupid (struct loops *, struct loop *, int);\n+static void decide_unroll_constant_iterations (struct loops *,\n+\t\t\t\t\t       struct loop *, int);\n+static void decide_unroll_runtime_iterations (struct loops *, struct loop *,\n+\t\t\t\t\t      int);\n+static void peel_loop_simple (struct loops *, struct loop *);\n+static void peel_loop_completely (struct loops *, struct loop *);\n+static void unroll_loop_stupid (struct loops *, struct loop *);\n+static void unroll_loop_constant_iterations (struct loops *, struct loop *);\n+static void unroll_loop_runtime_iterations (struct loops *, struct loop *);\n \n /* Unroll and/or peel (depending on FLAGS) LOOPS.  */\n void\n-unroll_and_peel_loops (loops, flags)\n-     struct loops *loops;\n-     int flags;\n+unroll_and_peel_loops (struct loops *loops, int flags)\n {\n   struct loop *loop, *next;\n   int check;\n@@ -152,9 +150,7 @@ unroll_and_peel_loops (loops, flags)\n \n /* Check whether to peel LOOPS (depending on FLAGS) completely and do so.  */\n static void\n-peel_loops_completely (loops, flags)\n-     struct loops *loops;\n-     int flags;\n+peel_loops_completely (struct loops *loops, int flags)\n {\n   struct loop *loop, *next;\n \n@@ -175,7 +171,7 @@ peel_loops_completely (loops, flags)\n \n       loop->lpt_decision.decision = LPT_NONE;\n       loop->has_desc = 0;\n-  \n+\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \";; Considering loop %d for complete peeling\\n\",\n \t\t loop->num);\n@@ -200,9 +196,7 @@ peel_loops_completely (loops, flags)\n \n /* Decide whether unroll or peel LOOPS (depending on FLAGS) and how much.  */\n static void\n-decide_unrolling_and_peeling (loops, flags)\n-     struct loops *loops;\n-     int flags;\n+decide_unrolling_and_peeling (struct loops *loops, int flags)\n {\n   struct loop *loop = loops->tree_root, *next;\n \n@@ -275,10 +269,8 @@ decide_unrolling_and_peeling (loops, flags)\n /* Decide whether the LOOP is once rolling and suitable for complete\n    peeling.  */\n static void\n-decide_peel_once_rolling (loops, loop, flags)\n-     struct loops *loops;\n-     struct loop *loop;\n-     int flags ATTRIBUTE_UNUSED;\n+decide_peel_once_rolling (struct loops *loops, struct loop *loop,\n+\t\t\t  int flags ATTRIBUTE_UNUSED)\n {\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \";; Considering peeling once rolling loop\\n\");\n@@ -311,10 +303,8 @@ decide_peel_once_rolling (loops, loop, flags)\n \n /* Decide whether the LOOP is suitable for complete peeling.  */\n static void\n-decide_peel_completely (loops, loop, flags)\n-     struct loops *loops;\n-     struct loop *loop;\n-     int flags ATTRIBUTE_UNUSED;\n+decide_peel_completely (struct loops *loops, struct loop *loop,\n+\t\t\tint flags ATTRIBUTE_UNUSED)\n {\n   unsigned npeel;\n \n@@ -377,7 +367,7 @@ decide_peel_completely (loops, loop, flags)\n   if (loop->desc.niter > npeel - 1)\n     {\n       if (rtl_dump_file)\n-      \t{\n+\t{\n \t  fprintf (rtl_dump_file, \";; Not peeling loop completely, rolls too much (\");\n \t  fprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC,(HOST_WIDEST_INT) loop->desc.niter);\n \t  fprintf (rtl_dump_file, \" iterations > %d [maximum peelings])\\n\", npeel);\n@@ -393,29 +383,27 @@ decide_peel_completely (loops, loop, flags)\n \n /* Peel all iterations of LOOP, remove exit edges and cancel the loop\n    completely.  The transformation done:\n-   \n+\n    for (i = 0; i < 4; i++)\n      body;\n \n    ==>\n-   \n-   i = 0; \n+\n+   i = 0;\n    body; i++;\n    body; i++;\n    body; i++;\n    body; i++;\n    */\n static void\n-peel_loop_completely (loops, loop)\n-     struct loops *loops;\n-     struct loop *loop;\n+peel_loop_completely (struct loops *loops, struct loop *loop)\n {\n   sbitmap wont_exit;\n   unsigned HOST_WIDE_INT npeel;\n   unsigned n_remove_edges, i;\n   edge *remove_edges;\n   struct loop_desc *desc = &loop->desc;\n-  \n+\n   npeel = desc->niter;\n \n   if (npeel)\n@@ -453,10 +441,8 @@ peel_loop_completely (loops, loop)\n \n /* Decide whether to unroll LOOP iterating constant number of times and how much.  */\n static void\n-decide_unroll_constant_iterations (loops, loop, flags)\n-     struct loops *loops;\n-     struct loop *loop;\n-     int flags;\n+decide_unroll_constant_iterations (struct loops *loops, struct loop *loop,\n+\t\t\t\t   int flags)\n {\n   unsigned nunroll, nunroll_by_av, best_copies, best_unroll = -1, n_copies, i;\n \n@@ -546,13 +532,13 @@ decide_unroll_constant_iterations (loops, loop, flags)\n }\n \n /* Unroll LOOP with constant number of iterations LOOP->LPT_DECISION.TIMES + 1\n-   times.  The transformation does this: \n-   \n+   times.  The transformation does this:\n+\n    for (i = 0; i < 102; i++)\n      body;\n-   \n+\n    ==>\n-   \n+\n    i = 0;\n    body; i++;\n    body; i++;\n@@ -565,9 +551,7 @@ decide_unroll_constant_iterations (loops, loop, flags)\n      }\n   */\n static void\n-unroll_loop_constant_iterations (loops, loop)\n-     struct loops *loops;\n-     struct loop *loop;\n+unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n {\n   unsigned HOST_WIDE_INT niter;\n   unsigned exit_mod;\n@@ -665,10 +649,8 @@ unroll_loop_constant_iterations (loops, loop)\n /* Decide whether to unroll LOOP iterating runtime computable number of times\n    and how much.  */\n static void\n-decide_unroll_runtime_iterations (loops, loop, flags)\n-     struct loops *loops;\n-     struct loop *loop;\n-     int flags;\n+decide_unroll_runtime_iterations (struct loops *loops, struct loop *loop,\n+\t\t\t\t  int flags)\n {\n   unsigned nunroll, nunroll_by_av, i;\n \n@@ -739,15 +721,15 @@ decide_unroll_runtime_iterations (loops, loop, flags)\n /* Unroll LOOP for that we are able to count number of iterations in runtime\n    LOOP->LPT_DECISION.TIMES + 1 times.  The transformation does this (with some\n    extra care for case n < 0):\n-   \n+\n    for (i = 0; i < n; i++)\n      body;\n-   \n+\n    ==>\n-  \n+\n    i = 0;\n    mod = n % 4;\n-  \n+\n    switch (mod)\n      {\n        case 3:\n@@ -758,7 +740,7 @@ decide_unroll_runtime_iterations (loops, loop, flags)\n          body; i++;\n        case 0: ;\n      }\n-   \n+\n    while (i < n)\n      {\n        body; i++;\n@@ -768,9 +750,7 @@ decide_unroll_runtime_iterations (loops, loop, flags)\n      }\n    */\n static void\n-unroll_loop_runtime_iterations (loops, loop)\n-     struct loops *loops;\n-     struct loop *loop;\n+unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n {\n   rtx niter, init_code, branch_code, jump, label;\n   unsigned i, j, p;\n@@ -876,7 +856,7 @@ unroll_loop_runtime_iterations (loops, loop)\n \t\tloops, 1,\n \t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n-    \tabort ();\n+\tabort ();\n \n       /* Create item for switch.  */\n       j = n_peel - i - (extra_zero_check ? 0 : 1);\n@@ -894,7 +874,7 @@ unroll_loop_runtime_iterations (loops, loop)\n       REG_NOTES (jump)\n \t      = gen_rtx_EXPR_LIST (REG_BR_PROB,\n \t\t\t\t   GEN_INT (p), REG_NOTES (jump));\n-\t\n+\n       LABEL_NUSES (label)++;\n       branch_code = get_insns ();\n       end_sequence ();\n@@ -924,7 +904,7 @@ unroll_loop_runtime_iterations (loops, loop)\n       REG_NOTES (jump)\n \t      = gen_rtx_EXPR_LIST (REG_BR_PROB,\n \t\t\t\t   GEN_INT (p), REG_NOTES (jump));\n-      \n+\n       LABEL_NUSES (label)++;\n       branch_code = get_insns ();\n       end_sequence ();\n@@ -946,7 +926,7 @@ unroll_loop_runtime_iterations (loops, loop)\n   RESET_BIT (wont_exit, may_exit_copy);\n \n   if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n-\t \tloops, max_unroll,\n+\t\tloops, max_unroll,\n \t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n     abort ();\n@@ -963,13 +943,10 @@ unroll_loop_runtime_iterations (loops, loop)\n \t     \";; Unrolled loop %d times, counting # of iterations in runtime, %i insns\\n\",\n \t     max_unroll, num_loop_insns (loop));\n }\n-  \n+\n /* Decide whether to simply peel LOOP and how much.  */\n static void\n-decide_peel_simple (loops, loop, flags)\n-     struct loops *loops;\n-     struct loop *loop;\n-     int flags;\n+decide_peel_simple (struct loops *loops, struct loop *loop, int flags)\n {\n   unsigned npeel;\n \n@@ -1064,9 +1041,7 @@ decide_peel_simple (loops, loop, flags)\n    end: ;\n    */\n static void\n-peel_loop_simple (loops, loop)\n-     struct loops *loops;\n-     struct loop *loop;\n+peel_loop_simple (struct loops *loops, struct loop *loop)\n {\n   sbitmap wont_exit;\n   unsigned npeel = loop->lpt_decision.times;\n@@ -1078,7 +1053,7 @@ peel_loop_simple (loops, loop)\n \t\tloops, npeel, wont_exit, NULL, NULL, NULL,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n     abort ();\n-  \n+\n   free (wont_exit);\n \n   if (rtl_dump_file)\n@@ -1087,10 +1062,7 @@ peel_loop_simple (loops, loop)\n \n /* Decide whether to unroll LOOP stupidly and how much.  */\n static void\n-decide_unroll_stupid (loops, loop, flags)\n-     struct loops *loops;\n-     struct loop *loop;\n-     int flags;\n+decide_unroll_stupid (struct loops *loops, struct loop *loop, int flags)\n {\n   unsigned nunroll, nunroll_by_av, i;\n \n@@ -1179,9 +1151,7 @@ decide_unroll_stupid (loops, loop, flags)\n      }\n    */\n static void\n-unroll_loop_stupid (loops, loop)\n-     struct loops *loops;\n-     struct loop *loop;\n+unroll_loop_stupid (struct loops *loops, struct loop *loop)\n {\n   sbitmap wont_exit;\n   unsigned nunroll = loop->lpt_decision.times;\n@@ -1195,7 +1165,7 @@ unroll_loop_stupid (loops, loop)\n     abort ();\n \n   free (wont_exit);\n-  \n+\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \";; Unrolled loop %d times, %i insns\\n\",\n \t     nunroll, num_loop_insns (loop));"}, {"sha": "b7c7f270385280b9ca1c34d27521c2303d070223", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Loop unswitching for GNU compiler.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -78,25 +78,23 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   containing subloops would not be very large compared to complications\n   with handling this case.  */\n \n-static struct loop *unswitch_loop\tPARAMS ((struct loops *,\n-\t\t\t\t\t\tstruct loop *, basic_block));\n-static void unswitch_single_loop\tPARAMS ((struct loops *, struct loop *,\n-\t\t\t\t\t\trtx, int));\n-static bool may_unswitch_on_p\t\tPARAMS ((struct loops *, basic_block,\n-\t\t\t\t\t\tstruct loop *, basic_block *));\n-static rtx reversed_condition\t\tPARAMS ((rtx));\n+static struct loop *unswitch_loop (struct loops *, struct loop *,\n+\t\t\t\t   basic_block);\n+static void unswitch_single_loop (struct loops *, struct loop *, rtx, int);\n+static bool may_unswitch_on_p (struct loops *, basic_block, struct loop *,\n+\t\t\t       basic_block *);\n+static rtx reversed_condition (rtx);\n \n /* Main entry point.  Perform loop unswitching on all suitable LOOPS.  */\n void\n-unswitch_loops (loops)\n-     struct loops *loops;\n+unswitch_loops (struct loops *loops)\n {\n   int i, num;\n   struct loop *loop;\n \n   /* Go through inner loops (only original ones).  */\n   num = loops->num;\n-  \n+\n   for (i = 1; i < num; i++)\n     {\n       /* Removed loop?  */\n@@ -119,11 +117,8 @@ unswitch_loops (loops)\n    basic blocks (for what it means see comments below).  List of basic blocks\n    inside LOOP is provided in BODY to save time.  */\n static bool\n-may_unswitch_on_p (loops, bb, loop, body)\n-     struct loops *loops;\n-     basic_block bb;\n-     struct loop *loop;\n-     basic_block *body;\n+may_unswitch_on_p (struct loops *loops, basic_block bb, struct loop *loop,\n+\t\t   basic_block *body)\n {\n   rtx test;\n   unsigned i;\n@@ -159,8 +154,7 @@ may_unswitch_on_p (loops, bb, loop, body)\n \n /* Reverses CONDition; returns NULL if we cannot.  */\n static rtx\n-reversed_condition (cond)\n-     rtx cond;\n+reversed_condition (rtx cond)\n {\n   enum rtx_code reversed;\n   reversed = reversed_comparison_code (cond, NULL);\n@@ -177,11 +171,8 @@ reversed_condition (cond)\n    number of unswitchings done; do not allow it to grow too much, it is too\n    easy to create example on that the code would grow exponentially.  */\n static void\n-unswitch_single_loop (loops, loop, cond_checked, num)\n-     struct loops *loops;\n-     struct loop *loop;\n-     rtx cond_checked;\n-     int num;\n+unswitch_single_loop (struct loops *loops, struct loop *loop,\n+\t\t      rtx cond_checked, int num)\n {\n   basic_block *bbs, bb;\n   struct loop *nloop;\n@@ -208,7 +199,7 @@ unswitch_single_loop (loops, loop, cond_checked, num)\n \tfprintf (rtl_dump_file, \";; Not unswitching, not innermost loop\\n\");\n       return;\n     }\n-  \n+\n   /* We must be able to duplicate loop body.  */\n   if (!can_duplicate_loop_p (loop))\n     {\n@@ -224,15 +215,15 @@ unswitch_single_loop (loops, loop, cond_checked, num)\n \tfprintf (rtl_dump_file, \";; Not unswitching, loop too big\\n\");\n       return;\n     }\n-  \n+\n   /* Do not unswitch in cold areas.  */\n   if (!maybe_hot_bb_p (loop->header))\n     {\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \";; Not unswitching, not hot area\\n\");\n       return;\n     }\n-  \n+\n   /* Nor if the loop usually does not roll.  */\n   if (expected_loop_iterations (loop) < 1)\n     {\n@@ -244,7 +235,7 @@ unswitch_single_loop (loops, loop, cond_checked, num)\n   do\n     {\n       repeat = 0;\n-    \n+\n       /* Find a bb to unswitch on.  */\n       bbs = get_loop_body (loop);\n       for (i = 0; i < loop->num_nodes; i++)\n@@ -260,7 +251,7 @@ unswitch_single_loop (loops, loop, cond_checked, num)\n       if (!(cond = get_condition (bbs[i]->end, &split_before)))\n \tabort ();\n       rcond = reversed_condition (cond);\n-      \n+\n       /* Check whether the result can be predicted.  */\n       always_true = 0;\n       always_false = 0;\n@@ -281,7 +272,7 @@ unswitch_single_loop (loops, loop, cond_checked, num)\n       if (always_true)\n \t{\n \t  /* Remove false path.  */\n- \t  for (e = bbs[i]->succ; !(e->flags & EDGE_FALLTHRU); e = e->succ_next);\n+\t  for (e = bbs[i]->succ; !(e->flags & EDGE_FALLTHRU); e = e->succ_next);\n \t  remove_path (loops, e);\n \t  free (bbs);\n \t  repeat = 1;\n@@ -295,7 +286,7 @@ unswitch_single_loop (loops, loop, cond_checked, num)\n \t  repeat = 1;\n \t}\n     } while (repeat);\n- \n+\n   /* We found the condition we can unswitch on.  */\n   conds = alloc_EXPR_LIST (0, cond, cond_checked);\n   if (rcond)\n@@ -330,10 +321,7 @@ unswitch_single_loop (loops, loop, cond_checked, num)\n    for the condition we unswitch on.  Returns NULL if impossible, new\n    loop otherwise.  */\n static struct loop *\n-unswitch_loop (loops, loop, unswitch_on)\n-     struct loops *loops;\n-     struct loop *loop;\n-     basic_block unswitch_on;\n+unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on)\n {\n   edge entry, latch_edge;\n   basic_block switch_bb, unswitch_on_alt, src;\n@@ -355,15 +343,15 @@ unswitch_loop (loops, loop, unswitch_on)\n     abort ();\n   if (!flow_bb_inside_loop_p (loop, unswitch_on->succ->succ_next->dest))\n     abort ();\n-  \n+\n   /* Will we be able to perform redirection?  */\n   if (!any_condjump_p (unswitch_on->end))\n     return NULL;\n   if (!cfg_layout_can_duplicate_bb_p (unswitch_on))\n     return NULL;\n \n   entry = loop_preheader_edge (loop);\n-  \n+\n   /* Make a copy.  */\n   src = entry->src;\n   irred_flag = entry->flags & EDGE_IRREDUCIBLE_LOOP;"}, {"sha": "b3c55170927c0eb9feb9dba1e271849617302cdb", "filename": "gcc/loop.c", "status": "modified", "additions": 321, "deletions": 606, "changes": 927, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -204,7 +204,7 @@ struct movable\n   short savings;\t\t/* Number of insns we can move for this reg,\n \t\t\t\t   including other movables that force this\n \t\t\t\t   or match this one.  */\n-  ENUM_BITFIELD(machine_mode) savemode : 8;   /* Nonzero means it is a mode for \n+  ENUM_BITFIELD(machine_mode) savemode : 8;   /* Nonzero means it is a mode for\n \t\t\t\t   a low part that we should avoid changing when\n \t\t\t\t   clearing the rest of the reg.  */\n   unsigned int cond : 1;\t/* 1 if only conditionally movable */\n@@ -236,133 +236,120 @@ FILE *loop_dump_stream;\n \n /* Forward declarations.  */\n \n-static void invalidate_loops_containing_label PARAMS ((rtx));\n-static void find_and_verify_loops PARAMS ((rtx, struct loops *));\n-static void mark_loop_jump PARAMS ((rtx, struct loop *));\n-static void prescan_loop PARAMS ((struct loop *));\n-static int reg_in_basic_block_p PARAMS ((rtx, rtx));\n-static int consec_sets_invariant_p PARAMS ((const struct loop *,\n-\t\t\t\t\t    rtx, int, rtx));\n-static int labels_in_range_p PARAMS ((rtx, int));\n-static void count_one_set PARAMS ((struct loop_regs *, rtx, rtx, rtx *));\n-static void note_addr_stored PARAMS ((rtx, rtx, void *));\n-static void note_set_pseudo_multiple_uses PARAMS ((rtx, rtx, void *));\n-static int loop_reg_used_before_p PARAMS ((const struct loop *, rtx, rtx));\n-static void scan_loop PARAMS ((struct loop*, int));\n+static void invalidate_loops_containing_label (rtx);\n+static void find_and_verify_loops (rtx, struct loops *);\n+static void mark_loop_jump (rtx, struct loop *);\n+static void prescan_loop (struct loop *);\n+static int reg_in_basic_block_p (rtx, rtx);\n+static int consec_sets_invariant_p (const struct loop *, rtx, int, rtx);\n+static int labels_in_range_p (rtx, int);\n+static void count_one_set (struct loop_regs *, rtx, rtx, rtx *);\n+static void note_addr_stored (rtx, rtx, void *);\n+static void note_set_pseudo_multiple_uses (rtx, rtx, void *);\n+static int loop_reg_used_before_p (const struct loop *, rtx, rtx);\n+static void scan_loop (struct loop*, int);\n #if 0\n-static void replace_call_address PARAMS ((rtx, rtx, rtx));\n+static void replace_call_address (rtx, rtx, rtx);\n #endif\n-static rtx skip_consec_insns PARAMS ((rtx, int));\n-static int libcall_benefit PARAMS ((rtx));\n-static void ignore_some_movables PARAMS ((struct loop_movables *));\n-static void force_movables PARAMS ((struct loop_movables *));\n-static void combine_movables PARAMS ((struct loop_movables *,\n-\t\t\t\t      struct loop_regs *));\n-static int num_unmoved_movables PARAMS ((const struct loop *));\n-static int regs_match_p PARAMS ((rtx, rtx, struct loop_movables *));\n-static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct loop_movables *,\n-\t\t\t\t\t struct loop_regs *));\n-static void add_label_notes PARAMS ((rtx, rtx));\n-static void move_movables PARAMS ((struct loop *loop, struct loop_movables *,\n-\t\t\t\t   int, int));\n-static void loop_movables_add PARAMS((struct loop_movables *,\n-\t\t\t\t      struct movable *));\n-static void loop_movables_free PARAMS((struct loop_movables *));\n-static int count_nonfixed_reads PARAMS ((const struct loop *, rtx));\n-static void loop_bivs_find PARAMS((struct loop *));\n-static void loop_bivs_init_find PARAMS((struct loop *));\n-static void loop_bivs_check PARAMS((struct loop *));\n-static void loop_givs_find PARAMS((struct loop *));\n-static void loop_givs_check PARAMS((struct loop *));\n-static int loop_biv_eliminable_p PARAMS((struct loop *, struct iv_class *,\n-\t\t\t\t\t int, int));\n-static int loop_giv_reduce_benefit PARAMS((struct loop *, struct iv_class *,\n-\t\t\t\t\t   struct induction *, rtx));\n-static void loop_givs_dead_check PARAMS((struct loop *, struct iv_class *));\n-static void loop_givs_reduce PARAMS((struct loop *, struct iv_class *));\n-static void loop_givs_rescan PARAMS((struct loop *, struct iv_class *,\n-\t\t\t\t     rtx *));\n-static void loop_ivs_free PARAMS((struct loop *));\n-static void strength_reduce PARAMS ((struct loop *, int));\n-static void find_single_use_in_loop PARAMS ((struct loop_regs *, rtx, rtx));\n-static int valid_initial_value_p PARAMS ((rtx, rtx, int, rtx));\n-static void find_mem_givs PARAMS ((const struct loop *, rtx, rtx, int, int));\n-static void record_biv PARAMS ((struct loop *, struct induction *,\n-\t\t\t\trtx, rtx, rtx, rtx, rtx *,\n-\t\t\t\tint, int));\n-static void check_final_value PARAMS ((const struct loop *,\n-\t\t\t\t       struct induction *));\n-static void loop_ivs_dump PARAMS((const struct loop *, FILE *, int));\n-static void loop_iv_class_dump PARAMS((const struct iv_class *, FILE *, int));\n-static void loop_biv_dump PARAMS((const struct induction *, FILE *, int));\n-static void loop_giv_dump PARAMS((const struct induction *, FILE *, int));\n-static void record_giv PARAMS ((const struct loop *, struct induction *,\n-\t\t\t\trtx, rtx, rtx, rtx, rtx, rtx, int,\n-\t\t\t\tenum g_types, int, int, rtx *));\n-static void update_giv_derive PARAMS ((const struct loop *, rtx));\n-static void check_ext_dependent_givs PARAMS ((struct iv_class *,\n-\t\t\t\t\t      struct loop_info *));\n-static int basic_induction_var PARAMS ((const struct loop *, rtx,\n-\t\t\t\t\tenum machine_mode, rtx, rtx,\n-\t\t\t\t\trtx *, rtx *, rtx **));\n-static rtx simplify_giv_expr PARAMS ((const struct loop *, rtx, rtx *, int *));\n-static int general_induction_var PARAMS ((const struct loop *loop, rtx, rtx *,\n-\t\t\t\t\t  rtx *, rtx *, rtx *, int, int *,\n-\t\t\t\t\t  enum machine_mode));\n-static int consec_sets_giv PARAMS ((const struct loop *, int, rtx,\n-\t\t\t\t    rtx, rtx, rtx *, rtx *, rtx *, rtx *));\n-static int check_dbra_loop PARAMS ((struct loop *, int));\n-static rtx express_from_1 PARAMS ((rtx, rtx, rtx));\n-static rtx combine_givs_p PARAMS ((struct induction *, struct induction *));\n-static int cmp_combine_givs_stats PARAMS ((const void *, const void *));\n-static void combine_givs PARAMS ((struct loop_regs *, struct iv_class *));\n-static int product_cheap_p PARAMS ((rtx, rtx));\n-static int maybe_eliminate_biv PARAMS ((const struct loop *, struct iv_class *,\n-\t\t\t\t\tint, int, int));\n-static int maybe_eliminate_biv_1 PARAMS ((const struct loop *, rtx, rtx,\n-\t\t\t\t\t  struct iv_class *, int,\n-\t\t\t\t\t  basic_block, rtx));\n-static int last_use_this_basic_block PARAMS ((rtx, rtx));\n-static void record_initial PARAMS ((rtx, rtx, void *));\n-static void update_reg_last_use PARAMS ((rtx, rtx));\n-static rtx next_insn_in_loop PARAMS ((const struct loop *, rtx));\n-static void loop_regs_scan PARAMS ((const struct loop *, int));\n-static int count_insns_in_loop PARAMS ((const struct loop *));\n-static int find_mem_in_note_1 PARAMS ((rtx *, void *));\n-static rtx find_mem_in_note PARAMS ((rtx));\n-static void load_mems PARAMS ((const struct loop *));\n-static int insert_loop_mem PARAMS ((rtx *, void *));\n-static int replace_loop_mem PARAMS ((rtx *, void *));\n-static void replace_loop_mems PARAMS ((rtx, rtx, rtx, int));\n-static int replace_loop_reg PARAMS ((rtx *, void *));\n-static void replace_loop_regs PARAMS ((rtx insn, rtx, rtx));\n-static void note_reg_stored PARAMS ((rtx, rtx, void *));\n-static void try_copy_prop PARAMS ((const struct loop *, rtx, unsigned int));\n-static void try_swap_copy_prop PARAMS ((const struct loop *, rtx,\n-\t\t\t\t\t unsigned int));\n-static rtx check_insn_for_givs PARAMS((struct loop *, rtx, int, int));\n-static rtx check_insn_for_bivs PARAMS((struct loop *, rtx, int, int));\n-static rtx gen_add_mult PARAMS ((rtx, rtx, rtx, rtx));\n-static void loop_regs_update PARAMS ((const struct loop *, rtx));\n-static int iv_add_mult_cost PARAMS ((rtx, rtx, rtx, rtx));\n-\n-static rtx loop_insn_emit_after PARAMS((const struct loop *, basic_block,\n-\t\t\t\t\trtx, rtx));\n-static rtx loop_call_insn_emit_before PARAMS((const struct loop *,\n-\t\t\t\t\t      basic_block, rtx, rtx));\n-static rtx loop_call_insn_hoist PARAMS((const struct loop *, rtx));\n-static rtx loop_insn_sink_or_swim PARAMS((const struct loop *, rtx));\n-\n-static void loop_dump_aux PARAMS ((const struct loop *, FILE *, int));\n-static void loop_delete_insns PARAMS ((rtx, rtx));\n-static HOST_WIDE_INT remove_constant_addition PARAMS ((rtx *));\n-static rtx gen_load_of_final_value PARAMS ((rtx, rtx));\n-void debug_ivs PARAMS ((const struct loop *));\n-void debug_iv_class PARAMS ((const struct iv_class *));\n-void debug_biv PARAMS ((const struct induction *));\n-void debug_giv PARAMS ((const struct induction *));\n-void debug_loop PARAMS ((const struct loop *));\n-void debug_loops PARAMS ((const struct loops *));\n+static rtx skip_consec_insns (rtx, int);\n+static int libcall_benefit (rtx);\n+static void ignore_some_movables (struct loop_movables *);\n+static void force_movables (struct loop_movables *);\n+static void combine_movables (struct loop_movables *, struct loop_regs *);\n+static int num_unmoved_movables (const struct loop *);\n+static int regs_match_p (rtx, rtx, struct loop_movables *);\n+static int rtx_equal_for_loop_p (rtx, rtx, struct loop_movables *,\n+\t\t\t\t struct loop_regs *);\n+static void add_label_notes (rtx, rtx);\n+static void move_movables (struct loop *loop, struct loop_movables *, int,\n+\t\t\t   int);\n+static void loop_movables_add (struct loop_movables *, struct movable *);\n+static void loop_movables_free (struct loop_movables *);\n+static int count_nonfixed_reads (const struct loop *, rtx);\n+static void loop_bivs_find (struct loop *);\n+static void loop_bivs_init_find (struct loop *);\n+static void loop_bivs_check (struct loop *);\n+static void loop_givs_find (struct loop *);\n+static void loop_givs_check (struct loop *);\n+static int loop_biv_eliminable_p (struct loop *, struct iv_class *, int, int);\n+static int loop_giv_reduce_benefit (struct loop *, struct iv_class *,\n+\t\t\t\t    struct induction *, rtx);\n+static void loop_givs_dead_check (struct loop *, struct iv_class *);\n+static void loop_givs_reduce (struct loop *, struct iv_class *);\n+static void loop_givs_rescan (struct loop *, struct iv_class *, rtx *);\n+static void loop_ivs_free (struct loop *);\n+static void strength_reduce (struct loop *, int);\n+static void find_single_use_in_loop (struct loop_regs *, rtx, rtx);\n+static int valid_initial_value_p (rtx, rtx, int, rtx);\n+static void find_mem_givs (const struct loop *, rtx, rtx, int, int);\n+static void record_biv (struct loop *, struct induction *, rtx, rtx, rtx,\n+\t\t\trtx, rtx *, int, int);\n+static void check_final_value (const struct loop *, struct induction *);\n+static void loop_ivs_dump (const struct loop *, FILE *, int);\n+static void loop_iv_class_dump (const struct iv_class *, FILE *, int);\n+static void loop_biv_dump (const struct induction *, FILE *, int);\n+static void loop_giv_dump (const struct induction *, FILE *, int);\n+static void record_giv (const struct loop *, struct induction *, rtx, rtx,\n+\t\t\trtx, rtx, rtx, rtx, int, enum g_types, int, int,\n+\t\t\trtx *);\n+static void update_giv_derive (const struct loop *, rtx);\n+static void check_ext_dependent_givs (struct iv_class *, struct loop_info *);\n+static int basic_induction_var (const struct loop *, rtx, enum machine_mode,\n+\t\t\t\trtx, rtx, rtx *, rtx *, rtx **);\n+static rtx simplify_giv_expr (const struct loop *, rtx, rtx *, int *);\n+static int general_induction_var (const struct loop *loop, rtx, rtx *, rtx *,\n+\t\t\t\t  rtx *, rtx *, int, int *, enum machine_mode);\n+static int consec_sets_giv (const struct loop *, int, rtx, rtx, rtx, rtx *,\n+\t\t\t    rtx *, rtx *, rtx *);\n+static int check_dbra_loop (struct loop *, int);\n+static rtx express_from_1 (rtx, rtx, rtx);\n+static rtx combine_givs_p (struct induction *, struct induction *);\n+static int cmp_combine_givs_stats (const void *, const void *);\n+static void combine_givs (struct loop_regs *, struct iv_class *);\n+static int product_cheap_p (rtx, rtx);\n+static int maybe_eliminate_biv (const struct loop *, struct iv_class *, int,\n+\t\t\t\tint, int);\n+static int maybe_eliminate_biv_1 (const struct loop *, rtx, rtx,\n+\t\t\t\t  struct iv_class *, int, basic_block, rtx);\n+static int last_use_this_basic_block (rtx, rtx);\n+static void record_initial (rtx, rtx, void *);\n+static void update_reg_last_use (rtx, rtx);\n+static rtx next_insn_in_loop (const struct loop *, rtx);\n+static void loop_regs_scan (const struct loop *, int);\n+static int count_insns_in_loop (const struct loop *);\n+static int find_mem_in_note_1 (rtx *, void *);\n+static rtx find_mem_in_note (rtx);\n+static void load_mems (const struct loop *);\n+static int insert_loop_mem (rtx *, void *);\n+static int replace_loop_mem (rtx *, void *);\n+static void replace_loop_mems (rtx, rtx, rtx, int);\n+static int replace_loop_reg (rtx *, void *);\n+static void replace_loop_regs (rtx insn, rtx, rtx);\n+static void note_reg_stored (rtx, rtx, void *);\n+static void try_copy_prop (const struct loop *, rtx, unsigned int);\n+static void try_swap_copy_prop (const struct loop *, rtx, unsigned int);\n+static rtx check_insn_for_givs (struct loop *, rtx, int, int);\n+static rtx check_insn_for_bivs (struct loop *, rtx, int, int);\n+static rtx gen_add_mult (rtx, rtx, rtx, rtx);\n+static void loop_regs_update (const struct loop *, rtx);\n+static int iv_add_mult_cost (rtx, rtx, rtx, rtx);\n+\n+static rtx loop_insn_emit_after (const struct loop *, basic_block, rtx, rtx);\n+static rtx loop_call_insn_emit_before (const struct loop *, basic_block,\n+\t\t\t\t       rtx, rtx);\n+static rtx loop_call_insn_hoist (const struct loop *, rtx);\n+static rtx loop_insn_sink_or_swim (const struct loop *, rtx);\n+\n+static void loop_dump_aux (const struct loop *, FILE *, int);\n+static void loop_delete_insns (rtx, rtx);\n+static HOST_WIDE_INT remove_constant_addition (rtx *);\n+static rtx gen_load_of_final_value (rtx, rtx);\n+void debug_ivs (const struct loop *);\n+void debug_iv_class (const struct iv_class *);\n+void debug_biv (const struct induction *);\n+void debug_giv (const struct induction *);\n+void debug_loop (const struct loop *);\n+void debug_loops (const struct loops *);\n \n typedef struct loop_replace_args\n {\n@@ -379,13 +366,12 @@ typedef struct loop_replace_args\n \n /* Indirect_jump_in_function is computed once per function.  */\n static int indirect_jump_in_function;\n-static int indirect_jump_in_function_p PARAMS ((rtx));\n+static int indirect_jump_in_function_p (rtx);\n \n-static int compute_luids PARAMS ((rtx, rtx, int));\n+static int compute_luids (rtx, rtx, int);\n \n-static int biv_elimination_giv_has_0_offset PARAMS ((struct induction *,\n-\t\t\t\t\t\t     struct induction *,\n-\t\t\t\t\t\t     rtx));\n+static int biv_elimination_giv_has_0_offset (struct induction *,\n+\t\t\t\t\t     struct induction *, rtx);\n \f\n /* Benefit penalty, if a giv is not replaceable, i.e. must emit an insn to\n    copy the value of the strength reduced giv to its original register.  */\n@@ -395,7 +381,7 @@ static int copy_cost;\n static int reg_address_cost;\n \n void\n-init_loop ()\n+init_loop (void)\n {\n   rtx reg = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n \n@@ -410,9 +396,7 @@ init_loop ()\n    Start at insn START and stop just before END.  Assign LUIDs\n    starting with PREV_LUID + 1.  Return the last assigned LUID + 1.  */\n static int\n-compute_luids (start, end, prev_luid)\n-     rtx start, end;\n-     int prev_luid;\n+compute_luids (rtx start, rtx end, int prev_luid)\n {\n   int i;\n   rtx insn;\n@@ -439,11 +423,7 @@ compute_luids (start, end, prev_luid)\n    (or 0 if none should be output).  */\n \n void\n-loop_optimize (f, dumpfile, flags)\n-     /* f is the first instruction of a chain of insns for one function */\n-     rtx f;\n-     FILE *dumpfile;\n-     int flags;\n+loop_optimize (rtx f, FILE *dumpfile, int flags)\n {\n   rtx insn;\n   int i;\n@@ -566,9 +546,7 @@ loop_optimize (f, dumpfile, flags)\n    bottom.  */\n \n static rtx\n-next_insn_in_loop (loop, insn)\n-     const struct loop *loop;\n-     rtx insn;\n+next_insn_in_loop (const struct loop *loop, rtx insn)\n {\n   insn = NEXT_INSN (insn);\n \n@@ -598,9 +576,7 @@ next_insn_in_loop (loop, insn)\n    write, then we can also mark the memory read as invariant.  */\n \n static void\n-scan_loop (loop, flags)\n-     struct loop *loop;\n-     int flags;\n+scan_loop (struct loop *loop, int flags)\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n@@ -824,7 +800,7 @@ scan_loop (loop, flags)\n \t\t   && (maybe_never\n \t\t       || loop_reg_used_before_p (loop, set, p)))\n \t\t/* It is unsafe to move the set.  However, it may be OK to\n-\t\t   move the source into a new pseudo, and substitute a \n+\t\t   move the source into a new pseudo, and substitute a\n \t\t   reg-to-reg copy for the original insn.\n \n \t\t   This code used to consider it OK to move a set of a variable\n@@ -850,7 +826,7 @@ scan_loop (loop, flags)\n \t\t - if the mode doesn't support copy operations (obviously),\n \t\t - if the source is already a reg (the motion will gain nothing),\n \t\t - if the source is a legitimate constant (likewise).  */\n-\t      else if (insert_temp \n+\t      else if (insert_temp\n \t\t       && (optimize_size\n \t\t\t   || ! can_copy_p (GET_MODE (SET_SRC (set)))\n \t\t\t   || GET_CODE (SET_SRC (set)) == REG\n@@ -1131,10 +1107,10 @@ scan_loop (loop, flags)\n      Store 0 in regs->array[I].set_in_loop for each reg I that is moved.\n \n      For machines with few registers this increases code size, so do not\n-     move moveables when optimizing for code size on such machines.  \n+     move moveables when optimizing for code size on such machines.\n      (The 18 below is the value for i386.)  */\n \n-  if (!optimize_size \n+  if (!optimize_size\n       || (reg_class_size[GENERAL_REGS] > 18 && !loop_info->has_call))\n     {\n       move_movables (loop, movables, threshold, insn_count);\n@@ -1210,9 +1186,7 @@ scan_loop (loop, flags)\n    mentioned in IN_THIS but not mentioned in NOT_IN_THIS.  */\n \n void\n-record_excess_regs (in_this, not_in_this, output)\n-     rtx in_this, not_in_this;\n-     rtx *output;\n+record_excess_regs (rtx in_this, rtx not_in_this, rtx *output)\n {\n   enum rtx_code code;\n   const char *fmt;\n@@ -1266,8 +1240,7 @@ record_excess_regs (in_this, not_in_this, output)\n    If there are one or more, return an EXPR_LIST containing all of them.  */\n \n rtx\n-libcall_other_reg (insn, equiv)\n-     rtx insn, equiv;\n+libcall_other_reg (rtx insn, rtx equiv)\n {\n   rtx note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n   rtx p = XEXP (note, 0);\n@@ -1291,8 +1264,7 @@ libcall_other_reg (insn, equiv)\n    are between INSN and the end of the basic block.  */\n \n static int\n-reg_in_basic_block_p (insn, reg)\n-     rtx insn, reg;\n+reg_in_basic_block_p (rtx insn, rtx reg)\n {\n   int regno = REGNO (reg);\n   rtx p;\n@@ -1345,8 +1317,7 @@ reg_in_basic_block_p (insn, reg)\n    value directly or can contain a library call.  */\n \n static int\n-libcall_benefit (last)\n-     rtx last;\n+libcall_benefit (rtx last)\n {\n   rtx insn;\n   int benefit = 0;\n@@ -1369,9 +1340,7 @@ libcall_benefit (last)\n /* Skip COUNT insns from INSN, counting library calls as 1 insn.  */\n \n static rtx\n-skip_consec_insns (insn, count)\n-     rtx insn;\n-     int count;\n+skip_consec_insns (rtx insn, int count)\n {\n   for (; count > 0; count--)\n     {\n@@ -1398,8 +1367,7 @@ skip_consec_insns (insn, count)\n    was made later and so appears later on the chain.  */\n \n static void\n-ignore_some_movables (movables)\n-     struct loop_movables *movables;\n+ignore_some_movables (struct loop_movables *movables)\n {\n   struct movable *m, *m1;\n \n@@ -1430,8 +1398,7 @@ ignore_some_movables (movables)\n    since the second can be moved only if the first is.  */\n \n static void\n-force_movables (movables)\n-     struct loop_movables *movables;\n+force_movables (struct loop_movables *movables)\n {\n   struct movable *m, *m1;\n \n@@ -1470,9 +1437,7 @@ force_movables (movables)\n    one register.  */\n \n static void\n-combine_movables (movables, regs)\n-     struct loop_movables *movables;\n-     struct loop_regs *regs;\n+combine_movables (struct loop_movables *movables, struct loop_regs *regs)\n {\n   struct movable *m;\n   char *matched_regs = (char *) xmalloc (regs->num);\n@@ -1597,8 +1562,7 @@ combine_movables (movables, regs)\n    moved outside the loop.  */\n \n static int\n-num_unmoved_movables (loop)\n-     const struct loop *loop;\n+num_unmoved_movables (const struct loop *loop)\n {\n   int num = 0;\n   struct movable *m;\n@@ -1614,9 +1578,7 @@ num_unmoved_movables (loop)\n /* Return 1 if regs X and Y will become the same if moved.  */\n \n static int\n-regs_match_p (x, y, movables)\n-     rtx x, y;\n-     struct loop_movables *movables;\n+regs_match_p (rtx x, rtx y, struct loop_movables *movables)\n {\n   unsigned int xn = REGNO (x);\n   unsigned int yn = REGNO (y);\n@@ -1643,10 +1605,8 @@ regs_match_p (x, y, movables)\n    equivalent constant, consider them equal.  */\n \n static int\n-rtx_equal_for_loop_p (x, y, movables, regs)\n-     rtx x, y;\n-     struct loop_movables *movables;\n-     struct loop_regs *regs;\n+rtx_equal_for_loop_p (rtx x, rtx y, struct loop_movables *movables,\n+\t\t      struct loop_regs *regs)\n {\n   int i;\n   int j;\n@@ -1762,9 +1722,7 @@ rtx_equal_for_loop_p (x, y, movables, regs)\n    references is incremented once for each added note.  */\n \n static void\n-add_label_notes (x, insns)\n-     rtx x;\n-     rtx insns;\n+add_label_notes (rtx x, rtx insns)\n {\n   enum rtx_code code = GET_CODE (x);\n   int i, j;\n@@ -1804,11 +1762,8 @@ add_label_notes (x, insns)\n    other throughout.  */\n \n static void\n-move_movables (loop, movables, threshold, insn_count)\n-     struct loop *loop;\n-     struct loop_movables *movables;\n-     int threshold;\n-     int insn_count;\n+move_movables (struct loop *loop, struct loop_movables *movables,\n+\t       int threshold, int insn_count)\n {\n   struct loop_regs *regs = LOOP_REGS (loop);\n   int nregs = regs->num;\n@@ -1984,15 +1939,15 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t  /* Replace the original insn with a move from\n \t\t\t     our newly created temp.  */\n \t\t\t  start_sequence ();\n-    \t\t\t  emit_move_insn (m->set_dest, newreg);\n+\t\t\t  emit_move_insn (m->set_dest, newreg);\n \t\t\t  seq = get_insns ();\n \t\t\t  end_sequence ();\n \t\t\t  emit_insn_before (seq, p);\n \t\t\t}\n \t\t    }\n \n \t\t  start_sequence ();\n-\t\t  emit_move_insn (m->insert_temp ? newreg : m->set_dest, \n+\t\t  emit_move_insn (m->insert_temp ? newreg : m->set_dest,\n \t\t\t          m->set_src);\n \t\t  seq = get_insns ();\n \t\t  end_sequence ();\n@@ -2165,14 +2120,14 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t}\n \t\t      else if (m->insert_temp)\n \t\t\t{\n-\t\t\t  rtx *reg_map2 = (rtx *) xcalloc (REGNO (newreg), \n+\t\t\t  rtx *reg_map2 = (rtx *) xcalloc (REGNO (newreg),\n \t\t\t\tsizeof(rtx));\n \t\t\t  reg_map2 [m->regno] = newreg;\n \n \t\t\t  i1 = loop_insn_hoist (loop, copy_rtx (PATTERN (p)));\n \t\t\t  replace_regs (i1, reg_map2, REGNO (newreg), 1);\n \t\t\t  free (reg_map2);\n-\t    \t\t}\n+\t\t\t}\n \t\t      else\n \t\t\ti1 = loop_insn_hoist (loop, PATTERN (p));\n \n@@ -2228,7 +2183,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t  /* Replace the original insn with a move from\n \t\t\t     our newly created temp.  */\n \t\t\t  start_sequence ();\n-    \t\t\t  emit_move_insn (m->set_dest, newreg);\n+\t\t\t  emit_move_insn (m->set_dest, newreg);\n \t\t\t  seq = get_insns ();\n \t\t\t  end_sequence ();\n \t\t\t  emit_insn_before (seq, p);\n@@ -2355,9 +2310,7 @@ move_movables (loop, movables, threshold, insn_count)\n \n \n static void\n-loop_movables_add (movables, m)\n-     struct loop_movables *movables;\n-     struct movable *m;\n+loop_movables_add (struct loop_movables *movables, struct movable *m)\n {\n   if (movables->head == 0)\n     movables->head = m;\n@@ -2368,8 +2321,7 @@ loop_movables_add (movables, m)\n \n \n static void\n-loop_movables_free (movables)\n-     struct loop_movables *movables;\n+loop_movables_free (struct loop_movables *movables)\n {\n   struct movable *m;\n   struct movable *m_next;\n@@ -2386,8 +2338,7 @@ loop_movables_free (movables)\n    REG is the address that MEM should have before the replacement.  */\n \n static void\n-replace_call_address (x, reg, addr)\n-     rtx x, reg, addr;\n+replace_call_address (rtx x, rtx reg, rtx addr)\n {\n   enum rtx_code code;\n   int i;\n@@ -2449,9 +2400,7 @@ replace_call_address (x, reg, addr)\n    in the rtx X.  */\n \n static int\n-count_nonfixed_reads (loop, x)\n-     const struct loop *loop;\n-     rtx x;\n+count_nonfixed_reads (const struct loop *loop, rtx x)\n {\n   enum rtx_code code;\n   int i;\n@@ -2505,8 +2454,7 @@ count_nonfixed_reads (loop, x)\n    list `store_mems' in LOOP.  */\n \n static void\n-prescan_loop (loop)\n-     struct loop *loop;\n+prescan_loop (struct loop *loop)\n {\n   int level = 1;\n   rtx insn;\n@@ -2582,8 +2530,8 @@ prescan_loop (loop)\n \t     later references.  */\n \t  {\n \t    rtx fusage_entry;\n-\t    \n-\t    for (fusage_entry = CALL_INSN_FUNCTION_USAGE (insn); \n+\n+\t    for (fusage_entry = CALL_INSN_FUNCTION_USAGE (insn);\n \t\t fusage_entry; fusage_entry = XEXP (fusage_entry, 1))\n \t      {\n \t\trtx fusage = XEXP (fusage_entry, 0);\n@@ -2715,8 +2663,7 @@ prescan_loop (loop)\n /* Invalidate all loops containing LABEL.  */\n \n static void\n-invalidate_loops_containing_label (label)\n-     rtx label;\n+invalidate_loops_containing_label (rtx label)\n {\n   struct loop *loop;\n   for (loop = uid_loop[INSN_UID (label)]; loop; loop = loop->outer)\n@@ -2728,9 +2675,7 @@ invalidate_loops_containing_label (label)\n    to from outside the loop.  */\n \n static void\n-find_and_verify_loops (f, loops)\n-     rtx f;\n-     struct loops *loops;\n+find_and_verify_loops (rtx f, struct loops *loops)\n {\n   rtx insn;\n   rtx label;\n@@ -3066,9 +3011,7 @@ find_and_verify_loops (f, loops)\n    For speed, we assume that X is part of a pattern of a JUMP_INSN.  */\n \n static void\n-mark_loop_jump (x, loop)\n-     rtx x;\n-     struct loop *loop;\n+mark_loop_jump (rtx x, struct loop *loop)\n {\n   struct loop *dest_loop;\n   struct loop *outer_loop;\n@@ -3214,9 +3157,7 @@ mark_loop_jump (x, loop)\n    been previously created by loop.c).  */\n \n static int\n-labels_in_range_p (insn, end)\n-     rtx insn;\n-     int end;\n+labels_in_range_p (rtx insn, int end)\n {\n   while (insn && INSN_LUID (insn) <= end)\n     {\n@@ -3231,10 +3172,8 @@ labels_in_range_p (insn, end)\n /* Record that a memory reference X is being set.  */\n \n static void\n-note_addr_stored (x, y, data)\n-     rtx x;\n-     rtx y ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+note_addr_stored (rtx x, rtx y ATTRIBUTE_UNUSED,\n+\t\t  void *data ATTRIBUTE_UNUSED)\n {\n   struct loop_info *loop_info = data;\n \n@@ -3266,10 +3205,7 @@ note_addr_stored (x, y, data)\n    used more than once.  DATA is a pointer to a loop_regs structure.  */\n \n static void\n-note_set_pseudo_multiple_uses (x, y, data)\n-     rtx x;\n-     rtx y ATTRIBUTE_UNUSED;\n-     void *data;\n+note_set_pseudo_multiple_uses (rtx x, rtx y ATTRIBUTE_UNUSED, void *data)\n {\n   struct loop_regs *regs = (struct loop_regs *) data;\n \n@@ -3301,9 +3237,7 @@ note_set_pseudo_multiple_uses (x, y, data)\n    with anything stored in `loop_info->store_mems'.  */\n \n int\n-loop_invariant_p (loop, x)\n-     const struct loop *loop;\n-     rtx x;\n+loop_invariant_p (const struct loop *loop, rtx x)\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n@@ -3441,10 +3375,8 @@ loop_invariant_p (loop, x)\n    and that its source is invariant.  */\n \n static int\n-consec_sets_invariant_p (loop, reg, n_sets, insn)\n-     const struct loop *loop;\n-     int n_sets;\n-     rtx reg, insn;\n+consec_sets_invariant_p (const struct loop *loop, rtx reg, int n_sets,\n+\t\t\t rtx insn)\n {\n   struct loop_regs *regs = LOOP_REGS (loop);\n   rtx p = insn;\n@@ -3517,9 +3449,7 @@ consec_sets_invariant_p (loop, reg, n_sets, insn)\n    that set REG are invariant according to TABLE.  */\n \n static int\n-all_sets_invariant_p (reg, insn, table)\n-     rtx reg, insn;\n-     short *table;\n+all_sets_invariant_p (rtx reg, rtx insn, short *table)\n {\n   rtx p = insn;\n   int regno = REGNO (reg);\n@@ -3547,10 +3477,7 @@ all_sets_invariant_p (reg, insn, table)\n    a different insn, set USAGE[REGNO] to const0_rtx.  */\n \n static void\n-find_single_use_in_loop (regs, insn, x)\n-     struct loop_regs *regs;\n-     rtx insn;\n-     rtx x;\n+find_single_use_in_loop (struct loop_regs *regs, rtx insn, rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt = GET_RTX_FORMAT (code);\n@@ -3588,10 +3515,7 @@ find_single_use_in_loop (regs, insn, x)\n    in X.  */\n \n static void\n-count_one_set (regs, insn, x, last_set)\n-     struct loop_regs *regs;\n-     rtx insn, x;\n-     rtx *last_set;\n+count_one_set (struct loop_regs *regs, rtx insn, rtx x, rtx *last_set)\n {\n   if (GET_CODE (x) == CLOBBER && GET_CODE (XEXP (x, 0)) == REG)\n     /* Don't move a reg that has an explicit clobber.\n@@ -3643,9 +3567,7 @@ count_one_set (regs, insn, x, last_set)\n    from an inner loop past two loops.  */\n \n static int\n-loop_reg_used_before_p (loop, set, insn)\n-     const struct loop *loop;\n-     rtx set, insn;\n+loop_reg_used_before_p (const struct loop *loop, rtx set, rtx insn)\n {\n   rtx reg = SET_DEST (set);\n   rtx p;\n@@ -3693,16 +3615,14 @@ struct check_store_data\n   int mem_write;\n };\n \n-static void check_store PARAMS ((rtx, rtx, void *));\n-static void emit_prefetch_instructions PARAMS ((struct loop *));\n-static int rtx_equal_for_prefetch_p PARAMS ((rtx, rtx));\n+static void check_store (rtx, rtx, void *);\n+static void emit_prefetch_instructions (struct loop *);\n+static int rtx_equal_for_prefetch_p (rtx, rtx);\n \n /* Set mem_write when mem_address is found.  Used as callback to\n    note_stores.  */\n static void\n-check_store (x, pat, data)\n-     rtx x, pat ATTRIBUTE_UNUSED;\n-     void *data;\n+check_store (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n {\n   struct check_store_data *d = (struct check_store_data *) data;\n \n@@ -3718,8 +3638,7 @@ check_store (x, pat, data)\n    It can be nice to develop some common way to handle this.  */\n \n static int\n-rtx_equal_for_prefetch_p (x, y)\n-     rtx x, y;\n+rtx_equal_for_prefetch_p (rtx x, rtx y)\n {\n   int i;\n   int j;\n@@ -3801,8 +3720,7 @@ rtx_equal_for_prefetch_p (x, y)\n    and return it.  */\n \n static HOST_WIDE_INT\n-remove_constant_addition (x)\n-     rtx *x;\n+remove_constant_addition (rtx *x)\n {\n   HOST_WIDE_INT addval = 0;\n   rtx exp = *x;\n@@ -3864,8 +3782,7 @@ remove_constant_addition (x)\n    controlled by defined symbols that can be overridden for each target.  */\n \n static void\n-emit_prefetch_instructions (loop)\n-     struct loop *loop;\n+emit_prefetch_instructions (struct loop *loop)\n {\n   int num_prefetches = 0;\n   int num_real_prefetches = 0;\n@@ -4240,8 +4157,8 @@ emit_prefetch_instructions (loop)\n \t    {\n \t      rtx reg = gen_reg_rtx (Pmode);\n \t      loop_iv_add_mult_emit_before (loop, loc, const1_rtx,\n-\t\t      \t\t\t    GEN_INT (bytes_ahead), reg,\n-\t\t\t\t  \t    0, before_insn);\n+\t\t\t\t\t    GEN_INT (bytes_ahead), reg,\n+\t\t\t\t\t    0, before_insn);\n \t      loc = reg;\n \t    }\n \n@@ -4362,9 +4279,7 @@ static rtx addr_placeholder;\n    loop iteration.\n  */\n void\n-for_each_insn_in_loop (loop, fncall)\n-     struct loop *loop;\n-     loop_insn_callback fncall;\n+for_each_insn_in_loop (struct loop *loop, loop_insn_callback fncall)\n {\n   int not_every_iteration = 0;\n   int maybe_multiple = 0;\n@@ -4502,8 +4417,7 @@ for_each_insn_in_loop (loop, fncall)\n }\n \f\n static void\n-loop_bivs_find (loop)\n-     struct loop *loop;\n+loop_bivs_find (struct loop *loop)\n {\n   struct loop_regs *regs = LOOP_REGS (loop);\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n@@ -4551,8 +4465,7 @@ loop_bivs_find (loop)\n /* Determine how BIVS are initialized by looking through pre-header\n    extended basic block.  */\n static void\n-loop_bivs_init_find (loop)\n-     struct loop *loop;\n+loop_bivs_init_find (struct loop *loop)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   /* Temporary list pointers for traversing ivs->list.  */\n@@ -4607,8 +4520,7 @@ loop_bivs_init_find (loop)\n    initial value from any initializing insns set up above.  (This is done\n    in two passes to avoid missing SETs in a PARALLEL.)  */\n static void\n-loop_bivs_check (loop)\n-     struct loop *loop;\n+loop_bivs_check (struct loop *loop)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   /* Temporary list pointers for traversing ivs->list.  */\n@@ -4663,8 +4575,7 @@ loop_bivs_check (loop)\n /* Search the loop for general induction variables.  */\n \n static void\n-loop_givs_find (loop)\n-     struct loop* loop;\n+loop_givs_find (struct loop* loop)\n {\n   for_each_insn_in_loop (loop, check_insn_for_givs);\n }\n@@ -4675,8 +4586,7 @@ loop_givs_find (loop)\n    can be calculated.  */\n \n static void\n-loop_givs_check (loop)\n-     struct loop *loop;\n+loop_givs_check (struct loop *loop)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *bl;\n@@ -4698,11 +4608,8 @@ loop_givs_check (loop)\n    be.  */\n \n static int\n-loop_biv_eliminable_p (loop, bl, threshold, insn_count)\n-     struct loop *loop;\n-     struct iv_class *bl;\n-     int threshold;\n-     int insn_count;\n+loop_biv_eliminable_p (struct loop *loop, struct iv_class *bl,\n+\t\t       int threshold, int insn_count)\n {\n   /* For architectures with a decrement_and_branch_until_zero insn,\n      don't do this if we put a REG_NONNEG note on the endtest for this\n@@ -4750,9 +4657,7 @@ loop_biv_eliminable_p (loop, bl, threshold, insn_count)\n /* Reduce each giv of BL that we have decided to reduce.  */\n \n static void\n-loop_givs_reduce (loop, bl)\n-     struct loop *loop;\n-     struct iv_class *bl;\n+loop_givs_reduce (struct loop *loop, struct iv_class *bl)\n {\n   struct induction *v;\n \n@@ -4889,9 +4794,7 @@ loop_givs_reduce (loop, bl)\n    eliminate a biv.  */\n \n static void\n-loop_givs_dead_check (loop, bl)\n-     struct loop *loop ATTRIBUTE_UNUSED;\n-     struct iv_class *bl;\n+loop_givs_dead_check (struct loop *loop ATTRIBUTE_UNUSED, struct iv_class *bl)\n {\n   struct induction *v;\n \n@@ -4915,10 +4818,7 @@ loop_givs_dead_check (loop, bl)\n \n \n static void\n-loop_givs_rescan (loop, bl, reg_map)\n-     struct loop *loop;\n-     struct iv_class *bl;\n-     rtx *reg_map;\n+loop_givs_rescan (struct loop *loop, struct iv_class *bl, rtx *reg_map)\n {\n   struct induction *v;\n \n@@ -4994,13 +4894,13 @@ loop_givs_rescan (loop, bl, reg_map)\n \t\t\t\t\t  gen_move_insn (v->dest_reg,\n \t\t\t\t\t\t\t v->new_reg));\n \n- \t  /* The original insn may have a REG_EQUAL note.  This note is\n- \t     now incorrect and may result in invalid substitutions later.\n- \t     The original insn is dead, but may be part of a libcall\n- \t     sequence, which doesn't seem worth the bother of handling.  */\n- \t  note = find_reg_note (original_insn, REG_EQUAL, NULL_RTX);\n- \t  if (note)\n- \t    remove_note (original_insn, note);\n+\t  /* The original insn may have a REG_EQUAL note.  This note is\n+\t     now incorrect and may result in invalid substitutions later.\n+\t     The original insn is dead, but may be part of a libcall\n+\t     sequence, which doesn't seem worth the bother of handling.  */\n+\t  note = find_reg_note (original_insn, REG_EQUAL, NULL_RTX);\n+\t  if (note)\n+\t    remove_note (original_insn, note);\n \t}\n \n       /* When a loop is reversed, givs which depend on the reversed\n@@ -5029,11 +4929,9 @@ loop_givs_rescan (loop, bl, reg_map)\n \n \n static int\n-loop_giv_reduce_benefit (loop, bl, v, test_reg)\n-     struct loop *loop ATTRIBUTE_UNUSED;\n-     struct iv_class *bl;\n-     struct induction *v;\n-     rtx test_reg;\n+loop_giv_reduce_benefit (struct loop *loop ATTRIBUTE_UNUSED,\n+\t\t\t struct iv_class *bl, struct induction *v,\n+\t\t\t rtx test_reg)\n {\n   int add_cost;\n   int benefit;\n@@ -5106,8 +5004,7 @@ loop_giv_reduce_benefit (loop, bl, v, test_reg)\n /* Free IV structures for LOOP.  */\n \n static void\n-loop_ivs_free (loop)\n-     struct loop *loop;\n+loop_ivs_free (struct loop *loop)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *iv = ivs->list;\n@@ -5147,9 +5044,7 @@ loop_ivs_free (loop)\n    must check regnos to make sure they are in bounds.  */\n \n static void\n-strength_reduce (loop, flags)\n-     struct loop *loop;\n-     int flags;\n+strength_reduce (struct loop *loop, int flags)\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n@@ -5463,11 +5358,8 @@ strength_reduce (loop, flags)\n \f\n /*Record all basic induction variables calculated in the insn.  */\n static rtx\n-check_insn_for_bivs (loop, p, not_every_iteration, maybe_multiple)\n-     struct loop *loop;\n-     rtx p;\n-     int not_every_iteration;\n-     int maybe_multiple;\n+check_insn_for_bivs (struct loop *loop, rtx p, int not_every_iteration,\n+\t\t     int maybe_multiple)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx set;\n@@ -5511,11 +5403,8 @@ check_insn_for_bivs (loop, p, not_every_iteration, maybe_multiple)\n    A register is a giv if: it is only set once, it is a function of a\n    biv and a constant (or invariant), and it is not a biv.  */\n static rtx\n-check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n-     struct loop *loop;\n-     rtx p;\n-     int not_every_iteration;\n-     int maybe_multiple;\n+check_insn_for_givs (struct loop *loop, rtx p, int not_every_iteration,\n+\t\t     int maybe_multiple)\n {\n   struct loop_regs *regs = LOOP_REGS (loop);\n \n@@ -5600,11 +5489,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n    INSN is the insn containing X.  */\n \n static int\n-valid_initial_value_p (x, insn, call_seen, loop_start)\n-     rtx x;\n-     rtx insn;\n-     int call_seen;\n-     rtx loop_start;\n+valid_initial_value_p (rtx x, rtx insn, int call_seen, rtx loop_start)\n {\n   if (CONSTANT_P (x))\n     return 1;\n@@ -5637,11 +5522,8 @@ valid_initial_value_p (x, insn, call_seen, loop_start)\n    more than once in each loop iteration.  */\n \n static void\n-find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n-     const struct loop *loop;\n-     rtx x;\n-     rtx insn;\n-     int not_every_iteration, maybe_multiple;\n+find_mem_givs (const struct loop *loop, rtx x, rtx insn,\n+\t       int not_every_iteration, int maybe_multiple)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -5731,17 +5613,9 @@ find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n    executed exactly once per iteration.  */\n \n static void\n-record_biv (loop, v, insn, dest_reg, inc_val, mult_val, location,\n-\t    not_every_iteration, maybe_multiple)\n-     struct loop *loop;\n-     struct induction *v;\n-     rtx insn;\n-     rtx dest_reg;\n-     rtx inc_val;\n-     rtx mult_val;\n-     rtx *location;\n-     int not_every_iteration;\n-     int maybe_multiple;\n+record_biv (struct loop *loop, struct induction *v, rtx insn, rtx dest_reg,\n+\t    rtx inc_val, rtx mult_val, rtx *location,\n+\t    int not_every_iteration, int maybe_multiple)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *bl;\n@@ -5832,18 +5706,10 @@ record_biv (loop, v, insn, dest_reg, inc_val, mult_val, location,\n    LOCATION points to the place where this giv's value appears in INSN.  */\n \n static void\n-record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n-\t    benefit, type, not_every_iteration, maybe_multiple, location)\n-     const struct loop *loop;\n-     struct induction *v;\n-     rtx insn;\n-     rtx src_reg;\n-     rtx dest_reg;\n-     rtx mult_val, add_val, ext_val;\n-     int benefit;\n-     enum g_types type;\n-     int not_every_iteration, maybe_multiple;\n-     rtx *location;\n+record_giv (const struct loop *loop, struct induction *v, rtx insn,\n+\t    rtx src_reg, rtx dest_reg, rtx mult_val, rtx add_val,\n+\t    rtx ext_val, int benefit, enum g_types type,\n+\t    int not_every_iteration, int maybe_multiple, rtx *location)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct induction *b;\n@@ -6046,9 +5912,7 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n    have been identified.  */\n \n static void\n-check_final_value (loop, v)\n-     const struct loop *loop;\n-     struct induction *v;\n+check_final_value (const struct loop *loop, struct induction *v)\n {\n   rtx final_value = 0;\n \n@@ -6196,9 +6060,7 @@ check_final_value (loop, v)\n    The cases we look at are when a label or an update to a biv is passed.  */\n \n static void\n-update_giv_derive (loop, p)\n-     const struct loop *loop;\n-     rtx p;\n+update_giv_derive (const struct loop *loop, rtx p)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *bl;\n@@ -6329,15 +6191,9 @@ update_giv_derive (loop, p)\n    If we cannot find a biv, we return 0.  */\n \n static int\n-basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val, location)\n-     const struct loop *loop;\n-     rtx x;\n-     enum machine_mode mode;\n-     rtx dest_reg;\n-     rtx p;\n-     rtx *inc_val;\n-     rtx *mult_val;\n-     rtx **location;\n+basic_induction_var (const struct loop *loop, rtx x, enum machine_mode mode,\n+\t\t     rtx dest_reg, rtx p, rtx *inc_val, rtx *mult_val,\n+\t\t     rtx **location)\n {\n   enum rtx_code code;\n   rtx *argp, arg;\n@@ -6507,17 +6363,10 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val, location)\n      such that the value of X is biv * mult + add;  */\n \n static int\n-general_induction_var (loop, x, src_reg, add_val, mult_val, ext_val,\n-\t\t       is_addr, pbenefit, addr_mode)\n-     const struct loop *loop;\n-     rtx x;\n-     rtx *src_reg;\n-     rtx *add_val;\n-     rtx *mult_val;\n-     rtx *ext_val;\n-     int is_addr;\n-     int *pbenefit;\n-     enum machine_mode addr_mode;\n+general_induction_var (const struct loop *loop, rtx x, rtx *src_reg,\n+\t\t       rtx *add_val, rtx *mult_val, rtx *ext_val,\n+\t\t       int is_addr, int *pbenefit,\n+\t\t       enum machine_mode addr_mode)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx orig_x = x;\n@@ -6616,15 +6465,11 @@ general_induction_var (loop, x, src_reg, add_val, mult_val, ext_val,\n \n    *BENEFIT will be incremented by the benefit of any sub-giv encountered.  */\n \n-static rtx sge_plus PARAMS ((enum machine_mode, rtx, rtx));\n-static rtx sge_plus_constant PARAMS ((rtx, rtx));\n+static rtx sge_plus (enum machine_mode, rtx, rtx);\n+static rtx sge_plus_constant (rtx, rtx);\n \n static rtx\n-simplify_giv_expr (loop, x, ext_val, benefit)\n-     const struct loop *loop;\n-     rtx x;\n-     rtx *ext_val;\n-     int *benefit;\n+simplify_giv_expr (const struct loop *loop, rtx x, rtx *ext_val, int *benefit)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n@@ -7049,8 +6894,7 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n    CONST_INT in the summation.  It is only used by simplify_giv_expr.  */\n \n static rtx\n-sge_plus_constant (x, c)\n-     rtx x, c;\n+sge_plus_constant (rtx x, rtx c)\n {\n   if (GET_CODE (x) == CONST_INT)\n     return GEN_INT (INTVAL (x) + INTVAL (c));\n@@ -7075,9 +6919,7 @@ sge_plus_constant (x, c)\n }\n \n static rtx\n-sge_plus (mode, x, y)\n-     enum machine_mode mode;\n-     rtx x, y;\n+sge_plus (enum machine_mode mode, rtx x, rtx y)\n {\n   while (GET_CODE (y) == PLUS)\n     {\n@@ -7115,17 +6957,9 @@ sge_plus (mode, x, y)\n    *MULT_VAL and *ADD_VAL.  */\n \n static int\n-consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n-\t\t add_val, mult_val, ext_val, last_consec_insn)\n-     const struct loop *loop;\n-     int first_benefit;\n-     rtx p;\n-     rtx src_reg;\n-     rtx dest_reg;\n-     rtx *add_val;\n-     rtx *mult_val;\n-     rtx *ext_val;\n-     rtx *last_consec_insn;\n+consec_sets_giv (const struct loop *loop, int first_benefit, rtx p,\n+\t\t rtx src_reg, rtx dest_reg, rtx *add_val, rtx *mult_val,\n+\t\t rtx *ext_val, rtx *last_consec_insn)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n@@ -7231,8 +7065,7 @@ consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n    subtracting variables.  */\n \n static rtx\n-express_from_1 (a, b, mult)\n-     rtx a, b, mult;\n+express_from_1 (rtx a, rtx b, rtx mult)\n {\n   /* If MULT is zero, then A*MULT is zero, and our expression is B.  */\n \n@@ -7330,8 +7163,7 @@ express_from_1 (a, b, mult)\n }\n \n rtx\n-express_from (g1, g2)\n-     struct induction *g1, *g2;\n+express_from (struct induction *g1, struct induction *g2)\n {\n   rtx mult, add;\n \n@@ -7412,8 +7244,7 @@ express_from (g1, g2)\n    used to represent G1.  */\n \n static rtx\n-combine_givs_p (g1, g2)\n-     struct induction *g1, *g2;\n+combine_givs_p (struct induction *g1, struct induction *g2)\n {\n   rtx comb, ret;\n \n@@ -7455,9 +7286,7 @@ combine_givs_p (g1, g2)\n    make the giv illegal.  */\n \n static void\n-check_ext_dependent_givs (bl, loop_info)\n-     struct iv_class *bl;\n-     struct loop_info *loop_info;\n+check_ext_dependent_givs (struct iv_class *bl, struct loop_info *loop_info)\n {\n   int ze_ok = 0, se_ok = 0, info_ok = 0;\n   enum machine_mode biv_mode = GET_MODE (bl->biv->src_reg);\n@@ -7617,9 +7446,7 @@ check_ext_dependent_givs (bl, loop_info)\n /* Generate a version of VALUE in a mode appropriate for initializing V.  */\n \n rtx\n-extend_value_for_giv (v, value)\n-     struct induction *v;\n-     rtx value;\n+extend_value_for_giv (struct induction *v, rtx value)\n {\n   rtx ext_dep = v->ext_dependent;\n \n@@ -7644,9 +7471,7 @@ struct combine_givs_stats\n };\n \n static int\n-cmp_combine_givs_stats (xp, yp)\n-     const void *xp;\n-     const void *yp;\n+cmp_combine_givs_stats (const void *xp, const void *yp)\n {\n   const struct combine_givs_stats * const x =\n     (const struct combine_givs_stats *) xp;\n@@ -7666,9 +7491,7 @@ cmp_combine_givs_stats (xp, yp)\n    giv.  Also, update BENEFIT and related fields for cost/benefit analysis.  */\n \n static void\n-combine_givs (regs, bl)\n-     struct loop_regs *regs;\n-     struct iv_class *bl;\n+combine_givs (struct loop_regs *regs, struct iv_class *bl)\n {\n   /* Additional benefit to add for being combined multiple times.  */\n   const int extra_benefit = 3;\n@@ -7836,14 +7659,12 @@ combine_givs (regs, bl)\n   free (can_combine);\n }\n \f\n-/* Generate sequence for REG = B * M + A.  */\n+/* Generate sequence for REG = B * M + A.  B is the initial value of\n+   the basic induction variable, M a multiplicative constant, A an\n+   additive constant and REG the destination register.  */\n \n static rtx\n-gen_add_mult (b, m, a, reg)\n-     rtx b;          /* initial value of basic induction variable */\n-     rtx m;          /* multiplicative constant */\n-     rtx a;          /* additive constant */\n-     rtx reg;        /* destination register */\n+gen_add_mult (rtx b,  rtx m, rtx a, rtx reg)\n {\n   rtx seq;\n   rtx result;\n@@ -7863,9 +7684,7 @@ gen_add_mult (b, m, a, reg)\n /* Update registers created in insn sequence SEQ.  */\n \n static void\n-loop_regs_update (loop, seq)\n-     const struct loop *loop ATTRIBUTE_UNUSED;\n-     rtx seq;\n+loop_regs_update (const struct loop *loop ATTRIBUTE_UNUSED, rtx seq)\n {\n   rtx insn;\n \n@@ -7893,17 +7712,14 @@ loop_regs_update (loop, seq)\n }\n \n \n-/* EMIT code before BEFORE_BB/BEFORE_INSN to set REG = B * M + A.  */\n+/* EMIT code before BEFORE_BB/BEFORE_INSN to set REG = B * M + A.  B\n+   is the initial value of the basic induction variable, M a\n+   multiplicative constant, A an additive constant and REG the\n+   destination register.  */\n \n void\n-loop_iv_add_mult_emit_before (loop, b, m, a, reg, before_bb, before_insn)\n-     const struct loop *loop;\n-     rtx b;          /* initial value of basic induction variable */\n-     rtx m;          /* multiplicative constant */\n-     rtx a;          /* additive constant */\n-     rtx reg;        /* destination register */\n-     basic_block before_bb;\n-     rtx before_insn;\n+loop_iv_add_mult_emit_before (const struct loop *loop, rtx b, rtx m, rtx a,\n+\t\t\t      rtx reg, basic_block before_bb, rtx before_insn)\n {\n   rtx seq;\n \n@@ -7929,15 +7745,13 @@ loop_iv_add_mult_emit_before (loop, b, m, a, reg, before_bb, before_insn)\n }\n \n \n-/* Emit insns in loop pre-header to set REG = B * M + A.  */\n+/* Emit insns in loop pre-header to set REG = B * M + A.  B is the\n+   initial value of the basic induction variable, M a multiplicative\n+   constant, A an additive constant and REG the destination\n+   register.  */\n \n void\n-loop_iv_add_mult_sink (loop, b, m, a, reg)\n-     const struct loop *loop;\n-     rtx b;          /* initial value of basic induction variable */\n-     rtx m;          /* multiplicative constant */\n-     rtx a;          /* additive constant */\n-     rtx reg;        /* destination register */\n+loop_iv_add_mult_sink (const struct loop *loop, rtx b, rtx m, rtx a, rtx reg)\n {\n   rtx seq;\n \n@@ -7958,15 +7772,12 @@ loop_iv_add_mult_sink (loop, b, m, a, reg)\n }\n \n \n-/* Emit insns after loop to set REG = B * M + A.  */\n+/* Emit insns after loop to set REG = B * M + A.  B is the initial\n+   value of the basic induction variable, M a multiplicative constant,\n+   A an additive constant and REG the destination register.  */\n \n void\n-loop_iv_add_mult_hoist (loop, b, m, a, reg)\n-     const struct loop *loop;\n-     rtx b;          /* initial value of basic induction variable */\n-     rtx m;          /* multiplicative constant */\n-     rtx a;          /* additive constant */\n-     rtx reg;        /* destination register */\n+loop_iv_add_mult_hoist (const struct loop *loop, rtx b, rtx m, rtx a, rtx reg)\n {\n   rtx seq;\n \n@@ -7986,11 +7797,7 @@ loop_iv_add_mult_hoist (loop, b, m, a, reg)\n    sequence.  */\n \n static int\n-iv_add_mult_cost (b, m, a, reg)\n-     rtx b;          /* initial value of basic induction variable */\n-     rtx m;          /* multiplicative constant */\n-     rtx a;          /* additive constant */\n-     rtx reg;        /* destination register */\n+iv_add_mult_cost (rtx b, rtx m, rtx a, rtx reg)\n {\n   int cost = 0;\n   rtx last, result;\n@@ -8020,9 +7827,7 @@ iv_add_mult_cost (b, m, a, reg)\n   ??? thing, generate wasted RTL just to see if something is possible.  */\n \n static int\n-product_cheap_p (a, b)\n-     rtx a;\n-     rtx b;\n+product_cheap_p (rtx a, rtx b)\n {\n   rtx tmp;\n   int win, n_insns;\n@@ -8098,9 +7903,7 @@ product_cheap_p (a, b)\n    final_[bg]iv_value.  */\n \n static int\n-check_dbra_loop (loop, insn_count)\n-     struct loop *loop;\n-     int insn_count;\n+check_dbra_loop (struct loop *loop, int insn_count)\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n@@ -8695,11 +8498,8 @@ check_dbra_loop (loop, insn_count)\n    start of the loop.  */\n \n static int\n-maybe_eliminate_biv (loop, bl, eliminate_p, threshold, insn_count)\n-     const struct loop *loop;\n-     struct iv_class *bl;\n-     int eliminate_p;\n-     int threshold, insn_count;\n+maybe_eliminate_biv (const struct loop *loop, struct iv_class *bl,\n+\t\t     int eliminate_p, int threshold, int insn_count)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx reg = bl->biv->dest_reg;\n@@ -8772,8 +8572,7 @@ maybe_eliminate_biv (loop, bl, eliminate_p, threshold, insn_count)\n    Return nonzero if INSN is first.  */\n \n int\n-loop_insn_first_p (insn, reference)\n-     rtx insn, reference;\n+loop_insn_first_p (rtx insn, rtx reference)\n {\n   rtx p, q;\n \n@@ -8806,9 +8605,8 @@ loop_insn_first_p (insn, reference)\n    the offset that we have to take into account due to auto-increment /\n    div derivation is zero.  */\n static int\n-biv_elimination_giv_has_0_offset (biv, giv, insn)\n-     struct induction *biv, *giv;\n-     rtx insn;\n+biv_elimination_giv_has_0_offset (struct induction *biv,\n+\t\t\t\t  struct induction *giv, rtx insn)\n {\n   /* If the giv V had the auto-inc address optimization applied\n      to it, and INSN occurs between the giv insn and the biv\n@@ -8836,13 +8634,9 @@ biv_elimination_giv_has_0_offset (biv, giv, insn)\n    start of the loop (when WHERE_INSN is zero).  */\n \n static int\n-maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where_bb, where_insn)\n-     const struct loop *loop;\n-     rtx x, insn;\n-     struct iv_class *bl;\n-     int eliminate_p;\n-     basic_block where_bb;\n-     rtx where_insn;\n+maybe_eliminate_biv_1 (const struct loop *loop, rtx x, rtx insn,\n+\t\t       struct iv_class *bl, int eliminate_p,\n+\t\t       basic_block where_bb, rtx where_insn)\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx reg = bl->biv->dest_reg;\n@@ -9211,9 +9005,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where_bb, where_insn)\n    is in an insn following INSN in the same basic block.  */\n \n static int\n-last_use_this_basic_block (reg, insn)\n-     rtx reg;\n-     rtx insn;\n+last_use_this_basic_block (rtx reg, rtx insn)\n {\n   rtx n;\n   for (n = insn;\n@@ -9230,10 +9022,7 @@ last_use_this_basic_block (reg, insn)\n    just record the location of the set and process it later.  */\n \n static void\n-record_initial (dest, set, data)\n-     rtx dest;\n-     rtx set;\n-     void *data ATTRIBUTE_UNUSED;\n+record_initial (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n {\n   struct loop_ivs *ivs = (struct loop_ivs *) data;\n   struct iv_class *bl;\n@@ -9259,9 +9048,7 @@ record_initial (dest, set, data)\n    use it.  X must be a source expression only.  */\n \n static void\n-update_reg_last_use (x, insn)\n-     rtx x;\n-     rtx insn;\n+update_reg_last_use (rtx x, rtx insn)\n {\n   /* Check for the case where INSN does not have a valid luid.  In this case,\n      there is no need to modify the regno_last_uid, as this can only happen\n@@ -9314,12 +9101,8 @@ update_reg_last_use (x, insn)\n    further.  */\n \n rtx\n-canonicalize_condition (insn, cond, reverse, earliest, want_reg)\n-     rtx insn;\n-     rtx cond;\n-     int reverse;\n-     rtx *earliest;\n-     rtx want_reg;\n+canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n+\t\t\trtx want_reg)\n {\n   enum rtx_code code;\n   rtx prev = insn;\n@@ -9563,9 +9346,7 @@ canonicalize_condition (insn, cond, reverse, earliest, want_reg)\n    insn and we will be sure that the inputs are still valid.  */\n \n rtx\n-get_condition (jump, earliest)\n-     rtx jump;\n-     rtx *earliest;\n+get_condition (rtx jump, rtx *earliest)\n {\n   rtx cond;\n   int reverse;\n@@ -9592,9 +9373,7 @@ get_condition (jump, earliest)\n    unless both operands are invariants.  */\n \n rtx\n-get_condition_for_loop (loop, x)\n-     const struct loop *loop;\n-     rtx x;\n+get_condition_for_loop (const struct loop *loop, rtx x)\n {\n   rtx comparison = get_condition (x, (rtx*) 0);\n \n@@ -9612,8 +9391,7 @@ get_condition_for_loop (loop, x)\n    This is taken mostly from flow.c; similar code exists elsewhere\n    in the compiler.  It may be useful to put this into rtlanal.c.  */\n static int\n-indirect_jump_in_function_p (start)\n-     rtx start;\n+indirect_jump_in_function_p (rtx start)\n {\n   rtx insn;\n \n@@ -9629,9 +9407,7 @@ indirect_jump_in_function_p (start)\n    This function is called from prescan_loop via for_each_rtx.  */\n \n static int\n-insert_loop_mem (mem, data)\n-     rtx *mem;\n-     void *data ATTRIBUTE_UNUSED;\n+insert_loop_mem (rtx *mem, void *data ATTRIBUTE_UNUSED)\n {\n   struct loop_info *loop_info = data;\n   int i;\n@@ -9719,9 +9495,7 @@ insert_loop_mem (mem, data)\n    optimize register I.  */\n \n static void\n-loop_regs_scan (loop, extra_size)\n-     const struct loop *loop;\n-     int extra_size;\n+loop_regs_scan (const struct loop *loop, int extra_size)\n {\n   struct loop_regs *regs = LOOP_REGS (loop);\n   int old_nregs;\n@@ -9791,8 +9565,8 @@ loop_regs_scan (loop, extra_size)\n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx link;\n-\t  for (link = CALL_INSN_FUNCTION_USAGE (insn); \n-\t       link; \n+\t  for (link = CALL_INSN_FUNCTION_USAGE (insn);\n+\t       link;\n \t       link = XEXP (link, 1))\n \t    {\n \t      rtx op, reg;\n@@ -9836,8 +9610,7 @@ loop_regs_scan (loop, extra_size)\n /* Returns the number of real INSNs in the LOOP.  */\n \n static int\n-count_insns_in_loop (loop)\n-     const struct loop *loop;\n+count_insns_in_loop (const struct loop *loop)\n {\n   int count = 0;\n   rtx insn;\n@@ -9853,8 +9626,7 @@ count_insns_in_loop (loop)\n /* Move MEMs into registers for the duration of the loop.  */\n \n static void\n-load_mems (loop)\n-     const struct loop *loop;\n+load_mems (const struct loop *loop)\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n@@ -10211,9 +9983,7 @@ struct note_reg_stored_arg\n /* Called via note_stores, record in SET_SEEN whether X, which is written,\n    is equal to ARG.  */\n static void\n-note_reg_stored (x, setter, arg)\n-     rtx x, setter ATTRIBUTE_UNUSED;\n-     void *arg;\n+note_reg_stored (rtx x, rtx setter ATTRIBUTE_UNUSED, void *arg)\n {\n   struct note_reg_stored_arg *t = (struct note_reg_stored_arg *) arg;\n   if (t->reg == x)\n@@ -10226,10 +9996,7 @@ note_reg_stored (x, setter, arg)\n    is not used after the loop.  */\n \n static void\n-try_copy_prop (loop, replacement, regno)\n-     const struct loop *loop;\n-     rtx replacement;\n-     unsigned int regno;\n+try_copy_prop (const struct loop *loop, rtx replacement, unsigned int regno)\n {\n   /* This is the reg that we are copying from.  */\n   rtx reg_rtx = regno_reg_rtx[regno];\n@@ -10326,9 +10093,7 @@ try_copy_prop (loop, replacement, regno)\n    with NOTE_INSN_DELETED notes.  */\n \n static void\n-loop_delete_insns (first, last)\n-     rtx first;\n-     rtx last;\n+loop_delete_insns (rtx first, rtx last)\n {\n   while (1)\n     {\n@@ -10352,10 +10117,8 @@ loop_delete_insns (first, last)\n    this pseudo followed immediately by a move insn that sets\n    REPLACEMENT with REGNO.  */\n static void\n-try_swap_copy_prop (loop, replacement, regno)\n-     const struct loop *loop;\n-     rtx replacement;\n-     unsigned int regno;\n+try_swap_copy_prop (const struct loop *loop, rtx replacement,\n+\t\t    unsigned int regno)\n {\n   rtx insn;\n   rtx set = NULL_RTX;\n@@ -10436,9 +10199,7 @@ try_swap_copy_prop (loop, replacement, regno)\n /* Worker function for find_mem_in_note, called via for_each_rtx.  */\n \n static int\n-find_mem_in_note_1 (x, data)\n-     rtx *x;\n-     void *data;\n+find_mem_in_note_1 (rtx *x, void *data)\n {\n   if (*x != NULL_RTX && GET_CODE (*x) == MEM)\n     {\n@@ -10452,23 +10213,20 @@ find_mem_in_note_1 (x, data)\n /* Returns the first MEM found in NOTE by depth-first search.  */\n \n static rtx\n-find_mem_in_note (note)\n-     rtx note;\n+find_mem_in_note (rtx note)\n {\n   if (note && for_each_rtx (&note, find_mem_in_note_1, &note))\n     return note;\n   return NULL_RTX;\n }\n-  \n+\n /* Replace MEM with its associated pseudo register.  This function is\n    called from load_mems via for_each_rtx.  DATA is actually a pointer\n    to a structure describing the instruction currently being scanned\n    and the MEM we are currently replacing.  */\n \n static int\n-replace_loop_mem (mem, data)\n-     rtx *mem;\n-     void *data;\n+replace_loop_mem (rtx *mem, void *data)\n {\n   loop_replace_args *args = (loop_replace_args *) data;\n   rtx m = *mem;\n@@ -10502,11 +10260,7 @@ replace_loop_mem (mem, data)\n }\n \n static void\n-replace_loop_mems (insn, mem, reg, written)\n-     rtx insn;\n-     rtx mem;\n-     rtx reg;\n-     int written;\n+replace_loop_mems (rtx insn, rtx mem, rtx reg, int written)\n {\n   loop_replace_args args;\n \n@@ -10542,9 +10296,7 @@ replace_loop_mems (insn, mem, reg, written)\n    a structure of arguments.  */\n \n static int\n-replace_loop_reg (px, data)\n-     rtx *px;\n-     void *data;\n+replace_loop_reg (rtx *px, void *data)\n {\n   rtx x = *px;\n   loop_replace_args *args = (loop_replace_args *) data;\n@@ -10559,10 +10311,7 @@ replace_loop_reg (px, data)\n }\n \n static void\n-replace_loop_regs (insn, reg, replacement)\n-     rtx insn;\n-     rtx reg;\n-     rtx replacement;\n+replace_loop_regs (rtx insn, rtx reg, rtx replacement)\n {\n   loop_replace_args args;\n \n@@ -10577,11 +10326,9 @@ replace_loop_regs (insn, reg, replacement)\n    (ignored in the interim).  */\n \n static rtx\n-loop_insn_emit_after (loop, where_bb, where_insn, pattern)\n-     const struct loop *loop ATTRIBUTE_UNUSED;\n-     basic_block where_bb ATTRIBUTE_UNUSED;\n-     rtx where_insn;\n-     rtx pattern;\n+loop_insn_emit_after (const struct loop *loop ATTRIBUTE_UNUSED,\n+\t\t      basic_block where_bb ATTRIBUTE_UNUSED, rtx where_insn,\n+\t\t      rtx pattern)\n {\n   return emit_insn_after (pattern, where_insn);\n }\n@@ -10592,11 +10339,9 @@ loop_insn_emit_after (loop, where_bb, where_insn, pattern)\n    otherwise hoist PATTERN into the loop pre-header.  */\n \n rtx\n-loop_insn_emit_before (loop, where_bb, where_insn, pattern)\n-     const struct loop *loop;\n-     basic_block where_bb ATTRIBUTE_UNUSED;\n-     rtx where_insn;\n-     rtx pattern;\n+loop_insn_emit_before (const struct loop *loop,\n+\t\t       basic_block where_bb ATTRIBUTE_UNUSED,\n+\t\t       rtx where_insn, rtx pattern)\n {\n   if (! where_insn)\n     return loop_insn_hoist (loop, pattern);\n@@ -10608,11 +10353,9 @@ loop_insn_emit_before (loop, where_bb, where_insn, pattern)\n    WHERE_BB (ignored in the interim) within the loop.  */\n \n static rtx\n-loop_call_insn_emit_before (loop, where_bb, where_insn, pattern)\n-     const struct loop *loop ATTRIBUTE_UNUSED;\n-     basic_block where_bb ATTRIBUTE_UNUSED;\n-     rtx where_insn;\n-     rtx pattern;\n+loop_call_insn_emit_before (const struct loop *loop ATTRIBUTE_UNUSED,\n+\t\t\t    basic_block where_bb ATTRIBUTE_UNUSED,\n+\t\t\t    rtx where_insn, rtx pattern)\n {\n   return emit_call_insn_before (pattern, where_insn);\n }\n@@ -10621,9 +10364,7 @@ loop_call_insn_emit_before (loop, where_bb, where_insn, pattern)\n /* Hoist insn for PATTERN into the loop pre-header.  */\n \n rtx\n-loop_insn_hoist (loop, pattern)\n-     const struct loop *loop;\n-     rtx pattern;\n+loop_insn_hoist (const struct loop *loop, rtx pattern)\n {\n   return loop_insn_emit_before (loop, 0, loop->start, pattern);\n }\n@@ -10632,9 +10373,7 @@ loop_insn_hoist (loop, pattern)\n /* Hoist call insn for PATTERN into the loop pre-header.  */\n \n static rtx\n-loop_call_insn_hoist (loop, pattern)\n-     const struct loop *loop;\n-     rtx pattern;\n+loop_call_insn_hoist (const struct loop *loop, rtx pattern)\n {\n   return loop_call_insn_emit_before (loop, 0, loop->start, pattern);\n }\n@@ -10643,18 +10382,15 @@ loop_call_insn_hoist (loop, pattern)\n /* Sink insn for PATTERN after the loop end.  */\n \n rtx\n-loop_insn_sink (loop, pattern)\n-     const struct loop *loop;\n-     rtx pattern;\n+loop_insn_sink (const struct loop *loop, rtx pattern)\n {\n   return loop_insn_emit_before (loop, 0, loop->sink, pattern);\n }\n \n /* bl->final_value can be either general_operand or PLUS of general_operand\n    and constant.  Emit sequence of instructions to load it into REG.  */\n static rtx\n-gen_load_of_final_value (reg, final_value)\n-     rtx reg, final_value;\n+gen_load_of_final_value (rtx reg, rtx final_value)\n {\n   rtx seq;\n   start_sequence ();\n@@ -10672,9 +10408,7 @@ gen_load_of_final_value (reg, final_value)\n    since this is slightly more efficient.  */\n \n static rtx\n-loop_insn_sink_or_swim (loop, pattern)\n-     const struct loop *loop;\n-     rtx pattern;\n+loop_insn_sink_or_swim (const struct loop *loop, rtx pattern)\n {\n   if (loop->exit_count)\n     return loop_insn_hoist (loop, pattern);\n@@ -10683,10 +10417,7 @@ loop_insn_sink_or_swim (loop, pattern)\n }\n \f\n static void\n-loop_ivs_dump (loop, file, verbose)\n-     const struct loop *loop;\n-     FILE *file;\n-     int verbose;\n+loop_ivs_dump (const struct loop *loop, FILE *file, int verbose)\n {\n   struct iv_class *bl;\n   int iv_num = 0;\n@@ -10708,10 +10439,8 @@ loop_ivs_dump (loop, file, verbose)\n \n \n static void\n-loop_iv_class_dump (bl, file, verbose)\n-     const struct iv_class *bl;\n-     FILE *file;\n-     int verbose ATTRIBUTE_UNUSED;\n+loop_iv_class_dump (const struct iv_class *bl, FILE *file,\n+\t\t    int verbose ATTRIBUTE_UNUSED)\n {\n   struct induction *v;\n   rtx incr;\n@@ -10773,10 +10502,7 @@ loop_iv_class_dump (bl, file, verbose)\n \n \n static void\n-loop_biv_dump (v, file, verbose)\n-     const struct induction *v;\n-     FILE *file;\n-     int verbose;\n+loop_biv_dump (const struct induction *v, FILE *file, int verbose)\n {\n   if (! v || ! file)\n     return;\n@@ -10799,10 +10525,7 @@ loop_biv_dump (v, file, verbose)\n \n \n static void\n-loop_giv_dump (v, file, verbose)\n-     const struct induction *v;\n-     FILE *file;\n-     int verbose;\n+loop_giv_dump (const struct induction *v, FILE *file, int verbose)\n {\n   if (! v || ! file)\n     return;\n@@ -10863,32 +10586,28 @@ loop_giv_dump (v, file, verbose)\n \n \n void\n-debug_ivs (loop)\n-     const struct loop *loop;\n+debug_ivs (const struct loop *loop)\n {\n   loop_ivs_dump (loop, stderr, 1);\n }\n \n \n void\n-debug_iv_class (bl)\n-     const struct iv_class *bl;\n+debug_iv_class (const struct iv_class *bl)\n {\n   loop_iv_class_dump (bl, stderr, 1);\n }\n \n \n void\n-debug_biv (v)\n-     const struct induction *v;\n+debug_biv (const struct induction *v)\n {\n   loop_biv_dump (v, stderr, 1);\n }\n \n \n void\n-debug_giv (v)\n-     const struct induction *v;\n+debug_giv (const struct induction *v)\n {\n   loop_giv_dump (v, stderr, 1);\n }\n@@ -10907,10 +10626,8 @@ debug_giv (v)\n #define LOOP_INSN_UID(INSN) ((INSN) ? INSN_UID (INSN) : -1)\n \n static void\n-loop_dump_aux (loop, file, verbose)\n-     const struct loop *loop;\n-     FILE *file;\n-     int verbose ATTRIBUTE_UNUSED;\n+loop_dump_aux (const struct loop *loop, FILE *file,\n+\t       int verbose ATTRIBUTE_UNUSED)\n {\n   rtx label;\n \n@@ -10974,17 +10691,15 @@ loop_dump_aux (loop, file, verbose)\n /* Call this function from the debugger to dump LOOP.  */\n \n void\n-debug_loop (loop)\n-     const struct loop *loop;\n+debug_loop (const struct loop *loop)\n {\n   flow_loop_dump (loop, stderr, loop_dump_aux, 1);\n }\n \n /* Call this function from the debugger to dump LOOPS.  */\n \n void\n-debug_loops (loops)\n-     const struct loops *loops;\n+debug_loops (const struct loops *loops)\n {\n   flow_loops_dump (loops, stderr, loop_dump_aux, 1);\n }"}, {"sha": "bd144db4c7c9c857ecd7e7341249fb2ac25e9cd0", "filename": "gcc/loop.h", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Loop optimization definitions for GCC\n-   Copyright (C) 1991, 1995, 1998, 1999, 2000, 2001, 2002\n+   Copyright (C) 1991, 1995, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -398,34 +398,31 @@ extern FILE *loop_dump_stream;\n \n /* Forward declarations for non-static functions declared in loop.c and\n    unroll.c.  */\n-int loop_invariant_p PARAMS ((const struct loop *, rtx));\n-rtx get_condition_for_loop PARAMS ((const struct loop *, rtx));\n-void loop_iv_add_mult_hoist PARAMS ((const struct loop *, rtx, rtx, rtx, rtx));\n-void loop_iv_add_mult_sink PARAMS ((const struct loop *, rtx, rtx, rtx, rtx));\n-void loop_iv_add_mult_emit_before PARAMS ((const struct loop *, rtx,\n-\t\t\t\t\t   rtx, rtx, rtx,\n-\t\t\t\t\t   basic_block, rtx));\n-rtx express_from PARAMS ((struct induction *, struct induction *));\n-rtx extend_value_for_giv PARAMS ((struct induction *, rtx));\n-\n-void unroll_loop PARAMS ((struct loop *, int, int));\n-rtx biv_total_increment PARAMS ((const struct iv_class *));\n-unsigned HOST_WIDE_INT loop_iterations PARAMS ((struct loop *));\n-int precondition_loop_p PARAMS ((const struct loop *,\n-\t\t\t\t rtx *, rtx *, rtx *,\n-\t\t\t\t enum machine_mode *mode));\n-rtx final_biv_value PARAMS ((const struct loop *, struct iv_class *));\n-rtx final_giv_value PARAMS ((const struct loop *, struct induction *));\n-void emit_unrolled_add PARAMS ((rtx, rtx, rtx));\n-int back_branch_in_range_p PARAMS ((const struct loop *, rtx));\n-\n-int loop_insn_first_p PARAMS ((rtx, rtx));\n-typedef rtx (*loop_insn_callback) PARAMS ((struct loop *, rtx, int, int));\n-void for_each_insn_in_loop PARAMS ((struct loop *, loop_insn_callback));\n-rtx loop_insn_emit_before PARAMS((const struct loop *, basic_block,\n-\t\t\t\t  rtx, rtx));\n-rtx loop_insn_sink PARAMS((const struct loop *, rtx));\n-rtx loop_insn_hoist PARAMS((const struct loop *, rtx));\n+extern int loop_invariant_p (const struct loop *, rtx);\n+extern rtx get_condition_for_loop (const struct loop *, rtx);\n+extern void loop_iv_add_mult_hoist (const struct loop *, rtx, rtx, rtx, rtx);\n+extern void loop_iv_add_mult_sink (const struct loop *, rtx, rtx, rtx, rtx);\n+extern void loop_iv_add_mult_emit_before (const struct loop *, rtx, rtx,\n+\t\t\t\t\t  rtx, rtx, basic_block, rtx);\n+extern rtx express_from (struct induction *, struct induction *);\n+extern rtx extend_value_for_giv (struct induction *, rtx);\n+\n+extern void unroll_loop (struct loop *, int, int);\n+extern rtx biv_total_increment (const struct iv_class *);\n+extern unsigned HOST_WIDE_INT loop_iterations (struct loop *);\n+extern int precondition_loop_p (const struct loop *, rtx *, rtx *, rtx *,\n+\t\t\t\tenum machine_mode *mode);\n+extern rtx final_biv_value (const struct loop *, struct iv_class *);\n+extern rtx final_giv_value (const struct loop *, struct induction *);\n+extern void emit_unrolled_add (rtx, rtx, rtx);\n+extern int back_branch_in_range_p (const struct loop *, rtx);\n+\n+extern int loop_insn_first_p (rtx, rtx);\n+typedef rtx (*loop_insn_callback) (struct loop *, rtx, int, int);\n+extern void for_each_insn_in_loop (struct loop *, loop_insn_callback);\n+extern rtx loop_insn_emit_before (const struct loop *, basic_block, rtx, rtx);\n+extern rtx loop_insn_sink (const struct loop *, rtx);\n+extern rtx loop_insn_hoist (const struct loop *, rtx);\n \n /* Forward declarations for non-static functions declared in doloop.c.  */\n-int doloop_optimize PARAMS ((const struct loop *));\n+extern int doloop_optimize (const struct loop *);"}, {"sha": "fbb48505e86005445ec57dccbb0a179a251e309e", "filename": "gcc/machmode.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Machine mode definitions for GCC; included by rtl.h and tree.h.\n-   Copyright (C) 1991, 1993, 1994, 1996, 1998, 1999, 2000, 2001\n+   Copyright (C) 1991, 1993, 1994, 1996, 1998, 1999, 2000, 2001, 2003\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -136,28 +136,27 @@ extern const unsigned char mode_wider_mode[NUM_MACHINE_MODES];\n    If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n    The value is BLKmode if no other mode is found.  */\n \n-extern enum machine_mode mode_for_size PARAMS ((unsigned int,\n-\t\t\t\t\t\tenum mode_class, int));\n+extern enum machine_mode mode_for_size (unsigned int, enum mode_class, int);\n \n /* Similar, but find the smallest mode for a given width.  */\n \n-extern enum machine_mode smallest_mode_for_size \n-\t\t\t\tPARAMS ((unsigned int, enum mode_class));\n+extern enum machine_mode smallest_mode_for_size (unsigned int,\n+\t\t\t\t\t\t enum mode_class);\n \n \n /* Return an integer mode of the exact same size as the input mode,\n    or BLKmode on failure.  */\n \n-extern enum machine_mode int_mode_for_mode PARAMS ((enum machine_mode));\n+extern enum machine_mode int_mode_for_mode (enum machine_mode);\n \n /* Find the best mode to use to access a bit field.  */\n \n-extern enum machine_mode get_best_mode PARAMS ((int, int, unsigned int,\n-\t\t\t\t\t\tenum machine_mode, int));\n+extern enum machine_mode get_best_mode (int, int, unsigned int,\n+\t\t\t\t\tenum machine_mode, int);\n \n /* Determine alignment, 1<=result<=BIGGEST_ALIGNMENT.  */\n \n-extern unsigned get_mode_alignment PARAMS ((enum machine_mode));\n+extern unsigned get_mode_alignment (enum machine_mode);\n \n #define GET_MODE_ALIGNMENT(MODE) get_mode_alignment (MODE)\n "}, {"sha": "16a936e58b7e994acfaa9c7bbab4aea6b9163aff", "filename": "gcc/main.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmain.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -23,16 +23,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm.h\"\n #include \"toplev.h\"\n \n-int main PARAMS ((int argc, char **argv));\n+int main (int argc, char **argv);\n \n /* We define main() to call toplev_main(), which is defined in toplev.c.\n    We do this in a separate file in order to allow the language front-end\n    to define a different main(), if it so desires.  */\n \n int\n-main (argc, argv)\n-  int argc;\n-  char **argv;\n+main (int argc, char **argv)\n {\n   return toplev_main (argc, (const char **) argv);\n }"}, {"sha": "81b87540a2caa101a2f096004256e26c9c8d655c", "filename": "gcc/mbchar.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fmbchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fmbchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmbchar.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Multibyte Character Functions.\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -41,7 +41,7 @@ typedef enum {ESCAPE, DOLLAR, BRACKET, AT, B, J, NUL, JIS_CHAR, OTHER,\n \t      JIS_C_NUM} JIS_CHAR_TYPE;\n \n typedef enum {ASCII, A_ESC, A_ESC_DL, JIS, JIS_1, JIS_2, J_ESC, J_ESC_BR,\n-\t     J2_ESC, J2_ESC_BR, INV, JIS_S_NUM} JIS_STATE; \n+\t     J2_ESC, J2_ESC_BR, INV, JIS_S_NUM} JIS_STATE;\n \n typedef enum {COPYA, COPYJ, COPYJ2, MAKE_A, MAKE_J, NOOP,\n \t      EMPTY, ERROR} JIS_ACTION;\n@@ -94,10 +94,7 @@ const char *literal_codeset = NULL;\n    it treats locale names of the form \"C-...\" specially.  */\n \n int\n-local_mbtowc (pwc, s, n)\n-     wchar_t *pwc;\n-     const char *s;\n-     size_t n;\n+local_mbtowc (wchar_t *pwc, const char *s, size_t n)\n {\n   static JIS_STATE save_state = ASCII;\n   JIS_STATE curr_state = save_state;\n@@ -153,7 +150,7 @@ local_mbtowc (pwc, s, n)\n       char1 = *t;\n       if (ISEUCJP (char1))\n         {\n-          int char2 = t[1];     \n+          int char2 = t[1];\n \n           if (n <= 1)\n             return -1;\n@@ -182,7 +179,7 @@ local_mbtowc (pwc, s, n)\n       JIS_CHAR_TYPE ch;\n       const unsigned char *ptr;\n       size_t i, curr_ch;\n- \n+\n       if (s == NULL)\n \t{\n \t  save_state = ASCII;\n@@ -227,7 +224,7 @@ local_mbtowc (pwc, s, n)\n \n           action = JIS_action_table[curr_state][ch];\n           curr_state = JIS_state_table[curr_state][ch];\n-        \n+\n           switch (action)\n             {\n             case NOOP:\n@@ -272,9 +269,9 @@ local_mbtowc (pwc, s, n)\n         }\n \n       /* More than n bytes needed.  */\n-      return -1;  \n+      return -1;\n     }\n-               \n+\n #ifdef CROSS_COMPILE\n   if (s == NULL)\n     /* Not state-dependent.  */\n@@ -298,9 +295,7 @@ local_mbtowc (pwc, s, n)\n    it treats locale names of the form \"C-...\" specially.  */\n \n int\n-local_mblen (s, n)\n-     const char *s;\n-     size_t n;\n+local_mblen (const char *s, size_t n)\n {\n   return local_mbtowc (NULL, s, n);\n }\n@@ -311,7 +306,7 @@ local_mblen (s, n)\n    except it treats locale names of the form \"C-...\" specially.  */\n \n int\n-local_mb_cur_max ()\n+local_mb_cur_max (void)\n {\n   if (literal_codeset == NULL || strlen (literal_codeset) <= 1)\n     ;"}, {"sha": "3846a8cfbbdb933346aa68cb62ab2a6f196b5b0d", "filename": "gcc/mbchar.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fmbchar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fmbchar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmbchar.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Various declarations for functions found in mbchar.c\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -31,9 +31,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define ISEUCJP(c)   ((c) >= 0xa1 && (c) <= 0xfe)\n #define ISJIS(c)     ((c) >= 0x21 && (c) <= 0x7e)\n \n-extern int local_mbtowc     PARAMS ((wchar_t *, const char *, size_t));\n-extern int local_mblen      PARAMS ((const char *, size_t));\n-extern int local_mb_cur_max PARAMS ((void));\n+extern int local_mbtowc (wchar_t *, const char *, size_t);\n+extern int local_mblen (const char *, size_t);\n+extern int local_mb_cur_max (void);\n \n /* The locale being used for multibyte characters in string/char literals.  */\n extern const char *literal_codeset;"}, {"sha": "71aab3d9fc55ee32bcf425a611f1a57d0d849a0d", "filename": "gcc/mkdeps.c", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fmkdeps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fmkdeps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmkdeps.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Dependency generator for Makefile fragments.\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n    Contributed by Zack Weinberg, Mar 2000\n \n This program is free software; you can redistribute it and/or modify it\n@@ -39,18 +39,17 @@ struct deps\n   unsigned int deps_size;\n };\n \n-static const char *munge\tPARAMS ((const char *));\n+static const char *munge (const char *);\n \n /* Given a filename, quote characters in that filename which are\n    significant to Make.  Note that it's not possible to quote all such\n    characters - e.g. \\n, %, *, ?, [, \\ (in some contexts), and ~ are\n    not properly handled.  It isn't possible to get this right in any\n    current version of Make.  (??? Still true?  Old comment referred to\n    3.76.1.)  */\n-   \n+\n static const char *\n-munge (filename)\n-     const char *filename;\n+munge (const char *filename)\n {\n   int len;\n   const char *p, *q;\n@@ -111,7 +110,7 @@ munge (filename)\n /* Public routines.  */\n \n struct deps *\n-deps_init ()\n+deps_init (void)\n {\n   struct deps *d = (struct deps *) xmalloc (sizeof (struct deps));\n \n@@ -129,8 +128,7 @@ deps_init ()\n }\n \n void\n-deps_free (d)\n-     struct deps *d;\n+deps_free (struct deps *d)\n {\n   unsigned int i;\n \n@@ -154,10 +152,7 @@ deps_free (d)\n /* Adds a target T.  We make a copy, so it need not be a permanent\n    string.  QUOTE is true if the string should be quoted.  */\n void\n-deps_add_target (d, t, quote)\n-     struct deps *d;\n-     const char *t;\n-     int quote;\n+deps_add_target (struct deps *d, const char *t, int quote)\n {\n   if (d->ntargets == d->targets_size)\n     {\n@@ -178,9 +173,7 @@ deps_add_target (d, t, quote)\n    string as the default target in interpreted as stdin.  The string\n    is quoted for MAKE.  */\n void\n-deps_add_default_target (d, tgt)\n-     struct deps *d;\n-     const char *tgt;\n+deps_add_default_target (struct deps *d, const char *tgt)\n {\n   /* Only if we have no targets.  */\n   if (d->ntargets)\n@@ -198,20 +191,18 @@ deps_add_default_target (d, tgt)\n       char *suffix;\n \n       strcpy (o, start);\n-      \n+\n       suffix = strrchr (o, '.');\n       if (!suffix)\n         suffix = o + strlen (o);\n       strcpy (suffix, TARGET_OBJECT_SUFFIX);\n-      \n+\n       deps_add_target (d, o, 1);\n     }\n }\n \n void\n-deps_add_dep (d, t)\n-     struct deps *d;\n-     const char *t;\n+deps_add_dep (struct deps *d, const char *t)\n {\n   t = munge (t);  /* Also makes permanent copy.  */\n \n@@ -225,10 +216,7 @@ deps_add_dep (d, t)\n }\n \n void\n-deps_write (d, fp, colmax)\n-     const struct deps *d;\n-     FILE *fp;\n-     unsigned int colmax;\n+deps_write (const struct deps *d, FILE *fp, unsigned int colmax)\n {\n   unsigned int size, i, column;\n \n@@ -275,11 +263,9 @@ deps_write (d, fp, colmax)\n     }\n   putc ('\\n', fp);\n }\n-  \n+\n void\n-deps_phony_targets (d, fp)\n-     const struct deps *d;\n-     FILE *fp;\n+deps_phony_targets (const struct deps *d, FILE *fp)\n {\n   unsigned int i;\n \n@@ -297,9 +283,7 @@ deps_phony_targets (d, fp)\n    error number will be in errno.  */\n \n int\n-deps_save (deps, f)\n-     struct deps *deps;\n-     FILE *f;\n+deps_save (struct deps *deps, FILE *f)\n {\n   unsigned int i;\n \n@@ -328,10 +312,7 @@ deps_save (deps, f)\n    in which case that filename is skipped.  */\n \n int\n-deps_restore (deps, fd, self)\n-     struct deps *deps;\n-     FILE *fd;\n-     const char *self;\n+deps_restore (struct deps *deps, FILE *fd, const char *self)\n {\n   unsigned int i, count;\n   size_t num_to_read;\n@@ -357,7 +338,7 @@ deps_restore (deps, fd, self)\n \treturn -1;\n       buf[num_to_read] = '\\0';\n \n-      /* Generate makefile dependencies from .pch if -nopch-deps.  */ \n+      /* Generate makefile dependencies from .pch if -nopch-deps.  */\n       if (self != NULL && strcmp (buf, self) != 0)\n         deps_add_dep (deps, buf);\n     }"}, {"sha": "745ba1f504185e954023954378f2afcefc704892", "filename": "gcc/mkdeps.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fmkdeps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fmkdeps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmkdeps.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Dependency generator for Makefile fragments.\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n    Contributed by Zack Weinberg, Mar 2000\n \n This program is free software; you can redistribute it and/or modify it\n@@ -29,45 +29,44 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n struct deps;\n \n /* Create a deps buffer.  */\n-extern struct deps *deps_init\tPARAMS ((void));\n+extern struct deps *deps_init (void);\n \n /* Destroy a deps buffer.  */\n-extern void deps_free\t\tPARAMS ((struct deps *));\n+extern void deps_free (struct deps *);\n \n /* Add a target (appears on left side of the colon) to the deps list.  Takes\n    a boolean indicating whether to quote the target for MAKE.  */\n-extern void deps_add_target\tPARAMS ((struct deps *, const char *, int));\n+extern void deps_add_target (struct deps *, const char *, int);\n \n /* Sets the default target if none has been given already.  An empty\n    string as the default target is interpreted as stdin.  */\n-extern void deps_add_default_target PARAMS ((struct deps *, const char *));\n+extern void deps_add_default_target (struct deps *, const char *);\n \n /* Add a dependency (appears on the right side of the colon) to the\n    deps list.  Dependencies will be printed in the order that they\n    were entered with this function.  By convention, the first\n    dependency entered should be the primary source file.  */\n-extern void deps_add_dep\tPARAMS ((struct deps *, const char *));\n+extern void deps_add_dep (struct deps *, const char *);\n \n /* Write out a deps buffer to a specified file.  The third argument\n    is the number of columns to word-wrap at (0 means don't wrap).  */\n-extern void deps_write\t\tPARAMS ((const struct deps *, FILE *,\n-\t\t\t\t\t unsigned int));\n+extern void deps_write (const struct deps *, FILE *, unsigned int);\n \n /* Write out a deps buffer to a file, in a form that can be read back\n    with deps_restore.  Returns nonzero on error, in which case the\n    error number will be in errno.  */\n-extern int deps_save\t\tPARAMS ((struct deps *, FILE *));\n+extern int deps_save (struct deps *, FILE *);\n \n /* Read back dependency information written with deps_save into\n    the deps buffer.  The third argument may be NULL, in which case\n    the dependency information is just skipped, or it may be a filename,\n    in which case that filename is skipped.  */\n-extern int deps_restore\t\tPARAMS ((struct deps *, FILE *, const char *));\n+extern int deps_restore (struct deps *, FILE *, const char *);\n \n /* For each dependency *except the first*, emit a dummy rule for that\n    file, causing it to depend on nothing.  This is used to work around\n    the intermediate-file deletion misfeature in Make, in some\n    automatic dependency schemes.  */\n-extern void deps_phony_targets\tPARAMS ((const struct deps *, FILE *));\n+extern void deps_phony_targets (const struct deps *, FILE *);\n \n #endif /* ! GCC_MKDEPS_H */"}, {"sha": "b4023e3eff4a99bf6bbf53fb381063078b4de431", "filename": "gcc/optabs.c", "status": "modified", "additions": 179, "deletions": 334, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -93,43 +93,38 @@ enum insn_code movcc_gen_code[NUM_MACHINE_MODES];\n    the code to be used in the trap insn and all other fields are ignored.  */\n static GTY(()) rtx trap_rtx;\n \n-static int add_equal_note\tPARAMS ((rtx, rtx, enum rtx_code, rtx, rtx));\n-static rtx widen_operand\tPARAMS ((rtx, enum machine_mode,\n-\t\t\t\t       enum machine_mode, int, int));\n-static int expand_cmplxdiv_straight PARAMS ((rtx, rtx, rtx, rtx,\n-\t\t\t\t\t   rtx, rtx, enum machine_mode,\n-\t\t\t\t\t   int, enum optab_methods,\n-\t\t\t\t\t   enum mode_class, optab));\n-static int expand_cmplxdiv_wide PARAMS ((rtx, rtx, rtx, rtx,\n-\t\t\t\t       rtx, rtx, enum machine_mode,\n-\t\t\t\t       int, enum optab_methods,\n-\t\t\t\t       enum mode_class, optab));\n-static void prepare_cmp_insn PARAMS ((rtx *, rtx *, enum rtx_code *, rtx,\n-\t\t\t\t      enum machine_mode *, int *,\n-\t\t\t\t      enum can_compare_purpose));\n-static enum insn_code can_fix_p\tPARAMS ((enum machine_mode, enum machine_mode,\n-\t\t\t\t       int, int *));\n-static enum insn_code can_float_p PARAMS ((enum machine_mode,\n-\t\t\t\t\t   enum machine_mode,\n-\t\t\t\t\t   int));\n-static rtx ftruncify\tPARAMS ((rtx));\n-static optab new_optab\tPARAMS ((void));\n-static inline optab init_optab\tPARAMS ((enum rtx_code));\n-static inline optab init_optabv\tPARAMS ((enum rtx_code));\n-static void init_libfuncs PARAMS ((optab, int, int, const char *, int));\n-static void init_integral_libfuncs PARAMS ((optab, const char *, int));\n-static void init_floating_libfuncs PARAMS ((optab, const char *, int));\n-static void emit_cmp_and_jump_insn_1 PARAMS ((rtx, rtx, enum machine_mode,\n-\t\t\t\t\t    enum rtx_code, int, rtx));\n-static void prepare_float_lib_cmp PARAMS ((rtx *, rtx *, enum rtx_code *,\n-\t\t\t\t\t enum machine_mode *, int *));\n-static rtx expand_vector_binop PARAMS ((enum machine_mode, optab,\n-\t\t\t\t\trtx, rtx, rtx, int,\n-\t\t\t\t\tenum optab_methods));\n-static rtx expand_vector_unop PARAMS ((enum machine_mode, optab, rtx, rtx,\n-\t\t\t\t       int));\n-static rtx widen_clz PARAMS ((enum machine_mode, rtx, rtx));\n-static rtx expand_parity PARAMS ((enum machine_mode, rtx, rtx));\n+static int add_equal_note (rtx, rtx, enum rtx_code, rtx, rtx);\n+static rtx widen_operand (rtx, enum machine_mode, enum machine_mode, int,\n+\t\t\t  int);\n+static int expand_cmplxdiv_straight (rtx, rtx, rtx, rtx, rtx, rtx,\n+\t\t\t\t     enum machine_mode, int,\n+\t\t\t\t     enum optab_methods, enum mode_class,\n+\t\t\t\t     optab);\n+static int expand_cmplxdiv_wide (rtx, rtx, rtx, rtx, rtx, rtx,\n+\t\t\t\t enum machine_mode, int, enum optab_methods,\n+\t\t\t\t enum mode_class, optab);\n+static void prepare_cmp_insn (rtx *, rtx *, enum rtx_code *, rtx,\n+\t\t\t      enum machine_mode *, int *,\n+\t\t\t      enum can_compare_purpose);\n+static enum insn_code can_fix_p (enum machine_mode, enum machine_mode, int,\n+\t\t\t\t int *);\n+static enum insn_code can_float_p (enum machine_mode, enum machine_mode, int);\n+static rtx ftruncify (rtx);\n+static optab new_optab (void);\n+static inline optab init_optab (enum rtx_code);\n+static inline optab init_optabv (enum rtx_code);\n+static void init_libfuncs (optab, int, int, const char *, int);\n+static void init_integral_libfuncs (optab, const char *, int);\n+static void init_floating_libfuncs (optab, const char *, int);\n+static void emit_cmp_and_jump_insn_1 (rtx, rtx, enum machine_mode,\n+\t\t\t\t      enum rtx_code, int, rtx);\n+static void prepare_float_lib_cmp (rtx *, rtx *, enum rtx_code *,\n+\t\t\t\t   enum machine_mode *, int *);\n+static rtx expand_vector_binop (enum machine_mode, optab, rtx, rtx, rtx, int,\n+\t\t\t\tenum optab_methods);\n+static rtx expand_vector_unop (enum machine_mode, optab, rtx, rtx, int);\n+static rtx widen_clz (enum machine_mode, rtx, rtx);\n+static rtx expand_parity (enum machine_mode, rtx, rtx);\n \n #ifndef HAVE_conditional_trap\n #define HAVE_conditional_trap 0\n@@ -147,11 +142,7 @@ static rtx expand_parity PARAMS ((enum machine_mode, rtx, rtx));\n    again, ensuring that TARGET is not one of the operands.  */\n \n static int\n-add_equal_note (insns, target, code, op0, op1)\n-     rtx insns;\n-     rtx target;\n-     enum rtx_code code;\n-     rtx op0, op1;\n+add_equal_note (rtx insns, rtx target, enum rtx_code code, rtx op0, rtx op1)\n {\n   rtx last_insn, insn, set;\n   rtx note;\n@@ -210,16 +201,13 @@ add_equal_note (insns, target, code, op0, op1)\n \f\n /* Widen OP to MODE and return the rtx for the widened operand.  UNSIGNEDP\n    says whether OP is signed or unsigned.  NO_EXTEND is nonzero if we need\n-   not actually do a sign-extend or zero-extend, but can leave the \n+   not actually do a sign-extend or zero-extend, but can leave the\n    higher-order bits of the result rtx undefined, for example, in the case\n    of logical operations, but not right shifts.  */\n \n static rtx\n-widen_operand (op, mode, oldmode, unsignedp, no_extend)\n-     rtx op;\n-     enum machine_mode mode, oldmode;\n-     int unsignedp;\n-     int no_extend;\n+widen_operand (rtx op, enum machine_mode mode, enum machine_mode oldmode,\n+\t       int unsignedp, int no_extend)\n {\n   rtx result;\n \n@@ -252,14 +240,10 @@ widen_operand (op, mode, oldmode, unsignedp, no_extend)\n /* Generate code to perform a straightforward complex divide.  */\n \n static int\n-expand_cmplxdiv_straight (real0, real1, imag0, imag1, realr, imagr, submode,\n-\t\t\t  unsignedp, methods, class, binoptab)\n-     rtx real0, real1, imag0, imag1, realr, imagr;\n-     enum machine_mode submode;\n-     int unsignedp;\n-     enum optab_methods methods;\n-     enum mode_class class;\n-     optab binoptab;\n+expand_cmplxdiv_straight (rtx real0, rtx real1, rtx imag0, rtx imag1,\n+\t\t\t  rtx realr, rtx imagr, enum machine_mode submode,\n+\t\t\t  int unsignedp, enum optab_methods methods,\n+\t\t\t  enum mode_class class, optab binoptab)\n {\n   rtx divisor;\n   rtx real_t, imag_t;\n@@ -269,7 +253,7 @@ expand_cmplxdiv_straight (real0, real1, imag0, imag1, realr, imagr, submode,\n   optab this_sub_optab = sub_optab;\n   optab this_neg_optab = neg_optab;\n   optab this_mul_optab = smul_optab;\n-\t      \n+\n   if (binoptab == sdivv_optab)\n     {\n       this_add_optab = addv_optab;\n@@ -310,7 +294,7 @@ expand_cmplxdiv_straight (real0, real1, imag0, imag1, realr, imagr, submode,\n       /* Calculate the dividend.  */\n       real_t = expand_binop (submode, this_mul_optab, real0, real1,\n \t\t\t     NULL_RTX, unsignedp, methods);\n-\t\t  \n+\n       imag_t = expand_binop (submode, this_mul_optab, real0, imag1,\n \t\t\t     NULL_RTX, unsignedp, methods);\n \n@@ -335,7 +319,7 @@ expand_cmplxdiv_straight (real0, real1, imag0, imag1, realr, imagr, submode,\n \n       real_t = expand_binop (submode, this_add_optab, temp1, temp2,\n \t\t\t     NULL_RTX, unsignedp, methods);\n-\t\t  \n+\n       temp1 = expand_binop (submode, this_mul_optab, imag0, real1,\n \t\t\t    NULL_RTX, unsignedp, methods);\n \n@@ -384,14 +368,10 @@ expand_cmplxdiv_straight (real0, real1, imag0, imag1, realr, imagr, submode,\n /* Generate code to perform a wide-input-range-acceptable complex divide.  */\n \n static int\n-expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n-\t\t      unsignedp, methods, class, binoptab)\n-     rtx real0, real1, imag0, imag1, realr, imagr;\n-     enum machine_mode submode;\n-     int unsignedp;\n-     enum optab_methods methods;\n-     enum mode_class class;\n-     optab binoptab;\n+expand_cmplxdiv_wide (rtx real0, rtx real1, rtx imag0, rtx imag1, rtx realr,\n+\t\t      rtx imagr, enum machine_mode submode, int unsignedp,\n+\t\t      enum optab_methods methods, enum mode_class class,\n+\t\t      optab binoptab)\n {\n   rtx ratio, divisor;\n   rtx real_t, imag_t;\n@@ -410,7 +390,7 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n       this_neg_optab = negv_optab;\n       this_mul_optab = smulv_optab;\n     }\n-\t      \n+\n   /* Don't fetch these from memory more than once.  */\n   real0 = force_reg (submode, real0);\n   real1 = force_reg (submode, real1);\n@@ -648,13 +628,9 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n    the operation to perform, not an optab pointer.  All other\n    arguments are the same.  */\n rtx\n-expand_simple_binop (mode, code, op0, op1, target, unsignedp, methods)\n-     enum machine_mode mode;\n-     enum rtx_code code;\n-     rtx op0, op1;\n-     rtx target;\n-     int unsignedp;\n-     enum optab_methods methods;\n+expand_simple_binop (enum machine_mode mode, enum rtx_code code, rtx op0,\n+\t\t     rtx op1, rtx target, int unsignedp,\n+\t\t     enum optab_methods methods)\n {\n   optab binop = code_to_optab[(int) code];\n   if (binop == 0)\n@@ -675,13 +651,8 @@ expand_simple_binop (mode, code, op0, op1, target, unsignedp, methods)\n    this may or may not be TARGET.  */\n \n rtx\n-expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n-     enum machine_mode mode;\n-     optab binoptab;\n-     rtx op0, op1;\n-     rtx target;\n-     int unsignedp;\n-     enum optab_methods methods;\n+expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n+\t      rtx target, int unsignedp, enum optab_methods methods)\n {\n   enum optab_methods next_methods\n     = (methods == OPTAB_LIB || methods == OPTAB_LIB_WIDEN\n@@ -1077,7 +1048,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  if (inter != 0)\n \t    inter = expand_binop (word_mode, binoptab, outof_input,\n \t\t\t\t  op1, outof_target, unsignedp, next_methods);\n-\t  \n+\n \t  if (inter != 0 && inter != outof_target)\n \t    emit_move_insn (outof_target, inter);\n \t}\n@@ -1283,7 +1254,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  if (i > 0)\n \t    {\n \t      rtx newx;\n-\t      \n+\n \t      /* Add/subtract previous carry to main result.  */\n \t      newx = expand_binop (word_mode,\n \t\t\t\t   normalizep == 1 ? binoptab : otheroptab,\n@@ -1311,7 +1282,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t    }\n \n \t  carry_in = carry_out;\n-\t}\t\n+\t}\n \n       if (i == GET_MODE_BITSIZE (mode) / (unsigned) BITS_PER_WORD)\n \t{\n@@ -1321,7 +1292,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      rtx temp = emit_move_insn (target, xtarget);\n \n \t      set_unique_reg_note (temp,\n-\t      \t\t\t   REG_EQUAL,\n+\t\t\t\t   REG_EQUAL,\n \t\t\t\t   gen_rtx_fmt_ee (binoptab->code, mode,\n \t\t\t\t\t\t   copy_rtx (xop0),\n \t\t\t\t\t\t   copy_rtx (xop1)));\n@@ -1339,7 +1310,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n   /* If we want to multiply two two-word values and have normal and widening\n      multiplies of single-word values, we can do this with three smaller\n      multiplications.  Note that we do not make a REG_NO_CONFLICT block here\n-     because we are not operating on one word at a time. \n+     because we are not operating on one word at a time.\n \n      The multiplication proceeds as follows:\n \t\t\t         _______________________\n@@ -1493,7 +1464,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t    emit_move_insn (product_high, temp);\n \n \t  if (temp != 0)\n-\t    temp = expand_binop (word_mode, binoptab, op1_low, op0_xhigh, \n+\t    temp = expand_binop (word_mode, binoptab, op1_low, op0_xhigh,\n \t\t\t\t NULL_RTX, 0, OPTAB_DIRECT);\n \n \t  if (temp != 0)\n@@ -1512,7 +1483,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\t{\n \t\t  temp = emit_move_insn (product, product);\n \t\t  set_unique_reg_note (temp,\n-\t\t  \t\t       REG_EQUAL,\n+\t\t\t\t       REG_EQUAL,\n \t\t\t\t       gen_rtx_fmt_ee (MULT, mode,\n \t\t\t\t\t\t       copy_rtx (op0),\n \t\t\t\t\t\t       copy_rtx (op1)));\n@@ -1708,7 +1679,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n \tcase DIV:\n \t  /* (a+ib) / (c+id) = ((ac+bd)/(cc+dd)) + i((bc-ad)/(cc+dd)) */\n-\t  \n+\n \t  if (imag1 == 0)\n \t    {\n \t      /* (a+ib) / (c+i0) = (a/c) + i(b/c) */\n@@ -1766,7 +1737,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\t}\n \t    }\n \t  break;\n-\t  \n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -1782,9 +1753,9 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\t\t\tcopy_rtx (op0), copy_rtx (op1));\n \t  else\n \t    equiv_value = 0;\n-\t  \n+\n \t  emit_no_conflict_block (seq, target, op0, op1, equiv_value);\n-      \n+\n \t  return target;\n \t}\n     }\n@@ -1908,13 +1879,9 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n /* Like expand_binop, but for open-coding vectors binops.  */\n \n static rtx\n-expand_vector_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n-     enum machine_mode mode;\n-     optab binoptab;\n-     rtx op0, op1;\n-     rtx target;\n-     int unsignedp;\n-     enum optab_methods methods;\n+expand_vector_binop (enum machine_mode mode, optab binoptab, rtx op0,\n+\t\t     rtx op1, rtx target, int unsignedp,\n+\t\t     enum optab_methods methods)\n {\n   enum machine_mode submode, tmode;\n   int size, elts, subsize, subbitsize, i;\n@@ -2035,12 +2002,8 @@ expand_vector_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n /* Like expand_unop but for open-coding vector unops.  */\n \n static rtx\n-expand_vector_unop (mode, unoptab, op0, target, unsignedp)\n-     enum machine_mode mode;\n-     optab unoptab;\n-     rtx op0;\n-     rtx target;\n-     int unsignedp;\n+expand_vector_unop (enum machine_mode mode, optab unoptab, rtx op0,\n+\t\t    rtx target, int unsignedp)\n {\n   enum machine_mode submode, tmode;\n   int size, elts, subsize, subbitsize, i;\n@@ -2066,7 +2029,7 @@ expand_vector_unop (mode, unoptab, op0, target, unsignedp)\n       /* Avoid infinite recursion when an\n \t error has left us with the wrong mode.  */\n       && GET_MODE (op0) == mode)\n-    {    \n+    {\n       rtx temp;\n       temp = expand_binop (mode, sub_optab, CONST0_RTX (mode), op0,\n                            target, unsignedp, OPTAB_DIRECT);\n@@ -2139,12 +2102,9 @@ expand_vector_unop (mode, unoptab, op0, target, unsignedp)\n    of an unsigned wider operation, since the result would be the same.  */\n \n rtx\n-sign_expand_binop (mode, uoptab, soptab, op0, op1, target, unsignedp, methods)\n-     enum machine_mode mode;\n-     optab uoptab, soptab;\n-     rtx op0, op1, target;\n-     int unsignedp;\n-     enum optab_methods methods;\n+sign_expand_binop (enum machine_mode mode, optab uoptab, optab soptab,\n+\t\t   rtx op0, rtx op1, rtx target, int unsignedp,\n+\t\t   enum optab_methods methods)\n {\n   rtx temp;\n   optab direct_optab = unsignedp ? uoptab : soptab;\n@@ -2201,11 +2161,8 @@ sign_expand_binop (mode, uoptab, soptab, op0, op1, target, unsignedp, methods)\n    Returns 1 if this operation can be performed; 0 if not.  */\n \n int\n-expand_twoval_binop (binoptab, op0, op1, targ0, targ1, unsignedp)\n-     optab binoptab;\n-     rtx op0, op1;\n-     rtx targ0, targ1;\n-     int unsignedp;\n+expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n+\t\t     int unsignedp)\n {\n   enum machine_mode mode = GET_MODE (targ0 ? targ0 : targ1);\n   enum mode_class class;\n@@ -2286,7 +2243,7 @@ expand_twoval_binop (binoptab, op0, op1, targ0, targ1, unsignedp)\n       if (! (*insn_data[icode].operand[0].predicate) (targ0, mode)\n \t  || ! (*insn_data[icode].operand[3].predicate) (targ1, mode))\n \tabort ();\n-\t\n+\n       pat = GEN_FCN (icode) (targ0, xop0, xop1, targ1);\n       if (pat)\n \t{\n@@ -2333,12 +2290,8 @@ expand_twoval_binop (binoptab, op0, op1, targ0, targ1, unsignedp)\n    the operation to perform, not an optab pointer.  All other\n    arguments are the same.  */\n rtx\n-expand_simple_unop (mode, code, op0, target, unsignedp)\n-     enum machine_mode mode;\n-     enum rtx_code code;\n-     rtx op0;\n-     rtx target;\n-     int unsignedp;\n+expand_simple_unop (enum machine_mode mode, enum rtx_code code, rtx op0,\n+\t\t    rtx target, int unsignedp)\n {\n   optab unop = code_to_optab[(int) code];\n   if (unop == 0)\n@@ -2352,10 +2305,7 @@ expand_simple_unop (mode, code, op0, target, unsignedp)\n    as\n \t(clz:wide (zero_extend:wide x)) - ((width wide) - (width narrow)).  */\n static rtx\n-widen_clz (mode, op0, target)\n-     enum machine_mode mode;\n-     rtx op0;\n-     rtx target;\n+widen_clz (enum machine_mode mode, rtx op0, rtx target)\n {\n   enum mode_class class = GET_MODE_CLASS (mode);\n   if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n@@ -2393,10 +2343,7 @@ widen_clz (mode, op0, target)\n /* Try calculating (parity x) as (and (popcount x) 1), where\n    popcount can also be done in a wider mode.  */\n static rtx\n-expand_parity (mode, op0, target)\n-     enum machine_mode mode;\n-     rtx op0;\n-     rtx target;\n+expand_parity (enum machine_mode mode, rtx op0, rtx target)\n {\n   enum mode_class class = GET_MODE_CLASS (mode);\n   if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n@@ -2442,12 +2389,8 @@ expand_parity (mode, op0, target)\n    this may or may not be TARGET.  */\n \n rtx\n-expand_unop (mode, unoptab, op0, target, unsignedp)\n-     enum machine_mode mode;\n-     optab unoptab;\n-     rtx op0;\n-     rtx target;\n-     int unsignedp;\n+expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n+\t     int unsignedp)\n {\n   enum mode_class class;\n   enum machine_mode wider_mode;\n@@ -2501,7 +2444,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \t    }\n \n \t  emit_insn (pat);\n-\t  \n+\n \t  return temp;\n \t}\n       else\n@@ -2536,7 +2479,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \t\t\t\t  (unoptab == neg_optab\n \t\t\t\t   || unoptab == one_cmpl_optab)\n \t\t\t\t  && class == MODE_INT);\n-\t      \n+\n \t    temp = expand_unop (wider_mode, unoptab, xop0, NULL_RTX,\n \t\t\t\tunsignedp);\n \n@@ -2608,7 +2551,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \n       if (target == 0)\n \ttarget = gen_reg_rtx (mode);\n-      \n+\n       start_sequence ();\n \n       target_piece = gen_imagpart (submode, target);\n@@ -2738,7 +2681,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \t\t\t\t    (unoptab == neg_optab\n \t\t\t\t     || unoptab == one_cmpl_optab)\n \t\t\t\t    && class == MODE_INT);\n-\t      \n+\n \t      temp = expand_unop (wider_mode, unoptab, xop0, NULL_RTX,\n \t\t\t\t  unsignedp);\n \n@@ -2771,7 +2714,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n   /* If there is no negate operation, try doing a subtract from zero.\n      The US Software GOFAST library needs this.  */\n   if (unoptab->code == NEG)\n-    {    \n+    {\n       rtx temp;\n       temp = expand_binop (mode,\n                            unoptab == negv_optab ? subv_optab : sub_optab,\n@@ -2780,7 +2723,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n       if (temp)\n \treturn temp;\n     }\n-      \n+\n   return 0;\n }\n \f\n@@ -2794,11 +2737,8 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n  */\n \n rtx\n-expand_abs_nojump (mode, op0, target, result_unsignedp)\n-     enum machine_mode mode;\n-     rtx op0;\n-     rtx target;\n-     int result_unsignedp;\n+expand_abs_nojump (enum machine_mode mode, rtx op0, rtx target,\n+\t\t   int result_unsignedp)\n {\n   rtx temp;\n \n@@ -2892,12 +2832,8 @@ expand_abs_nojump (mode, op0, target, result_unsignedp)\n }\n \n rtx\n-expand_abs (mode, op0, target, result_unsignedp, safe)\n-     enum machine_mode mode;\n-     rtx op0;\n-     rtx target;\n-     int result_unsignedp;\n-     int safe;\n+expand_abs (enum machine_mode mode, rtx op0, rtx target,\n+\t    int result_unsignedp, int safe)\n {\n   rtx temp, op1;\n \n@@ -2931,7 +2867,7 @@ expand_abs (mode, op0, target, result_unsignedp, safe)\n      compare word by word.  Rely on CSE to optimize constant cases.  */\n   if (GET_MODE_CLASS (mode) == MODE_INT\n       && ! can_compare_p (GE, mode, ccp_jump))\n-    do_jump_by_parts_greater_rtx (mode, 0, target, const0_rtx, \n+    do_jump_by_parts_greater_rtx (mode, 0, target, const0_rtx,\n \t\t\t\t  NULL_RTX, op1);\n   else\n     do_compare_rtx_and_jump (target, CONST0_RTX (mode), GE, 0, mode,\n@@ -2956,11 +2892,8 @@ expand_abs (mode, op0, target, result_unsignedp, safe)\n    UNSIGNEDP is relevant for complex integer modes.  */\n \n rtx\n-expand_complex_abs (mode, op0, target, unsignedp)\n-     enum machine_mode mode;\n-     rtx op0;\n-     rtx target;\n-     int unsignedp;\n+expand_complex_abs (enum machine_mode mode, rtx op0, rtx target,\n+\t\t    int unsignedp)\n {\n   enum mode_class class = GET_MODE_CLASS (mode);\n   enum machine_mode wider_mode;\n@@ -3019,16 +2952,16 @@ expand_complex_abs (mode, op0, target, unsignedp)\n       if (pat)\n \t{\n \t  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n-\t      && ! add_equal_note (pat, temp, this_abs_optab->code, xop0, \n+\t      && ! add_equal_note (pat, temp, this_abs_optab->code, xop0,\n \t\t\t\t   NULL_RTX))\n \t    {\n \t      delete_insns_since (last);\n-\t      return expand_unop (mode, this_abs_optab, op0, NULL_RTX, \n+\t      return expand_unop (mode, this_abs_optab, op0, NULL_RTX,\n \t\t\t\t  unsignedp);\n \t    }\n \n \t  emit_insn (pat);\n-\t  \n+\n \t  return temp;\n \t}\n       else\n@@ -3040,7 +2973,7 @@ expand_complex_abs (mode, op0, target, unsignedp)\n   for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n        wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n     {\n-      if (this_abs_optab->handlers[(int) wider_mode].insn_code \n+      if (this_abs_optab->handlers[(int) wider_mode].insn_code\n \t  != CODE_FOR_nothing)\n \t{\n \t  rtx xop0 = op0;\n@@ -3156,11 +3089,7 @@ expand_complex_abs (mode, op0, target, unsignedp)\n    the value that is stored into TARGET.  */\n \n void\n-emit_unop_insn (icode, target, op0, code)\n-     int icode;\n-     rtx target;\n-     rtx op0;\n-     enum rtx_code code;\n+emit_unop_insn (int icode, rtx target, rtx op0, enum rtx_code code)\n {\n   rtx temp;\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n@@ -3189,7 +3118,7 @@ emit_unop_insn (icode, target, op0, code)\n \n   if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX && code != UNKNOWN)\n     add_equal_note (pat, temp, code, op0, NULL_RTX);\n-  \n+\n   emit_insn (pat);\n \n   if (temp != target)\n@@ -3210,7 +3139,7 @@ emit_unop_insn (icode, target, op0, code)\n \n    INSNS is a block of code generated to perform the operation, not including\n    the CLOBBER and final copy.  All insns that compute intermediate values\n-   are first emitted, followed by the block as described above.  \n+   are first emitted, followed by the block as described above.\n \n    TARGET, OP0, and OP1 are the output and inputs of the operations,\n    respectively.  OP1 may be zero for a unary operation.\n@@ -3225,11 +3154,7 @@ emit_unop_insn (icode, target, op0, code)\n    The final insn emitted is returned.  */\n \n rtx\n-emit_no_conflict_block (insns, target, op0, op1, equiv)\n-     rtx insns;\n-     rtx target;\n-     rtx op0, op1;\n-     rtx equiv;\n+emit_no_conflict_block (rtx insns, rtx target, rtx op0, rtx op1, rtx equiv)\n {\n   rtx prev, next, first, last, insn;\n \n@@ -3366,11 +3291,7 @@ emit_no_conflict_block (insns, target, op0, op1, equiv)\n    block is delimited by REG_RETVAL and REG_LIBCALL notes.  */\n \n void\n-emit_libcall_block (insns, target, result, equiv)\n-     rtx insns;\n-     rtx target;\n-     rtx result;\n-     rtx equiv;\n+emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n {\n   rtx final_dest = target;\n   rtx prev, next, first, last, insn;\n@@ -3379,7 +3300,7 @@ emit_libcall_block (insns, target, result, equiv)\n      into a MEM later.  Protect the libcall block from this change.  */\n   if (! REG_P (target) || REG_USERVAR_P (target))\n     target = gen_reg_rtx (GET_MODE (target));\n-  \n+\n   /* If we're using non-call exceptions, a libcall corresponding to an\n      operation that may trap may also trap.  */\n   if (flag_non_call_exceptions && may_trap_p (equiv))\n@@ -3388,7 +3309,7 @@ emit_libcall_block (insns, target, result, equiv)\n \tif (GET_CODE (insn) == CALL_INSN)\n \t  {\n \t    rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-\t    \n+\n \t    if (note != 0 && INTVAL (XEXP (note, 0)) <= 0)\n \t      remove_note (insn, note);\n \t  }\n@@ -3402,7 +3323,7 @@ emit_libcall_block (insns, target, result, equiv)\n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-\t\n+\n \t  if (note != 0)\n \t    XEXP (note, 0) = GEN_INT (-1);\n \t  else\n@@ -3518,8 +3439,7 @@ emit_libcall_block (insns, target, result, equiv)\n /* Generate code to store zero in X.  */\n \n void\n-emit_clr_insn (x)\n-     rtx x;\n+emit_clr_insn (rtx x)\n {\n   emit_move_insn (x, const0_rtx);\n }\n@@ -3528,8 +3448,7 @@ emit_clr_insn (x)\n    assuming it contains zero beforehand.  */\n \n void\n-emit_0_to_1_insn (x)\n-     rtx x;\n+emit_0_to_1_insn (rtx x)\n {\n   emit_move_insn (x, const1_rtx);\n }\n@@ -3539,14 +3458,12 @@ emit_0_to_1_insn (x)\n    comparison code we will be using.\n \n    ??? Actually, CODE is slightly weaker than that.  A target is still\n-   required to implement all of the normal bcc operations, but not \n+   required to implement all of the normal bcc operations, but not\n    required to implement all (or any) of the unordered bcc operations.  */\n-  \n+\n int\n-can_compare_p (code, mode, purpose)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     enum can_compare_purpose purpose;\n+can_compare_p (enum rtx_code code, enum machine_mode mode,\n+\t       enum can_compare_purpose purpose)\n {\n   do\n     {\n@@ -3594,13 +3511,9 @@ can_compare_p (code, mode, purpose)\n    should perform the comparison on the modified values.  */\n \n static void\n-prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, purpose)\n-     rtx *px, *py;\n-     enum rtx_code *pcomparison;\n-     rtx size;\n-     enum machine_mode *pmode;\n-     int *punsignedp;\n-     enum can_compare_purpose purpose;\n+prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n+\t\t  enum machine_mode *pmode, int *punsignedp,\n+\t\t  enum can_compare_purpose purpose)\n {\n   enum machine_mode mode = *pmode;\n   rtx x = *px, y = *py;\n@@ -3768,12 +3681,8 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, purpose)\n    that it is accepted by the operand predicate.  Return the new value.  */\n \n rtx\n-prepare_operand (icode, x, opnum, mode, wider_mode, unsignedp)\n-     int icode;\n-     rtx x;\n-     int opnum;\n-     enum machine_mode mode, wider_mode;\n-     int unsignedp;\n+prepare_operand (int icode, rtx x, int opnum, enum machine_mode mode,\n+\t\t enum machine_mode wider_mode, int unsignedp)\n {\n   x = protect_from_queue (x, 0);\n \n@@ -3792,12 +3701,8 @@ prepare_operand (icode, x, opnum, mode, wider_mode, unsignedp)\n    be NULL_RTX which indicates that only a comparison is to be generated.  */\n \n static void\n-emit_cmp_and_jump_insn_1 (x, y, mode, comparison, unsignedp, label)\n-     rtx x, y;\n-     enum machine_mode mode;\n-     enum rtx_code comparison;\n-     int unsignedp;\n-     rtx label;\n+emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n+\t\t\t  enum rtx_code comparison, int unsignedp, rtx label)\n {\n   rtx test = gen_rtx_fmt_ee (comparison, mode, x, y);\n   enum mode_class class = GET_MODE_CLASS (mode);\n@@ -3810,9 +3715,9 @@ emit_cmp_and_jump_insn_1 (x, y, mode, comparison, unsignedp, label)\n       PUT_MODE (test, wider_mode);\n \n       if (label)\n-\t{\t  \n+\t{\n \t  icode = cbranch_optab->handlers[(int) wider_mode].insn_code;\n-\t  \n+\n \t  if (icode != CODE_FOR_nothing\n \t      && (*insn_data[icode].operand[0].predicate) (test, wider_mode))\n \t    {\n@@ -3876,13 +3781,8 @@ emit_cmp_and_jump_insn_1 (x, y, mode, comparison, unsignedp, label)\n    unsigned variant based on UNSIGNEDP to select a proper jump instruction.  */\n \n void\n-emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, label)\n-     rtx x, y;\n-     enum rtx_code comparison;\n-     rtx size;\n-     enum machine_mode mode;\n-     int unsignedp;\n-     rtx label;\n+emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n+\t\t\t enum machine_mode mode, int unsignedp, rtx label)\n {\n   rtx op0 = x, op1 = y;\n \n@@ -3918,12 +3818,8 @@ emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, label)\n /* Like emit_cmp_and_jump_insns, but generate only the comparison.  */\n \n void\n-emit_cmp_insn (x, y, comparison, size, mode, unsignedp)\n-     rtx x, y;\n-     enum rtx_code comparison;\n-     rtx size;\n-     enum machine_mode mode;\n-     int unsignedp;\n+emit_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n+\t       enum machine_mode mode, int unsignedp)\n {\n   emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, 0);\n }\n@@ -3932,11 +3828,8 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp)\n    COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).  */\n \n static void\n-prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp)\n-     rtx *px, *py;\n-     enum rtx_code *pcomparison;\n-     enum machine_mode *pmode;\n-     int *punsignedp;\n+prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n+\t\t       enum machine_mode *pmode, int *punsignedp)\n {\n   enum rtx_code comparison = *pcomparison;\n   rtx tmp;\n@@ -4278,8 +4171,7 @@ prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp)\n /* Generate code to indirectly jump to a location given in the rtx LOC.  */\n \n void\n-emit_indirect_jump (loc)\n-     rtx loc;\n+emit_indirect_jump (rtx loc)\n {\n   if (! ((*insn_data[(int) CODE_FOR_indirect_jump].operand[0].predicate)\n \t (loc, Pmode)))\n@@ -4306,15 +4198,9 @@ emit_indirect_jump (loc)\n    is not supported.  */\n \n rtx\n-emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n-\t\t       unsignedp)\n-     rtx target;\n-     enum rtx_code code;\n-     rtx op0, op1;\n-     enum machine_mode cmode;\n-     rtx op2, op3;\n-     enum machine_mode mode;\n-     int unsignedp;\n+emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n+\t\t       enum machine_mode cmode, rtx op2, rtx op3,\n+\t\t       enum machine_mode mode, int unsignedp)\n {\n   rtx tem, subtarget, comparison, insn;\n   enum insn_code icode;\n@@ -4395,7 +4281,7 @@ emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n   /* Everything should now be in the suitable form, so emit the compare insn\n      and then the conditional move.  */\n \n-  comparison \n+  comparison\n     = compare_from_rtx (op0, op1, code, unsignedp, cmode, NULL_RTX);\n \n   /* ??? Watch for const0_rtx (nop) and const_true_rtx (unconditional)?  */\n@@ -4404,7 +4290,7 @@ emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n      situation.  */\n   if (GET_CODE (comparison) != code)\n     return NULL_RTX;\n-  \n+\n   insn = GEN_FCN (icode) (subtarget, comparison, op2, op3);\n \n   /* If that failed, then give up.  */\n@@ -4428,8 +4314,7 @@ emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n    comparisons, and vice versa.  How do we handle them?  */\n \n int\n-can_conditionally_move_p (mode)\n-     enum machine_mode mode;\n+can_conditionally_move_p (enum machine_mode mode)\n {\n   if (movcc_gen_code[mode] != CODE_FOR_nothing)\n     return 1;\n@@ -4454,15 +4339,9 @@ can_conditionally_move_p (mode)\n    is not supported.  */\n \n rtx\n-emit_conditional_add (target, code, op0, op1, cmode, op2, op3, mode,\n-\t\t      unsignedp)\n-     rtx target;\n-     enum rtx_code code;\n-     rtx op0, op1;\n-     enum machine_mode cmode;\n-     rtx op2, op3;\n-     enum machine_mode mode;\n-     int unsignedp;\n+emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n+\t\t      enum machine_mode cmode, rtx op2, rtx op3,\n+\t\t      enum machine_mode mode, int unsignedp)\n {\n   rtx tem, subtarget, comparison, insn;\n   enum insn_code icode;\n@@ -4543,7 +4422,7 @@ emit_conditional_add (target, code, op0, op1, cmode, op2, op3, mode,\n   /* Everything should now be in the suitable form, so emit the compare insn\n      and then the conditional move.  */\n \n-  comparison \n+  comparison\n     = compare_from_rtx (op0, op1, code, unsignedp, cmode, NULL_RTX);\n \n   /* ??? Watch for const0_rtx (nop) and const_true_rtx (unconditional)?  */\n@@ -4552,7 +4431,7 @@ emit_conditional_add (target, code, op0, op1, cmode, op2, op3, mode,\n      situation.  */\n   if (GET_CODE (comparison) != code)\n     return NULL_RTX;\n-  \n+\n   insn = GEN_FCN (icode) (subtarget, comparison, op2, op3);\n \n   /* If that failed, then give up.  */\n@@ -4578,10 +4457,9 @@ emit_conditional_add (target, code, op0, op1, cmode, op2, op3, mode,\n /* Generate and return an insn body to add Y to X.  */\n \n rtx\n-gen_add2_insn (x, y)\n-     rtx x, y;\n+gen_add2_insn (rtx x, rtx y)\n {\n-  int icode = (int) add_optab->handlers[(int) GET_MODE (x)].insn_code; \n+  int icode = (int) add_optab->handlers[(int) GET_MODE (x)].insn_code;\n \n   if (! ((*insn_data[icode].operand[0].predicate)\n \t (x, insn_data[icode].operand[0].mode))\n@@ -4597,8 +4475,7 @@ gen_add2_insn (x, y)\n /* Generate and return an insn body to add r1 and c,\n    storing the result in r0.  */\n rtx\n-gen_add3_insn (r0, r1, c)\n-     rtx r0, r1, c;\n+gen_add3_insn (rtx r0, rtx r1, rtx c)\n {\n   int icode = (int) add_optab->handlers[(int) GET_MODE (r0)].insn_code;\n \n@@ -4615,15 +4492,14 @@ gen_add3_insn (r0, r1, c)\n }\n \n int\n-have_add2_insn (x, y)\n-     rtx x, y;\n+have_add2_insn (rtx x, rtx y)\n {\n   int icode;\n \n   if (GET_MODE (x) == VOIDmode)\n     abort ();\n \n-  icode = (int) add_optab->handlers[(int) GET_MODE (x)].insn_code; \n+  icode = (int) add_optab->handlers[(int) GET_MODE (x)].insn_code;\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n@@ -4642,10 +4518,9 @@ have_add2_insn (x, y)\n /* Generate and return an insn body to subtract Y from X.  */\n \n rtx\n-gen_sub2_insn (x, y)\n-     rtx x, y;\n+gen_sub2_insn (rtx x, rtx y)\n {\n-  int icode = (int) sub_optab->handlers[(int) GET_MODE (x)].insn_code; \n+  int icode = (int) sub_optab->handlers[(int) GET_MODE (x)].insn_code;\n \n   if (! ((*insn_data[icode].operand[0].predicate)\n \t (x, insn_data[icode].operand[0].mode))\n@@ -4661,8 +4536,7 @@ gen_sub2_insn (x, y)\n /* Generate and return an insn body to subtract r1 and c,\n    storing the result in r0.  */\n rtx\n-gen_sub3_insn (r0, r1, c)\n-     rtx r0, r1, c;\n+gen_sub3_insn (rtx r0, rtx r1, rtx c)\n {\n   int icode = (int) sub_optab->handlers[(int) GET_MODE (r0)].insn_code;\n \n@@ -4679,15 +4553,14 @@ gen_sub3_insn (r0, r1, c)\n }\n \n int\n-have_sub2_insn (x, y)\n-     rtx x, y;\n+have_sub2_insn (rtx x, rtx y)\n {\n   int icode;\n \n   if (GET_MODE (x) == VOIDmode)\n     abort ();\n \n-  icode = (int) sub_optab->handlers[(int) GET_MODE (x)].insn_code; \n+  icode = (int) sub_optab->handlers[(int) GET_MODE (x)].insn_code;\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n@@ -4707,8 +4580,7 @@ have_sub2_insn (x, y)\n    It may be a list of insns, if one insn isn't enough.  */\n \n rtx\n-gen_move_insn (x, y)\n-     rtx x, y;\n+gen_move_insn (rtx x, rtx y)\n {\n   rtx seq;\n \n@@ -4724,9 +4596,8 @@ gen_move_insn (x, y)\n    no such operation exists, CODE_FOR_nothing will be returned.  */\n \n enum insn_code\n-can_extend_p (to_mode, from_mode, unsignedp)\n-     enum machine_mode to_mode, from_mode;\n-     int unsignedp;\n+can_extend_p (enum machine_mode to_mode, enum machine_mode from_mode,\n+\t      int unsignedp)\n {\n #ifdef HAVE_ptr_extend\n   if (unsignedp < 0)\n@@ -4740,10 +4611,8 @@ can_extend_p (to_mode, from_mode, unsignedp)\n    into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */\n \n rtx\n-gen_extend_insn (x, y, mto, mfrom, unsignedp)\n-     rtx x, y;\n-     enum machine_mode mto, mfrom;\n-     int unsignedp;\n+gen_extend_insn (rtx x, rtx y, enum machine_mode mto,\n+\t\t enum machine_mode mfrom, int unsignedp)\n {\n   return (GEN_FCN (extendtab[(int) mto][(int) mfrom][unsignedp != 0]) (x, y));\n }\n@@ -4758,10 +4627,8 @@ gen_extend_insn (x, y, mto, mfrom, unsignedp)\n    an explicit FTRUNC insn before the fix insn; otherwise 0.  */\n \n static enum insn_code\n-can_fix_p (fixmode, fltmode, unsignedp, truncp_ptr)\n-     enum machine_mode fltmode, fixmode;\n-     int unsignedp;\n-     int *truncp_ptr;\n+can_fix_p (enum machine_mode fixmode, enum machine_mode fltmode,\n+\t   int unsignedp, int *truncp_ptr)\n {\n   *truncp_ptr = 0;\n   if (fixtrunctab[(int) fltmode][(int) fixmode][unsignedp != 0]\n@@ -4777,9 +4644,8 @@ can_fix_p (fixmode, fltmode, unsignedp, truncp_ptr)\n }\n \n static enum insn_code\n-can_float_p (fltmode, fixmode, unsignedp)\n-     enum machine_mode fixmode, fltmode;\n-     int unsignedp;\n+can_float_p (enum machine_mode fltmode, enum machine_mode fixmode,\n+\t     int unsignedp)\n {\n   return floattab[(int) fltmode][(int) fixmode][unsignedp != 0];\n }\n@@ -4791,9 +4657,7 @@ can_float_p (fltmode, fixmode, unsignedp)\n    if it is negative.  */\n \n void\n-expand_float (to, from, unsignedp)\n-     rtx to, from;\n-     int unsignedp;\n+expand_float (rtx to, rtx from, int unsignedp)\n {\n   enum insn_code icode;\n   rtx target = to;\n@@ -4881,7 +4745,7 @@ expand_float (to, from, unsignedp)\n \t      rtx temp1;\n \t      rtx neglabel = gen_label_rtx ();\n \n-\t      /* Don't use TARGET if it isn't a register, is a hard register, \n+\t      /* Don't use TARGET if it isn't a register, is a hard register,\n \t\t or is the wrong mode.  */\n \t      if (GET_CODE (target) != REG\n \t\t  || REGNO (target) < FIRST_PSEUDO_REGISTER\n@@ -4910,7 +4774,7 @@ expand_float (to, from, unsignedp)\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \t      temp1 = expand_shift (RSHIFT_EXPR, imode, from, integer_one_node,\n \t\t\t\t    NULL_RTX, 1);\n-\t      temp = expand_binop (imode, ior_optab, temp, temp1, temp, 1, \n+\t      temp = expand_binop (imode, ior_optab, temp, temp1, temp, 1,\n \t\t\t\t   OPTAB_LIB_WIDEN);\n \t      expand_float (target, temp, 0);\n \n@@ -4943,7 +4807,7 @@ expand_float (to, from, unsignedp)\n       emit_cmp_and_jump_insns (from, const0_rtx, GE, NULL_RTX, GET_MODE (from),\n \t\t\t       0, label);\n \n-      \n+\n       real_2expN (&offset, GET_MODE_BITSIZE (GET_MODE (from)));\n       temp = expand_binop (fmode, add_optab, target,\n \t\t\t   CONST_DOUBLE_FROM_REAL_VALUE (offset, fmode),\n@@ -5049,17 +4913,14 @@ expand_float (to, from, unsignedp)\n    and store in TO.  FROM must be floating point.  */\n \n static rtx\n-ftruncify (x)\n-     rtx x;\n+ftruncify (rtx x)\n {\n   rtx temp = gen_reg_rtx (GET_MODE (x));\n   return expand_unop (GET_MODE (x), ftrunc_optab, x, temp, 0);\n }\n \n void\n-expand_fix (to, from, unsignedp)\n-     rtx to, from;\n-     int unsignedp;\n+expand_fix (rtx to, rtx from, int unsignedp)\n {\n   enum insn_code icode;\n   rtx target = to;\n@@ -5112,7 +4973,7 @@ expand_fix (to, from, unsignedp)\n      one plus the highest signed number, convert, and add it back.\n \n      We only need to check all real modes, since we know we didn't find\n-     anything with a wider integer mode.  \n+     anything with a wider integer mode.\n \n      This code used to extend FP value into mode wider than the destination.\n      This is not needed.  Consider, for instance conversion from SFmode\n@@ -5276,7 +5137,7 @@ expand_fix (to, from, unsignedp)\n \t\t\t  gen_rtx_fmt_e (unsignedp ? UNSIGNED_FIX : FIX,\n \t\t\t\t\t GET_MODE (to), from));\n     }\n-      \n+\n   if (target != to)\n     {\n       if (GET_MODE (to) == GET_MODE (target))\n@@ -5289,9 +5150,7 @@ expand_fix (to, from, unsignedp)\n /* Report whether we have an instruction to perform the operation\n    specified by CODE on operands of mode MODE.  */\n int\n-have_insn_for (code, mode)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n+have_insn_for (enum rtx_code code, enum machine_mode mode)\n {\n   return (code_to_optab[(int) code] != 0\n \t  && (code_to_optab[(int) code]->handlers[(int) mode].insn_code\n@@ -5300,7 +5159,7 @@ have_insn_for (code, mode)\n \n /* Create a blank optab.  */\n static optab\n-new_optab ()\n+new_optab (void)\n {\n   int i;\n   optab op = (optab) ggc_alloc (sizeof (struct optab));\n@@ -5316,8 +5175,7 @@ new_optab ()\n /* Same, but fill in its code as CODE, and write it into the\n    code_to_optab table.  */\n static inline optab\n-init_optab (code)\n-     enum rtx_code code;\n+init_optab (enum rtx_code code)\n {\n   optab op = new_optab ();\n   op->code = code;\n@@ -5328,8 +5186,7 @@ init_optab (code)\n /* Same, but fill in its code as CODE, and do _not_ write it into\n    the code_to_optab table.  */\n static inline optab\n-init_optabv (code)\n-     enum rtx_code code;\n+init_optabv (enum rtx_code code)\n {\n   optab op = new_optab ();\n   op->code = code;\n@@ -5354,12 +5211,8 @@ init_optabv (code)\n */\n \n static void\n-init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n-     optab optable;\n-     int first_mode;\n-     int last_mode;\n-     const char *opname;\n-     int suffix;\n+init_libfuncs (optab optable, int first_mode, int last_mode,\n+\t       const char *opname, int suffix)\n {\n   int mode;\n   unsigned opname_len = strlen (opname);\n@@ -5394,10 +5247,7 @@ init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n    routine.  (See above).  */\n \n static void\n-init_integral_libfuncs (optable, opname, suffix)\n-     optab optable;\n-     const char *opname;\n-     int suffix;\n+init_integral_libfuncs (optab optable, const char *opname, int suffix)\n {\n   int maxsize = 2*BITS_PER_WORD;\n   if (maxsize < LONG_LONG_TYPE_SIZE)\n@@ -5413,10 +5263,7 @@ init_integral_libfuncs (optable, opname, suffix)\n    routine.  (See above).  */\n \n static void\n-init_floating_libfuncs (optable, opname, suffix)\n-     optab optable;\n-     const char *opname;\n-     int suffix;\n+init_floating_libfuncs (optab optable, const char *opname, int suffix)\n {\n   enum machine_mode fmode, dmode, lmode;\n \n@@ -5433,8 +5280,7 @@ init_floating_libfuncs (optable, opname, suffix)\n }\n \n rtx\n-init_one_libfunc (name)\n-     const char *name;\n+init_one_libfunc (const char *name)\n {\n   rtx symbol;\n \n@@ -5461,7 +5307,7 @@ init_one_libfunc (name)\n    appropriately for the current target machine.  */\n \n void\n-init_optabs ()\n+init_optabs (void)\n {\n   unsigned int i, j, k;\n \n@@ -5836,9 +5682,8 @@ init_optabs ()\n    CODE.  Return 0 on failure.  */\n \n rtx\n-gen_cond_trap (code, op1, op2, tcode)\n-     enum rtx_code code ATTRIBUTE_UNUSED;\n-     rtx op1, op2 ATTRIBUTE_UNUSED, tcode ATTRIBUTE_UNUSED;\n+gen_cond_trap (enum rtx_code code ATTRIBUTE_UNUSED, rtx op1,\n+\t       rtx op2 ATTRIBUTE_UNUSED, rtx tcode ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode = GET_MODE (op1);\n   enum insn_code icode;"}, {"sha": "27044abc17b9ce39d12d44fde40a53bda28f32cf", "filename": "gcc/optabs.h", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -93,7 +93,7 @@ enum optab_index\n   /* Arithmetic shift left */\n   OTI_ashl,\n   /* Logical shift right */\n-  OTI_lshr,  \n+  OTI_lshr,\n   /* Arithmetic shift right */\n   OTI_ashr,\n   /* Rotate left */\n@@ -168,7 +168,7 @@ enum optab_index\n   OTI_cbranch,\n   OTI_cmov,\n   OTI_cstore,\n-    \n+\n   /* Push instruction.  */\n   OTI_push,\n \n@@ -269,7 +269,7 @@ extern enum insn_code reload_out_optab[NUM_MACHINE_MODES];\n extern GTY(()) optab code_to_optab[NUM_RTX_CODE + 1];\n \n \f\n-typedef rtx (*rtxfun) PARAMS ((rtx));\n+typedef rtx (*rtxfun) (rtx);\n \n /* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n    gives the gen_function to make a branch to test that condition.  */\n@@ -298,43 +298,43 @@ extern enum insn_code clrstr_optab[NUM_MACHINE_MODES];\n /* Define functions given in optabs.c.  */\n \n /* Expand a binary operation given optab and rtx operands.  */\n-extern rtx expand_binop PARAMS ((enum machine_mode, optab, rtx, rtx, rtx,\n-\t\t\t\t int, enum optab_methods));\n+extern rtx expand_binop (enum machine_mode, optab, rtx, rtx, rtx, int,\n+\t\t\t enum optab_methods);\n \n /* Expand a binary operation with both signed and unsigned forms.  */\n-extern rtx sign_expand_binop PARAMS ((enum machine_mode, optab, optab, rtx,\n-\t\t\t\t      rtx, rtx, int, enum optab_methods));\n+extern rtx sign_expand_binop (enum machine_mode, optab, optab, rtx, rtx,\n+\t\t\t      rtx, int, enum optab_methods);\n \n /* Generate code to perform an operation on two operands with two results.  */\n-extern int expand_twoval_binop PARAMS ((optab, rtx, rtx, rtx, rtx, int));\n+extern int expand_twoval_binop (optab, rtx, rtx, rtx, rtx, int);\n \n /* Expand a unary arithmetic operation given optab rtx operand.  */\n-extern rtx expand_unop PARAMS ((enum machine_mode, optab, rtx, rtx, int));\n+extern rtx expand_unop (enum machine_mode, optab, rtx, rtx, int);\n \n /* Expand the absolute value operation.  */\n-extern rtx expand_abs_nojump PARAMS ((enum machine_mode, rtx, rtx, int));\n-extern rtx expand_abs PARAMS ((enum machine_mode, rtx, rtx, int, int));\n+extern rtx expand_abs_nojump (enum machine_mode, rtx, rtx, int);\n+extern rtx expand_abs (enum machine_mode, rtx, rtx, int, int);\n \n /* Expand the complex absolute value operation.  */\n-extern rtx expand_complex_abs PARAMS ((enum machine_mode, rtx, rtx, int));\n+extern rtx expand_complex_abs (enum machine_mode, rtx, rtx, int);\n \n /* Generate an instruction with a given INSN_CODE with an output and\n    an input.  */\n-extern void emit_unop_insn PARAMS ((int, rtx, rtx, enum rtx_code));\n+extern void emit_unop_insn (int, rtx, rtx, enum rtx_code);\n \n /* Emit code to perform a series of operations on a multi-word quantity, one\n    word at a time.  */\n-extern rtx emit_no_conflict_block PARAMS ((rtx, rtx, rtx, rtx, rtx));\n+extern rtx emit_no_conflict_block (rtx, rtx, rtx, rtx, rtx);\n \n /* Emit one rtl instruction to store zero in specified rtx.  */\n-extern void emit_clr_insn PARAMS ((rtx));\n+extern void emit_clr_insn (rtx);\n \n /* Emit one rtl insn to store 1 in specified rtx assuming it contains 0.  */\n-extern void emit_0_to_1_insn PARAMS ((rtx));\n+extern void emit_0_to_1_insn (rtx);\n \n /* Emit one rtl insn to compare two rtx's.  */\n-extern void emit_cmp_insn PARAMS ((rtx, rtx, enum rtx_code, rtx,\n-\t\t\t\t   enum machine_mode, int));\n+extern void emit_cmp_insn (rtx, rtx, enum rtx_code, rtx, enum machine_mode,\n+\t\t\t   int);\n \n /* The various uses that a comparison can have; used by can_compare_p:\n    jumps, conditional moves, store flag operations.  */\n@@ -347,30 +347,29 @@ enum can_compare_purpose\n \n /* Nonzero if a compare of mode MODE can be done straightforwardly\n    (without splitting it into pieces).  */\n-extern int can_compare_p PARAMS ((enum rtx_code, enum machine_mode,\n-\t\t\t\t  enum can_compare_purpose));\n+extern int can_compare_p (enum rtx_code, enum machine_mode,\n+\t\t\t  enum can_compare_purpose);\n \n-extern rtx prepare_operand PARAMS ((int, rtx, int, enum machine_mode,\n-\t\t\t\t    enum machine_mode, int));\n+extern rtx prepare_operand (int, rtx, int, enum machine_mode,\n+\t\t\t    enum machine_mode, int);\n \n /* Return the INSN_CODE to use for an extend operation.  */\n-extern enum insn_code can_extend_p PARAMS ((enum machine_mode,\n-\t\t\t\t\t    enum machine_mode, int));\n+extern enum insn_code can_extend_p (enum machine_mode, enum machine_mode, int);\n \n /* Generate the body of an insn to extend Y (with mode MFROM)\n    into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */\n-extern rtx gen_extend_insn PARAMS ((rtx, rtx, enum machine_mode,\n-\t\t\t\t    enum machine_mode, int));\n+extern rtx gen_extend_insn (rtx, rtx, enum machine_mode,\n+\t\t\t    enum machine_mode, int);\n \n /* Initialize the tables that control conversion between fixed and\n    floating values.  */\n-extern void init_fixtab PARAMS ((void));\n-extern void init_floattab PARAMS ((void));\n+extern void init_fixtab (void);\n+extern void init_floattab (void);\n \n /* Generate code for a FLOAT_EXPR.  */\n-extern void expand_float PARAMS ((rtx, rtx, int));\n+extern void expand_float (rtx, rtx, int);\n \n /* Generate code for a FIX_EXPR.  */\n-extern void expand_fix PARAMS ((rtx, rtx, int));\n+extern void expand_fix (rtx, rtx, int);\n \n #endif /* GCC_OPTABS_H */"}, {"sha": "ac24c4b36a67deaf8b99c036a1c93fb2562d4e84", "filename": "gcc/output.h", "status": "modified", "additions": 134, "deletions": 145, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -24,87 +24,87 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define GCC_OUTPUT_H\n \n /* Compute branch alignments based on frequency information in the CFG.  */\n-extern void compute_alignments  PARAMS ((void));\n+extern void compute_alignments (void);\n \n /* Initialize data in final at the beginning of a compilation.  */\n-extern void init_final\t\tPARAMS ((const char *));\n+extern void init_final (const char *);\n \n /* Enable APP processing of subsequent output.\n    Used before the output from an `asm' statement.  */\n-extern void app_enable\t\tPARAMS ((void));\n+extern void app_enable (void);\n \n /* Disable APP processing of subsequent output.\n    Called from varasm.c before most kinds of output.  */\n-extern void app_disable\t\tPARAMS ((void));\n+extern void app_disable (void);\n \n /* Return the number of slots filled in the current\n    delayed branch sequence (we don't count the insn needing the\n    delay slot).   Zero if not in a delayed branch sequence.  */\n-extern int dbr_sequence_length\tPARAMS ((void));\n+extern int dbr_sequence_length (void);\n \n /* Indicate that branch shortening hasn't yet been done.  */\n-extern void init_insn_lengths\tPARAMS ((void));\n+extern void init_insn_lengths (void);\n \n /* Obtain the current length of an insn.  If branch shortening has been done,\n    get its actual length.  Otherwise, get its maximum length.  */\n-extern int get_attr_length\tPARAMS ((rtx));\n+extern int get_attr_length (rtx);\n \n /* Make a pass over all insns and compute their actual lengths by shortening\n    any branches of variable length if possible.  */\n-extern void shorten_branches\tPARAMS ((rtx));\n+extern void shorten_branches (rtx);\n \n /* Output assembler code for the start of a function,\n    and initialize some of the variables in this file\n    for the new function.  The label for the function and associated\n    assembler pseudo-ops have already been output in\n    `assemble_start_function'.  */\n-extern void final_start_function  PARAMS ((rtx, FILE *, int));\n+extern void final_start_function (rtx, FILE *, int);\n \n /* Output assembler code for the end of a function.\n    For clarity, args are same as those of `final_start_function'\n    even though not all of them are needed.  */\n-extern void final_end_function  PARAMS ((void));\n+extern void final_end_function (void);\n \n /* Output assembler code for some insns: all or part of a function.  */\n-extern void final\t\tPARAMS ((rtx, FILE *, int, int));\n+extern void final (rtx, FILE *, int, int);\n \n /* The final scan for one insn, INSN.  Args are same as in `final', except\n    that INSN is the insn being scanned.  Value returned is the next insn to\n    be scanned.  */\n-extern rtx final_scan_insn\tPARAMS ((rtx, FILE *, int, int, int));\n+extern rtx final_scan_insn (rtx, FILE *, int, int, int);\n \n /* Replace a SUBREG with a REG or a MEM, based on the thing it is a\n    subreg of.  */\n-extern rtx alter_subreg PARAMS ((rtx *));\n+extern rtx alter_subreg (rtx *);\n \n /* Report inconsistency between the assembler template and the operands.\n    In an `asm', it's the user's fault; otherwise, the compiler's fault.  */\n-extern void output_operand_lossage  PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+extern void output_operand_lossage (const char *, ...) ATTRIBUTE_PRINTF_1;\n \n /* Output a string of assembler code, substituting insn operands.\n    Defined in final.c.  */\n-extern void output_asm_insn\tPARAMS ((const char *, rtx *));\n+extern void output_asm_insn (const char *, rtx *);\n \n /* Compute a worst-case reference address of a branch so that it\n    can be safely used in the presence of aligned labels.\n    Defined in final.c.  */\n-extern int insn_current_reference_address\tPARAMS ((rtx));\n+extern int insn_current_reference_address (rtx);\n \n /* Find the alignment associated with a CODE_LABEL.\n    Defined in final.c.  */\n-extern int label_to_alignment\tPARAMS ((rtx));\n+extern int label_to_alignment (rtx);\n \n /* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */\n-extern void output_asm_label\tPARAMS ((rtx));\n+extern void output_asm_label (rtx);\n \n /* Print a memory reference operand for address X\n    using machine-dependent assembler syntax.  */\n-extern void output_address\tPARAMS ((rtx));\n+extern void output_address (rtx);\n \n /* Print an integer constant expression in assembler syntax.\n    Addition and subtraction are the only arithmetic\n    that may appear in these expressions.  */\n-extern void output_addr_const PARAMS ((FILE *, rtx));\n+extern void output_addr_const (FILE *, rtx);\n \n /* Output a string of assembler code, substituting numbers, strings\n    and fixed syntactic prefixes.  */\n@@ -118,116 +118,116 @@ typedef HOST_WIDE_INT __gcc_host_wide_int__;\n #define ATTRIBUTE_ASM_FPRINTF(m, n) ATTRIBUTE_NONNULL(m)\n #endif\n \n-extern void asm_fprintf\t\tPARAMS ((FILE *file, const char *p, ...)) ATTRIBUTE_ASM_FPRINTF(2, 3);\n+extern void asm_fprintf (FILE *file, const char *p, ...)\n+     ATTRIBUTE_ASM_FPRINTF(2, 3);\n \n /* Split up a CONST_DOUBLE or integer constant rtx into two rtx's for single\n    words.  */\n-extern void split_double\tPARAMS ((rtx, rtx *, rtx *));\n+extern void split_double (rtx, rtx *, rtx *);\n \n /* Return nonzero if this function has no function calls.  */\n-extern int leaf_function_p\tPARAMS ((void));\n+extern int leaf_function_p (void);\n \n /* Return 1 if branch is a forward branch.\n    Uses insn_shuid array, so it works only in the final pass.  May be used by\n    output templates to add branch prediction hints, for example.  */\n-extern int final_forward_branch_p PARAMS ((rtx));\n+extern int final_forward_branch_p (rtx);\n \n /* Return 1 if this function uses only the registers that can be\n    safely renumbered.  */\n-extern int only_leaf_regs_used\tPARAMS ((void));\n+extern int only_leaf_regs_used (void);\n \n /* Scan IN_RTX and its subexpressions, and renumber all regs into those\n    available in leaf functions.  */\n-extern void leaf_renumber_regs_insn PARAMS ((rtx));\n+extern void leaf_renumber_regs_insn (rtx);\n \n /* Locate the proper template for the given insn-code.  */\n-extern const char *get_insn_template PARAMS ((int, rtx));\n+extern const char *get_insn_template (int, rtx);\n \n /* Add function NAME to the weak symbols list.  VALUE is a weak alias\n    associated with NAME.  */\n-extern int add_weak PARAMS ((tree, const char *, const char *));\n+extern int add_weak (tree, const char *, const char *);\n \n /* Functions in flow.c */\n-extern void allocate_for_life_analysis\tPARAMS ((void));\n-extern int regno_uninitialized\t\tPARAMS ((unsigned int));\n-extern int regno_clobbered_at_setjmp\tPARAMS ((int));\n-extern void find_basic_blocks\t\tPARAMS ((rtx, int, FILE *));\n-extern bool cleanup_cfg\t\t\tPARAMS ((int));\n-extern bool delete_unreachable_blocks\tPARAMS ((void));\n-extern void check_function_return_warnings PARAMS ((void));\n+extern void allocate_for_life_analysis (void);\n+extern int regno_uninitialized (unsigned int);\n+extern int regno_clobbered_at_setjmp (int);\n+extern void find_basic_blocks (rtx, int, FILE *);\n+extern bool cleanup_cfg (int);\n+extern bool delete_unreachable_blocks (void);\n+extern void check_function_return_warnings (void);\n \n /* Functions in varasm.c.  */\n \n /* Tell assembler to switch to text section.  */\n-extern void text_section\t\tPARAMS ((void));\n+extern void text_section (void);\n \n /* Tell assembler to switch to data section.  */\n-extern void data_section\t\tPARAMS ((void));\n+extern void data_section (void);\n \n /* Tell assembler to switch to read-only data section.  This is normally\n    the text section.  */\n-extern void readonly_data_section\tPARAMS ((void));\n+extern void readonly_data_section (void);\n \n /* Determine if we're in the text section.  */\n-extern int in_text_section\t\tPARAMS ((void));\n+extern int in_text_section (void);\n \n #ifdef CTORS_SECTION_ASM_OP\n-extern void ctors_section PARAMS ((void));\n+extern void ctors_section (void);\n #endif\n \n #ifdef DTORS_SECTION_ASM_OP\n-extern void dtors_section PARAMS ((void));\n+extern void dtors_section (void);\n #endif\n \n #ifdef BSS_SECTION_ASM_OP\n-extern void bss_section PARAMS ((void));\n+extern void bss_section (void);\n #endif\n \n #ifdef INIT_SECTION_ASM_OP\n-extern void init_section PARAMS ((void));\n+extern void init_section (void);\n #endif\n \n #ifdef FINI_SECTION_ASM_OP\n-extern void fini_section PARAMS ((void));\n+extern void fini_section (void);\n #endif\n \n #ifdef EXPORTS_SECTION_ASM_OP\n-extern void exports_section PARAMS ((void));\n+extern void exports_section (void);\n #endif\n \n #ifdef DRECTVE_SECTION_ASM_OP\n-extern void drectve_section PARAMS ((void));\n+extern void drectve_section (void);\n #endif\n \n #ifdef SDATA_SECTION_ASM_OP\n-extern void sdata_section PARAMS ((void));\n+extern void sdata_section (void);\n #endif\n \n /* Tell assembler to change to section NAME for DECL.\n    If DECL is NULL, just switch to section NAME.\n    If NAME is NULL, get the name from DECL.\n    If RELOC is 1, the initializer for DECL contains relocs.  */\n-extern void named_section\t\tPARAMS ((tree, const char *, int));\n+extern void named_section (tree, const char *, int);\n \n /* Tell assembler to switch to the section for function DECL.  */\n-extern void function_section\t\tPARAMS ((tree));\n+extern void function_section (tree);\n \n /* Tell assembler to switch to the section for string merging.  */\n-extern void mergeable_string_section\tPARAMS ((tree, unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned int));\n+extern void mergeable_string_section (tree, unsigned HOST_WIDE_INT,\n+\t\t\t\t      unsigned int);\n \n /* Tell assembler to switch to the section for constant merging.  */\n-extern void mergeable_constant_section\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned int));\n+extern void mergeable_constant_section (enum machine_mode,\n+\t\t\t\t\tunsigned HOST_WIDE_INT, unsigned int);\n \n /* Declare DECL to be a weak symbol.  */\n-extern void declare_weak\t\tPARAMS ((tree));\n+extern void declare_weak (tree);\n /* Merge weak status.  */\n-extern void merge_weak\t\t\tPARAMS ((tree, tree));\n+extern void merge_weak (tree, tree);\n \n /* Emit any pending weak declarations.  */\n-extern void weak_finish\t\t\tPARAMS ((void));\n+extern void weak_finish (void);\n \n /* Decode an `asm' spec for a declaration as a register name.\n    Return the register number, or -1 if nothing specified,\n@@ -236,29 +236,29 @@ extern void weak_finish\t\t\tPARAMS ((void));\n    or -4 if ASMSPEC is `memory' and is not recognized.\n    Accept an exact spelling or a decimal number.\n    Prefixes such as % are optional.  */\n-extern int decode_reg_name\t\tPARAMS ((const char *));\n+extern int decode_reg_name (const char *);\n \n /* Make the rtl for variable VAR be volatile.\n    Use this only for static variables.  */\n-extern void make_var_volatile\t\tPARAMS ((tree));\n+extern void make_var_volatile (tree);\n \n-extern void assemble_alias\t\tPARAMS ((tree, tree));\n+extern void assemble_alias (tree, tree);\n \n-extern void default_assemble_visibility\tPARAMS ((tree, int));\n+extern void default_assemble_visibility (tree, int);\n \n /* Output a string of literal assembler code\n    for an `asm' keyword used between functions.  */\n-extern void assemble_asm\t\tPARAMS ((tree));\n+extern void assemble_asm (tree);\n \n /* Output assembler code for the constant pool of a function and associated\n    with defining the name of the function.  DECL describes the function.\n    NAME is the function's name.  For the constant pool, we use the current\n    constant pool data.  */\n-extern void assemble_start_function\tPARAMS ((tree, const char *));\n+extern void assemble_start_function (tree, const char *);\n \n /* Output assembler code associated with defining the size of the\n    function.  DECL describes the function.  NAME is the function's name.  */\n-extern void assemble_end_function\tPARAMS ((tree, const char *));\n+extern void assemble_end_function (tree, const char *);\n \n /* Assemble everything that is needed for a variable or function declaration.\n    Not used for automatic variables, and not used for function definitions.\n@@ -269,36 +269,36 @@ extern void assemble_end_function\tPARAMS ((tree, const char *));\n    to define things that have had only tentative definitions.\n    DONT_OUTPUT_DATA if nonzero means don't actually output the\n    initial value (that will be done by the caller).  */\n-extern void assemble_variable\t\tPARAMS ((tree, int, int, int));\n+extern void assemble_variable (tree, int, int, int);\n \n /* Output something to declare an external symbol to the assembler.\n    (Most assemblers don't need this, so we normally output nothing.)\n    Do nothing if DECL is not external.  */\n-extern void assemble_external\t\tPARAMS ((tree));\n+extern void assemble_external (tree);\n \n /* Assemble code to leave SIZE bytes of zeros.  */\n-extern void assemble_zeros\t\tPARAMS ((unsigned HOST_WIDE_INT));\n+extern void assemble_zeros (unsigned HOST_WIDE_INT);\n \n /* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */\n-extern void assemble_align\t\tPARAMS ((int));\n-extern void assemble_eh_align\t\tPARAMS ((int));\n+extern void assemble_align (int);\n+extern void assemble_eh_align (int);\n \n /* Assemble a string constant with the specified C string as contents.  */\n-extern void assemble_string\t\tPARAMS ((const char *, int));\n+extern void assemble_string (const char *, int);\n \n /* Similar, for calling a library function FUN.  */\n-extern void assemble_external_libcall\tPARAMS ((rtx));\n+extern void assemble_external_libcall (rtx);\n \n /* Assemble a label named NAME.  */\n-extern void assemble_label\t\tPARAMS ((const char *));\n-extern void assemble_eh_label\t\tPARAMS ((const char *));\n+extern void assemble_label (const char *);\n+extern void assemble_eh_label (const char *);\n \n /* Output to FILE a reference to the assembler name of a C-level name NAME.\n    If NAME starts with a *, the rest of NAME is output verbatim.\n    Otherwise NAME is transformed in an implementation-defined way\n    (usually by the addition of an underscore).\n    Many macros in the tm file are defined to call this function.  */\n-extern void assemble_name\t\tPARAMS ((FILE *, const char *));\n+extern void assemble_name (FILE *, const char *);\n \n /* Return the assembler directive for creating a given kind of integer\n    object.  SIZE is the number of bytes in the object and ALIGNED_P\n@@ -307,20 +307,20 @@ extern void assemble_name\t\tPARAMS ((FILE *, const char *));\n \n    The returned string should be printed at the start of a new line and\n    be followed immediately by the object's initial value.  */\n-extern const char *integer_asm_op\tPARAMS ((int, int));\n+extern const char *integer_asm_op (int, int);\n \n /* Use directive OP to assemble an integer object X.  Print OP at the\n    start of the line, followed immediately by the value of X.  */\n-extern void assemble_integer_with_op\tPARAMS ((const char *, rtx));\n+extern void assemble_integer_with_op (const char *, rtx);\n \n /* The default implementation of the asm_out.integer target hook.  */\n-extern bool default_assemble_integer\tPARAMS ((rtx, unsigned int, int));\n+extern bool default_assemble_integer (rtx, unsigned int, int);\n \n /* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is\n    the alignment of the integer in bits.  Return 1 if we were able to output\n    the constant, otherwise 0.  If FORCE is nonzero, abort if we can't output\n    the constant.  */\n-extern bool assemble_integer\t\tPARAMS ((rtx, unsigned, unsigned, int));\n+extern bool assemble_integer (rtx, unsigned, unsigned, int);\n \n /* An interface to assemble_integer for the common case in which a value is\n    fully aligned and must be printed.  VALUE is the value of the integer\n@@ -330,20 +330,18 @@ extern bool assemble_integer\t\tPARAMS ((rtx, unsigned, unsigned, int));\n \n #ifdef REAL_VALUE_TYPE_SIZE\n /* Assemble the floating-point constant D into an object of size MODE.  */\n-extern void assemble_real\t\tPARAMS ((REAL_VALUE_TYPE,\n-\t\t\t\t\t         enum machine_mode,\n-\t\t\t\t\t\t unsigned));\n+extern void assemble_real (REAL_VALUE_TYPE, enum machine_mode, unsigned);\n #endif\n \n /* Return the size of the constant pool.  */\n-extern int get_pool_size\t\tPARAMS ((void));\n+extern int get_pool_size (void);\n \n #ifdef HAVE_peephole\n-extern rtx peephole\t\t\tPARAMS ((rtx));\n+extern rtx peephole (rtx);\n #endif\n \n /* Write all the constants in the constant pool.  */\n-extern void output_constant_pool\tPARAMS ((const char *, tree));\n+extern void output_constant_pool (const char *, tree);\n \n /* Return nonzero if VALUE is a valid constant-valued expression\n    for use in initializing a static variable; one that can be an\n@@ -354,7 +352,7 @@ extern void output_constant_pool\tPARAMS ((const char *, tree));\n    We assume that VALUE has been folded as much as possible;\n    therefore, we do not need to check for such things as\n    arithmetic-combinations of integers.  */\n-extern tree initializer_constant_valid_p\tPARAMS ((tree, tree));\n+extern tree initializer_constant_valid_p (tree, tree);\n \n /* Output assembler code for constant EXP to FILE, with no label.\n    This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n@@ -364,8 +362,7 @@ extern tree initializer_constant_valid_p\tPARAMS ((tree, tree));\n    with zeros if necessary.  SIZE must always be specified.\n \n    ALIGN is the alignment in bits that may be assumed for the data.  */\n-extern void output_constant\t\tPARAMS ((tree, unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned int));\n+extern void output_constant (tree, unsigned HOST_WIDE_INT, unsigned int);\n \n /* When outputting delayed branch sequences, this rtx holds the\n    sequence being output.  It is null when no delayed branch\n@@ -437,23 +434,23 @@ extern rtx this_is_asm_operands;\n \n /* Decide whether DECL needs to be in a writable section.\n    RELOC is the same as for SELECT_SECTION.  */\n-extern bool decl_readonly_section PARAMS ((tree, int));\n-extern bool decl_readonly_section_1 PARAMS ((tree, int, int));\n+extern bool decl_readonly_section (tree, int);\n+extern bool decl_readonly_section_1 (tree, int, int);\n \n /* User label prefix in effect for this compilation.  */\n extern const char *user_label_prefix;\n \n /* Default target function prologue and epilogue assembler output.  */\n-extern void default_function_pro_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+extern void default_function_pro_epilogue (FILE *, HOST_WIDE_INT);\n \n /* Tell assembler to switch to the section for the exception table.  */\n-extern void default_exception_section\tPARAMS ((void));\n+extern void default_exception_section (void);\n \n /* Tell assembler to switch to the section for the EH frames.  */\n-extern void default_eh_frame_section\tPARAMS ((void));\n+extern void default_eh_frame_section (void);\n \n /* Default target hook that outputs nothing to a stream.  */\n-extern void no_asm_to_stream PARAMS ((FILE *));\n+extern void no_asm_to_stream (FILE *);\n \n /* Flags controlling properties of a section.  */\n #define SECTION_ENTSIZE\t 0x000ff\t/* entity size in section */\n@@ -472,62 +469,54 @@ extern void no_asm_to_stream PARAMS ((FILE *));\n #define SECTION_NOTYPE\t 0x80000\t/* don't output @progbits */\n #define SECTION_MACH_DEP 0x100000\t/* subsequent bits reserved for target */\n \n-extern unsigned int get_named_section_flags PARAMS ((const char *));\n-extern bool set_named_section_flags\tPARAMS ((const char *, unsigned int));\n-extern void named_section_flags\t\tPARAMS ((const char *, unsigned int));\n-extern bool named_section_first_declaration PARAMS((const char *));\n+extern unsigned int get_named_section_flags (const char *);\n+extern bool set_named_section_flags (const char *, unsigned int);\n+extern void named_section_flags (const char *, unsigned int);\n+extern bool named_section_first_declaration (const char *);\n \n union tree_node;\n-extern unsigned int default_section_type_flags PARAMS ((union tree_node *,\n-\t\t\t\t\t\t\tconst char *, int));\n-extern unsigned int default_section_type_flags_1 PARAMS ((union tree_node *,\n-\t\t\t\t\t\t\t  const char *,\n-\t\t\t\t\t\t\t  int, int));\n-\n-extern void default_no_named_section PARAMS ((const char *, unsigned int));\n-extern void default_elf_asm_named_section PARAMS ((const char *, unsigned int));\n-extern void default_coff_asm_named_section PARAMS ((const char *,\n-\t\t\t\t\t\t    unsigned int));\n-extern void default_pe_asm_named_section PARAMS ((const char *, unsigned int));\n-\n-extern void default_stabs_asm_out_destructor PARAMS ((struct rtx_def *, int));\n-extern void default_named_section_asm_out_destructor PARAMS ((struct rtx_def *,\n-\t\t\t\t\t\t\t      int));\n-extern void default_dtor_section_asm_out_destructor PARAMS ((struct rtx_def *,\n-\t\t\t\t\t\t\t     int));\n-extern void default_stabs_asm_out_constructor PARAMS ((struct rtx_def *, int));\n-extern void default_named_section_asm_out_constructor PARAMS ((struct rtx_def *,\n-\t\t\t\t\t\t\t       int));\n-extern void default_ctor_section_asm_out_constructor PARAMS ((struct rtx_def *,\n-\t\t\t\t\t\t\t      int));\n-\n-extern void default_select_section PARAMS ((tree, int,\n-\t\t\t\t\t    unsigned HOST_WIDE_INT));\n-extern void default_elf_select_section PARAMS ((tree, int,\n-\t\t\t\t\t\tunsigned HOST_WIDE_INT));\n-extern void default_elf_select_section_1 PARAMS ((tree, int,\n-\t\t\t\t\t\t  unsigned HOST_WIDE_INT, int));\n-extern void default_unique_section PARAMS ((tree, int));\n-extern void default_unique_section_1 PARAMS ((tree, int, int));\n-extern void default_select_rtx_section PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t\tunsigned HOST_WIDE_INT));\n-extern void default_elf_select_rtx_section PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t\t    unsigned HOST_WIDE_INT));\n-extern void default_encode_section_info PARAMS ((tree, rtx, int));\n-extern const char *default_strip_name_encoding PARAMS ((const char *));\n-extern bool default_binds_local_p PARAMS ((tree));\n-extern bool default_binds_local_p_1 PARAMS ((tree, int));\n-extern void default_globalize_label PARAMS ((FILE *, const char *));\n-extern void default_internal_label PARAMS ((FILE *, const char *, unsigned long));\n-extern void default_file_start PARAMS ((void));\n-extern void file_end_indicate_exec_stack PARAMS ((void));\n-extern bool default_valid_pointer_mode PARAMS ((enum machine_mode));\n+extern unsigned int default_section_type_flags (union tree_node *,\n+\t\t\t\t\t\tconst char *, int);\n+extern unsigned int default_section_type_flags_1 (union tree_node *,\n+\t\t\t\t\t\t  const char *, int, int);\n+\n+extern void default_no_named_section (const char *, unsigned int);\n+extern void default_elf_asm_named_section (const char *, unsigned int);\n+extern void default_coff_asm_named_section (const char *, unsigned int);\n+extern void default_pe_asm_named_section (const char *, unsigned int);\n+\n+extern void default_stabs_asm_out_destructor (struct rtx_def *, int);\n+extern void default_named_section_asm_out_destructor (struct rtx_def *, int);\n+extern void default_dtor_section_asm_out_destructor (struct rtx_def *, int);\n+extern void default_stabs_asm_out_constructor (struct rtx_def *, int);\n+extern void default_named_section_asm_out_constructor (struct rtx_def *,\n+\t\t\t\t\t\t       int);\n+extern void default_ctor_section_asm_out_constructor (struct rtx_def *, int);\n+\n+extern void default_select_section (tree, int, unsigned HOST_WIDE_INT);\n+extern void default_elf_select_section (tree, int, unsigned HOST_WIDE_INT);\n+extern void default_elf_select_section_1 (tree, int,\n+\t\t\t\t\t  unsigned HOST_WIDE_INT, int);\n+extern void default_unique_section (tree, int);\n+extern void default_unique_section_1 (tree, int, int);\n+extern void default_select_rtx_section (enum machine_mode, rtx,\n+\t\t\t\t\tunsigned HOST_WIDE_INT);\n+extern void default_elf_select_rtx_section (enum machine_mode, rtx,\n+\t\t\t\t\t    unsigned HOST_WIDE_INT);\n+extern void default_encode_section_info (tree, rtx, int);\n+extern const char *default_strip_name_encoding (const char *);\n+extern bool default_binds_local_p (tree);\n+extern bool default_binds_local_p_1 (tree, int);\n+extern void default_globalize_label (FILE *, const char *);\n+extern void default_internal_label (FILE *, const char *, unsigned long);\n+extern void default_file_start (void);\n+extern void file_end_indicate_exec_stack (void);\n+extern bool default_valid_pointer_mode (enum machine_mode);\n \n /* Emit data for vtable gc for GNU binutils.  */\n-extern void assemble_vtable_entry PARAMS ((struct rtx_def *, HOST_WIDE_INT));\n-extern void assemble_vtable_inherit PARAMS ((struct rtx_def *,\n-\t\t\t\t\t     struct rtx_def *));\n+extern void assemble_vtable_entry (struct rtx_def *, HOST_WIDE_INT);\n+extern void assemble_vtable_inherit (struct rtx_def *, struct rtx_def *);\n \n-extern int default_address_cost PARAMS ((rtx));\n+extern int default_address_cost (rtx);\n \n #endif /* ! GCC_OUTPUT_H */"}, {"sha": "9c459c5b463512ff244c23d8b5675b603d175c97", "filename": "gcc/postreload.c", "status": "modified", "additions": 21, "deletions": 36, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -45,24 +45,23 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"except.h\"\n #include \"tree.h\"\n \n-static int reload_cse_noop_set_p\tPARAMS ((rtx));\n-static void reload_cse_simplify\t\tPARAMS ((rtx, rtx));\n-static void reload_cse_regs_1\t\tPARAMS ((rtx));\n-static int reload_cse_simplify_set\tPARAMS ((rtx, rtx));\n-static int reload_cse_simplify_operands\tPARAMS ((rtx, rtx));\n+static int reload_cse_noop_set_p (rtx);\n+static void reload_cse_simplify (rtx, rtx);\n+static void reload_cse_regs_1 (rtx);\n+static int reload_cse_simplify_set (rtx, rtx);\n+static int reload_cse_simplify_operands (rtx, rtx);\n \n-static void reload_combine\t\tPARAMS ((void));\n-static void reload_combine_note_use\tPARAMS ((rtx *, rtx));\n-static void reload_combine_note_store\tPARAMS ((rtx, rtx, void *));\n+static void reload_combine (void);\n+static void reload_combine_note_use (rtx *, rtx);\n+static void reload_combine_note_store (rtx, rtx, void *);\n \n-static void reload_cse_move2add\t\tPARAMS ((rtx));\n-static void move2add_note_store\t\tPARAMS ((rtx, rtx, void *));\n+static void reload_cse_move2add (rtx);\n+static void move2add_note_store (rtx, rtx, void *);\n \n /* Call cse / combine like post-reload optimization phases.\n    FIRST is the first instruction.  */\n void\n-reload_cse_regs (first)\n-     rtx first ATTRIBUTE_UNUSED;\n+reload_cse_regs (rtx first ATTRIBUTE_UNUSED)\n {\n   reload_cse_regs_1 (first);\n   reload_combine ();\n@@ -73,8 +72,7 @@ reload_cse_regs (first)\n \n /* See whether a single set SET is a noop.  */\n static int\n-reload_cse_noop_set_p (set)\n-     rtx set;\n+reload_cse_noop_set_p (rtx set)\n {\n   if (cselib_reg_set_mode (SET_DEST (set)) != GET_MODE (SET_DEST (set)))\n     return 0;\n@@ -84,9 +82,7 @@ reload_cse_noop_set_p (set)\n \n /* Try to simplify INSN.  */\n static void\n-reload_cse_simplify (insn, testreg)\n-     rtx insn;\n-     rtx testreg;\n+reload_cse_simplify (rtx insn, rtx testreg)\n {\n   rtx body = PATTERN (insn);\n \n@@ -180,8 +176,7 @@ reload_cse_simplify (insn, testreg)\n    if possible, much like an optional reload would.  */\n \n static void\n-reload_cse_regs_1 (first)\n-     rtx first;\n+reload_cse_regs_1 (rtx first)\n {\n   rtx insn;\n   rtx testreg = gen_rtx_REG (VOIDmode, -1);\n@@ -209,9 +204,7 @@ reload_cse_regs_1 (first)\n    and change the set into a register copy.  */\n \n static int\n-reload_cse_simplify_set (set, insn)\n-     rtx set;\n-     rtx insn;\n+reload_cse_simplify_set (rtx set, rtx insn)\n {\n   int did_change = 0;\n   int dreg;\n@@ -354,9 +347,7 @@ reload_cse_simplify_set (set, insn)\n    hard registers.  */\n \n static int\n-reload_cse_simplify_operands (insn, testreg)\n-     rtx insn;\n-     rtx testreg;\n+reload_cse_simplify_operands (rtx insn, rtx testreg)\n {\n   int i, j;\n \n@@ -629,7 +620,7 @@ static int reload_combine_ruid;\n   (label_live[CODE_LABEL_NUMBER (LABEL) - min_labelno])\n \n static void\n-reload_combine ()\n+reload_combine (void)\n {\n   rtx insn, set;\n   int first_index_reg = -1;\n@@ -922,9 +913,7 @@ reload_combine ()\n    accordingly.  Called via note_stores from reload_combine.  */\n \n static void\n-reload_combine_note_store (dst, set, data)\n-     rtx dst, set;\n-     void *data ATTRIBUTE_UNUSED;\n+reload_combine_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n {\n   int regno = 0;\n   int i;\n@@ -972,8 +961,7 @@ reload_combine_note_store (dst, set, data)\n    *XP is the pattern of INSN, or a part of it.\n    Called from reload_combine, and recursively by itself.  */\n static void\n-reload_combine_note_use (xp, insn)\n-     rtx *xp, insn;\n+reload_combine_note_use (rtx *xp, rtx insn)\n {\n   rtx x = *xp;\n   enum rtx_code code = x->code;\n@@ -1131,8 +1119,7 @@ static int move2add_last_label_luid;\n \t\t\t\t GET_MODE_BITSIZE (INMODE))))\n \n static void\n-reload_cse_move2add (first)\n-     rtx first;\n+reload_cse_move2add (rtx first)\n {\n   int i;\n   rtx insn;\n@@ -1374,9 +1361,7 @@ reload_cse_move2add (first)\n    Called from reload_cse_move2add via note_stores.  */\n \n static void\n-move2add_note_store (dst, set, data)\n-     rtx dst, set;\n-     void *data ATTRIBUTE_UNUSED;\n+move2add_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n {\n   unsigned int regno = 0;\n   unsigned int i;"}, {"sha": "ef9d9b8da92397c5e4c44507d90e68c71cb7d382", "filename": "gcc/prefix.c", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fprefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fprefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Utility to update paths from internal to external forms.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -76,21 +76,20 @@ Boston, MA 02111-1307, USA.  */\n \n static const char *std_prefix = PREFIX;\n \n-static const char *get_key_value\tPARAMS ((char *));\n-static char *translate_name\t\tPARAMS ((char *));\n-static char *save_string\t\tPARAMS ((const char *, int));\n-static void tr\t\t\t\tPARAMS ((char *, int, int));\n+static const char *get_key_value (char *);\n+static char *translate_name (char *);\n+static char *save_string (const char *, int);\n+static void tr (char *, int, int);\n \n #if defined(_WIN32) && defined(ENABLE_WIN32_REGISTRY)\n-static char *lookup_key\t\tPARAMS ((char *));\n+static char *lookup_key (char *);\n static HKEY reg_key = (HKEY) INVALID_HANDLE_VALUE;\n #endif\n \n /* Given KEY, as above, return its value.  */\n \n static const char *\n-get_key_value (key)\n-     char *key;\n+get_key_value (char *key)\n {\n   const char *prefix = 0;\n   char *temp = 0;\n@@ -114,9 +113,7 @@ get_key_value (key)\n /* Return a copy of a string that has been placed in the heap.  */\n \n static char *\n-save_string (s, len)\n-  const char *s;\n-  int len;\n+save_string (const char *s, int len)\n {\n   char *result = xmalloc (len + 1);\n \n@@ -130,8 +127,7 @@ save_string (s, len)\n /* Look up \"key\" in the registry, as above.  */\n \n static char *\n-lookup_key (key)\n-     char *key;\n+lookup_key (char *key)\n {\n   char *dst;\n   DWORD size;\n@@ -183,8 +179,7 @@ lookup_key (key)\n    Otherwise, return the given name.  */\n \n static char *\n-translate_name (name)\n-     char *name;\n+translate_name (char *name)\n {\n   char code;\n   char *key, *old_name;\n@@ -233,9 +228,7 @@ translate_name (name)\n \n /* In a NUL-terminated STRING, replace character C1 with C2 in-place.  */\n static void\n-tr (string, c1, c2)\n-     char *string;\n-     int c1, c2;\n+tr (char *string, int c1, int c2)\n {\n   do\n     {\n@@ -250,9 +243,7 @@ tr (string, c1, c2)\n    freeing it.  */\n \n char *\n-update_path (path, key)\n-  const char *path;\n-  const char *key;\n+update_path (const char *path, const char *key)\n {\n   char *result, *p;\n \n@@ -352,9 +343,7 @@ update_path (path, key)\n \n /* Reset the standard prefix.  */\n void\n-set_std_prefix (prefix, len)\n-  const char *prefix;\n-  int len;\n+set_std_prefix (const char *prefix, int len)\n {\n   std_prefix = save_string (prefix, len);\n }"}, {"sha": "25f2115962b899c3fcd3f7d7d78298f9a5b2bbfa", "filename": "gcc/prefix.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fprefix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fprefix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Provide prototypes for functions exported from prefix.c.\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -25,7 +25,7 @@ Boston, MA 02111-1307, USA.  */\n /* Update PATH using KEY if PATH starts with PREFIX.  The returned\n    string is always malloc-ed, and the caller is responsible for\n    freeing it.  */\n-extern char *update_path PARAMS ((const char *path, const char *key));\n-extern void set_std_prefix PARAMS ((const char *, int));\n+extern char *update_path (const char *path, const char *key);\n+extern void set_std_prefix (const char *, int);\n \n #endif /* ! GCC_PREFIX_H */"}, {"sha": "ebc0eaeba1b1c32e993951ab444b3e4e12dacfbd", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -58,7 +58,7 @@ static int sawclose = 0;\n \n static int indent;\n \n-static void print_rtx\t\tPARAMS ((rtx));\n+static void print_rtx (rtx);\n \n /* String printed at beginning of each RTL when it is dumped.\n    This string is set to ASM_COMMENT_START when the RTL is dumped in\n@@ -80,9 +80,7 @@ int dump_for_graph;\n static int debug_call_placeholder_verbose;\n \n void\n-print_mem_expr (outfile, expr)\n-     FILE *outfile;\n-     tree expr;\n+print_mem_expr (FILE *outfile, tree expr)\n {\n   if (TREE_CODE (expr) == COMPONENT_REF)\n     {\n@@ -111,8 +109,7 @@ print_mem_expr (outfile, expr)\n /* Print IN_RTX onto OUTFILE.  This is the recursive part of printing.  */\n \n static void\n-print_rtx (in_rtx)\n-     rtx in_rtx;\n+print_rtx (rtx in_rtx)\n {\n   int i = 0;\n   int j;\n@@ -638,10 +635,7 @@ print_rtx (in_rtx)\n    characters.  */\n \n void\n-print_inline_rtx (outf, x, ind)\n-     FILE *outf;\n-     rtx x;\n-     int ind;\n+print_inline_rtx (FILE *outf, rtx x, int ind)\n {\n   int oldsaw = sawclose;\n   int oldindent = indent;\n@@ -657,8 +651,7 @@ print_inline_rtx (outf, x, ind)\n /* Call this function from the debugger to see what X looks like.  */\n \n void\n-debug_rtx (x)\n-     rtx x;\n+debug_rtx (rtx x)\n {\n   outfile = stderr;\n   sawclose = 0;\n@@ -678,9 +671,7 @@ int debug_rtx_count = 0;\t/* 0 is treated as equivalent to 1 */\n    EG: -5 prints 2 rtx's on either side (in addition to the specified rtx).  */\n \n void\n-debug_rtx_list (x, n)\n-     rtx x;\n-     int n;\n+debug_rtx_list (rtx x, int n)\n {\n   int i,count;\n   rtx insn;\n@@ -707,8 +698,7 @@ debug_rtx_list (x, n)\n /* Call this function to print an rtx list from START to END inclusive.  */\n \n void\n-debug_rtx_range (start, end)\n-     rtx start, end;\n+debug_rtx_range (rtx start, rtx end)\n {\n   while (1)\n     {\n@@ -725,9 +715,7 @@ debug_rtx_range (start, end)\n    The found insn is returned to enable further debugging analysis.  */\n \n rtx\n-debug_rtx_find (x, uid)\n-     rtx x;\n-     int uid;\n+debug_rtx_find (rtx x, int uid)\n {\n   while (x != 0 && INSN_UID (x) != uid)\n     x = NEXT_INSN (x);\n@@ -750,9 +738,7 @@ debug_rtx_find (x, uid)\n    If RTX_FIRST is not an insn, then it alone is printed, with no newline.  */\n \n void\n-print_rtl (outf, rtx_first)\n-     FILE *outf;\n-     rtx rtx_first;\n+print_rtl (FILE *outf, rtx rtx_first)\n {\n   rtx tmp_rtx;\n \n@@ -793,9 +779,7 @@ print_rtl (outf, rtx_first)\n /* Return nonzero if we actually printed anything.  */\n \n int\n-print_rtl_single (outf, x)\n-     FILE *outf;\n-     rtx x;\n+print_rtl_single (FILE *outf, rtx x)\n {\n   outfile = outf;\n   sawclose = 0;\n@@ -815,9 +799,7 @@ print_rtl_single (outf, x)\n    if RTX is a CONST_INT then print in decimal format.  */\n \n void\n-print_simple_rtl (outf, x)\n-     FILE *outf;\n-     rtx x;\n+print_simple_rtl (FILE *outf, rtx x)\n {\n   flag_simple = 1;\n   print_rtl (outf, x);"}, {"sha": "88bbc34092fc147a643b07f29d85513f663caf8f", "filename": "gcc/print-tree.c", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -47,8 +47,7 @@ static struct bucket **table;\n    down to a depth of six.  */\n \n void\n-debug_tree (node)\n-     tree node;\n+debug_tree (tree node)\n {\n   table = (struct bucket **) xcalloc (HASH_SIZE, sizeof (struct bucket *));\n   print_node (stderr, \"\", node, 0);\n@@ -60,11 +59,7 @@ debug_tree (node)\n /* Print a node in brief fashion, with just the code, address and name.  */\n \n void\n-print_node_brief (file, prefix, node, indent)\n-     FILE *file;\n-     const char *prefix;\n-     tree node;\n-     int indent;\n+print_node_brief (FILE *file, const char *prefix, tree node, int indent)\n {\n   char class;\n \n@@ -141,9 +136,7 @@ print_node_brief (file, prefix, node, indent)\n }\n \n void\n-indent_to (file, column)\n-     FILE *file;\n-     int column;\n+indent_to (FILE *file, int column)\n {\n   int i;\n \n@@ -158,11 +151,7 @@ indent_to (file, column)\n    starting in column INDENT.  */\n \n void\n-print_node (file, prefix, node, indent)\n-     FILE *file;\n-     const char *prefix;\n-     tree node;\n-     int indent;\n+print_node (FILE *file, const char *prefix, tree node, int indent)\n {\n   int hash;\n   struct bucket *b;"}, {"sha": "dd23628c70875de93d5f3ca73f851d37fe92d3dc", "filename": "gcc/profile.c", "status": "modified", "additions": 54, "deletions": 57, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -66,10 +66,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Additional information about the edges we need.  */\n struct edge_info {\n   unsigned int count_valid : 1;\n-  \n+\n   /* Is on the spanning tree.  */\n   unsigned int on_tree : 1;\n-  \n+\n   /* Pretend this edge does not exist (it is abnormal and we've\n      inserted a fake to compensate).  */\n   unsigned int ignore : 1;\n@@ -105,18 +105,21 @@ static int total_num_never_executed;\n static int total_num_branches;\n \n /* Forward declarations.  */\n-static void find_spanning_tree PARAMS ((struct edge_list *));\n-static rtx gen_edge_profiler PARAMS ((int));\n-static rtx gen_interval_profiler (struct histogram_value *, unsigned, unsigned);\n+static void find_spanning_tree (struct edge_list *);\n+static rtx gen_edge_profiler (int);\n+static rtx gen_interval_profiler (struct histogram_value *, unsigned,\n+\t\t\t\t  unsigned);\n static rtx gen_pow2_profiler (struct histogram_value *, unsigned, unsigned);\n-static rtx gen_one_value_profiler (struct histogram_value *, unsigned, unsigned);\n-static rtx gen_const_delta_profiler (struct histogram_value *, unsigned, unsigned);\n-static unsigned instrument_edges PARAMS ((struct edge_list *));\n+static rtx gen_one_value_profiler (struct histogram_value *, unsigned,\n+\t\t\t\t   unsigned);\n+static rtx gen_const_delta_profiler (struct histogram_value *, unsigned,\n+\t\t\t\t     unsigned);\n+static unsigned instrument_edges (struct edge_list *);\n static void instrument_values (unsigned, struct histogram_value *);\n-static void compute_branch_probabilities PARAMS ((void));\n-static gcov_type * get_exec_counts PARAMS ((void));\n-static basic_block find_group PARAMS ((basic_block));\n-static void union_groups PARAMS ((basic_block, basic_block));\n+static void compute_branch_probabilities (void);\n+static gcov_type * get_exec_counts (void);\n+static basic_block find_group (basic_block);\n+static void union_groups (basic_block, basic_block);\n \n \f\n /* Add edge instrumentation code to the entire insn chain.\n@@ -125,13 +128,12 @@ static void union_groups PARAMS ((basic_block, basic_block));\n    NUM_BLOCKS is the number of basic blocks found in F.  */\n \n static unsigned\n-instrument_edges (el)\n-     struct edge_list *el;\n+instrument_edges (struct edge_list *el)\n {\n   unsigned num_instr_edges = 0;\n   int num_edges = NUM_EDGES (el);\n   basic_block bb;\n-  \n+\n   remove_fake_edges ();\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n@@ -141,11 +143,11 @@ instrument_edges (el)\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  struct edge_info *inf = EDGE_INFO (e);\n-\t  \n+\n \t  if (!inf->ignore && !inf->on_tree)\n \t    {\n \t      rtx edge_profile;\n-\t      \n+\n \t      if (e->flags & EDGE_ABNORMAL)\n \t\tabort ();\n \t      if (rtl_dump_file)\n@@ -172,7 +174,7 @@ instrument_values (unsigned n_values, struct histogram_value *values)\n   rtx sequence;\n   unsigned i, t;\n   edge e;\n- \n+\n   /* Emit code to generate the histograms before the insns.  */\n \n   for (i = 0; i < n_values; i++)\n@@ -233,12 +235,12 @@ instrument_values (unsigned n_values, struct histogram_value *values)\n /* Computes hybrid profile for all matching entries in da_file.  */\n \n static gcov_type *\n-get_exec_counts ()\n+get_exec_counts (void)\n {\n   unsigned num_edges = 0;\n   basic_block bb;\n   gcov_type *counts;\n-  \n+\n   /* Count the edges to be (possibly) instrumented.  */\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n@@ -264,7 +266,7 @@ get_exec_counts ()\n    Annotate them accordingly.  */\n \n static void\n-compute_branch_probabilities ()\n+compute_branch_probabilities (void)\n {\n   basic_block bb;\n   int i;\n@@ -616,7 +618,7 @@ compute_branch_probabilities ()\n    Main entry point of this file.  */\n \n void\n-branch_prob ()\n+branch_prob (void)\n {\n   basic_block bb;\n   unsigned i;\n@@ -716,7 +718,7 @@ branch_prob ()\n      as possible to minimize number of edge splits necessary.  */\n \n   find_spanning_tree (el);\n-  \n+\n   /* Fake edges that are not on the tree will not be instrumented, so\n      mark them ignored.  */\n   for (num_instrumented = i = 0; i < num_edges; i++)\n@@ -754,7 +756,7 @@ branch_prob ()\n   if (coverage_begin_output ())\n     {\n       gcov_position_t offset;\n-      \n+\n       offset = gcov_write_tag (GCOV_TAG_BLOCKS);\n       for (i = 0; i != (unsigned) (n_basic_blocks + 2); i++)\n \tgcov_write_unsigned (0);\n@@ -767,7 +769,7 @@ branch_prob ()\n   ENTRY_BLOCK_PTR->index = -1;\n   EXIT_BLOCK_PTR->index = last_basic_block;\n #define BB_TO_GCOV_INDEX(bb)  ((bb)->index + 1)\n-  \n+\n   /* Arcs */\n   if (coverage_begin_output ())\n     {\n@@ -779,14 +781,14 @@ branch_prob ()\n \n \t  offset = gcov_write_tag (GCOV_TAG_ARCS);\n \t  gcov_write_unsigned (BB_TO_GCOV_INDEX (bb));\n-\t  \n+\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    {\n \t      struct edge_info *i = EDGE_INFO (e);\n \t      if (!i->ignore)\n \t\t{\n \t\t  unsigned flag_bits = 0;\n-\t\t  \n+\n \t\t  if (i->on_tree)\n \t\t    flag_bits |= GCOV_ARC_ON_TREE;\n \t\t  if (e->flags & EDGE_FAKE)\n@@ -802,28 +804,28 @@ branch_prob ()\n \t  gcov_write_length (offset);\n \t}\n     }\n-  \n+\n   /* Line numbers.  */\n   if (coverage_begin_output ())\n     {\n       char const *prev_file_name = NULL;\n       gcov_position_t offset;\n-      \n+\n       FOR_EACH_BB (bb)\n \t{\n \t  rtx insn = bb->head;\n \t  int ignore_next_note = 0;\n-\t  \n+\n \t  offset = 0;\n-\t  \n+\n \t  /* We are looking for line number notes.  Search backward\n \t     before basic block to find correct ones.  */\n \t  insn = prev_nonnote_insn (insn);\n \t  if (!insn)\n \t    insn = get_insns ();\n \t  else\n \t    insn = NEXT_INSN (insn);\n-\t  \n+\n \t  while (insn != bb->end)\n \t    {\n \t      if (GET_CODE (insn) == NOTE)\n@@ -846,7 +848,7 @@ branch_prob ()\n \t\t\t  offset = gcov_write_tag (GCOV_TAG_LINES);\n \t\t\t  gcov_write_unsigned (BB_TO_GCOV_INDEX (bb));\n \t\t\t}\n-\t\t      \n+\n \t\t      /* If this is a new source file, then output the\n \t\t\t file's name to the .bb file.  */\n \t\t      if (!prev_file_name\n@@ -862,7 +864,7 @@ branch_prob ()\n \t\t}\n \t      insn = NEXT_INSN (insn);\n \t    }\n-\t  \n+\n \t  if (offset)\n \t    {\n \t      /* A file of NULL indicates the end of run.  */\n@@ -920,8 +922,7 @@ branch_prob ()\n    aux fields.  */\n \n static basic_block\n-find_group (bb)\n-     basic_block bb;\n+find_group (basic_block bb)\n {\n   basic_block group = bb, bb1;\n \n@@ -939,8 +940,7 @@ find_group (bb)\n }\n \n static void\n-union_groups (bb1, bb2)\n-     basic_block bb1, bb2;\n+union_groups (basic_block bb1, basic_block bb2)\n {\n   basic_block bb1g = find_group (bb1);\n   basic_block bb2g = find_group (bb2);\n@@ -961,8 +961,7 @@ union_groups (bb1, bb2)\n    are more expensive to instrument.  */\n \n static void\n-find_spanning_tree (el)\n-     struct edge_list *el;\n+find_spanning_tree (struct edge_list *el)\n {\n   int i;\n   int num_edges = NUM_EDGES (el);\n@@ -1031,7 +1030,7 @@ find_spanning_tree (el)\n /* Perform file-level initialization for branch-prob processing.  */\n \n void\n-init_branch_prob ()\n+init_branch_prob (void)\n {\n   int i;\n \n@@ -1052,7 +1051,7 @@ init_branch_prob ()\n    is completed.  */\n \n void\n-end_branch_prob ()\n+end_branch_prob (void)\n {\n   if (rtl_dump_file)\n     {\n@@ -1092,8 +1091,7 @@ end_branch_prob ()\n /* Output instructions as RTL to increment the edge execution count.  */\n \n static rtx\n-gen_edge_profiler (edgeno)\n-     int edgeno;\n+gen_edge_profiler (int edgeno)\n {\n   rtx ref = coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);\n   rtx tmp;\n@@ -1119,8 +1117,8 @@ gen_edge_profiler (edgeno)\n    section for counters, BASE is offset of the counter position.  */\n \n static rtx\n-gen_interval_profiler (struct histogram_value *value,\n-\t\t       unsigned tag, unsigned base)\n+gen_interval_profiler (struct histogram_value *value, unsigned tag,\n+\t\t       unsigned base)\n {\n   unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n   enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n@@ -1175,7 +1173,7 @@ gen_interval_profiler (struct histogram_value *value,\n       emit_label (more_label);\n       tmp1 = expand_simple_binop (Pmode, PLUS, copy_rtx (tmp),\n \t\t\t\t  GEN_INT (per_counter * value->hdata.intvl.steps),\n-    \t\t\t\t  mr, 0, OPTAB_WIDEN);\n+\t\t\t\t  mr, 0, OPTAB_WIDEN);\n       if (tmp1 != mr)\n \temit_move_insn (copy_rtx (mr), tmp1);\n       if (value->hdata.intvl.may_be_less)\n@@ -1220,8 +1218,7 @@ gen_interval_profiler (struct histogram_value *value,\n    section for counters, BASE is offset of the counter position.  */\n \n static rtx\n-gen_pow2_profiler (struct histogram_value *value,\n-\t\t   unsigned tag, unsigned base)\n+gen_pow2_profiler (struct histogram_value *value, unsigned tag, unsigned base)\n {\n   unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n   enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n@@ -1254,7 +1251,7 @@ gen_pow2_profiler (struct histogram_value *value,\n       tmp = expand_simple_binop (value->mode, AND, copy_rtx (uval), tmp,\n \t\t\t\t NULL_RTX, 0, OPTAB_WIDEN);\n       do_compare_rtx_and_jump (tmp, const0_rtx, NE, 0, value->mode, NULL_RTX,\n-    \t\t\t       NULL_RTX, end_of_code_label);\n+\t\t\t       NULL_RTX, end_of_code_label);\n     }\n \n   /* Count log_2(value).  */\n@@ -1294,8 +1291,8 @@ gen_pow2_profiler (struct histogram_value *value,\n    section for counters, BASE is offset of the counter position.  */\n \n static rtx\n-gen_one_value_profiler (struct histogram_value *value,\n-\t\t\tunsigned tag, unsigned base)\n+gen_one_value_profiler (struct histogram_value *value, unsigned tag,\n+\t\t\tunsigned base)\n {\n   unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n   enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n@@ -1324,7 +1321,7 @@ gen_one_value_profiler (struct histogram_value *value,\n   /* Check if the stored value matches.  */\n   do_compare_rtx_and_jump (copy_rtx (uval), copy_rtx (stored_value), EQ,\n \t\t\t   0, mode, NULL_RTX, NULL_RTX, same_label);\n-  \n+\n   /* Does not match; check whether the counter is zero.  */\n   do_compare_rtx_and_jump (copy_rtx (counter), const0_rtx, EQ, 0, mode,\n \t\t\t   NULL_RTX, NULL_RTX, zero_label);\n@@ -1338,7 +1335,7 @@ gen_one_value_profiler (struct histogram_value *value,\n \n   emit_jump_insn (gen_jump (end_of_code_label));\n   emit_barrier ();\n- \n+\n   emit_label (zero_label);\n   /* Set new value.  */\n   emit_move_insn (copy_rtx (stored_value), copy_rtx (uval));\n@@ -1350,7 +1347,7 @@ gen_one_value_profiler (struct histogram_value *value,\n \n   if (tmp != counter)\n     emit_move_insn (copy_rtx (counter), tmp);\n-  \n+\n   emit_label (end_of_code_label);\n \n   /* Increase the counter of all executions; this seems redundant given\n@@ -1375,8 +1372,8 @@ gen_one_value_profiler (struct histogram_value *value,\n    section for counters, BASE is offset of the counter position.  */\n \n static rtx\n-gen_const_delta_profiler (struct histogram_value *value,\n-\t\t\t  unsigned tag, unsigned base)\n+gen_const_delta_profiler (struct histogram_value *value, unsigned tag,\n+\t\t\t  unsigned base)\n {\n   struct histogram_value one_value_delta;\n   unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);"}, {"sha": "629390997c252a570c6efc19dbc7653127427238", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 29, "deletions": 52, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,6 @@\n /* RTL reader for GCC.\n-   Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001, 2002\n+   Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001, 2002,\n+   2003\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -29,18 +30,18 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static htab_t md_constants;\n \n-static void fatal_with_file_and_line PARAMS ((FILE *, const char *, ...))\n+static void fatal_with_file_and_line (FILE *, const char *, ...)\n   ATTRIBUTE_PRINTF_2 ATTRIBUTE_NORETURN;\n-static void fatal_expected_char PARAMS ((FILE *, int, int)) ATTRIBUTE_NORETURN;\n-static void read_name\t\tPARAMS ((char *, FILE *));\n-static char *read_string\tPARAMS ((struct obstack *, FILE *, int));\n-static char *read_quoted_string\tPARAMS ((struct obstack *, FILE *));\n-static char *read_braced_string\tPARAMS ((struct obstack *, FILE *));\n-static void read_escape\t\tPARAMS ((struct obstack *, FILE *));\n-static hashval_t def_hash\tPARAMS ((const void *));\n-static int def_name_eq_p PARAMS ((const void *, const void *));\n-static void read_constants PARAMS ((FILE *infile, char *tmp_char));\n-static void validate_const_int PARAMS ((FILE *, const char *));\n+static void fatal_expected_char (FILE *, int, int) ATTRIBUTE_NORETURN;\n+static void read_name (char *, FILE *);\n+static char *read_string (struct obstack *, FILE *, int);\n+static char *read_quoted_string (struct obstack *, FILE *);\n+static char *read_braced_string (struct obstack *, FILE *);\n+static void read_escape (struct obstack *, FILE *);\n+static hashval_t def_hash (const void *);\n+static int def_name_eq_p (const void *, const void *);\n+static void read_constants (FILE *infile, char *tmp_char);\n+static void validate_const_int (FILE *, const char *);\n \n /* Subroutines of read_rtx.  */\n \n@@ -87,9 +88,7 @@ fatal_with_file_and_line (FILE *infile, const char *msg, ...)\n    invalid data.  */\n \n static void\n-fatal_expected_char (infile, expected_c, actual_c)\n-     FILE *infile;\n-     int expected_c, actual_c;\n+fatal_expected_char (FILE *infile, int expected_c, int actual_c)\n {\n   fatal_with_file_and_line (infile, \"expected character `%c', found `%c'\",\n \t\t\t    expected_c, actual_c);\n@@ -101,8 +100,7 @@ fatal_expected_char (infile, expected_c, actual_c)\n    Tools such as genflags use this function.  */\n \n int\n-read_skip_spaces (infile)\n-     FILE *infile;\n+read_skip_spaces (FILE *infile)\n {\n   int c;\n \n@@ -154,9 +152,7 @@ read_skip_spaces (infile)\n    It is terminated by any of the punctuation chars of rtx printed syntax.  */\n \n static void\n-read_name (str, infile)\n-     char *str;\n-     FILE *infile;\n+read_name (char *str, FILE *infile)\n {\n   char *p;\n   int c;\n@@ -207,9 +203,7 @@ read_name (str, infile)\n /* Subroutine of the string readers.  Handles backslash escapes.\n    Caller has read the backslash, but not placed it into the obstack.  */\n static void\n-read_escape (ob, infile)\n-     struct obstack *ob;\n-     FILE *infile;\n+read_escape (struct obstack *ob, FILE *infile)\n {\n   int c = getc (infile);\n \n@@ -262,9 +256,7 @@ read_escape (ob, infile)\n /* Read a double-quoted string onto the obstack.  Caller has scanned\n    the leading quote.  */\n static char *\n-read_quoted_string (ob, infile)\n-     struct obstack *ob;\n-     FILE *infile;\n+read_quoted_string (struct obstack *ob, FILE *infile)\n {\n   int c;\n \n@@ -292,9 +284,7 @@ read_quoted_string (ob, infile)\n    scanned the leading brace.  Note that unlike quoted strings,\n    the outermost braces _are_ included in the string constant.  */\n static char *\n-read_braced_string (ob, infile)\n-     struct obstack *ob;\n-     FILE *infile;\n+read_braced_string (struct obstack *ob, FILE *infile)\n {\n   int c;\n   int brace_depth = 1;  /* caller-processed */\n@@ -319,7 +309,7 @@ read_braced_string (ob, infile)\n       else if (c == EOF)\n \tfatal_with_file_and_line\n \t  (infile, \"missing closing } for opening brace on line %lu\",\n-\t   starting_read_rtx_lineno);      \n+\t   starting_read_rtx_lineno);\n \n       obstack_1grow (ob, c);\n     }\n@@ -333,10 +323,7 @@ read_braced_string (ob, infile)\n    and dispatch to the appropriate string constant reader.  */\n \n static char *\n-read_string (ob, infile, star_if_braced)\n-     struct obstack *ob;\n-     FILE *infile;\n-     int star_if_braced;\n+read_string (struct obstack *ob, FILE *infile, int star_if_braced)\n {\n   char *stringbuf;\n   int saw_paren = 0;\n@@ -373,11 +360,10 @@ read_string (ob, infile, star_if_braced)\n /* Provide a version of a function to read a long long if the system does\n    not provide one.  */\n #if HOST_BITS_PER_WIDE_INT > HOST_BITS_PER_LONG && !defined(HAVE_ATOLL) && !defined(HAVE_ATOQ)\n-HOST_WIDE_INT atoll PARAMS ((const char *));\n+HOST_WIDE_INT atoll (const char *);\n \n HOST_WIDE_INT\n-atoll (p)\n-    const char *p;\n+atoll (const char *p)\n {\n   int neg = 0;\n   HOST_WIDE_INT tmp_wide;\n@@ -411,8 +397,7 @@ atoll (p)\n \n /* Given a constant definition, return a hash code for its name.  */\n static hashval_t\n-def_hash (def)\n-     const void *def;\n+def_hash (const void *def)\n {\n   unsigned result, i;\n   const char *string = ((const struct md_constant *) def)->name;\n@@ -424,8 +409,7 @@ def_hash (def)\n \n /* Given two constant definitions, return true if they have the same name.  */\n static int\n-def_name_eq_p (def1, def2)\n-     const void *def1, *def2;\n+def_name_eq_p (const void *def1, const void *def2)\n {\n   return ! strcmp (((const struct md_constant *) def1)->name,\n \t\t   ((const struct md_constant *) def2)->name);\n@@ -435,9 +419,7 @@ def_name_eq_p (def1, def2)\n    to read a name or number into.  Process a define_constants directive,\n    starting with the optional space after the \"define_constants\".  */\n static void\n-read_constants (infile, tmp_char)\n-     FILE *infile;\n-     char *tmp_char;\n+read_constants (FILE *infile, char *tmp_char)\n {\n   int c;\n   htab_t defs;\n@@ -493,18 +475,14 @@ read_constants (infile, tmp_char)\n    a pointer a pointer to the constant definition and INFO.\n    Stops when CALLBACK returns zero.  */\n void\n-traverse_md_constants (callback, info)\n-     htab_trav callback;\n-     void *info;\n+traverse_md_constants (htab_trav callback, void *info)\n {\n   if (md_constants)\n     htab_traverse (md_constants, callback, info);\n }\n \n static void\n-validate_const_int (infile, string)\n-     FILE *infile;\n-     const char *string;\n+validate_const_int (FILE *infile, const char *string)\n {\n   const char *cp;\n   int valid = 1;\n@@ -529,8 +507,7 @@ validate_const_int (infile, string)\n    the utilities gen*.c that construct C code from machine descriptions.  */\n \n rtx\n-read_rtx (infile)\n-     FILE *infile;\n+read_rtx (FILE *infile)\n {\n   int i, j;\n   RTX_CODE tmp_code;"}, {"sha": "5180aec382aaf62b75546a4ec6ce02a8942f9b57", "filename": "gcc/real.c", "status": "modified", "additions": 288, "deletions": 477, "changes": 765, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -49,7 +49,7 @@\n    significand is fractional.  Normalized significands are in the\n    range [0.5, 1.0).\n \n-   A requirement of the model is that P be larger than than the \n+   A requirement of the model is that P be larger than than the\n    largest supported target floating-point type by at least 2 bits.\n    This gives us proper rounding when we truncate to the target type.\n    In addition, E must be large enough to hold the smallest supported\n@@ -59,7 +59,7 @@\n    significand is 113 bits; we store at least 160.  The smallest\n    denormal number fits in 17 exponent bits; we store 29.\n \n-   Note that the decimal string conversion routines are sensitive to \n+   Note that the decimal string conversion routines are sensitive to\n    rounding error.  Since the raw arithmetic routines do not themselves\n    have guard digits or rounding, the computation of 10**exp can\n    accumulate more than a few digits of error.  The previous incarnation\n@@ -79,70 +79,54 @@\n  #error \"Some constant folding done by hand to avoid shift count warnings\"\n #endif\n \n-static void get_zero PARAMS ((REAL_VALUE_TYPE *, int));\n-static void get_canonical_qnan PARAMS ((REAL_VALUE_TYPE *, int));\n-static void get_canonical_snan PARAMS ((REAL_VALUE_TYPE *, int));\n-static void get_inf PARAMS ((REAL_VALUE_TYPE *, int));\n-static bool sticky_rshift_significand PARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t\t       const REAL_VALUE_TYPE *,\n-\t\t\t\t\t       unsigned int));\n-static void rshift_significand PARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t\tconst REAL_VALUE_TYPE *,\n-\t\t\t\t\tunsigned int));\n-static void lshift_significand PARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t\tconst REAL_VALUE_TYPE *,\n-\t\t\t\t\tunsigned int));\n-static void lshift_significand_1 PARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t\t  const REAL_VALUE_TYPE *));\n-static bool add_significands PARAMS ((REAL_VALUE_TYPE *r,\n-\t\t\t\t      const REAL_VALUE_TYPE *,\n-\t\t\t\t      const REAL_VALUE_TYPE *));\n-static bool sub_significands PARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t      const REAL_VALUE_TYPE *,\n-\t\t\t\t      const REAL_VALUE_TYPE *, int));\n-static void neg_significand PARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t     const REAL_VALUE_TYPE *));\n-static int cmp_significands PARAMS ((const REAL_VALUE_TYPE *,\n-\t\t\t\t     const REAL_VALUE_TYPE *));\n-static int cmp_significand_0 PARAMS ((const REAL_VALUE_TYPE *));\n-static void set_significand_bit PARAMS ((REAL_VALUE_TYPE *, unsigned int));\n-static void clear_significand_bit PARAMS ((REAL_VALUE_TYPE *, unsigned int));\n-static bool test_significand_bit PARAMS ((REAL_VALUE_TYPE *, unsigned int));\n-static void clear_significand_below PARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t\t     unsigned int));\n-static bool div_significands PARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t      const REAL_VALUE_TYPE *,\n-\t\t\t\t      const REAL_VALUE_TYPE *));\n-static void normalize PARAMS ((REAL_VALUE_TYPE *));\n-\n-static bool do_add PARAMS ((REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n-\t\t\t    const REAL_VALUE_TYPE *, int));\n-static bool do_multiply PARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t const REAL_VALUE_TYPE *,\n-\t\t\t\t const REAL_VALUE_TYPE *));\n-static bool do_divide PARAMS ((REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n-\t\t\t       const REAL_VALUE_TYPE *));\n-static int do_compare PARAMS ((const REAL_VALUE_TYPE *,\n-\t\t\t       const REAL_VALUE_TYPE *, int));\n-static void do_fix_trunc PARAMS ((REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *));\n-\n-static unsigned long rtd_divmod PARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t\t REAL_VALUE_TYPE *));\n-\n-static const REAL_VALUE_TYPE * ten_to_ptwo PARAMS ((int));\n-static const REAL_VALUE_TYPE * ten_to_mptwo PARAMS ((int));\n-static const REAL_VALUE_TYPE * real_digit PARAMS ((int));\n-static void times_pten PARAMS ((REAL_VALUE_TYPE *, int));\n-\n-static void round_for_format PARAMS ((const struct real_format *,\n-\t\t\t\t      REAL_VALUE_TYPE *));\n+static void get_zero (REAL_VALUE_TYPE *, int);\n+static void get_canonical_qnan (REAL_VALUE_TYPE *, int);\n+static void get_canonical_snan (REAL_VALUE_TYPE *, int);\n+static void get_inf (REAL_VALUE_TYPE *, int);\n+static bool sticky_rshift_significand (REAL_VALUE_TYPE *,\n+\t\t\t\t       const REAL_VALUE_TYPE *, unsigned int);\n+static void rshift_significand (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n+\t\t\t\tunsigned int);\n+static void lshift_significand (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n+\t\t\t\tunsigned int);\n+static void lshift_significand_1 (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n+static bool add_significands (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *,\n+\t\t\t      const REAL_VALUE_TYPE *);\n+static bool sub_significands (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n+\t\t\t      const REAL_VALUE_TYPE *, int);\n+static void neg_significand (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n+static int cmp_significands (const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n+static int cmp_significand_0 (const REAL_VALUE_TYPE *);\n+static void set_significand_bit (REAL_VALUE_TYPE *, unsigned int);\n+static void clear_significand_bit (REAL_VALUE_TYPE *, unsigned int);\n+static bool test_significand_bit (REAL_VALUE_TYPE *, unsigned int);\n+static void clear_significand_below (REAL_VALUE_TYPE *, unsigned int);\n+static bool div_significands (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n+\t\t\t      const REAL_VALUE_TYPE *);\n+static void normalize (REAL_VALUE_TYPE *);\n+\n+static bool do_add (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n+\t\t    const REAL_VALUE_TYPE *, int);\n+static bool do_multiply (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n+\t\t\t const REAL_VALUE_TYPE *);\n+static bool do_divide (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n+\t\t       const REAL_VALUE_TYPE *);\n+static int do_compare (const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, int);\n+static void do_fix_trunc (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n+\n+static unsigned long rtd_divmod (REAL_VALUE_TYPE *, REAL_VALUE_TYPE *);\n+\n+static const REAL_VALUE_TYPE * ten_to_ptwo (int);\n+static const REAL_VALUE_TYPE * ten_to_mptwo (int);\n+static const REAL_VALUE_TYPE * real_digit (int);\n+static void times_pten (REAL_VALUE_TYPE *, int);\n+\n+static void round_for_format (const struct real_format *, REAL_VALUE_TYPE *);\n \f\n /* Initialize R with a positive zero.  */\n \n static inline void\n-get_zero (r, sign)\n-     REAL_VALUE_TYPE *r;\n-     int sign;\n+get_zero (REAL_VALUE_TYPE *r, int sign)\n {\n   memset (r, 0, sizeof (*r));\n   r->sign = sign;\n@@ -151,9 +135,7 @@ get_zero (r, sign)\n /* Initialize R with the canonical quiet NaN.  */\n \n static inline void\n-get_canonical_qnan (r, sign)\n-     REAL_VALUE_TYPE *r;\n-     int sign;\n+get_canonical_qnan (REAL_VALUE_TYPE *r, int sign)\n {\n   memset (r, 0, sizeof (*r));\n   r->class = rvc_nan;\n@@ -162,9 +144,7 @@ get_canonical_qnan (r, sign)\n }\n \n static inline void\n-get_canonical_snan (r, sign)\n-     REAL_VALUE_TYPE *r;\n-     int sign;\n+get_canonical_snan (REAL_VALUE_TYPE *r, int sign)\n {\n   memset (r, 0, sizeof (*r));\n   r->class = rvc_nan;\n@@ -174,9 +154,7 @@ get_canonical_snan (r, sign)\n }\n \n static inline void\n-get_inf (r, sign)\n-     REAL_VALUE_TYPE *r;\n-     int sign;\n+get_inf (REAL_VALUE_TYPE *r, int sign)\n {\n   memset (r, 0, sizeof (*r));\n   r->class = rvc_inf;\n@@ -188,10 +166,8 @@ get_inf (r, sign)\n    significand of R.  If any one bits are shifted out, return true.  */\n \n static bool\n-sticky_rshift_significand (r, a, n)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *a;\n-     unsigned int n;\n+sticky_rshift_significand (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n+\t\t\t   unsigned int n)\n {\n   unsigned long sticky = 0;\n   unsigned int i, ofs = 0;\n@@ -229,10 +205,8 @@ sticky_rshift_significand (r, a, n)\n    significand of R.  */\n \n static void\n-rshift_significand (r, a, n)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *a;\n-     unsigned int n;\n+rshift_significand (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n+\t\t    unsigned int n)\n {\n   unsigned int i, ofs = n / HOST_BITS_PER_LONG;\n \n@@ -260,10 +234,8 @@ rshift_significand (r, a, n)\n    significand of R.  */\n \n static void\n-lshift_significand (r, a, n)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *a;\n-     unsigned int n;\n+lshift_significand (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n+\t\t    unsigned int n)\n {\n   unsigned int i, ofs = n / HOST_BITS_PER_LONG;\n \n@@ -288,9 +260,7 @@ lshift_significand (r, a, n)\n /* Likewise, but N is specialized to 1.  */\n \n static inline void\n-lshift_significand_1 (r, a)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *a;\n+lshift_significand_1 (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a)\n {\n   unsigned int i;\n \n@@ -303,9 +273,8 @@ lshift_significand_1 (r, a)\n    true if there was carry out of the most significant word.  */\n \n static inline bool\n-add_significands (r, a, b)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *a, *b;\n+add_significands (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n+\t\t  const REAL_VALUE_TYPE *b)\n {\n   bool carry = false;\n   int i;\n@@ -334,10 +303,8 @@ add_significands (r, a, b)\n    Return true if there was borrow out of the most significant word.  */\n \n static inline bool\n-sub_significands (r, a, b, carry)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *a, *b;\n-     int carry;\n+sub_significands (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n+\t\t  const REAL_VALUE_TYPE *b, int carry)\n {\n   int i;\n \n@@ -358,14 +325,12 @@ sub_significands (r, a, b, carry)\n     }\n \n   return carry;\n-}  \n+}\n \n /* Negate the significand A, placing the result in R.  */\n \n static inline void\n-neg_significand (r, a)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *a;\n+neg_significand (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a)\n {\n   bool carry = true;\n   int i;\n@@ -389,13 +354,12 @@ neg_significand (r, a)\n \n       r->sig[i] = ri;\n     }\n-}  \n+}\n \n /* Compare significands.  Return tri-state vs zero.  */\n \n-static inline int \n-cmp_significands (a, b)\n-     const REAL_VALUE_TYPE *a, *b;\n+static inline int\n+cmp_significands (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b)\n {\n   int i;\n \n@@ -415,9 +379,8 @@ cmp_significands (a, b)\n \n /* Return true if A is nonzero.  */\n \n-static inline int \n-cmp_significand_0 (a)\n-     const REAL_VALUE_TYPE *a;\n+static inline int\n+cmp_significand_0 (const REAL_VALUE_TYPE *a)\n {\n   int i;\n \n@@ -431,9 +394,7 @@ cmp_significand_0 (a)\n /* Set bit N of the significand of R.  */\n \n static inline void\n-set_significand_bit (r, n)\n-     REAL_VALUE_TYPE *r;\n-     unsigned int n;\n+set_significand_bit (REAL_VALUE_TYPE *r, unsigned int n)\n {\n   r->sig[n / HOST_BITS_PER_LONG]\n     |= (unsigned long)1 << (n % HOST_BITS_PER_LONG);\n@@ -442,9 +403,7 @@ set_significand_bit (r, n)\n /* Clear bit N of the significand of R.  */\n \n static inline void\n-clear_significand_bit (r, n)\n-     REAL_VALUE_TYPE *r;\n-     unsigned int n;\n+clear_significand_bit (REAL_VALUE_TYPE *r, unsigned int n)\n {\n   r->sig[n / HOST_BITS_PER_LONG]\n     &= ~((unsigned long)1 << (n % HOST_BITS_PER_LONG));\n@@ -453,9 +412,7 @@ clear_significand_bit (r, n)\n /* Test bit N of the significand of R.  */\n \n static inline bool\n-test_significand_bit (r, n)\n-     REAL_VALUE_TYPE *r;\n-     unsigned int n;\n+test_significand_bit (REAL_VALUE_TYPE *r, unsigned int n)\n {\n   /* ??? Compiler bug here if we return this expression directly.\n      The conversion to bool strips the \"&1\" and we wind up testing\n@@ -467,9 +424,7 @@ test_significand_bit (r, n)\n /* Clear bits 0..N-1 of the significand of R.  */\n \n static void\n-clear_significand_below (r, n)\n-     REAL_VALUE_TYPE *r;\n-     unsigned int n;\n+clear_significand_below (REAL_VALUE_TYPE *r, unsigned int n)\n {\n   int i, w = n / HOST_BITS_PER_LONG;\n \n@@ -483,9 +438,8 @@ clear_significand_below (r, n)\n    true if the division was inexact.  */\n \n static inline bool\n-div_significands (r, a, b)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *a, *b;\n+div_significands (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n+\t\t  const REAL_VALUE_TYPE *b)\n {\n   REAL_VALUE_TYPE u;\n   int i, bit = SIGNIFICAND_BITS - 1;\n@@ -521,8 +475,7 @@ div_significands (r, a, b)\n    exponent is large enough to handle target denormals normalized.)  */\n \n static void\n-normalize (r)\n-     REAL_VALUE_TYPE *r;\n+normalize (REAL_VALUE_TYPE *r)\n {\n   int shift = 0, exp;\n   int i, j;\n@@ -567,10 +520,8 @@ normalize (r)\n    result may be inexact due to a loss of precision.  */\n \n static bool\n-do_add (r, a, b, subtract_p)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *a, *b;\n-     int subtract_p;\n+do_add (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n+\tconst REAL_VALUE_TYPE *b, int subtract_p)\n {\n   int dexp, sign, exp;\n   REAL_VALUE_TYPE t;\n@@ -706,9 +657,8 @@ do_add (r, a, b, subtract_p)\n /* Calculate R = A * B.  Return true if the result may be inexact.  */\n \n static bool\n-do_multiply (r, a, b)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *a, *b;\n+do_multiply (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n+\t     const REAL_VALUE_TYPE *b)\n {\n   REAL_VALUE_TYPE u, t, *rr;\n   unsigned int i, j, k;\n@@ -843,9 +793,8 @@ do_multiply (r, a, b)\n /* Calculate R = A / B.  Return true if the result may be inexact.  */\n \n static bool\n-do_divide (r, a, b)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *a, *b;\n+do_divide (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n+\t   const REAL_VALUE_TYPE *b)\n {\n   int exp, sign = a->sign ^ b->sign;\n   REAL_VALUE_TYPE t, *rr;\n@@ -941,9 +890,8 @@ do_divide (r, a, b)\n    one of the two operands is a NaN.  */\n \n static int\n-do_compare (a, b, nan_result)\n-     const REAL_VALUE_TYPE *a, *b;\n-     int nan_result;\n+do_compare (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b,\n+\t    int nan_result)\n {\n   int ret;\n \n@@ -998,9 +946,7 @@ do_compare (a, b, nan_result)\n /* Return A truncated to an integral value toward zero.  */\n \n static void\n-do_fix_trunc (r, a)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *a;\n+do_fix_trunc (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a)\n {\n   *r = *a;\n \n@@ -1027,10 +973,8 @@ do_fix_trunc (r, a)\n    For a unary operation, leave OP1 NULL.  */\n \n void\n-real_arithmetic (r, icode, op0, op1)\n-     REAL_VALUE_TYPE *r;\n-     int icode;\n-     const REAL_VALUE_TYPE *op0, *op1;\n+real_arithmetic (REAL_VALUE_TYPE *r, int icode, const REAL_VALUE_TYPE *op0,\n+\t\t const REAL_VALUE_TYPE *op1)\n {\n   enum tree_code code = icode;\n \n@@ -1092,19 +1036,17 @@ real_arithmetic (r, icode, op0, op1)\n /* Legacy.  Similar, but return the result directly.  */\n \n REAL_VALUE_TYPE\n-real_arithmetic2 (icode, op0, op1)\n-     int icode;\n-     const REAL_VALUE_TYPE *op0, *op1;\n+real_arithmetic2 (int icode, const REAL_VALUE_TYPE *op0,\n+\t\t  const REAL_VALUE_TYPE *op1)\n {\n   REAL_VALUE_TYPE r;\n   real_arithmetic (&r, icode, op0, op1);\n   return r;\n }\n \n bool\n-real_compare (icode, op0, op1)\n-     int icode;\n-     const REAL_VALUE_TYPE *op0, *op1;\n+real_compare (int icode, const REAL_VALUE_TYPE *op0,\n+\t      const REAL_VALUE_TYPE *op1)\n {\n   enum tree_code code = icode;\n \n@@ -1145,8 +1087,7 @@ real_compare (icode, op0, op1)\n /* Return floor log2(R).  */\n \n int\n-real_exponent (r)\n-     const REAL_VALUE_TYPE *r;\n+real_exponent (const REAL_VALUE_TYPE *r)\n {\n   switch (r->class)\n     {\n@@ -1165,10 +1106,7 @@ real_exponent (r)\n /* R = OP0 * 2**EXP.  */\n \n void\n-real_ldexp (r, op0, exp)\n-     REAL_VALUE_TYPE *r;\n-     const REAL_VALUE_TYPE *op0;\n-     int exp;\n+real_ldexp (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *op0, int exp)\n {\n   *r = *op0;\n   switch (r->class)\n@@ -1196,44 +1134,39 @@ real_ldexp (r, op0, exp)\n /* Determine whether a floating-point value X is infinite.  */\n \n bool\n-real_isinf (r)\n-     const REAL_VALUE_TYPE *r;\n+real_isinf (const REAL_VALUE_TYPE *r)\n {\n   return (r->class == rvc_inf);\n }\n \n /* Determine whether a floating-point value X is a NaN.  */\n \n bool\n-real_isnan (r)\n-     const REAL_VALUE_TYPE *r;\n+real_isnan (const REAL_VALUE_TYPE *r)\n {\n   return (r->class == rvc_nan);\n }\n \n /* Determine whether a floating-point value X is negative.  */\n \n bool\n-real_isneg (r)\n-     const REAL_VALUE_TYPE *r;\n+real_isneg (const REAL_VALUE_TYPE *r)\n {\n   return r->sign;\n }\n \n /* Determine whether a floating-point value X is minus zero.  */\n \n bool\n-real_isnegzero (r)\n-     const REAL_VALUE_TYPE *r;\n+real_isnegzero (const REAL_VALUE_TYPE *r)\n {\n   return r->sign && r->class == rvc_zero;\n }\n \n /* Compare two floating-point objects for bitwise identity.  */\n \n bool\n-real_identical (a, b)\n-     const REAL_VALUE_TYPE *a, *b;\n+real_identical (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b)\n {\n   int i;\n \n@@ -1250,7 +1183,7 @@ real_identical (a, b)\n \n     case rvc_normal:\n       if (a->exp != b->exp)\n- \treturn false;\n+\treturn false;\n       break;\n \n     case rvc_nan:\n@@ -1276,14 +1209,12 @@ real_identical (a, b)\n    mode MODE.  Return true if successful.  */\n \n bool\n-exact_real_inverse (mode, r)\n-     enum machine_mode mode;\n-     REAL_VALUE_TYPE *r;\n+exact_real_inverse (enum machine_mode mode, REAL_VALUE_TYPE *r)\n {\n   const REAL_VALUE_TYPE *one = real_digit (1);\n   REAL_VALUE_TYPE u;\n   int i;\n-  \n+\n   if (r->class != rvc_normal)\n     return false;\n \n@@ -1297,7 +1228,7 @@ exact_real_inverse (mode, r)\n   /* Find the inverse and truncate to the required mode.  */\n   do_divide (&u, one, r);\n   real_convert (&u, mode, &u);\n-  \n+\n   /* The rounding may have overflowed.  */\n   if (u.class != rvc_normal)\n     return false;\n@@ -1314,8 +1245,7 @@ exact_real_inverse (mode, r)\n /* Render R as an integer.  */\n \n HOST_WIDE_INT\n-real_to_integer (r)\n-     const REAL_VALUE_TYPE *r;\n+real_to_integer (const REAL_VALUE_TYPE *r)\n {\n   unsigned HOST_WIDE_INT i;\n \n@@ -1338,7 +1268,7 @@ real_to_integer (r)\n \tgoto underflow;\n       /* Only force overflow for unsigned overflow.  Signed overflow is\n \t undefined, so it doesn't matter what we return, and some callers\n-\t expect to be able to use this routine for both signed and \n+\t expect to be able to use this routine for both signed and\n \t unsigned conversions.  */\n       if (r->exp > HOST_BITS_PER_WIDE_INT)\n \tgoto overflow;\n@@ -1368,9 +1298,8 @@ real_to_integer (r)\n /* Likewise, but to an integer pair, HI+LOW.  */\n \n void\n-real_to_integer2 (plow, phigh, r)\n-     HOST_WIDE_INT *plow, *phigh;\n-     const REAL_VALUE_TYPE *r;\n+real_to_integer2 (HOST_WIDE_INT *plow, HOST_WIDE_INT *phigh,\n+\t\t  const REAL_VALUE_TYPE *r)\n {\n   REAL_VALUE_TYPE t;\n   HOST_WIDE_INT low, high;\n@@ -1402,7 +1331,7 @@ real_to_integer2 (plow, phigh, r)\n \tgoto underflow;\n       /* Only force overflow for unsigned overflow.  Signed overflow is\n \t undefined, so it doesn't matter what we return, and some callers\n-\t expect to be able to use this routine for both signed and \n+\t expect to be able to use this routine for both signed and\n \t unsigned conversions.  */\n       if (exp > 2*HOST_BITS_PER_WIDE_INT)\n \tgoto overflow;\n@@ -1449,8 +1378,7 @@ real_to_integer2 (plow, phigh, r)\n    small.  */\n \n static unsigned long\n-rtd_divmod (num, den)\n-     REAL_VALUE_TYPE *num, *den;\n+rtd_divmod (REAL_VALUE_TYPE *num, REAL_VALUE_TYPE *den)\n {\n   unsigned long q, msb;\n   int expn = num->exp, expd = den->exp;\n@@ -1488,11 +1416,8 @@ rtd_divmod (num, den)\n #define M_LOG10_2\t0.30102999566398119521\n \n void\n-real_to_decimal (str, r_orig, buf_size, digits, crop_trailing_zeros)\n-     char *str;\n-     const REAL_VALUE_TYPE *r_orig;\n-     size_t buf_size, digits;\n-     int crop_trailing_zeros;\n+real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig, size_t buf_size,\n+\t\t size_t digits, int crop_trailing_zeros)\n {\n   const REAL_VALUE_TYPE *one, *ten;\n   REAL_VALUE_TYPE r, pten, u, v;\n@@ -1564,7 +1489,7 @@ real_to_decimal (str, r_orig, buf_size, digits, crop_trailing_zeros)\n \n       /* Iterate over the bits of the possible powers of 10 that might\n \t be present in U and eliminate them.  That is, if we find that\n-\t 10**2**M divides U evenly, keep the division and increase \n+\t 10**2**M divides U evenly, keep the division and increase\n \t DEC_EXP by 2**M.  */\n       do\n \t{\n@@ -1585,7 +1510,7 @@ real_to_decimal (str, r_orig, buf_size, digits, crop_trailing_zeros)\n       r = u;\n \n       /* Find power of 10.  Do this by dividing out 10**2**M when\n-\t this is larger than the current remainder.  Fill PTEN with \n+\t this is larger than the current remainder.  Fill PTEN with\n \t the power of 10 that we compute.  */\n       if (r.exp > 0)\n \t{\n@@ -1740,7 +1665,7 @@ real_to_decimal (str, r_orig, buf_size, digits, crop_trailing_zeros)\n \t  dec_exp++;\n \t}\n     }\n-  \n+\n   /* Insert the decimal point.  */\n   first[0] = first[1];\n   first[1] = '.';\n@@ -1760,11 +1685,8 @@ real_to_decimal (str, r_orig, buf_size, digits, crop_trailing_zeros)\n    strip trailing zeros.  */\n \n void\n-real_to_hexadecimal (str, r, buf_size, digits, crop_trailing_zeros)\n-     char *str;\n-     const REAL_VALUE_TYPE *r;\n-     size_t buf_size, digits;\n-     int crop_trailing_zeros;\n+real_to_hexadecimal (char *str, const REAL_VALUE_TYPE *r, size_t buf_size,\n+\t\t     size_t digits, int crop_trailing_zeros)\n {\n   int i, j, exp = r->exp;\n   char *p, *first;\n@@ -1830,9 +1752,7 @@ real_to_hexadecimal (str, r, buf_size, digits, crop_trailing_zeros)\n    assumed to have been syntax checked already.  */\n \n void\n-real_from_string (r, str)\n-     REAL_VALUE_TYPE *r;\n-     const char *str;\n+real_from_string (REAL_VALUE_TYPE *r, const char *str)\n {\n   int exp = 0;\n   bool sign = false;\n@@ -2016,9 +1936,7 @@ real_from_string (r, str)\n /* Legacy.  Similar, but return the result directly.  */\n \n REAL_VALUE_TYPE\n-real_from_string2 (s, mode)\n-     const char *s;\n-     enum machine_mode mode;\n+real_from_string2 (const char *s, enum machine_mode mode)\n {\n   REAL_VALUE_TYPE r;\n \n@@ -2032,12 +1950,9 @@ real_from_string2 (s, mode)\n /* Initialize R from the integer pair HIGH+LOW.  */\n \n void\n-real_from_integer (r, mode, low, high, unsigned_p)\n-     REAL_VALUE_TYPE *r;\n-     enum machine_mode mode;\n-     unsigned HOST_WIDE_INT low;\n-     HOST_WIDE_INT high;\n-     int unsigned_p;\n+real_from_integer (REAL_VALUE_TYPE *r, enum machine_mode mode,\n+\t\t   unsigned HOST_WIDE_INT low, HOST_WIDE_INT high,\n+\t\t   int unsigned_p)\n {\n   if (low == 0 && high == 0)\n     get_zero (r, 0);\n@@ -2084,8 +1999,7 @@ real_from_integer (r, mode, low, high, unsigned_p)\n /* Returns 10**2**N.  */\n \n static const REAL_VALUE_TYPE *\n-ten_to_ptwo (n)\n-     int n;\n+ten_to_ptwo (int n)\n {\n   static REAL_VALUE_TYPE tens[EXP_BITS];\n \n@@ -2117,8 +2031,7 @@ ten_to_ptwo (n)\n /* Returns 10**(-2**N).  */\n \n static const REAL_VALUE_TYPE *\n-ten_to_mptwo (n)\n-     int n;\n+ten_to_mptwo (int n)\n {\n   static REAL_VALUE_TYPE tens[EXP_BITS];\n \n@@ -2134,8 +2047,7 @@ ten_to_mptwo (n)\n /* Returns N.  */\n \n static const REAL_VALUE_TYPE *\n-real_digit (n)\n-     int n;\n+real_digit (int n)\n {\n   static REAL_VALUE_TYPE num[10];\n \n@@ -2151,9 +2063,7 @@ real_digit (n)\n /* Multiply R by 10**EXP.  */\n \n static void\n-times_pten (r, exp)\n-     REAL_VALUE_TYPE *r;\n-     int exp;\n+times_pten (REAL_VALUE_TYPE *r, int exp)\n {\n   REAL_VALUE_TYPE pten, *rr;\n   bool negative = (exp < 0);\n@@ -2179,8 +2089,7 @@ times_pten (r, exp)\n /* Fills R with +Inf.  */\n \n void\n-real_inf (r)\n-     REAL_VALUE_TYPE *r;\n+real_inf (REAL_VALUE_TYPE *r)\n {\n   get_inf (r, 0);\n }\n@@ -2191,11 +2100,8 @@ real_inf (r)\n    if the string was successfully parsed.  */\n \n bool\n-real_nan (r, str, quiet, mode)\n-     REAL_VALUE_TYPE *r;\n-     const char *str;\n-     int quiet;\n-     enum machine_mode mode;\n+real_nan (REAL_VALUE_TYPE *r, const char *str, int quiet,\n+\t  enum machine_mode mode)\n {\n   const struct real_format *fmt;\n \n@@ -2284,10 +2190,7 @@ real_nan (r, str, quiet, mode)\n    If SIGN is nonzero, R is set to the most negative finite value.  */\n \n void\n-real_maxval (r, sign, mode)\n-     REAL_VALUE_TYPE *r;\n-     int sign;\n-     enum machine_mode mode;\n+real_maxval (REAL_VALUE_TYPE *r, int sign, enum machine_mode mode)\n {\n   const struct real_format *fmt;\n   int np2;\n@@ -2310,9 +2213,7 @@ real_maxval (r, sign, mode)\n /* Fills R with 2**N.  */\n \n void\n-real_2expN (r, n)\n-     REAL_VALUE_TYPE *r;\n-     int n;\n+real_2expN (REAL_VALUE_TYPE *r, int n)\n {\n   memset (r, 0, sizeof (*r));\n \n@@ -2331,9 +2232,7 @@ real_2expN (r, n)\n \n \f\n static void\n-round_for_format (fmt, r)\n-     const struct real_format *fmt;\n-     REAL_VALUE_TYPE *r;\n+round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)\n {\n   int p2, np2, i, w;\n   unsigned long sticky;\n@@ -2464,10 +2363,8 @@ round_for_format (fmt, r)\n /* Extend or truncate to a new mode.  */\n \n void\n-real_convert (r, mode, a)\n-     REAL_VALUE_TYPE *r;\n-     enum machine_mode mode;\n-     const REAL_VALUE_TYPE *a;\n+real_convert (REAL_VALUE_TYPE *r, enum machine_mode mode,\n+\t      const REAL_VALUE_TYPE *a)\n {\n   const struct real_format *fmt;\n \n@@ -2486,9 +2383,7 @@ real_convert (r, mode, a)\n /* Legacy.  Likewise, except return the struct directly.  */\n \n REAL_VALUE_TYPE\n-real_value_truncate (mode, a)\n-     enum machine_mode mode;\n-     REAL_VALUE_TYPE a;\n+real_value_truncate (enum machine_mode mode, REAL_VALUE_TYPE a)\n {\n   REAL_VALUE_TYPE r;\n   real_convert (&r, mode, &a);\n@@ -2498,9 +2393,7 @@ real_value_truncate (mode, a)\n /* Return true if truncating to MODE is exact.  */\n \n bool\n-exact_real_truncate (mode, a)\n-     enum machine_mode mode;\n-     const REAL_VALUE_TYPE *a;\n+exact_real_truncate (enum machine_mode mode, const REAL_VALUE_TYPE *a)\n {\n   REAL_VALUE_TYPE t;\n   real_convert (&t, mode, a);\n@@ -2514,10 +2407,8 @@ exact_real_truncate (mode, a)\n    Legacy: return word 0 for implementing REAL_VALUE_TO_TARGET_SINGLE.  */\n \n long\n-real_to_target_fmt (buf, r_orig, fmt)\n-     long *buf;\n-     const REAL_VALUE_TYPE *r_orig;\n-     const struct real_format *fmt;\n+real_to_target_fmt (long *buf, const REAL_VALUE_TYPE *r_orig,\n+\t\t    const struct real_format *fmt)\n {\n   REAL_VALUE_TYPE r;\n   long buf1;\n@@ -2535,10 +2426,7 @@ real_to_target_fmt (buf, r_orig, fmt)\n /* Similar, but look up the format from MODE.  */\n \n long\n-real_to_target (buf, r, mode)\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n-     enum machine_mode mode;\n+real_to_target (long *buf, const REAL_VALUE_TYPE *r, enum machine_mode mode)\n {\n   const struct real_format *fmt;\n \n@@ -2554,21 +2442,16 @@ real_to_target (buf, r, mode)\n    long, no matter the size of the host long.  */\n \n void\n-real_from_target_fmt (r, buf, fmt)\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n-     const struct real_format *fmt;\n+real_from_target_fmt (REAL_VALUE_TYPE *r, const long *buf,\n+\t\t      const struct real_format *fmt)\n {\n   (*fmt->decode) (fmt, r, buf);\n-}     \n+}\n \n /* Similar, but look up the format from MODE.  */\n \n void\n-real_from_target (r, buf, mode)\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n-     enum machine_mode mode;\n+real_from_target (REAL_VALUE_TYPE *r, const long *buf, enum machine_mode mode)\n {\n   const struct real_format *fmt;\n \n@@ -2577,14 +2460,13 @@ real_from_target (r, buf, mode)\n     abort ();\n \n   (*fmt->decode) (fmt, r, buf);\n-}     \n+}\n \n /* Return the number of bits in the significand for MODE.  */\n /* ??? Legacy.  Should get access to real_format directly.  */\n \n int\n-significand_size (mode)\n-     enum machine_mode mode;\n+significand_size (enum machine_mode mode)\n {\n   const struct real_format *fmt;\n \n@@ -2600,8 +2482,7 @@ significand_size (mode)\n    but I didn't want to pull hashtab.h into real.h.  */\n \n unsigned int\n-real_hash (r)\n-     const REAL_VALUE_TYPE *r;\n+real_hash (const REAL_VALUE_TYPE *r)\n {\n   unsigned int h;\n   size_t i;\n@@ -2643,16 +2524,14 @@ real_hash (r)\n \f\n /* IEEE single-precision format.  */\n \n-static void encode_ieee_single PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\tlong *, const REAL_VALUE_TYPE *));\n-static void decode_ieee_single PARAMS ((const struct real_format *,\n-\t\t\t\t\tREAL_VALUE_TYPE *, const long *));\n+static void encode_ieee_single (const struct real_format *fmt,\n+\t\t\t\tlong *, const REAL_VALUE_TYPE *);\n+static void decode_ieee_single (const struct real_format *,\n+\t\t\t\tREAL_VALUE_TYPE *, const long *);\n \n static void\n-encode_ieee_single (fmt, buf, r)\n-     const struct real_format *fmt;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_ieee_single (const struct real_format *fmt, long *buf,\n+\t\t    const REAL_VALUE_TYPE *r)\n {\n   unsigned long image, sig, exp;\n   bool denormal = (r->sig[SIGSZ-1] & SIG_MSB) == 0;\n@@ -2717,10 +2596,8 @@ encode_ieee_single (fmt, buf, r)\n }\n \n static void\n-decode_ieee_single (fmt, r, buf)\n-     const struct real_format *fmt;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_ieee_single (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n+\t\t    const long *buf)\n {\n   unsigned long image = buf[0] & 0xffffffff;\n   bool sign = (image >> 31) & 1;\n@@ -2768,7 +2645,7 @@ decode_ieee_single (fmt, r, buf)\n     }\n }\n \n-const struct real_format ieee_single_format = \n+const struct real_format ieee_single_format =\n   {\n     encode_ieee_single,\n     decode_ieee_single,\n@@ -2786,7 +2663,7 @@ const struct real_format ieee_single_format =\n     true\n   };\n \n-const struct real_format mips_single_format = \n+const struct real_format mips_single_format =\n   {\n     encode_ieee_single,\n     decode_ieee_single,\n@@ -2807,16 +2684,14 @@ const struct real_format mips_single_format =\n \f\n /* IEEE double-precision format.  */\n \n-static void encode_ieee_double PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\tlong *, const REAL_VALUE_TYPE *));\n-static void decode_ieee_double PARAMS ((const struct real_format *,\n-\t\t\t\t\tREAL_VALUE_TYPE *, const long *));\n+static void encode_ieee_double (const struct real_format *fmt,\n+\t\t\t\tlong *, const REAL_VALUE_TYPE *);\n+static void decode_ieee_double (const struct real_format *,\n+\t\t\t\tREAL_VALUE_TYPE *, const long *);\n \n static void\n-encode_ieee_double (fmt, buf, r)\n-     const struct real_format *fmt;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_ieee_double (const struct real_format *fmt, long *buf,\n+\t\t    const REAL_VALUE_TYPE *r)\n {\n   unsigned long image_lo, image_hi, sig_lo, sig_hi, exp;\n   bool denormal = (r->sig[SIGSZ-1] & SIG_MSB) == 0;\n@@ -2909,10 +2784,8 @@ encode_ieee_double (fmt, buf, r)\n }\n \n static void\n-decode_ieee_double (fmt, r, buf)\n-     const struct real_format *fmt;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_ieee_double (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n+\t\t    const long *buf)\n {\n   unsigned long image_hi, image_lo;\n   bool sign;\n@@ -2995,7 +2868,7 @@ decode_ieee_double (fmt, r, buf)\n     }\n }\n \n-const struct real_format ieee_double_format = \n+const struct real_format ieee_double_format =\n   {\n     encode_ieee_double,\n     decode_ieee_double,\n@@ -3013,7 +2886,7 @@ const struct real_format ieee_double_format =\n     true\n   };\n \n-const struct real_format mips_double_format = \n+const struct real_format mips_double_format =\n   {\n     encode_ieee_double,\n     decode_ieee_double,\n@@ -3036,23 +2909,19 @@ const struct real_format mips_double_format =\n    flavors: Intel's as a 12 byte image, Intel's as a 16 byte image,\n    and Motorola's.  */\n \n-static void encode_ieee_extended PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\t  long *, const REAL_VALUE_TYPE *));\n-static void decode_ieee_extended PARAMS ((const struct real_format *,\n-\t\t\t\t\t  REAL_VALUE_TYPE *, const long *));\n+static void encode_ieee_extended (const struct real_format *fmt,\n+\t\t\t\t  long *, const REAL_VALUE_TYPE *);\n+static void decode_ieee_extended (const struct real_format *,\n+\t\t\t\t  REAL_VALUE_TYPE *, const long *);\n \n-static void encode_ieee_extended_128 PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\t      long *,\n-\t\t\t\t\t      const REAL_VALUE_TYPE *));\n-static void decode_ieee_extended_128 PARAMS ((const struct real_format *,\n-\t\t\t\t\t      REAL_VALUE_TYPE *,\n-\t\t\t\t\t      const long *));\n+static void encode_ieee_extended_128 (const struct real_format *fmt,\n+\t\t\t\t      long *, const REAL_VALUE_TYPE *);\n+static void decode_ieee_extended_128 (const struct real_format *,\n+\t\t\t\t      REAL_VALUE_TYPE *, const long *);\n \n static void\n-encode_ieee_extended (fmt, buf, r)\n-     const struct real_format *fmt;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_ieee_extended (const struct real_format *fmt, long *buf,\n+\t\t      const REAL_VALUE_TYPE *r)\n {\n   unsigned long image_hi, sig_hi, sig_lo;\n   bool denormal = (r->sig[SIGSZ-1] & SIG_MSB) == 0;\n@@ -3122,7 +2991,7 @@ encode_ieee_extended (fmt, buf, r)\n \n \t/* Recall that IEEE numbers are interpreted as 1.F x 2**exp,\n \t   whereas the intermediate representation is 0.F x 2**exp.\n-\t   Which means we're off by one. \n+\t   Which means we're off by one.\n \n \t   Except for Motorola, which consider exp=0 and explicit\n \t   integer bit set to continue to be normalized.  In theory\n@@ -3164,20 +3033,16 @@ encode_ieee_extended (fmt, buf, r)\n }\n \n static void\n-encode_ieee_extended_128 (fmt, buf, r)\n-     const struct real_format *fmt;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_ieee_extended_128 (const struct real_format *fmt, long *buf,\n+\t\t\t  const REAL_VALUE_TYPE *r)\n {\n   buf[3 * !FLOAT_WORDS_BIG_ENDIAN] = 0;\n   encode_ieee_extended (fmt, buf+!!FLOAT_WORDS_BIG_ENDIAN, r);\n }\n \n static void\n-decode_ieee_extended (fmt, r, buf)\n-     const struct real_format *fmt;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_ieee_extended (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n+\t\t      const long *buf)\n {\n   unsigned long image_hi, sig_hi, sig_lo;\n   bool sign;\n@@ -3264,15 +3129,13 @@ decode_ieee_extended (fmt, r, buf)\n }\n \n static void\n-decode_ieee_extended_128 (fmt, r, buf)\n-     const struct real_format *fmt;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_ieee_extended_128 (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n+\t\t\t  const long *buf)\n {\n   decode_ieee_extended (fmt, r, buf+!!FLOAT_WORDS_BIG_ENDIAN);\n }\n \n-const struct real_format ieee_extended_motorola_format = \n+const struct real_format ieee_extended_motorola_format =\n   {\n     encode_ieee_extended,\n     decode_ieee_extended,\n@@ -3290,7 +3153,7 @@ const struct real_format ieee_extended_motorola_format =\n     true\n   };\n \n-const struct real_format ieee_extended_intel_96_format = \n+const struct real_format ieee_extended_intel_96_format =\n   {\n     encode_ieee_extended,\n     decode_ieee_extended,\n@@ -3308,7 +3171,7 @@ const struct real_format ieee_extended_intel_96_format =\n     true\n   };\n \n-const struct real_format ieee_extended_intel_128_format = \n+const struct real_format ieee_extended_intel_128_format =\n   {\n     encode_ieee_extended_128,\n     decode_ieee_extended_128,\n@@ -3328,7 +3191,7 @@ const struct real_format ieee_extended_intel_128_format =\n \n /* The following caters to i386 systems that set the rounding precision\n    to 53 bits instead of 64, e.g. FreeBSD.  */\n-const struct real_format ieee_extended_intel_96_round_53_format = \n+const struct real_format ieee_extended_intel_96_round_53_format =\n   {\n     encode_ieee_extended,\n     decode_ieee_extended,\n@@ -3355,16 +3218,14 @@ const struct real_format ieee_extended_intel_96_round_53_format =\n    ignored.  Zeroes, Infinities, and NaNs are set in both doubles\n    due to precedent.  */\n \n-static void encode_ibm_extended PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\t long *, const REAL_VALUE_TYPE *));\n-static void decode_ibm_extended PARAMS ((const struct real_format *,\n-\t\t\t\t\t REAL_VALUE_TYPE *, const long *));\n+static void encode_ibm_extended (const struct real_format *fmt,\n+\t\t\t\t long *, const REAL_VALUE_TYPE *);\n+static void decode_ibm_extended (const struct real_format *,\n+\t\t\t\t REAL_VALUE_TYPE *, const long *);\n \n static void\n-encode_ibm_extended (fmt, buf, r)\n-     const struct real_format *fmt;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_ibm_extended (const struct real_format *fmt, long *buf,\n+\t\t     const REAL_VALUE_TYPE *r)\n {\n   REAL_VALUE_TYPE u, v;\n   const struct real_format *base_fmt;\n@@ -3388,7 +3249,7 @@ encode_ibm_extended (fmt, buf, r)\n       buf[2] = buf[0];\n       buf[3] = buf[1];\n       return;\n-      \n+\n     case rvc_normal:\n       /* u = IEEE double precision portion of significand.  */\n       u = *r;\n@@ -3422,10 +3283,8 @@ encode_ibm_extended (fmt, buf, r)\n }\n \n static void\n-decode_ibm_extended (fmt, r, buf)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_ibm_extended (const struct real_format *fmt ATTRIBUTE_UNUSED, REAL_VALUE_TYPE *r,\n+\t\t     const long *buf)\n {\n   REAL_VALUE_TYPE u, v;\n   const struct real_format *base_fmt;\n@@ -3442,7 +3301,7 @@ decode_ibm_extended (fmt, r, buf)\n     *r = u;\n }\n \n-const struct real_format ibm_extended_format = \n+const struct real_format ibm_extended_format =\n   {\n     encode_ibm_extended,\n     decode_ibm_extended,\n@@ -3460,7 +3319,7 @@ const struct real_format ibm_extended_format =\n     true\n   };\n \n-const struct real_format mips_extended_format = \n+const struct real_format mips_extended_format =\n   {\n     encode_ibm_extended,\n     decode_ibm_extended,\n@@ -3481,16 +3340,14 @@ const struct real_format mips_extended_format =\n \f\n /* IEEE quad precision format.  */\n \n-static void encode_ieee_quad PARAMS ((const struct real_format *fmt,\n-\t\t\t\t      long *, const REAL_VALUE_TYPE *));\n-static void decode_ieee_quad PARAMS ((const struct real_format *,\n-\t\t\t\t      REAL_VALUE_TYPE *, const long *));\n+static void encode_ieee_quad (const struct real_format *fmt,\n+\t\t\t      long *, const REAL_VALUE_TYPE *);\n+static void decode_ieee_quad (const struct real_format *,\n+\t\t\t      REAL_VALUE_TYPE *, const long *);\n \n static void\n-encode_ieee_quad (fmt, buf, r)\n-     const struct real_format *fmt;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_ieee_quad (const struct real_format *fmt, long *buf,\n+\t\t  const REAL_VALUE_TYPE *r)\n {\n   unsigned long image3, image2, image1, image0, exp;\n   bool denormal = (r->sig[SIGSZ-1] & SIG_MSB) == 0;\n@@ -3620,10 +3477,8 @@ encode_ieee_quad (fmt, buf, r)\n }\n \n static void\n-decode_ieee_quad (fmt, r, buf)\n-     const struct real_format *fmt;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_ieee_quad (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n+\t\t  const long *buf)\n {\n   unsigned long image3, image2, image1, image0;\n   bool sign;\n@@ -3730,7 +3585,7 @@ decode_ieee_quad (fmt, r, buf)\n     }\n }\n \n-const struct real_format ieee_quad_format = \n+const struct real_format ieee_quad_format =\n   {\n     encode_ieee_quad,\n     decode_ieee_quad,\n@@ -3748,7 +3603,7 @@ const struct real_format ieee_quad_format =\n     true\n   };\n \n-const struct real_format mips_quad_format = \n+const struct real_format mips_quad_format =\n   {\n     encode_ieee_quad,\n     decode_ieee_quad,\n@@ -3775,25 +3630,23 @@ const struct real_format mips_quad_format =\n \n    We don't implement the H_floating format here, simply because neither\n    the VAX or Alpha ports use it.  */\n-   \n-static void encode_vax_f PARAMS ((const struct real_format *fmt,\n-\t\t\t\t  long *, const REAL_VALUE_TYPE *));\n-static void decode_vax_f PARAMS ((const struct real_format *,\n-\t\t\t\t  REAL_VALUE_TYPE *, const long *));\n-static void encode_vax_d PARAMS ((const struct real_format *fmt,\n-\t\t\t\t  long *, const REAL_VALUE_TYPE *));\n-static void decode_vax_d PARAMS ((const struct real_format *,\n-\t\t\t\t  REAL_VALUE_TYPE *, const long *));\n-static void encode_vax_g PARAMS ((const struct real_format *fmt,\n-\t\t\t\t  long *, const REAL_VALUE_TYPE *));\n-static void decode_vax_g PARAMS ((const struct real_format *,\n-\t\t\t\t  REAL_VALUE_TYPE *, const long *));\n+\n+static void encode_vax_f (const struct real_format *fmt,\n+\t\t\t  long *, const REAL_VALUE_TYPE *);\n+static void decode_vax_f (const struct real_format *,\n+\t\t\t  REAL_VALUE_TYPE *, const long *);\n+static void encode_vax_d (const struct real_format *fmt,\n+\t\t\t  long *, const REAL_VALUE_TYPE *);\n+static void decode_vax_d (const struct real_format *,\n+\t\t\t  REAL_VALUE_TYPE *, const long *);\n+static void encode_vax_g (const struct real_format *fmt,\n+\t\t\t  long *, const REAL_VALUE_TYPE *);\n+static void decode_vax_g (const struct real_format *,\n+\t\t\t  REAL_VALUE_TYPE *, const long *);\n \n static void\n-encode_vax_f (fmt, buf, r)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_vax_f (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n+\t      const REAL_VALUE_TYPE *r)\n {\n   unsigned long sign, exp, sig, image;\n \n@@ -3828,10 +3681,8 @@ encode_vax_f (fmt, buf, r)\n }\n \n static void\n-decode_vax_f (fmt, r, buf)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_vax_f (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t      REAL_VALUE_TYPE *r, const long *buf)\n {\n   unsigned long image = buf[0] & 0xffffffff;\n   int exp = (image >> 7) & 0xff;\n@@ -3850,10 +3701,8 @@ decode_vax_f (fmt, r, buf)\n }\n \n static void\n-encode_vax_d (fmt, buf, r)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_vax_d (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n+\t      const REAL_VALUE_TYPE *r)\n {\n   unsigned long image0, image1, sign = r->sign << 15;\n \n@@ -3906,10 +3755,8 @@ encode_vax_d (fmt, buf, r)\n }\n \n static void\n-decode_vax_d (fmt, r, buf)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_vax_d (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t      REAL_VALUE_TYPE *r, const long *buf)\n {\n   unsigned long image0, image1;\n   int exp;\n@@ -3954,10 +3801,8 @@ decode_vax_d (fmt, r, buf)\n }\n \n static void\n-encode_vax_g (fmt, buf, r)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_vax_g (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n+\t      const REAL_VALUE_TYPE *r)\n {\n   unsigned long image0, image1, sign = r->sign << 15;\n \n@@ -4010,10 +3855,8 @@ encode_vax_g (fmt, buf, r)\n }\n \n static void\n-decode_vax_g (fmt, r, buf)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_vax_g (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t      REAL_VALUE_TYPE *r, const long *buf)\n {\n   unsigned long image0, image1;\n   int exp;\n@@ -4057,7 +3900,7 @@ decode_vax_g (fmt, r, buf)\n     }\n }\n \n-const struct real_format vax_f_format = \n+const struct real_format vax_f_format =\n   {\n     encode_vax_f,\n     decode_vax_f,\n@@ -4075,7 +3918,7 @@ const struct real_format vax_f_format =\n     false\n   };\n \n-const struct real_format vax_d_format = \n+const struct real_format vax_d_format =\n   {\n     encode_vax_d,\n     decode_vax_d,\n@@ -4093,7 +3936,7 @@ const struct real_format vax_d_format =\n     false\n   };\n \n-const struct real_format vax_g_format = \n+const struct real_format vax_g_format =\n   {\n     encode_vax_g,\n     decode_vax_g,\n@@ -4118,20 +3961,18 @@ const struct real_format vax_g_format =\n    http://publibz.boulder.ibm.com/cgi-bin/bookmgr_OS390/BOOKS/DZ9AR001/9.1?DT=19930923083613\n */\n \n-static void encode_i370_single PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\tlong *, const REAL_VALUE_TYPE *));\n-static void decode_i370_single PARAMS ((const struct real_format *,\n-\t\t\t\t\tREAL_VALUE_TYPE *, const long *));\n-static void encode_i370_double PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\tlong *, const REAL_VALUE_TYPE *));\n-static void decode_i370_double PARAMS ((const struct real_format *,\n-\t\t\t\t\tREAL_VALUE_TYPE *, const long *));\n+static void encode_i370_single (const struct real_format *fmt,\n+\t\t\t\tlong *, const REAL_VALUE_TYPE *);\n+static void decode_i370_single (const struct real_format *,\n+\t\t\t\tREAL_VALUE_TYPE *, const long *);\n+static void encode_i370_double (const struct real_format *fmt,\n+\t\t\t\tlong *, const REAL_VALUE_TYPE *);\n+static void decode_i370_double (const struct real_format *,\n+\t\t\t\tREAL_VALUE_TYPE *, const long *);\n \n static void\n-encode_i370_single (fmt, buf, r)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_i370_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t    long *buf, const REAL_VALUE_TYPE *r)\n {\n   unsigned long sign, exp, sig, image;\n \n@@ -4162,10 +4003,8 @@ encode_i370_single (fmt, buf, r)\n }\n \n static void\n-decode_i370_single (fmt, r, buf)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_i370_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t    REAL_VALUE_TYPE *r, const long *buf)\n {\n   unsigned long sign, sig, image = buf[0];\n   int exp;\n@@ -4187,10 +4026,8 @@ decode_i370_single (fmt, r, buf)\n }\n \n static void\n-encode_i370_double (fmt, buf, r)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_i370_double (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t    long *buf, const REAL_VALUE_TYPE *r)\n {\n   unsigned long sign, exp, image_hi, image_lo;\n \n@@ -4238,10 +4075,8 @@ encode_i370_double (fmt, buf, r)\n }\n \n static void\n-decode_i370_double (fmt, r, buf)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_i370_double (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t    REAL_VALUE_TYPE *r, const long *buf)\n {\n   unsigned long sign, image_hi, image_lo;\n   int exp;\n@@ -4331,23 +4166,21 @@ const struct real_format i370_double_format =\n \n    See http://www-s.ti.com/sc/psheets/spru063c/spru063c.pdf  */\n \n-static void encode_c4x_single PARAMS ((const struct real_format *fmt,\n-\t\t\t\t       long *, const REAL_VALUE_TYPE *));\n-static void decode_c4x_single PARAMS ((const struct real_format *,\n-\t\t\t\t       REAL_VALUE_TYPE *, const long *));\n-static void encode_c4x_extended PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\t long *, const REAL_VALUE_TYPE *));\n-static void decode_c4x_extended PARAMS ((const struct real_format *,\n-\t\t\t\t\t REAL_VALUE_TYPE *, const long *));\n+static void encode_c4x_single (const struct real_format *fmt,\n+\t\t\t       long *, const REAL_VALUE_TYPE *);\n+static void decode_c4x_single (const struct real_format *,\n+\t\t\t       REAL_VALUE_TYPE *, const long *);\n+static void encode_c4x_extended (const struct real_format *fmt,\n+\t\t\t\t long *, const REAL_VALUE_TYPE *);\n+static void decode_c4x_extended (const struct real_format *,\n+\t\t\t\t REAL_VALUE_TYPE *, const long *);\n \n static void\n-encode_c4x_single (fmt, buf, r)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_c4x_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t   long *buf, const REAL_VALUE_TYPE *r)\n {\n   unsigned long image, exp, sig;\n-  \n+\n   switch (r->class)\n     {\n     case rvc_zero:\n@@ -4383,10 +4216,8 @@ encode_c4x_single (fmt, buf, r)\n }\n \n static void\n-decode_c4x_single (fmt, r, buf)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_c4x_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t   REAL_VALUE_TYPE *r, const long *buf)\n {\n   unsigned long image = buf[0];\n   unsigned long sig;\n@@ -4418,13 +4249,11 @@ decode_c4x_single (fmt, r, buf)\n }\n \n static void\n-encode_c4x_extended (fmt, buf, r)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_c4x_extended (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t     long *buf, const REAL_VALUE_TYPE *r)\n {\n   unsigned long exp, sig;\n-  \n+\n   switch (r->class)\n     {\n     case rvc_zero:\n@@ -4470,10 +4299,8 @@ encode_c4x_extended (fmt, buf, r)\n }\n \n static void\n-decode_c4x_extended (fmt, r, buf)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_c4x_extended (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t     REAL_VALUE_TYPE *r, const long *buf)\n {\n   unsigned long sig;\n   int exp, sf;\n@@ -4510,7 +4337,7 @@ decode_c4x_extended (fmt, r, buf)\n     }\n }\n \n-const struct real_format c4x_single_format = \n+const struct real_format c4x_single_format =\n   {\n     encode_c4x_single,\n     decode_c4x_single,\n@@ -4528,7 +4355,7 @@ const struct real_format c4x_single_format =\n     false\n   };\n \n-const struct real_format c4x_extended_format = \n+const struct real_format c4x_extended_format =\n   {\n     encode_c4x_extended,\n     decode_c4x_extended,\n@@ -4552,30 +4379,26 @@ const struct real_format c4x_extended_format =\n    The encode and decode routines exist only to satisfy our paranoia\n    harness.  */\n \n-static void encode_internal PARAMS ((const struct real_format *fmt,\n-\t\t\t\t     long *, const REAL_VALUE_TYPE *));\n-static void decode_internal PARAMS ((const struct real_format *,\n-\t\t\t\t     REAL_VALUE_TYPE *, const long *));\n+static void encode_internal (const struct real_format *fmt,\n+\t\t\t     long *, const REAL_VALUE_TYPE *);\n+static void decode_internal (const struct real_format *,\n+\t\t\t     REAL_VALUE_TYPE *, const long *);\n \n static void\n-encode_internal (fmt, buf, r)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     long *buf;\n-     const REAL_VALUE_TYPE *r;\n+encode_internal (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n+\t\t const REAL_VALUE_TYPE *r)\n {\n   memcpy (buf, r, sizeof (*r));\n }\n \n static void\n-decode_internal (fmt, r, buf)\n-     const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     REAL_VALUE_TYPE *r;\n-     const long *buf;\n+decode_internal (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t REAL_VALUE_TYPE *r, const long *buf)\n {\n   memcpy (r, buf, sizeof (*r));\n }\n \n-const struct real_format real_internal_format = \n+const struct real_format real_internal_format =\n   {\n     encode_internal,\n     decode_internal,\n@@ -4590,7 +4413,7 @@ const struct real_format real_internal_format =\n     true,\n     false,\n     true,\n-    true \n+    true\n   };\n \f\n /* Set up default mode to format mapping for IEEE.  Everyone else has\n@@ -4618,10 +4441,8 @@ const struct real_format *real_format_for_mode[TFmode - QFmode + 1] =\n    1993.  http://www.hpl.hp.com/techreports/93/HPL-93-42.pdf.  */\n \n bool\n-real_sqrt (r, mode, x)\n-     REAL_VALUE_TYPE *r;\n-     enum machine_mode mode;\n-     const REAL_VALUE_TYPE *x;\n+real_sqrt (REAL_VALUE_TYPE *r, enum machine_mode mode,\n+\t   const REAL_VALUE_TYPE *x)\n {\n   static REAL_VALUE_TYPE halfthree;\n   static bool init = false;\n@@ -4699,11 +4520,8 @@ real_sqrt (r, mode, x)\n    Algorithms\", \"The Art of Computer Programming\", Volume 2.  */\n \n bool\n-real_powi (r, mode, x, n)\n-     REAL_VALUE_TYPE *r;\n-     enum machine_mode mode;\n-     const REAL_VALUE_TYPE *x;\n-     HOST_WIDE_INT n;\n+real_powi (REAL_VALUE_TYPE *r, enum machine_mode mode,\n+\t   const REAL_VALUE_TYPE *x, HOST_WIDE_INT n)\n {\n   unsigned HOST_WIDE_INT bit;\n   REAL_VALUE_TYPE t;\n@@ -4752,10 +4570,8 @@ real_powi (r, mode, x, n)\n    towards zero, placing the result in R in mode MODE.  */\n \n void\n-real_trunc (r, mode, x)\n-     REAL_VALUE_TYPE *r;\n-     enum machine_mode mode;\n-     const REAL_VALUE_TYPE *x;\n+real_trunc (REAL_VALUE_TYPE *r, enum machine_mode mode,\n+\t    const REAL_VALUE_TYPE *x)\n {\n   do_fix_trunc (r, x);\n   if (mode != VOIDmode)\n@@ -4766,10 +4582,8 @@ real_trunc (r, mode, x)\n    down, placing the result in R in mode MODE.  */\n \n void\n-real_floor (r, mode, x)\n-     REAL_VALUE_TYPE *r;\n-     enum machine_mode mode;\n-     const REAL_VALUE_TYPE *x;\n+real_floor (REAL_VALUE_TYPE *r, enum machine_mode mode,\n+\t    const REAL_VALUE_TYPE *x)\n {\n   do_fix_trunc (r, x);\n   if (! real_identical (r, x) && r->sign)\n@@ -4782,15 +4596,12 @@ real_floor (r, mode, x)\n    up, placing the result in R in mode MODE.  */\n \n void\n-real_ceil (r, mode, x)\n-     REAL_VALUE_TYPE *r;\n-     enum machine_mode mode;\n-     const REAL_VALUE_TYPE *x;\n+real_ceil (REAL_VALUE_TYPE *r, enum machine_mode mode,\n+\t   const REAL_VALUE_TYPE *x)\n {\n   do_fix_trunc (r, x);\n   if (! real_identical (r, x) && ! r->sign)\n     do_add (r, r, &dconst1, 0);\n   if (mode != VOIDmode)\n     real_convert (r, mode, r);\n }\n-"}, {"sha": "2b9a371f73ece13efbac253fc038d331d4f5c507", "filename": "gcc/real.h", "status": "modified", "additions": 59, "deletions": 79, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -106,10 +106,10 @@ extern char test_real_width\n struct real_format\n {\n   /* Move to and from the target bytes.  */\n-  void (*encode) PARAMS ((const struct real_format *, long *,\n-\t\t\t  const REAL_VALUE_TYPE *));\n-  void (*decode) PARAMS ((const struct real_format *, REAL_VALUE_TYPE *,\n-\t\t\t  const long *));\n+  void (*encode) (const struct real_format *, long *,\n+\t\t  const REAL_VALUE_TYPE *);\n+  void (*decode) (const struct real_format *, REAL_VALUE_TYPE *,\n+\t\t  const long *);\n \n   /* The radix of the exponent and digits of the significand.  */\n   int b;\n@@ -149,82 +149,72 @@ extern const struct real_format *real_format_for_mode[TFmode - QFmode + 1];\n /* Declare functions in real.c.  */\n \n /* Binary or unary arithmetic on tree_code.  */\n-extern void real_arithmetic\tPARAMS ((REAL_VALUE_TYPE *, int,\n-\t\t\t\t\t const REAL_VALUE_TYPE *,\n-\t\t\t\t\t const REAL_VALUE_TYPE *));\n+extern void real_arithmetic (REAL_VALUE_TYPE *, int, const REAL_VALUE_TYPE *,\n+\t\t\t     const REAL_VALUE_TYPE *);\n \n /* Compare reals by tree_code.  */\n-extern bool real_compare\tPARAMS ((int, const REAL_VALUE_TYPE *,\n-\t\t\t\t\t const REAL_VALUE_TYPE *));\n+extern bool real_compare (int, const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n \n /* Determine whether a floating-point value X is infinite.  */\n-extern bool real_isinf\t\tPARAMS ((const REAL_VALUE_TYPE *));\n+extern bool real_isinf (const REAL_VALUE_TYPE *);\n \n /* Determine whether a floating-point value X is a NaN.  */\n-extern bool real_isnan\t\tPARAMS ((const REAL_VALUE_TYPE *));\n+extern bool real_isnan (const REAL_VALUE_TYPE *);\n \n /* Determine whether a floating-point value X is negative.  */\n-extern bool real_isneg\t\tPARAMS ((const REAL_VALUE_TYPE *));\n+extern bool real_isneg (const REAL_VALUE_TYPE *);\n \n /* Determine whether a floating-point value X is minus zero.  */\n-extern bool real_isnegzero\tPARAMS ((const REAL_VALUE_TYPE *));\n+extern bool real_isnegzero (const REAL_VALUE_TYPE *);\n \n /* Compare two floating-point objects for bitwise identity.  */\n-extern bool real_identical\tPARAMS ((const REAL_VALUE_TYPE *,\n-\t\t\t\t\t const REAL_VALUE_TYPE *));\n+extern bool real_identical (const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n \n /* Extend or truncate to a new mode.  */\n-extern void real_convert\tPARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t const REAL_VALUE_TYPE *));\n+extern void real_convert (REAL_VALUE_TYPE *, enum machine_mode,\n+\t\t\t  const REAL_VALUE_TYPE *);\n \n /* Return true if truncating to NEW is exact.  */\n-extern bool exact_real_truncate PARAMS ((enum machine_mode,\n-\t\t\t\t\t const REAL_VALUE_TYPE *));\n+extern bool exact_real_truncate (enum machine_mode, const REAL_VALUE_TYPE *);\n \n /* Render R as a decimal floating point constant.  */\n-extern void real_to_decimal\tPARAMS ((char *, const REAL_VALUE_TYPE *,\n-\t\t\t\t\t size_t, size_t, int));\n+extern void real_to_decimal (char *, const REAL_VALUE_TYPE *, size_t,\n+\t\t\t     size_t, int);\n \n /* Render R as a hexadecimal floating point constant.  */\n-extern void real_to_hexadecimal\tPARAMS ((char *, const REAL_VALUE_TYPE *,\n-\t\t\t\t\t size_t, size_t, int));\n+extern void real_to_hexadecimal (char *, const REAL_VALUE_TYPE *,\n+\t\t\t\t size_t, size_t, int);\n \n /* Render R as an integer.  */\n-extern HOST_WIDE_INT real_to_integer PARAMS ((const REAL_VALUE_TYPE *));\n-extern void real_to_integer2 PARAMS ((HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t      const REAL_VALUE_TYPE *));\n+extern HOST_WIDE_INT real_to_integer (const REAL_VALUE_TYPE *);\n+extern void real_to_integer2 (HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t      const REAL_VALUE_TYPE *);\n \n /* Initialize R from a decimal or hexadecimal string.  */\n-extern void real_from_string\tPARAMS ((REAL_VALUE_TYPE *, const char *));\n+extern void real_from_string (REAL_VALUE_TYPE *, const char *);\n \n /* Initialize R from an integer pair HIGH/LOW.  */\n-extern void real_from_integer\tPARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t HOST_WIDE_INT, int));\n+extern void real_from_integer (REAL_VALUE_TYPE *, enum machine_mode,\n+\t\t\t       unsigned HOST_WIDE_INT, HOST_WIDE_INT, int);\n \n-extern long real_to_target_fmt\tPARAMS ((long *, const REAL_VALUE_TYPE *,\n-\t\t\t\t\t const struct real_format *));\n-extern long real_to_target\tPARAMS ((long *, const REAL_VALUE_TYPE *,\n-\t\t\t\t\t enum machine_mode));\n+extern long real_to_target_fmt (long *, const REAL_VALUE_TYPE *,\n+\t\t\t\tconst struct real_format *);\n+extern long real_to_target (long *, const REAL_VALUE_TYPE *, enum machine_mode);\n \n-extern void real_from_target_fmt PARAMS ((REAL_VALUE_TYPE *, const long *,\n-\t\t\t\t\t  const struct real_format *));\n-extern void real_from_target\tPARAMS ((REAL_VALUE_TYPE *, const long *,\n-\t\t\t\t\t enum machine_mode));\n+extern void real_from_target_fmt (REAL_VALUE_TYPE *, const long *,\n+\t\t\t\t  const struct real_format *);\n+extern void real_from_target (REAL_VALUE_TYPE *, const long *,\n+\t\t\t      enum machine_mode);\n \n-extern void real_inf\t\tPARAMS ((REAL_VALUE_TYPE *));\n+extern void real_inf (REAL_VALUE_TYPE *);\n \n-extern bool real_nan\t\tPARAMS ((REAL_VALUE_TYPE *, const char *,\n-\t\t\t\t\t int, enum machine_mode));\n+extern bool real_nan (REAL_VALUE_TYPE *, const char *, int, enum machine_mode);\n \n-extern void real_maxval\t\tPARAMS ((REAL_VALUE_TYPE *, int,\n-\t\t\t\t\t enum machine_mode));\n+extern void real_maxval (REAL_VALUE_TYPE *, int, enum machine_mode);\n \n-extern void real_2expN\t\tPARAMS ((REAL_VALUE_TYPE *, int));\n+extern void real_2expN (REAL_VALUE_TYPE *, int);\n \n-extern unsigned int real_hash\tPARAMS ((const REAL_VALUE_TYPE *));\n+extern unsigned int real_hash (const REAL_VALUE_TYPE *);\n \n \n /* Target formats defined in real.c.  */\n@@ -290,25 +280,24 @@ extern const struct real_format real_internal_format;\n #define REAL_VALUE_FROM_UNSIGNED_INT(r, lo, hi, mode) \\\n   real_from_integer (&(r), mode, lo, hi, 1)\n \n-extern REAL_VALUE_TYPE real_value_truncate PARAMS ((enum machine_mode,\n-\t\t\t\t\t\t    REAL_VALUE_TYPE));\n+extern REAL_VALUE_TYPE real_value_truncate (enum machine_mode,\n+\t\t\t\t\t    REAL_VALUE_TYPE);\n \n #define REAL_VALUE_TO_INT(plow, phigh, r) \\\n   real_to_integer2 (plow, phigh, &(r))\n \n-extern REAL_VALUE_TYPE real_arithmetic2 PARAMS ((int, const REAL_VALUE_TYPE *,\n-\t\t\t\t\t\t const REAL_VALUE_TYPE *));\n+extern REAL_VALUE_TYPE real_arithmetic2 (int, const REAL_VALUE_TYPE *,\n+\t\t\t\t\t const REAL_VALUE_TYPE *);\n \n #define REAL_VALUE_NEGATE(X) \\\n   real_arithmetic2 (NEGATE_EXPR, &(X), NULL)\n \n #define REAL_VALUE_ABS(X) \\\n   real_arithmetic2 (ABS_EXPR, &(X), NULL)\n \n-extern int significand_size PARAMS ((enum machine_mode));\n+extern int significand_size (enum machine_mode);\n \n-extern REAL_VALUE_TYPE real_from_string2 PARAMS ((const char *,\n-\t\t\t\t\t\t  enum machine_mode));\n+extern REAL_VALUE_TYPE real_from_string2 (const char *, enum machine_mode);\n \n #define REAL_VALUE_ATOF(s, m) \\\n   real_from_string2 (s, m)\n@@ -326,11 +315,10 @@ extern REAL_VALUE_TYPE real_from_string2 PARAMS ((const char *,\n /* ??? These were added for Paranoia support.  */\n \n /* Return floor log2(R).  */\n-extern int real_exponent\tPARAMS ((const REAL_VALUE_TYPE *));\n+extern int real_exponent (const REAL_VALUE_TYPE *);\n \n /* R = A * 2**EXP.  */\n-extern void real_ldexp\t\tPARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t\t const REAL_VALUE_TYPE *, int));\n+extern void real_ldexp (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, int);\n \n /* **** End of software floating point emulator interface macros **** */\n \f\n@@ -345,8 +333,7 @@ extern REAL_VALUE_TYPE dconsthalf;\n \n /* Function to return a real value (not a tree node)\n    from a given integer constant.  */\n-REAL_VALUE_TYPE real_value_from_int_cst\tPARAMS ((union tree_node *,\n-\t\t\t\t\t\t union tree_node *));\n+REAL_VALUE_TYPE real_value_from_int_cst (union tree_node *, union tree_node *);\n \n /* Given a CONST_DOUBLE in FROM, store into TO the value it represents.  */\n #define REAL_VALUE_FROM_CONST_DOUBLE(to, from) \\\n@@ -355,35 +342,28 @@ REAL_VALUE_TYPE real_value_from_int_cst\tPARAMS ((union tree_node *,\n /* Return a CONST_DOUBLE with value R and mode M.  */\n #define CONST_DOUBLE_FROM_REAL_VALUE(r, m) \\\n   const_double_from_real_value (r, m)\n-extern rtx const_double_from_real_value PARAMS ((REAL_VALUE_TYPE,\n-\t\t\t\t\t\t enum machine_mode));\n+extern rtx const_double_from_real_value (REAL_VALUE_TYPE, enum machine_mode);\n \n /* Replace R by 1/R in the given machine mode, if the result is exact.  */\n-extern bool exact_real_inverse\tPARAMS ((enum machine_mode, REAL_VALUE_TYPE *));\n+extern bool exact_real_inverse (enum machine_mode, REAL_VALUE_TYPE *);\n \n /* In tree.c: wrap up a REAL_VALUE_TYPE in a tree node.  */\n-extern tree build_real\t\t\tPARAMS ((tree, REAL_VALUE_TYPE));\n+extern tree build_real (tree, REAL_VALUE_TYPE);\n \n /* Calculate R as the square root of X in the given machine mode.  */\n-extern bool real_sqrt\t\t\tPARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t const REAL_VALUE_TYPE *));\n+extern bool real_sqrt (REAL_VALUE_TYPE *, enum machine_mode,\n+\t\t       const REAL_VALUE_TYPE *);\n \n /* Calculate R as X raised to the integer exponent N in mode MODE.  */\n-extern bool real_powi\t\t\tPARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t const REAL_VALUE_TYPE *,\n-\t\t\t\t\t\t HOST_WIDE_INT));\n+extern bool real_powi (REAL_VALUE_TYPE *, enum machine_mode,\n+\t\t       const REAL_VALUE_TYPE *, HOST_WIDE_INT);\n \n /* Standard round to integer value functions.  */\n-extern void real_trunc\tPARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t enum machine_mode,\n-\t\t\t\t const REAL_VALUE_TYPE *));\n-extern void real_floor\tPARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t enum machine_mode,\n-\t\t\t\t const REAL_VALUE_TYPE *));\n-extern void real_ceil\tPARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t enum machine_mode,\n-\t\t\t\t const REAL_VALUE_TYPE *));\n+extern void real_trunc (REAL_VALUE_TYPE *, enum machine_mode,\n+\t\t\tconst REAL_VALUE_TYPE *);\n+extern void real_floor (REAL_VALUE_TYPE *, enum machine_mode,\n+\t\t\tconst REAL_VALUE_TYPE *);\n+extern void real_ceil (REAL_VALUE_TYPE *, enum machine_mode,\n+\t\t       const REAL_VALUE_TYPE *);\n \n #endif /* ! GCC_REAL_H */"}, {"sha": "a804669595b34f070d28334e2f899af6ec08fd6a", "filename": "gcc/recog.c", "status": "modified", "additions": 71, "deletions": 161, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -56,10 +56,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #endif\n #endif\n \n-static void validate_replace_rtx_1\tPARAMS ((rtx *, rtx, rtx, rtx));\n-static rtx *find_single_use_1\t\tPARAMS ((rtx, rtx *));\n-static void validate_replace_src_1 \tPARAMS ((rtx *, void *));\n-static rtx split_insn\t\t\tPARAMS ((rtx));\n+static void validate_replace_rtx_1 (rtx *, rtx, rtx, rtx);\n+static rtx *find_single_use_1 (rtx, rtx *);\n+static void validate_replace_src_1 (rtx *, void *);\n+static rtx split_insn (rtx);\n \n /* Nonzero means allow operands to be volatile.\n    This should be 0 if you are generating rtl, such as if you are calling\n@@ -96,13 +96,13 @@ int epilogue_completed;\n    before any insn recognition may be done in the function.  */\n \n void\n-init_recog_no_volatile ()\n+init_recog_no_volatile (void)\n {\n   volatile_ok = 0;\n }\n \n void\n-init_recog ()\n+init_recog (void)\n {\n   volatile_ok = 1;\n }\n@@ -117,8 +117,7 @@ init_recog ()\n    through this one.  (The only exception is in combine.c.)  */\n \n int\n-recog_memoized_1 (insn)\n-     rtx insn;\n+recog_memoized_1 (rtx insn)\n {\n   if (INSN_CODE (insn) < 0)\n     INSN_CODE (insn) = recog (PATTERN (insn), insn, 0);\n@@ -129,8 +128,7 @@ recog_memoized_1 (insn)\n    and that the operands mentioned in it are legitimate.  */\n \n int\n-check_asm_operands (x)\n-     rtx x;\n+check_asm_operands (rtx x)\n {\n   int noperands;\n   rtx *operands;\n@@ -206,11 +204,7 @@ static int num_changes = 0;\n    Otherwise, perform the change and return 1.  */\n \n int\n-validate_change (object, loc, new, in_group)\n-    rtx object;\n-    rtx *loc;\n-    rtx new;\n-    int in_group;\n+validate_change (rtx object, rtx *loc, rtx new, int in_group)\n {\n   rtx old = *loc;\n \n@@ -264,8 +258,7 @@ validate_change (object, loc, new, in_group)\n    were valid; i.e. whether INSN can still be recognized.  */\n \n int\n-insn_invalid_p (insn)\n-     rtx insn;\n+insn_invalid_p (rtx insn)\n {\n   rtx pat = PATTERN (insn);\n   int num_clobbers = 0;\n@@ -315,7 +308,7 @@ insn_invalid_p (insn)\n \n /* Return number of changes made and not validated yet.  */\n int\n-num_changes_pending ()\n+num_changes_pending (void)\n {\n   return num_changes;\n }\n@@ -324,7 +317,7 @@ num_changes_pending ()\n    Return 1 if all changes are valid, zero otherwise.  */\n \n int\n-apply_change_group ()\n+apply_change_group (void)\n {\n   int i;\n   rtx last_validated = NULL_RTX;\n@@ -425,16 +418,15 @@ apply_change_group ()\n /* Return the number of changes so far in the current group.  */\n \n int\n-num_validated_changes ()\n+num_validated_changes (void)\n {\n   return num_changes;\n }\n \n /* Retract the changes numbered NUM and up.  */\n \n void\n-cancel_changes (num)\n-     int num;\n+cancel_changes (int num)\n {\n   int i;\n \n@@ -453,9 +445,7 @@ cancel_changes (num)\n    validate_change passing OBJECT.  */\n \n static void\n-validate_replace_rtx_1 (loc, from, to, object)\n-     rtx *loc;\n-     rtx from, to, object;\n+validate_replace_rtx_1 (rtx *loc, rtx from, rtx to, rtx object)\n {\n   int i, j;\n   const char *fmt;\n@@ -636,8 +626,7 @@ validate_replace_rtx_1 (loc, from, to, object)\n    if INSN is still valid.  */\n \n int\n-validate_replace_rtx_subexp (from, to, insn, loc)\n-     rtx from, to, insn, *loc;\n+validate_replace_rtx_subexp (rtx from, rtx to, rtx insn, rtx *loc)\n {\n   validate_replace_rtx_1 (loc, from, to, insn);\n   return apply_change_group ();\n@@ -647,8 +636,7 @@ validate_replace_rtx_subexp (from, to, insn, loc)\n    changes have been made, validate by seeing if INSN is still valid.  */\n \n int\n-validate_replace_rtx (from, to, insn)\n-     rtx from, to, insn;\n+validate_replace_rtx (rtx from, rtx to, rtx insn)\n {\n   validate_replace_rtx_1 (&PATTERN (insn), from, to, insn);\n   return apply_change_group ();\n@@ -657,8 +645,7 @@ validate_replace_rtx (from, to, insn)\n /* Try replacing every occurrence of FROM in INSN with TO.  */\n \n void\n-validate_replace_rtx_group (from, to, insn)\n-     rtx from, to, insn;\n+validate_replace_rtx_group (rtx from, rtx to, rtx insn)\n {\n   validate_replace_rtx_1 (&PATTERN (insn), from, to, insn);\n }\n@@ -672,9 +659,7 @@ struct validate_replace_src_data\n };\n \n static void\n-validate_replace_src_1 (x, data)\n-     rtx *x;\n-     void *data;\n+validate_replace_src_1 (rtx *x, void *data)\n {\n   struct validate_replace_src_data *d\n     = (struct validate_replace_src_data *) data;\n@@ -686,8 +671,7 @@ validate_replace_src_1 (x, data)\n    SET_DESTs.  */\n \n void\n-validate_replace_src_group (from, to, insn)\n-     rtx from, to, insn;\n+validate_replace_src_group (rtx from, rtx to, rtx insn)\n {\n   struct validate_replace_src_data d;\n \n@@ -700,8 +684,7 @@ validate_replace_src_group (from, to, insn)\n /* Same as validate_replace_src_group, but validate by seeing if\n    INSN is still valid.  */\n int\n-validate_replace_src (from, to, insn)\n-     rtx from, to, insn;\n+validate_replace_src (rtx from, rtx to, rtx insn)\n {\n   validate_replace_src_group (from, to, insn);\n   return apply_change_group ();\n@@ -713,8 +696,7 @@ validate_replace_src (from, to, insn)\n    EQ and NE tests do not count.  */\n \n int\n-next_insn_tests_no_inequality (insn)\n-     rtx insn;\n+next_insn_tests_no_inequality (rtx insn)\n {\n   rtx next = next_cc0_user (insn);\n \n@@ -735,9 +717,7 @@ next_insn_tests_no_inequality (insn)\n    DEST that are being used to totally replace it are not counted.  */\n \n static rtx *\n-find_single_use_1 (dest, loc)\n-     rtx dest;\n-     rtx *loc;\n+find_single_use_1 (rtx dest, rtx *loc)\n {\n   rtx x = *loc;\n   enum rtx_code code = GET_CODE (x);\n@@ -848,10 +828,7 @@ find_single_use_1 (dest, loc)\n    and last insn referencing DEST.  */\n \n rtx *\n-find_single_use (dest, insn, ploc)\n-     rtx dest;\n-     rtx insn;\n-     rtx *ploc;\n+find_single_use (rtx dest, rtx insn, rtx *ploc)\n {\n   rtx next;\n   rtx *result;\n@@ -914,9 +891,7 @@ find_single_use (dest, insn, ploc)\n    class NO_REGS, see the comment for `register_operand'.  */\n \n int\n-general_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+general_operand (rtx op, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -971,7 +946,7 @@ general_operand (op, mode)\n \treturn 0;\n \n       /* FLOAT_MODE subregs can't be paradoxical.  Combine will occasionally\n- \t create such rtl, and we must reject it.  */\n+\t create such rtl, and we must reject it.  */\n       if (GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT\n \t  && GET_MODE_SIZE (GET_MODE (op)) > GET_MODE_SIZE (GET_MODE (sub)))\n \treturn 0;\n@@ -1018,9 +993,7 @@ general_operand (op, mode)\n    expressions in the machine description.  */\n \n int\n-address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+address_operand (rtx op, enum machine_mode mode)\n {\n   return memory_address_p (mode, op);\n }\n@@ -1040,9 +1013,7 @@ address_operand (op, mode)\n    it is most consistent to keep this function from accepting them.  */\n \n int\n-register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+register_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return 0;\n@@ -1093,9 +1064,7 @@ register_operand (op, mode)\n /* Return 1 for a register in Pmode; ignore the tested mode.  */\n \n int\n-pmode_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+pmode_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return register_operand (op, Pmode);\n }\n@@ -1104,9 +1073,7 @@ pmode_register_operand (op, mode)\n    or a hard register.  */\n \n int\n-scratch_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+scratch_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return 0;\n@@ -1122,9 +1089,7 @@ scratch_operand (op, mode)\n    expressions in the machine description.  */\n \n int\n-immediate_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+immediate_operand (rtx op, enum machine_mode mode)\n {\n   /* Don't accept CONST_INT or anything similar\n      if the caller wants something floating.  */\n@@ -1156,9 +1121,7 @@ immediate_operand (op, mode)\n /* Returns 1 if OP is an operand that is a CONST_INT.  */\n \n int\n-const_int_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+const_int_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -1174,9 +1137,7 @@ const_int_operand (op, mode)\n    floating-point number.  */\n \n int\n-const_double_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+const_double_operand (rtx op, enum machine_mode mode)\n {\n   /* Don't accept CONST_INT or anything similar\n      if the caller wants something floating.  */\n@@ -1193,19 +1154,15 @@ const_double_operand (op, mode)\n /* Return 1 if OP is a general operand that is not an immediate operand.  */\n \n int\n-nonimmediate_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+nonimmediate_operand (rtx op, enum machine_mode mode)\n {\n   return (general_operand (op, mode) && ! CONSTANT_P (op));\n }\n \n /* Return 1 if OP is a register reference or immediate value of mode MODE.  */\n \n int\n-nonmemory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+nonmemory_operand (rtx op, enum machine_mode mode)\n {\n   if (CONSTANT_P (op))\n     {\n@@ -1259,9 +1216,7 @@ nonmemory_operand (op, mode)\n    expressions in the machine description.  */\n \n int\n-push_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+push_operand (rtx op, enum machine_mode mode)\n {\n   unsigned int rounded_size = GET_MODE_SIZE (mode);\n \n@@ -1307,9 +1262,7 @@ push_operand (op, mode)\n    expressions in the machine description.  */\n \n int\n-pop_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+pop_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) != MEM)\n     return 0;\n@@ -1328,9 +1281,7 @@ pop_operand (op, mode)\n /* Return 1 if ADDR is a valid memory address for mode MODE.  */\n \n int\n-memory_address_p (mode, addr)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx addr;\n+memory_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx addr)\n {\n   if (GET_CODE (addr) == ADDRESSOF)\n     return 1;\n@@ -1349,9 +1300,7 @@ memory_address_p (mode, addr)\n    expressions in the machine description.  */\n \n int\n-memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+memory_operand (rtx op, enum machine_mode mode)\n {\n   rtx inner;\n \n@@ -1374,9 +1323,7 @@ memory_operand (op, mode)\n    that is, a memory reference whose address is a general_operand.  */\n \n int\n-indirect_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+indirect_operand (rtx op, enum machine_mode mode)\n {\n   /* Before reload, a SUBREG isn't in memory (see memory_operand, above).  */\n   if (! reload_completed\n@@ -1409,9 +1356,7 @@ indirect_operand (op, mode)\n    MATCH_OPERATOR to recognize all the branch insns.  */\n \n int\n-comparison_operator (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+comparison_operator (rtx op, enum machine_mode mode)\n {\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n \t  && GET_RTX_CLASS (GET_CODE (op)) == '<');\n@@ -1422,8 +1367,7 @@ comparison_operator (op, mode)\n    Otherwise return -1.  */\n \n int\n-asm_noperands (body)\n-     rtx body;\n+asm_noperands (rtx body)\n {\n   switch (GET_CODE (body))\n     {\n@@ -1507,12 +1451,8 @@ asm_noperands (body)\n    we don't store that info.  */\n \n const char *\n-decode_asm_operands (body, operands, operand_locs, constraints, modes)\n-     rtx body;\n-     rtx *operands;\n-     rtx **operand_locs;\n-     const char **constraints;\n-     enum machine_mode *modes;\n+decode_asm_operands (rtx body, rtx *operands, rtx **operand_locs,\n+\t\t     const char **constraints, enum machine_mode *modes)\n {\n   int i;\n   int noperands;\n@@ -1644,9 +1584,7 @@ decode_asm_operands (body, operands, operand_locs, constraints, modes)\n    Return > 0 if ok, = 0 if bad, < 0 if inconclusive.  */\n \n int\n-asm_operand_ok (op, constraint)\n-     rtx op;\n-     const char *constraint;\n+asm_operand_ok (rtx op, const char *constraint)\n {\n   int result = 0;\n \n@@ -1861,8 +1799,7 @@ asm_operand_ok (op, constraint)\n    Otherwise, return a null pointer.  */\n \n rtx *\n-find_constant_term_loc (p)\n-     rtx *p;\n+find_constant_term_loc (rtx *p)\n {\n   rtx *tem;\n   enum rtx_code code = GET_CODE (*p);\n@@ -1915,8 +1852,7 @@ find_constant_term_loc (p)\n    don't use it before reload.  */\n \n int\n-offsettable_memref_p (op)\n-     rtx op;\n+offsettable_memref_p (rtx op)\n {\n   return ((GET_CODE (op) == MEM)\n \t  && offsettable_address_p (1, GET_MODE (op), XEXP (op, 0)));\n@@ -1926,8 +1862,7 @@ offsettable_memref_p (op)\n    consider pseudo-regs valid as index or base regs.  */\n \n int\n-offsettable_nonstrict_memref_p (op)\n-     rtx op;\n+offsettable_nonstrict_memref_p (rtx op)\n {\n   return ((GET_CODE (op) == MEM)\n \t  && offsettable_address_p (0, GET_MODE (op), XEXP (op, 0)));\n@@ -1944,16 +1879,13 @@ offsettable_nonstrict_memref_p (op)\n    for the sake of use in reload.c.  */\n \n int\n-offsettable_address_p (strictp, mode, y)\n-     int strictp;\n-     enum machine_mode mode;\n-     rtx y;\n+offsettable_address_p (int strictp, enum machine_mode mode, rtx y)\n {\n   enum rtx_code ycode = GET_CODE (y);\n   rtx z;\n   rtx y1 = y;\n   rtx *y2;\n-  int (*addressp) PARAMS ((enum machine_mode, rtx)) =\n+  int (*addressp) (enum machine_mode, rtx) =\n     (strictp ? strict_memory_address_p : memory_address_p);\n   unsigned int mode_sz = GET_MODE_SIZE (mode);\n \n@@ -2019,8 +1951,7 @@ offsettable_address_p (strictp, mode, y)\n    because the amount of the increment depends on the mode.  */\n \n int\n-mode_dependent_address_p (addr)\n-  rtx addr ATTRIBUTE_UNUSED; /* Maybe used in GO_IF_MODE_DEPENDENT_ADDRESS.  */\n+mode_dependent_address_p (rtx addr ATTRIBUTE_UNUSED /* Maybe used in GO_IF_MODE_DEPENDENT_ADDRESS. */)\n {\n   GO_IF_MODE_DEPENDENT_ADDRESS (addr, win);\n   return 0;\n@@ -2034,8 +1965,7 @@ mode_dependent_address_p (addr)\n    valid information.  This is used primary by gen_attr infrastructure that\n    often does extract insn again and again.  */\n void\n-extract_insn_cached (insn)\n-     rtx insn;\n+extract_insn_cached (rtx insn)\n {\n   if (recog_data.insn == insn && INSN_CODE (insn) >= 0)\n     return;\n@@ -2045,8 +1975,7 @@ extract_insn_cached (insn)\n /* Do cached extract_insn, constrain_operand and complain about failures.\n    Used by insn_attrtab.  */\n void\n-extract_constrain_insn_cached (insn)\n-     rtx insn;\n+extract_constrain_insn_cached (rtx insn)\n {\n   extract_insn_cached (insn);\n   if (which_alternative == -1\n@@ -2055,8 +1984,7 @@ extract_constrain_insn_cached (insn)\n }\n /* Do cached constrain_operand and complain about failures.  */\n int\n-constrain_operands_cached (strict)\n-\tint strict;\n+constrain_operands_cached (int strict)\n {\n   if (which_alternative == -1)\n     return constrain_operands (strict);\n@@ -2067,8 +1995,7 @@ constrain_operands_cached (strict)\n /* Analyze INSN and fill in recog_data.  */\n \n void\n-extract_insn (insn)\n-     rtx insn;\n+extract_insn (rtx insn)\n {\n   int i;\n   int icode;\n@@ -2167,7 +2094,7 @@ extract_insn (insn)\n    information from the constraint strings into a more usable form.\n    The collected data is stored in recog_op_alt.  */\n void\n-preprocess_constraints ()\n+preprocess_constraints (void)\n {\n   int i;\n \n@@ -2326,8 +2253,7 @@ struct funny_match\n };\n \n int\n-constrain_operands (strict)\n-     int strict;\n+constrain_operands (int strict)\n {\n   const char *constraints[MAX_RECOG_OPERANDS];\n   int matching_operands[MAX_RECOG_OPERANDS];\n@@ -2616,7 +2542,7 @@ constrain_operands (strict)\n \t\t      /* Every memory operand can be reloaded to fit.  */\n \t\t      if (strict < 0 && GET_CODE (op) == MEM)\n \t\t\twin = 1;\n-\t\n+\n \t\t      /* Before reload, accept what reload can turn into mem.  */\n \t\t      if (strict < 0 && CONSTANT_P (op))\n \t\t\twin = 1;\n@@ -2704,11 +2630,8 @@ constrain_operands (strict)\n    If REG occupies multiple hard regs, all of them must be in CLASS.  */\n \n int\n-reg_fits_class_p (operand, class, offset, mode)\n-     rtx operand;\n-     enum reg_class class;\n-     int offset;\n-     enum machine_mode mode;\n+reg_fits_class_p (rtx operand, enum reg_class class, int offset,\n+\t\t  enum machine_mode mode)\n {\n   int regno = REGNO (operand);\n   if (regno < FIRST_PSEUDO_REGISTER\n@@ -2731,8 +2654,7 @@ reg_fits_class_p (operand, class, offset, mode)\n /* Split single instruction.  Helper function for split_all_insns.\n    Return last insn in the sequence if successful, or NULL if unsuccessful.  */\n static rtx\n-split_insn (insn)\n-     rtx insn;\n+split_insn (rtx insn)\n {\n   rtx set;\n   if (!INSN_P (insn))\n@@ -2787,8 +2709,7 @@ split_insn (insn)\n /* Split all insns in the function.  If UPD_LIFE, update life info after.  */\n \n void\n-split_all_insns (upd_life)\n-     int upd_life;\n+split_all_insns (int upd_life)\n {\n   sbitmap blocks;\n   bool changed;\n@@ -2852,7 +2773,7 @@ split_all_insns (upd_life)\n    Used by machine dependent reorg passes.  */\n \n void\n-split_all_insns_noflow ()\n+split_all_insns_noflow (void)\n {\n   rtx next, insn;\n \n@@ -2884,8 +2805,7 @@ static int peep2_current;\n    in a multi-insn pattern.  */\n \n rtx\n-peep2_next_insn (n)\n-     int n;\n+peep2_next_insn (int n)\n {\n   if (n >= MAX_INSNS_PER_PEEP2 + 1)\n     abort ();\n@@ -2903,9 +2823,7 @@ peep2_next_insn (n)\n    after `current'.  */\n \n int\n-peep2_regno_dead_p (ofs, regno)\n-     int ofs;\n-     int regno;\n+peep2_regno_dead_p (int ofs, int regno)\n {\n   if (ofs >= MAX_INSNS_PER_PEEP2 + 1)\n     abort ();\n@@ -2923,9 +2841,7 @@ peep2_regno_dead_p (ofs, regno)\n /* Similarly for a REG.  */\n \n int\n-peep2_reg_dead_p (ofs, reg)\n-     int ofs;\n-     rtx reg;\n+peep2_reg_dead_p (int ofs, rtx reg)\n {\n   int regno, n;\n \n@@ -2959,11 +2875,8 @@ peep2_reg_dead_p (ofs, reg)\n    returned.  */\n \n rtx\n-peep2_find_free_register (from, to, class_str, mode, reg_set)\n-     int from, to;\n-     const char *class_str;\n-     enum machine_mode mode;\n-     HARD_REG_SET *reg_set;\n+peep2_find_free_register (int from, int to, const char *class_str,\n+\t\t\t  enum machine_mode mode, HARD_REG_SET *reg_set)\n {\n   static int search_ofs;\n   enum reg_class class;\n@@ -3061,8 +2974,7 @@ peep2_find_free_register (from, to, class_str, mode, reg_set)\n /* Perform the peephole2 optimization pass.  */\n \n void\n-peephole2_optimize (dump_file)\n-     FILE *dump_file ATTRIBUTE_UNUSED;\n+peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n {\n   regset_head rs_heads[MAX_INSNS_PER_PEEP2 + 2];\n   rtx insn, prev;\n@@ -3352,8 +3264,7 @@ peephole2_optimize (dump_file)\n    SETs inside.  */\n \n int\n-store_data_bypass_p (out_insn, in_insn)\n-     rtx out_insn, in_insn;\n+store_data_bypass_p (rtx out_insn, rtx in_insn)\n {\n   rtx out_set, in_set;\n \n@@ -3403,8 +3314,7 @@ store_data_bypass_p (out_insn, in_insn)\n    of insn categorization may be any JUMP or CALL insn.  */\n \n int\n-if_test_bypass_p (out_insn, in_insn)\n-     rtx out_insn, in_insn;\n+if_test_bypass_p (rtx out_insn, rtx in_insn)\n {\n   rtx out_set, in_set;\n "}, {"sha": "b4f47430bedd7ab1fc9d81ed95b2b81e5f1efde4", "filename": "gcc/recog.h", "status": "modified", "additions": 69, "deletions": 71, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Declarations for interface to insn recognizer and insn-output.c.\n-   Copyright (C) 1987, 1996, 1997, 1998, 1999, 2000, 2001\n+   Copyright (C) 1987, 1996, 1997, 1998, 1999, 2000, 2001, 2003\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -54,9 +54,9 @@ struct operand_alternative\n   /* Nonzero if '&' was found in the constraint string.  */\n   unsigned int earlyclobber:1;\n   /* Nonzero if 'm' was found in the constraint string.  */\n-  unsigned int memory_ok:1;  \n+  unsigned int memory_ok:1;\n   /* Nonzero if 'o' was found in the constraint string.  */\n-  unsigned int offmem_ok:1;  \n+  unsigned int offmem_ok:1;\n   /* Nonzero if 'V' was found in the constraint string.  */\n   unsigned int nonoffmem_ok:1;\n   /* Nonzero if '<' was found in the constraint string.  */\n@@ -71,75 +71,73 @@ struct operand_alternative\n };\n \n \n-extern void init_recog\t\t\tPARAMS ((void));\n-extern void init_recog_no_volatile\tPARAMS ((void));\n-extern int recog_memoized_1\t\tPARAMS ((rtx));\n-extern int check_asm_operands\t\tPARAMS ((rtx));\n-extern int asm_operand_ok\t\tPARAMS ((rtx, const char *));\n-extern int validate_change\t\tPARAMS ((rtx, rtx *, rtx, int));\n-extern int insn_invalid_p\t\tPARAMS ((rtx));\n-extern int apply_change_group\t\tPARAMS ((void));\n-extern int num_validated_changes\tPARAMS ((void));\n-extern void cancel_changes\t\tPARAMS ((int));\n-extern int constrain_operands\t\tPARAMS ((int));\n-extern int constrain_operands_cached\tPARAMS ((int));\n-extern int memory_address_p\t\tPARAMS ((enum machine_mode, rtx));\n-extern int strict_memory_address_p\tPARAMS ((enum machine_mode, rtx));\n-extern int validate_replace_rtx_subexp\tPARAMS ((rtx, rtx, rtx, rtx *));\n-extern int validate_replace_rtx\t\tPARAMS ((rtx, rtx, rtx));\n-extern void validate_replace_rtx_group\tPARAMS ((rtx, rtx, rtx));\n-extern int validate_replace_src\t\tPARAMS ((rtx, rtx, rtx));\n-extern void validate_replace_src_group\tPARAMS ((rtx, rtx, rtx));\n-extern int num_changes_pending\t\tPARAMS ((void));\n+extern void init_recog (void);\n+extern void init_recog_no_volatile (void);\n+extern int recog_memoized_1 (rtx);\n+extern int check_asm_operands (rtx);\n+extern int asm_operand_ok (rtx, const char *);\n+extern int validate_change (rtx, rtx *, rtx, int);\n+extern int insn_invalid_p (rtx);\n+extern int apply_change_group (void);\n+extern int num_validated_changes (void);\n+extern void cancel_changes (int);\n+extern int constrain_operands (int);\n+extern int constrain_operands_cached (int);\n+extern int memory_address_p (enum machine_mode, rtx);\n+extern int strict_memory_address_p (enum machine_mode, rtx);\n+extern int validate_replace_rtx_subexp (rtx, rtx, rtx, rtx *);\n+extern int validate_replace_rtx (rtx, rtx, rtx);\n+extern void validate_replace_rtx_group (rtx, rtx, rtx);\n+extern int validate_replace_src (rtx, rtx, rtx);\n+extern void validate_replace_src_group (rtx, rtx, rtx);\n+extern int num_changes_pending (void);\n #ifdef HAVE_cc0\n-extern int next_insn_tests_no_inequality PARAMS ((rtx));\n+extern int next_insn_tests_no_inequality (rtx);\n #endif\n-extern int reg_fits_class_p\t\tPARAMS ((rtx, enum reg_class, int,\n-\t\t\t\t\t       enum machine_mode));\n-extern rtx *find_single_use\t\tPARAMS ((rtx, rtx, rtx *));\n-\n-extern int general_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int address_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int register_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int pmode_register_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int scratch_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int immediate_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int const_int_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int const_double_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int nonimmediate_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int nonmemory_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int push_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int pop_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int memory_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int indirect_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int comparison_operator\t\tPARAMS ((rtx, enum machine_mode));\n-\n-extern int offsettable_memref_p\t\tPARAMS ((rtx));\n-extern int offsettable_nonstrict_memref_p\tPARAMS ((rtx));\n-extern int offsettable_address_p\tPARAMS ((int, enum machine_mode, rtx));\n-extern int mode_dependent_address_p\tPARAMS ((rtx));\n-\n-extern int recog\t\t\tPARAMS ((rtx, rtx, int *));\n-extern void add_clobbers\t\tPARAMS ((rtx, int));\n-extern int added_clobbers_hard_reg_p\tPARAMS ((int));\n-extern void insn_extract\t\tPARAMS ((rtx));\n-extern void extract_insn\t\tPARAMS ((rtx));\n-extern void extract_constrain_insn_cached PARAMS ((rtx));\n-extern void extract_insn_cached\t\tPARAMS ((rtx));\n-extern void preprocess_constraints\tPARAMS ((void));\n-extern rtx peep2_next_insn\t\tPARAMS ((int));\n-extern int peep2_regno_dead_p\t\tPARAMS ((int, int));\n-extern int peep2_reg_dead_p\t\tPARAMS ((int, rtx));\n+extern int reg_fits_class_p (rtx, enum reg_class, int, enum machine_mode);\n+extern rtx *find_single_use (rtx, rtx, rtx *);\n+\n+extern int general_operand (rtx, enum machine_mode);\n+extern int address_operand (rtx, enum machine_mode);\n+extern int register_operand (rtx, enum machine_mode);\n+extern int pmode_register_operand (rtx, enum machine_mode);\n+extern int scratch_operand (rtx, enum machine_mode);\n+extern int immediate_operand (rtx, enum machine_mode);\n+extern int const_int_operand (rtx, enum machine_mode);\n+extern int const_double_operand (rtx, enum machine_mode);\n+extern int nonimmediate_operand (rtx, enum machine_mode);\n+extern int nonmemory_operand (rtx, enum machine_mode);\n+extern int push_operand (rtx, enum machine_mode);\n+extern int pop_operand (rtx, enum machine_mode);\n+extern int memory_operand (rtx, enum machine_mode);\n+extern int indirect_operand (rtx, enum machine_mode);\n+extern int comparison_operator (rtx, enum machine_mode);\n+\n+extern int offsettable_memref_p (rtx);\n+extern int offsettable_nonstrict_memref_p (rtx);\n+extern int offsettable_address_p (int, enum machine_mode, rtx);\n+extern int mode_dependent_address_p (rtx);\n+\n+extern int recog (rtx, rtx, int *);\n+extern void add_clobbers (rtx, int);\n+extern int added_clobbers_hard_reg_p (int);\n+extern void insn_extract (rtx);\n+extern void extract_insn (rtx);\n+extern void extract_constrain_insn_cached (rtx);\n+extern void extract_insn_cached (rtx);\n+extern void preprocess_constraints (void);\n+extern rtx peep2_next_insn (int);\n+extern int peep2_regno_dead_p (int, int);\n+extern int peep2_reg_dead_p (int, rtx);\n #ifdef CLEAR_HARD_REG_SET\n-extern rtx peep2_find_free_register\tPARAMS ((int, int, const char *,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t HARD_REG_SET *));\n+extern rtx peep2_find_free_register (int, int, const char *,\n+\t\t\t\t     enum machine_mode, HARD_REG_SET *);\n #endif\n-extern void peephole2_optimize\t\tPARAMS ((FILE *));\n-extern rtx peephole2_insns\t\tPARAMS ((rtx, rtx, int *));\n+extern void peephole2_optimize (FILE *);\n+extern rtx peephole2_insns (rtx, rtx, int *);\n \n-extern int store_data_bypass_p\t\tPARAMS ((rtx, rtx));\n-extern int if_test_bypass_p\t\tPARAMS ((rtx, rtx));\n+extern int store_data_bypass_p (rtx, rtx);\n+extern int if_test_bypass_p (rtx, rtx);\n \n /* Nonzero means volatile operands are recognized.  */\n extern int volatile_ok;\n@@ -182,7 +180,7 @@ struct recog_data\n   char dup_num[MAX_DUP_OPERANDS];\n \n   /* ??? Note that these are `char' instead of `unsigned char' to (try to)\n-     avoid certain lossage from K&R C, wherein `unsigned char' default \n+     avoid certain lossage from K&R C, wherein `unsigned char' default\n      promotes to `unsigned int' instead of `int' as in ISO C.  As of 1999,\n      the most common places to bootstrap from K&R C are SunOS and HPUX,\n      both of which have signed characters by default.  The only other\n@@ -213,9 +211,9 @@ extern struct operand_alternative recog_op_alt[MAX_RECOG_OPERANDS][MAX_RECOG_ALT\n /* A table defined in insn-output.c that give information about\n    each insn-code value.  */\n \n-typedef int (*insn_operand_predicate_fn) PARAMS ((rtx, enum machine_mode));\n-typedef const char * (*insn_output_fn) PARAMS ((rtx *, rtx));\n-typedef rtx (*insn_gen_fn) PARAMS ((rtx, ...));\n+typedef int (*insn_operand_predicate_fn) (rtx, enum machine_mode);\n+typedef const char * (*insn_output_fn) (rtx *, rtx);\n+typedef rtx (*insn_gen_fn) (rtx, ...);\n \n struct insn_operand_data\n {"}, {"sha": "299ba0e6501e4b606f807e574e6bf39efefeddbc", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 63, "deletions": 122, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -236,45 +236,41 @@ static rtx nan;\n \n /* Forward declarations */\n \n-static int stack_regs_mentioned_p\tPARAMS ((rtx pat));\n-static void straighten_stack\t\tPARAMS ((rtx, stack));\n-static void pop_stack\t\t\tPARAMS ((stack, int));\n-static rtx *get_true_reg\t\tPARAMS ((rtx *));\n-\n-static int check_asm_stack_operands\tPARAMS ((rtx));\n-static int get_asm_operand_n_inputs\tPARAMS ((rtx));\n-static rtx stack_result\t\t\tPARAMS ((tree));\n-static void replace_reg\t\t\tPARAMS ((rtx *, int));\n-static void remove_regno_note\t\tPARAMS ((rtx, enum reg_note,\n-\t\t\t\t\t\t unsigned int));\n-static int get_hard_regnum\t\tPARAMS ((stack, rtx));\n-static rtx emit_pop_insn\t\tPARAMS ((rtx, stack, rtx,\n-\t\t\t\t\t       enum emit_where));\n-static void emit_swap_insn\t\tPARAMS ((rtx, stack, rtx));\n-static void move_for_stack_reg\t\tPARAMS ((rtx, stack, rtx));\n-static int swap_rtx_condition_1\t\tPARAMS ((rtx));\n-static int swap_rtx_condition\t\tPARAMS ((rtx));\n-static void compare_for_stack_reg\tPARAMS ((rtx, stack, rtx));\n-static void subst_stack_regs_pat\tPARAMS ((rtx, stack, rtx));\n-static void subst_asm_stack_regs\tPARAMS ((rtx, stack));\n-static void subst_stack_regs\t\tPARAMS ((rtx, stack));\n-static void change_stack\t\tPARAMS ((rtx, stack, stack,\n-\t\t\t\t\t       enum emit_where));\n-static int convert_regs_entry\t\tPARAMS ((void));\n-static void convert_regs_exit\t\tPARAMS ((void));\n-static int convert_regs_1\t\tPARAMS ((FILE *, basic_block));\n-static int convert_regs_2\t\tPARAMS ((FILE *, basic_block));\n-static int convert_regs\t\t\tPARAMS ((FILE *));\n-static void print_stack \t\tPARAMS ((FILE *, stack));\n-static rtx next_flags_user \t\tPARAMS ((rtx));\n-static void record_label_references\tPARAMS ((rtx, rtx));\n-static bool compensate_edge\t\tPARAMS ((edge, FILE *));\n+static int stack_regs_mentioned_p (rtx pat);\n+static void straighten_stack (rtx, stack);\n+static void pop_stack (stack, int);\n+static rtx *get_true_reg (rtx *);\n+\n+static int check_asm_stack_operands (rtx);\n+static int get_asm_operand_n_inputs (rtx);\n+static rtx stack_result (tree);\n+static void replace_reg (rtx *, int);\n+static void remove_regno_note (rtx, enum reg_note, unsigned int);\n+static int get_hard_regnum (stack, rtx);\n+static rtx emit_pop_insn (rtx, stack, rtx, enum emit_where);\n+static void emit_swap_insn (rtx, stack, rtx);\n+static void move_for_stack_reg (rtx, stack, rtx);\n+static int swap_rtx_condition_1 (rtx);\n+static int swap_rtx_condition (rtx);\n+static void compare_for_stack_reg (rtx, stack, rtx);\n+static void subst_stack_regs_pat (rtx, stack, rtx);\n+static void subst_asm_stack_regs (rtx, stack);\n+static void subst_stack_regs (rtx, stack);\n+static void change_stack (rtx, stack, stack, enum emit_where);\n+static int convert_regs_entry (void);\n+static void convert_regs_exit (void);\n+static int convert_regs_1 (FILE *, basic_block);\n+static int convert_regs_2 (FILE *, basic_block);\n+static int convert_regs (FILE *);\n+static void print_stack (FILE *, stack);\n+static rtx next_flags_user (rtx);\n+static void record_label_references (rtx, rtx);\n+static bool compensate_edge (edge, FILE *);\n \f\n /* Return nonzero if any stack register is mentioned somewhere within PAT.  */\n \n static int\n-stack_regs_mentioned_p (pat)\n-     rtx pat;\n+stack_regs_mentioned_p (rtx pat)\n {\n   const char *fmt;\n   int i;\n@@ -303,8 +299,7 @@ stack_regs_mentioned_p (pat)\n /* Return nonzero if INSN mentions stacked registers, else return zero.  */\n \n int\n-stack_regs_mentioned (insn)\n-     rtx insn;\n+stack_regs_mentioned (rtx insn)\n {\n   unsigned int uid, max;\n   int test;\n@@ -336,8 +331,7 @@ stack_regs_mentioned (insn)\n static rtx ix86_flags_rtx;\n \n static rtx\n-next_flags_user (insn)\n-     rtx insn;\n+next_flags_user (rtx insn)\n {\n   /* Search forward looking for the first use of this value.\n      Stop at block boundaries.  */\n@@ -359,9 +353,7 @@ next_flags_user (insn)\n    after this insn.  */\n \n static void\n-straighten_stack (insn, regstack)\n-     rtx insn;\n-     stack regstack;\n+straighten_stack (rtx insn, stack regstack)\n {\n   struct stack_def temp_stack;\n   int top;\n@@ -384,9 +376,7 @@ straighten_stack (insn, regstack)\n /* Pop a register from the stack.  */\n \n static void\n-pop_stack (regstack, regno)\n-     stack regstack;\n-     int   regno;\n+pop_stack (stack regstack, int regno)\n {\n   int top = regstack->top;\n \n@@ -417,9 +407,7 @@ pop_stack (regstack, regno)\n    the edges.  */\n \n bool\n-reg_to_stack (first, file)\n-     rtx first;\n-     FILE *file;\n+reg_to_stack (rtx first, FILE *file)\n {\n   basic_block bb;\n   int i;\n@@ -437,7 +425,7 @@ reg_to_stack (first, file)\n     return false;\n \n   /* Ok, floating point instructions exist.  If not optimizing,\n-     build the CFG and run life analysis.  \n+     build the CFG and run life analysis.\n      Also need to rebuild life when superblock scheduling is done\n      as it don't update liveness yet.  */\n   if (!optimize\n@@ -507,8 +495,7 @@ reg_to_stack (first, file)\n    reference.  */\n \n static void\n-record_label_references (insn, pat)\n-     rtx insn, pat;\n+record_label_references (rtx insn, rtx pat)\n {\n   enum rtx_code code = GET_CODE (pat);\n   int i;\n@@ -561,8 +548,7 @@ record_label_references (insn, pat)\n    PAT that stopped the search.  */\n \n static rtx *\n-get_true_reg (pat)\n-     rtx *pat;\n+get_true_reg (rtx *pat)\n {\n   for (;;)\n     switch (GET_CODE (*pat))\n@@ -599,8 +585,7 @@ static bool any_malformed_asm;\n    numbers below refer to that explanation.  */\n \n static int\n-check_asm_stack_operands (insn)\n-     rtx insn;\n+check_asm_stack_operands (rtx insn)\n {\n   int i;\n   int n_clobbers;\n@@ -788,8 +773,7 @@ check_asm_stack_operands (insn)\n    placed.  */\n \n static int\n-get_asm_operand_n_inputs (body)\n-     rtx body;\n+get_asm_operand_n_inputs (rtx body)\n {\n   if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n     return ASM_OPERANDS_INPUT_LENGTH (SET_SRC (body));\n@@ -812,8 +796,7 @@ get_asm_operand_n_inputs (body)\n    return the REG.  Otherwise, return 0.  */\n \n static rtx\n-stack_result (decl)\n-     tree decl;\n+stack_result (tree decl)\n {\n   rtx result;\n \n@@ -846,9 +829,7 @@ stack_result (decl)\n    the desired hard REGNO.  */\n \n static void\n-replace_reg (reg, regno)\n-     rtx *reg;\n-     int regno;\n+replace_reg (rtx *reg, int regno)\n {\n   if (regno < FIRST_STACK_REG || regno > LAST_STACK_REG\n       || ! STACK_REG_P (*reg))\n@@ -868,10 +849,7 @@ replace_reg (reg, regno)\n    number REGNO from INSN.  Remove only one such note.  */\n \n static void\n-remove_regno_note (insn, note, regno)\n-     rtx insn;\n-     enum reg_note note;\n-     unsigned int regno;\n+remove_regno_note (rtx insn, enum reg_note note, unsigned int regno)\n {\n   rtx *note_link, this;\n \n@@ -894,9 +872,7 @@ remove_regno_note (insn, note, regno)\n    returned if the register is not found.  */\n \n static int\n-get_hard_regnum (regstack, reg)\n-     stack regstack;\n-     rtx reg;\n+get_hard_regnum (stack regstack, rtx reg)\n {\n   int i;\n \n@@ -918,11 +894,7 @@ get_hard_regnum (regstack, reg)\n    cases the movdf pattern to pop.  */\n \n static rtx\n-emit_pop_insn (insn, regstack, reg, where)\n-     rtx insn;\n-     stack regstack;\n-     rtx reg;\n-     enum emit_where where;\n+emit_pop_insn (rtx insn, stack regstack, rtx reg, enum emit_where where)\n {\n   rtx pop_insn, pop_rtx;\n   int hard_regno;\n@@ -977,10 +949,7 @@ emit_pop_insn (insn, regstack, reg, where)\n    If REG is already at the top of the stack, no insn is emitted.  */\n \n static void\n-emit_swap_insn (insn, regstack, reg)\n-     rtx insn;\n-     stack regstack;\n-     rtx reg;\n+emit_swap_insn (rtx insn, stack regstack, rtx reg)\n {\n   int hard_regno;\n   rtx swap_rtx;\n@@ -1062,10 +1031,7 @@ emit_swap_insn (insn, regstack, reg)\n    REGSTACK is the current stack.  */\n \n static void\n-move_for_stack_reg (insn, regstack, pat)\n-     rtx insn;\n-     stack regstack;\n-     rtx pat;\n+move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n {\n   rtx *psrc =  get_true_reg (&SET_SRC (pat));\n   rtx *pdest = get_true_reg (&SET_DEST (pat));\n@@ -1209,8 +1175,7 @@ move_for_stack_reg (insn, regstack, pat)\n    such.  */\n \n static int\n-swap_rtx_condition_1 (pat)\n-     rtx pat;\n+swap_rtx_condition_1 (rtx pat)\n {\n   const char *fmt;\n   int i, r = 0;\n@@ -1241,8 +1206,7 @@ swap_rtx_condition_1 (pat)\n }\n \n static int\n-swap_rtx_condition (insn)\n-     rtx insn;\n+swap_rtx_condition (rtx insn)\n {\n   rtx pat = PATTERN (insn);\n \n@@ -1329,10 +1293,7 @@ swap_rtx_condition (insn)\n    set up.  */\n \n static void\n-compare_for_stack_reg (insn, regstack, pat_src)\n-     rtx insn;\n-     stack regstack;\n-     rtx pat_src;\n+compare_for_stack_reg (rtx insn, stack regstack, rtx pat_src)\n {\n   rtx *src1, *src2;\n   rtx src1_note, src2_note;\n@@ -1421,10 +1382,7 @@ compare_for_stack_reg (insn, regstack, pat_src)\n    is the current register layout.  */\n \n static void\n-subst_stack_regs_pat (insn, regstack, pat)\n-     rtx insn;\n-     stack regstack;\n-     rtx pat;\n+subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n {\n   rtx *dest, *src;\n \n@@ -1749,7 +1707,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t\t  struct stack_def temp_stack;\n \t\t  int regno, j, k, temp;\n \n- \t\t  temp_stack = *regstack;\n+\t\t  temp_stack = *regstack;\n \n \t\t  /* Place operand 1 at the top of stack.  */\n \t\t  regno = get_hard_regnum (&temp_stack, *src1);\n@@ -1937,9 +1895,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n    requirements, since record_asm_stack_regs removes any problem asm.  */\n \n static void\n-subst_asm_stack_regs (insn, regstack)\n-     rtx insn;\n-     stack regstack;\n+subst_asm_stack_regs (rtx insn, stack regstack)\n {\n   rtx body = PATTERN (insn);\n   int alt;\n@@ -2226,9 +2182,7 @@ subst_asm_stack_regs (insn, regstack)\n    stack for the 387 based on the contents of the insn.  */\n \n static void\n-subst_stack_regs (insn, regstack)\n-     rtx insn;\n-     stack regstack;\n+subst_stack_regs (rtx insn, stack regstack)\n {\n   rtx *note_link, note;\n   int i;\n@@ -2320,11 +2274,7 @@ subst_stack_regs (insn, regstack)\n    is no longer needed once this has executed.  */\n \n static void\n-change_stack (insn, old, new, where)\n-     rtx insn;\n-     stack old;\n-     stack new;\n-     enum emit_where where;\n+change_stack (rtx insn, stack old, stack new, enum emit_where where)\n {\n   int reg;\n   int update_end = 0;\n@@ -2423,9 +2373,7 @@ change_stack (insn, old, new, where)\n /* Print stack configuration.  */\n \n static void\n-print_stack (file, s)\n-     FILE *file;\n-     stack s;\n+print_stack (FILE *file, stack s)\n {\n   if (! file)\n     return;\n@@ -2453,7 +2401,7 @@ print_stack (file, s)\n    commit_edge_insertions needs to be called.  */\n \n static int\n-convert_regs_entry ()\n+convert_regs_entry (void)\n {\n   int inserted = 0;\n   edge e;\n@@ -2516,7 +2464,7 @@ convert_regs_entry ()\n    be `empty', or the function return value at top-of-stack.  */\n \n static void\n-convert_regs_exit ()\n+convert_regs_exit (void)\n {\n   int value_reg_low, value_reg_high;\n   stack output_stack;\n@@ -2551,9 +2499,7 @@ convert_regs_exit ()\n    target block, or copy stack info into the stack of the successor\n    of the successor hasn't been processed yet.  */\n static bool\n-compensate_edge (e, file)\n-    edge e;\n-    FILE *file;\n+compensate_edge (edge e, FILE *file)\n {\n   basic_block block = e->src, target = e->dest;\n   block_info bi = BLOCK_INFO (block);\n@@ -2688,9 +2634,7 @@ compensate_edge (e, file)\n /* Convert stack register references in one block.  */\n \n static int\n-convert_regs_1 (file, block)\n-     FILE *file;\n-     basic_block block;\n+convert_regs_1 (FILE *file, basic_block block)\n {\n   struct stack_def regstack;\n   block_info bi = BLOCK_INFO (block);\n@@ -2851,9 +2795,7 @@ convert_regs_1 (file, block)\n /* Convert registers in all blocks reachable from BLOCK.  */\n \n static int\n-convert_regs_2 (file, block)\n-     FILE *file;\n-     basic_block block;\n+convert_regs_2 (FILE *file, basic_block block)\n {\n   basic_block *stack, *sp;\n   int inserted;\n@@ -2890,8 +2832,7 @@ convert_regs_2 (file, block)\n    to the stack-like registers the 387 uses.  */\n \n static int\n-convert_regs (file)\n-     FILE *file;\n+convert_regs (FILE *file)\n {\n   int inserted;\n   basic_block b;"}, {"sha": "c24dfd4c9523cab634d579e0d0ce1e01953f9c2a", "filename": "gcc/regclass.c", "status": "modified", "additions": 52, "deletions": 105, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -45,9 +45,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"timevar.h\"\n \n-static void init_reg_sets_1\tPARAMS ((void));\n-static void init_reg_modes\tPARAMS ((void));\n-static void init_reg_autoinc\tPARAMS ((void));\n+static void init_reg_sets_1 (void);\n+static void init_reg_modes (void);\n+static void init_reg_autoinc (void);\n \n /* If we have auto-increment or auto-decrement and we can have secondary\n    reloads, we are not allowed to use classes requiring secondary\n@@ -261,7 +261,7 @@ static int no_global_reg_vars = 0;\n    Once this is done, various switches may override.  */\n \n void\n-init_reg_sets ()\n+init_reg_sets (void)\n {\n   int i, j;\n \n@@ -296,7 +296,7 @@ init_reg_sets ()\n    `fixed_regs' and `call_used_regs', convert them to HARD_REG_SETs.  */\n \n static void\n-init_reg_sets_1 ()\n+init_reg_sets_1 (void)\n {\n   unsigned int i, j;\n   unsigned int /* enum machine_mode */ m;\n@@ -547,7 +547,7 @@ init_reg_sets_1 ()\n    (as opposed to a multi-register mode).  */\n \n static void\n-init_reg_modes ()\n+init_reg_modes (void)\n {\n   int i;\n \n@@ -569,7 +569,7 @@ init_reg_modes ()\n    initialize the register modes.  */\n \n void\n-init_regs ()\n+init_regs (void)\n {\n   /* This finishes what was started by init_reg_sets, but couldn't be done\n      until after register usage was specified.  */\n@@ -584,7 +584,7 @@ init_regs ()\n    memory_move_secondary_cost.  */\n \n void\n-init_fake_stack_mems ()\n+init_fake_stack_mems (void)\n {\n #ifdef HAVE_SECONDARY_RELOADS\n   {\n@@ -602,10 +602,7 @@ init_fake_stack_mems ()\n    Only needed if secondary reloads are required for memory moves.  */\n \n int\n-memory_move_secondary_cost (mode, class, in)\n-     enum machine_mode mode;\n-     enum reg_class class;\n-     int in;\n+memory_move_secondary_cost (enum machine_mode mode, enum reg_class class, int in)\n {\n   enum reg_class altclass;\n   int partial_cost = 0;\n@@ -659,9 +656,8 @@ memory_move_secondary_cost (mode, class, in)\n    enough to save nregs.  If we can't find one, return VOIDmode.  */\n \n enum machine_mode\n-choose_hard_reg_mode (regno, nregs)\n-     unsigned int regno ATTRIBUTE_UNUSED;\n-     unsigned int nregs;\n+choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n+\t\t      unsigned int nregs)\n {\n   unsigned int /* enum machine_mode */ m;\n   enum machine_mode found_mode = VOIDmode, mode;\n@@ -728,9 +724,7 @@ choose_hard_reg_mode (regno, nregs)\n    call-used register if CALL_USED.  */\n \n void\n-fix_register (name, fixed, call_used)\n-     const char *name;\n-     int fixed, call_used;\n+fix_register (const char *name, int fixed, int call_used)\n {\n   int i;\n \n@@ -774,8 +768,7 @@ fix_register (name, fixed, call_used)\n /* Mark register number I as global.  */\n \n void\n-globalize_reg (i)\n-     int i;\n+globalize_reg (int i)\n {\n   if (fixed_regs[i] == 0 && no_global_reg_vars)\n     error (\"global register variable follows a function definition\");\n@@ -854,36 +847,33 @@ static struct reg_pref *reg_pref_buffer;\n \n static int frequency;\n \n-static rtx scan_one_insn\tPARAMS ((rtx, int));\n-static void record_operand_costs PARAMS ((rtx, struct costs *, struct reg_pref *));\n-static void dump_regclass\tPARAMS ((FILE *));\n-static void record_reg_classes\tPARAMS ((int, int, rtx *, enum machine_mode *,\n-\t\t\t\t       const char **, rtx,\n-\t\t\t\t       struct costs *, struct reg_pref *));\n-static int copy_cost\t\tPARAMS ((rtx, enum machine_mode,\n-\t\t\t\t       enum reg_class, int));\n-static void record_address_regs\tPARAMS ((rtx, enum reg_class, int));\n+static rtx scan_one_insn (rtx, int);\n+static void record_operand_costs (rtx, struct costs *, struct reg_pref *);\n+static void dump_regclass (FILE *);\n+static void record_reg_classes (int, int, rtx *, enum machine_mode *,\n+\t\t\t\tconst char **, rtx, struct costs *,\n+\t\t\t\tstruct reg_pref *);\n+static int copy_cost (rtx, enum machine_mode, enum reg_class, int);\n+static void record_address_regs (rtx, enum reg_class, int);\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n-static int auto_inc_dec_reg_p\tPARAMS ((rtx, enum machine_mode));\n+static int auto_inc_dec_reg_p (rtx, enum machine_mode);\n #endif\n-static void reg_scan_mark_refs\tPARAMS ((rtx, rtx, int, unsigned int));\n+static void reg_scan_mark_refs (rtx, rtx, int, unsigned int);\n \n /* Return the reg_class in which pseudo reg number REGNO is best allocated.\n    This function is sometimes called before the info has been computed.\n    When that happens, just return GENERAL_REGS, which is innocuous.  */\n \n enum reg_class\n-reg_preferred_class (regno)\n-     int regno;\n+reg_preferred_class (int regno)\n {\n   if (reg_pref == 0)\n     return GENERAL_REGS;\n   return (enum reg_class) reg_pref[regno].prefclass;\n }\n \n enum reg_class\n-reg_alternate_class (regno)\n-     int regno;\n+reg_alternate_class (int regno)\n {\n   if (reg_pref == 0)\n     return ALL_REGS;\n@@ -894,7 +884,7 @@ reg_alternate_class (regno)\n /* Initialize some global data for this pass.  */\n \n void\n-regclass_init ()\n+regclass_init (void)\n {\n   int i;\n \n@@ -912,8 +902,7 @@ regclass_init ()\n \f\n /* Dump register costs.  */\n static void\n-dump_regclass (dump)\n-     FILE *dump;\n+dump_regclass (FILE *dump)\n {\n   static const char *const reg_class_names[] = REG_CLASS_NAMES;\n   int i;\n@@ -945,10 +934,8 @@ dump_regclass (dump)\n /* Calculate the costs of insn operands.  */\n \n static void\n-record_operand_costs (insn, op_costs, reg_pref)\n-     rtx insn;\n-     struct costs *op_costs;\n-     struct reg_pref *reg_pref;\n+record_operand_costs (rtx insn, struct costs *op_costs,\n+\t\t      struct reg_pref *reg_pref)\n {\n   const char *constraints[MAX_RECOG_OPERANDS];\n   enum machine_mode modes[MAX_RECOG_OPERANDS];\n@@ -1018,9 +1005,7 @@ record_operand_costs (insn, op_costs, reg_pref)\n    there.  */\n \n static rtx\n-scan_one_insn (insn, pass)\n-     rtx insn;\n-     int pass;\n+scan_one_insn (rtx insn, int pass)\n {\n   enum rtx_code code = GET_CODE (insn);\n   enum rtx_code pat_code;\n@@ -1147,7 +1132,7 @@ scan_one_insn (insn, pass)\n    pseudos that are auto-incremented or auto-decremented.  */\n \n static void\n-init_reg_autoinc ()\n+init_reg_autoinc (void)\n {\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n   int i;\n@@ -1203,10 +1188,7 @@ init_reg_autoinc ()\n    This pass comes just before local register allocation.  */\n \n void\n-regclass (f, nregs, dump)\n-     rtx f;\n-     int nregs;\n-     FILE *dump;\n+regclass (rtx f, int nregs, FILE *dump)\n {\n   rtx insn;\n   int i;\n@@ -1395,16 +1377,10 @@ regclass (f, nregs, dump)\n    alternatives.  */\n \n static void\n-record_reg_classes (n_alts, n_ops, ops, modes,\n-\t\t    constraints, insn, op_costs, reg_pref)\n-     int n_alts;\n-     int n_ops;\n-     rtx *ops;\n-     enum machine_mode *modes;\n-     const char **constraints;\n-     rtx insn;\n-     struct costs *op_costs;\n-     struct reg_pref *reg_pref;\n+record_reg_classes (int n_alts, int n_ops, rtx *ops,\n+\t\t    enum machine_mode *modes, const char **constraints,\n+\t\t    rtx insn, struct costs *op_costs,\n+\t\t    struct reg_pref *reg_pref)\n {\n   int alt;\n   int i, j;\n@@ -1886,11 +1862,8 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n    X must not be a pseudo.  */\n \n static int\n-copy_cost (x, mode, class, to_p)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     enum reg_class class;\n-     int to_p ATTRIBUTE_UNUSED;\n+copy_cost (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t   enum reg_class class, int to_p ATTRIBUTE_UNUSED)\n {\n #ifdef HAVE_SECONDARY_RELOADS\n   enum reg_class secondary_class = NO_REGS;\n@@ -1951,10 +1924,7 @@ copy_cost (x, mode, class, to_p)\n    can represent half-cost adjustments).  */\n \n static void\n-record_address_regs (x, class, scale)\n-     rtx x;\n-     enum reg_class class;\n-     int scale;\n+record_address_regs (rtx x, enum reg_class class, int scale)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -2135,9 +2105,7 @@ record_address_regs (x, class, scale)\n    to an object of MODE.  */\n \n static int\n-auto_inc_dec_reg_p (reg, mode)\n-     rtx reg;\n-     enum machine_mode mode;\n+auto_inc_dec_reg_p (rtx reg, enum machine_mode mode)\n {\n   if (HAVE_POST_INCREMENT\n       && memory_address_p (mode, gen_rtx_POST_INC (Pmode, reg)))\n@@ -2171,10 +2139,7 @@ static unsigned int reg_n_max;\n    RENUMBER_P is nonzero, allocate the reg_renumber array also.  */\n \n void\n-allocate_reg_info (num_regs, new_p, renumber_p)\n-     size_t num_regs;\n-     int new_p;\n-     int renumber_p;\n+allocate_reg_info (size_t num_regs, int new_p, int renumber_p)\n {\n   size_t size_info;\n   size_t size_renumber;\n@@ -2278,7 +2243,7 @@ allocate_reg_info (num_regs, new_p, renumber_p)\n \n /* Free up the space allocated by allocate_reg_info.  */\n void\n-free_reg_info ()\n+free_reg_info (void)\n {\n   if (reg_n_info)\n     {\n@@ -2324,10 +2289,7 @@ int max_parallel;\n static int max_set_parallel;\n \n void\n-reg_scan (f, nregs, repeat)\n-     rtx f;\n-     unsigned int nregs;\n-     int repeat ATTRIBUTE_UNUSED;\n+reg_scan (rtx f, unsigned int nregs, int repeat ATTRIBUTE_UNUSED)\n {\n   rtx insn;\n \n@@ -2362,10 +2324,7 @@ reg_scan (f, nregs, repeat)\n    such a REG.  We only update information for those.  */\n \n void\n-reg_scan_update (first, last, old_max_regno)\n-     rtx first;\n-     rtx last;\n-     unsigned int old_max_regno;\n+reg_scan_update (rtx first, rtx last, unsigned int old_max_regno)\n {\n   rtx insn;\n \n@@ -2392,11 +2351,7 @@ reg_scan_update (first, last, old_max_regno)\n    greater than or equal to MIN_REGNO.  */\n \n static void\n-reg_scan_mark_refs (x, insn, note_flag, min_regno)\n-     rtx x;\n-     rtx insn;\n-     int note_flag;\n-     unsigned int min_regno;\n+reg_scan_mark_refs (rtx x, rtx insn, int note_flag, unsigned int min_regno)\n {\n   enum rtx_code code;\n   rtx dest;\n@@ -2573,9 +2528,7 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n    is also in C2.  */\n \n int\n-reg_class_subset_p (c1, c2)\n-     enum reg_class c1;\n-     enum reg_class c2;\n+reg_class_subset_p (enum reg_class c1, enum reg_class c2)\n {\n   if (c1 == c2) return 1;\n \n@@ -2591,9 +2544,7 @@ reg_class_subset_p (c1, c2)\n /* Return nonzero if there is a register that is in both C1 and C2.  */\n \n int\n-reg_classes_intersect_p (c1, c2)\n-     enum reg_class c1;\n-     enum reg_class c2;\n+reg_classes_intersect_p (enum reg_class c1, enum reg_class c2)\n {\n #ifdef HARD_REG_SET\n   register\n@@ -2618,7 +2569,7 @@ reg_classes_intersect_p (c1, c2)\n /* Release any memory allocated by register sets.  */\n \n void\n-regset_release_memory ()\n+regset_release_memory (void)\n {\n   bitmap_release_memory ();\n }\n@@ -2628,10 +2579,8 @@ regset_release_memory ()\n    their mode from FROM to any mode in which REGNO was encountered.  */\n \n void\n-cannot_change_mode_set_regs (used, from, regno)\n-     HARD_REG_SET *used;\n-     enum machine_mode from;\n-     unsigned int regno;\n+cannot_change_mode_set_regs (HARD_REG_SET *used, enum machine_mode from,\n+\t\t\t     unsigned int regno)\n {\n   enum machine_mode to;\n   int n, i;\n@@ -2652,10 +2601,8 @@ cannot_change_mode_set_regs (used, from, regno)\n    mode.  */\n \n bool\n-invalid_mode_change_p (regno, class, from_mode)\n-     unsigned int regno;\n-      enum reg_class class;\n-     enum machine_mode from_mode;\n+invalid_mode_change_p (unsigned int regno, enum reg_class class,\n+\t\t       enum machine_mode from_mode)\n {\n   enum machine_mode to_mode;\n   int n;"}, {"sha": "7085ce8696b6da3637da648672abc43dbfff3963", "filename": "gcc/regmove.c", "status": "modified", "additions": 56, "deletions": 104, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -53,11 +53,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define STACK_GROWS_DOWNWARD 0\n #endif\n \n-static int perhaps_ends_bb_p\tPARAMS ((rtx));\n-static int optimize_reg_copy_1\tPARAMS ((rtx, rtx, rtx));\n-static void optimize_reg_copy_2\tPARAMS ((rtx, rtx, rtx));\n-static void optimize_reg_copy_3\tPARAMS ((rtx, rtx, rtx));\n-static void copy_src_to_dest\tPARAMS ((rtx, rtx, rtx, int));\n+static int perhaps_ends_bb_p (rtx);\n+static int optimize_reg_copy_1 (rtx, rtx, rtx);\n+static void optimize_reg_copy_2 (rtx, rtx, rtx);\n+static void optimize_reg_copy_3 (rtx, rtx, rtx);\n+static void copy_src_to_dest (rtx, rtx, rtx, int);\n static int *regmove_bb_head;\n \n struct match {\n@@ -67,26 +67,24 @@ struct match {\n   int early_clobber[MAX_RECOG_OPERANDS];\n };\n \n-static rtx discover_flags_reg PARAMS ((void));\n-static void mark_flags_life_zones PARAMS ((rtx));\n-static void flags_set_1 PARAMS ((rtx, rtx, void *));\n-\n-static int try_auto_increment PARAMS ((rtx, rtx, rtx, rtx, HOST_WIDE_INT, int));\n-static int find_matches PARAMS ((rtx, struct match *));\n-static void replace_in_call_usage PARAMS ((rtx *, unsigned int, rtx, rtx));\n-static int fixup_match_1 PARAMS ((rtx, rtx, rtx, rtx, rtx, int, int, int, FILE *))\n-;\n-static int reg_is_remote_constant_p PARAMS ((rtx, rtx, rtx));\n-static int stable_and_no_regs_but_for_p PARAMS ((rtx, rtx, rtx));\n-static int regclass_compatible_p PARAMS ((int, int));\n-static int replacement_quality PARAMS ((rtx));\n-static int fixup_match_2 PARAMS ((rtx, rtx, rtx, rtx, FILE *));\n+static rtx discover_flags_reg (void);\n+static void mark_flags_life_zones (rtx);\n+static void flags_set_1 (rtx, rtx, void *);\n+\n+static int try_auto_increment (rtx, rtx, rtx, rtx, HOST_WIDE_INT, int);\n+static int find_matches (rtx, struct match *);\n+static void replace_in_call_usage (rtx *, unsigned int, rtx, rtx);\n+static int fixup_match_1 (rtx, rtx, rtx, rtx, rtx, int, int, int, FILE *);\n+static int reg_is_remote_constant_p (rtx, rtx, rtx);\n+static int stable_and_no_regs_but_for_p (rtx, rtx, rtx);\n+static int regclass_compatible_p (int, int);\n+static int replacement_quality (rtx);\n+static int fixup_match_2 (rtx, rtx, rtx, rtx, FILE *);\n \n /* Return nonzero if registers with CLASS1 and CLASS2 can be merged without\n    causing too much register allocation problems.  */\n static int\n-regclass_compatible_p (class0, class1)\n-     int class0, class1;\n+regclass_compatible_p (int class0, int class1)\n {\n   return (class0 == class1\n \t  || (reg_class_subset_p (class0, class1)\n@@ -100,10 +98,8 @@ regclass_compatible_p (class0, class1)\n    Iff INC_INSN_SET is nonzero, inc_insn has a destination different from src.\n    Return nonzero for success.  */\n static int\n-try_auto_increment (insn, inc_insn, inc_insn_set, reg, increment, pre)\n-     rtx reg, insn, inc_insn ,inc_insn_set;\n-     HOST_WIDE_INT increment;\n-     int pre;\n+try_auto_increment (rtx insn, rtx inc_insn, rtx inc_insn_set, rtx reg,\n+\t\t    HOST_WIDE_INT increment, int pre)\n {\n   enum rtx_code inc_code;\n \n@@ -167,7 +163,7 @@ try_auto_increment (insn, inc_insn, inc_insn_set, reg, increment, pre)\n    if no flags were found.  Return pc_rtx if we got confused.  */\n \n static rtx\n-discover_flags_reg ()\n+discover_flags_reg (void)\n {\n   rtx tmp;\n   tmp = gen_rtx_REG (word_mode, 10000);\n@@ -220,8 +216,7 @@ static rtx flags_set_1_rtx;\n static int flags_set_1_set;\n \n static void\n-mark_flags_life_zones (flags)\n-     rtx flags;\n+mark_flags_life_zones (rtx flags)\n {\n   int flags_regno;\n   int flags_nregs;\n@@ -319,9 +314,7 @@ mark_flags_life_zones (flags)\n /* A subroutine of mark_flags_life_zones, called through note_stores.  */\n \n static void\n-flags_set_1 (x, pat, data)\n-     rtx x, pat;\n-     void *data ATTRIBUTE_UNUSED;\n+flags_set_1 (rtx x, rtx pat, void *data ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (pat) == SET\n       && reg_overlap_mentioned_p (x, flags_set_1_rtx))\n@@ -336,8 +329,7 @@ static int *regno_src_regno;\n    a candidate for tying to a hard register, since the output might in\n    turn be a candidate to be tied to a different hard register.  */\n static int\n-replacement_quality (reg)\n-     rtx reg;\n+replacement_quality (rtx reg)\n {\n   int src_regno;\n \n@@ -402,10 +394,7 @@ static int perhaps_ends_bb_p (insn)\n    register-register copy.  */\n \n static int\n-optimize_reg_copy_1 (insn, dest, src)\n-     rtx insn;\n-     rtx dest;\n-     rtx src;\n+optimize_reg_copy_1 (rtx insn, rtx dest, rtx src)\n {\n   rtx p, q;\n   rtx note;\n@@ -601,10 +590,7 @@ optimize_reg_copy_1 (insn, dest, src)\n    this for hard registers since the substitutions we may make might fail.  */\n \n static void\n-optimize_reg_copy_2 (insn, dest, src)\n-     rtx insn;\n-     rtx dest;\n-     rtx src;\n+optimize_reg_copy_2 (rtx insn, rtx dest, rtx src)\n {\n   rtx p, q;\n   rtx set;\n@@ -662,10 +648,7 @@ optimize_reg_copy_2 (insn, dest, src)\n    the remaining accesses to use the appropriate SUBREG.  This allows\n    SRC and DEST to be tied later.  */\n static void\n-optimize_reg_copy_3 (insn, dest, src)\n-     rtx insn;\n-     rtx dest;\n-     rtx src;\n+optimize_reg_copy_3 (rtx insn, rtx dest, rtx src)\n {\n   rtx src_reg = XEXP (src, 0);\n   int src_no = REGNO (src_reg);\n@@ -750,11 +733,7 @@ optimize_reg_copy_3 (insn, dest, src)\n    instead moving the value to dest directly before the operation.  */\n \n static void\n-copy_src_to_dest (insn, src, dest, old_max_uid)\n-     rtx insn;\n-     rtx src;\n-     rtx dest;\n-     int old_max_uid;\n+copy_src_to_dest (rtx insn, rtx src, rtx dest, int old_max_uid)\n {\n   rtx seq;\n   rtx link;\n@@ -871,10 +850,7 @@ copy_src_to_dest (insn, src, dest, old_max_uid)\n    the first insn in the function.  */\n \n static int\n-reg_is_remote_constant_p (reg, insn, first)\n-     rtx reg;\n-     rtx insn;\n-     rtx first;\n+reg_is_remote_constant_p (rtx reg, rtx insn, rtx first)\n {\n   rtx p;\n \n@@ -939,9 +915,7 @@ reg_is_remote_constant_p (reg, insn, first)\n    hard register as ultimate source, like the frame pointer.  */\n \n static int\n-fixup_match_2 (insn, dst, src, offset, regmove_dump_file)\n-     rtx insn, dst, src, offset;\n-     FILE *regmove_dump_file;\n+fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset, FILE *regmove_dump_file)\n {\n   rtx p, dst_death = 0;\n   int length, num_calls = 0;\n@@ -1063,10 +1037,7 @@ fixup_match_2 (insn, dst, src, offset, regmove_dump_file)\n    (or 0 if none should be output).  */\n \n void\n-regmove_optimize (f, nregs, regmove_dump_file)\n-     rtx f;\n-     int nregs;\n-     FILE *regmove_dump_file;\n+regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n {\n   int old_max_uid = get_max_uid ();\n   rtx insn;\n@@ -1543,9 +1514,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n    Initialize the info in MATCHP based on the constraints.  */\n \n static int\n-find_matches (insn, matchp)\n-     rtx insn;\n-     struct match *matchp;\n+find_matches (rtx insn, struct match *matchp)\n {\n   int likely_spilled[MAX_RECOG_OPERANDS];\n   int op_no;\n@@ -1633,11 +1602,7 @@ find_matches (insn, matchp)\n    assumed to be in INSN.  */\n \n static void\n-replace_in_call_usage (loc, dst_reg, src, insn)\n-     rtx *loc;\n-     unsigned int dst_reg;\n-     rtx src;\n-     rtx insn;\n+replace_in_call_usage (rtx *loc, unsigned int dst_reg, rtx src, rtx insn)\n {\n   rtx x = *loc;\n   enum rtx_code code;\n@@ -1676,11 +1641,9 @@ replace_in_call_usage (loc, dst_reg, src, insn)\n    Return nonzero for success.  */\n \n static int\n-fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n-\t       match_number, regmove_dump_file)\n-     rtx insn, set, src, src_subreg, dst;\n-     int backward, operand_number, match_number;\n-     FILE *regmove_dump_file;\n+fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n+\t       int backward, int operand_number, int match_number,\n+\t       FILE *regmove_dump_file)\n {\n   rtx p;\n   rtx post_inc = 0, post_inc_set = 0, search_end = 0;\n@@ -2079,8 +2042,7 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n    leave the burden to update REG_DEAD / REG_UNUSED notes, so we don't\n    want any registers but SRC and DST.  */\n static int\n-stable_and_no_regs_but_for_p (x, src, dst)\n-     rtx x, src, dst;\n+stable_and_no_regs_but_for_p (rtx x, rtx src, rtx dst)\n {\n   RTX_CODE code = GET_CODE (x);\n   switch (GET_RTX_CLASS (code))\n@@ -2140,21 +2102,21 @@ struct csa_memlist\n   struct csa_memlist *next;\n };\n \n-static int stack_memref_p\t\tPARAMS ((rtx));\n-static rtx single_set_for_csa\t\tPARAMS ((rtx));\n-static void free_csa_memlist\t\tPARAMS ((struct csa_memlist *));\n-static struct csa_memlist *record_one_stack_memref\n-  PARAMS ((rtx, rtx *, struct csa_memlist *));\n-static int try_apply_stack_adjustment\n-  PARAMS ((rtx, struct csa_memlist *, HOST_WIDE_INT, HOST_WIDE_INT));\n-static void combine_stack_adjustments_for_block PARAMS ((basic_block));\n-static int record_stack_memrefs\tPARAMS ((rtx *, void *));\n+static int stack_memref_p (rtx);\n+static rtx single_set_for_csa (rtx);\n+static void free_csa_memlist (struct csa_memlist *);\n+static struct csa_memlist *record_one_stack_memref (rtx, rtx *,\n+\t\t\t\t\t\t    struct csa_memlist *);\n+static int try_apply_stack_adjustment (rtx, struct csa_memlist *,\n+\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT);\n+static void combine_stack_adjustments_for_block (basic_block);\n+static int record_stack_memrefs (rtx *, void *);\n \n \n /* Main entry point for stack adjustment combination.  */\n \n void\n-combine_stack_adjustments ()\n+combine_stack_adjustments (void)\n {\n   basic_block bb;\n \n@@ -2165,8 +2127,7 @@ combine_stack_adjustments ()\n /* Recognize a MEM of the form (sp) or (plus sp const).  */\n \n static int\n-stack_memref_p (x)\n-     rtx x;\n+stack_memref_p (rtx x)\n {\n   if (GET_CODE (x) != MEM)\n     return 0;\n@@ -2186,8 +2147,7 @@ stack_memref_p (x)\n    tying fp and sp adjustments.  */\n \n static rtx\n-single_set_for_csa (insn)\n-     rtx insn;\n+single_set_for_csa (rtx insn)\n {\n   int i;\n   rtx tmp = single_set (insn);\n@@ -2221,8 +2181,7 @@ single_set_for_csa (insn)\n /* Free the list of csa_memlist nodes.  */\n \n static void\n-free_csa_memlist (memlist)\n-     struct csa_memlist *memlist;\n+free_csa_memlist (struct csa_memlist *memlist)\n {\n   struct csa_memlist *next;\n   for (; memlist ; memlist = next)\n@@ -2236,9 +2195,7 @@ free_csa_memlist (memlist)\n    It is already known that the memory is stack_memref_p.  */\n \n static struct csa_memlist *\n-record_one_stack_memref (insn, mem, next_memlist)\n-     rtx insn, *mem;\n-     struct csa_memlist *next_memlist;\n+record_one_stack_memref (rtx insn, rtx *mem, struct csa_memlist *next_memlist)\n {\n   struct csa_memlist *ml;\n \n@@ -2260,10 +2217,8 @@ record_one_stack_memref (insn, mem, next_memlist)\n    as each of the memories in MEMLIST.  Return true on success.  */\n \n static int\n-try_apply_stack_adjustment (insn, memlist, new_adjust, delta)\n-     rtx insn;\n-     struct csa_memlist *memlist;\n-     HOST_WIDE_INT new_adjust, delta;\n+try_apply_stack_adjustment (rtx insn, struct csa_memlist *memlist, HOST_WIDE_INT new_adjust,\n+\t\t\t    HOST_WIDE_INT delta)\n {\n   struct csa_memlist *ml;\n   rtx set;\n@@ -2299,9 +2254,7 @@ struct record_stack_memrefs_data\n };\n \n static int\n-record_stack_memrefs (xp, data)\n-     rtx *xp;\n-     void *data;\n+record_stack_memrefs (rtx *xp, void *data)\n {\n   rtx x = *xp;\n   struct record_stack_memrefs_data *d =\n@@ -2343,8 +2296,7 @@ record_stack_memrefs (xp, data)\n /* Subroutine of combine_stack_adjustments, called for each basic block.  */\n \n static void\n-combine_stack_adjustments_for_block (bb)\n-     basic_block bb;\n+combine_stack_adjustments_for_block (basic_block bb)\n {\n   HOST_WIDE_INT last_sp_adjust = 0;\n   rtx last_sp_set = NULL_RTX;"}, {"sha": "719db5841b362ede40f9f4addcf1520e69536757", "filename": "gcc/regrename.c", "status": "modified", "additions": 75, "deletions": 140, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Register renaming for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -78,28 +78,25 @@ static const char * const scan_actions_name[] =\n \n static struct obstack rename_obstack;\n \n-static void do_replace PARAMS ((struct du_chain *, int));\n-static void scan_rtx_reg PARAMS ((rtx, rtx *, enum reg_class,\n-\t\t\t\t  enum scan_actions, enum op_type, int));\n-static void scan_rtx_address PARAMS ((rtx, rtx *, enum reg_class,\n-\t\t\t\t      enum scan_actions, enum machine_mode));\n-static void scan_rtx PARAMS ((rtx, rtx *, enum reg_class,\n-\t\t\t      enum scan_actions, enum op_type, int));\n-static struct du_chain *build_def_use PARAMS ((basic_block));\n-static void dump_def_use_chain PARAMS ((struct du_chain *));\n-static void note_sets PARAMS ((rtx, rtx, void *));\n-static void clear_dead_regs PARAMS ((HARD_REG_SET *, enum machine_mode, rtx));\n-static void merge_overlapping_regs PARAMS ((basic_block, HARD_REG_SET *,\n-\t\t\t\t\t    struct du_chain *));\n+static void do_replace (struct du_chain *, int);\n+static void scan_rtx_reg (rtx, rtx *, enum reg_class,\n+\t\t\t  enum scan_actions, enum op_type, int);\n+static void scan_rtx_address (rtx, rtx *, enum reg_class,\n+\t\t\t      enum scan_actions, enum machine_mode);\n+static void scan_rtx (rtx, rtx *, enum reg_class, enum scan_actions,\n+\t\t      enum op_type, int);\n+static struct du_chain *build_def_use (basic_block);\n+static void dump_def_use_chain (struct du_chain *);\n+static void note_sets (rtx, rtx, void *);\n+static void clear_dead_regs (HARD_REG_SET *, enum machine_mode, rtx);\n+static void merge_overlapping_regs (basic_block, HARD_REG_SET *,\n+\t\t\t\t    struct du_chain *);\n \n /* Called through note_stores from update_life.  Find sets of registers, and\n    record them in *DATA (which is actually a HARD_REG_SET *).  */\n \n static void\n-note_sets (x, set, data)\n-     rtx x;\n-     rtx set ATTRIBUTE_UNUSED;\n-     void *data;\n+note_sets (rtx x, rtx set ATTRIBUTE_UNUSED, void *data)\n {\n   HARD_REG_SET *pset = (HARD_REG_SET *) data;\n   unsigned int regno;\n@@ -121,10 +118,7 @@ note_sets (x, set, data)\n    in the list NOTES.  */\n \n static void\n-clear_dead_regs (pset, kind, notes)\n-     HARD_REG_SET *pset;\n-     enum machine_mode kind;\n-     rtx notes;\n+clear_dead_regs (HARD_REG_SET *pset, enum machine_mode kind, rtx notes)\n {\n   rtx note;\n   for (note = notes; note; note = XEXP (note, 1))\n@@ -147,10 +141,8 @@ clear_dead_regs (pset, kind, notes)\n    its lifetime and set the corresponding bits in *PSET.  */\n \n static void\n-merge_overlapping_regs (b, pset, chain)\n-     basic_block b;\n-     HARD_REG_SET *pset;\n-     struct du_chain *chain;\n+merge_overlapping_regs (basic_block b, HARD_REG_SET *pset,\n+\t\t\tstruct du_chain *chain)\n {\n   struct du_chain *t = chain;\n   rtx insn;\n@@ -192,7 +184,7 @@ merge_overlapping_regs (b, pset, chain)\n /* Perform register renaming on the current function.  */\n \n void\n-regrename_optimize ()\n+regrename_optimize (void)\n {\n   int tick[FIRST_PSEUDO_REGISTER];\n   int this_tick = 0;\n@@ -370,9 +362,7 @@ regrename_optimize ()\n }\n \n static void\n-do_replace (chain, reg)\n-     struct du_chain *chain;\n-     int reg;\n+do_replace (struct du_chain *chain, int reg)\n {\n   while (chain)\n     {\n@@ -392,13 +382,8 @@ static struct du_chain *open_chains;\n static struct du_chain *closed_chains;\n \n static void\n-scan_rtx_reg (insn, loc, class, action, type, earlyclobber)\n-     rtx insn;\n-     rtx *loc;\n-     enum reg_class class;\n-     enum scan_actions action;\n-     enum op_type type;\n-     int earlyclobber;\n+scan_rtx_reg (rtx insn, rtx *loc, enum reg_class class,\n+\t      enum scan_actions action, enum op_type type, int earlyclobber)\n {\n   struct du_chain **p;\n   rtx x = *loc;\n@@ -519,12 +504,8 @@ scan_rtx_reg (insn, loc, class, action, type, earlyclobber)\n    BASE_REG_CLASS depending on how the register is being considered.  */\n \n static void\n-scan_rtx_address (insn, loc, class, action, mode)\n-     rtx insn;\n-     rtx *loc;\n-     enum reg_class class;\n-     enum scan_actions action;\n-     enum machine_mode mode;\n+scan_rtx_address (rtx insn, rtx *loc, enum reg_class class,\n+\t\t  enum scan_actions action, enum machine_mode mode)\n {\n   rtx x = *loc;\n   RTX_CODE code = GET_CODE (x);\n@@ -656,13 +637,8 @@ scan_rtx_address (insn, loc, class, action, mode)\n }\n \n static void\n-scan_rtx (insn, loc, class, action, type, earlyclobber)\n-     rtx insn;\n-     rtx *loc;\n-     enum reg_class class;\n-     enum scan_actions action;\n-     enum op_type type;\n-     int earlyclobber;\n+scan_rtx (rtx insn, rtx *loc, enum reg_class class,\n+\t  enum scan_actions action, enum op_type type, int earlyclobber)\n {\n   const char *fmt;\n   rtx x = *loc;\n@@ -746,8 +722,7 @@ scan_rtx (insn, loc, class, action, type, earlyclobber)\n /* Build def/use chain.  */\n \n static struct du_chain *\n-build_def_use (bb)\n-     basic_block bb;\n+build_def_use (basic_block bb)\n {\n   rtx insn;\n \n@@ -991,8 +966,7 @@ build_def_use (bb)\n    printed in reverse order as that's how we build them.  */\n \n static void\n-dump_def_use_chain (chains)\n-     struct du_chain *chains;\n+dump_def_use_chain (struct du_chain *chains)\n {\n   while (chains)\n     {\n@@ -1036,42 +1010,36 @@ struct value_data\n   unsigned int max_value_regs;\n };\n \n-static void kill_value_regno PARAMS ((unsigned, struct value_data *));\n-static void kill_value PARAMS ((rtx, struct value_data *));\n-static void set_value_regno PARAMS ((unsigned, enum machine_mode,\n-\t\t\t\t     struct value_data *));\n-static void init_value_data PARAMS ((struct value_data *));\n-static void kill_clobbered_value PARAMS ((rtx, rtx, void *));\n-static void kill_set_value PARAMS ((rtx, rtx, void *));\n-static int kill_autoinc_value PARAMS ((rtx *, void *));\n-static void copy_value PARAMS ((rtx, rtx, struct value_data *));\n-static bool mode_change_ok PARAMS ((enum machine_mode, enum machine_mode,\n-\t\t\t\t    unsigned int));\n-static rtx maybe_mode_change PARAMS ((enum machine_mode, enum machine_mode,\n-\t\t\t\t      enum machine_mode, unsigned int,\n-\t\t\t\t      unsigned int));\n-static rtx find_oldest_value_reg PARAMS ((enum reg_class, rtx,\n-\t\t\t\t\t  struct value_data *));\n-static bool replace_oldest_value_reg PARAMS ((rtx *, enum reg_class, rtx,\n-\t\t\t\t\t      struct value_data *));\n-static bool replace_oldest_value_addr PARAMS ((rtx *, enum reg_class,\n-\t\t\t\t\t       enum machine_mode, rtx,\n-\t\t\t\t\t       struct value_data *));\n-static bool replace_oldest_value_mem PARAMS ((rtx, rtx, struct value_data *));\n-static bool copyprop_hardreg_forward_1 PARAMS ((basic_block,\n-\t\t\t\t\t\tstruct value_data *));\n-extern void debug_value_data PARAMS ((struct value_data *));\n+static void kill_value_regno (unsigned, struct value_data *);\n+static void kill_value (rtx, struct value_data *);\n+static void set_value_regno (unsigned, enum machine_mode, struct value_data *);\n+static void init_value_data (struct value_data *);\n+static void kill_clobbered_value (rtx, rtx, void *);\n+static void kill_set_value (rtx, rtx, void *);\n+static int kill_autoinc_value (rtx *, void *);\n+static void copy_value (rtx, rtx, struct value_data *);\n+static bool mode_change_ok (enum machine_mode, enum machine_mode,\n+\t\t\t    unsigned int);\n+static rtx maybe_mode_change (enum machine_mode, enum machine_mode,\n+\t\t\t      enum machine_mode, unsigned int, unsigned int);\n+static rtx find_oldest_value_reg (enum reg_class, rtx, struct value_data *);\n+static bool replace_oldest_value_reg (rtx *, enum reg_class, rtx,\n+\t\t\t\t      struct value_data *);\n+static bool replace_oldest_value_addr (rtx *, enum reg_class,\n+\t\t\t\t       enum machine_mode, rtx,\n+\t\t\t\t       struct value_data *);\n+static bool replace_oldest_value_mem (rtx, rtx, struct value_data *);\n+static bool copyprop_hardreg_forward_1 (basic_block, struct value_data *);\n+extern void debug_value_data (struct value_data *);\n #ifdef ENABLE_CHECKING\n-static void validate_value_data PARAMS ((struct value_data *));\n+static void validate_value_data (struct value_data *);\n #endif\n \n /* Kill register REGNO.  This involves removing it from any value lists,\n    and resetting the value mode to VOIDmode.  */\n \n static void\n-kill_value_regno (regno, vd)\n-     unsigned int regno;\n-     struct value_data *vd;\n+kill_value_regno (unsigned int regno, struct value_data *vd)\n {\n   unsigned int i, next;\n \n@@ -1102,9 +1070,7 @@ kill_value_regno (regno, vd)\n    so that we mind the mode the register is in.  */\n \n static void\n-kill_value (x, vd)\n-     rtx x;\n-     struct value_data *vd;\n+kill_value (rtx x, struct value_data *vd)\n {\n   /* SUBREGS are supposed to have been eliminated by now.  But some\n      ports, e.g. i386 sse, use them to smuggle vector type information\n@@ -1144,10 +1110,8 @@ kill_value (x, vd)\n /* Remember that REGNO is valid in MODE.  */\n \n static void\n-set_value_regno (regno, mode, vd)\n-     unsigned int regno;\n-     enum machine_mode mode;\n-     struct value_data *vd;\n+set_value_regno (unsigned int regno, enum machine_mode mode,\n+\t\t struct value_data *vd)\n {\n   unsigned int nregs;\n \n@@ -1161,8 +1125,7 @@ set_value_regno (regno, mode, vd)\n /* Initialize VD such that there are no known relationships between regs.  */\n \n static void\n-init_value_data (vd)\n-     struct value_data *vd;\n+init_value_data (struct value_data *vd)\n {\n   int i;\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n@@ -1177,10 +1140,7 @@ init_value_data (vd)\n /* Called through note_stores.  If X is clobbered, kill its value.  */\n \n static void\n-kill_clobbered_value (x, set, data)\n-     rtx x;\n-     rtx set;\n-     void *data;\n+kill_clobbered_value (rtx x, rtx set, void *data)\n {\n   struct value_data *vd = data;\n   if (GET_CODE (set) == CLOBBER)\n@@ -1191,10 +1151,7 @@ kill_clobbered_value (x, set, data)\n    current value and install it as the root of its own value list.  */\n \n static void\n-kill_set_value (x, set, data)\n-     rtx x;\n-     rtx set;\n-     void *data;\n+kill_set_value (rtx x, rtx set, void *data)\n {\n   struct value_data *vd = data;\n   if (GET_CODE (set) != CLOBBER)\n@@ -1210,9 +1167,7 @@ kill_set_value (x, set, data)\n    own value list.  */\n \n static int\n-kill_autoinc_value (px, data)\n-     rtx *px;\n-     void *data;\n+kill_autoinc_value (rtx *px, void *data)\n {\n   rtx x = *px;\n   struct value_data *vd = data;\n@@ -1232,10 +1187,7 @@ kill_autoinc_value (px, data)\n    to reflect that SRC contains an older copy of the shared value.  */\n \n static void\n-copy_value (dest, src, vd)\n-     rtx dest;\n-     rtx src;\n-     struct value_data *vd;\n+copy_value (rtx dest, rtx src, struct value_data *vd)\n {\n   unsigned int dr = REGNO (dest);\n   unsigned int sr = REGNO (src);\n@@ -1311,9 +1263,8 @@ copy_value (dest, src, vd)\n /* Return true if a mode change from ORIG to NEW is allowed for REGNO.  */\n \n static bool\n-mode_change_ok (orig_mode, new_mode, regno)\n-     enum machine_mode orig_mode, new_mode;\n-     unsigned int regno ATTRIBUTE_UNUSED;\n+mode_change_ok (enum machine_mode orig_mode, enum machine_mode new_mode,\n+\t\tunsigned int regno ATTRIBUTE_UNUSED)\n {\n   if (GET_MODE_SIZE (orig_mode) < GET_MODE_SIZE (new_mode))\n     return false;\n@@ -1331,9 +1282,9 @@ mode_change_ok (orig_mode, new_mode, regno)\n    Return a NEW_MODE rtx for REGNO if that's OK, otherwise return NULL_RTX.  */\n \n static rtx\n-maybe_mode_change (orig_mode, copy_mode, new_mode, regno, copy_regno)\n-     enum machine_mode orig_mode, copy_mode, new_mode;\n-     unsigned int regno, copy_regno ATTRIBUTE_UNUSED;\n+maybe_mode_change (enum machine_mode orig_mode, enum machine_mode copy_mode,\n+\t\t   enum machine_mode new_mode, unsigned int regno,\n+\t\t   unsigned int copy_regno ATTRIBUTE_UNUSED)\n {\n   if (orig_mode == new_mode)\n     return gen_rtx_raw_REG (new_mode, regno);\n@@ -1363,10 +1314,7 @@ maybe_mode_change (orig_mode, copy_mode, new_mode, regno, copy_regno)\n    of that oldest register, otherwise return NULL.  */\n \n static rtx\n-find_oldest_value_reg (class, reg, vd)\n-     enum reg_class class;\n-     rtx reg;\n-     struct value_data *vd;\n+find_oldest_value_reg (enum reg_class class, rtx reg, struct value_data *vd)\n {\n   unsigned int regno = REGNO (reg);\n   enum machine_mode mode = GET_MODE (reg);\n@@ -1408,11 +1356,8 @@ find_oldest_value_reg (class, reg, vd)\n    in register class CLASS.  Return true if successfully replaced.  */\n \n static bool\n-replace_oldest_value_reg (loc, class, insn, vd)\n-     rtx *loc;\n-     enum reg_class class;\n-     rtx insn;\n-     struct value_data *vd;\n+replace_oldest_value_reg (rtx *loc, enum reg_class class, rtx insn,\n+\t\t\t  struct value_data *vd)\n {\n   rtx new = find_oldest_value_reg (class, *loc, vd);\n   if (new)\n@@ -1432,12 +1377,9 @@ replace_oldest_value_reg (loc, class, insn, vd)\n    BASE_REG_CLASS depending on how the register is being considered.  */\n \n static bool\n-replace_oldest_value_addr (loc, class, mode, insn, vd)\n-     rtx *loc;\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     rtx insn;\n-     struct value_data *vd;\n+replace_oldest_value_addr (rtx *loc, enum reg_class class,\n+\t\t\t   enum machine_mode mode, rtx insn,\n+\t\t\t   struct value_data *vd)\n {\n   rtx x = *loc;\n   RTX_CODE code = GET_CODE (x);\n@@ -1567,10 +1509,7 @@ replace_oldest_value_addr (loc, class, mode, insn, vd)\n /* Similar to replace_oldest_value_reg, but X contains a memory.  */\n \n static bool\n-replace_oldest_value_mem (x, insn, vd)\n-     rtx x;\n-     rtx insn;\n-     struct value_data *vd;\n+replace_oldest_value_mem (rtx x, rtx insn, struct value_data *vd)\n {\n   return replace_oldest_value_addr (&XEXP (x, 0),\n \t\t\t\t    MODE_BASE_REG_CLASS (GET_MODE (x)),\n@@ -1580,9 +1519,7 @@ replace_oldest_value_mem (x, insn, vd)\n /* Perform the forward copy propagation on basic block BB.  */\n \n static bool\n-copyprop_hardreg_forward_1 (bb, vd)\n-     basic_block bb;\n-     struct value_data *vd;\n+copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n {\n   bool changed = false;\n   rtx insn;\n@@ -1781,7 +1718,7 @@ copyprop_hardreg_forward_1 (bb, vd)\n /* Main entry point for the forward copy propagation optimization.  */\n \n void\n-copyprop_hardreg_forward ()\n+copyprop_hardreg_forward (void)\n {\n   struct value_data *all_vd;\n   bool need_refresh;\n@@ -1833,8 +1770,7 @@ copyprop_hardreg_forward ()\n /* Dump the value chain data to stderr.  */\n \n void\n-debug_value_data (vd)\n-     struct value_data *vd;\n+debug_value_data (struct value_data *vd)\n {\n   HARD_REG_SET set;\n   unsigned int i, j;\n@@ -1889,8 +1825,7 @@ debug_value_data (vd)\n \n #ifdef ENABLE_CHECKING\n static void\n-validate_value_data (vd)\n-     struct value_data *vd;\n+validate_value_data (struct value_data *vd)\n {\n   HARD_REG_SET set;\n   unsigned int i, j;"}, {"sha": "2206fdcdeb72bcaa59c54c3b38ab501a126e905a", "filename": "gcc/regs.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -60,7 +60,7 @@ typedef struct reg_info_def\n   int live_length;\t\t/* # of instructions (REG n) is live */\n   int calls_crossed;\t\t/* # of calls (REG n) is live across */\n   int basic_block;\t\t/* # of basic blocks (REG n) is used in */\n-  char changes_mode;\t\t/* whether (SUBREG (REG n)) exists and \n+  char changes_mode;\t\t/* whether (SUBREG (REG n)) exists and\n \t\t\t\t   is illegal.  */\n } reg_info;\n \n@@ -76,7 +76,7 @@ extern bitmap_head subregs_of_mode;\n \n #define REG_FREQ(N) (VARRAY_REG (reg_n_info, N)->freq)\n \n-/* The weights for each insn varries from 0 to REG_FREQ_BASE. \n+/* The weights for each insn varries from 0 to REG_FREQ_BASE.\n    This constant does not need to be high, as in infrequently executed\n    regions we want to count instructions equivalently to optimize for\n    size instead of speed.  */\n@@ -213,11 +213,11 @@ extern int caller_save_needed;\n   choose_hard_reg_mode (REGNO, NREGS)\n #endif\n \n-/* Registers that get partially clobbered by a call in a given mode. \n+/* Registers that get partially clobbered by a call in a given mode.\n    These must not be call used registers.  */\n #ifndef HARD_REGNO_CALL_PART_CLOBBERED\n #define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE) 0\n #endif\n \n /* Allocate reg_n_info tables */\n-extern void allocate_reg_info PARAMS ((size_t, int, int));\n+extern void allocate_reg_info (size_t, int, int);"}, {"sha": "a12af45f2aa8d377556fc4833df1f019af9411de", "filename": "gcc/reload.c", "status": "modified", "additions": 115, "deletions": 232, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -234,43 +234,41 @@ static int output_reloadnum;\n       : (type)))\n \n #ifdef HAVE_SECONDARY_RELOADS\n-static int push_secondary_reload PARAMS ((int, rtx, int, int, enum reg_class,\n-\t\t\t\t\tenum machine_mode, enum reload_type,\n-\t\t\t\t\tenum insn_code *));\n+static int push_secondary_reload (int, rtx, int, int, enum reg_class,\n+\t\t\t\t  enum machine_mode, enum reload_type,\n+\t\t\t\t  enum insn_code *);\n #endif\n-static enum reg_class find_valid_class PARAMS ((enum machine_mode, int,\n-\t\t\t\t\t\tunsigned int));\n-static int reload_inner_reg_of_subreg PARAMS ((rtx, enum machine_mode, int));\n-static void push_replacement\tPARAMS ((rtx *, int, enum machine_mode));\n-static void dup_replacements\tPARAMS ((rtx *, rtx *));\n-static void combine_reloads\tPARAMS ((void));\n-static int find_reusable_reload\tPARAMS ((rtx *, rtx, enum reg_class,\n-\t\t\t\t       enum reload_type, int, int));\n-static rtx find_dummy_reload\tPARAMS ((rtx, rtx, rtx *, rtx *,\n-\t\t\t\t       enum machine_mode, enum machine_mode,\n-\t\t\t\t       enum reg_class, int, int));\n-static int hard_reg_set_here_p\tPARAMS ((unsigned int, unsigned int, rtx));\n-static struct decomposition decompose PARAMS ((rtx));\n-static int immune_p\t\tPARAMS ((rtx, rtx, struct decomposition));\n-static int alternative_allows_memconst PARAMS ((const char *, int));\n-static rtx find_reloads_toplev\tPARAMS ((rtx, int, enum reload_type, int,\n-\t\t\t\t\t int, rtx, int *));\n-static rtx make_memloc\t\tPARAMS ((rtx, int));\n-static int maybe_memory_address_p PARAMS ((enum machine_mode, rtx, rtx *));\n-static int find_reloads_address\tPARAMS ((enum machine_mode, rtx *, rtx, rtx *,\n-\t\t\t\t       int, enum reload_type, int, rtx));\n-static rtx subst_reg_equivs\tPARAMS ((rtx, rtx));\n-static rtx subst_indexed_address PARAMS ((rtx));\n-static void update_auto_inc_notes PARAMS ((rtx, int, int));\n-static int find_reloads_address_1 PARAMS ((enum machine_mode, rtx, int, rtx *,\n-\t\t\t\t\t int, enum reload_type,int, rtx));\n-static void find_reloads_address_part PARAMS ((rtx, rtx *, enum reg_class,\n-\t\t\t\t\t     enum machine_mode, int,\n-\t\t\t\t\t     enum reload_type, int));\n-static rtx find_reloads_subreg_address PARAMS ((rtx, int, int,\n-\t\t\t\t\t\tenum reload_type, int, rtx));\n-static void copy_replacements_1 PARAMS ((rtx *, rtx *, int));\n-static int find_inc_amount\tPARAMS ((rtx, rtx));\n+static enum reg_class find_valid_class (enum machine_mode, int, unsigned int);\n+static int reload_inner_reg_of_subreg (rtx, enum machine_mode, int);\n+static void push_replacement (rtx *, int, enum machine_mode);\n+static void dup_replacements (rtx *, rtx *);\n+static void combine_reloads (void);\n+static int find_reusable_reload (rtx *, rtx, enum reg_class,\n+\t\t\t\t enum reload_type, int, int);\n+static rtx find_dummy_reload (rtx, rtx, rtx *, rtx *, enum machine_mode,\n+\t\t\t      enum machine_mode, enum reg_class, int, int);\n+static int hard_reg_set_here_p (unsigned int, unsigned int, rtx);\n+static struct decomposition decompose (rtx);\n+static int immune_p (rtx, rtx, struct decomposition);\n+static int alternative_allows_memconst (const char *, int);\n+static rtx find_reloads_toplev (rtx, int, enum reload_type, int, int, rtx,\n+\t\t\t\tint *);\n+static rtx make_memloc (rtx, int);\n+static int maybe_memory_address_p (enum machine_mode, rtx, rtx *);\n+static int find_reloads_address (enum machine_mode, rtx *, rtx, rtx *,\n+\t\t\t\t int, enum reload_type, int, rtx);\n+static rtx subst_reg_equivs (rtx, rtx);\n+static rtx subst_indexed_address (rtx);\n+static void update_auto_inc_notes (rtx, int, int);\n+static int find_reloads_address_1 (enum machine_mode, rtx, int, rtx *,\n+\t\t\t\t   int, enum reload_type,int, rtx);\n+static void find_reloads_address_part (rtx, rtx *, enum reg_class,\n+\t\t\t\t       enum machine_mode, int,\n+\t\t\t\t       enum reload_type, int);\n+static rtx find_reloads_subreg_address (rtx, int, int, enum reload_type,\n+\t\t\t\t\tint, rtx);\n+static void copy_replacements_1 (rtx *, rtx *, int);\n+static int find_inc_amount (rtx, rtx);\n \f\n #ifdef HAVE_SECONDARY_RELOADS\n \n@@ -284,16 +282,10 @@ static int find_inc_amount\tPARAMS ((rtx, rtx));\n    need a secondary reload.  */\n \n static int\n-push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n-\t\t       type, picode)\n-     int in_p;\n-     rtx x;\n-     int opnum;\n-     int optional;\n-     enum reg_class reload_class;\n-     enum machine_mode reload_mode;\n-     enum reload_type type;\n-     enum insn_code *picode;\n+push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n+\t\t       enum reg_class reload_class,\n+\t\t       enum machine_mode reload_mode, enum reload_type type,\n+\t\t       enum insn_code *picode)\n {\n   enum reg_class class = NO_REGS;\n   enum machine_mode mode = reload_mode;\n@@ -588,11 +580,8 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n    call find_reloads_address on the location being returned.  */\n \n rtx\n-get_secondary_mem (x, mode, opnum, type)\n-     rtx x ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n-     int opnum;\n-     enum reload_type type;\n+get_secondary_mem (rtx x ATTRIBUTE_UNUSED, enum machine_mode mode,\n+\t\t   int opnum, enum reload_type type)\n {\n   rtx loc;\n   int mem_valid;\n@@ -660,7 +649,7 @@ get_secondary_mem (x, mode, opnum, type)\n /* Clear any secondary memory locations we've made.  */\n \n void\n-clear_secondary_mem ()\n+clear_secondary_mem (void)\n {\n   memset ((char *) secondary_memlocs, 0, sizeof secondary_memlocs);\n }\n@@ -671,10 +660,8 @@ clear_secondary_mem ()\n    Abort if no such class exists.  */\n \n static enum reg_class\n-find_valid_class (m1, n, dest_regno)\n-     enum machine_mode m1 ATTRIBUTE_UNUSED;\n-     int n;\n-     unsigned int dest_regno ATTRIBUTE_UNUSED;\n+find_valid_class (enum machine_mode m1 ATTRIBUTE_UNUSED, int n,\n+\t\t  unsigned int dest_regno ATTRIBUTE_UNUSED)\n {\n   int best_cost = -1;\n   int class;\n@@ -722,11 +709,8 @@ find_valid_class (m1, n, dest_regno)\n    DONT_SHARE is nonzero if we can't share any input-only reload for IN.  */\n \n static int\n-find_reusable_reload (p_in, out, class, type, opnum, dont_share)\n-     rtx *p_in, out;\n-     enum reg_class class;\n-     enum reload_type type;\n-     int opnum, dont_share;\n+find_reusable_reload (rtx *p_in, rtx out, enum reg_class class,\n+\t\t      enum reload_type type, int opnum, int dont_share)\n {\n   rtx in = *p_in;\n   int i;\n@@ -799,10 +783,7 @@ find_reusable_reload (p_in, out, class, type, opnum, dont_share)\n    SUBREG_REG expression.  */\n \n static int\n-reload_inner_reg_of_subreg (x, mode, output)\n-     rtx x;\n-     enum machine_mode mode;\n-     int output;\n+reload_inner_reg_of_subreg (rtx x, enum machine_mode mode, int output)\n {\n   rtx inner;\n \n@@ -920,16 +901,10 @@ can_reload_into (rtx in, int regno, enum machine_mode mode)\n    distinguish them.  */\n \n int\n-push_reload (in, out, inloc, outloc, class,\n-\t     inmode, outmode, strict_low, optional, opnum, type)\n-     rtx in, out;\n-     rtx *inloc, *outloc;\n-     enum reg_class class;\n-     enum machine_mode inmode, outmode;\n-     int strict_low;\n-     int optional;\n-     int opnum;\n-     enum reload_type type;\n+push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n+\t     enum reg_class class, enum machine_mode inmode,\n+\t     enum machine_mode outmode, int strict_low, int optional,\n+\t     int opnum, enum reload_type type)\n {\n   int i;\n   int dont_share = 0;\n@@ -1170,7 +1145,7 @@ push_reload (in, out, inloc, outloc, class,\n \t  || (GET_CODE (SUBREG_REG (out)) == REG\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n \t      && REG_CANNOT_CHANGE_MODE_P (REGNO (SUBREG_REG (out)),\n-\t\t   \t\t\t   GET_MODE (SUBREG_REG (out)), \n+\t\t\t\t\t   GET_MODE (SUBREG_REG (out)),\n \t\t\t\t\t   outmode))\n #endif\n \t  ))\n@@ -1603,10 +1578,7 @@ push_reload (in, out, inloc, outloc, class,\n    This is used in insn patterns that use match_dup.  */\n \n static void\n-push_replacement (loc, reloadnum, mode)\n-     rtx *loc;\n-     int reloadnum;\n-     enum machine_mode mode;\n+push_replacement (rtx *loc, int reloadnum, enum machine_mode mode)\n {\n   if (replace_reloads)\n     {\n@@ -1623,9 +1595,7 @@ push_replacement (loc, reloadnum, mode)\n    This is used in insn patterns that use match_dup.  */\n \n static void\n-dup_replacements (dup_loc, orig_loc)\n-     rtx *dup_loc;\n-     rtx *orig_loc;\n+dup_replacements (rtx *dup_loc, rtx *orig_loc)\n {\n   int i, n = n_replacements;\n \n@@ -1641,8 +1611,7 @@ dup_replacements (dup_loc, orig_loc)\n    reload TO.  */\n \n void\n-transfer_replacements (to, from)\n-     int to, from;\n+transfer_replacements (int to, int from)\n {\n   int i;\n \n@@ -1656,8 +1625,7 @@ transfer_replacements (to, from)\n    cancel the reloads that were supposed to load them.\n    Return nonzero if we canceled any reloads.  */\n int\n-remove_address_replacements (in_rtx)\n-     rtx in_rtx;\n+remove_address_replacements (rtx in_rtx)\n {\n   int i, j;\n   char reload_flags[MAX_RELOADS];\n@@ -1703,7 +1671,7 @@ remove_address_replacements (in_rtx)\n    class and does not appear in the value being output-reloaded.  */\n \n static void\n-combine_reloads ()\n+combine_reloads (void)\n {\n   int i;\n   int output_reload = -1;\n@@ -1900,14 +1868,9 @@ combine_reloads ()\n    is safe from the earlyclobber).  */\n \n static rtx\n-find_dummy_reload (real_in, real_out, inloc, outloc,\n-\t\t   inmode, outmode, class, for_real, earlyclobber)\n-     rtx real_in, real_out;\n-     rtx *inloc, *outloc;\n-     enum machine_mode inmode, outmode;\n-     enum reg_class class;\n-     int for_real;\n-     int earlyclobber;\n+find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n+\t\t   enum machine_mode inmode, enum machine_mode outmode,\n+\t\t   enum reg_class class, int for_real, int earlyclobber)\n {\n   rtx in = real_in;\n   rtx out = real_out;\n@@ -2058,8 +2021,7 @@ find_dummy_reload (real_in, real_out, inloc, outloc,\n /* Return 1 if X is an operand of an insn that is being earlyclobbered.  */\n \n int\n-earlyclobber_operand_p (x)\n-     rtx x;\n+earlyclobber_operand_p (rtx x)\n {\n   int i;\n \n@@ -2076,9 +2038,7 @@ earlyclobber_operand_p (x)\n    X should be the body of an instruction.  */\n \n static int\n-hard_reg_set_here_p (beg_regno, end_regno, x)\n-     unsigned int beg_regno, end_regno;\n-     rtx x;\n+hard_reg_set_here_p (unsigned int beg_regno, unsigned int end_regno, rtx x)\n {\n   if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n     {\n@@ -2113,9 +2073,7 @@ hard_reg_set_here_p (beg_regno, end_regno, x)\n    hard reg.  */\n \n int\n-strict_memory_address_p (mode, addr)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx addr;\n+strict_memory_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx addr)\n {\n   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n   return 0;\n@@ -2140,8 +2098,7 @@ strict_memory_address_p (mode, addr)\n    because that is natural in (SET output (... input ...)).  */\n \n int\n-operands_match_p (x, y)\n-     rtx x, y;\n+operands_match_p (rtx x, rtx y)\n {\n   int i;\n   RTX_CODE code = GET_CODE (x);\n@@ -2292,8 +2249,7 @@ operands_match_p (x, y)\n    so we set the SAFE field.  */\n \n static struct decomposition\n-decompose (x)\n-     rtx x;\n+decompose (rtx x)\n {\n   struct decomposition val;\n   int all_const = 0;\n@@ -2431,9 +2387,7 @@ decompose (x)\n    Y is also described by YDATA, which should be decompose (Y).  */\n \n static int\n-immune_p (x, y, ydata)\n-     rtx x, y;\n-     struct decomposition ydata;\n+immune_p (rtx x, rtx y, struct decomposition ydata)\n {\n   struct decomposition xdata;\n \n@@ -2476,8 +2430,7 @@ immune_p (x, y, ydata)\n /* Similar, but calls decompose.  */\n \n int\n-safe_from_earlyclobber (op, clobber)\n-     rtx op, clobber;\n+safe_from_earlyclobber (rtx op, rtx clobber)\n {\n   struct decomposition early_data;\n \n@@ -2508,11 +2461,8 @@ safe_from_earlyclobber (op, clobber)\n    commutative operands, reg_equiv_address substitution, or whatever.  */\n \n int\n-find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n-     rtx insn;\n-     int replace, ind_levels;\n-     int live_known;\n-     short *reload_reg_p;\n+find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n+\t      short *reload_reg_p)\n {\n   int insn_code_number;\n   int i, j;\n@@ -4387,15 +4337,15 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   for (i = 0; i < n_reloads; i++)\n     if (rld[i].when_needed == RELOAD_FOR_INPUT\n \t&& GET_CODE (PATTERN (insn)) == SET\n- \t&& GET_CODE (SET_DEST (PATTERN (insn))) == REG\n- \t&& SET_SRC (PATTERN (insn)) == rld[i].in)\n+\t&& GET_CODE (SET_DEST (PATTERN (insn))) == REG\n+\t&& SET_SRC (PATTERN (insn)) == rld[i].in)\n       {\n- \trtx dest = SET_DEST (PATTERN (insn));\n+\trtx dest = SET_DEST (PATTERN (insn));\n \tunsigned int regno = REGNO (dest);\n \n- \tif (regno < FIRST_PSEUDO_REGISTER\n- \t    && TEST_HARD_REG_BIT (reg_class_contents[rld[i].class], regno)\n- \t    && HARD_REGNO_MODE_OK (regno, rld[i].mode))\n+\tif (regno < FIRST_PSEUDO_REGISTER\n+\t    && TEST_HARD_REG_BIT (reg_class_contents[rld[i].class], regno)\n+\t    && HARD_REGNO_MODE_OK (regno, rld[i].mode))\n \t  {\n \t    int nr = HARD_REGNO_NREGS (regno, rld[i].mode);\n \t    int ok = 1, nri;\n@@ -4416,9 +4366,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n    accepts a memory operand with constant address.  */\n \n static int\n-alternative_allows_memconst (constraint, altnum)\n-     const char *constraint;\n-     int altnum;\n+alternative_allows_memconst (const char *constraint, int altnum)\n {\n   int c;\n   /* Skip alternatives before the one requested.  */\n@@ -4459,15 +4407,9 @@ alternative_allows_memconst (constraint, altnum)\n    result of find_reloads_address.  */\n \n static rtx\n-find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn,\n-\t\t     address_reloaded)\n-     rtx x;\n-     int opnum;\n-     enum reload_type type;\n-     int ind_levels;\n-     int is_set_dest;\n-     rtx insn;\n-     int *address_reloaded;\n+find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n+\t\t     int ind_levels, int is_set_dest, rtx insn,\n+\t\t     int *address_reloaded)\n {\n   RTX_CODE code = GET_CODE (x);\n \n@@ -4611,9 +4553,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn,\n    This mem ref is not shared with anything.  */\n \n static rtx\n-make_memloc (ad, regno)\n-     rtx ad;\n-     int regno;\n+make_memloc (rtx ad, int regno)\n {\n   /* We must rerun eliminate_regs, in case the elimination\n      offsets have changed.  */\n@@ -4636,14 +4576,11 @@ make_memloc (ad, regno)\n }\n \n /* Returns true if AD could be turned into a valid memory reference\n-   to mode MODE by reloading the part pointed to by PART into a \n+   to mode MODE by reloading the part pointed to by PART into a\n    register.  */\n \n static int\n-maybe_memory_address_p (mode, ad, part)\n-     enum machine_mode mode;\n-     rtx ad;\n-     rtx *part;\n+maybe_memory_address_p (enum machine_mode mode, rtx ad, rtx *part)\n {\n   int retv;\n   rtx tem = *part;\n@@ -4681,15 +4618,9 @@ maybe_memory_address_p (mode, ad, part)\n    to a hard register, and frame pointer elimination.  */\n \n static int\n-find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n-     enum machine_mode mode;\n-     rtx *memrefloc;\n-     rtx ad;\n-     rtx *loc;\n-     int opnum;\n-     enum reload_type type;\n-     int ind_levels;\n-     rtx insn;\n+find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n+\t\t      rtx *loc, int opnum, enum reload_type type,\n+\t\t      int ind_levels, rtx insn)\n {\n   int regno;\n   int removed_and = 0;\n@@ -5042,9 +4973,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n    front of it for pseudos that we have to replace with stack slots.  */\n \n static rtx\n-subst_reg_equivs (ad, insn)\n-     rtx ad;\n-     rtx insn;\n+subst_reg_equivs (rtx ad, rtx insn)\n {\n   RTX_CODE code = GET_CODE (ad);\n   int i;\n@@ -5115,8 +5044,7 @@ subst_reg_equivs (ad, insn)\n    This routine assumes both inputs are already in canonical form.  */\n \n rtx\n-form_sum (x, y)\n-     rtx x, y;\n+form_sum (rtx x, rtx y)\n {\n   rtx tem;\n   enum machine_mode mode = GET_MODE (x);\n@@ -5170,8 +5098,7 @@ form_sum (x, y)\n    In all other cases, return ADDR.  */\n \n static rtx\n-subst_indexed_address (addr)\n-     rtx addr;\n+subst_indexed_address (rtx addr)\n {\n   rtx op0 = 0, op1 = 0, op2 = 0;\n   rtx tem;\n@@ -5228,10 +5155,8 @@ subst_indexed_address (addr)\n    RELOADNUM is the reload number.  */\n \n static void\n-update_auto_inc_notes (insn, regno, reloadnum)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     int regno ATTRIBUTE_UNUSED;\n-     int reloadnum ATTRIBUTE_UNUSED;\n+update_auto_inc_notes (rtx insn ATTRIBUTE_UNUSED, int regno ATTRIBUTE_UNUSED,\n+\t\t       int reloadnum ATTRIBUTE_UNUSED)\n {\n #ifdef AUTO_INC_DEC\n   rtx link;\n@@ -5268,15 +5193,9 @@ update_auto_inc_notes (insn, regno, reloadnum)\n    could have addressing modes that this does not handle right.  */\n \n static int\n-find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n-     enum machine_mode mode;\n-     rtx x;\n-     int context;\n-     rtx *loc;\n-     int opnum;\n-     enum reload_type type;\n-     int ind_levels;\n-     rtx insn;\n+find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n+\t\t\trtx *loc, int opnum, enum reload_type type,\n+\t\t\tint ind_levels, rtx insn)\n {\n   RTX_CODE code = GET_CODE (x);\n \n@@ -5445,7 +5364,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \n \t    /* Handle a register that is equivalent to a memory location\n \t       which cannot be addressed directly.  */\n- \t    if (reg_equiv_memory_loc[regno] != 0\n+\t    if (reg_equiv_memory_loc[regno] != 0\n \t\t&& (reg_equiv_address[regno] != 0\n \t\t    || num_not_at_initial_offset))\n \t      {\n@@ -5809,14 +5728,9 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n    supports.  */\n \n static void\n-find_reloads_address_part (x, loc, class, mode, opnum, type, ind_levels)\n-     rtx x;\n-     rtx *loc;\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     int opnum;\n-     enum reload_type type;\n-     int ind_levels;\n+find_reloads_address_part (rtx x, rtx *loc, enum reg_class class,\n+\t\t\t   enum machine_mode mode, int opnum,\n+\t\t\t   enum reload_type type, int ind_levels)\n {\n   if (CONSTANT_P (x)\n       && (! LEGITIMATE_CONSTANT_P (x)\n@@ -5869,14 +5783,8 @@ find_reloads_address_part (x, loc, class, mode, opnum, type, ind_levels)\n    stack slots.  */\n \n static rtx\n-find_reloads_subreg_address (x, force_replace, opnum, type,\n-\t\t\t     ind_levels, insn)\n-     rtx x;\n-     int force_replace;\n-     int opnum;\n-     enum reload_type type;\n-     int ind_levels;\n-     rtx insn;\n+find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n+\t\t\t     enum reload_type type, int ind_levels, rtx insn)\n {\n   int regno = REGNO (SUBREG_REG (x));\n \n@@ -5955,8 +5863,7 @@ find_reloads_subreg_address (x, force_replace, opnum, type,\n    Return the rtx that X translates into; usually X, but modified.  */\n \n void\n-subst_reloads (insn)\n-     rtx insn;\n+subst_reloads (rtx insn)\n {\n   int i;\n \n@@ -6046,8 +5953,7 @@ subst_reloads (insn)\n    copies to locations in Y, a copy of X.  */\n \n void\n-copy_replacements (x, y)\n-     rtx x, y;\n+copy_replacements (rtx x, rtx y)\n {\n   /* We can't support X being a SUBREG because we might then need to know its\n      location if something inside it was replaced.  */\n@@ -6058,10 +5964,7 @@ copy_replacements (x, y)\n }\n \n static void\n-copy_replacements_1 (px, py, orig_replacements)\n-     rtx *px;\n-     rtx *py;\n-     int orig_replacements;\n+copy_replacements_1 (rtx *px, rtx *py, int orig_replacements)\n {\n   int i, j;\n   rtx x, y;\n@@ -6108,9 +6011,7 @@ copy_replacements_1 (px, py, orig_replacements)\n /* Change any replacements being done to *X to be done to *Y.  */\n \n void\n-move_replacements (x, y)\n-     rtx *x;\n-     rtx *y;\n+move_replacements (rtx *x, rtx *y)\n {\n   int i;\n \n@@ -6128,8 +6029,7 @@ move_replacements (x, y)\n    Otherwise, return *LOC.  */\n \n rtx\n-find_replacement (loc)\n-     rtx *loc;\n+find_replacement (rtx *loc)\n {\n   struct replacement *r;\n \n@@ -6199,10 +6099,8 @@ find_replacement (loc)\n    look at equivalences for pseudos that didn't get hard registers.  */\n \n int\n-refers_to_regno_for_reload_p (regno, endregno, x, loc)\n-     unsigned int regno, endregno;\n-     rtx x;\n-     rtx *loc;\n+refers_to_regno_for_reload_p (unsigned int regno, unsigned int endregno,\n+\t\t\t      rtx x, rtx *loc)\n {\n   int i;\n   unsigned int r;\n@@ -6325,8 +6223,7 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n    that we look at equivalences for pseudos that didn't get hard registers.  */\n \n int\n-reg_overlap_mentioned_for_reload_p (x, in)\n-     rtx x, in;\n+reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n {\n   int regno, endregno;\n \n@@ -6384,8 +6281,7 @@ reg_overlap_mentioned_for_reload_p (x, in)\n    registers.  */\n \n int\n-refers_to_mem_for_reload_p (x)\n-     rtx x;\n+refers_to_mem_for_reload_p (rtx x)\n {\n   const char *fmt;\n   int i;\n@@ -6435,14 +6331,8 @@ refers_to_mem_for_reload_p (x)\n    as if it were a constant except that sp is required to be unchanging.  */\n \n rtx\n-find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n-     rtx goal;\n-     rtx insn;\n-     enum reg_class class;\n-     int other;\n-     short *reload_reg_p;\n-     int goalreg;\n-     enum machine_mode mode;\n+find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n+\t\tshort *reload_reg_p, int goalreg, enum machine_mode mode)\n {\n   rtx p = insn;\n   rtx goaltry, valtry, value, where;\n@@ -6890,8 +6780,7 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n    The value is always positive.  */\n \n static int\n-find_inc_amount (x, inced)\n-     rtx x, inced;\n+find_inc_amount (rtx x, rtx inced)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n@@ -6946,11 +6835,8 @@ find_inc_amount (x, inced)\n    If SETS is nonzero, also consider SETs.  */\n \n int\n-regno_clobbered_p (regno, insn, mode, sets)\n-     unsigned int regno;\n-     rtx insn;\n-     enum machine_mode mode;\n-     int sets;\n+regno_clobbered_p (unsigned int regno, rtx insn, enum machine_mode mode,\n+\t\t   int sets)\n {\n   unsigned int nregs = HARD_REGNO_NREGS (regno, mode);\n   unsigned int endregno = regno + nregs;\n@@ -6988,9 +6874,7 @@ regno_clobbered_p (regno, insn, mode, sets)\n \n /* Find the low part, with mode MODE, of a hard regno RELOADREG.  */\n rtx\n-reload_adjust_reg_for_mode (reloadreg, mode)\n-     rtx reloadreg;\n-     enum machine_mode mode;\n+reload_adjust_reg_for_mode (rtx reloadreg, enum machine_mode mode)\n {\n   int regno;\n \n@@ -7026,8 +6910,7 @@ static const char * const reg_class_names[] = REG_CLASS_NAMES;\n /* These functions are used to print the variables set by 'find_reloads' */\n \n void\n-debug_reload_to_stream (f)\n-     FILE *f;\n+debug_reload_to_stream (FILE *f)\n {\n   int r;\n   const char *prefix;\n@@ -7122,7 +7005,7 @@ debug_reload_to_stream (f)\n }\n \n void\n-debug_reload ()\n+debug_reload (void)\n {\n   debug_reload_to_stream (stderr);\n }"}, {"sha": "9a5e33c843a222c4ab44807b08f88200adce28e4", "filename": "gcc/reload.h", "status": "modified", "additions": 47, "deletions": 49, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -44,7 +44,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define MEMORY_MOVE_COST(MODE,CLASS,IN) 4\n #endif\n #endif\n-extern int memory_move_secondary_cost PARAMS ((enum machine_mode, enum reg_class, int));\n+extern int memory_move_secondary_cost (enum machine_mode, enum reg_class, int);\n \n /* Maximum number of reloads we can need.  */\n #define MAX_RELOADS (2 * MAX_RECOG_OPERANDS * (MAX_REGS_PER_ADDRESS + 1))\n@@ -68,14 +68,14 @@ extern int memory_move_secondary_cost PARAMS ((enum machine_mode, enum reg_class\n                                 reloads; usually secondary reloads\n    RELOAD_OTHER\t\t\tnone of the above, usually multiple uses\n    RELOAD_FOR_OTHER_ADDRESS     reload for part of the address of an input\n-   \t\t\t\tthat is marked RELOAD_OTHER.\n+\t\t\t\tthat is marked RELOAD_OTHER.\n \n    This used to be \"enum reload_when_needed\" but some debuggers have trouble\n    with an enum tag and variable of the same name.  */\n \n enum reload_type\n {\n-  RELOAD_FOR_INPUT, RELOAD_FOR_OUTPUT, RELOAD_FOR_INSN, \n+  RELOAD_FOR_INPUT, RELOAD_FOR_OUTPUT, RELOAD_FOR_INSN,\n   RELOAD_FOR_INPUT_ADDRESS, RELOAD_FOR_INPADDR_ADDRESS,\n   RELOAD_FOR_OUTPUT_ADDRESS, RELOAD_FOR_OUTADDR_ADDRESS,\n   RELOAD_FOR_OPERAND_ADDRESS, RELOAD_FOR_OPADDR_ADDR,\n@@ -147,7 +147,7 @@ struct reload\n      addressing an output, for addressing a non-reloaded mem ref, or for\n      unspecified purposes (i.e., more than one of the above).  */\n   enum reload_type when_needed;\n-  \n+\n   /* Nonzero for an optional reload.  Optional reloads are ignored unless the\n      value is already sitting in a register.  */\n   unsigned int optional:1;\n@@ -203,7 +203,7 @@ struct needs\n /* This structure describes instructions which are relevant for reload.\n    Apart from all regular insns, this also includes CODE_LABELs, since they\n    must be examined for register elimination.  */\n-struct insn_chain \n+struct insn_chain\n {\n   /* Links to the neighbor instructions.  */\n   struct insn_chain *next, *prev;\n@@ -247,146 +247,144 @@ struct insn_chain\n extern struct insn_chain *reload_insn_chain;\n \n /* Allocate a new insn_chain structure.  */\n-extern struct insn_chain *new_insn_chain\tPARAMS ((void));\n+extern struct insn_chain *new_insn_chain (void);\n \n-extern void compute_use_by_pseudos\t\tPARAMS ((HARD_REG_SET *, regset));\n+extern void compute_use_by_pseudos (HARD_REG_SET *, regset);\n #endif\n \n /* Functions from reload.c:  */\n \n-/* Return a memory location that will be used to copy X in mode MODE.  \n+/* Return a memory location that will be used to copy X in mode MODE.\n    If we haven't already made a location for this mode in this insn,\n    call find_reloads_address on the location being returned.  */\n-extern rtx get_secondary_mem PARAMS ((rtx, enum machine_mode,\n-\t\t\t\t    int, enum reload_type));\n+extern rtx get_secondary_mem (rtx, enum machine_mode, int, enum reload_type);\n \n /* Clear any secondary memory locations we've made.  */\n-extern void clear_secondary_mem PARAMS ((void));\n+extern void clear_secondary_mem (void);\n \n /* Transfer all replacements that used to be in reload FROM to be in\n    reload TO.  */\n-extern void transfer_replacements PARAMS ((int, int));\n+extern void transfer_replacements (int, int);\n \n /* IN_RTX is the value loaded by a reload that we now decided to inherit,\n    or a subpart of it.  If we have any replacements registered for IN_RTX,\n    cancel the reloads that were supposed to load them.\n    Return nonzero if we canceled any reloads.  */\n-extern int remove_address_replacements PARAMS ((rtx in_rtx));\n+extern int remove_address_replacements (rtx in_rtx);\n \n /* Like rtx_equal_p except that it allows a REG and a SUBREG to match\n    if they are the same hard reg, and has special hacks for\n    autoincrement and autodecrement.  */\n-extern int operands_match_p PARAMS ((rtx, rtx));\n+extern int operands_match_p (rtx, rtx);\n \n /* Return 1 if altering OP will not modify the value of CLOBBER.  */\n-extern int safe_from_earlyclobber PARAMS ((rtx, rtx));\n+extern int safe_from_earlyclobber (rtx, rtx);\n \n /* Search the body of INSN for values that need reloading and record them\n    with push_reload.  REPLACE nonzero means record also where the values occur\n    so that subst_reloads can be used.  */\n-extern int find_reloads PARAMS ((rtx, int, int, int, short *));\n+extern int find_reloads (rtx, int, int, int, short *);\n \n /* Compute the sum of X and Y, making canonicalizations assumed in an\n    address, namely: sum constant integers, surround the sum of two\n    constants with a CONST, put the constant as the second operand, and\n    group the constant on the outermost sum.  */\n-extern rtx form_sum PARAMS ((rtx, rtx));\n+extern rtx form_sum (rtx, rtx);\n \n /* Substitute into the current INSN the registers into which we have reloaded\n    the things that need reloading.  */\n-extern void subst_reloads PARAMS ((rtx));\n+extern void subst_reloads (rtx);\n \n /* Make a copy of any replacements being done into X and move those copies\n    to locations in Y, a copy of X.  We only look at the highest level of\n    the RTL.  */\n-extern void copy_replacements PARAMS ((rtx, rtx));\n+extern void copy_replacements (rtx, rtx);\n \n /* Change any replacements being done to *X to be done to *Y */\n-extern void move_replacements PARAMS ((rtx *x, rtx *y));\n+extern void move_replacements (rtx *x, rtx *y);\n \n /* If LOC was scheduled to be replaced by something, return the replacement.\n    Otherwise, return *LOC.  */\n-extern rtx find_replacement PARAMS ((rtx *));\n+extern rtx find_replacement (rtx *);\n \n /* Return nonzero if register in range [REGNO, ENDREGNO)\n    appears either explicitly or implicitly in X\n    other than being stored into.  */\n-extern int refers_to_regno_for_reload_p PARAMS ((unsigned int, unsigned int,\n-\t\t\t\t\t\t rtx, rtx *));\n+extern int refers_to_regno_for_reload_p (unsigned int, unsigned int,\n+\t\t\t\t\t rtx, rtx *);\n \n /* Nonzero if modifying X will affect IN.  */\n-extern int reg_overlap_mentioned_for_reload_p PARAMS ((rtx, rtx));\n+extern int reg_overlap_mentioned_for_reload_p (rtx, rtx);\n \n /* Return nonzero if anything in X contains a MEM.  Look also for pseudo\n    registers.  */\n-extern int refers_to_mem_for_reload_p PARAMS ((rtx));\n+extern int refers_to_mem_for_reload_p (rtx);\n \n /* Check the insns before INSN to see if there is a suitable register\n    containing the same value as GOAL.  */\n-extern rtx find_equiv_reg PARAMS ((rtx, rtx, enum reg_class, int, short *,\n-\t\t\t\t int, enum machine_mode));\n+extern rtx find_equiv_reg (rtx, rtx, enum reg_class, int, short *,\n+\t\t\t   int, enum machine_mode);\n \n /* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */\n-extern int regno_clobbered_p PARAMS ((unsigned int, rtx, enum machine_mode,\n-\t\t\t\t      int));\n+extern int regno_clobbered_p (unsigned int, rtx, enum machine_mode, int);\n \n /* Return 1 if X is an operand of an insn that is being earlyclobbered.  */\n-extern int earlyclobber_operand_p PARAMS ((rtx));\n+extern int earlyclobber_operand_p (rtx);\n \n /* Record one reload that needs to be performed.  */\n-extern int push_reload PARAMS ((rtx, rtx, rtx *, rtx *, enum reg_class,\n-\t\t\t\tenum machine_mode, enum machine_mode,\n-\t\t\t\tint, int, int, enum reload_type));\n+extern int push_reload (rtx, rtx, rtx *, rtx *, enum reg_class,\n+\t\t\tenum machine_mode, enum machine_mode,\n+\t\t\tint, int, int, enum reload_type);\n \n /* Functions in postreload.c:  */\n-extern void reload_cse_regs\t\tPARAMS ((rtx));\n+extern void reload_cse_regs (rtx);\n \n /* Functions in reload1.c:  */\n-extern int reloads_conflict\t\tPARAMS ((int, int));\n+extern int reloads_conflict (int, int);\n \n /* Initialize the reload pass once per compilation.  */\n-extern void init_reload PARAMS ((void));\n+extern void init_reload (void);\n \n /* The reload pass itself.  */\n-extern int reload PARAMS ((rtx, int));\n+extern int reload (rtx, int);\n \n /* Mark the slots in regs_ever_live for the hard regs\n    used by pseudo-reg number REGNO.  */\n-extern void mark_home_live PARAMS ((int));\n+extern void mark_home_live (int);\n \n /* Scan X and replace any eliminable registers (such as fp) with a\n    replacement (such as sp), plus an offset.  */\n-extern rtx eliminate_regs PARAMS ((rtx, enum machine_mode, rtx));\n+extern rtx eliminate_regs (rtx, enum machine_mode, rtx);\n \n /* Emit code to perform a reload from IN (which may be a reload register) to\n    OUT (which may also be a reload register).  IN or OUT is from operand\n    OPNUM with reload type TYPE.  */\n-extern rtx gen_reload PARAMS ((rtx, rtx, int, enum reload_type));\n+extern rtx gen_reload (rtx, rtx, int, enum reload_type);\n \n /* Deallocate the reload register used by reload number R.  */\n-extern void deallocate_reload_reg PARAMS ((int r));\n+extern void deallocate_reload_reg (int r);\n \n /* Functions in caller-save.c:  */\n \n /* Initialize for caller-save.  */\n-extern void init_caller_save PARAMS ((void));\n+extern void init_caller_save (void);\n \n /* Initialize save areas by showing that we haven't allocated any yet.  */\n-extern void init_save_areas PARAMS ((void));\n+extern void init_save_areas (void);\n \n /* Allocate save areas for any hard registers that might need saving.  */\n-extern void setup_save_areas PARAMS ((void));\n+extern void setup_save_areas (void);\n \n /* Find the places where hard regs are live across calls and save them.  */\n-extern void save_call_clobbered_regs PARAMS ((void));\n+extern void save_call_clobbered_regs (void);\n \n /* Replace (subreg (reg)) with the appropriate (reg) for any operands.  */\n-extern void cleanup_subreg_operands PARAMS ((rtx));\n+extern void cleanup_subreg_operands (rtx);\n \n /* Debugging support.  */\n-extern void debug_reload_to_stream PARAMS ((FILE *));\n-extern void debug_reload PARAMS ((void));\n+extern void debug_reload_to_stream (FILE *);\n+extern void debug_reload (void);\n \n /* Compute the actual register we should reload to, in case we're\n    reloading to/from a register that is wider than a word.  */\n-extern rtx reload_adjust_reg_for_mode PARAMS ((rtx, enum machine_mode));\n+extern rtx reload_adjust_reg_for_mode (rtx, enum machine_mode);"}, {"sha": "fadc6d302814bad8977d31c44e2a210a6798d1f7", "filename": "gcc/reload1.c", "status": "modified", "additions": 143, "deletions": 263, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -364,86 +364,77 @@ static int (*offsets_at)[NUM_ELIMINABLE_REGS];\n \n static int num_labels;\n \f\n-static void replace_pseudos_in\tPARAMS ((rtx *, enum machine_mode, rtx));\n-static void maybe_fix_stack_asms\tPARAMS ((void));\n-static void copy_reloads\t\tPARAMS ((struct insn_chain *));\n-static void calculate_needs_all_insns\tPARAMS ((int));\n-static int find_reg\t\t\tPARAMS ((struct insn_chain *, int));\n-static void find_reload_regs\t\tPARAMS ((struct insn_chain *));\n-static void select_reload_regs\t\tPARAMS ((void));\n-static void delete_caller_save_insns\tPARAMS ((void));\n-\n-static void spill_failure\t\tPARAMS ((rtx, enum reg_class));\n-static void count_spilled_pseudo\tPARAMS ((int, int, int));\n-static void delete_dead_insn\t\tPARAMS ((rtx));\n-static void alter_reg\t\t\tPARAMS ((int, int));\n-static void set_label_offsets\t\tPARAMS ((rtx, rtx, int));\n-static void check_eliminable_occurrences\tPARAMS ((rtx));\n-static void elimination_effects\t\tPARAMS ((rtx, enum machine_mode));\n-static int eliminate_regs_in_insn\tPARAMS ((rtx, int));\n-static void update_eliminable_offsets\tPARAMS ((void));\n-static void mark_not_eliminable\t\tPARAMS ((rtx, rtx, void *));\n-static void set_initial_elim_offsets\tPARAMS ((void));\n-static void verify_initial_elim_offsets\tPARAMS ((void));\n-static void set_initial_label_offsets\tPARAMS ((void));\n-static void set_offsets_for_label\tPARAMS ((rtx));\n-static void init_elim_table\t\tPARAMS ((void));\n-static void update_eliminables\t\tPARAMS ((HARD_REG_SET *));\n-static void spill_hard_reg\t\tPARAMS ((unsigned int, int));\n-static int finish_spills\t\tPARAMS ((int));\n-static void ior_hard_reg_set\t\tPARAMS ((HARD_REG_SET *, HARD_REG_SET *));\n-static void scan_paradoxical_subregs\tPARAMS ((rtx));\n-static void count_pseudo\t\tPARAMS ((int));\n-static void order_regs_for_reload\tPARAMS ((struct insn_chain *));\n-static void reload_as_needed\t\tPARAMS ((int));\n-static void forget_old_reloads_1\tPARAMS ((rtx, rtx, void *));\n-static int reload_reg_class_lower\tPARAMS ((const void *, const void *));\n-static void mark_reload_reg_in_use\tPARAMS ((unsigned int, int,\n-\t\t\t\t\t\t enum reload_type,\n-\t\t\t\t\t\t enum machine_mode));\n-static void clear_reload_reg_in_use\tPARAMS ((unsigned int, int,\n-\t\t\t\t\t\t enum reload_type,\n-\t\t\t\t\t\t enum machine_mode));\n-static int reload_reg_free_p\t\tPARAMS ((unsigned int, int,\n-\t\t\t\t\t\t enum reload_type));\n-static int reload_reg_free_for_value_p\tPARAMS ((int, int, int,\n-\t\t\t\t\t\t enum reload_type,\n-\t\t\t\t\t\t rtx, rtx, int, int));\n-static int free_for_value_p\t\tPARAMS ((int, enum machine_mode, int,\n-\t\t\t\t\t\t enum reload_type, rtx, rtx,\n-\t\t\t\t\t\t int, int));\n-static int reload_reg_reaches_end_p\tPARAMS ((unsigned int, int,\n-\t\t\t\t\t\t enum reload_type));\n-static int allocate_reload_reg\t\tPARAMS ((struct insn_chain *, int,\n-\t\t\t\t\t\t int));\n-static int conflicts_with_override\tPARAMS ((rtx));\n-static void failed_reload\t\tPARAMS ((rtx, int));\n-static int set_reload_reg\t\tPARAMS ((int, int));\n-static void choose_reload_regs_init\tPARAMS ((struct insn_chain *, rtx *));\n-static void choose_reload_regs\t\tPARAMS ((struct insn_chain *));\n-static void merge_assigned_reloads\tPARAMS ((rtx));\n-static void emit_input_reload_insns\tPARAMS ((struct insn_chain *,\n-\t\t\t\t\t\t struct reload *, rtx, int));\n-static void emit_output_reload_insns\tPARAMS ((struct insn_chain *,\n-\t\t\t\t\t\t struct reload *, int));\n-static void do_input_reload\t\tPARAMS ((struct insn_chain *,\n-\t\t\t\t\t\t struct reload *, int));\n-static void do_output_reload\t\tPARAMS ((struct insn_chain *,\n-\t\t\t\t\t\t struct reload *, int));\n-static void emit_reload_insns\t\tPARAMS ((struct insn_chain *));\n-static void delete_output_reload\tPARAMS ((rtx, int, int));\n-static void delete_address_reloads\tPARAMS ((rtx, rtx));\n-static void delete_address_reloads_1\tPARAMS ((rtx, rtx, rtx));\n-static rtx inc_for_reload\t\tPARAMS ((rtx, rtx, rtx, int));\n+static void replace_pseudos_in (rtx *, enum machine_mode, rtx);\n+static void maybe_fix_stack_asms (void);\n+static void copy_reloads (struct insn_chain *);\n+static void calculate_needs_all_insns (int);\n+static int find_reg (struct insn_chain *, int);\n+static void find_reload_regs (struct insn_chain *);\n+static void select_reload_regs (void);\n+static void delete_caller_save_insns (void);\n+\n+static void spill_failure (rtx, enum reg_class);\n+static void count_spilled_pseudo (int, int, int);\n+static void delete_dead_insn (rtx);\n+static void alter_reg (int, int);\n+static void set_label_offsets (rtx, rtx, int);\n+static void check_eliminable_occurrences (rtx);\n+static void elimination_effects (rtx, enum machine_mode);\n+static int eliminate_regs_in_insn (rtx, int);\n+static void update_eliminable_offsets (void);\n+static void mark_not_eliminable (rtx, rtx, void *);\n+static void set_initial_elim_offsets (void);\n+static void verify_initial_elim_offsets (void);\n+static void set_initial_label_offsets (void);\n+static void set_offsets_for_label (rtx);\n+static void init_elim_table (void);\n+static void update_eliminables (HARD_REG_SET *);\n+static void spill_hard_reg (unsigned int, int);\n+static int finish_spills (int);\n+static void ior_hard_reg_set (HARD_REG_SET *, HARD_REG_SET *);\n+static void scan_paradoxical_subregs (rtx);\n+static void count_pseudo (int);\n+static void order_regs_for_reload (struct insn_chain *);\n+static void reload_as_needed (int);\n+static void forget_old_reloads_1 (rtx, rtx, void *);\n+static int reload_reg_class_lower (const void *, const void *);\n+static void mark_reload_reg_in_use (unsigned int, int, enum reload_type,\n+\t\t\t\t    enum machine_mode);\n+static void clear_reload_reg_in_use (unsigned int, int, enum reload_type,\n+\t\t\t\t     enum machine_mode);\n+static int reload_reg_free_p (unsigned int, int, enum reload_type);\n+static int reload_reg_free_for_value_p (int, int, int, enum reload_type,\n+\t\t\t\t\trtx, rtx, int, int);\n+static int free_for_value_p (int, enum machine_mode, int, enum reload_type,\n+\t\t\t     rtx, rtx, int, int);\n+static int reload_reg_reaches_end_p (unsigned int, int, enum reload_type);\n+static int allocate_reload_reg (struct insn_chain *, int, int);\n+static int conflicts_with_override (rtx);\n+static void failed_reload (rtx, int);\n+static int set_reload_reg (int, int);\n+static void choose_reload_regs_init (struct insn_chain *, rtx *);\n+static void choose_reload_regs (struct insn_chain *);\n+static void merge_assigned_reloads (rtx);\n+static void emit_input_reload_insns (struct insn_chain *, struct reload *,\n+\t\t\t\t     rtx, int);\n+static void emit_output_reload_insns (struct insn_chain *, struct reload *,\n+\t\t\t\t      int);\n+static void do_input_reload (struct insn_chain *, struct reload *, int);\n+static void do_output_reload (struct insn_chain *, struct reload *, int);\n+static void emit_reload_insns (struct insn_chain *);\n+static void delete_output_reload (rtx, int, int);\n+static void delete_address_reloads (rtx, rtx);\n+static void delete_address_reloads_1 (rtx, rtx, rtx);\n+static rtx inc_for_reload (rtx, rtx, rtx, int);\n #ifdef AUTO_INC_DEC\n-static void add_auto_inc_notes\t\tPARAMS ((rtx, rtx));\n+static void add_auto_inc_notes (rtx, rtx);\n #endif\n-static void copy_eh_notes\t\tPARAMS ((rtx, rtx));\n+static void copy_eh_notes (rtx, rtx);\n \f\n /* Initialize the reload pass once per compilation.  */\n \n void\n-init_reload ()\n+init_reload (void)\n {\n   int i;\n \n@@ -501,7 +492,7 @@ static struct insn_chain *unused_insn_chains = 0;\n \n /* Allocate an empty insn_chain structure.  */\n struct insn_chain *\n-new_insn_chain ()\n+new_insn_chain (void)\n {\n   struct insn_chain *c;\n \n@@ -528,9 +519,7 @@ new_insn_chain ()\n    allocated to pseudos in regset FROM.  */\n \n void\n-compute_use_by_pseudos (to, from)\n-     HARD_REG_SET *to;\n-     regset from;\n+compute_use_by_pseudos (HARD_REG_SET *to, regset from)\n {\n   unsigned int regno;\n \n@@ -562,10 +551,7 @@ compute_use_by_pseudos (to, from)\n    equivalences.  */\n \n static void\n-replace_pseudos_in (loc, mem_mode, usage)\n-     rtx *loc;\n-     enum machine_mode mem_mode;\n-     rtx usage;\n+replace_pseudos_in (rtx *loc, enum machine_mode mem_mode, rtx usage)\n {\n   rtx x = *loc;\n   enum rtx_code code;\n@@ -646,9 +632,7 @@ static int failure;\n    and we must not do any more for this function.  */\n \n int\n-reload (first, global)\n-     rtx first;\n-     int global;\n+reload (rtx first, int global)\n {\n   int i;\n   rtx insn;\n@@ -1182,7 +1166,7 @@ reload (first, global)\n \t\t&& (GET_CODE (XEXP (PATTERN (insn), 0)) != MEM\n \t\t    || GET_MODE (XEXP (PATTERN (insn), 0)) != BLKmode\n \t\t    || (GET_CODE (XEXP (XEXP (PATTERN (insn), 0), 0)) != SCRATCH\n-\t\t\t&& XEXP (XEXP (PATTERN (insn), 0), 0) \n+\t\t\t&& XEXP (XEXP (PATTERN (insn), 0), 0)\n \t\t\t\t!= stack_pointer_rtx))\n \t\t&& (GET_CODE (XEXP (PATTERN (insn), 0)) != REG\n \t\t    || ! REG_FUNCTION_VALUE_P (XEXP (PATTERN (insn), 0)))))\n@@ -1287,7 +1271,7 @@ reload (first, global)\n    The whole thing is rather sick, I'm afraid.  */\n \n static void\n-maybe_fix_stack_asms ()\n+maybe_fix_stack_asms (void)\n {\n #ifdef STACK_REGS\n   const char *constraints[MAX_RECOG_OPERANDS];\n@@ -1400,8 +1384,7 @@ maybe_fix_stack_asms ()\n /* Copy the global variables n_reloads and rld into the corresponding elts\n    of CHAIN.  */\n static void\n-copy_reloads (chain)\n-     struct insn_chain *chain;\n+copy_reloads (struct insn_chain *chain)\n {\n   chain->n_reloads = n_reloads;\n   chain->rld\n@@ -1415,8 +1398,7 @@ copy_reloads (chain)\n    and/or eliminations.  Build the corresponding insns_need_reload list, and\n    set something_needs_elimination as appropriate.  */\n static void\n-calculate_needs_all_insns (global)\n-     int global;\n+calculate_needs_all_insns (int global)\n {\n   struct insn_chain **pprev_reload = &insns_need_reload;\n   struct insn_chain *chain, *next = 0;\n@@ -1531,9 +1513,7 @@ calculate_needs_all_insns (global)\n    should be handled first.  *P1 and *P2 are the reload numbers.  */\n \n static int\n-reload_reg_class_lower (r1p, r2p)\n-     const void *r1p;\n-     const void *r2p;\n+reload_reg_class_lower (const void *r1p, const void *r2p)\n {\n   int r1 = *(const short *) r1p, r2 = *(const short *) r2p;\n   int t;\n@@ -1575,8 +1555,7 @@ static int spill_add_cost[FIRST_PSEUDO_REGISTER];\n /* Update the spill cost arrays, considering that pseudo REG is live.  */\n \n static void\n-count_pseudo (reg)\n-     int reg;\n+count_pseudo (int reg)\n {\n   int freq = REG_FREQ (reg);\n   int r = reg_renumber[reg];\n@@ -1602,8 +1581,7 @@ count_pseudo (reg)\n    contents of BAD_SPILL_REGS for the insn described by CHAIN.  */\n \n static void\n-order_regs_for_reload (chain)\n-     struct insn_chain *chain;\n+order_regs_for_reload (struct insn_chain *chain)\n {\n   int i;\n   HARD_REG_SET used_by_pseudos;\n@@ -1653,8 +1631,7 @@ static HARD_REG_SET used_spill_regs_local;\n    update SPILL_COST/SPILL_ADD_COST.  */\n \n static void\n-count_spilled_pseudo (spilled, spilled_nregs, reg)\n-     int spilled, spilled_nregs, reg;\n+count_spilled_pseudo (int spilled, int spilled_nregs, int reg)\n {\n   int r = reg_renumber[reg];\n   int nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (reg));\n@@ -1673,9 +1650,7 @@ count_spilled_pseudo (spilled, spilled_nregs, reg)\n /* Find reload register to use for reload number ORDER.  */\n \n static int\n-find_reg (chain, order)\n-     struct insn_chain *chain;\n-     int order;\n+find_reg (struct insn_chain *chain, int order)\n {\n   int rnum = reload_order[order];\n   struct reload *rl = rld + rnum;\n@@ -1781,8 +1756,7 @@ find_reg (chain, order)\n    for a smaller class even though it belongs to that class.  */\n \n static void\n-find_reload_regs (chain)\n-     struct insn_chain *chain;\n+find_reload_regs (struct insn_chain *chain)\n {\n   int i;\n \n@@ -1842,7 +1816,7 @@ find_reload_regs (chain)\n }\n \n static void\n-select_reload_regs ()\n+select_reload_regs (void)\n {\n   struct insn_chain *chain;\n \n@@ -1855,7 +1829,7 @@ select_reload_regs ()\n /* Delete all insns that were inserted by emit_caller_save_insns during\n    this iteration.  */\n static void\n-delete_caller_save_insns ()\n+delete_caller_save_insns (void)\n {\n   struct insn_chain *c = reload_insn_chain;\n \n@@ -1887,9 +1861,7 @@ delete_caller_save_insns ()\n    INSN should be one of the insns which needed this particular spill reg.  */\n \n static void\n-spill_failure (insn, class)\n-     rtx insn;\n-     enum reg_class class;\n+spill_failure (rtx insn, enum reg_class class)\n {\n   static const char *const reg_class_names[] = REG_CLASS_NAMES;\n   if (asm_noperands (PATTERN (insn)) >= 0)\n@@ -1907,8 +1879,7 @@ spill_failure (insn, class)\n    data that is dead in INSN.  */\n \n static void\n-delete_dead_insn (insn)\n-     rtx insn;\n+delete_dead_insn (rtx insn)\n {\n   rtx prev = prev_real_insn (insn);\n   rtx prev_dest;\n@@ -1936,9 +1907,7 @@ delete_dead_insn (insn)\n    can share one stack slot.  */\n \n static void\n-alter_reg (i, from_reg)\n-     int i;\n-     int from_reg;\n+alter_reg (int i, int from_reg)\n {\n   /* When outputting an inline function, this can happen\n      for a reg that isn't actually used.  */\n@@ -2086,8 +2055,7 @@ alter_reg (i, from_reg)\n    used by pseudo-reg number REGNO.  */\n \n void\n-mark_home_live (regno)\n-     int regno;\n+mark_home_live (int regno)\n {\n   int i, lim;\n \n@@ -2110,10 +2078,7 @@ mark_home_live (regno)\n    current offset.  */\n \n static void\n-set_label_offsets (x, insn, initial_p)\n-     rtx x;\n-     rtx insn;\n-     int initial_p;\n+set_label_offsets (rtx x, rtx insn, int initial_p)\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx tem;\n@@ -2276,10 +2241,7 @@ set_label_offsets (x, insn, initial_p)\n    the proper thing.  */\n \n rtx\n-eliminate_regs (x, mem_mode, insn)\n-     rtx x;\n-     enum machine_mode mem_mode;\n-     rtx insn;\n+eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n {\n   enum rtx_code code = GET_CODE (x);\n   struct elim_table *ep;\n@@ -2664,10 +2626,7 @@ eliminate_regs (x, mem_mode, insn)\n    the mode of an enclosing MEM rtx, or VOIDmode if not within a MEM.  */\n \n static void\n-elimination_effects (x, mem_mode)\n-     rtx x;\n-     enum machine_mode mem_mode;\n-\n+elimination_effects (rtx x, enum machine_mode mem_mode)\n {\n   enum rtx_code code = GET_CODE (x);\n   struct elim_table *ep;\n@@ -2864,8 +2823,7 @@ elimination_effects (x, mem_mode)\n    eliminable.  */\n \n static void\n-check_eliminable_occurrences (x)\n-     rtx x;\n+check_eliminable_occurrences (rtx x)\n {\n   const char *fmt;\n   int i;\n@@ -2914,9 +2872,7 @@ check_eliminable_occurrences (x)\n    is returned.  Otherwise, 1 is returned.  */\n \n static int\n-eliminate_regs_in_insn (insn, replace)\n-     rtx insn;\n-     int replace;\n+eliminate_regs_in_insn (rtx insn, int replace)\n {\n   int icode = recog_memoized (insn);\n   rtx old_body = PATTERN (insn);\n@@ -3262,7 +3218,7 @@ eliminate_regs_in_insn (insn, replace)\n    grow downward) for each elimination pair.  */\n \n static void\n-update_eliminable_offsets ()\n+update_eliminable_offsets (void)\n {\n   struct elim_table *ep;\n \n@@ -3290,10 +3246,7 @@ update_eliminable_offsets ()\n    the insns of the function.  */\n \n static void\n-mark_not_eliminable (dest, x, data)\n-     rtx dest;\n-     rtx x;\n-     void *data ATTRIBUTE_UNUSED;\n+mark_not_eliminable (rtx dest, rtx x, void *data ATTRIBUTE_UNUSED)\n {\n   unsigned int i;\n \n@@ -3325,7 +3278,7 @@ mark_not_eliminable (dest, x, data)\n    cause incorrect code to be generated if we did not check for it.  */\n \n static void\n-verify_initial_elim_offsets ()\n+verify_initial_elim_offsets (void)\n {\n   int t;\n \n@@ -3348,7 +3301,7 @@ verify_initial_elim_offsets ()\n /* Reset all offsets on eliminable registers to their initial values.  */\n \n static void\n-set_initial_elim_offsets ()\n+set_initial_elim_offsets (void)\n {\n   struct elim_table *ep = reg_eliminate;\n \n@@ -3374,7 +3327,7 @@ set_initial_elim_offsets ()\n    For all other labels, show that we don't know the offsets.  */\n \n static void\n-set_initial_label_offsets ()\n+set_initial_label_offsets (void)\n {\n   rtx x;\n   memset (offsets_known_at, 0, num_labels);\n@@ -3388,8 +3341,7 @@ set_initial_label_offsets ()\n    by INSN.  */\n \n static void\n-set_offsets_for_label (insn)\n-     rtx insn;\n+set_offsets_for_label (rtx insn)\n {\n   unsigned int i;\n   int label_nr = CODE_LABEL_NUMBER (insn);\n@@ -3412,8 +3364,7 @@ set_offsets_for_label (insn)\n    since they can't have changed.  */\n \n static void\n-update_eliminables (pset)\n-     HARD_REG_SET *pset;\n+update_eliminables (HARD_REG_SET *pset)\n {\n   int previous_frame_pointer_needed = frame_pointer_needed;\n   struct elim_table *ep;\n@@ -3489,7 +3440,7 @@ update_eliminables (pset)\n /* Initialize the table of registers to eliminate.  */\n \n static void\n-init_elim_table ()\n+init_elim_table (void)\n {\n   struct elim_table *ep;\n #ifdef ELIMINABLE_REGS\n@@ -3556,9 +3507,7 @@ init_elim_table ()\n    Return nonzero if any pseudos needed to be kicked out.  */\n \n static void\n-spill_hard_reg (regno, cant_eliminate)\n-     unsigned int regno;\n-     int cant_eliminate;\n+spill_hard_reg (unsigned int regno, int cant_eliminate)\n {\n   int i;\n \n@@ -3585,8 +3534,7 @@ spill_hard_reg (regno, cant_eliminate)\n    from within EXECUTE_IF_SET_IN_REG_SET.  Hence this awkwardness.  */\n \n static void\n-ior_hard_reg_set (set1, set2)\n-     HARD_REG_SET *set1, *set2;\n+ior_hard_reg_set (HARD_REG_SET *set1, HARD_REG_SET *set2)\n {\n   IOR_HARD_REG_SET (*set1, *set2);\n }\n@@ -3597,8 +3545,7 @@ ior_hard_reg_set (set1, set2)\n    spill_regs array for use by choose_reload_regs.  */\n \n static int\n-finish_spills (global)\n-     int global;\n+finish_spills (int global)\n {\n   struct insn_chain *chain;\n   int something_changed = 0;\n@@ -3747,8 +3694,7 @@ finish_spills (global)\n    forbidden from being used for spill registers.  */\n \n static void\n-scan_paradoxical_subregs (x)\n-     rtx x;\n+scan_paradoxical_subregs (rtx x)\n {\n   int i;\n   const char *fmt;\n@@ -3811,8 +3757,7 @@ scan_paradoxical_subregs (x)\n    as the insns are scanned.  */\n \n static void\n-reload_as_needed (live_known)\n-     int live_known;\n+reload_as_needed (int live_known)\n {\n   struct insn_chain *chain;\n #if defined (AUTO_INC_DEC)\n@@ -4090,10 +4035,8 @@ reload_as_needed (live_known)\n    or it may be a pseudo reg that was reloaded from.  */\n \n static void\n-forget_old_reloads_1 (x, ignored, data)\n-     rtx x;\n-     rtx ignored ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+forget_old_reloads_1 (rtx x, rtx ignored ATTRIBUTE_UNUSED,\n+\t\t      void *data ATTRIBUTE_UNUSED)\n {\n   unsigned int regno;\n   unsigned int nr;\n@@ -4189,11 +4132,8 @@ static HARD_REG_SET reg_used_in_insn;\n    actually used.  */\n \n static void\n-mark_reload_reg_in_use (regno, opnum, type, mode)\n-     unsigned int regno;\n-     int opnum;\n-     enum reload_type type;\n-     enum machine_mode mode;\n+mark_reload_reg_in_use (unsigned int regno, int opnum, enum reload_type type,\n+\t\t\tenum machine_mode mode)\n {\n   unsigned int nregs = HARD_REGNO_NREGS (regno, mode);\n   unsigned int i;\n@@ -4254,11 +4194,8 @@ mark_reload_reg_in_use (regno, opnum, type, mode)\n /* Similarly, but show REGNO is no longer in use for a reload.  */\n \n static void\n-clear_reload_reg_in_use (regno, opnum, type, mode)\n-     unsigned int regno;\n-     int opnum;\n-     enum reload_type type;\n-     enum machine_mode mode;\n+clear_reload_reg_in_use (unsigned int regno, int opnum,\n+\t\t\t enum reload_type type, enum machine_mode mode)\n {\n   unsigned int nregs = HARD_REGNO_NREGS (regno, mode);\n   unsigned int start_regno, end_regno, r;\n@@ -4366,10 +4303,7 @@ clear_reload_reg_in_use (regno, opnum, type, mode)\n    specified by OPNUM and TYPE.  */\n \n static int\n-reload_reg_free_p (regno, opnum, type)\n-     unsigned int regno;\n-     int opnum;\n-     enum reload_type type;\n+reload_reg_free_p (unsigned int regno, int opnum, enum reload_type type)\n {\n   int i;\n \n@@ -4532,10 +4466,7 @@ reload_reg_free_p (regno, opnum, type)\n    in case the reg has already been marked in use.  */\n \n static int\n-reload_reg_reaches_end_p (regno, opnum, type)\n-     unsigned int regno;\n-     int opnum;\n-     enum reload_type type;\n+reload_reg_reaches_end_p (unsigned int regno, int opnum, enum reload_type type)\n {\n   int i;\n \n@@ -4665,8 +4596,7 @@ reload_reg_reaches_end_p (regno, opnum, type)\n    This function uses the same algorithm as reload_reg_free_p above.  */\n \n int\n-reloads_conflict (r1, r2)\n-     int r1, r2;\n+reloads_conflict (int r1, int r2)\n {\n   enum reload_type r1_type = rld[r1].when_needed;\n   enum reload_type r2_type = rld[r2].when_needed;\n@@ -4757,14 +4687,9 @@ int reload_spill_index[MAX_RELOADS];\n    (possibly comprising multiple hard registers) that we are considering.  */\n \n static int\n-reload_reg_free_for_value_p (start_regno, regno, opnum, type, value, out,\n-\t\t\t     reloadnum, ignore_address_reloads)\n-     int start_regno, regno;\n-     int opnum;\n-     enum reload_type type;\n-     rtx value, out;\n-     int reloadnum;\n-     int ignore_address_reloads;\n+reload_reg_free_for_value_p (int start_regno, int regno, int opnum,\n+\t\t\t     enum reload_type type, rtx value, rtx out,\n+\t\t\t     int reloadnum, int ignore_address_reloads)\n {\n   int time1;\n   /* Set if we see an input reload that must not share its reload register\n@@ -5001,15 +4926,9 @@ reload_reg_free_for_value_p (start_regno, regno, opnum, type, value, out,\n    register.  */\n \n static int\n-free_for_value_p (regno, mode, opnum, type, value, out, reloadnum,\n-\t\t  ignore_address_reloads)\n-     int regno;\n-     enum machine_mode mode;\n-     int opnum;\n-     enum reload_type type;\n-     rtx value, out;\n-     int reloadnum;\n-     int ignore_address_reloads;\n+free_for_value_p (int regno, enum machine_mode mode, int opnum,\n+\t\t  enum reload_type type, rtx value, rtx out, int reloadnum,\n+\t\t  int ignore_address_reloads)\n {\n   int nregs = HARD_REGNO_NREGS (regno, mode);\n   while (nregs-- > 0)\n@@ -5024,8 +4943,7 @@ free_for_value_p (regno, mode, opnum, type, value, out, reloadnum,\n    overriding inheritance.  Return nonzero if so.  */\n \n static int\n-conflicts_with_override (x)\n-     rtx x;\n+conflicts_with_override (rtx x)\n {\n   int i;\n   for (i = 0; i < n_reloads; i++)\n@@ -5038,9 +4956,7 @@ conflicts_with_override (x)\n /* Give an error message saying we failed to find a reload for INSN,\n    and clear out reload R.  */\n static void\n-failed_reload (insn, r)\n-     rtx insn;\n-     int r;\n+failed_reload (rtx insn, int r)\n {\n   if (asm_noperands (PATTERN (insn)) < 0)\n     /* It's the compiler's fault.  */\n@@ -5061,8 +4977,7 @@ failed_reload (insn, r)\n    for reload R.  If it's valid, get an rtx for it.  Return nonzero if\n    successful.  */\n static int\n-set_reload_reg (i, r)\n-     int i, r;\n+set_reload_reg (int i, int r)\n {\n   int regno;\n   rtx reg = spill_reg_rtx[i];\n@@ -5117,10 +5032,8 @@ set_reload_reg (i, r)\n    we didn't change anything.  */\n \n static int\n-allocate_reload_reg (chain, r, last_reload)\n-     struct insn_chain *chain ATTRIBUTE_UNUSED;\n-     int r;\n-     int last_reload;\n+allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n+\t\t     int last_reload)\n {\n   int i, pass, count;\n \n@@ -5241,9 +5154,7 @@ allocate_reload_reg (chain, r, last_reload)\n    is the array we use to restore the reg_rtx field for every reload.  */\n \n static void\n-choose_reload_regs_init (chain, save_reload_reg_rtx)\n-     struct insn_chain *chain;\n-     rtx *save_reload_reg_rtx;\n+choose_reload_regs_init (struct insn_chain *chain, rtx *save_reload_reg_rtx)\n {\n   int i;\n \n@@ -5302,8 +5213,7 @@ choose_reload_regs_init (chain, save_reload_reg_rtx)\n    finding a reload reg in the proper class.  */\n \n static void\n-choose_reload_regs (chain)\n-     struct insn_chain *chain;\n+choose_reload_regs (struct insn_chain *chain)\n {\n   rtx insn = chain->insn;\n   int i, j;\n@@ -5676,7 +5586,7 @@ choose_reload_regs (chain)\n \t\t    {\n \t\t      regs_used |= TEST_HARD_REG_BIT (reload_reg_used_at_all,\n \t\t\t\t\t\t      i);\n-\t\t      bad_for_class |= ! TEST_HARD_REG_BIT (reg_class_contents[(int) rld[r].class], \n+\t\t      bad_for_class |= ! TEST_HARD_REG_BIT (reg_class_contents[(int) rld[r].class],\n \t\t\t\t\t\t\t   i);\n \t\t    }\n \n@@ -5998,8 +5908,7 @@ choose_reload_regs (chain)\n    remove_address_replacements.  */\n \n void\n-deallocate_reload_reg (r)\n-     int r;\n+deallocate_reload_reg (int r)\n {\n   int regno;\n \n@@ -6027,8 +5936,7 @@ deallocate_reload_reg (r)\n    prevent redundant code.  */\n \n static void\n-merge_assigned_reloads (insn)\n-     rtx insn;\n+merge_assigned_reloads (rtx insn)\n {\n   int i, j;\n \n@@ -6168,11 +6076,8 @@ static HARD_REG_SET reg_reloaded_died;\n    has the number J.  OLD contains the value to be used as input.  */\n \n static void\n-emit_input_reload_insns (chain, rl, old, j)\n-     struct insn_chain *chain;\n-     struct reload *rl;\n-     rtx old;\n-     int j;\n+emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n+\t\t\t rtx old, int j)\n {\n   rtx insn = chain->insn;\n   rtx reloadreg = rl->reg_rtx;\n@@ -6659,10 +6564,8 @@ emit_input_reload_insns (chain, rl, old, j)\n /* Generate insns to for the output reload RL, which is for the insn described\n    by CHAIN and has the number J.  */\n static void\n-emit_output_reload_insns (chain, rl, j)\n-     struct insn_chain *chain;\n-     struct reload *rl;\n-     int j;\n+emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n+\t\t\t  int j)\n {\n   rtx reloadreg = rl->reg_rtx;\n   rtx insn = chain->insn;\n@@ -6873,10 +6776,7 @@ emit_output_reload_insns (chain, rl, j)\n /* Do input reloading for reload RL, which is for the insn described by CHAIN\n    and has the number J.  */\n static void\n-do_input_reload (chain, rl, j)\n-     struct insn_chain *chain;\n-     struct reload *rl;\n-     int j;\n+do_input_reload (struct insn_chain *chain, struct reload *rl, int j)\n {\n   rtx insn = chain->insn;\n   rtx old = (rl->in && GET_CODE (rl->in) == MEM\n@@ -6931,10 +6831,7 @@ do_input_reload (chain, rl, j)\n    ??? At some point we need to support handling output reloads of\n    JUMP_INSNs or insns that set cc0.  */\n static void\n-do_output_reload (chain, rl, j)\n-     struct insn_chain *chain;\n-     struct reload *rl;\n-     int j;\n+do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n {\n   rtx note, old;\n   rtx insn = chain->insn;\n@@ -7003,8 +6900,7 @@ do_output_reload (chain, rl, j)\n /* Output insns to reload values in and out of the chosen reload regs.  */\n \n static void\n-emit_reload_insns (chain)\n-     struct insn_chain *chain;\n+emit_reload_insns (struct insn_chain *chain)\n {\n   rtx insn = chain->insn;\n \n@@ -7377,11 +7273,7 @@ emit_reload_insns (chain)\n    Returns first insn emitted.  */\n \n rtx\n-gen_reload (out, in, opnum, type)\n-     rtx out;\n-     rtx in;\n-     int opnum;\n-     enum reload_type type;\n+gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n {\n   rtx last = get_last_insn ();\n   rtx tem;\n@@ -7601,10 +7493,7 @@ gen_reload (out, in, opnum, type)\n    certain that reload J doesn't use REG any longer for input.  */\n \n static void\n-delete_output_reload (insn, j, last_reload_reg)\n-     rtx insn;\n-     int j;\n-     int last_reload_reg;\n+delete_output_reload (rtx insn, int j, int last_reload_reg)\n {\n   rtx output_reload_insn = spill_reg_store[last_reload_reg];\n   rtx reg = spill_reg_stored_to[last_reload_reg];\n@@ -7771,8 +7660,7 @@ delete_output_reload (insn, j, last_reload_reg)\n    reload registers used in DEAD_INSN that are not used till CURRENT_INSN.\n    CURRENT_INSN is being reloaded, so we have to check its reloads too.  */\n static void\n-delete_address_reloads (dead_insn, current_insn)\n-     rtx dead_insn, current_insn;\n+delete_address_reloads (rtx dead_insn, rtx current_insn)\n {\n   rtx set = single_set (dead_insn);\n   rtx set2, dst, prev, next;\n@@ -7808,8 +7696,7 @@ delete_address_reloads (dead_insn, current_insn)\n \n /* Subfunction of delete_address_reloads: process registers found in X.  */\n static void\n-delete_address_reloads_1 (dead_insn, x, current_insn)\n-     rtx dead_insn, x, current_insn;\n+delete_address_reloads_1 (rtx dead_insn, rtx x, rtx current_insn)\n {\n   rtx prev, set, dst, i2;\n   int i, j;\n@@ -7927,10 +7814,7 @@ delete_address_reloads_1 (dead_insn, x, current_insn)\n    Return the instruction that stores into RELOADREG.  */\n \n static rtx\n-inc_for_reload (reloadreg, in, value, inc_amount)\n-     rtx reloadreg;\n-     rtx in, value;\n-     int inc_amount;\n+inc_for_reload (rtx reloadreg, rtx in, rtx value, int inc_amount)\n {\n   /* REG or MEM to be copied and incremented.  */\n   rtx incloc = XEXP (value, 0);\n@@ -8021,9 +7905,7 @@ inc_for_reload (reloadreg, in, value, inc_amount)\n \f\n #ifdef AUTO_INC_DEC\n static void\n-add_auto_inc_notes (insn, x)\n-     rtx insn;\n-     rtx x;\n+add_auto_inc_notes (rtx insn, rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n@@ -8051,9 +7933,7 @@ add_auto_inc_notes (insn, x)\n \n /* Copy EH notes from an insn to its reloads.  */\n static void\n-copy_eh_notes (insn, x)\n-     rtx insn;\n-     rtx x;\n+copy_eh_notes (rtx insn, rtx x)\n {\n   rtx eh_note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n   if (eh_note)\n@@ -8075,7 +7955,7 @@ copy_eh_notes (insn, x)\n \n    Similar handle instructions throwing exceptions internally.  */\n void\n-fixup_abnormal_edges ()\n+fixup_abnormal_edges (void)\n {\n   bool inserted = false;\n   basic_block bb;"}, {"sha": "9a7c05bc7f1813a7c57db04368e915e7b58adece", "filename": "gcc/reorg.c", "status": "modified", "additions": 95, "deletions": 159, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,6 +1,6 @@\n /* Perform instruction reorganizations for delay slot filling.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu).\n    Hacked by Michael Tiemann (tiemann@cygnus.com).\n \n@@ -177,63 +177,60 @@ static int *uid_to_ruid;\n /* Highest valid index in `uid_to_ruid'.  */\n static int max_uid;\n \n-static int stop_search_p\t\tPARAMS ((rtx, int));\n-static int resource_conflicts_p\t\tPARAMS ((struct resources *,\n-\t\t\t\t\t       struct resources *));\n-static int insn_references_resource_p\tPARAMS ((rtx, struct resources *, int));\n-static int insn_sets_resource_p\t\tPARAMS ((rtx, struct resources *, int));\n-static rtx find_end_label\t\tPARAMS ((void));\n-static rtx emit_delay_sequence\t\tPARAMS ((rtx, rtx, int));\n-static rtx add_to_delay_list\t\tPARAMS ((rtx, rtx));\n-static rtx delete_from_delay_slot\tPARAMS ((rtx));\n-static void delete_scheduled_jump\tPARAMS ((rtx));\n-static void note_delay_statistics\tPARAMS ((int, int));\n+static int stop_search_p (rtx, int);\n+static int resource_conflicts_p (struct resources *, struct resources *);\n+static int insn_references_resource_p (rtx, struct resources *, int);\n+static int insn_sets_resource_p (rtx, struct resources *, int);\n+static rtx find_end_label (void);\n+static rtx emit_delay_sequence (rtx, rtx, int);\n+static rtx add_to_delay_list (rtx, rtx);\n+static rtx delete_from_delay_slot (rtx);\n+static void delete_scheduled_jump (rtx);\n+static void note_delay_statistics (int, int);\n #if defined(ANNUL_IFFALSE_SLOTS) || defined(ANNUL_IFTRUE_SLOTS)\n-static rtx optimize_skip\t\tPARAMS ((rtx));\n+static rtx optimize_skip (rtx);\n #endif\n-static int get_jump_flags\t\tPARAMS ((rtx, rtx));\n-static int rare_destination\t\tPARAMS ((rtx));\n-static int mostly_true_jump\t\tPARAMS ((rtx, rtx));\n-static rtx get_branch_condition\t\tPARAMS ((rtx, rtx));\n-static int condition_dominates_p\tPARAMS ((rtx, rtx));\n-static int redirect_with_delay_slots_safe_p PARAMS ((rtx, rtx, rtx));\n-static int redirect_with_delay_list_safe_p PARAMS ((rtx, rtx, rtx));\n-static int check_annul_list_true_false\tPARAMS ((int, rtx));\n-static rtx steal_delay_list_from_target PARAMS ((rtx, rtx, rtx, rtx,\n-\t\t\t\t\t       struct resources *,\n-\t\t\t\t\t       struct resources *,\n-\t\t\t\t\t       struct resources *,\n-\t\t\t\t\t       int, int *, int *, rtx *));\n-static rtx steal_delay_list_from_fallthrough PARAMS ((rtx, rtx, rtx, rtx,\n-\t\t\t\t\t\t    struct resources *,\n-\t\t\t\t\t\t    struct resources *,\n-\t\t\t\t\t\t    struct resources *,\n-\t\t\t\t\t\t    int, int *, int *));\n-static void try_merge_delay_insns\tPARAMS ((rtx, rtx));\n-static rtx redundant_insn\t\tPARAMS ((rtx, rtx, rtx));\n-static int own_thread_p\t\t\tPARAMS ((rtx, rtx, int));\n-static void update_block\t\tPARAMS ((rtx, rtx));\n-static int reorg_redirect_jump\t\tPARAMS ((rtx, rtx));\n-static void update_reg_dead_notes\tPARAMS ((rtx, rtx));\n-static void fix_reg_dead_note\t\tPARAMS ((rtx, rtx));\n-static void update_reg_unused_notes\tPARAMS ((rtx, rtx));\n-static void fill_simple_delay_slots\tPARAMS ((int));\n-static rtx fill_slots_from_thread\tPARAMS ((rtx, rtx, rtx, rtx, int, int,\n-\t\t\t\t\t       int, int, int *, rtx));\n-static void fill_eager_delay_slots\tPARAMS ((void));\n-static void relax_delay_slots\t\tPARAMS ((rtx));\n+static int get_jump_flags (rtx, rtx);\n+static int rare_destination (rtx);\n+static int mostly_true_jump (rtx, rtx);\n+static rtx get_branch_condition (rtx, rtx);\n+static int condition_dominates_p (rtx, rtx);\n+static int redirect_with_delay_slots_safe_p (rtx, rtx, rtx);\n+static int redirect_with_delay_list_safe_p (rtx, rtx, rtx);\n+static int check_annul_list_true_false (int, rtx);\n+static rtx steal_delay_list_from_target (rtx, rtx, rtx, rtx,\n+\t\t\t\t\t struct resources *,\n+\t\t\t\t\t struct resources *,\n+\t\t\t\t\t struct resources *,\n+\t\t\t\t\t int, int *, int *, rtx *);\n+static rtx steal_delay_list_from_fallthrough (rtx, rtx, rtx, rtx,\n+\t\t\t\t\t      struct resources *,\n+\t\t\t\t\t      struct resources *,\n+\t\t\t\t\t      struct resources *,\n+\t\t\t\t\t      int, int *, int *);\n+static void try_merge_delay_insns (rtx, rtx);\n+static rtx redundant_insn (rtx, rtx, rtx);\n+static int own_thread_p (rtx, rtx, int);\n+static void update_block (rtx, rtx);\n+static int reorg_redirect_jump (rtx, rtx);\n+static void update_reg_dead_notes (rtx, rtx);\n+static void fix_reg_dead_note (rtx, rtx);\n+static void update_reg_unused_notes (rtx, rtx);\n+static void fill_simple_delay_slots (int);\n+static rtx fill_slots_from_thread (rtx, rtx, rtx, rtx, int, int, int, int,\n+\t\t\t\t   int *, rtx);\n+static void fill_eager_delay_slots (void);\n+static void relax_delay_slots (rtx);\n #ifdef HAVE_return\n-static void make_return_insns\t\tPARAMS ((rtx));\n+static void make_return_insns (rtx);\n #endif\n \f\n /* Return TRUE if this insn should stop the search for insn to fill delay\n    slots.  LABELS_P indicates that labels should terminate the search.\n    In all cases, jumps terminate the search.  */\n \n static int\n-stop_search_p (insn, labels_p)\n-     rtx insn;\n-     int labels_p;\n+stop_search_p (rtx insn, int labels_p)\n {\n   if (insn == 0)\n     return 1;\n@@ -267,8 +264,7 @@ stop_search_p (insn, labels_p)\n    resource set contains a volatile memory reference.  Otherwise, return FALSE.  */\n \n static int\n-resource_conflicts_p (res1, res2)\n-     struct resources *res1, *res2;\n+resource_conflicts_p (struct resources *res1, struct resources *res2)\n {\n   if ((res1->cc && res2->cc) || (res1->memory && res2->memory)\n       || (res1->unch_memory && res2->unch_memory)\n@@ -299,10 +295,8 @@ resource_conflicts_p (res1, res2)\n    a large block of complex code.  */\n \n static int\n-insn_references_resource_p (insn, res, include_delayed_effects)\n-     rtx insn;\n-     struct resources *res;\n-     int include_delayed_effects;\n+insn_references_resource_p (rtx insn, struct resources *res,\n+\t\t\t    int include_delayed_effects)\n {\n   struct resources insn_res;\n \n@@ -317,10 +311,8 @@ insn_references_resource_p (insn, res, include_delayed_effects)\n    in front of mark_set_resources for details.  */\n \n static int\n-insn_sets_resource_p (insn, res, include_delayed_effects)\n-     rtx insn;\n-     struct resources *res;\n-     int include_delayed_effects;\n+insn_sets_resource_p (rtx insn, struct resources *res,\n+\t\t      int include_delayed_effects)\n {\n   struct resources insn_sets;\n \n@@ -333,7 +325,7 @@ insn_sets_resource_p (insn, res, include_delayed_effects)\n    none, make one.  */\n \n static rtx\n-find_end_label ()\n+find_end_label (void)\n {\n   rtx insn;\n \n@@ -430,10 +422,7 @@ find_end_label ()\n    Returns the SEQUENCE that replaces INSN.  */\n \n static rtx\n-emit_delay_sequence (insn, list, length)\n-     rtx insn;\n-     rtx list;\n-     int length;\n+emit_delay_sequence (rtx insn, rtx list, int length)\n {\n   int i = 1;\n   rtx li;\n@@ -556,9 +545,7 @@ emit_delay_sequence (insn, list, length)\n    be in the order in which the insns are to be executed.  */\n \n static rtx\n-add_to_delay_list (insn, delay_list)\n-     rtx insn;\n-     rtx delay_list;\n+add_to_delay_list (rtx insn, rtx delay_list)\n {\n   /* If we have an empty list, just make a new list element.  If\n      INSN has its block number recorded, clear it since we may\n@@ -581,8 +568,7 @@ add_to_delay_list (insn, delay_list)\n    produce an insn with no delay slots.  Return the new insn.  */\n \n static rtx\n-delete_from_delay_slot (insn)\n-     rtx insn;\n+delete_from_delay_slot (rtx insn)\n {\n   rtx trial, seq_insn, seq, prev;\n   rtx delay_list = 0;\n@@ -639,8 +625,7 @@ delete_from_delay_slot (insn)\n    the insn that sets CC0 for it and delete it too.  */\n \n static void\n-delete_scheduled_jump (insn)\n-     rtx insn;\n+delete_scheduled_jump (rtx insn)\n {\n   /* Delete the insn that sets cc0 for us.  On machines without cc0, we could\n      delete the insn that sets the condition code, but it is hard to find it.\n@@ -697,8 +682,7 @@ static int num_filled_delays[NUM_REORG_FUNCTIONS][MAX_DELAY_HISTOGRAM+1][MAX_REO\n static int reorg_pass_number;\n \n static void\n-note_delay_statistics (slots_filled, index)\n-     int slots_filled, index;\n+note_delay_statistics (int slots_filled, int index)\n {\n   num_insns_needing_delays[index][reorg_pass_number]++;\n   if (slots_filled > MAX_DELAY_HISTOGRAM)\n@@ -741,8 +725,7 @@ note_delay_statistics (slots_filled, index)\n    of delay slots required.  */\n \n static rtx\n-optimize_skip (insn)\n-     rtx insn;\n+optimize_skip (rtx insn)\n {\n   rtx trial = next_nonnote_insn (insn);\n   rtx next_trial = next_active_insn (trial);\n@@ -823,8 +806,7 @@ optimize_skip (insn)\n     are predicted as very likely taken.  */\n \n static int\n-get_jump_flags (insn, label)\n-     rtx insn, label;\n+get_jump_flags (rtx insn, rtx label)\n {\n   int flags;\n \n@@ -887,8 +869,7 @@ get_jump_flags (insn, label)\n    return 0.  */\n \n static int\n-rare_destination (insn)\n-     rtx insn;\n+rare_destination (rtx insn)\n {\n   int jump_count = 0;\n   rtx next;\n@@ -939,8 +920,7 @@ rare_destination (insn)\n    CONDITION, if nonzero, is the condition that JUMP_INSN is testing.  */\n \n static int\n-mostly_true_jump (jump_insn, condition)\n-     rtx jump_insn, condition;\n+mostly_true_jump (rtx jump_insn, rtx condition)\n {\n   rtx target_label = JUMP_LABEL (jump_insn);\n   rtx insn, note;\n@@ -1062,9 +1042,7 @@ mostly_true_jump (jump_insn, condition)\n    type of jump, or it doesn't go to TARGET, return 0.  */\n \n static rtx\n-get_branch_condition (insn, target)\n-     rtx insn;\n-     rtx target;\n+get_branch_condition (rtx insn, rtx target)\n {\n   rtx pat = PATTERN (insn);\n   rtx src;\n@@ -1110,9 +1088,7 @@ get_branch_condition (insn, target)\n    INSN, i.e., if INSN will always branch if CONDITION is true.  */\n \n static int\n-condition_dominates_p (condition, insn)\n-     rtx condition;\n-     rtx insn;\n+condition_dominates_p (rtx condition, rtx insn)\n {\n   rtx other_condition = get_branch_condition (insn, JUMP_LABEL (insn));\n   enum rtx_code code = GET_CODE (condition);\n@@ -1138,8 +1114,7 @@ condition_dominates_p (condition, insn)\n    any insns already in the delay slot of JUMP.  */\n \n static int\n-redirect_with_delay_slots_safe_p (jump, newlabel, seq)\n-     rtx jump, newlabel, seq;\n+redirect_with_delay_slots_safe_p (rtx jump, rtx newlabel, rtx seq)\n {\n   int flags, i;\n   rtx pat = PATTERN (seq);\n@@ -1173,8 +1148,7 @@ redirect_with_delay_slots_safe_p (jump, newlabel, seq)\n    any insns we wish to place in the delay slot of JUMP.  */\n \n static int\n-redirect_with_delay_list_safe_p (jump, newlabel, delay_list)\n-     rtx jump, newlabel, delay_list;\n+redirect_with_delay_list_safe_p (rtx jump, rtx newlabel, rtx delay_list)\n {\n   int flags, i;\n   rtx li;\n@@ -1207,9 +1181,7 @@ redirect_with_delay_list_safe_p (jump, newlabel, delay_list)\n    If not, return 0; otherwise return 1.  */\n \n static int\n-check_annul_list_true_false (annul_true_p, delay_list)\n-     int annul_true_p;\n-     rtx delay_list;\n+check_annul_list_true_false (int annul_true_p, rtx delay_list)\n {\n   rtx temp;\n \n@@ -1249,18 +1221,12 @@ check_annul_list_true_false (annul_true_p, delay_list)\n    execution should continue.  */\n \n static rtx\n-steal_delay_list_from_target (insn, condition, seq, delay_list,\n-\t\t\t      sets, needed, other_needed,\n-\t\t\t      slots_to_fill, pslots_filled, pannul_p,\n-\t\t\t      pnew_thread)\n-     rtx insn, condition;\n-     rtx seq;\n-     rtx delay_list;\n-     struct resources *sets, *needed, *other_needed;\n-     int slots_to_fill;\n-     int *pslots_filled;\n-     int *pannul_p;\n-     rtx *pnew_thread;\n+steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n+\t\t\t      rtx delay_list, struct resources *sets,\n+\t\t\t      struct resources *needed,\n+\t\t\t      struct resources *other_needed,\n+\t\t\t      int slots_to_fill, int *pslots_filled,\n+\t\t\t      int *pannul_p, rtx *pnew_thread)\n {\n   rtx temp;\n   int slots_remaining = slots_to_fill - *pslots_filled;\n@@ -1388,16 +1354,12 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n    for INSN since unconditional branches are much easier to fill.  */\n \n static rtx\n-steal_delay_list_from_fallthrough (insn, condition, seq,\n-\t\t\t\t   delay_list, sets, needed, other_needed,\n-\t\t\t\t   slots_to_fill, pslots_filled, pannul_p)\n-     rtx insn, condition;\n-     rtx seq;\n-     rtx delay_list;\n-     struct resources *sets, *needed, *other_needed;\n-     int slots_to_fill;\n-     int *pslots_filled;\n-     int *pannul_p;\n+steal_delay_list_from_fallthrough (rtx insn, rtx condition, rtx seq,\n+\t\t\t\t   rtx delay_list, struct resources *sets,\n+\t\t\t\t   struct resources *needed,\n+\t\t\t\t   struct resources *other_needed,\n+\t\t\t\t   int slots_to_fill, int *pslots_filled,\n+\t\t\t\t   int *pannul_p)\n {\n   int i;\n   int flags;\n@@ -1472,8 +1434,7 @@ steal_delay_list_from_fallthrough (insn, condition, seq,\n    we delete the merged insn.  */\n \n static void\n-try_merge_delay_insns (insn, thread)\n-     rtx insn, thread;\n+try_merge_delay_insns (rtx insn, rtx thread)\n {\n   rtx trial, next_trial;\n   rtx delay_insn = XVECEXP (PATTERN (insn), 0, 0);\n@@ -1663,10 +1624,7 @@ try_merge_delay_insns (insn, thread)\n    gain in rare cases.  */\n \n static rtx\n-redundant_insn (insn, target, delay_list)\n-     rtx insn;\n-     rtx target;\n-     rtx delay_list;\n+redundant_insn (rtx insn, rtx target, rtx delay_list)\n {\n   rtx target_main = target;\n   rtx ipat = PATTERN (insn);\n@@ -1873,10 +1831,7 @@ redundant_insn (insn, target, delay_list)\n    finding an active insn, we do not own this thread.  */\n \n static int\n-own_thread_p (thread, label, allow_fallthrough)\n-     rtx thread;\n-     rtx label;\n-     int allow_fallthrough;\n+own_thread_p (rtx thread, rtx label, int allow_fallthrough)\n {\n   rtx active_insn;\n   rtx insn;\n@@ -1920,9 +1875,7 @@ own_thread_p (thread, label, allow_fallthrough)\n    BARRIER in relax_delay_slots.  */\n \n static void\n-update_block (insn, where)\n-     rtx insn;\n-     rtx where;\n+update_block (rtx insn, rtx where)\n {\n   /* Ignore if this was in a delay slot and it came from the target of\n      a branch.  */\n@@ -1941,9 +1894,7 @@ update_block (insn, where)\n    the basic block containing the jump.  */\n \n static int\n-reorg_redirect_jump (jump, nlabel)\n-     rtx jump;\n-     rtx nlabel;\n+reorg_redirect_jump (rtx jump, rtx nlabel)\n {\n   incr_ticks_for_insn (jump);\n   return redirect_jump (jump, nlabel, 1);\n@@ -1961,8 +1912,7 @@ reorg_redirect_jump (jump, nlabel)\n    is dead because it sees a REG_DEAD note immediately before a CODE_LABEL.  */\n \n static void\n-update_reg_dead_notes (insn, delayed_insn)\n-     rtx insn, delayed_insn;\n+update_reg_dead_notes (rtx insn, rtx delayed_insn)\n {\n   rtx p, link, next;\n \n@@ -1995,8 +1945,7 @@ update_reg_dead_notes (insn, delayed_insn)\n    confused into thinking the register is dead.  */\n \n static void\n-fix_reg_dead_note (start_insn, stop_insn)\n-     rtx start_insn, stop_insn;\n+fix_reg_dead_note (rtx start_insn, rtx stop_insn)\n {\n   rtx p, link, next;\n \n@@ -2026,8 +1975,7 @@ fix_reg_dead_note (start_insn, stop_insn)\n    does.  */\n \n static void\n-update_reg_unused_notes (insn, redundant_insn)\n-     rtx insn, redundant_insn;\n+update_reg_unused_notes (rtx insn, rtx redundant_insn)\n {\n   rtx link, next;\n \n@@ -2060,8 +2008,7 @@ update_reg_unused_notes (insn, redundant_insn)\n    through FINAL_SEQUENCE.  */\n \n static void\n-fill_simple_delay_slots (non_jumps_p)\n-     int non_jumps_p;\n+fill_simple_delay_slots (int non_jumps_p)\n {\n   rtx insn, pat, trial, next_trial;\n   int i;\n@@ -2564,17 +2511,10 @@ fill_simple_delay_slots (non_jumps_p)\n    slot.  We then adjust the jump to point after the insns we have taken.  */\n \n static rtx\n-fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n-\t\t\tthread_if_true, own_thread,\n-\t\t\tslots_to_fill, pslots_filled, delay_list)\n-     rtx insn;\n-     rtx condition;\n-     rtx thread, opposite_thread;\n-     int likely;\n-     int thread_if_true;\n-     int own_thread;\n-     int slots_to_fill, *pslots_filled;\n-     rtx delay_list;\n+fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n+\t\t\trtx opposite_thread, int likely, int thread_if_true,\n+\t\t\tint own_thread, int slots_to_fill,\n+\t\t\tint *pslots_filled, rtx delay_list)\n {\n   rtx new_thread;\n   struct resources opposite_needed, set, needed;\n@@ -2991,7 +2931,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n    if safe.  */\n \n static void\n-fill_eager_delay_slots ()\n+fill_eager_delay_slots (void)\n {\n   rtx insn;\n   int i;\n@@ -3018,7 +2958,7 @@ fill_eager_delay_slots ()\n \t delay slots only in certain circumstances which may depend on\n \t nearby insns (which change due to reorg's actions).\n \n- \t For example, the PA port normally has delay slots for unconditional\n+\t For example, the PA port normally has delay slots for unconditional\n \t jumps.\n \n \t However, the PA port claims such jumps do not have a delay slot\n@@ -3119,8 +3059,7 @@ fill_eager_delay_slots ()\n    threading.  */\n \n static void\n-relax_delay_slots (first)\n-     rtx first;\n+relax_delay_slots (rtx first)\n {\n   rtx insn, next, pat;\n   rtx trial, delay_insn, target_label;\n@@ -3485,8 +3424,7 @@ relax_delay_slots (first)\n    RETURN as well.  */\n \n static void\n-make_return_insns (first)\n-     rtx first;\n+make_return_insns (rtx first)\n {\n   rtx insn, jump_insn, pat;\n   rtx real_return_label = end_of_function_label;\n@@ -3617,9 +3555,7 @@ make_return_insns (first)\n /* Try to find insns to place in delay slots.  */\n \n void\n-dbr_schedule (first, file)\n-     rtx first;\n-     FILE *file;\n+dbr_schedule (rtx first, FILE *file)\n {\n   rtx insn, next, epilogue_insn = 0;\n   int i;"}, {"sha": "4d4cc6be50f8fcad15b44daf289fc85b25b81dea", "filename": "gcc/resource.c", "status": "modified", "additions": 24, "deletions": 45, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,6 @@\n /* Definitions for computing resource usage of specific insns.\n-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -78,21 +79,18 @@ static HARD_REG_SET current_live_regs;\n \n static HARD_REG_SET pending_dead_regs;\n \f\n-static void update_live_status\t\tPARAMS ((rtx, rtx, void *));\n-static int find_basic_block\t\tPARAMS ((rtx, int));\n-static rtx next_insn_no_annul\t\tPARAMS ((rtx));\n-static rtx find_dead_or_set_registers\tPARAMS ((rtx, struct resources*,\n-\t\t\t\t\t\trtx*, int, struct resources,\n-\t\t\t\t\t\tstruct resources));\n+static void update_live_status (rtx, rtx, void *);\n+static int find_basic_block (rtx, int);\n+static rtx next_insn_no_annul (rtx);\n+static rtx find_dead_or_set_registers (rtx, struct resources*,\n+\t\t\t\t       rtx*, int, struct resources,\n+\t\t\t\t       struct resources);\n \f\n /* Utility function called from mark_target_live_regs via note_stores.\n    It deadens any CLOBBERed registers and livens any SET registers.  */\n \n static void\n-update_live_status (dest, x, data)\n-     rtx dest;\n-     rtx x;\n-     void *data ATTRIBUTE_UNUSED;\n+update_live_status (rtx dest, rtx x, void *data ATTRIBUTE_UNUSED)\n {\n   int first_regno, last_regno;\n   int i;\n@@ -131,9 +129,7 @@ update_live_status (dest, x, data)\n    correct.  */\n \n static int\n-find_basic_block (insn, search_limit)\n-     rtx insn;\n-     int search_limit;\n+find_basic_block (rtx insn, int search_limit)\n {\n   basic_block bb;\n \n@@ -170,8 +166,7 @@ find_basic_block (insn, search_limit)\n    an annulled branch.  */\n \n static rtx\n-next_insn_no_annul (insn)\n-     rtx insn;\n+next_insn_no_annul (rtx insn)\n {\n   if (insn)\n     {\n@@ -210,10 +205,8 @@ next_insn_no_annul (insn)\n    CALL_INSNs.  */\n \n void\n-mark_referenced_resources (x, res, include_delayed_effects)\n-     rtx x;\n-     struct resources *res;\n-     int include_delayed_effects;\n+mark_referenced_resources (rtx x, struct resources *res,\n+\t\t\t   int include_delayed_effects)\n {\n   enum rtx_code code = GET_CODE (x);\n   int i, j;\n@@ -443,12 +436,9 @@ mark_referenced_resources (x, res, include_delayed_effects)\n    number of unconditional branches.  */\n \n static rtx\n-find_dead_or_set_registers (target, res, jump_target, jump_count, set, needed)\n-     rtx target;\n-     struct resources *res;\n-     rtx *jump_target;\n-     int jump_count;\n-     struct resources set, needed;\n+find_dead_or_set_registers (rtx target, struct resources *res,\n+\t\t\t    rtx *jump_target, int jump_count,\n+\t\t\t    struct resources set, struct resources needed)\n {\n   HARD_REG_SET scratch;\n   rtx insn, next;\n@@ -638,11 +628,8 @@ find_dead_or_set_registers (target, res, jump_target, jump_count, set, needed)\n    our computation and thus may be placed in a delay slot.  */\n \n void\n-mark_set_resources (x, res, in_dest, mark_type)\n-     rtx x;\n-     struct resources *res;\n-     int in_dest;\n-     enum mark_resource_type mark_type;\n+mark_set_resources (rtx x, struct resources *res, int in_dest,\n+\t\t    enum mark_resource_type mark_type)\n {\n   enum rtx_code code;\n   int i, j;\n@@ -902,10 +889,7 @@ mark_set_resources (x, res, in_dest, mark_type)\n    init_resource_info () was invoked before we are called.  */\n \n void\n-mark_target_live_regs (insns, target, res)\n-     rtx insns;\n-     rtx target;\n-     struct resources *res;\n+mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n {\n   int b = -1;\n   unsigned int i;\n@@ -1172,8 +1156,7 @@ mark_target_live_regs (insns, target, res)\n    This should be invoked before the first call to mark_target_live_regs.  */\n \n void\n-init_resource_info (epilogue_insn)\n-     rtx epilogue_insn;\n+init_resource_info (rtx epilogue_insn)\n {\n   int i;\n \n@@ -1249,7 +1232,7 @@ init_resource_info (epilogue_insn)\n    should be invoked after the last call to mark_target_live_regs ().  */\n \n void\n-free_resource_info ()\n+free_resource_info (void)\n {\n   if (target_hash_table != NULL)\n     {\n@@ -1281,8 +1264,7 @@ free_resource_info ()\n /* Clear any hashed information that we have stored for INSN.  */\n \n void\n-clear_hashed_info_for_insn (insn)\n-     rtx insn;\n+clear_hashed_info_for_insn (rtx insn)\n {\n   struct target_info *tinfo;\n \n@@ -1301,8 +1283,7 @@ clear_hashed_info_for_insn (insn)\n /* Increment the tick count for the basic block that contains INSN.  */\n \n void\n-incr_ticks_for_insn (insn)\n-     rtx insn;\n+incr_ticks_for_insn (rtx insn)\n {\n   int b = find_basic_block (insn, MAX_DELAY_SLOT_LIVE_SEARCH);\n \n@@ -1313,9 +1294,7 @@ incr_ticks_for_insn (insn)\n /* Add TRIAL to the set of resources used at the end of the current\n    function.  */\n void\n-mark_end_of_function_resources (trial, include_delayed_effects)\n-     rtx trial;\n-     int include_delayed_effects;\n+mark_end_of_function_resources (rtx trial, int include_delayed_effects)\n {\n   mark_referenced_resources (trial, &end_of_function_needs,\n \t\t\t     include_delayed_effects);"}, {"sha": "b738a0c504fa0549bde369a5dd9f3ab14183b8ea", "filename": "gcc/resource.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fresource.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Fresource.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for computing resource usage of specific insns.\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -41,12 +41,12 @@ enum mark_resource_type\n   MARK_DEST = 2\n };\n \n-extern void mark_target_live_regs \tPARAMS ((rtx, rtx, struct resources *));\n-extern void mark_set_resources\t\tPARAMS ((rtx, struct resources *, int,\n-\t\t\t\t\t       enum mark_resource_type));\n-extern void mark_referenced_resources\tPARAMS ((rtx, struct resources *, int));\n-extern void clear_hashed_info_for_insn\tPARAMS ((rtx));\n-extern void incr_ticks_for_insn\t\tPARAMS ((rtx));\n-extern void mark_end_of_function_resources PARAMS ((rtx, int));\n-extern void init_resource_info\t\tPARAMS ((rtx));\n-extern void free_resource_info\t\tPARAMS ((void));\n+extern void mark_target_live_regs (rtx, rtx, struct resources *);\n+extern void mark_set_resources (rtx, struct resources *, int,\n+\t\t\t\tenum mark_resource_type);\n+extern void mark_referenced_resources (rtx, struct resources *, int);\n+extern void clear_hashed_info_for_insn (rtx);\n+extern void incr_ticks_for_insn (rtx);\n+extern void mark_end_of_function_resources (rtx, int);\n+extern void init_resource_info (rtx);\n+extern void free_resource_info (void);"}, {"sha": "72ef094b112a60e93ab4985aec63ef2cea0a4db9", "filename": "gcc/rtl-error.c", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Frtl-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Frtl-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-error.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -33,19 +33,17 @@ Boston, MA 02111-1307, USA.  */\n #include \"intl.h\"\n #include \"diagnostic.h\"\n \n-static location_t location_for_asm PARAMS ((rtx));\n-static void diagnostic_for_asm PARAMS ((rtx, const char *, va_list *,\n-                                        diagnostic_t));\n+static location_t location_for_asm (rtx);\n+static void diagnostic_for_asm (rtx, const char *, va_list *, diagnostic_t);\n \n /* Figure the location of the given INSN.  */\n static location_t\n-location_for_asm (insn)\n-     rtx insn;\n+location_for_asm (rtx insn)\n {\n   rtx body = PATTERN (insn);\n   rtx asmop;\n   location_t loc;\n-  \n+\n   /* Find the (or one of the) ASM_OPERANDS in the insn.  */\n   if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n     asmop = SET_SRC (body);\n@@ -74,14 +72,11 @@ location_for_asm (insn)\n    of the insn INSN.  This is used only when INSN is an `asm' with operands,\n    and each ASM_OPERANDS records its own source file and line.  */\n static void\n-diagnostic_for_asm (insn, msg, args_ptr, kind)\n-     rtx insn;\n-     const char *msg;\n-     va_list *args_ptr;\n-     diagnostic_t kind;\n+diagnostic_for_asm (rtx insn, const char *msg, va_list *args_ptr,\n+\t\t    diagnostic_t kind)\n {\n   diagnostic_info diagnostic;\n-  \n+\n   diagnostic_set_info (&diagnostic, msg, args_ptr,\n \t\t       location_for_asm (insn), kind);\n   report_diagnostic (&diagnostic);\n@@ -91,7 +86,7 @@ void\n error_for_asm (rtx insn, const char *msgid, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, msgid);\n   diagnostic_for_asm (insn, msgid, &ap, DK_ERROR);\n   va_end (ap);\n@@ -101,19 +96,15 @@ void\n warning_for_asm (rtx insn, const char *msgid, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, msgid);\n   diagnostic_for_asm (insn, msgid, &ap, DK_WARNING);\n   va_end (ap);\n }\n \n void\n-_fatal_insn (msgid, insn, file, line, function)\n-     const char *msgid;\n-     rtx insn;\n-     const char *file;\n-     int line;\n-     const char *function;\n+_fatal_insn (const char *msgid, rtx insn, const char *file, int line,\n+\t     const char *function)\n {\n   error (\"%s\", _(msgid));\n \n@@ -126,16 +117,12 @@ _fatal_insn (msgid, insn, file, line, function)\n }\n \n void\n-_fatal_insn_not_found (insn, file, line, function)\n-     rtx insn;\n-     const char *file;\n-     int line;\n-     const char *function;\n+_fatal_insn_not_found (rtx insn, const char *file, int line,\n+\t\t       const char *function)\n {\n   if (INSN_CODE (insn) < 0)\n     _fatal_insn (\"unrecognizable insn:\", insn, file, line, function);\n   else\n     _fatal_insn (\"insn does not satisfy its constraints:\",\n \t\tinsn, file, line, function);\n }\n-"}, {"sha": "a92ca4b502e4f1f6adc0483c54698a6991a9a042", "filename": "gcc/rtl.c", "status": "modified", "additions": 19, "deletions": 55, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -240,8 +240,7 @@ const char * const reg_note_name[] =\n    Store the length, and initialize all elements to zero.  */\n \n rtvec\n-rtvec_alloc (n)\n-     int n;\n+rtvec_alloc (int n)\n {\n   rtvec rt;\n \n@@ -257,8 +256,7 @@ rtvec_alloc (n)\n    all the rest is initialized to zero.  */\n \n rtx\n-rtx_alloc (code)\n-  RTX_CODE code;\n+rtx_alloc (RTX_CODE code)\n {\n   rtx rt;\n   int n = GET_RTX_LENGTH (code);\n@@ -280,8 +278,7 @@ rtx_alloc (code)\n    except for those few rtx codes that are sharable.  */\n \n rtx\n-copy_rtx (orig)\n-     rtx orig;\n+copy_rtx (rtx orig)\n {\n   rtx copy;\n   int i, j;\n@@ -386,8 +383,7 @@ copy_rtx (orig)\n /* Create a new copy of an rtx.  Only copy just one level.  */\n \n rtx\n-shallow_copy_rtx (orig)\n-     rtx orig;\n+shallow_copy_rtx (rtx orig)\n {\n   RTX_CODE code = GET_CODE (orig);\n   size_t n = GET_RTX_LENGTH (code);\n@@ -409,8 +405,7 @@ int generating_concat_p;\n    This is the Lisp function EQUAL for rtx arguments.  */\n \n int\n-rtx_equal_p (x, y)\n-     rtx x, y;\n+rtx_equal_p (rtx x, rtx y)\n {\n   int i;\n   int j;\n@@ -526,12 +521,8 @@ rtx_equal_p (x, y)\n \f\n #if defined ENABLE_RTL_CHECKING && (GCC_VERSION >= 2007)\n void\n-rtl_check_failed_bounds (r, n, file, line, func)\n-    rtx r;\n-    int n;\n-    const char *file;\n-    int line;\n-    const char *func;\n+rtl_check_failed_bounds (rtx r, int n, const char *file, int line,\n+\t\t\t const char *func)\n {\n   internal_error\n     (\"RTL check: access of elt %d of `%s' with last elt %d in %s, at %s:%d\",\n@@ -540,13 +531,8 @@ rtl_check_failed_bounds (r, n, file, line, func)\n }\n \n void\n-rtl_check_failed_type1 (r, n, c1, file, line, func)\n-    rtx r;\n-    int n;\n-    int c1;\n-    const char *file;\n-    int line;\n-    const char *func;\n+rtl_check_failed_type1 (rtx r, int n, int c1, const char *file, int line,\n+\t\t\tconst char *func)\n {\n   internal_error\n     (\"RTL check: expected elt %d type '%c', have '%c' (rtx %s) in %s, at %s:%d\",\n@@ -555,14 +541,8 @@ rtl_check_failed_type1 (r, n, c1, file, line, func)\n }\n \n void\n-rtl_check_failed_type2 (r, n, c1, c2, file, line, func)\n-    rtx r;\n-    int n;\n-    int c1;\n-    int c2;\n-    const char *file;\n-    int line;\n-    const char *func;\n+rtl_check_failed_type2 (rtx r, int n, int c1, int c2, const char *file,\n+\t\t\tint line, const char *func)\n {\n   internal_error\n     (\"RTL check: expected elt %d type '%c' or '%c', have '%c' (rtx %s) in %s, at %s:%d\",\n@@ -571,25 +551,17 @@ rtl_check_failed_type2 (r, n, c1, c2, file, line, func)\n }\n \n void\n-rtl_check_failed_code1 (r, code, file, line, func)\n-    rtx r;\n-    enum rtx_code code;\n-    const char *file;\n-    int line;\n-    const char *func;\n+rtl_check_failed_code1 (rtx r, enum rtx_code code, const char *file,\n+\t\t\tint line, const char *func)\n {\n   internal_error (\"RTL check: expected code `%s', have `%s' in %s, at %s:%d\",\n \t\t  GET_RTX_NAME (code), GET_RTX_NAME (GET_CODE (r)), func,\n \t\t  trim_filename (file), line);\n }\n \n void\n-rtl_check_failed_code2 (r, code1, code2, file, line, func)\n-    rtx r;\n-    enum rtx_code code1, code2;\n-    const char *file;\n-    int line;\n-    const char *func;\n+rtl_check_failed_code2 (rtx r, enum rtx_code code1, enum rtx_code code2,\n+\t\t\tconst char *file, int line, const char *func)\n {\n   internal_error\n     (\"RTL check: expected code `%s' or `%s', have `%s' in %s, at %s:%d\",\n@@ -599,12 +571,8 @@ rtl_check_failed_code2 (r, code1, code2, file, line, func)\n \n /* XXX Maybe print the vector?  */\n void\n-rtvec_check_failed_bounds (r, n, file, line, func)\n-    rtvec r;\n-    int n;\n-    const char *file;\n-    int line;\n-    const char *func;\n+rtvec_check_failed_bounds (rtvec r, int n, const char *file, int line,\n+\t\t\t   const char *func)\n {\n   internal_error\n     (\"RTL check: access of elt %d of vector with last elt %d in %s, at %s:%d\",\n@@ -614,12 +582,8 @@ rtvec_check_failed_bounds (r, n, file, line, func)\n \n #if defined ENABLE_RTL_FLAG_CHECKING\n void\n-rtl_check_failed_flag (name, r, file, line, func)\n-    const char *name;\n-    rtx r;\n-    const char *file;\n-    int line;\n-    const char *func;\n+rtl_check_failed_flag (const char *name, rtx r, const char *file,\n+\t\t       int line, const char *func)\n {\n   internal_error\n     (\"RTL flag check: %s used with unexpected rtx code `%s' in %s, at %s:%d\","}, {"sha": "10b4d5be4cc5995abf738073c90a15ced5a5ac6a", "filename": "gcc/rtl.h", "status": "modified", "additions": 439, "deletions": 486, "changes": 925, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -339,23 +339,23 @@ struct rtvec_def GTY(()) {\n \t\t\t\t  __FUNCTION__);\t\t\t\\\n      &_rtvec->elem[_i]; }))\n \n-extern void rtl_check_failed_bounds PARAMS ((rtx, int,\n-\t\t\t\t\t   const char *, int, const char *))\n+extern void rtl_check_failed_bounds (rtx, int, const char *, int,\n+\t\t\t\t     const char *)\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_type1 PARAMS ((rtx, int, int,\n-\t\t\t\t\t  const char *, int, const char *))\n+extern void rtl_check_failed_type1 (rtx, int, int, const char *, int,\n+\t\t\t\t    const char *)\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_type2 PARAMS ((rtx, int, int, int,\n-\t\t\t\t\t  const char *, int, const char *))\n+extern void rtl_check_failed_type2 (rtx, int, int, int, const char *,\n+\t\t\t\t    int, const char *)\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_code1 PARAMS ((rtx, enum rtx_code,\n-\t\t\t\t\t  const char *, int, const char *))\n+extern void rtl_check_failed_code1 (rtx, enum rtx_code, const char *,\n+\t\t\t\t    int, const char *)\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_code2 PARAMS ((rtx, enum rtx_code, enum rtx_code,\n-\t\t\t\t\t  const char *, int, const char *))\n+extern void rtl_check_failed_code2 (rtx, enum rtx_code, enum rtx_code,\n+\t\t\t\t    const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n-extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n-\t\t\t\t\t     const char *, int, const char *))\n+extern void rtvec_check_failed_bounds (rtvec, int, const char *, int,\n+\t\t\t\t       const char *)\n     ATTRIBUTE_NORETURN;\n \n #else   /* not ENABLE_RTL_CHECKING */\n@@ -445,8 +445,8 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n-extern void rtl_check_failed_flag PARAMS ((const char *, rtx, const char *,\n-\t\t\t\t\t   int, const char *))\n+extern void rtl_check_failed_flag (const char *, rtx, const char *,\n+\t\t\t\t   int, const char *)\n     ATTRIBUTE_NORETURN\n     ;\n \n@@ -1031,16 +1031,12 @@ enum label_kind\n #define SUBREG_BYTE(RTX) XCUINT (RTX, 1, SUBREG)\n \n /* in rtlanal.c */\n-extern unsigned int subreg_lsb\t\tPARAMS ((rtx));\n-extern unsigned int subreg_regno_offset\tPARAMS ((unsigned int,\n-\t\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t\t unsigned int,\n-\t\t\t\t\t\t\t enum machine_mode));\n-extern bool subreg_offset_representable_p\tPARAMS ((unsigned int,\n-\t\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t\t unsigned int,\n-\t\t\t\t\t\t\t enum machine_mode));\n-extern unsigned int subreg_regno\tPARAMS ((rtx));\n+extern unsigned int subreg_lsb (rtx);\n+extern unsigned int subreg_regno_offset\t(unsigned int, enum machine_mode,\n+\t\t\t\t\t unsigned int, enum machine_mode);\n+extern bool subreg_offset_representable_p (unsigned int, enum machine_mode,\n+\t\t\t\t\t   unsigned int, enum machine_mode);\n+extern unsigned int subreg_regno (rtx);\n \n /* 1 if RTX is a subreg containing a reg that is already known to be\n    sign- or zero-extended from the mode of the subreg to the mode of\n@@ -1398,7 +1394,7 @@ extern int generating_concat_p;\n /* Generally useful functions.  */\n \n /* In expmed.c */\n-extern int ceil_log2\t\t\tPARAMS ((unsigned HOST_WIDE_INT));\n+extern int ceil_log2 (unsigned HOST_WIDE_INT);\n \n #define plus_constant(X, C) plus_constant_wide ((X), (HOST_WIDE_INT) (C))\n \n@@ -1407,237 +1403,211 @@ extern rtx expand_builtin_expect_jump (tree, rtx, rtx);\n extern void purge_builtin_constant_p (void);\n \n /* In explow.c */\n-extern void set_stack_check_libfunc PARAMS ((rtx));\n-extern HOST_WIDE_INT trunc_int_for_mode\tPARAMS ((HOST_WIDE_INT,\n-\t\t\t\t\t       enum machine_mode));\n-extern rtx plus_constant_wide\t\t PARAMS ((rtx, HOST_WIDE_INT));\n-extern rtx plus_constant_for_output_wide PARAMS ((rtx, HOST_WIDE_INT));\n-extern void optimize_save_area_alloca\tPARAMS ((rtx));\n+extern void set_stack_check_libfunc (rtx);\n+extern HOST_WIDE_INT trunc_int_for_mode\t(HOST_WIDE_INT, enum machine_mode);\n+extern rtx plus_constant_wide (rtx, HOST_WIDE_INT);\n+extern rtx plus_constant_for_output_wide (rtx, HOST_WIDE_INT);\n+extern void optimize_save_area_alloca (rtx);\n \n /* In emit-rtl.c */\n-extern rtx gen_rtx\t\t\tPARAMS ((enum rtx_code,\n-\t\t\t\t\t\t enum machine_mode, ...));\n-extern rtvec gen_rtvec\t\t\tPARAMS ((int, ...));\n-extern rtx copy_insn_1\t\t\tPARAMS ((rtx));\n-extern rtx copy_insn\t\t\tPARAMS ((rtx));\n-extern rtx gen_int_mode\t\t\tPARAMS ((HOST_WIDE_INT,\n-\t\t\t\t\t\t enum machine_mode));\n-extern rtx emit_copy_of_insn_after\tPARAMS ((rtx, rtx));\n-extern void set_reg_attrs_from_mem\tPARAMS ((rtx, rtx));\n-extern void set_mem_attrs_from_reg\tPARAMS ((rtx, rtx));\n-extern void set_reg_attrs_for_parm\tPARAMS ((rtx, rtx));\n+extern rtx gen_rtx (enum rtx_code, enum machine_mode, ...);\n+extern rtvec gen_rtvec (int, ...);\n+extern rtx copy_insn_1 (rtx);\n+extern rtx copy_insn (rtx);\n+extern rtx gen_int_mode (HOST_WIDE_INT, enum machine_mode);\n+extern rtx emit_copy_of_insn_after (rtx, rtx);\n+extern void set_reg_attrs_from_mem (rtx, rtx);\n+extern void set_mem_attrs_from_reg (rtx, rtx);\n+extern void set_reg_attrs_for_parm (rtx, rtx);\n \n /* In rtl.c */\n-extern rtx rtx_alloc\t\t\tPARAMS ((RTX_CODE));\n-extern rtvec rtvec_alloc\t\tPARAMS ((int));\n-extern rtx copy_rtx\t\t\tPARAMS ((rtx));\n+extern rtx rtx_alloc (RTX_CODE);\n+extern rtvec rtvec_alloc (int);\n+extern rtx copy_rtx (rtx);\n \n /* In emit-rtl.c */\n-extern rtx copy_rtx_if_shared\t\tPARAMS ((rtx));\n+extern rtx copy_rtx_if_shared (rtx);\n \n /* In rtl.c */\n-extern rtx copy_most_rtx\t\tPARAMS ((rtx, rtx));\n-extern rtx shallow_copy_rtx\t\tPARAMS ((rtx));\n-extern int rtx_equal_p                  PARAMS ((rtx, rtx));\n+extern rtx copy_most_rtx (rtx, rtx);\n+extern rtx shallow_copy_rtx (rtx);\n+extern int rtx_equal_p (rtx, rtx);\n \n /* In emit-rtl.c */\n-extern rtvec gen_rtvec_v\t\tPARAMS ((int, rtx *));\n-extern rtx gen_reg_rtx\t\t\tPARAMS ((enum machine_mode));\n-extern rtx gen_rtx_REG_offset\t\tPARAMS ((rtx, enum machine_mode,\n-\t\t\t\t\t\t unsigned int, int));\n-extern rtx gen_label_rtx\t\tPARAMS ((void));\n-extern int subreg_hard_regno\t\tPARAMS ((rtx, int));\n-extern rtx gen_lowpart_common\t\tPARAMS ((enum machine_mode, rtx));\n-extern rtx gen_lowpart\t\t\tPARAMS ((enum machine_mode, rtx));\n+extern rtvec gen_rtvec_v (int, rtx *);\n+extern rtx gen_reg_rtx (enum machine_mode);\n+extern rtx gen_rtx_REG_offset (rtx, enum machine_mode, unsigned int, int);\n+extern rtx gen_label_rtx (void);\n+extern int subreg_hard_regno (rtx, int);\n+extern rtx gen_lowpart_common (enum machine_mode, rtx);\n+extern rtx gen_lowpart (enum machine_mode, rtx);\n \n /* In cse.c */\n-extern rtx gen_lowpart_if_possible\tPARAMS ((enum machine_mode, rtx));\n+extern rtx gen_lowpart_if_possible (enum machine_mode, rtx);\n \n /* In emit-rtl.c */\n-extern rtx gen_highpart\t\t\tPARAMS ((enum machine_mode, rtx));\n-extern rtx gen_highpart_mode\t\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t enum machine_mode, rtx));\n-extern rtx gen_realpart\t\t\tPARAMS ((enum machine_mode, rtx));\n-extern rtx gen_imagpart\t\t\tPARAMS ((enum machine_mode, rtx));\n-extern rtx operand_subword\t\tPARAMS ((rtx, unsigned int, int,\n-\t\t\t\t\t\t enum machine_mode));\n-extern rtx constant_subword\t\tPARAMS ((rtx, int,\n-\t\t\t\t\t\t enum machine_mode));\n+extern rtx gen_highpart (enum machine_mode, rtx);\n+extern rtx gen_highpart_mode (enum machine_mode, enum machine_mode, rtx);\n+extern rtx gen_realpart (enum machine_mode, rtx);\n+extern rtx gen_imagpart (enum machine_mode, rtx);\n+extern rtx operand_subword (rtx, unsigned int, int, enum machine_mode);\n+extern rtx constant_subword (rtx, int, enum machine_mode);\n \n /* In emit-rtl.c */\n-extern rtx operand_subword_force\tPARAMS ((rtx, unsigned int,\n-\t\t\t\t\t\t enum machine_mode));\n-extern int subreg_lowpart_p\t\tPARAMS ((rtx));\n-extern unsigned int subreg_lowpart_offset PARAMS ((enum machine_mode,\n-\t\t\t\t\t\t   enum machine_mode));\n-extern unsigned int subreg_highpart_offset PARAMS ((enum machine_mode,\n-\t\t\t\t\t\t    enum machine_mode));\n-extern rtx make_safe_from\t\tPARAMS ((rtx, rtx));\n-extern rtx convert_memory_address\tPARAMS ((enum machine_mode, rtx));\n-extern rtx get_insns\t\t\tPARAMS ((void));\n-extern const char *get_insn_name\tPARAMS ((int));\n-extern rtx get_last_insn\t\tPARAMS ((void));\n-extern rtx get_last_insn_anywhere\tPARAMS ((void));\n-extern rtx get_first_nonnote_insn\tPARAMS ((void));\n-extern rtx get_last_nonnote_insn\tPARAMS ((void));\n-extern void start_sequence\t\tPARAMS ((void));\n-extern void push_to_sequence\t\tPARAMS ((rtx));\n-extern void end_sequence\t\tPARAMS ((void));\n-extern void push_to_full_sequence\tPARAMS ((rtx, rtx));\n-extern void end_full_sequence\t\tPARAMS ((rtx*, rtx*));\n+extern rtx operand_subword_force (rtx, unsigned int, enum machine_mode);\n+extern int subreg_lowpart_p (rtx);\n+extern unsigned int subreg_lowpart_offset (enum machine_mode,\n+\t\t\t\t\t   enum machine_mode);\n+extern unsigned int subreg_highpart_offset (enum machine_mode,\n+\t\t\t\t\t    enum machine_mode);\n+extern rtx make_safe_from (rtx, rtx);\n+extern rtx convert_memory_address (enum machine_mode, rtx);\n+extern rtx get_insns (void);\n+extern const char *get_insn_name (int);\n+extern rtx get_last_insn (void);\n+extern rtx get_last_insn_anywhere (void);\n+extern rtx get_first_nonnote_insn (void);\n+extern rtx get_last_nonnote_insn (void);\n+extern void start_sequence (void);\n+extern void push_to_sequence (rtx);\n+extern void end_sequence (void);\n+extern void push_to_full_sequence (rtx, rtx);\n+extern void end_full_sequence (rtx*, rtx*);\n \n /* In varasm.c  */\n-extern rtx immed_double_const\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode));\n-extern rtx mem_for_const_double\t\tPARAMS ((rtx));\n-extern rtx force_const_mem\t\tPARAMS ((enum machine_mode, rtx));\n+extern rtx immed_double_const (HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t       enum machine_mode);\n+extern rtx mem_for_const_double (rtx);\n+extern rtx force_const_mem (enum machine_mode, rtx);\n \n /* In varasm.c  */\n-extern rtx get_pool_constant\t\tPARAMS ((rtx));\n-extern rtx get_pool_constant_mark\tPARAMS ((rtx, bool *));\n-extern enum machine_mode get_pool_mode\tPARAMS ((rtx));\n-extern rtx get_pool_constant_for_function\tPARAMS ((struct function *, rtx));\n-extern enum machine_mode get_pool_mode_for_function\tPARAMS ((struct function *, rtx));\n-extern int get_pool_offset\t\tPARAMS ((rtx));\n-extern rtx simplify_subtraction\t\tPARAMS ((rtx));\n+extern rtx get_pool_constant (rtx);\n+extern rtx get_pool_constant_mark (rtx, bool *);\n+extern enum machine_mode get_pool_mode (rtx);\n+extern rtx get_pool_constant_for_function (struct function *, rtx);\n+extern enum machine_mode get_pool_mode_for_function (struct function *, rtx);\n+extern int get_pool_offset (rtx);\n+extern rtx simplify_subtraction (rtx);\n \n /* In function.c  */\n-extern rtx assign_stack_local\t\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t       HOST_WIDE_INT, int));\n-extern rtx assign_stack_temp\t\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t       HOST_WIDE_INT, int));\n-extern rtx assign_stack_temp_for_type\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t HOST_WIDE_INT, int, tree));\n-extern rtx assign_temp\t\t\tPARAMS ((tree, int, int, int));\n+extern rtx assign_stack_local (enum machine_mode, HOST_WIDE_INT, int);\n+extern rtx assign_stack_temp (enum machine_mode, HOST_WIDE_INT, int);\n+extern rtx assign_stack_temp_for_type (enum machine_mode,\n+\t\t\t\t       HOST_WIDE_INT, int, tree);\n+extern rtx assign_temp (tree, int, int, int);\n \n /* In emit-rtl.c */\n-extern rtx emit_insn_before\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_insn_before_setloc\tPARAMS ((rtx, rtx, int));\n-extern rtx emit_jump_insn_before\tPARAMS ((rtx, rtx));\n-extern rtx emit_jump_insn_before_setloc\tPARAMS ((rtx, rtx, int));\n-extern rtx emit_call_insn_before\tPARAMS ((rtx, rtx));\n-extern rtx emit_call_insn_before_setloc\tPARAMS ((rtx, rtx, int));\n-extern rtx emit_barrier_before\t\tPARAMS ((rtx));\n-extern rtx emit_label_before\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_note_before\t\tPARAMS ((int, rtx));\n-extern rtx emit_insn_after\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_insn_after_setloc\tPARAMS ((rtx, rtx, int));\n-extern rtx emit_jump_insn_after\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_jump_insn_after_setloc\tPARAMS ((rtx, rtx, int));\n-extern rtx emit_call_insn_after\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_call_insn_after_setloc\tPARAMS ((rtx, rtx, int));\n-extern rtx emit_barrier_after\t\tPARAMS ((rtx));\n-extern rtx emit_label_after\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_note_after\t\tPARAMS ((int, rtx));\n-extern rtx emit_note_copy_after\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_insn\t\t\tPARAMS ((rtx));\n-extern rtx emit_jump_insn\t\tPARAMS ((rtx));\n-extern rtx emit_call_insn\t\tPARAMS ((rtx));\n-extern rtx emit_label\t\t\tPARAMS ((rtx));\n-extern rtx emit_barrier\t\t\tPARAMS ((void));\n-extern rtx emit_note\t\t\tPARAMS ((int));\n-extern rtx emit_note_copy\t\tPARAMS ((rtx));\n-extern rtx emit_line_note\t\tPARAMS ((const char *, int));\n-extern rtx emit_line_note_force\t\tPARAMS ((const char *, int));\n-extern rtx make_insn_raw\t\tPARAMS ((rtx));\n-extern void add_function_usage_to       PARAMS ((rtx, rtx));\n-extern rtx last_call_insn               PARAMS ((void));\n-extern rtx previous_insn\t\tPARAMS ((rtx));\n-extern rtx next_insn\t\t\tPARAMS ((rtx));\n-extern rtx prev_nonnote_insn\t\tPARAMS ((rtx));\n-extern rtx next_nonnote_insn\t\tPARAMS ((rtx));\n-extern rtx prev_real_insn\t\tPARAMS ((rtx));\n-extern rtx next_real_insn\t\tPARAMS ((rtx));\n-extern rtx prev_active_insn\t\tPARAMS ((rtx));\n-extern rtx next_active_insn\t\tPARAMS ((rtx));\n-extern int active_insn_p\t\tPARAMS ((rtx));\n-extern rtx prev_label\t\t\tPARAMS ((rtx));\n-extern rtx next_label\t\t\tPARAMS ((rtx));\n-extern rtx next_cc0_user\t\tPARAMS ((rtx));\n-extern rtx prev_cc0_setter\t\tPARAMS ((rtx));\n+extern rtx emit_insn_before (rtx, rtx);\n+extern rtx emit_insn_before_setloc (rtx, rtx, int);\n+extern rtx emit_jump_insn_before (rtx, rtx);\n+extern rtx emit_jump_insn_before_setloc (rtx, rtx, int);\n+extern rtx emit_call_insn_before (rtx, rtx);\n+extern rtx emit_call_insn_before_setloc (rtx, rtx, int);\n+extern rtx emit_barrier_before (rtx);\n+extern rtx emit_label_before (rtx, rtx);\n+extern rtx emit_note_before (int, rtx);\n+extern rtx emit_insn_after (rtx, rtx);\n+extern rtx emit_insn_after_setloc (rtx, rtx, int);\n+extern rtx emit_jump_insn_after (rtx, rtx);\n+extern rtx emit_jump_insn_after_setloc (rtx, rtx, int);\n+extern rtx emit_call_insn_after (rtx, rtx);\n+extern rtx emit_call_insn_after_setloc (rtx, rtx, int);\n+extern rtx emit_barrier_after (rtx);\n+extern rtx emit_label_after (rtx, rtx);\n+extern rtx emit_note_after (int, rtx);\n+extern rtx emit_note_copy_after (rtx, rtx);\n+extern rtx emit_insn (rtx);\n+extern rtx emit_jump_insn (rtx);\n+extern rtx emit_call_insn (rtx);\n+extern rtx emit_label (rtx);\n+extern rtx emit_barrier (void);\n+extern rtx emit_note (int);\n+extern rtx emit_note_copy (rtx);\n+extern rtx emit_line_note (const char *, int);\n+extern rtx emit_line_note_force (const char *, int);\n+extern rtx make_insn_raw (rtx);\n+extern void add_function_usage_to (rtx, rtx);\n+extern rtx last_call_insn (void);\n+extern rtx previous_insn (rtx);\n+extern rtx next_insn (rtx);\n+extern rtx prev_nonnote_insn (rtx);\n+extern rtx next_nonnote_insn (rtx);\n+extern rtx prev_real_insn (rtx);\n+extern rtx next_real_insn (rtx);\n+extern rtx prev_active_insn (rtx);\n+extern rtx next_active_insn (rtx);\n+extern int active_insn_p (rtx);\n+extern rtx prev_label (rtx);\n+extern rtx next_label (rtx);\n+extern rtx next_cc0_user (rtx);\n+extern rtx prev_cc0_setter (rtx);\n \n /* In cfglayout.c  */\n-extern tree choose_inner_scope\t\tPARAMS ((tree, tree));\n-extern int insn_line\t\t\tPARAMS ((rtx));\n-extern const char * insn_file\t\tPARAMS ((rtx));\n+extern tree choose_inner_scope (tree, tree);\n+extern int insn_line (rtx);\n+extern const char * insn_file (rtx);\n extern int prologue_locator, epilogue_locator;\n \n /* In jump.c */\n-extern enum rtx_code reverse_condition\tPARAMS ((enum rtx_code));\n-extern enum rtx_code reverse_condition_maybe_unordered PARAMS ((enum rtx_code));\n-extern enum rtx_code swap_condition\tPARAMS ((enum rtx_code));\n-extern enum rtx_code unsigned_condition\tPARAMS ((enum rtx_code));\n-extern enum rtx_code signed_condition\tPARAMS ((enum rtx_code));\n-extern void mark_jump_label\t\tPARAMS ((rtx, rtx, int));\n-extern void cleanup_barriers\t\tPARAMS ((void));\n+extern enum rtx_code reverse_condition (enum rtx_code);\n+extern enum rtx_code reverse_condition_maybe_unordered (enum rtx_code);\n+extern enum rtx_code swap_condition (enum rtx_code);\n+extern enum rtx_code unsigned_condition (enum rtx_code);\n+extern enum rtx_code signed_condition (enum rtx_code);\n+extern void mark_jump_label (rtx, rtx, int);\n+extern void cleanup_barriers (void);\n \n /* In jump.c */\n-extern bool squeeze_notes\t\tPARAMS ((rtx *, rtx *));\n-extern rtx delete_related_insns\t\t\tPARAMS ((rtx));\n-extern void delete_jump\t\t\tPARAMS ((rtx));\n-extern void delete_barrier\t\tPARAMS ((rtx));\n-extern rtx get_label_before\t\tPARAMS ((rtx));\n-extern rtx get_label_after\t\tPARAMS ((rtx));\n-extern rtx follow_jumps\t\t\tPARAMS ((rtx));\n+extern bool squeeze_notes (rtx *, rtx *);\n+extern rtx delete_related_insns (rtx);\n+extern void delete_jump (rtx);\n+extern void delete_barrier (rtx);\n+extern rtx get_label_before (rtx);\n+extern rtx get_label_after (rtx);\n+extern rtx follow_jumps (rtx);\n \n /* In recog.c  */\n-extern rtx *find_constant_term_loc\tPARAMS ((rtx *));\n+extern rtx *find_constant_term_loc (rtx *);\n \n /* In emit-rtl.c  */\n-extern rtx try_split\t\t\tPARAMS ((rtx, rtx, int));\n+extern rtx try_split (rtx, rtx, int);\n extern int split_branch_probability;\n \n /* In unknown file  */\n-extern rtx split_insns\t\t\tPARAMS ((rtx, rtx));\n+extern rtx split_insns (rtx, rtx);\n \n /* In simplify-rtx.c  */\n-extern rtx simplify_unary_operation\tPARAMS ((enum rtx_code,\n-\t\t\t\t\t\t enum machine_mode, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-extern rtx simplify_binary_operation\tPARAMS ((enum rtx_code,\n-\t\t\t\t\t\t enum machine_mode, rtx,\n-\t\t\t\t\t\t rtx));\n-extern rtx simplify_ternary_operation\tPARAMS ((enum rtx_code,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t enum machine_mode, rtx, rtx,\n-\t\t\t\t\t\t rtx));\n-extern rtx simplify_relational_operation PARAMS ((enum rtx_code,\n-\t\t\t\t\t\t  enum machine_mode, rtx,\n-\t\t\t\t\t\t  rtx));\n-extern rtx simplify_gen_binary\t\tPARAMS ((enum rtx_code,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t rtx, rtx));\n-extern rtx simplify_gen_unary\t\tPARAMS ((enum rtx_code,\n-\t\t\t\t\t\t enum machine_mode, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-extern rtx simplify_gen_ternary\t\tPARAMS ((enum rtx_code,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t rtx, rtx, rtx));\n-extern rtx simplify_gen_relational\tPARAMS ((enum rtx_code,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t rtx, rtx));\n-extern rtx simplify_subreg\t\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t rtx,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t unsigned int));\n-extern rtx simplify_gen_subreg\t\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t rtx,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t unsigned int));\n-extern rtx simplify_replace_rtx\t\tPARAMS ((rtx, rtx, rtx));\n-extern rtx simplify_rtx\t\t\tPARAMS ((rtx));\n-extern rtx avoid_constant_pool_reference PARAMS ((rtx));\n+extern rtx simplify_unary_operation (enum rtx_code, enum machine_mode, rtx,\n+\t\t\t\t     enum machine_mode);\n+extern rtx simplify_binary_operation (enum rtx_code, enum machine_mode, rtx,\n+\t\t\t\t      rtx);\n+extern rtx simplify_ternary_operation (enum rtx_code, enum machine_mode,\n+\t\t\t\t       enum machine_mode, rtx, rtx, rtx);\n+extern rtx simplify_relational_operation (enum rtx_code, enum machine_mode,\n+\t\t\t\t\t  rtx, rtx);\n+extern rtx simplify_gen_binary (enum rtx_code, enum machine_mode, rtx, rtx);\n+extern rtx simplify_gen_unary (enum rtx_code, enum machine_mode, rtx,\n+\t\t\t       enum machine_mode);\n+extern rtx simplify_gen_ternary (enum rtx_code, enum machine_mode,\n+\t\t\t\t enum machine_mode, rtx, rtx, rtx);\n+extern rtx simplify_gen_relational (enum rtx_code, enum machine_mode,\n+\t\t\t\t    enum machine_mode, rtx, rtx);\n+extern rtx simplify_subreg (enum machine_mode, rtx, enum machine_mode,\n+\t\t\t    unsigned int);\n+extern rtx simplify_gen_subreg (enum machine_mode, rtx, enum machine_mode,\n+\t\t\t\tunsigned int);\n+extern rtx simplify_replace_rtx (rtx, rtx, rtx);\n+extern rtx simplify_rtx (rtx);\n+extern rtx avoid_constant_pool_reference (rtx);\n \n /* In function.c  */\n-extern rtx gen_mem_addressof\t\tPARAMS ((rtx, tree, int));\n+extern rtx gen_mem_addressof (rtx, tree, int);\n \n /* In regclass.c  */\n-extern enum machine_mode choose_hard_reg_mode PARAMS ((unsigned int,\n-\t\t\t\t\t\t       unsigned int));\n+extern enum machine_mode choose_hard_reg_mode (unsigned int, unsigned int);\n \n /* In emit-rtl.c  */\n-extern rtx set_unique_reg_note\t\tPARAMS ((rtx, enum reg_note, rtx));\n+extern rtx set_unique_reg_note (rtx, enum reg_note, rtx);\n \n /* Functions in rtlanal.c */\n \n@@ -1656,83 +1626,75 @@ typedef struct replace_label_data\n   bool update_label_nuses;\n } replace_label_data;\n \n-extern int rtx_addr_can_trap_p\t\tPARAMS ((rtx));\n-extern bool nonzero_address_p\t\tPARAMS ((rtx));\n-extern int rtx_unstable_p\t\tPARAMS ((rtx));\n-extern int rtx_varies_p\t\t\tPARAMS ((rtx, int));\n-extern int rtx_addr_varies_p\t\tPARAMS ((rtx, int));\n-extern HOST_WIDE_INT get_integer_term\tPARAMS ((rtx));\n-extern rtx get_related_value\t\tPARAMS ((rtx));\n-extern rtx get_jump_table_offset\tPARAMS ((rtx, rtx *));\n-extern int global_reg_mentioned_p\tPARAMS ((rtx));\n-extern int reg_mentioned_p\t\tPARAMS ((rtx, rtx));\n-extern int count_occurrences\t\tPARAMS ((rtx, rtx, int));\n-extern int reg_referenced_p\t\tPARAMS ((rtx, rtx));\n-extern int reg_used_between_p\t\tPARAMS ((rtx, rtx, rtx));\n-extern int reg_referenced_between_p\tPARAMS ((rtx, rtx, rtx));\n-extern int reg_set_between_p\t\tPARAMS ((rtx, rtx, rtx));\n-extern int regs_set_between_p\t\tPARAMS ((rtx, rtx, rtx));\n-extern int commutative_operand_precedence PARAMS ((rtx));\n-extern int swap_commutative_operands_p\tPARAMS ((rtx, rtx));\n-extern int modified_between_p\t\tPARAMS ((rtx, rtx, rtx));\n-extern int no_labels_between_p\t\tPARAMS ((rtx, rtx));\n-extern int no_jumps_between_p\t\tPARAMS ((rtx, rtx));\n-extern int modified_in_p\t\tPARAMS ((rtx, rtx));\n-extern int insn_dependent_p\t\tPARAMS ((rtx, rtx));\n-extern int reg_set_p\t\t\tPARAMS ((rtx, rtx));\n-extern rtx single_set_2\t\t\tPARAMS ((rtx, rtx));\n-extern int multiple_sets\t\tPARAMS ((rtx));\n-extern int set_noop_p\t\t\tPARAMS ((rtx));\n-extern int noop_move_p\t\t\tPARAMS ((rtx));\n-extern rtx find_last_value\t\tPARAMS ((rtx, rtx *, rtx, int));\n-extern int refers_to_regno_p\t\tPARAMS ((unsigned int, unsigned int,\n-\t\t\t\t\t\t rtx, rtx *));\n-extern int reg_overlap_mentioned_p\tPARAMS ((rtx, rtx));\n-extern rtx set_of\t\t\tPARAMS ((rtx, rtx));\n-extern void note_stores\t\t\tPARAMS ((rtx,\n-\t\t\t\t\t\t void (*) (rtx, rtx, void *),\n-\t\t\t\t\t\t void *));\n-extern void note_uses\t\t\tPARAMS ((rtx *,\n-\t\t\t\t\t\t void (*) (rtx *, void *),\n-\t\t\t\t\t\t void *));\n-extern rtx reg_set_last\t\t\tPARAMS ((rtx, rtx));\n-extern int dead_or_set_p\t\tPARAMS ((rtx, rtx));\n-extern int dead_or_set_regno_p\t\tPARAMS ((rtx, unsigned int));\n-extern rtx find_reg_note\t\tPARAMS ((rtx, enum reg_note, rtx));\n-extern rtx find_regno_note\t\tPARAMS ((rtx, enum reg_note,\n-\t\t\t\t\t\t unsigned int));\n-extern rtx find_reg_equal_equiv_note\tPARAMS ((rtx));\n-extern int find_reg_fusage\t\tPARAMS ((rtx, enum rtx_code, rtx));\n-extern int find_regno_fusage\t\tPARAMS ((rtx, enum rtx_code,\n-\t\t\t\t\t\t unsigned int));\n-extern int pure_call_p\t\t\tPARAMS ((rtx));\n-extern void remove_note\t\t\tPARAMS ((rtx, rtx));\n-extern int side_effects_p\t\tPARAMS ((rtx));\n-extern int volatile_refs_p\t\tPARAMS ((rtx));\n-extern int volatile_insn_p\t\tPARAMS ((rtx));\n-extern int may_trap_p\t\t\tPARAMS ((rtx));\n-extern int inequality_comparisons_p\tPARAMS ((rtx));\n-extern rtx replace_rtx\t\t\tPARAMS ((rtx, rtx, rtx));\n-extern rtx replace_regs\t\t\tPARAMS ((rtx, rtx *, unsigned int,\n-\t\t\t\t\t\t int));\n-extern int replace_label\t\tPARAMS ((rtx *, void *));\n-extern int rtx_referenced_p\t\tPARAMS ((rtx, rtx));\n-extern bool tablejump_p\t\t\tPARAMS ((rtx, rtx *, rtx *));\n-extern int computed_jump_p\t\tPARAMS ((rtx));\n-typedef int (*rtx_function)             PARAMS ((rtx *, void *));\n-extern int for_each_rtx                 PARAMS ((rtx *, rtx_function, void *));\n-extern rtx regno_use_in\t\t\tPARAMS ((unsigned int, rtx));\n-extern int auto_inc_p\t\t\tPARAMS ((rtx));\n-extern int in_expr_list_p\t\tPARAMS ((rtx, rtx));\n-extern void remove_node_from_expr_list\tPARAMS ((rtx, rtx *));\n-extern int insns_safe_to_move_p         PARAMS ((rtx, rtx, rtx *));\n-extern int loc_mentioned_in_p\t\tPARAMS ((rtx *, rtx));\n-extern rtx find_first_parameter_load\tPARAMS ((rtx, rtx));\n-extern bool keep_with_call_p\t\tPARAMS ((rtx));\n+extern int rtx_addr_can_trap_p (rtx);\n+extern bool nonzero_address_p (rtx);\n+extern int rtx_unstable_p (rtx);\n+extern int rtx_varies_p (rtx, int);\n+extern int rtx_addr_varies_p (rtx, int);\n+extern HOST_WIDE_INT get_integer_term (rtx);\n+extern rtx get_related_value (rtx);\n+extern rtx get_jump_table_offset (rtx, rtx *);\n+extern int global_reg_mentioned_p (rtx);\n+extern int reg_mentioned_p (rtx, rtx);\n+extern int count_occurrences (rtx, rtx, int);\n+extern int reg_referenced_p (rtx, rtx);\n+extern int reg_used_between_p (rtx, rtx, rtx);\n+extern int reg_referenced_between_p (rtx, rtx, rtx);\n+extern int reg_set_between_p (rtx, rtx, rtx);\n+extern int regs_set_between_p (rtx, rtx, rtx);\n+extern int commutative_operand_precedence (rtx);\n+extern int swap_commutative_operands_p (rtx, rtx);\n+extern int modified_between_p (rtx, rtx, rtx);\n+extern int no_labels_between_p (rtx, rtx);\n+extern int no_jumps_between_p (rtx, rtx);\n+extern int modified_in_p (rtx, rtx);\n+extern int insn_dependent_p (rtx, rtx);\n+extern int reg_set_p (rtx, rtx);\n+extern rtx single_set_2 (rtx, rtx);\n+extern int multiple_sets (rtx);\n+extern int set_noop_p (rtx);\n+extern int noop_move_p (rtx);\n+extern rtx find_last_value (rtx, rtx *, rtx, int);\n+extern int refers_to_regno_p (unsigned int, unsigned int, rtx, rtx *);\n+extern int reg_overlap_mentioned_p (rtx, rtx);\n+extern rtx set_of (rtx, rtx);\n+extern void note_stores (rtx, void (*) (rtx, rtx, void *), void *);\n+extern void note_uses (rtx *, void (*) (rtx *, void *), void *);\n+extern rtx reg_set_last (rtx, rtx);\n+extern int dead_or_set_p (rtx, rtx);\n+extern int dead_or_set_regno_p (rtx, unsigned int);\n+extern rtx find_reg_note (rtx, enum reg_note, rtx);\n+extern rtx find_regno_note (rtx, enum reg_note, unsigned int);\n+extern rtx find_reg_equal_equiv_note (rtx);\n+extern int find_reg_fusage (rtx, enum rtx_code, rtx);\n+extern int find_regno_fusage (rtx, enum rtx_code, unsigned int);\n+extern int pure_call_p (rtx);\n+extern void remove_note (rtx, rtx);\n+extern int side_effects_p (rtx);\n+extern int volatile_refs_p (rtx);\n+extern int volatile_insn_p (rtx);\n+extern int may_trap_p (rtx);\n+extern int inequality_comparisons_p (rtx);\n+extern rtx replace_rtx (rtx, rtx, rtx);\n+extern rtx replace_regs (rtx, rtx *, unsigned int, int);\n+extern int replace_label (rtx *, void *);\n+extern int rtx_referenced_p (rtx, rtx);\n+extern bool tablejump_p (rtx, rtx *, rtx *);\n+extern int computed_jump_p (rtx);\n+typedef int (*rtx_function) (rtx *, void *);\n+extern int for_each_rtx (rtx *, rtx_function, void *);\n+extern rtx regno_use_in (unsigned int, rtx);\n+extern int auto_inc_p (rtx);\n+extern int in_expr_list_p (rtx, rtx);\n+extern void remove_node_from_expr_list (rtx, rtx *);\n+extern int insns_safe_to_move_p (rtx, rtx, rtx *);\n+extern int loc_mentioned_in_p (rtx *, rtx);\n+extern rtx find_first_parameter_load (rtx, rtx);\n+extern bool keep_with_call_p (rtx);\n \n /* flow.c */\n \n-extern rtx find_use_as_address\t\tPARAMS ((rtx, rtx, HOST_WIDE_INT));\n+extern rtx find_use_as_address (rtx, rtx, HOST_WIDE_INT);\n \n /* lists.c */\n \n@@ -1752,21 +1714,20 @@ rtx alloc_EXPR_LIST\t\t\t(int, rtx, rtx);\n extern int max_parallel;\n \n /* Free up register info memory.  */\n-extern void free_reg_info\t\tPARAMS ((void));\n+extern void free_reg_info (void);\n \n /* recog.c */\n-extern int asm_noperands\t\tPARAMS ((rtx));\n-extern const char *decode_asm_operands\tPARAMS ((rtx, rtx *, rtx **,\n-\t\t\t\t\t       const char **,\n-\t\t\t\t\t       enum machine_mode *));\n+extern int asm_noperands (rtx);\n+extern const char *decode_asm_operands (rtx, rtx *, rtx **, const char **,\n+\t\t\t\t\tenum machine_mode *);\n \n-extern enum reg_class reg_preferred_class PARAMS ((int));\n-extern enum reg_class reg_alternate_class PARAMS ((int));\n+extern enum reg_class reg_preferred_class (int);\n+extern enum reg_class reg_alternate_class (int);\n \n-extern rtx get_first_nonparm_insn\tPARAMS ((void));\n+extern rtx get_first_nonparm_insn (void);\n \n-extern void split_all_insns\t\tPARAMS ((int));\n-extern void split_all_insns_noflow\tPARAMS ((void));\n+extern void split_all_insns (int);\n+extern void split_all_insns_noflow (void);\n \n #define MAX_SAVED_CONST_INT 64\n extern GTY(()) rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n@@ -1866,14 +1827,14 @@ extern GTY(()) rtx return_address_pointer_rtx;\n    add to this list, modify special_rtx in gengenrtl.c as well.  You\n    should also modify gen_rtx to use the special function.  */\n \n-extern rtx gen_rtx_CONST_INT PARAMS ((enum machine_mode, HOST_WIDE_INT));\n-extern rtx gen_rtx_CONST_VECTOR PARAMS ((enum machine_mode, rtvec));\n-extern rtx gen_raw_REG PARAMS ((enum machine_mode, int));\n-extern rtx gen_rtx_REG PARAMS ((enum machine_mode, unsigned));\n-extern rtx gen_rtx_SUBREG PARAMS ((enum machine_mode, rtx, int));\n-extern rtx gen_rtx_MEM PARAMS ((enum machine_mode, rtx));\n+extern rtx gen_rtx_CONST_INT (enum machine_mode, HOST_WIDE_INT);\n+extern rtx gen_rtx_CONST_VECTOR (enum machine_mode, rtvec);\n+extern rtx gen_raw_REG (enum machine_mode, int);\n+extern rtx gen_rtx_REG (enum machine_mode, unsigned);\n+extern rtx gen_rtx_SUBREG (enum machine_mode, rtx, int);\n+extern rtx gen_rtx_MEM (enum machine_mode, rtx);\n \n-extern rtx gen_lowpart_SUBREG PARAMS ((enum machine_mode, rtx));\n+extern rtx gen_lowpart_SUBREG (enum machine_mode, rtx);\n \n /* We need the cast here to ensure that we get the same result both with\n    and without prototypes.  */\n@@ -1943,10 +1904,10 @@ extern rtx gen_lowpart_SUBREG PARAMS ((enum machine_mode, rtx));\n /* REGNUM never really appearing in the INSN stream.  */\n #define INVALID_REGNUM\t\t\t(~(unsigned int) 0)\n \n-extern rtx output_constant_def\t\tPARAMS ((tree, int));\n+extern rtx output_constant_def (tree, int);\n \n /* Called from integrate.c when a deferred constant is inlined.  */\n-extern void notice_rtl_inlining_of_deferred_constant PARAMS ((void));\n+extern void notice_rtl_inlining_of_deferred_constant (void);\n \n /* Nonzero after the second flow pass has completed.\n    Set to 1 or 0 by toplev.c  */\n@@ -1981,7 +1942,7 @@ extern int no_new_pseudos;\n    REAL_ARITHMETIC.  The function returns an int because the caller may not\n    know what `enum tree_code' means.  */\n \n-extern int rtx_to_tree_code\tPARAMS ((enum rtx_code));\n+extern int rtx_to_tree_code (enum rtx_code);\n \n /* In cse.c */\n struct cse_basic_block_data;\n@@ -1995,92 +1956,91 @@ struct cse_basic_block_data;\n    not to use an rtx with this cost under any circumstances.  */\n #define MAX_COST INT_MAX\n \n-extern int rtx_cost\t\t\tPARAMS ((rtx, enum rtx_code));\n-extern int address_cost\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int delete_trivially_dead_insns\tPARAMS ((rtx, int));\n+extern int rtx_cost (rtx, enum rtx_code);\n+extern int address_cost (rtx, enum machine_mode);\n+extern int delete_trivially_dead_insns (rtx, int);\n #ifdef BUFSIZ\n-extern int cse_main\t\t\tPARAMS ((rtx, int, int, FILE *));\n+extern int cse_main (rtx, int, int, FILE *);\n #endif\n-extern void cse_end_of_basic_block\tPARAMS ((rtx,\n-\t\t\t\t\t\tstruct cse_basic_block_data *,\n-\t\t\t\t\t\tint, int, int));\n+extern void cse_end_of_basic_block (rtx, struct cse_basic_block_data *,\n+\t\t\t\t    int, int, int);\n \n /* In jump.c */\n-extern int comparison_dominates_p\tPARAMS ((enum rtx_code, enum rtx_code));\n-extern int condjump_p\t\t\tPARAMS ((rtx));\n-extern int any_condjump_p\t\tPARAMS ((rtx));\n-extern int any_uncondjump_p\t\tPARAMS ((rtx));\n-extern int safe_to_remove_jump_p\tPARAMS ((rtx));\n-extern rtx pc_set\t\t\tPARAMS ((rtx));\n-extern rtx condjump_label\t\tPARAMS ((rtx));\n-extern int simplejump_p\t\t\tPARAMS ((rtx));\n-extern int returnjump_p\t\t\tPARAMS ((rtx));\n-extern int onlyjump_p\t\t\tPARAMS ((rtx));\n-extern int only_sets_cc0_p\t\tPARAMS ((rtx));\n-extern int sets_cc0_p\t\t\tPARAMS ((rtx));\n-extern int invert_jump_1\t\tPARAMS ((rtx, rtx));\n-extern int invert_jump\t\t\tPARAMS ((rtx, rtx, int));\n-extern int rtx_renumbered_equal_p\tPARAMS ((rtx, rtx));\n-extern int true_regnum\t\t\tPARAMS ((rtx));\n-extern unsigned int reg_or_subregno\tPARAMS ((rtx));\n-extern int redirect_jump_1\t\tPARAMS ((rtx, rtx));\n-extern int redirect_jump\t\tPARAMS ((rtx, rtx, int));\n-extern void rebuild_jump_labels\t\tPARAMS ((rtx));\n-extern enum rtx_code reversed_comparison_code PARAMS ((rtx, rtx));\n-extern enum rtx_code reversed_comparison_code_parts PARAMS ((enum rtx_code,\n-\t\t\t\t\t\t\t     rtx, rtx, rtx));\n-extern void delete_for_peephole\t\tPARAMS ((rtx, rtx));\n-extern int condjump_in_parallel_p\tPARAMS ((rtx));\n-extern void never_reached_warning\tPARAMS ((rtx, rtx));\n-extern void purge_line_number_notes\tPARAMS ((rtx));\n-extern void copy_loop_headers\t\tPARAMS ((rtx));\n+extern int comparison_dominates_p (enum rtx_code, enum rtx_code);\n+extern int condjump_p (rtx);\n+extern int any_condjump_p (rtx);\n+extern int any_uncondjump_p (rtx);\n+extern int safe_to_remove_jump_p (rtx);\n+extern rtx pc_set (rtx);\n+extern rtx condjump_label (rtx);\n+extern int simplejump_p (rtx);\n+extern int returnjump_p (rtx);\n+extern int onlyjump_p (rtx);\n+extern int only_sets_cc0_p (rtx);\n+extern int sets_cc0_p (rtx);\n+extern int invert_jump_1 (rtx, rtx);\n+extern int invert_jump (rtx, rtx, int);\n+extern int rtx_renumbered_equal_p (rtx, rtx);\n+extern int true_regnum (rtx);\n+extern unsigned int reg_or_subregno (rtx);\n+extern int redirect_jump_1 (rtx, rtx);\n+extern int redirect_jump (rtx, rtx, int);\n+extern void rebuild_jump_labels (rtx);\n+extern enum rtx_code reversed_comparison_code (rtx, rtx);\n+extern enum rtx_code reversed_comparison_code_parts (enum rtx_code,\n+\t\t\t\t\t\t     rtx, rtx, rtx);\n+extern void delete_for_peephole (rtx, rtx);\n+extern int condjump_in_parallel_p (rtx);\n+extern void never_reached_warning (rtx, rtx);\n+extern void purge_line_number_notes (rtx);\n+extern void copy_loop_headers (rtx);\n \n /* In emit-rtl.c.  */\n-extern int max_reg_num\t\t\t\tPARAMS ((void));\n-extern int max_label_num\t\t\tPARAMS ((void));\n-extern int get_first_label_num\t\t\tPARAMS ((void));\n-extern void delete_insns_since\t\t\tPARAMS ((rtx));\n-extern void mark_reg_pointer\t\t\tPARAMS ((rtx, int));\n-extern void mark_user_reg\t\t\tPARAMS ((rtx));\n-extern void reset_used_flags\t\t\tPARAMS ((rtx));\n-extern void reorder_insns\t\t\tPARAMS ((rtx, rtx, rtx));\n-extern void reorder_insns_nobb\t\t\tPARAMS ((rtx, rtx, rtx));\n-extern int get_max_uid\t\t\t\tPARAMS ((void));\n-extern int in_sequence_p\t\t\tPARAMS ((void));\n-extern void force_next_line_note\t\tPARAMS ((void));\n-extern void init_emit\t\t\t\tPARAMS ((void));\n-extern void init_emit_once\t\t\tPARAMS ((int));\n-extern void push_topmost_sequence\t\tPARAMS ((void));\n-extern void pop_topmost_sequence\t\tPARAMS ((void));\n-extern int subreg_realpart_p\t\t\tPARAMS ((rtx));\n-extern void reverse_comparison\t\t\tPARAMS ((rtx));\n-extern void set_new_first_and_last_insn\t\tPARAMS ((rtx, rtx));\n-extern void set_new_first_and_last_label_num\tPARAMS ((int, int));\n-extern void set_new_last_label_num\t\tPARAMS ((int));\n-extern void unshare_all_rtl_again\t\tPARAMS ((rtx));\n-extern void set_first_insn\t\t\tPARAMS ((rtx));\n-extern void set_last_insn\t\t\tPARAMS ((rtx));\n-extern void link_cc0_insns\t\t\tPARAMS ((rtx));\n-extern void add_insn\t\t\t\tPARAMS ((rtx));\n-extern void add_insn_before\t\t\tPARAMS ((rtx, rtx));\n-extern void add_insn_after\t\t\tPARAMS ((rtx, rtx));\n-extern void remove_insn\t\t\t\tPARAMS ((rtx));\n-extern void reorder_insns_with_line_notes\tPARAMS ((rtx, rtx, rtx));\n-extern void emit_insn_after_with_line_notes\tPARAMS ((rtx, rtx, rtx));\n-extern enum rtx_code classify_insn\t\tPARAMS ((rtx));\n-extern rtx emit\t\t\t\t\tPARAMS ((rtx));\n+extern int max_reg_num (void);\n+extern int max_label_num (void);\n+extern int get_first_label_num (void);\n+extern void delete_insns_since (rtx);\n+extern void mark_reg_pointer (rtx, int);\n+extern void mark_user_reg (rtx);\n+extern void reset_used_flags (rtx);\n+extern void reorder_insns (rtx, rtx, rtx);\n+extern void reorder_insns_nobb (rtx, rtx, rtx);\n+extern int get_max_uid (void);\n+extern int in_sequence_p (void);\n+extern void force_next_line_note (void);\n+extern void init_emit (void);\n+extern void init_emit_once (int);\n+extern void push_topmost_sequence (void);\n+extern void pop_topmost_sequence (void);\n+extern int subreg_realpart_p (rtx);\n+extern void reverse_comparison (rtx);\n+extern void set_new_first_and_last_insn (rtx, rtx);\n+extern void set_new_first_and_last_label_num (int, int);\n+extern void set_new_last_label_num (int);\n+extern void unshare_all_rtl_again (rtx);\n+extern void set_first_insn (rtx);\n+extern void set_last_insn (rtx);\n+extern void link_cc0_insns (rtx);\n+extern void add_insn (rtx);\n+extern void add_insn_before (rtx, rtx);\n+extern void add_insn_after (rtx, rtx);\n+extern void remove_insn (rtx);\n+extern void reorder_insns_with_line_notes (rtx, rtx, rtx);\n+extern void emit_insn_after_with_line_notes (rtx, rtx, rtx);\n+extern enum rtx_code classify_insn (rtx);\n+extern rtx emit (rtx);\n /* Query and clear/ restore no_line_numbers.  This is used by the\n    switch / case handling in stmt.c to give proper line numbers in\n    warnings about unreachable code.  */\n-int force_line_numbers PARAMS ((void));\n-void restore_line_number_status PARAMS ((int old_value));\n-extern void renumber_insns                      PARAMS ((FILE *));\n-extern void remove_unnecessary_notes             PARAMS ((void));\n-extern rtx delete_insn\t\t\tPARAMS ((rtx));\n-extern void delete_insn_chain\t\tPARAMS ((rtx, rtx));\n-extern rtx unlink_insn_chain\t\tPARAMS ((rtx, rtx));\n-extern rtx delete_insn_and_edges\tPARAMS ((rtx));\n-extern void delete_insn_chain_and_edges\tPARAMS ((rtx, rtx));\n+int force_line_numbers (void);\n+void restore_line_number_status (int old_value);\n+extern void renumber_insns (FILE *);\n+extern void remove_unnecessary_notes (void);\n+extern rtx delete_insn (rtx);\n+extern void delete_insn_chain (rtx, rtx);\n+extern rtx unlink_insn_chain (rtx, rtx);\n+extern rtx delete_insn_and_edges (rtx);\n+extern void delete_insn_chain_and_edges (rtx, rtx);\n \n /* In combine.c */\n extern int combine_instructions (rtx, unsigned int);\n@@ -2093,143 +2053,139 @@ extern void dump_combine_total_stats (FILE *);\n \n /* In sched.c.  */\n #ifdef BUFSIZ\n-extern void schedule_insns\t\tPARAMS ((FILE *));\n-extern void schedule_ebbs\t\tPARAMS ((FILE *));\n+extern void schedule_insns (FILE *);\n+extern void schedule_ebbs (FILE *);\n #endif\n-extern void fix_sched_param\t\tPARAMS ((const char *, const char *));\n+extern void fix_sched_param (const char *, const char *);\n \n /* In print-rtl.c */\n extern const char *print_rtx_head;\n-extern void debug_rtx\t\t\tPARAMS ((rtx));\n-extern void debug_rtx_list\t\tPARAMS ((rtx, int));\n-extern void debug_rtx_range\t\tPARAMS ((rtx, rtx));\n-extern rtx debug_rtx_find\t\tPARAMS ((rtx, int));\n+extern void debug_rtx (rtx);\n+extern void debug_rtx_list (rtx, int);\n+extern void debug_rtx_range (rtx, rtx);\n+extern rtx debug_rtx_find (rtx, int);\n #ifdef BUFSIZ\n-extern void print_mem_expr\t\tPARAMS ((FILE *, tree));\n-extern void print_rtl\t\t\tPARAMS ((FILE *, rtx));\n-extern void print_simple_rtl\t\tPARAMS ((FILE *, rtx));\n-extern int print_rtl_single\t\tPARAMS ((FILE *, rtx));\n-extern void print_inline_rtx\t\tPARAMS ((FILE *, rtx, int));\n+extern void print_mem_expr (FILE *, tree);\n+extern void print_rtl (FILE *, rtx);\n+extern void print_simple_rtl (FILE *, rtx);\n+extern int print_rtl_single (FILE *, rtx);\n+extern void print_inline_rtx (FILE *, rtx, int);\n #endif\n \n /* In loop.c */\n-extern void init_loop\t\t\tPARAMS ((void));\n-extern rtx libcall_other_reg\t\tPARAMS ((rtx, rtx));\n+extern void init_loop (void);\n+extern rtx libcall_other_reg (rtx, rtx);\n #ifdef BUFSIZ\n-extern void loop_optimize\t\tPARAMS ((rtx, FILE *, int));\n+extern void loop_optimize (rtx, FILE *, int);\n #endif\n extern void branch_target_load_optimize (rtx, bool);\n-extern void record_excess_regs\t\tPARAMS ((rtx, rtx, rtx *));\n+extern void record_excess_regs (rtx, rtx, rtx *);\n \n /* In function.c */\n-extern void reposition_prologue_and_epilogue_notes\tPARAMS ((rtx));\n-extern void thread_prologue_and_epilogue_insns\t\tPARAMS ((rtx));\n-extern int prologue_epilogue_contains\t\t\tPARAMS ((rtx));\n-extern int sibcall_epilogue_contains\t\t\tPARAMS ((rtx));\n-extern void preserve_rtl_expr_result\t\t\tPARAMS ((rtx));\n-extern void mark_temp_addr_taken\t\t\tPARAMS ((rtx));\n-extern void update_temp_slot_address\t\t\tPARAMS ((rtx, rtx));\n-extern void purge_addressof\t\t\t\tPARAMS ((rtx));\n-extern void purge_hard_subreg_sets\t\t\tPARAMS ((rtx));\n+extern void reposition_prologue_and_epilogue_notes (rtx);\n+extern void thread_prologue_and_epilogue_insns (rtx);\n+extern int prologue_epilogue_contains (rtx);\n+extern int sibcall_epilogue_contains (rtx);\n+extern void preserve_rtl_expr_result (rtx);\n+extern void mark_temp_addr_taken (rtx);\n+extern void update_temp_slot_address (rtx, rtx);\n+extern void purge_addressof (rtx);\n+extern void purge_hard_subreg_sets (rtx);\n \n /* In stmt.c */\n-extern void set_file_and_line_for_stmt\tPARAMS ((const char *, int));\n-extern void expand_null_return\t\tPARAMS ((void));\n-extern void emit_jump\t\t\tPARAMS ((rtx));\n-extern int preserve_subexpressions_p\tPARAMS ((void));\n+extern void set_file_and_line_for_stmt (const char *, int);\n+extern void expand_null_return (void);\n+extern void emit_jump (rtx);\n+extern int preserve_subexpressions_p (void);\n \n /* In expr.c */\n-extern rtx move_by_pieces\t\tPARAMS ((rtx, rtx,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned int, int));\n+extern rtx move_by_pieces (rtx, rtx, unsigned HOST_WIDE_INT,\n+\t\t\t   unsigned int, int);\n \n /* In flow.c */\n-extern void recompute_reg_usage\t\t\tPARAMS ((rtx, int));\n-extern int initialize_uninitialized_subregs\tPARAMS ((void));\n-extern void delete_dead_jumptables\t\tPARAMS ((void));\n+extern void recompute_reg_usage (rtx, int);\n+extern int initialize_uninitialized_subregs (void);\n+extern void delete_dead_jumptables (void);\n #ifdef BUFSIZ\n-extern void print_rtl_with_bb\t\t\tPARAMS ((FILE *, rtx));\n-extern void dump_flow_info\t\t\tPARAMS ((FILE *));\n+extern void print_rtl_with_bb (FILE *, rtx);\n+extern void dump_flow_info (FILE *);\n #endif\n \n /* In expmed.c */\n-extern void init_expmed\t\t\tPARAMS ((void));\n-extern void expand_inc\t\t\tPARAMS ((rtx, rtx));\n-extern void expand_dec\t\t\tPARAMS ((rtx, rtx));\n-extern rtx expand_mult_highpart\t\tPARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t\tunsigned HOST_WIDE_INT, rtx,\n-\t\t\t\t\t\tint, int));\n+extern void init_expmed (void);\n+extern void expand_inc (rtx, rtx);\n+extern void expand_dec (rtx, rtx);\n+extern rtx expand_mult_highpart (enum machine_mode, rtx,\n+\t\t\t\t unsigned HOST_WIDE_INT, rtx, int, int);\n \n /* In gcse.c */\n-extern bool can_copy_p\t\t\tPARAMS ((enum machine_mode));\n-extern rtx fis_get_condition\t\tPARAMS ((rtx));\n+extern bool can_copy_p (enum machine_mode);\n+extern rtx fis_get_condition (rtx);\n #ifdef BUFSIZ\n-extern int gcse_main\t\t\tPARAMS ((rtx, FILE *));\n-extern int bypass_jumps\t\t\tPARAMS ((FILE *));\n+extern int gcse_main (rtx, FILE *);\n+extern int bypass_jumps (FILE *);\n #endif\n \n /* In global.c */\n-extern void mark_elimination\t\tPARAMS ((int, int));\n+extern void mark_elimination (int, int);\n #ifdef BUFSIZ\n-extern int global_alloc\t\t\tPARAMS ((FILE *));\n-extern void dump_global_regs\t\tPARAMS ((FILE *));\n+extern int global_alloc (FILE *);\n+extern void dump_global_regs (FILE *);\n #endif\n #ifdef HARD_CONST\n /* Yes, this ifdef is silly, but HARD_REG_SET is not always defined.  */\n-extern void retry_global_alloc\t\tPARAMS ((int, HARD_REG_SET));\n+extern void retry_global_alloc (int, HARD_REG_SET);\n #endif\n-extern void build_insn_chain\t\tPARAMS ((rtx));\n+extern void build_insn_chain (rtx);\n \n /* In regclass.c */\n-extern int reg_classes_intersect_p\tPARAMS ((enum reg_class, enum reg_class));\n-extern int reg_class_subset_p\t\tPARAMS ((enum reg_class, enum reg_class));\n-extern void globalize_reg\t\tPARAMS ((int));\n-extern void init_regs\t\t\tPARAMS ((void));\n-extern void init_fake_stack_mems\tPARAMS ((void));\n-extern void init_reg_sets\t\tPARAMS ((void));\n-extern void regset_release_memory\tPARAMS ((void));\n-extern void regclass_init\t\tPARAMS ((void));\n-extern void regclass\t\t\tPARAMS ((rtx, int, FILE *));\n-extern void reg_scan\t\t\tPARAMS ((rtx, unsigned int, int));\n-extern void reg_scan_update\t\tPARAMS ((rtx, rtx, unsigned int));\n-extern void fix_register\t\tPARAMS ((const char *, int, int));\n+extern int reg_classes_intersect_p (enum reg_class, enum reg_class);\n+extern int reg_class_subset_p (enum reg_class, enum reg_class);\n+extern void globalize_reg (int);\n+extern void init_regs (void);\n+extern void init_fake_stack_mems (void);\n+extern void init_reg_sets (void);\n+extern void regset_release_memory (void);\n+extern void regclass_init (void);\n+extern void regclass (rtx, int, FILE *);\n+extern void reg_scan (rtx, unsigned int, int);\n+extern void reg_scan_update (rtx, rtx, unsigned int);\n+extern void fix_register (const char *, int, int);\n #ifdef HARD_CONST\n-extern void cannot_change_mode_set_regs PARAMS ((HARD_REG_SET *,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t unsigned int));\n+extern void cannot_change_mode_set_regs (HARD_REG_SET *,\n+\t\t\t\t\t enum machine_mode, unsigned int);\n #endif\n-extern bool invalid_mode_change_p\tPARAMS ((unsigned int,\n-\t\t\t\t\t\t enum reg_class,\n-\t\t\t\t\t\t enum machine_mode));\n+extern bool invalid_mode_change_p (unsigned int, enum reg_class,\n+\t\t\t\t   enum machine_mode);\n \n-extern int delete_null_pointer_checks\tPARAMS ((rtx));\n+extern int delete_null_pointer_checks (rtx);\n \n /* In regmove.c */\n #ifdef BUFSIZ\n-extern void regmove_optimize\t\tPARAMS ((rtx, int, FILE *));\n+extern void regmove_optimize (rtx, int, FILE *);\n #endif\n-extern void combine_stack_adjustments\tPARAMS ((void));\n+extern void combine_stack_adjustments (void);\n \n /* In reorg.c */\n #ifdef BUFSIZ\n-extern void dbr_schedule\t\tPARAMS ((rtx, FILE *));\n+extern void dbr_schedule (rtx, FILE *);\n #endif\n \n /* In local-alloc.c */\n #ifdef BUFSIZ\n-extern void dump_local_alloc\t\tPARAMS ((FILE *));\n+extern void dump_local_alloc (FILE *);\n #endif\n-extern int local_alloc\t\t\tPARAMS ((void));\n-extern int function_invariant_p\t\tPARAMS ((rtx));\n+extern int local_alloc (void);\n+extern int function_invariant_p (rtx);\n \n /* In profile.c */\n-extern void init_branch_prob\t\tPARAMS ((void));\n-extern void branch_prob\t\t\tPARAMS ((void));\n-extern void end_branch_prob\t\tPARAMS ((void));\n+extern void init_branch_prob (void);\n+extern void branch_prob (void);\n+extern void end_branch_prob (void);\n \n /* In reg-stack.c */\n #ifdef BUFSIZ\n-extern bool reg_to_stack\t\tPARAMS ((rtx, FILE *));\n+extern bool reg_to_stack (rtx, FILE *);\n #endif\n \n /* In calls.c */\n@@ -2246,29 +2202,26 @@ enum libcall_type\n   LCT_RETURNS_TWICE = 8\n };\n \n-extern void emit_library_call\t\tPARAMS ((rtx, enum libcall_type,\n-\t\t\t\t\t\t enum machine_mode, int,\n-\t\t\t\t\t\t ...));\n-extern rtx emit_library_call_value\tPARAMS ((rtx, rtx, enum libcall_type,\n-\t\t\t\t\t\t enum machine_mode, int,\n-\t\t\t\t\t\t ...));\n+extern void emit_library_call (rtx, enum libcall_type, enum machine_mode, int,\n+\t\t\t       ...);\n+extern rtx emit_library_call_value (rtx, rtx, enum libcall_type,\n+\t\t\t\t    enum machine_mode, int, ...);\n \n /* In unroll.c */\n-extern int set_dominates_use\t\tPARAMS ((int, int, int, rtx, rtx));\n+extern int set_dominates_use (int, int, int, rtx, rtx);\n \n /* In varasm.c */\n-extern int in_data_section\t\tPARAMS ((void));\n-extern void init_varasm_once\t\tPARAMS ((void));\n+extern int in_data_section (void);\n+extern void init_varasm_once (void);\n \n /* In rtl.c */\n-extern void init_rtl\t\t\tPARAMS ((void));\n-extern void traverse_md_constants\tPARAMS ((int (*) (void **, void *),\n-\t\t\t\t\t\t void *));\n+extern void init_rtl (void);\n+extern void traverse_md_constants (int (*) (void **, void *), void *);\n struct md_constant { char *name, *value; };\n \n #ifdef BUFSIZ\n-extern int read_skip_spaces\t\tPARAMS ((FILE *));\n-extern rtx read_rtx\t\t\tPARAMS ((FILE *));\n+extern int read_skip_spaces (FILE *);\n+extern rtx read_rtx (FILE *);\n #endif\n \n extern const char *read_rtx_filename;\n@@ -2280,7 +2233,7 @@ extern int read_rtx_lineno;\n    special abort includes one or both.  toplev.h gets too few files,\n    system.h gets too many.  */\n \n-extern void fancy_abort PARAMS ((const char *, int, const char *))\n+extern void fancy_abort (const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n #define abort() fancy_abort (__FILE__, __LINE__, __FUNCTION__)\n \n@@ -2309,27 +2262,27 @@ typedef enum {\n   sibcall_use_sibcall\n } sibcall_use_t;\n \n-extern void optimize_sibling_and_tail_recursive_calls PARAMS ((void));\n-extern void replace_call_placeholder\tPARAMS ((rtx, sibcall_use_t));\n+extern void optimize_sibling_and_tail_recursive_calls (void);\n+extern void replace_call_placeholder (rtx, sibcall_use_t);\n \n #ifdef STACK_REGS\n-extern int stack_regs_mentioned\t\tPARAMS ((rtx insn));\n+extern int stack_regs_mentioned (rtx insn);\n #endif\n \n /* In toplev.c */\n extern GTY(()) rtx stack_limit_rtx;\n \n /* In regrename.c */\n-extern void regrename_optimize\t\tPARAMS ((void));\n-extern void copyprop_hardreg_forward\tPARAMS ((void));\n+extern void regrename_optimize (void);\n+extern void copyprop_hardreg_forward (void);\n \n /* In ifcvt.c */\n-extern void if_convert\t\t\tPARAMS ((int));\n+extern void if_convert (int);\n \n /* In predict.c */\n-extern void invert_br_probabilities\tPARAMS ((rtx));\n-extern bool expensive_function_p\tPARAMS ((int));\n+extern void invert_br_probabilities (rtx);\n+extern bool expensive_function_p (int);\n /* In tracer.c */\n-extern void tracer\t\t\tPARAMS ((void));\n+extern void tracer (void);\n \n #endif /* ! GCC_RTL_H */"}, {"sha": "a7d410267d6a4dd981c24c2c10dd27d63dbf0811", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 95, "deletions": 230, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c20a65f04004843874f9e22c460207285dfdec1/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=0c20a65f04004843874f9e22c460207285dfdec1", "patch": "@@ -1,6 +1,6 @@\n /* Analyze RTL for C-Compiler\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -35,14 +35,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"real.h\"\n \n /* Forward declarations */\n-static int global_reg_mentioned_p_1 PARAMS ((rtx *, void *));\n-static void set_of_1\t\tPARAMS ((rtx, rtx, void *));\n-static void insn_dependent_p_1\tPARAMS ((rtx, rtx, void *));\n-static int rtx_referenced_p_1\tPARAMS ((rtx *, void *));\n-static int computed_jump_p_1\tPARAMS ((rtx));\n-static void parms_set \t\tPARAMS ((rtx, rtx, void *));\n-static bool hoist_test_store\t\tPARAMS ((rtx, rtx, regset));\n-static void hoist_update_store\t\tPARAMS ((rtx, rtx *, rtx, rtx));\n+static int global_reg_mentioned_p_1 (rtx *, void *);\n+static void set_of_1 (rtx, rtx, void *);\n+static void insn_dependent_p_1 (rtx, rtx, void *);\n+static int rtx_referenced_p_1 (rtx *, void *);\n+static int computed_jump_p_1 (rtx);\n+static void parms_set (rtx, rtx, void *);\n+static bool hoist_test_store (rtx, rtx, regset);\n+static void hoist_update_store (rtx, rtx *, rtx, rtx);\n \n /* Bit flags that specify the machine subtype we are compiling for.\n    Bits are tested using macros TARGET_... defined in the tm.h file\n@@ -56,8 +56,7 @@ int target_flags;\n    (within one function) and so is anything marked `unchanging'.  */\n \n int\n-rtx_unstable_p (x)\n-     rtx x;\n+rtx_unstable_p (rtx x)\n {\n   RTX_CODE code = GET_CODE (x);\n   int i;\n@@ -132,9 +131,7 @@ rtx_unstable_p (x)\n    The frame pointer and the arg pointer are considered constant.  */\n \n int\n-rtx_varies_p (x, for_alias)\n-     rtx x;\n-     int for_alias;\n+rtx_varies_p (rtx x, int for_alias)\n {\n   RTX_CODE code = GET_CODE (x);\n   int i;\n@@ -219,8 +216,7 @@ rtx_varies_p (x, for_alias)\n /* Return 0 if the use of X as an address in a MEM can cause a trap.  */\n \n int\n-rtx_addr_can_trap_p (x)\n-     rtx x;\n+rtx_addr_can_trap_p (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -283,8 +279,7 @@ rtx_addr_can_trap_p (x)\n /* Return true if X is an address that is known to not be zero.  */\n \n bool\n-nonzero_address_p (x)\n-     rtx x;\n+nonzero_address_p (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -371,9 +366,7 @@ nonzero_address_p (x)\n    zero, we are slightly more conservative.  */\n \n int\n-rtx_addr_varies_p (x, for_alias)\n-     rtx x;\n-     int for_alias;\n+rtx_addr_varies_p (rtx x, int for_alias)\n {\n   enum rtx_code code;\n   int i;\n@@ -409,8 +402,7 @@ rtx_addr_varies_p (x, for_alias)\n    This is used in cse.c with the `related_value' field.  */\n \n HOST_WIDE_INT\n-get_integer_term (x)\n-     rtx x;\n+get_integer_term (rtx x)\n {\n   if (GET_CODE (x) == CONST)\n     x = XEXP (x, 0);\n@@ -429,8 +421,7 @@ get_integer_term (x)\n    Only obvious integer terms are detected.  */\n \n rtx\n-get_related_value (x)\n-     rtx x;\n+get_related_value (rtx x)\n {\n   if (GET_CODE (x) != CONST)\n     return 0;\n@@ -452,9 +443,7 @@ get_related_value (x)\n    insn used in locating the offset was found.  */\n \n rtx\n-get_jump_table_offset (insn, earliest)\n-     rtx insn;\n-     rtx *earliest;\n+get_jump_table_offset (rtx insn, rtx *earliest)\n {\n   rtx label;\n   rtx table;\n@@ -582,9 +571,7 @@ get_jump_table_offset (insn, earliest)\n    a global register.  */\n \n static int\n-global_reg_mentioned_p_1 (loc, data)\n-     rtx *loc;\n-     void *data ATTRIBUTE_UNUSED;\n+global_reg_mentioned_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n {\n   int regno;\n   rtx x = *loc;\n@@ -633,8 +620,7 @@ global_reg_mentioned_p_1 (loc, data)\n /* Returns nonzero if X mentions a global register.  */\n \n int\n-global_reg_mentioned_p (x)\n-     rtx x;\n+global_reg_mentioned_p (rtx x)\n {\n   if (INSN_P (x))\n     {\n@@ -657,9 +643,7 @@ global_reg_mentioned_p (x)\n    zero, we do not count occurrences inside the destination of a SET.  */\n \n int\n-count_occurrences (x, find, count_dest)\n-     rtx x, find;\n-     int count_dest;\n+count_occurrences (rtx x, rtx find, int count_dest)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -722,8 +706,7 @@ count_occurrences (x, find, count_dest)\n    for a subexpression of IN that is Lisp \"equal\" to REG.  */\n \n int\n-reg_mentioned_p (reg, in)\n-     rtx reg, in;\n+reg_mentioned_p (rtx reg, rtx in)\n {\n   const char *fmt;\n   int i;\n@@ -788,8 +771,7 @@ reg_mentioned_p (reg, in)\n    no CODE_LABEL insn.  */\n \n int\n-no_labels_between_p (beg, end)\n-     rtx beg, end;\n+no_labels_between_p (rtx beg, rtx end)\n {\n   rtx p;\n   if (beg == end)\n@@ -804,8 +786,7 @@ no_labels_between_p (beg, end)\n    no JUMP_INSN insn.  */\n \n int\n-no_jumps_between_p (beg, end)\n-     rtx beg, end;\n+no_jumps_between_p (rtx beg, rtx end)\n {\n   rtx p;\n   for (p = NEXT_INSN (beg); p != end; p = NEXT_INSN (p))\n@@ -818,8 +799,7 @@ no_jumps_between_p (beg, end)\n    FROM_INSN and TO_INSN (exclusive of those two).  */\n \n int\n-reg_used_between_p (reg, from_insn, to_insn)\n-     rtx reg, from_insn, to_insn;\n+reg_used_between_p (rtx reg, rtx from_insn, rtx to_insn)\n {\n   rtx insn;\n \n@@ -841,9 +821,7 @@ reg_used_between_p (reg, from_insn, to_insn)\n    we do not consider it a reference.  */\n \n int\n-reg_referenced_p (x, body)\n-     rtx x;\n-     rtx body;\n+reg_referenced_p (rtx x, rtx body)\n {\n   int i;\n \n@@ -920,8 +898,7 @@ reg_referenced_p (x, body)\n    not count.  */\n \n int\n-reg_referenced_between_p (reg, from_insn, to_insn)\n-     rtx reg, from_insn, to_insn;\n+reg_referenced_between_p (rtx reg, rtx from_insn, rtx to_insn)\n {\n   rtx insn;\n \n@@ -941,8 +918,7 @@ reg_referenced_between_p (reg, from_insn, to_insn)\n    FROM_INSN and TO_INSN (exclusive of those two).  */\n \n int\n-reg_set_between_p (reg, from_insn, to_insn)\n-     rtx reg, from_insn, to_insn;\n+reg_set_between_p (rtx reg, rtx from_insn, rtx to_insn)\n {\n   rtx insn;\n \n@@ -957,8 +933,7 @@ reg_set_between_p (reg, from_insn, to_insn)\n \n /* Internals of reg_set_between_p.  */\n int\n-reg_set_p (reg, insn)\n-     rtx reg, insn;\n+reg_set_p (rtx reg, rtx insn)\n {\n   /* We can be passed an insn or part of one.  If we are passed an insn,\n      check if a side-effect of the insn clobbers REG.  */\n@@ -985,9 +960,7 @@ reg_set_p (reg, insn)\n    consider non-registers one way or the other.  */\n \n int\n-regs_set_between_p (x, start, end)\n-     rtx x;\n-     rtx start, end;\n+regs_set_between_p (rtx x, rtx start, rtx end)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n@@ -1032,9 +1005,7 @@ regs_set_between_p (x, start, end)\n    X contains a MEM; this routine does usememory aliasing.  */\n \n int\n-modified_between_p (x, start, end)\n-     rtx x;\n-     rtx start, end;\n+modified_between_p (rtx x, rtx start, rtx end)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n@@ -1096,9 +1067,7 @@ modified_between_p (x, start, end)\n    does use memory aliasing.  */\n \n int\n-modified_in_p (x, insn)\n-     rtx x;\n-     rtx insn;\n+modified_in_p (rtx x, rtx insn)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n@@ -1154,8 +1123,7 @@ modified_in_p (x, insn)\n    anything in insn Y.  */\n \n int\n-insn_dependent_p (x, y)\n-     rtx x, y;\n+insn_dependent_p (rtx x, rtx y)\n {\n   rtx tmp;\n \n@@ -1178,10 +1146,7 @@ insn_dependent_p (x, y)\n /* A helper routine for insn_dependent_p called through note_stores.  */\n \n static void\n-insn_dependent_p_1 (x, pat, data)\n-     rtx x;\n-     rtx pat ATTRIBUTE_UNUSED;\n-     void *data;\n+insn_dependent_p_1 (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n {\n   rtx * pinsn = (rtx *) data;\n \n@@ -1197,10 +1162,7 @@ struct set_of_data\n   };\n \n static void\n-set_of_1 (x, pat, data1)\n-     rtx x;\n-     rtx pat;\n-     void *data1;\n+set_of_1 (rtx x, rtx pat, void *data1)\n {\n    struct set_of_data *data = (struct set_of_data *) (data1);\n    if (rtx_equal_p (x, data->pat)\n@@ -1211,8 +1173,7 @@ set_of_1 (x, pat, data1)\n /* Give an INSN, return a SET or CLOBBER expression that does modify PAT\n    (either directly or via STRICT_LOW_PART and similar modifiers).  */\n rtx\n-set_of (pat, insn)\n-     rtx pat, insn;\n+set_of (rtx pat, rtx insn)\n {\n   struct set_of_data data;\n   data.found = NULL_RTX;\n@@ -1226,8 +1187,7 @@ set_of (pat, insn)\n    will not be used, which we ignore.  */\n \n rtx\n-single_set_2 (insn, pat)\n-     rtx insn, pat;\n+single_set_2 (rtx insn, rtx pat)\n {\n   rtx set = NULL;\n   int set_verified = 1;\n@@ -1280,8 +1240,7 @@ single_set_2 (insn, pat)\n    zero.  */\n \n int\n-multiple_sets (insn)\n-     rtx insn;\n+multiple_sets (rtx insn)\n {\n   int found;\n   int i;\n@@ -1312,8 +1271,7 @@ multiple_sets (insn)\n    and there are no side effects.  */\n \n int\n-set_noop_p (set)\n-     rtx set;\n+set_noop_p (rtx set)\n {\n   rtx src = SET_SRC (set);\n   rtx dst = SET_DEST (set);\n@@ -1349,8 +1307,7 @@ set_noop_p (set)\n    value to itself.  */\n \n int\n-noop_move_p (insn)\n-     rtx insn;\n+noop_move_p (rtx insn)\n {\n   rtx pat = PATTERN (insn);\n \n@@ -1400,11 +1357,7 @@ noop_move_p (insn)\n    be the src.  */\n \n rtx\n-find_last_value (x, pinsn, valid_to, allow_hwreg)\n-     rtx x;\n-     rtx *pinsn;\n-     rtx valid_to;\n-     int allow_hwreg;\n+find_last_value (rtx x, rtx *pinsn, rtx valid_to, int allow_hwreg)\n {\n   rtx p;\n \n@@ -1450,10 +1403,8 @@ find_last_value (x, pinsn, valid_to, allow_hwreg)\n    LOC may be zero, meaning don't ignore anything.  */\n \n int\n-refers_to_regno_p (regno, endregno, x, loc)\n-     unsigned int regno, endregno;\n-     rtx x;\n-     rtx *loc;\n+refers_to_regno_p (unsigned int regno, unsigned int endregno, rtx x,\n+\t\t   rtx *loc)\n {\n   int i;\n   unsigned int x_regno;\n@@ -1564,8 +1515,7 @@ refers_to_regno_p (regno, endregno, x, loc)\n    conflict because we expect this to be a rare case.  */\n \n int\n-reg_overlap_mentioned_p (x, in)\n-     rtx x, in;\n+reg_overlap_mentioned_p (rtx x, rtx in)\n {\n   unsigned int regno, endregno;\n \n@@ -1641,9 +1591,7 @@ reg_overlap_mentioned_p (x, in)\n    check if a MEM remains unchanged.  */\n \n rtx\n-reg_set_last (x, insn)\n-     rtx x;\n-     rtx insn;\n+reg_set_last (rtx x, rtx insn)\n {\n   rtx orig_insn = insn;\n \n@@ -1694,10 +1642,7 @@ reg_set_last (x, insn)\n   the SUBREG will be passed.  */\n \n void\n-note_stores (x, fun, data)\n-     rtx x;\n-     void (*fun) PARAMS ((rtx, rtx, void *));\n-     void *data;\n+note_stores (rtx x, void (*fun) (rtx, rtx, void *), void *data)\n {\n   int i;\n \n@@ -1743,10 +1688,7 @@ note_stores (x, fun, data)\n    partially set, while we do not.  */\n \n void\n-note_uses (pbody, fun, data)\n-     rtx *pbody;\n-     void (*fun) PARAMS ((rtx *, void *));\n-     void *data;\n+note_uses (rtx *pbody, void (*fun) (rtx *, void *), void *data)\n {\n   rtx body = *pbody;\n   int i;\n@@ -1838,9 +1780,7 @@ note_uses (pbody, fun, data)\n    by INSN.  */\n \n int\n-dead_or_set_p (insn, x)\n-     rtx insn;\n-     rtx x;\n+dead_or_set_p (rtx insn, rtx x)\n {\n   unsigned int regno, last_regno;\n   unsigned int i;\n@@ -1867,9 +1807,7 @@ dead_or_set_p (insn, x)\n    called from flow.c.  */\n \n int\n-dead_or_set_regno_p (insn, test_regno)\n-     rtx insn;\n-     unsigned int test_regno;\n+dead_or_set_regno_p (rtx insn, unsigned int test_regno)\n {\n   unsigned int regno, endregno;\n   rtx pattern;\n@@ -1952,10 +1890,7 @@ dead_or_set_regno_p (insn, test_regno)\n    If DATUM is nonzero, look for one whose datum is DATUM.  */\n \n rtx\n-find_reg_note (insn, kind, datum)\n-     rtx insn;\n-     enum reg_note kind;\n-     rtx datum;\n+find_reg_note (rtx insn, enum reg_note kind, rtx datum)\n {\n   rtx link;\n \n@@ -1976,10 +1911,7 @@ find_reg_note (insn, kind, datum)\n    it might be the case that the note overlaps REGNO.  */\n \n rtx\n-find_regno_note (insn, kind, regno)\n-     rtx insn;\n-     enum reg_note kind;\n-     unsigned int regno;\n+find_regno_note (rtx insn, enum reg_note kind, unsigned int regno)\n {\n   rtx link;\n \n@@ -2006,8 +1938,7 @@ find_regno_note (insn, kind, regno)\n    has such a note.  */\n \n rtx\n-find_reg_equal_equiv_note (insn)\n-     rtx insn;\n+find_reg_equal_equiv_note (rtx insn)\n {\n   rtx link;\n \n@@ -2028,10 +1959,7 @@ find_reg_equal_equiv_note (insn)\n    in the CALL_INSN_FUNCTION_USAGE information of INSN.  */\n \n int\n-find_reg_fusage (insn, code, datum)\n-     rtx insn;\n-     enum rtx_code code;\n-     rtx datum;\n+find_reg_fusage (rtx insn, enum rtx_code code, rtx datum)\n {\n   /* If it's not a CALL_INSN, it can't possibly have a\n      CALL_INSN_FUNCTION_USAGE field, so don't bother checking.  */\n@@ -2078,10 +2006,7 @@ find_reg_fusage (insn, code, datum)\n    in the CALL_INSN_FUNCTION_USAGE information of INSN.  */\n \n int\n-find_regno_fusage (insn, code, regno)\n-     rtx insn;\n-     enum rtx_code code;\n-     unsigned int regno;\n+find_regno_fusage (rtx insn, enum rtx_code code, unsigned int regno)\n {\n   rtx link;\n \n@@ -2110,8 +2035,7 @@ find_regno_fusage (insn, code, regno)\n /* Return true if INSN is a call to a pure function.  */\n \n int\n-pure_call_p (insn)\n-     rtx insn;\n+pure_call_p (rtx insn)\n {\n   rtx link;\n \n@@ -2135,9 +2059,7 @@ pure_call_p (insn)\n /* Remove register note NOTE from the REG_NOTES of INSN.  */\n \n void\n-remove_note (insn, note)\n-     rtx insn;\n-     rtx note;\n+remove_note (rtx insn, rtx note)\n {\n   rtx link;\n \n@@ -2165,9 +2087,7 @@ remove_note (insn, note)\n    NODE matches.  */\n \n int\n-in_expr_list_p (listp, node)\n-     rtx listp;\n-     rtx node;\n+in_expr_list_p (rtx listp, rtx node)\n {\n   rtx x;\n \n@@ -2184,9 +2104,7 @@ in_expr_list_p (listp, node)\n    A simple equality test is used to determine if NODE matches.  */\n \n void\n-remove_node_from_expr_list (node, listp)\n-     rtx node;\n-     rtx *listp;\n+remove_node_from_expr_list (rtx node, rtx *listp)\n {\n   rtx temp = *listp;\n   rtx prev = NULL_RTX;\n@@ -2215,8 +2133,7 @@ remove_node_from_expr_list (node, listp)\n    only volatile asms and UNSPEC_VOLATILE instructions.  */\n \n int\n-volatile_insn_p (x)\n-     rtx x;\n+volatile_insn_p (rtx x)\n {\n   RTX_CODE code;\n \n@@ -2282,8 +2199,7 @@ volatile_insn_p (x)\n    UNSPEC_VOLATILE operations or volatile ASM_OPERANDS expressions.  */\n \n int\n-volatile_refs_p (x)\n-     rtx x;\n+volatile_refs_p (rtx x)\n {\n   RTX_CODE code;\n \n@@ -2347,8 +2263,7 @@ volatile_refs_p (x)\n    incrementing.  */\n \n int\n-side_effects_p (x)\n-     rtx x;\n+side_effects_p (rtx x)\n {\n   RTX_CODE code;\n \n@@ -2424,8 +2339,7 @@ side_effects_p (x)\n /* Return nonzero if evaluating rtx X might cause a trap.  */\n \n int\n-may_trap_p (x)\n-     rtx x;\n+may_trap_p (rtx x)\n {\n   int i;\n   enum rtx_code code;\n@@ -2557,8 +2471,7 @@ may_trap_p (x)\n    i.e., an inequality.  */\n \n int\n-inequality_comparisons_p (x)\n-     rtx x;\n+inequality_comparisons_p (rtx x)\n {\n   const char *fmt;\n   int len, i;\n@@ -2621,8 +2534,7 @@ inequality_comparisons_p (x)\n    are to be modified.  */\n \n rtx\n-replace_rtx (x, from, to)\n-     rtx x, from, to;\n+replace_rtx (rtx x, rtx from, rtx to)\n {\n   int i, j;\n   const char *fmt;\n@@ -2699,11 +2611,7 @@ replace_rtx (x, from, to)\n    otherwise, only sources are replaced.  */\n \n rtx\n-replace_regs (x, reg_map, nregs, replace_dest)\n-     rtx x;\n-     rtx *reg_map;\n-     unsigned int nregs;\n-     int replace_dest;\n+replace_regs (rtx x, rtx *reg_map, unsigned int nregs, int replace_dest)\n {\n   enum rtx_code code;\n   int i;\n@@ -2794,9 +2702,7 @@ replace_regs (x, reg_map, nregs, replace_dest)\n    DATA is a REPLACE_LABEL_DATA containing the old and new labels.  */\n \n int\n-replace_label (x, data)\n-     rtx *x;\n-     void *data;\n+replace_label (rtx *x, void *data)\n {\n   rtx l = *x;\n   rtx tmp;\n@@ -2817,7 +2723,7 @@ replace_label (x, data)\n \t{\n \t  rtx new_c, new_l;\n \t  replace_label_data *d = (replace_label_data *) data;\n-\t  \n+\n \t  /* Create a copy of constant C; replace the label inside\n \t     but do not update LABEL_NUSES because uses in constant pool\n \t     are not counted.  */\n@@ -2861,9 +2767,7 @@ replace_label (x, data)\n    too, otherwise FOR_EACH_RTX continues traversing *BODY.  */\n \n static int\n-rtx_referenced_p_1 (body, x)\n-     rtx *body;\n-     void *x;\n+rtx_referenced_p_1 (rtx *body, void *x)\n {\n   rtx y = (rtx) x;\n \n@@ -2886,9 +2790,7 @@ rtx_referenced_p_1 (body, x)\n /* Return true if X is referenced in BODY.  */\n \n int\n-rtx_referenced_p (x, body)\n-     rtx x;\n-     rtx body;\n+rtx_referenced_p (rtx x, rtx body)\n {\n   return for_each_rtx (&body, rtx_referenced_p_1, x);\n }\n@@ -2898,10 +2800,7 @@ rtx_referenced_p (x, body)\n    LABEL and TABLE may be NULL.  */\n \n bool\n-tablejump_p (insn, label, table)\n-     rtx insn;\n-     rtx *label;\n-     rtx *table;\n+tablejump_p (rtx insn, rtx *label, rtx *table)\n {\n   rtx l, t;\n \n@@ -2926,8 +2825,7 @@ tablejump_p (insn, label, table)\n    of an IF_THEN_ELSE.  */\n \n static int\n-computed_jump_p_1 (x)\n-     rtx x;\n+computed_jump_p_1 (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   int i, j;\n@@ -2981,8 +2879,7 @@ computed_jump_p_1 (x)\n    we can recognize them by a (use (label_ref)).  */\n \n int\n-computed_jump_p (insn)\n-     rtx insn;\n+computed_jump_p (rtx insn)\n {\n   int i;\n   if (GET_CODE (insn) == JUMP_INSN)\n@@ -3031,10 +2928,7 @@ computed_jump_p (insn)\n    implement many of the other routines in this file.  */\n \n int\n-for_each_rtx (x, f, data)\n-     rtx *x;\n-     rtx_function f;\n-     void *data;\n+for_each_rtx (rtx *x, rtx_function f, void *data)\n {\n   int result;\n   int length;\n@@ -3095,9 +2989,7 @@ for_each_rtx (x, f, data)\n    reference found if any.  Otherwise, returns NULL_RTX.  */\n \n rtx\n-regno_use_in (regno, x)\n-     unsigned int regno;\n-     rtx x;\n+regno_use_in (unsigned int regno, rtx x)\n {\n   const char *fmt;\n   int i, j;\n@@ -3130,8 +3022,7 @@ regno_use_in (regno, x)\n    and positive values for the second operand.  */\n \n int\n-commutative_operand_precedence (op)\n-     rtx op;\n+commutative_operand_precedence (rtx op)\n {\n   /* Constants always come the second operand.  Prefer \"nice\" constants.  */\n   if (GET_CODE (op) == CONST_INT)\n@@ -3165,8 +3056,7 @@ commutative_operand_precedence (op)\n    in order to canonicalize expression.  */\n \n int\n-swap_commutative_operands_p (x, y)\n-     rtx x, y;\n+swap_commutative_operands_p (rtx x, rtx y)\n {\n   return (commutative_operand_precedence (x)\n \t  < commutative_operand_precedence (y));\n@@ -3175,8 +3065,7 @@ swap_commutative_operands_p (x, y)\n /* Return 1 if X is an autoincrement side effect and the register is\n    not the stack pointer.  */\n int\n-auto_inc_p (x)\n-     rtx x;\n+auto_inc_p (rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -3206,10 +3095,7 @@ auto_inc_p (x)\n    conditions as well.  */\n \n int\n-insns_safe_to_move_p (from, to, new_to)\n-     rtx from;\n-     rtx to;\n-     rtx *new_to;\n+insns_safe_to_move_p (rtx from, rtx to, rtx *new_to)\n {\n   int eh_region_count = 0;\n   int past_to_p = 0;\n@@ -3276,8 +3162,7 @@ insns_safe_to_move_p (from, to, new_to)\n \n /* Return nonzero if IN contains a piece of rtl that has the address LOC.  */\n int\n-loc_mentioned_in_p (loc, in)\n-     rtx *loc, in;\n+loc_mentioned_in_p (rtx *loc, rtx in)\n {\n   enum rtx_code code = GET_CODE (in);\n   const char *fmt = GET_RTX_FORMAT (code);\n@@ -3304,8 +3189,7 @@ loc_mentioned_in_p (loc, in)\n    (counting from the least significant bit of the reg).  */\n \n unsigned int\n-subreg_lsb (x)\n-     rtx x;\n+subreg_lsb (rtx x)\n {\n   enum machine_mode inner_mode = GET_MODE (SUBREG_REG (x));\n   enum machine_mode mode = GET_MODE (x);\n@@ -3350,11 +3234,8 @@ subreg_lsb (x)\n    ymode  - The mode of a top level SUBREG (or what may become one).\n    RETURN - The regno offset which would be used.  */\n unsigned int\n-subreg_regno_offset (xregno, xmode, offset, ymode)\n-     unsigned int xregno;\n-     enum machine_mode xmode;\n-     unsigned int offset;\n-     enum machine_mode ymode;\n+subreg_regno_offset (unsigned int xregno, enum machine_mode xmode,\n+\t\t     unsigned int offset, enum machine_mode ymode)\n {\n   int nregs_xmode, nregs_ymode;\n   int mode_multiple, nregs_multiple;\n@@ -3396,11 +3277,8 @@ subreg_regno_offset (xregno, xmode, offset, ymode)\n    ymode  - The mode of a top level SUBREG (or what may become one).\n    RETURN - The regno offset which would be used.  */\n bool\n-subreg_offset_representable_p (xregno, xmode, offset, ymode)\n-     unsigned int xregno;\n-     enum machine_mode xmode;\n-     unsigned int offset;\n-     enum machine_mode ymode;\n+subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n+\t\t\t       unsigned int offset, enum machine_mode ymode)\n {\n   int nregs_xmode, nregs_ymode;\n   int mode_multiple, nregs_multiple;\n@@ -3436,9 +3314,9 @@ subreg_offset_representable_p (xregno, xmode, offset, ymode)\n   /* The XMODE value can be seen as a vector of NREGS_XMODE\n      values.  The subreg must represent an lowpart of given field.\n      Compute what field it is.  */\n-  offset -= subreg_lowpart_offset (ymode, \n-\t\t  \t\t   mode_for_size (GET_MODE_BITSIZE (xmode)\n-\t\t\t  \t\t\t  / nregs_xmode,\n+  offset -= subreg_lowpart_offset (ymode,\n+\t\t\t\t   mode_for_size (GET_MODE_BITSIZE (xmode)\n+\t\t\t\t\t\t  / nregs_xmode,\n \t\t\t\t\t\t  MODE_INT, 0));\n \n   /* size of ymode must not be greater than the size of xmode.  */\n@@ -3458,8 +3336,7 @@ subreg_offset_representable_p (xregno, xmode, offset, ymode)\n \n /* Return the final regno that a subreg expression refers to.  */\n unsigned int\n-subreg_regno (x)\n-     rtx x;\n+subreg_regno (rtx x)\n {\n   unsigned int ret;\n   rtx subreg = SUBREG_REG (x);\n@@ -3480,9 +3357,7 @@ struct parms_set_data\n \n /* Helper function for noticing stores to parameter registers.  */\n static void\n-parms_set (x, pat, data)\n-\trtx x, pat ATTRIBUTE_UNUSED;\n-\tvoid *data;\n+parms_set (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n {\n   struct parms_set_data *d = data;\n   if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER\n@@ -3496,8 +3371,7 @@ parms_set (x, pat, data)\n /* Look backward for first parameter to be loaded.\n    Do not skip BOUNDARY.  */\n rtx\n-find_first_parameter_load (call_insn, boundary)\n-     rtx call_insn, boundary;\n+find_first_parameter_load (rtx call_insn, rtx boundary)\n {\n   struct parms_set_data parm;\n   rtx p, before;\n@@ -3555,8 +3429,7 @@ find_first_parameter_load (call_insn, boundary)\n    call instruction.  */\n \n bool\n-keep_with_call_p (insn)\n-     rtx insn;\n+keep_with_call_p (rtx insn)\n {\n   rtx set;\n \n@@ -3590,9 +3463,7 @@ keep_with_call_p (insn)\n    whose value will be used.  */\n \n static bool\n-hoist_test_store (x, val, live)\n-     rtx x, val;\n-     regset live;\n+hoist_test_store (rtx x, rtx val, regset live)\n {\n   if (GET_CODE (x) == SCRATCH)\n     return true;\n@@ -3648,9 +3519,7 @@ hoist_test_store (x, val, live)\n    and used by the hoisting pass.  */\n \n bool\n-can_hoist_insn_p (insn, val, live)\n-     rtx insn, val;\n-     regset live;\n+can_hoist_insn_p (rtx insn, rtx val, regset live)\n {\n   rtx pat = PATTERN (insn);\n   int i;\n@@ -3717,8 +3586,7 @@ can_hoist_insn_p (insn, val, live)\n    be updated to NEW.  */\n \n static void\n-hoist_update_store (insn, xp, val, new)\n-     rtx insn, *xp, val, new;\n+hoist_update_store (rtx insn, rtx *xp, rtx val, rtx new)\n {\n   rtx x = *xp;\n \n@@ -3755,8 +3623,7 @@ hoist_update_store (insn, xp, val, new)\n    and each other side effect to pseudo register by new pseudo register.  */\n \n rtx\n-hoist_insn_after (insn, after, val, new)\n-     rtx insn, after, val, new;\n+hoist_insn_after (rtx insn, rtx after, rtx val, rtx new)\n {\n   rtx pat;\n   int i;\n@@ -3820,9 +3687,7 @@ hoist_insn_after (insn, after, val, new)\n }\n \n rtx\n-hoist_insn_to_edge (insn, e, val, new)\n-     rtx insn, val, new;\n-     edge e;\n+hoist_insn_to_edge (rtx insn, edge e, rtx val, rtx new)\n {\n   rtx new_insn;\n "}]}