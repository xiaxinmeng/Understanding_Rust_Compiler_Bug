{"sha": "ed9e2ed0aa5f80cef689aa291da9952167aba5dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ5ZTJlZDBhYTVmODBjZWY2ODlhYTI5MWRhOTk1MjE2N2FiYTVkYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-05-31T05:29:57Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-05-31T05:29:57Z"}, "message": "ira.c (init_move_cost): Adjust local variable names to match file conventions.\n\ngcc/\n\t* ira.c (init_move_cost): Adjust local variable names to match\n\tfile conventions.  Use ira_assert instead of gcc_assert.\n\nFrom-SVN: r188044", "tree": {"sha": "188043a75e5fc1e059f51745dc70e5b079bdab8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/188043a75e5fc1e059f51745dc70e5b079bdab8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed9e2ed0aa5f80cef689aa291da9952167aba5dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed9e2ed0aa5f80cef689aa291da9952167aba5dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed9e2ed0aa5f80cef689aa291da9952167aba5dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed9e2ed0aa5f80cef689aa291da9952167aba5dc/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650"}], "stats": {"total": 97, "additions": 52, "deletions": 45}, "files": [{"sha": "bfab9d4e7fc9fbd268015938de5ef32d400b590a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9e2ed0aa5f80cef689aa291da9952167aba5dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9e2ed0aa5f80cef689aa291da9952167aba5dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed9e2ed0aa5f80cef689aa291da9952167aba5dc", "patch": "@@ -1,3 +1,8 @@\n+2012-05-31  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* ira.c (init_move_cost): Adjust local variable names to match\n+\tfile conventions.  Use ira_assert instead of gcc_assert.\n+\n 2012-05-31  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* regs.h (move_table, move_cost, may_move_in_cost, may_move_out_cost):"}, {"sha": "90b21b0ad4d5f958dffdb4684a648d9138a0c88b", "filename": "gcc/ira.c", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9e2ed0aa5f80cef689aa291da9952167aba5dc/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9e2ed0aa5f80cef689aa291da9952167aba5dc/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=ed9e2ed0aa5f80cef689aa291da9952167aba5dc", "patch": "@@ -1461,90 +1461,92 @@ clarify_prohibited_class_mode_regs (void)\n /* Initialize may_move_cost and friends for mode M.  */\n \n static void\n-init_move_cost (enum machine_mode m)\n+init_move_cost (enum machine_mode mode)\n {\n   static unsigned short last_move_cost[N_REG_CLASSES][N_REG_CLASSES];\n   bool all_match = true;\n-  unsigned int i, j;\n+  unsigned int cl1, cl2;\n \n-  gcc_assert (have_regs_of_mode[m]);\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    if (contains_reg_of_mode[i][m])\n-      for (j = 0; j < N_REG_CLASSES; j++)\n+  ira_assert (have_regs_of_mode[mode]);\n+  for (cl1 = 0; cl1 < N_REG_CLASSES; cl1++)\n+    if (contains_reg_of_mode[cl1][mode])\n+      for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n \t{\n \t  int cost;\n-\t  if (!contains_reg_of_mode[j][m])\n+\t  if (!contains_reg_of_mode[cl2][mode])\n \t    cost = 65535;\n \t  else\n \t    {\n-\t      cost = register_move_cost (m, (enum reg_class) i,\n-\t\t\t\t\t (enum reg_class) j);\n-\t      gcc_assert (cost < 65535);\n+\t      cost = register_move_cost (mode, (enum reg_class) cl1,\n+\t\t\t\t\t (enum reg_class) cl2);\n+\t      ira_assert (cost < 65535);\n \t    }\n-\t  all_match &= (last_move_cost[i][j] == cost);\n-\t  last_move_cost[i][j] = cost;\n+\t  all_match &= (last_move_cost[cl1][cl2] == cost);\n+\t  last_move_cost[cl1][cl2] = cost;\n \t}\n   if (all_match && last_mode_for_init_move_cost != -1)\n     {\n-      move_cost[m] = move_cost[last_mode_for_init_move_cost];\n-      may_move_in_cost[m] = may_move_in_cost[last_mode_for_init_move_cost];\n-      may_move_out_cost[m] = may_move_out_cost[last_mode_for_init_move_cost];\n+      move_cost[mode] = move_cost[last_mode_for_init_move_cost];\n+      may_move_in_cost[mode] = may_move_in_cost[last_mode_for_init_move_cost];\n+      may_move_out_cost[mode] = may_move_out_cost[last_mode_for_init_move_cost];\n       return;\n     }\n-  last_mode_for_init_move_cost = m;\n-  move_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n+  last_mode_for_init_move_cost = mode;\n+  move_cost[mode] = (move_table *)xmalloc (sizeof (move_table)\n \t\t\t\t\t* N_REG_CLASSES);\n-  may_move_in_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n+  may_move_in_cost[mode] = (move_table *)xmalloc (sizeof (move_table)\n \t\t\t\t\t       * N_REG_CLASSES);\n-  may_move_out_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n+  may_move_out_cost[mode] = (move_table *)xmalloc (sizeof (move_table)\n \t\t\t\t\t        * N_REG_CLASSES);\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    if (contains_reg_of_mode[i][m])\n-      for (j = 0; j < N_REG_CLASSES; j++)\n+  for (cl1 = 0; cl1 < N_REG_CLASSES; cl1++)\n+    if (contains_reg_of_mode[cl1][mode])\n+      for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n \t{\n \t  int cost;\n \t  enum reg_class *p1, *p2;\n \n-\t  if (last_move_cost[i][j] == 65535)\n+\t  if (last_move_cost[cl1][cl2] == 65535)\n \t    {\n-\t      move_cost[m][i][j] = 65535;\n-\t      may_move_in_cost[m][i][j] = 65535;\n-\t      may_move_out_cost[m][i][j] = 65535;\n+\t      move_cost[mode][cl1][cl2] = 65535;\n+\t      may_move_in_cost[mode][cl1][cl2] = 65535;\n+\t      may_move_out_cost[mode][cl1][cl2] = 65535;\n \t    }\n \t  else\n \t    {\n-\t      cost = last_move_cost[i][j];\n+\t      cost = last_move_cost[cl1][cl2];\n \n-\t      for (p2 = &reg_class_subclasses[j][0];\n+\t      for (p2 = &reg_class_subclasses[cl2][0];\n \t\t   *p2 != LIM_REG_CLASSES; p2++)\n-\t\tif (*p2 != i && contains_reg_of_mode[*p2][m])\n-\t\t  cost = MAX (cost, move_cost[m][i][*p2]);\n+\t\tif (*p2 != cl1 && contains_reg_of_mode[*p2][mode])\n+\t\t  cost = MAX (cost, move_cost[mode][cl1][*p2]);\n \n-\t      for (p1 = &reg_class_subclasses[i][0];\n+\t      for (p1 = &reg_class_subclasses[cl1][0];\n \t\t   *p1 != LIM_REG_CLASSES; p1++)\n-\t\tif (*p1 != j && contains_reg_of_mode[*p1][m])\n-\t\t  cost = MAX (cost, move_cost[m][*p1][j]);\n+\t\tif (*p1 != cl2 && contains_reg_of_mode[*p1][mode])\n+\t\t  cost = MAX (cost, move_cost[mode][*p1][cl2]);\n \n-\t      gcc_assert (cost <= 65535);\n-\t      move_cost[m][i][j] = cost;\n+\t      ira_assert (cost <= 65535);\n+\t      move_cost[mode][cl1][cl2] = cost;\n \n-\t      if (reg_class_subset_p ((enum reg_class) i, (enum reg_class) j))\n-\t\tmay_move_in_cost[m][i][j] = 0;\n+\t      if (reg_class_subset_p ((enum reg_class) cl1,\n+\t\t\t\t      (enum reg_class) cl2))\n+\t\tmay_move_in_cost[mode][cl1][cl2] = 0;\n \t      else\n-\t\tmay_move_in_cost[m][i][j] = cost;\n+\t\tmay_move_in_cost[mode][cl1][cl2] = cost;\n \n-\t      if (reg_class_subset_p ((enum reg_class) j, (enum reg_class) i))\n-\t\tmay_move_out_cost[m][i][j] = 0;\n+\t      if (reg_class_subset_p ((enum reg_class) cl2,\n+\t\t\t\t      (enum reg_class) cl1))\n+\t\tmay_move_out_cost[mode][cl1][cl2] = 0;\n \t      else\n-\t\tmay_move_out_cost[m][i][j] = cost;\n+\t\tmay_move_out_cost[mode][cl1][cl2] = cost;\n \t    }\n \t}\n     else\n-      for (j = 0; j < N_REG_CLASSES; j++)\n+      for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n \t{\n-\t  move_cost[m][i][j] = 65535;\n-\t  may_move_in_cost[m][i][j] = 65535;\n-\t  may_move_out_cost[m][i][j] = 65535;\n+\t  move_cost[mode][cl1][cl2] = 65535;\n+\t  may_move_in_cost[mode][cl1][cl2] = 65535;\n+\t  may_move_out_cost[mode][cl1][cl2] = 65535;\n \t}\n }\n "}]}