{"sha": "06ec61726d192659cd446e59a91e78745037f0fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZlYzYxNzI2ZDE5MjY1OWNkNDQ2ZTU5YTkxZTc4NzQ1MDM3ZjBmZA==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2020-05-29T13:22:42Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2020-06-04T16:56:37Z"}, "message": "[OpenACC] Repair/restore 'is_tgt_unmapped' checking\n\n\tlibgomp/\n\t* oacc-mem.c (goacc_exit_datum): Repair 'is_tgt_unmapped'\n\tchecking.\n\t(acc_unmap_data, goacc_exit_data_internal): Restore\n\t'is_tgt_unmapped' checking.\n\t* testsuite/libgomp.oacc-c-c++-common/struct-refcount-1.c: New\n\tfile.\n\t* testsuite/libgomp.oacc-fortran/deep-copy-6.f90: Adjust.\n\t* testsuite/libgomp.oacc-fortran/mdc-refcount-1-1-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/mdc-refcount-1-2-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/mdc-refcount-1-2-2.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/mdc-refcount-1-3-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/mdc-refcount-1-4-1.f90: Likewise.\n\nCo-Authored-By: Julian Brown <julian@codesourcery.com>", "tree": {"sha": "bde7c01eee6a9dc75814531320d8d6e3f9c452b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bde7c01eee6a9dc75814531320d8d6e3f9c452b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06ec61726d192659cd446e59a91e78745037f0fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ec61726d192659cd446e59a91e78745037f0fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06ec61726d192659cd446e59a91e78745037f0fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ec61726d192659cd446e59a91e78745037f0fd/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2112d3242f413979931e371423dcead9d19440e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2112d3242f413979931e371423dcead9d19440e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2112d3242f413979931e371423dcead9d19440e7"}], "stats": {"total": 165, "additions": 135, "deletions": 30}, "files": [{"sha": "b7c85cf5976f2d2de5aa145bbd476416810a2c7e", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=06ec61726d192659cd446e59a91e78745037f0fd", "patch": "@@ -485,7 +485,8 @@ acc_unmap_data (void *h)\n   tgt->tgt_end = 0;\n   tgt->to_free = NULL;\n \n-  gomp_remove_var (acc_dev, n);\n+  bool is_tgt_unmapped = gomp_remove_var (acc_dev, n);\n+  assert (is_tgt_unmapped);\n \n   gomp_mutex_unlock (&acc_dev->lock);\n \n@@ -727,8 +728,16 @@ goacc_exit_datum (void *h, size_t s, unsigned short kind, int async)\n \tgomp_remove_var_async (acc_dev, n, aq);\n       else\n \t{\n+\t  size_t num_mappings = 0;\n+\t  /* If the target_mem_desc represents a single data mapping, we can\n+\t     check that it is freed when this splay tree key's refcount reaches\n+\t     zero.  Otherwise (e.g. for a 'GOMP_MAP_STRUCT' mapping with\n+\t     multiple members), fall back to skipping the test.  */\n+\t  for (size_t l_i = 0; l_i < n->tgt->list_count; ++l_i)\n+\t    if (n->tgt->list[l_i].key)\n+\t      ++num_mappings;\n \t  bool is_tgt_unmapped = gomp_remove_var (acc_dev, n);\n-\t  assert (is_tgt_unmapped);\n+\t  assert (is_tgt_unmapped || num_mappings > 1);\n \t}\n     }\n \n@@ -1145,7 +1154,28 @@ goacc_exit_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t\t\t\t  cur_node.host_end - cur_node.host_start);\n \n \t    if (n->refcount == 0)\n-\t      gomp_remove_var_async (acc_dev, n, aq);\n+\t      {\n+\t\tif (aq)\n+\t\t  /* TODO We can't do the 'is_tgt_unmapped' checking -- see the\n+\t\t     'gomp_unref_tgt' comment in\n+\t\t     <http://mid.mail-archive.com/878snl36eu.fsf@euler.schwinge.homeip.net>;\n+\t\t     PR92881.  */\n+\t\t  gomp_remove_var_async (acc_dev, n, aq);\n+\t\telse\n+\t\t  {\n+\t\t    size_t num_mappings = 0;\n+\t\t    /* If the target_mem_desc represents a single data mapping,\n+\t\t       we can check that it is freed when this splay tree key's\n+\t\t       refcount reaches zero.  Otherwise (e.g. for a\n+\t\t       'GOMP_MAP_STRUCT' mapping with multiple members), fall\n+\t\t       back to skipping the test.  */\n+\t\t    for (size_t l_i = 0; l_i < n->tgt->list_count; ++l_i)\n+\t\t      if (n->tgt->list[l_i].key)\n+\t\t\t++num_mappings;\n+\t\t    bool is_tgt_unmapped = gomp_remove_var (acc_dev, n);\n+\t\t    assert (is_tgt_unmapped || num_mappings > 1);\n+\t\t  }\n+\t      }\n \t  }\n \t  break;\n \n@@ -1177,7 +1207,29 @@ goacc_exit_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t\t\t     && str->refcount != REFCOUNT_INFINITY)\n \t\t      str->refcount--;\n \t\t    if (str->refcount == 0)\n-\t\t      gomp_remove_var_async (acc_dev, str, aq);\n+\t\t      {\n+\t\t\tif (aq)\n+\t\t\t  /* TODO We can't do the 'is_tgt_unmapped' checking --\n+\t\t\t     see the 'gomp_unref_tgt' comment in\n+\t\t\t     <http://mid.mail-archive.com/878snl36eu.fsf@euler.schwinge.homeip.net>;\n+\t\t\t     PR92881.  */\n+\t\t\t  gomp_remove_var_async (acc_dev, str, aq);\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    size_t num_mappings = 0;\n+\t\t\t    /* If the target_mem_desc represents a single data\n+\t\t\t       mapping, we can check that it is freed when this\n+\t\t\t       splay tree key's refcount reaches zero.\n+\t\t\t       Otherwise (e.g. for a 'GOMP_MAP_STRUCT' mapping\n+\t\t\t       with multiple members), fall back to skipping\n+\t\t\t       the test.  */\n+\t\t\t    for (size_t l_i = 0; l_i < str->tgt->list_count; ++l_i)\n+\t\t\t      if (str->tgt->list[l_i].key)\n+\t\t\t\t++num_mappings;\n+\t\t\t    bool is_tgt_unmapped = gomp_remove_var (acc_dev, str);\n+\t\t\t    assert (is_tgt_unmapped || num_mappings > 1);\n+\t\t\t  }\n+\t\t      }\n \t\t  }\n \t      }\n \t    i += elems;"}, {"sha": "bde5890d6676bdbeb4b0cc8962fecb7986385e5c", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/struct-refcount-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fstruct-refcount-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fstruct-refcount-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fstruct-refcount-1.c?ref=06ec61726d192659cd446e59a91e78745037f0fd", "patch": "@@ -0,0 +1,47 @@\n+/* Test dynamic unmapping of separate structure members.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#include <assert.h>\n+#include <stdbool.h>\n+#include <openacc.h>\n+\n+struct s\n+{\n+  char a;\n+  float b;\n+};\n+\n+void test (bool use_directives)\n+{\n+  struct s s;\n+\n+#pragma acc enter data create(s.a, s.b)\n+  assert (acc_is_present (&s.a, sizeof s.a));\n+  assert (acc_is_present (&s.b, sizeof s.b));\n+\n+  if (use_directives)\n+    {\n+#pragma acc exit data delete(s.a)\n+    }\n+  else\n+    acc_delete (&s.a, sizeof s.a);\n+  assert (!acc_is_present (&s.a, sizeof s.a));\n+  assert (acc_is_present (&s.b, sizeof s.b));\n+  if (use_directives)\n+    {\n+#pragma acc exit data delete(s.b)\n+    }\n+  else\n+    acc_delete (&s.b, sizeof s.b);\n+  assert (!acc_is_present (&s.a, sizeof s.a));\n+  assert (!acc_is_present (&s.b, sizeof s.b));\n+}\n+\n+int main ()\n+{\n+  test (true);\n+  test (false);\n+\n+  return 0;\n+}"}, {"sha": "5837a4039106045ed43dbf1c26ec09f94e03b29c", "filename": "libgomp/testsuite/libgomp.oacc-fortran/deep-copy-6.f90", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6.f90?ref=06ec61726d192659cd446e59a91e78745037f0fd", "patch": "@@ -40,19 +40,20 @@ program dtype\n   if (.not. acc_is_present(var%a(5:n - 5))) stop 11\n   if (.not. acc_is_present(var%b(5:n - 5))) stop 12\n   if (.not. acc_is_present(var)) stop 13\n-!$acc exit data copyout(var%a(5:n - 5), var%b(5:n - 5)) finalize\n-  if (acc_get_device_type() .ne. acc_device_host) then\n-     if (acc_is_present(var%a(5:n - 5))) stop 21\n-     if (acc_is_present(var%b(5:n - 5))) stop 22\n-  end if\n   print *, \"CheCKpOInT1\"\n   ! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n-  if (.not. acc_is_present(var)) stop 23\n-  !TODO { dg-output \"STOP 23(\\n|\\r\\n|\\r)$\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n+!$acc exit data copyout(var%a(5:n - 5), var%b(5:n - 5)) finalize\n+  !TODO     goacc_exit_data_internal: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n+  !TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n   !TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n   !TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n   print *, \"CheCKpOInT2\"\n   ! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n+  if (acc_get_device_type() .ne. acc_device_host) then\n+     if (acc_is_present(var%a(5:n - 5))) stop 21\n+     if (acc_is_present(var%b(5:n - 5))) stop 22\n+  end if\n+  if (.not. acc_is_present(var)) stop 23\n \n !$acc end data\n "}, {"sha": "445cbabb8ca4a0ddfdbebb6638ea86341561d631", "filename": "libgomp/testsuite/libgomp.oacc-fortran/mdc-refcount-1-1-1.f90", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-1-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-1-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-1-1.f90?ref=06ec61726d192659cd446e59a91e78745037f0fd", "patch": "@@ -21,16 +21,17 @@ program main\n   if (.not. acc_is_present(var%a)) stop 1\n   if (.not. acc_is_present(var)) stop 2\n \n-  !$acc exit data delete(var%a) finalize\n-  if (acc_is_present(var%a)) stop 3\n   print *, \"CheCKpOInT1\"\n   ! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n-  if (.not. acc_is_present(var)) stop 4\n-  !TODO { dg-output \"STOP 4(\\n|\\r\\n|\\r)$\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n+  !$acc exit data delete(var%a) finalize\n+  !TODO     goacc_exit_data_internal: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n+  !TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n   !TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n   !TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n   print *, \"CheCKpOInT2\"\n   ! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n+  if (acc_is_present(var%a)) stop 3\n+  if (.not. acc_is_present(var)) stop 4\n \n   !$acc end data\n   if (acc_is_present(var%a)) stop 5"}, {"sha": "8554534b2f271cc48565f9beeaf48238bcf1fb38", "filename": "libgomp/testsuite/libgomp.oacc-fortran/mdc-refcount-1-2-1.f90", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-2-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-2-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-2-1.f90?ref=06ec61726d192659cd446e59a91e78745037f0fd", "patch": "@@ -23,16 +23,17 @@ program main\n   if (.not. acc_is_present(var%a)) stop 1\n   if (.not. acc_is_present(var)) stop 2\n \n-  !$acc exit data delete(var%a) finalize\n-  if (acc_is_present(var%a)) stop 3\n   print *, \"CheCKpOInT1\"\n   ! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n-  if (.not. acc_is_present(var)) stop 4\n-  !TODO { dg-output \"STOP 4(\\n|\\r\\n|\\r)$\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n+  !$acc exit data delete(var%a) finalize\n+  !TODO     goacc_exit_data_internal: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n+  !TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n   !TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n   !TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n   print *, \"CheCKpOInT2\"\n   ! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n+  if (acc_is_present(var%a)) stop 3\n+  if (.not. acc_is_present(var)) stop 4\n \n   !$acc end data\n   if (acc_is_present(var%a)) stop 5"}, {"sha": "8e696cc70e80881ca94b6edf77b4ce2ee6103a9d", "filename": "libgomp/testsuite/libgomp.oacc-fortran/mdc-refcount-1-2-2.f90", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-2-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-2-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-2-2.f90?ref=06ec61726d192659cd446e59a91e78745037f0fd", "patch": "@@ -23,16 +23,17 @@ program main\n   if (.not. acc_is_present(var%a)) stop 1\n   if (.not. acc_is_present(var)) stop 2\n \n-  !$acc exit data delete(var%a)\n-  if (acc_is_present(var%a)) stop 3\n   print *, \"CheCKpOInT1\"\n   ! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n-  if (.not. acc_is_present(var)) stop 4\n-  !TODO { dg-output \"STOP 4(\\n|\\r\\n|\\r)$\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n+  !$acc exit data delete(var%a)\n+  !TODO     goacc_exit_data_internal: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n+  !TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n   !TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n   !TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n   print *, \"CheCKpOInT2\"\n   ! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n+  if (acc_is_present(var%a)) stop 3\n+  if (.not. acc_is_present(var)) stop 4\n \n   !$acc end data\n   if (acc_is_present(var%a)) stop 5"}, {"sha": "070a6f8e1493fbe8772a92c6d858b61502715f21", "filename": "libgomp/testsuite/libgomp.oacc-fortran/mdc-refcount-1-3-1.f90", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-3-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-3-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-3-1.f90?ref=06ec61726d192659cd446e59a91e78745037f0fd", "patch": "@@ -24,16 +24,17 @@ program main\n   if (.not. acc_is_present(var)) stop 2\n \n   !$acc exit data detach(var%a)\n-  !$acc exit data delete(var%a) finalize\n-  if (acc_is_present(var%a)) stop 3\n   print *, \"CheCKpOInT1\"\n   ! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n-  if (.not. acc_is_present(var)) stop 4\n-  !TODO { dg-output \"STOP 4(\\n|\\r\\n|\\r)$\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n+  !$acc exit data delete(var%a) finalize\n+  !TODO     goacc_exit_data_internal: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n+  !TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n   !TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n   !TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n   print *, \"CheCKpOInT2\"\n   ! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n+  if (acc_is_present(var%a)) stop 3\n+  if (.not. acc_is_present(var)) stop 4\n \n   !$acc end data\n   if (acc_is_present(var%a)) stop 5"}, {"sha": "b22e411567ffb9a649624e32afb92001a52bf8ae", "filename": "libgomp/testsuite/libgomp.oacc-fortran/mdc-refcount-1-4-1.f90", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-4-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec61726d192659cd446e59a91e78745037f0fd/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-4-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-4-1.f90?ref=06ec61726d192659cd446e59a91e78745037f0fd", "patch": "@@ -23,15 +23,16 @@ program main\n   if (.not. acc_is_present(var%a)) stop 1\n   if (.not. acc_is_present(var)) stop 2\n \n-  !$acc exit data detach(var%a) finalize\n   print *, \"CheCKpOInT1\"\n   ! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n-  !$acc exit data delete(var%a)\n-  !TODO { dg-output \"(\\n|\\r\\n|\\r)libgomp: struct not mapped for detach operation(\\n|\\r\\n|\\r)$\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n+  !$acc exit data detach(var%a) finalize\n+  !TODO     goacc_exit_data_internal: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n+  !TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n   !TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n   !TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n   print *, \"CheCKpOInT2\"\n   ! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n+  !$acc exit data delete(var%a)\n   if (acc_is_present(var%a)) stop 3\n   if (.not. acc_is_present(var)) stop 4\n "}]}