{"sha": "18df6de934489a4ace9de466d596efb7f6ecf5b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThkZjZkZTkzNDQ4OWE0YWNlOWRlNDY2ZDU5NmVmYjdmNmVjZjViMA==", "commit": {"author": {"name": "David S. Miller", "email": "davem@nuts.davemloft.net", "date": "2004-07-09T22:59:32Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2004-07-09T22:59:32Z"}, "message": "sparc.h (processor_costs): Define.\n\n2004-07-02  David S. Miller  <davem@nuts.davemloft.net>\n\n\t* config/sparc/sparc.h (processor_costs): Define.\n\t(sparc_costs): Declare.\n\t* config/sparc/sparc.c (cypress_costs, supersparc_costs,\n\thypersparc_costs, sparclet_costs, ultrasparc_costs,\n\tultrasparc3_costs): New.\n\t(sparc_override_options): Set sparc_costs as appropriate.\n\t(sparc_rtx_costs): Use sparc_costs instead of messy\n\tconditionals.\n\nFrom-SVN: r84414", "tree": {"sha": "9b9c0d3ba55cbc78ce2f3096de48e1c4002e38d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b9c0d3ba55cbc78ce2f3096de48e1c4002e38d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18df6de934489a4ace9de466d596efb7f6ecf5b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18df6de934489a4ace9de466d596efb7f6ecf5b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18df6de934489a4ace9de466d596efb7f6ecf5b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18df6de934489a4ace9de466d596efb7f6ecf5b0/comments", "author": null, "committer": null, "parents": [{"sha": "a3e8d8b400125d422085e28d40c1960bf5dcb6b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3e8d8b400125d422085e28d40c1960bf5dcb6b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3e8d8b400125d422085e28d40c1960bf5dcb6b7"}], "stats": {"total": 709, "additions": 397, "deletions": 312}, "files": [{"sha": "43d21e3d50ad624a1bf31058b92eb70ea2cd3866", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18df6de934489a4ace9de466d596efb7f6ecf5b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18df6de934489a4ace9de466d596efb7f6ecf5b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18df6de934489a4ace9de466d596efb7f6ecf5b0", "patch": "@@ -1,3 +1,14 @@\n+2004-07-09  David S. Miller  <davem@nuts.davemloft.net>\n+\n+\t* config/sparc/sparc.h (processor_costs): Define.\n+\t(sparc_costs): Declare.\n+\t* config/sparc/sparc.c (cypress_costs, supersparc_costs,\n+\thypersparc_costs, sparclet_costs, ultrasparc_costs,\n+\tultrasparc3_costs): New.\n+\t(sparc_override_options): Set sparc_costs as appropriate.\n+\t(sparc_rtx_costs): Use sparc_costs instead of messy\n+\tconditionals.\n+\t\n 2004-07-09  Steven Bosscher  <stevenb@suse.de>\n \n \t* doc/md.texi (Processor pipeline description): Mention that"}, {"sha": "ef9e33798a68a3532379d8819cccbc4e993dab74", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 308, "deletions": 312, "changes": 620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18df6de934489a4ace9de466d596efb7f6ecf5b0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18df6de934489a4ace9de466d596efb7f6ecf5b0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=18df6de934489a4ace9de466d596efb7f6ecf5b0", "patch": "@@ -49,6 +49,153 @@ Boston, MA 02111-1307, USA.  */\n #include \"cfglayout.h\"\n #include \"tree-gimple.h\"\n \n+/* Processor costs */\n+static const\n+struct processor_costs cypress_costs = {\n+  2, /* int load */\n+  2, /* int signed load */\n+  2, /* int zeroed load */\n+  2, /* float load */\n+  5, /* fmov, fneg, fabs */\n+  5, /* fadd, fsub */\n+  1, /* fcmp */\n+  1, /* fmov, fmovr */\n+  7, /* fmul */\n+  37, /* fdivs */\n+  37, /* fdivd */\n+  63, /* fsqrts */\n+  63, /* fsqrtd */\n+  1, /* imul */\n+  1, /* imulX */\n+  0, /* imul bit factor */\n+  1, /* idiv */\n+  1, /* idivX */\n+  1, /* movcc/movr */\n+  0, /* shift penalty */\n+};\n+\n+static const\n+struct processor_costs supersparc_costs = {\n+  1, /* int load */\n+  1, /* int signed load */\n+  1, /* int zeroed load */\n+  0, /* float load */\n+  3, /* fmov, fneg, fabs */\n+  3, /* fadd, fsub */\n+  3, /* fcmp */\n+  1, /* fmov, fmovr */\n+  3, /* fmul */\n+  6, /* fdivs */\n+  9, /* fdivd */\n+  12, /* fsqrts */\n+  12, /* fsqrtd */\n+  4, /* imul */\n+  4, /* imulX */\n+  0, /* imul bit factor */\n+  4, /* idiv */\n+  4, /* idivX */\n+  1, /* movcc/movr */\n+  1, /* shift penalty */\n+};\n+\n+static const\n+struct processor_costs hypersparc_costs = {\n+  1, /* int load */\n+  1, /* int signed load */\n+  1, /* int zeroed load */\n+  1, /* float load */\n+  1, /* fmov, fneg, fabs */\n+  1, /* fadd, fsub */\n+  1, /* fcmp */\n+  1, /* fmov, fmovr */\n+  1, /* fmul */\n+  8, /* fdivs */\n+  12, /* fdivd */\n+  17, /* fsqrts */\n+  17, /* fsqrtd */\n+  17, /* imul */\n+  17, /* imulX */\n+  0, /* imul bit factor */\n+  17, /* idiv */\n+  17, /* idivX */\n+  1, /* movcc/movr */\n+  0, /* shift penalty */\n+};\n+\n+static const\n+struct processor_costs sparclet_costs = {\n+  3, /* int load */\n+  3, /* int signed load */\n+  1, /* int zeroed load */\n+  1, /* float load */\n+  1, /* fmov, fneg, fabs */\n+  1, /* fadd, fsub */\n+  1, /* fcmp */\n+  1, /* fmov, fmovr */\n+  1, /* fmul */\n+  1, /* fdivs */\n+  1, /* fdivd */\n+  1, /* fsqrts */\n+  1, /* fsqrtd */\n+  5, /* imul */\n+  5, /* imulX */\n+  0, /* imul bit factor */\n+  5, /* idiv */\n+  5, /* idivX */\n+  1, /* movcc/movr */\n+  0, /* shift penalty */\n+};\n+\n+static const\n+struct processor_costs ultrasparc_costs = {\n+  2, /* int load */\n+  3, /* int signed load */\n+  2, /* int zeroed load */\n+  2, /* float load */\n+  1, /* fmov, fneg, fabs */\n+  4, /* fadd, fsub */\n+  1, /* fcmp */\n+  2, /* fmov, fmovr */\n+  4, /* fmul */\n+  13, /* fdivs */\n+  23, /* fdivd */\n+  13, /* fsqrts */\n+  23, /* fsqrtd */\n+  4, /* imul */\n+  4, /* imulX */\n+  2, /* imul bit factor */\n+  37, /* idiv */\n+  68, /* idivX */\n+  2, /* movcc/movr */\n+  2, /* shift penalty */\n+};\n+\n+static const\n+struct processor_costs ultrasparc3_costs = {\n+  2, /* int load */\n+  3, /* int signed load */\n+  3, /* int zeroed load */\n+  2, /* float load */\n+  3, /* fmov, fneg, fabs */\n+  4, /* fadd, fsub */\n+  5, /* fcmp */\n+  3, /* fmov, fmovr */\n+  4, /* fmul */\n+  17, /* fdivs */\n+  20, /* fdivd */\n+  20, /* fsqrts */\n+  29, /* fsqrtd */\n+  6, /* imul */\n+  6, /* imulX */\n+  0, /* imul bit factor */\n+  40, /* idiv */\n+  71, /* idivX */\n+  2, /* movcc/movr */\n+  0, /* shift penalty */\n+};\n+\n+const struct processor_costs *sparc_costs = &cypress_costs;\n+\n #ifdef HAVE_AS_RELAX_OPTION\n /* If 'as' and 'ld' are relaxing tail call insns into branch always, use\n    \"or %o7,%g0,X; call Y; or X,%g0,%o7\" always, so that it can be optimized.\n@@ -503,6 +650,36 @@ sparc_override_options (void)\n \n   /* Set up function hooks.  */\n   init_machine_status = sparc_init_machine_status;\n+\n+  switch (sparc_cpu)\n+    {\n+    case PROCESSOR_V7:\n+    case PROCESSOR_CYPRESS:\n+      sparc_costs = &cypress_costs;\n+      break;\n+    case PROCESSOR_V8:\n+    case PROCESSOR_SPARCLITE:\n+    case PROCESSOR_SUPERSPARC:\n+      sparc_costs = &supersparc_costs;\n+      break;\n+    case PROCESSOR_F930:\n+    case PROCESSOR_F934:\n+    case PROCESSOR_HYPERSPARC:\n+    case PROCESSOR_SPARCLITE86X:\n+      sparc_costs = &hypersparc_costs;\n+      break;\n+    case PROCESSOR_SPARCLET:\n+    case PROCESSOR_TSC701:\n+      sparc_costs = &sparclet_costs;\n+      break;\n+    case PROCESSOR_V9:\n+    case PROCESSOR_ULTRASPARC:\n+      sparc_costs = &ultrasparc_costs;\n+      break;\n+    case PROCESSOR_ULTRASPARC3:\n+      sparc_costs = &ultrasparc3_costs;\n+      break;\n+    };\n }\n \f\n /* Miscellaneous utilities.  */\n@@ -8071,362 +8248,181 @@ sparc_extra_constraint_check (rtx op, int c, int strict)\n static bool\n sparc_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n+  enum machine_mode mode = GET_MODE (x);\n+  bool float_mode_p = FLOAT_MODE_P (mode);\n+\n   switch (code)\n     {\n-    case PLUS: case MINUS: case ABS: case NEG:\n-    case FLOAT: case UNSIGNED_FLOAT:\n-    case FIX: case UNSIGNED_FIX:\n-    case FLOAT_EXTEND: case FLOAT_TRUNCATE:\n-      if (FLOAT_MODE_P (GET_MODE (x)))\n-\t{\n-\t  switch (sparc_cpu)\n-\t    {\n-\t    case PROCESSOR_ULTRASPARC:\n-\t    case PROCESSOR_ULTRASPARC3:\n-\t      *total = COSTS_N_INSNS (4);\n-\t      return true;\n-\n-\t    case PROCESSOR_SUPERSPARC:\n-\t      *total = COSTS_N_INSNS (3);\n-\t      return true;\n-\n-\t    case PROCESSOR_CYPRESS:\n-\t      *total = COSTS_N_INSNS (5);\n-\t      return true;\n-\n-\t    case PROCESSOR_HYPERSPARC:\n-\t    case PROCESSOR_SPARCLITE86X:\n-\t    default:\n-\t      *total = COSTS_N_INSNS (1);\n-\t      return true;\n-\t    }\n-\t}\n-\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case SQRT:\n-      switch (sparc_cpu)\n+    case CONST_INT:\n+      if (INTVAL (x) < 0x1000 && INTVAL (x) >= -0x1000)\n \t{\n-\tcase PROCESSOR_ULTRASPARC:\n-\t  if (GET_MODE (x) == SFmode)\n-\t    *total = COSTS_N_INSNS (13);\n-\t  else\n-\t    *total = COSTS_N_INSNS (23);\n-\t  return true;\n-\n-\tcase PROCESSOR_ULTRASPARC3:\n-\t  if (GET_MODE (x) == SFmode)\n-\t    *total = COSTS_N_INSNS (20);\n-\t  else\n-\t    *total = COSTS_N_INSNS (29);\n-\t  return true;\n-\n-\tcase PROCESSOR_SUPERSPARC:\n-\t  *total = COSTS_N_INSNS (12);\n-\t  return true;\n-\n-\tcase PROCESSOR_CYPRESS:\n-\t  *total = COSTS_N_INSNS (63);\n-\t  return true;\n-\n-\tcase PROCESSOR_HYPERSPARC:\n-\tcase PROCESSOR_SPARCLITE86X:\n-\t  *total = COSTS_N_INSNS (17);\n-\t  return true;\n-\n-\tdefault:\n-\t  *total = COSTS_N_INSNS (30);\n+\t  *total = 0;\n \t  return true;\n \t}\n+      /* FALLTHRU */\n \n-    case COMPARE:\n-      if (FLOAT_MODE_P (GET_MODE (x)))\n-\t{\n-\t  switch (sparc_cpu)\n-\t    {\n-\t    case PROCESSOR_ULTRASPARC:\n-\t    case PROCESSOR_ULTRASPARC3:\n-\t      *total = COSTS_N_INSNS (1);\n-\t      return true;\n-\n-\t    case PROCESSOR_SUPERSPARC:\n-\t      *total = COSTS_N_INSNS (3);\n-\t      return true;\n-\n-\t    case PROCESSOR_CYPRESS:\n-\t      *total = COSTS_N_INSNS (5);\n-\t      return true;\n-\n-\t    case PROCESSOR_HYPERSPARC:\n-\t    case PROCESSOR_SPARCLITE86X:\n-\t    default:\n-\t      *total = COSTS_N_INSNS (1);\n-\t      return true;\n-\t    }\n-\t}\n+    case HIGH:\n+      *total = 2;\n+      return true;\n \n-      /* ??? Maybe mark integer compares as zero cost on\n-\t ??? all UltraSPARC processors because the result\n-\t ??? can be bypassed to a branch in the same group.  */\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      *total = 4;\n+      return true;\n \n-      *total = COSTS_N_INSNS (1);\n+    case CONST_DOUBLE:\n+      if (GET_MODE (x) == DImode\n+\t  && ((XINT (x, 3) == 0\n+\t       && (unsigned HOST_WIDE_INT) XINT (x, 2) < 0x1000)\n+\t      || (XINT (x, 3) == -1\n+\t\t  && XINT (x, 2) < 0\n+\t\t  && XINT (x, 2) >= -0x1000)))\n+\t*total = 0;\n+      else\n+\t*total = 8;\n       return true;\n \n-    case MULT:\n-      if (FLOAT_MODE_P (GET_MODE (x)))\n+    case MEM:\n+      /* If outer-code was a sign or zero extension, a cost\n+\t of COSTS_N_INSNS (1) was already added in.  This is\n+\t why we are subtracting it back out.  */\n+      if (outer_code == ZERO_EXTEND)\n \t{\n-\t  switch (sparc_cpu)\n-\t    {\n-\t    case PROCESSOR_ULTRASPARC:\n-\t    case PROCESSOR_ULTRASPARC3:\n-\t      *total = COSTS_N_INSNS (4);\n-\t      return true;\n-\n-\t    case PROCESSOR_SUPERSPARC:\n-\t      *total = COSTS_N_INSNS (3);\n-\t      return true;\n-\n-\t    case PROCESSOR_CYPRESS:\n-\t      *total = COSTS_N_INSNS (7);\n-\t      return true;\n-\n-\t    case PROCESSOR_HYPERSPARC:\n-\t    case PROCESSOR_SPARCLITE86X:\n-\t      *total = COSTS_N_INSNS (1);\n-\t      return true;\n-\n-\t    default:\n-\t      *total = COSTS_N_INSNS (5);\n-\t      return true;\n-\t    }\n+\t  *total = sparc_costs->int_zload - COSTS_N_INSNS (1);\n \t}\n-\n-      /* The latency is actually variable for Ultra-I/II\n-\t And if one of the inputs have a known constant\n-\t value, we could calculate this precisely.\n-\n-\t However, for that to be useful we would need to\n-\t add some machine description changes which would\n-\t make sure small constants ended up in rs1 of the\n-\t multiply instruction.  This is because the multiply\n-\t latency is determined by the number of clear (or\n-\t set if the value is negative) bits starting from\n-\t the most significant bit of the first input.\n-\n-\t The algorithm for computing num_cycles of a multiply\n-\t on Ultra-I/II is:\n-\n-\t \tif (rs1 < 0)\n-\t\t\thighest_bit = highest_clear_bit(rs1);\n-\t\telse\n-\t\t\thighest_bit = highest_set_bit(rs1);\n-\t\tif (num_bits < 3)\n-\t\t\thighest_bit = 3;\n-\t\tnum_cycles = 4 + ((highest_bit - 3) / 2);\n-\n-\t If we did that we would have to also consider register\n-\t allocation issues that would result from forcing such\n-\t a value into a register.\n-\n-\t There are other similar tricks we could play if we\n-\t knew, for example, that one input was an array index.\n-\n-\t Since we do not play any such tricks currently the\n-\t safest thing to do is report the worst case latency.  */\n-      if (sparc_cpu == PROCESSOR_ULTRASPARC)\n+      else if (outer_code == SIGN_EXTEND)\n \t{\n-\t  *total = (GET_MODE (x) == DImode\n-\t\t    ? COSTS_N_INSNS (34) : COSTS_N_INSNS (19));\n-\t  return true;\n+\t  *total = sparc_costs->int_sload - COSTS_N_INSNS (1);\n \t}\n-\n-      /* Multiply latency on Ultra-III, fortunately, is constant.  */\n-      if (sparc_cpu == PROCESSOR_ULTRASPARC3)\n+      else if (float_mode_p)\n \t{\n-\t  *total = COSTS_N_INSNS (6);\n-\t  return true;\n+\t  *total = sparc_costs->float_load;\n \t}\n-\n-      if (sparc_cpu == PROCESSOR_HYPERSPARC\n-\t  || sparc_cpu == PROCESSOR_SPARCLITE86X)\n+      else\n \t{\n-\t  *total = COSTS_N_INSNS (17);\n-\t  return true;\n+\t  *total = sparc_costs->int_load;\n \t}\n \n-      *total = (TARGET_HARD_MUL ? COSTS_N_INSNS (5) : COSTS_N_INSNS (25));\n       return true;\n \n-    case DIV:\n-    case UDIV:\n-    case MOD:\n-    case UMOD:\n-      if (FLOAT_MODE_P (GET_MODE (x)))\n-\t{\n-\t  switch (sparc_cpu)\n-\t    {\n-\t    case PROCESSOR_ULTRASPARC:\n-\t      if (GET_MODE (x) == SFmode)\n-\t\t*total = COSTS_N_INSNS (13);\n-\t      else\n-\t\t*total = COSTS_N_INSNS (23);\n-\t      return true;\n+    case PLUS:\n+    case MINUS:\n+      if (float_mode_p)\n+\t*total = sparc_costs->float_plusminus;\n+      else\n+\t*total = COSTS_N_INSNS (1);\n+      return false;\n \n-\t    case PROCESSOR_ULTRASPARC3:\n-\t      if (GET_MODE (x) == SFmode)\n-\t\t*total = COSTS_N_INSNS (17);\n-\t      else\n-\t\t*total = COSTS_N_INSNS (20);\n-\t      return true;\n+    case MULT:\n+      if (float_mode_p)\n+\t*total = sparc_costs->float_mul;\n+      else\n+\t{\n+\t  int bit_cost;\n \n-\t    case PROCESSOR_SUPERSPARC:\n-\t      if (GET_MODE (x) == SFmode)\n-\t\t*total = COSTS_N_INSNS (6);\n-\t      else\n-\t\t*total = COSTS_N_INSNS (9);\n-\t      return true;\n+\t  bit_cost = 0;\n+\t  if (sparc_costs->int_mul_bit_factor)\n+\t    {\n+\t      int nbits;\n \n-\t    case PROCESSOR_HYPERSPARC:\n-\t    case PROCESSOR_SPARCLITE86X:\n-\t      if (GET_MODE (x) == SFmode)\n-\t\t*total = COSTS_N_INSNS (8);\n+\t      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t\t{\n+\t\t  unsigned HOST_WIDE_INT value = INTVAL (XEXP (x, 1));\n+\t\t  for (nbits = 0; value != 0; value &= value - 1)\n+\t\t    nbits++;\n+\t\t}\n+\t      else if (GET_CODE (XEXP (x, 1)) == CONST_DOUBLE\n+\t\t       && GET_MODE (XEXP (x, 1)) == DImode)\n+\t\t{\n+\t\t  rtx x1 = XEXP (x, 1);\n+\t\t  unsigned HOST_WIDE_INT value1 = XINT (x1, 2);\n+\t\t  unsigned HOST_WIDE_INT value2 = XINT (x1, 3);\n+\n+\t\t  for (nbits = 0; value1 != 0; value1 &= value1 - 1)\n+\t\t    nbits++;\n+\t\t  for (; value2 != 0; value2 &= value2 - 1)\n+\t\t    nbits++;\n+\t\t}\n \t      else\n-\t\t*total = COSTS_N_INSNS (12);\n-\t      return true;\n+\t\tnbits = 7;\n \n-\t    default:\n-\t      *total = COSTS_N_INSNS (7);\n-\t      return true;\n+\t      if (nbits < 3)\n+\t\tnbits = 3;\n+\t      bit_cost = (nbits - 3) / sparc_costs->int_mul_bit_factor;\n \t    }\n+\n+\t  if (mode == DImode)\n+\t    *total = COSTS_N_INSNS (sparc_costs->int_mulX) + bit_cost;\n+\t  else\n+\t    *total = COSTS_N_INSNS (sparc_costs->int_mul) + bit_cost;\n \t}\n+      return false;\n \n-      if (sparc_cpu == PROCESSOR_ULTRASPARC)\n-\t*total = (GET_MODE (x) == DImode\n-\t\t  ? COSTS_N_INSNS (68) : COSTS_N_INSNS (37));\n-      else if (sparc_cpu == PROCESSOR_ULTRASPARC3)\n-\t*total = (GET_MODE (x) == DImode\n-\t\t  ? COSTS_N_INSNS (71) : COSTS_N_INSNS (40));\n-      else\n-\t*total = COSTS_N_INSNS (25);\n-      return true;\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      *total = COSTS_N_INSNS (1) + sparc_costs->shift_penalty;\n+      return false;\n \n-    case IF_THEN_ELSE:\n-      /* Conditional moves.  */\n-      switch (sparc_cpu)\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      if (float_mode_p)\n \t{\n-\tcase PROCESSOR_ULTRASPARC:\n-\t  *total = COSTS_N_INSNS (2);\n-\t  return true;\n-\n-\tcase PROCESSOR_ULTRASPARC3:\n-\t  if (FLOAT_MODE_P (GET_MODE (x)))\n-\t    *total = COSTS_N_INSNS (3);\n+\t  if (mode == DFmode)\n+\t    *total = sparc_costs->float_div_df;\n \t  else\n-\t    *total = COSTS_N_INSNS (2);\n-\t  return true;\n-\n-\tdefault:\n-\t  *total = COSTS_N_INSNS (1);\n-\t  return true;\n+\t    *total = sparc_costs->float_div_sf;\n \t}\n-\n-    case MEM:\n-      /* If outer-code is SIGN/ZERO extension we have to subtract\n-\t out COSTS_N_INSNS (1) from whatever we return in determining\n-\t the cost.  */\n-      switch (sparc_cpu)\n+      else\n \t{\n-\tcase PROCESSOR_ULTRASPARC:\n-\t  if (outer_code == ZERO_EXTEND)\n-\t    *total = COSTS_N_INSNS (1);\n-\t  else\n-\t    *total = COSTS_N_INSNS (2);\n-\t  return true;\n-\n-\tcase PROCESSOR_ULTRASPARC3:\n-\t  if (outer_code == ZERO_EXTEND)\n-\t    {\n-\t      if (GET_MODE (x) == QImode\n-\t\t  || GET_MODE (x) == HImode\n-\t\t  || outer_code == SIGN_EXTEND)\n-\t\t*total = COSTS_N_INSNS (2);\n-\t      else\n-\t\t*total = COSTS_N_INSNS (1);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* This handles sign extension (3 cycles)\n-\t\t and everything else (2 cycles).  */\n-\t      *total = COSTS_N_INSNS (2);\n-\t    }\n-\t  return true;\n-\n-\tcase PROCESSOR_SUPERSPARC:\n-\t  if (FLOAT_MODE_P (GET_MODE (x))\n-\t      || outer_code == ZERO_EXTEND\n-\t      || outer_code == SIGN_EXTEND)\n-\t    *total = COSTS_N_INSNS (0);\n-\t  else\n-\t    *total = COSTS_N_INSNS (1);\n-\t  return true;\n-\n-\tcase PROCESSOR_TSC701:\n-\t  if (outer_code == ZERO_EXTEND\n-\t      || outer_code == SIGN_EXTEND)\n-\t    *total = COSTS_N_INSNS (2);\n+\t  if (mode == DImode)\n+\t    *total = sparc_costs->int_divX;\n \t  else\n-\t    *total = COSTS_N_INSNS (3);\n-\t  return true;\n-\t  \n-\tcase PROCESSOR_CYPRESS:\n-\t  if (outer_code == ZERO_EXTEND\n-\t      || outer_code == SIGN_EXTEND)\n-\t    *total = COSTS_N_INSNS (1);\n-\t  else\n-\t    *total = COSTS_N_INSNS (2);\n-\t  return true;\n-\t  \n-\tcase PROCESSOR_HYPERSPARC:\n-\tcase PROCESSOR_SPARCLITE86X:\n-\tdefault:\n-\t  if (outer_code == ZERO_EXTEND\n-\t      || outer_code == SIGN_EXTEND)\n-\t    *total = COSTS_N_INSNS (0);\n-\t  else\n-\t    *total = COSTS_N_INSNS (1);\n-\t  return true;\n+\t    *total = sparc_costs->int_div;\n \t}\n+      return false;\n \n-    case CONST_INT:\n-      if (INTVAL (x) < 0x1000 && INTVAL (x) >= -0x1000)\n+    case NEG:\n+      if (! float_mode_p)\n \t{\n-\t  *total = 0;\n-\t  return true;\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return false;\n \t}\n       /* FALLTHRU */\n \n-    case HIGH:\n-      *total = 2;\n-      return true;\n+    case ABS:\n+    case FLOAT:\n+    case UNSIGNED_FLOAT:\n+    case FIX:\n+    case UNSIGNED_FIX:\n+    case FLOAT_EXTEND:\n+    case FLOAT_TRUNCATE:\n+      *total = sparc_costs->float_move;\n+      return false;\n \n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      *total = 4;\n-      return true;\n+    case SQRT:\n+      if (mode == DFmode)\n+\t*total = sparc_costs->float_sqrt_df;\n+      else\n+\t*total = sparc_costs->float_sqrt_sf;\n+      return false;\n \n-    case CONST_DOUBLE:\n-      if (GET_MODE (x) == DImode\n-\t  && ((XINT (x, 3) == 0\n-\t       && (unsigned HOST_WIDE_INT) XINT (x, 2) < 0x1000)\n-\t      || (XINT (x, 3) == -1\n-\t\t  && XINT (x, 2) < 0\n-\t\t  && XINT (x, 2) >= -0x1000)))\n-\t*total = 0;\n+    case COMPARE:\n+      if (float_mode_p)\n+\t*total = sparc_costs->float_cmp;\n       else\n-\t*total = 8;\n-      return true;\n+\t*total = COSTS_N_INSNS (1);\n+      return false;\n+\n+    case IF_THEN_ELSE:\n+      if (float_mode_p)\n+\t*total = sparc_costs->float_cmove;\n+      else\n+\t*total = sparc_costs->int_cmove;\n+      return false;\n \n     default:\n       return false;"}, {"sha": "d0f75d2382f294222cfaa295d15c2f17ae21f4bb", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18df6de934489a4ace9de466d596efb7f6ecf5b0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18df6de934489a4ace9de466d596efb7f6ecf5b0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=18df6de934489a4ace9de466d596efb7f6ecf5b0", "patch": "@@ -25,6 +25,84 @@ Boston, MA 02111-1307, USA.  */\n /* Note that some other tm.h files include this one and then override\n    whatever definitions are necessary.  */\n \n+/* Define the specific costs for a given cpu */\n+\n+struct processor_costs {\n+  /* Integer load */\n+  const int int_load;\n+\n+  /* Integer signed load */\n+  const int int_sload;\n+\n+  /* Integer zeroed load */\n+  const int int_zload;\n+\n+  /* Float load */\n+  const int float_load;\n+\n+  /* fmov, fneg, fabs */\n+  const int float_move;\n+\n+  /* fadd, fsub */\n+  const int float_plusminus;\n+\n+  /* fcmp */\n+  const int float_cmp;\n+\n+  /* fmov, fmovr */\n+  const int float_cmove;\n+\n+  /* fmul */\n+  const int float_mul;\n+\n+  /* fdivs */\n+  const int float_div_sf;\n+\n+  /* fdivd */\n+  const int float_div_df;\n+\n+  /* fsqrts */\n+  const int float_sqrt_sf;\n+\n+  /* fsqrtd */\n+  const int float_sqrt_df;\n+\n+  /* umul/smul */\n+  const int int_mul;\n+\n+  /* mulX */\n+  const int int_mulX;\n+\n+  /* integer multiply cost for each bit set past the most\n+     significant 3, so the formula for multiply cost becomes:\n+\n+\tif (rs1 < 0)\n+\t  highest_bit = highest_clear_bit(rs1);\n+\telse\n+\t  highest_bit = highest_set_bit(rs1);\n+\tif (highest_bit < 3)\n+\t  highest_bit = 3;\n+\tcost = int_mul{,X} + ((highest_bit - 3) / int_mul_bit_factor);\n+\n+     A value of zero indicates that the multiply costs is fixed,\n+     and not variable.  */\n+  const int int_mul_bit_factor;\n+\n+  /* udiv/sdiv */\n+  const int int_div;\n+\n+  /* divX */\n+  const int int_divX;\n+\n+  /* movcc, movr */\n+  const int int_cmove;\n+\n+  /* penalty for shifts, due to scheduling rules etc. */\n+  const int shift_penalty;\n+};\n+\n+extern const struct processor_costs *sparc_costs;\n+\n /* Target CPU builtins.  FIXME: Defining sparc is for the benefit of\n    Solaris only; otherwise just define __sparc__.  Sadly the headers\n    are such a mess there is no Solaris-specific header.  */"}]}