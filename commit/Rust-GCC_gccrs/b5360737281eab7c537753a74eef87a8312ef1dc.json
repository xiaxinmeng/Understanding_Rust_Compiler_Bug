{"sha": "b5360737281eab7c537753a74eef87a8312ef1dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUzNjA3MzcyODFlYWI3YzUzNzc1M2E3NGVlZjg3YTgzMTJlZjFkYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T08:12:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T08:12:31Z"}, "message": "[multiple changes]\n\n2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb (Check_Expression_Function): Do not check for the\n\tuse of deferred constants if the freezing of the expression\n\tfunction is triggered by its generated body, rather than a\n\tpremature use.\n\n2017-04-25  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_attr.adb (Rewrite_Stream_Proc_Call): Handle\n\tsubtypes of private types when performing the view conversion.\n\n2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Freeze_Type): Signal the DIC body is created for\n\tthe purposes of freezing.\n\t* exp_util.adb Update the documentation and structure of the\n\ttype map used in class-wide semantics of assertion expressions.\n\t(Add_Inherited_Tagged_DIC): There is really no need to preanalyze\n\tand resolve the triaged expression because all substitutions\n\trefer to the proper entities.  Update the replacement of\n\treferences.\n\t(Build_DIC_Procedure_Body): Add formal parameter\n\tFor_Freeze. Add local variable Build_Body. Inherited DIC pragmas\n\tare now only processed when freezing occurs.  Build a body only\n\twhen one is needed.\n\t(Entity_Hash): Removed.\n\t(Map_Types): New routine.\n\t(Replace_Object_And_Primitive_References): Removed.\n\t(Replace_References): New routine.\n\t(Replace_Type_References): Moved to the library level of Exp_Util.\n\t(Type_Map_Hash): New routine.\n\t(Update_Primitives_Mapping): Update the mapping call.\n\t(Update_Primitives_Mapping_Of_Types): Removed.\n\t* exp_util.ads (Build_DIC_Procedure_Body): Add formal\n\tparameter For_Freeze and update the comment on usage.\n\t(Map_Types): New routine.\n\t(Replace_References): New routine.\n\t(Replace_Type_References): Moved to the library level of Exp_Util.\n\t(Update_Primitives_Mapping_Of_Types): Removed.\n\t* sem_ch7.adb (Preserve_Full_Attributes): Propagate the DIC\n\tproperties of the private type to the full view in case the full\n\tview derives from a parent type and inherits a DIC pragma.\n\t* sem_prag.adb (Analyze_Pragma): Guard against a case where a\n\tDIC pragma is placed at the top of a declarative region.\n\nFrom-SVN: r247141", "tree": {"sha": "2d1a1284c77348102a05004c5c0669b3c8f94ac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d1a1284c77348102a05004c5c0669b3c8f94ac4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5360737281eab7c537753a74eef87a8312ef1dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5360737281eab7c537753a74eef87a8312ef1dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5360737281eab7c537753a74eef87a8312ef1dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5360737281eab7c537753a74eef87a8312ef1dc/comments", "author": null, "committer": null, "parents": [{"sha": "a187206c1450fc02d7a466b372c073b67f41c26b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a187206c1450fc02d7a466b372c073b67f41c26b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a187206c1450fc02d7a466b372c073b67f41c26b"}], "stats": {"total": 1666, "additions": 1093, "deletions": 573}, "files": [{"sha": "5f109e192abf42ec0fe75d9c9b308ee9799bf68f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b5360737281eab7c537753a74eef87a8312ef1dc", "patch": "@@ -1,3 +1,49 @@\n+2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb (Check_Expression_Function): Do not check for the\n+\tuse of deferred constants if the freezing of the expression\n+\tfunction is triggered by its generated body, rather than a\n+\tpremature use.\n+\n+2017-04-25  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_attr.adb (Rewrite_Stream_Proc_Call): Handle\n+\tsubtypes of private types when performing the view conversion.\n+\n+2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Freeze_Type): Signal the DIC body is created for\n+\tthe purposes of freezing.\n+\t* exp_util.adb Update the documentation and structure of the\n+\ttype map used in class-wide semantics of assertion expressions.\n+\t(Add_Inherited_Tagged_DIC): There is really no need to preanalyze\n+\tand resolve the triaged expression because all substitutions\n+\trefer to the proper entities.  Update the replacement of\n+\treferences.\n+\t(Build_DIC_Procedure_Body): Add formal parameter\n+\tFor_Freeze. Add local variable Build_Body. Inherited DIC pragmas\n+\tare now only processed when freezing occurs.  Build a body only\n+\twhen one is needed.\n+\t(Entity_Hash): Removed.\n+\t(Map_Types): New routine.\n+\t(Replace_Object_And_Primitive_References): Removed.\n+\t(Replace_References): New routine.\n+\t(Replace_Type_References): Moved to the library level of Exp_Util.\n+\t(Type_Map_Hash): New routine.\n+\t(Update_Primitives_Mapping): Update the mapping call.\n+\t(Update_Primitives_Mapping_Of_Types): Removed.\n+\t* exp_util.ads (Build_DIC_Procedure_Body): Add formal\n+\tparameter For_Freeze and update the comment on usage.\n+\t(Map_Types): New routine.\n+\t(Replace_References): New routine.\n+\t(Replace_Type_References): Moved to the library level of Exp_Util.\n+\t(Update_Primitives_Mapping_Of_Types): Removed.\n+\t* sem_ch7.adb (Preserve_Full_Attributes): Propagate the DIC\n+\tproperties of the private type to the full view in case the full\n+\tview derives from a parent type and inherits a DIC pragma.\n+\t* sem_prag.adb (Analyze_Pragma): Guard against a case where a\n+\tDIC pragma is placed at the top of a declarative region.\n+\n 2017-04-25  Tristan Gingold  <gingold@adacore.com>\n \n \t* s-mmap.ads (Data): Add pragma Inline."}, {"sha": "6061f720517002fb21d7778b45aff9da3e421b7c", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=b5360737281eab7c537753a74eef87a8312ef1dc", "patch": "@@ -1650,8 +1650,8 @@ package body Exp_Attr is\n             --  Perform a view conversion when either the argument or the\n             --  formal parameter are of a private type.\n \n-            if Is_Private_Type (Formal_Typ)\n-              or else Is_Private_Type (Item_Typ)\n+            if Is_Private_Type (Base_Type (Formal_Typ))\n+              or else Is_Private_Type (Base_Type (Item_Typ))\n             then\n                Rewrite (Item,\n                  Unchecked_Convert_To (Formal_Typ, Relocate_Node (Item)));"}, {"sha": "d8258cc9564047547b8492e9cc0692cdf0728ff4", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=b5360737281eab7c537753a74eef87a8312ef1dc", "patch": "@@ -7509,7 +7509,7 @@ package body Exp_Ch3 is\n       --  verification of pragma Default_Initial_Condition's expression.\n \n       if Has_DIC (Def_Id) then\n-         Build_DIC_Procedure_Body (Def_Id);\n+         Build_DIC_Procedure_Body (Def_Id, For_Freeze => True);\n       end if;\n \n       --  Generate the [spec and] body of the invariant procedure tasked with"}, {"sha": "0b8ed616458277a05dcf0666e7ce55f99e5cef5a", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 976, "deletions": 562, "changes": 1538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=b5360737281eab7c537753a74eef87a8312ef1dc", "patch": "@@ -92,17 +92,27 @@ package body Exp_Util is\n    --  operations are mapped into the overriding operations of that current\n    --  type extension.\n \n-   Primitives_Mapping_Size : constant := 511;\n+   --  The contents of the map are as follows:\n \n-   subtype Num_Primitives is Integer range 0 .. Primitives_Mapping_Size - 1;\n-   function Entity_Hash (E : Entity_Id) return Num_Primitives;\n+   --    Key                                Value\n \n-   package Primitives_Mapping is new GNAT.HTable.Simple_HTable\n-     (Header_Num => Num_Primitives,\n+   --    Discriminant (Entity_Id)           Discriminant (Entity_Id)\n+   --    Discriminant (Entity_Id)           Non-discriminant name (Entity_Id)\n+   --    Discriminant (Entity_Id)           Expression (Node_Id)\n+   --    Primitive subprogram (Entity_Id)   Primitive subprogram (Entity_Id)\n+   --    Type (Entity_Id)                   Type (Entity_Id)\n+\n+   Type_Map_Size : constant := 511;\n+\n+   subtype Type_Map_Header is Integer range 0 .. Type_Map_Size - 1;\n+   function Type_Map_Hash (Id : Entity_Id) return Type_Map_Header;\n+\n+   package Type_Map is new GNAT.HTable.Simple_HTable\n+     (Header_Num => Type_Map_Header,\n       Key        => Entity_Id,\n-      Element    => Entity_Id,\n+      Element    => Node_Or_Entity_Id,\n       No_element => Empty,\n-      Hash       => Entity_Hash,\n+      Hash       => Type_Map_Hash,\n       Equal      => \"=\");\n \n    -----------------------\n@@ -1087,7 +1097,7 @@ package body Exp_Util is\n \n             --  Determine whether entity has a renaming\n \n-            New_E := Primitives_Mapping.Get (Entity (N));\n+            New_E := Type_Map.Get (Entity (N));\n \n             if Present (New_E) then\n                Rewrite (N, New_Occurrence_Of (New_E, Sloc (N)));\n@@ -1173,7 +1183,7 @@ package body Exp_Util is\n       Subp_Formal := First_Formal (Subp);\n \n       while Present (Par_Formal) and then Present (Subp_Formal) loop\n-         Primitives_Mapping.Set (Par_Formal, Subp_Formal);\n+         Type_Map.Set (Par_Formal, Subp_Formal);\n          Next_Formal (Par_Formal);\n          Next_Formal (Subp_Formal);\n       end loop;\n@@ -1211,7 +1221,10 @@ package body Exp_Util is\n    --  replaced by gotos which jump to the end of the routine and restore the\n    --  Ghost mode.\n \n-   procedure Build_DIC_Procedure_Body (Typ : Entity_Id) is\n+   procedure Build_DIC_Procedure_Body\n+     (Typ        : Entity_Id;\n+      For_Freeze : Boolean := False)\n+   is\n       procedure Add_DIC_Check\n         (DIC_Prag : Node_Id;\n          DIC_Expr : Node_Id;\n@@ -1250,34 +1263,6 @@ package body Exp_Util is\n       --  DIC_Prag. DIC_Typ is the owner of the DIC pragma. All generated code\n       --  is added to list Stmts.\n \n-      procedure Replace_Object_And_Primitive_References\n-        (Expr      : Node_Id;\n-         Par_Typ   : Entity_Id;\n-         Deriv_Typ : Entity_Id;\n-         Par_Obj   : Entity_Id := Empty;\n-         Deriv_Obj : Entity_Id := Empty);\n-      --  Expr denotes an arbitrary expression. Par_Typ is a parent type in a\n-      --  type hierarchy. Deriv_Typ is a type derived from Par_Typ. Par_Obj is\n-      --  the formal parameter which emulates the current instance of Par_Typ.\n-      --  Deriv_Obj is the formal parameter which emulates the current instance\n-      --  of Deriv_Typ. Perform the following substitutions:\n-      --\n-      --    * Replace a reference to Par_Obj with a reference to Deriv_Obj if\n-      --      applicable.\n-      --\n-      --    * Replace a call to an overridden parent primitive with a call to\n-      --      the overriding derived type primitive.\n-      --\n-      --    * Replace a call to an inherited parent primitive with a call to\n-      --      the internally-generated inherited derived type primitive.\n-\n-      procedure Replace_Type_References\n-        (Expr   : Node_Id;\n-         Typ    : Entity_Id;\n-         Obj_Id : Entity_Id);\n-      --  Substitute all references of the current instance of type Typ with\n-      --  references to formal parameter Obj_Id within expression Expr.\n-\n       -------------------\n       -- Add_DIC_Check --\n       -------------------\n@@ -1359,7 +1344,6 @@ package body Exp_Util is\n          Deriv_Typ : Entity_Id;\n          Stmts     : in out List_Id)\n       is\n-         Deriv_Decl : constant Node_Id   := Declaration_Node (Deriv_Typ);\n          Deriv_Proc : constant Entity_Id := DIC_Procedure (Deriv_Typ);\n          DIC_Args   : constant List_Id   :=\n                         Pragma_Argument_Associations (DIC_Prag);\n@@ -1384,6 +1368,9 @@ package body Exp_Util is\n          --      type's DIC procedure with a reference to the _object parameter\n          --      of the derived types' DIC procedure.\n \n+         --    * Replace a reference to a discriminant of the parent type with\n+         --      a suitable value from the point of view of the derived type.\n+\n          --    * Replace a call to an overridden parent primitive with a call\n          --      to the overriding derived type primitive.\n \n@@ -1396,19 +1383,13 @@ package body Exp_Util is\n \n          pragma Assert (Present (Deriv_Proc) and then Present (Par_Proc));\n \n-         Replace_Object_And_Primitive_References\n+         Replace_References\n            (Expr      => Expr,\n             Par_Typ   => Par_Typ,\n             Deriv_Typ => Deriv_Typ,\n             Par_Obj   => First_Formal (Par_Proc),\n             Deriv_Obj => First_Formal (Deriv_Proc));\n \n-         --  Preanalyze the DIC expression to detect errors and at the same\n-         --  time capture the visibility of the proper package part.\n-\n-         Set_Parent (Expr, Deriv_Decl);\n-         Preanalyze_Assert_Expression (Expr, Any_Boolean);\n-\n          --  Once the DIC assertion expression is fully processed, add a check\n          --  to the statements of the DIC procedure.\n \n@@ -1532,200 +1513,6 @@ package body Exp_Util is\n             Stmts    => Stmts);\n       end Add_Own_DIC;\n \n-      ---------------------------------------------\n-      -- Replace_Object_And_Primitive_References --\n-      ---------------------------------------------\n-\n-      procedure Replace_Object_And_Primitive_References\n-        (Expr      : Node_Id;\n-         Par_Typ   : Entity_Id;\n-         Deriv_Typ : Entity_Id;\n-         Par_Obj   : Entity_Id := Empty;\n-         Deriv_Obj : Entity_Id := Empty)\n-      is\n-         function Replace_Ref (Ref : Node_Id) return Traverse_Result;\n-         --  Substitute a reference to an entity with a reference to the\n-         --  corresponding entity stored in in table Primitives_Mapping.\n-\n-         -----------------\n-         -- Replace_Ref --\n-         -----------------\n-\n-         function Replace_Ref (Ref : Node_Id) return Traverse_Result is\n-            Context : constant Node_Id    := Parent (Ref);\n-            Loc     : constant Source_Ptr := Sloc (Ref);\n-            New_Id  : Entity_Id;\n-            New_Ref : Node_Id;\n-            Ref_Id  : Entity_Id;\n-            Result  : Traverse_Result;\n-\n-         begin\n-            Result := OK;\n-\n-            --  The current node denotes a reference\n-\n-            if Nkind (Ref) in N_Has_Entity and then Present (Entity (Ref)) then\n-               Ref_Id := Entity (Ref);\n-               New_Id := Primitives_Mapping.Get (Ref_Id);\n-\n-               --  The reference mentions a parent type primitive which has a\n-               --  corresponding derived type primitive.\n-\n-               if Present (New_Id) then\n-                  New_Ref := New_Occurrence_Of (New_Id, Loc);\n-\n-               --  The reference mentions the _object parameter of the parent\n-               --  type's DIC procedure.\n-\n-               elsif Present (Par_Obj)\n-                 and then Present (Deriv_Obj)\n-                 and then Ref_Id = Par_Obj\n-               then\n-                  New_Ref := New_Occurrence_Of (Deriv_Obj, Loc);\n-\n-                  --  The reference to _object acts as an actual parameter in a\n-                  --  subprogram call which may be invoking a primitive of the\n-                  --  parent type:\n-\n-                  --    Primitive (... _object ...);\n-\n-                  --  The parent type primitive may not be overridden nor\n-                  --  inherited when it is declared after the derived type\n-                  --  definition:\n-\n-                  --    type Parent is tagged private;\n-                  --    type Child is new Parent with private;\n-                  --    procedure Primitive (Obj : Parent);\n-\n-                  --  In this scenario the _object parameter is converted to\n-                  --  the parent type.\n-\n-                  if Nkind_In (Context, N_Function_Call,\n-                                        N_Procedure_Call_Statement)\n-                    and then\n-                      No (Primitives_Mapping.Get (Entity (Name (Context))))\n-                  then\n-                     New_Ref := Convert_To (Par_Typ, New_Ref);\n-\n-                     --  Do not process the generated type conversion because\n-                     --  both the parent type and the derived type are in the\n-                     --  Primitives_Mapping table. This will clobber the type\n-                     --  conversion by resetting its subtype mark.\n-\n-                     Result := Skip;\n-                  end if;\n-\n-               --  Otherwise there is nothing to replace\n-\n-               else\n-                  New_Ref := Empty;\n-               end if;\n-\n-               if Present (New_Ref) then\n-                  Rewrite (Ref, New_Ref);\n-\n-                  --  Update the return type when the context of the reference\n-                  --  acts as the name of a function call. Note that the update\n-                  --  should not be performed when the reference appears as an\n-                  --  actual in the call.\n-\n-                  if Nkind (Context) = N_Function_Call\n-                    and then Name (Context) = Ref\n-                  then\n-                     Set_Etype (Context, Etype (New_Id));\n-                  end if;\n-               end if;\n-            end if;\n-\n-            --  Reanalyze the reference due to potential replacements\n-\n-            if Nkind (Ref) in N_Has_Etype then\n-               Set_Analyzed (Ref, False);\n-            end if;\n-\n-            return Result;\n-         end Replace_Ref;\n-\n-         procedure Replace_Refs is new Traverse_Proc (Replace_Ref);\n-\n-      --  Start of processing for Replace_Object_And_Primitive_References\n-\n-      begin\n-         --  Map each primitive operation of the parent type to the proper\n-         --  primitive of the derived type.\n-\n-         Update_Primitives_Mapping_Of_Types\n-           (Par_Typ   => Par_Typ,\n-            Deriv_Typ => Deriv_Typ);\n-\n-         --  Inspect the input expression and perform substitutions where\n-         --  necessary.\n-\n-         Replace_Refs (Expr);\n-      end Replace_Object_And_Primitive_References;\n-\n-      -----------------------------\n-      -- Replace_Type_References --\n-      -----------------------------\n-\n-      procedure Replace_Type_References\n-        (Expr   : Node_Id;\n-         Typ    : Entity_Id;\n-         Obj_Id : Entity_Id)\n-      is\n-         procedure Replace_Type_Ref (N : Node_Id);\n-         --  Substitute a single reference of the current instance of type Typ\n-         --  with a reference to Obj_Id.\n-\n-         ----------------------\n-         -- Replace_Type_Ref --\n-         ----------------------\n-\n-         procedure Replace_Type_Ref (N : Node_Id) is\n-            Ref : Node_Id;\n-\n-         begin\n-            --  Decorate the reference to Typ even though it may be rewritten\n-            --  further down. This is done for two reasons:\n-\n-            --    1) ASIS has all necessary semantic information in the\n-            --    original tree.\n-\n-            --    2) Routines which examine properties of the Original_Node\n-            --    have some semantic information.\n-\n-            if Nkind (N) = N_Identifier then\n-               Set_Entity (N, Typ);\n-               Set_Etype  (N, Typ);\n-\n-            elsif Nkind (N) = N_Selected_Component then\n-               Analyze (Prefix (N));\n-               Set_Entity (Selector_Name (N), Typ);\n-               Set_Etype  (Selector_Name (N), Typ);\n-            end if;\n-\n-            --  Perform the following substitution:\n-\n-            --    Typ  -->  _object\n-\n-            Ref := Make_Identifier (Sloc (N), Chars (Obj_Id));\n-            Set_Entity (Ref, Obj_Id);\n-            Set_Etype  (Ref, Typ);\n-\n-            Rewrite (N, Ref);\n-\n-            Set_Comes_From_Source (N, True);\n-         end Replace_Type_Ref;\n-\n-         procedure Replace_Type_Refs is\n-           new Replace_Type_References_Generic (Replace_Type_Ref);\n-\n-      --  Start of processing for Replace_Type_References\n-\n-      begin\n-         Replace_Type_Refs (Expr, Typ);\n-      end Replace_Type_References;\n-\n       --  Local variables\n \n       Loc : constant Source_Ptr := Sloc (Typ);\n@@ -1741,6 +1528,9 @@ package body Exp_Util is\n       Proc_Id      : Entity_Id;\n       Stmts        : List_Id := No_List;\n \n+      Build_Body : Boolean := False;\n+      --  Flag set when the type requires a DIC procedure body to be built\n+\n       Work_Typ : Entity_Id;\n       --  The working type\n \n@@ -1855,9 +1645,18 @@ package body Exp_Util is\n             DIC_Typ  => DIC_Typ,\n             Stmts    => Stmts);\n \n-      --  Otherwise the working type inherits a DIC pragma from a parent type\n+         Build_Body := True;\n \n-      else\n+      --  Otherwise the working type inherits a DIC pragma from a parent type.\n+      --  This processing is carried out when the type is frozen because the\n+      --  state of all parent discriminants is known at that point. Note that\n+      --  it is semantically sound to delay the creation of the DIC procedure\n+      --  body till the freeze point. If the type has a DIC pragma of its own,\n+      --  then the DIC procedure body would have already been constructed at\n+      --  the end of the visible declarations and all parent DIC pragmas are\n+      --  effectively \"hidden\" and irrelevant.\n+\n+      elsif For_Freeze then\n          pragma Assert (Has_Inherited_DIC (Work_Typ));\n          pragma Assert (DIC_Typ /= Work_Typ);\n \n@@ -1883,66 +1682,71 @@ package body Exp_Util is\n                Deriv_Typ => Work_Typ,\n                Stmts     => Stmts);\n          end if;\n+\n+         Build_Body := True;\n       end if;\n \n       End_Scope;\n \n-      --  Produce an empty completing body in the following cases:\n-      --    * Assertions are disabled\n-      --    * The DIC Assertion_Policy is Ignore\n-      --    * Pragma DIC appears without an argument\n-      --    * Pragma DIC appears with argument \"null\"\n+      if Build_Body then\n \n-      if No (Stmts) then\n-         Stmts := New_List (Make_Null_Statement (Loc));\n-      end if;\n+         --  Produce an empty completing body in the following cases:\n+         --    * Assertions are disabled\n+         --    * The DIC Assertion_Policy is Ignore\n+         --    * Pragma DIC appears without an argument\n+         --    * Pragma DIC appears with argument \"null\"\n \n-      --  Generate:\n-      --    procedure <Work_Typ>DIC (_object : <Work_Typ>) is\n-      --    begin\n-      --       <Stmts>\n-      --    end <Work_Typ>DIC;\n+         if No (Stmts) then\n+            Stmts := New_List (Make_Null_Statement (Loc));\n+         end if;\n+\n+         --  Generate:\n+         --    procedure <Work_Typ>DIC (_object : <Work_Typ>) is\n+         --    begin\n+         --       <Stmts>\n+         --    end <Work_Typ>DIC;\n \n-      Proc_Body :=\n-        Make_Subprogram_Body (Loc,\n-          Specification                =>\n-            Copy_Subprogram_Spec (Parent (Proc_Id)),\n-          Declarations                 => Empty_List,\n-            Handled_Statement_Sequence =>\n-              Make_Handled_Sequence_Of_Statements (Loc,\n-                Statements => Stmts));\n-      Proc_Body_Id := Defining_Entity (Proc_Body);\n+         Proc_Body :=\n+           Make_Subprogram_Body (Loc,\n+             Specification                =>\n+               Copy_Subprogram_Spec (Parent (Proc_Id)),\n+             Declarations                 => Empty_List,\n+               Handled_Statement_Sequence =>\n+                 Make_Handled_Sequence_Of_Statements (Loc,\n+                   Statements => Stmts));\n+         Proc_Body_Id := Defining_Entity (Proc_Body);\n \n-      --  Perform minor decoration in case the body is not analyzed\n+         --  Perform minor decoration in case the body is not analyzed\n \n-      Set_Ekind (Proc_Body_Id, E_Subprogram_Body);\n-      Set_Etype (Proc_Body_Id, Standard_Void_Type);\n-      Set_Scope (Proc_Body_Id, Current_Scope);\n+         Set_Ekind (Proc_Body_Id, E_Subprogram_Body);\n+         Set_Etype (Proc_Body_Id, Standard_Void_Type);\n+         Set_Scope (Proc_Body_Id, Current_Scope);\n \n-      --  Link both spec and body to avoid generating duplicates\n+         --  Link both spec and body to avoid generating duplicates\n \n-      Set_Corresponding_Body (Proc_Decl, Proc_Body_Id);\n-      Set_Corresponding_Spec (Proc_Body, Proc_Id);\n+         Set_Corresponding_Body (Proc_Decl, Proc_Body_Id);\n+         Set_Corresponding_Spec (Proc_Body, Proc_Id);\n \n-      --  The body should not be inserted into the tree when the context is\n-      --  ASIS or a generic unit because it is not part of the template. Note\n-      --  that the body must still be generated in order to resolve the DIC\n-      --  assertion expression.\n+         --  The body should not be inserted into the tree when the context\n+         --  is ASIS or a generic unit because it is not part of the template.\n+         --  Note that the body must still be generated in order to resolve the\n+         --  DIC assertion expression.\n \n-      if ASIS_Mode or Inside_A_Generic then\n-         null;\n+         if ASIS_Mode or Inside_A_Generic then\n+            null;\n \n-      --  Semi-insert the body into the tree for GNATprove by setting its\n-      --  Parent field. This allows for proper upstream tree traversals.\n+         --  Semi-insert the body into the tree for GNATprove by setting its\n+         --  Parent field. This allows for proper upstream tree traversals.\n \n-      elsif GNATprove_Mode then\n-         Set_Parent (Proc_Body, Parent (Declaration_Node (Work_Typ)));\n+         elsif GNATprove_Mode then\n+            Set_Parent (Proc_Body, Parent (Declaration_Node (Work_Typ)));\n \n-      --  Otherwise the body is part of the freezing actions of the working\n-      --  type.\n+         --  Otherwise the body is part of the freezing actions of the working\n+         --  type.\n \n-      else\n-         Append_Freeze_Action (Work_Typ, Proc_Body);\n+         else\n+            Append_Freeze_Action (Work_Typ, Proc_Body);\n+         end if;\n       end if;\n \n    <<Leave>>\n@@ -3389,15 +3193,6 @@ package body Exp_Util is\n       end if;\n    end Ensure_Defined;\n \n-   -----------------\n-   -- Entity_Hash --\n-   -----------------\n-\n-   function Entity_Hash (E : Entity_Id) return Num_Primitives is\n-   begin\n-      return Num_Primitives (E mod Primitives_Mapping_Size);\n-   end Entity_Hash;\n-\n    --------------------\n    -- Entry_Names_OK --\n    --------------------\n@@ -8290,148 +8085,636 @@ package body Exp_Util is\n               Constraints => List_Constr));\n    end Make_Subtype_From_Expr;\n \n-   ----------------------------\n-   -- Matching_Standard_Type --\n-   ----------------------------\n+   ---------------\n+   -- Map_Types --\n+   ---------------\n \n-   function Matching_Standard_Type (Typ : Entity_Id) return Entity_Id is\n-      pragma Assert (Is_Scalar_Type (Typ));\n-      Siz : constant Uint := Esize (Typ);\n+   procedure Map_Types (Par_Typ : Entity_Id; Deriv_Typ : Entity_Id) is\n \n-   begin\n-      --  Floating-point cases\n+      --  Note: most of the routines in Map_Types are intentionally unnested to\n+      --  avoid deep indentation of code.\n \n-      if Is_Floating_Point_Type (Typ) then\n-         if Siz <= Esize (Standard_Short_Float) then\n-            return Standard_Short_Float;\n-         elsif Siz <= Esize (Standard_Float) then\n-            return Standard_Float;\n-         elsif Siz <= Esize (Standard_Long_Float) then\n-            return Standard_Long_Float;\n-         elsif Siz <= Esize (Standard_Long_Long_Float) then\n-            return Standard_Long_Long_Float;\n-         else\n-            raise Program_Error;\n-         end if;\n+      procedure Add_Primitive (Prim : Entity_Id);\n+      --  Subsidiary to Map_Primitives. Find a primitive in the inheritance or\n+      --  overriding chain starting from Prim whose dispatching type is parent\n+      --  type Par_Typ and add a mapping between the result and primitive Prim.\n+\n+      function Ancestor_Primitive (Subp : Entity_Id) return Entity_Id;\n+      --  Subsidiary to Map_Primitives. Return the next ancestor primitive in\n+      --  the inheritance or overriding chain of subprogram Subp. Return Empty\n+      --  if no such primitive is available.\n+\n+      function Build_Chain return Elist_Id;\n+      --  Subsidiary to Map_Discriminants. Recreate the derivation chain from\n+      --  parent type Par_Typ leading down towards derived type Deriv_Typ. The\n+      --  list has the form:\n+      --\n+      --    head                                              tail\n+      --    v                                                 v\n+      --    <Ancestor_N> -> <Ancestor_N-1> -> <Ancestor_1> -> Deriv_Typ\n+      --\n+      --  Note that Par_Typ is not part of the resulting derivation chain.\n+\n+      function Find_Discriminant_Value\n+        (Discr    : Entity_Id;\n+         Typ_Elmt : Elmt_Id) return Node_Or_Entity_Id;\n+      --  Subsidiary to Map_Discriminants. Find the value of discriminant Discr\n+      --  in the derivation chain starting from parent type Par_Typ leading to\n+      --  derived type Deriv_Typ. The returned value is one of the following:\n+      --\n+      --    * An entity which is either a discriminant or a non-discriminant\n+      --      name which renames/constraints Discr.\n+      --\n+      --    * An expression which constraints Discr\n+      --\n+      --  Typ_Elmt is an element of the derivation chain created by routine\n+      --  Build_Chain and denotes the current ancestor being examined.\n \n-      --  Integer cases (includes fixed-point types)\n+      procedure Map_Discriminants;\n+      --  Map each discriminant of type Par_Typ to a meaningful constraint from\n+      --  the point of view of type Deriv_Typ.\n \n-      --  Unsigned integer cases (includes normal enumeration types)\n+      procedure Map_Primitives;\n+      --  Map each primitive of type Par_Typ to a corresponding primitive of\n+      --  type Deriv_Typ.\n \n-      elsif Is_Unsigned_Type (Typ) then\n-         if Siz <= Esize (Standard_Short_Short_Unsigned) then\n-            return Standard_Short_Short_Unsigned;\n-         elsif Siz <= Esize (Standard_Short_Unsigned) then\n-            return Standard_Short_Unsigned;\n-         elsif Siz <= Esize (Standard_Unsigned) then\n-            return Standard_Unsigned;\n-         elsif Siz <= Esize (Standard_Long_Unsigned) then\n-            return Standard_Long_Unsigned;\n-         elsif Siz <= Esize (Standard_Long_Long_Unsigned) then\n-            return Standard_Long_Long_Unsigned;\n-         else\n-            raise Program_Error;\n-         end if;\n+      -------------------\n+      -- Add_Primitive --\n+      -------------------\n \n-      --  Signed integer cases\n+      procedure Add_Primitive (Prim : Entity_Id) is\n+         Par_Prim : Entity_Id;\n \n-      else\n-         if Siz <= Esize (Standard_Short_Short_Integer) then\n-            return Standard_Short_Short_Integer;\n-         elsif Siz <= Esize (Standard_Short_Integer) then\n-            return Standard_Short_Integer;\n-         elsif Siz <= Esize (Standard_Integer) then\n-            return Standard_Integer;\n-         elsif Siz <= Esize (Standard_Long_Integer) then\n-            return Standard_Long_Integer;\n-         elsif Siz <= Esize (Standard_Long_Long_Integer) then\n-            return Standard_Long_Long_Integer;\n-         else\n-            raise Program_Error;\n-         end if;\n-      end if;\n-   end Matching_Standard_Type;\n+      begin\n+         --  Inspect the inheritance chain through the Alias attribute and the\n+         --  overriding chain through the Overridden_Operation looking for an\n+         --  ancestor primitive with the appropriate dispatching type.\n \n-   -----------------------------\n-   -- May_Generate_Large_Temp --\n-   -----------------------------\n+         Par_Prim := Prim;\n+         while Present (Par_Prim) loop\n+            exit when Find_Dispatching_Type (Par_Prim) = Par_Typ;\n+            Par_Prim := Ancestor_Primitive (Par_Prim);\n+         end loop;\n \n-   --  At the current time, the only types that we return False for (i.e. where\n-   --  we decide we know they cannot generate large temps) are ones where we\n-   --  know the size is 256 bits or less at compile time, and we are still not\n-   --  doing a thorough job on arrays and records ???\n+         --  Create a mapping of the form:\n \n-   function May_Generate_Large_Temp (Typ : Entity_Id) return Boolean is\n-   begin\n-      if not Size_Known_At_Compile_Time (Typ) then\n-         return False;\n+         --    parent type primitive -> derived type primitive\n \n-      elsif Esize (Typ) /= 0 and then Esize (Typ) <= 256 then\n-         return False;\n+         if Present (Par_Prim) then\n+            Type_Map.Set (Par_Prim, Prim);\n+         end if;\n+      end Add_Primitive;\n \n-      elsif Is_Array_Type (Typ)\n-        and then Present (Packed_Array_Impl_Type (Typ))\n-      then\n-         return May_Generate_Large_Temp (Packed_Array_Impl_Type (Typ));\n+      ------------------------\n+      -- Ancestor_Primitive --\n+      ------------------------\n \n-      --  We could do more here to find other small types ???\n+      function Ancestor_Primitive (Subp : Entity_Id) return Entity_Id is\n+         Inher_Prim : constant Entity_Id := Alias (Subp);\n+         Over_Prim  : constant Entity_Id := Overridden_Operation (Subp);\n \n-      else\n-         return True;\n-      end if;\n-   end May_Generate_Large_Temp;\n+      begin\n+         --  The current subprogram overrides an ancestor primitive\n \n-   ------------------------\n-   -- Needs_Finalization --\n-   ------------------------\n+         if Present (Over_Prim) then\n+            return Over_Prim;\n \n-   function Needs_Finalization (T : Entity_Id) return Boolean is\n-      function Has_Some_Controlled_Component (Rec : Entity_Id) return Boolean;\n-      --  If type is not frozen yet, check explicitly among its components,\n-      --  because the Has_Controlled_Component flag is not necessarily set.\n+         --  The current subprogram is an internally generated alias of an\n+         --  inherited ancestor primitive.\n \n-      -----------------------------------\n-      -- Has_Some_Controlled_Component --\n-      -----------------------------------\n+         elsif Present (Inher_Prim) then\n+            return Inher_Prim;\n \n-      function Has_Some_Controlled_Component\n-        (Rec : Entity_Id) return Boolean\n-      is\n-         Comp : Entity_Id;\n+         --  Otherwise the current subprogram is the root of the inheritance or\n+         --  overriding chain.\n \n-      begin\n-         if Has_Controlled_Component (Rec) then\n-            return True;\n+         else\n+            return Empty;\n+         end if;\n+      end Ancestor_Primitive;\n \n-         elsif not Is_Frozen (Rec) then\n-            if Is_Record_Type (Rec) then\n-               Comp := First_Entity (Rec);\n+      -----------------\n+      -- Build_Chain --\n+      -----------------\n \n-               while Present (Comp) loop\n-                  if not Is_Type (Comp)\n-                    and then Needs_Finalization (Etype (Comp))\n-                  then\n-                     return True;\n-                  end if;\n+      function Build_Chain return Elist_Id is\n+         Anc_Typ  : Entity_Id;\n+         Chain    : Elist_Id;\n+         Curr_Typ : Entity_Id;\n \n-                  Next_Entity (Comp);\n-               end loop;\n+      begin\n+         Chain := New_Elmt_List;\n \n-               return False;\n+         --  Add the derived type to the derivation chain\n \n-            else\n-               return\n-                 Is_Array_Type (Rec)\n-                   and then Needs_Finalization (Component_Type (Rec));\n-            end if;\n-         else\n-            return False;\n-         end if;\n-      end Has_Some_Controlled_Component;\n+         Prepend_Elmt (Deriv_Typ, Chain);\n \n-   --  Start of processing for Needs_Finalization\n+         --  Examine all ancestors starting from the derived type climbing\n+         --  towards parent type Par_Typ.\n \n-   begin\n+         Curr_Typ := Deriv_Typ;\n+         loop\n+            Anc_Typ := Base_Type (Etype (Curr_Typ));\n+\n+            --  Stop the climb when either the parent type has been reached or\n+            --  there are no more ancestors left to examine.\n+\n+            exit when Anc_Typ = Curr_Typ or else Anc_Typ = Par_Typ;\n+\n+            --  Add the current ancestor to the derivation chain\n+\n+            Prepend_Elmt (Anc_Typ, Chain);\n+            Curr_Typ := Anc_Typ;\n+         end loop;\n+\n+         return Chain;\n+      end Build_Chain;\n+\n+      -----------------------------\n+      -- Find_Discriminant_Value --\n+      -----------------------------\n+\n+      function Find_Discriminant_Value\n+        (Discr    : Entity_Id;\n+         Typ_Elmt : Elmt_Id) return Node_Or_Entity_Id\n+      is\n+         Discr_Pos : constant Uint      := Discriminant_Number (Discr);\n+         Typ       : constant Entity_Id := Node (Typ_Elmt);\n+\n+         function Find_Constraint_Value\n+           (Constr : Node_Or_Entity_Id) return Node_Or_Entity_Id;\n+         --  Given constraint Constr, find what it denotes. This is either:\n+         --\n+         --    * An entity which is either a discriminant or a name\n+         --\n+         --    * An expression\n+\n+         ---------------------------\n+         -- Find_Constraint_Value --\n+         ---------------------------\n+\n+         function Find_Constraint_Value\n+           (Constr : Node_Or_Entity_Id) return Node_Or_Entity_Id\n+         is\n+         begin\n+            if Nkind (Constr) in N_Entity then\n+\n+               --  The constraint denotes a discriminant of the current type\n+               --  which renames the ancestor discriminant:\n+\n+               --              vv\n+               --    type Typ (D1 : ...; DN : ...) is\n+               --      new Anc (Discr => D1) with ...\n+               --                        ^^\n+\n+               if Ekind (Constr) = E_Discriminant then\n+\n+                  --  The discriminant belongs to derived type Deriv_Typ. This\n+                  --  is the final value for the ancestor discriminant as the\n+                  --  derivations chain has been fully exhausted.\n+\n+                  if Typ = Deriv_Typ then\n+                     return Constr;\n+\n+                  --  Otherwise the discriminant may be renamed or constrained\n+                  --  at a lower level. Continue looking down the derivation\n+                  --  chain.\n+\n+                  else\n+                     return\n+                       Find_Discriminant_Value\n+                         (Discr    => Constr,\n+                          Typ_Elmt => Next_Elmt (Typ_Elmt));\n+                  end if;\n+\n+               --  Otherwise the constraint denotes a reference to some name\n+               --  which results in a Girder discriminant:\n+\n+               --    vvvv\n+               --    Name : ...;\n+               --    type Typ (D1 : ...; DN : ...) is\n+               --      new Anc (Discr => Name) with ...\n+               --                        ^^^^\n+\n+               --  Return the name as this is the proper constraint of the\n+               --  discriminant.\n+\n+               else\n+                  return Constr;\n+               end if;\n+\n+            --  The constraint denotes a reference to a name\n+\n+            elsif Is_Entity_Name (Constr) then\n+               return Find_Constraint_Value (Entity (Constr));\n+\n+            --  Otherwise the current constraint is an expression which yields\n+            --  a Girder discriminant:\n+\n+            --    type Typ (D1 : ...; DN : ...) is\n+            --      new Anc (Discr => <expression>) with ...\n+            --                         ^^^^^^^^^^\n+\n+            --  Return the expression as this is the proper constraint of the\n+            --  discriminant.\n+\n+            else\n+               return Constr;\n+            end if;\n+         end Find_Constraint_Value;\n+\n+         --  Local variables\n+\n+         Constrs : constant Elist_Id := Stored_Constraint (Typ);\n+\n+         Constr_Elmt : Elmt_Id;\n+         Pos         : Uint;\n+         Typ_Discr   : Entity_Id;\n+\n+      --  Start of processing for Find_Discriminant_Value\n+\n+      begin\n+         --  The algorithm for finding the value of a discriminant works as\n+         --  follows. First, it recreates the derivation chain from Par_Typ\n+         --  to Deriv_Typ as a list:\n+\n+         --     Par_Typ      (shown for completeness)\n+         --        v\n+         --    Ancestor_N  <-- head of chain\n+         --        v\n+         --    Ancestor_1\n+         --        v\n+         --    Deriv_Typ   <--  tail of chain\n+\n+         --  The algorithm then traces the fate of a parent discriminant down\n+         --  the derivation chain. At each derivation level, the discriminant\n+         --  may be either inherited or constrained.\n+\n+         --    1) Discriminant is inherited: there are two cases, depending on\n+         --    which type is inheriting.\n+\n+         --    1.1) Deriv_Typ is inheriting:\n+\n+         --      type Ancestor (D_1 : ...) is tagged ...\n+         --      type Deriv_Typ is new Ancestor ...\n+\n+         --    In this case the inherited discriminant is the final value of\n+         --    the parent discriminant because the end of the derivation chain\n+         --    has been reached.\n+\n+         --    1.2) Some other type is inheriting:\n+\n+         --      type Ancestor_1 (D_1 : ...) is tagged ...\n+         --      type Ancestor_2 is new Ancestor_1 ...\n+\n+         --    In this case the algorithm continues to trace the fate of the\n+         --    inherited discriminant down the derivation chain because it may\n+         --    be further inherited or constrained.\n+\n+         --    2) Discriminant is constrained: there are three cases, depending\n+         --    on what the constraint is.\n+\n+         --    2.1) The constraint is another discriminant (aka renaming):\n+\n+         --      type Ancestor_1 (D_1 : ...) is tagged ...\n+         --      type Ancestor_2 (D_2 : ...) is new Ancestor_1 (D_1 => D_2) ...\n+\n+         --    In this case the constraining discriminant becomes the one to\n+         --    track down the derivation chain. The algorithm already knows\n+         --    that D_2 constrains D_1, therefore if the algorithm finds the\n+         --    value of D_2, then this would also be the value for D_1.\n+\n+         --    2.2) The constraint is a name (aka Girder):\n+\n+         --      Name : ...\n+         --      type Ancestor_1 (D_1 : ...) is tagged ...\n+         --      type Ancestor_2 is new Ancestor_1 (D_1 => Name) ...\n+\n+         --    In this case the name is the final value of D_1 because the\n+         --    discriminant cannot be further constrained.\n+\n+         --    2.3) The constraint is an expression (aka Girder):\n+\n+         --      type Ancestor_1 (D_1 : ...) is tagged ...\n+         --      type Ancestor_2 is new Ancestor_1 (D_1 => 1 + 2) ...\n+\n+         --    Similar to 2.2, the expression is the final value of D_1\n+\n+         Pos := Uint_1;\n+\n+         --  When a derived type constrains its parent type, all constaints\n+         --  appear in the Stored_Constraint list. Examine the list looking\n+         --  for a positional match.\n+\n+         if Present (Constrs) then\n+            Constr_Elmt := First_Elmt (Constrs);\n+            while Present (Constr_Elmt) loop\n+\n+               --  The position of the current constraint matches that of the\n+               --  ancestor discriminant.\n+\n+               if Pos = Discr_Pos then\n+                  return Find_Constraint_Value (Node (Constr_Elmt));\n+               end if;\n+\n+               Next_Elmt (Constr_Elmt);\n+               Pos := Pos + 1;\n+            end loop;\n+\n+         --  Otherwise the derived type does not constraint its parent type in\n+         --  which case it inherits the parent discriminants.\n+\n+         else\n+            Typ_Discr := First_Discriminant (Typ);\n+            while Present (Typ_Discr) loop\n+\n+               --  The position of the current discriminant matches that of the\n+               --  ancestor discriminant.\n+\n+               if Pos = Discr_Pos then\n+                  return Find_Constraint_Value (Typ_Discr);\n+               end if;\n+\n+               Next_Discriminant (Typ_Discr);\n+               Pos := Pos + 1;\n+            end loop;\n+         end if;\n+\n+         --  A discriminant must always have a corresponding value. This is\n+         --  either another discriminant, a name, or an expression.\n+\n+         pragma Assert (False);\n+\n+         return Empty;\n+      end Find_Discriminant_Value;\n+\n+      -----------------------\n+      -- Map_Discriminants --\n+      -----------------------\n+\n+      procedure Map_Discriminants is\n+         Deriv_Chain : constant Elist_Id := Build_Chain;\n+\n+         Discr     : Entity_Id;\n+         Discr_Val : Node_Or_Entity_Id;\n+\n+      begin\n+         --  Examine each discriminant of parent type Par_Typ and find a proper\n+         --  value for it from the point of view of derived type Deriv_Typ.\n+\n+         if Has_Discriminants (Par_Typ) then\n+            Discr := First_Discriminant (Par_Typ);\n+            while Present (Discr) loop\n+               Discr_Val :=\n+                 Find_Discriminant_Value\n+                   (Discr    => Discr,\n+                    Typ_Elmt => First_Elmt (Deriv_Chain));\n+\n+               --  Create a mapping of the form:\n+\n+               --    parent type discriminant -> value\n+\n+               Type_Map.Set (Discr, Discr_Val);\n+\n+               Next_Discriminant (Discr);\n+            end loop;\n+         end if;\n+      end Map_Discriminants;\n+\n+      --------------------\n+      -- Map_Primitives --\n+      --------------------\n+\n+      procedure Map_Primitives is\n+         Deriv_Prim : Entity_Id;\n+         Par_Prim   : Entity_Id;\n+         Par_Prims  : Elist_Id;\n+         Prim_Elmt  : Elmt_Id;\n+\n+      begin\n+         --  Inspect the primitives of the derived type and determine whether\n+         --  they relate to the primitives of the parent type. If there is a\n+         --  meaningful relation, create a mapping of the form:\n+\n+         --    parent type primitive -> derived type primitive\n+\n+         if Present (Direct_Primitive_Operations (Deriv_Typ)) then\n+            Prim_Elmt := First_Elmt (Direct_Primitive_Operations (Deriv_Typ));\n+            while Present (Prim_Elmt) loop\n+               Deriv_Prim := Node (Prim_Elmt);\n+\n+               if Is_Subprogram (Deriv_Prim)\n+                 and then Find_Dispatching_Type (Deriv_Prim) = Deriv_Typ\n+               then\n+                  Add_Primitive (Deriv_Prim);\n+               end if;\n+\n+               Next_Elmt (Prim_Elmt);\n+            end loop;\n+         end if;\n+\n+         --  If the parent operation is an interface operation, the overriding\n+         --  indicator is not present. Instead, we get from the interface\n+         --  operation the primitive of the current type that implements it.\n+\n+         if Is_Interface (Par_Typ) then\n+            Par_Prims := Collect_Primitive_Operations (Par_Typ);\n+\n+            if Present (Par_Prims) then\n+               Prim_Elmt := First_Elmt (Par_Prims);\n+\n+               while Present (Prim_Elmt) loop\n+                  Par_Prim   := Node (Prim_Elmt);\n+                  Deriv_Prim :=\n+                    Find_Primitive_Covering_Interface (Deriv_Typ, Par_Prim);\n+\n+                  if Present (Deriv_Prim) then\n+                     Type_Map.Set (Par_Prim, Deriv_Prim);\n+                  end if;\n+\n+                  Next_Elmt (Prim_Elmt);\n+               end loop;\n+            end if;\n+         end if;\n+      end Map_Primitives;\n+\n+   --  Start of processing for Map_Types\n+\n+   begin\n+      --  Nothing to do if there are no types to work with\n+\n+      if No (Par_Typ) or else No (Deriv_Typ) then\n+         return;\n+\n+      --  Nothing to do if the mapping already exists\n+\n+      elsif Type_Map.Get (Par_Typ) = Deriv_Typ then\n+         return;\n+\n+      --  Nothing to do if both types are not tagged. Note that untagged types\n+      --  do not have primitive operations and their discriminants are already\n+      --  handled by gigi.\n+\n+      elsif not Is_Tagged_Type (Par_Typ)\n+        or else not Is_Tagged_Type (Deriv_Typ)\n+      then\n+         return;\n+      end if;\n+\n+      --  Create a mapping of the form:\n+\n+      --    parent type -> derived type\n+\n+      --  to prevent any subsequent attempts to produce the same relations.\n+\n+      Type_Map.Set (Par_Typ, Deriv_Typ);\n+\n+      Map_Discriminants;\n+      Map_Primitives;\n+   end Map_Types;\n+\n+   ----------------------------\n+   -- Matching_Standard_Type --\n+   ----------------------------\n+\n+   function Matching_Standard_Type (Typ : Entity_Id) return Entity_Id is\n+      pragma Assert (Is_Scalar_Type (Typ));\n+      Siz : constant Uint := Esize (Typ);\n+\n+   begin\n+      --  Floating-point cases\n+\n+      if Is_Floating_Point_Type (Typ) then\n+         if Siz <= Esize (Standard_Short_Float) then\n+            return Standard_Short_Float;\n+         elsif Siz <= Esize (Standard_Float) then\n+            return Standard_Float;\n+         elsif Siz <= Esize (Standard_Long_Float) then\n+            return Standard_Long_Float;\n+         elsif Siz <= Esize (Standard_Long_Long_Float) then\n+            return Standard_Long_Long_Float;\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Integer cases (includes fixed-point types)\n+\n+      --  Unsigned integer cases (includes normal enumeration types)\n+\n+      elsif Is_Unsigned_Type (Typ) then\n+         if Siz <= Esize (Standard_Short_Short_Unsigned) then\n+            return Standard_Short_Short_Unsigned;\n+         elsif Siz <= Esize (Standard_Short_Unsigned) then\n+            return Standard_Short_Unsigned;\n+         elsif Siz <= Esize (Standard_Unsigned) then\n+            return Standard_Unsigned;\n+         elsif Siz <= Esize (Standard_Long_Unsigned) then\n+            return Standard_Long_Unsigned;\n+         elsif Siz <= Esize (Standard_Long_Long_Unsigned) then\n+            return Standard_Long_Long_Unsigned;\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Signed integer cases\n+\n+      else\n+         if Siz <= Esize (Standard_Short_Short_Integer) then\n+            return Standard_Short_Short_Integer;\n+         elsif Siz <= Esize (Standard_Short_Integer) then\n+            return Standard_Short_Integer;\n+         elsif Siz <= Esize (Standard_Integer) then\n+            return Standard_Integer;\n+         elsif Siz <= Esize (Standard_Long_Integer) then\n+            return Standard_Long_Integer;\n+         elsif Siz <= Esize (Standard_Long_Long_Integer) then\n+            return Standard_Long_Long_Integer;\n+         else\n+            raise Program_Error;\n+         end if;\n+      end if;\n+   end Matching_Standard_Type;\n+\n+   -----------------------------\n+   -- May_Generate_Large_Temp --\n+   -----------------------------\n+\n+   --  At the current time, the only types that we return False for (i.e. where\n+   --  we decide we know they cannot generate large temps) are ones where we\n+   --  know the size is 256 bits or less at compile time, and we are still not\n+   --  doing a thorough job on arrays and records ???\n+\n+   function May_Generate_Large_Temp (Typ : Entity_Id) return Boolean is\n+   begin\n+      if not Size_Known_At_Compile_Time (Typ) then\n+         return False;\n+\n+      elsif Esize (Typ) /= 0 and then Esize (Typ) <= 256 then\n+         return False;\n+\n+      elsif Is_Array_Type (Typ)\n+        and then Present (Packed_Array_Impl_Type (Typ))\n+      then\n+         return May_Generate_Large_Temp (Packed_Array_Impl_Type (Typ));\n+\n+      --  We could do more here to find other small types ???\n+\n+      else\n+         return True;\n+      end if;\n+   end May_Generate_Large_Temp;\n+\n+   ------------------------\n+   -- Needs_Finalization --\n+   ------------------------\n+\n+   function Needs_Finalization (T : Entity_Id) return Boolean is\n+      function Has_Some_Controlled_Component (Rec : Entity_Id) return Boolean;\n+      --  If type is not frozen yet, check explicitly among its components,\n+      --  because the Has_Controlled_Component flag is not necessarily set.\n+\n+      -----------------------------------\n+      -- Has_Some_Controlled_Component --\n+      -----------------------------------\n+\n+      function Has_Some_Controlled_Component\n+        (Rec : Entity_Id) return Boolean\n+      is\n+         Comp : Entity_Id;\n+\n+      begin\n+         if Has_Controlled_Component (Rec) then\n+            return True;\n+\n+         elsif not Is_Frozen (Rec) then\n+            if Is_Record_Type (Rec) then\n+               Comp := First_Entity (Rec);\n+\n+               while Present (Comp) loop\n+                  if not Is_Type (Comp)\n+                    and then Needs_Finalization (Etype (Comp))\n+                  then\n+                     return True;\n+                  end if;\n+\n+                  Next_Entity (Comp);\n+               end loop;\n+\n+               return False;\n+\n+            else\n+               return\n+                 Is_Array_Type (Rec)\n+                   and then Needs_Finalization (Component_Type (Rec));\n+            end if;\n+         else\n+            return False;\n+         end if;\n+      end Has_Some_Controlled_Component;\n+\n+   --  Start of processing for Needs_Finalization\n+\n+   begin\n       --  Certain run-time configurations and targets do not provide support\n       --  for controlled types.\n \n@@ -9522,6 +9805,280 @@ package body Exp_Util is\n       Scope_Suppress := Svg_Suppress;\n    end Remove_Side_Effects;\n \n+   ------------------------\n+   -- Replace_References --\n+   ------------------------\n+\n+   procedure Replace_References\n+     (Expr      : Node_Id;\n+      Par_Typ   : Entity_Id;\n+      Deriv_Typ : Entity_Id;\n+      Par_Obj   : Entity_Id := Empty;\n+      Deriv_Obj : Entity_Id := Empty)\n+   is\n+      function Is_Deriv_Obj_Ref (Ref : Node_Id) return Boolean;\n+      --  Determine whether node Ref denotes some component of Deriv_Obj\n+\n+      function Replace_Ref (Ref : Node_Id) return Traverse_Result;\n+      --  Substitute a reference to an entity with the corresponding value\n+      --  stored in table Type_Map.\n+\n+      ----------------------\n+      -- Is_Deriv_Obj_Ref --\n+      ----------------------\n+\n+      function Is_Deriv_Obj_Ref (Ref : Node_Id) return Boolean is\n+         Par : constant Node_Id := Parent (Ref);\n+\n+      begin\n+         --  Detect the folowing selected component form:\n+\n+         --    Deriv_Obj.(something)\n+\n+         return\n+           Nkind (Par) = N_Selected_Component\n+             and then Is_Entity_Name (Prefix (Par))\n+             and then Entity (Prefix (Par)) = Deriv_Obj;\n+      end Is_Deriv_Obj_Ref;\n+\n+      -----------------\n+      -- Replace_Ref --\n+      -----------------\n+\n+      function Replace_Ref (Ref : Node_Id) return Traverse_Result is\n+         Context : constant Node_Id    := Parent (Ref);\n+         Loc     : constant Source_Ptr := Sloc (Ref);\n+         Ref_Id  : Entity_Id;\n+         Result  : Traverse_Result;\n+\n+         New_Ref : Node_Id;\n+         --  The new reference which is intended to substitute the old one\n+\n+         Old_Ref : Node_Id;\n+         --  The reference designated for replacement. In certain cases this\n+         --  may be a node other than Ref.\n+\n+         Val : Node_Or_Entity_Id;\n+         --  The corresponding value of Ref from the type map\n+\n+      begin\n+         --  Assume that the input reference is to be replaced and that the\n+         --  traversal should examine the children of the reference.\n+\n+         Old_Ref := Ref;\n+         Result  := OK;\n+\n+         --  The input denotes a meaningful reference\n+\n+         if Nkind (Ref) in N_Has_Entity and then Present (Entity (Ref)) then\n+            Ref_Id := Entity (Ref);\n+            Val    := Type_Map.Get (Ref_Id);\n+\n+            --  The reference has a corresponding value in the type map, a\n+            --  substitution is possible.\n+\n+            if Present (Val) then\n+\n+               --  The reference denotes a discriminant\n+\n+               if Ekind (Ref_Id) = E_Discriminant then\n+                  if Nkind (Val) in N_Entity then\n+\n+                     --  The value denotes another discriminant. Replace as\n+                     --  follows:\n+\n+                     --    _object.Discr -> _object.Val\n+\n+                     if Ekind (Val) = E_Discriminant then\n+                        New_Ref := New_Occurrence_Of (Val, Loc);\n+\n+                     --  Otherwise the value denotes the entity of a name which\n+                     --  constraints the discriminant. Replace as follows:\n+\n+                     --    _object.Discr -> Val\n+\n+                     else\n+                        pragma Assert (Is_Deriv_Obj_Ref (Old_Ref));\n+\n+                        New_Ref := New_Occurrence_Of (Val, Loc);\n+                        Old_Ref := Parent (Old_Ref);\n+                     end if;\n+\n+                  --  Otherwise the value denotes an arbitrary expression which\n+                  --  constraints the discriminant. Replace as follows:\n+\n+                  --    _object.Discr -> Val\n+\n+                  else\n+                     pragma Assert (Is_Deriv_Obj_Ref (Old_Ref));\n+\n+                     New_Ref := New_Copy_Tree (Val);\n+                     Old_Ref := Parent (Old_Ref);\n+                  end if;\n+\n+               --  Otherwise the reference denotes a primitive. Replace as\n+               --  follows:\n+\n+               --    Primitive -> Val\n+\n+               else\n+                  pragma Assert (Nkind (Val) in N_Entity);\n+                  New_Ref := New_Occurrence_Of (Val, Loc);\n+               end if;\n+\n+            --  The reference mentions the _object parameter of the parent\n+            --  type's DIC procedure. Replace as follows:\n+\n+            --    _object -> _object\n+\n+            elsif Present (Par_Obj)\n+              and then Present (Deriv_Obj)\n+              and then Ref_Id = Par_Obj\n+            then\n+               New_Ref := New_Occurrence_Of (Deriv_Obj, Loc);\n+\n+               --  The reference to _object acts as an actual parameter in a\n+               --  subprogram call which may be invoking a primitive of the\n+               --  parent type:\n+\n+               --    Primitive (... _object ...);\n+\n+               --  The parent type primitive may not be overridden nor\n+               --  inherited when it is declared after the derived type\n+               --  definition:\n+\n+               --    type Parent is tagged private;\n+               --    type Child is new Parent with private;\n+               --    procedure Primitive (Obj : Parent);\n+\n+               --  In this scenario the _object parameter is converted to the\n+               --  parent type.\n+\n+               if Nkind_In (Context, N_Function_Call,\n+                                     N_Procedure_Call_Statement)\n+                 and then No (Type_Map.Get (Entity (Name (Context))))\n+               then\n+                  New_Ref := Convert_To (Par_Typ, New_Ref);\n+\n+                  --  Do not process the generated type conversion because\n+                  --  both the parent type and the derived type are in the\n+                  --  Type_Map table. This will clobber the type conversion\n+                  --  by resetting its subtype mark.\n+\n+                  Result := Skip;\n+               end if;\n+\n+            --  Otherwise there is nothing to replace\n+\n+            else\n+               New_Ref := Empty;\n+            end if;\n+\n+            if Present (New_Ref) then\n+               Rewrite (Old_Ref, New_Ref);\n+\n+               --  Update the return type when the context of the reference\n+               --  acts as the name of a function call. Note that the update\n+               --  should not be performed when the reference appears as an\n+               --  actual in the call.\n+\n+               if Nkind (Context) = N_Function_Call\n+                 and then Name (Context) = Old_Ref\n+               then\n+                  Set_Etype (Context, Etype (Val));\n+               end if;\n+            end if;\n+         end if;\n+\n+         --  Reanalyze the reference due to potential replacements\n+\n+         if Nkind (Old_Ref) in N_Has_Etype then\n+            Set_Analyzed (Old_Ref, False);\n+         end if;\n+\n+         return Result;\n+      end Replace_Ref;\n+\n+      procedure Replace_Refs is new Traverse_Proc (Replace_Ref);\n+\n+   --  Start of processing for Replace_References\n+\n+   begin\n+      --  Map the attributes of the parent type to the proper corresponding\n+      --  attributes of the derived type.\n+\n+      Map_Types\n+        (Par_Typ   => Par_Typ,\n+         Deriv_Typ => Deriv_Typ);\n+\n+      --  Inspect the input expression and perform substitutions where\n+      --  necessary.\n+\n+      Replace_Refs (Expr);\n+   end Replace_References;\n+\n+   -----------------------------\n+   -- Replace_Type_References --\n+   -----------------------------\n+\n+   procedure Replace_Type_References\n+     (Expr   : Node_Id;\n+      Typ    : Entity_Id;\n+      Obj_Id : Entity_Id)\n+   is\n+      procedure Replace_Type_Ref (N : Node_Id);\n+      --  Substitute a single reference of the current instance of type Typ\n+      --  with a reference to Obj_Id.\n+\n+      ----------------------\n+      -- Replace_Type_Ref --\n+      ----------------------\n+\n+      procedure Replace_Type_Ref (N : Node_Id) is\n+         Ref : Node_Id;\n+\n+      begin\n+         --  Decorate the reference to Typ even though it may be rewritten\n+         --  further down. This is done for two reasons:\n+\n+         --    * ASIS has all necessary semantic information in the original\n+         --      tree.\n+\n+         --    * Routines which examine properties of the Original_Node have\n+         --      some semantic information.\n+\n+         if Nkind (N) = N_Identifier then\n+            Set_Entity (N, Typ);\n+            Set_Etype  (N, Typ);\n+\n+         elsif Nkind (N) = N_Selected_Component then\n+            Analyze (Prefix (N));\n+            Set_Entity (Selector_Name (N), Typ);\n+            Set_Etype  (Selector_Name (N), Typ);\n+         end if;\n+\n+         --  Perform the following substitution:\n+\n+         --    Typ  ->  _object\n+\n+         Ref := Make_Identifier (Sloc (N), Chars (Obj_Id));\n+         Set_Entity (Ref, Obj_Id);\n+         Set_Etype  (Ref, Typ);\n+\n+         Rewrite (N, Ref);\n+\n+         Set_Comes_From_Source (N, True);\n+      end Replace_Type_Ref;\n+\n+      procedure Replace_Type_Refs is\n+        new Replace_Type_References_Generic (Replace_Type_Ref);\n+\n+   --  Start of processing for Replace_Type_References\n+\n+   begin\n+      Replace_Type_Refs (Expr, Typ);\n+   end Replace_Type_References;\n+\n    ---------------------------\n    -- Represented_As_Scalar --\n    ---------------------------\n@@ -10965,6 +11522,15 @@ package body Exp_Util is\n         and then Esize (Left_Typ) = Esize (Result_Typ);\n    end Target_Has_Fixed_Ops;\n \n+   -------------------\n+   -- Type_Map_Hash --\n+   -------------------\n+\n+   function Type_Map_Hash (Id : Entity_Id) return Type_Map_Header is\n+   begin\n+      return Type_Map_Header (Id mod Type_Map_Size);\n+   end Type_Map_Hash;\n+\n    ------------------------------------------\n    -- Type_May_Have_Bit_Aligned_Components --\n    ------------------------------------------\n@@ -11016,163 +11582,11 @@ package body Exp_Util is\n       Subp_Id  : Entity_Id)\n    is\n    begin\n-      Update_Primitives_Mapping_Of_Types\n+      Map_Types\n         (Par_Typ   => Find_Dispatching_Type (Inher_Id),\n          Deriv_Typ => Find_Dispatching_Type (Subp_Id));\n    end Update_Primitives_Mapping;\n \n-   ----------------------------------------\n-   -- Update_Primitives_Mapping_Of_Types --\n-   ----------------------------------------\n-\n-   procedure Update_Primitives_Mapping_Of_Types\n-     (Par_Typ   : Entity_Id;\n-      Deriv_Typ : Entity_Id)\n-   is\n-      procedure Add_Primitive (Prim : Entity_Id);\n-      --  Find a primitive in the inheritance/overriding chain starting from\n-      --  Prim whose dispatching type is parent type Par_Typ and add a mapping\n-      --  between the result and primitive Prim.\n-\n-      -------------------\n-      -- Add_Primitive --\n-      -------------------\n-\n-      procedure Add_Primitive (Prim : Entity_Id) is\n-         function Ancestor_Primitive (Subp : Entity_Id) return Entity_Id;\n-         --  Return the next ancestor primitive in the inheritance/overriding\n-         --  chain of subprogram Subp. Return Empty if no such primitive is\n-         --  available.\n-\n-         ------------------------\n-         -- Ancestor_Primitive --\n-         ------------------------\n-\n-         function Ancestor_Primitive (Subp : Entity_Id) return Entity_Id is\n-            Inher_Prim : constant Entity_Id := Alias (Subp);\n-            Over_Prim  : constant Entity_Id := Overridden_Operation (Subp);\n-\n-         begin\n-            --  The current subprogram overrides an ancestor primitive\n-\n-            if Present (Over_Prim) then\n-               return Over_Prim;\n-\n-            --  The current subprogram is an internally generated alias of an\n-            --  inherited ancestor primitive.\n-\n-            elsif Present (Inher_Prim) then\n-               return Inher_Prim;\n-\n-            --  Otherwise the current subprogram is the root of the inheritance\n-            --  or overriding chain.\n-\n-            else\n-               return Empty;\n-            end if;\n-         end Ancestor_Primitive;\n-\n-         --  Local variables\n-\n-         Par_Prim : Entity_Id;\n-\n-      --  Start of processing for Add_Primitive\n-\n-      begin\n-         --  Inspect both the inheritance chain through the Alias attribute and\n-         --  the overriding chain through the Overridden_Operation looking for\n-         --  an ancestor primitive with the appropriate dispatching type.\n-\n-         Par_Prim := Prim;\n-         while Present (Par_Prim) loop\n-            exit when Find_Dispatching_Type (Par_Prim) = Par_Typ;\n-            Par_Prim := Ancestor_Primitive (Par_Prim);\n-         end loop;\n-\n-         --  Create a mapping of the form:\n-\n-         --    Parent type primitive -> derived type primitive\n-\n-         if Present (Par_Prim) then\n-            Primitives_Mapping.Set (Par_Prim, Prim);\n-         end if;\n-      end Add_Primitive;\n-\n-      --  Local variables\n-\n-      Deriv_Prim : Entity_Id;\n-      Par_Prim   : Entity_Id;\n-      Par_Prims  : Elist_Id;\n-      Prim_Elmt  : Elmt_Id;\n-\n-   --  Start of processing for Update_Primitives_Mapping_Of_Types\n-\n-   begin\n-      --  Nothing to do if there are no types to work with\n-\n-      if No (Par_Typ) or else No (Deriv_Typ) then\n-         return;\n-\n-      --  Nothing to do if the mapping already exists\n-\n-      elsif Primitives_Mapping.Get (Par_Typ) = Deriv_Typ then\n-         return;\n-      end if;\n-\n-      --  Create a mapping of the form:\n-\n-      --    Parent type -> Derived type\n-\n-      --  to prevent any subsequent attempts to produce the same relations.\n-\n-      Primitives_Mapping.Set (Par_Typ, Deriv_Typ);\n-\n-      --  Inspect the primitives of the derived type and determine whether they\n-      --  relate to the primitives of the parent type. If there is a meaningful\n-      --  relation, create a mapping of the form:\n-\n-      --    Parent type primitive -> Derived type primitive\n-\n-      if Present (Direct_Primitive_Operations (Deriv_Typ)) then\n-         Prim_Elmt := First_Elmt (Direct_Primitive_Operations (Deriv_Typ));\n-         while Present (Prim_Elmt) loop\n-            Deriv_Prim := Node (Prim_Elmt);\n-\n-            if Is_Subprogram (Deriv_Prim)\n-              and then Find_Dispatching_Type (Deriv_Prim) = Deriv_Typ\n-            then\n-               Add_Primitive (Deriv_Prim);\n-            end if;\n-\n-            Next_Elmt (Prim_Elmt);\n-         end loop;\n-      end if;\n-\n-      --  If the parent operation is an interface operation, the overriding\n-      --  indicator is not present. Instead, we get from the interface\n-      --  operation the primitive of the current type that implements it.\n-\n-      if Is_Interface (Par_Typ) then\n-         Par_Prims := Collect_Primitive_Operations (Par_Typ);\n-\n-         if Present (Par_Prims) then\n-            Prim_Elmt := First_Elmt (Par_Prims);\n-\n-            while Present (Prim_Elmt) loop\n-               Par_Prim   := Node (Prim_Elmt);\n-               Deriv_Prim :=\n-                 Find_Primitive_Covering_Interface (Deriv_Typ, Par_Prim);\n-\n-               if Present (Deriv_Prim) then\n-                  Primitives_Mapping.Set (Par_Prim, Deriv_Prim);\n-               end if;\n-\n-               Next_Elmt (Prim_Elmt);\n-            end loop;\n-         end if;\n-      end if;\n-   end Update_Primitives_Mapping_Of_Types;\n-\n    ----------------------------------\n    -- Within_Case_Or_If_Expression --\n    ----------------------------------"}, {"sha": "cfb45fdb52b9203219a2cca59d3ae414274deeb4", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=b5360737281eab7c537753a74eef87a8312ef1dc", "patch": "@@ -278,9 +278,13 @@ package Exp_Util is\n    --  Build a call to the DIC procedure of type Typ with Obj_Id as the actual\n    --  parameter.\n \n-   procedure Build_DIC_Procedure_Body (Typ : Entity_Id);\n+   procedure Build_DIC_Procedure_Body\n+     (Typ        : Entity_Id;\n+      For_Freeze : Boolean := False);\n    --  Create the body of the procedure which verifies the assertion expression\n-   --  of pragma Default_Initial_Condition at run time.\n+   --  of pragma Default_Initial_Condition at run time. Flag For_Freeze should\n+   --  be set when the body is construction as part of the freezing actions for\n+   --  Typ.\n \n    procedure Build_DIC_Procedure_Declaration (Typ : Entity_Id);\n    --  Create the declaration of the procedure which verifies the assertion\n@@ -870,6 +874,19 @@ package Exp_Util is\n    --  wide type. Set Related_Id to request an external name for the subtype\n    --  rather than an internal temporary.\n \n+   procedure Map_Types (Par_Typ : Entity_Id; Deriv_Typ : Entity_Id);\n+   --  Establish the following mapping between the attributes of tagged parent\n+   --  type Par_Type and tagged derived type Deriv_Typ.\n+   --\n+   --    * Map each discriminant of type Par_Typ to the corresponding\n+   --      discriminant of type Deriv_Typ.\n+\n+   --    * Map each primitive operation of type Par_Typ to the corresponding\n+   --      primitive of type Deriv_Typ.\n+   --\n+   --  The mapping Par_Typ -> Deriv_Typ is also added to the table in order to\n+   --  prevent subsequent attempts of the same mapping.\n+\n    function Matching_Standard_Type (Typ : Entity_Id) return Entity_Id;\n    --  Given a scalar subtype Typ, returns a matching type in standard that\n    --  has the same object size value. For example, a 16 bit signed type will\n@@ -995,6 +1012,37 @@ package Exp_Util is\n    --  renaming cannot be elaborated without evaluating the subexpression, so\n    --  gigi would resort to method 1) or 3) under the hood for them.\n \n+   procedure Replace_References\n+     (Expr      : Node_Id;\n+      Par_Typ   : Entity_Id;\n+      Deriv_Typ : Entity_Id;\n+      Par_Obj   : Entity_Id := Empty;\n+      Deriv_Obj : Entity_Id := Empty);\n+   --  Expr denotes an arbitrary expression. Par_Typ is a tagged parent type\n+   --  in a type hierarchy. Deriv_Typ is a tagged type derived from Par_Typ\n+   --  with optional ancestors in between. Par_Obj is a formal parameter\n+   --  which emulates the current instance of Par_Typ. Deriv_Obj is a formal\n+   --  parameter which emulates the current instance of Deriv_Typ. Perform the\n+   --  following substitutions in Expr:\n+   --\n+   --    * Replace a reference to Par_Obj with a reference to Deriv_Obj\n+   --\n+   --    * Replace a reference to a discriminant of Par_Typ with a suitable\n+   --      value from the point of view of Deriv_Typ.\n+   --\n+   --    * Replace a call to an overridden primitive of Par_Typ with a call to\n+   --      an overriding primitive of Deriv_Typ.\n+   --\n+   --    * Replace a call to an inherited primitive of Par_Type with a call to\n+   --      the internally-generated inherited primitive of Deriv_Typ.\n+\n+   procedure Replace_Type_References\n+     (Expr   : Node_Id;\n+      Typ    : Entity_Id;\n+      Obj_Id : Entity_Id);\n+   --  Substitute all references of the current instance of type Typ with\n+   --  references to formal parameter Obj_Id within expression Expr.\n+\n    function Represented_As_Scalar (T : Entity_Id) return Boolean;\n    --  Returns True iff the implementation of this type in code generation\n    --  terms is scalar. This is true for scalars in the Ada sense, and for\n@@ -1103,12 +1151,6 @@ package Exp_Util is\n    --  when elaborating a contract for a subprogram, and when freezing a type\n    --  extension to verify legality rules on inherited conditions.\n \n-   procedure Update_Primitives_Mapping_Of_Types\n-     (Par_Typ   : Entity_Id;\n-      Deriv_Typ : Entity_Id);\n-   --  Map the primitive operations of parent type Par_Typ to the corresponding\n-   --  primitives of derived type Deriv_Typ.\n-\n    function Within_Case_Or_If_Expression (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N is within a case or an if expression\n "}, {"sha": "e5167519271a502998739b63c4ed879770e30a9f", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=b5360737281eab7c537753a74eef87a8312ef1dc", "patch": "@@ -1384,8 +1384,12 @@ package body Freeze is\n    begin\n       Decl := Original_Node (Unit_Declaration_Node (Nam));\n \n+      --  The subprogram body created for the expression function is not\n+      --  itself a freeze point.\n+\n       if Scope (Nam) = Current_Scope\n         and then Nkind (Decl) = N_Expression_Function\n+        and then Nkind (N) /= N_Subprogram_Body\n       then\n          Check_Deferred (Expression (Decl));\n       end if;"}, {"sha": "e5879dfabb663b91dad76125fd5edebd2fece679", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=b5360737281eab7c537753a74eef87a8312ef1dc", "patch": "@@ -2568,6 +2568,11 @@ package body Sem_Ch7 is\n          Propagate_DIC_Attributes (Full, From_Typ => Full_Base);\n          Propagate_DIC_Attributes (Full_Base, From_Typ => Full);\n \n+         --  Propagate Default_Initial_Condition-related attributes from the\n+         --  full view to the private view.\n+\n+         Propagate_DIC_Attributes (Priv, From_Typ => Full);\n+\n          --  Propagate invariant-related attributes from the base type of the\n          --  full view to the full view and vice versa. This may seem strange,\n          --  but is necessary depending on which type triggered the generation"}, {"sha": "81101b95419aedececa041cf4fca39e9d59b0532", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5360737281eab7c537753a74eef87a8312ef1dc/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b5360737281eab7c537753a74eef87a8312ef1dc", "patch": "@@ -13828,6 +13828,7 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_At_Most_N_Arguments (1);\n \n+            Typ  := Empty;\n             Stmt := Prev (N);\n             while Present (Stmt) loop\n \n@@ -13869,6 +13870,14 @@ package body Sem_Prag is\n                Stmt := Prev (Stmt);\n             end loop;\n \n+            --  The pragma does not apply to a legal construct, issue an error\n+            --  and stop the analysis.\n+\n+            if No (Typ) then\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n "}]}