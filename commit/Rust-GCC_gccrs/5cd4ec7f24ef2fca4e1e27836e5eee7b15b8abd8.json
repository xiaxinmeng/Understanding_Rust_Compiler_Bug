{"sha": "5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNkNGVjN2YyNGVmMmZjYTRlMWUyNzgzNmU1ZWVlN2IxNWI4YWJkOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-11-28T14:42:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-11-28T14:42:37Z"}, "message": "Privatize SSA variables into gimple_df.\n\n\t* tree-flow-inline.h\n\t(gimple_in_ssa_p, gimple_aliases_computed_p, gimple_addressable_vars,\n\tgimple_call_clobbered_vars, gimple_referenced_vars, gimple_global_var,\n\tgimple_nonlocal_all): New accessors.\n\t(first_referenced_var): Update.\n\t(mark_stmt_modified): Update.\n\t(is_call_clobbered): Update.\n\t(mark_call_clobbered): Update.\n\t(clear_call_clobbered): Update.\n\t(mark_non_addressable): Update.\n\t* tree-vrp.c (get_value_range): Update.\n\t* tree-into-ssa.c (in_ssa_p): Kill.\n\t(get_default_def_for): Update.\n\t(rewrite_into_ssa): Update.\n\t* tree-complex.c (init_parameter_lattice_values): Update.\n\t(update_complex_assignment): Update.\n\t(update_parameter_components): Update.\n\t(expand_complex_libcall): Update.\n\t(expand_complex_operations_1): Update.\n\t* tree-tailcall.c (arg_needs_copy_p): Update.\n\t(add_virtual_phis): Update.\n\t(tree_optimize_tail_calls_1): Update.\n\t* tree-ssa-dse.c (memory_ssa_name_same): Update.\n\t* tree-ssa-copyrename.c\n\t(copy_rename_partition_coalesce): Update.\n\t* tree-ssa-math-opts.c (execute_cse_reciprocals): Update.\n\t* tree-ssa-propagate.c (set_rhs): Update.\n\t* tree-ssa-alias.c (aliases_computed_p, call_clobbered_vars,\n\taddressable_vars, global_var):Kill.\n\t(set_initial_properties): Update.\n\t(init_alias_info): Update.\n\t(finalize_ref_all_pointers): Update.\n\t(setup_pointers_and_addressables): Update.\n\t(maybe_create_global_var): Update.\n\t(create_global_var): Update.\n\t(dump_points_to_info): Update.\n\t* function.h (struct gimple_df): Forward declare.\n\t(struct function): Add GIMPLE_DF field.\n\t* gimplify.c (force_gimple_operand): Update.\n\t* tree-dfa.c (referenced_vars, default_defs): KIll.\n\t(make_rename_temp): Update.\n\t(dump_variable): Update.\n\t(referenced_var_lookup): Update.\n\t(referenced_var_check_and_insert): Update.\n\t(default_def): Rename to ...\n\t(gimple_default_def): ... this one; accept cfun argument.\n\t(set_default_def): Update.\n\t* tree-cfgcleanup.c (modified_noreturn_calls): Kill.\n\t(cleanup_control_flow): Update.\n\t* tree-ssa-pre.c (compute_avail): Update\n\t* tree-ssa-live.c (calculate_live_on_entry): Update.\n\t* tree-ssa.c (verify_use): Update.\n\t(verify_call_clobbering): Update.\n\t(verify_call_clobbering): Update.\n\t(init_tree_ssa): Update.\n\t(delete_tree_ssa): Update.\n\t* tree-outof-ssa.c (coalesce_ssa_name): Update.\n\t(rewrite_out_of_ssa): Update.\n\t* tree-flow.h (gimple_df): New structure collecting dataflow variables.\n\t(FREE_SSANAMES, SSANAMES, MODIFIED_NORETURN_CALLS, DEFAULT_DEFS): New\n\tprivate accessors.\n\t(in_ssa_p, modified_noreturn_calls, referenced_vars, default_defs,\n\tssa_names, global_var, nonlocal_all, call_clobbered_vars,\n\taddressable_vars, aliases_computed_p): Kill.\n\t(default_def): Rename to...\n\t(gimple_default_def): ... this one.\n\t(defaule_def_fn): Kill.\n\t(num_referenced_vars, ssa_names, num_ssa_names): Update.\n\t* tree-ssa-structalias.c (nonlocal_all): Kill.\n\t(get_constraint_exp_from_ssa_var): Update.\n\t(create_nonlocal_var): Update.\n\t(get_constraint_for): Update.\n\t(update_alias_info): Update.\n\t(find_global_initializers): Update.\n\t(intra_create_variable_infos): Update.\n\t(intra_create_variable_infos):\n\t(find_what_p_points_to): Update.\n\t(init_alias_heapvars): Update.\n\t* tree-cfg.c (remove_bb): Update.\n\t(gimplify_val): Update.\n\t* tree-ssa-reassoc.c (get_rank): Update.\n\t(init_reassoc): Update.\n\t* tree-ssanames.c: Do not include gt-tree-ssanames.h\n\t(ssa_names, free_ssanames): Kill.\n\t(init_ssanames): Update.\n\t(make_ssa_name): Update.\n\t(release_ssa_name): Update.\n\t(release_defs): Update.\n\t(replace_ssa_name_symbol): Update.\n\t* tree-ssa-operands.c (access_can_touch_variable): Update.\n\t(add_virtual_operand): Update.\n\t(add_call_clobber_ops): Update.\n\t(add_call_read_ops): Update.\n\t(get_call_expr_operands): Update.\n\t(get_asm_expr_operands): Update.\n\nFrom-SVN: r119294", "tree": {"sha": "5e09813d89b6e045357e6ee37686e9b16cf2a1ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e09813d89b6e045357e6ee37686e9b16cf2a1ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/comments", "author": null, "committer": null, "parents": [{"sha": "3faa49284198625952a4420b889d5139710dab81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3faa49284198625952a4420b889d5139710dab81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3faa49284198625952a4420b889d5139710dab81"}], "stats": {"total": 626, "additions": 390, "deletions": 236}, "files": [{"sha": "5ec596685688e90fb8be627bc8b6defba35fb161", "filename": "gcc/ChangeLog", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -1,3 +1,102 @@\n+2006-11-28  Jan Hubicka  <jh@suse.cz>\n+\n+\tPrivatize SSA variables into gimple_df.\n+\t* tree-flow-inline.h\n+\t(gimple_in_ssa_p, gimple_aliases_computed_p, gimple_addressable_vars,\n+\tgimple_call_clobbered_vars, gimple_referenced_vars, gimple_global_var,\n+\tgimple_nonlocal_all): New accessors.\n+\t(first_referenced_var): Update.\n+\t(mark_stmt_modified): Update.\n+\t(is_call_clobbered): Update.\n+\t(mark_call_clobbered): Update.\n+\t(clear_call_clobbered): Update.\n+\t(mark_non_addressable): Update.\n+\t* tree-vrp.c (get_value_range): Update.\n+\t* tree-into-ssa.c (in_ssa_p): Kill.\n+\t(get_default_def_for): Update.\n+\t(rewrite_into_ssa): Update.\n+\t* tree-complex.c (init_parameter_lattice_values): Update.\n+\t(update_complex_assignment): Update.\n+\t(update_parameter_components): Update.\n+\t(expand_complex_libcall): Update.\n+\t(expand_complex_operations_1): Update.\n+\t* tree-tailcall.c (arg_needs_copy_p): Update.\n+\t(add_virtual_phis): Update.\n+\t(tree_optimize_tail_calls_1): Update.\n+\t* tree-ssa-dse.c (memory_ssa_name_same): Update.\n+\t* tree-ssa-copyrename.c\n+\t(copy_rename_partition_coalesce): Update.\n+\t* tree-ssa-math-opts.c (execute_cse_reciprocals): Update.\n+\t* tree-ssa-propagate.c (set_rhs): Update.\n+\t* tree-ssa-alias.c (aliases_computed_p, call_clobbered_vars,\n+\taddressable_vars, global_var):Kill.\n+\t(set_initial_properties): Update.\n+\t(init_alias_info): Update.\n+\t(finalize_ref_all_pointers): Update.\n+\t(setup_pointers_and_addressables): Update.\n+\t(maybe_create_global_var): Update.\n+\t(create_global_var): Update.\n+\t(dump_points_to_info): Update.\n+\t* function.h (struct gimple_df): Forward declare.\n+\t(struct function): Add GIMPLE_DF field.\n+\t* gimplify.c (force_gimple_operand): Update.\n+\t* tree-dfa.c (referenced_vars, default_defs): KIll.\n+\t(make_rename_temp): Update.\n+\t(dump_variable): Update.\n+\t(referenced_var_lookup): Update.\n+\t(referenced_var_check_and_insert): Update.\n+\t(default_def): Rename to ...\n+\t(gimple_default_def): ... this one; accept cfun argument.\n+\t(set_default_def): Update.\n+\t* tree-cfgcleanup.c (modified_noreturn_calls): Kill.\n+\t(cleanup_control_flow): Update.\n+\t* tree-ssa-pre.c (compute_avail): Update\n+\t* tree-ssa-live.c (calculate_live_on_entry): Update.\n+\t* tree-ssa.c (verify_use): Update.\n+\t(verify_call_clobbering): Update.\n+\t(verify_call_clobbering): Update.\n+\t(init_tree_ssa): Update.\n+\t(delete_tree_ssa): Update.\n+\t* tree-outof-ssa.c (coalesce_ssa_name): Update.\n+\t(rewrite_out_of_ssa): Update.\n+\t* tree-flow.h (gimple_df): New structure collecting dataflow variables.\n+\t(FREE_SSANAMES, SSANAMES, MODIFIED_NORETURN_CALLS, DEFAULT_DEFS): New\n+\tprivate accessors.\n+\t(in_ssa_p, modified_noreturn_calls, referenced_vars, default_defs,\n+\tssa_names, global_var, nonlocal_all, call_clobbered_vars,\n+\taddressable_vars, aliases_computed_p): Kill.\n+\t(default_def): Rename to...\n+\t(gimple_default_def): ... this one.\n+\t(defaule_def_fn): Kill.\n+\t(num_referenced_vars, ssa_names, num_ssa_names): Update.\n+\t* tree-ssa-structalias.c (nonlocal_all): Kill.\n+\t(get_constraint_exp_from_ssa_var): Update.\n+\t(create_nonlocal_var): Update.\n+\t(get_constraint_for): Update.\n+\t(update_alias_info): Update.\n+\t(find_global_initializers): Update.\n+\t(intra_create_variable_infos): Update.\n+\t(intra_create_variable_infos):\n+\t(find_what_p_points_to): Update.\n+\t(init_alias_heapvars): Update.\n+\t* tree-cfg.c (remove_bb): Update.\n+\t(gimplify_val): Update.\n+\t* tree-ssa-reassoc.c (get_rank): Update.\n+\t(init_reassoc): Update.\n+\t* tree-ssanames.c: Do not include gt-tree-ssanames.h\n+\t(ssa_names, free_ssanames): Kill.\n+\t(init_ssanames): Update.\n+\t(make_ssa_name): Update.\n+\t(release_ssa_name): Update.\n+\t(release_defs): Update.\n+\t(replace_ssa_name_symbol): Update.\n+\t* tree-ssa-operands.c (access_can_touch_variable): Update.\n+\t(add_virtual_operand): Update.\n+\t(add_call_clobber_ops): Update.\n+\t(add_call_read_ops): Update.\n+\t(get_call_expr_operands): Update.\n+\t(get_asm_expr_operands): Update.\n+\n 2006-11-28  Jan Hubicka  <jh@suse.cz>\n \n \t* builtins.c: Include tree-flow.h."}, {"sha": "869f1dc91981ecb6f4050fe9a8b5088503a71845", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -8237,7 +8237,7 @@ fold_builtin_memory_op (tree arglist, tree type, bool ignore, int endp)\n \treturn 0;\n \n       if (srctype == desttype\n-\t  || (in_ssa_p\n+\t  || (gimple_in_ssa_p (cfun)\n \t      && tree_ssa_useless_type_conversion_1 (desttype, srctype)))\n \texpr = srcvar;\n       else if ((INTEGRAL_TYPE_P (TREE_TYPE (srcvar))"}, {"sha": "63d42dcc79f211d6423a9c1aa43d8c7dc078ac98", "filename": "gcc/function.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -159,6 +159,7 @@ struct expr_status GTY(())\n #define forced_labels (cfun->expr->x_forced_labels)\n #define stack_pointer_delta (cfun->expr->x_stack_pointer_delta)\n \n+struct gimple_df;\n struct temp_slot;\n typedef struct temp_slot *temp_slot_p;\n \n@@ -188,6 +189,8 @@ struct function GTY(())\n \n   /* The control flow graph for this function.  */\n   struct control_flow_graph *cfg;\n+  /* SSA and dataflow information.  */\n+  struct gimple_df *gimple_df;\n \n   /* The loops in this function.  */\n   struct loops * GTY((skip)) x_current_loops;"}, {"sha": "ce91852eea3d8b039c7dffb029fef9f6d95400f1", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -6365,7 +6365,7 @@ force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n   gimple_test_f = simple ? is_gimple_val : is_gimple_reg_rhs;\n \n   push_gimplify_context ();\n-  gimplify_ctxp->into_ssa = in_ssa_p;\n+  gimplify_ctxp->into_ssa = gimple_in_ssa_p (cfun);\n \n   if (var)\n     expr = build2 (MODIFY_EXPR, TREE_TYPE (var), var, expr);\n@@ -6374,7 +6374,7 @@ force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n \t\t       gimple_test_f, fb_rvalue);\n   gcc_assert (ret != GS_ERROR);\n \n-  if (referenced_vars)\n+  if (gimple_referenced_vars (cfun))\n     {\n       for (t = gimplify_ctxp->temps; t ; t = TREE_CHAIN (t))\n \tadd_referenced_var (t);"}, {"sha": "bdbff33fdead71ca4726a3c23ce72d7eb212cc10", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -2040,7 +2040,7 @@ remove_bb (basic_block bb)\n \t     may be called when not in SSA.  For example,\n \t     final_cleanup calls this function via\n \t     cleanup_tree_cfg.  */\n-\t  if (in_ssa_p)\n+\t  if (gimple_in_ssa_p (cfun))\n \t    release_defs (stmt);\n \n \t  bsi_remove (&i, true);\n@@ -5645,7 +5645,7 @@ gimplify_val (block_stmt_iterator *bsi, tree type, tree exp)\n   TREE_BLOCK (new_stmt) = TREE_BLOCK (orig_stmt);\n \n   bsi_insert_before (bsi, new_stmt, BSI_SAME_STMT);\n-  if (in_ssa_p)\n+  if (gimple_in_ssa_p (cfun))\n     mark_new_vars_to_rename (new_stmt);\n \n   return t;"}, {"sha": "13a3b0b0ea8011c03dad05f8fcaac00a67dbab8d", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -127,14 +127,6 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n   return retval;\n }\n \n-/* A list of all the noreturn calls passed to modify_stmt.\n-   cleanup_control_flow uses it to detect cases where a mid-block\n-   indirect call has been turned into a noreturn call.  When this\n-   happens, all the instructions after the call are no longer\n-   reachable and must be deleted as dead.  */\n-\n-VEC(tree,gc) *modified_noreturn_calls;\n-\n /* Try to remove superfluous control structures.  */\n \n static bool\n@@ -146,13 +138,14 @@ cleanup_control_flow (void)\n   tree stmt;\n \n   /* Detect cases where a mid-block call is now known not to return.  */\n-  while (VEC_length (tree, modified_noreturn_calls))\n-    {\n-      stmt = VEC_pop (tree, modified_noreturn_calls);\n-      bb = bb_for_stmt (stmt);\n-      if (bb != NULL && last_stmt (bb) != stmt && noreturn_call_p (stmt))\n-\tsplit_block (bb, stmt);\n-    }\n+  if (cfun->gimple_df)\n+    while (VEC_length (tree, MODIFIED_NORETURN_CALLS (cfun)))\n+      {\n+\tstmt = VEC_pop (tree, MODIFIED_NORETURN_CALLS (cfun));\n+\tbb = bb_for_stmt (stmt);\n+\tif (bb != NULL && last_stmt (bb) != stmt && noreturn_call_p (stmt))\n+\t  split_block (bb, stmt);\n+      }\n \n   FOR_EACH_BB (bb)\n     {"}, {"sha": "d3909ae0acc18b678783fe672f7327341e1910e2", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -165,7 +165,7 @@ init_parameter_lattice_values (void)\n   for (parm = DECL_ARGUMENTS (cfun->decl); parm ; parm = TREE_CHAIN (parm))\n     if (is_complex_reg (parm) && var_ann (parm) != NULL)\n       {\n-\ttree ssa_name = default_def (parm);\n+\ttree ssa_name = gimple_default_def (cfun, parm);\n \tVEC_replace (complex_lattice_t, complex_lattice_values,\n \t\t     SSA_NAME_VERSION (ssa_name), VARYING);\n       }\n@@ -625,7 +625,7 @@ update_complex_assignment (block_stmt_iterator *bsi, tree r, tree i)\n   mod = stmt = bsi_stmt (*bsi);\n   if (TREE_CODE (stmt) == RETURN_EXPR)\n     mod = TREE_OPERAND (mod, 0);\n-  else if (in_ssa_p)\n+  else if (gimple_in_ssa_p (cfun))\n     update_complex_components (bsi, stmt, r, i);\n   \n   type = TREE_TYPE (TREE_OPERAND (mod, 1));\n@@ -651,7 +651,7 @@ update_parameter_components (void)\n \tcontinue;\n \n       type = TREE_TYPE (type);\n-      ssa_name = default_def (parm);\n+      ssa_name = gimple_default_def (cfun, parm);\n       if (!ssa_name)\n \tcontinue;\n \n@@ -910,7 +910,7 @@ expand_complex_libcall (block_stmt_iterator *bsi, tree ar, tree ai,\n     = build3 (CALL_EXPR, type, build_fold_addr_expr (fn), args, NULL);\n   update_stmt (stmt);\n \n-  if (in_ssa_p)\n+  if (gimple_in_ssa_p (cfun))\n     {\n       tree lhs = TREE_OPERAND (stmt, 0);\n       type = TREE_TYPE (type);\n@@ -1422,7 +1422,7 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n \t}\n     }\n \n-  if (in_ssa_p)\n+  if (gimple_in_ssa_p (cfun))\n     {\n       al = find_lattice_value (ac);\n       if (al == UNINITIALIZED)"}, {"sha": "3330624c19f8e27cfc59637b2f6800ef98140cd6", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -71,18 +71,6 @@ static tree collect_dfa_stats_r (tree *, int *, void *);\n static tree find_vars_r (tree *, int *, void *);\n \n \n-/* Global declarations.  */\n-\n-/* Array of all variables referenced in the function.  */\n-htab_t referenced_vars;\n-\n-/* Default definition for this symbols.  If set for symbol, it\n-   means that the first reference to this variable in the function is a\n-   USE or a VUSE.  In those cases, the SSA renamer creates an SSA name\n-   for this variable with an empty defining statement.  */\n-htab_t default_defs;\n-\n-\n /*---------------------------------------------------------------------------\n \t\t\tDataflow analysis (DFA) routines\n ---------------------------------------------------------------------------*/\n@@ -222,7 +210,7 @@ make_rename_temp (tree type, const char *prefix)\n   if (TREE_CODE (type) == COMPLEX_TYPE)\n     DECL_COMPLEX_GIMPLE_REG_P (t) = 1;\n \n-  if (referenced_vars)\n+  if (gimple_referenced_vars (cfun))\n     {\n       add_referenced_var (t);\n       mark_sym_for_renaming (t);\n@@ -375,10 +363,10 @@ dump_variable (FILE *file, tree var)\n \t}\n     }\n \n-  if (default_def (var))\n+  if (gimple_default_def (cfun, var))\n     {\n       fprintf (file, \", default def: \");\n-      print_generic_expr (file, default_def (var), dump_flags);\n+      print_generic_expr (file, gimple_default_def (cfun, var), dump_flags);\n     }\n \n   if (may_aliases (var))\n@@ -611,7 +599,8 @@ referenced_var_lookup (unsigned int uid)\n {\n   struct int_tree_map *h, in;\n   in.uid = uid;\n-  h = (struct int_tree_map *) htab_find_with_hash (referenced_vars, &in, uid);\n+  h = (struct int_tree_map *) htab_find_with_hash (gimple_referenced_vars (cfun),\n+\t\t\t\t\t\t   &in, uid);\n   gcc_assert (h || uid == 0);\n   if (h)\n     return h->to;\n@@ -630,7 +619,8 @@ referenced_var_check_and_insert (tree to)\n \n   in.uid = uid;\n   in.to = to;\n-  h = (struct int_tree_map *) htab_find_with_hash (referenced_vars, &in, uid);\n+  h = (struct int_tree_map *) htab_find_with_hash (gimple_referenced_vars (cfun),\n+\t\t\t\t\t\t   &in, uid);\n \n   if (h)\n     {\n@@ -643,7 +633,8 @@ referenced_var_check_and_insert (tree to)\n   h = GGC_NEW (struct int_tree_map);\n   h->uid = uid;\n   h->to = to;\n-  loc = htab_find_slot_with_hash (referenced_vars, h, uid, INSERT);\n+  loc = htab_find_slot_with_hash (gimple_referenced_vars (cfun),\n+\t\t\t\t  h, uid, INSERT);\n   *(struct int_tree_map **)  loc = h;\n   return true;\n }\n@@ -652,12 +643,13 @@ referenced_var_check_and_insert (tree to)\n    variable.  */\n \n tree \n-default_def (tree var)\n+gimple_default_def (struct function *fn, tree var)\n {\n   struct int_tree_map *h, in;\n   gcc_assert (SSA_VAR_P (var));\n   in.uid = DECL_UID (var);\n-  h = (struct int_tree_map *) htab_find_with_hash (default_defs, &in,\n+  h = (struct int_tree_map *) htab_find_with_hash (DEFAULT_DEFS (fn),\n+\t\t\t\t\t\t   &in,\n                                                    DECL_UID (var));\n   if (h)\n     return h->to;\n@@ -675,14 +667,16 @@ set_default_def (tree var, tree def)\n \n   gcc_assert (SSA_VAR_P (var));\n   in.uid = DECL_UID (var);\n-  if (!def && default_def (var))\n+  if (!def && gimple_default_def (cfun, var))\n     {\n-      loc = htab_find_slot_with_hash (default_defs, &in, DECL_UID (var), INSERT);\n-      htab_remove_elt (default_defs, *loc);\n+      loc = htab_find_slot_with_hash (DEFAULT_DEFS (cfun), &in,\n+            DECL_UID (var), INSERT);\n+      htab_remove_elt (DEFAULT_DEFS (cfun), *loc);\n       return;\n     }\n   gcc_assert (TREE_CODE (def) == SSA_NAME);\n-  loc = htab_find_slot_with_hash (default_defs, &in, DECL_UID (var), INSERT);\n+  loc = htab_find_slot_with_hash (DEFAULT_DEFS (cfun), &in,\n+                                  DECL_UID (var), INSERT);\n   /* Default definition might be changed by tail call optimization.  */\n   if (!*loc)\n     {"}, {"sha": "ae937b1c9b93c610d89dd140556f05c509df4d5e", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 74, "deletions": 7, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -25,6 +25,72 @@ Boston, MA 02110-1301, USA.  */\n /* Inline functions for manipulating various data structures defined in\n    tree-flow.h.  See tree-flow.h for documentation.  */\n \n+/* Return true when gimple SSA form was built.\n+   gimple_in_ssa_p is queried by gimplifier in various early stages before SSA\n+   infrastructure is initialized.  Check for presence of the datastructures\n+   at first place.  */\n+static inline bool\n+gimple_in_ssa_p (struct function *fun)\n+{\n+  return fun && fun->gimple_df && fun->gimple_df->in_ssa_p;\n+}\n+\n+/* 'true' after aliases have been computed (see compute_may_aliases).  */\n+static inline bool\n+gimple_aliases_computed_p (struct function *fun)\n+{\n+  gcc_assert (fun && fun->gimple_df);\n+  return fun->gimple_df->aliases_computed_p;\n+}\n+\n+/* Addressable variables in the function.  If bit I is set, then\n+   REFERENCED_VARS (I) has had its address taken.  Note that\n+   CALL_CLOBBERED_VARS and ADDRESSABLE_VARS are not related.  An\n+   addressable variable is not necessarily call-clobbered (e.g., a\n+   local addressable whose address does not escape) and not all\n+   call-clobbered variables are addressable (e.g., a local static\n+   variable).  */\n+static inline bitmap\n+gimple_addressable_vars (struct function *fun)\n+{\n+  gcc_assert (fun && fun->gimple_df);\n+  return fun->gimple_df->addressable_vars;\n+}\n+\n+/* Call clobbered variables in the function.  If bit I is set, then\n+   REFERENCED_VARS (I) is call-clobbered.  */\n+static inline bitmap\n+gimple_call_clobbered_vars (struct function *fun)\n+{\n+  gcc_assert (fun && fun->gimple_df);\n+  return fun->gimple_df->call_clobbered_vars;\n+}\n+\n+/* Array of all variables referenced in the function.  */\n+static inline htab_t\n+gimple_referenced_vars (struct function *fun)\n+{\n+  if (!fun->gimple_df)\n+    return NULL;\n+  return fun->gimple_df->referenced_vars;\n+}\n+\n+/* Artificial variable used to model the effects of function calls.  */\n+static inline tree\n+gimple_global_var (struct function *fun)\n+{\n+  gcc_assert (fun && fun->gimple_df);\n+  return fun->gimple_df->global_var;\n+}\n+\n+/* Artificial variable used to model the effects of nonlocal\n+   variables.  */\n+static inline tree\n+gimple_nonlocal_all (struct function *fun)\n+{\n+  gcc_assert (fun && fun->gimple_df);\n+  return fun->gimple_df->nonlocal_all;\n+}\n /* Initialize the hashtable iterator HTI to point to hashtable TABLE */\n \n static inline void *\n@@ -79,7 +145,8 @@ first_referenced_var (referenced_var_iterator *iter)\n {\n   struct int_tree_map *itm;\n   itm = (struct int_tree_map *) first_htab_element (&iter->hti,\n-                                                    referenced_vars);\n+                                                    gimple_referenced_vars\n+\t\t\t\t\t\t    (cfun));\n   if (!itm) \n     return NULL;\n   return itm->to;\n@@ -278,8 +345,8 @@ mark_stmt_modified (tree t)\n   ann = stmt_ann (t);\n   if (ann == NULL)\n     ann = create_stmt_ann (t);\n-  else if (noreturn_call_p (t))\n-    VEC_safe_push (tree, gc, modified_noreturn_calls, t);\n+  else if (noreturn_call_p (t) && cfun->gimple_df)\n+    VEC_safe_push (tree, gc, MODIFIED_NORETURN_CALLS (cfun), t);\n   ann->modified = 1;\n }\n \n@@ -760,7 +827,7 @@ is_call_clobbered (tree var)\n   if (!MTAG_P (var))\n     return DECL_CALL_CLOBBERED (var);\n   else\n-    return bitmap_bit_p (call_clobbered_vars, DECL_UID (var)); \n+    return bitmap_bit_p (gimple_call_clobbered_vars (cfun), DECL_UID (var)); \n }\n \n /* Mark variable VAR as being clobbered by function calls.  */\n@@ -770,7 +837,7 @@ mark_call_clobbered (tree var, unsigned int escape_type)\n   var_ann (var)->escape_mask |= escape_type;\n   if (!MTAG_P (var))\n     DECL_CALL_CLOBBERED (var) = true;\n-  bitmap_set_bit (call_clobbered_vars, DECL_UID (var));\n+  bitmap_set_bit (gimple_call_clobbered_vars (cfun), DECL_UID (var));\n }\n \n /* Clear the call-clobbered attribute from variable VAR.  */\n@@ -783,7 +850,7 @@ clear_call_clobbered (tree var)\n     MTAG_GLOBAL (var) = 0;\n   if (!MTAG_P (var))\n     DECL_CALL_CLOBBERED (var) = false;\n-  bitmap_clear_bit (call_clobbered_vars, DECL_UID (var));\n+  bitmap_clear_bit (gimple_call_clobbered_vars (cfun), DECL_UID (var));\n }\n \n /* Mark variable VAR as being non-addressable.  */\n@@ -792,7 +859,7 @@ mark_non_addressable (tree var)\n {\n   if (!MTAG_P (var))\n     DECL_CALL_CLOBBERED (var) = false;\n-  bitmap_clear_bit (call_clobbered_vars, DECL_UID (var));\n+  bitmap_clear_bit (gimple_call_clobbered_vars (cfun), DECL_UID (var));\n   TREE_ADDRESSABLE (var) = 0;\n }\n "}, {"sha": "fad1686f104474b20e329dd11eaba8c9dd2b0413", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 62, "deletions": 37, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -39,8 +39,63 @@ struct basic_block_def;\n typedef struct basic_block_def *basic_block;\n #endif\n \n-/* True if the code is in ssa form.  */\n-extern bool in_ssa_p;\n+/* Gimple dataflow datastructure. All publically available fields shall have\n+   gimple_ accessor defined in tree-flow-inline.h, all publically modifiable\n+   fields should have gimple_set accessor.  */\n+struct gimple_df GTY(()) {\n+  /* Array of all variables referenced in the function.  */\n+  htab_t GTY((param_is (struct int_tree_map))) referenced_vars;\n+  /* A list of all the noreturn calls passed to modify_stmt.\n+     cleanup_control_flow uses it to detect cases where a mid-block\n+     indirect call has been turned into a noreturn call.  When this\n+     happens, all the instructions after the call are no longer\n+     reachable and must be deleted as dead.  */\n+  VEC(tree,gc) *modified_noreturn_calls;\n+  /* Array of all SSA_NAMEs used in the function.  */\n+  VEC(tree,gc) *ssa_names;\n+\n+  /* Artificial variable used to model the effects of function calls.  */\n+  tree global_var;\n+\n+  /* Artificial variable used to model the effects of nonlocal\n+     variables.  */\n+  tree nonlocal_all;\n+\n+  /* Call clobbered variables in the function.  If bit I is set, then\n+     REFERENCED_VARS (I) is call-clobbered.  */\n+  bitmap call_clobbered_vars;\n+\n+  /* Addressable variables in the function.  If bit I is set, then\n+     REFERENCED_VARS (I) has had its address taken.  Note that\n+     CALL_CLOBBERED_VARS and ADDRESSABLE_VARS are not related.  An\n+     addressable variable is not necessarily call-clobbered (e.g., a\n+     local addressable whose address does not escape) and not all\n+     call-clobbered variables are addressable (e.g., a local static\n+     variable).  */\n+  bitmap addressable_vars;\n+\n+  /* Free list of SSA_NAMEs.  */\n+  tree free_ssanames;\n+\n+  /* Hashtable holding definition for symbol.  If this field is not NULL, it\n+     means that the first reference to this variable in the function is a\n+     USE or a VUSE.  In those cases, the SSA renamer creates an SSA name\n+     for this variable with an empty defining statement.  */\n+  htab_t GTY((param_is (struct int_tree_map))) default_defs;\n+\n+  /* 'true' after aliases have been computed (see compute_may_aliases).  */\n+  unsigned int aliases_computed_p : 1;\n+\n+  /* True if the code is in ssa form.  */\n+  unsigned int in_ssa_p : 1;\n+};\n+\n+/* Accessors for internal use only.  Generic code should use abstraction\n+   provided by tree-flow-inline.h or specific modules.  */\n+#define FREE_SSANAMES(fun) (fun)->gimple_df->free_ssanames\n+#define SSANAMES(fun) (fun)->gimple_df->ssa_names\n+#define MODIFIED_NORETURN_CALLS(fun) (fun)->gimple_df->modified_noreturn_calls\n+#define DEFAULT_DEFS(fun) (fun)->gimple_df->default_defs\n \n typedef struct\n {\n@@ -206,7 +261,7 @@ struct var_ann_d GTY(())\n   /* During into-ssa and the dominator optimizer, this field holds the\n      current version of this variable (an SSA_NAME).  */\n   tree current_def;\n-  \n+\n   /* If this variable is a structure, this fields holds a list of\n      symbols representing each of the fields of the structure.  */\n   subvar_t subvars;\n@@ -329,8 +384,6 @@ union tree_ann_d GTY((desc (\"ann_type ((tree_ann_t)&%h)\")))\n   struct stmt_ann_d GTY((tag (\"STMT_ANN\"))) stmt;\n };\n \n-extern GTY(()) VEC(tree,gc) *modified_noreturn_calls;\n-\n typedef union tree_ann_d *tree_ann_t;\n typedef struct var_ann_d *var_ann_t;\n typedef struct function_ann_d *function_ann_t;\n@@ -422,40 +475,13 @@ typedef struct\n        VEC_iterate (tree, (VEC), (ITER).i, (VAR)); \\\n        (ITER).i++)\n \n-/* Array of all variables referenced in the function.  */\n-extern GTY((param_is (struct int_tree_map))) htab_t referenced_vars;\n-\n-/* Default defs for undefined symbols. */\n-extern GTY((param_is (struct int_tree_map))) htab_t default_defs;\n-\n extern tree referenced_var_lookup (unsigned int);\n extern bool referenced_var_check_and_insert (tree);\n-#define num_referenced_vars htab_elements (referenced_vars)\n+#define num_referenced_vars htab_elements (gimple_referenced_vars (cfun))\n #define referenced_var(i) referenced_var_lookup (i)\n \n-/* Array of all SSA_NAMEs used in the function.  */\n-extern GTY(()) VEC(tree,gc) *ssa_names;\n-\n-#define num_ssa_names (VEC_length (tree, ssa_names))\n-#define ssa_name(i) (VEC_index (tree, ssa_names, (i)))\n-\n-/* Artificial variable used to model the effects of function calls.  */\n-extern GTY(()) tree global_var;\n-\n-/* Artificial variable used to model the effects of nonlocal\n-   variables.  */\n-extern GTY(()) tree nonlocal_all;\n-\n-/* Call clobbered variables in the function.  If bit I is set, then\n-   REFERENCED_VARS (I) is call-clobbered.  */\n-extern bitmap call_clobbered_vars;\n-\n-/* Addressable variables in the function.  If bit I is set, then\n-   REFERENCED_VARS (I) has had its address taken.  */\n-extern bitmap addressable_vars;\n-\n-/* 'true' after aliases have been computed (see compute_may_aliases).  */\n-extern bool aliases_computed_p;\n+#define num_ssa_names (VEC_length (tree, cfun->gimple_df->ssa_names))\n+#define ssa_name(i) (VEC_index (tree, cfun->gimple_df->ssa_names, (i)))\n \n /* Macros for showing usage statistics.  */\n #define SCALE(x) ((unsigned long) ((x) < 1024*10\t\\\n@@ -652,8 +678,7 @@ extern void find_new_referenced_vars (tree *);\n \n extern tree make_rename_temp (tree, const char *);\n extern void set_default_def (tree, tree);\n-extern tree default_def (tree);\n-extern tree default_def_fn (struct function *, tree);\n+extern tree gimple_default_def (struct function *, tree);\n \n /* In tree-phinodes.c  */\n extern void reserve_phi_args_for_new_edge (basic_block);"}, {"sha": "3fb2c53181741a5e894131cc14f3e6681ae1deb8", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -55,9 +55,6 @@ Boston, MA 02110-1301, USA.  */\n    Graph. ACM Transactions on Programming Languages and Systems,\n    13(4):451-490, October 1991.  */\n \n-/* True if the code is in ssa form.  */\n-bool in_ssa_p;\n-\n /* Structure to map a variable VAR to the set of blocks that contain\n    definitions for VAR.  */\n struct def_blocks_d\n@@ -1074,7 +1071,7 @@ find_def_blocks_for (tree var)\n static inline tree\n get_default_def_for (tree sym)\n {\n-  tree ddef = default_def (sym);\n+  tree ddef = gimple_default_def (cfun, sym);\n \n   if (ddef == NULL_TREE)\n     {\n@@ -2122,7 +2119,7 @@ rewrite_into_ssa (void)\n   sbitmap_free (interesting_blocks);\n \n   timevar_pop (TV_TREE_SSA_OTHER);\n-  in_ssa_p = true;\n+  cfun->gimple_df->in_ssa_p = true;\n   return 0;\n }\n "}, {"sha": "705066a2805320f0492065cb56ba68723f5fb7c7", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -870,7 +870,7 @@ coalesce_ssa_name (var_map map, int flags)\n   for (x = 0 ; x < num; x++)\n     {\n       tree var = partition_to_var (map, x);\n-      if (default_def (SSA_NAME_VAR (var)) == var)\n+      if (gimple_default_def (cfun, SSA_NAME_VAR (var)) == var)\n \tSET_BIT (live, x);\n     }\n \n@@ -2543,7 +2543,7 @@ rewrite_out_of_ssa (void)\n   /* Flush out flow graph and SSA data.  */\n   delete_var_map (map);\n \n-  in_ssa_p = false;\n+  cfun->gimple_df->in_ssa_p = false;\n   return 0;\n }\n "}, {"sha": "65a8417b9d329c33804466defb9a45c6d6e6c9ef", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 19, "deletions": 40, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -52,9 +52,6 @@ Boston, MA 02110-1301, USA.  */\n    aliasing  */\n static bitmap_obstack alias_obstack;\n \n-/* 'true' after aliases have been computed (see compute_may_aliases).  */\n-bool aliases_computed_p;\n-\n /* Structure to map a variable to its alias set and keep track of the\n    virtual operands that will be needed to represent it.  */\n struct alias_map_d\n@@ -117,26 +114,6 @@ static void set_pt_anything (tree ptr);\n \n /* Global declarations.  */\n \n-/* Call clobbered variables in the function.  If bit I is set, then\n-   REFERENCED_VARS (I) is call-clobbered.  */\n-bitmap call_clobbered_vars;\n-\n-/* Addressable variables in the function.  If bit I is set, then\n-   REFERENCED_VARS (I) has had its address taken.  Note that\n-   CALL_CLOBBERED_VARS and ADDRESSABLE_VARS are not related.  An\n-   addressable variable is not necessarily call-clobbered (e.g., a\n-   local addressable whose address does not escape) and not all\n-   call-clobbered variables are addressable (e.g., a local static\n-   variable).  */\n-bitmap addressable_vars;\n-\n-/* When the program has too many call-clobbered variables and call-sites,\n-   this variable is used to represent the clobbering effects of function\n-   calls.  In these cases, all the call clobbered variables in the program\n-   are forced to alias this variable.  This reduces compile times by not\n-   having to keep track of too many V_MAY_DEF expressions at call sites.  */\n-tree global_var;\n-\n /* qsort comparison function to sort type/name tags by DECL_UID.  */\n \n static int\n@@ -327,10 +304,10 @@ set_initial_properties (struct alias_info *ai)\n \t    mark_call_clobbered (var, ESCAPE_IS_GLOBAL);\n \t}\n       else if (TREE_CODE (var) == PARM_DECL\n-\t       && default_def (var)\n+\t       && gimple_default_def (cfun, var)\n \t       && POINTER_TYPE_P (TREE_TYPE (var)))\n \t{\n-\t  tree def = default_def (var);\n+\t  tree def = gimple_default_def (cfun, var);\n \t  get_ptr_info (def)->value_escapes_p = 1;\n \t  get_ptr_info (def)->escape_mask |= ESCAPE_IS_PARM;\t  \n \t}\n@@ -883,14 +860,14 @@ init_alias_info (void)\n   ai->dereferenced_ptrs_load = BITMAP_ALLOC (&alias_obstack);\n \n   /* If aliases have been computed before, clear existing information.  */\n-  if (aliases_computed_p)\n+  if (gimple_aliases_computed_p (cfun))\n     {\n       unsigned i;\n   \n       /* Similarly, clear the set of addressable variables.  In this\n \t case, we can just clear the set because addressability is\n \t only computed here.  */\n-      bitmap_clear (addressable_vars);\n+      bitmap_clear (gimple_addressable_vars (cfun));\n \n       /* Clear flow-insensitive alias information from each symbol.  */\n       FOR_EACH_REFERENCED_VAR (var, rvi)\n@@ -945,7 +922,7 @@ init_alias_info (void)\n     }\n \n   /* Next time, we will need to reset alias information.  */\n-  aliases_computed_p = true;\n+  cfun->gimple_df->aliases_computed_p = true;\n \n   return ai;\n }\n@@ -1341,8 +1318,8 @@ finalize_ref_all_pointers (struct alias_info *ai)\n {\n   size_t i;\n \n-  if (global_var)\n-    add_may_alias (ai->ref_all_symbol_mem_tag, global_var);\n+  if (gimple_global_var (cfun))\n+    add_may_alias (ai->ref_all_symbol_mem_tag, gimple_global_var (cfun));\n   else\n     {\n       /* First add the real call-clobbered variables.  */\n@@ -1761,7 +1738,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n          cleanup passes.  */\n       if (TREE_ADDRESSABLE (var))\n \t{\n-\t  if (!bitmap_bit_p (addressable_vars, DECL_UID (var))\n+\t  if (!bitmap_bit_p (gimple_addressable_vars (cfun), DECL_UID (var))\n \t      && TREE_CODE (var) != RESULT_DECL\n \t      && !is_global_var (var))\n \t    {\n@@ -1781,7 +1758,8 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \n \t\t  for (sv = svars; sv; sv = sv->next)\n \t\t    {\t      \n-\t\t      if (bitmap_bit_p (addressable_vars, DECL_UID (sv->var)))\n+\t\t      if (bitmap_bit_p (gimple_addressable_vars (cfun),\n+\t\t\t\t\tDECL_UID (sv->var)))\n \t\t\tokay_to_mark = false;\n \t\t      mark_sym_for_renaming (sv->var);\n \t\t    }\n@@ -1902,11 +1880,11 @@ maybe_create_global_var (struct alias_info *ai)\n   bitmap_iterator bi;\n   \n   /* No need to create it, if we have one already.  */\n-  if (global_var == NULL_TREE)\n+  if (gimple_global_var (cfun) == NULL_TREE)\n     {\n       /* Count all the call-clobbered variables.  */\n       n_clobbered = 0;\n-      EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n+      EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, i, bi)\n \t{\n \t  n_clobbered++;\n \t}\n@@ -1949,16 +1927,16 @@ maybe_create_global_var (struct alias_info *ai)\n   /* Mark all call-clobbered symbols for renaming.  Since the initial\n      rewrite into SSA ignored all call sites, we may need to rename\n      .GLOBAL_VAR and the call-clobbered variables.   */\n-  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, i, bi)\n     {\n       tree var = referenced_var (i);\n \n       /* If the function has calls to clobbering functions and\n \t .GLOBAL_VAR has been created, make it an alias for all\n \t call-clobbered variables.  */\n-      if (global_var && var != global_var)\n+      if (gimple_global_var (cfun) && var != gimple_global_var (cfun))\n \t{\n-\t  add_may_alias (var, global_var);\n+\t  add_may_alias (var, gimple_global_var (cfun));\n \t  gcc_assert (!get_subvars_for_var (var));\n \t}\n       \n@@ -2398,8 +2376,8 @@ get_tmt_for (tree ptr, struct alias_info *ai)\n static void\n create_global_var (void)\n {\n-  global_var = build_decl (VAR_DECL, get_identifier (\".GLOBAL_VAR\"),\n-                           void_type_node);\n+  tree global_var = build_decl (VAR_DECL, get_identifier (\".GLOBAL_VAR\"),\n+                                void_type_node);\n   DECL_ARTIFICIAL (global_var) = 1;\n   TREE_READONLY (global_var) = 0;\n   DECL_EXTERNAL (global_var) = 1;\n@@ -2413,6 +2391,7 @@ create_global_var (void)\n   mark_call_clobbered (global_var, ESCAPE_UNKNOWN);\n   add_referenced_var (global_var);\n   mark_sym_for_renaming (global_var);\n+  cfun->gimple_df->global_var = global_var;\n }\n \n \n@@ -2622,7 +2601,7 @@ dump_points_to_info (FILE *file)\n     {\n       if (POINTER_TYPE_P (TREE_TYPE (var)))\n \t{\n-\t  tree def = default_def (var);\n+\t  tree def = gimple_default_def (cfun, var);\n \t  if (def)\n \t    dump_points_to_info_for (file, def);\n \t}"}, {"sha": "a0ffefd0a6cfaccea9af08772facbae26f3ed30b", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -219,9 +219,9 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n \n   /* If both values have default defs, we can't coalesce.  If only one has a \n      tag, make sure that variable is the new root partition.  */\n-  if (default_def (root1))\n+  if (gimple_default_def (cfun, root1))\n     {\n-      if (default_def (root2))\n+      if (gimple_default_def (cfun, root2))\n \t{\n \t  if (debug)\n \t    fprintf (debug, \" : 2 default defs. No coalesce.\\n\");\n@@ -233,7 +233,7 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n \t  ign1 = false;\n \t}\n     }\n-  else if (default_def (root2))\n+  else if (gimple_default_def (cfun, root2))\n     {\n       ign1 = true;\n       ign2 = false;"}, {"sha": "f7f333f0b2cf37b8c948b7e01841807e105002c6", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -173,7 +173,7 @@ memory_ssa_name_same (tree *expr_p, int *walk_subtrees ATTRIBUTE_UNUSED,\n \n   /* If we've found a default definition, then there's no problem.  Both\n      stores will post-dominate it.  And def_bb will be NULL.  */\n-  if (expr == default_def (SSA_NAME_VAR (expr)))\n+  if (expr == gimple_default_def (cfun, SSA_NAME_VAR (expr)))\n     return NULL_TREE;\n \n   def_stmt = SSA_NAME_DEF_STMT (expr);"}, {"sha": "b34190f219fe4d98cd53566ca8e4c88d667ce20e", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -736,7 +736,7 @@ calculate_live_on_entry (var_map map)\n \t  var = partition_to_var (map, i);\n \t  stmt = SSA_NAME_DEF_STMT (var);\n \t  tmp = bb_for_stmt (stmt);\n-\t  d = default_def (SSA_NAME_VAR (var));\n+\t  d = gimple_default_def (cfun, SSA_NAME_VAR (var));\n \n \t  if (bitmap_bit_p (live_entry_blocks (live, i), entry_block))\n \t    {"}, {"sha": "76b0c3ea9b3da7868f29176aa5bb49921dc94a93", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -469,10 +469,10 @@ execute_cse_reciprocals (void)\n #endif\n \n   for (arg = DECL_ARGUMENTS (cfun->decl); arg; arg = TREE_CHAIN (arg))\n-    if (default_def (arg)\n+    if (gimple_default_def (cfun, arg)\n \t&& FLOAT_TYPE_P (TREE_TYPE (arg))\n \t&& is_gimple_reg (arg))\n-      execute_cse_reciprocals_1 (NULL, default_def (arg));\n+      execute_cse_reciprocals_1 (NULL, gimple_default_def (cfun, arg));\n \n   FOR_EACH_BB (bb)\n     {"}, {"sha": "a594d4d5dab7caaf64e9575eb9ea9b67589ac880", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -1050,12 +1050,12 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n   /* If ALIAS is .GLOBAL_VAR then the memory reference REF must be\n      using a call-clobbered memory tag.  By definition, call-clobbered\n      memory tags can always touch .GLOBAL_VAR.  */\n-  if (alias == global_var)\n+  if (alias == gimple_global_var (cfun))\n     return true;\n \n   /* We cannot prune nonlocal aliases because they are not type\n      specific.  */\n-  if (alias == nonlocal_all)\n+  if (alias == gimple_nonlocal_all (cfun))\n     return true;\n \n   /* If ALIAS is an SFT, it can't be touched if the offset     \n@@ -1317,7 +1317,7 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n \t\t set on it, or else we will get the wrong answer on\n \t\t clobbers.  */\n \t      if (none_added\n-\t\t  && !updating_used_alone && aliases_computed_p\n+\t\t  && !updating_used_alone && gimple_aliases_computed_p (cfun)\n \t\t  && TREE_CODE (var) == SYMBOL_MEMORY_TAG)\n \t\tgcc_assert (SMT_USED_ALONE (var));\n \n@@ -1552,9 +1552,10 @@ add_call_clobber_ops (tree stmt, tree callee)\n \n   /* If we created .GLOBAL_VAR earlier, just use it.  See compute_may_aliases \n      for the heuristic used to decide whether to create .GLOBAL_VAR or not.  */\n-  if (global_var)\n+  if (gimple_global_var (cfun))\n     {\n-      add_stmt_operand (&global_var, s_ann, opf_is_def);\n+      tree var = gimple_global_var (cfun);\n+      add_stmt_operand (&var, s_ann, opf_is_def);\n       return;\n     }\n \n@@ -1564,7 +1565,7 @@ add_call_clobber_ops (tree stmt, tree callee)\n   not_read_b = callee ? ipa_reference_get_not_read_global (callee) : NULL; \n   not_written_b = callee ? ipa_reference_get_not_written_global (callee) : NULL; \n   /* Add a V_MAY_DEF operand for every call clobbered variable.  */\n-  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, u, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, u, bi)\n     {\n       tree var = referenced_var_lookup (u);\n       unsigned int escape_mask = var_ann (var)->escape_mask;\n@@ -1633,16 +1634,17 @@ add_call_read_ops (tree stmt, tree callee)\n   /* if the function is not pure, it may reference memory.  Add\n      a VUSE for .GLOBAL_VAR if it has been created.  See add_referenced_var\n      for the heuristic used to decide whether to create .GLOBAL_VAR.  */\n-  if (global_var)\n+  if (gimple_global_var (cfun))\n     {\n-      add_stmt_operand (&global_var, s_ann, opf_none);\n+      tree var = gimple_global_var (cfun);\n+      add_stmt_operand (&var, s_ann, opf_none);\n       return;\n     }\n   \n   not_read_b = callee ? ipa_reference_get_not_read_global (callee) : NULL; \n \n   /* Add a VUSE for each call-clobbered variable.  */\n-  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, u, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, u, bi)\n     {\n       tree var = referenced_var (u);\n       tree real_var = var;\n@@ -1688,8 +1690,8 @@ get_call_expr_operands (tree stmt, tree expr)\n      computed.  By not bothering with virtual operands for CALL_EXPRs\n      we avoid adding superfluous virtual operands, which can be a\n      significant compile time sink (See PR 15855).  */\n-  if (aliases_computed_p\n-      && !bitmap_empty_p (call_clobbered_vars)\n+  if (gimple_aliases_computed_p (cfun)\n+      && !bitmap_empty_p (gimple_call_clobbered_vars (cfun))\n       && !(call_flags & ECF_NOVOPS))\n     {\n       /* A 'pure' or a 'const' function never call-clobbers anything. \n@@ -1776,17 +1778,20 @@ get_asm_expr_operands (tree stmt)\n \n \t/* Clobber all call-clobbered variables (or .GLOBAL_VAR if we\n \t   decided to group them).  */\n-\tif (global_var)\n-\t  add_stmt_operand (&global_var, s_ann, opf_is_def);\n+\tif (gimple_global_var (cfun))\n+\t  {\n+            tree var = gimple_global_var (cfun);\n+\t    add_stmt_operand (&var, s_ann, opf_is_def);\n+\t  }\n \telse\n-\t  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n+\t  EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, i, bi)\n \t    {\n \t      tree var = referenced_var (i);\n \t      add_stmt_operand (&var, s_ann, opf_is_def | opf_non_specific);\n \t    }\n \n \t/* Now clobber all addressables.  */\n-\tEXECUTE_IF_SET_IN_BITMAP (addressable_vars, 0, i, bi)\n+\tEXECUTE_IF_SET_IN_BITMAP (gimple_addressable_vars (cfun), 0, i, bi)\n \t    {\n \t      tree var = referenced_var (i);\n "}, {"sha": "80986eb086041880f11ab88744ba8db45f7fb598", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -3660,9 +3660,9 @@ compute_avail (void)\n        param;\n        param = TREE_CHAIN (param))\n     {\n-      if (default_def (param) != NULL)\n+      if (gimple_default_def (cfun, param) != NULL)\n \t{\n-\t  tree def = default_def (param);\n+\t  tree def = gimple_default_def (cfun, param);\n \n \t  vn_lookup_or_add (def, NULL);\n \t  bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), def);\n@@ -3676,9 +3676,9 @@ compute_avail (void)\n   if (cfun->static_chain_decl)\n     {\n       param = cfun->static_chain_decl;\n-      if (default_def (param) != NULL)\n+      if (gimple_default_def (cfun, param) != NULL)\n \t{\n-\t  tree def = default_def (param);\n+\t  tree def = gimple_default_def (cfun, param);\n \n \t  vn_lookup_or_add (def, NULL);\n \t  bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), def);"}, {"sha": "a5114862dc8dbdc093315fa492f5cfdddd5d5406", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -688,7 +688,7 @@ set_rhs (tree *stmt_p, tree expr)\n       *stmt_p = TREE_SIDE_EFFECTS (expr) ? expr : build_empty_stmt ();\n       (*stmt_p)->common.ann = (tree_ann_t) ann;\n \n-      if (in_ssa_p\n+      if (gimple_in_ssa_p (cfun)\n \t  && TREE_SIDE_EFFECTS (expr))\n \t{\n \t  /* Fix all the SSA_NAMEs created by *STMT_P to point to its new"}, {"sha": "6835a179125c143f8501428ec7f89d60c7cabf1a", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -264,7 +264,7 @@ get_rank (tree e)\n       int i;\n \n       if (TREE_CODE (SSA_NAME_VAR (e)) == PARM_DECL\n-\t  && e == default_def (SSA_NAME_VAR (e)))\n+\t  && e == gimple_default_def (cfun, SSA_NAME_VAR (e)))\n \treturn find_operand_rank (e)->rank;\n \n       stmt = SSA_NAME_DEF_STMT (e);\n@@ -1435,17 +1435,17 @@ init_reassoc (void)\n        param;\n        param = TREE_CHAIN (param))\n     {\n-      if (default_def (param) != NULL)\n+      if (gimple_default_def (cfun, param) != NULL)\n \t{\n-\t  tree def = default_def (param);\n+\t  tree def = gimple_default_def (cfun, param);\n \t  insert_operand_rank (def, ++rank);\n \t}\n     }\n \n   /* Give the chain decl a distinct rank. */\n   if (cfun->static_chain_decl != NULL)\n     {\n-      tree def = default_def (cfun->static_chain_decl);\n+      tree def = gimple_default_def (cfun, cfun->static_chain_decl);\n       if (def != NULL)\n \tinsert_operand_rank (def, ++rank);\n     }"}, {"sha": "30769eccae2c30f689f14424cff88b075e745434", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -165,9 +165,6 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map))) \n htab_t heapvar_for_stmt;\n \n-/* One variable to represent all non-local accesses.  */\n-tree nonlocal_all;\n-\n static bool use_field_sensitive = true;\n static int in_ipa_mode = 0;\n static bitmap_obstack predbitmap_obstack;\n@@ -1836,7 +1833,7 @@ get_constraint_exp_from_ssa_var (tree t)\n      decl.  */\n   if (TREE_CODE (t) == SSA_NAME \n       && TREE_CODE (SSA_NAME_VAR (t)) == PARM_DECL \n-      && default_def (SSA_NAME_VAR (t)) == t)\n+      && gimple_default_def (cfun, SSA_NAME_VAR (t)) == t)\n     return get_constraint_exp_from_ssa_var (SSA_NAME_VAR (t));\n \n   cexpr.type = SCALAR;\n@@ -2101,7 +2098,7 @@ create_nonlocal_var (tree type)\n {\n   tree nonlocal = create_tmp_var_raw (type, \"NONLOCAL\");\n   \n-  if (referenced_vars)\n+  if (gimple_referenced_vars (cfun))\n     add_referenced_var (nonlocal);\n \n   DECL_EXTERNAL (nonlocal) = 1;\n@@ -2224,7 +2221,7 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t\t    heapvar = create_tmp_var_raw (ptr_type_node, \"HEAP\");\n \t\t    DECL_EXTERNAL (heapvar) = 1;\n \t\t    get_var_ann (heapvar)->is_heapvar = 1;\n-\t\t    if (referenced_vars)\n+\t\t    if (gimple_referenced_vars (cfun))\n \t\t      add_referenced_var (heapvar);\n \t\t    heapvar_insert (t, heapvar);\n \t\t  }\n@@ -2659,7 +2656,7 @@ update_alias_info (tree stmt, struct alias_info *ai)\n   addr_taken = addresses_taken (stmt);\n   if (addr_taken)\n     {\n-      bitmap_ior_into (addressable_vars, addr_taken);\n+      bitmap_ior_into (gimple_addressable_vars (cfun), addr_taken);\n \n       /* If STMT is an escape point, all the addresses taken by it are\n \t call-clobbered.  */\n@@ -2695,7 +2692,10 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t to the set of addressable variables.  */\n       if (TREE_CODE (op) == ADDR_EXPR)\n \t{\n+\t  bitmap addressable_vars = gimple_addressable_vars (cfun);\n+\n \t  gcc_assert (TREE_CODE (stmt) == PHI_NODE);\n+\t  gcc_assert (addressable_vars);\n \n \t  /* PHI nodes don't have annotations for pinning the set\n \t     of addresses taken, so we collect them here.\n@@ -2704,7 +2704,8 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t     so that they can be treated like regular statements?\n \t     Currently, they are treated as second-class\n \t     statements.  */\n-\t  add_to_addressable_set (TREE_OPERAND (op, 0), &addressable_vars);\n+\t  add_to_addressable_set (TREE_OPERAND (op, 0),\n+                                  &addressable_vars);\n \t  continue;\n \t}\n \n@@ -3608,7 +3609,7 @@ find_global_initializers (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n     case VAR_DECL:\n       /* We might not have walked this because we skip\n \t DECL_EXTERNALs during the initial scan.  */\n-      if (referenced_vars)\n+      if (gimple_referenced_vars (cfun))\n \t{\n \t  get_var_ann (t);\n \t  if (referenced_var_check_and_insert (t))\n@@ -3867,7 +3868,7 @@ intra_create_variable_infos (void)\n \t\t\t\t\t    \"PARM_NOALIAS\");\n \t      get_var_ann (heapvar)->is_heapvar = 1;\n \t      DECL_EXTERNAL (heapvar) = 1;\n-\t      if (referenced_vars)\n+\t      if (gimple_referenced_vars (cfun))\n \t\tadd_referenced_var (heapvar);\n \t      heapvar_insert (t, heapvar);\n \t    }\n@@ -3891,13 +3892,14 @@ intra_create_variable_infos (void)\n \t    make_constraint_from_escaped (p);\n \t}\n     }\n-  if (!nonlocal_all)\n-    nonlocal_all = create_nonlocal_var (void_type_node);\n+  if (!gimple_nonlocal_all (cfun))\n+    cfun->gimple_df->nonlocal_all = create_nonlocal_var (void_type_node);\n \n   /* Create variable info for the nonlocal var if it does not\n      exist.  */\n-  nonlocal_vars_id = create_variable_info_for (nonlocal_all,\n-\t\t\t\t\t       get_name (nonlocal_all));\n+  nonlocal_vars_id = create_variable_info_for (gimple_nonlocal_all (cfun),\n+\t\t\t\t\t       get_name (gimple_nonlocal_all\n+\t\t\t\t\t\t\t (cfun)));\n   nonlocal_vi = get_varinfo (nonlocal_vars_id);\n   nonlocal_vi->is_artificial_var = 1;\n   nonlocal_vi->is_heap_var = 1; \n@@ -3999,7 +4001,7 @@ find_what_p_points_to (tree p)\n      decl.  */\n   if (TREE_CODE (p) == SSA_NAME \n       && TREE_CODE (SSA_NAME_VAR (p)) == PARM_DECL \n-      && default_def (SSA_NAME_VAR (p)) == p)\n+      && gimple_default_def (cfun, SSA_NAME_VAR (p)) == p)\n     lookup_p = SSA_NAME_VAR (p);\n \n   if (lookup_id_for_tree (lookup_p, &id))\n@@ -4591,13 +4593,13 @@ init_alias_heapvars (void)\n {\n   heapvar_for_stmt = htab_create_ggc (11, tree_map_hash, tree_map_eq,\n \t\t\t\t      NULL);\n-  nonlocal_all = NULL_TREE;\n+  cfun->gimple_df->nonlocal_all = NULL_TREE;\n }\n \n void\n delete_alias_heapvars (void)\n {\n-  nonlocal_all = NULL_TREE;\n+  cfun->gimple_df->nonlocal_all = NULL_TREE;\n   htab_delete (heapvar_for_stmt);\n }\n "}, {"sha": "4914510d7529bbde72107b335da7e932d966c76a", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -231,7 +231,7 @@ verify_use (basic_block bb, basic_block def_bb, use_operand_p use_p,\n   TREE_VISITED (ssa_name) = 1;\n \n   if (IS_EMPTY_STMT (SSA_NAME_DEF_STMT (ssa_name))\n-      && default_def (SSA_NAME_VAR (ssa_name)) == ssa_name)\n+      && gimple_default_def (cfun, SSA_NAME_VAR (ssa_name)) == ssa_name)\n     ; /* Default definitions have empty statements.  Nothing to do.  */\n   else if (!def_bb)\n     {\n@@ -627,7 +627,7 @@ verify_call_clobbering (void)\n      that everything in call_clobbered_vars is marked\n      DECL_CALL_CLOBBERED, and that everything marked\n      DECL_CALL_CLOBBERED is in call_clobbered_vars.  */\n-  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, i, bi)\n     {\n       var = referenced_var (i);\n       if (!MTAG_P (var) && !DECL_CALL_CLOBBERED (var))\n@@ -640,7 +640,7 @@ verify_call_clobbering (void)\n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n       if (!MTAG_P (var) && DECL_CALL_CLOBBERED (var)\n-\t  && !bitmap_bit_p (call_clobbered_vars, DECL_UID (var)))\n+\t  && !bitmap_bit_p (gimple_call_clobbered_vars (cfun), DECL_UID (var)))\n \t{\n \t  error (\"variable marked DECL_CALL_CLOBBERED but not in call_clobbered_vars bitmap.\");\n \t  debug_variable (var);\n@@ -830,16 +830,16 @@ int_tree_map_hash (const void *item)\n void\n init_tree_ssa (void)\n {\n-  referenced_vars = htab_create_ggc (20, int_tree_map_hash, \n-\t\t\t\t     int_tree_map_eq, NULL);\n-  default_defs = htab_create_ggc (20, int_tree_map_hash, int_tree_map_eq, NULL);\n-  call_clobbered_vars = BITMAP_ALLOC (NULL);\n-  addressable_vars = BITMAP_ALLOC (NULL);\n+  cfun->gimple_df = ggc_alloc_cleared (sizeof (struct gimple_df));\n+  cfun->gimple_df->referenced_vars = htab_create_ggc (20, int_tree_map_hash, \n+\t\t\t\t     \t\t      int_tree_map_eq, NULL);\n+  cfun->gimple_df->default_defs = htab_create_ggc (20, int_tree_map_hash, \n+\t\t\t\t                   int_tree_map_eq, NULL);\n+  cfun->gimple_df->call_clobbered_vars = BITMAP_GGC_ALLOC ();\n+  cfun->gimple_df->addressable_vars = BITMAP_GGC_ALLOC ();\n   init_alias_heapvars ();\n   init_ssanames ();\n   init_phinodes ();\n-  global_var = NULL_TREE;\n-  aliases_computed_p = false;\n }\n \n \n@@ -887,21 +887,19 @@ delete_tree_ssa (void)\n       ggc_free (var->common.ann);\n       var->common.ann = NULL;\n     }\n-  htab_delete (referenced_vars);\n-  referenced_vars = NULL;\n+  htab_delete (gimple_referenced_vars (cfun));\n+  cfun->gimple_df->referenced_vars = NULL;\n \n   fini_ssanames ();\n   fini_phinodes ();\n \n-  global_var = NULL_TREE;\n+  cfun->gimple_df->global_var = NULL_TREE;\n   \n-  htab_delete (default_defs);\n-  BITMAP_FREE (call_clobbered_vars);\n-  call_clobbered_vars = NULL;\n-  BITMAP_FREE (addressable_vars);\n-  addressable_vars = NULL;\n-  modified_noreturn_calls = NULL;\n-  aliases_computed_p = false;\n+  htab_delete (cfun->gimple_df->default_defs);\n+  cfun->gimple_df->call_clobbered_vars = NULL;\n+  cfun->gimple_df->addressable_vars = NULL;\n+  cfun->gimple_df->modified_noreturn_calls = NULL;\n+  cfun->gimple_df->aliases_computed_p = false;\n   delete_alias_heapvars ();\n   gcc_assert (!need_ssa_update_p ());\n }"}, {"sha": "21d5761d03b133768080d6c7e7efdb75d5979606", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -57,13 +57,6 @@ Boston, MA 02110-1301, USA.  */\n    We could also use a zone allocator for these objects since they have\n    a very well defined lifetime.  If someone wants to experiment with that\n    this is the place to try it.  */\n-   \n-/* Array of all SSA_NAMEs used in the function.  */\n-VEC(tree,gc) *ssa_names;\n-\n-/* Free list of SSA_NAMEs.  This list is wiped at the end of each function\n-   after we leave SSA form.  */\n-static GTY (()) tree free_ssanames;\n \n /* Version numbers with special meanings.  We start allocating new version\n    numbers after the special ones.  */\n@@ -79,7 +72,7 @@ unsigned int ssa_name_nodes_created;\n void\n init_ssanames (void)\n {\n-  ssa_names = VEC_alloc (tree, gc, 50);\n+  SSANAMES (cfun) = VEC_alloc (tree, gc, 50);\n \n   /* Version 0 is special, so reserve the first slot in the table.  Though\n      currently unused, we may use version 0 in alias analysis as part of\n@@ -88,17 +81,17 @@ init_ssanames (void)\n \n      We use VEC_quick_push here because we know that SSA_NAMES has at\n      least 50 elements reserved in it.  */\n-  VEC_quick_push (tree, ssa_names, NULL_TREE);\n-  free_ssanames = NULL;\n+  VEC_quick_push (tree, SSANAMES (cfun), NULL_TREE);\n+  FREE_SSANAMES (cfun) = NULL;\n }\n \n /* Finalize management of SSA_NAMEs.  */\n \n void\n fini_ssanames (void)\n {\n-  VEC_free (tree, gc, ssa_names);\n-  free_ssanames = NULL;\n+  VEC_free (tree, gc, SSANAMES (cfun));\n+  FREE_SSANAMES (cfun) = NULL;\n }\n \n /* Dump some simple statistics regarding the re-use of SSA_NAME nodes.  */\n@@ -129,24 +122,24 @@ make_ssa_name (tree var, tree stmt)\n   gcc_assert (!stmt || EXPR_P (stmt) || TREE_CODE (stmt) == PHI_NODE);\n \n   /* If our free list has an element, then use it.  */\n-  if (free_ssanames)\n+  if (FREE_SSANAMES (cfun))\n     {\n-      t = free_ssanames;\n-      free_ssanames = TREE_CHAIN (free_ssanames);\n+      t = FREE_SSANAMES (cfun);\n+      FREE_SSANAMES (cfun) = TREE_CHAIN (FREE_SSANAMES (cfun));\n #ifdef GATHER_STATISTICS\n       ssa_name_nodes_reused++;\n #endif\n \n       /* The node was cleared out when we put it on the free list, so\n \t there is no need to do so again here.  */\n       gcc_assert (ssa_name (SSA_NAME_VERSION (t)) == NULL);\n-      VEC_replace (tree, ssa_names, SSA_NAME_VERSION (t), t);\n+      VEC_replace (tree, SSANAMES (cfun), SSA_NAME_VERSION (t), t);\n     }\n   else\n     {\n       t = make_node (SSA_NAME);\n       SSA_NAME_VERSION (t) = num_ssa_names;\n-      VEC_safe_push (tree, gc, ssa_names, t);\n+      VEC_safe_push (tree, gc, SSANAMES (cfun), t);\n #ifdef GATHER_STATISTICS\n       ssa_name_nodes_created++;\n #endif\n@@ -183,7 +176,7 @@ release_ssa_name (tree var)\n \n   /* Never release the default definition for a symbol.  It's a\n      special SSA name that should always exist once it's created.  */\n-  if (var == default_def (SSA_NAME_VAR (var)))\n+  if (var == gimple_default_def (cfun, SSA_NAME_VAR (var)))\n     return;\n \n   /* If VAR has been registered for SSA updating, don't remove it.\n@@ -213,7 +206,8 @@ release_ssa_name (tree var)\n       while (imm->next != imm)\n \tdelink_imm_use (imm->next);\n \n-      VEC_replace (tree, ssa_names, SSA_NAME_VERSION (var), NULL_TREE);\n+      VEC_replace (tree, SSANAMES (cfun),\n+\t\t   SSA_NAME_VERSION (var), NULL_TREE);\n       memset (var, 0, tree_size (var));\n \n       imm->prev = imm;\n@@ -234,8 +228,8 @@ release_ssa_name (tree var)\n       SSA_NAME_IN_FREE_LIST (var) = 1;\n \n       /* And finally link it into the free list.  */\n-      TREE_CHAIN (var) = free_ssanames;\n-      free_ssanames = var;\n+      TREE_CHAIN (var) = FREE_SSANAMES (cfun);\n+      FREE_SSANAMES (cfun) = var;\n     }\n }\n \n@@ -291,7 +285,7 @@ release_defs (tree stmt)\n \n   /* Make sure that we are in SSA.  Otherwise, operand cache may point\n      to garbage.  */\n-  gcc_assert (in_ssa_p);\n+  gcc_assert (gimple_in_ssa_p (cfun));\n \n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n     if (TREE_CODE (def) == SSA_NAME)\n@@ -307,5 +301,3 @@ replace_ssa_name_symbol (tree ssa_name, tree sym)\n   SSA_NAME_VAR (ssa_name) = sym;\n   TREE_TYPE (ssa_name) = TREE_TYPE (sym);\n }\n-\n-#include \"gt-tree-ssanames.h\""}, {"sha": "616a550d55cb4ce89059bceedbdec0dfe73ba3f5", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -702,7 +702,7 @@ arg_needs_copy_p (tree param)\n     return false;\n \t\t\n   /* Parameters that are only defined but never used need not be copied.  */\n-  def = default_def (param);\n+  def = gimple_default_def (cfun, param);\n   if (!def)\n     return false;\n \n@@ -826,7 +826,7 @@ add_virtual_phis (void)\n \n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      if (!is_gimple_reg (var) && default_def (var) != NULL_TREE)\n+      if (!is_gimple_reg (var) && gimple_default_def (cfun, var) != NULL_TREE)\n \tmark_sym_for_renaming (var);\n     }\n \n@@ -911,7 +911,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t       param = TREE_CHAIN (param))\n \t    if (arg_needs_copy_p (param))\n \t      {\n-\t\ttree name = default_def (param);\n+\t\ttree name = gimple_default_def (cfun, param);\n \t\ttree new_name = make_ssa_name (param, SSA_NAME_DEF_STMT (name));\n \t\ttree phi;\n "}, {"sha": "fed86cbc5e6dcf9638e08de2c64ab50fc52ce8e1", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=5cd4ec7f24ef2fca4e1e27836e5eee7b15b8abd8", "patch": "@@ -273,7 +273,7 @@ get_value_range (tree var)\n   /* If VAR is a default definition, the variable can take any value\n      in VAR's type.  */\n   sym = SSA_NAME_VAR (var);\n-  if (var == default_def (sym))\n+  if (var == gimple_default_def (cfun, sym))\n     {\n       /* Try to use the \"nonnull\" attribute to create ~[0, 0]\n \t anti-ranges for pointers.  Note that this is only valid with"}]}