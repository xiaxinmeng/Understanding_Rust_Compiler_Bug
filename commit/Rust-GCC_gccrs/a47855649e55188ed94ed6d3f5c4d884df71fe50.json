{"sha": "a47855649e55188ed94ed6d3f5c4d884df71fe50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ3ODU1NjQ5ZTU1MTg4ZWQ5NGVkNmQzZjVjNGQ4ODRkZjcxZmU1MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-06-05T21:57:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-06-05T21:57:05Z"}, "message": "spew.c (yylex): Also return the TYPE_DECL if got_object.\n\n\t* spew.c (yylex): Also return the TYPE_DECL if got_object.\n\tDon't clear got_object after '~'.\n\t* call.c (build_scoped_method_call): Tweak destructor handling.\n\t(build_method_call): Likewise.\n\t* pt.c (tsubst_copy, case METHOD_CALL_EXPR): Don't mess with\n\tTYPE_MAIN_VARIANT for destructors.\n\t* semantics.c (finish_object_call_expr): Complain about calling a\n\tTYPE_DECL.\n\nFrom-SVN: r20256", "tree": {"sha": "0d8b3af3ac0f813a34ca81018ae0dc5d23965642", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d8b3af3ac0f813a34ca81018ae0dc5d23965642"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a47855649e55188ed94ed6d3f5c4d884df71fe50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a47855649e55188ed94ed6d3f5c4d884df71fe50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a47855649e55188ed94ed6d3f5c4d884df71fe50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a47855649e55188ed94ed6d3f5c4d884df71fe50/comments", "author": null, "committer": null, "parents": [{"sha": "e211a323f625b6a8a49d13f644ef21f76d0e2453", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e211a323f625b6a8a49d13f644ef21f76d0e2453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e211a323f625b6a8a49d13f644ef21f76d0e2453"}], "stats": {"total": 111, "additions": 77, "deletions": 34}, "files": [{"sha": "04ff5dc88eb29a57ab4bd2b2f11d24bd6dc5fa33", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47855649e55188ed94ed6d3f5c4d884df71fe50/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47855649e55188ed94ed6d3f5c4d884df71fe50/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a47855649e55188ed94ed6d3f5c4d884df71fe50", "patch": "@@ -1,3 +1,14 @@\n+1998-06-05  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* spew.c (yylex): Also return the TYPE_DECL if got_object.\n+\tDon't clear got_object after '~'.\n+\t* call.c (build_scoped_method_call): Tweak destructor handling.\n+\t(build_method_call): Likewise.\n+\t* pt.c (tsubst_copy, case METHOD_CALL_EXPR): Don't mess with\n+\tTYPE_MAIN_VARIANT for destructors.\n+\t* semantics.c (finish_object_call_expr): Complain about calling a\n+\tTYPE_DECL.\n+\n 1998-06-05  Per Bothner  <bothner@cygnus.com>\n \n \t* g++spec.c (lang_specific_pre_link, lang_specific_extra_ofiles):"}, {"sha": "7007cdf44ed2ca2fbd951f7be56e680ae426838f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47855649e55188ed94ed6d3f5c4d884df71fe50/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47855649e55188ed94ed6d3f5c4d884df71fe50/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a47855649e55188ed94ed6d3f5c4d884df71fe50", "patch": "@@ -356,14 +356,16 @@ build_scoped_method_call (exp, basetype, name, parms)\n      @@ But we do have to check access privileges later.  */\n   tree binfo, decl;\n   tree type = TREE_TYPE (exp);\n+  tree tmp;\n \n   if (type == error_mark_node\n       || basetype == error_mark_node)\n     return error_mark_node;\n \n   if (processing_template_decl)\n     {\n-      if (TREE_CODE (name) == BIT_NOT_EXPR)\n+      if (TREE_CODE (name) == BIT_NOT_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (name, 0)) == IDENTIFIER_NODE)\n \t{\n \t  tree type = get_aggr_from_typedef (TREE_OPERAND (name, 0), 0);\n \t  if (type)\n@@ -384,22 +386,42 @@ build_scoped_method_call (exp, basetype, name, parms)\n   else\n     binfo = NULL_TREE;\n \n+  /* Check the destructor call syntax.  */\n+  if (TREE_CODE (name) == BIT_NOT_EXPR)\n+    {\n+      tmp = TREE_OPERAND (name, 0);\n+\n+      if (TREE_CODE (tmp) == TYPE_DECL)\n+\ttmp = TREE_TYPE (tmp);\n+      else if (TREE_CODE_CLASS (TREE_CODE (tmp)) == 't')\n+\t/* OK */;\n+      else if (TREE_CODE (tmp) == IDENTIFIER_NODE)\n+\t{\n+\t  if (IS_AGGR_TYPE (basetype) && tmp == constructor_name (basetype))\n+\t    tmp = basetype;\n+\t  else\n+\t    tmp = get_type_value (tmp);\n+\t}\n+      else\n+\tmy_friendly_abort (980605);\n+      \n+      if (! (tmp && TYPE_MAIN_VARIANT (basetype) == TYPE_MAIN_VARIANT (tmp)))\n+\t{\n+\t  cp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n+\t\t    basetype, TREE_OPERAND (name, 0));\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n   /* Destructors can be \"called\" for simple types; see 5.2.4 and 12.4 Note\n      that explicit ~int is caught in the parser; this deals with typedefs\n      and template parms.  */\n   if (TREE_CODE (name) == BIT_NOT_EXPR && ! IS_AGGR_TYPE (basetype))\n     {\n-      tree tmp;\n       if (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (basetype))\n \tcp_error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n \t\t  exp, basetype, type);\n-      name = TREE_OPERAND (name, 0);\n-      if (! (name == TYPE_MAIN_VARIANT (basetype) \n-\t     || ((tmp = get_type_value (name))\n-\t\t && (TYPE_MAIN_VARIANT (basetype)\n-\t\t     == TYPE_MAIN_VARIANT (tmp)))))\n-\tcp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n-\t\t  basetype, name);\n+      \n       return cp_convert (void_type_node, exp);\n     }\n \n@@ -434,17 +456,6 @@ build_scoped_method_call (exp, basetype, name, parms)\n       /* Call to a destructor.  */\n       if (TREE_CODE (name) == BIT_NOT_EXPR)\n \t{\n-\t  /* Explicit call to destructor.  */\n-\t  name = TREE_OPERAND (name, 0);\n-\t  if (! (name == TYPE_MAIN_VARIANT (TREE_TYPE (decl))\n-\t\t || name == constructor_name (TREE_TYPE (decl))\n-\t\t || TREE_TYPE (decl) == get_type_value (name)))\n-\t    {\n-\t      cp_error\n-\t\t(\"qualified type `%T' does not match destructor name `~%T'\",\n-\t\t TREE_TYPE (decl), name);\n-\t      return error_mark_node;\n-\t    }\n \t  if (! TYPE_HAS_DESTRUCTOR (TREE_TYPE (decl)))\n \t    return cp_convert (void_type_node, exp);\n \t  \n@@ -599,7 +610,8 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n   if (processing_template_decl)\n     {\n-      if (TREE_CODE (name) == BIT_NOT_EXPR)\n+      if (TREE_CODE (name) == BIT_NOT_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (name, 0)) == IDENTIFIER_NODE)\n \t{\n \t  tree type = get_aggr_from_typedef (TREE_OPERAND (name, 0), 0);\n \t  if (type)\n@@ -635,21 +647,32 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n       tree tmp;\n+\n       flags |= LOOKUP_DESTRUCTOR;\n       name = TREE_OPERAND (name, 0);\n       if (parms)\n \terror (\"destructors take no parameters\");\n       basetype = TREE_TYPE (instance);\n       if (TREE_CODE (basetype) == REFERENCE_TYPE)\n \tbasetype = TREE_TYPE (basetype);\n-      if (! (name == TYPE_MAIN_VARIANT (basetype)\n-\t     || (IS_AGGR_TYPE (basetype)\n-\t\t && name == constructor_name (basetype))\n-\t     || ((tmp = get_type_value (name))\n-\t\t && (TYPE_MAIN_VARIANT (basetype)\n-\t\t     == TYPE_MAIN_VARIANT (tmp)))))\n+\n+      if (TREE_CODE (name) == TYPE_DECL)\n+\ttmp = TREE_TYPE (name);\n+      else if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')\n+\ttmp = name;\n+      else if (TREE_CODE (name) == IDENTIFIER_NODE)\n+\t{\n+\t  if (IS_AGGR_TYPE (basetype) && tmp == constructor_name (basetype))\n+\t    tmp = basetype;\n+\t  else\n+\t    tmp = get_type_value (tmp);\n+\t}\n+      else\n+\tmy_friendly_abort (980605);\n+\n+      if (! (tmp && TYPE_MAIN_VARIANT (basetype) == TYPE_MAIN_VARIANT (tmp)))\n \t{\n-\t  cp_error (\"destructor name `~%D' does not match type `%T' of expression\",\n+\t  cp_error (\"destructor name `~%T' does not match type `%T' of expression\",\n \t\t    name, basetype);\n \t  return cp_convert (void_type_node, instance);\n \t}"}, {"sha": "c5c98f81a1474971f0bf4ff90d803c2dec473d94", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47855649e55188ed94ed6d3f5c4d884df71fe50/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47855649e55188ed94ed6d3f5c4d884df71fe50/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a47855649e55188ed94ed6d3f5c4d884df71fe50", "patch": "@@ -5220,8 +5220,6 @@ tsubst_copy (t, args, in_decl)\n \tif (TREE_CODE (name) == BIT_NOT_EXPR)\n \t  {\n \t    name = tsubst_copy (TREE_OPERAND (name, 0), args, in_decl);\n-\t    if (TREE_CODE (name) != IDENTIFIER_NODE)\n-\t      name = TYPE_MAIN_VARIANT (name);\n \t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n \t  }\n \telse if (TREE_CODE (name) == SCOPE_REF\n@@ -5230,8 +5228,6 @@ tsubst_copy (t, args, in_decl)\n \t    tree base = tsubst_copy (TREE_OPERAND (name, 0), args, in_decl);\n \t    name = TREE_OPERAND (name, 1);\n \t    name = tsubst_copy (TREE_OPERAND (name, 0), args, in_decl);\n-\t    if (TREE_CODE (name) != IDENTIFIER_NODE)\n-\t      name = TYPE_MAIN_VARIANT (name);\n \t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n \t    name = build_nt (SCOPE_REF, base, name);\n \t  }"}, {"sha": "c2d687539d0ebe10ebc2736878bdb88a10dcf752", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47855649e55188ed94ed6d3f5c4d884df71fe50/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47855649e55188ed94ed6d3f5c4d884df71fe50/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a47855649e55188ed94ed6d3f5c4d884df71fe50", "patch": "@@ -919,6 +919,12 @@ finish_object_call_expr (fn, object, args)\n   tree real_fn = build_component_ref (object, fn, NULL_TREE, 1);\n   return finish_call_expr (real_fn, args);\n #else\n+  if (TREE_CODE (fn) == TYPE_DECL)\n+    {\n+      cp_error (\"calling type `%T' like a method\", fn);\n+      return error_mark_node;\n+    }\n+\n   return build_method_call (object, fn, args, NULL_TREE, LOOKUP_NORMAL);\n #endif\n }"}, {"sha": "1d2cea1d46f1e4f21ff57a4e7d16d4b87fd50565", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47855649e55188ed94ed6d3f5c4d884df71fe50/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47855649e55188ed94ed6d3f5c4d884df71fe50/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=a47855649e55188ed94ed6d3f5c4d884df71fe50", "patch": "@@ -327,7 +327,10 @@ yylex ()\n \t    case NSNAME:\n \t    case PTYPENAME:\n \t      lastiddecl = trrr;\n-\t      if (got_scope)\n+\n+\t      /* If this got special lookup, remember it.  In these cases,\n+\t         we don't have to worry about being a declarator-id. */\n+\t      if (got_scope || got_object)\n \t\ttmp_token.yylval.ttype = trrr;\n \t      break;\n \n@@ -379,7 +382,11 @@ yylex ()\n       consume_token ();\n     }\n \n-  got_object = NULL_TREE;\n+  /* class member lookup only applies to the first token after the object\n+     expression, except for explicit destructor calls.  */\n+  if (tmp_token.yychar != '~')\n+    got_object = NULL_TREE;\n+\n   yylval = tmp_token.yylval;\n   yychar = tmp_token.yychar;\n   end_of_file = tmp_token.end_of_file;"}]}