{"sha": "ba40277f6ac96ceb982120ce95d2b64695a25dff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE0MDI3N2Y2YWM5NmNlYjk4MjEyMGNlOTVkMmI2NDY5NWEyNWRmZg==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2019-12-18T17:00:39Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2019-12-18T17:00:39Z"}, "message": "[PR92848] [OpenACC] Use 'GOMP_MAP_VARS_ENTER_DATA' for dynamic data lifetimes\n\n\tlibgomp/\n\tPR libgomp/92848\n\t* oacc-mem.c (acc_map_data, present_create_copy)\n\t(goacc_insert_pointer): Use 'GOMP_MAP_VARS_ENTER_DATA'.\n\t(acc_unmap_data, delete_copyout, goacc_remove_pointer): Adjust.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-50.c: Remove.\n\t* testsuite/libgomp.oacc-c-c++-common/pr92848-1-d-a.c: New file\n\t* testsuite/libgomp.oacc-c-c++-common/pr92848-1-d-p.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/pr92848-1-r-a.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/pr92848-1-r-p.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-p.c:\n\tRemove \"XFAIL\"s.\n\nFrom-SVN: r279530", "tree": {"sha": "007a9147fd5e9078cef4bb70e83dcd53066855ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/007a9147fd5e9078cef4bb70e83dcd53066855ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba40277f6ac96ceb982120ce95d2b64695a25dff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba40277f6ac96ceb982120ce95d2b64695a25dff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba40277f6ac96ceb982120ce95d2b64695a25dff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba40277f6ac96ceb982120ce95d2b64695a25dff/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6278b549221501a947383ac057cfed5f02e30461", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6278b549221501a947383ac057cfed5f02e30461", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6278b549221501a947383ac057cfed5f02e30461"}], "stats": {"total": 488, "additions": 410, "deletions": 78}, "files": [{"sha": "d9aba5bee18554cd6b2571e52d8f46dd5a2ab586", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=ba40277f6ac96ceb982120ce95d2b64695a25dff", "patch": "@@ -1,5 +1,17 @@\n 2019-12-18  Thomas Schwinge  <thomas@codesourcery.com>\n \n+\tPR libgomp/92848\n+\t* oacc-mem.c (acc_map_data, present_create_copy)\n+\t(goacc_insert_pointer): Use 'GOMP_MAP_VARS_ENTER_DATA'.\n+\t(acc_unmap_data, delete_copyout, goacc_remove_pointer): Adjust.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-50.c: Remove.\n+\t* testsuite/libgomp.oacc-c-c++-common/pr92848-1-d-a.c: New file\n+\t* testsuite/libgomp.oacc-c-c++-common/pr92848-1-d-p.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/pr92848-1-r-a.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/pr92848-1-r-p.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-p.c:\n+\tRemove \"XFAIL\"s.\n+\n \t* target.c (gomp_unmap_tgt): Make it 'static'.\n \t* libgomp.h (gomp_unmap_tgt): Remove.\n "}, {"sha": "5442798234142d97dca276c5cc50bf49c04b780c", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 56, "deletions": 32, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=ba40277f6ac96ceb982120ce95d2b64695a25dff", "patch": "@@ -403,7 +403,8 @@ acc_map_data (void *h, void *d, size_t s)\n       gomp_mutex_unlock (&acc_dev->lock);\n \n       tgt = gomp_map_vars (acc_dev, mapnum, &hostaddrs, &devaddrs, &sizes,\n-\t\t\t   &kinds, true, GOMP_MAP_VARS_OPENACC);\n+\t\t\t   &kinds, true, GOMP_MAP_VARS_ENTER_DATA);\n+      assert (tgt);\n       splay_tree_key n = tgt->list[0].key;\n       assert (n->refcount == 1);\n       assert (n->dynamic_refcount == 0);\n@@ -468,23 +469,21 @@ acc_unmap_data (void *h)\n \t\t  (void *) h, (int) host_size);\n     }\n \n-  /* Mark for removal.  */\n-  n->refcount = 1;\n-\n   t = n->tgt;\n \n-  if (t->refcount == 2)\n+  if (t->refcount == 1)\n     {\n       /* This is the last reference, so pull the descriptor off the\n-         chain. This avoids gomp_unmap_vars via gomp_unmap_tgt from\n+         chain.  This prevents 'gomp_unmap_tgt' via 'gomp_remove_var' from\n          freeing the device memory. */\n       t->tgt_end = 0;\n       t->to_free = 0;\n     }\n \n-  gomp_mutex_unlock (&acc_dev->lock);\n+  bool is_tgt_unmapped = gomp_remove_var (acc_dev, n);\n+  assert (is_tgt_unmapped);\n \n-  gomp_unmap_vars (t, true);\n+  gomp_mutex_unlock (&acc_dev->lock);\n \n   if (profiling_p)\n     {\n@@ -572,7 +571,8 @@ present_create_copy (unsigned f, void *h, size_t s, int async)\n       goacc_aq aq = get_goacc_asyncqueue (async);\n \n       tgt = gomp_map_vars_async (acc_dev, aq, mapnum, &hostaddrs, NULL, &s,\n-\t\t\t\t &kinds, true, GOMP_MAP_VARS_OPENACC);\n+\t\t\t\t &kinds, true, GOMP_MAP_VARS_ENTER_DATA);\n+      assert (tgt);\n       n = tgt->list[0].key;\n       assert (n->refcount == 1);\n       assert (n->dynamic_refcount == 0);\n@@ -727,7 +727,18 @@ delete_copyout (unsigned f, void *h, size_t s, int async, const char *libfnname)\n \t\t\t      + (uintptr_t) h - n->host_start);\n \t  gomp_copy_dev2host (acc_dev, aq, h, d, s);\n \t}\n-      gomp_remove_var_async (acc_dev, n, aq);\n+\n+      if (aq)\n+\t/* TODO We can't do the 'is_tgt_unmapped' checking -- see the\n+\t   'gomp_unref_tgt' comment in\n+\t   <http://mid.mail-archive.com/878snl36eu.fsf@euler.schwinge.homeip.net>;\n+\t   PR92881.  */\n+\tgomp_remove_var_async (acc_dev, n, aq);\n+      else\n+\t{\n+\t  bool is_tgt_unmapped = gomp_remove_var (acc_dev, n);\n+\t  assert (is_tgt_unmapped);\n+\t}\n     }\n \n   gomp_mutex_unlock (&acc_dev->lock);\n@@ -877,7 +888,8 @@ acc_update_self_async (void *h, size_t s, int async)\n /* Special handling for 'GOMP_MAP_POINTER', 'GOMP_MAP_TO_PSET'.\n \n    Only the first mapping is considered in reference counting; the following\n-   ones implicitly follow suit.  */\n+   ones implicitly follow suit.  Similarly, 'copyout' ('force_copyfrom') is\n+   done only for the first mapping.  */\n \n static void\n goacc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n@@ -918,7 +930,8 @@ goacc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n   gomp_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n   goacc_aq aq = get_goacc_asyncqueue (async);\n   tgt = gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs,\n-\t\t\t     NULL, sizes, kinds, true, GOMP_MAP_VARS_OPENACC);\n+\t\t\t     NULL, sizes, kinds, true, GOMP_MAP_VARS_ENTER_DATA);\n+  assert (tgt);\n   splay_tree_key n = tgt->list[0].key;\n   assert (n->refcount == 1);\n   assert (n->dynamic_refcount == 0);\n@@ -928,13 +941,12 @@ goacc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n \n static void\n goacc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,\n-\t\t      int finalize, int mapnum)\n+\t\t      int finalize)\n {\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n   splay_tree_key n;\n   struct target_mem_desc *t;\n-  int minrefs = (mapnum == 1) ? 2 : 3;\n \n   if (!acc_is_present (h, s))\n     return;\n@@ -972,28 +984,40 @@ goacc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,\n       n->dynamic_refcount--;\n     }\n \n-  gomp_mutex_unlock (&acc_dev->lock);\n-\n   if (n->refcount == 0)\n     {\n-      /* Set refcount to 1 to allow gomp_unmap_vars to unmap it.  */\n-      n->refcount = 1;\n-      t->refcount = minrefs;\n-      for (size_t i = 0; i < t->list_count; i++)\n-\tif (t->list[i].key == n)\n-\t  {\n-\t    t->list[i].copy_from = force_copyfrom ? 1 : 0;\n-\t    break;\n-\t  }\n+      goacc_aq aq = get_goacc_asyncqueue (async);\n \n-      /* If running synchronously, unmap immediately.  */\n-      if (async < acc_async_noval)\n-\tgomp_unmap_vars (t, true);\n-      else\n+      if (force_copyfrom)\n+\t{\n+\t  void *d = (void *) (t->tgt_start + n->tgt_offset\n+\t\t\t      + (uintptr_t) h - n->host_start);\n+\n+\t  gomp_copy_dev2host (acc_dev, aq, h, d, s);\n+\t}\n+\n+      if (aq)\n \t{\n-\t  goacc_aq aq = get_goacc_asyncqueue (async);\n-\t  gomp_unmap_vars_async (t, true, aq);\n+\t  /* TODO The way the following code is currently implemented, we need\n+\t     the 'is_tgt_unmapped' return value from 'gomp_remove_var', so\n+\t     can't use 'gomp_remove_var_async' here -- see the 'gomp_unref_tgt'\n+\t     comment in\n+\t     <http://mid.mail-archive.com/878snl36eu.fsf@euler.schwinge.homeip.net>;\n+\t     PR92881 -- so have to synchronize here.  */\n+\t  if (!acc_dev->openacc.async.synchronize_func (aq))\n+\t    {\n+\t      gomp_mutex_unlock (&acc_dev->lock);\n+\t      gomp_fatal (\"synchronize failed\");\n+\t    }\n+\t}\n+      bool is_tgt_unmapped = false;\n+      for (size_t i = 0; i < t->list_count; i++)\n+\t{\n+\t  is_tgt_unmapped = gomp_remove_var (acc_dev, t->list[i].key);\n+\t  if (is_tgt_unmapped)\n+\t    break;\n \t}\n+      assert (is_tgt_unmapped);\n     }\n \n   gomp_mutex_unlock (&acc_dev->lock);\n@@ -1234,7 +1258,7 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum, void **hostaddrs,\n \t    bool copyfrom = (kind == GOMP_MAP_FORCE_FROM\n \t\t\t     || kind == GOMP_MAP_FROM);\n \t    goacc_remove_pointer (hostaddrs[i], sizes[i], copyfrom, async,\n-\t\t\t\t  finalize, pointer);\n+\t\t\t\t  finalize);\n \t    /* See the above comment.  */\n \t    i += pointer - 1;\n \t  }"}, {"sha": "e8294e1af365c8e7dbac5ad111f8af2f4e2404f5", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-50.c", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6278b549221501a947383ac057cfed5f02e30461/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6278b549221501a947383ac057cfed5f02e30461/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-50.c?ref=6278b549221501a947383ac057cfed5f02e30461", "patch": "@@ -1,30 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } } */\n-\n-#include <stdlib.h>\n-#include <openacc.h>\n-\n-int\n-main (int argc, char **argv)\n-{\n-  const int N = 256;\n-  unsigned char *h;\n-  void *d;\n-\n-  h = (unsigned char *) malloc (N);\n-\n-  d = acc_malloc (N);\n-\n-  acc_map_data (h, d, N);\n-\n-  if (acc_is_present (h, N) != 1)\n-    abort ();\n-\n-  acc_unmap_data (h);\n-\n-  acc_free (d);\n-\n-  free (h);\n-\n-  return 0;\n-}"}, {"sha": "6fe6a9af8c272d371b8f79f1f7f73a5550819fc1", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/pr92848-1-d-a.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92848-1-d-a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92848-1-d-a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92848-1-d-a.c?ref=ba40277f6ac96ceb982120ce95d2b64695a25dff", "patch": "@@ -0,0 +1,7 @@\n+/* Verify device memory allocation/deallocation\n+   { dg-additional-options \"-DOPENACC_DIRECTIVES\" } using OpenACC directives,\n+   { dg-additional-options \"-DARRAYS\" } using arrays.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#include \"pr92848-1-r-p.c\""}, {"sha": "2228b2d5d60dc958a8b6cbdc8bd4a28f29b75793", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/pr92848-1-d-p.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92848-1-d-p.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92848-1-d-p.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92848-1-d-p.c?ref=ba40277f6ac96ceb982120ce95d2b64695a25dff", "patch": "@@ -0,0 +1,7 @@\n+/* Verify device memory allocation/deallocation\n+   { dg-additional-options \"-DOPENACC_DIRECTIVES\" } using OpenACC directives,\n+   { dg-additional-options \"-DPOINTERS\" } using pointers.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#include \"pr92848-1-r-p.c\""}, {"sha": "3f5f0acbcf06224706f221497d1662ce8b8d1ec5", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/pr92848-1-r-a.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92848-1-r-a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92848-1-r-a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92848-1-r-a.c?ref=ba40277f6ac96ceb982120ce95d2b64695a25dff", "patch": "@@ -0,0 +1,7 @@\n+/* Verify device memory allocation/deallocation\n+   { dg-additional-options \"-DOPENACC_RUNTIME\" } using OpenACC Runtime Library routines,\n+   { dg-additional-options \"-DARRAYS\" } using arrays.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#include \"pr92848-1-r-p.c\""}, {"sha": "95565ba1cb2491d8a3c57d21b99f74f4b5ae0112", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/pr92848-1-r-p.c", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92848-1-r-p.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92848-1-r-p.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92848-1-r-p.c?ref=ba40277f6ac96ceb982120ce95d2b64695a25dff", "patch": "@@ -0,0 +1,321 @@\n+/* Verify device memory allocation/deallocation\n+   { dg-additional-options \"-DOPENACC_RUNTIME\" } using OpenACC Runtime Library routines,\n+   { dg-additional-options \"-DPOINTERS\" } using pointers.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#if OPENACC_RUNTIME\n+#elif OPENACC_DIRECTIVES\n+#else\n+# error\n+#endif\n+\n+#if POINTERS\n+#elif ARRAYS\n+#else\n+# error\n+#endif\n+\n+\n+#include <openacc.h>\n+#include <acc_prof.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdint.h>\n+#include <stdbool.h>\n+\n+\n+static bool cb_ev_alloc_expected;\n+static size_t cb_ev_alloc_bytes;\n+static const void *cb_ev_alloc_device_ptr;\n+static void\n+cb_ev_alloc (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  assert (cb_ev_alloc_expected);\n+  cb_ev_alloc_expected = false;\n+\n+  cb_ev_alloc_bytes = event_info->data_event.bytes;\n+  cb_ev_alloc_device_ptr = event_info->data_event.device_ptr;\n+}\n+\n+static bool cb_ev_free_expected;\n+static const void *cb_ev_free_device_ptr;\n+static void\n+cb_ev_free (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  assert (cb_ev_free_expected);\n+  cb_ev_free_expected = false;\n+\n+  cb_ev_free_device_ptr = event_info->data_event.device_ptr;\n+}\n+\n+\n+/* Match the alignment processing that\n+   'libgomp/target.c:gomp_map_vars_internal' is doing; simplified, not\n+   considering special alignment requirements of certain data types.  */\n+\n+static size_t\n+aligned_size (size_t tgt_size)\n+{\n+  size_t tgt_align = sizeof (void *);\n+  return tgt_size + tgt_align - 1;\n+}\n+\n+static const void *\n+aligned_address (const void *tgt_start)\n+{\n+  size_t tgt_align = sizeof (void *);\n+  return (void *) (((uintptr_t) tgt_start + tgt_align - 1) & ~(tgt_align - 1));\n+}\n+\n+\n+#define SIZE 1024\n+#define SUBSET 32\n+\n+\n+/* A \"create\", [...], \"delete\" sequence.  */\n+\n+static void\n+f1 (void)\n+{\n+  cb_ev_alloc_expected = false;\n+  cb_ev_free_expected = false;\n+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);\n+\n+#if POINTERS\n+  char *h = (char *) malloc (SIZE);\n+#else\n+  char h[SIZE];\n+#endif\n+\n+  void *d;\n+  cb_ev_alloc_expected = true;\n+#if OPENACC_RUNTIME\n+  d = acc_create (h, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc enter data create (h[0:SIZE])\n+# else\n+#  pragma acc enter data create (h)\n+# endif\n+  d = acc_deviceptr (h);\n+#endif\n+  assert (d);\n+  assert (!cb_ev_alloc_expected);\n+  assert (cb_ev_alloc_bytes == aligned_size (SIZE));\n+  assert (aligned_address (cb_ev_alloc_device_ptr) == d);\n+  assert (acc_is_present (h, SIZE));\n+\n+#if OPENACC_RUNTIME\n+  acc_create (h, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc enter data create (h[0:SIZE])\n+# else\n+#  pragma acc enter data create (h)\n+# endif\n+#endif\n+\n+#if POINTERS\n+# pragma acc data create (h[0:SIZE])\n+  ;\n+#else\n+# pragma acc data create (h)\n+  ;\n+#endif\n+  assert (acc_is_present (h, SIZE));\n+\n+#if OPENACC_RUNTIME\n+  acc_delete (h, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc exit data delete (h[0:SIZE])\n+# else\n+#  pragma acc exit data delete (h)\n+# endif\n+#endif\n+  assert (acc_is_present (h, SIZE));\n+\n+  cb_ev_free_expected = true;\n+#if OPENACC_RUNTIME\n+  acc_delete (h, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc exit data delete (h[0:SIZE])\n+# else\n+#  pragma acc exit data delete (h)\n+# endif\n+#endif\n+  assert (!cb_ev_free_expected);\n+  assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n+  assert (!acc_is_present (h, SIZE));\n+\n+#if POINTERS\n+  free (h);\n+#endif\n+\n+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);\n+}\n+\n+\n+/* A \"map\", [...] \"unmap\" sequence.  */\n+\n+static void\n+f2 (void)\n+{\n+  cb_ev_alloc_expected = false;\n+  cb_ev_free_expected = false;\n+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);\n+\n+#if POINTERS\n+  char *h = (char *) malloc (SIZE);\n+#else\n+  char h[SIZE];\n+#endif\n+\n+  void *d;\n+  cb_ev_alloc_expected = true;\n+  d = acc_malloc (SIZE);\n+  assert (d);\n+  assert (!cb_ev_alloc_expected);\n+  assert (cb_ev_alloc_bytes == SIZE);\n+  assert (cb_ev_alloc_device_ptr == d);\n+\n+  acc_map_data (h, d, SIZE);\n+  assert (acc_is_present (h, SIZE));\n+\n+#if OPENACC_RUNTIME\n+  acc_create (h, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc enter data create (h[0:SIZE])\n+# else\n+#  pragma acc enter data create (h)\n+# endif\n+#endif\n+\n+#if POINTERS\n+# pragma acc data create (h[0:SIZE])\n+  ;\n+#else\n+# pragma acc data create (h)\n+  ;\n+#endif\n+  assert (acc_is_present (h, SIZE));\n+\n+#if OPENACC_RUNTIME\n+  acc_delete (h, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc exit data delete (h[0:SIZE])\n+# else\n+#  pragma acc exit data delete (h)\n+# endif\n+#endif\n+  assert (acc_is_present (h, SIZE));\n+\n+  acc_unmap_data (h);\n+  assert (!acc_is_present (h, SIZE));\n+\n+  cb_ev_free_expected = true;\n+  acc_free (d);\n+  assert (!cb_ev_free_expected);\n+  assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n+\n+#if POINTERS\n+  free (h);\n+#endif\n+\n+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);\n+}\n+\n+\n+/* A structured 'data' construct.  */\n+\n+static void\n+f3 (void)\n+{\n+  cb_ev_alloc_expected = false;\n+  cb_ev_free_expected = false;\n+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);\n+\n+#if POINTERS\n+  char *h = (char *) malloc (SIZE);\n+#else\n+  char h[SIZE];\n+#endif\n+\n+  cb_ev_alloc_expected = true;\n+#if POINTERS\n+# pragma acc data create (h[0:SIZE])\n+#else\n+# pragma acc data create (h)\n+#endif\n+  {\n+    void *d = acc_deviceptr (h);\n+    assert (d);\n+    assert (!cb_ev_alloc_expected);\n+    assert (cb_ev_alloc_bytes == aligned_size (SIZE));\n+    assert (aligned_address (cb_ev_alloc_device_ptr) == d);\n+    assert (acc_is_present (h, SIZE));\n+\n+#if OPENACC_RUNTIME\n+    acc_create (h, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc enter data create (h[0:SIZE])\n+# else\n+#  pragma acc enter data create (h)\n+# endif\n+#endif\n+\n+#if POINTERS\n+# pragma acc data create (h[0:SIZE])\n+    ;\n+#else\n+# pragma acc data create (h)\n+    ;\n+#endif\n+    assert (acc_is_present (h, SIZE));\n+\n+#if OPENACC_RUNTIME\n+    acc_delete (h, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc exit data delete (h[0:SIZE])\n+# else\n+#  pragma acc exit data delete (h)\n+# endif\n+#endif\n+    assert (acc_is_present (h, SIZE));\n+\n+    cb_ev_free_expected = true;\n+  }\n+  assert (!cb_ev_free_expected);\n+  assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n+  assert (!acc_is_present (h, SIZE));\n+\n+#if POINTERS\n+  free (h);\n+#endif\n+\n+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);\n+}\n+\n+\n+int\n+main ()\n+{\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+\n+  return 0;\n+}"}, {"sha": "907b85877731975f3b144f0286ac50a5f2840453", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-p.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-r-p.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba40277f6ac96ceb982120ce95d2b64695a25dff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-r-p.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-r-p.c?ref=ba40277f6ac96ceb982120ce95d2b64695a25dff", "patch": "@@ -156,20 +156,16 @@ f1 (void)\n \n       assert (acc_is_present (&myblock[i], SUBSET));\n       assert (acc_is_present (myblock, SIZE));\n-#if 0 //TODO PR92848\n       if (last)\n \tcb_ev_free_expected = true;\n-#endif\n #if OPENACC_RUNTIME\n       acc_delete (&myblock[i], SUBSET);\n #else\n # pragma acc exit data delete (myblock[i:SUBSET])\n #endif\n-#if 0 //TODO PR92848\n       assert (!cb_ev_free_expected);\n       if (last)\n \tassert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n-#endif\n       assert (acc_is_present (&myblock[i], SUBSET) != last);\n       assert (acc_is_present (myblock, SIZE) != last);\n     }\n@@ -331,9 +327,7 @@ f3 ()\n   assert (acc_is_present (h, SIZE));\n   assert (acc_is_present (&h[2], SIZE - 2));\n \n-#if 0 //TODO PR92848\n   cb_ev_free_expected = true;\n-#endif\n #if OPENACC_RUNTIME\n   acc_delete (h, SIZE);\n #else\n@@ -343,10 +337,8 @@ f3 ()\n #  pragma acc exit data delete (h)\n # endif\n #endif\n-#if 0 //TODO PR92848\n   assert (!cb_ev_free_expected);\n   assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n-#endif\n \n   assert (!acc_is_present (h, SIZE));\n   assert (!acc_is_present (&h[2], SIZE - 2));\n@@ -401,19 +393,15 @@ f_lib_22 (void)\n   memset (h, c1, SIZE);\n   /* Now 'copyout' not the whole but only a \"subset\" subarray, missing one\n      SUBSET at the beginning, and half a SUBSET at the end...  */\n-#if 0 //TODO PR92848\n   cb_ev_free_expected = true;\n-#endif\n #if OPENACC_RUNTIME\n   acc_copyout (h + SUBSET, SIZE - SUBSET - SUBSET / 2);\n #else\n # pragma acc exit data copyout (h[SUBSET:SIZE - SUBSET - SUBSET / 2])\n #endif\n-#if 0 //TODO PR92848\n   /* ..., yet, expect the device memory object to be 'free'd...  */\n   assert (!cb_ev_free_expected);\n   assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n-#endif\n   /* ..., and the mapping to be removed...  */\n   assert (!acc_is_present (h, SIZE));\n   assert (!acc_is_present (&h[SUBSET], SIZE - SUBSET - SUBSET / 2));\n@@ -474,19 +462,15 @@ f_lib_30 (void)\n   assert (aligned_address (cb_ev_alloc_device_ptr) == d);\n \n   /* We 'delete' not the whole but only a \"subset\" subarray...  */\n-#if 0 //TODO PR92848\n   cb_ev_free_expected = true;\n-#endif\n #if OPENACC_RUNTIME\n   acc_delete (h, SIZE - SUBSET);\n #else\n # pragma acc exit data delete (h[0:SIZE - SUBSET])\n #endif\n-#if 0 //TODO PR92848\n   /* ..., yet, expect the device memory object to be 'free'd...  */\n   assert (!cb_ev_free_expected);\n   assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n-#endif\n   /* ..., and the mapping to be removed.  */\n   assert (!acc_is_present (h, SIZE));\n   assert (!acc_is_present (h, SIZE - SUBSET));"}]}