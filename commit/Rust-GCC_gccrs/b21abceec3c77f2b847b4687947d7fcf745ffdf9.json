{"sha": "b21abceec3c77f2b847b4687947d7fcf745ffdf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIxYWJjZWVjM2M3N2YyYjg0N2I0Njg3OTQ3ZDdmY2Y3NDVmZmRmOQ==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-09-18T15:56:20Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-09-18T15:56:20Z"}, "message": "regex.h: Add friend classes.\n\n2013-09-18  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex.h: Add friend classes.\n\t(match_results<>::position, regex_iterator<>::operator++):\n\tImplement position specification in regex_iterator.\n\t(regex_match<>, regex_search<>):\n\tMove match_results initializations to these function. Remove `todo`.\n\t* include/bits/regex_compiler.tcc:\n\t(_Compiler<>::_M_quantifier): Fix greedy/ungreedy of interval matching.\n\t* include/bits/regex_constants.h:\n\tFix indentation. Change match_flag_type to enum type.\n\t* include/bits/regex_executor.h:\n\tMerge identical code to the base class _Executor.\n\tSupport flags in regex_constants.\n\t* include/bits/regex_executor.tcc: Likewise.\n\t* include/bits/regex_scanner.h: Add comments.\n\t* include/bits/regex_scanner.tcc: Same.\n\t* testsuite/28_regex/algorithms/regex_search/ecma/assertion.cc:\n\tAdd a testcase.\n\t* testsuite/28_regex/algorithms/regex_search/ecma/flags.cc: New.\n\t* testsuite/28_regex/iterators/regex_iterator/char/\n\tstring_position_01.cc: Remove `xfail`.\n\t* testsuite/28_regex/iterators/regex_iterator/wchar_t/string_02.cc:\n\tRemove `xfail` and make the case really work.\n\nFrom-SVN: r202706", "tree": {"sha": "db5788d9dc9a22dd1aeac31c52fb72395dd7756d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db5788d9dc9a22dd1aeac31c52fb72395dd7756d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b21abceec3c77f2b847b4687947d7fcf745ffdf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b21abceec3c77f2b847b4687947d7fcf745ffdf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b21abceec3c77f2b847b4687947d7fcf745ffdf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b21abceec3c77f2b847b4687947d7fcf745ffdf9/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "64bc8861e91cba89fbdeb0880395315ecc2dcf28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64bc8861e91cba89fbdeb0880395315ecc2dcf28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64bc8861e91cba89fbdeb0880395315ecc2dcf28"}], "stats": {"total": 1024, "additions": 630, "deletions": 394}, "files": [{"sha": "cf411e6c96349758db3d2f181aea9fbf7203e2d8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b21abceec3c77f2b847b4687947d7fcf745ffdf9", "patch": "@@ -1,3 +1,28 @@\n+2013-09-18  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex.h: Add friend classes.\n+\t(match_results<>::position, regex_iterator<>::operator++):\n+\tImplement position specification in regex_iterator.\n+\t(regex_match<>, regex_search<>):\n+\tMove match_results initializations to these function. Remove `todo`.\n+\t* include/bits/regex_compiler.tcc:\n+\t(_Compiler<>::_M_quantifier): Fix greedy/ungreedy of interval matching.\n+\t* include/bits/regex_constants.h:\n+\tFix indentation. Change match_flag_type to enum type.\n+\t* include/bits/regex_executor.h:\n+\tMerge identical code to the base class _Executor.\n+\tSupport flags in regex_constants.\n+\t* include/bits/regex_executor.tcc: Likewise.\n+\t* include/bits/regex_scanner.h: Add comments.\n+\t* include/bits/regex_scanner.tcc: Same.\n+\t* testsuite/28_regex/algorithms/regex_search/ecma/assertion.cc:\n+\tAdd a testcase.\n+\t* testsuite/28_regex/algorithms/regex_search/ecma/flags.cc: New.\n+\t* testsuite/28_regex/iterators/regex_iterator/char/\n+\tstring_position_01.cc: Remove `xfail`.\n+\t* testsuite/28_regex/iterators/regex_iterator/wchar_t/string_02.cc:\n+\tRemove `xfail` and make the case really work.\n+\n 2013-09-18  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* testsuite/performance/25_algorithms/search_n.cc: Fix typo."}, {"sha": "9d1438aab2391b6883492336d4e5c10fdb99ce58", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=b21abceec3c77f2b847b4687947d7fcf745ffdf9", "patch": "@@ -1004,6 +1004,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t     const basic_regex<_Cp, _Rp>&,\n \t\t     regex_constants::match_flag_type);\n \n+      template<typename, typename, typename, typename>\n+\tfriend class __detail::_Executor;\n+\n+      template<typename, typename, typename, typename>\n+\tfriend class __detail::_DFSExecutor;\n+\n+      template<typename, typename, typename, typename>\n+\tfriend class __detail::_BFSExecutor;\n+\n       flag_type     _M_flags;\n       _Rx_traits    _M_traits;\n       _AutomatonPtr _M_automaton;\n@@ -1783,21 +1792,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       explicit\n       match_results(const _Alloc& __a = _Alloc())\n-      : _Base_type(__a)\n+      : _Base_type(__a), _M_in_iterator(false)\n       { }\n \n       /**\n        * @brief Copy constructs a %match_results.\n        */\n       match_results(const match_results& __rhs)\n-      : _Base_type(__rhs)\n+      : _Base_type(__rhs), _M_in_iterator(false)\n       { }\n \n       /**\n        * @brief Move constructs a %match_results.\n        */\n       match_results(match_results&& __rhs) noexcept\n-      : _Base_type(std::move(__rhs))\n+      : _Base_type(std::move(__rhs)), _M_in_iterator(false)\n       { }\n \n       /**\n@@ -1905,8 +1914,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       difference_type\n       position(size_type __sub = 0) const\n       {\n-\treturn __sub < size() ? std::distance(this->prefix().first,\n-\t\t\t\t\t      (*this)[__sub].first) : -1;\n+\t// [28.12.1.4.5]\n+\tif (_M_in_iterator)\n+\t  return __sub < size() ? std::distance(_M_begin,\n+\t\t\t\t\t\t(*this)[__sub].first) : -1;\n+\telse\n+\t  return __sub < size() ? std::distance(this->prefix().first,\n+\t\t\t\t\t\t(*this)[__sub].first) : -1;\n       }\n \n       /**\n@@ -2106,6 +2120,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename, typename, typename, typename>\n \tfriend class __detail::_BFSExecutor;\n \n+      template<typename, typename, typename>\n+\tfriend class regex_iterator;\n+\n       template<typename _Bp, typename _Ap,\n \ttypename _Ch_type, typename _Rx_traits>\n \tfriend bool\n@@ -2121,6 +2138,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t     const basic_regex<_Ch_type,\n \t\t     _Rx_traits>&,\n \t\t     regex_constants::match_flag_type);\n+\n+      _Bi_iter _M_begin;\n+      bool     _M_in_iterator;\n     };\n \n   typedef match_results<const char*>             cmatch;\n@@ -2200,8 +2220,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @retval false Otherwise.\n    *\n    * @throws an exception of type regex_error.\n-   *\n-   * @todo Implement this function.\n    */\n   template<typename _Bi_iter, typename _Alloc,\n \t   typename _Ch_type, typename _Rx_traits>\n@@ -2215,6 +2233,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (__re._M_automaton == nullptr)\n \treturn false;\n+\n+      auto __size = __re._M_automaton->_M_sub_count();\n+      __size += 2;\n+      __m.resize(__size);\n+      for (decltype(__size) __i = 0; __i < __size; ++__i)\n+\t__m.at(__i).matched = false;\n+\n       if (__detail::__get_executor(__s, __e, __m, __re, __flags)->_M_match())\n \t{\n \t  for (auto __it : __m)\n@@ -2360,8 +2385,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *               undefined.\n    *\n    * @throws an exception of type regex_error.\n-   *\n-   * @todo Implement this function.\n    */\n   template<typename _Bi_iter, typename _Alloc,\n \t   typename _Ch_type, typename _Rx_traits>\n@@ -2374,6 +2397,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (__re._M_automaton == nullptr)\n \treturn false;\n+\n+      auto __size = __re._M_automaton->_M_sub_count();\n+      __size += 2;\n+      __m.resize(__size);\n+      for (decltype(__size) __i = 0; __i < __size; ++__i)\n+\t__m.at(__i).matched = false;\n+\n       if (__detail::__get_executor(__first, __last, __m, __re, __flags)\n \t  ->_M_search())\n \t{\n@@ -2677,7 +2707,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n     operator++()\n     {\n-      // FIXME: In all cases in which the call to regex_search returns true,\n+      // In all cases in which the call to regex_search returns true,\n       // match.prefix().first shall be equal to the previous value of\n       // match[0].second, and for each index i in the half-open range\n       // [0, match.size()) for which match[i].matched is true,\n@@ -2697,12 +2727,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\tif (regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags\n \t\t\t\t | regex_constants::match_not_null\n \t\t\t\t | regex_constants::match_continuous))\n-\t\t  return *this;\n+\t\t  {\n+\t\t    _M_match._M_in_iterator = true;\n+\t\t    _M_match._M_begin = _M_begin;\n+\t\t    return *this;\n+\t\t  }\n \t\telse\n \t\t  ++__start;\n \t      }\n \t  _M_flags |= regex_constants::match_prev_avail;\n-\t  if (!regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags))\n+\t  if (regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags))\n+\t    {\n+\t      _M_match._M_in_iterator = true;\n+\t      _M_match._M_begin = _M_begin;\n+\t    }\n+\t  else\n \t    _M_match = value_type();\n \t}\n       return *this;"}, {"sha": "7f9a19af2d96aa0491a466d4e01cda93ab39f677", "filename": "libstdc++-v3/include/bits/regex_compiler.tcc", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc?ref=b21abceec3c77f2b847b4687947d7fcf745ffdf9", "patch": "@@ -28,7 +28,7 @@\n  *  Do not attempt to use it directly. @headername{regex}\n  */\n \n-// TODO make comments doxygen format.\n+// FIXME make comments doxygen format.\n \n // This compiler refers to \"Regular Expression Matching Can Be Simple And Fast\"\n // (http://swtch.com/~rsc/regexp/regexp1.html\"),\n@@ -223,16 +223,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\tif (__n < 0)\n \t\t  __throw_regex_error(regex_constants::error_badbrace);\n \t\tauto __end = _M_nfa._M_insert_dummy();\n+\t\t// _M_alt is the \"match more\" branch, and _M_next is the\n+\t\t// \"match less\" one. Switch _M_alt and _M_next of all created\n+\t\t// nodes. This is a hacking but IMO works well.\n+\t\tstd::stack<_StateIdT> __stack;\n \t\tfor (int __i = 0; __i < __n; ++__i)\n \t\t  {\n \t\t    auto __tmp = __r._M_clone();\n-\t\t    __e._M_append\n-\t\t      (_StateSeqT(_M_nfa,\n-\t\t\t\t  _M_nfa._M_insert_alt(__tmp._M_start,\n-\t\t\t\t\t\t       __end, __neg),\n-\t\t\t\t  __tmp._M_end));\n+\t\t    auto __alt = _M_nfa._M_insert_alt(__tmp._M_start,\n+\t\t\t\t\t\t      __end, __neg);\n+\t\t    __stack.push(__alt);\n+\t\t    __e._M_append(_StateSeqT(_M_nfa, __alt, __tmp._M_end));\n \t\t  }\n \t\t__e._M_append(__end);\n+\t\twhile (!__stack.empty())\n+\t\t  {\n+\t\t    auto& __tmp = _M_nfa[__stack.top()];\n+\t\t    __stack.pop();\n+\t\t    swap(__tmp._M_next, __tmp._M_alt);\n+\t\t  }\n \t      }\n \t    else // {3,}\n \t      {"}, {"sha": "94c25e531b32360d8c4b24b214303a901f62bad7", "filename": "libstdc++-v3/include/bits/regex_constants.h", "status": "modified", "additions": 156, "deletions": 118, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h?ref=b21abceec3c77f2b847b4687947d7fcf745ffdf9", "patch": "@@ -52,19 +52,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n   //@{\n   enum __syntax_option\n-    {\n-      _S_icase,\n-      _S_nosubs,\n-      _S_optimize,\n-      _S_collate,\n-      _S_ECMAScript,\n-      _S_basic,\n-      _S_extended,\n-      _S_awk,\n-      _S_grep,\n-      _S_egrep,\n-      _S_syntax_last\n-    };\n+  {\n+    _S_icase,\n+    _S_nosubs,\n+    _S_optimize,\n+    _S_collate,\n+    _S_ECMAScript,\n+    _S_basic,\n+    _S_extended,\n+    _S_awk,\n+    _S_grep,\n+    _S_egrep,\n+    _S_syntax_last\n+  };\n \n   /**\n    * @brief This is a bitmask type indicating how to interpret the regex.\n@@ -211,20 +211,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   //@{\n \n   enum __match_flag\n-    {\n-      _S_not_bol,\n-      _S_not_eol,\n-      _S_not_bow,\n-      _S_not_eow,\n-      _S_any,\n-      _S_not_null,\n-      _S_continuous,\n-      _S_prev_avail,\n-      _S_sed,\n-      _S_no_copy,\n-      _S_first_only,\n-      _S_match_flag_last\n-    };\n+  {\n+    _S_not_bol,\n+    _S_not_eol,\n+    _S_not_bow,\n+    _S_not_eow,\n+    _S_any,\n+    _S_not_null,\n+    _S_continuous,\n+    _S_prev_avail,\n+    _S_sed,\n+    _S_no_copy,\n+    _S_first_only,\n+    _S_match_flag_last\n+  };\n \n   /**\n    * @brief This is a bitmask type indicating regex matching rules.\n@@ -233,110 +233,148 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * perform bitwise operations on these values and expect the right thing to\n    * happen.\n    */\n-  typedef std::bitset<_S_match_flag_last> match_flag_type;\n+  enum match_flag_type : unsigned int\n+  {\n+    /**\n+     * The default matching rules.\n+     */\n+    match_default     = 0,\n \n-  /**\n-   * The default matching rules.\n-   */\n-  constexpr match_flag_type match_default     = 0;\n+    /**\n+     * The first character in the sequence [first, last) is treated as though it\n+     * is not at the beginning of a line, so the character (^) in the regular\n+     * expression shall not match [first, first).\n+     */\n+    match_not_bol     = 1 << _S_not_bol,\n \n-  /**\n-   * The first character in the sequence [first, last) is treated as though it\n-   * is not at the beginning of a line, so the character (^) in the regular\n-   * expression shall not match [first, first).\n-   */\n-  constexpr match_flag_type match_not_bol     = 1 << _S_not_bol;\n+    /**\n+     * The last character in the sequence [first, last) is treated as though it\n+     * is not at the end of a line, so the character ($) in the regular\n+     * expression shall not match [last, last).\n+     */\n+    match_not_eol     = 1 << _S_not_eol,\n \n-  /**\n-   * The last character in the sequence [first, last) is treated as though it\n-   * is not at the end of a line, so the character ($) in the regular\n-   * expression shall not match [last, last).\n-   */\n-  constexpr match_flag_type match_not_eol     = 1 << _S_not_eol;\n+    /**\n+     * The expression \\\\b is not matched against the sub-sequence\n+     * [first,first).\n+     */\n+    match_not_bow     = 1 << _S_not_bow,\n \n-  /**\n-   * The expression \\\\b is not matched against the sub-sequence\n-   * [first,first).\n-   */\n-  constexpr match_flag_type match_not_bow     = 1 << _S_not_bow;\n+    /**\n+     * The expression \\\\b should not be matched against the sub-sequence\n+     * [last,last).\n+     */\n+    match_not_eow     = 1 << _S_not_eow,\n \n-  /**\n-   * The expression \\\\b should not be matched against the sub-sequence\n-   * [last,last).\n-   */\n-  constexpr match_flag_type match_not_eow     = 1 << _S_not_eow;\n+    /**\n+     * If more than one match is possible then any match is an acceptable\n+     * result.\n+     */\n+    match_any         = 1 << _S_any,\n \n-  /**\n-   * If more than one match is possible then any match is an acceptable\n-   * result.\n-   */\n-  constexpr match_flag_type match_any         = 1 << _S_any;\n+    /**\n+     * The expression does not match an empty sequence.\n+     */\n+    match_not_null    = 1 << _S_not_null,\n \n-  /**\n-   * The expression does not match an empty sequence.\n-   */\n-  constexpr match_flag_type match_not_null    = 1 << _S_not_null;\n+    /**\n+     * The expression only matches a sub-sequence that begins at first .\n+     */\n+    match_continuous  = 1 << _S_continuous,\n \n-  /**\n-   * The expression only matches a sub-sequence that begins at first .\n-   */\n-  constexpr match_flag_type match_continuous  = 1 << _S_continuous;\n+    /**\n+     * --first is a valid iterator position.  When this flag is set then the\n+     * flags match_not_bol and match_not_bow are ignored by the regular\n+     * expression algorithms 28.11 and iterators 28.12.\n+     */\n+    match_prev_avail  = 1 << _S_prev_avail,\n \n-  /**\n-   * --first is a valid iterator position.  When this flag is set then the\n-   * flags match_not_bol and match_not_bow are ignored by the regular\n-   * expression algorithms 28.11 and iterators 28.12.\n-   */\n-  constexpr match_flag_type match_prev_avail  = 1 << _S_prev_avail;\n+    /**\n+     * When a regular expression match is to be replaced by a new string, the\n+     * new string is constructed using the rules used by the ECMAScript replace\n+     * function in ECMA- 262 [Ecma International, ECMAScript Language\n+     * Specification, Standard Ecma-262, third edition, 1999], part 15.5.4.11\n+     * String.prototype.replace. In addition, during search and replace\n+     * operations all non-overlapping occurrences of the regular expression\n+     * are located and replaced, and sections of the input that did not match\n+     * the expression are copied unchanged to the output string.\n+     *\n+     * Format strings (from ECMA-262 [15.5.4.11]):\n+     * @li $$  The dollar-sign itself ($)\n+     * @li $&  The matched substring.\n+     * @li $`  The portion of @a string that precedes the matched substring.\n+     *         This would be match_results::prefix().\n+     * @li $'  The portion of @a string that follows the matched substring.\n+     *         This would be match_results::suffix().\n+     * @li $n  The nth capture, where n is in [1,9] and $n is not followed by a\n+     *         decimal digit.  If n <= match_results::size() and the nth capture\n+     *         is undefined, use the empty string instead.  If n >\n+     *         match_results::size(), the result is implementation-defined.\n+     * @li $nn The nnth capture, where nn is a two-digit decimal number on\n+     *         [01, 99].  If nn <= match_results::size() and the nth capture is\n+     *         undefined, use the empty string instead. If\n+     *         nn > match_results::size(), the result is implementation-defined.\n+     */\n+    format_default    = 0,\n \n-  /**\n-   * When a regular expression match is to be replaced by a new string, the\n-   * new string is constructed using the rules used by the ECMAScript replace\n-   * function in ECMA- 262 [Ecma International, ECMAScript Language\n-   * Specification, Standard Ecma-262, third edition, 1999], part 15.5.4.11\n-   * String.prototype.replace. In addition, during search and replace\n-   * operations all non-overlapping occurrences of the regular expression\n-   * are located and replaced, and sections of the input that did not match\n-   * the expression are copied unchanged to the output string.\n-   *\n-   * Format strings (from ECMA-262 [15.5.4.11]):\n-   * @li $$  The dollar-sign itself ($)\n-   * @li $&  The matched substring.\n-   * @li $`  The portion of @a string that precedes the matched substring.\n-   *         This would be match_results::prefix().\n-   * @li $'  The portion of @a string that follows the matched substring.\n-   *         This would be match_results::suffix().\n-   * @li $n  The nth capture, where n is in [1,9] and $n is not followed by a\n-   *         decimal digit.  If n <= match_results::size() and the nth capture\n-   *         is undefined, use the empty string instead.  If n >\n-   *         match_results::size(), the result is implementation-defined.\n-   * @li $nn The nnth capture, where nn is a two-digit decimal number on\n-   *         [01, 99].  If nn <= match_results::size() and the nth capture is\n-   *         undefined, use the empty string instead. If\n-   *         nn > match_results::size(), the result is implementation-defined.\n-   */\n-  constexpr match_flag_type format_default    = 0;\n+    /**\n+     * When a regular expression match is to be replaced by a new string, the\n+     * new string is constructed using the rules used by the POSIX sed utility\n+     * in IEEE Std 1003.1- 2001 [IEEE, Information Technology -- Portable\n+     * Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n+     */\n+    format_sed        = 1 << _S_sed,\n \n-  /**\n-   * When a regular expression match is to be replaced by a new string, the\n-   * new string is constructed using the rules used by the POSIX sed utility\n-   * in IEEE Std 1003.1- 2001 [IEEE, Information Technology -- Portable\n-   * Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n-   */\n-  constexpr match_flag_type format_sed        = 1 << _S_sed;\n+    /**\n+     * During a search and replace operation, sections of the character\n+     * container sequence being searched that do not match the regular\n+     * expression shall not be copied to the output string.\n+     */\n+    format_no_copy    = 1 << _S_no_copy,\n \n-  /**\n-   * During a search and replace operation, sections of the character\n-   * container sequence being searched that do not match the regular\n-   * expression shall not be copied to the output string.\n-   */\n-  constexpr match_flag_type format_no_copy    = 1 << _S_no_copy;\n+    /**\n+     * When specified during a search and replace operation, only the first\n+     * occurrence of the regular expression shall be replaced.\n+     */\n+    format_first_only = 1 << _S_first_only,\n+  };\n \n-  /**\n-   * When specified during a search and replace operation, only the first\n-   * occurrence of the regular expression shall be replaced.\n-   */\n-  constexpr match_flag_type format_first_only = 1 << _S_first_only;\n+  constexpr inline match_flag_type\n+  operator&(match_flag_type __a, match_flag_type __b)\n+  {\n+    return (match_flag_type)(static_cast<unsigned int>(__a)\n+\t\t\t\t& static_cast<unsigned int>(__b));\n+  }\n+\n+  constexpr inline match_flag_type\n+  operator|(match_flag_type __a, match_flag_type __b)\n+  {\n+    return (match_flag_type)(static_cast<unsigned int>(__a)\n+\t\t\t\t| static_cast<unsigned int>(__b));\n+  }\n+\n+  constexpr inline match_flag_type\n+  operator^(match_flag_type __a, match_flag_type __b)\n+  {\n+    return (match_flag_type)(static_cast<unsigned int>(__a)\n+\t\t\t\t^ static_cast<unsigned int>(__b));\n+  }\n+\n+  constexpr inline match_flag_type\n+  operator~(match_flag_type __a)\n+  { return (match_flag_type)(~static_cast<unsigned int>(__a)); }\n+\n+  inline match_flag_type&\n+  operator&=(match_flag_type& __a, match_flag_type __b)\n+  { return __a = __a & __b; }\n+\n+  inline match_flag_type&\n+  operator|=(match_flag_type& __a, match_flag_type __b)\n+  { return __a = __a | __b; }\n+\n+  inline match_flag_type&\n+  operator^=(match_flag_type& __a, match_flag_type __b)\n+  { return __a = __a ^ __b; }\n \n   //@}\n "}, {"sha": "b8e9266f910255db59078be4bc1b7592feb97d3b", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 157, "deletions": 125, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=b21abceec3c77f2b847b4687947d7fcf745ffdf9", "patch": "@@ -28,7 +28,11 @@\n  *  Do not attempt to use it directly. @headername{regex}\n  */\n \n-// TODO: convert comments to doxygen format.\n+// FIXME convert comments to doxygen format.\n+\n+// TODO Put _DFSExecutor and _BFSExecutor into one class. They are becoming\n+// much more similar. Also, make grouping seperated. The\n+// regex_constants::nosubs enables much more simpler execution.\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -57,55 +61,107 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     class _Executor\n     {\n     public:\n+      typedef basic_regex<_CharT, _TraitsT>           _RegexT;\n       typedef match_results<_BiIter, _Alloc>          _ResultsT;\n       typedef std::vector<sub_match<_BiIter>, _Alloc> _ResultsVec;\n       typedef regex_constants::match_flag_type        _FlagT;\n+      typedef typename _TraitsT::char_class_type      _ClassT;\n \n-      virtual\n-      ~_Executor()\n+    public:\n+      _Executor(_BiIter         __begin,\n+\t\t_BiIter         __end,\n+\t\t_ResultsT&      __results,\n+\t\tconst _RegexT&  __re,\n+\t\t_FlagT          __flags)\n+      : _M_begin(__begin),\n+      _M_end(__end),\n+      _M_results(__results),\n+      _M_re(__re),\n+      _M_flags(__flags)\n       { }\n \n       // Set matched when string exactly match the pattern.\n-      virtual bool\n-      _M_match() = 0;\n+      bool\n+      _M_match()\n+      {\n+\t_M_match_mode = true;\n+\t_M_init(_M_begin);\n+\treturn _M_main();\n+      }\n \n       // Set matched when some prefix of the string matches the pattern.\n-      virtual bool\n-      _M_search() = 0;\n-\n-    protected:\n-      typedef typename _NFA<_CharT, _TraitsT>::_SizeT _SizeT;\n-      typedef typename _TraitsT::char_class_type      _ClassT;\n+      bool\n+      _M_search_from_first()\n+      {\n+\t_M_match_mode = false;\n+\t_M_init(_M_begin);\n+\treturn _M_main();\n+      }\n \n-      _Executor(_BiIter         __begin,\n-\t\t_BiIter         __end,\n-\t\t_ResultsT&      __results,\n-\t\t_FlagT          __flags,\n-\t\t_SizeT          __size,\n-\t\tconst _TraitsT& __traits)\n-      : _M_current(__begin), _M_begin(__begin), _M_end(__end),\n-      _M_results(__results), _M_flags(__flags), _M_traits(__traits)\n+      bool\n+      _M_search()\n       {\n-\t__size += 2;\n-\t_M_results.resize(__size);\n-\tfor (_SizeT __i = 0; __i < __size; ++__i)\n-\t  _M_results[__i].matched = false;\n+\tif (_M_flags & regex_constants::match_continuous)\n+\t  return _M_search_from_first();\n+\tauto __cur = _M_begin;\n+\tdo\n+\t  {\n+\t    _M_match_mode = false;\n+\t    _M_init(__cur);\n+\t    if (_M_main())\n+\t      return true;\n+\t  }\n+\t// Continue when __cur == _M_end\n+\twhile (__cur++ != _M_end);\n+\treturn false;\n       }\n \n       bool\n-      _M_is_word(_CharT __ch)\n+      _M_is_word(_CharT __ch) const\n       {\n \tstatic const _CharT __s = 'w';\n-\treturn _M_traits.isctype(__ch,\n-\t\t\t\t _M_traits.lookup_classname(&__s, &__s+1));\n+\treturn _M_re._M_traits.isctype\n+\t  (__ch, _M_re._M_traits.lookup_classname(&__s, &__s+1));\n+      }\n+\n+      bool\n+      _M_at_begin() const\n+      {\n+\treturn _M_current == _M_begin\n+\t  && !(_M_flags & (regex_constants::match_not_bol\n+\t\t\t   | regex_constants::match_prev_avail));\n       }\n \n+      bool\n+      _M_at_end() const\n+      {\n+\treturn _M_current == _M_end\n+\t  && !(_M_flags & regex_constants::match_not_eol);\n+      }\n+\n+      bool\n+      _M_word_boundry(_State<_CharT, _TraitsT> __state) const;\n+\n+      bool\n+      _M_lookahead(_State<_CharT, _TraitsT> __state) const;\n+\n+    public:\n+      virtual void\n+      _M_init(_BiIter __cur) = 0;\n+\n+      virtual void\n+      _M_set_start(_StateIdT __start) = 0;\n+\n+      virtual bool\n+      _M_main() = 0;\n+\n       _BiIter         _M_current;\n       const _BiIter   _M_begin;\n       const _BiIter   _M_end;\n-      _ResultsVec&    _M_results;\n-      const _TraitsT& _M_traits;\n-      _FlagT          _M_flags;\n+      const _RegexT&  _M_re;\n+      _ResultsT&      _M_results;\n+      const _FlagT    _M_flags;\n+      bool            _M_match_mode;\n     };\n \n   // A _DFSExecutor perform a DFS on given NFA and input string. At the very\n@@ -128,61 +184,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n     public:\n       typedef _Executor<_BiIter, _Alloc, _CharT, _TraitsT> _BaseT;\n-      typedef _NFA<_CharT, _TraitsT>                       _RegexT;\n+      typedef _NFA<_CharT, _TraitsT>                       _NFAT;\n+      typedef typename _BaseT::_RegexT                     _RegexT;\n       typedef typename _BaseT::_ResultsT                   _ResultsT;\n       typedef typename _BaseT::_ResultsVec                 _ResultsVec;\n-      typedef regex_constants::match_flag_type             _FlagT;\n+      typedef typename _BaseT::_FlagT                      _FlagT;\n \n+    public:\n       _DFSExecutor(_BiIter         __begin,\n \t\t   _BiIter         __end,\n \t\t   _ResultsT&      __results,\n-\t\t   const _RegexT&  __nfa,\n-\t\t   const _TraitsT& __traits,\n+\t\t   const _RegexT&  __re,\n \t\t   _FlagT          __flags)\n-      : _BaseT(__begin, __end, __results, __flags, __nfa._M_sub_count(),\n-\t       __traits),\n-\t_M_traits(__traits), _M_nfa(__nfa), _M_cur_results(this->_M_results),\n-\t_M_start_state(__nfa._M_start())\n+      : _BaseT(__begin, __end, __results, __re, __flags),\n+      _M_nfa(*std::static_pointer_cast<_NFA<_CharT, _TraitsT>>\n+\t     (__re._M_automaton)),\n+      _M_start_state(_M_nfa._M_start())\n       { }\n \n-      bool\n-      _M_match()\n+    private:\n+      void\n+      _M_init(_BiIter __cur)\n       {\n-\tthis->_M_current = this->_M_begin;\n-\treturn _M_dfs<true>(_M_start_state);\n+\t_M_cur_results.resize(_M_nfa._M_sub_count() + 2);\n+\tthis->_M_current = __cur;\n       }\n \n-      bool\n-      _M_search_from_first()\n-      {\n-\tthis->_M_current = this->_M_begin;\n-\treturn _M_dfs<false>(_M_start_state);\n-      }\n+      void\n+      _M_set_start(_StateIdT __start)\n+      { _M_start_state = __start; }\n \n       bool\n-      _M_search()\n-      {\n-\tauto __cur = this->_M_begin;\n-\tdo\n-\t  {\n-\t    this->_M_current = __cur;\n-\t    if (_M_dfs<false>(_M_start_state))\n-\t      return true;\n-\t  }\n-\t// Continue when __cur == _M_end\n-\twhile (__cur++ != this->_M_end);\n-\treturn false;\n-      }\n+      _M_main()\n+      { return _M_dfs(this->_M_start_state); }\n \n-    private:\n-      template<bool __match_mode>\n-\tbool\n-\t_M_dfs(_StateIdT __i);\n+      bool\n+      _M_dfs(_StateIdT __start);\n \n       // To record current solution.\n       _ResultsVec     _M_cur_results;\n-      const _TraitsT& _M_traits;\n-      const _RegexT&  _M_nfa;\n+      const _NFAT&    _M_nfa;\n       _StateIdT       _M_start_state;\n     };\n \n@@ -206,47 +247,57 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n     public:\n       typedef _Executor<_BiIter, _Alloc, _CharT, _TraitsT> _BaseT;\n-      typedef _NFA<_CharT, _TraitsT>                       _RegexT;\n+      typedef _NFA<_CharT, _TraitsT>                       _NFAT;\n+      typedef typename _BaseT::_RegexT                     _RegexT;\n       typedef typename _BaseT::_ResultsT                   _ResultsT;\n+      typedef typename _BaseT::_ResultsVec                 _ResultsVec;\n+      typedef typename _BaseT::_FlagT                      _FlagT;\n       // Here's a solution for greedy/ungreedy mode in BFS approach. We need to\n       // carefully work out how to compare to conflict matching states.\n       //\n       // A matching state is a pair(where, when); `where` is a NFA node; `when`\n-      // is a _BiIter, indicating which char is the next to be mathed one.  Two\n-      // matching states conflict means that they have equivalent `where` and\n-      // `when`.\n+      // is a _BiIter, indicating which char is the next to be matched. Two\n+      // matching states conflict if they have equivalent `where` and `when`.\n       //\n-      // Now since we need to drop one and keep another, because at most one of\n-      // them could be the final optimal solution. This behavior is affected by\n+      // Now we need to drop one and keep another, because at most one of them\n+      // could be the final optimal solution. This behavior is affected by\n       // greedy policy.\n       //\n       // The definition of `greedy`:\n       // For the sequence of quantifiers in NFA sorted by there start position,\n-      // now maintain a vector in a matching state, with equal length to\n+      // now maintain a vector in every matching state, with equal length to\n       // quantifier seq, recording repeating times of every quantifier. Now to\n       // compare two matching states, we just lexically compare these two\n       // vectors. To win the compare(to survive), one matching state needs to\n       // make its greedy quantifier count larger, and ungreedy quantifiers\n       // count smaller.\n       //\n-      // In the implementation, we recorded negtive numbers for greedy\n-      // quantifiers and positive numbers of ungreedy ones. Now a simple\n+      // In the implementation, we recorded negtive counts for greedy\n+      // quantifiers and positive counts of ungreedy ones. Now the implicit\n       // operator<() for lexicographical_compare will emit the answer.\n       //\n       // When two vectors equal, it means the `where`, `when` and quantifier\n-      // counts are identical, it indicates the same answer, so just return\n+      // counts are identical, and indicates the same solution; so just return\n       // false.\n       struct _ResultsEntry\n-      : private _BaseT::_ResultsVec\n+      : private _ResultsVec\n       {\n       public:\n \t_ResultsEntry(unsigned int __res_sz, unsigned int __sz)\n-\t: _BaseT::_ResultsVec(__res_sz), _M_quant_keys(__sz)\n+\t: _ResultsVec(__res_sz), _M_quant_keys(__sz)\n \t{ }\n \n+\tvoid\n+\tresize(unsigned int __n)\n+\t{ _ResultsVec::resize(__n); }\n+\n+\tunsigned int\n+\tsize()\n+\t{ return _ResultsVec::size(); }\n+\n \tsub_match<_BiIter>&\n \toperator[](unsigned int __idx)\n-\t{ return this->_BaseT::_ResultsVec::operator[](__idx); }\n+\t{ return _ResultsVec::operator[](__idx); }\n \n \tbool\n \toperator<(const _ResultsEntry& __rhs) const\n@@ -263,75 +314,47 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_inc(unsigned int __idx, bool __neg)\n \t{ _M_quant_keys[__idx] += __neg ? 1 : -1; }\n \n-\ttypename _BaseT::_ResultsVec\n+\t_ResultsVec\n \t_M_get()\n \t{ return *this; }\n \n       public:\n \tstd::vector<int> _M_quant_keys;\n       };\n-\n       typedef std::unique_ptr<_ResultsEntry>               _ResultsPtr;\n-      typedef regex_constants::match_flag_type             _FlagT;\n \n+    public:\n       _BFSExecutor(_BiIter         __begin,\n \t\t   _BiIter         __end,\n \t\t   _ResultsT&      __results,\n-\t\t   const _RegexT&  __nfa,\n-\t\t   const _TraitsT& __traits,\n+\t\t   const _RegexT&  __re,\n \t\t   _FlagT          __flags)\n-      : _BaseT(__begin, __end, __results, __flags, __nfa._M_sub_count(),\n-\t       __traits),\n-\t_M_nfa(__nfa),\n-\t_M_cur_results(nullptr),\n-\t_M_start_state(__nfa._M_start())\n+      : _BaseT(__begin, __end, __results, __re, __flags),\n+      _M_nfa(*std::static_pointer_cast<_NFA<_CharT, _TraitsT>>\n+\t     (__re._M_automaton)),\n+      _M_start_state(_M_nfa._M_start())\n       { }\n \n-      bool\n-      _M_match()\n-      {\n-\t_M_init(this->_M_begin);\n-\treturn _M_main_loop<true>();\n-      }\n-\n-      bool\n-      _M_search_from_first()\n-      {\n-\t_M_init(this->_M_begin);\n-\treturn _M_main_loop<false>();\n-      }\n-\n-      bool\n-      _M_search()\n-      {\n-\tauto __cur = this->_M_begin;\n-\tdo\n-\t  {\n-\t    _M_init(__cur);\n-\t    if (_M_main_loop<false>())\n-\t      return true;\n-\t  }\n-\t// Continue when __cur == _M_end\n-\twhile (__cur++ != this->_M_end);\n-\treturn false;\n-      }\n-\n     private:\n       void\n       _M_init(_BiIter __cur)\n       {\n-\t_GLIBCXX_DEBUG_ASSERT(_M_start_state != _S_invalid_state_id);\n+\t_GLIBCXX_DEBUG_ASSERT(this->_M_start_state != _S_invalid_state_id);\n \tthis->_M_current = __cur;\n \t_M_covered.clear();\n-\t_M_covered[_M_start_state] =\n-\t  _ResultsPtr(new _ResultsEntry(this->_M_results.size(),\n+\t_ResultsVec& __res(this->_M_results);\n+\t_M_covered[this->_M_start_state] =\n+\t  _ResultsPtr(new _ResultsEntry(__res.size(),\n \t\t\t\t\t_M_nfa._M_quant_count));\n \t_M_e_closure();\n       }\n \n-      template<bool __match_mode>\n-\tbool\n-\t_M_main_loop();\n+      void\n+      _M_set_start(_StateIdT __start)\n+      { _M_start_state = __start; }\n+\n+      bool\n+      _M_main();\n \n       void\n       _M_e_closure();\n@@ -345,10 +368,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::map<_StateIdT, _ResultsPtr> _M_covered;\n       // To record global optimal solution.\n       _ResultsPtr                      _M_cur_results;\n-      const _RegexT&                   _M_nfa;\n+      const _NFAT&                     _M_nfa;\n       _StateIdT                        _M_start_state;\n     };\n \n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    std::unique_ptr<_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n+    __get_executor(_BiIter __b,\n+\t\t   _BiIter __e,\n+\t\t   match_results<_BiIter, _Alloc>& __m,\n+\t\t   const basic_regex<_CharT, _TraitsT>& __re,\n+\t\t   regex_constants::match_flag_type __flags);\n+\n  //@} regex-detail\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace __detail"}, {"sha": "af2455b8a4e366605fd3b89894d586982e550357", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 121, "deletions": 117, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=b21abceec3c77f2b847b4687947d7fcf745ffdf9", "patch": "@@ -36,147 +36,129 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n-  template<bool __match_mode>\n     bool _DFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n     _M_dfs(_StateIdT __i)\n     {\n       if (__i == _S_invalid_state_id)\n \t// This is not that certain. Need deeper investigate.\n \treturn false;\n       auto& __current = this->_M_current;\n-      auto& __begin = this->_M_begin;\n-      auto& __end = this->_M_end;\n-      auto& __results = _M_cur_results;\n       const auto& __state = _M_nfa[__i];\n       bool __ret = false;\n       switch (__state._M_opcode)\n \t{\n \tcase _S_opcode_alternative:\n \t  // Greedy or not, this is a question ;)\n \t  if (!__state._M_neg)\n-\t    __ret = _M_dfs<__match_mode>(__state._M_alt)\n-\t      || _M_dfs<__match_mode>(__state._M_next);\n+\t    __ret = _M_dfs(__state._M_alt)\n+\t      || _M_dfs(__state._M_next);\n \t  else\n-\t    __ret = _M_dfs<__match_mode>(__state._M_next)\n-\t      || _M_dfs<__match_mode>(__state._M_alt);\n+\t    __ret = _M_dfs(__state._M_next)\n+\t      || _M_dfs(__state._M_alt);\n \t  break;\n \tcase _S_opcode_subexpr_begin:\n \t  // Here's the critical part: if there's nothing changed since last\n \t  // visit, do NOT continue. This prevents the executor from get into\n \t  // infinite loop when use \"()*\" to match \"\".\n \t  //\n-\t  // Every change on __results will be roll back after the recursion\n-\t  // step finished.\n-\t  if (!__results[__state._M_subexpr].matched\n-\t      || __results[__state._M_subexpr].first != __current)\n+\t  // Every change on _M_cur_results will be roll back after the\n+\t  // recursion step finished.\n+\t  if (!_M_cur_results[__state._M_subexpr].matched\n+\t      || _M_cur_results[__state._M_subexpr].first != __current)\n \t    {\n \t      auto __back = __current;\n-\t      __results[__state._M_subexpr].first = __current;\n-\t      __ret = _M_dfs<__match_mode>(__state._M_next);\n-\t      __results[__state._M_subexpr].first = __back;\n+\t      _M_cur_results[__state._M_subexpr].first = __current;\n+\t      __ret = _M_dfs(__state._M_next);\n+\t      _M_cur_results[__state._M_subexpr].first = __back;\n \t    }\n \t  break;\n \tcase _S_opcode_subexpr_end:\n-\t  if (__results[__state._M_subexpr].second != __current\n-\t      || __results[__state._M_subexpr].matched != true)\n+\t  if (_M_cur_results[__state._M_subexpr].second != __current\n+\t      || _M_cur_results[__state._M_subexpr].matched != true)\n \t    {\n-\t      auto __back = __results[__state._M_subexpr];\n-\t      __results[__state._M_subexpr].second = __current;\n-\t      __results[__state._M_subexpr].matched = true;\n-\t      __ret = _M_dfs<__match_mode>(__state._M_next);\n-\t      __results[__state._M_subexpr] = __back;\n+\t      auto __back = _M_cur_results[__state._M_subexpr];\n+\t      _M_cur_results[__state._M_subexpr].second = __current;\n+\t      _M_cur_results[__state._M_subexpr].matched = true;\n+\t      __ret = _M_dfs(__state._M_next);\n+\t      _M_cur_results[__state._M_subexpr] = __back;\n \t    }\n \t  else\n-\t    __ret = _M_dfs<__match_mode>(__state._M_next);\n+\t    __ret = _M_dfs(__state._M_next);\n \t  break;\n \tcase _S_opcode_line_begin_assertion:\n-\t  if (__current == __begin)\n-\t    __ret = _M_dfs<__match_mode>(__state._M_next);\n+\t  if (this->_M_at_begin())\n+\t    __ret = _M_dfs(__state._M_next);\n \t  break;\n \tcase _S_opcode_line_end_assertion:\n-\t  if (__current == __end)\n-\t    __ret = _M_dfs<__match_mode>(__state._M_next);\n+\t  if (this->_M_at_end())\n+\t    __ret = _M_dfs(__state._M_next);\n \t  break;\n-\t  // By definition.\n \tcase _S_opcode_word_boundry:\n-\t    {\n-\t      bool __ans = false;\n-\t      if (__current == __begin && this->_M_is_word(*__current))\n-\t\t__ans = true;\n-\t      else if (__current == __end && this->_M_is_word(*__current))\n-\t\t__ans = true;\n-\t      else\n-\t\t{\n-\t\t  auto __pre = __current;\n-\t\t  --__pre;\n-\t\t  if (this->_M_is_word(*__current)\n-\t\t      != this->_M_is_word(*__pre))\n-\t\t    __ans = true;\n-\t\t}\n-\t      if (__ans == !__state._M_neg)\n-\t\t__ret = _M_dfs<__match_mode>(__state._M_next);\n-\t    }\n+\t  if (this->_M_word_boundry(__state) == !__state._M_neg)\n+\t    __ret = _M_dfs(__state._M_next);\n \t  break;\n \t  // Here __state._M_alt offers a single start node for a sub-NFA.\n \t  // We recursivly invoke our algorithm to match the sub-NFA.\n \tcase _S_opcode_subexpr_lookahead:\n-\t    {\n-\t      _ResultsT __m;\n-\t      // FIXME Here's not necessarily a DFSExecutor. But we need to\n-\t      // refactor the whole NFA to a recursive tree structure first.\n-\t      _DFSExecutor __sub(this->_M_current,\n-\t\t\t\t this->_M_end,\n-\t\t\t\t __m,\n-\t\t\t\t this->_M_nfa,\n-\t\t\t\t this->_M_traits,\n-\t\t\t\t this->_M_flags);\n-\t      __sub._M_start_state = __state._M_alt;\n-\t      if (__sub._M_search_from_first() == !__state._M_neg)\n-\t\t__ret = _M_dfs<__match_mode>(__state._M_next);\n-\t    }\n+\t  if (this->_M_lookahead(__state) == !__state._M_neg)\n+\t    __ret = _M_dfs(__state._M_next);\n \t  break;\n \tcase _S_opcode_match:\n-\t  if (__current != __end && __state._M_matches(*__current))\n+\t  if (__current != this->_M_end && __state._M_matches(*__current))\n \t    {\n \t      ++__current;\n-\t      __ret = _M_dfs<__match_mode>(__state._M_next);\n+\t      __ret = _M_dfs(__state._M_next);\n \t      --__current;\n \t    }\n \t  break;\n-\t// First fetch the matched result from __results as __submatch;\n+\t// First fetch the matched result from _M_cur_results as __submatch;\n \t// then compare it with\n \t// (__current, __current + (__submatch.second - __submatch.first))\n \t// If matched, keep going; else just return to try another state.\n \tcase _S_opcode_backref:\n \t  {\n-\t    auto& __submatch = __results[__state._M_backref_index];\n+\t    auto& __submatch = _M_cur_results[__state._M_backref_index];\n \t    if (!__submatch.matched)\n \t      break;\n \t    auto __last = __current;\n \t    for (auto __tmp = __submatch.first;\n-\t\t __last != __end && __tmp != __submatch.second;\n+\t\t __last != this->_M_end && __tmp != __submatch.second;\n \t\t ++__tmp)\n \t      ++__last;\n-\t    if (_M_traits.transform(__submatch.first, __submatch.second)\n-\t\t== _M_traits.transform(__current, __last))\n+\t    if (this->_M_re._M_traits.transform(__submatch.first,\n+\t\t\t\t\t\t__submatch.second)\n+\t\t== this->_M_re._M_traits.transform(__current, __last))\n \t      if (__last != __current)\n \t\t{\n \t\t  auto __backup = __current;\n \t\t  __current = __last;\n-\t\t  __ret = _M_dfs<__match_mode>(__state._M_next);\n+\t\t  __ret = _M_dfs(__state._M_next);\n \t\t  __current = __backup;\n \t\t}\n \t      else\n-\t\t__ret = _M_dfs<__match_mode>(__state._M_next);\n+\t\t__ret = _M_dfs(__state._M_next);\n \t  }\n \t  break;\n \tcase _S_opcode_accept:\n-\t  if (__match_mode)\n-\t    __ret = __current == __end;\n+\t  if (this->_M_match_mode)\n+\t    __ret = __current == this->_M_end;\n \t  else\n \t    __ret = true;\n+\t  if (__current == this->_M_begin\n+\t      && (this->_M_flags & regex_constants::match_not_null))\n+\t    __ret = false;\n \t  if (__ret)\n-\t    this->_M_results = __results;\n+\t    {\n+\t      _ResultsVec& __res(this->_M_results);\n+\t      if (this->_M_re.flags() & regex_constants::nosubs)\n+\t\t{\n+\t\t  _M_cur_results.resize(3); // truncate\n+\t\t  __res.resize(3);\n+\t\t}\n+\t      for (unsigned int __i = 0; __i < _M_cur_results.size(); ++__i)\n+\t\tif (_M_cur_results[__i].matched)\n+\t\t  __res[__i] = _M_cur_results[__i];\n+\t    }\n \t  break;\n \tdefault:\n \t  _GLIBCXX_DEBUG_ASSERT(false);\n@@ -186,23 +168,37 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n-  template<bool __match_mode>\n     bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n-    _M_main_loop()\n+    _M_main()\n     {\n       bool __ret = false;\n+      if (!this->_M_match_mode\n+\t  && !(this->_M_flags & regex_constants::match_not_null))\n+\t__ret = _M_includes_some() || __ret;\n       while (this->_M_current != this->_M_end)\n \t{\n-\t  if (!__match_mode)\n-\t    // To keep regex_search greedy, no \"return true\" here.\n-\t    __ret = _M_includes_some() || __ret;\n \t  _M_move();\n \t  ++this->_M_current;\n \t  _M_e_closure();\n+\t  if (!this->_M_match_mode)\n+\t    // To keep regex_search greedy, no \"return true\" here.\n+\t    __ret = _M_includes_some() || __ret;\n \t}\n-      __ret = _M_includes_some() || __ret;\n+      if (this->_M_match_mode)\n+\t__ret = _M_includes_some();\n       if (__ret)\n-\tthis->_M_results = _M_cur_results->_M_get();\n+\t{\n+\t  _ResultsVec& __res(this->_M_results);\n+\t  if (this->_M_re.flags() & regex_constants::nosubs)\n+\t    {\n+\t      // truncate\n+\t      _M_cur_results->resize(3);\n+\t      __res.resize(3);\n+\t    }\n+\t  for (unsigned int __i = 0; __i < _M_cur_results->size(); ++__i)\n+\t    if ((*_M_cur_results)[__i].matched)\n+\t      __res[__i] = (*_M_cur_results)[__i];\n+\t}\n       return __ret;\n     }\n \n@@ -211,11 +207,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n     _M_e_closure()\n     {\n-      auto& __current = this->_M_current;\n       std::queue<_StateIdT> __q;\n       std::vector<bool> __in_q(_M_nfa.size(), false);\n-      auto& __begin = this->_M_begin;\n-      auto& __end = this->_M_end;\n+      auto& __current = this->_M_current;\n \n       for (auto& __it : _M_covered)\n \t{\n@@ -292,46 +286,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t}\n \t\tbreak;\n \t      case _S_opcode_line_begin_assertion:\n-\t\tif (__current == __begin)\n+\t\tif (this->_M_at_begin())\n \t\t  __add_visited_state(__state._M_next);\n \t\tbreak;\n \t      case _S_opcode_line_end_assertion:\n-\t\tif (__current == __end)\n+\t\tif (this->_M_at_end())\n \t\t  __add_visited_state(__state._M_next);\n \t\tbreak;\n \t      case _S_opcode_word_boundry:\n-\t\t  {\n-\t\t    bool __ans = false;\n-\t\t    if (__current == __begin && this->_M_is_word(*__current))\n-\t\t      __ans = true;\n-\t\t    else if (__current == __end && this->_M_is_word(*__current))\n-\t\t      __ans = true;\n-\t\t    else\n-\t\t      {\n-\t\t\tauto __pre = __current;\n-\t\t\t--__pre;\n-\t\t\tif (this->_M_is_word(*__current)\n-\t\t\t    != this->_M_is_word(*__pre))\n-\t\t\t  __ans = true;\n-\t\t      }\n-\t\t    if (__ans == !__state._M_neg)\n-\t\t      __add_visited_state(__state._M_next);\n-\t\t  }\n+\t\tif (this->_M_word_boundry(__state) == !__state._M_neg)\n+\t\t  __add_visited_state(__state._M_next);\n \t\tbreak;\n \t      case _S_opcode_subexpr_lookahead:\n-\t\t  {\n-\t\t    _ResultsT __m;\n-\t\t    // Same comment as in DFS.\n-\t\t    _BFSExecutor __sub(this->_M_current,\n-\t\t\t\t       this->_M_end,\n-\t\t\t\t       __m,\n-\t\t\t\t       this->_M_nfa,\n-\t\t\t\t       this->_M_traits,\n-\t\t\t\t       this->_M_flags);\n-\t\t    __sub._M_start_state = __state._M_alt;\n-\t\t    if (__sub._M_search_from_first() == !__state._M_neg)\n-\t\t      __add_visited_state(__state._M_next);\n-\t\t  }\n+\t\tif (this->_M_lookahead(__state) == !__state._M_neg)\n+\t\t  __add_visited_state(__state._M_next);\n \t\tbreak;\n \t      case _S_opcode_match:\n \t\tbreak;\n@@ -395,6 +363,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __succ;\n     }\n \n+  // Return whether now is at some word boundry.\n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    bool _Executor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+    _M_word_boundry(_State<_CharT, _TraitsT> __state) const\n+    {\n+      // By definition.\n+      bool __ans = false;\n+      auto __pre = _M_current;\n+      --__pre;\n+      if (!(_M_at_begin() && _M_at_end()))\n+\tif (_M_at_begin())\n+\t  __ans = _M_is_word(*_M_current)\n+\t    && !(_M_flags & regex_constants::match_not_bow);\n+\telse if (_M_at_end())\n+\t  __ans = _M_is_word(*__pre)\n+\t    && !(_M_flags & regex_constants::match_not_eow);\n+\telse\n+\t  __ans = _M_is_word(*_M_current)\n+\t    != _M_is_word(*__pre);\n+      return __ans;\n+    }\n+\n+  // Return whether now match the given sub-NFA.\n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    bool _Executor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+    _M_lookahead(_State<_CharT, _TraitsT> __state) const\n+    {\n+      auto __sub = __get_executor(this->_M_current,\n+\t\t\t\t  this->_M_end,\n+\t\t\t\t  this->_M_results,\n+\t\t\t\t  this->_M_re,\n+\t\t\t\t  this->_M_flags);\n+      __sub->_M_set_start(__state._M_alt);\n+      return __sub->_M_search_from_first();\n+    }\n+\n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n     std::unique_ptr<_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n@@ -411,10 +417,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       auto __p = std::static_pointer_cast<_NFA<_CharT, _TraitsT>>\n \t(__re._M_automaton);\n       if (__p->_M_has_backref)\n-\treturn _ExecutorPtr(new _DFSExecutorT(__b, __e, __m, *__p,\n-\t\t\t\t\t      __re._M_traits, __flags));\n-      return _ExecutorPtr(new _BFSExecutorT(__b, __e, __m, *__p,\n-\t\t\t\t\t    __re._M_traits, __flags));\n+\treturn _ExecutorPtr(new _DFSExecutorT(__b, __e, __m, __re, __flags));\n+      return _ExecutorPtr(new _BFSExecutorT(__b, __e, __m, __re, __flags));\n     }\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "09a18f634a09a7b3adebaa389b87431375243fac", "filename": "libstdc++-v3/include/bits/regex_scanner.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h?ref=b21abceec3c77f2b847b4687947d7fcf745ffdf9", "patch": "@@ -68,7 +68,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_token_backref,\n \t_S_token_subexpr_begin,\n \t_S_token_subexpr_no_group_begin,\n-\t_S_token_subexpr_lookahead_begin,\n+\t_S_token_subexpr_lookahead_begin, // neg if _M_value[0] == 'n'\n \t_S_token_subexpr_end,\n \t_S_token_bracket_begin,\n \t_S_token_bracket_neg_begin,\n@@ -86,7 +86,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_token_ungreedy,\n \t_S_token_line_begin,\n \t_S_token_line_end,\n-\t_S_token_word_bound,\n+\t_S_token_word_bound, // neg if _M_value[0] == 'n'\n \t_S_token_comma,\n \t_S_token_dup_count,\n \t_S_token_eof,\n@@ -174,7 +174,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _StringT                      _M_value;\n       bool                          _M_at_bracket_start;\n     public:\n-      // TODO: make them static when this file is stable.\n+      // FIXME: make them static when this file is stable.\n       const std::map<char, _TokenT> _M_token_map;\n       const std::map<char, char>    _M_ecma_escape_map;\n       const std::map<char, char>    _M_awk_escape_map;"}, {"sha": "abdbcc64f1f3b4d9d41b728268f3e2b581a75b0f", "filename": "libstdc++-v3/include/bits/regex_scanner.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc?ref=b21abceec3c77f2b847b4687947d7fcf745ffdf9", "patch": "@@ -28,7 +28,7 @@\n  *  Do not attempt to use it directly. @headername{regex}\n  */\n \n-// TODO make comments doxygen format.\n+// FIXME make comments doxygen format.\n \n // N3376 specified 6 regex styles: ECMAScript, basic, extended, grep, egrep\n // and awk"}, {"sha": "3064b3b26e4bbe68e34b148629422aa5792f383c", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_search/ecma/assertion.cc", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fassertion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fassertion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fassertion.cc?ref=b21abceec3c77f2b847b4687947d7fcf745ffdf9", "patch": "@@ -1,5 +1,4 @@\n // { dg-options \"-std=gnu++11\" }\n-// { dg-do run { xfail *-*-* } }\n \n //\n // 2013-09-14  Tim Shen <timshen91@gmail.com>\n@@ -54,22 +53,37 @@ test01()\n   string sol[] =\n     {\n       \"This\",\n+      \"\",\n       \"is\",\n+      \"\",\n       \"a\",\n+      \"\",\n       \"regular\",\n+      \"\",\n       \"expression\",\n+      \"\",\n     };\n \n   regex re(\"\\\\b\\\\w*\\\\b\");\n   int i = 0;\n   for (auto it = sregex_iterator(s.begin(), s.end(), re);\n-       it != sregex_iterator() && i < 5;\n+       it != sregex_iterator();\n        ++it)\n     {\n       string s((*it)[0].first, (*it)[0].second);\n       VERIFY(s == sol[i++]);\n     }\n-  VERIFY(i == 5);\n+  VERIFY(i == 10);\n+\n+  {\n+    cmatch m;\n+    regex re(\"(?=(as)df)as(df)\");\n+    regex_search(\"asdf\", m, re);\n+    VERIFY(m.size() == 3);\n+    VERIFY(m[0].matched && string(m[0].first, m[0].second) == \"asdf\");\n+    VERIFY(m[1].matched && string(m[1].first, m[1].second) == \"as\");\n+    VERIFY(m[2].matched && string(m[2].first, m[2].second) == \"df\");\n+  }\n }\n \n int"}, {"sha": "4be406cb072cc2d1d59323604e3a3d2db5392f59", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_search/ecma/flags.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fflags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fflags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fflags.cc?ref=b21abceec3c77f2b847b4687947d7fcf745ffdf9", "patch": "@@ -0,0 +1,71 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-09-18  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.3 regex_search\n+// Tests ECMAScript flags.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  cmatch m;\n+  regex re(\"((as)(df))\", regex_constants::ECMAScript | regex_constants::nosubs);\n+  VERIFY(regex_search(\"asdf\", m, re));\n+  VERIFY(m.size() == 1);\n+  VERIFY(m[0].matched && string(m[0].first, m[0].second) == \"asdf\");\n+\n+  VERIFY( regex_search(\"a\", regex(\"^a\")));\n+  VERIFY(!regex_search(\"a\", regex(\"^a\"), regex_constants::match_not_bol));\n+  VERIFY( regex_search(\"a\", regex(\"a$\")));\n+  VERIFY(!regex_search(\"a\", regex(\"a$\"), regex_constants::match_not_eol));\n+  VERIFY( regex_search(\"a\", regex(\"\\\\ba\")));\n+  VERIFY(!regex_search(\"a\", regex(\"\\\\ba\"), regex_constants::match_not_bow));\n+  VERIFY( regex_search(\"a\", regex(\"a\\\\b\")));\n+  VERIFY(!regex_search(\"a\", regex(\"a\\\\b\"), regex_constants::match_not_eow));\n+  VERIFY( regex_search(\"\", regex(\"\")));\n+  VERIFY(!regex_search(\"\", regex(\"\"), regex_constants::match_not_null));\n+  VERIFY( regex_search(\"\", regex(\"^$\")));\n+  VERIFY(!regex_search(\"\", regex(\"^$\"), regex_constants::match_not_null));\n+  VERIFY( regex_search(\"aaa\", m, regex(\"a*?\"),\n+\t\t       regex_constants::match_not_null));\n+  VERIFY(m[0].matched && string(m[0].first, m[0].second) == \"a\");\n+  VERIFY( regex_search(\"asdf\", regex(\"sdf\")));\n+  VERIFY(!regex_search(\"asdf\", regex(\"sdf\"),\n+\t\t       regex_constants::match_continuous));\n+  VERIFY( regex_search(\" a\"+1, regex(\"\\\\ba\"),\n+\t\t       regex_constants::match_prev_avail));\n+  VERIFY( regex_search(\"ba\"+1, regex(\"\\\\Ba\"),\n+\t\t       regex_constants::match_prev_avail));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "978565021ccb94ec30fca6def9a263d587fca93a", "filename": "libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/string_position_01.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fchar%2Fstring_position_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fchar%2Fstring_position_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fchar%2Fstring_position_01.cc?ref=b21abceec3c77f2b847b4687947d7fcf745ffdf9", "patch": "@@ -1,5 +1,4 @@\n // { dg-options \"-std=gnu++11\" }\n-// { dg-do run { xfail *-*-* } }\n \n //\n // 2013-07-25  Tim Shen <timshen91@gmail.com>"}, {"sha": "9cb96f7a162976ab70c63971fbcba18ca1204a68", "filename": "libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/wchar_t/string_02.cc", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fwchar_t%2Fstring_02.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b21abceec3c77f2b847b4687947d7fcf745ffdf9/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fwchar_t%2Fstring_02.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fwchar_t%2Fstring_02.cc?ref=b21abceec3c77f2b847b4687947d7fcf745ffdf9", "patch": "@@ -1,6 +1,5 @@\n // { dg-options \"-std=gnu++11\" }\n // { dg-require-namedlocale \"en_US.UTF-8\" }\n-// { dg-do run { xfail *-*-* } }\n \n //\n // 2013-09-05  Tim Shen <timshen91@gmail.com>\n@@ -42,13 +41,19 @@ test01()\n \n   re2.assign(L\"([[:lower:]]{0,1}[[:space:]]{0,1}[[:upper:]]{0,1})\");\n \n-  std::wsregex_iterator p(str2.begin(), str2.end(), re2);\n-  auto a = p;\n-  ++p;\n-  VERIFY(a != p);\n-  //for (std::wsregex_iterator p(str2.begin(), str2.end(), re2);\n-  //    p != std::wsregex_iterator{}; ++p)\n-  //  std::wcout << (*p)[1] << std::endl;\n+  std::wstring sol[] =\n+    {\n+      L\"\u00e4\\u2009\u00c4\",\n+      L\"\\u2009\",\n+      L\"\u00f6\\u2009\u00d6\",\n+      L\"\\u2009\",\n+      L\"\u00fc\\u2009\u00dc\",\n+      L\"\",\n+    };\n+  int i = 0;\n+  for (std::wsregex_iterator p(str2.begin(), str2.end(), re2);\n+      p != std::wsregex_iterator{}; ++p)\n+    VERIFY(std::wstring((*p)[1].first, (*p)[1].second) == sol[i++]);\n }\n \n int"}]}