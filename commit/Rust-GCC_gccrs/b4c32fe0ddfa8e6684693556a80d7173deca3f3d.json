{"sha": "b4c32fe0ddfa8e6684693556a80d7173deca3f3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRjMzJmZTBkZGZhOGU2Njg0NjkzNTU2YTgwZDcxNzNkZWNhM2YzZA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-10-13T11:09:23Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-10-13T11:09:23Z"}, "message": "tree-vect-loop.c (loop_niters_no_overflow): New func.\n\n\t* tree-vect-loop.c (loop_niters_no_overflow): New func.\n\t(vect_transform_loop): Call loop_niters_no_overflow.  Pass the\n\tno-overflow information to vect_do_peeling_for_loop_bound and\n\tvect_gen_vector_loop_niters.\n\nFrom-SVN: r241102", "tree": {"sha": "b00d1e5e165e9e1ec7fa02f36ff1e7f38e370693", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b00d1e5e165e9e1ec7fa02f36ff1e7f38e370693"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4c32fe0ddfa8e6684693556a80d7173deca3f3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c32fe0ddfa8e6684693556a80d7173deca3f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4c32fe0ddfa8e6684693556a80d7173deca3f3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c32fe0ddfa8e6684693556a80d7173deca3f3d/comments", "author": null, "committer": null, "parents": [{"sha": "fcd2766617291ad6cf72a0583363bd3c8f8e8165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcd2766617291ad6cf72a0583363bd3c8f8e8165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcd2766617291ad6cf72a0583363bd3c8f8e8165"}], "stats": {"total": 45, "additions": 43, "deletions": 2}, "files": [{"sha": "8bfe53244f9d365396e28ddb25ffbf3cfe46d27e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c32fe0ddfa8e6684693556a80d7173deca3f3d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c32fe0ddfa8e6684693556a80d7173deca3f3d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4c32fe0ddfa8e6684693556a80d7173deca3f3d", "patch": "@@ -1,3 +1,10 @@\n+2016-10-13  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-vect-loop.c (loop_niters_no_overflow): New func.\n+\t(vect_transform_loop): Call loop_niters_no_overflow.  Pass the\n+\tno-overflow information to vect_do_peeling_for_loop_bound and\n+\tvect_gen_vector_loop_niters.\n+\n 2016-10-13  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-predcom.c (tree_predictive_commoning_loop): Skip loop that only"}, {"sha": "9cca9b717a6990042190f9a49e97cfa8cd94af44", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c32fe0ddfa8e6684693556a80d7173deca3f3d/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c32fe0ddfa8e6684693556a80d7173deca3f3d/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b4c32fe0ddfa8e6684693556a80d7173deca3f3d", "patch": "@@ -6620,6 +6620,39 @@ vect_loop_kill_debug_uses (struct loop *loop, gimple *stmt)\n     }\n }\n \n+/* Given loop represented by LOOP_VINFO, return true if computation of\n+   LOOP_VINFO_NITERS (= LOOP_VINFO_NITERSM1 + 1) doesn't overflow, false\n+   otherwise.  */\n+\n+static bool\n+loop_niters_no_overflow (loop_vec_info loop_vinfo)\n+{\n+  /* Constant case.  */\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+    {\n+      tree cst_niters = LOOP_VINFO_NITERS (loop_vinfo);\n+      tree cst_nitersm1 = LOOP_VINFO_NITERSM1 (loop_vinfo);\n+\n+      gcc_assert (TREE_CODE (cst_niters) == INTEGER_CST);\n+      gcc_assert (TREE_CODE (cst_nitersm1) == INTEGER_CST);\n+      if (wi::to_widest (cst_nitersm1) < wi::to_widest (cst_niters))\n+\treturn true;\n+    }\n+\n+  widest_int max;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  /* Check the upper bound of loop niters.  */\n+  if (get_max_loop_iterations (loop, &max))\n+    {\n+      tree type = TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo));\n+      signop sgn = TYPE_SIGN (type);\n+      widest_int type_max = widest_int::from (wi::max_value (type), sgn);\n+      if (max < type_max)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Function vect_transform_loop.\n \n    The analysis phase has determined that the loop is vectorizable.\n@@ -6707,8 +6740,9 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   tree niters = vect_build_loop_niters (loop_vinfo);\n   LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = niters;\n   tree nitersm1 = unshare_expr (LOOP_VINFO_NITERSM1 (loop_vinfo));\n+  bool niters_no_overflow = loop_niters_no_overflow (loop_vinfo);\n   vect_do_peeling (loop_vinfo, niters, nitersm1, &niters_vector, th,\n-\t\t   check_profitability, false);\n+\t\t   check_profitability, niters_no_overflow);\n   if (niters_vector == NULL_TREE)\n     {\n       if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n@@ -6717,7 +6751,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t\t   LOOP_VINFO_INT_NITERS (loop_vinfo) / vf);\n       else\n \tvect_gen_vector_loop_niters (loop_vinfo, niters, &niters_vector,\n-\t\t\t\t     false);\n+\t\t\t\t     niters_no_overflow);\n     }\n \n   /* 1) Make sure the loop header has exactly two entries"}]}