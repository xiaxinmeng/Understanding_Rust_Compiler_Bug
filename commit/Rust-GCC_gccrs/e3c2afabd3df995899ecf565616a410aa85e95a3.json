{"sha": "e3c2afabd3df995899ecf565616a410aa85e95a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNjMmFmYWJkM2RmOTk1ODk5ZWNmNTY1NjE2YTQxMGFhODVlOTVhMw==", "commit": {"author": {"name": "Alan Modra", "email": "alan@linuxcare.com.au", "date": "2000-03-28T06:10:09Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-03-28T06:10:09Z"}, "message": "Alan Modra  <alan@linuxcare.com.au>\n\n        * config/i386/i386.c (output_387_binary_op): Correct intel\n        mode assembly output, and add spaces after commas in AT&T\n        output.  Correct Unixware assembler comment.  Document input\n        constraints.  Comment fp operations.  Reduce profligate buffer\n        size.  Remove extraneous abort.  Localize temp var.\n        (SYSV386_COMPAT): Define.  Add !SYSV386_COMPAT code.\n        (output_fix_trunc): Add spaces after commas in assembly output.\n\nFrom-SVN: r32778", "tree": {"sha": "f3abf000592340351103d15a17ce92c8cc2b2ac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3abf000592340351103d15a17ce92c8cc2b2ac8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3c2afabd3df995899ecf565616a410aa85e95a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3c2afabd3df995899ecf565616a410aa85e95a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3c2afabd3df995899ecf565616a410aa85e95a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3c2afabd3df995899ecf565616a410aa85e95a3/comments", "author": null, "committer": null, "parents": [{"sha": "161897403ed49d37f05034008193379c8a2bc897", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/161897403ed49d37f05034008193379c8a2bc897", "html_url": "https://github.com/Rust-GCC/gccrs/commit/161897403ed49d37f05034008193379c8a2bc897"}], "stats": {"total": 122, "additions": 96, "deletions": 26}, "files": [{"sha": "c223a64e58bafcfdd2970f5995838cb9a28f63ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c2afabd3df995899ecf565616a410aa85e95a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c2afabd3df995899ecf565616a410aa85e95a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3c2afabd3df995899ecf565616a410aa85e95a3", "patch": "@@ -1,3 +1,13 @@\n+2000-03-27  Alan Modra  <alan@linuxcare.com.au>\n+\n+\t* config/i386/i386.c (output_387_binary_op): Correct intel\n+\tmode assembly output, and add spaces after commas in AT&T\n+\toutput.  Correct Unixware assembler comment.  Document input\n+\tconstraints.  Comment fp operations.  Reduce profligate buffer\n+\tsize.  Remove extraneous abort.  Localize temp var.\n+\t(SYSV386_COMPAT): Define.  Add !SYSV386_COMPAT code.\n+\t(output_fix_trunc): Add spaces after commas in assembly output.\n+\n 2000-03-27  Richard Henderson  <rth@cygnus.com>\n \n \t* i386-protos.h (ix86_match_ccmode): Declare.\n@@ -575,8 +585,8 @@ Thu Mar 23 11:34:39 2000  Jim Wilson  <wilson@cygnus.com>\n \n Thu Mar 23 16:04:40 2000  Andrew Haley  <aph@cygnus.com>\n \n-        * config/mips/mips.md (movdf_internal1a): Delete (set 'f', 'F')\n-        alternative when using -fp64 -gp32.\n+\t* config/mips/mips.md (movdf_internal1a): Delete (set 'f', 'F')\n+\talternative when using -fp64 -gp32.\n \n 2000-03-22  Jason Merrill  <jason@casey.cygnus.com>\n \n@@ -594,7 +604,7 @@ Thu Mar 23 16:04:40 2000  Andrew Haley  <aph@cygnus.com>\n \n 2000-03-22  Theodore Papadopoulo <Theodore.Papadopoulo@sophia.inria.fr>\n \n-        * builtin.c (get_pointer_alignment): Use DECL_P and TYPE_P macros.\n+\t* builtin.c (get_pointer_alignment): Use DECL_P and TYPE_P macros.\n \t* c-common.c (decl_attributes,check_format_info,truthvalue_conversion,\n \t  c_get_alias_set): Likewise.\n \t* c-decl.c (duplicate_decls): Likewise.\n@@ -679,7 +689,7 @@ Wed Mar 22 11:44:50 MET 2000  Jan Hubicka  <jh@suse.cz>\n \n 2000-03-21  Richard Henderson  <rth@cygnus.com>\n \n-        * flow.c (delete_block): Fix typo last change.\n+\t* flow.c (delete_block): Fix typo last change.\n \n 2000-03-21  Mark Mitchell  <mark@codesourcery.com>\n "}, {"sha": "d3f3a6573f9c6a05571136d007b92a8a5574e0c1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 82, "deletions": 22, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c2afabd3df995899ecf565616a410aa85e95a3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c2afabd3df995899ecf565616a410aa85e95a3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e3c2afabd3df995899ecf565616a410aa85e95a3", "patch": "@@ -3434,15 +3434,39 @@ split_di (operands, num, lo_half, hi_half)\n    There is no guarantee that the operands are the same mode, as they\n    might be within FLOAT or FLOAT_EXTEND expressions. */\n \n+#ifndef SYSV386_COMPAT\n+/* Set to 1 for compatibility with brain-damaged assemblers.  No-one\n+   wants to fix the assemblers because that causes incompatibility\n+   with gcc.  No-one wants to fix gcc because that causes\n+   incompatibility with assemblers...  You can use the option of\n+   -DSYSV386_COMPAT=0 if you recompile both gcc and gas this way.  */\n+#define SYSV386_COMPAT 1\n+#endif\n+\n const char *\n output_387_binary_op (insn, operands)\n      rtx insn;\n      rtx *operands;\n {\n-  static char buf[100];\n-  rtx temp;\n+  static char buf[30];\n   const char *p;\n \n+#ifdef ENABLE_CHECKING\n+  /* Even if we do not want to check the inputs, this documents input\n+     constraints.  Which helps in understanding the following code.  */\n+  if (STACK_REG_P (operands[0])\n+      && ((REG_P (operands[1])\n+\t   && REGNO (operands[0]) == REGNO (operands[1])\n+\t   && (STACK_REG_P (operands[2]) || GET_CODE (operands[2]) == MEM))\n+\t  || (REG_P (operands[2])\n+\t      && REGNO (operands[0]) == REGNO (operands[2])\n+\t      && (STACK_REG_P (operands[1]) || GET_CODE (operands[1]) == MEM)))\n+      && (STACK_TOP_P (operands[1]) || STACK_TOP_P (operands[2])))\n+    ; /* ok */\n+  else\n+    abort ();\n+#endif\n+\n   switch (GET_CODE (operands[3]))\n     {\n     case PLUS:\n@@ -3489,11 +3513,13 @@ output_387_binary_op (insn, operands)\n     case PLUS:\n       if (REG_P (operands[2]) && REGNO (operands[0]) == REGNO (operands[2]))\n \t{\n-\t  temp = operands[2];\n+\t  rtx temp = operands[2];\n \t  operands[2] = operands[1];\n \t  operands[1] = temp;\n \t}\n \n+      /* know operands[0] == operands[1].  */\n+\n       if (GET_CODE (operands[2]) == MEM)\n \t{\n \t  p = \"%z2\\t%2\";\n@@ -3503,16 +3529,23 @@ output_387_binary_op (insn, operands)\n       if (find_regno_note (insn, REG_DEAD, REGNO (operands[2])))\n \t{\n \t  if (STACK_TOP_P (operands[0]))\n-\t    p = \"p\\t{%0,%2|%2, %0}\";\n+\t    /* How is it that we are storing to a dead operand[2]?\n+\t       Well, presumably operands[1] is dead too.  We can't\n+\t       store the result to st(0) as st(0) gets popped on this\n+\t       instruction.  Instead store to operands[2] (which I\n+\t       think has to be st(1)).  st(1) will be popped later.\n+\t       gcc <= 2.8.1 didn't have this check and generated\n+\t       assembly code that the Unixware assembler rejected.  */\n+\t    p = \"p\\t{%0, %2|%2, %0}\";\t/* st(1) = st(0) op st(1); pop */\n \t  else\n-\t    p = \"p\\t{%2,%0|%0, %2}\";\n+\t    p = \"p\\t{%2, %0|%0, %2}\";\t/* st(r1) = st(r1) op st(0); pop */\n \t  break;\n \t}\n \n       if (STACK_TOP_P (operands[0]))\n-\tp = \"\\t{%y2,%0|%0, %y2}\";\n+\tp = \"\\t{%y2, %0|%0, %y2}\";\t/* st(0) = st(0) op st(r2) */\n       else\n-\tp = \"\\t{%2,%0|%0, %2}\";\n+\tp = \"\\t{%2, %0|%0, %2}\";\t/* st(r1) = st(r1) op st(0) */\n       break;\n \n     case MINUS:\n@@ -3529,42 +3562,69 @@ output_387_binary_op (insn, operands)\n \t  break;\n \t}\n \n-      if (! STACK_REG_P (operands[1]) || ! STACK_REG_P (operands[2]))\n-\tabort ();\n-\n-      /* Note that the Unixware assembler, and the AT&T assembler before\n-\t that, are confusingly not reversed from Intel syntax in this\n-\t area.  */\n       if (find_regno_note (insn, REG_DEAD, REGNO (operands[2])))\n \t{\n+#if SYSV386_COMPAT\n+\t  /* The SystemV/386 SVR3.2 assembler, and probably all AT&T\n+\t     derived assemblers, confusingly reverse the direction of\n+\t     the operation for fsub{r} and fdiv{r} when the\n+\t     destination register is not st(0).  The Intel assembler\n+\t     doesn't have this brain damage.  Read !SYSV386_COMPAT to\n+\t     figure out what the hardware really does.  */\n+\t  if (STACK_TOP_P (operands[0]))\n+\t    p = \"{p\\t%0, %2|rp\\t%2, %0}\";\n+\t  else\n+\t    p = \"{rp\\t%2, %0|p\\t%0, %2}\";\n+#else\n \t  if (STACK_TOP_P (operands[0]))\n-\t    p = \"p\\t%0,%2\";\n+\t    /* As above for fmul/fadd, we can't store to st(0).  */\n+\t    p = \"rp\\t{%0, %2|%2, %0}\";\t/* st(1) = st(0) op st(1); pop */\n \t  else\n-\t    p = \"rp\\t%2,%0\";\n+\t    p = \"p\\t{%2, %0|%0, %2}\";\t/* st(r1) = st(r1) op st(0); pop */\n+#endif\n \t  break;\n \t}\n \n       if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n \t{\n+#if SYSV386_COMPAT\n \t  if (STACK_TOP_P (operands[0]))\n-\t    p = \"rp\\t%0,%1\";\n+\t    p = \"{rp\\t%0, %1|p\\t%1, %0}\";\n \t  else\n-\t    p = \"p\\t%1,%0\";\n+\t    p = \"{p\\t%1, %0|rp\\t%0, %1}\";\n+#else\n+\t  if (STACK_TOP_P (operands[0]))\n+\t    p = \"p\\t{%0, %1|%1, %0}\";\t/* st(1) = st(1) op st(0); pop */\n+\t  else\n+\t    p = \"rp\\t{%1, %0|%0, %1}\";\t/* st(r2) = st(0) op st(r2); pop */\n+#endif\n \t  break;\n \t}\n \n       if (STACK_TOP_P (operands[0]))\n \t{\n \t  if (STACK_TOP_P (operands[1]))\n-\t    p = \"\\t%y2,%0\";\n+\t    p = \"\\t{%y2, %0|%0, %y2}\";\t/* st(0) = st(0) op st(r2) */\n \t  else\n-\t    p = \"r\\t%y1,%0\";\n+\t    p = \"r\\t{%y1, %0|%0, %y1}\";\t/* st(0) = st(r1) op st(0) */\n \t  break;\n \t}\n       else if (STACK_TOP_P (operands[1]))\n-\tp = \"\\t%1,%0\";\n+\t{\n+#if SYSV386_COMPAT\n+\t  p = \"{\\t%1, %0|r\\t%0, %1}\";\n+#else\n+\t  p = \"r\\t{%1, %0|%0, %1}\";\t/* st(r2) = st(0) op st(r2) */\n+#endif\n+\t}\n       else\n-\tp = \"r\\t%2,%0\";\n+\t{\n+#if SYSV386_COMPAT\n+\t  p = \"{r\\t%2, %0|\\t%0, %2}\";\n+#else\n+\t  p = \"\\t{%2, %0|%0, %2}\";\t/* st(r1) = st(r1) op st(0) */\n+#endif\n+\t}\n       break;\n \n     default:\n@@ -3628,7 +3688,7 @@ output_fix_trunc (insn, operands)\n \t  output_asm_insn (\"mov{l}\\t{%3, %1|%1, %3}\", xops);\n \t}\n       else\n-\toutput_asm_insn (\"mov{l}\\t{%3,%0|%0, %3}\", operands);\n+\toutput_asm_insn (\"mov{l}\\t{%3, %0|%0, %3}\", operands);\n     }\n \n   return \"\";"}]}