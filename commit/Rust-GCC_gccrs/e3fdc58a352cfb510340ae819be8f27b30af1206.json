{"sha": "e3fdc58a352cfb510340ae819be8f27b30af1206", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNmZGM1OGEzNTJjZmI1MTAzNDBhZTgxOWJlOGYyN2IzMGFmMTIwNg==", "commit": {"author": {"name": "Jason Eckhardt", "email": "jle@cygnus.com", "date": "2000-05-01T03:46:21Z"}, "committer": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2000-05-01T03:46:21Z"}, "message": "bb-reorder.c (scope_def): New struct.\n\nSun Apr 30 22:48:24 2000  Jason Eckhardt  <jle@cygnus.com>\n\n\t* bb-reorder.c (scope_def): New struct.\n\t(scope_forest_info): New struct.\n\t(struct reorder_block_def): New member \"scope\".\n\t(REORDER_BLOCK_SCOPE): New macro.\n\t(relate_bbs_with_scopes): New function and prototype.\n\t(make_new_scope): Likewise.\n\t(build_scope_forest): Likewise.\n\t(remove_scope_notes): Likewise.\n\t(insert_intra_1): Likewise.\n\t(insert_intra_bb_scope_notes): Likewise.\n\t(insert_inter_bb_scope_notes): Likewise.\n\t(rebuild_scope_notes): Likewise.\n\t(free_scope_forest_1): Likewise.\n\t(free_scope_forest): Likewise.\n\t(dump_scope_forest): Likewise.\n\t(dump_scope_forest_1): Likewise.\n\t(chain_reorder_blocks): Set REORDER_BLOCK_SCOPE for new block.\n\tUpdate REORDER_BLOCK_EFF_HEAD and REORDER_BLOCK_EFF_END for new\n\tblock.\n\t(reorder_basic_blocks): Added calls to build_scope_scope_forest\n\tand remove_scope_notes before reordering is done. Added calls to\n\trebuild_scope_notes, free_scope_forest, and reorder_blocks after\n\tafter reordering is done.\n\nFrom-SVN: r33560", "tree": {"sha": "fb239b04fd7afd1d622708b1b2473a1c7eac9fcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb239b04fd7afd1d622708b1b2473a1c7eac9fcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3fdc58a352cfb510340ae819be8f27b30af1206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3fdc58a352cfb510340ae819be8f27b30af1206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3fdc58a352cfb510340ae819be8f27b30af1206", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3fdc58a352cfb510340ae819be8f27b30af1206/comments", "author": null, "committer": null, "parents": [{"sha": "4c0aad2c0846b123c21c6ba67b0778736a20fa27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c0aad2c0846b123c21c6ba67b0778736a20fa27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c0aad2c0846b123c21c6ba67b0778736a20fa27"}], "stats": {"total": 685, "additions": 683, "deletions": 2}, "files": [{"sha": "ddaa543396f916e09fa03e428bf12d183099278f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3fdc58a352cfb510340ae819be8f27b30af1206/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3fdc58a352cfb510340ae819be8f27b30af1206/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3fdc58a352cfb510340ae819be8f27b30af1206", "patch": "@@ -1,3 +1,29 @@\n+Sun Apr 30 22:48:24 2000  Jason Eckhardt  <jle@cygnus.com>\n+\n+\t* bb-reorder.c (scope_def): New struct.\n+\t(scope_forest_info): New struct.\n+\t(struct reorder_block_def): New member \"scope\".\n+\t(REORDER_BLOCK_SCOPE): New macro.\n+\t(relate_bbs_with_scopes): New function and prototype.\n+\t(make_new_scope): Likewise.\n+\t(build_scope_forest): Likewise.\n+\t(remove_scope_notes): Likewise.\n+\t(insert_intra_1): Likewise.\n+\t(insert_intra_bb_scope_notes): Likewise.\n+\t(insert_inter_bb_scope_notes): Likewise.\n+\t(rebuild_scope_notes): Likewise.\n+\t(free_scope_forest_1): Likewise.\n+\t(free_scope_forest): Likewise.\n+\t(dump_scope_forest): Likewise.\n+\t(dump_scope_forest_1): Likewise.\n+\t(chain_reorder_blocks): Set REORDER_BLOCK_SCOPE for new block.\n+\tUpdate REORDER_BLOCK_EFF_HEAD and REORDER_BLOCK_EFF_END for new\n+\tblock.\n+\t(reorder_basic_blocks): Added calls to build_scope_scope_forest\n+\tand remove_scope_notes before reordering is done. Added calls to\n+\trebuild_scope_notes, free_scope_forest, and reorder_blocks after\n+\tafter reordering is done.\n+\n 2000-40-30  Bruce Korb  <bkorb@gnu.org>\n \n \t* fixinc/inclhack.def:  Added definitions needed by OSR5,"}, {"sha": "3a9a25fcbb6349f2780197cdb821fa832c28b1ed", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 657, "deletions": 2, "changes": 659, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3fdc58a352cfb510340ae819be8f27b30af1206/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3fdc58a352cfb510340ae819be8f27b30af1206/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=e3fdc58a352cfb510340ae819be8f27b30af1206", "patch": "@@ -52,6 +52,53 @@\n extern struct obstack *function_obstack;\n \n \n+/* Structure to hold information about lexical scopes.  */\n+typedef struct scope_def\n+{\n+  int level;\n+\n+  /* The NOTE_INSN_BLOCK_BEG that started this scope.  */\n+  rtx note_beg;\n+\n+  /* The NOTE_INSN_BLOCK_END that ended this scope.  */\n+  rtx note_end;\n+\n+  /* The bb containing note_beg (if any).  */\n+  basic_block bb_beg;\n+\n+  /* The bb containing note_end (if any).  */\n+  basic_block bb_end;\n+\n+  /* List of basic blocks contained within this scope.  */\n+  basic_block *bbs;\n+\n+  /* Number of blocks contained within this scope.  */\n+  int num_bbs;\n+\n+  /* The outer scope or NULL if outermost scope.  */\n+  struct scope_def *outer;\n+\n+  /* The first inner scope or NULL if innermost scope.  */\n+  struct scope_def *inner;\n+\n+  /* The last inner scope or NULL if innermost scope.  */\n+  struct scope_def *inner_last;\n+\n+  /* Link to the next (sibling) scope.  */\n+  struct scope_def *next;\n+} *scope;\n+\n+/* Structure to hold information about the scope forest.  */\n+typedef struct\n+{\n+  /* Number of trees in forest.  */\n+  int num_trees;\n+\n+  /* List of tree roots.  */\n+  scope *trees;\n+} scope_forest_info;\n+\n+\n typedef struct reorder_block_def {\n   int flags;\n   int index;\n@@ -62,6 +109,7 @@ typedef struct reorder_block_def {\n   int block_end;\n   rtx eff_head;\n   rtx eff_end;\n+  scope scope;\n } *reorder_block_def;\n \n static struct reorder_block_def rbd_init\n@@ -74,7 +122,8 @@ static struct reorder_block_def rbd_init\n     0,\t\t\t/* block_begin */\n     0,\t\t\t/* block_end */\n     NULL_RTX,\t\t/* eff_head */\n-    NULL_RTX\t\t/* eff_end */\n+    NULL_RTX,\t\t/* eff_end */\n+    NULL\t\t/* scope */\n };\n \n \n@@ -108,6 +157,9 @@ static struct reorder_block_def rbd_init\n #define REORDER_BLOCK_EFF_END(bb) \\\n   ((reorder_block_def) (bb)->aux)->eff_end\n \n+#define REORDER_BLOCK_SCOPE(bb) \\\n+  ((reorder_block_def) (bb)->aux)->scope\n+\n \n static int reorder_index;\n static basic_block reorder_last_visited;\n@@ -126,6 +178,18 @@ static void fixup_reorder_chain\t\tPARAMS ((void));\n #ifdef ENABLE_CHECKING\n static void verify_insn_chain\t\tPARAMS ((void));\n #endif\n+static void relate_bbs_with_scopes\tPARAMS ((scope));\n+static scope make_new_scope\t\tPARAMS ((int, rtx));\n+static void build_scope_forest\t\tPARAMS ((scope_forest_info *));\n+static void remove_scope_notes\t\tPARAMS ((void));\n+static void insert_intra_1\t\tPARAMS ((scope, rtx *));\n+static void insert_intra_bb_scope_notes PARAMS ((basic_block));\n+static void insert_inter_bb_scope_notes PARAMS ((basic_block, basic_block));\n+static void rebuild_scope_notes\t\tPARAMS ((scope_forest_info *));\n+static void free_scope_forest_1\t\tPARAMS ((scope));\n+static void free_scope_forest\t\tPARAMS ((scope_forest_info *));\n+void dump_scope_forest\t\t\tPARAMS ((scope_forest_info *));\n+static void dump_scope_forest_1\t\tPARAMS ((scope, int));\n \n /* Skip over insns BEFORE or AFTER BB which are typically associated with\n    basic block BB.  */\n@@ -477,7 +541,7 @@ chain_reorder_blocks (e, ceb)\n   dbe_insn = REORDER_BLOCK_EFF_END (db);\n \n   /* Leave behind any lexical block markers.  */\n-  if (debug_info_level > DINFO_LEVEL_TERSE\n+  if (0 && debug_info_level > DINFO_LEVEL_TERSE\n       && ceb->index + 1 < db->index)\n     {\n       rtx insn, last_insn = get_last_insn ();\n@@ -707,7 +771,12 @@ fixup_reorder_chain ()\n \t\t      >= REORDER_BLOCK_INDEX (bbi) + 1)\n \t\t    REORDER_BLOCK_INDEX (bbj)++;\n \t\t}\n+\t      REORDER_BLOCK_SCOPE (nb) = REORDER_BLOCK_SCOPE (bbi);\n+\t      REORDER_BLOCK_EFF_HEAD (nb) = nb->head;\n+\t      REORDER_BLOCK_EFF_END (nb) = barrier_insn;\n \t    }\n+\t  else\n+\t    REORDER_BLOCK_EFF_END (bbi) = barrier_insn;\n \t}\n     }\n }\n@@ -777,6 +846,579 @@ verify_insn_chain ()\n }\n #endif\n \n+static rtx\n+get_next_bb_note (x)\n+     rtx x;\n+{\n+  while (x)\n+    {\n+      if (GET_CODE (x) == NOTE\n+\t  && NOTE_LINE_NUMBER (x) == NOTE_INSN_BASIC_BLOCK)\n+\treturn x;\n+      x = NEXT_INSN (x);\n+    }\n+  return NULL;\n+}\n+\n+\n+static rtx\n+get_prev_bb_note (x)\n+     rtx x;\n+{\n+  while (x)\n+    {\n+      if (GET_CODE (x) == NOTE\n+\t  && NOTE_LINE_NUMBER (x) == NOTE_INSN_BASIC_BLOCK)\n+\treturn x;\n+      x = PREV_INSN (x);\n+    }\n+  return NULL;\n+}\n+\n+\n+/* Determine and record the relationships between basic blocks and\n+   scopes in scope tree S.  */\n+\n+static void\n+relate_bbs_with_scopes (s)\n+     scope s;\n+{\n+  scope p;\n+  int i, bbi1, bbi2, bbs_spanned;\n+  rtx bbnote;\n+\n+  for (p = s->inner; p; p = p->next)\n+    relate_bbs_with_scopes (p);\n+\n+  bbi1 = bbi2 = -1;\n+  bbs_spanned = 0;\n+\n+  /* If the begin and end notes are both inside the same basic block,\n+     or if they are both outside of basic blocks, then we know immediately\n+     how they are related. Otherwise, we need to poke around to make the\n+     determination.  */\n+  if (s->bb_beg != s->bb_end)\n+    {\n+      if (s->bb_beg && s->bb_end)\n+        {\n+\t  /* Both notes are in different bbs. This implies that all the\n+\t     basic blocks spanned by the pair of notes are contained in\n+             this scope.  */\n+\t  bbi1 = s->bb_beg->index;\n+\t  bbi2 = s->bb_end->index;\n+\t  bbs_spanned = 1;\n+\t}\n+      else if (! s->bb_beg)\n+        {\n+\t  /* First note is outside of a bb. If the scope spans more than\n+\t     one basic block, then they all are contained within this\n+             scope. Otherwise, this scope is contained within the basic\n+\t     block.  */\n+\t  bbnote = get_next_bb_note (s->note_beg);\n+\t  if (! bbnote)\n+\t    abort ();\n+\t  if (NOTE_BASIC_BLOCK (bbnote) == s->bb_end)\n+\t    {\n+\t      bbs_spanned = 0;\n+\t      s->bb_beg = NOTE_BASIC_BLOCK (bbnote);\n+\t    }\n+\t  else\n+\t    {\n+\t      bbi1 = NOTE_BASIC_BLOCK (bbnote)->index;\n+\t      bbi2 = s->bb_end->index;\n+\t      s->bb_end = NULL;\n+\t      bbs_spanned = 1;\n+\t    }\n+\t}\n+      else /* ! s->bb_end */\n+        {\n+\t  /* Second note is outside of a bb. If the scope spans more than\n+\t     one basic block, then they all are contained within this\n+             scope. Otherwise, this scope is contained within the basic\n+\t     block.  */\n+\t  bbnote = get_prev_bb_note (s->note_end);\n+\t  if (! bbnote)\n+\t    abort ();\n+\t  if (NOTE_BASIC_BLOCK (bbnote) == s->bb_beg)\n+\t    {\n+\t      bbs_spanned = 0;\n+\t      s->bb_end = NOTE_BASIC_BLOCK (bbnote);\n+\t    }\n+\t  else\n+\t    {\n+\t      bbi1 = s->bb_beg->index;\n+\t      bbi2 = NOTE_BASIC_BLOCK (bbnote)->index;\n+\t      s->bb_beg = NULL;\n+\t      bbs_spanned = 1;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      if (s->bb_beg)\n+        /* Both notes are in the same bb, which implies the block\n+\t   contains this scope.  */\n+\tbbs_spanned = 0;\n+      else\n+\t{\n+          rtx x1, x2;\n+\t  /* Both notes are outside of any bbs. This implies that all the\n+\t     basic blocks spanned by the pair of notes are contained in\n+             this scope. \n+\t     There is a degenerate case to consider. If the notes do not\n+\t     span any basic blocks, then it is an empty scope that can\n+\t     safely be deleted or ignored. Mark these with level = -1.  */\n+\n+\t  x1 = get_next_bb_note (s->note_beg);\n+\t  x2 = get_prev_bb_note (s->note_end);\n+\t  if (! (x1 && x2))\n+\t    {\n+\t      s->level = -1; \n+\t      bbs_spanned = 0; \n+\t    }\n+\t  else\n+\t    {\n+\t      bbi1 = NOTE_BASIC_BLOCK (x1)->index;\n+\t      bbi2 = NOTE_BASIC_BLOCK (x2)->index;\n+\t      bbs_spanned = 1;\n+\t    }\n+\t}\n+    }\n+\n+\n+  /* If the scope spans one or more basic blocks, we record them. We\n+     only record the bbs that are immediately contained within this\n+     scope. Note that if a scope is contained within a bb, we can tell\n+     by checking that bb_beg = bb_end and that they are non-null.  */\n+  if (bbs_spanned)\n+    {\n+      int j = 0;\n+\n+      s->num_bbs = 0;\n+      for (i = bbi1; i <= bbi2; i++)\n+\tif (! REORDER_BLOCK_SCOPE (BASIC_BLOCK (i)))\n+\t  s->num_bbs++;\n+\n+      s->bbs = xcalloc (s->num_bbs, sizeof (struct basic_block_def));\n+      for (i = bbi1; i <= bbi2; i++)\n+\t{\n+\t  basic_block curr_bb = BASIC_BLOCK (i);\n+\t  if (! REORDER_BLOCK_SCOPE (curr_bb))\n+\t    {\n+\t      s->bbs[j++] = curr_bb;\n+\t      REORDER_BLOCK_SCOPE (curr_bb) = s;\n+\t    }\n+\t}\n+    }\n+  else\n+    s->num_bbs = 0;\n+}\n+\n+\n+/* Allocate and initialize a new scope structure with scope level LEVEL,\n+   and record the NOTE beginning the scope.  */\n+\n+static scope \n+make_new_scope (level, note)\n+     int level;\n+     rtx note;\n+{\n+  scope new_scope = xcalloc (1, sizeof (struct scope_def));\n+  new_scope->level = level;\n+  new_scope->note_beg = note;\n+  new_scope->note_end = NULL;\n+  new_scope->bb_beg = NULL;\n+  new_scope->bb_end = NULL;\n+  new_scope->inner = NULL;\n+  new_scope->inner_last = NULL;\n+  new_scope->outer = NULL;\n+  new_scope->next = NULL;\n+  new_scope->num_bbs = 0;\n+  new_scope->bbs = NULL;\n+  return new_scope;\n+}\n+\n+\n+/* Build a forest representing the scope structure of the function.\n+   Return a pointer to a structure describing the forest.  */\n+\n+static void\n+build_scope_forest (forest)\n+    scope_forest_info *forest;\n+{\n+  rtx x;\n+  int level, bbi, i;\n+  basic_block curr_bb;\n+  scope root, curr_scope;\n+\n+  forest->num_trees = 0;\n+  forest->trees = NULL;\n+  level = -1;\n+  root = NULL;\n+  curr_bb = NULL;\n+  bbi = 0;\n+  for (x = get_insns (); x; x = NEXT_INSN (x))\n+    {\n+      if (bbi < n_basic_blocks && x == BASIC_BLOCK (bbi)->head)\n+\tcurr_bb = BASIC_BLOCK (bbi);\n+\n+      if (GET_CODE (x) == NOTE)\n+\t{\n+\t  if (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_BEG)\n+\t    {\n+\t      if (root)\n+\t\t{\n+\t\t  scope new_scope;\n+\t\t  if (! curr_scope)\n+\t\t    abort();\n+\t\t  level++;\n+\t\t  new_scope = make_new_scope (level, x);\n+\t\t  new_scope->outer = curr_scope;\n+\t\t  new_scope->next = NULL;\n+\t\t  if (! curr_scope->inner)\n+\t\t    {\n+\t\t      curr_scope->inner = new_scope;\n+\t\t      curr_scope->inner_last = new_scope;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      curr_scope->inner_last->next = new_scope;\n+\t\t      curr_scope->inner_last = new_scope;\n+\t\t    }\n+\t\t  curr_scope = curr_scope->inner_last;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  int ntrees = forest->num_trees;\n+\t\t  level++;\n+\t          curr_scope = make_new_scope (level, x);\n+\t\t  root = curr_scope;\n+\t\t  if (ntrees == 0)\n+\t\t    forest->trees = xcalloc (1, sizeof (scope));\n+\t\t  else\n+\t\t    forest->trees = xrealloc (forest->trees,\n+\t\t\t\t\t      sizeof (scope) * (ntrees + 1));\n+\t\t  forest->trees[forest->num_trees++] = root;\n+\t\t}\n+\t      curr_scope->bb_beg = curr_bb;\n+\t    }\n+\t  else if (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_END)\n+\t    {\n+\t      curr_scope->bb_end = curr_bb;\n+\t      curr_scope->note_end = x;\n+\t      level--;\n+\t      curr_scope = curr_scope->outer;\n+\t      if (level == -1)\n+\t\troot = NULL;\n+\t    }\n+\t} /* if note */\n+\n+      if (curr_bb && curr_bb->end == x)\n+\t{\n+\t  curr_bb = NULL;\n+\t  bbi++;\n+\t}\n+\n+    } /* for */\n+\n+  for (i = 0; i < forest->num_trees; i++)\n+    relate_bbs_with_scopes (forest->trees[i]);\n+}\n+\n+\n+/* Remove all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes from\n+   the insn chain.  */\n+\n+static void\n+remove_scope_notes ()\n+{\n+  rtx x, next;\n+  basic_block currbb = NULL;\n+\n+  for (x = get_insns (); x; x = next)\n+    {\n+      next = NEXT_INSN (x);\n+      if (GET_CODE (x) == NOTE\n+\t  && NOTE_LINE_NUMBER (x) == NOTE_INSN_BASIC_BLOCK)\n+\tcurrbb = NOTE_BASIC_BLOCK (x);\n+\n+      if (GET_CODE (x) == NOTE\n+\t  && (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_BEG\n+\t      || NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_END))\n+\t{\n+\t  /* Check if the scope end happens to be the end of a bb.  */\n+\t  if (currbb && x == currbb->end\n+\t      && NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_END)\n+\t    currbb->end = PREV_INSN (x);\n+\n+\t  if (PREV_INSN (x))\n+\t    {\n+\t      NEXT_INSN (PREV_INSN (x)) = next;\n+\t      PREV_INSN (next) = PREV_INSN (x);\n+\n+              NEXT_INSN (x) = NULL;\n+              PREV_INSN (x) = NULL;\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+    }\n+}\n+\n+\n+/* Insert scope note pairs for a contained scope tree S after insn IP.  */\n+static void\n+insert_intra_1 (s, ip)\n+     scope s;\n+     rtx *ip;\n+{\n+  scope p;\n+\n+  if (NOTE_BLOCK (s->note_beg))\n+    {  \n+      *ip = emit_note_after (NOTE_INSN_BLOCK_BEG, *ip);\n+      NOTE_BLOCK (*ip) = NOTE_BLOCK (s->note_beg);\n+    } \n+\n+  for (p = s->inner; p; p = p->next)\n+    insert_intra_1 (p, ip);\n+\n+  if (NOTE_BLOCK (s->note_beg))\n+    {  \n+      *ip = emit_note_after (NOTE_INSN_BLOCK_END, *ip);\n+      NOTE_BLOCK (*ip) = NOTE_BLOCK (s->note_end);\n+    }\n+}\n+\n+\n+/* Insert NOTE_INSN_BLOCK_END notes and NOTE_INSN_BLOCK_BEG notes for\n+   scopes that are contained within BB.  */\n+\n+static void\n+insert_intra_bb_scope_notes (bb)\n+     basic_block bb;\n+{\n+  scope s = REORDER_BLOCK_SCOPE (bb);\n+  scope p;\n+  rtx ip;\n+\n+  if (! s)\n+    return;\n+\n+  ip = bb->head;\n+  if (GET_CODE (ip) == CODE_LABEL)\n+    ip = NEXT_INSN (ip);\n+\n+  for (p = s->inner; p; p = p->next)\n+    {\n+      if (p->bb_beg != NULL && p->bb_beg == p->bb_end && p->bb_beg == bb)\n+\tinsert_intra_1 (p, &ip);\n+    }\n+}\n+\n+\n+/* Given two consecutive basic blocks BB1 and BB2 with different scopes,\n+   insert NOTE_INSN_BLOCK_END notes after BB1 and NOTE_INSN_BLOCK_BEG\n+   notes before BB2 such that the notes are correctly balanced. If BB1 or\n+   BB2 is NULL, we are inserting scope notes for the first and last basic\n+   blocks, respectively.  */\n+\n+static void\n+insert_inter_bb_scope_notes (bb1, bb2)\n+     basic_block bb1;\n+     basic_block bb2;\n+{\n+  rtx ip;\n+  scope com;\n+\n+  /* It is possible that a basic block is not contained in any scope.\n+     In that case, we either open or close a scope but not both.  */\n+  if (bb1 && bb2)\n+    {\n+      scope s1 = REORDER_BLOCK_SCOPE (bb1);\n+      scope s2 = REORDER_BLOCK_SCOPE (bb2);\n+      if (! s1 && ! s2)\n+\treturn;\n+      if (! s1)\n+\tbb1 = NULL;\n+      else if (! s2)\n+\tbb2 = NULL;\n+    }\n+\n+  /* Find common ancestor scope.  */\n+  if (bb1 && bb2)\n+    {\n+      scope s1 = REORDER_BLOCK_SCOPE (bb1);\n+      scope s2 = REORDER_BLOCK_SCOPE (bb2);\n+      while (s1 != s2)\n+\t{\n+          if (! (s1 && s2))\n+\t    abort ();\n+\t  if (s1->level > s2->level)\n+\t    s1 = s1->outer;\n+\t  else if (s2->level > s1->level)\n+\t    s2 = s2->outer;\n+\t  else\n+\t    {\n+\t      s1 = s1->outer;\n+\t      s2 = s2->outer;\n+\t    }\n+\t}\n+      com = s1;\n+    }\n+  else\n+    com = NULL;\n+\n+  /* Close scopes.  */\n+  if (bb1)\n+    {\n+      scope s = REORDER_BLOCK_SCOPE (bb1);\n+      ip = REORDER_BLOCK_EFF_END (bb1);\n+      while (s != com)\n+\t{\n+\t  if (NOTE_BLOCK (s->note_beg))\n+\t    {  \n+\t      ip = emit_note_after (NOTE_INSN_BLOCK_END, ip);\n+\t      NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_end);\n+\t    }\n+\t  s = s->outer;\n+\t}\n+    }\n+\n+  /* Open scopes.  */\n+  if (bb2)\n+    {\n+      scope s = REORDER_BLOCK_SCOPE (bb2);\n+      ip = bb2->head;\n+      while (s != com)\n+\t{\n+\t  if (NOTE_BLOCK (s->note_beg))\n+\t    {  \n+\t      ip = emit_note_before (NOTE_INSN_BLOCK_BEG, ip);\n+\t      NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_beg);\n+\t    }\n+\t  s = s->outer;\n+\t}\n+    }\n+}\n+\n+\n+/* Rebuild all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes based\n+   on the scope forest and the newly reordered basic blocks.  */\n+\n+static void\n+rebuild_scope_notes (forest)\n+    scope_forest_info *forest;\n+{\n+  int i;\n+\n+  if (forest->num_trees == 0)\n+    return;\n+\n+  /* Start by opening the scopes before the first basic block.  */\n+  insert_inter_bb_scope_notes (NULL, BASIC_BLOCK (0));\n+\n+  /* Then, open and close scopes as needed between blocks.  */\n+  for (i = 0; i < n_basic_blocks - 1; i++)\n+    {\n+      basic_block bb1 = BASIC_BLOCK (i);\n+      basic_block bb2 = BASIC_BLOCK (i + 1);\n+      if (REORDER_BLOCK_SCOPE (bb1) != REORDER_BLOCK_SCOPE (bb2))\n+\tinsert_inter_bb_scope_notes (bb1, bb2);\n+      insert_intra_bb_scope_notes (bb1);\n+    }\n+\n+  /* Finally, close the scopes after the last basic block.  */\n+  insert_inter_bb_scope_notes (BASIC_BLOCK (n_basic_blocks - 1), NULL);\n+  insert_intra_bb_scope_notes (BASIC_BLOCK (n_basic_blocks - 1));\n+}\n+\n+\n+/* Free the storage associated with the scope tree at S.  */\n+\n+static void\n+free_scope_forest_1 (s)\n+    scope s;\n+{\n+  scope p, next;\n+\n+  for (p = s->inner; p; p = next)\n+    {\n+      next = p->next;\n+      free_scope_forest_1 (p);\n+    }\n+\n+  if (s->bbs)\n+    free (s->bbs);\n+  free (s);\n+}\n+\n+\n+/* Free the storage associated with the scope forest.  */\n+\n+static void\n+free_scope_forest (forest)\n+    scope_forest_info *forest;\n+{\n+  int i;\n+  for (i = 0; i < forest->num_trees; i++)\n+    free_scope_forest_1 (forest->trees[i]);\n+}\n+\n+\n+/* Visualize the scope forest.  */\n+\n+void\n+dump_scope_forest (forest)\n+    scope_forest_info *forest;\n+{\n+  if (forest->num_trees == 0)\n+    fprintf (stderr, \"\\n< Empty scope forest >\\n\");\n+  else\n+    {\n+      int i;\n+      fprintf (stderr, \"\\n< Scope forest >\\n\");\n+      for (i = 0; i < forest->num_trees; i++)\n+\tdump_scope_forest_1 (forest->trees[i], 0);\n+    }\n+}\n+\n+\n+/* Recursive portion of dump_scope_forest.  */\n+\n+static void\n+dump_scope_forest_1 (s, indent)\n+     scope s;\n+     int indent;\n+{\n+  scope p;\n+  int i;\n+\n+  if (s->bb_beg != NULL && s->bb_beg == s->bb_end\n+      && REORDER_BLOCK_SCOPE (s->bb_beg)\n+      && REORDER_BLOCK_SCOPE (s->bb_beg)->level + 1 == s->level)\n+    {\n+      fprintf (stderr, \"%*s\", indent, \"\");\n+      fprintf (stderr, \"BB%d:\\n\", s->bb_beg->index);\n+    }\n+\n+  fprintf (stderr, \"%*s\", indent, \"\");\n+  fprintf (stderr, \"{ level %d (block %p)\\n\", s->level,\n+\t   NOTE_BLOCK (s->note_beg));\n+\n+  fprintf (stderr, \"%*s%s\", indent, \"\", \"bbs:\");\n+  for (i = 0; i < s->num_bbs; i++)\n+    fprintf (stderr, \" %d\", s->bbs[i]->index);\n+  fprintf (stderr, \"\\n\");\n+  \n+  for (p = s->inner; p; p = p->next)\n+    dump_scope_forest_1 (p, indent + 2);\n+\n+  fprintf (stderr, \"%*s\", indent, \"\");\n+  fprintf (stderr, \"}\\n\");\n+}\n+\n+\n /* Reorder basic blocks.  */\n \n void\n@@ -785,6 +1427,7 @@ reorder_basic_blocks ()\n   int i, j;\n   struct loops loops_info;\n   int num_loops;\n+  scope_forest_info forest;\n \n   if (profile_arc_flag)\n     return;\n@@ -820,6 +1463,14 @@ reorder_basic_blocks ()\n       basic_block bbi = BASIC_BLOCK (i);\n       bbi->aux = xcalloc (1, sizeof (struct reorder_block_def));\n       *((struct reorder_block_def *)bbi->aux) = rbd_init;\n+    }\n+\n+  build_scope_forest (&forest);\n+  remove_scope_notes ();\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      basic_block bbi = BASIC_BLOCK (i);\n       REORDER_BLOCK_EFF_END (bbi)\n \t= skip_insns_between_block (bbi, REORDER_SKIP_AFTER);\n       if (i == 0)\n@@ -877,6 +1528,10 @@ reorder_basic_blocks ()\n \t}\n     }\n \n+  rebuild_scope_notes (&forest);\n+  free_scope_forest (&forest);\n+  reorder_blocks ();\n+\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif"}]}