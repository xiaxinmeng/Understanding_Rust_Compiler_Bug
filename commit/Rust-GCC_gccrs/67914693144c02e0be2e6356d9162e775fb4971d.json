{"sha": "67914693144c02e0be2e6356d9162e775fb4971d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc5MTQ2OTMxNDRjMDJlMGJlMmU2MzU2ZDkxNjJlNzc1ZmI0OTcxZA==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2019-01-09T21:37:45Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2019-01-09T21:37:45Z"}, "message": "PR other/16615 [1/5]\n\n2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tPR other/16615 [1/5]\n\n\tcontrib/\n\t* mklog: Mechanically replace \"can not\" with \"cannot\".\n\n\tgcc/\n\t* Makefile.in: Mechanically replace \"can not\" with \"cannot\".\n\t* alias.c: Likewise.\n\t* builtins.c: Likewise.\n\t* calls.c: Likewise.\n\t* cgraph.c: Likewise.\n\t* cgraph.h: Likewise.\n\t* cgraphclones.c: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* combine-stack-adj.c: Likewise.\n\t* combine.c: Likewise.\n\t* common/config/i386/i386-common.c: Likewise.\n\t* config/aarch64/aarch64.c: Likewise.\n\t* config/alpha/sync.md: Likewise.\n\t* config/arc/arc.c: Likewise.\n\t* config/arc/predicates.md: Likewise.\n\t* config/arm/arm-c.c: Likewise.\n\t* config/arm/arm.c: Likewise.\n\t* config/arm/arm.h: Likewise.\n\t* config/arm/arm.md: Likewise.\n\t* config/arm/cortex-r4f.md: Likewise.\n\t* config/csky/csky.c: Likewise.\n\t* config/csky/csky.h: Likewise.\n\t* config/darwin-f.c: Likewise.\n\t* config/epiphany/epiphany.md: Likewise.\n\t* config/i386/i386.c: Likewise.\n\t* config/i386/sol2.h: Likewise.\n\t* config/m68k/m68k.c: Likewise.\n\t* config/mcore/mcore.h: Likewise.\n\t* config/microblaze/microblaze.md: Likewise.\n\t* config/mips/20kc.md: Likewise.\n\t* config/mips/sb1.md: Likewise.\n\t* config/nds32/nds32.c: Likewise.\n\t* config/nds32/predicates.md: Likewise.\n\t* config/pa/pa.c: Likewise.\n\t* config/rs6000/e300c2c3.md: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t* config/s390/s390.h: Likewise.\n\t* config/sh/sh.c: Likewise.\n\t* config/sh/sh.md: Likewise.\n\t* config/spu/vmx2spu.h: Likewise.\n\t* cprop.c: Likewise.\n\t* dbxout.c: Likewise.\n\t* df-scan.c: Likewise.\n\t* doc/cfg.texi: Likewise.\n\t* doc/extend.texi: Likewise.\n\t* doc/fragments.texi: Likewise.\n\t* doc/gty.texi: Likewise.\n\t* doc/invoke.texi: Likewise.\n\t* doc/lto.texi: Likewise.\n\t* doc/md.texi: Likewise.\n\t* doc/objc.texi: Likewise.\n\t* doc/rtl.texi: Likewise.\n\t* doc/tm.texi: Likewise.\n\t* dse.c: Likewise.\n\t* emit-rtl.c: Likewise.\n\t* emit-rtl.h: Likewise.\n\t* except.c: Likewise.\n\t* expmed.c: Likewise.\n\t* expr.c: Likewise.\n\t* fold-const.c: Likewise.\n\t* genautomata.c: Likewise.\n\t* gimple-fold.c: Likewise.\n\t* hard-reg-set.h: Likewise.\n\t* ifcvt.c: Likewise.\n\t* ipa-comdats.c: Likewise.\n\t* ipa-cp.c: Likewise.\n\t* ipa-devirt.c: Likewise.\n\t* ipa-fnsummary.c: Likewise.\n\t* ipa-icf.c: Likewise.\n\t* ipa-inline-transform.c: Likewise.\n\t* ipa-inline.c: Likewise.\n\t* ipa-polymorphic-call.c: Likewise.\n\t* ipa-profile.c: Likewise.\n\t* ipa-prop.c: Likewise.\n\t* ipa-pure-const.c: Likewise.\n\t* ipa-reference.c: Likewise.\n\t* ipa-split.c: Likewise.\n\t* ipa-visibility.c: Likewise.\n\t* ipa.c: Likewise.\n\t* ira-build.c: Likewise.\n\t* ira-color.c: Likewise.\n\t* ira-conflicts.c: Likewise.\n\t* ira-costs.c: Likewise.\n\t* ira-int.h: Likewise.\n\t* ira-lives.c: Likewise.\n\t* ira.c: Likewise.\n\t* ira.h: Likewise.\n\t* loop-invariant.c: Likewise.\n\t* loop-unroll.c: Likewise.\n\t* lower-subreg.c: Likewise.\n\t* lra-assigns.c: Likewise.\n\t* lra-constraints.c: Likewise.\n\t* lra-eliminations.c: Likewise.\n\t* lra-lives.c: Likewise.\n\t* lra-remat.c: Likewise.\n\t* lra-spills.c: Likewise.\n\t* lra.c: Likewise.\n\t* lto-cgraph.c: Likewise.\n\t* lto-streamer-out.c: Likewise.\n\t* postreload-gcse.c: Likewise.\n\t* predict.c: Likewise.\n\t* profile-count.h: Likewise.\n\t* profile.c: Likewise.\n\t* recog.c: Likewise.\n\t* ree.c: Likewise.\n\t* reload.c: Likewise.\n\t* reload1.c: Likewise.\n\t* reorg.c: Likewise.\n\t* resource.c: Likewise.\n\t* rtl.def: Likewise.\n\t* rtl.h: Likewise.\n\t* rtlanal.c: Likewise.\n\t* sched-deps.c: Likewise.\n\t* sched-ebb.c: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* sel-sched-ir.c: Likewise.\n\t* sel-sched.c: Likewise.\n\t* shrink-wrap.c: Likewise.\n\t* simplify-rtx.c: Likewise.\n\t* symtab.c: Likewise.\n\t* target.def: Likewise.\n\t* toplev.c: Likewise.\n\t* tree-call-cdce.c: Likewise.\n\t* tree-cfg.c: Likewise.\n\t* tree-complex.c: Likewise.\n\t* tree-core.h: Likewise.\n\t* tree-eh.c: Likewise.\n\t* tree-inline.c: Likewise.\n\t* tree-loop-distribution.c: Likewise.\n\t* tree-nrv.c: Likewise.\n\t* tree-profile.c: Likewise.\n\t* tree-sra.c: Likewise.\n\t* tree-ssa-alias.c: Likewise.\n\t* tree-ssa-dce.c: Likewise.\n\t* tree-ssa-dom.c: Likewise.\n\t* tree-ssa-forwprop.c: Likewise.\n\t* tree-ssa-loop-im.c: Likewise.\n\t* tree-ssa-loop-ivcanon.c: Likewise.\n\t* tree-ssa-loop-ivopts.c: Likewise.\n\t* tree-ssa-loop-niter.c: Likewise.\n\t* tree-ssa-phionlycprop.c: Likewise.\n\t* tree-ssa-phiopt.c: Likewise.\n\t* tree-ssa-propagate.c: Likewise.\n\t* tree-ssa-threadedge.c: Likewise.\n\t* tree-ssa-threadupdate.c: Likewise.\n\t* tree-ssa-uninit.c: Likewise.\n\t* tree-ssanames.c: Likewise.\n\t* tree-streamer-out.c: Likewise.\n\t* tree.c: Likewise.\n\t* tree.h: Likewise.\n\t* vr-values.c: Likewise.\n\n\tgcc/ada/\n\t* exp_ch9.adb: Mechanically replace \"can not\" with \"cannot\".\n\t* libgnat/s-regpat.ads: Likewise.\n\t* par-ch4.adb: Likewise.\n\t* set_targ.adb: Likewise.\n\t* types.ads: Likewise.\n\n\tgcc/cp/\n\t* cp-tree.h: Mechanically replace \"can not\" with \"cannot\".\n\t* parser.c: Likewise.\n\t* pt.c: Likewise.\n\n\tgcc/fortran/\n\t* class.c: Mechanically replace \"can not\" with \"cannot\".\n\t* decl.c: Likewise.\n\t* expr.c: Likewise.\n\t* gfc-internals.texi: Likewise.\n\t* intrinsic.texi: Likewise.\n\t* invoke.texi: Likewise.\n\t* io.c: Likewise.\n\t* match.c: Likewise.\n\t* parse.c: Likewise.\n\t* primary.c: Likewise.\n\t* resolve.c: Likewise.\n\t* symbol.c: Likewise.\n\t* trans-array.c: Likewise.\n\t* trans-decl.c: Likewise.\n\t* trans-intrinsic.c: Likewise.\n\t* trans-stmt.c: Likewise.\n\n\tgcc/go/\n\t* go-backend.c: Mechanically replace \"can not\" with \"cannot\".\n\t* go-gcc.cc: Likewise.\n\n\tgcc/lto/\n\t* lto-partition.c: Mechanically replace \"can not\" with \"cannot\".\n\t* lto-symtab.c: Likewise.\n\t* lto.c: Likewise.\n\n\tgcc/objc/\n\t* objc-act.c: Mechanically replace \"can not\" with \"cannot\".\n\n\tlibbacktrace/\n\t* backtrace.h: Mechanically replace \"can not\" with \"cannot\".\n\n\tlibgcc/\n\t* config/c6x/libunwind.S: Mechanically replace \"can not\" with\n\t\"cannot\".\n\t* config/tilepro/atomic.h: Likewise.\n\t* config/vxlib-tls.c: Likewise.\n\t* generic-morestack-thread.c: Likewise.\n\t* generic-morestack.c: Likewise.\n\t* mkmap-symver.awk: Likewise.\n\n\tlibgfortran/\n\t* caf/single.c: Mechanically replace \"can not\" with \"cannot\".\n\t* io/unit.c: Likewise.\n\n\tlibobjc/\n\t* class.c: Mechanically replace \"can not\" with \"cannot\".\n\t* objc/runtime.h: Likewise.\n\t* sendmsg.c: Likewise.\n\n\tliboffloadmic/\n\t* include/coi/common/COIResult_common.h: Mechanically replace\n\t\"can not\" with \"cannot\".\n\t* include/coi/source/COIBuffer_source.h: Likewise.\n\n\tlibstdc++-v3/\n\t* include/ext/bitmap_allocator.h: Mechanically replace \"can not\"\n\twith \"cannot\".\n\nFrom-SVN: r267783", "tree": {"sha": "63ea86de007194fa30edb25c79acb6a6136e5cab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63ea86de007194fa30edb25c79acb6a6136e5cab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67914693144c02e0be2e6356d9162e775fb4971d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67914693144c02e0be2e6356d9162e775fb4971d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67914693144c02e0be2e6356d9162e775fb4971d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67914693144c02e0be2e6356d9162e775fb4971d/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ee0b3cea205eb7e832d7262425ddee8ed34778e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee0b3cea205eb7e832d7262425ddee8ed34778e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee0b3cea205eb7e832d7262425ddee8ed34778e5"}], "stats": {"total": 1134, "additions": 699, "deletions": 435}, "files": [{"sha": "eb765edcbe2663cb4c47fafd49cf6a30f3e65362", "filename": "contrib/mklog", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/contrib%2Fmklog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/contrib%2Fmklog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fmklog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -236,7 +236,7 @@ def find_changed_funs(hunk):\n \n     change = line and re.match(r'^[-+!][^-]', line)\n \n-    # Top-level comment can not belong to function\n+    # Top-level comment cannot belong to function\n     if re.match(r'^[-+! ]\\/\\*', line):\n       fn = None\n "}, {"sha": "749b9bcd3105e7a15be4446f2481133637856374", "filename": "gcc/ChangeLog", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,159 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* Makefile.in: Mechanically replace \"can not\" with \"cannot\".\n+\t* alias.c: Likewise.\n+\t* builtins.c: Likewise.\n+\t* calls.c: Likewise.\n+\t* cgraph.c: Likewise.\n+\t* cgraph.h: Likewise.\n+\t* cgraphclones.c: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* combine-stack-adj.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* common/config/i386/i386-common.c: Likewise.\n+\t* config/aarch64/aarch64.c: Likewise.\n+\t* config/alpha/sync.md: Likewise.\n+\t* config/arc/arc.c: Likewise.\n+\t* config/arc/predicates.md: Likewise.\n+\t* config/arm/arm-c.c: Likewise.\n+\t* config/arm/arm.c: Likewise.\n+\t* config/arm/arm.h: Likewise.\n+\t* config/arm/arm.md: Likewise.\n+\t* config/arm/cortex-r4f.md: Likewise.\n+\t* config/csky/csky.c: Likewise.\n+\t* config/csky/csky.h: Likewise.\n+\t* config/darwin-f.c: Likewise.\n+\t* config/epiphany/epiphany.md: Likewise.\n+\t* config/i386/i386.c: Likewise.\n+\t* config/i386/sol2.h: Likewise.\n+\t* config/m68k/m68k.c: Likewise.\n+\t* config/mcore/mcore.h: Likewise.\n+\t* config/microblaze/microblaze.md: Likewise.\n+\t* config/mips/20kc.md: Likewise.\n+\t* config/mips/sb1.md: Likewise.\n+\t* config/nds32/nds32.c: Likewise.\n+\t* config/nds32/predicates.md: Likewise.\n+\t* config/pa/pa.c: Likewise.\n+\t* config/rs6000/e300c2c3.md: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n+\t* config/s390/s390.h: Likewise.\n+\t* config/sh/sh.c: Likewise.\n+\t* config/sh/sh.md: Likewise.\n+\t* config/spu/vmx2spu.h: Likewise.\n+\t* cprop.c: Likewise.\n+\t* dbxout.c: Likewise.\n+\t* df-scan.c: Likewise.\n+\t* doc/cfg.texi: Likewise.\n+\t* doc/extend.texi: Likewise.\n+\t* doc/fragments.texi: Likewise.\n+\t* doc/gty.texi: Likewise.\n+\t* doc/invoke.texi: Likewise.\n+\t* doc/lto.texi: Likewise.\n+\t* doc/md.texi: Likewise.\n+\t* doc/objc.texi: Likewise.\n+\t* doc/rtl.texi: Likewise.\n+\t* doc/tm.texi: Likewise.\n+\t* dse.c: Likewise.\n+\t* emit-rtl.c: Likewise.\n+\t* emit-rtl.h: Likewise.\n+\t* except.c: Likewise.\n+\t* expmed.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* fold-const.c: Likewise.\n+\t* genautomata.c: Likewise.\n+\t* gimple-fold.c: Likewise.\n+\t* hard-reg-set.h: Likewise.\n+\t* ifcvt.c: Likewise.\n+\t* ipa-comdats.c: Likewise.\n+\t* ipa-cp.c: Likewise.\n+\t* ipa-devirt.c: Likewise.\n+\t* ipa-fnsummary.c: Likewise.\n+\t* ipa-icf.c: Likewise.\n+\t* ipa-inline-transform.c: Likewise.\n+\t* ipa-inline.c: Likewise.\n+\t* ipa-polymorphic-call.c: Likewise.\n+\t* ipa-profile.c: Likewise.\n+\t* ipa-prop.c: Likewise.\n+\t* ipa-pure-const.c: Likewise.\n+\t* ipa-reference.c: Likewise.\n+\t* ipa-split.c: Likewise.\n+\t* ipa-visibility.c: Likewise.\n+\t* ipa.c: Likewise.\n+\t* ira-build.c: Likewise.\n+\t* ira-color.c: Likewise.\n+\t* ira-conflicts.c: Likewise.\n+\t* ira-costs.c: Likewise.\n+\t* ira-int.h: Likewise.\n+\t* ira-lives.c: Likewise.\n+\t* ira.c: Likewise.\n+\t* ira.h: Likewise.\n+\t* loop-invariant.c: Likewise.\n+\t* loop-unroll.c: Likewise.\n+\t* lower-subreg.c: Likewise.\n+\t* lra-assigns.c: Likewise.\n+\t* lra-constraints.c: Likewise.\n+\t* lra-eliminations.c: Likewise.\n+\t* lra-lives.c: Likewise.\n+\t* lra-remat.c: Likewise.\n+\t* lra-spills.c: Likewise.\n+\t* lra.c: Likewise.\n+\t* lto-cgraph.c: Likewise.\n+\t* lto-streamer-out.c: Likewise.\n+\t* postreload-gcse.c: Likewise.\n+\t* predict.c: Likewise.\n+\t* profile-count.h: Likewise.\n+\t* profile.c: Likewise.\n+\t* recog.c: Likewise.\n+\t* ree.c: Likewise.\n+\t* reload.c: Likewise.\n+\t* reload1.c: Likewise.\n+\t* reorg.c: Likewise.\n+\t* resource.c: Likewise.\n+\t* rtl.def: Likewise.\n+\t* rtl.h: Likewise.\n+\t* rtlanal.c: Likewise.\n+\t* sched-deps.c: Likewise.\n+\t* sched-ebb.c: Likewise.\n+\t* sched-rgn.c: Likewise.\n+\t* sel-sched-ir.c: Likewise.\n+\t* sel-sched.c: Likewise.\n+\t* shrink-wrap.c: Likewise.\n+\t* simplify-rtx.c: Likewise.\n+\t* symtab.c: Likewise.\n+\t* target.def: Likewise.\n+\t* toplev.c: Likewise.\n+\t* tree-call-cdce.c: Likewise.\n+\t* tree-cfg.c: Likewise.\n+\t* tree-complex.c: Likewise.\n+\t* tree-core.h: Likewise.\n+\t* tree-eh.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* tree-loop-distribution.c: Likewise.\n+\t* tree-nrv.c: Likewise.\n+\t* tree-profile.c: Likewise.\n+\t* tree-sra.c: Likewise.\n+\t* tree-ssa-alias.c: Likewise.\n+\t* tree-ssa-dce.c: Likewise.\n+\t* tree-ssa-dom.c: Likewise.\n+\t* tree-ssa-forwprop.c: Likewise.\n+\t* tree-ssa-loop-im.c: Likewise.\n+\t* tree-ssa-loop-ivcanon.c: Likewise.\n+\t* tree-ssa-loop-ivopts.c: Likewise.\n+\t* tree-ssa-loop-niter.c: Likewise.\n+\t* tree-ssa-phionlycprop.c: Likewise.\n+\t* tree-ssa-phiopt.c: Likewise.\n+\t* tree-ssa-propagate.c: Likewise.\n+\t* tree-ssa-threadedge.c: Likewise.\n+\t* tree-ssa-threadupdate.c: Likewise.\n+\t* tree-ssa-uninit.c: Likewise.\n+\t* tree-ssanames.c: Likewise.\n+\t* tree-streamer-out.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* tree.h: Likewise.\n+\t* vr-values.c: Likewise.\n+\n 2019-01-09  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386-protos.h (ix86_expand_xorsign): New prototype."}, {"sha": "2fa9083d1b3ffe4bf666c4302ddf658cf64d5387", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -746,7 +746,7 @@ EXTRA_HEADERS =@extra_headers_list@\n USE_GCC_STDINT = @use_gcc_stdint@\n \n # The configure script will set this to collect2$(exeext), except on a\n-# (non-Unix) host which can not build collect2, for which it will be\n+# (non-Unix) host which cannot build collect2, for which it will be\n # set to empty.\n COLLECT2 = @collect2@\n "}, {"sha": "402ad9288b14f117d7bebec3e4be6649ec20ea44", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,13 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* exp_ch9.adb: Mechanically replace \"can not\" with \"cannot\".\n+\t* libgnat/s-regpat.ads: Likewise.\n+\t* par-ch4.adb: Likewise.\n+\t* set_targ.adb: Likewise.\n+\t* types.ads: Likewise.\n+\n 2019-01-08  Justin Squirek  <squirek@adacore.com>\n \n \tRevert:"}, {"sha": "5ec9fb486e5679b7e4e7d9fe6bbcd60d23d4af3c", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -3741,7 +3741,7 @@ package body Exp_Ch9 is\n             raise Program_Error;\n       end case;\n \n-      --  When exceptions can not be propagated, we never need to call\n+      --  When exceptions cannot be propagated, we never need to call\n       --  Exception_Complete_Entry_Body.\n \n       if No_Exception_Handlers_Set then"}, {"sha": "74ecdec96a46c75bbbed405904a5a75f5fae0e15", "filename": "gcc/ada/libgnat/s-regpat.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fada%2Flibgnat%2Fs-regpat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fada%2Flibgnat%2Fs-regpat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-regpat.ads?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -347,7 +347,7 @@ package System.Regpat is\n    --  N'th parenthesized subexpressions; Matches (0) is for the whole\n    --  expression.\n    --\n-   --  Non-capturing parenthesis (introduced with (?:...)) can not be\n+   --  Non-capturing parenthesis (introduced with (?:...)) cannot be\n    --  retrieved and do not count in the match array index.\n    --\n    --  For instance, if your regular expression is: \"a((b*)c+)(d+)\", then"}, {"sha": "9de9a606c6fbc9d505c539cd6a6fcfb49b2eee1b", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1884,7 +1884,7 @@ package body Ch4 is\n    --  called in all contexts where a right parenthesis cannot legitimately\n    --  follow an expression.\n \n-   --  Error recovery: can not raise Error_Resync\n+   --  Error recovery: cannot raise Error_Resync\n \n    function P_Expression_No_Right_Paren return Node_Id is\n       Expr : constant Node_Id := P_Expression;"}, {"sha": "ae4a8c6195cef972df9475e79932d416cfa27a2b", "filename": "gcc/ada/set_targ.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fada%2Fset_targ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fada%2Fset_targ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fset_targ.adb?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -820,7 +820,7 @@ package body Set_Targ is\n \n begin\n    --  First step: see if the -gnateT switch is present. As we have noted,\n-   --  this has to be done very early, so can not depend on the normal circuit\n+   --  this has to be done very early, so cannot depend on the normal circuit\n    --  for reading switches and setting switches in Opt. The following code\n    --  will set Opt.Target_Dependent_Info_Read_Name if the switch -gnateT=name\n    --  is present in the options string."}, {"sha": "12974515af2e05cbf6e86155370c225173e4df52", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -138,7 +138,7 @@ package Types is\n    -- Types Used for Text Buffer Handling --\n    -----------------------------------------\n \n-   --  We can not use type String for text buffers, since we must use the\n+   --  We cannot use type String for text buffers, since we must use the\n    --  standard 32-bit integer as an index value, since we count on all index\n    --  values being the same size.\n "}, {"sha": "b64e3ea264d6d9a917ba3558ce252f34ff61d3b6", "filename": "gcc/alias.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -832,7 +832,7 @@ get_alias_set (tree t)\n {\n   alias_set_type set;\n \n-  /* We can not give up with -fno-strict-aliasing because we need to build\n+  /* We cannot give up with -fno-strict-aliasing because we need to build\n      proper type representation for possible functions which are build with\n      -fstrict-aliasing.  */\n \n@@ -894,7 +894,7 @@ get_alias_set (tree t)\n       /* Handle structure type equality for pointer types, arrays and vectors.\n \t This is easy to do, because the code bellow ignore canonical types on\n \t these anyway.  This is important for LTO, where TYPE_CANONICAL for\n-\t pointers can not be meaningfuly computed by the frotnend.  */\n+\t pointers cannot be meaningfuly computed by the frotnend.  */\n       if (canonical_type_used_p (t))\n \t{\n \t  /* In LTO we set canonical types for all types where it makes\n@@ -1058,7 +1058,7 @@ get_alias_set (tree t)\n \t    }\n \n \t  /* Assign the alias set to both p and t.\n-\t     We can not call get_alias_set (p) here as that would trigger\n+\t     We cannot call get_alias_set (p) here as that would trigger\n \t     infinite recursion when p == t.  In other cases it would just\n \t     trigger unnecesary legwork of rebuilding the pointer again.  */\n \t  gcc_checking_assert (p == TYPE_MAIN_VARIANT (p));\n@@ -2061,7 +2061,7 @@ may_be_sp_based_p (rtx x)\n }\n \n /* BASE1 and BASE2 are decls.  Return 1 if they refer to same object, 0\n-   if they refer to different objects and -1 if we can not decide.  */\n+   if they refer to different objects and -1 if we cannot decide.  */\n \n int\n compare_base_decls (tree base1, tree base2)\n@@ -2135,7 +2135,7 @@ compare_base_symbol_refs (const_rtx x_base, const_rtx y_base)\n \n       symtab_node *x_node = symtab_node::get_create (x_decl)\n \t\t\t    ->ultimate_alias_target ();\n-      /* External variable can not be in section anchor.  */\n+      /* External variable cannot be in section anchor.  */\n       if (!x_node->definition)\n \treturn 0;\n       x_base = XEXP (DECL_RTL (x_node->decl), 0);\n@@ -2651,7 +2651,7 @@ memrefs_conflict_p (poly_int64 xsize, rtx x, poly_int64 ysize, rtx y,\n    ways.\n \n    If both memory references are volatile, then there must always be a\n-   dependence between the two references, since their order can not be\n+   dependence between the two references, since their order cannot be\n    changed.  A volatile and non-volatile reference can be interchanged\n    though.\n "}, {"sha": "6135bc5a4e2359a1f514310ac28d6dd34808de13", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -6529,7 +6529,7 @@ expand_builtin_atomic_fetch_op (machine_mode mode, tree exp, rtx target,\n   gcc_assert (TREE_OPERAND (addr, 0) == fndecl);\n   TREE_OPERAND (addr, 0) = builtin_decl_explicit (ext_call);\n \n-  /* If we will emit code after the call, the call can not be a tail call.\n+  /* If we will emit code after the call, the call cannot be a tail call.\n      If it is emitted as a tail call, a barrier is emitted after it, and\n      then all trailing code is removed.  */\n   if (!ignore)"}, {"sha": "e11977e98df64b144d19ebd4f9669d8254070ab7", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -3145,7 +3145,7 @@ can_implement_as_sibling_call_p (tree exp,\n     }\n \n #ifdef REG_PARM_STACK_SPACE\n-  /* If outgoing reg parm stack space changes, we can not do sibcall.  */\n+  /* If outgoing reg parm stack space changes, we cannot do sibcall.  */\n   if (OUTGOING_REG_PARM_STACK_SPACE (funtype)\n       != OUTGOING_REG_PARM_STACK_SPACE (TREE_TYPE (current_function_decl))\n       || (reg_parm_stack_space != REG_PARM_STACK_SPACE (current_function_decl)))\n@@ -4294,7 +4294,7 @@ expand_call (tree exp, rtx target, int ignore)\n \n \t  emit_move_insn (temp, valreg);\n \n-\t  /* The return value from a malloc-like function can not alias\n+\t  /* The return value from a malloc-like function cannot alias\n \t     anything else.  */\n \t  last = get_last_insn ();\n \t  add_reg_note (last, REG_NOALIAS, temp);"}, {"sha": "c9788d0286a44e631a5b2b48415f3ccfc5547634", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2708,7 +2708,7 @@ cgraph_node::set_pure_flag (bool pure, bool looping)\n   return info.changed;\n }\n \n-/* Return true when cgraph_node can not return or throw and thus\n+/* Return true when cgraph_node cannot return or throw and thus\n    it is safe to ignore its side effects for IPA analysis.  */\n \n bool\n@@ -2722,7 +2722,7 @@ cgraph_node::cannot_return_p (void)\n \t     == (ECF_NORETURN | ECF_NOTHROW));\n }\n \n-/* Return true when call of edge can not lead to return from caller\n+/* Return true when call of edge cannot lead to return from caller\n    and thus it is safe to ignore its side effects for IPA analysis\n    when computing side effects of the caller.\n    FIXME: We could actually mark all edges that have no reaching"}, {"sha": "c016da3875c54add93f74ca3b3c1ef84148e904d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -51,7 +51,7 @@ enum symtab_type\n struct GTY((for_user)) section_hash_entry\n {\n   int ref_count;\n-  char *name;  /* As long as this datastructure stays in GGC, we can not put\n+  char *name;  /* As long as this datastructure stays in GGC, we cannot put\n \t\t  string at the tail of structure of GGC dies in horrible\n \t\t  way  */\n };\n@@ -283,7 +283,7 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n \t\t\t\t    void *data,\n \t\t\t\t    bool include_overwrite);\n \n-  /* If node can not be interposable by static or dynamic linker to point to\n+  /* If node cannot be interposable by static or dynamic linker to point to\n      different definition, return this symbol. Otherwise look for alias with\n      such property and if none exists, introduce new one.  */\n   symtab_node *noninterposable_alias (void);\n@@ -482,7 +482,7 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* C++ frontend produce same body aliases and extra name aliases for\n      virtual functions and vtables that are obviously equivalent.\n      Those aliases are bit special, especially because C++ frontend\n-     visibility code is so ugly it can not get them right at first time\n+     visibility code is so ugly it cannot get them right at first time\n      and their visibility needs to be copied from their \"masters\" at\n      the end of parsing.  */\n   unsigned cpp_implicit_alias : 1;\n@@ -709,7 +709,7 @@ struct GTY(()) cgraph_local_info {\n   /* False when there is something makes versioning impossible.  */\n   unsigned versionable : 1;\n \n-  /* False when function calling convention and signature can not be changed.\n+  /* False when function calling convention and signature cannot be changed.\n      This is the case when __builtin_apply_args is used.  */\n   unsigned can_change_signature : 1;\n \n@@ -1229,7 +1229,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      compilation units.  */\n   bool can_be_local_p (void);\n \n-  /* Return true when cgraph_node can not return or throw and thus\n+  /* Return true when cgraph_node cannot return or throw and thus\n      it is safe to ignore its side effects for IPA analysis.  */\n   bool cannot_return_p (void);\n \n@@ -1577,7 +1577,7 @@ class GTY(()) ipa_polymorphic_call_context {\n \n   /* Adjust all offsets in contexts by given number of bits.  */\n   void offset_by (HOST_WIDE_INT);\n-  /* Use when we can not track dynamic type change.  This speculatively assume\n+  /* Use when we cannot track dynamic type change.  This speculatively assume\n      type change is not happening.  */\n   void possible_dynamic_type_change (bool, tree otr_type = NULL);\n   /* Assume that both THIS and a given context is valid and strenghten THIS\n@@ -1709,7 +1709,7 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* Verify edge count and frequency.  */\n   bool verify_count ();\n \n-  /* Return true when call of edge can not lead to return from caller\n+  /* Return true when call of edge cannot lead to return from caller\n      and thus it is safe to ignore its side effects for IPA analysis\n      when computing side effects of the caller.  */\n   bool cannot_lead_to_return_p (void);\n@@ -2933,7 +2933,7 @@ cgraph_node::can_remove_if_no_direct_calls_and_refs_p (void)\n   /* Extern inlines can always go, we will use the external definition.  */\n   if (DECL_EXTERNAL (decl))\n     return true;\n-  /* When function is needed, we can not remove it.  */\n+  /* When function is needed, we cannot remove it.  */\n   if (force_output || used_from_other_partition)\n     return false;\n   if (DECL_STATIC_CONSTRUCTOR (decl)"}, {"sha": "4688de91cfe73e176e4448faa4e72814acb71cee", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -648,7 +648,7 @@ cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n   DECL_ARGUMENTS (new_decl) = NULL;\n   DECL_INITIAL (new_decl) = NULL;\n   DECL_RESULT (new_decl) = NULL; \n-  /* We can not do DECL_RESULT (new_decl) = NULL; here because of LTO partitioning\n+  /* We cannot do DECL_RESULT (new_decl) = NULL; here because of LTO partitioning\n      sometimes storing only clone decl instead of original.  */\n \n   /* Generate a new name for the new version. */"}, {"sha": "1cf9ac53a28aae118e223e0ca7dfd8b8e5577fdd", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1051,7 +1051,7 @@ analyze_functions (bool first_time)\n   symtab->state = CONSTRUCTION;\n   input_location = UNKNOWN_LOCATION;\n \n-  /* Ugly, but the fixup can not happen at a time same body alias is created;\n+  /* Ugly, but the fixup cannot happen at a time same body alias is created;\n      C++ FE is confused about the COMDAT groups being right.  */\n   if (symtab->cpp_implicit_aliases_done)\n     FOR_EACH_SYMBOL (node)"}, {"sha": "3638a1b10ee4c81d2cba803355bbb588eb37405f", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -540,7 +540,7 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t\t Also we need to be careful to not move stack pointer\n \t\t such that we create stack accesses outside the allocated\n \t\t area.  We can combine an allocation into the first insn,\n-\t\t or a deallocation into the second insn.  We can not\n+\t\t or a deallocation into the second insn.  We cannot\n \t\t combine an allocation followed by a deallocation.\n \n \t\t The only somewhat frequent occurrence of the later is when"}, {"sha": "e226c7dd353986a69c31d65b26bb89062f2dcb4c", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -530,7 +530,7 @@ target_canonicalize_comparison (enum rtx_code *code, rtx *op0, rtx *op1,\n }\n \n /* Try to split PATTERN found in INSN.  This returns NULL_RTX if\n-   PATTERN can not be split.  Otherwise, it returns an insn sequence.\n+   PATTERN cannot be split.  Otherwise, it returns an insn sequence.\n    This is a wrapper around split_insns which ensures that the\n    reg_stat vector is made larger if the splitter creates a new\n    register.  */"}, {"sha": "a5dac6d7303b9f2f6d1d5cccda26a27368d96e19", "filename": "gcc/common/config/i386/i386-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1411,7 +1411,7 @@ ix86_option_init_struct (struct gcc_options *opts)\n }\n \n /* On the x86 -fsplit-stack and -fstack-protector both use the same\n-   field in the TCB, so they can not be used together.  */\n+   field in the TCB, so they cannot be used together.  */\n \n static bool\n ix86_supports_split_stack (bool report ATTRIBUTE_UNUSED,"}, {"sha": "1c300af19bc8a9aff9397de7c0ebbdb6d2b3d0e3", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -14780,7 +14780,7 @@ aarch64_simd_dup_constant (rtx vals)\n /* Generate code to load VALS, which is a PARALLEL containing only\n    constants (for vec_init) or CONST_VECTOR, efficiently into a\n    register.  Returns an RTX to copy into the register, or NULL_RTX\n-   for a PARALLEL that can not be converted into a CONST_VECTOR.  */\n+   for a PARALLEL that cannot be converted into a CONST_VECTOR.  */\n static rtx\n aarch64_simd_make_constant (rtx vals)\n {\n@@ -14818,12 +14818,12 @@ aarch64_simd_make_constant (rtx vals)\n     /* Loaded using DUP.  */\n     return const_dup;\n   else if (const_vec != NULL_RTX)\n-    /* Load from constant pool. We can not take advantage of single-cycle\n+    /* Load from constant pool. We cannot take advantage of single-cycle\n        LD1 because we need a PC-relative addressing mode.  */\n     return const_vec;\n   else\n     /* A PARALLEL containing something not valid inside CONST_VECTOR.\n-       We can not construct an initializer.  */\n+       We cannot construct an initializer.  */\n     return NULL_RTX;\n }\n "}, {"sha": "c416ad4b43e7caddc393baf6779975557d70f91b", "filename": "gcc/config/alpha/sync.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Falpha%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Falpha%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fsync.md?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -65,7 +65,7 @@\n ;; the lock is cleared by a normal load or store.  This means we cannot\n ;; expand a ll/sc sequence before reload, lest a register spill is\n ;; inserted inside the sequence.  It is also UNPREDICTABLE whether the\n-;; lock is cleared by a TAKEN branch.  This means that we can not expand\n+;; lock is cleared by a TAKEN branch.  This means that we cannot expand\n ;; a ll/sc sequence containing a branch (i.e. compare-and-swap) until after\n ;; the final basic-block reordering pass.\n "}, {"sha": "de2c8d5df9cfb35b4e0ff4bb0303928544b1349e", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -8477,7 +8477,7 @@ arc_reorg (void)\n         Brcc.d b, c, s9\n         Brcc.d b, u6, s9\n \n-        For cc={GT, LE, GTU, LEU}, u6=63 can not be allowed,\n+        For cc={GT, LE, GTU, LEU}, u6=63 cannot be allowed,\n       since they are encoded by the assembler as {GE, LT, HS, LS} 64, which\n       does not have a delay slot\n "}, {"sha": "72fbf2a85288f761ac6f96111819c3fb95474b22", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -696,7 +696,7 @@\n        (match_test \"REGNO (op) == (TARGET_BIG_ENDIAN ? 59 : 58)\")\n        (match_test \"TARGET_V2\")))\n \n-; Unfortunately, we can not allow a const_int_operand before reload, because\n+; Unfortunately, we cannot allow a const_int_operand before reload, because\n ; reload needs a non-void mode to guide it how to reload the inside of a\n ; {sign_}extend.\n (define_predicate \"extend_operand\""}, {"sha": "ab4a0ab9a2e276bf10e5988b508e2bb233575da1", "filename": "gcc/config/arm/arm-c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farm%2Farm-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farm%2Farm-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-c.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -28,7 +28,7 @@\n #include \"c-family/c-pragma.h\"\n #include \"stringpool.h\"\n \n-/* Output C specific EABI object attributes.  These can not be done in\n+/* Output C specific EABI object attributes.  These cannot be done in\n    arm.c because they require information from the C frontend.  */\n \n static void"}, {"sha": "839238057ce9abbaadf9fb4014fa1cbccc998f67", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2885,7 +2885,7 @@ arm_option_check_internal (struct gcc_options *opts)\n     error (\"iWMMXt unsupported under Thumb mode\");\n \n   if (TARGET_HARD_TP && TARGET_THUMB1_P (flags))\n-    error (\"can not use -mtp=cp15 with 16-bit Thumb\");\n+    error (\"cannot use -mtp=cp15 with 16-bit Thumb\");\n \n   if (TARGET_THUMB_P (flags) && TARGET_VXWORKS_RTP && flag_pic)\n     {\n@@ -12327,7 +12327,7 @@ neon_vdup_constant (rtx vals)\n /* Generate code to load VALS, which is a PARALLEL containing only\n    constants (for vec_init) or CONST_VECTOR, efficiently into a\n    register.  Returns an RTX to copy into the register, or NULL_RTX\n-   for a PARALLEL that can not be converted into a CONST_VECTOR.  */\n+   for a PARALLEL that cannot be converted into a CONST_VECTOR.  */\n \n rtx\n neon_make_constant (rtx vals)\n@@ -12369,13 +12369,13 @@ neon_make_constant (rtx vals)\n     return target;\n   else if (const_vec != NULL_RTX)\n     /* Load from constant pool.  On Cortex-A8 this takes two cycles\n-       (for either double or quad vectors).  We can not take advantage\n+       (for either double or quad vectors).  We cannot take advantage\n        of single-cycle VLD1 because we need a PC-relative addressing\n        mode.  */\n     return const_vec;\n   else\n     /* A PARALLEL containing something not valid inside CONST_VECTOR.\n-       We can not construct an initializer.  */\n+       We cannot construct an initializer.  */\n     return NULL_RTX;\n }\n \n@@ -16063,7 +16063,7 @@ add_minipool_forward_ref (Mfix *fix)\n   Mnode *       mp;\n \n   /* If the minipool starts before the end of FIX->INSN then this FIX\n-     can not be placed into the current pool.  Furthermore, adding the\n+     cannot be placed into the current pool.  Furthermore, adding the\n      new constant pool entry may cause the pool to start FIX_SIZE bytes\n      earlier.  */\n   if (minipool_vector_head &&"}, {"sha": "5cebabeaea7ec554a443bb7b79204cd98144c867", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1168,7 +1168,7 @@ enum reg_class\n    : GET_MODE_SIZE (MODE) >= 4 ? BASE_REGS\t\t\t\\\n    : LO_REGS)\n \n-/* For Thumb we can not support SP+reg addressing, so we return LO_REGS\n+/* For Thumb we cannot support SP+reg addressing, so we return LO_REGS\n    instead of BASE_REGS.  */\n #define MODE_BASE_REG_REG_CLASS(MODE) BASE_REG_CLASS\n \n@@ -1647,7 +1647,7 @@ enum arm_auto_incmodes\n    : ARM_REGNO_OK_FOR_BASE_P (REGNO))\n \n /* Nonzero if X can be the base register in a reg+reg addressing mode.\n-   For Thumb, we can not use SP + reg, so reject SP.  */\n+   For Thumb, we cannot use SP + reg, so reject SP.  */\n #define REGNO_MODE_OK_FOR_REG_BASE_P(X, MODE)\t\\\n   REGNO_MODE_OK_FOR_BASE_P (X, QImode)\n \n@@ -1823,7 +1823,7 @@ enum arm_auto_incmodes\n    : ARM_REG_OK_FOR_INDEX_P (X))\n \n /* Nonzero if X can be the base register in a reg+reg addressing mode.\n-   For Thumb, we can not use SP + reg, so reject SP.  */\n+   For Thumb, we cannot use SP + reg, so reject SP.  */\n #define REG_MODE_OK_FOR_REG_BASE_P(X, MODE)\t\\\n   REG_OK_FOR_INDEX_P (X)\n \f"}, {"sha": "aa759624f8f617576773aa75fd6239d6e06e8a13", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -287,7 +287,7 @@\n ; CLOB means that the condition codes are altered in an undefined manner, if\n ;   they are altered at all\n ;\n-; UNCONDITIONAL means the instruction can not be conditionally executed and\n+; UNCONDITIONAL means the instruction cannot be conditionally executed and\n ;   that the instruction does not use or alter the condition codes.\n ;\n ; NOCOND means that the instruction does not use or alter the condition\n@@ -7406,7 +7406,7 @@\n )\n \n ;; DImode comparisons.  The generic code generates branches that\n-;; if-conversion can not reduce to a conditional compare, so we do\n+;; if-conversion cannot reduce to a conditional compare, so we do\n ;; that directly.\n \n (define_insn_and_split \"*arm_cmpdi_insn\""}, {"sha": "1aac8317dd44c8bb3a47224db736678ff1278427", "filename": "gcc/config/arm/cortex-r4f.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farm%2Fcortex-r4f.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Farm%2Fcortex-r4f.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcortex-r4f.md?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -115,7 +115,7 @@\n \t\t  \"cortex_r4_fmacs\"\n \t\t  \"arm_no_early_mul_dep\")\n \n-;; Double precision operations.  These can not dual issue.\n+;; Double precision operations.  These cannot dual issue.\n \n (define_insn_reservation \"cortex_r4_fmacd\" 20\n  (and (eq_attr \"tune_cortexr4\" \"yes\")"}, {"sha": "8a3c9094a99b68e23f3bc0ccba575e86a1645e17", "filename": "gcc/config/csky/csky.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fcsky%2Fcsky.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fcsky%2Fcsky.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -967,7 +967,7 @@ add_csky_minipool_forward_ref (Mfix *fix)\n   Mnode *mp;\n \n   /* If the minipool starts before the end of FIX->INSN then this FIX\n-     can not be placed into the current pool.  Furthermore, adding the\n+     cannot be placed into the current pool.  Furthermore, adding the\n      new constant pool entry may cause the pool to start FIX_SIZE bytes\n      earlier.  */\n   if (minipool_vector_head"}, {"sha": "ea95290eae2c13a2cdef088795194dcfd52a388c", "filename": "gcc/config/csky/csky.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fcsky%2Fcsky.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fcsky%2Fcsky.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -923,7 +923,7 @@ extern const int csky_dbx_regno[];\n #define MOVE_MAX 4\n \n /* Shift counts are truncated to 6-bits (0 to 63) instead of the expected\n-   5-bits, so we can not define SHIFT_COUNT_TRUNCATED to true for this\n+   5-bits, so we cannot define SHIFT_COUNT_TRUNCATED to true for this\n    target.  */\n #define SHIFT_COUNT_TRUNCATED 0\n "}, {"sha": "69a9eea8a2558f810940956e5d824e659fd0621b", "filename": "gcc/config/darwin-f.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fdarwin-f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fdarwin-f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-f.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Provide stubs for the hooks defined by darwin.h\n      TARGET_EXTRA_PRE_INCLUDES, TARGET_EXTRA_INCLUDES\n \n-   As both, gcc and gfortran link in incpath.o, we can not\n+   As both, gcc and gfortran link in incpath.o, we cannot\n    conditionally undefine said hooks if fortran is build.\n    However, we can define do-nothing stubs of said hooks as\n    we are not interested in objc include files in Fortran."}, {"sha": "be9ea9ab5aa78bedf6978c918a9fb2c953fa7f9d", "filename": "gcc/config/epiphany/epiphany.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fepiphany%2Fepiphany.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fepiphany%2Fepiphany.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.md?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1039,7 +1039,7 @@\n ; use next_active_insn to look at the 'following' insn.  That should\n ; exist, because peephole2 runs after reload, and there has to be\n ; a return after an fp_int insn.\n-; ??? However, we can not even ordinarily match the preceding insn;\n+; ??? However, we cannot even ordinarily match the preceding insn;\n ; there is some bug in the generators such that then it leaves out\n ; the check for PARALLEL before the length check for the then-second\n ; main insn.  Observed when compiling compatibility-atomic-c++0x.cc"}, {"sha": "0e23eaaa79c80caa11a4ed266dd9249e57f829fc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -29759,13 +29759,13 @@ ix86_local_alignment (tree exp, machine_mode mode,\n      a C99 variable-length array variable always has alignment of at least 16 bytes.\n \n      This was added to allow use of aligned SSE instructions at arrays.  This\n-     rule is meant for static storage (where compiler can not do the analysis\n+     rule is meant for static storage (where compiler cannot do the analysis\n      by itself).  We follow it for automatic variables only when convenient.\n      We fully control everything in the function compiled and functions from\n-     other unit can not rely on the alignment.\n+     other unit cannot rely on the alignment.\n \n      Exclude va_list type.  It is the common case of local array where\n-     we can not benefit from the alignment.  \n+     we cannot benefit from the alignment.  \n \n      TODO: Probably one should optimize for size only when var is not escaping.  */\n   if (TARGET_64BIT && optimize_function_for_speed_p (cfun)"}, {"sha": "09e401cca20cb206cd21dfcf11fac1d5f866731f", "filename": "gcc/config/i386/sol2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fi386%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fi386%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsol2.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -26,7 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #undef STACK_REALIGN_DEFAULT\n #define STACK_REALIGN_DEFAULT (TARGET_64BIT ? 0 : 1)\n \n-/* Old versions of the Solaris assembler can not handle the difference of\n+/* Old versions of the Solaris assembler cannot handle the difference of\n    labels in different sections, so force DW_EH_PE_datarel if so.  */\n #ifndef HAVE_AS_IX86_DIFF_SECT_DELTA\n #undef ASM_PREFERRED_EH_DATA_FORMAT"}, {"sha": "bd389ea7284bc3156fd436633e09a900bbf50eee", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2541,7 +2541,7 @@ m68k_call_tls_get_addr (rtx x, rtx eqv, enum m68k_reloc reloc)\n      consider (plus (%a5) (const (unspec))) to be a good enough\n      operand for push, so it forces it into a register.  The bad\n      thing about this is that combiner, due to copy propagation and other\n-     optimizations, sometimes can not later fix this.  As a consequence,\n+     optimizations, sometimes cannot later fix this.  As a consequence,\n      additional register may be allocated resulting in a spill.\n      For reference, see args processing loops in\n      calls.c:emit_library_call_value_1."}, {"sha": "5830c8514c2e819b21e19021de61958c5b204b06", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -533,7 +533,7 @@ extern const enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define SLOW_BYTE_ACCESS TARGET_SLOW_BYTES\n \n /* Shift counts are truncated to 6-bits (0 to 63) instead of the expected\n-   5-bits, so we can not define SHIFT_COUNT_TRUNCATED to true for this\n+   5-bits, so we cannot define SHIFT_COUNT_TRUNCATED to true for this\n    target.  */\n #define SHIFT_COUNT_TRUNCATED 0\n "}, {"sha": "183afff37251e9e188d0fd826327c7ea9d28bce6", "filename": "gcc/config/microblaze/microblaze.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -124,29 +124,29 @@\n      DEFINE_AUTOMATON).\n \n      All define_reservations and define_cpu_units should have unique\n-     names which can not be \"nothing\".\n+     names which cannot be \"nothing\".\n \n    o (exclusion_set string string) means that each CPU function unit\n-     in the first string can not be reserved simultaneously with each\n+     in the first string cannot be reserved simultaneously with each\n      unit whose name is in the second string and vise versa.  CPU\n      units in the string are separated by commas. For example, it is\n      useful for description CPU with fully pipelined floating point\n      functional unit which can execute simultaneously only single\n      floating point insns or only double floating point insns.\n \n    o (presence_set string string) means that each CPU function unit in\n-     the first string can not be reserved unless at least one of units\n+     the first string cannot be reserved unless at least one of units\n      whose names are in the second string is reserved.  This is an\n      asymmetric relation.  CPU units in the string are separated by\n      commas.  For example, it is useful for description that slot1 is\n      reserved after slot0 reservation for a VLIW processor.\n \n    o (absence_set string string) means that each CPU function unit in\n-     the first string can not be reserved only if each unit whose name\n+     the first string cannot be reserved only if each unit whose name\n      is in the second string is not reserved.  This is an asymmetric\n      relation (actually exclusion set is analogous to this one but it\n      is symmetric).  CPU units in the string are separated by commas.\n-     For example, it is useful for description that slot0 can not be\n+     For example, it is useful for description that slot0 cannot be\n      reserved after slot1 or slot2 reservation for a VLIW processor.\n \n    o (define_bypass number out_insn_names in_insn_names) names bypass with\n@@ -169,7 +169,7 @@\n      case, you describe common part and use one its name (the 1st\n      parameter) in regular expression in define_insn_reservation.  All\n      define_reservations, define results and define_cpu_units should\n-     have unique names which can not be \"nothing\".\n+     have unique names which cannot be \"nothing\".\n \n    o (define_insn_reservation name default_latency condition regexpr)\n      describes reservation of cpu functional units (the 3nd operand)"}, {"sha": "d2fbce0c9682fbe12188434b3613eb04546bd11b", "filename": "gcc/config/mips/20kc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fmips%2F20kc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fmips%2F20kc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2F20kc.md?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -71,7 +71,7 @@\n (exclusion_set \"r20kc_fpu_add\" \"r20kc_fpu_mpy, r20kc_fpu_divsqrt\")\n (exclusion_set \"r20kc_fpu_mpy\" \"r20kc_fpu_divsqrt\")\n \n-;; After branch any insn can not be issued.\n+;; After branch any insn cannot be issued.\n (absence_set \"r20kc_iss0,r20kc_iss1\" \"r20kc_ixub_branch\")\n \n ;;"}, {"sha": "9e3cbe399f3e5b21a7c5fb13d9ec1de03ed9acb8", "filename": "gcc/config/mips/sb1.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fmips%2Fsb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fmips%2Fsb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsb1.md?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -127,7 +127,7 @@\n ;; register as destination.\n \n ;; ??? SB-1 can co-issue a load with a dependent arith insn if it executes on\n-;; an EX unit.  Can not co-issue if the dependent insn executes on an LS unit.\n+;; an EX unit.  Cannot co-issue if the dependent insn executes on an LS unit.\n ;; SB-1A can always co-issue here.\n \n ;; A load normally has a latency of zero cycles.  In some cases, dependent\n@@ -144,7 +144,7 @@\n        (eq_attr \"type\" \"load,prefetch\"))\n   \"sb1_ls0 | sb1_ls1\")\n \n-;; Can not co-issue fpload with fp exe when in 32-bit mode.\n+;; Cannot co-issue fpload with fp exe when in 32-bit mode.\n \n (define_insn_reservation \"ir_sb1_fpload\" 0\n   (and (eq_attr \"cpu\" \"sb1,sb1a\")\n@@ -252,7 +252,7 @@\n        (eq_attr \"type\" \"const,arith,logical,move,signext\"))\n   \"sb1_ls1 | sb1_ex1 | sb1_ex0\")\n \n-;; On SB-1A, simple alu instructions can not execute on the LS1 unit, and we\n+;; On SB-1A, simple alu instructions cannot execute on the LS1 unit, and we\n ;; have none of the above problems.\n \n (define_insn_reservation \"ir_sb1a_simple_alu\" 1"}, {"sha": "b4f4edee9d1a51ef2f491174a4839f972ce79d31", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1354,7 +1354,7 @@ nds32_emit_adjust_frame (rtx to_reg, rtx from_reg, int adjust_value)\n       frame_adjust_insn = emit_insn (frame_adjust_insn);\n \n       /* Because (tmp_reg <- full_value) may be split into two\n-\t rtl patterns, we can not set its RTX_FRAME_RELATED_P.\n+\t rtl patterns, we cannot set its RTX_FRAME_RELATED_P.\n \t We need to construct another (sp <- sp + full_value)\n \t and then insert it into sp_adjust_insn's reg note to\n \t represent a frame related expression.\n@@ -5352,7 +5352,7 @@ nds32_can_use_return_insn (void)\n   int sp_adjust;\n \n   /* Prior to reloading, we can't tell how many registers must be saved.\n-     Thus we can not determine whether this function has null epilogue.  */\n+     Thus we cannot determine whether this function has null epilogue.  */\n   if (!reload_completed)\n     return 0;\n "}, {"sha": "79ae8ea2a3430de23f6da2eafc8e7d45997dbfdc", "filename": "gcc/config/nds32/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fpredicates.md?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -114,7 +114,7 @@\n        (not (match_code \"high,const,symbol_ref,label_ref\")))\n {\n   /* If the constant op does NOT satisfy Is20 nor Ihig,\n-     we can not perform move behavior by a single instruction.  */\n+     we cannot perform move behavior by a single instruction.  */\n   if (CONST_INT_P (op)\n       && !satisfies_constraint_Is20 (op)\n       && !satisfies_constraint_Ihig (op))\n@@ -128,7 +128,7 @@\n        (not (match_code \"high,const,symbol_ref,label_ref\")))\n {\n   /* If the constant op does NOT satisfy Is20 nor Ihig,\n-     we can not perform move behavior by a single instruction.  */\n+     we cannot perform move behavior by a single instruction.  */\n   if (GET_CODE (op) == CONST_VECTOR\n       && !satisfies_constraint_CVs2 (op)\n       && !satisfies_constraint_CVhi (op))"}, {"sha": "5042683e38876aeae2ce878736c2cdf0a397f152", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -4013,7 +4013,7 @@ pa_expand_prologue (void)\n \t     the callee registers.  */\n \t  if (VAL_14_BITS_P (actual_fsize) && local_fsize == 0)\n \t    merge_sp_adjust_with_store = 1;\n-\t  /* Can not optimize.  Adjust the stack frame by actual_fsize\n+\t  /* Cannot optimize.  Adjust the stack frame by actual_fsize\n \t     bytes.  */\n \t  else\n \t    set_reg_plus_d (STACK_POINTER_REGNUM, STACK_POINTER_REGNUM,"}, {"sha": "6fee4d9c8c28ccb288688ec235eb58b6b7b110fe", "filename": "gcc/config/rs6000/e300c2c3.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Frs6000%2Fe300c2c3.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Frs6000%2Fe300c2c3.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fe300c2c3.md?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -22,7 +22,7 @@\n (define_cpu_unit \"ppce300c3_decode_0,ppce300c3_decode_1\" \"ppce300c3_most\")\n \n ;; We don't simulate general issue queue (GIC).  If we have SU insn\n-;; and then SU1 insn, they can not be issued on the same cycle\n+;; and then SU1 insn, they cannot be issued on the same cycle\n ;; (although SU1 insn and then SU insn can be issued) because the SU\n ;; insn will go to SU1 from GIC0 entry.  Fortunately, the first cycle\n ;; multipass insn scheduling will find the situation and issue the SU1\n@@ -31,7 +31,7 @@\n \n ;; We could describe completion buffers slots in combination with the\n ;; retirement units and the order of completion but the result\n-;; automaton would behave in the same way because we can not describe\n+;; automaton would behave in the same way because we cannot describe\n ;; real latency time with taking in order completion into account.\n ;; Actually we could define the real latency time by querying reserved\n ;; automaton units but the current scheduler uses latency time before"}, {"sha": "0357dc88e596edae6f1c97e1a4457b53ec11c564", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -8118,7 +8118,7 @@ legitimate_lo_sum_address_p (machine_mode mode, rtx x, int strict)\n \t recognizes some LO_SUM addresses as valid although this\n \t function says opposite.  In most cases, LRA through different\n \t transformations can generate correct code for address reloads.\n-\t It can not manage only some LO_SUM cases.  So we need to add\n+\t It cannot manage only some LO_SUM cases.  So we need to add\n \t code analogous to one in rs6000_legitimize_reload_address for\n \t LOW_SUM here saying that some addresses are still valid.  */\n       large_toc_ok = (lra_in_progress && TARGET_CMODEL != CMODEL_SMALL\n@@ -28983,7 +28983,7 @@ rs6000_output_function_epilogue (FILE *file)\n \t length fields that follow.  However, if you omit the optional\n \t fields, the assembler outputs zeros for all optional fields\n \t anyways, giving each variable length field is minimum length\n-\t (as defined in sys/debug.h).  Thus we can not use the .tbtab\n+\t (as defined in sys/debug.h).  Thus we cannot use the .tbtab\n \t pseudo-op at all.  */\n \n       /* An all-zero word flags the start of the tbtab, for debuggers"}, {"sha": "3ea7c3801f5f16348196797b6202e8720758ab55", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1047,7 +1047,7 @@ extern const struct s390_processor processor_table[];\n \n /* Target pragma.  */\n \n-/* resolve_overloaded_builtin can not be defined the normal way since\n+/* resolve_overloaded_builtin cannot be defined the normal way since\n    it is defined in code which technically belongs to the\n    front-end.  */\n #define REGISTER_TARGET_PRAGMAS()\t\t\\"}, {"sha": "fcb7cffc2cfc1d963d82c3f6717913fcb69a7494", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -921,7 +921,7 @@ sh_option_override (void)\n \t to the pressure on R0.  */\n       /* Enable sched1 for SH4 if the user explicitly requests.\n \t When sched1 is enabled, the ready queue will be reordered by\n-\t the target hooks if pressure is high.  We can not do this for\n+\t the target hooks if pressure is high.  We cannot do this for\n \t PIC, SH3 and lower as they give spill failures for R0.  */\n       if (!TARGET_HARD_SH4 || flag_pic)\n \tflag_schedule_insns = 0;"}, {"sha": "83543778619ee0f3a275290d4ea9e8d2439d3f85", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -7170,7 +7170,7 @@\n })\n \n ;; The use of operand 1 / 2 helps us distinguish case table jumps\n-;; which can be present in structured code from indirect jumps which can not\n+;; which can be present in structured code from indirect jumps which cannot\n ;; be present in structured code.  This allows -fprofile-arcs to work.\n \n ;; For SH1 processors."}, {"sha": "75ab5949bf0e1bd2fdcdba09cae54e7c0c705c90", "filename": "gcc/config/spu/vmx2spu.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fspu%2Fvmx2spu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fconfig%2Fspu%2Fvmx2spu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fvmx2spu.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2302,7 +2302,7 @@ static inline vec_int4 vec_unpackh(vec_short8 a)\n \n #ifdef SUPPORT_UNPACK_PIXEL\n /* Due to type conflicts, unpacking of pixel types and boolean shorts\n- * can not simultaneously be supported. By default, the boolean short is\n+ * cannot simultaneously be supported. By default, the boolean short is\n  * supported.\n  */\n static inline vec_uint4 vec_unpackh(vec_pixel8 a)\n@@ -2356,7 +2356,7 @@ static inline vec_int4 vec_unpackl(vec_short8 a)\n \n #ifdef SUPPORT_UNPACK_PIXEL\n /* Due to type conflicts, unpacking of pixel types and boolean shorts\n- * can not simultaneously be supported. By default, the boolean short is\n+ * cannot simultaneously be supported. By default, the boolean short is\n  * supported.\n  */\n static inline vec_uint4 vec_unpackl(vec_pixel8 a)"}, {"sha": "b3ee2a5db2fbdae25196641dbbb6ec81880cb29e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,11 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* cp-tree.h: Mechanically replace \"can not\" with \"cannot\".\n+\t* parser.c: Likewise.\n+\t* pt.c: Likewise.\n+\n 2019-01-08  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* decl.c (grok_reference_init): Improve error location."}, {"sha": "56489465c0c295452dfb53bef4e84ec6b70f638a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -4229,7 +4229,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define IMPLICIT_CONV_EXPR_NONTYPE_ARG(NODE) \\\n   (TREE_LANG_FLAG_1 (IMPLICIT_CONV_EXPR_CHECK (NODE)))\n \n-/* Nonzero means that an object of this type can not be initialized using\n+/* Nonzero means that an object of this type cannot be initialized using\n    an initializer list.  */\n #define CLASSTYPE_NON_AGGREGATE(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->non_aggregate)"}, {"sha": "be669f2f321422c0f36503bf55dedbe98faef3ef", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1646,7 +1646,7 @@ declarator_can_be_parameter_pack (cp_declarator *declarator)\n \n   /* Search for a declarator name, or any other declarator that goes\n      after the point where the ellipsis could appear in a parameter\n-     pack. If we find any of these, then this declarator can not be\n+     pack. If we find any of these, then this declarator cannot be\n      made into a parameter pack.  */\n   bool found = false;\n   while (declarator && !found)"}, {"sha": "84f59a2c3561b056309020641605f43daeeb490d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1925,7 +1925,7 @@ explicit_class_specialization_p (tree type)\n }\n \n /* Print the list of functions at FNS, going through all the overloads\n-   for each element of the list.  Alternatively, FNS can not be a\n+   for each element of the list.  Alternatively, FNS cannot be a\n    TREE_LIST, in which case it will be printed together with all the\n    overloads.\n \n@@ -22065,7 +22065,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n       /* If the argument deduction results is a METHOD_TYPE,\n          then there is a problem.\n          METHOD_TYPE doesn't map to any real C++ type the result of\n-\t the deduction can not be of that type.  */\n+\t the deduction cannot be of that type.  */\n       if (TREE_CODE (arg) == METHOD_TYPE)\n \treturn unify_method_type_error (explain_p, arg);\n "}, {"sha": "65c0130cc07a1327ccae43a718d82485c4bd28b8", "filename": "gcc/cprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -839,7 +839,7 @@ find_avail_set (int regno, rtx_insn *insn, struct cprop_expr *set_ret[2])\n        (set (reg X) (reg Y))\n        (set (reg Y) (reg X))\n \n-     This can not happen since the set of (reg Y) would have killed the\n+     This cannot happen since the set of (reg Y) would have killed the\n      set of (reg X) making it unavailable at the start of this block.  */\n   while (1)\n     {"}, {"sha": "81577dfe5cd36335506aa6856ce1b4e1f6762168", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2817,7 +2817,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n                 /* Do not generate a tag for incomplete records.  */\n                 && COMPLETE_TYPE_P (type)\n \t\t/* Do not generate a tag for records of variable size,\n-\t\t   since this type can not be properly described in the\n+\t\t   since this type cannot be properly described in the\n \t\t   DBX format, and it confuses some tools such as objdump.  */\n \t\t&& tree_fits_uhwi_p (TYPE_SIZE (type)))\n \t      {"}, {"sha": "644d01e0b87d59921c9ea5496c94940cc163b1b9", "filename": "gcc/df-scan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2982,7 +2982,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t   scanned and regs_asm_clobbered is filled out.\n \n \t   For all ASM_OPERANDS, we must traverse the vector of input\n-\t   operands.  We can not just fall through here since then we\n+\t   operands.  We cannot just fall through here since then we\n \t   would be confused by the ASM_INPUT rtx inside ASM_OPERANDS,\n \t   which do not indicate traditional asms unlike their normal\n \t   usage.  */"}, {"sha": "ee1a1c62d58eaa25684521e625033178182673b3", "filename": "gcc/doc/cfg.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Fcfg.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Fcfg.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcfg.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -32,7 +32,7 @@ passes pipeline, and even from @code{GIMPLE} to @code{RTL}.\n \n Often the CFG may be better viewed as integral part of instruction\n chain, than structure built on the top of it.  Updating the compiler's\n-intermediate representation for instructions can not be easily done\n+intermediate representation for instructions cannot be easily done\n without proper maintenance of the CFG simultaneously.\n \n @menu"}, {"sha": "f0130571d580434ab99c28e37980ef88eefe8958", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -10054,7 +10054,7 @@ register.\n \n @subsubheading Declaring the variable\n \n-Global register variables can not have initial values, because an\n+Global register variables cannot have initial values, because an\n executable file has no means to supply initial contents for a register.\n \n When selecting a register, choose one that is normally saved and "}, {"sha": "299adef4a7bb0e482feb245c270eeb6c473fb6bd", "filename": "gcc/doc/fragments.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Ffragments.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Ffragments.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ffragments.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -63,7 +63,7 @@ in @code{EXTRA-PARTS}.\n @findex MULTILIB_OPTIONS\n @item MULTILIB_OPTIONS\n For some targets, invoking GCC in different ways produces objects\n-that can not be linked together.  For example, for some targets GCC\n+that cannot be linked together.  For example, for some targets GCC\n produces both big and little endian code.  For these targets, you must\n arrange for multiple versions of @file{libgcc.a} to be compiled, one for\n each set of incompatible options.  When GCC invokes the linker, it"}, {"sha": "4f3cd4f9ed7c8f0f5bd80f60793b7ba2d6d37150", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -362,7 +362,7 @@ referenced.  But the memory that the pointer points to is an array of\n find pointers to mark or relocate, which is why it is marked with the\n @code{atomic} option.\n \n-Note that, currently, global variables can not be marked with\n+Note that, currently, global variables cannot be marked with\n @code{atomic}; only fields of a struct can.  This is a known\n limitation.  It would be useful to be able to mark global pointers\n with @code{atomic} to make the PCH machinery aware of them so that"}, {"sha": "abfb1d19ed16e9ddbc0572a5592a36ebd75b3342", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -13064,7 +13064,7 @@ most of benefits of whole program optimizations are however lost.\n During the incremental link (by @option{-r}) the linker plugin will default to\n @option{rel}. With current interfaces to GNU Binutils it is however not\n possible to link incrementally LTO objects and non-LTO objects into a single\n-mixed object file.  In the case any of object files in incremental link can not\n+mixed object file.  In the case any of object files in incremental link cannot\n be used for link-time optimization the linker plugin will output warning and\n use @samp{nolto-rel}. To maintain the whole program optimization it is\n recommended to link such objects into static library instead. Alternatively it\n@@ -25771,7 +25771,7 @@ if this option were not present.\n @item -mfixed-range=@var{register-range}\n @opindex mfixed-range\n Generate code treating the given register range as fixed registers.\n-A fixed register is one that the register allocator can not use.  This is\n+A fixed register is one that the register allocator cannot use.  This is\n useful when compiling kernel code.  A register range is specified as\n two registers separated by a dash.  Multiple register ranges can be\n specified separated by a comma.\n@@ -28463,7 +28463,7 @@ Note that @option{-mcmodel=large} is incompatible with\n not be reachable in the large code model.\n \n Note that @option{-mindirect-branch=thunk-extern} is incompatible with\n-@option{-fcf-protection=branch} since the external thunk can not be modified\n+@option{-fcf-protection=branch} since the external thunk cannot be modified\n to disable control-flow check.\n \n @item -mfunction-return=@var{choice}"}, {"sha": "771e8278e504990f9bb2793786d3689eec248f5c", "filename": "gcc/doc/lto.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Flto.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Flto.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Flto.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -353,7 +353,7 @@ To simplify development, the GCC pass manager differentiates\n between normal inter-procedural passes and small inter-procedural\n passes.  A @emph{small inter-procedural pass}\n (@code{SIMPLE_IPA_PASS}) is a pass that does\n-everything at once and thus it can not be executed during WPA in\n+everything at once and thus it cannot be executed during WPA in\n WHOPR mode.  It defines only the @emph{Execute} stage and during\n this stage it accesses and modifies the function bodies.  Such\n passes are useful for optimization at LGEN or LTRANS time and are"}, {"sha": "18b8af0d95625439197d7fbd30ea407dfbe1cd2d", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -4583,7 +4583,7 @@ The syntax and semantics are otherwise identical to\n \n @deffn {MD Expression} define_special_memory_constraint name docstring exp\n Use this expression for constraints that match a subset of all memory\n-operands: that is, @code{reload} can not make them match by reloading\n+operands: that is, @code{reload} cannot make them match by reloading\n the address as it is described for @code{define_memory_constraint} or\n such address reload is undesirable with the performance point of view.\n \n@@ -6213,8 +6213,8 @@ in a way that the blocks are not required to be aligned according to it in\n all cases. This expected alignment is also in bytes, just like operand 4.\n Expected size, when unknown, is set to @code{(const_int -1)}.\n Operand 7 is the minimal size of the block and operand 8 is the\n-maximal size of the block (NULL if it can not be represented as CONST_INT).\n-Operand 9 is the probable maximal size (i.e.@: we can not rely on it for\n+maximal size of the block (NULL if it cannot be represented as CONST_INT).\n+Operand 9 is the probable maximal size (i.e.@: we cannot rely on it for\n correctness, but it can be used for choosing proper code sequence for a\n given size).\n \n@@ -9901,7 +9901,7 @@ the common part by the following construction\n @var{reservation-name} is a string giving name of @var{regexp}.\n Functional unit names and reservation names are in the same name\n space.  So the reservation names should be different from the\n-functional unit names and can not be the reserved name @samp{nothing}.\n+functional unit names and cannot be the reserved name @samp{nothing}.\n \n @findex define_bypass\n @cindex instruction latency time\n@@ -9967,15 +9967,15 @@ separated by comma.  Currently pattern is one unit or units\n separated by white-spaces.\n \n The first construction (@samp{exclusion_set}) means that each\n-functional unit in the first string can not be reserved simultaneously\n+functional unit in the first string cannot be reserved simultaneously\n with a unit whose name is in the second string and vice versa.  For\n example, the construction is useful for describing processors\n (e.g.@: some SPARC processors) with a fully pipelined floating point\n functional unit which can execute simultaneously only single floating\n point insns or only double floating point insns.\n \n The second construction (@samp{presence_set}) means that each\n-functional unit in the first string can not be reserved unless at\n+functional unit in the first string cannot be reserved unless at\n least one of pattern of units whose names are in the second string is\n reserved.  This is an asymmetric relation.  For example, it is useful\n for description that @acronym{VLIW} @samp{slot1} is reserved after\n@@ -10030,7 +10030,7 @@ can be described as:\n (absence_set \"slot0\" \"slot1, slot2\")\n @end smallexample\n \n-Or @samp{slot2} can not be reserved if @samp{slot0} and unit @samp{b0}\n+Or @samp{slot2} cannot be reserved if @samp{slot0} and unit @samp{b0}\n are reserved or @samp{slot1} and unit @samp{b1} are reserved.  In\n this case we could write\n \n@@ -10133,7 +10133,7 @@ are issued into the second pipeline.  Integer division and\n multiplication insns can be executed only in the second integer\n pipeline and their results are ready correspondingly in 9 and 4\n cycles.  The integer division is not pipelined, i.e.@: the subsequent\n-integer division insn can not be issued until the current division\n+integer division insn cannot be issued until the current division\n insn finished.  Floating point insns are fully pipelined and their\n results are ready in 3 cycles.  Where the result of a floating point\n insn is used by an integer insn, an additional delay of one cycle is"}, {"sha": "29039eaeb5a6fe9b316623fea9fb486783d529c9", "filename": "gcc/doc/objc.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Fobjc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Fobjc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fobjc.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1165,7 +1165,7 @@ in dynamically registering the method.\n To configure the hook, you set the global variable\n @code{__objc_msg_forward2} to a function with the same argument and\n return types of @code{objc_msg_lookup()}.  When\n-@code{objc_msg_lookup()} can not find a method implementation, it\n+@code{objc_msg_lookup()} cannot find a method implementation, it\n invokes the hook function you provided to get a method implementation\n to return.  So, in practice @code{__objc_msg_forward2} allows you to\n extend @code{objc_msg_lookup()} by adding some custom code that is"}, {"sha": "f5f2de7568360bfc4bcc2948fa7feb6caa2afdca", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2897,7 +2897,7 @@ in the @code{insv} or @code{extv} pattern.\n The mode @var{m} is the same as the mode that would be used for\n @var{loc} if it were a register.\n \n-A @code{sign_extract} can not appear as an lvalue, or part thereof,\n+A @code{sign_extract} cannot appear as an lvalue, or part thereof,\n in RTL.\n \n @findex zero_extract\n@@ -3157,7 +3157,7 @@ given the value @var{x} and the rest of the register is not changed.\n If @var{lval} is a @code{zero_extract}, then the referenced part of\n the bit-field (a memory or register reference) specified by the\n @code{zero_extract} is given the value @var{x} and the rest of the\n-bit-field is not changed.  Note that @code{sign_extract} can not\n+bit-field is not changed.  Note that @code{sign_extract} cannot\n appear in @var{lval}.\n \n If @var{lval} is @code{(cc0)}, it has no machine mode, and @var{x} may"}, {"sha": "ddde4a7287b8185b7b40c9351950c6d721a1086f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -4960,7 +4960,7 @@ or @code{NULL} if this is an indirect call.\n It is not uncommon for limitations of calling conventions to prevent\n tail calls to functions outside the current unit of translation, or\n during PIC compilation.  The hook is used to enforce these restrictions,\n-as the @code{sibcall} md pattern can not fail, or fall over to a\n+as the @code{sibcall} md pattern cannot fail, or fall over to a\n ``normal'' call.  The criteria for successful sibling call optimization\n may vary greatly between different architectures.\n @end deftypefn"}, {"sha": "389c52d42842b30979b107ca22016454b390cc83", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2587,7 +2587,7 @@ remove_useless_values (cselib_val *base)\n       bool del = false;\n \n       /* If ANY of the store_infos match the cselib group that is\n-\t being deleted, then the insn can not be deleted.  */\n+\t being deleted, then the insn cannot be deleted.  */\n       while (store_info)\n \t{\n \t  if ((store_info->group_id == -1)"}, {"sha": "4b0aa7cee061a7778eeb760e561f3649ab735ead", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1781,7 +1781,7 @@ operand_subword_force (rtx op, poly_uint64 offset, machine_mode mode)\n \n   if (mode != BLKmode && mode != VOIDmode)\n     {\n-      /* If this is a register which can not be accessed by words, copy it\n+      /* If this is a register which cannot be accessed by words, copy it\n \t to a pseudo register.  */\n       if (REG_P (op))\n \top = copy_to_reg (op);"}, {"sha": "edf66b57419c7fb0abd146b1ece7595286ce1113", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -245,7 +245,7 @@ struct GTY(()) rtl_data {\n   /* True if dbr_schedule has already been called for this function.  */\n   bool dbr_scheduled_p;\n \n-  /* True if current function can not throw.  Unlike\n+  /* True if current function cannot throw.  Unlike\n      TREE_NOTHROW (current_function_decl) it is set even for overwritable\n      function where currently compiled version of it is nothrow.  */\n   bool nothrow;"}, {"sha": "10fef2f35445c9c179ed6c62bda9c27386740b55", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1159,7 +1159,7 @@ sjlj_emit_function_enter (rtx_code_label *dispatch_label)\n \n   /* We're storing this libcall's address into memory instead of\n      calling it directly.  Thus, we must call assemble_external_libcall\n-     here, as we can not depend on emit_library_call to do it for us.  */\n+     here, as we cannot depend on emit_library_call to do it for us.  */\n   assemble_external_libcall (personality);\n   mem = adjust_address (fc, Pmode, sjlj_fc_personality_ofs);\n   emit_move_insn (mem, personality);"}, {"sha": "b7f55a7e73b560e47fa7c6739e02b0a71246ea58", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -3876,7 +3876,7 @@ expmed_mult_highpart_optab (scalar_int_mode mode, rtx op0, rtx op1,\n \n /* Emit code to multiply OP0 and OP1 (where OP1 is an integer constant),\n    putting the high half of the result in TARGET if that is convenient,\n-   and return where the result is.  If the operation can not be performed,\n+   and return where the result is.  If the operation cannot be performed,\n    0 is returned.\n \n    MODE is the mode of operation and result."}, {"sha": "6ccba9d53ad118dffbaa2bae81bf11d90d090dfc", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1550,7 +1550,7 @@ compare_by_pieces (rtx arg0, rtx arg1, unsigned HOST_WIDE_INT len,\n    ALIGN is the maximum alignment we can assume they have.\n    METHOD describes what kind of copy this is, and what mechanisms may be used.\n    MIN_SIZE is the minimal size of block to move\n-   MAX_SIZE is the maximal size of block to move, if it can not be represented\n+   MAX_SIZE is the maximal size of block to move, if it cannot be represented\n    in unsigned HOST_WIDE_INT, than it is mask of all ones.\n \n    Return the address of the new block, if memcpy is called and returns it,\n@@ -1789,7 +1789,7 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n \t  if (nops >= 8)\n \t    {\n \t      create_integer_operand (&ops[6], min_size);\n-\t      /* If we can not represent the maximal size,\n+\t      /* If we cannot represent the maximal size,\n \t\t make parameter NULL.  */\n \t      if ((HOST_WIDE_INT) max_size != -1)\n \t        create_integer_operand (&ops[7], max_size);\n@@ -1798,7 +1798,7 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n \t    }\n \t  if (nops == 9)\n \t    {\n-\t      /* If we can not represent the maximal size,\n+\t      /* If we cannot represent the maximal size,\n \t\t make parameter NULL.  */\n \t      if ((HOST_WIDE_INT) probable_max_size != -1)\n \t        create_integer_operand (&ops[8], probable_max_size);\n@@ -3144,7 +3144,7 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \t  if (nops >= 8)\n \t    {\n \t      create_integer_operand (&ops[6], min_size);\n-\t      /* If we can not represent the maximal size,\n+\t      /* If we cannot represent the maximal size,\n \t\t make parameter NULL.  */\n \t      if ((HOST_WIDE_INT) max_size != -1)\n \t        create_integer_operand (&ops[7], max_size);\n@@ -3153,7 +3153,7 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \t    }\n \t  if (nops == 9)\n \t    {\n-\t      /* If we can not represent the maximal size,\n+\t      /* If we cannot represent the maximal size,\n \t\t make parameter NULL.  */\n \t      if ((HOST_WIDE_INT) probable_max_size != -1)\n \t        create_integer_operand (&ops[8], probable_max_size);"}, {"sha": "640a6ece44e6ca88ae985e55d0e2ffbca67d0853", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -735,7 +735,7 @@ fold_negate_expr (location_t loc, tree t)\n   return fold_convert_loc (loc, type, tem);\n }\n \n-/* Like fold_negate_expr, but return a NEGATE_EXPR tree, if T can not be\n+/* Like fold_negate_expr, but return a NEGATE_EXPR tree, if T cannot be\n    negated in a simpler way.  Also allow for T to be NULL_TREE, in which case\n    return NULL_TREE. */\n \n@@ -8419,7 +8419,7 @@ maybe_canonicalize_comparison (location_t loc, enum tree_code code, tree type,\n \n /* Return whether BASE + OFFSET + BITPOS may wrap around the address\n    space.  This is used to avoid issuing overflow warnings for\n-   expressions like &p->x which can not wrap.  */\n+   expressions like &p->x which cannot wrap.  */\n \n static bool\n pointer_may_wrap_p (tree base, tree offset, poly_int64 bitpos)"}, {"sha": "8e81904ed86d0a771effa8e7d995f750d8c136f0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,24 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* class.c: Mechanically replace \"can not\" with \"cannot\".\n+\t* decl.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* gfc-internals.texi: Likewise.\n+\t* intrinsic.texi: Likewise.\n+\t* invoke.texi: Likewise.\n+\t* io.c: Likewise.\n+\t* match.c: Likewise.\n+\t* parse.c: Likewise.\n+\t* primary.c: Likewise.\n+\t* resolve.c: Likewise.\n+\t* symbol.c: Likewise.\n+\t* trans-array.c: Likewise.\n+\t* trans-decl.c: Likewise.\n+\t* trans-intrinsic.c: Likewise.\n+\t* trans-stmt.c: Likewise.\n+\n 2019-01-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/68426"}, {"sha": "6c6139b96f530b09a6a6e30be7f215558c7dc587", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -630,7 +630,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n \t\t   || attr->select_type_temporary || attr->associate_var;\n \n   if (!attr->class_ok)\n-    /* We can not build the class container yet.  */\n+    /* We cannot build the class container yet.  */\n     return true;\n \n   /* Determine the name of the encapsulating type.  */"}, {"sha": "460c45db5dde566c8c888d7363538542f90a91a0", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2440,7 +2440,7 @@ variable_decl (int elem)\n \n   /* At this point, we know for sure if the symbol is PARAMETER and can thus\n      determine (and check) whether it can be implied-shape.  If it\n-     was parsed as assumed-size, change it because PARAMETERs can not\n+     was parsed as assumed-size, change it because PARAMETERs cannot\n      be assumed-size.\n \n      An explicit-shape-array cannot appear under several conditions.\n@@ -5673,7 +5673,7 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n \t  retval = false;\n \t}\n \n-      /* Scalar variables that are bind(c) can not have the pointer\n+      /* Scalar variables that are bind(c) cannot have the pointer\n \t or allocatable attributes.  */\n       if (tmp_sym->attr.is_bind_c == 1)\n \t{\n@@ -5702,7 +5702,7 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n \tgfc_error (\"Return type of BIND(C) function %qs at %L cannot \"\n \t\t   \"be an array\", tmp_sym->name, &(tmp_sym->declared_at));\n \n-      /* BIND(C) functions can not return a character string.  */\n+      /* BIND(C) functions cannot return a character string.  */\n       if (bind_c_function && tmp_sym->ts.type == BT_CHARACTER)\n \tif (tmp_sym->ts.u.cl == NULL || tmp_sym->ts.u.cl->length == NULL\n \t    || tmp_sym->ts.u.cl->length->expr_type != EXPR_CONSTANT"}, {"sha": "bc318f757aa2199b89a886465970f71f47d77a8a", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2050,7 +2050,7 @@ scalarize_intrinsic_call (gfc_expr *, bool init_flag);\n      1   Simplifying array constructors -- will substitute\n \t iterator values.\n    Returns false on error, true otherwise.\n-   NOTE: Will return true even if the expression can not be simplified.  */\n+   NOTE: Will return true even if the expression cannot be simplified.  */\n \n bool\n gfc_simplify_expr (gfc_expr *p, int type)\n@@ -5981,15 +5981,15 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       if (pointer && is_pointer)\n \t{\n \t  if (context)\n-\t    gfc_error (\"Variable %qs is PROTECTED and can not appear in a\"\n+\t    gfc_error (\"Variable %qs is PROTECTED and cannot appear in a\"\n \t\t       \" pointer association context (%s) at %L\",\n \t\t       sym->name, context, &e->where);\n \t  return false;\n \t}\n       if (!pointer && !is_pointer)\n \t{\n \t  if (context)\n-\t    gfc_error (\"Variable %qs is PROTECTED and can not appear in a\"\n+\t    gfc_error (\"Variable %qs is PROTECTED and cannot appear in a\"\n \t\t       \" variable definition context (%s) at %L\",\n \t\t       sym->name, context, &e->where);\n \t  return false;\n@@ -6001,7 +6001,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n   if (!pointer && !own_scope && gfc_pure (NULL) && gfc_impure_variable (sym))\n     {\n       if (context)\n-\tgfc_error (\"Variable %qs can not appear in a variable definition\"\n+\tgfc_error (\"Variable %qs cannot appear in a variable definition\"\n \t\t   \" context (%s) at %L in PURE procedure\",\n \t\t   sym->name, context, &e->where);\n       return false;\n@@ -6075,9 +6075,9 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       if (!gfc_check_vardef_context (assoc->target, pointer, false, false, NULL))\n \t{\n \t  if (context)\n-\t    gfc_error (\"Associate-name %qs can not appear in a variable\"\n+\t    gfc_error (\"Associate-name %qs cannot appear in a variable\"\n \t\t       \" definition context (%s) at %L because its target\"\n-\t\t       \" at %L can not, either\",\n+\t\t       \" at %L cannot, either\",\n \t\t       name, context, &e->where,\n \t\t       &assoc->target->where);\n \t  return false;"}, {"sha": "d65d5deded3e758147add63e0621adbc02469aaa", "filename": "gcc/fortran/gfc-internals.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fgfc-internals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fgfc-internals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfc-internals.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -715,7 +715,7 @@ array member @code{tb_op} indexed by the intrinsic operator's enum\n value.  Those need not be packed into @code{gfc_symtree} structures and are\n only @code{gfc_typebound_proc} instances.\n \n-When an operator call or assignment is found that can not be handled in\n+When an operator call or assignment is found that cannot be handled in\n another way (i.e. neither matches an intrinsic nor interface operator\n definition) but that contains a derived-type expression, all type-bound\n operators defined on that derived-type are checked for a match with"}, {"sha": "941c2e3937443f99821146d2f7e1281672c8f6fc", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -6762,7 +6762,7 @@ kind.\n \n @item @emph{Return value}:\n After @code{GETARG} returns, the @var{VALUE} argument holds the\n-@var{POS}th command line argument. If @var{VALUE} can not hold the\n+@var{POS}th command line argument. If @var{VALUE} cannot hold the\n argument, it is truncated to fit the length of @var{VALUE}. If there are\n less than @var{POS} arguments specified at the command line, @var{VALUE}\n will be filled with blanks. If @math{@var{POS} = 0}, @var{VALUE} is set\n@@ -6875,7 +6875,7 @@ and of default kind.\n \n @item @emph{Return value}:\n After @code{GET_COMMAND_ARGUMENT} returns, the @var{VALUE} argument holds the \n-@var{NUMBER}-th command line argument. If @var{VALUE} can not hold the argument, it is \n+@var{NUMBER}-th command line argument. If @var{VALUE} cannot hold the argument, it is \n truncated to fit the length of @var{VALUE}. If there are less than @var{NUMBER}\n arguments specified at the command line, @var{VALUE} will be filled with blanks. \n If @math{@var{NUMBER} = 0}, @var{VALUE} is set to the name of the program (on"}, {"sha": "668e8d9bc7295959b7bc518958c047a06af89042", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1112,7 +1112,7 @@ time.  This option is implied by @option{-Wall}.\n @item -Wdo-subscript\n @opindex @code{Wdo-subscript}\n Warn if an array subscript inside a DO loop could lead to an\n-out-of-bounds access even if the compiler can not prove that the\n+out-of-bounds access even if the compiler cannot prove that the\n statement is actually executed, in cases like\n @smallexample\n   real a(3)"}, {"sha": "4ea37a331ca93386e0ed254a5a9b7998203271a5", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -4619,7 +4619,7 @@ gfc_match_inquire (void)\n       && ((mpz_get_si (inquire->unit->value.integer) == GFC_INTERNAL_UNIT4)\n       || (mpz_get_si (inquire->unit->value.integer) == GFC_INTERNAL_UNIT)))\n     {\n-      gfc_error (\"UNIT number in INQUIRE statement at %L can not \"\n+      gfc_error (\"UNIT number in INQUIRE statement at %L cannot \"\n \t\t \"be %d\", &loc, (int) mpz_get_si (inquire->unit->value.integer));\n       goto cleanup;\n     }"}, {"sha": "9ff1c35b2a0a84474cefdce111ee425be17fb0e2", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -5144,7 +5144,7 @@ gfc_match_common (void)\n                 }\n \n               if (sym->attr.is_bind_c == 1)\n-                gfc_error_now (\"Variable %qs in common block %qs at %C can not \"\n+                gfc_error_now (\"Variable %qs in common block %qs at %C cannot \"\n                                \"be bind(c) since it is not global\", sym->name,\n \t\t\t       t->name);\n             }"}, {"sha": "5dcd91af6cf18f21eb24af51c01f715766b80afe", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -3746,7 +3746,7 @@ parse_spec (gfc_statement st)\n \t  break;\n       }\n \n-  /* If we find a statement that can not be followed by an IMPLICIT statement\n+  /* If we find a statement that cannot be followed by an IMPLICIT statement\n      (and thus we can expect to see none any further), type the function result\n      if it has not yet been typed.  Be careful not to give the END statement\n      to verify_st_order!  */\n@@ -4543,7 +4543,7 @@ parse_associate (void)\n \t in case of association to a derived-type.  */\n       sym->ts = a->target->ts;\n \n-      /* Check if the target expression is array valued.  This can not always\n+      /* Check if the target expression is array valued.  This cannot always\n \t be done by looking at target.rank, because that might not have been\n \t set yet.  Therefore traverse the chain of refs, looking for the last\n \t array ref and evaluate that.  */"}, {"sha": "fa764dcdab11c416e6dea7bd71f3e4d1c9bde163", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1570,7 +1570,7 @@ match_actual_arg (gfc_expr **result)\n \t  gfc_set_sym_referenced (sym);\n \t  if (sym->attr.flavor == FL_NAMELIST)\n \t    {\n-\t      gfc_error (\"Namelist %qs can not be an argument at %L\",\n+\t      gfc_error (\"Namelist %qs cannot be an argument at %L\",\n \t      sym->name, &where);\n \t      break;\n \t    }\n@@ -3598,7 +3598,7 @@ gfc_match_rvalue (gfc_expr **result)\n       /* F08:C612.  */\n       if (gfc_peek_ascii_char() == '%')\n \t{\n-\t  gfc_error (\"The leftmost part-ref in a data-ref can not be a \"\n+\t  gfc_error (\"The leftmost part-ref in a data-ref cannot be a \"\n \t\t     \"function reference at %C\");\n \t  m = MATCH_ERROR;\n \t}"}, {"sha": "a681ecaf2497dc12d6421a93823ef8b5f2d306d0", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1089,7 +1089,7 @@ resolve_common_blocks (gfc_symtree *common_root)\n \t       sym->name, &common_root->n.common->where, &sym->declared_at);\n \n   if (sym->attr.external)\n-    gfc_error (\"COMMON block %qs at %L can not have the EXTERNAL attribute\",\n+    gfc_error (\"COMMON block %qs at %L cannot have the EXTERNAL attribute\",\n \t       sym->name, &common_root->n.common->where);\n \n   if (sym->attr.intrinsic)\n@@ -9319,7 +9319,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \tdefault_case->next = if_st;\n     }\n \n-  /* Resolve the internal code.  This can not be done earlier because\n+  /* Resolve the internal code.  This cannot be done earlier because\n      it requires that the sym->assoc of selectors is set already.  */\n   gfc_current_ns = ns;\n   gfc_resolve_blocks (code->block, gfc_current_ns);\n@@ -9453,7 +9453,7 @@ resolve_transfer (gfc_code *code)\n \t  return;\n \t}\n \n-      /* C_PTR and C_FUNPTR have private components which means they can not\n+      /* C_PTR and C_FUNPTR have private components which means they cannot\n          be printed.  However, if -std=gnu and not -pedantic, allow\n          the component to be printed to help debugging.  */\n       if (ts->u.derived->ts.f90_type == BT_VOID)\n@@ -15311,7 +15311,7 @@ resolve_symbol (gfc_symbol *sym)\n \t  for (; formal; formal = formal->next)\n \t    if (formal->sym && formal->sym->attr.flavor == FL_NAMELIST)\n \t      {\n-\t\tgfc_error (\"Namelist %qs can not be an argument to \"\n+\t\tgfc_error (\"Namelist %qs cannot be an argument to \"\n \t\t\t   \"subroutine or function at %L\",\n \t\t\t   formal->sym->name, &sym->declared_at);\n \t\treturn;"}, {"sha": "06c21d969f2b56eeef8f995cf67ce49a5a7ec87b", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -4470,7 +4470,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n \t  && curr_comp->ts.u.derived->ts.is_iso_c != 1\n           && curr_comp->ts.u.derived != derived_sym)\n         {\n-          /* This should be allowed; the draft says a derived-type can not\n+          /* This should be allowed; the draft says a derived-type cannot\n              have type parameters if it is has the BIND attribute.  Type\n              parameters seem to be for making parameterized derived types.\n              There's no need to verify the type if it is c_ptr/c_funptr.  */"}, {"sha": "e71e76ee9cf06dd1e869dae1c5e35bfe4031de43", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -9078,7 +9078,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t     TREE_TYPE (len), len, tmp);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t      size = size_of_string_in_bytes (c->ts.kind, len);\n-\t      /* This component can not have allocatable components,\n+\t      /* This component cannot have allocatable components,\n \t\t therefore add_when_allocated of duplicate_allocatable ()\n \t\t is always NULL.  */\n \t      tmp = duplicate_allocatable (dcmp, comp, ctype, rank,"}, {"sha": "474ad0bf930e5cf5c0c0162133720e946ab6404f", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1369,7 +1369,7 @@ gfc_add_assign_aux_vars (gfc_symbol * sym)\n   gfc_finish_var_decl (length, sym);\n   gfc_finish_var_decl (addr, sym);\n   /*  STRING_LENGTH is also used as flag. Less than -1 means that\n-      ASSIGN_ADDR can not be used. Equal -1 means that ASSIGN_ADDR is the\n+      ASSIGN_ADDR cannot be used. Equal -1 means that ASSIGN_ADDR is the\n       target label's address. Otherwise, value is the length of a format string\n       and ASSIGN_ADDR is its address.  */\n   if (TREE_STATIC (length))"}, {"sha": "64d52588d6e55eea7fa781f43d3afe92afeccfdf", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1432,7 +1432,7 @@ conv_expr_ref_to_caf_ref (stmtblock_t *block, gfc_expr *expr)\n \t\t\t  gcc_assert (end != NULL_TREE);\n \t\t\t  /* Multiply with the product of array's stride and\n \t\t\t     the step of the ref to a virtual upper bound.\n-\t\t\t     We can not compute the actual upper bound here or\n+\t\t\t     We cannot compute the actual upper bound here or\n \t\t\t     the caflib would compute the extend\n \t\t\t     incorrectly.  */\n \t\t\t  end = fold_build2 (MULT_EXPR, gfc_array_index_type,"}, {"sha": "6b785a6db4ea7b6b9bba49838d21e856e86ed878", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -6303,7 +6303,7 @@ gfc_trans_allocate (gfc_code * code)\n \tal_len = se.string_length;\n \n       al_len_needs_set = al_len != NULL_TREE;\n-      /* When allocating an array one can not use much of the\n+      /* When allocating an array one cannot use much of the\n \t pre-evaluated expr3 expressions, because for most of them the\n \t scalarizer is needed which is not available in the pre-evaluation\n \t step.  Therefore gfc_array_allocate () is responsible (and able)\n@@ -6554,7 +6554,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\t information in future loop iterations.  */\n \t      if (tmp_expr3_len_flag)\n \t\t/* No need to reset tmp_expr3_len_flag, because the\n-\t\t   presence of an expr3 can not change within in the\n+\t\t   presence of an expr3 cannot change within in the\n \t\t   loop.  */\n \t\texpr3_len = NULL_TREE;\n \t    }"}, {"sha": "d408eed77b5f1795ef2e2d689550c69a00ff4025", "filename": "gcc/genautomata.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -5539,9 +5539,9 @@ form_reservs_matter (automaton_t automaton)\n       if (units_array [unit]->automaton_decl\n \t  == automaton->corresponding_automaton_decl\n \t  && (cycle >= units_array [unit]->min_occ_cycle_num\n-\t      /* We can not remove queried unit from reservations.  */\n+\t      /* We cannot remove queried unit from reservations.  */\n \t      || units_array [unit]->query_p\n-\t      /* We can not remove units which are used\n+\t      /* We cannot remove units which are used\n \t\t `exclusion_set', `presence_set',\n \t\t `final_presence_set', `absence_set', and\n \t\t `final_absence_set'.  */\n@@ -9207,7 +9207,7 @@ generate (void)\n #define STANDARD_OUTPUT_DESCRIPTION_FILE_SUFFIX \".dfa\"\n \n /* The function returns suffix of given file name.  The returned\n-   string can not be changed.  */\n+   string cannot be changed.  */\n static const char *\n file_name_suffix (const char *file_name)\n {\n@@ -9222,7 +9222,7 @@ file_name_suffix (const char *file_name)\n /* The function returns base name of given file name, i.e. pointer to\n    first char after last `/' (or `\\' for WIN32) in given file name,\n    given file name itself if the directory name is absent.  The\n-   returned string can not be changed.  */\n+   returned string cannot be changed.  */\n static const char *\n base_file_name (const char *file_name)\n {"}, {"sha": "2d25f9eec5f45d2230c1c048e358abecfcaaaba4", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -380,8 +380,8 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t\t\tSTRIP_USELESS_TYPE_CONVERSION (val);\n \t\t      }\n \t\t    else\n-\t\t      /* We can not use __builtin_unreachable here because it\n-\t\t\t can not have address taken.  */\n+\t\t      /* We cannot use __builtin_unreachable here because it\n+\t\t\t cannot have address taken.  */\n \t\t      val = build_int_cst (TREE_TYPE (val), 0);\n \t\t    return val;\n \t\t  }\n@@ -6988,7 +6988,7 @@ fold_const_aggregate_ref_1 (tree t, tree (*valueize) (tree))\n \t\t     but don't fold.  */\n \t\t  if (maybe_lt (offset, 0))\n \t\t    return NULL_TREE;\n-\t\t  /* We can not determine ctor.  */\n+\t\t  /* We cannot determine ctor.  */\n \t\t  if (!ctor)\n \t\t    return NULL_TREE;\n \t\t  return fold_ctor_reference (TREE_TYPE (t), ctor, offset,\n@@ -7013,7 +7013,7 @@ fold_const_aggregate_ref_1 (tree t, tree (*valueize) (tree))\n       /* We do not know precise address.  */\n       if (!known_size_p (max_size) || maybe_ne (max_size, size))\n \treturn NULL_TREE;\n-      /* We can not determine ctor.  */\n+      /* We cannot determine ctor.  */\n       if (!ctor)\n \treturn NULL_TREE;\n "}, {"sha": "64e20cd128a407e66f74056da7b1b7404fb6f235", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,10 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* go-backend.c: Mechanically replace \"can not\" with \"cannot\".\n+\t* go-gcc.cc: Likewise.\n+\n 2019-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "9422b0d2b8a7b65652cb4f5c7571a361df8fea15", "filename": "gcc/go/go-backend.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fgo%2Fgo-backend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fgo%2Fgo-backend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-backend.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -82,7 +82,7 @@ go_field_alignment (tree t)\n }\n \n /* This is called by the Go frontend proper if the unsafe package was\n-   imported.  When that happens we can not do type-based alias\n+   imported.  When that happens we cannot do type-based alias\n    analysis.  */\n \n void"}, {"sha": "afdc7f8c5b2b36c86caf1c605c9337a70aeace77", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -760,7 +760,7 @@ Gcc_backend::Gcc_backend()\n \t\t\t\t\t\t\tNULL_TREE),\n \t\t       false, false);\n \n-  // The compiler uses __builtin_unreachable for cases that can not\n+  // The compiler uses __builtin_unreachable for cases that cannot\n   // occur.\n   this->define_builtin(BUILT_IN_UNREACHABLE, \"__builtin_unreachable\", NULL,\n \t\t       build_function_type(void_type_node, void_list_node),\n@@ -909,7 +909,7 @@ Gcc_backend::function_type(const Btyped_identifier& receiver,\n   if (result == error_mark_node)\n     return this->error_type();\n \n-  // The libffi library can not represent a zero-sized object.  To\n+  // The libffi library cannot represent a zero-sized object.  To\n   // avoid causing confusion on 32-bit SPARC, we treat a function that\n   // returns a zero-sized value as returning void.  That should do no\n   // harm since there is no actual value to be returned.  See"}, {"sha": "a72819662fb3f0b2cc7f0e758c036491ba6ffeac", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -674,7 +674,7 @@ struct target_hard_regs {\n      with the local stack frame are safe, but scant others.  */\n   HARD_REG_SET x_regs_invalidated_by_call;\n \n-  /* Call used hard registers which can not be saved because there is no\n+  /* Call used hard registers which cannot be saved because there is no\n      insn for this.  */\n   HARD_REG_SET x_no_caller_save_reg_set;\n "}, {"sha": "7b2f6e6bd75cdb40240aad511a9ad83ad0c6d2ca", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -503,7 +503,7 @@ cond_exec_process_if_block (ce_if_block * ce_info,\n     return FALSE;\n \n   /* If the conditional jump is more than just a conditional jump,\n-     then we can not do conditional execution conversion on this block.  */\n+     then we cannot do conditional execution conversion on this block.  */\n   if (! onlyjump_p (BB_END (test_bb)))\n     return FALSE;\n \n@@ -652,7 +652,7 @@ cond_exec_process_if_block (ce_if_block * ce_info,\n \t    goto fail;\n \n \t  /* If the conditional jump is more than just a conditional jump, then\n-\t     we can not do conditional execution conversion on this block.  */\n+\t     we cannot do conditional execution conversion on this block.  */\n \t  if (! onlyjump_p (BB_END (bb)))\n \t    goto fail;\n \n@@ -4022,7 +4022,7 @@ noce_find_if_block (basic_block test_bb, edge then_edge, edge else_edge,\n     }\n \n   /* If the conditional jump is more than just a conditional\n-     jump, then we can not do if-conversion on this block.  */\n+     jump, then we cannot do if-conversion on this block.  */\n   jump = BB_END (test_bb);\n   if (! onlyjump_p (jump))\n     return FALSE;\n@@ -4642,7 +4642,7 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n     return FALSE;\n \n   /* If the conditional jump is more than just a conditional jump, then\n-     we can not do if-conversion on this block.  Give up for returnjump_p,\n+     we cannot do if-conversion on this block.  Give up for returnjump_p,\n      changing a conditional return followed by unconditional trap for\n      conditional trap followed by unconditional return is likely not\n      beneficial and harder to handle.  */"}, {"sha": "69cc3f3b907f1e51e8a1272480042fb0c06aa912", "filename": "gcc/ipa-comdats.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-comdats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-comdats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-comdats.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -82,7 +82,7 @@ propagate_comdat_group (struct symtab_node *symbol,\n \t  continue;\n \t}\n \n-      /* One COMDAT group can not hold both variables and functions at\n+      /* One COMDAT group cannot hold both variables and functions at\n \t a same time.  For now we just go to BOTTOM, in future we may\n \t invent special comdat groups for this case.  */\n \n@@ -127,7 +127,7 @@ propagate_comdat_group (struct symtab_node *symbol,\n \n \tif (cgraph_node * cn = dyn_cast <cgraph_node *> (symbol2))\n \t  {\n-\t    /* Thunks can not call across section boundary.  */\n+\t    /* Thunks cannot call across section boundary.  */\n \t    if (cn->thunk.thunk_p)\n \t      newgroup = propagate_comdat_group (symbol2, newgroup, map);\n \t    /* If we see inline clone, its comdat group actually\n@@ -257,7 +257,7 @@ ipa_comdats (void)\n \t/* Mark the symbol so we won't waste time visiting it for dataflow.  */\n \tsymbol->aux = (symtab_node *) (void *) 1;\n       }\n-    /* See symbols that can not be privatized to comdats; that is externally\n+    /* See symbols that cannot be privatized to comdats; that is externally\n        visible symbols or otherwise used ones.  We also do not want to mangle\n        user section names.  */\n     else if (symbol->externally_visible"}, {"sha": "3489ed59ce20adf38c899aa28e7281248fa1c6ac", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1129,7 +1129,7 @@ count_callers (cgraph_node *node, void *data)\n   int *caller_count = (int *) data;\n \n   for (cgraph_edge *cs = node->callers; cs; cs = cs->next_caller)\n-    /* Local thunks can be handled transparently, but if the thunk can not\n+    /* Local thunks can be handled transparently, but if the thunk cannot\n        be optimized out, count it as a real use.  */\n     if (!cs->caller->thunk.thunk_p || !cs->caller->local.local)\n       ++*caller_count;"}, {"sha": "bba73b2d1e2e8d39cb7fb4bd528c2cfe57fb4164", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -244,7 +244,7 @@ type_all_ctors_visible_p (tree t)\n {\n   return !flag_ltrans\n \t && symtab->state >= CONSTRUCTION\n-\t /* We can not always use type_all_derivations_known_p.\n+\t /* We cannot always use type_all_derivations_known_p.\n \t    For function local types we must assume case where\n \t    the function is COMDAT and shared in between units.\n \n@@ -1144,12 +1144,12 @@ warn_types_mismatch (tree t1, tree t2, location_t loc1, location_t loc2)\n          verbose.  */\n       if (IDENTIFIER_POINTER (n1) != IDENTIFIER_POINTER (n2))\n         inform (loc_t1,\n-\t        \"type %qT defined in anonymous namespace can not match \"\n+\t        \"type %qT defined in anonymous namespace cannot match \"\n \t        \"type %qT across the translation unit boundary\",\n \t        t1, t2);\n       else\n         inform (loc_t1,\n-\t        \"type %qT defined in anonymous namespace can not match \"\n+\t        \"type %qT defined in anonymous namespace cannot match \"\n \t        \"across the translation unit boundary\",\n \t        t1);\n       if (loc_t2_useful)\n@@ -1312,7 +1312,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n       || (type_with_linkage_p (TYPE_MAIN_VARIANT (t2))\n \t  && type_in_anonymous_namespace_p (TYPE_MAIN_VARIANT (t2))))\n     {\n-      /* We can not trip this when comparing ODR types, only when trying to\n+      /* We cannot trip this when comparing ODR types, only when trying to\n \t match different ODR derivations from different declarations.\n \t So WARN should be always false.  */\n       gcc_assert (!warn);\n@@ -2120,7 +2120,7 @@ get_odr_type (tree type, bool insert)\n       val->all_derivations_known = type_all_derivations_known_p (type);\n       for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); i++)\n \t/* For now record only polymorphic types. other are\n-\t   pointless for devirtualization and we can not precisely\n+\t   pointless for devirtualization and we cannot precisely\n \t   determine ODR equivalency of these during LTO.  */\n \tif (polymorphic_type_binfo_p (BINFO_BASE_BINFO (binfo, i)))\n \t  {\n@@ -2467,7 +2467,7 @@ is_cxa_pure_virtual_p (tree target)\n \n /* If TARGET has associated node, record it in the NODES array.\n    CAN_REFER specify if program can refer to the target directly.\n-   if TARGET is unknown (NULL) or it can not be inserted (for example because\n+   if TARGET is unknown (NULL) or it cannot be inserted (for example because\n    its body was already removed and there is no way to refer to it), clear\n    COMPLETEP.  */\n \n@@ -2568,7 +2568,7 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n   else if (!completep)\n     ;\n   /* We have definition of __cxa_pure_virtual that is not accessible (it is\n-     optimized out or partitioned to other unit) so we can not add it.  When\n+     optimized out or partitioned to other unit) so we cannot add it.  When\n      not sanitizing, there is nothing to do.\n      Otherwise declare the list incomplete.  */\n   else if (pure_virtual)\n@@ -3805,7 +3805,7 @@ ipa_devirt (void)\n \t\tndropped++;\n \t        if (dump_file)\n \t\t  fprintf (dump_file, \"Dropping polymorphic call info;\"\n-\t\t\t   \" it can not be used by ipa-prop\\n\");\n+\t\t\t   \" it cannot be used by ipa-prop\\n\");\n \t      }\n \n \t    if (!opt_for_fn (n->decl, flag_devirtualize_speculatively))"}, {"sha": "dbb95b0897181df7f878b6c96c3d7594d4bb5461", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -307,7 +307,7 @@ set_hint_predicate (predicate **p, predicate new_predicate)\n    copy when called in a given context.  It is a bitmask of conditions. Bit\n    0 means that condition is known to be false, while bit 1 means that condition\n    may or may not be true.  These differs - for example NOT_INLINED condition\n-   is always false in the second and also builtin_constant_p tests can not use\n+   is always false in the second and also builtin_constant_p tests cannot use\n    the fact that parameter is indeed a constant.\n \n    KNOWN_VALS is partial mapping of parameters of NODE to constant values.\n@@ -2219,7 +2219,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t      struct predicate p = bb_predicate & will_be_nonconstant;\n \n \t      /* We can ignore statement when we proved it is never going\n-\t\t to happen, but we can not do that for call statements\n+\t\t to happen, but we cannot do that for call statements\n \t\t because edges are accounted specially.  */\n \n \t      if (*(is_gimple_call (stmt) ? &bb_predicate : &p) != false)\n@@ -2430,7 +2430,7 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n       info->account_size_time (2 * ipa_fn_summary::size_scale, 0, t, t);\n       ipa_update_overall_fn_summary (node);\n       info->self_size = info->size;\n-      /* We can not inline instrumentation clones.  */\n+      /* We cannot inline instrumentation clones.  */\n       if (node->thunk.add_pointer_bounds_args)\n \t{\n           info->inlinable = false;\n@@ -2471,7 +2471,7 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n \t     node->local.can_change_signature = true;\n \t   else\n \t     {\n-\t       /* Functions calling builtin_apply can not change signature.  */\n+\t       /* Functions calling builtin_apply cannot change signature.  */\n \t       for (e = node->callees; e; e = e->next_callee)\n \t\t {\n \t\t   tree cdecl = e->callee->decl;"}, {"sha": "056be1139db7fcdca66f131af1e1b9560c7b8578", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -368,7 +368,7 @@ sem_item::compare_referenced_symbol_properties (symtab_node *used_by,\n \t  && (!used_by || !is_a <cgraph_node *> (used_by) || address\n \t      || opt_for_fn (used_by->decl, flag_devirtualize)))\n \treturn return_false_with_msg\n-\t\t (\"references to virtual tables can not be merged\");\n+\t\t (\"references to virtual tables cannot be merged\");\n \n       if (address && DECL_ALIGN (n1->decl) != DECL_ALIGN (n2->decl))\n \treturn return_false_with_msg (\"alignment mismatch\");\n@@ -1083,23 +1083,23 @@ sem_function::merge (sem_item *alias_item)\n   if (original->can_be_discarded_p ())\n     original_discardable = true;\n   /* Also consider case where we have resolution info and we know that\n-     original's definition is not going to be used.  In this case we can not\n+     original's definition is not going to be used.  In this case we cannot\n      create alias to original.  */\n   if (node->resolution != LDPR_UNKNOWN\n       && !decl_binds_to_current_def_p (node->decl))\n     original_discardable = original_discarded = true;\n \n   /* Creating a symtab alias is the optimal way to merge.\n-     It however can not be used in the following cases:\n+     It however cannot be used in the following cases:\n \n      1) if ORIGINAL and ALIAS may be possibly compared for address equality.\n      2) if ORIGINAL is in a section that may be discarded by linker or if\n-\tit is an external functions where we can not create an alias\n+\tit is an external functions where we cannot create an alias\n \t(ORIGINAL_DISCARDABLE)\n      3) if target do not support symbol aliases.\n      4) original and alias lie in different comdat groups.\n \n-     If we can not produce alias, we will turn ALIAS into WRAPPER of ORIGINAL\n+     If we cannot produce alias, we will turn ALIAS into WRAPPER of ORIGINAL\n      and/or redirect all callers from ALIAS to ORIGINAL.  */\n   if ((original_address_matters && alias_address_matters)\n       || (original_discardable\n@@ -1149,7 +1149,7 @@ sem_function::merge (sem_item *alias_item)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n-\t\t     \"can not create wrapper of stdarg function.\\n\");\n+\t\t     \"cannot create wrapper of stdarg function.\\n\");\n \t}\n       else if (ipa_fn_summaries\n \t       && ipa_fn_summaries->get (alias) != NULL\n@@ -1184,7 +1184,7 @@ sem_function::merge (sem_item *alias_item)\n       if (!redirect_callers && !create_wrapper)\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"Not unifying; can not redirect callers nor \"\n+\t    fprintf (dump_file, \"Not unifying; cannot redirect callers nor \"\n \t\t     \"produce wrapper\\n\\n\");\n \t  return false;\n \t}\n@@ -1193,7 +1193,7 @@ sem_function::merge (sem_item *alias_item)\n \t If ORIGINAL is interposable, we need to call a local alias.\n \t Also produce local alias (if possible) as an optimization.\n \n-\t Local aliases can not be created inside comdat groups because that\n+\t Local aliases cannot be created inside comdat groups because that\n \t prevents inlining.  */\n       if (!original_discardable && !original->get_comdat_group ())\n \t{\n@@ -1203,28 +1203,28 @@ sem_function::merge (sem_item *alias_item)\n \t      && original->get_availability () > AVAIL_INTERPOSABLE)\n \t    local_original = original;\n \t}\n-      /* If we can not use local alias, fallback to the original\n+      /* If we cannot use local alias, fallback to the original\n \t when possible.  */\n       else if (original->get_availability () > AVAIL_INTERPOSABLE)\n \tlocal_original = original;\n \n-      /* If original is COMDAT local, we can not really redirect calls outside\n+      /* If original is COMDAT local, we cannot really redirect calls outside\n \t of its comdat group to it.  */\n       if (original->comdat_local_p ())\n         redirect_callers = false;\n       if (!local_original)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Not unifying; \"\n-\t\t     \"can not produce local alias.\\n\\n\");\n+\t\t     \"cannot produce local alias.\\n\\n\");\n \t  return false;\n \t}\n \n       if (!redirect_callers && !create_wrapper)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Not unifying; \"\n-\t\t     \"can not redirect callers nor produce a wrapper\\n\\n\");\n+\t\t     \"cannot redirect callers nor produce a wrapper\\n\\n\");\n \t  return false;\n \t}\n       if (!create_wrapper\n@@ -1233,7 +1233,7 @@ sem_function::merge (sem_item *alias_item)\n \t  && !alias->can_remove_if_no_direct_calls_p ())\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"Not unifying; can not make wrapper and \"\n+\t    fprintf (dump_file, \"Not unifying; cannot make wrapper and \"\n \t\t     \"function has other uses than direct calls\\n\\n\");\n \t  return false;\n \t}\n@@ -2124,7 +2124,7 @@ sem_variable::merge (sem_item *alias_item)\n   /* See if original is in a section that can be discarded if the main\n      symbol is not used.\n      Also consider case where we have resolution info and we know that\n-     original's definition is not going to be used.  In this case we can not\n+     original's definition is not going to be used.  In this case we cannot\n      create alias to original.  */\n   if (original->can_be_discarded_p ()\n       || (node->resolution != LDPR_UNKNOWN\n@@ -2160,7 +2160,7 @@ sem_variable::merge (sem_item *alias_item)\n       return false;\n     }\n \n-  /* We can not merge if address comparsion metters.  */\n+  /* We cannot merge if address comparsion metters.  */\n   if (alias_address_matters && flag_merge_constants < 2)\n     {\n       if (dump_file)"}, {"sha": "4a3a193bc9c07730387e03cc1ba488d6f4dd3cf5", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -596,7 +596,7 @@ save_inline_function_body (struct cgraph_node *node)\n   /* When doing recursive inlining, the clone may become unnecessary.\n      This is possible i.e. in the case when the recursive function is proved to be\n      non-throwing and the recursion happens only in the EH landing pad.\n-     We can not remove the clone until we are done with saving the body.\n+     We cannot remove the clone until we are done with saving the body.\n      Remove it now.  */\n   if (!first_clone->callers)\n     {"}, {"sha": "2c1843aa8168b5e4d8e46da97a584d728f0daf71", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -59,7 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n \t optimization) and thus improve quality of analysis done by real IPA\n \t optimizers.\n \n-\t Because of lack of whole unit knowledge, the pass can not really make\n+\t Because of lack of whole unit knowledge, the pass cannot really make\n \t good code size/performance tradeoffs.  It however does very simple\n \t speculative inlining allowing code size to grow by\n \t EARLY_INLINING_INSNS when callee is leaf function.  In this case the\n@@ -562,7 +562,7 @@ can_early_inline_edge_p (struct cgraph_edge *e)\n {\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n   /* Early inliner might get called at WPA stage when IPA pass adds new\n-     function.  In this case we can not really do any of early inlining\n+     function.  In this case we cannot really do any of early inlining\n      because function bodies are missing.  */\n   if (cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR)\n     return false;"}, {"sha": "7d8c5ab9baf727416858ddb99d6878c227208c72", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -112,7 +112,7 @@ possible_placement_new (tree type, tree expected_type,\n    If the same is produced by multiple inheritance, we end up with A and offset\n    sizeof(int). \n \n-   If we can not find corresponding class, give up by setting\n+   If we cannot find corresponding class, give up by setting\n    THIS->OUTER_TYPE to OTR_TYPE and THIS->OFFSET to NULL. \n    Return true when lookup was sucesful.\n \n@@ -146,7 +146,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n     derived from OUTER_TYPE.\n \n     Because the instance type may contain field whose type is of OUTER_TYPE,\n-    we can not derive any effective information about it.\n+    we cannot derive any effective information about it.\n \n     TODO: In the case we know all derrived types, we can definitely do better\n     here.  */\n@@ -191,7 +191,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n       tree fld;\n \n       /* If we do not know size of TYPE, we need to be more conservative\n-         about accepting cases where we can not find EXPECTED_TYPE.\n+         about accepting cases where we cannot find EXPECTED_TYPE.\n \t Generally the types that do matter here are of constant size.\n \t Size_unknown case should be very rare.  */\n       if (TYPE_SIZE (type)\n@@ -233,7 +233,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n \t\t  && type_known_to_have_no_derivations_p (outer_type))\n \t\tmaybe_derived_type = false;\n \n-\t      /* Type can not contain itself on an non-zero offset.  In that case\n+\t      /* Type cannot contain itself on an non-zero offset.  In that case\n \t\t just give up.  Still accept the case where size is now known.\n \t\t Either the second copy may appear past the end of type or within\n \t\t the non-POD buffer located inside the variably sized type\n@@ -287,7 +287,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n \t      size = tree_to_uhwi (DECL_SIZE (fld));\n \n \t      /* We can always skip types smaller than pointer size:\n-\t\t those can not contain a virtual table pointer.\n+\t\t those cannot contain a virtual table pointer.\n \n \t\t Disqualifying fields that are too small to fit OTR_TYPE\n \t\t saves work needed to walk them for no benefit.\n@@ -552,7 +552,7 @@ decl_maybe_in_construction_p (tree base, tree outer_type,\n   if (DECL_STRUCT_FUNCTION (function)->after_inlining)\n     return true;\n \n-  /* Pure functions can not do any changes on the dynamic type;\n+  /* Pure functions cannot do any changes on the dynamic type;\n      that require writting to memory.  */\n   if ((!base || !auto_var_in_fn_p (base, function))\n       && flags_from_decl_or_type (function) & (ECF_PURE | ECF_CONST))\n@@ -1745,7 +1745,7 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n      sub-objects and the code written by the user is run.  Only this may\n      include calling virtual functions, directly or indirectly.\n \n-     4) placement new can not be used to change type of non-POD statically\n+     4) placement new cannot be used to change type of non-POD statically\n      allocated variables.\n \n      There is no way to call a constructor of an ancestor sub-object in any\n@@ -2333,7 +2333,7 @@ ipa_polymorphic_call_context::make_speculative (tree otr_type)\n \t\t\t    otr_type);\n }\n \n-/* Use when we can not track dynamic type change.  This speculatively assume\n+/* Use when we cannot track dynamic type change.  This speculatively assume\n    type change is not happening.  */\n \n void"}, {"sha": "de9563d808c37168df66a3123d32a406a89dc67b", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -391,7 +391,7 @@ ipa_propagate_frequency (struct cgraph_node *node)\n   struct ipa_propagate_frequency_data d = {node, true, true, true, true};\n   bool changed = false;\n \n-  /* We can not propagate anything useful about externally visible functions\n+  /* We cannot propagate anything useful about externally visible functions\n      nor about virtuals.  */\n   if (!node->local.local\n       || node->alias"}, {"sha": "6830f8d7f3f095060f3f4a7f6ca6d1c457ace223", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -686,14 +686,14 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n    in between beggining of the function until CALL is invoked.\n \n    Generally functions are not allowed to change type of such instances,\n-   but they call destructors.  We assume that methods can not destroy the THIS\n+   but they call destructors.  We assume that methods cannot destroy the THIS\n    pointer.  Also as a special cases, constructor and destructors may change\n    type of the THIS pointer.  */\n \n static bool\n param_type_may_change_p (tree function, tree arg, gimple *call)\n {\n-  /* Pure functions can not do any changes on the dynamic type;\n+  /* Pure functions cannot do any changes on the dynamic type;\n      that require writting to memory.  */\n   if (flags_from_decl_or_type (function) & (ECF_PURE | ECF_CONST))\n     return false;\n@@ -1971,7 +1971,7 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t    }\n \t}\n \n-      /* If ARG is pointer, we can not use its type to determine the type of aggregate\n+      /* If ARG is pointer, we cannot use its type to determine the type of aggregate\n \t passed (because type conversions are ignored in gimple).  Usually we can\n \t safely get type from function declaration, but in case of K&R prototypes or\n \t variadic functions we can try our luck with type of the pointer passed.\n@@ -2875,7 +2875,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"ipa-prop: Discovered call to a known target \"\n-\t\t     \"(%s -> %s) but can not refer to it. Giving up.\\n\",\n+\t\t     \"(%s -> %s) but cannot refer to it. Giving up.\\n\",\n \t\t     ie->caller->dump_name (),\n \t\t     ie->callee->dump_name ());\n \t  return NULL;\n@@ -2914,7 +2914,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \n   ipa_check_create_node_params ();\n \n-  /* We can not make edges to inline clones.  It is bug that someone removed\n+  /* We cannot make edges to inline clones.  It is bug that someone removed\n      the cgraph node too early.  */\n   gcc_assert (!callee->global.inlined_to);\n "}, {"sha": "d2dcf7c2d43e82d8889909f092d5c2687be8e6ca", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1087,7 +1087,7 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \t\tif (!finite_loop_p (loop))\n \t\t  {\n \t\t    if (dump_file)\n-\t\t      fprintf (dump_file, \"    can not prove finiteness of \"\n+\t\t      fprintf (dump_file, \"    cannot prove finiteness of \"\n \t\t\t       \"loop %i\\n\", loop->num);\n \t\t    l->looping =true;\n \t\t    break;\n@@ -1186,7 +1186,7 @@ pure_const_generate_summary (void)\n \n   /* Process all of the functions.\n \n-     We process AVAIL_INTERPOSABLE functions.  We can not use the results\n+     We process AVAIL_INTERPOSABLE functions.  We cannot use the results\n      by default, but the info can be used at LTO with -fwhole-program or\n      when function got cloned and the clone is AVAILABLE.  */\n \n@@ -2292,7 +2292,7 @@ pass_nothrow::execute (function *)\n \n   node = cgraph_node::get (current_function_decl);\n \n-  /* We run during lowering, we can not really use availability yet.  */\n+  /* We run during lowering, we cannot really use availability yet.  */\n   if (cgraph_node::get (current_function_decl)->get_availability ()\n       <= AVAIL_INTERPOSABLE)\n     {"}, {"sha": "8ad12d30bb22c0a97b19a7c91660a20b9bd1d1df", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -239,7 +239,7 @@ is_improper (symtab_node *n, void *v ATTRIBUTE_UNUSED)\n   if (TREE_READONLY (t))\n     return true;\n \n-  /* We can not track variables with address taken.  */\n+  /* We cannot track variables with address taken.  */\n   if (TREE_ADDRESSABLE (t))\n     return true;\n \n@@ -641,7 +641,7 @@ get_read_write_all_from_node (struct cgraph_node *node,\n {\n   struct cgraph_edge *e, *ie;\n \n-  /* When function is overwritable, we can not assume anything.  */\n+  /* When function is overwritable, we cannot assume anything.  */\n   if (node->get_availability () <= AVAIL_INTERPOSABLE\n       || (node->analyzed && !opt_for_fn (node->decl, flag_ipa_reference)))\n     read_write_all_from_decl (node, read_all, write_all);"}, {"sha": "cfd03abb07d038c3009d7533bd8d933de8610769", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -452,7 +452,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n        < (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.apply_scale\n \t   (PARAM_VALUE (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY), 100))))\n     {\n-      /* When profile is guessed, we can not expect it to give us\n+      /* When profile is guessed, we cannot expect it to give us\n \t realistic estimate on likelyness of function taking the\n \t complex path.  As a special case, when tail of the function is\n \t a loop, enable splitting since inlining code skipping the loop\n@@ -729,7 +729,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n    of the form:\n    <retval> = tmp_var;\n    return <retval>\n-   but return_bb can not be more complex than this (except for\n+   but return_bb cannot be more complex than this (except for\n    -fsanitize=thread we allow TSAN_FUNC_EXIT () internal call in there).\n    If nothing is found, return the exit block.\n \n@@ -878,7 +878,7 @@ visit_bb (basic_block bb, basic_block return_bb,\n       if (gimple_clobber_p (stmt))\n \tcontinue;\n \n-      /* FIXME: We can split regions containing EH.  We can not however\n+      /* FIXME: We can split regions containing EH.  We cannot however\n \t split RESX, EH_DISPATCH and EH_POINTER referring to same region\n \t into different partitions.  This would require tracking of\n \t EH regions and checking in consider_split_point if they \n@@ -1003,7 +1003,7 @@ struct stack_entry\n   sreal overall_time;\n   int overall_size;\n \n-  /* When false we can not split on this BB.  */\n+  /* When false we cannot split on this BB.  */\n   bool can_split;\n };\n \n@@ -1071,7 +1071,7 @@ find_split_points (basic_block return_bb, sreal overall_time, int overall_size)\n \t  if (pos <= entry->earliest && !entry->can_split\n \t      && dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n-\t\t     \"found articulation at bb %i but can not split\\n\",\n+\t\t     \"found articulation at bb %i but cannot split\\n\",\n \t\t     entry->bb->index);\n \t  if (pos <= entry->earliest && entry->can_split)\n \t     {\n@@ -1344,7 +1344,7 @@ split_function (basic_block return_bb, struct split_point *split_point,\n   node->tp_first_run = cur_node->tp_first_run + 1;\n \n   /* For usual cloning it is enough to clear builtin only when signature\n-     changes.  For partial inlining we however can not expect the part\n+     changes.  For partial inlining we however cannot expect the part\n      of builtin implementation to have same semantic as the whole.  */\n   if (fndecl_built_in_p (node->decl))\n     {"}, {"sha": "5752e5c50855af840bca685e8cd9fc3dc1b11da8", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -42,7 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n       its calling convention.  We simply mark all static functions whose\n       address is not taken as local.\n \n-      externally_visible flag is set for symbols that can not be privatized.\n+      externally_visible flag is set for symbols that cannot be privatized.\n       For privatized symbols we clear TREE_PUBLIC flag and dismantle comdat\n       group.\n \n@@ -87,7 +87,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n \n-/* Return true when NODE can not be local. Worker for cgraph_local_node_p.  */\n+/* Return true when NODE cannot be local. Worker for cgraph_local_node_p.  */\n \n static bool\n non_local_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n@@ -147,7 +147,7 @@ comdat_can_be_unshared_p_1 (symtab_node *node)\n           && !flag_whole_program))\n     return false;\n \n-  /* Non-readonly and volatile variables can not be duplicated.  */\n+  /* Non-readonly and volatile variables cannot be duplicated.  */\n   if (is_a <varpool_node *> (node)\n       && (!TREE_READONLY (node->decl)\n \t  || TREE_THIS_VOLATILE (node->decl)))\n@@ -158,7 +158,7 @@ comdat_can_be_unshared_p_1 (symtab_node *node)\n /* COMDAT functions must be shared only if they have address taken,\n    otherwise we can produce our own private implementation with\n    -fwhole-program.  \n-   Return true when turning COMDAT function static can not lead to wrong\n+   Return true when turning COMDAT function static cannot lead to wrong\n    code when the resulting object links with a library defining same COMDAT.\n \n    Virtual functions do have their addresses taken from the vtables,\n@@ -464,7 +464,7 @@ optimize_weakref (symtab_node *node)\n \n   gcc_assert (node->weakref);\n \n-  /* Weakrefs with no target defined can not be optimized.  */\n+  /* Weakrefs with no target defined cannot be optimized.  */\n   if (!node->analyzed)\n     return;\n   symtab_node *target = node->get_alias_target ();\n@@ -674,7 +674,7 @@ function_and_variable_visibility (bool whole_program)\n \t}\n \n       /* C++ FE on lack of COMDAT support create local COMDAT functions\n-\t (that ought to be shared but can not due to object format\n+\t (that ought to be shared but cannot due to object format\n \t limitations).  It is necessary to keep the flag to make rest of C++ FE\n \t happy.  Clear the flag here to avoid confusion in middle-end.  */\n       if (DECL_COMDAT (node->decl) && !TREE_PUBLIC (node->decl))\n@@ -750,8 +750,8 @@ function_and_variable_visibility (bool whole_program)\n       if (!node->local.local)\n         node->local.local |= node->local_p ();\n \n-      /* If we know that function can not be overwritten by a\n-\t different semantics and moreover its section can not be\n+      /* If we know that function cannot be overwritten by a\n+\t different semantics and moreover its section cannot be\n \t discarded, replace all direct calls by calls to an\n \t noninterposable alias.  This make dynamic linking cheaper and\n \t enable more optimization.\n@@ -787,7 +787,7 @@ function_and_variable_visibility (bool whole_program)\n \t\t  || vnode->weakref\n       \t\t  || TREE_PUBLIC (vnode->decl)\n \t\t  || DECL_EXTERNAL (vnode->decl));\n-      /* In several cases declarations can not be common:\n+      /* In several cases declarations cannot be common:\n \n \t - when declaration has initializer\n \t - when it is in weak"}, {"sha": "26268bc0c7c370d7d26789eff63ac6ebbd51d148", "filename": "gcc/ipa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -760,7 +760,7 @@ clear_addressable_bit (varpool_node *vnode, void *data ATTRIBUTE_UNUSED)\n \n    Return true when unreachable symbol removal should be done.\n \n-   FIXME: This can not be done in between gimplify and omp_expand since\n+   FIXME: This cannot be done in between gimplify and omp_expand since\n    readonly flag plays role on what is shared and what is not.  Currently we do\n    this transformation as part of whole program visibility and re-do at\n    ipa-reference pass (to take into account clonning), but it would"}, {"sha": "83caa3a8ed8bb69738d361bf08429a1dcc293f96", "filename": "gcc/ira-build.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -45,7 +45,7 @@ ira_loop_tree_node_t ira_loop_tree_root;\n int ira_loop_tree_height;\n \n /* All nodes representing basic blocks are referred through the\n-   following array.  We can not use basic block member `aux' for this\n+   following array.  We cannot use basic block member `aux' for this\n    because it is used for insertion of insns on edges.  */\n ira_loop_tree_node_t ira_bb_nodes;\n \n@@ -259,7 +259,7 @@ add_loop_to_tree (struct loop *loop)\n   struct loop *parent;\n   ira_loop_tree_node_t loop_node, parent_node;\n \n-  /* We can not use loop node access macros here because of potential\n+  /* We cannot use loop node access macros here because of potential\n      checking and because the nodes are not initialized enough\n      yet.  */\n   if (loop != NULL && loop_outer (loop) != NULL)\n@@ -334,7 +334,7 @@ form_loop_tree (void)\n   struct loop *parent;\n   ira_loop_tree_node_t bb_node, loop_node;\n \n-  /* We can not use loop/bb node access macros because of potential\n+  /* We cannot use loop/bb node access macros because of potential\n      checking and because the nodes are not initialized enough\n      yet.  */\n   FOR_EACH_BB_FN (bb, cfun)\n@@ -2166,7 +2166,7 @@ low_pressure_loop_node_p (ira_loop_tree_node_t node)\n #ifdef STACK_REGS\n /* Return TRUE if LOOP has a complex enter or exit edge.  We don't\n    form a region from such loop if the target use stack register\n-   because reg-stack.c can not deal with such edges.  */\n+   because reg-stack.c cannot deal with such edges.  */\n static bool\n loop_with_complex_edge_p (struct loop *loop)\n {\n@@ -2619,8 +2619,8 @@ remove_unnecessary_regions (bool all_p)\n \n /* At this point true value of allocno attribute bad_spill_p means\n    that there is an insn where allocno occurs and where the allocno\n-   can not be used as memory.  The function updates the attribute, now\n-   it can be true only for allocnos which can not be used as memory in\n+   cannot be used as memory.  The function updates the attribute, now\n+   it can be true only for allocnos which cannot be used as memory in\n    an insn and in whose live ranges there is other allocno deaths.\n    Spilling allocnos with true value will not improve the code because\n    it will not make other allocnos colorable and additional reloads"}, {"sha": "aa91b56c81f210a90b0ece0fd15aa928ec6dfb44", "filename": "gcc/ira-color.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1575,7 +1575,7 @@ update_conflict_hard_regno_costs (int *costs, enum reg_class aclass,\n /* Set up conflicting (through CONFLICT_REGS) for each object of\n    allocno A and the start allocno profitable regs (through\n    START_PROFITABLE_REGS).  Remember that the start profitable regs\n-   exclude hard regs which can not hold value of mode of allocno A.\n+   exclude hard regs which cannot hold value of mode of allocno A.\n    This covers mostly cases when multi-register value should be\n    aligned.  */\n static inline void\n@@ -2272,7 +2272,7 @@ bucket_allocno_compare_func (const void *v1p, const void *v2p)\n   /* Push pseudos requiring less hard registers first.  It means that\n      we will assign pseudos requiring more hard registers first\n      avoiding creation small holes in free hard register file into\n-     which the pseudos requiring more hard registers can not fit.  */\n+     which the pseudos requiring more hard registers cannot fit.  */\n   if ((diff = (ira_reg_class_max_nregs[cl1][ALLOCNO_MODE (a1)]\n \t       - ira_reg_class_max_nregs[cl2][ALLOCNO_MODE (a2)])) != 0)\n     return diff;"}, {"sha": "7ec709db830c53fa4bb77aff5e5c612096f7bc6c", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -289,7 +289,7 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n \n   if (! IN_RANGE (allocno_preferenced_hard_regno,\n \t\t  0, FIRST_PSEUDO_REGISTER - 1))\n-    /* Can not be tied.  */\n+    /* Cannot be tied.  */\n     return false;\n   rclass = REGNO_REG_CLASS (allocno_preferenced_hard_regno);\n   mode = ALLOCNO_MODE (a);\n@@ -300,7 +300,7 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n     return false;\n   index = ira_class_hard_reg_index[aclass][allocno_preferenced_hard_regno];\n   if (index < 0)\n-    /* Can not be tied.  It is not in the allocno class.  */\n+    /* Cannot be tied.  It is not in the allocno class.  */\n     return false;\n   ira_init_register_move_cost_if_necessary (mode);\n   if (HARD_REGISTER_P (reg1))"}, {"sha": "0ca70a0053a7ab2eebc1f6f7ff96f5060fb60b8d", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -389,8 +389,8 @@ setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n \n /* Setup cost classes for pseudo REGNO with MODE.  Usage of MODE can\n    decrease number of cost classes for the pseudo, if hard registers\n-   of some important classes can not hold a value of MODE.  So the\n-   pseudo can not get hard register of some important classes and cost\n+   of some important classes cannot hold a value of MODE.  So the\n+   pseudo cannot get hard register of some important classes and cost\n    calculation for such important classes is only wasting CPU\n    time.  */\n static void"}, {"sha": "3c7fe4e6450a2b7dbc3c2f9b04bfe900955779d9", "filename": "gcc/ira-int.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -107,7 +107,7 @@ struct ira_loop_tree_node\n \n   /* Allocnos in the loop corresponding to their regnos.  If it is\n      NULL the loop does not form a separate register allocation region\n-     (e.g. because it has abnormal enter/exit edges and we can not put\n+     (e.g. because it has abnormal enter/exit edges and we cannot put\n      code for register shuffling on the edges if a different\n      allocation is used for a pseudo-register on different sides of\n      the edges).  Caps are not in the map (remember we can have more\n@@ -145,7 +145,7 @@ extern ira_loop_tree_node_t ira_loop_tree_root;\n extern int ira_loop_tree_height;\n \n /* All nodes representing basic blocks are referred through the\n-   following array.  We can not use basic block member `aux' for this\n+   following array.  We cannot use basic block member `aux' for this\n    because it is used for insertion of insns on edges.  */\n extern ira_loop_tree_node_t ira_bb_nodes;\n \n@@ -250,7 +250,7 @@ struct ira_object\n      of other ira_objects that this one can conflict with.  */\n   int min, max;\n   /* Initial and accumulated hard registers conflicting with this\n-     object and as a consequences can not be assigned to the allocno.\n+     object and as a consequences cannot be assigned to the allocno.\n      All non-allocatable hard regs and hard regs of register classes\n      different from given allocno one are included in the sets.  */\n   HARD_REG_SET conflict_hard_regs, total_conflict_hard_regs;\n@@ -795,7 +795,7 @@ struct target_ira_int {\n   struct costs *x_op_costs[MAX_RECOG_OPERANDS];\n   struct costs *x_this_op_costs[MAX_RECOG_OPERANDS];\n \n-  /* Hard registers that can not be used for the register allocator for\n+  /* Hard registers that cannot be used for the register allocator for\n      all functions of the current compilation unit.  */\n   HARD_REG_SET x_no_unit_alloc_regs;\n "}, {"sha": "af5b821768866a060f6905e48e990c4c8a6b620c", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1381,7 +1381,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t  /* We should create a conflict of PIC pseudo with\n \t\t     PIC hard reg as PIC hard reg can have a wrong\n \t\t     value after jump described by the abnormal edge.\n-\t\t     In this case we can not allocate PIC hard reg to\n+\t\t     In this case we cannot allocate PIC hard reg to\n \t\t     PIC pseudo as PIC pseudo will also have a wrong\n \t\t     value.  This code is not critical as LRA can fix\n \t\t     it but it is better to have the right allocation"}, {"sha": "ccdc2aba181c82aecad8cbbe3420eecdf6749edb", "filename": "gcc/ira.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -233,7 +233,7 @@ along with GCC; see the file COPYING3.  If not see\n \t more profitable than memory usage.\n \n        * Popping the allocnos from the stack and assigning them hard\n-         registers.  If IRA can not assign a hard register to an\n+         registers.  If IRA cannot assign a hard register to an\n          allocno and the allocno is coalesced, IRA undoes the\n          coalescing and puts the uncoalesced allocnos onto the stack in\n          the hope that some such allocnos will get a hard register\n@@ -937,7 +937,7 @@ setup_uniform_class_p (void)\n       ira_uniform_class_p[cl] = false;\n       if (ira_class_hard_regs_num[cl] == 0)\n \tcontinue;\n-      /* We can not use alloc_reg_class_subclasses here because move\n+      /* We cannot use alloc_reg_class_subclasses here because move\n \t cost hooks does not take into account that some registers are\n \t unavailable for the subtarget.  E.g. for i686, INT_SSE_REGS\n \t is element of alloc_reg_class_subclasses for GENERAL_REGS\n@@ -966,7 +966,7 @@ setup_uniform_class_p (void)\n    IRA_IMPORTANT_CLASSES, and IRA_IMPORTANT_CLASSES_NUM.\n \n    Target may have many subtargets and not all target hard registers can\n-   be used for allocation, e.g. x86 port in 32-bit mode can not use\n+   be used for allocation, e.g. x86 port in 32-bit mode cannot use\n    hard registers introduced in x86-64 like r8-r15).  Some classes\n    might have the same allocatable hard registers, e.g.  INDEX_REGS\n    and GENERAL_REGS in x86 port in 32-bit mode.  To decrease different\n@@ -3506,7 +3506,7 @@ update_equiv_regs (void)\n \t      rtx_insn_list *list;\n \n \t      /* If we have already processed this pseudo and determined it\n-\t\t can not have an equivalence, then honor that decision.  */\n+\t\t cannot have an equivalence, then honor that decision.  */\n \t      if (reg_equiv[regno].no_equiv)\n \t\tcontinue;\n \n@@ -5390,7 +5390,7 @@ ira (FILE *f)\n   if (ira_conflicts_p && ! ira_use_lra_p)\n     /* Opposite to reload pass, LRA does not use any conflict info\n        from IRA.  We don't rebuild conflict info for LRA (through\n-       ira_flattening call) and can not use the check here.  We could\n+       ira_flattening call) and cannot use the check here.  We could\n        rebuild this info for LRA in the check mode but there is a risk\n        that code generated with the check and without it will be a bit\n        different.  Calling ira_flattening in any mode would be a"}, {"sha": "8e1d039ee28898cef335ae8b0cd256cb1f01a401", "filename": "gcc/ira.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -109,7 +109,7 @@ struct target_ira\n      index [CL][M] gives the number of that register, otherwise it is -1.  */\n   short x_ira_class_singleton[N_REG_CLASSES][MAX_MACHINE_MODE];\n \n-  /* Function specific hard registers can not be used for the register\n+  /* Function specific hard registers cannot be used for the register\n      allocation.  */\n   HARD_REG_SET x_ira_no_alloc_regs;\n "}, {"sha": "3e82f1e10d5e5b867af315e1378915cdff8e5ef4", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1053,7 +1053,7 @@ check_dependencies (rtx_insn *insn, bitmap depends_on)\n   return true;\n }\n \n-/* Pre-check candidate DEST to skip the one which can not make a valid insn\n+/* Pre-check candidate DEST to skip the one which cannot make a valid insn\n    during move_invariant_reg.  SIMPLE is to skip HARD_REGISTER.  */\n static bool\n pre_check_invariant_p (bool simple, rtx dest)\n@@ -1365,7 +1365,7 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed,\n        This usually has the effect that FP constant loads from the constant\n        pool are not moved out of the loop.\n \n-       Note that this also means that dependent invariants can not be moved.\n+       Note that this also means that dependent invariants cannot be moved.\n        However, the primary purpose of this pass is to move loop invariant\n        address arithmetic out of loops, and address arithmetic that depends\n        on floating point constants is unlikely to ever occur.  */"}, {"sha": "cbc66736c040c68a3bcd15a41e80ad9cacd5b5fe", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1407,7 +1407,7 @@ analyze_insn_to_expand_var (struct loop *loop, rtx_insn *insn)\n     }\n \n   /* Hmm, this is a bit paradoxical.  We know that INSN is a valid insn\n-     in MD.  But if there is no optab to generate the insn, we can not\n+     in MD.  But if there is no optab to generate the insn, we cannot\n      perform the variable expansion.  This can happen if an MD provides\n      an insn but not a named pattern to generate it, for example to avoid\n      producing code that needs additional mode switches like for x87/mmx."}, {"sha": "4f68a7381b750fe160bb5436b2601d4ec572cc7c", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -79,7 +79,7 @@ along with GCC; see the file COPYING3.  If not see\n static bitmap decomposable_context;\n \n /* Bit N in this bitmap is set if regno N is used in a context in\n-   which it can not be decomposed.  */\n+   which it cannot be decomposed.  */\n static bitmap non_decomposable_context;\n \n /* Bit N in this bitmap is set if regno N is used in a subreg\n@@ -561,7 +561,7 @@ find_decomposable_subregs (rtx *loc, enum classify_move_insn *pcmi)\n \t     the register.\n \n \t     If this is not a simple copy from one location to another,\n-\t     then we can not decompose this register.  If this is a simple\n+\t     then we cannot decompose this register.  If this is a simple\n \t     copy we want to decompose, and the mode is right,\n \t     then we mark the register as decomposable.\n \t     Otherwise we don't say anything about this register --\n@@ -982,7 +982,7 @@ resolve_simple_move (rtx set, rtx_insn *insn)\n   /* It's possible for the code to use a subreg of a decomposed\n      register while forming an address.  We need to handle that before\n      passing the address to emit_move_insn.  We pass NULL_RTX as the\n-     insn parameter to resolve_subreg_use because we can not validate\n+     insn parameter to resolve_subreg_use because we cannot validate\n      the insn yet.  */\n   if (MEM_P (src) || MEM_P (dest))\n     {"}, {"sha": "131280452463d2bcefb529e0aa38f6bcc81b7133", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -564,7 +564,7 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n \t\t\t\t    lra_reg_info[conflict_regno].biggest_mode);\n \t  /* Remember about multi-register pseudos.  For example, 2\n \t     hard register pseudos can start on the same hard register\n-\t     but can not start on HR and HR+1/HR-1.  */\n+\t     but cannot start on HR and HR+1/HR-1.  */\n \t  for (hr = conflict_hr + 1;\n \t       hr < FIRST_PSEUDO_REGISTER && hr < conflict_hr + nregs;\n \t       hr++)\n@@ -634,7 +634,7 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n \t\t\t\t     PSEUDO_REGNO_MODE (regno), hard_regno)\n \t  && targetm.hard_regno_mode_ok (hard_regno,\n \t\t\t\t\t PSEUDO_REGNO_MODE (regno))\n-\t  /* We can not use prohibited_class_mode_regs for all classes\n+\t  /* We cannot use prohibited_class_mode_regs for all classes\n \t     because it is not defined for all classes.  */\n \t  && (ira_allocno_class_translate[rclass] != rclass\n \t      || ! TEST_HARD_REG_BIT (ira_prohibited_class_mode_regs\n@@ -785,7 +785,7 @@ lra_setup_reg_renumber (int regno, int hard_regno, bool print_p)\n {\n   int i, hr;\n \n-  /* We can not just reassign hard register.  */\n+  /* We cannot just reassign hard register.  */\n   lra_assert (hard_regno < 0 || reg_renumber[regno] < 0);\n   if ((hr = hard_regno) < 0)\n     hr = reg_renumber[regno];\n@@ -1434,7 +1434,7 @@ assign_by_spills (void)\n \t  fails_p = nfails != 0;\n \t  break;\n \t}\n-      /* This is a very rare event.  We can not assign a hard register\n+      /* This is a very rare event.  We cannot assign a hard register\n \t to reload pseudo because the hard register was assigned to\n \t another reload pseudo on a previous assignment pass.  For x86\n \t example, on the 1st pass we assigned CX (although another"}, {"sha": "e3b5ddb52269c250e6d445db30c9e5c8a9d21507", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -985,7 +985,7 @@ match_reload (signed char out, signed char *ins, signed char *outs,\n \t operand (\"a\").  \"b\" must then be copied into a new register\n \t so that it doesn't clobber the current value of \"a\".\n \n-\t We can not use the same value if the output pseudo is\n+\t We cannot use the same value if the output pseudo is\n \t early clobbered or the input pseudo is mentioned in the\n \t output, e.g. as an address part in memory, because\n \t output reload will actually extend the pseudo liveness.\n@@ -1880,7 +1880,7 @@ update_and_check_small_class_inputs (int nop, enum reg_class op_class)\n /* Major function to choose the current insn alternative and what\n    operands should be reloaded and how.\t If ONLY_ALTERNATIVE is not\n    negative we should consider only this alternative.  Return false if\n-   we can not choose the alternative or find how to reload the\n+   we cannot choose the alternative or find how to reload the\n    operands.  */\n static bool\n process_alt_operands (int only_alternative)\n@@ -2638,7 +2638,7 @@ process_alt_operands (int only_alternative)\n \t\t  goto fail;\n \t\t}\n \n-\t      /* Alternative loses if it required class pseudo can not\n+\t      /* Alternative loses if it required class pseudo cannot\n \t\t hold value of required mode.  Such insns can be\n \t\t described by insn definitions with mode iterators.  */\n \t      if (GET_MODE (*curr_id->operand_loc[nop]) != VOIDmode\n@@ -2662,7 +2662,7 @@ process_alt_operands (int only_alternative)\n \t\t  if (lra_dump_file != NULL)\n \t\t    fprintf (lra_dump_file,\n \t\t\t     \"            alt=%d: reload pseudo for op %d \"\n-\t\t\t     \" can not hold the mode value -- refuse\\n\",\n+\t\t\t     \" cannot hold the mode value -- refuse\\n\",\n \t\t\t     nalt, nop);\n \t\t  goto fail;\n \t\t}\n@@ -4008,7 +4008,7 @@ curr_insn_transform (bool check_only_p)\n       if (sec_mode != rld_mode)\n         {\n \t  /* If the target says specifically to use another mode for\n-\t     secondary memory moves we can not reuse the original\n+\t     secondary memory moves we cannot reuse the original\n \t     insn.  */\n \t  after = emit_spill_move (false, new_reg, dest);\n \t  lra_process_new_insns (curr_insn, NULL, after,\n@@ -4767,7 +4767,7 @@ lra_constraints (bool first_p)\n \t  {\n \t    bool pseudo_p = contains_reg_p (x, false, false);\n \n-\t    /* After RTL transformation, we can not guarantee that\n+\t    /* After RTL transformation, we cannot guarantee that\n \t       pseudo in the substitution was not reloaded which might\n \t       make equivalence invalid.  For example, in reverse\n \t       equiv of p0\n@@ -4800,7 +4800,7 @@ lra_constraints (bool first_p)\n \t\t|| (! reverse_equiv_p (i)\n \t\t    && (init_insn_rhs_dead_pseudo_p (i)\n \t\t\t/* If we reloaded the pseudo in an equivalence\n-\t\t\t   init insn, we can not remove the equiv init\n+\t\t\t   init insn, we cannot remove the equiv init\n \t\t\t   insns and the init insns might write into\n \t\t\t   const memory in this case.  */\n \t\t\t|| contains_reloaded_insn_p (i)))\n@@ -4882,7 +4882,7 @@ lra_constraints (bool first_p)\n \t      if ((REG_P (dest_reg)\n \t\t   && (x = get_equiv (dest_reg)) != dest_reg\n \t\t   /* Remove insns which set up a pseudo whose value\n-\t\t      can not be changed.  Such insns might be not in\n+\t\t      cannot be changed.  Such insns might be not in\n \t\t      init_insns because we don't update equiv data\n \t\t      during insn transformations.\n \t\t      \n@@ -5195,7 +5195,7 @@ check_secondary_memory_needed_p (enum reg_class inher_cl ATTRIBUTE_UNUSED,\n    (inheritance/split pseudos and original registers).\t*/\n static bitmap_head check_only_regs;\n \n-/* Reload pseudos can not be involded in invariant inheritance in the\n+/* Reload pseudos cannot be involded in invariant inheritance in the\n    current EBB.  */\n static bitmap_head invalid_invariant_regs;\n \n@@ -6316,12 +6316,12 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t\t      /* Don't do inheritance if the pseudo is also\n \t\t\t used in the insn.  */\n \t\t      if (r == NULL)\n-\t\t\t/* We can not do inheritance right now\n+\t\t\t/* We cannot do inheritance right now\n \t\t\t   because the current insn reg info (chain\n \t\t\t   regs) can change after that.  */\n \t\t\tadd_to_inherit (dst_regno, next_usage_insns);\n \t\t    }\n-\t\t  /* We can not process one reg twice here because of\n+\t\t  /* We cannot process one reg twice here because of\n \t\t     usage_insns invalidation.  */\n \t\t  if ((dst_regno < FIRST_PSEUDO_REGISTER\n \t\t       || reg_renumber[dst_regno] >= 0)\n@@ -6741,7 +6741,7 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n   bool change_p, done_p;\n \n   change_p = ! bitmap_empty_p (remove_pseudos);\n-  /* We can not finish the function right away if CHANGE_P is true\n+  /* We cannot finish the function right away if CHANGE_P is true\n      because we need to marks insns affected by previous\n      inheritance/split pass for processing by the subsequent\n      constraint pass.  */\n@@ -6782,7 +6782,7 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n \t\t{\n \t\t  /* reload pseudo <- invariant inheritance pseudo */\n \t\t  start_sequence ();\n-\t\t  /* We can not just change the source.  It might be\n+\t\t  /* We cannot just change the source.  It might be\n \t\t     an insn different from the move.  */\n \t\t  emit_insn (lra_reg_info[sregno].restore_rtx);\n \t\t  rtx_insn *new_insns = get_insns ();"}, {"sha": "ee9fd51f129d2cef1a2766d6bdf0345f906cdf0c", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1109,7 +1109,7 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,\n \t    {\n \t      /* If we are assigning to a hard register that can be\n \t\t eliminated, it must be as part of a PARALLEL, since\n-\t\t the code above handles single SETs.  This reg can not\n+\t\t the code above handles single SETs.  This reg cannot\n \t\t be longer eliminated -- it is forced by\n \t\t mark_not_eliminable.  */\n \t      for (ep = reg_eliminate;\n@@ -1236,7 +1236,7 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n \t\t     \"\tElimination %d to %d is not possible anymore\\n\",\n \t\t     ep->from, ep->to);\n \t  /* If after processing RTL we decides that SP can be used as\n-\t     a result of elimination, it can not be changed.  */\n+\t     a result of elimination, it cannot be changed.  */\n \t  gcc_assert ((ep->to_rtx != stack_pointer_rtx)\n \t\t      || (ep->from < FIRST_PSEUDO_REGISTER\n \t\t\t  && fixed_regs [ep->from]));"}, {"sha": "a00ec389bf9dee72570ce52e2af67a2dd80a5868", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1073,7 +1073,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t      /* We should create a conflict of PIC pseudo with PIC\n \t\t hard reg as PIC hard reg can have a wrong value after\n \t\t jump described by the abnormal edge.  In this case we\n-\t\t can not allocate PIC hard reg to PIC pseudo as PIC\n+\t\t cannot allocate PIC hard reg to PIC pseudo as PIC\n \t\t pseudo will also have a wrong value.  */\n \t      || (px == REAL_PIC_OFFSET_TABLE_REGNUM\n \t\t  && pic_offset_table_rtx != NULL_RTX"}, {"sha": "8dde7d20904bbeb13dccdb9246bc932a0a5cb9d2", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -253,7 +253,7 @@ finish_cand_table (void)\n \n \f\n \n-/* Return true if X contains memory or some UNSPEC.  We can not just\n+/* Return true if X contains memory or some UNSPEC.  We cannot just\n    check insn operands as memory or unspec might be not an operand\n    itself but contain an operand.  Insn with memory access is not\n    profitable for rematerialization.  Rematerialization of UNSPEC\n@@ -287,7 +287,7 @@ bad_for_rematerialization_p (rtx x)\n   return false;\n }\n \n-/* If INSN can not be used for rematerialization, return negative\n+/* If INSN cannot be used for rematerialization, return negative\n    value.  If INSN can be considered as a candidate for\n    rematerialization, return value which is the operand number of the\n    pseudo for which the insn can be used for rematerialization.  Here\n@@ -306,10 +306,10 @@ operand_to_remat (rtx_insn *insn)\n   /* First find a pseudo which can be rematerialized.  */\n   for (reg = id->regs; reg != NULL; reg = reg->next)\n     {\n-      /* True FRAME_POINTER_NEEDED might be because we can not follow\n+      /* True FRAME_POINTER_NEEDED might be because we cannot follow\n \t changing sp offsets, e.g. alloca is used.  If the insn contains\n-\t stack pointer in such case, we can not rematerialize it as we\n-\t can not know sp offset at a rematerialization place.  */\n+\t stack pointer in such case, we cannot rematerialize it as we\n+\t cannot know sp offset at a rematerialization place.  */\n       if (reg->regno == STACK_POINTER_REGNUM && frame_pointer_needed)\n \treturn -1;\n       else if (reg->type == OP_OUT && ! reg->subreg_p"}, {"sha": "c19b76a579cf7285096031db1801059c6d578c7a", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -232,7 +232,7 @@ assign_spill_hard_regs (int *pseudo_regnos, int n)\n   basic_block bb;\n   HARD_REG_SET conflict_hard_regs;\n   bitmap setjump_crosses = regstat_get_setjmp_crosses ();\n-  /* Hard registers which can not be used for any purpose at given\n+  /* Hard registers which cannot be used for any purpose at given\n      program point because they are unallocatable or already allocated\n      for other pseudos.\t */\n   HARD_REG_SET *reserved_hard_regs;"}, {"sha": "592b9908597cd9adc50fd8420eaf894b6403bf5e", "filename": "gcc/lra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -881,7 +881,7 @@ collect_non_operand_hard_regs (rtx_insn *insn, rtx *x,\n \t      }\n \t  if (curr == NULL)\n \t    {\n-\t      /* This is a new hard regno or the info can not be\n+\t      /* This is a new hard regno or the info cannot be\n \t\t integrated into the found structure.\t */\n #ifdef STACK_REGS\n \t      early_clobber\n@@ -1495,7 +1495,7 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n \t    if (curr->regno == regno)\n \t      {\n \t\tif (curr->subreg_p != subreg_p || curr->biggest_mode != mode)\n-\t\t  /* The info can not be integrated into the found\n+\t\t  /* The info cannot be integrated into the found\n \t\t     structure.  */\n \t\t  data->regs = new_insn_reg (data->insn, regno, type, mode,\n \t\t\t\t\t     subreg_p, early_clobber,"}, {"sha": "b941c76a8781443e6082b08ac8a73023a13101c0", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -421,7 +421,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   if (boundary_p && node->analyzed\n       && node->get_partitioning_class () == SYMBOL_PARTITION)\n     {\n-      /* Inline clones can not be part of boundary.  \n+      /* Inline clones cannot be part of boundary.  \n          gcc_assert (!node->global.inlined_to);  \n \n \t FIXME: At the moment they can be, when partition contains an inline"}, {"sha": "b26c883b732562636f80a2737004feff5d539e91", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -857,7 +857,7 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n       /* TYPE_CANONICAL is re-computed during type merging, so no need\n \t to follow it here.  */\n       /* Do not stream TYPE_STUB_DECL; it is not needed by LTO but currently\n-\t it can not be freed by free_lang_data without triggering ICEs in\n+\t it cannot be freed by free_lang_data without triggering ICEs in\n \t langhooks.  */\n     }\n "}, {"sha": "6b183df3b0f2f3c49b3185a102ee95c9428d024e", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,11 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* lto-partition.c: Mechanically replace \"can not\" with \"cannot\".\n+\t* lto-symtab.c: Likewise.\n+\t* lto.c: Likewise.\n+\n 2019-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "6972e6e9ef3bab0b9434ede1e9f56d8200cdb409", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -250,14 +250,14 @@ add_symbol_to_partition (ltrans_partition part, symtab_node *node)\n {\n   symtab_node *node1;\n \n-  /* Verify that we do not try to duplicate something that can not be.  */\n+  /* Verify that we do not try to duplicate something that cannot be.  */\n   gcc_checking_assert (node->get_partitioning_class () == SYMBOL_DUPLICATE\n \t\t       || !symbol_partitioned_p (node));\n \n   while ((node1 = contained_in_symbol (node)) != node)\n     node = node1;\n \n-  /* If we have duplicated symbol contained in something we can not duplicate,\n+  /* If we have duplicated symbol contained in something we cannot duplicate,\n      we are very badly screwed.  The other way is possible, so we do not\n      assert this in add_symbol_to_partition_1. \n \n@@ -1093,7 +1093,7 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node *node)\n     return;\n \n   /* Now walk symbols sharing the same name and see if there are any conflicts.\n-     (all types of symbols counts here, since we can not have static of the\n+     (all types of symbols counts here, since we cannot have static of the\n      same name as external or public symbol.)  */\n   for (s = symtab_node::get_for_asmname (name);\n        s; s = s->next_sharing_asm_name)"}, {"sha": "22da4c78b8cdfbd4c50ea554d679aa1d2b580947", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -240,7 +240,7 @@ warn_type_compatibility_p (tree prevailing_type, tree type,\n   prevailing_type = TYPE_MAIN_VARIANT (prevailing_type);\n   type = TYPE_MAIN_VARIANT (type);\n \n-  /* We can not use types_compatible_p because we permit some changes\n+  /* We cannot use types_compatible_p because we permit some changes\n      across types.  For example unsigned size_t and \"signed size_t\" may be\n      compatible when merging C and Fortran types.  */\n   if (COMPLETE_TYPE_P (prevailing_type)"}, {"sha": "bb332f8221c87a05a41f168be7409787508a4dab", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -290,7 +290,7 @@ hash_canonical_type (tree type)\n   enum tree_code code;\n \n   /* We compute alias sets only for types that needs them.\n-     Be sure we do not recurse to something else as we can not hash incomplete\n+     Be sure we do not recurse to something else as we cannot hash incomplete\n      types in a way they would have same hash value as compatible complete\n      types.  */\n   gcc_checking_assert (type_with_alias_set_p (type));"}, {"sha": "aa81466fdcbcb9c2154e8de6f61b97bb0b76e6ef", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,9 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* objc-act.c: Mechanically replace \"can not\" with \"cannot\".\n+\n 2019-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "777225e9154589f06f66cfff4f94763de87f6b31", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -907,7 +907,7 @@ objc_add_property_declaration (location_t location, tree decl,\n \n   if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n     {\n-      error_at (location, \"property can not be an array\");\n+      error_at (location, \"property cannot be an array\");\n       return;\n     }\n \n@@ -922,10 +922,10 @@ objc_add_property_declaration (location_t location, tree decl,\n \t describe a pair of accessor methods, so its type (which is\n \t the type of the return value of the getter and the first\n \t argument of the setter) can't be a bitfield (as return values\n-\t and arguments of functions can not be bitfields).  The\n+\t and arguments of functions cannot be bitfields).  The\n \t underlying instance variable could be a bitfield, but that is\n \t a different matter.  */\n-      error_at (location, \"property can not be a bit-field\");\n+      error_at (location, \"property cannot be a bit-field\");\n       return;\n     }\n #endif\n@@ -1743,7 +1743,7 @@ objc_build_setter_call (tree lhs, tree rhs)\n \n   if (PROPERTY_READONLY (property_decl))\n     {\n-      error (\"readonly property can not be set\");\n+      error (\"readonly property cannot be set\");\n       return error_mark_node;\n     }\n   else\n@@ -2053,7 +2053,7 @@ objc_start_method_definition (bool is_class_method, tree decl, tree attributes,\n #endif\n \n   if (attributes)\n-    warning_at (input_location, 0, \"method attributes can not be specified in @implementation context\");\n+    warning_at (input_location, 0, \"method attributes cannot be specified in @implementation context\");\n   else\n     objc_decl_method_attributes (&decl, attributes, 0);\n \n@@ -4210,7 +4210,7 @@ objc_begin_catch_clause (tree decl)\n   else if (TYPE_HAS_OBJC_INFO (TREE_TYPE (type))\n \t   && TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (type)))\n     {\n-      error (\"@catch parameter can not be protocol-qualified\");\n+      error (\"@catch parameter cannot be protocol-qualified\");\n       type = error_mark_node;\n     }\n   else if (POINTER_TYPE_P (type) && objc_is_object_id (TREE_TYPE (type)))\n@@ -4677,7 +4677,7 @@ adjust_type_for_id_default (tree type)\n     TREE_VALUE (type) = objc_object_type;\n   else if (TREE_CODE (TREE_VALUE (type)) == RECORD_TYPE\n \t   && TYPED_OBJECT (TREE_VALUE (type)))\n-    error (\"can not use an object as parameter to a method\");\n+    error (\"cannot use an object as parameter to a method\");\n \n   return type;\n }\n@@ -7225,7 +7225,7 @@ objc_synthesize_getter (tree klass, tree class_methods ATTRIBUTE_UNUSED, tree pr\n \t  {\n \t    /* This should never happen.  */\n \t    error_at (location,\n-\t\t      \"can not find instance variable associated with property\");\n+\t\t      \"cannot find instance variable associated with property\");\n \t    ret_val = error_mark_node;\n \t    break;\n \t  }\n@@ -7421,7 +7421,7 @@ objc_synthesize_setter (tree klass, tree class_methods ATTRIBUTE_UNUSED, tree pr\n \tif (!ivar || is_private (ivar))\n \t  {\n \t    error_at (location,\n-\t\t      \"can not find instance variable associated with property\");\n+\t\t      \"cannot find instance variable associated with property\");\n \t    statement = error_mark_node;\n \t    break;\n \t  }\n@@ -7727,7 +7727,7 @@ objc_add_synthesize_declaration (location_t location, tree property_and_ivar_lis\n \n   if (TREE_CODE (objc_implementation_context) == CATEGORY_IMPLEMENTATION_TYPE)\n     {\n-      error_at (location, \"%<@synthesize%> can not be used in categories\");\n+      error_at (location, \"%<@synthesize%> cannot be used in categories\");\n       return;\n     }\n "}, {"sha": "a165351ca961fdbc26c9e3c08d15f86e729e7a23", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1392,7 +1392,7 @@ gcse_after_reload_main (rtx f ATTRIBUTE_UNUSED)\n \t increase the number of redundant loads found.  So compute transparency\n \t information for each memory expression in the hash table.  */\n       df_analyze ();\n-      /* This can not be part of the normal allocation routine because\n+      /* This cannot be part of the normal allocation routine because\n \t we have to know the number of elements in the hash table.  */\n       transp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n \t\t\t\t     expr_table->elements ());"}, {"sha": "43ee91a5b13993a46aff9aaba3155d6e36e5c74b", "filename": "gcc/predict.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -826,7 +826,7 @@ unlikely_executed_bb_p (basic_block bb)\n   return false;\n }\n \n-/* We can not predict the probabilities of outgoing edges of bb.  Set them\n+/* We cannot predict the probabilities of outgoing edges of bb.  Set them\n    evenly and hope for the best.  If UNLIKELY_EDGES is not null, distribute\n    even probability for all edges not mentioned in the set.  These edges\n    are given PROB_VERY_UNLIKELY probability.  Similarly for LIKELY_EDGES,\n@@ -4266,7 +4266,7 @@ report_predictor_hitrates (void)\n    we are not 100% sure.\n \n    This function locally updates profile without attempt to keep global\n-   consistency which can not be reached in full generality without full profile\n+   consistency which cannot be reached in full generality without full profile\n    rebuild from probabilities alone.  Doing so is not necessarily a good idea\n    because frequencies and counts may be more realistic then probabilities.\n \n@@ -4344,7 +4344,7 @@ force_edge_cold (edge e, bool impossible)\n \t{\n \t  if (impossible)\n \t    e->probability = profile_probability::never ();\n-\t  /* If BB has some edges out that are not impossible, we can not\n+\t  /* If BB has some edges out that are not impossible, we cannot\n \t     assume that BB itself is.  */\n \t  impossible = false;\n \t}"}, {"sha": "06564ddf4bd32d8ceaf631a1cebd9326027df04d", "filename": "gcc/profile-count.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -30,7 +30,7 @@ enum profile_quality {\n   /* Uninitialized value.  */\n   profile_uninitialized,\n   /* Profile is based on static branch prediction heuristics and may\n-     or may not match reality.  It is local to function and can not be compared\n+     or may not match reality.  It is local to function and cannot be compared\n      inter-procedurally.  Never used by probabilities (they are always local).\n    */\n   profile_guessed_local,\n@@ -539,7 +539,7 @@ class GTY((user)) profile_probability\n     }\n \n   /* Comparsions are three-state and conservative.  False is returned if\n-     the inequality can not be decided.  */\n+     the inequality cannot be decided.  */\n   bool operator< (const profile_probability &other) const\n     {\n       return initialized_p () && other.initialized_p () && m_val < other.m_val;\n@@ -596,7 +596,7 @@ class GTY((user)) profile_probability\n         was never run in train feedback) but they hold local static profile\n         estimate.\n \n-   Counters of type 1 and 3 can not be mixed with counters of different type\n+   Counters of type 1 and 3 cannot be mixed with counters of different type\n    within operation (because whole function should use one type of counter)\n    with exception that global zero mix in most operations where outcome is\n    well defined.\n@@ -829,7 +829,7 @@ class GTY(()) profile_count\n     }\n \n   /* Comparsions are three-state and conservative.  False is returned if\n-     the inequality can not be decided.  */\n+     the inequality cannot be decided.  */\n   bool operator< (const profile_count &other) const\n     {\n       if (!initialized_p () || !other.initialized_p ())"}, {"sha": "a1dba1ac8fb8cacca700b956d15db84988476fe8", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1218,7 +1218,7 @@ branch_prob (bool thunk)\n      various transformations.  */\n   if (thunk)\n     {\n-      /* At stream in time we do not have CFG, so we can not do checksums.  */\n+      /* At stream in time we do not have CFG, so we cannot do checksums.  */\n       cfg_checksum = 0;\n       lineno_checksum = 0;\n     }"}, {"sha": "d0c498fced2834205306a8d2bea807fd3786c3cc", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2967,7 +2967,7 @@ split_all_insns (void)\n \n \t     If that happens and INSN was the last reference to the\n \t     given EH region, then the EH region will become unreachable.\n-\t     We can not leave the unreachable blocks in the CFG as that\n+\t     We cannot leave the unreachable blocks in the CFG as that\n \t     will trigger a checking failure.\n \n \t     So track if INSN has a REG_EH_REGION note.  If so and we"}, {"sha": "e23e607a5e1418c4bc20cc8a878c83b855065518", "filename": "gcc/ree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1206,7 +1206,7 @@ add_removable_extension (const_rtx expr, rtx_insn *insn,\n \n       /* Fourth, if the extended version occupies more registers than the\n \t original and the source of the extension is the same hard register\n-\t as the destination of the extension, then we can not eliminate\n+\t as the destination of the extension, then we cannot eliminate\n \t the extension without deep analysis, so just punt.\n \n \t We allow this when the registers are different because the"}, {"sha": "3ad11a81ec5e576a510f6100d2eb54aa1faf8e31", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -408,7 +408,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \n      The convention is that secondary input reloads are valid only if the\n      secondary_class is different from class.  If you have such a case, you\n-     can not use secondary reloads, you must work around the problem some\n+     cannot use secondary reloads, you must work around the problem some\n      other way.\n \n      Allow this when a reload_in/out pattern is being used.  I.e. assume\n@@ -6528,7 +6528,7 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n       || GET_RTX_CLASS (GET_CODE (x)) == RTX_AUTOINC)\n     x = XEXP (x, 0);\n \n-  /* If either argument is a constant, then modifying X can not affect IN.  */\n+  /* If either argument is a constant, then modifying X cannot affect IN.  */\n   if (CONSTANT_P (x) || CONSTANT_P (in))\n     return 0;\n   else if (GET_CODE (x) == SUBREG && MEM_P (SUBREG_REG (x)))"}, {"sha": "9e4429f36cb8a4c13cb1df3bd86623a934a38614", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -6048,7 +6048,7 @@ reload_reg_free_for_value_p (int start_regno, int regno, int opnum,\n    RELOADNUM is the number of the reload we want to load this value for;\n    a reload does not conflict with itself.\n \n-   When IGNORE_ADDRESS_RELOADS is set, we can not have conflicts with\n+   When IGNORE_ADDRESS_RELOADS is set, we cannot have conflicts with\n    reloads that load an address for the very reload we are considering.\n \n    The caller has to make sure that there is no conflict with the return\n@@ -8764,9 +8764,9 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n     emit_insn (gen_rtx_SET (out, in));\n \n   /* Return the first insn emitted.\n-     We can not just return get_last_insn, because there may have\n+     We cannot just return get_last_insn, because there may have\n      been multiple instructions emitted.  Also note that gen_move_insn may\n-     emit more than one insn itself, so we can not assume that there is one\n+     emit more than one insn itself, so we cannot assume that there is one\n      insn emitted per emit_insn_before call.  */\n \n   return last ? NEXT_INSN (last) : get_insns ();"}, {"sha": "d2b565438e72a91745511cb33b586fb79d23f2ec", "filename": "gcc/reorg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1064,9 +1064,9 @@ steal_delay_list_from_target (rtx_insn *insn, rtx condition, rtx_sequence *seq,\n      ??? It may be possible to move other sets into INSN in addition to\n      moving the instructions in the delay slots.\n \n-     We can not steal the delay list if one of the instructions in the\n+     We cannot steal the delay list if one of the instructions in the\n      current delay_list modifies the condition codes and the jump in the\n-     sequence is a conditional jump. We can not do this because we can\n+     sequence is a conditional jump. We cannot do this because we can\n      not change the direction of the jump because the condition codes\n      will effect the direction of the jump in the sequence.  */\n "}, {"sha": "f8a23ed9f58bb25de2106b25ad7bc2095798517b", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -265,7 +265,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n       res->volatil |= MEM_VOLATILE_P (x);\n \n       /* For all ASM_OPERANDS, we must traverse the vector of input operands.\n-\t We can not just fall through here since then we would be confused\n+\t We cannot just fall through here since then we would be confused\n \t by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate\n \t traditional asms unlike their normal usage.  */\n \n@@ -817,7 +817,7 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n       res->volatil |= MEM_VOLATILE_P (x);\n \n       /* For all ASM_OPERANDS, we must traverse the vector of input operands.\n-\t We can not just fall through here since then we would be confused\n+\t We cannot just fall through here since then we would be confused\n \t by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate\n \t traditional asms unlike their normal usage.  */\n "}, {"sha": "f4c9d946cb5aedb74b4cc9181987762151231855", "filename": "gcc/rtl.def", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -298,7 +298,7 @@ DEF_RTL_EXPR(SET, \"set\", \"ee\", RTX_EXTRA)\n    For example, subroutine calls will use the register\n    in which the static chain is passed.\n \n-   USE can not appear as an operand of other rtx except for PARALLEL.\n+   USE cannot appear as an operand of other rtx except for PARALLEL.\n    USE is not deletable, as it indicates that the operand\n    is used in some unknown way.  */\n DEF_RTL_EXPR(USE, \"use\", \"e\", RTX_EXTRA)\n@@ -307,7 +307,7 @@ DEF_RTL_EXPR(USE, \"use\", \"e\", RTX_EXTRA)\n    For example, subroutine calls will clobber some physical registers\n    (the ones that are by convention not saved).\n \n-   CLOBBER can not appear as an operand of other rtx except for PARALLEL.\n+   CLOBBER cannot appear as an operand of other rtx except for PARALLEL.\n    CLOBBER of a hard register appearing by itself (not within PARALLEL)\n    is considered undeletable before reload.  */\n DEF_RTL_EXPR(CLOBBER, \"clobber\", \"e\", RTX_EXTRA)\n@@ -683,7 +683,7 @@ DEF_RTL_EXPR(PARITY, \"parity\", \"e\", RTX_UNARY)\n    operand 2 counts from the msb of the memory unit.\n    Otherwise, the first bit is the lsb and operand 2 counts from\n    the lsb of the memory unit.\n-   This kind of expression can not appear as an lvalue in RTL.  */\n+   This kind of expression cannot appear as an lvalue in RTL.  */\n DEF_RTL_EXPR(SIGN_EXTRACT, \"sign_extract\", \"eee\", RTX_BITFIELD_OPS)\n \n /* Similar for unsigned bit-field.\n@@ -1079,7 +1079,7 @@ DEF_RTL_EXPR(DEFINE_CPU_UNIT, \"define_cpu_unit\", \"sS\", RTX_EXTRA)\n DEF_RTL_EXPR(DEFINE_QUERY_CPU_UNIT, \"define_query_cpu_unit\", \"sS\", RTX_EXTRA)\n \n /* (exclusion_set string string) means that each CPU functional unit\n-   in the first string can not be reserved simultaneously with any\n+   in the first string cannot be reserved simultaneously with any\n    unit whose name is in the second string and vise versa.  CPU units\n    in the string are separated by commas.  For example, it is useful\n    for description CPU with fully pipelined floating point functional\n@@ -1089,7 +1089,7 @@ DEF_RTL_EXPR(DEFINE_QUERY_CPU_UNIT, \"define_query_cpu_unit\", \"sS\", RTX_EXTRA)\n DEF_RTL_EXPR(EXCLUSION_SET, \"exclusion_set\", \"ss\", RTX_EXTRA)\n \n /* (presence_set string string) means that each CPU functional unit in\n-   the first string can not be reserved unless at least one of pattern\n+   the first string cannot be reserved unless at least one of pattern\n    of units whose names are in the second string is reserved.  This is\n    an asymmetric relation.  CPU units or unit patterns in the strings\n    are separated by commas.  Pattern is one unit name or unit names\n@@ -1139,13 +1139,13 @@ DEF_RTL_EXPR(FINAL_PRESENCE_SET, \"final_presence_set\", \"ss\", RTX_EXTRA)\n    are separated by commas.  Pattern is one unit name or unit names\n    separated by white-spaces.\n \n-   For example, it is useful for description that slot0 can not be\n+   For example, it is useful for description that slot0 cannot be\n    reserved after slot1 or slot2 reservation for a VLIW processor.  We\n    could describe it by the following construction\n \n       (absence_set \"slot2\" \"slot0, slot1\")\n \n-   Or slot2 can not be reserved if slot0 and unit b0 are reserved or\n+   Or slot2 cannot be reserved if slot0 and unit b0 are reserved or\n    slot1 and unit b1 are reserved .  In this case we could write\n \n       (absence_set \"slot2\" \"slot0 b0, slot1 b1\")"}, {"sha": "70891e6e364671b80419bab448c685b35cc8ff64", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1629,7 +1629,7 @@ extern const char * const reg_note_name[];\n    are passed to the function.\n      CLOBBER expressions document the registers explicitly clobbered\n    by this CALL_INSN.\n-     Pseudo registers can not be mentioned in this list.  */\n+     Pseudo registers cannot be mentioned in this list.  */\n #define CALL_INSN_FUNCTION_USAGE(INSN)\tXEXP(INSN, 7)\n \n /* The label-number of a code-label.  The assembler label"}, {"sha": "401c38fe0e2944967e538d705dbbf67a78ccdbd7", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1806,7 +1806,7 @@ reg_overlap_mentioned_p (const_rtx x, const_rtx in)\n {\n   unsigned int regno, endregno;\n \n-  /* If either argument is a constant, then modifying X can not\n+  /* If either argument is a constant, then modifying X cannot\n      affect IN.  Here we look at IN, we can profitably combine\n      CONSTANT_P (x) with the switch statement below.  */\n   if (CONSTANT_P (in))"}, {"sha": "a9e934d7fa054d5b00bb7a97911a51e5e93d134f", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2770,7 +2770,7 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t  reg_pending_barrier = TRUE_BARRIER;\n \n \t/* For all ASM_OPERANDS, we must traverse the vector of input operands.\n-\t   We can not just fall through here since then we would be confused\n+\t   We cannot just fall through here since then we would be confused\n \t   by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate\n \t   traditional asms unlike their normal usage.  */\n \n@@ -4602,7 +4602,7 @@ check_dep (dep_t dep, bool relaxed_p)\n \t\t&& (ds & DEP_CONTROL)\n \t\t&& !(ds & (DEP_OUTPUT | DEP_ANTI | DEP_TRUE)));\n \n-  /* HARD_DEP can not appear in dep_status of a link.  */\n+  /* HARD_DEP cannot appear in dep_status of a link.  */\n   gcc_assert (!(ds & HARD_DEP));\n \n   /* Check that dependence status is set correctly when speculation is not"}, {"sha": "4875eef96a83d0d4e69c8d6e4209221ae402a30f", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -419,7 +419,7 @@ add_deps_for_risky_insns (rtx_insn *head, rtx_insn *tail)\n \t    case PRISKY_CANDIDATE:\n \t      /* ??? We could implement better checking PRISKY_CANDIDATEs\n \t\t analogous to sched-rgn.c.  */\n-\t      /* We can not change the mode of the backward\n+\t      /* We cannot change the mode of the backward\n \t\t dependency because REG_DEP_ANTI has the lowest\n \t\t rank.  */\n \t      if (! sched_insns_conditions_mutex_p (insn, prev))"}, {"sha": "83688b3c9c42d86215d45dc272adef15adfb318b", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -927,7 +927,7 @@ haifa_find_rgns (void)\n \t     The algorithm in the DFS traversal may not mark B & D as part\n \t     of the loop (i.e. they will not have max_hdr set to A).\n \n-\t     We know they can not be loop latches (else they would have\n+\t     We know they cannot be loop latches (else they would have\n \t     had max_hdr set since they'd have a backedge to a dominator\n \t     block).  So we don't need them on the initial queue.\n "}, {"sha": "e8e508ef69213ddf10b66f99939969b686375bec", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -3782,7 +3782,7 @@ maybe_tidy_empty_bb (basic_block bb)\n \n           if (!(e->flags & EDGE_FALLTHRU))\n             {\n-\t      /* We can not invalidate computed topological order by moving\n+\t      /* We cannot invalidate computed topological order by moving\n \t         the edge destination block (E->SUCC) along a fallthru edge.\n \n \t\t We will update dominators here only when we'll get"}, {"sha": "bf4b2ddca181322822ed596e41b4e8760b065d0c", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -3227,7 +3227,7 @@ get_spec_check_type_for_insn (insn_t insn, expr_t expr)\n    ORIGINAL_INSNS list.\n \n    REG_RENAME_P denotes the set of hardware registers that\n-   can not be used with renaming due to the register class restrictions,\n+   cannot be used with renaming due to the register class restrictions,\n    mode restrictions and other (the register we'll choose should be\n    compatible class with the original uses, shouldn't be in call_used_regs,\n    should be HARD_REGNO_RENAME_OK etc).\n@@ -5849,7 +5849,7 @@ maybe_emit_renaming_copy (rtx_insn *insn,\n   bool insn_emitted  = false;\n   rtx cur_reg;\n \n-  /* Bail out early when expression can not be renamed at all.  */\n+  /* Bail out early when expression cannot be renamed at all.  */\n   if (!EXPR_SEPARABLE_P (params->c_expr))\n     return false;\n "}, {"sha": "e0f55ee5e2ead956c7f15436c5361729e9bb8829", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -477,10 +477,10 @@ prepare_shrink_wrap (basic_block entry_block)\n   dead_debug_local_finish (&debug, NULL);\n }\n \n-/* Return whether basic block PRO can get the prologue.  It can not if it\n+/* Return whether basic block PRO can get the prologue.  It cannot if it\n    has incoming complex edges that need a prologue inserted (we make a new\n    block for the prologue, so those edges would need to be redirected, which\n-   does not work).  It also can not if there exist registers live on entry\n+   does not work).  It also cannot if there exist registers live on entry\n    to PRO that are clobbered by the prologue.  */\n \n static bool"}, {"sha": "83580a259f39776b14faf4ca4e73256c24797eda", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -6581,7 +6581,7 @@ simplify_subreg (machine_mode outermode, rtx op,\n \n \t  /* Propagate original regno.  We don't have any way to specify\n \t     the offset inside original regno, so do so only for lowpart.\n-\t     The information is used only by alias analysis that can not\n+\t     The information is used only by alias analysis that cannot\n \t     grog partial register anyway.  */\n \n \t  if (known_eq (subreg_lowpart_offset (outermode, innermode), byte))"}, {"sha": "c9fa16b353bc973ae8b88bf558f401a6f0278cad", "filename": "gcc/symtab.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1761,7 +1761,7 @@ symtab_node::noninterposable_alias (symtab_node *node, void *data)\n   return false;\n }\n \n-/* If node can not be overwriten by static or dynamic linker to point to\n+/* If node cannot be overwriten by static or dynamic linker to point to\n    different definition, return NODE. Otherwise look for alias with such\n    property and if none exists, introduce new one.  */\n \n@@ -1882,9 +1882,9 @@ symtab_node::get_partitioning_class (void)\n     {\n       if (alias && definition && !ultimate_alias_target ()->definition)\n \treturn SYMBOL_EXTERNAL;\n-      /* Constant pool references use local symbol names that can not\n+      /* Constant pool references use local symbol names that cannot\n          be promoted global.  We should never put into a constant pool\n-         objects that can not be duplicated across partitions.  */\n+         objects that cannot be duplicated across partitions.  */\n       if (DECL_IN_CONSTANT_POOL (decl))\n \treturn SYMBOL_DUPLICATE;\n       if (DECL_HARD_REGISTER (decl))\n@@ -1923,7 +1923,7 @@ symtab_node::nonzero_address ()\n \n \t  if (target->alias && target->weakref)\n \t    return false;\n-\t  /* We can not recurse to target::nonzero.  It is possible that the\n+\t  /* We cannot recurse to target::nonzero.  It is possible that the\n \t     target is used only via the alias.\n \t     We may walk references and look for strong use, but we do not know\n \t     if this strong use will survive to final binary, so be\n@@ -2016,7 +2016,7 @@ symtab_node::equal_address_to (symtab_node *s2, bool memory_accessed)\n   bool really_binds_local1 = binds_local1;\n   bool really_binds_local2 = binds_local2;\n \n-  /* Addresses of vtables and virtual functions can not be used by user\n+  /* Addresses of vtables and virtual functions cannot be used by user\n      code and are used only within speculation.  In this case we may make\n      symbol equivalent to its alias even if interposition may break this\n      rule.  Doing so will allow us to turn speculative inlining into\n@@ -2042,7 +2042,7 @@ symtab_node::equal_address_to (symtab_node *s2, bool memory_accessed)\n       return 1;\n     }\n \n-  /* If both symbols may resolve to NULL, we can not really prove them\n+  /* If both symbols may resolve to NULL, we cannot really prove them\n      different.  */\n   if (!memory_accessed && !nonzero_address () && !s2->nonzero_address ())\n     return -1;\n@@ -2056,7 +2056,7 @@ symtab_node::equal_address_to (symtab_node *s2, bool memory_accessed)\n     return -1;\n \n   /* If we have a non-interposale definition of at least one of the symbols\n-     and the other symbol is different, we know other unit can not interpose\n+     and the other symbol is different, we know other unit cannot interpose\n      it to the first symbol; all aliases of the definition needs to be \n      present in the current unit.  */\n   if (((really_binds_local1 || really_binds_local2)\n@@ -2147,7 +2147,7 @@ symtab_node::can_increase_alignment_p (void)\n   if (TREE_ASM_WRITTEN (target->decl))\n     return false;\n \n-  /* If target is already placed in an anchor, we can not touch its\n+  /* If target is already placed in an anchor, we cannot touch its\n      alignment.  */\n   if (DECL_RTL_SET_P (target->decl)\n       && MEM_P (DECL_RTL (target->decl))\n@@ -2342,7 +2342,7 @@ symtab_node::output_to_lto_symbol_table_p (void)\n \n  /* Ignore all references from external vars initializers - they are not really\n     part of the compilation unit until they are used by folding.  Some symbols,\n-    like references to external construction vtables can not be referred to at\n+    like references to external construction vtables cannot be referred to at\n     all.  We decide this at can_refer_decl_in_current_unit_p.  */\n  if (!definition || DECL_EXTERNAL (decl))\n     {"}, {"sha": "2aeb1ff844558beac1e431e45cf1b18a8bd20d02", "filename": "gcc/target.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2911,7 +2911,7 @@ or @code{NULL} if this is an indirect call.\\n\\\n It is not uncommon for limitations of calling conventions to prevent\\n\\\n tail calls to functions outside the current unit of translation, or\\n\\\n during PIC compilation.  The hook is used to enforce these restrictions,\\n\\\n-as the @code{sibcall} md pattern can not fail, or fall over to a\\n\\\n+as the @code{sibcall} md pattern cannot fail, or fall over to a\\n\\\n ``normal'' call.  The criteria for successful sibling call optimization\\n\\\n may vary greatly between different architectures.\",\n  bool, (tree decl, tree exp),"}, {"sha": "0acfaaed3f731bfafdb9ae4e039cc740559f8b20", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -604,7 +604,7 @@ compile_file (void)\n   invoke_plugin_callbacks (PLUGIN_FINISH_UNIT, NULL);\n \n   /* This must be at the end.  Some target ports emit end of file directives\n-     into the assembly file here, and hence we can not output anything to the\n+     into the assembly file here, and hence we cannot output anything to the\n      assembly file after this point.  */\n   targetm.asm_out.file_end ();\n \n@@ -1730,7 +1730,7 @@ process_options (void)\n       flag_stack_clash_protection = 0;\n     }\n \n-  /* We can not support -fstack-check= and -fstack-clash-protection at\n+  /* We cannot support -fstack-check= and -fstack-clash-protection at\n      the same time.  */\n   if (flag_stack_check != NO_STACK_CHECK && flag_stack_clash_protection)\n     {"}, {"sha": "2b1e9340bcebb25e73e9cb80b88fb324dbd3c2e1", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -172,7 +172,7 @@ check_target_format (tree arg)\n       || (mode == DFmode\n \t  && (rfmt == &ieee_double_format || rfmt == &mips_double_format\n \t      || rfmt == &motorola_double_format))\n-      /* For long double, we can not really check XFmode\n+      /* For long double, we cannot really check XFmode\n          which is only defined on intel platforms.\n          Candidate pre-selection using builtin function\n          code guarantees that we are checking formats"}, {"sha": "6041f4208b07e4a02df63d42001151bcd9f85da8", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2136,7 +2136,7 @@ gimple_merge_blocks (basic_block a, basic_block b)\n \t     a situation where we have a forced label in block B\n \t     However, the label at the start of block B might still be\n \t     used in other ways (think about the runtime checking for\n-\t     Fortran assigned gotos).  So we can not just delete the\n+\t     Fortran assigned gotos).  So we cannot just delete the\n \t     label.  Instead we move the label to the start of block A.  */\n \t  if (FORCED_LABEL (label))\n \t    {\n@@ -2359,7 +2359,7 @@ find_taken_edge (basic_block bb, tree val)\n   if (computed_goto_p (stmt))\n     {\n       /* Only optimize if the argument is a label, if the argument is\n-\t not a label then we can not construct a proper CFG.\n+\t not a label then we cannot construct a proper CFG.\n \n          It may be the case that we only need to allow the LABEL_REF to\n          appear inside an ADDR_EXPR, but we also allow the LABEL_REF to"}, {"sha": "d4b053d68e1396a98760060c4a9cae448635d1a5", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1682,7 +1682,7 @@ expand_complex_operations_1 (gimple_stmt_iterator *gsi)\n       ac = gimple_assign_rhs1 (stmt);\n       bc = (gimple_num_ops (stmt) > 2) ? gimple_assign_rhs2 (stmt) : NULL;\n     }\n-  /* GIMPLE_CALL can not get here.  */\n+  /* GIMPLE_CALL cannot get here.  */\n   else\n     {\n       ac = gimple_cond_lhs (stmt);"}, {"sha": "4541c955403870c3966b8131a96499d287ceb6a5", "filename": "gcc/tree-core.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -156,7 +156,7 @@ enum built_in_class {\n   BUILT_IN_NORMAL\n };\n \n-/* Last marker used for LTO stremaing of built_in_class.  We can not add it\n+/* Last marker used for LTO stremaing of built_in_class.  We cannot add it\n    to the enum since we need the enumb to fit in 2 bits.  */\n #define BUILT_IN_LAST (BUILT_IN_NORMAL + 1)\n "}, {"sha": "c8063486f2db5dcdd506e03f5cfd55ab11436b0c", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -4763,7 +4763,7 @@ verify_eh_edges (gimple *stmt)\n     {\n       if (eh_edge)\n \t{\n-\t  error (\"BB %i can not throw but has an EH edge\", bb->index);\n+\t  error (\"BB %i cannot throw but has an EH edge\", bb->index);\n \t  return true;\n \t}\n       return false;"}, {"sha": "75d1df12e1dc2389dc51e3c0e6d2290b362b966d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -615,7 +615,7 @@ remap_type (tree type, copy_body_data *id)\n static bool\n can_be_nonlocal (tree decl, copy_body_data *id)\n {\n-  /* We can not duplicate function decls.  */\n+  /* We cannot duplicate function decls.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     return true;\n \n@@ -2778,7 +2778,7 @@ copy_cfg_body (copy_body_data * id,\n \t    && bb->index != ENTRY_BLOCK\n \t    && bb->index != EXIT_BLOCK)\n \t  maybe_move_debug_stmts_to_successors (id, (basic_block) bb->aux);\n-\t/* Update call edge destinations.  This can not be done before loop\n+\t/* Update call edge destinations.  This cannot be done before loop\n \t   info is updated, because we may split basic blocks.  */\n \tif (id->transform_call_graph_edges == CB_CGE_DUPLICATE\n \t    && bb->index != ENTRY_BLOCK\n@@ -2796,7 +2796,7 @@ copy_cfg_body (copy_body_data * id,\n \tmaybe_move_debug_stmts_to_successors (id,\n \t\t\t\t\t      BASIC_BLOCK_FOR_FN (cfun, last));\n       BASIC_BLOCK_FOR_FN (cfun, last)->aux = NULL;\n-      /* Update call edge destinations.  This can not be done before loop\n+      /* Update call edge destinations.  This cannot be done before loop\n \t info is updated, because we may split basic blocks.  */\n       if (id->transform_call_graph_edges == CB_CGE_DUPLICATE)\n \tredirect_all_calls (id, BASIC_BLOCK_FOR_FN (cfun, last));\n@@ -3527,7 +3527,7 @@ copy_forbidden (struct function *fun)\n static const char *inline_forbidden_reason;\n \n /* A callback for walk_gimple_seq to handle statements.  Returns non-null\n-   iff a function can not be inlined.  Also sets the reason why. */\n+   iff a function cannot be inlined.  Also sets the reason why. */\n \n static tree\n inline_forbidden_p_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,"}, {"sha": "7df052de0cf3bd8bc8567642a39fd79de1d41a6b", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1896,7 +1896,7 @@ pg_add_dependence_edges (struct graph *rdg, int dir,\n \t      /* Be conservative.  If data references are not well analyzed,\n \t\t or the two data references have the same base address and\n \t\t offset, add dependence and consider it alias to each other.\n-\t\t In other words, the dependence can not be resolved by\n+\t\t In other words, the dependence cannot be resolved by\n \t\t runtime alias check.  */\n \t      if (!DR_BASE_ADDRESS (dr1) || !DR_BASE_ADDRESS (dr2)\n \t\t  || !DR_OFFSET (dr1) || !DR_OFFSET (dr2)\n@@ -2109,7 +2109,7 @@ build_partition_graph (struct graph *rdg,\n \n \t  /* Add edge to partition graph if there exists dependence.  There\n \t     are two types of edges.  One type edge is caused by compilation\n-\t     time known dependence, this type can not be resolved by runtime\n+\t     time known dependence, this type cannot be resolved by runtime\n \t     alias check.  The other type can be resolved by runtime alias\n \t     check.  */\n \t  if (dir == 1 || dir == 2"}, {"sha": "9f976922d5458bccbcc6efc500de262729eabebc", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -193,7 +193,7 @@ pass_nrv::execute (function *fun)\n \t      if (found != NULL)\n \t\t{\n \t\t  /* If we found a return statement using a different variable\n-\t\t     than previous return statements, then we can not perform\n+\t\t     than previous return statements, then we cannot perform\n \t\t     NRV optimizations.  */\n \t\t  if (found != rhs)\n \t\t    return 0;"}, {"sha": "5860e7c3f19789108f684f1df7cf6cc671178687", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -763,7 +763,7 @@ tree_profiling (void)\n \n       if (node->thunk.thunk_p)\n \t{\n-\t  /* We can not expand variadic thunks to Gimple.  */\n+\t  /* We cannot expand variadic thunks to Gimple.  */\n \t  if (stdarg_p (TREE_TYPE (node->decl)))\n \t    continue;\n \t  thunk = true;"}, {"sha": "e4851daaa3fe179b548ce65186843485ec5ae952", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -5430,7 +5430,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n   if (!node->local.can_change_signature)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"Function can not change signature.\\n\");\n+\tfprintf (dump_file, \"Function cannot change signature.\\n\");\n       return false;\n     }\n "}, {"sha": "10b4d3f2514f7e088391b372364594a5a4a958a2", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -202,7 +202,7 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n \treturn true;\n     }\n \n-  /* Non-aliased variables can not be pointed to.  */\n+  /* Non-aliased variables cannot be pointed to.  */\n   if (!may_be_aliased (decl))\n     return false;\n "}, {"sha": "7dd8d58539e6473ab9ed0ecad4c9d57a521e8dcd", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -420,7 +420,7 @@ find_obviously_necessary_stmts (bool aggressive)\n \tif (!finite_loop_p (loop))\n \t  {\n \t    if (dump_file)\n-\t      fprintf (dump_file, \"can not prove finiteness of loop %i\\n\", loop->num);\n+\t      fprintf (dump_file, \"cannot prove finiteness of loop %i\\n\", loop->num);\n \t    mark_control_dependent_edges_necessary (loop->latch, false);\n \t  }\n     }"}, {"sha": "458f7112bbe4596a594e52172f169d68f6503105", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1136,7 +1136,7 @@ record_equivalences_from_phis (basic_block bb)\n \t  t = dom_valueize (t);\n \n \t  /* If T is an SSA_NAME and its associated edge is a backedge,\n-\t     then quit as we can not utilize this equivalence.  */\n+\t     then quit as we cannot utilize this equivalence.  */\n \t  if (TREE_CODE (t) == SSA_NAME\n \t      && (gimple_phi_arg_edge (phi, i)->flags & EDGE_DFS_BACK))\n \t    break;\n@@ -1376,7 +1376,7 @@ cprop_into_successor_phis (basic_block bb,\n \tcontinue;\n \n       /* We may have an equivalence associated with this edge.  While\n-\t we can not propagate it into non-dominated blocks, we can\n+\t we cannot propagate it into non-dominated blocks, we can\n \t propagate them into PHIs in non-dominated blocks.  */\n \n       /* Push the unwind marker so we can reset the const and copies\n@@ -1521,7 +1521,7 @@ eliminate_redundant_computations (gimple_stmt_iterator* gsi,\n   else\n     def = gimple_get_lhs (stmt);\n \n-  /* Certain expressions on the RHS can be optimized away, but can not\n+  /* Certain expressions on the RHS can be optimized away, but cannot\n      themselves be entered into the hash tables.  */\n   if (! def\n       || TREE_CODE (def) != SSA_NAME"}, {"sha": "eeb6281c65273f12d7b69b642a7f256668ee8570", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -280,7 +280,7 @@ can_propagate_from (gimple *def_stmt)\n     return false;\n \n   /* If the definition is a conversion of a pointer to a function type,\n-     then we can not apply optimizations as some targets require\n+     then we cannot apply optimizations as some targets require\n      function pointers to be canonicalized and in this case this\n      optimization could eliminate a necessary canonicalization.  */\n   if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt)))"}, {"sha": "d8a84402d4bca2612f2e7560bdac18864ba2783a", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1855,7 +1855,7 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n   /* Flag is set in FLAG_BBS. Determine probability that flag will be true\n      at loop exit.\n \n-     This code may look fancy, but it can not update profile very realistically\n+     This code may look fancy, but it cannot update profile very realistically\n      because we do not know the probability that flag will be true at given\n      loop exit.\n "}, {"sha": "eb0c1c94b9272f34e212ffe439c01cd6e3a39806", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -718,7 +718,7 @@ try_unroll_loop_completely (struct loop *loop,\n       if (edge_to_cancel == exit)\n \tedge_to_cancel = EDGE_SUCC (exit->src, 1);\n     }\n-  /* We do not know the number of iterations and thus we can not eliminate\n+  /* We do not know the number of iterations and thus we cannot eliminate\n      the EXIT edge.  */\n   else\n     exit = NULL;\n@@ -730,7 +730,7 @@ try_unroll_loop_completely (struct loop *loop,\n     {\n       n_unroll = maxiter;\n       n_unroll_found = true;\n-      /* Loop terminates before the IV variable test, so we can not\n+      /* Loop terminates before the IV variable test, so we cannot\n \t remove it in the last iteration.  */\n       edge_to_cancel = NULL;\n     }\n@@ -1443,7 +1443,7 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \n           unloop_loops (loop_closed_ssa_invalidated, &irred_invalidated);\n \n-\t  /* We can not use TODO_update_ssa_no_phi because VOPS gets confused.  */\n+\t  /* We cannot use TODO_update_ssa_no_phi because VOPS gets confused.  */\n \t  if (loop_closed_ssa_invalidated\n \t      && !bitmap_empty_p (loop_closed_ssa_invalidated))\n             rewrite_into_loop_closed_ssa (loop_closed_ssa_invalidated,"}, {"sha": "af0c9816bf79949f521589a6c576033e4044283f", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1438,7 +1438,7 @@ find_givs_in_stmt_scev (struct ivopts_data *data, gimple *stmt, affine_iv *iv)\n     return false;\n \n   /* If STMT could throw, then do not consider STMT as defining a GIV.\n-     While this will suppress optimizations, we can not safely delete this\n+     While this will suppress optimizations, we cannot safely delete this\n      GIV and associated statements, even if it appears it is not used.  */\n   if (stmt_could_throw_p (cfun, stmt))\n     return false;"}, {"sha": "622d18abacb512dcce43125c3f366b907d77acf8", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -4505,7 +4505,7 @@ n_of_executions_at_most (gimple *stmt,\n \n \t  /* By stmt_dominates_stmt_p we already know that STMT appears\n \t     before NITER_BOUND->STMT.  Still need to test that the loop\n-\t     can not be terinated by a side effect in between.  */\n+\t     cannot be terinated by a side effect in between.  */\n \t  for (bsi = gsi_for_stmt (stmt); gsi_stmt (bsi) != niter_bound->stmt;\n \t       gsi_next (&bsi))\n \t    if (gimple_has_side_effects (gsi_stmt (bsi)))"}, {"sha": "f367800da415a174169ccaa867d574624da3ddfd", "filename": "gcc/tree-ssa-phionlycprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-phionlycprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-phionlycprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phionlycprop.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -497,7 +497,7 @@ pass_phi_only_cprop::execute (function *fun)\n {\n   bool cfg_altered = false;\n \n-  /* Bitmap of blocks which need EH information updated.  We can not\n+  /* Bitmap of blocks which need EH information updated.  We cannot\n      update it on-the-fly as doing so invalidates the dominator tree.  */\n   auto_bitmap need_eh_cleanup;\n "}, {"sha": "219791ea4ba57c234e96ead69dec3ea00d025ad5", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1852,14 +1852,14 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n      form arg0 = -arg1 or arg1 = -arg0.  */\n \n   assign = last_and_only_stmt (middle_bb);\n-  /* If we did not find the proper negation assignment, then we can not\n+  /* If we did not find the proper negation assignment, then we cannot\n      optimize.  */\n   if (assign == NULL)\n     return false;\n \n   /* If we got here, then we have found the only executable statement\n      in OTHER_BLOCK.  If it is anything other than arg = -arg1 or\n-     arg1 = -arg0, then we can not optimize.  */\n+     arg1 = -arg0, then we cannot optimize.  */\n   if (gimple_code (assign) != GIMPLE_ASSIGN)\n     return false;\n "}, {"sha": "6b78dc1c06c22dd4987c610932086985be0679ce", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -339,7 +339,7 @@ ssa_propagation_engine::simulate_block (basic_block block)\n       /* Note that we have simulated this block.  */\n       block->flags |= BB_VISITED;\n \n-      /* We can not predict when abnormal and EH edges will be executed, so\n+      /* We cannot predict when abnormal and EH edges will be executed, so\n \t once a block is considered executable, we consider any\n \t outgoing abnormal edges as executable.\n "}, {"sha": "c3ea2d680d8aefba74be383244bed15ff878d386", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -140,7 +140,7 @@ record_temporary_equivalences_from_phis (edge e,\n       tree dst = gimple_phi_result (phi);\n \n       /* If the desired argument is not the same as this PHI's result\n-\t and it is set by a PHI in E->dest, then we can not thread\n+\t and it is set by a PHI in E->dest, then we cannot thread\n \t through E->dest.  */\n       if (src != dst\n \t  && TREE_CODE (src) == SSA_NAME\n@@ -253,13 +253,13 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \tcontinue;\n \n       /* If the statement has volatile operands, then we assume we\n-\t can not thread through this block.  This is overly\n+\t cannot thread through this block.  This is overly\n \t conservative in some ways.  */\n       if (gimple_code (stmt) == GIMPLE_ASM\n \t  && gimple_asm_volatile_p (as_a <gasm *> (stmt)))\n \treturn NULL;\n \n-      /* If the statement is a unique builtin, we can not thread\n+      /* If the statement is a unique builtin, we cannot thread\n \t through here.  */\n       if (gimple_code (stmt) == GIMPLE_CALL\n \t  && gimple_call_internal_p (stmt)\n@@ -906,7 +906,7 @@ thread_around_empty_blocks (edge taken_edge,\n   tree cond;\n \n   /* The key property of these blocks is that they need not be duplicated\n-     when threading.  Thus they can not have visible side effects such\n+     when threading.  Thus they cannot have visible side effects such\n      as PHI nodes.  */\n   if (!gsi_end_p (gsi_start_phis (bb)))\n     return false;"}, {"sha": "bccef879db03263af6c782f4faae1ab9a07ca354", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2550,7 +2550,7 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n      Consider if we have two jump threading paths A and B.  If the\n      target edge of A is the starting edge of B and we thread path A\n      first, then we create an additional incoming edge into B->dest that\n-     we can not discover as a jump threading path on this iteration.\n+     we cannot discover as a jump threading path on this iteration.\n \n      If we instead thread B first, then the edge into B->dest will have\n      already been redirected before we process path A and path A will"}, {"sha": "32cf730f4eec670a3ad0bc2ab5d4314c914fa8d6", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1464,7 +1464,7 @@ pred_expr_equal_p (pred_info x1, tree x2)\n \n /* Returns true of the domain of single predicate expression\n    EXPR1 is a subset of that of EXPR2.  Returns false if it\n-   can not be proved.  */\n+   cannot be proved.  */\n \n static bool\n is_pred_expr_subset_of (pred_info expr1, pred_info expr2)\n@@ -1502,7 +1502,7 @@ is_pred_expr_subset_of (pred_info expr1, pred_info expr2)\n }\n \n /* Returns true if the domain of PRED1 is a subset\n-   of that of PRED2.  Returns false if it can not be proved so.  */\n+   of that of PRED2.  Returns false if it cannot be proved so.  */\n \n static bool\n is_pred_chain_subset_of (pred_chain pred1, pred_chain pred2)\n@@ -2404,7 +2404,7 @@ uninit_uses_cannot_happen (gphi *phi, unsigned uninit_opnds,\n    USE_STMT is guarded with a predicate set not overlapping with\n    predicate sets of all runtime paths that do not have a definition.\n \n-   Returns false if it is not or it can not be determined.  USE_BB is\n+   Returns false if it is not or it cannot be determined.  USE_BB is\n    the bb of the use (for phi operand use, the bb is not the bb of\n    the phi stmt, but the src bb of the operand edge).\n \n@@ -2735,7 +2735,7 @@ execute_early_warn_uninitialized (void)\n \n   warn_uninitialized_vars (/*warn_possibly_uninitialized=*/!optimize);\n \n-  /* Post-dominator information can not be reliably updated.  Free it\n+  /* Post-dominator information cannot be reliably updated.  Free it\n      after the use.  */\n \n   free_dominance_info (CDI_POST_DOMINATORS);"}, {"sha": "51f52bb5bd3c2ab7632bf028d492866be1009d81", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -591,7 +591,7 @@ release_ssa_name_fn (struct function *fn, tree var)\n      keep a status bit in the SSA_NAME node itself to indicate it has\n      been put on the free list.\n \n-     Note that once on the freelist you can not reference the SSA_NAME's\n+     Note that once on the freelist you cannot reference the SSA_NAME's\n      defining statement.  */\n   if (! SSA_NAME_IN_FREE_LIST (var))\n     {"}, {"sha": "ce7e8086b398b2c94f7afeae203a1f9b968b3ad1", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -694,7 +694,7 @@ write_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n   /* TYPE_CANONICAL is re-computed during type merging, so no need\n      to stream it here.  */\n   /* Do not stream TYPE_STUB_DECL; it is not needed by LTO but currently\n-     it can not be freed by free_lang_data without triggering ICEs in\n+     it cannot be freed by free_lang_data without triggering ICEs in\n      langhooks.  */\n }\n "}, {"sha": "2e112ee17c6ec56e90158d030588a74780627c08", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -5658,7 +5658,7 @@ free_lang_data_in_decl (tree decl, struct free_lang_data_d *fld)\n \t use for middle-end.\n \n \t It would make more sense if frontends set TREE_ADDRESSABLE to 0 only\n-\t for public objects that indeed can not be adressed, but it is not\n+\t for public objects that indeed cannot be adressed, but it is not\n \t the case.  Set the flag to true so we do not get merge failures for\n \t i.e. virtual tables between units that take address of it and\n \t units that don't.  */\n@@ -14239,15 +14239,15 @@ verify_type (const_tree t)\n       debug_tree (ct);\n       error_found = true;\n     }\n-  /* Method and function types can not be used to address memory and thus\n+  /* Method and function types cannot be used to address memory and thus\n      TYPE_CANONICAL really matters only for determining useless conversions.\n \n      FIXME: C++ FE produce declarations of builtin functions that are not\n      compatible with main variants.  */\n   else if (TREE_CODE (t) == FUNCTION_TYPE)\n     ;\n   else if (t != ct\n-\t   /* FIXME: gimple_canonical_types_compatible_p can not compare types\n+\t   /* FIXME: gimple_canonical_types_compatible_p cannot compare types\n \t      with variably sized arrays because their sizes possibly\n \t      gimplified to different variables.  */\n \t   && !variably_modified_type_p (ct, NULL)"}, {"sha": "39b2ca51f761b05df938a08c428300620ea028e0", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -5867,7 +5867,7 @@ type_with_alias_set_p (const_tree t)\n   if (COMPLETE_TYPE_P (t))\n     return true;\n \n-  /* Incomplete types can not be accessed in general except for arrays\n+  /* Incomplete types cannot be accessed in general except for arrays\n      where we can fetch its element despite we have no array bounds.  */\n   if (TREE_CODE (t) == ARRAY_TYPE && COMPLETE_TYPE_P (TREE_TYPE (t)))\n     return true;"}, {"sha": "f4058ea1fe980e116b47aecaee3ebb79bb8269fe", "filename": "gcc/vr-values.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -2390,7 +2390,7 @@ vr_values::vrp_evaluate_conditional_warnv_with_ops (enum tree_code code,\n }\n \n /* Given (CODE OP0 OP1) within STMT, try to simplify it based on value range\n-   information.  Return NULL if the conditional can not be evaluated.\n+   information.  Return NULL if the conditional cannot be evaluated.\n    The ranges of all the names equivalent with the operands in COND\n    will be used when trying to compute the value.  If the result is\n    based on undefined signed overflow, issue a warning if"}, {"sha": "cd6aba044a5174dfa2b036799ab3de4d9a8ada55", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,9 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* backtrace.h: Mechanically replace \"can not\" with \"cannot\".\n+\n 2019-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "7918ef87698bc24fb5135fb5c9dde154b24399e1", "filename": "libbacktrace/backtrace.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libbacktrace%2Fbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libbacktrace%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fbacktrace.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -94,7 +94,7 @@ typedef void (*backtrace_error_callback) (void *data, const char *msg,\n    pointer on success, NULL on error.  If an error occurs, this will\n    call the ERROR_CALLBACK routine.\n \n-   Calling this function allocates resources that can not be freed.\n+   Calling this function allocates resources that cannot be freed.\n    There is no backtrace_free_state function.  The state is used to\n    cache information that is expensive to recompute.  Programs are\n    expected to call this function at most once and to save the return"}, {"sha": "c3ff6c7ca57881f742730d44061e88a2477de2e9", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,15 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* config/c6x/libunwind.S: Mechanically replace \"can not\" with\n+\t\"cannot\".\n+\t* config/tilepro/atomic.h: Likewise.\n+\t* config/vxlib-tls.c: Likewise.\n+\t* generic-morestack-thread.c: Likewise.\n+\t* generic-morestack.c: Likewise.\n+\t* mkmap-symver.awk: Likewise.\n+\n 2019-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "d56618bdfb41425fc02721ab0527432fd84ab012", "filename": "libgcc/config/c6x/libunwind.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2Fconfig%2Fc6x%2Flibunwind.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2Fconfig%2Fc6x%2Flibunwind.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fc6x%2Flibunwind.S?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -53,7 +53,7 @@ restore_core_regs:\n \t;; scratch registers and stack pointer before the base registers\n \t;; disappear.  We also need to make sure no interrupts occur,\n \t;; so put the whole thing in the delay slots of a dummy branch\n-\t;; We can not move the ret earlier as that would cause it to occur\n+\t;; We cannot move the ret earlier as that would cause it to occur\n \t;; before the last load completes\n \tb\t.s1\t(1f)\n \tldw\t.d1t1\t*+A4[4], A4"}, {"sha": "1b7f1df300fddd818b6ac6a9922dd2dd71d040c7", "filename": "libgcc/config/tilepro/atomic.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2Fconfig%2Ftilepro%2Fatomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2Fconfig%2Ftilepro%2Fatomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fatomic.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -59,7 +59,7 @@\n    advantage of the kernel's existing atomic-integer support (managed\n    by a distributed array of locks).  The kernel provides proper\n    ordering among simultaneous atomic operations on different cores,\n-   and guarantees a process can not be context-switched part way\n+   and guarantees a process cannot be context-switched part way\n    through an atomic operation.  By virtue of sharing the kernel\n    atomic implementation, the userspace atomic operations\n    are compatible with the atomic methods provided by the kernel's"}, {"sha": "b8d6907d81d7c3bc84436571ab9e5844dbd93d3d", "filename": "libgcc/config/vxlib-tls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2Fconfig%2Fvxlib-tls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2Fconfig%2Fvxlib-tls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvxlib-tls.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -70,7 +70,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n    The task delete hook is only installed when at least one thread\n    has TLS data.  This is a necessary precaution, to allow this module\n-   to be unloaded - a module with a hook can not be removed.\n+   to be unloaded - a module with a hook cannot be removed.\n \n    Since this interface is used to allocate only a small number of\n    keys, the table size is small and static, which simplifies the"}, {"sha": "42f1ad0d971612246d8ccdbef509efe639b84fca", "filename": "libgcc/generic-morestack-thread.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2Fgeneric-morestack-thread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2Fgeneric-morestack-thread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fgeneric-morestack-thread.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -29,7 +29,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"tm.h\"\n #include \"libgcc_tm.h\"\n \n-/* If inhibit_libc is defined, we can not compile this file.  The\n+/* If inhibit_libc is defined, we cannot compile this file.  The\n    effect is that people will not be able to use -fsplit-stack.  That\n    is much better than failing the build particularly since people\n    will want to define inhibit_libc while building a compiler which"}, {"sha": "0f6f0005f994f384468d5b60eed7067a0eb5fac7", "filename": "libgcc/generic-morestack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2Fgeneric-morestack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2Fgeneric-morestack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fgeneric-morestack.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"tm.h\"\n #include \"libgcc_tm.h\"\n \n-/* If inhibit_libc is defined, we can not compile this file.  The\n+/* If inhibit_libc is defined, we cannot compile this file.  The\n    effect is that people will not be able to use -fsplit-stack.  That\n    is much better than failing the build particularly since people\n    will want to define inhibit_libc while building a compiler which"}, {"sha": "fdd23a6ec746f15d6d3703fd5f7a9db55d6e8d58", "filename": "libgcc/mkmap-symver.awk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2Fmkmap-symver.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libgcc%2Fmkmap-symver.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fmkmap-symver.awk?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -33,7 +33,7 @@ BEGIN {\n }\n \n # We begin with nm input.  Collect the set of symbols that are present\n-# so that we can not emit them into the final version script -- Solaris\n+# so that we cannot emit them into the final version script -- Solaris\n # complains at us if we do.\n \n state == \"nm\" && /^%%/ {"}, {"sha": "10fe088ee718ca652b7bf523f0766934c20ca662", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,10 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* caf/single.c: Mechanically replace \"can not\" with \"cannot\".\n+\t* io/unit.c: Likewise.\n+\n 2019-01-07  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \tHarald Anlauf <anlauf@gmx.de>\n \tTobias Burnus <burnus@gcc.gnu.org>"}, {"sha": "1190f1abae3ea1dcc8f98e1d603657f87b5bcf6f", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -327,7 +327,7 @@ int _gfortran_caf_image_status (int image,\n }\n \n \n-/* Single image library.  There can not be any failed images with only one\n+/* Single image library.  There cannot be any failed images with only one\n    image.  */\n \n void\n@@ -1268,7 +1268,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t  if (ref->next && ref->next->type == CAF_REF_COMPONENT)\n \t    /* The currently ref'ed component was allocatabe (caf_token_offset\n \t       > 0) and the next ref is a component, too, then the new sr has to\n-\t       be dereffed.  (static arrays can not be allocatable or they\n+\t       be dereffed.  (static arrays cannot be allocatable or they\n \t       become an array with descriptor.  */\n \t    sr = *(void **)(sr + ref->u.c.offset);\n \t  else\n@@ -1525,7 +1525,7 @@ get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n \t\t       dst_kind, src_kind, dst_dim, src_dim + 1, 1,\n \t\t       stat, src_type);\n \t  return;\n-\t/* The OPEN_* are mapped to a RANGE and therefore can not occur.  */\n+\t/* The OPEN_* are mapped to a RANGE and therefore cannot occur.  */\n \tcase CAF_ARR_REF_OPEN_END:\n \tcase CAF_ARR_REF_OPEN_START:\n \tdefault:\n@@ -1558,7 +1558,7 @@ _gfortran_caf_get_by_ref (caf_token_t token,\n   const char extentoutofrange[] = \"libcaf_single::caf_get_by_ref(): \"\n \t\t\t\t  \"extent out of range.\\n\";\n   const char cannotallocdst[] = \"libcaf_single::caf_get_by_ref(): \"\n-\t\t\t\t\"can not allocate memory.\\n\";\n+\t\t\t\t\"cannot allocate memory.\\n\";\n   const char nonallocextentmismatch[] = \"libcaf_single::caf_get_by_ref(): \"\n       \"extent of non-allocatable arrays mismatch (%lu != %lu).\\n\";\n   const char doublearrayref[] = \"libcaf_single::caf_get_by_ref(): \"\n@@ -1864,7 +1864,7 @@ _gfortran_caf_get_by_ref (caf_token_t token,\n \t\t  break;\n \t\tcase CAF_ARR_REF_OPEN_END:\n \t\t  /* This and OPEN_START are mapped to a RANGE and therefore\n-\t\t     can not occur here.  */\n+\t\t     cannot occur here.  */\n \t\tcase CAF_ARR_REF_OPEN_START:\n \t\tdefault:\n \t\t  caf_internal_error (unknownarrreftype, stat, NULL, 0);\n@@ -2415,7 +2415,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t\t       dst_kind, src_kind, dst_dim + 1, src_dim, 1,\n \t\t       size, stat, dst_type);\n \t  return;\n-\t/* The OPEN_* are mapped to a RANGE and therefore can not occur.  */\n+\t/* The OPEN_* are mapped to a RANGE and therefore cannot occur.  */\n \tcase CAF_ARR_REF_OPEN_END:\n \tcase CAF_ARR_REF_OPEN_START:\n \tdefault:\n@@ -2447,7 +2447,7 @@ _gfortran_caf_send_by_ref (caf_token_t token,\n   const char realloconinnerref[] = \"libcaf_single::caf_send_by_ref(): \"\n       \"reallocation of array followed by component ref not allowed.\\n\";\n   const char cannotallocdst[] = \"libcaf_single::caf_send_by_ref(): \"\n-\t\t\t\t\"can not allocate memory.\\n\";\n+\t\t\t\t\"cannot allocate memory.\\n\";\n   const char nonallocextentmismatch[] = \"libcaf_single::caf_send_by_ref(): \"\n       \"extent of non-allocatable array mismatch.\\n\";\n   const char innercompref[] = \"libcaf_single::caf_send_by_ref(): \"\n@@ -2728,7 +2728,7 @@ _gfortran_caf_send_by_ref (caf_token_t token,\n \t\t  break;\n \t\tcase CAF_ARR_REF_OPEN_END:\n \t\t  /* This and OPEN_START are mapped to a RANGE and therefore\n-\t\t     can not occur here.  */\n+\t\t     cannot occur here.  */\n \t\tcase CAF_ARR_REF_OPEN_START:\n \t\tdefault:\n \t\t  caf_internal_error (unknownarrreftype, stat, NULL, 0);"}, {"sha": "c0dbfad2c7860de5d98c968c82225cb3544dc75c", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -431,7 +431,7 @@ is_trim_ok (st_parameter_dt *dtp)\n   /* Check rank and stride.  */\n   if (dtp->internal_unit_desc)\n     return false;\n-  /* Format strings can not have 'BZ' or '/'.  */\n+  /* Format strings cannot have 'BZ' or '/'.  */\n   if (dtp->common.flags & IOPARM_DT_HAS_FORMAT)\n     {\n       char *p = dtp->format;"}, {"sha": "a85fb5986c7ccef57b6998ad8ffbb290d1fda9c3", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,11 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* class.c: Mechanically replace \"can not\" with \"cannot\".\n+\t* objc/runtime.h: Likewise.\n+\t* sendmsg.c: Likewise.\n+\n 2019-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "326cf43e089382cddce548361a869754835fb7c0", "filename": "libobjc/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fclass.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -958,7 +958,7 @@ class_getSuperclass (Class class_)\n   /* Classes that are in construction are not resolved, and still have\n      the class name (instead of a class pointer) in the\n      class_->super_class field.  In that case we need to lookup the\n-     superclass name to return the superclass.  We can not resolve the\n+     superclass name to return the superclass.  We cannot resolve the\n      class until it is registered.  */\n   if (CLS_IS_IN_CONSTRUCTION (class_))\n     {"}, {"sha": "2ce23ccfd8650abadd35d497a8673f67498b52c5", "filename": "libobjc/objc/runtime.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libobjc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libobjc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fruntime.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -342,7 +342,7 @@ objc_EXPORT Ivar * class_copyIvarList (Class class_, unsigned int *numberOfRetur\n /* Add an instance variable with name 'ivar_name' to class 'class_',\n    where 'class_' is a class in construction that has been created\n    using objc_allocateClassPair() and has not been registered with the\n-   runtime using objc_registerClassPair() yet.  You can not add\n+   runtime using objc_registerClassPair() yet.  You cannot add\n    instance variables to classes already registered with the runtime.\n    'size' is the size of the instance variable, 'log_2_of_alignment'\n    the alignment as a power of 2 (so 0 means alignment to a 1 byte\n@@ -373,7 +373,7 @@ objc_EXPORT const char * property_getName (Property property);\n objc_EXPORT const char * property_getAttributes (Property property);\n \n /* Return the property with name 'propertyName' of the class 'class_'.\n-   This function returns NULL if the required property can not be\n+   This function returns NULL if the required property cannot be\n    found.  Return NULL if 'class_' or 'propertyName' is NULL.\n \n    Note that the traditional ABI does not store the list of properties\n@@ -568,7 +568,7 @@ method_exchangeImplementations (Method method_a, Method method_b);\n    class_addMethod (object_getClass (class), method)) that are\n    required, and then you need to call objc_registerClassPair() to\n    activate the class.  If you need to create a hierarchy of classes,\n-   you need to create and register them one at a time.  You can not\n+   you need to create and register them one at a time.  You cannot\n    create a new class using another class in construction as\n    superclass.  Return Nil if 'class-name' is NULL or if a class with\n    that name already exists or 'superclass' is a class still in\n@@ -876,7 +876,7 @@ objc_EXPORT struct objc_method_description *protocol_copyMethodDescriptionList (\n    properties.  At the moment, optional properties and class\n    properties are not part of the Objective-C language, so both\n    'requiredProperty' and 'instanceProperty' should be set to YES.\n-   This function returns NULL if the required property can not be\n+   This function returns NULL if the required property cannot be\n    found.\n \n    Note that the traditional ABI does not store the list of properties"}, {"sha": "2eba86b1c86e8a9e7da87bad86db65fe5ce38858", "filename": "libobjc/sendmsg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsendmsg.c?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1045,7 +1045,7 @@ __objc_prepare_dtable_for_class (Class cls)\n   struct sarray *dtable;\n   struct sarray *super_dtable;\n \n-  /* This table could be initialized in init.c.  We can not use the\n+  /* This table could be initialized in init.c.  We cannot use the\n      class name since the class maintains the instance methods and the\n      meta class maintains the the class methods yet both share the\n      same name.  Classes should be unique in any program.  */"}, {"sha": "6305b5f5039e12916081eca0a1fe628ebc2aa80a", "filename": "liboffloadmic/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,11 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* include/coi/common/COIResult_common.h: Mechanically replace\n+\t\"can not\" with \"cannot\".\n+\t* include/coi/source/COIBuffer_source.h: Likewise.\n+\n 2018-12-14  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* runtime/offload.h (omp_target_is_present, omp_target_memcpy)"}, {"sha": "d40c0b0d3ea484c842f8f4c7b536640ed3cbe65a", "filename": "liboffloadmic/include/coi/common/COIResult_common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -116,7 +116,7 @@ typedef enum COIRESULT\n     ///< the user that requested an engine.\n     ///< Only reported if daemon is set up for\n     ///< authorization. Is also reported in\n-    ///< Windows if host can not find user.\n+    ///< Windows if host cannot find user.\n     COI_COMM_NOT_INITIALIZED,         ///< The function was called before the\n     ///< comm was initialized.\n     COI_INCORRECT_FORMAT,             ///< Format of data is incorrect"}, {"sha": "e1f91572a34699e9139f1642682b9a5517131dfa", "filename": "liboffloadmic/include/coi/source/COIBuffer_source.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -496,7 +496,7 @@ COIBufferCreate(\n ///         are provided as hints to the runtime system so it can make\n ///         certain performance optimizations. Note that the flag\n ///         COI_SAME_ADDRESS_SINKS_AND_SOURCE is still valid but may fail\n-///         if the same address as in_Memory can not be allocated on the sink.\n+///         if the same address as in_Memory cannot be allocated on the sink.\n ///\n /// @param  in_Memory\n ///         [in] A pointer to an already allocated memory region"}, {"sha": "7ab044b093a835cde34f2da17db0635773a65c1f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -1,3 +1,10 @@\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* include/ext/bitmap_allocator.h: Mechanically replace \"can not\"\n+\twith \"cannot\".\n+\n 2019-01-09  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* testsuite/libstdc++-prettyprinters/cxx17.cc: Fix expected output"}, {"sha": "400030bfbc5b1eab9e1a633235499c9c6870a3b3", "filename": "libstdc++-v3/include/ext/bitmap_allocator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67914693144c02e0be2e6356d9162e775fb4971d/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67914693144c02e0be2e6356d9162e775fb4971d/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h?ref=67914693144c02e0be2e6356d9162e775fb4971d", "patch": "@@ -754,7 +754,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       /** @brief  Responsible for exponentially growing the internal\n        *  memory pool.\n        *\n-       *  @throw  std::bad_alloc. If memory can not be allocated.\n+       *  @throw  std::bad_alloc. If memory cannot be allocated.\n        *\n        *  Complexity: O(1), but internally depends upon the\n        *  complexity of the function free_list::_M_get. The part where\n@@ -810,7 +810,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       /** @brief  Allocates memory for a single object of size\n        *  sizeof(_Tp).\n        *\n-       *  @throw  std::bad_alloc. If memory can not be allocated.\n+       *  @throw  std::bad_alloc. If memory cannot be allocated.\n        *\n        *  Complexity: Worst case complexity is O(N), but that\n        *  is hardly ever hit. If and when this particular case is"}]}