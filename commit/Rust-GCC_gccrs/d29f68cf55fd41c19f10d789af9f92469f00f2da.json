{"sha": "d29f68cf55fd41c19f10d789af9f92469f00f2da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI5ZjY4Y2Y1NWZkNDFjMTlmMTBkNzg5YWY5ZjkyNDY5ZjAwZjJkYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T11:49:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T11:49:17Z"}, "message": "[multiple changes]\n\n2015-10-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Process_Declarations): A loop\n\tparameter does not require finalization actions.\n\n2015-10-20  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_ch6.adb (Expand_Simple_Function_Return): Do not create an\n\tactual subtype for a mutable record return type if the expression\n\tis itself a function call.\n\n2015-10-20  Dmitriy Anisimkov  <anisimko@adacore.com>\n\n\t* s-atocou.adb, s-atocou-builtin.adb: Fix implementation description\n\trelated to new type support.\n\n2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Resolve_Explicit_Dererence): Call Analyze_Dimension\n\tto propagate dimension information from prefix.\n\t* sem_dim.adb (Analyze_Dimension): Handle Explicit_Dereference.\n\t* inline.ads: minor whitespace fix in comment\n\t* sem_ch6.adb: minor gramar fix in comment\n\n2015-10-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Contract):\n\tA protected type or a protected object is allowed to have a\n\tdiscriminated part.\n\n2015-10-20  Bob Duff  <duff@adacore.com>\n\n\t* sem_util.adb (Requires_Transient_Scope):\n\tReturn true for mutable records if the maximum size is very large.\n\n2015-10-20  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* a-except-2005.adb (To_Stderr): Import Put_Char_Stderr with\n\tthe same signature as in System.IO.Put.\n\nFrom-SVN: r229052", "tree": {"sha": "b2cf724a7a7f4495421ee83948fbe30918908db5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2cf724a7a7f4495421ee83948fbe30918908db5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d29f68cf55fd41c19f10d789af9f92469f00f2da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d29f68cf55fd41c19f10d789af9f92469f00f2da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d29f68cf55fd41c19f10d789af9f92469f00f2da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d29f68cf55fd41c19f10d789af9f92469f00f2da/comments", "author": null, "committer": null, "parents": [{"sha": "b54d1d39d30c22dd0937b8115e2326637b3558c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b54d1d39d30c22dd0937b8115e2326637b3558c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b54d1d39d30c22dd0937b8115e2326637b3558c9"}], "stats": {"total": 214, "additions": 186, "deletions": 28}, "files": [{"sha": "0599e3222f938da0ecec4785ac4cbbcd9cc4ca93", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d29f68cf55fd41c19f10d789af9f92469f00f2da", "patch": "@@ -1,3 +1,43 @@\n+2015-10-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Process_Declarations): A loop\n+\tparameter does not require finalization actions.\n+\n+2015-10-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Simple_Function_Return): Do not create an\n+\tactual subtype for a mutable record return type if the expression\n+\tis itself a function call.\n+\n+2015-10-20  Dmitriy Anisimkov  <anisimko@adacore.com>\n+\n+\t* s-atocou.adb, s-atocou-builtin.adb: Fix implementation description\n+\trelated to new type support.\n+\n+2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Explicit_Dererence): Call Analyze_Dimension\n+\tto propagate dimension information from prefix.\n+\t* sem_dim.adb (Analyze_Dimension): Handle Explicit_Dereference.\n+\t* inline.ads: minor whitespace fix in comment\n+\t* sem_ch6.adb: minor gramar fix in comment\n+\n+2015-10-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Contract):\n+\tA protected type or a protected object is allowed to have a\n+\tdiscriminated part.\n+\n+2015-10-20  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_util.adb (Requires_Transient_Scope):\n+\tReturn true for mutable records if the maximum size is very large.\n+\n+2015-10-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* a-except-2005.adb (To_Stderr): Import Put_Char_Stderr with\n+\tthe same signature as in System.IO.Put.\n+\n 2015-10-20  Bob Duff  <duff@adacore.com>\n \n \t* a-cobove.adb (Set_Length): Restore previous logic, but with \"Checks"}, {"sha": "43a556d4783d2d864dd7838d4354cb8f8024c53b", "filename": "gcc/ada/a-except-2005.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=d29f68cf55fd41c19f10d789af9f92469f00f2da", "patch": "@@ -1631,11 +1631,10 @@ package body Ada.Exceptions is\n    ---------------\n \n    procedure To_Stderr (C : Character) is\n-      type int is new Integer;\n-      procedure put_char_stderr (C : int);\n-      pragma Import (C, put_char_stderr, \"put_char_stderr\");\n+      procedure Put_Char_Stderr (C : Character);\n+      pragma Import (C, Put_Char_Stderr, \"put_char_stderr\");\n    begin\n-      put_char_stderr (Character'Pos (C));\n+      Put_Char_Stderr (C);\n    end To_Stderr;\n \n    procedure To_Stderr (S : String) is"}, {"sha": "e7d1dcec7a12fa4ef0e12aa686e946b52646fc4a", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d29f68cf55fd41c19f10d789af9f92469f00f2da", "patch": "@@ -5942,17 +5942,21 @@ package body Exp_Ch6 is\n \n       elsif not Requires_Transient_Scope (R_Type) then\n \n-         --  Mutable records with no variable length components are not\n-         --  returned on the sec-stack, so we need to make sure that the\n-         --  backend will only copy back the size of the actual value, and not\n-         --  the maximum size. We create an actual subtype for this purpose.\n+         --  Mutable records with variable-length components are not returned\n+         --  on the sec-stack, so we need to make sure that the back end will\n+         --  only copy back the size of the actual value, and not the maximum\n+         --  size. We create an actual subtype for this purpose. However we\n+         --  need not do it if the expression is a function call since this\n+         --  will be done in the called function and doing it here too would\n+         --  cause a temporary with maximum size to be created.\n \n          declare\n             Ubt  : constant Entity_Id := Underlying_Type (Base_Type (Exptyp));\n             Decl : Node_Id;\n             Ent  : Entity_Id;\n          begin\n-            if Has_Discriminants (Ubt)\n+            if Nkind (Exp) /= N_Function_Call\n+              and then Has_Discriminants (Ubt)\n               and then not Is_Constrained (Ubt)\n               and then not Has_Unchecked_Union (Ubt)\n             then"}, {"sha": "5a241b2af36e1425cfa4947afa0b9d332ff0c0cb", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=d29f68cf55fd41c19f10d789af9f92469f00f2da", "patch": "@@ -1837,6 +1837,15 @@ package body Exp_Ch7 is\n                elsif Is_Ignored_Ghost_Entity (Obj_Id) then\n                   null;\n \n+               --  The expansion of iterator loops generates an object\n+               --  declaration where the Ekind is explicitly set to loop\n+               --  parameter. This is to ensure that the loop parameter behaves\n+               --  as a constant from user code point of view. Such object are\n+               --  never controlled and do not require finalization.\n+\n+               elsif Ekind (Obj_Id) = E_Loop_Parameter then\n+                  null;\n+\n                --  The object is of the form:\n                --    Obj : Typ [:= Expr];\n "}, {"sha": "223c3dc174abf6fe4c6e226c27c5bf5c2e0b9658", "filename": "gcc/ada/inline.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Finline.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Finline.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.ads?ref=d29f68cf55fd41c19f10d789af9f92469f00f2da", "patch": "@@ -165,7 +165,7 @@ package Inline is\n    --  subsequently used for inline expansions at call sites. If subprogram can\n    --  be inlined (depending on size and nature of local declarations) the\n    --  template body is created. Otherwise subprogram body is treated normally\n-   --  and calls are not inlined in the frontend.  If proper warnings are\n+   --  and calls are not inlined in the frontend. If proper warnings are\n    --  enabled and the subprogram contains a construct that cannot be inlined,\n    --  the problematic construct is flagged accordingly.\n "}, {"sha": "36a939fd89e7650a60336d921efcd9eb09c4bbd6", "filename": "gcc/ada/s-atocou-builtin.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fs-atocou-builtin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fs-atocou-builtin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-atocou-builtin.adb?ref=d29f68cf55fd41c19f10d789af9f92469f00f2da", "patch": "@@ -29,8 +29,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package implements Atomic_Counter operatiobns for platforms where\n---  GCC supports __sync_add_and_fetch_4 and __sync_sub_and_fetch_4 builtins.\n+--  This package implements Atomic_Counter and Atomic_Unsigned operations\n+--  for platforms where GCC supports __sync_add_and_fetch_4 and\n+--  __sync_sub_and_fetch_4 builtins.\n \n package body System.Atomic_Counters is\n "}, {"sha": "2897c6c83682ff1fb45d5ba79487c22e593d57b7", "filename": "gcc/ada/s-atocou.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fs-atocou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fs-atocou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-atocou.adb?ref=d29f68cf55fd41c19f10d789af9f92469f00f2da", "patch": "@@ -29,12 +29,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is dummy version of the package, for use on platforms where this\n---  capability is not supported. Any use of any of the routines in this\n---  package will raise Program_Error.\n-\n---  Why don't we use pragma Unimplemented_Unit in a dummy spec, this would\n---  seem much more useful than raising an exception at run time ???\n+--  This is version of the package, for use on platforms where this capability\n+--  is not supported. All Atomic_Counter operations raises Program_Error,\n+--  Atomic_Unsigned operations processed in non-atomic manner.\n \n package body System.Atomic_Counters is\n "}, {"sha": "d91f831ec33030158a0dfa8ec1008bcbf4d794cd", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d29f68cf55fd41c19f10d789af9f92469f00f2da", "patch": "@@ -3347,9 +3347,11 @@ package body Sem_Ch3 is\n                      Obj_Id);\n \n                --  An object of a discriminated type cannot be effectively\n-               --  volatile (SPARK RM C.6(4)).\n+               --  volatile except for protected objects (SPARK RM 7.1.3(5)).\n \n-               elsif Has_Discriminants (Obj_Typ) then\n+               elsif Has_Discriminants (Obj_Typ)\n+                 and then not Is_Protected_Type (Obj_Typ)\n+               then\n                   Error_Msg_N\n                     (\"discriminated object & cannot be volatile\", Obj_Id);\n "}, {"sha": "0243700eb83ae0cedbc4fbc52b73814f6ef801e1", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=d29f68cf55fd41c19f10d789af9f92469f00f2da", "patch": "@@ -265,15 +265,16 @@ package body Sem_Ch6 is\n       LocX : constant Source_Ptr := Sloc (Expr);\n       Spec : constant Node_Id    := Specification (N);\n \n-      Def_Id :  Entity_Id;\n+      Def_Id : Entity_Id;\n \n-      Prev :  Entity_Id;\n+      Prev : Entity_Id;\n       --  If the expression is a completion, Prev is the entity whose\n       --  declaration is completed. Def_Id is needed to analyze the spec.\n \n       New_Body : Node_Id;\n       New_Spec : Node_Id;\n       Ret      : Node_Id;\n+      Asp      : Node_Id;\n \n    begin\n       --  This is one of the occasions on which we transform the tree during\n@@ -449,6 +450,17 @@ package body Sem_Ch6 is\n \n          Analyze (N);\n \n+         --  If aspect SPARK_Mode was specified on the body, it needs to be\n+         --  repeated both on the generated spec and the body.\n+\n+         Asp := Find_Aspect (Defining_Unit_Name (Spec), Aspect_SPARK_Mode);\n+\n+         if Present (Asp) then\n+            Asp := New_Copy_Tree (Asp);\n+            Set_Analyzed (Asp, False);\n+            Set_Aspect_Specifications (New_Body, New_List (Asp));\n+         end if;\n+\n          --  Within a generic pre-analyze the original expression for name\n          --  capture. The body is also generated but plays no role in\n          --  this because it is not part of the original source.\n@@ -3632,8 +3644,8 @@ package body Sem_Ch6 is\n       --  declaration for now, as inlining of subprogram bodies acting as\n       --  declarations, or subprogram stubs, are not supported by frontend\n       --  inlining. This inlining should occur after analysis of the body, so\n-      --  that it is known whether the value of SPARK_Mode applicable to the\n-      --  body, which can be defined by a pragma inside the body.\n+      --  that it is known whether the value of SPARK_Mode, which can be\n+      --  defined by a pragma inside the body, is applicable to the body.\n \n       elsif GNATprove_Mode\n         and then Full_Analysis"}, {"sha": "e9bafa40f8a7b8e4eadb24947c4b78c312940393", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=d29f68cf55fd41c19f10d789af9f92469f00f2da", "patch": "@@ -194,6 +194,7 @@ package body Sem_Dim is\n    OK_For_Dimension : constant array (Node_Kind) of Boolean :=\n      (N_Attribute_Reference       => True,\n       N_Expanded_Name             => True,\n+      N_Explicit_Dereference      => True,\n       N_Defining_Identifier       => True,\n       N_Function_Call             => True,\n       N_Identifier                => True,\n@@ -1135,6 +1136,7 @@ package body Sem_Dim is\n \n          when N_Attribute_Reference       |\n               N_Expanded_Name             |\n+              N_Explicit_Dereference      |\n               N_Function_Call             |\n               N_Identifier                |\n               N_Indexed_Component         |\n@@ -2093,7 +2095,6 @@ package body Sem_Dim is\n \n    procedure Analyze_Dimension_Simple_Return_Statement (N : Node_Id) is\n       Expr                : constant Node_Id := Expression (N);\n-      Dims_Of_Expr        : constant Dimension_Type := Dimensions_Of (Expr);\n       Return_Ent          : constant Entity_Id := Return_Statement_Entity (N);\n       Return_Etyp         : constant Entity_Id :=\n                               Etype (Return_Applies_To (Return_Ent));\n@@ -2126,7 +2127,7 @@ package body Sem_Dim is\n    --  Start of processing for Analyze_Dimension_Simple_Return_Statement\n \n    begin\n-      if Dims_Of_Return_Etyp /= Dims_Of_Expr then\n+      if Dims_Of_Return_Etyp /= Dimensions_Of (Expr) then\n          Error_Dim_Msg_For_Simple_Return_Statement (N, Return_Etyp, Expr);\n          Remove_Dimensions (Expr);\n       end if;"}, {"sha": "9d7e6da607748e134848d3d4caa8362f14d99391", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d29f68cf55fd41c19f10d789af9f92469f00f2da", "patch": "@@ -8067,6 +8067,7 @@ package body Sem_Res is\n          Set_Etype (N, Get_Actual_Subtype (N));\n       end if;\n \n+      Analyze_Dimension (N);\n       --  Note: No Eval processing is required for an explicit dereference,\n       --  because such a name can never be static.\n "}, {"sha": "0c6e2b00b6168bcee2682223fabc8da5715baa38", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29f68cf55fd41c19f10d789af9f92469f00f2da/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d29f68cf55fd41c19f10d789af9f92469f00f2da", "patch": "@@ -17215,6 +17215,11 @@ package body Sem_Util is\n       --  could be nested inside some other record that is constrained by\n       --  nondiscriminants). That is, the recursive calls are too conservative.\n \n+      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean;\n+      --  Returns True if Typ is a nonlimited record with defaulted\n+      --  discriminants whose max size makes it unsuitable for allocating on\n+      --  the primary stack.\n+\n       ------------------------------\n       -- Caller_Known_Size_Record --\n       ------------------------------\n@@ -17267,6 +17272,85 @@ package body Sem_Util is\n          return True;\n       end Caller_Known_Size_Record;\n \n+      ------------------------------\n+      -- Large_Max_Size_Mutable --\n+      ------------------------------\n+\n+      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean is\n+         pragma Assert (Typ = Underlying_Type (Typ));\n+\n+         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean;\n+         --  Returns true if the discrete type T has a large range\n+\n+         ----------------------------\n+         -- Is_Large_Discrete_Type --\n+         ----------------------------\n+\n+         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean is\n+            Threshold : constant Int := 16;\n+            --  Arbitrary threshold above which we consider it \"large\". We want\n+            --  a fairly large threshold, because these large types really\n+            --  shouldn't have default discriminants in the first place, in\n+            --  most cases.\n+\n+         begin\n+            return UI_To_Int (RM_Size (T)) > Threshold;\n+         end Is_Large_Discrete_Type;\n+\n+      begin\n+         if Is_Record_Type (Typ)\n+           and then not Is_Limited_View (Typ)\n+           and then Has_Defaulted_Discriminants (Typ)\n+         then\n+            --  Loop through the components, looking for an array whose upper\n+            --  bound(s) depends on discriminants, where both the subtype of\n+            --  the discriminant and the index subtype are too large.\n+\n+            declare\n+               Comp : Entity_Id;\n+\n+            begin\n+               Comp := First_Entity (Typ);\n+               while Present (Comp) loop\n+                  if Ekind (Comp) = E_Component then\n+                     declare\n+                        Comp_Type : constant Entity_Id :=\n+                                      Underlying_Type (Etype (Comp));\n+                        Indx : Node_Id;\n+                        Ityp : Entity_Id;\n+                        Hi   : Node_Id;\n+\n+                     begin\n+                        if Is_Array_Type (Comp_Type) then\n+                           Indx := First_Index (Comp_Type);\n+\n+                           while Present (Indx) loop\n+                              Ityp := Etype (Indx);\n+                              Hi := Type_High_Bound (Ityp);\n+\n+                              if Nkind (Hi) = N_Identifier\n+                                and then Ekind (Entity (Hi)) = E_Discriminant\n+                                and then Is_Large_Discrete_Type (Ityp)\n+                                and then Is_Large_Discrete_Type\n+                                           (Etype (Entity (Hi)))\n+                              then\n+                                 return True;\n+                              end if;\n+\n+                              Next_Index (Indx);\n+                           end loop;\n+                        end if;\n+                     end;\n+                  end if;\n+\n+                  Next_Entity (Comp);\n+               end loop;\n+            end;\n+         end if;\n+\n+         return False;\n+      end Large_Max_Size_Mutable;\n+\n       --  Local declarations\n \n       Typ : constant Entity_Id := Underlying_Type (Id);\n@@ -17313,10 +17397,18 @@ package body Sem_Util is\n \n       --  Untagged definite subtypes are known size. This includes all\n       --  elementary [sub]types. Tasks are known size even if they have\n-      --  discriminants.\n+      --  discriminants. So we return False here, with one exception:\n+      --  For a type like:\n+      --    type T (Last : Natural := 0) is\n+      --       X : String (1 .. Last);\n+      --    end record;\n+      --  we return True. That's because for \"P(F(...));\", where F returns T,\n+      --  we don't know the size of the result at the call site, so if we\n+      --  allocated it on the primary stack, we would have to allocate the\n+      --  maximum size, which is way too big.\n \n       elsif Is_Definite_Subtype (Typ) or else Is_Task_Type (Typ) then\n-         return False;\n+         return Large_Max_Size_Mutable (Typ);\n \n       --  Indefinite (discriminated) untagged record or protected type\n "}]}