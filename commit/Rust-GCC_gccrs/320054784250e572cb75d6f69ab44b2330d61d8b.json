{"sha": "320054784250e572cb75d6f69ab44b2330d61d8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIwMDU0Nzg0MjUwZTU3MmNiNzVkNmY2OWFiNDRiMjMzMGQ2MWQ4Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-08-12T09:45:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-08-14T16:58:48Z"}, "message": "c++: Copy elision and [[no_unique_address]]. [PR93711]\n\nWe don't elide a copy from a function returning a class by value into a base\nbecause that can overwrite data laid out in the tail padding of the base\nclass; we need to handle [[no_unique_address]] fields the same way, or we\nICE when the middle-end wants to create a temporary object of a\nTYPE_NEEDS_CONSTRUCTING type.\n\nThis means that we can't always express initialization of a field with\nINIT_EXPR from a TARGET_EXPR the way we usually do, so I needed\nto change several places that were assuming that was sufficient.\n\nThis also fixes 90254, the same problem with C++17 aggregate initialization\nof a base.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/90254\n\tPR c++/93711\n\t* cp-tree.h (unsafe_return_slot_p): Declare.\n\t* call.c (is_base_field_ref): Rename to unsafe_return_slot_p.\n\t(build_over_call): Check unsafe_return_slot_p.\n\t(build_special_member_call): Likewise.\n\t* init.c (expand_default_init): Likewise.\n\t* typeck2.c (split_nonconstant_init_1): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/90254\n\tPR c++/93711\n\t* g++.dg/cpp1z/aggr-base10.C: New test.\n\t* g++.dg/cpp2a/no_unique_address7.C: New test.\n\t* g++.dg/cpp2a/no_unique_address7a.C: New test.", "tree": {"sha": "527b83bfa30fdf702800a08a693826eb77ae7dcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/527b83bfa30fdf702800a08a693826eb77ae7dcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/320054784250e572cb75d6f69ab44b2330d61d8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/320054784250e572cb75d6f69ab44b2330d61d8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/320054784250e572cb75d6f69ab44b2330d61d8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/320054784250e572cb75d6f69ab44b2330d61d8b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40"}], "stats": {"total": 104, "additions": 85, "deletions": 19}, "files": [{"sha": "94aaf65b3f4459a62a2b22b073f3e5fc2675d11d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=320054784250e572cb75d6f69ab44b2330d61d8b", "patch": "@@ -8347,24 +8347,34 @@ call_copy_ctor (tree a, tsubst_flags_t complain)\n   return r;\n }\n \n-/* Return true iff T refers to a base field.  */\n+/* Return true iff T refers to a base or potentially-overlapping field, which\n+   cannot be used for return by invisible reference.  We avoid doing C++17\n+   mandatory copy elision when this is true.\n \n-static bool\n-is_base_field_ref (tree t)\n+   This returns true even if the type of T has no tail padding that other data\n+   could be allocated into, because that depends on the particular ABI.\n+   unsafe_copy_elision_p, below, does consider whether there is padding.  */\n+\n+bool\n+unsafe_return_slot_p (tree t)\n {\n   STRIP_NOPS (t);\n   if (TREE_CODE (t) == ADDR_EXPR)\n     t = TREE_OPERAND (t, 0);\n   if (TREE_CODE (t) == COMPONENT_REF)\n     t = TREE_OPERAND (t, 1);\n-  if (TREE_CODE (t) == FIELD_DECL)\n-    return DECL_FIELD_IS_BASE (t);\n-  return false;\n+  if (TREE_CODE (t) != FIELD_DECL)\n+    return false;\n+  if (!CLASS_TYPE_P (TREE_TYPE (t)))\n+    /* The middle-end will do the right thing for scalar types.  */\n+    return false;\n+  return (DECL_FIELD_IS_BASE (t)\n+\t  || lookup_attribute (\"no_unique_address\", DECL_ATTRIBUTES (t)));\n }\n \n-/* We can't elide a copy from a function returning by value to a base\n-   subobject, as the callee might clobber tail padding.  Return true iff this\n-   could be that case.  */\n+/* We can't elide a copy from a function returning by value to a\n+   potentially-overlapping subobject, as the callee might clobber tail padding.\n+   Return true iff this could be that case.  */\n \n static bool\n unsafe_copy_elision_p (tree target, tree exp)\n@@ -8374,10 +8384,11 @@ unsafe_copy_elision_p (tree target, tree exp)\n     return false;\n   tree type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n   /* It's safe to elide the copy for a class with no tail padding.  */\n-  if (tree_int_cst_equal (TYPE_SIZE (type), CLASSTYPE_SIZE (type)))\n+  if (!is_empty_class (type)\n+      && tree_int_cst_equal (TYPE_SIZE (type), CLASSTYPE_SIZE (type)))\n     return false;\n   /* It's safe to elide the copy if we aren't initializing a base object.  */\n-  if (!is_base_field_ref (target))\n+  if (!unsafe_return_slot_p (target))\n     return false;\n   tree init = TARGET_EXPR_INITIAL (exp);\n   /* build_compound_expr pushes COMPOUND_EXPR inside TARGET_EXPR.  */\n@@ -8569,6 +8580,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       && DECL_COMPLETE_CONSTRUCTOR_P (fn)\n       && (DECL_COPY_CONSTRUCTOR_P (fn)\n \t  || DECL_MOVE_CONSTRUCTOR_P (fn))\n+      && !unsafe_return_slot_p (first_arg)\n       && conv_binds_ref_to_prvalue (convs[0]))\n     {\n       force_elide = true;\n@@ -8953,7 +8965,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n     {\n       tree targ;\n       tree arg = argarray[num_artificial_parms_for (fn)];\n-      tree fa;\n+      tree fa = argarray[0];\n       bool trivial = trivial_fn_p (fn);\n \n       /* Pull out the real argument, disregarding const-correctness.  */\n@@ -8983,18 +8995,17 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       else\n \targ = cp_build_fold_indirect_ref (arg);\n \n-      /* In C++17 we shouldn't be copying a TARGET_EXPR except into a base\n-\t subobject.  */\n+      /* In C++17 we shouldn't be copying a TARGET_EXPR except into a\n+\t potentially-overlapping subobject.  */\n       if (CHECKING_P && cxx_dialect >= cxx17)\n \tgcc_assert (TREE_CODE (arg) != TARGET_EXPR\n \t\t    || force_elide\n \t\t    /* It's from binding the ref parm to a packed field. */\n \t\t    || convs[0]->need_temporary_p\n \t\t    || seen_error ()\n \t\t    /* See unsafe_copy_elision_p.  */\n-\t\t    || DECL_BASE_CONSTRUCTOR_P (fn));\n+\t\t    || unsafe_return_slot_p (fa));\n \n-      fa = argarray[0];\n       bool unsafe = unsafe_copy_elision_p (fa, arg);\n       bool eliding_temp = (TREE_CODE (arg) == TARGET_EXPR && !unsafe);\n \n@@ -9806,7 +9817,7 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n      resolution.  */\n   if (cxx_dialect >= cxx17\n       && args && vec_safe_length (*args) == 1\n-      && name == complete_ctor_identifier)\n+      && !unsafe_return_slot_p (instance))\n     {\n       tree arg = (**args)[0];\n "}, {"sha": "59ab2309d18c6c6e3c91984b3d99e2475cf58551", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=320054784250e572cb75d6f69ab44b2330d61d8b", "patch": "@@ -6359,6 +6359,7 @@ extern bool is_std_init_list\t\t\t(tree);\n extern bool is_list_ctor\t\t\t(tree);\n extern void validate_conversion_obstack\t\t(void);\n extern void mark_versions_used\t\t\t(tree);\n+extern bool unsafe_return_slot_p\t\t(tree);\n extern bool cp_warn_deprecated_use\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n extern void cp_warn_deprecated_use_scopes\t(tree);\n extern tree get_function_version_dispatcher\t(tree);"}, {"sha": "872c23453fd35a407d6c8f12034ac495b898f1fd", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=320054784250e572cb75d6f69ab44b2330d61d8b", "patch": "@@ -1895,7 +1895,8 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n     }\n \n   if (init && TREE_CODE (init) != TREE_LIST\n-      && (flags & LOOKUP_ONLYCONVERTING))\n+      && (flags & LOOKUP_ONLYCONVERTING)\n+      && !unsafe_return_slot_p (exp))\n     {\n       /* Base subobjects should only get direct-initialization.  */\n       gcc_assert (true_exp == exp);"}, {"sha": "b95f112a7449c8fd59fd7bb3cfbaaa2a7fa48a60", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=320054784250e572cb75d6f69ab44b2330d61d8b", "patch": "@@ -711,7 +711,17 @@ split_nonconstant_init_1 (tree dest, tree init, bool nested)\n \t\t    sub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n \t\t\t\t  NULL_TREE);\n \n-\t\t  code = build2 (INIT_EXPR, inner_type, sub, value);\n+\t\t  if (unsafe_return_slot_p (sub))\n+\t\t    {\n+\t\t      /* We may need to add a copy constructor call if\n+\t\t\t the field has [[no_unique_address]].  */\n+\t\t      releasing_vec args = make_tree_vector_single (value);\n+\t\t      code = build_special_member_call\n+\t\t\t(sub, complete_ctor_identifier, &args, inner_type,\n+\t\t\t LOOKUP_NORMAL, tf_warning_or_error);\n+\t\t    }\n+\t\t  else\n+\t\t    code = build2 (INIT_EXPR, inner_type, sub, value);\n \t\t  code = build_stmt (input_location, EXPR_STMT, code);\n \t\t  code = maybe_cleanup_point_expr_void (code);\n \t\t  add_stmt (code);"}, {"sha": "10370daa6e607e5322e841e72f7e9974b7f34d57", "filename": "gcc/testsuite/g++.dg/cpp1z/aggr-base10.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faggr-base10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faggr-base10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faggr-base10.C?ref=320054784250e572cb75d6f69ab44b2330d61d8b", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/90254\n+// { dg-do compile { target c++17 } }\n+\n+struct A {\n+  A();\n+  A(const A &);\n+};\n+struct B : A { };\n+\n+A foo ();\n+\n+int\n+main ()\n+{\n+  B b{foo()};\n+}"}, {"sha": "edd82d1ecccca08fe17b2caf912be42b028aa837", "filename": "gcc/testsuite/g++.dg/cpp2a/no_unique_address7.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address7.C?ref=320054784250e572cb75d6f69ab44b2330d61d8b", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/93711\n+// { dg-do compile { target c++11 } }\n+\n+struct A { A(const A&) = delete; };\n+\n+A f();\n+\n+struct C\n+{\n+  [[no_unique_address]] A a;\n+};\n+\n+C c{f()};\t\t\t// { dg-error \"deleted\" }"}, {"sha": "453baceb905a39dbea31904fc1406b4fa499469c", "filename": "gcc/testsuite/g++.dg/cpp2a/no_unique_address7a.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address7a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320054784250e572cb75d6f69ab44b2330d61d8b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address7a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address7a.C?ref=320054784250e572cb75d6f69ab44b2330d61d8b", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/93711\n+// { dg-do compile { target c++11 } }\n+\n+struct B { };\n+struct A: B { A(const A&) = delete; };\n+\n+A f();\n+\n+struct C\n+{\n+  [[no_unique_address]] A a;\n+};\n+\n+C c{f()};\t\t\t// { dg-error \"deleted\" }"}]}