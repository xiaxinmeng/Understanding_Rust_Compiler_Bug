{"sha": "a62436c0a505155fc8becac07a8c0abe2c265bfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYyNDM2YzBhNTA1MTU1ZmM4YmVjYWMwN2E4YzBhYmUyYzI2NWJmZQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2016-11-10T00:32:43Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-11-10T00:32:43Z"}, "message": "simplify-rtx: Transform (xor (and (xor A B) C) B) with C const\n\nmatch.pd transforms (A&C)|(B&~C) to ((A^B)&C)^B, which is fewer\noperations if C is not const (and it is not on simple tests at least,\nthis transform is done very early already).\n\nVarious processors have \"insert\" instructions that can do this, but\ncombine cannot build those from the xor-and-xor, especially it has no\nchance at all to do that if A or B or multiple instructions as well\n(on PowerPC, the rl[wd]imi instructions can do this with together with\na rotate, or a simple shift with appropriate C; other ISAs have similar\ninsns).\n\nThis patch makes RTL simplify transform (xor (and (xor A B) C) B) back\nto (ior (and A C) (and B ~C)) for constant C (and similar with A instead\nof B for that last term).\n\n\n\t* simplify-rtx.c (simplify_binary_operation_1): Simplify\n\t(xor (and (xor A B) C) B) to (ior (and A C) (and B ~C)) and\n\t(xor (and (xor A B) C) A) to (ior (and A ~C) (and B C)) if C\n\tis a const_int.\n\nFrom-SVN: r242031", "tree": {"sha": "bb6f4efa2648eb51dc815e233e1459b00835762f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb6f4efa2648eb51dc815e233e1459b00835762f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a62436c0a505155fc8becac07a8c0abe2c265bfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a62436c0a505155fc8becac07a8c0abe2c265bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a62436c0a505155fc8becac07a8c0abe2c265bfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a62436c0a505155fc8becac07a8c0abe2c265bfe/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a84a4f0b87c7ff9836a5b7c030be43aec6126966", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a84a4f0b87c7ff9836a5b7c030be43aec6126966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a84a4f0b87c7ff9836a5b7c030be43aec6126966"}], "stats": {"total": 38, "additions": 38, "deletions": 0}, "files": [{"sha": "c9034e8dca4efe3fd7b6469125623080bf856594", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62436c0a505155fc8becac07a8c0abe2c265bfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62436c0a505155fc8becac07a8c0abe2c265bfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a62436c0a505155fc8becac07a8c0abe2c265bfe", "patch": "@@ -1,3 +1,10 @@\n+2016-11-09  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* simplify-rtx.c (simplify_binary_operation_1): Simplify\n+\t(xor (and (xor A B) C) B) to (ior (and A C) (and B ~C)) and\n+\t(xor (and (xor A B) C) A) to (ior (and A ~C) (and B C)) if C\n+\tis a const_int.\n+\n 2016-11-09  David Malcolm  <dmalcolm@redhat.com>\n \n \t* print-rtl-function.c: Include varasm.h."}, {"sha": "11a2e0267c7d182f2d92ebc86befe6b70c606384", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62436c0a505155fc8becac07a8c0abe2c265bfe/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62436c0a505155fc8becac07a8c0abe2c265bfe/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=a62436c0a505155fc8becac07a8c0abe2c265bfe", "patch": "@@ -2886,6 +2886,37 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t    }\n \t}\n \n+      /* If we have (xor (and (xor A B) C) A) with C a constant we can instead\n+\t do (ior (and A ~C) (and B C)) which is a machine instruction on some\n+\t machines, and also has shorter instruction path length.  */\n+      if (GET_CODE (op0) == AND\n+\t  && GET_CODE (XEXP (op0, 0)) == XOR\n+\t  && CONST_INT_P (XEXP (op0, 1))\n+\t  && rtx_equal_p (XEXP (XEXP (op0, 0), 0), trueop1))\n+\t{\n+\t  rtx a = trueop1;\n+\t  rtx b = XEXP (XEXP (op0, 0), 1);\n+\t  rtx c = XEXP (op0, 1);\n+\t  rtx nc = simplify_gen_unary (NOT, mode, c, mode);\n+\t  rtx a_nc = simplify_gen_binary (AND, mode, a, nc);\n+\t  rtx bc = simplify_gen_binary (AND, mode, b, c);\n+\t  return simplify_gen_binary (IOR, mode, a_nc, bc);\n+\t}\n+      /* Similarly, (xor (and (xor A B) C) B) as (ior (and A C) (and B ~C))  */\n+      else if (GET_CODE (op0) == AND\n+\t  && GET_CODE (XEXP (op0, 0)) == XOR\n+\t  && CONST_INT_P (XEXP (op0, 1))\n+\t  && rtx_equal_p (XEXP (XEXP (op0, 0), 1), trueop1))\n+\t{\n+\t  rtx a = XEXP (XEXP (op0, 0), 0);\n+\t  rtx b = trueop1;\n+\t  rtx c = XEXP (op0, 1);\n+\t  rtx nc = simplify_gen_unary (NOT, mode, c, mode);\n+\t  rtx b_nc = simplify_gen_binary (AND, mode, b, nc);\n+\t  rtx ac = simplify_gen_binary (AND, mode, a, c);\n+\t  return simplify_gen_binary (IOR, mode, ac, b_nc);\n+\t}\n+\n       /* (xor (comparison foo bar) (const_int 1)) can become the reversed\n \t comparison if STORE_FLAG_VALUE is 1.  */\n       if (STORE_FLAG_VALUE == 1"}]}