{"sha": "f187056f8a6ca4c42c7cfa2954b134a94c7a38b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE4NzA1NmY4YTZjYTRjNDJjN2NmYTI5NTRiMTM0YTk0YzdhMzhiMw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-08-16T05:49:38Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-08-16T05:49:38Z"}, "message": "haifa-sched.c (find_post_sched_live): Call FREE_REG_SET as needed.\n\n        * haifa-sched.c (find_post_sched_live): Call FREE_REG_SET as needed.\n        (schedule_region): Likewise.\n        (schedule_insns): Likewise.\nTo avoid leaking memory.\n\n        * PROJECTS: Update with Haifa stuff.\n\nFrom-SVN: r14817", "tree": {"sha": "b162c9e0799ca9727b0820e9bb37b15c7707f396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b162c9e0799ca9727b0820e9bb37b15c7707f396"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f187056f8a6ca4c42c7cfa2954b134a94c7a38b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f187056f8a6ca4c42c7cfa2954b134a94c7a38b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f187056f8a6ca4c42c7cfa2954b134a94c7a38b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f187056f8a6ca4c42c7cfa2954b134a94c7a38b3/comments", "author": null, "committer": null, "parents": [{"sha": "0945e93725cde4d4c1ddd4ba621cf836c4368cd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0945e93725cde4d4c1ddd4ba621cf836c4368cd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0945e93725cde4d4c1ddd4ba621cf836c4368cd1"}], "stats": {"total": 120, "additions": 61, "deletions": 59}, "files": [{"sha": "dffb90518c9fde3e1b30ffa96839e34196250916", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f187056f8a6ca4c42c7cfa2954b134a94c7a38b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f187056f8a6ca4c42c7cfa2954b134a94c7a38b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f187056f8a6ca4c42c7cfa2954b134a94c7a38b3", "patch": "@@ -1,3 +1,11 @@\n+Fri Aug 15 23:48:32 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* haifa-sched.c (find_post_sched_live): Call FREE_REG_SET as needed.\n+\t(schedule_region): Likewise.\n+\t(schedule_insns): Likewise.\n+\n+\t* PROJECTS: Update with Haifa stuff.\n+\n Fri Aug 15 12:49:56 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* version.c: Change the version string to look like:"}, {"sha": "356f477a086e4e66341d2c3e4e8d70e38fe6967f", "filename": "gcc/PROJECTS", "status": "modified", "additions": 46, "deletions": 59, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f187056f8a6ca4c42c7cfa2954b134a94c7a38b3/gcc%2FPROJECTS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f187056f8a6ca4c42c7cfa2954b134a94c7a38b3/gcc%2FPROJECTS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FPROJECTS?ref=f187056f8a6ca4c42c7cfa2954b134a94c7a38b3", "patch": "@@ -1,12 +1,47 @@\n-0. Improved efficiency.\n+Haifa scheduler (haifa-sched.c, loop.[ch], unroll.[ch], genattrtab.c):\n+(contact law@cygnus.com before starting any serious haifa work)\n \n-* Parse and output array initializers an element at a time, freeing\n-storage after each, instead of parsing the whole initializer first and\n-then outputting.  This would reduce memory usage for large\n-initializers.\n+  * Fix all the formatting problems.  Simple, mindless work.\n \n-* See if the techniques describe in Oct 1991 SIGPLAN Notices\n-(Frazer and Hanson) are applicable to GCC.\n+  * Fix/add comments throughout the code.  Many of the comments are from\n+  the old scheduler and are out of date and misleading.  Many new hunks\n+  of code don't have sufficient comments and documentation.  Those which\n+  do have comments need to be rewritten to use complete sentences and\n+  proper formatting.\n+\n+  * Someone needs make one (or more) passes over the scheduler as a whole to\n+  just clean it up.  Try to move the machine dependent bits into the target\n+  files where they belong, avoid re-creating functions where or near\n+  equivalents already exist (ie is_conditional_branch and friends), etc etc.\n+\n+  * Document the new scheduling options.  Remove those options which are\n+  not really useful (like reverse scheduling for example).  In general\n+  the haifa scheduler adds _way_ too many options.  I'm definitely of the\n+  opinion that gcc already has too many -foptions, and haifa doesn't help\n+  that situation.\n+\n+  * Testing and benchmarking.  Haifa has received little testing inside\n+  Cygnus -- it needs to be throughly tested on a wide variety of platforms\n+  which benefit from instruction scheduling (sparc, alpha, pa, ppc, mips, x86,\n+  i960, m88k, sh, etc).    It needs to be benchmarked -- my tests showed\n+  haifa was very much a hit or miss in terms of performance improvements.\n+\n+  Some benchmarks ran significantly fasters, other significantly slower.\n+  We need to work on making haifa generate better overall code.\n+\n+  We need to have some kind of docs for how to best describe a machine to\n+  the haifa scheduler to get good performance.  Some existing ports have\n+  been tuned to deal with the old scheduler -- they may need to be tuned\n+  to generate good schedules with haifa.\n+\n+  \n+\n+\n+-------------\n+\n+The old PROJECTS file.  Stuff I know has been done has been deleted.\n+Stuff in progress has a contact name associated with it.\n+has been \n \n 1. Better optimization.\n \n@@ -25,22 +60,8 @@ to point to the constant and cause it to be output.\n The techniques for doing full global cse are described in the red\n dragon book, or (a different version) in Frederick Chow's thesis from\n Stanford.  It is likely to be slow and use a lot of memory, but it\n-might be worth offering as an additional option.\n-\n-It is probably possible to extend cse to a few very frequent cases\n-without so much expense.\n-\n-For example, it is not very hard to handle cse through if-then\n-statements with no else clauses.  Here's how to do it.  On reaching a\n-label, notice that the label's use-count is 1 and that the last\n-preceding jump jumps conditionally to this label.  Now you know it\n-is a simple if-then statement.  Remove from the hash table\n-all the expressions that were entered since that jump insn\n-and you can continue with cse.\n-\n-It is probably not hard to handle cse from the end of a loop\n-around to the beginning, and a few loops would be greatly sped\n-up by this.\n+might be worth offering as an additional option.  Contact dje@cygnus.com\n+before doing any work on CSE.\n \n * Optimize a sequence of if statements whose conditions are exclusive.\n \n@@ -174,42 +195,8 @@ or outside of a particular loop where the variable is not used.  (The\n latter is nice because it might let the variable be in a register most\n of the time even though the loop needs all the registers.)\n \n-It might not be very hard to do this in global.c when a variable\n-fails to get a hard register for its entire life span.\n-\n-The first step is to find a loop in which the variable is live, but\n-which is not the whole life span or nearly so.  It's probably best to\n-use a loop in which the variable is heavily used.\n-\n-Then create a new pseudo-register to represent the variable in that loop.\n-Substitute this for the old pseudo-register there, and insert move insns\n-to copy between the two at the loop entry and all exits.  (When several\n-such moves are inserted at the same place, some new feature should be\n-added to say that none of those registers conflict merely because of\n-overlap between the new moves.  And the reload pass should reorder them\n-so that a store precedes a load, for any given hard register.)\n-\n-After doing this for all the reasonable candidates, run global-alloc\n-over again.  With luck, one of the two pseudo-registers will be fit\n-somewhere.  It may even have a much higher priority due to its reduced\n-life span.\n-\n-There will be no room in general for the new pseudo-registers in\n-basic_block_live_at_start, so there will need to be a second such\n-matrix exclusively for the new ones.  Various other vectors indexed by\n-register number will have to be made bigger, or there will have to be\n-secondary extender vectors just for global-alloc.\n-\n-A simple new feature could arrange that both pseudo-registers get the\n-same stack slot if they both fail to get hard registers.\n-\n-Other compilers split live ranges when they are not connected, or\n-try to split off pieces `at the edge'.  I think splitting around loops\n-will provide more speedup.\n-\n-Creating a fake binding block and a new like-named variable with\n-shorter life span and different address might succeed in describing\n-this technique for the debugger.\n+Contact meissner@cygnus.com before starting any work on live range\n+splitting.\n \n * Detect dead stores into memory?\n "}, {"sha": "57bff8bec5165c7252eadbfec5e5fafa26f4e6eb", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f187056f8a6ca4c42c7cfa2954b134a94c7a38b3/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f187056f8a6ca4c42c7cfa2954b134a94c7a38b3/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=f187056f8a6ca4c42c7cfa2954b134a94c7a38b3", "patch": "@@ -5433,6 +5433,8 @@ find_post_sched_live (bb)\n   if (current_nr_blocks > 1)\n     COPY_REG_SET (basic_block_live_at_start[b], bb_live_regs);\n \n+\n+  FREE_REG_SET (old_live_regs);\n }\t\t\t\t/* find_post_sched_live */\n \n /* After scheduling the subroutine, restore information about uses of\n@@ -7632,6 +7634,8 @@ schedule_region (rgn)\n \n   /* Done with this region */\n   free_pending_lists ();\n+\n+  FREE_REG_SET (reg_pending_sets);\n }\n \n /* Subroutine of split_hard_reg_notes.  Searches X for any reference to\n@@ -8674,5 +8678,8 @@ schedule_insns (dump_file)\n \t}\n       fprintf (dump, \"\\n\\n\");\n     }\n+\n+  if (bb_live_regs)\n+    FREE_REG_SET (bb_live_regs);\n }\n #endif /* INSN_SCHEDULING */"}]}