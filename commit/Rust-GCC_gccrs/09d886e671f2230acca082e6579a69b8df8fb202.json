{"sha": "09d886e671f2230acca082e6579a69b8df8fb202", "node_id": "C_kwDOANBUbNoAKDA5ZDg4NmU2NzFmMjIzMGFjY2EwODJlNjU3OWE2OWI4ZGY4ZmIyMDI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-01T15:07:17Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-10-06T02:41:00Z"}, "message": "c++: defaulted <=> with bitfields [PR102490]\n\nThe testcases in the patch are either miscompiled or ICE with checking,\nbecause the defaulted operator== is synthesized too early (but only if\nconstexpr), when the corresponding class type is still incomplete type.  The\nproblem is that at that point the bitfield FIELD_DECLs still have as\nTREE_TYPE their underlying type rather than integral type with their\nprecision and when layout_class_type is called for the class soon after\nthat, it changes those types but the COMPONENT_REFs type stay the way that\nthey were during the operator== synthesize_method type and the middle-end is\nthen upset by the mismatch of types.  As what exact type will be given isn't\njust a one liner but quite long code especially for over-sized bitfields, I\nthink it is best to just not synthesize the comparison operators so early\nand call defaulted_late_check for them once again as soon as the class is\ncomplete.\n\nThis is also a problem for virtual operator<=>, where we need to compare the\nnoexcept-specifier to validate the override before the class is complete.\nRather than try to defer that comparison, maybe_instantiate_noexcept now\ncalls maybe_synthesize_method, which calls build_comparison_op in\nnon-defining mode if the class isn't complete yet.  In that situation we\nalso might not have base fields yet, so we look in the binfo for the bases.\n\nCo-authored-by: Jason Merrill <jason@redhat.com>\n\n2021-10-01  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/98712\n\tPR c++/102490\n\t* cp-tree.h (maybe_synthesize_method): Declare.\n\t* method.c (genericize_spaceship): Use\n\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL | LOOKUP_DEFAULTED instead of\n\tLOOKUP_NORMAL for flags.\n\t(comp_info): Remove defining member.  Add complain, code, retcat.\n\t(comp_info::comp_info): Adjust.\n\t(do_one_comp): Split out from build_comparison_op.   Use\n\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL | LOOKUP_DEFAULTED instead of\n\tLOOKUP_NORMAL for flags.\n\t(build_comparison_op): Add defining argument. Adjust comp_info\n\tconstruction.  Use defining instead of info.defining.  Assert that\n\tif defining, ctype is a complete type.  Walk base binfos.\n\t(synthesize_method, maybe_explain_implicit_delete,\n\texplain_implicit_non_constexpr): Adjust build_comparison_op callers.\n\t(maybe_synthesize_method): New function.\n\t* class.c (check_bases_and_members): Don't call defaulted_late_check\n\tfor sfk_comparison.\n\t(finish_struct_1): Call it here instead after class has been\n\tcompleted.\n\t* pt.c (maybe_instantiate_noexcept): Call maybe_synthesize_method\n\tinstead of synthesize_method.\n\n\t* g++.dg/cpp2a/spaceship-synth8.C (std::strong_ordering): Provide\n\tmore complete definition.\n\t(std::strong_ordering::less, std::strong_ordering::equal,\n\tstd::strong_ordering::greater): Define.\n\t* g++.dg/cpp2a/spaceship-synth12.C: New test.\n\t* g++.dg/cpp2a/spaceship-synth13.C: New test.\n\t* g++.dg/cpp2a/spaceship-synth14.C: New test.\n\t* g++.dg/cpp2a/spaceship-eq11.C: New test.\n\t* g++.dg/cpp2a/spaceship-eq12.C: New test.\n\t* g++.dg/cpp2a/spaceship-eq13.C: New test.", "tree": {"sha": "47c7586af3681fc0b819c9b8ebf804d73d340ed2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47c7586af3681fc0b819c9b8ebf804d73d340ed2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09d886e671f2230acca082e6579a69b8df8fb202", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09d886e671f2230acca082e6579a69b8df8fb202", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09d886e671f2230acca082e6579a69b8df8fb202", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09d886e671f2230acca082e6579a69b8df8fb202/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb6194e0b44a8262d8de304be3bd3ee65187772a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6194e0b44a8262d8de304be3bd3ee65187772a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb6194e0b44a8262d8de304be3bd3ee65187772a"}], "stats": {"total": 418, "additions": 328, "deletions": 90}, "files": [{"sha": "59611627d187d2834d680f772958cf42bbb78c8a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=09d886e671f2230acca082e6579a69b8df8fb202", "patch": "@@ -6119,6 +6119,10 @@ check_bases_and_members (tree t)\n \t&& !DECL_ARTIFICIAL (fn)\n \t&& DECL_DEFAULTED_IN_CLASS_P (fn))\n       {\n+\t/* ...except handle comparisons later, in finish_struct_1.  */\n+\tif (special_function_p (fn) == sfk_comparison)\n+\t  continue;\n+\n \tint copy = copy_fn_p (fn);\n \tif (copy > 0)\n \t  {\n@@ -7467,7 +7471,14 @@ finish_struct_1 (tree t)\n      for any static member objects of the type we're working on.  */\n   for (x = TYPE_FIELDS (t); x; x = DECL_CHAIN (x))\n     if (DECL_DECLARES_FUNCTION_P (x))\n-      DECL_IN_AGGR_P (x) = false;\n+      {\n+\t/* Synthesize constexpr defaulted comparisons.  */\n+\tif (!DECL_ARTIFICIAL (x)\n+\t    && DECL_DEFAULTED_IN_CLASS_P (x)\n+\t    && special_function_p (x) == sfk_comparison)\n+\t  defaulted_late_check (x);\n+\tDECL_IN_AGGR_P (x) = false;\n+      }\n     else if (VAR_P (x) && TREE_STATIC (x)\n \t     && TREE_TYPE (x) != error_mark_node\n \t     && same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (x)), t))"}, {"sha": "5248ecd8fe73654254589d5fe133cacab1e7c89b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=09d886e671f2230acca082e6579a69b8df8fb202", "patch": "@@ -7013,6 +7013,7 @@ extern void explain_implicit_non_constexpr\t(tree);\n extern bool deduce_inheriting_ctor\t\t(tree);\n extern bool decl_remember_implicit_trigger_p\t(tree);\n extern void synthesize_method\t\t\t(tree);\n+extern void maybe_synthesize_method\t\t(tree);\n extern tree lazily_declare_fn\t\t\t(special_function_kind,\n \t\t\t\t\t\t tree);\n extern tree skip_artificial_parms_for\t\t(const_tree, tree);"}, {"sha": "1023aefc575b3124989c188867bda75cac010839", "filename": "gcc/cp/method.c", "status": "modified", "additions": 153, "deletions": 87, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=09d886e671f2230acca082e6579a69b8df8fb202", "patch": "@@ -1288,21 +1288,19 @@ struct comp_info\n {\n   tree fndecl;\n   location_t loc;\n-  bool defining;\n+  tsubst_flags_t complain;\n+  tree_code code;\n+  comp_cat_tag retcat;\n   bool first_time;\n   bool constexp;\n   bool was_constexp;\n   bool noex;\n \n-  comp_info (tree fndecl, tsubst_flags_t &complain)\n-    : fndecl (fndecl)\n+  comp_info (tree fndecl, tsubst_flags_t complain)\n+    : fndecl (fndecl), complain (complain)\n   {\n     loc = DECL_SOURCE_LOCATION (fndecl);\n \n-    /* We only have tf_error set when we're called from\n-       explain_invalid_constexpr_fn or maybe_explain_implicit_delete.  */\n-    defining = !(complain & tf_error);\n-\n     first_time = DECL_MAYBE_DELETED (fndecl);\n     DECL_MAYBE_DELETED (fndecl) = false;\n \n@@ -1358,23 +1356,99 @@ struct comp_info\n   }\n };\n \n+/* Subroutine of build_comparison_op, to compare a single subobject.  */\n+\n+static tree\n+do_one_comp (location_t loc, const comp_info &info, tree sub, tree lhs, tree rhs)\n+{\n+  const tree_code code = info.code;\n+  const tree fndecl = info.fndecl;\n+  const comp_cat_tag retcat = info.retcat;\n+  const tsubst_flags_t complain = info.complain;\n+\n+  tree overload = NULL_TREE;\n+  int flags = LOOKUP_NORMAL | LOOKUP_NONVIRTUAL | LOOKUP_DEFAULTED;\n+  /* If we have an explicit comparison category return type we can fall back\n+     to </=, so don't give an error yet if <=> lookup fails.  */\n+  bool tentative = retcat != cc_last;\n+  tree comp = build_new_op (loc, code, flags, lhs, rhs,\n+\t\t\t    NULL_TREE, &overload,\n+\t\t\t    tentative ? tf_none : complain);\n+\n+  if (code != SPACESHIP_EXPR)\n+    return comp;\n+\n+  tree rettype = TREE_TYPE (TREE_TYPE (fndecl));\n+\n+  if (comp == error_mark_node)\n+    {\n+      if (overload == NULL_TREE && (tentative || complain))\n+\t{\n+\t  /* No viable <=>, try using op< and op==.  */\n+\t  tree lteq = genericize_spaceship (loc, rettype, lhs, rhs);\n+\t  if (lteq != error_mark_node)\n+\t    {\n+\t      /* We found usable < and ==.  */\n+\t      if (retcat != cc_last)\n+\t\t/* Return type is a comparison category, use them.  */\n+\t\tcomp = lteq;\n+\t      else if (complain & tf_error)\n+\t\t/* Return type is auto, suggest changing it.  */\n+\t\tinform (info.loc, \"changing the return type from %qs \"\n+\t\t\t\"to a comparison category type will allow the \"\n+\t\t\t\"comparison to use %qs and %qs\", \"auto\",\n+\t\t\t\"operator<\", \"operator==\");\n+\t    }\n+\t  else if (tentative && complain)\n+\t    /* No usable < and ==, give an error for op<=>.  */\n+\t    build_new_op (loc, code, flags, lhs, rhs, complain);\n+\t}\n+      if (comp == error_mark_node)\n+\treturn error_mark_node;\n+    }\n+\n+  if (FNDECL_USED_AUTO (fndecl)\n+      && cat_tag_for (TREE_TYPE (comp)) == cc_last)\n+    {\n+      /* The operator function is defined as deleted if ... Ri is not a\n+\t comparison category type.  */\n+      if (complain & tf_error)\n+\tinform (loc,\n+\t\t\"three-way comparison of %qD has type %qT, not a \"\n+\t\t\"comparison category type\", sub, TREE_TYPE (comp));\n+      return error_mark_node;\n+    }\n+  else if (!FNDECL_USED_AUTO (fndecl)\n+\t   && !can_convert (rettype, TREE_TYPE (comp), complain))\n+    {\n+      if (complain & tf_error)\n+\terror_at (loc,\n+\t\t  \"three-way comparison of %qD has type %qT, which \"\n+\t\t  \"does not convert to %qT\",\n+\t\t  sub, TREE_TYPE (comp), rettype);\n+      return error_mark_node;\n+    }\n+\n+  return comp;\n+}\n+\n /* Build up the definition of a defaulted comparison operator.  Unlike other\n    defaulted functions that use synthesized_method_walk to determine whether\n    the function is e.g. deleted, for comparisons we use the same code.  We try\n    to use synthesize_method at the earliest opportunity and bail out if the\n    function ends up being deleted.  */\n \n-static void\n-build_comparison_op (tree fndecl, tsubst_flags_t complain)\n+void\n+build_comparison_op (tree fndecl, bool defining, tsubst_flags_t complain)\n {\n   comp_info info (fndecl, complain);\n \n-  if (!info.defining && !(complain & tf_error) && !DECL_MAYBE_DELETED (fndecl))\n+  if (!defining && !(complain & tf_error) && !DECL_MAYBE_DELETED (fndecl))\n     return;\n \n   int flags = LOOKUP_NORMAL;\n   const ovl_op_info_t *op = IDENTIFIER_OVL_OP_INFO (DECL_NAME (fndecl));\n-  tree_code code = op->tree_code;\n+  tree_code code = info.code = op->tree_code;\n \n   tree lhs = DECL_ARGUMENTS (fndecl);\n   tree rhs = DECL_CHAIN (lhs);\n@@ -1384,6 +1458,7 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n     lhs = convert_from_reference (lhs);\n   rhs = convert_from_reference (rhs);\n   tree ctype = TYPE_MAIN_VARIANT (TREE_TYPE (lhs));\n+  gcc_assert (!defining || COMPLETE_TYPE_P (ctype));\n \n   iloc_sentinel ils (info.loc);\n \n@@ -1399,7 +1474,7 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n     }\n \n   tree compound_stmt = NULL_TREE;\n-  if (info.defining)\n+  if (defining)\n     compound_stmt = begin_compound_stmt (0);\n   else\n     ++cp_unevaluated_operand;\n@@ -1413,21 +1488,42 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \n   if (code == EQ_EXPR || code == SPACESHIP_EXPR)\n     {\n-      comp_cat_tag retcat = cc_last;\n+      comp_cat_tag &retcat = (info.retcat = cc_last);\n       if (code == SPACESHIP_EXPR && !FNDECL_USED_AUTO (fndecl))\n \tretcat = cat_tag_for (rettype);\n \n       bool bad = false;\n       auto_vec<tree> comps;\n \n-      /* Compare each of the subobjects.  Note that we get bases from\n-\t next_initializable_field because we're past C++17.  */\n+      /* Compare the base subobjects.  We handle them this way, rather than in\n+\t the field loop below, because maybe_instantiate_noexcept might bring\n+\t us here before we've built the base fields.  */\n+      for (tree base_binfo : BINFO_BASE_BINFOS (TYPE_BINFO (ctype)))\n+\t{\n+\t  tree lhs_base\n+\t    = build_base_path (PLUS_EXPR, lhs, base_binfo, 0, complain);\n+\t  tree rhs_base\n+\t    = build_base_path (PLUS_EXPR, rhs, base_binfo, 0, complain);\n+\n+\t  location_t loc = DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (ctype));\n+\t  tree comp = do_one_comp (loc, info, BINFO_TYPE (base_binfo),\n+\t\t\t\t   lhs_base, rhs_base);\n+\t  if (comp == error_mark_node)\n+\t    {\n+\t      bad = true;\n+\t      continue;\n+\t    }\n+\n+\t  comps.safe_push (comp);\n+\t}\n+\n+      /* Now compare the field subobjects.  */\n       for (tree field = next_initializable_field (TYPE_FIELDS (ctype));\n \t   field;\n \t   field = next_initializable_field (DECL_CHAIN (field)))\n \t{\n-\t  if (DECL_VIRTUAL_P (field))\n-\t    /* Don't compare vptr fields.  */\n+\t  if (DECL_VIRTUAL_P (field) || DECL_FIELD_IS_BASE (field))\n+\t    /* We ignore the vptr, and we already handled bases.  */\n \t    continue;\n \n \t  tree expr_type = TREE_TYPE (field);\n@@ -1478,8 +1574,8 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t\tbreak;\n \t      tree idx;\n \t      /* [1] array, no loop needed, just add [0] ARRAY_REF.\n-\t\t Similarly if !info.defining.  */\n-\t      if (integer_zerop (maxval) || !info.defining)\n+\t\t Similarly if !defining.  */\n+\t      if (integer_zerop (maxval) || !defining)\n \t\tidx = size_zero_node;\n \t      /* Some other array, will need runtime loop.  */\n \t      else\n@@ -1496,69 +1592,13 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t  if (TREE_CODE (expr_type) == ARRAY_TYPE)\n \t    continue;\n \n-\t  tree overload = NULL_TREE;\n-\t  tree comp = build_new_op (field_loc, code, flags, lhs_mem, rhs_mem,\n-\t\t\t\t    NULL_TREE, &overload,\n-\t\t\t\t    retcat != cc_last ? tf_none : complain);\n+\t  tree comp = do_one_comp (field_loc, info, field, lhs_mem, rhs_mem);\n \t  if (comp == error_mark_node)\n \t    {\n-\t      if (overload == NULL_TREE && code == SPACESHIP_EXPR\n-\t\t  && (retcat != cc_last || complain))\n-\t\t{\n-\t\t  tree comptype = (retcat != cc_last ? rettype\n-\t\t\t\t   : DECL_SAVED_AUTO_RETURN_TYPE (fndecl));\n-\t\t  /* No viable <=>, try using op< and op==.  */\n-\t\t  tree lteq = genericize_spaceship (field_loc, comptype,\n-\t\t\t\t\t\t    lhs_mem, rhs_mem);\n-\t\t  if (lteq != error_mark_node)\n-\t\t    {\n-\t\t      /* We found usable < and ==.  */\n-\t\t      if (retcat != cc_last)\n-\t\t\t/* Return type is a comparison category, use them.  */\n-\t\t\tcomp = lteq;\n-\t\t      else if (complain & tf_error)\n-\t\t\t/* Return type is auto, suggest changing it.  */\n-\t\t\tinform (info.loc, \"changing the return type from %qs \"\n-\t\t\t\t\"to a comparison category type will allow the \"\n-\t\t\t\t\"comparison to use %qs and %qs\", \"auto\",\n-\t\t\t\t\"operator<\", \"operator==\");\n-\t\t    }\n-\t\t  else if (retcat != cc_last && complain != tf_none)\n-\t\t    /* No usable < and ==, give an error for op<=>.  */\n-\t\t    build_new_op (field_loc, code, flags, lhs_mem, rhs_mem,\n-\t\t\t\t  complain);\n-\t\t}\n-\t      if (comp == error_mark_node)\n-\t\t{\n-\t\t  bad = true;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t  if (code != SPACESHIP_EXPR)\n-\t    ;\n-\t  else if (FNDECL_USED_AUTO (fndecl)\n-\t\t   && cat_tag_for (TREE_TYPE (comp)) == cc_last)\n-\t    {\n-\t      /* The operator function is defined as deleted if ... Ri is not a\n-\t\t comparison category type.  */\n-\t      if (complain & tf_error)\n-\t\tinform (field_loc,\n-\t\t\t\"three-way comparison of %qD has type %qT, not a \"\n-\t\t\t\"comparison category type\", field, TREE_TYPE (comp));\n-\t      bad = true;\n-\t      continue;\n-\t    }\n-\t  else if (!FNDECL_USED_AUTO (fndecl)\n-\t\t   && !can_convert (rettype, TREE_TYPE (comp), complain))\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror_at (field_loc,\n-\t\t\t  \"three-way comparison of %qD has type %qT, which \"\n-\t\t\t  \"does not convert to %qT\",\n-\t\t\t  field, TREE_TYPE (comp), rettype);\n \t      bad = true;\n \t      continue;\n \t    }\n+\n \t  /* Most of the time, comp is the expression that should be evaluated\n \t     to compare the two members.  If the expression needs to be\n \t     evaluated more than once in a loop, it will be a TREE_LIST\n@@ -1588,7 +1628,7 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t  tree comp = comps[i];\n \t  tree eq, retval = NULL_TREE, if_ = NULL_TREE;\n \t  tree loop_indexes = NULL_TREE;\n-\t  if (info.defining)\n+\t  if (defining)\n \t    {\n \t      if (TREE_CODE (comp) == TREE_LIST)\n \t\t{\n@@ -1636,7 +1676,7 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t\tcomp = build_static_cast (input_location, rettype, comp,\n \t\t\t\t\t  complain);\n \t      info.check (comp);\n-\t      if (info.defining)\n+\t      if (defining)\n \t\t{\n \t\t  tree var = create_temporary_var (rettype);\n \t\t  pushdecl (var);\n@@ -1649,7 +1689,7 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t    }\n \t  tree ceq = contextual_conv_bool (eq, complain);\n \t  info.check (ceq);\n-\t  if (info.defining)\n+\t  if (defining)\n \t    {\n \t      finish_if_stmt_cond (ceq, if_);\n \t      finish_then_clause (if_);\n@@ -1662,7 +1702,7 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t\tfinish_for_stmt (TREE_VALUE (loop_index));\n \t    }\n \t}\n-      if (info.defining)\n+      if (defining)\n \t{\n \t  tree val;\n \t  if (code == EQ_EXPR)\n@@ -1683,7 +1723,7 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t\t\t\tNULL_TREE, NULL, complain);\n       comp = contextual_conv_bool (comp, complain);\n       info.check (comp);\n-      if (info.defining)\n+      if (defining)\n \t{\n \t  tree neg = build1 (TRUTH_NOT_EXPR, boolean_type_node, comp);\n \t  finish_return_stmt (neg);\n@@ -1696,12 +1736,12 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n       tree comp2 = build_new_op (info.loc, code, flags, comp, integer_zero_node,\n \t\t\t\t NULL_TREE, NULL, complain);\n       info.check (comp2);\n-      if (info.defining)\n+      if (defining)\n \tfinish_return_stmt (comp2);\n     }\n \n  out:\n-  if (info.defining)\n+  if (defining)\n     finish_compound_stmt (compound_stmt);\n   else\n     --cp_unevaluated_operand;\n@@ -1780,7 +1820,7 @@ synthesize_method (tree fndecl)\n   else if (sfk == sfk_comparison)\n     {\n       /* Pass tf_none so the function is just deleted if there's a problem.  */\n-      build_comparison_op (fndecl, tf_none);\n+      build_comparison_op (fndecl, true, tf_none);\n       need_body = false;\n     }\n \n@@ -1814,6 +1854,32 @@ synthesize_method (tree fndecl)\n \t      fndecl);\n }\n \n+/* Like synthesize_method, but don't actually synthesize defaulted comparison\n+   methods if their class is still incomplete.  Just deduce the return\n+   type in that case.  */\n+\n+void\n+maybe_synthesize_method (tree fndecl)\n+{\n+  if (special_function_p (fndecl) == sfk_comparison)\n+    {\n+      tree lhs = DECL_ARGUMENTS (fndecl);\n+      if (is_this_parameter (lhs))\n+\tlhs = cp_build_fold_indirect_ref (lhs);\n+      else\n+\tlhs = convert_from_reference (lhs);\n+      tree ctype = TYPE_MAIN_VARIANT (TREE_TYPE (lhs));\n+      if (!COMPLETE_TYPE_P (ctype))\n+\t{\n+\t  push_deferring_access_checks (dk_no_deferred);\n+\t  build_comparison_op (fndecl, false, tf_none);\n+\t  pop_deferring_access_checks ();\n+\t  return;\n+\t}\n+    }\n+  return synthesize_method (fndecl);\n+}\n+\n /* Build a reference to type TYPE with cv-quals QUALS, which is an\n    rvalue if RVALUE is true.  */\n \n@@ -2753,7 +2819,7 @@ maybe_explain_implicit_delete (tree decl)\n \t  inform (DECL_SOURCE_LOCATION (decl),\n \t\t  \"%q#D is implicitly deleted because the default \"\n \t\t  \"definition would be ill-formed:\", decl);\n-\t  build_comparison_op (decl, tf_warning_or_error);\n+\t  build_comparison_op (decl, false, tf_warning_or_error);\n \t}\n       else if (!informed)\n \t{\n@@ -2814,7 +2880,7 @@ explain_implicit_non_constexpr (tree decl)\n   if (sfk == sfk_comparison)\n     {\n       DECL_DECLARED_CONSTEXPR_P (decl) = true;\n-      build_comparison_op (decl, tf_warning_or_error);\n+      build_comparison_op (decl, false, tf_warning_or_error);\n       DECL_DECLARED_CONSTEXPR_P (decl) = false;\n     }\n   else"}, {"sha": "19e03369ffa654ec1a5fe4cabe84844075c9ed1a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=09d886e671f2230acca082e6579a69b8df8fb202", "patch": "@@ -25773,7 +25773,7 @@ maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)\n \treturn true;\n \n       ++function_depth;\n-      synthesize_method (fn);\n+      maybe_synthesize_method (fn);\n       --function_depth;\n       return !DECL_MAYBE_DELETED (fn);\n     }"}, {"sha": "b71ed4f83179cd70b276d2aace344c68aca78157", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq11.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq11.C?ref=09d886e671f2230acca082e6579a69b8df8fb202", "patch": "@@ -0,0 +1,43 @@\n+// PR c++/102490\n+// { dg-do run { target c++20 } }\n+\n+struct A\n+{\n+  unsigned char a : 1;\n+  unsigned char b : 1;\n+  constexpr bool operator== (const A &) const = default;\n+};\n+\n+struct B\n+{\n+  unsigned char a : 8;\n+  int : 0;\n+  unsigned char b : 7;\n+  constexpr bool operator== (const B &) const = default;\n+};\n+\n+struct C\n+{\n+  unsigned char a : 3;\n+  unsigned char b : 1;\n+  constexpr bool operator== (const C &) const = default;\n+};\n+\n+void\n+foo (C &x, int y)\n+{\n+  x.b = y;\n+}\n+\n+int\n+main ()\n+{\n+  A a{}, b{};\n+  B c{}, d{};\n+  C e{}, f{};\n+  a.b = 1;\n+  d.b = 1;\n+  foo (e, 0);\n+  foo (f, 1);\n+  return a == b || c == d || e == f;\n+}"}, {"sha": "8346e7e38968191c6c420c7a7b17429733080f1c", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq12.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq12.C?ref=09d886e671f2230acca082e6579a69b8df8fb202", "patch": "@@ -0,0 +1,5 @@\n+// PR c++/102490\n+// { dg-do run { target c++20 } }\n+// { dg-options \"-O2\" }\n+\n+#include \"spaceship-eq11.C\""}, {"sha": "cb521edf7f3f4a920a40c446b8158710da1d63e2", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq13.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq13.C?ref=09d886e671f2230acca082e6579a69b8df8fb202", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/98712\n+// { dg-do run { target c++20 } }\n+\n+struct S\n+{\n+  int s = 0;\n+  S(int s) : s(s) {}\n+  bool operator==(const S&) const = default;\n+};\n+\n+struct T : S\n+{\n+  T(int s) : S(s) {}\n+  constexpr bool operator==(const T&) const = default;\n+};\n+\n+int\n+main()\n+{\n+  if (T(0) == T(1))\n+    __builtin_abort ();\n+}"}, {"sha": "85b478437b8ed2fefc87b7572d6f4f8e7e25132b", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth12.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth12.C?ref=09d886e671f2230acca082e6579a69b8df8fb202", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/98712\n+// { dg-do run { target c++20 } }\n+\n+#include <compare>\n+\n+struct S\n+{\n+  int s = 0;\n+  S(int s) : s(s) {}\n+  auto operator<=>(const S&) const = default;\n+};\n+\n+struct T : S\n+{\n+  T(int s) : S(s) {}\n+  constexpr auto operator<=>(const T&) const = default;\n+};\n+\n+int\n+main()\n+{\n+  if (T(0) >= T(1))\n+    __builtin_abort ();\n+}"}, {"sha": "ab479d7353e0666632069615a74ccc835a70ce2e", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth13.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth13.C?ref=09d886e671f2230acca082e6579a69b8df8fb202", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile { target c++20 } }\n+\n+#include <compare>\n+#include <type_traits>\n+\n+struct E;\n+struct D {\n+  auto operator<=>(const D&) const = default;\n+  float f;\n+};\n+struct E : D {\n+  auto operator<=>(const E&) const = default;\n+  int i;\n+};\n+extern E e1, e2;\n+auto a = e1 <=> e2;\n+static_assert (std::is_same_v <decltype (a), std::partial_ordering>);\n+struct G;\n+struct H {\n+  constexpr auto operator<=>(const H&) const = default;\n+  float f;\n+};\n+struct G : H {\n+  constexpr auto operator<=>(const G&) const = default;\n+  int i;\n+};\n+extern G g1, g2;\n+auto c = g1 <=> g2;\n+static_assert (std::is_same_v <decltype (c), std::partial_ordering>);"}, {"sha": "369d3a3e9dd3f02d635022e9c4d7d49a00027373", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth14.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth14.C?ref=09d886e671f2230acca082e6579a69b8df8fb202", "patch": "@@ -0,0 +1,26 @@\n+// Test virtual <=>.\n+// { dg-do run { target c++20 } }\n+\n+#include <compare>\n+\n+struct E;\n+struct D {\n+  std::partial_ordering operator<=>(const D&) const = default;\n+  virtual std::partial_ordering operator<=>(const E&) const = 0;\n+  float f;\n+  D(float f): f(f) {}\n+};\n+struct E : D {\n+  std::partial_ordering operator<=>(const E&) const override = default;\n+  int i;\n+  E(float f, int i): D(f), i(i) {}\n+};\n+\n+int main()\n+{\n+  E e1{0.0,42};\n+  E e2{1.0,24};\n+  auto a = e1 <=> e2;\n+  if (!is_lt (e1 <=> e2))\n+    __builtin_abort();\n+}"}, {"sha": "886176522f5cf7aae28b4bc2f38bdf5ed7a1b320", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth8.C", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09d886e671f2230acca082e6579a69b8df8fb202/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth8.C?ref=09d886e671f2230acca082e6579a69b8df8fb202", "patch": "@@ -1,7 +1,18 @@\n // PR c++/94907\n // { dg-do compile { target c++20 } }\n \n-namespace std { struct strong_ordering { }; }\n+namespace std { struct strong_ordering {\n+  int _v;\n+  constexpr strong_ordering (int v) :_v(v) {}\n+  constexpr operator int (void) const { return _v; }\n+  static const strong_ordering less;\n+  static const strong_ordering equal;\n+  static const strong_ordering greater;\n+};\n+constexpr strong_ordering strong_ordering::less = -1;\n+constexpr strong_ordering strong_ordering::equal = 0;\n+constexpr strong_ordering strong_ordering::greater = 1;\n+}\n \n struct E;\n struct D {"}]}