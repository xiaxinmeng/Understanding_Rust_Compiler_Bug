{"sha": "765005dd6791889af2731073bb7c5f6305d14f01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY1MDA1ZGQ2NzkxODg5YWYyNzMxMDczYmI3YzVmNjMwNWQxNGYwMQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2020-04-16T15:06:31Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-17T08:14:18Z"}, "message": "[Ada] Crash in tagged type constructor with task components\n\n2020-06-17  Javier Miranda  <miranda@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch6.adb (Has_BIP_Extra_Formal): New subprogram.\n\t(Needs_BIP_Task_Actuals): Add support for the subprogram type\n\tinternally generated for dispatching calls.\n\t* exp_disp.adb (Expand_Dispatching_Call): Adding code to\n\texplicitly duplicate the extra formals of the target subprogram.\n\t* freeze.adb (Check_Extra_Formals): New subprogram.\n\t(Freeze_Subprogram): Fix decoration of Extra_Formals.\n\t* sem_ch3.adb (Derive_Subprogram): Fix decoration of\n\tExtra_Formals.", "tree": {"sha": "13c5a99380af84a166f21ac4f0965bdd34f21419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13c5a99380af84a166f21ac4f0965bdd34f21419"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/765005dd6791889af2731073bb7c5f6305d14f01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/765005dd6791889af2731073bb7c5f6305d14f01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/765005dd6791889af2731073bb7c5f6305d14f01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/765005dd6791889af2731073bb7c5f6305d14f01/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da901811dc478d45e7dc1028dce0bda8abbbee65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da901811dc478d45e7dc1028dce0bda8abbbee65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da901811dc478d45e7dc1028dce0bda8abbbee65"}], "stats": {"total": 200, "additions": 186, "deletions": 14}, "files": [{"sha": "daa672f01931ee8a60f0f9ac5fdb758c08731312", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 77, "deletions": 3, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765005dd6791889af2731073bb7c5f6305d14f01/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765005dd6791889af2731073bb7c5f6305d14f01/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=765005dd6791889af2731073bb7c5f6305d14f01", "patch": "@@ -272,6 +272,15 @@ package body Exp_Ch6 is\n    --  Expand simple return from function. In the case where we are returning\n    --  from a function body this is called by Expand_N_Simple_Return_Statement.\n \n+   function Has_BIP_Extra_Formal\n+     (E    : Entity_Id;\n+      Kind : BIP_Formal_Kind) return Boolean;\n+   --  Given a frozen subprogram, subprogram type, entry or entry family,\n+   --  return True if E has the BIP extra formal associated with Kind. It must\n+   --  be invoked with a frozen entity or a subprogram type of a dispatching\n+   --  call since we can only rely on the availability of the extra formals\n+   --  on these entities.\n+\n    procedure Insert_Post_Call_Actions (N : Node_Id; Post_Call : List_Id);\n    --  Insert the Post_Call list previously produced by routine Expand_Actuals\n    --  or Expand_Call_Helper into the tree.\n@@ -828,8 +837,8 @@ package body Exp_Ch6 is\n      (Func : Entity_Id;\n       Kind : BIP_Formal_Kind) return Entity_Id\n    is\n+      Extra_Formal  : Entity_Id := Extra_Formals (Func);\n       Formal_Suffix : constant String := BIP_Formal_Suffix (Kind);\n-      Extra_Formal : Entity_Id := Extra_Formals (Func);\n \n    begin\n       --  Maybe it would be better for each implicit formal of a build-in-place\n@@ -8230,6 +8239,41 @@ package body Exp_Ch6 is\n       end if;\n    end Freeze_Subprogram;\n \n+   --------------------------\n+   -- Has_BIP_Extra_Formal --\n+   --------------------------\n+\n+   function Has_BIP_Extra_Formal\n+     (E    : Entity_Id;\n+      Kind : BIP_Formal_Kind) return Boolean\n+   is\n+      Extra_Formal : Entity_Id := Extra_Formals (E);\n+\n+   begin\n+      --  We can only rely on the availability of the extra formals in frozen\n+      --  entities or in subprogram types of dispatching calls (since their\n+      --  extra formals are added when the target subprogram is frozen; see\n+      --  Expand_Dispatching_Call).\n+\n+      pragma Assert (Is_Frozen (E)\n+        or else (Ekind (E) = E_Subprogram_Type\n+                   and then Is_Dispatch_Table_Entity (E))\n+        or else (Is_Dispatching_Operation (E)\n+                   and then Is_Frozen (Find_Dispatching_Type (E))));\n+\n+      while Present (Extra_Formal) loop\n+         if Is_Build_In_Place_Entity (Extra_Formal)\n+           and then BIP_Suffix_Kind (Extra_Formal) = Kind\n+         then\n+            return True;\n+         end if;\n+\n+         Next_Formal_With_Extras (Extra_Formal);\n+      end loop;\n+\n+      return False;\n+   end Has_BIP_Extra_Formal;\n+\n    ------------------------------\n    -- Insert_Post_Call_Actions --\n    ------------------------------\n@@ -9871,6 +9915,10 @@ package body Exp_Ch6 is\n       Func_Typ : Entity_Id;\n \n    begin\n+      if Global_No_Tasking or else No_Run_Time_Mode then\n+         return False;\n+      end if;\n+\n       --  For thunks we must rely on their target entity; otherwise, given that\n       --  the profile of thunks for functions returning a limited interface\n       --  type returns a class-wide type, we would erroneously add these extra\n@@ -9887,8 +9935,34 @@ package body Exp_Ch6 is\n \n       Func_Typ := Underlying_Type (Etype (Subp_Id));\n \n-      return not Global_No_Tasking\n-        and then (Has_Task (Func_Typ) or else Might_Have_Tasks (Func_Typ));\n+      --  At first sight, for all the following cases, we could add assertions\n+      --  to ensure that if Func_Id is frozen then the computed result matches\n+      --  with the availability of the task master extra formal; unfortunately\n+      --  this is not feasible because we may be precisely freezing this entity\n+      --  (ie. Is_Frozen has been set by Freeze_Entity but it has not completed\n+      --  its work).\n+\n+      if Has_Task (Func_Typ) then\n+         return True;\n+\n+      elsif Ekind (Func_Id) = E_Function then\n+         return Might_Have_Tasks (Func_Typ);\n+\n+      --  Handle subprogram type internally generated for dispatching call. We\n+      --  can not rely on the return type of the subprogram type of dispatching\n+      --  calls since it is always a class-wide type (cf. Expand_Dispatching_\n+      --  _Call).\n+\n+      elsif Ekind (Func_Id) = E_Subprogram_Type then\n+         if Is_Dispatch_Table_Entity (Func_Id) then\n+            return Has_BIP_Extra_Formal (Func_Id, BIP_Task_Master);\n+         else\n+            return Might_Have_Tasks (Func_Typ);\n+         end if;\n+\n+      else\n+         raise Program_Error;\n+      end if;\n    end Needs_BIP_Task_Actuals;\n \n    -----------------------------------"}, {"sha": "1585998df32ec96a90b9deddb9c543950d3c8979", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765005dd6791889af2731073bb7c5f6305d14f01/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765005dd6791889af2731073bb7c5f6305d14f01/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=765005dd6791889af2731073bb7c5f6305d14f01", "patch": "@@ -1023,9 +1023,9 @@ package body Exp_Disp is\n       --  list including the creation of a new set of matching entities.\n \n       declare\n-         Old_Formal : Entity_Id := First_Formal (Subp);\n-         New_Formal : Entity_Id;\n-         Extra      : Entity_Id := Empty;\n+         Old_Formal  : Entity_Id := First_Formal (Subp);\n+         New_Formal  : Entity_Id;\n+         Last_Formal : Entity_Id := Empty;\n \n       begin\n          if Present (Old_Formal) then\n@@ -1049,7 +1049,7 @@ package body Exp_Disp is\n                --  errors when the itype is the completion of a type derived\n                --  from a private type.\n \n-               Extra := New_Formal;\n+               Last_Formal := New_Formal;\n                Next_Formal (Old_Formal);\n                exit when No (Old_Formal);\n \n@@ -1059,17 +1059,41 @@ package body Exp_Disp is\n             end loop;\n \n             Unlink_Next_Entity (New_Formal);\n-            Set_Last_Entity (Subp_Typ, Extra);\n+            Set_Last_Entity (Subp_Typ, Last_Formal);\n          end if;\n \n          --  Now that the explicit formals have been duplicated, any extra\n-         --  formals needed by the subprogram must be created.\n+         --  formals needed by the subprogram must be duplicated; we know\n+         --  that extra formals are available because they were added when\n+         --  the tagged type was frozen (see Expand_Freeze_Record_Type).\n \n-         if Present (Extra) then\n-            Set_Extra_Formal (Extra, Empty);\n-         end if;\n+         pragma Assert (Is_Frozen (Typ));\n+\n+         --  Warning: The addition of the extra formals cannot be performed\n+         --  here invoking Create_Extra_Formals since we must ensure that all\n+         --  the extra formals of the pointer type and the target subprogram\n+         --  match (and for functions that return a tagged type the profile of\n+         --  the built subprogram type always returns a class-wide type, which\n+         --  may affect the addition of some extra formals).\n+\n+         if Present (Last_Formal)\n+           and then Present (Extra_Formal (Last_Formal))\n+         then\n+            Old_Formal := Extra_Formal (Last_Formal);\n+            New_Formal := New_Copy (Old_Formal);\n \n-         Create_Extra_Formals (Subp_Typ);\n+            Set_Extra_Formal (Last_Formal, New_Formal);\n+            Set_Extra_Formals (Subp_Typ, New_Formal);\n+\n+            Old_Formal := Extra_Formal (Old_Formal);\n+            while Present (Old_Formal) loop\n+               Set_Extra_Formal (New_Formal, New_Copy (Old_Formal));\n+               New_Formal := Extra_Formal (New_Formal);\n+               Set_Scope (New_Formal, Subp_Typ);\n+\n+               Old_Formal := Extra_Formal (Old_Formal);\n+            end loop;\n+         end if;\n       end;\n \n       --  Complete description of pointer type, including size information, as"}, {"sha": "4862c7df084816b335d123fa3b1b860fe9628d8a", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765005dd6791889af2731073bb7c5f6305d14f01/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765005dd6791889af2731073bb7c5f6305d14f01/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=765005dd6791889af2731073bb7c5f6305d14f01", "patch": "@@ -8700,10 +8700,60 @@ package body Freeze is\n    -----------------------\n \n    procedure Freeze_Subprogram (E : Entity_Id) is\n+      function Check_Extra_Formals (E : Entity_Id) return Boolean;\n+      --  Return True if the decoration of the attributes associated with extra\n+      --  formals are properly set.\n+\n       procedure Set_Profile_Convention (Subp_Id : Entity_Id);\n       --  Set the conventions of all anonymous access-to-subprogram formals and\n       --  result subtype of subprogram Subp_Id to the convention of Subp_Id.\n \n+      -------------------------\n+      -- Check_Extra_Formals --\n+      -------------------------\n+\n+      function Check_Extra_Formals (E : Entity_Id) return Boolean is\n+         Last_Formal       : Entity_Id := Empty;\n+         Formal            : Entity_Id;\n+         Has_Extra_Formals : Boolean := False;\n+\n+      begin\n+         --  Check attribute Extra_Formal: if available it must be set only\n+         --  in the last formal of E\n+\n+         Formal := First_Formal (E);\n+         while Present (Formal) loop\n+            if Present (Extra_Formal (Formal)) then\n+               if Has_Extra_Formals then\n+                  return False;\n+               end if;\n+\n+               Has_Extra_Formals := True;\n+            end if;\n+\n+            Last_Formal := Formal;\n+            Next_Formal (Formal);\n+         end loop;\n+\n+         --  Check attribute Extra_Formals: if E has extra formals then this\n+         --  attribute must must point to the first extra formal of E.\n+\n+         if Has_Extra_Formals then\n+            return Present (Extra_Formals (E))\n+              and then Present (Extra_Formal (Last_Formal))\n+              and then Extra_Formal (Last_Formal) = Extra_Formals (E);\n+\n+         --  When E has no formals the first extra formal is available through\n+         --  the Extra_Formals attribute.\n+\n+         elsif Present (Extra_Formals (E)) then\n+            return No (First_Formal (E));\n+\n+         else\n+            return True;\n+         end if;\n+      end Check_Extra_Formals;\n+\n       ----------------------------\n       -- Set_Profile_Convention --\n       ----------------------------\n@@ -8840,9 +8890,27 @@ package body Freeze is\n \n       if not Has_Foreign_Convention (E) then\n          if No (Extra_Formals (E)) then\n-            Create_Extra_Formals (E);\n+\n+            --  Extra formals are shared by derived subprograms; therefore if\n+            --  the ultimate alias of E has been frozen before E then the extra\n+            --  formals have been added but the attribute Extra_Formals is\n+            --  still unset (and must be set now).\n+\n+            if Present (Alias (E))\n+              and then Present (Extra_Formals (Ultimate_Alias (E)))\n+              and then Last_Formal (Ultimate_Alias (E)) = Last_Formal (E)\n+            then\n+               pragma Assert (Is_Frozen (Ultimate_Alias (E)));\n+               pragma Assert (No (First_Formal (Ultimate_Alias (E)))\n+                 or else\n+                   Present (Extra_Formal (Last_Formal (Ultimate_Alias (E)))));\n+               Set_Extra_Formals (E, Extra_Formals (Ultimate_Alias (E)));\n+            else\n+               Create_Extra_Formals (E);\n+            end if;\n          end if;\n \n+         pragma Assert (Check_Extra_Formals (E));\n          Set_Mechanisms (E);\n \n          --  If this is convention Ada and a Valued_Procedure, that's odd"}, {"sha": "4c3212d3dee0f9c24fab560bcedd65046c2313d3", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765005dd6791889af2731073bb7c5f6305d14f01/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765005dd6791889af2731073bb7c5f6305d14f01/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=765005dd6791889af2731073bb7c5f6305d14f01", "patch": "@@ -15557,6 +15557,12 @@ package body Sem_Ch3 is\n          Next_Formal (Formal);\n       end loop;\n \n+      --  Extra formals are shared between the parent subprogram and the\n+      --  derived subprogram (implicit in the above copy of formals), and\n+      --  hence we must inherit also the reference to the first extra formal.\n+\n+      Set_Extra_Formals (New_Subp, Extra_Formals (Parent_Subp));\n+\n       --  If this derivation corresponds to a tagged generic actual, then\n       --  primitive operations rename those of the actual. Otherwise the\n       --  primitive operations rename those of the parent type, If the parent"}]}