{"sha": "cd1216d581b44f14b93a427bf2e95ee37e394b8b", "node_id": "C_kwDOANBUbNoAKGNkMTIxNmQ1ODFiNDRmMTRiOTNhNDI3YmYyZTk1ZWUzN2UzOTRiOGI", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-24T09:22:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-24T09:47:05Z"}, "message": "Split uninit analysis from predicate analysis\n\nThis splits the API collected in gimple-predicate-analysis.h into\nwhat I'd call a predicate and assorted functionality plus utility\nused by the uninit pass that happens to use that.  I've tried to\nbe minimalistic with refactoring, there's still recursive\ninstantiation of uninit_analysis, the new class encapsulating a\nseries of uninit analysis queries from the uninit pass.  But it\nat least should make the predicate part actually reusable and\nwhat predicate is dealt with is a little bit more clear in the\nuninit_analysis part.\n\nI will followup with moving the predicate implementation bits\ntogether in the gimple-predicate-analysis.cc file.\n\n\t* gimple-predicate-analysis.h (predicate): Split out\n\tnon-predicate related functionality into ..\n\t(uninit_analysis): .. this new class.\n\t* gimple-predicate-analysis.cc: Refactor into two classes.\n\t* tree-ssa-uninit.cc (find_uninit_use): Use uninit_analysis.", "tree": {"sha": "620bc5dcb99245da71c9ea66c33c2c19af2ec329", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/620bc5dcb99245da71c9ea66c33c2c19af2ec329"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd1216d581b44f14b93a427bf2e95ee37e394b8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd1216d581b44f14b93a427bf2e95ee37e394b8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd1216d581b44f14b93a427bf2e95ee37e394b8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd1216d581b44f14b93a427bf2e95ee37e394b8b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e50aebc813477655e0090b7de6578a7b11816ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e50aebc813477655e0090b7de6578a7b11816ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e50aebc813477655e0090b7de6578a7b11816ba"}], "stats": {"total": 223, "additions": 121, "deletions": 102}, "files": [{"sha": "8995c11a45ca4e01ca2a75ce6e5d364e26938dce", "filename": "gcc/gimple-predicate-analysis.cc", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1216d581b44f14b93a427bf2e95ee37e394b8b/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1216d581b44f14b93a427bf2e95ee37e394b8b/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=cd1216d581b44f14b93a427bf2e95ee37e394b8b", "patch": "@@ -483,19 +483,18 @@ find_var_cmp_const (pred_chain_union preds, gphi *phi, gimple **flag_def,\n    Checking recursively into (1), the compiler can find out that only\n    some_val (which is defined) can flow into (3) which is OK.  */\n \n-static bool\n-prune_phi_opnds (gphi *phi, unsigned opnds, gphi *flag_def,\n-\t\t tree boundary_cst, tree_code cmp_code,\n-\t\t predicate::func_t &eval,\n-\t\t hash_set<gphi *> *visited_phis,\n-\t\t bitmap *visited_flag_phis)\n+bool\n+uninit_analysis::prune_phi_opnds (gphi *phi, unsigned opnds, gphi *flag_def,\n+\t\t\t\t  tree boundary_cst, tree_code cmp_code,\n+\t\t\t\t  hash_set<gphi *> *visited_phis,\n+\t\t\t\t  bitmap *visited_flag_phis)\n {\n   /* The Boolean predicate guarding the PHI definition.  Initialized\n      lazily from PHI in the first call to is_use_guarded() and cached\n      for subsequent iterations.  */\n-  predicate def_preds (eval);\n+  uninit_analysis def_preds (m_eval);\n \n-  unsigned n = MIN (eval.max_phi_args, gimple_phi_num_args (flag_def));\n+  unsigned n = MIN (m_eval.max_phi_args, gimple_phi_num_args (flag_def));\n   for (unsigned i = 0; i < n; i++)\n     {\n       if (!MASK_TEST_BIT (opnds, i))\n@@ -532,9 +531,9 @@ prune_phi_opnds (gphi *phi, unsigned opnds, gphi *flag_def,\n \t  bitmap_set_bit (*visited_flag_phis, SSA_NAME_VERSION (phi_result));\n \n \t  /* Now recursively try to prune the interesting phi args.  */\n-\t  unsigned opnds_arg_phi = eval.phi_arg_set (phi_arg_def);\n+\t  unsigned opnds_arg_phi = m_eval.phi_arg_set (phi_arg_def);\n \t  if (!prune_phi_opnds (phi_arg_def, opnds_arg_phi, flag_arg_def,\n-\t\t\t\tboundary_cst, cmp_code, eval, visited_phis,\n+\t\t\t\tboundary_cst, cmp_code, visited_phis,\n \t\t\t\tvisited_flag_phis))\n \t    return false;\n \n@@ -554,7 +553,7 @@ prune_phi_opnds (gphi *phi, unsigned opnds, gphi *flag_def,\n \t  gimple *opnd_def = SSA_NAME_DEF_STMT (opnd);\n \t  if (gphi *opnd_def_phi = dyn_cast <gphi *> (opnd_def))\n \t    {\n-\t      unsigned opnds2 = eval.phi_arg_set (opnd_def_phi);\n+\t      unsigned opnds2 = m_eval.phi_arg_set (opnd_def_phi);\n \t      if (!MASK_EMPTY (opnds2))\n \t\t{\n \t\t  edge opnd_edge = gimple_phi_arg_edge (phi, i);\n@@ -578,9 +577,10 @@ prune_phi_opnds (gphi *phi, unsigned opnds, gphi *flag_def,\n    up the CFG nodes that it's dominated by.  *EDGES holds the result, and\n    VISITED is used for detecting cycles.  */\n \n-static void\n-collect_phi_def_edges (gphi *phi, basic_block cd_root, auto_vec<edge> *edges,\n-\t\t       predicate::func_t &eval, hash_set<gimple *> *visited)\n+void\n+uninit_analysis::collect_phi_def_edges (gphi *phi, basic_block cd_root,\n+\t\t\t\t\tvec<edge> *edges,\n+\t\t\t\t\thash_set<gimple *> *visited)\n {\n   if (visited->elements () == 0\n       && DEBUG_PREDICATE_ANALYZER\n@@ -607,9 +607,9 @@ collect_phi_def_edges (gphi *phi, basic_block cd_root, auto_vec<edge> *edges,\n \n \t  if (gimple_code (def) == GIMPLE_PHI\n \t      && dominated_by_p (CDI_DOMINATORS, gimple_bb (def), cd_root))\n-\t    collect_phi_def_edges (as_a<gphi *> (def), cd_root, edges, eval,\n+\t    collect_phi_def_edges (as_a<gphi *> (def), cd_root, edges,\n \t\t\t\t   visited);\n-\t  else if (!eval (opnd))\n+\t  else if (!m_eval (opnd))\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n@@ -635,7 +635,7 @@ collect_phi_def_edges (gphi *phi, basic_block cd_root, auto_vec<edge> *edges,\n \t      print_gimple_stmt (dump_file, phi, 0);\n \t    }\n \n-\t  if (!eval (opnd))\n+\t  if (!m_eval (opnd))\n \t    edges->safe_push (opnd_edge);\n \t}\n     }\n@@ -689,7 +689,7 @@ build_pred_expr (const pred_chain_union &preds, bool invert = false)\n /* Return a bitset of all PHI arguments or zero if there are too many.  */\n \n unsigned\n-predicate::func_t::phi_arg_set (gphi *phi)\n+uninit_analysis::func_t::phi_arg_set (gphi *phi)\n {\n   unsigned n = gimple_phi_num_args (phi);\n \n@@ -772,7 +772,8 @@ predicate::func_t::phi_arg_set (gphi *phi)\n      checked.  */\n \n bool\n-predicate::overlap (gphi *phi, unsigned opnds, hash_set<gphi *> *visited)\n+uninit_analysis::overlap (gphi *phi, unsigned opnds, hash_set<gphi *> *visited,\n+\t\t\t  const predicate &use_preds)\n {\n   gimple *flag_def = NULL;\n   tree boundary_cst = NULL_TREE;\n@@ -781,7 +782,7 @@ predicate::overlap (gphi *phi, unsigned opnds, hash_set<gphi *> *visited)\n   /* Find within the common prefix of multiple predicate chains\n      a predicate that is a comparison of a flag variable against\n      a constant.  */\n-  tree_code cmp_code = find_var_cmp_const (m_preds, phi, &flag_def,\n+  tree_code cmp_code = find_var_cmp_const (use_preds.chain (), phi, &flag_def,\n \t\t\t\t\t   &boundary_cst);\n   if (cmp_code == ERROR_MARK)\n     return true;\n@@ -790,7 +791,7 @@ predicate::overlap (gphi *phi, unsigned opnds, hash_set<gphi *> *visited)\n      value that is in conflict with the use guard/predicate.  */\n   gphi *phi_def = as_a<gphi *> (flag_def);\n   bool all_pruned = prune_phi_opnds (phi, opnds, phi_def, boundary_cst,\n-\t\t\t\t     cmp_code, m_eval, visited,\n+\t\t\t\t     cmp_code, visited,\n \t\t\t\t     &visited_flag_phis);\n \n   if (visited_flag_phis)\n@@ -1255,7 +1256,7 @@ can_be_invalidated_p (const pred_chain_union &preds, const pred_chain &guard)\n    the use guards in *THIS that guard the PHI's use.  */\n \n bool\n-predicate::use_cannot_happen (gphi *phi, unsigned opnds)\n+uninit_analysis::use_cannot_happen (gphi *phi, unsigned opnds, const predicate &use_preds)\n {\n   if (!m_eval.phi_arg_set (phi))\n     return false;\n@@ -1264,22 +1265,22 @@ predicate::use_cannot_happen (gphi *phi, unsigned opnds)\n      possible guard, there's no way of knowing which guard was true.\n      In that case compute the intersection of all use predicates\n      and use that.  */\n-  const pred_chain_union &phi_use_guards = m_preds;\n-  const pred_chain *use_guard = &phi_use_guards[0];\n+  const predicate &phi_use_guards = use_preds;\n+  const pred_chain *use_guard = &phi_use_guards.chain() [0];\n   pred_chain phi_use_guard_intersection = vNULL;\n-  if (phi_use_guards.length () != 1)\n+  if (phi_use_guards.chain ().length () != 1)\n     {\n       phi_use_guard_intersection = use_guard->copy ();\n-      for (unsigned i = 1; i < phi_use_guards.length (); ++i)\n+      for (unsigned i = 1; i < phi_use_guards.chain ().length (); ++i)\n \t{\n \t  for (unsigned j = 0; j < phi_use_guard_intersection.length ();)\n \t    {\n \t      unsigned k;\n-\t      for (k = 0; k < phi_use_guards[i].length (); ++k)\n-\t\tif (pred_equal_p (phi_use_guards[i][k],\n+\t      for (k = 0; k < phi_use_guards.chain ()[i].length (); ++k)\n+\t\tif (pred_equal_p (phi_use_guards.chain ()[i][k],\n \t\t\t\t  phi_use_guard_intersection[j]))\n \t\t  break;\n-\t      if (k == phi_use_guards[i].length ())\n+\t      if (k == phi_use_guards.chain ()[i].length ())\n \t\tphi_use_guard_intersection.unordered_remove (j);\n \t      else\n \t\tj++;\n@@ -1341,7 +1342,7 @@ predicate::use_cannot_happen (gphi *phi, unsigned opnds)\n \n       /* ...and convert it into a set of predicates guarding its\n \t definition.  */\n-      predicate def_preds (m_eval);\n+      predicate def_preds;\n       def_preds.init_from_control_deps (dep_chains, num_chains);\n       if (def_preds.is_empty ())\n \t/* If there's no predicate there's no basis to rule the use out.  */\n@@ -1745,13 +1746,16 @@ predicate::dump (gimple *stmt, const char *msg) const\n   fputc ('\\n', dump_file);\n }\n \n-/* Initialize *THIS with the predicates of the control dependence chains\n+/* Initialize USE_PREDS with the predicates of the control dependence chains\n    between the basic block DEF_BB that defines a variable of interst and\n    USE_BB that uses the variable, respectively.  */\n \n-predicate::predicate (basic_block def_bb, basic_block use_bb, func_t &eval)\n-  : m_preds (vNULL), m_eval (eval)\n+bool\n+uninit_analysis::init_use_preds (predicate &use_preds, basic_block def_bb,\n+\t\t\t\t basic_block use_bb)\n {\n+  gcc_assert (use_preds.is_empty ());\n+\n   /* Set CD_ROOT to the basic block closest to USE_BB that is the control\n      equivalent of (is guarded by the same predicate as) DEF_BB that also\n      dominates USE_BB.  */\n@@ -1799,7 +1803,8 @@ predicate::predicate (basic_block def_bb, basic_block use_bb, func_t &eval)\n      condition under which the definition in DEF_BB is used in USE_BB.\n      Each OR subexpression is represented by one element of DEP_CHAINS,\n      where each element consists of a series of AND subexpressions.  */\n-  init_from_control_deps (dep_chains, num_chains);\n+  use_preds.init_from_control_deps (dep_chains, num_chains);\n+  return !use_preds.is_empty ();\n }\n \n /* Release resources in *THIS.  */\n@@ -1820,9 +1825,6 @@ predicate::operator= (const predicate &rhs)\n   if (this == &rhs)\n     return *this;\n \n-  /* FIXME: Make this a compile-time constraint?  */\n-  gcc_assert (&m_eval == &rhs.m_eval);\n-\n   unsigned n = m_preds.length ();\n   for (unsigned i = 0; i != n; ++i)\n     m_preds[i].release ();\n@@ -1843,9 +1845,9 @@ predicate::operator= (const predicate &rhs)\n    Return true if a nonempty predicate has been obtained.  */\n \n bool\n-predicate::init_from_phi_def (gphi *phi)\n+uninit_analysis::init_from_phi_def (gphi *phi)\n {\n-  gcc_assert (is_empty ());\n+  gcc_assert (m_phi_def_preds.is_empty ());\n \n   basic_block phi_bb = gimple_bb (phi);\n   /* Find the closest dominating bb to be the control dependence root.  */\n@@ -1857,7 +1859,7 @@ predicate::init_from_phi_def (gphi *phi)\n      definitions of each of the PHI operands for which M_EVAL is false.  */\n   auto_vec<edge> def_edges;\n   hash_set<gimple *> visited_phis;\n-  collect_phi_def_edges (phi, cd_root, &def_edges, m_eval, &visited_phis);\n+  collect_phi_def_edges (phi, cd_root, &def_edges, &visited_phis);\n \n   unsigned nedges = def_edges.length ();\n   if (nedges == 0)\n@@ -1887,8 +1889,8 @@ predicate::init_from_phi_def (gphi *phi)\n   /* Convert control dependence chains to the predicate in *THIS under\n      which the PHI operands are defined to values for which M_EVAL is\n      false.  */\n-  init_from_control_deps (dep_chains, num_chains);\n-  return !is_empty ();\n+  m_phi_def_preds.init_from_control_deps (dep_chains, num_chains);\n+  return !m_phi_def_preds.is_empty ();\n }\n \n /* Compute the predicates that guard the use USE_STMT and check if\n@@ -1911,9 +1913,9 @@ predicate::init_from_phi_def (gphi *phi)\n    VISITED_PHIS is a pointer set of phis being visited.  */\n \n bool\n-predicate::is_use_guarded (gimple *use_stmt, basic_block use_bb,\n-\t\t\t   gphi *phi, unsigned opnds,\n-\t\t\t   hash_set<gphi *> *visited)\n+uninit_analysis::is_use_guarded (gimple *use_stmt, basic_block use_bb,\n+\t\t\t\t gphi *phi, unsigned opnds,\n+\t\t\t\t hash_set<gphi *> *visited)\n {\n   if (visited->add (phi))\n     return false;\n@@ -1928,12 +1930,12 @@ predicate::is_use_guarded (gimple *use_stmt, basic_block use_bb,\n   /* Try to build the predicate expression under which the PHI flows\n      into its use.  This will be empty if the PHI is defined and used\n      in the same bb.  */\n-  predicate use_preds (def_bb, use_bb, m_eval);\n-  if (use_preds.is_empty ())\n+  predicate use_preds;\n+  if (!init_use_preds (use_preds, def_bb, use_bb))\n     return false;\n \n   /* Try to prune the dead incoming phi edges.  */\n-  if (!use_preds.overlap (phi, opnds, visited))\n+  if (!overlap (phi, opnds, visited, use_preds))\n     {\n       if (DEBUG_PREDICATE_ANALYZER && dump_file)\n \tfputs (\"found predicate overlap\\n\", dump_file);\n@@ -1943,17 +1945,17 @@ predicate::is_use_guarded (gimple *use_stmt, basic_block use_bb,\n \n   /* We might be able to prove that if the control dependencies for OPNDS\n      are true, the control dependencies for USE_STMT can never be true.  */\n-  if (use_preds.use_cannot_happen (phi, opnds))\n+  if (use_cannot_happen (phi, opnds, use_preds))\n     return true;\n \n-  if (is_empty ())\n+  if (m_phi_def_preds.is_empty ())\n     {\n       /* Lazily initialize *THIS from PHI.  */\n       if (!init_from_phi_def (phi))\n \treturn false;\n \n-      simplify (phi);\n-      normalize (phi);\n+      m_phi_def_preds.simplify (phi);\n+      m_phi_def_preds.normalize (phi);\n     }\n \n   use_preds.simplify (use_stmt, /*is_use=*/true);\n@@ -1962,7 +1964,7 @@ predicate::is_use_guarded (gimple *use_stmt, basic_block use_bb,\n   /* Return true if the predicate guarding the valid definition (i.e.,\n      *THIS) is a superset of the predicate guarding the use (i.e.,\n      USE_PREDS).  */\n-  if (superset_of (use_preds))\n+  if (m_phi_def_preds.superset_of (use_preds))\n     return true;\n \n   return false;\n@@ -1971,8 +1973,8 @@ predicate::is_use_guarded (gimple *use_stmt, basic_block use_bb,\n /* Public interface to the above. */\n \n bool\n-predicate::is_use_guarded (gimple *stmt, basic_block use_bb, gphi *phi,\n-\t\t\t   unsigned opnds)\n+uninit_analysis::is_use_guarded (gimple *stmt, basic_block use_bb, gphi *phi,\n+\t\t\t\t unsigned opnds)\n {\n   hash_set<gphi *> visited;\n   return is_use_guarded (stmt, use_bb, phi, opnds, &visited);\n@@ -2141,7 +2143,7 @@ predicate::normalize (const pred_chain &chain)\n   while (!work_list.is_empty ())\n     {\n       pred_info pi = work_list.pop ();\n-      predicate pred (m_eval);\n+      predicate pred;\n       /* The predicate object is not modified here, only NORM_CHAIN and\n \t WORK_LIST are appended to.  */\n       pred.normalize (&norm_chain, pi, BIT_AND_EXPR, &work_list, &mark_set);\n@@ -2162,7 +2164,7 @@ predicate::normalize (gimple *use_or_def, bool is_use)\n       dump (use_or_def, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n     }\n \n-  predicate norm_preds (m_eval);\n+  predicate norm_preds;\n   for (unsigned i = 0; i < m_preds.length (); i++)\n     {\n       if (m_preds[i].length () != 1)"}, {"sha": "b4aa5de7e7b537b2db399a02f8d1997e376b4faf", "filename": "gcc/gimple-predicate-analysis.h", "status": "modified", "additions": 59, "deletions": 42, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1216d581b44f14b93a427bf2e95ee37e394b8b/gcc%2Fgimple-predicate-analysis.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1216d581b44f14b93a427bf2e95ee37e394b8b/gcc%2Fgimple-predicate-analysis.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.h?ref=cd1216d581b44f14b93a427bf2e95ee37e394b8b", "patch": "@@ -44,37 +44,11 @@ typedef vec<pred_chain, va_heap, vl_ptr> pred_chain_union;\n class predicate\n {\n  public:\n-  /* Base function object type used to determine whether an expression\n-     is of interest.  */\n-  struct func_t\n-  {\n-    typedef unsigned phi_arg_set_t;\n-\n-    /* Return true if the argument is an expression of interest.  */\n-    virtual bool operator()(tree) = 0;\n-    /* Return a bitset of PHI arguments of interest.  By default returns\n-       bitset with a bit set for each argument.  Should be called in\n-       the overriden function first and, if nonzero, the result then\n-       refined as appropriate.  */\n-    virtual phi_arg_set_t phi_arg_set (gphi *);\n-\n-    /* Maximum number of PHI arguments supported by phi_arg_set().  */\n-    static constexpr unsigned max_phi_args =\n-      sizeof (phi_arg_set_t) * CHAR_BIT;\n-  };\n-\n   /* Construct with the specified EVAL object.  */\n-  predicate (func_t &eval)\n-    : m_preds (vNULL), m_eval (eval) { }\n+  predicate () : m_preds (vNULL) { }\n \n   /* Copy.  */\n-  predicate (const predicate &rhs)\n-    : m_preds (vNULL), m_eval (rhs.m_eval)\n-    {\n-      *this = rhs;\n-    }\n-\n-  predicate (basic_block, basic_block, func_t &);\n+  predicate (const predicate &rhs) : m_preds (vNULL) { *this = rhs; }\n \n   ~predicate ();\n \n@@ -91,34 +65,23 @@ class predicate\n     return m_preds;\n   }\n \n-  /* Return true if the use by a statement in the basic block of\n-     a PHI operand is ruled out (i.e., guarded) by *THIS.  */\n-  bool is_use_guarded (gimple *, basic_block, gphi *, unsigned);\n-\n   void init_from_control_deps (const vec<edge> *, unsigned);\n \n   void dump (gimple *, const char *) const;\n \n   void normalize (gimple * = NULL, bool = false);\n   void simplify (gimple * = NULL, bool = false);\n \n-  bool is_use_guarded (gimple *, basic_block, gphi *, unsigned,\n-\t\t       hash_set<gphi *> *);\n-\n-private:\n-  bool includes (const pred_chain &) const;\n   bool superset_of (const predicate &) const;\n-  bool overlap (gphi *, unsigned, hash_set<gphi *> *);\n-  bool use_cannot_happen (gphi *, unsigned);\n \n-  bool init_from_phi_def (gphi *);\n+private:\n \n+  bool includes (const pred_chain &) const;\n   void push_pred (const pred_info &);\n \n   /* Normalization functions.  */\n   void normalize (pred_chain *, pred_info, tree_code, pred_chain *,\n \t\t  hash_set<tree> *);\n-\n   void normalize (const pred_info &);\n   void normalize (const pred_chain &);\n \n@@ -127,9 +90,63 @@ class predicate\n   bool simplify_3 ();\n   bool simplify_4 ();\n \n-private:\n   /* Representation of the predicate expression(s).  */\n   pred_chain_union m_preds;\n+};\n+\n+/* Represents a complex Boolean predicate expression.  */\n+class uninit_analysis\n+{\n+ public:\n+  /* Base function object type used to determine whether an expression\n+     is of interest.  */\n+  struct func_t\n+  {\n+    typedef unsigned phi_arg_set_t;\n+\n+    /* Return true if the argument is an expression of interest.  */\n+    virtual bool operator()(tree) = 0;\n+    /* Return a bitset of PHI arguments of interest.  By default returns\n+       bitset with a bit set for each argument.  Should be called in\n+       the overriden function first and, if nonzero, the result then\n+       refined as appropriate.  */\n+    virtual phi_arg_set_t phi_arg_set (gphi *);\n+\n+    /* Maximum number of PHI arguments supported by phi_arg_set().  */\n+    static constexpr unsigned max_phi_args =\n+      sizeof (phi_arg_set_t) * CHAR_BIT;\n+  };\n+\n+  /* Construct with the specified EVAL object.  */\n+  uninit_analysis (func_t &eval)\n+    : m_phi_def_preds (), m_eval (eval) { }\n+\n+  /* Copy.  */\n+  uninit_analysis (const uninit_analysis &rhs) = delete;\n+\n+  /* Assign.  */\n+  uninit_analysis& operator= (const uninit_analysis&) = delete;\n+\n+  /* Return true if the use by a statement in the basic block of\n+     a PHI operand is ruled out (i.e., guarded) by *THIS.  */\n+  bool is_use_guarded (gimple *, basic_block, gphi *, unsigned);\n+\n+private:\n+  bool is_use_guarded (gimple *, basic_block, gphi *, unsigned,\n+\t\t       hash_set<gphi *> *);\n+  bool prune_phi_opnds (gphi *, unsigned, gphi *, tree, tree_code,\n+\t\t\thash_set<gphi *> *, bitmap *);\n+  bool overlap (gphi *, unsigned, hash_set<gphi *> *, const predicate &);\n+  bool use_cannot_happen (gphi *, unsigned, const predicate &);\n+\n+  void collect_phi_def_edges (gphi *, basic_block, vec<edge> *,\n+\t\t\t      hash_set<gimple *> *);\n+  bool init_from_phi_def (gphi *);\n+  bool init_use_preds (predicate &, basic_block, basic_block);\n+\n+\n+  /* Representation of the predicate expression(s).  */\n+  predicate m_phi_def_preds;\n   /* Callback to evaluate an operand.  Return true if it's interesting.  */\n   func_t &m_eval;\n };"}, {"sha": "450ff0fd0627dd40f3147a1960c3db0cb440fb81", "filename": "gcc/tree-ssa-uninit.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1216d581b44f14b93a427bf2e95ee37e394b8b/gcc%2Ftree-ssa-uninit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1216d581b44f14b93a427bf2e95ee37e394b8b/gcc%2Ftree-ssa-uninit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.cc?ref=cd1216d581b44f14b93a427bf2e95ee37e394b8b", "patch": "@@ -1111,7 +1111,7 @@ compute_uninit_opnds_pos (gphi *phi)\n \n   unsigned n = gimple_phi_num_args (phi);\n   /* Bail out for phi with too many args.  */\n-  if (n > predicate::func_t::max_phi_args)\n+  if (n > uninit_analysis::func_t::max_phi_args)\n     return 0;\n \n   for (unsigned i = 0; i < n; ++i)\n@@ -1137,7 +1137,7 @@ compute_uninit_opnds_pos (gphi *phi)\n /* Function object type used to determine whether an expression\n    is of interest to the predicate analyzer.  */\n \n-struct uninit_undef_val_t: public predicate::func_t\n+struct uninit_undef_val_t: public uninit_analysis::func_t\n {\n   virtual bool operator()(tree) override;\n   virtual unsigned phi_arg_set (gphi *) override;\n@@ -1179,7 +1179,7 @@ find_uninit_use (gphi *phi, unsigned uninit_opnds,\n      lazily from PHI in the first call to is_use_guarded() and cached\n      for subsequent iterations.  */\n   uninit_undef_val_t eval;\n-  predicate def_preds (eval);\n+  uninit_analysis def_preds (eval);\n \n   use_operand_p use_p;\n   imm_use_iterator iter;"}]}