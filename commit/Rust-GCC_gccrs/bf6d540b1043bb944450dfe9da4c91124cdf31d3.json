{"sha": "bf6d540b1043bb944450dfe9da4c91124cdf31d3", "node_id": "C_kwDOANBUbNoAKGJmNmQ1NDBiMTA0M2JiOTQ0NDUwZGZlOWRhNGM5MTEyNGNkZjMxZDM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-05-23T14:57:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-23T14:57:55Z"}, "message": "Merge #1268\n\n1268: Fix Slice Type Layout r=philberty a=philberty\n\nSlices in Rust are represented by TypePaths such as '[i32]'. Though if you\r\nactually try to use this explicit type-path you will hit errors such as\r\nthis type has an unknown size at compile time. This is because this is\r\nactually what Rust calls a dynamically sized type. This means when you use\r\ntypes such as: '&[i32]' it is not actually a reference type to a slice. Its\r\na slice in its entirety this means for lack of a better word when you use\r\n'*const [i32]' or '&mut [i32]' we end up actually passing around a struct\r\nby value _not_ at pointer/reference to it.\r\n\r\nThis patch changes the type-layout so that we handle this layout change\r\nproperly. This patch will also need to be applied to str types which I\r\nbelieve have a similar layout for safety.\r\n\r\nThe patch also sets up TYPE_MAIN_VARIANT so that we can avoid unnessecary\r\nview_convert_expressions between *const [i32] and &mut [i32] which will\r\nhave the same layout.\r\n\r\nReference:\r\n\r\nhttps://doc.rust-lang.org/reference/dynamically-sized-types.html\r\n\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=672adac002939a2dab43b8d231adc1dc\r\n\r\nFixes #1232\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "6edb9359d5ac9d9b63938019e0fd9b336c1dd43e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6edb9359d5ac9d9b63938019e0fd9b336c1dd43e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf6d540b1043bb944450dfe9da4c91124cdf31d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJii6DzCRBK7hj4Ov3rIwAA6GcIAI9QwdUg8D23ALChd9HEKPrG\nmVpEMUDBxf85dAQT/GLf5xOjbq5hkDUigy53StdeK0oD/2bHNNPOdzZEG2Fw9Asd\n/5+4598MQOjgD7Ap79q9nkaSNxq+Qmpu+DKNnJ7g47HzAZukXDVDC3I+At47nGXI\ndw70/AA9Pr3Nn/aymDXgJSpjIUhrW2kuMk9+s5XHC7/G1LoxlnTbjLT10dw59Prl\n2bJMhz2CAxkcRUI6D0g5nQwUtbQh7Uk+ZyK2qxWEL2RdMqaqPBlN95io/v3+Rc7J\nuiEwYZlm8d39AAGUVFUYLXOAJTOeBUbaXKpKcUNrCh8oupeA5WtYb5T5f2Ka74k=\n=ATtj\n-----END PGP SIGNATURE-----\n", "payload": "tree 6edb9359d5ac9d9b63938019e0fd9b336c1dd43e\nparent 63762cc243c643c10aca7e07dfd6abe9b78748f8\nparent cd39861da5e1113207193bb8b3e6fb3dde92895f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1653317875 +0000\ncommitter GitHub <noreply@github.com> 1653317875 +0000\n\nMerge #1268\n\n1268: Fix Slice Type Layout r=philberty a=philberty\n\nSlices in Rust are represented by TypePaths such as '[i32]'. Though if you\r\nactually try to use this explicit type-path you will hit errors such as\r\nthis type has an unknown size at compile time. This is because this is\r\nactually what Rust calls a dynamically sized type. This means when you use\r\ntypes such as: '&[i32]' it is not actually a reference type to a slice. Its\r\na slice in its entirety this means for lack of a better word when you use\r\n'*const [i32]' or '&mut [i32]' we end up actually passing around a struct\r\nby value _not_ at pointer/reference to it.\r\n\r\nThis patch changes the type-layout so that we handle this layout change\r\nproperly. This patch will also need to be applied to str types which I\r\nbelieve have a similar layout for safety.\r\n\r\nThe patch also sets up TYPE_MAIN_VARIANT so that we can avoid unnessecary\r\nview_convert_expressions between *const [i32] and &mut [i32] which will\r\nhave the same layout.\r\n\r\nReference:\r\n\r\nhttps://doc.rust-lang.org/reference/dynamically-sized-types.html\r\n\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=672adac002939a2dab43b8d231adc1dc\r\n\r\nFixes #1232\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6d540b1043bb944450dfe9da4c91124cdf31d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf6d540b1043bb944450dfe9da4c91124cdf31d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6d540b1043bb944450dfe9da4c91124cdf31d3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63762cc243c643c10aca7e07dfd6abe9b78748f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63762cc243c643c10aca7e07dfd6abe9b78748f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63762cc243c643c10aca7e07dfd6abe9b78748f8"}, {"sha": "cd39861da5e1113207193bb8b3e6fb3dde92895f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd39861da5e1113207193bb8b3e6fb3dde92895f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd39861da5e1113207193bb8b3e6fb3dde92895f"}], "stats": {"total": 372, "additions": 345, "deletions": 27}, "files": [{"sha": "096b65f8b3945178e862e98dcfbb9392105005fa", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=bf6d540b1043bb944450dfe9da4c91124cdf31d3", "patch": "@@ -67,6 +67,17 @@ class Context\n     return type;\n   }\n \n+  tree insert_main_variant (tree type)\n+  {\n+    hashval_t h = type_hasher (type);\n+    auto it = main_variants.find (h);\n+    if (it != main_variants.end ())\n+      return it->second;\n+\n+    main_variants.insert ({h, type});\n+    return type;\n+  }\n+\n   ::Backend *get_backend () { return backend; }\n   Resolver::Resolver *get_resolver () { return resolver; }\n   Resolver::TypeCheckContext *get_tyctx () { return tyctx; }\n@@ -314,6 +325,7 @@ class Context\n   std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, tree>>>\n     mono_fns;\n   std::map<HirId, tree> implicit_pattern_bindings;\n+  std::map<hashval_t, tree> main_variants;\n \n   // To GCC middle-end\n   std::vector<tree> type_decls;"}, {"sha": "b176ed2cf36beb620f538a64f5db7b8910010f8b", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=bf6d540b1043bb944450dfe9da4c91124cdf31d3", "patch": "@@ -123,6 +123,11 @@ void\n CompileExpr::visit (HIR::BorrowExpr &expr)\n {\n   tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+  if (SLICE_TYPE_P (TREE_TYPE (main_expr)))\n+    {\n+      translated = main_expr;\n+      return;\n+    }\n \n   TyTy::BaseType *tyty = nullptr;\n   if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n@@ -164,6 +169,12 @@ CompileExpr::visit (HIR::DereferenceExpr &expr)\n     }\n \n   tree expected_type = TyTyResolveCompile::compile (ctx, tyty);\n+  if (SLICE_TYPE_P (TREE_TYPE (main_expr)) && SLICE_TYPE_P (expected_type))\n+    {\n+      translated = main_expr;\n+      return;\n+    }\n+\n   bool known_valid = true;\n   translated\n     = ctx->get_backend ()->indirect_expression (expected_type, main_expr,\n@@ -1092,6 +1103,32 @@ CompileExpr::type_cast_expression (tree type_to_cast_to, tree expr_tree,\n       return fold_build1_loc (location.gcc_location (), VIEW_CONVERT_EXPR,\n \t\t\t      type_to_cast_to, expr_tree);\n     }\n+  else if (TREE_CODE (type_to_cast_to) == POINTER_TYPE\n+\t   && SLICE_TYPE_P (TREE_TYPE (expr_tree)))\n+    {\n+      // returning a raw cast using NOP_EXPR seems to resut in an ICE:\n+      //\n+      // Analyzing compilation unit\n+      // Performing interprocedural optimizations\n+      //  <*free_lang_data> {heap 2644k} <visibility> {heap 2644k}\n+      //  <build_ssa_passes> {heap 2644k} <opt_local_passes> {heap 2644k}during\n+      //  GIMPLE pass: cddce\n+      // In function \u2018*T::as_ptr<i32>\u2019:\n+      // rust1: internal compiler error: in propagate_necessity, at\n+      // tree-ssa-dce.cc:984 0x1d5b43e propagate_necessity\n+      //         ../../gccrs/gcc/tree-ssa-dce.cc:984\n+      // 0x1d5e180 perform_tree_ssa_dce\n+      //         ../../gccrs/gcc/tree-ssa-dce.cc:1876\n+      // 0x1d5e2c8 tree_ssa_cd_dce\n+      //         ../../gccrs/gcc/tree-ssa-dce.cc:1920\n+      // 0x1d5e49a execute\n+      //         ../../gccrs/gcc/tree-ssa-dce.cc:1992\n+\n+      // this is returning the direct raw pointer of the slice an assumes a very\n+      // specific layout\n+      return ctx->get_backend ()->struct_field_expression (expr_tree, 0,\n+\t\t\t\t\t\t\t   location);\n+    }\n \n   return fold_convert_loc (location.gcc_location (), type_to_cast_to,\n \t\t\t   expr_tree);\n@@ -1261,9 +1298,13 @@ HIRCompileBase::resolve_adjustements (\n \n \tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n \t  case Resolver::Adjustment::AdjustmentType::MUT_REF: {\n-\t    tree ptrtype\n-\t      = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n-\t    e = address_expression (e, ptrtype, locus);\n+\t    if (!SLICE_TYPE_P (TREE_TYPE (e)))\n+\t      {\n+\t\ttree ptrtype\n+\t\t  = TyTyResolveCompile::compile (ctx,\n+\t\t\t\t\t\t adjustment.get_expected ());\n+\t\te = address_expression (e, ptrtype, locus);\n+\t      }\n \t  }\n \t  break;\n \n@@ -1619,6 +1660,15 @@ CompileExpr::visit (HIR::ArrayIndexExpr &expr)\n \t\t\t\t     index, expr.get_array_expr (),\n \t\t\t\t     expr.get_index_expr ());\n \n+      tree actual_type = TREE_TYPE (operator_overload_call);\n+      bool can_indirect = TYPE_PTR_P (actual_type) || TYPE_REF_P (actual_type);\n+      if (!can_indirect)\n+\t{\n+\t  // nothing to do\n+\t  translated = operator_overload_call;\n+\t  return;\n+\t}\n+\n       // lookup the expected type for this expression\n       TyTy::BaseType *tyty = nullptr;\n       bool ok"}, {"sha": "707b2afcbe3c9aa457c110718d6667d2a7aee3d8", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 62, "deletions": 20, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=bf6d540b1043bb944450dfe9da4c91124cdf31d3", "patch": "@@ -25,6 +25,13 @@\n namespace Rust {\n namespace Compile {\n \n+static const std::string RUST_ENUM_DISR_FIELD_NAME = \"RUST$ENUM$DISR\";\n+\n+TyTyResolveCompile::TyTyResolveCompile (Context *ctx, bool trait_object_mode)\n+  : ctx (ctx), trait_object_mode (trait_object_mode),\n+    translated (error_mark_node), recurisve_ops (0)\n+{}\n+\n tree\n TyTyResolveCompile::compile (Context *ctx, const TyTy::BaseType *ty,\n \t\t\t     bool trait_object_mode)\n@@ -42,8 +49,6 @@ TyTyResolveCompile::compile (Context *ctx, const TyTy::BaseType *ty,\n   return compiler.translated;\n }\n \n-static const std::string RUST_ENUM_DISR_FIELD_NAME = \"RUST$ENUM$DISR\";\n-\n // see: gcc/c/c-decl.cc:8230-8241\n // https://github.com/Rust-GCC/gccrs/blob/0024bc2f028369b871a65ceb11b2fddfb0f9c3aa/gcc/c/c-decl.c#L8229-L8241\n tree\n@@ -375,24 +380,7 @@ TyTyResolveCompile::visit (const TyTy::ArrayType &type)\n void\n TyTyResolveCompile::visit (const TyTy::SliceType &type)\n {\n-  std::vector<Backend::typed_identifier> fields;\n-\n-  tree element_type\n-    = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n-  tree data_field_ty = build_pointer_type (element_type);\n-  Backend::typed_identifier data_field (\"data\", data_field_ty, Location ());\n-  fields.push_back (std::move (data_field));\n-\n-  // lookup usize\n-  TyTy::BaseType *usize = nullptr;\n-  bool ok = ctx->get_tyctx ()->lookup_builtin (\"usize\", &usize);\n-  rust_assert (ok);\n-\n-  tree len_field_ty = TyTyResolveCompile::compile (ctx, usize);\n-  Backend::typed_identifier len_field (\"len\", len_field_ty, Location ());\n-  fields.push_back (std::move (len_field));\n-\n-  tree type_record = ctx->get_backend ()->struct_type (fields);\n+  tree type_record = create_slice_type_record (type);\n \n   std::string named_struct_str\n     = std::string (\"[\") + type.get_element_type ()->get_name () + \"]\";\n@@ -536,6 +524,21 @@ TyTyResolveCompile::visit (const TyTy::CharType &type)\n void\n TyTyResolveCompile::visit (const TyTy::ReferenceType &type)\n {\n+  const TyTy::SliceType *slice = nullptr;\n+  if (type.is_dyn_slice_type (&slice))\n+    {\n+      tree type_record = create_slice_type_record (*slice);\n+      std::string dyn_slice_type_str\n+\t= std::string (type.is_mutable () ? \"&mut \" : \"&\") + \"[\"\n+\t  + slice->get_element_type ()->get_name () + \"]\";\n+\n+      translated\n+\t= ctx->get_backend ()->named_type (dyn_slice_type_str, type_record,\n+\t\t\t\t\t   slice->get_locus ());\n+\n+      return;\n+    }\n+\n   tree base_compiled_type\n     = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n   if (type.is_mutable ())\n@@ -552,6 +555,21 @@ TyTyResolveCompile::visit (const TyTy::ReferenceType &type)\n void\n TyTyResolveCompile::visit (const TyTy::PointerType &type)\n {\n+  const TyTy::SliceType *slice = nullptr;\n+  if (type.is_dyn_slice_type (&slice))\n+    {\n+      tree type_record = create_slice_type_record (*slice);\n+      std::string dyn_slice_type_str\n+\t= std::string (type.is_mutable () ? \"*mut \" : \"*const \") + \"[\"\n+\t  + slice->get_element_type ()->get_name () + \"]\";\n+\n+      translated\n+\t= ctx->get_backend ()->named_type (dyn_slice_type_str, type_record,\n+\t\t\t\t\t   slice->get_locus ());\n+\n+      return;\n+    }\n+\n   tree base_compiled_type\n     = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n   if (type.is_mutable ())\n@@ -615,5 +633,29 @@ TyTyResolveCompile::visit (const TyTy::DynamicObjectType &type)\n \t\t\t\t\t\ttype.get_ident ().locus);\n }\n \n+tree\n+TyTyResolveCompile::create_slice_type_record (const TyTy::SliceType &type)\n+{\n+  // lookup usize\n+  TyTy::BaseType *usize = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_builtin (\"usize\", &usize);\n+  rust_assert (ok);\n+\n+  tree element_type\n+    = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n+  tree data_field_ty = build_pointer_type (element_type);\n+  Backend::typed_identifier data_field (\"data\", data_field_ty,\n+\t\t\t\t\ttype.get_locus ());\n+\n+  tree len_field_ty = TyTyResolveCompile::compile (ctx, usize);\n+  Backend::typed_identifier len_field (\"len\", len_field_ty, type.get_locus ());\n+\n+  tree record = ctx->get_backend ()->struct_type ({data_field, len_field});\n+  SLICE_FLAG (record) = 1;\n+  TYPE_MAIN_VARIANT (record) = ctx->insert_main_variant (record);\n+\n+  return record;\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "aefacea5e602dcf2f29a42bd689e3ae215f4824c", "filename": "gcc/rust/backend/rust-compile-type.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.h?ref=bf6d540b1043bb944450dfe9da4c91124cdf31d3", "patch": "@@ -60,11 +60,11 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n public:\n   static hashval_t type_hasher (tree type);\n \n+protected:\n+  tree create_slice_type_record (const TyTy::SliceType &type);\n+\n private:\n-  TyTyResolveCompile (Context *ctx, bool trait_object_mode)\n-    : ctx (ctx), trait_object_mode (trait_object_mode),\n-      translated (error_mark_node), recurisve_ops (0)\n-  {}\n+  TyTyResolveCompile (Context *ctx, bool trait_object_mode);\n \n   Context *ctx;\n   bool trait_object_mode;"}, {"sha": "18a2df6b97ad2ebbbb76992f9ac413e47b74b91a", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=bf6d540b1043bb944450dfe9da4c91124cdf31d3", "patch": "@@ -218,6 +218,11 @@ HIRCompileBase::coercion_site (tree rvalue, const TyTy::BaseType *rval,\n \t= static_cast<const TyTy::ReferenceType *> (expected);\n       const TyTy::ReferenceType *act\n \t= static_cast<const TyTy::ReferenceType *> (actual);\n+      if (act->is_dyn_slice_type ())\n+\t{\n+\t  // nothing to do\n+\t  return rvalue;\n+\t}\n \n       tree expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n       tree deref_rvalue\n@@ -227,6 +232,8 @@ HIRCompileBase::coercion_site (tree rvalue, const TyTy::BaseType *rval,\n       tree coerced\n \t= coercion_site (deref_rvalue, act->get_base (), exp->get_base (),\n \t\t\t lvalue_locus, rvalue_locus);\n+      if (exp->is_dyn_slice_type () && SLICE_TYPE_P (TREE_TYPE (coerced)))\n+\treturn coerced;\n \n       return address_expression (coerced,\n \t\t\t\t build_reference_type (TREE_TYPE (coerced)),\n@@ -249,13 +256,25 @@ HIRCompileBase::coercion_site (tree rvalue, const TyTy::BaseType *rval,\n \t{\n \t  const TyTy::ReferenceType *act\n \t    = static_cast<const TyTy::ReferenceType *> (actual);\n+\t  if (act->is_dyn_slice_type ())\n+\t    {\n+\t      // nothing to do\n+\t      return rvalue;\n+\t    }\n+\n \t  actual_base = act->get_base ();\n \t  expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n \t}\n       else if (actual->get_kind () == TyTy::TypeKind::POINTER)\n \t{\n \t  const TyTy::PointerType *act\n \t    = static_cast<const TyTy::PointerType *> (actual);\n+\t  if (act->is_dyn_slice_type ())\n+\t    {\n+\t      // nothing to do\n+\t      return rvalue;\n+\t    }\n+\n \t  actual_base = act->get_base ();\n \t  expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n \t}"}, {"sha": "2b480ada400b15d63490f5e8458c49fba928b212", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=bf6d540b1043bb944450dfe9da4c91124cdf31d3", "patch": "@@ -74,6 +74,12 @@\n   (INDIRECT_REF_P (NODE) && TREE_TYPE (TREE_OPERAND (NODE, 0))                 \\\n    && TYPE_REF_P (TREE_TYPE (TREE_OPERAND ((NODE), 0))))\n \n+// this is a helper to differentiate RECORD types between actual records and\n+// slices\n+#define SLICE_FLAG TREE_LANG_FLAG_0\n+#define SLICE_TYPE_P(TYPE)                                                     \\\n+  (TREE_CODE (TYPE) == RECORD_TYPE && TREE_LANG_FLAG_0 (TYPE))\n+\n namespace Rust {\n \n // forked from gcc/cp/cvt.cc convert_to_void"}, {"sha": "31d26dc3340d98fe8f317c77af593c8cf6d18d5a", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=bf6d540b1043bb944450dfe9da4c91124cdf31d3", "patch": "@@ -2180,6 +2180,21 @@ class ReferenceType : public BaseType\n \n   bool is_mutable () const { return mut == Mutability::Mut; }\n \n+  bool is_dyn_slice_type () const\n+  {\n+    return get_base ()->destructure ()->get_kind () == TyTy::TypeKind::SLICE;\n+  }\n+\n+  bool is_dyn_slice_type (const TyTy::SliceType **slice) const\n+  {\n+    const TyTy::BaseType *element = get_base ()->destructure ();\n+    if (element->get_kind () != TyTy::TypeKind::SLICE)\n+      return false;\n+\n+    *slice = static_cast<const TyTy::SliceType *> (element);\n+    return true;\n+  }\n+\n private:\n   TyVar base;\n   Mutability mut;\n@@ -2241,6 +2256,21 @@ class PointerType : public BaseType\n \n   bool is_const () const { return mut == Mutability::Imm; }\n \n+  bool is_dyn_slice_type () const\n+  {\n+    return get_base ()->destructure ()->get_kind () == TyTy::TypeKind::SLICE;\n+  }\n+\n+  bool is_dyn_slice_type (const TyTy::SliceType **slice) const\n+  {\n+    const TyTy::BaseType *element = get_base ()->destructure ();\n+    if (element->get_kind () != TyTy::TypeKind::SLICE)\n+      return false;\n+\n+    *slice = static_cast<const TyTy::SliceType *> (element);\n+    return true;\n+  }\n+\n private:\n   TyVar base;\n   Mutability mut;"}, {"sha": "983ea41d7d89cd9d33e217dea2eb5d8253d85c44", "filename": "gcc/testsuite/rust/execute/torture/issue-1232.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1232.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6d540b1043bb944450dfe9da4c91124cdf31d3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1232.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1232.rs?ref=bf6d540b1043bb944450dfe9da4c91124cdf31d3", "patch": "@@ -0,0 +1,159 @@\n+// { dg-additional-options \"-w\" }\n+// { dg-output \"slice_access=3\\n\" }\n+extern \"rust-intrinsic\" {\n+    fn offset<T>(dst: *const T, offset: isize) -> *const T;\n+}\n+\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct FatPtr<T> {\n+    data: *const T,\n+    len: usize,\n+}\n+\n+pub union Repr<T> {\n+    rust: *const [T],\n+    rust_mut: *mut [T],\n+    raw: FatPtr<T>,\n+}\n+\n+pub enum Option<T> {\n+    None,\n+    Some(T),\n+}\n+\n+#[lang = \"Range\"]\n+pub struct Range<Idx> {\n+    pub start: Idx,\n+    pub end: Idx,\n+}\n+\n+#[lang = \"const_slice_ptr\"]\n+impl<T> *const [T] {\n+    pub const fn len(self) -> usize {\n+        let a = unsafe { Repr { rust: self }.raw };\n+        a.len\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}\n+\n+#[lang = \"const_ptr\"]\n+impl<T> *const T {\n+    pub const unsafe fn offset(self, count: isize) -> *const T {\n+        unsafe { offset(self, count) }\n+    }\n+\n+    pub const unsafe fn add(self, count: usize) -> Self {\n+        unsafe { self.offset(count as isize) }\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}\n+\n+const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n+    unsafe {\n+        Repr {\n+            raw: FatPtr { data, len },\n+        }\n+        .rust\n+    }\n+}\n+\n+#[lang = \"index\"]\n+trait Index<Idx> {\n+    type Output;\n+\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+pub unsafe trait SliceIndex<T> {\n+    type Output;\n+\n+    fn get(self, slice: &T) -> Option<&Self::Output>;\n+\n+    unsafe fn get_unchecked(self, slice: *const T) -> *const Self::Output;\n+\n+    fn index(self, slice: &T) -> &Self::Output;\n+}\n+\n+unsafe impl<T> SliceIndex<[T]> for usize {\n+    type Output = T;\n+\n+    fn get(self, slice: &[T]) -> Option<&T> {\n+        unsafe { Option::Some(&*self.get_unchecked(slice)) }\n+    }\n+\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {\n+        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n+        // cannot be longer than `isize::MAX`. They also guarantee that\n+        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n+        // so the call to `add` is safe.\n+        unsafe { slice.as_ptr().add(self) }\n+    }\n+\n+    fn index(self, slice: &[T]) -> &T {\n+        // N.B., use intrinsic indexing\n+        // &(*slice)[self]\n+        unsafe { &*self.get_unchecked(slice) }\n+    }\n+}\n+\n+unsafe impl<T> SliceIndex<[T]> for Range<usize> {\n+    type Output = [T];\n+\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        if self.start > self.end\n+        /* || self.end > slice.len() */\n+        {\n+            Option::None\n+        } else {\n+            unsafe { Option::Some(&*self.get_unchecked(slice)) }\n+        }\n+    }\n+\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        unsafe {\n+            let a: *const T = slice.as_ptr();\n+            let b: *const T = a.add(self.start);\n+            slice_from_raw_parts(b, self.end - self.start)\n+        }\n+    }\n+\n+    fn index(self, slice: &[T]) -> &[T] {\n+        unsafe { &*self.get_unchecked(slice) }\n+    }\n+}\n+\n+impl<T, I> Index<I> for [T]\n+where\n+    I: SliceIndex<[T]>,\n+{\n+    type Output = I::Output;\n+\n+    fn index(&self, index: I) -> &I::Output {\n+        index.index(self)\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let array = [1, 2, 3, 4, 5];\n+    let slice = &array[1..3];\n+    let slice_access = slice[1];\n+\n+    unsafe {\n+        let a = \"slice_access=%i\\n\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, slice_access);\n+    }\n+\n+    0\n+}"}]}