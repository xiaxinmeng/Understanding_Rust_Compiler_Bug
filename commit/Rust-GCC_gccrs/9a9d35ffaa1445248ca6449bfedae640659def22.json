{"sha": "9a9d35ffaa1445248ca6449bfedae640659def22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE5ZDM1ZmZhYTE0NDUyNDhjYTY0NDliZmVkYWU2NDA2NTlkZWYyMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T13:19:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T13:19:06Z"}, "message": "[multiple changes]\n\n2014-08-04  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Add section on use of address clause for memory\n\tmapped I/O.\n\n2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Subtype_Declaration): A subtype, in\n\tparticular the subtype created for a generic actual, inherits\n\tinvariant information from the base type.\n\nFrom-SVN: r213589", "tree": {"sha": "36cad7bd8435dccb490025727dad4822aa8c3c27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36cad7bd8435dccb490025727dad4822aa8c3c27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a9d35ffaa1445248ca6449bfedae640659def22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9d35ffaa1445248ca6449bfedae640659def22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a9d35ffaa1445248ca6449bfedae640659def22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9d35ffaa1445248ca6449bfedae640659def22/comments", "author": null, "committer": null, "parents": [{"sha": "c2a2dbcc6ba197d3e6921ac220a097ac617c1493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a2dbcc6ba197d3e6921ac220a097ac617c1493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2a2dbcc6ba197d3e6921ac220a097ac617c1493"}], "stats": {"total": 78, "additions": 78, "deletions": 0}, "files": [{"sha": "ca0d4e8429f21bd11ae864015f04cde34dbc5c5c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9d35ffaa1445248ca6449bfedae640659def22/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9d35ffaa1445248ca6449bfedae640659def22/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9a9d35ffaa1445248ca6449bfedae640659def22", "patch": "@@ -1,3 +1,14 @@\n+2014-08-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Add section on use of address clause for memory\n+\tmapped I/O.\n+\n+2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Subtype_Declaration): A subtype, in\n+\tparticular the subtype created for a generic actual, inherits\n+\tinvariant information from the base type.\n+\n 2014-08-04  Robert Dewar  <dewar@adacore.com>\n \n \t* aspects.ads, aspects.adb: Add entries for aspect Obsolescent."}, {"sha": "f1f0ccf13e80a7e6d0d1870a80e654997d57ba1b", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9d35ffaa1445248ca6449bfedae640659def22/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9d35ffaa1445248ca6449bfedae640659def22/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=9a9d35ffaa1445248ca6449bfedae640659def22", "patch": "@@ -14813,6 +14813,7 @@ source file location.\n * Handling of Records with Holes::\n * Enumeration Clauses::\n * Address Clauses::\n+* Use of Address Clauses for Memory-Mapped I/O::\n * Effect of Convention on Representation::\n * Conventions and Anonymous Access Types::\n * Determining the Representations chosen by GNAT::\n@@ -16606,6 +16607,64 @@ end Overwrite_Array;\n then the program compiles without the warning and when run will generate\n the output @code{X was not clobbered}.\n \n+@node Use of Address Clauses for Memory-Mapped I/O\n+@section Use of Address Clauses for Memory-Mapped I/O\n+@cindex Memory-mapped I/O\n+\n+A common pattern is to use an address clause to map an atomic variable to\n+a location in memory that corresponds to a memory-mapped I/O operation or\n+operations, for example:\n+\n+@smallexample @c ada\n+    type Mem_Word is record\n+       A,B,C,D : Byte;\n+    end record;\n+    pragma Atomic (Mem_Word);\n+    for Mem_Word_Size use 32;\n+\n+    Mem : Mem_Word;\n+    for Mem'Address use some-address;\n+    ...\n+    Temp := Mem;\n+    Temp.A := 32;\n+    Mem := Temp;\n+@end smallexample\n+\n+@noindent\n+For a full access (reference or modification) of the variable (Mem) in\n+this case, as in the above examples, GNAT guarantees that the entire atomic\n+word will be accessed. It is not clear whether the RM requires this. For\n+example in the above, can the compiler reference only the Mem.A field as\n+an optimization? Whatever the answer to this question is, GNAT makes the\n+guarantee that for such a reference, the entire word is read or written.\n+\n+A problem arises with a component access such as:\n+\n+@smallexample @c ada\n+    Mem.A := 32;\n+@end smallexample\n+\n+@noindent\n+Note that the component A is not declared as atomic. This means that it is\n+not clear what this assignment means. It could correspond to full word read\n+and write as given in the first example, or on architectures that supported\n+such an operation it might be a single byte store instruction. The RM does\n+not have anything to say in this situation, and GNAT does not make any\n+guarantee. The code generated may vary from target to target. GNAT will issue\n+a warning in such a case:\n+\n+@smallexample @c ada\n+    Mem.A := 32;\n+    |\n+    >>> warning: access to non-atomic component of atomic array,\n+        may cause unexpected accesses to atomic object\n+@end smallexample\n+\n+@noindent\n+It is best to be explicit in this situation, by either declaring the\n+components to be atomic if you want the byte store, or explicitly writing\n+the full word access sequence if that is what the hardware requires.\n+\n @node Effect of Convention on Representation\n @section Effect of Convention on Representation\n @cindex Convention, effect on representation"}, {"sha": "dd71672d39b0988d16dafe5b8c2b9ef7ab75ad83", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9d35ffaa1445248ca6449bfedae640659def22/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9d35ffaa1445248ca6449bfedae640659def22/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=9a9d35ffaa1445248ca6449bfedae640659def22", "patch": "@@ -4944,6 +4944,14 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  A type invariant applies to any subtype in its scope, in particular\n+      --  to a generic actual.\n+\n+      if Has_Invariants (T) and then In_Open_Scopes (Scope (T)) then\n+         Set_Has_Invariants (Id);\n+         Set_Invariant_Procedure (Id, Invariant_Procedure (T));\n+      end if;\n+\n       --  Make sure that generic actual types are properly frozen. The subtype\n       --  is marked as a generic actual type when the enclosing instance is\n       --  analyzed, so here we identify the subtype from the tree structure."}]}