{"sha": "fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJmMWMzNGJmYTgzYTRiMDhmOWVlODY1MTI1MGNkOTg5ZDBiZDBiYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-11-16T08:34:38Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-11-16T08:34:38Z"}, "message": "cp-tree.h (DECL_TEMPLATE_INSTANTIATED): New macro.\n\n\t* cp-tree.h (DECL_TEMPLATE_INSTANTIATED): New macro.\n\t* decl.c (duplicate_decls): Remove special-case code to deal with\n\ttemplate friends, and just do the obvious thing.\n\t* pt.c (register_specialization): Tweak for clarity, and also to\n\tclear DECL_INITIAL for an instantiation before it is merged with a\n\tspecialization.\n\t(check_explicit_specialization): Fix indentation.\n\t(tsubst_friend_function): Handle both definitions in friend\n\tdeclaration and outside friend declarations.\n\t(tsubst_decl): Don't clear DECL_INITIAL for an instantiation.\n\t(regenerate_decl_from_template): Tweak accordingly.\n\t(instantiate_decl): Likewise.\n\nFrom-SVN: r23674", "tree": {"sha": "4e2640645217b40b287d5f8c413c905bb4a702c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e2640645217b40b287d5f8c413c905bb4a702c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/comments", "author": null, "committer": null, "parents": [{"sha": "848b92e1cc58303988dadd22623b904697084092", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848b92e1cc58303988dadd22623b904697084092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/848b92e1cc58303988dadd22623b904697084092"}], "stats": {"total": 190, "additions": 127, "deletions": 63}, "files": [{"sha": "bbd866471bb50d950a36fb19e2f8c9ed4d276fb5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba", "patch": "@@ -1,3 +1,18 @@\n+1998-11-16  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (DECL_TEMPLATE_INSTANTIATED): New macro.\n+\t* decl.c (duplicate_decls): Remove special-case code to deal with\n+\ttemplate friends, and just do the obvious thing.\n+\t* pt.c (register_specialization): Tweak for clarity, and also to\n+\tclear DECL_INITIAL for an instantiation before it is merged with a\n+\tspecialization.\n+\t(check_explicit_specialization): Fix indentation.\n+\t(tsubst_friend_function): Handle both definitions in friend\n+\tdeclaration and outside friend declarations.\n+\t(tsubst_decl): Don't clear DECL_INITIAL for an instantiation.\n+\t(regenerate_decl_from_template): Tweak accordingly.\n+\t(instantiate_decl): Likewise.\n+\t\n 1998-11-16  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (cplus_expand_expr_stmt): Promote warning about naked"}, {"sha": "8cf5594a325095a2f5f405ec8c75b81b2804a0e3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba", "patch": "@@ -65,6 +65,7 @@ Boston, MA 02111-1307, USA.  */\n    Usage of DECL_LANG_FLAG_?:\n    0: DECL_ERROR_REPORTED (in VAR_DECL).\n    1: C_TYPEDEF_EXPLICITLY_SIGNED (in TYPE_DECL).\n+      DECL_TEMPLATE_INSTANTIATED (in a VAR_DECL or a FUNCTION_DECL)\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n    3: DECL_IN_AGGR_P.\n    4: DECL_MAYBE_TEMPLATE.\n@@ -1812,6 +1813,12 @@ extern int flag_new_for_scope;\n \n /* This function may be a guiding decl for a template.  */\n #define DECL_MAYBE_TEMPLATE(NODE) DECL_LANG_FLAG_4 (NODE)\n+\n+/* Nonzero if this VAR_DECL or FUNCTION_DECL has already been\n+   instantiated, i.e. its definition has been generated from the\n+   pattern given in the the template.  */\n+#define DECL_TEMPLATE_INSTANTIATED(NODE) DECL_LANG_FLAG_1(NODE)\n+\n /* We know what we're doing with this decl now.  */\n #define DECL_INTERFACE_KNOWN(NODE) DECL_LANG_FLAG_5 (NODE)\n "}, {"sha": "a9779f914c9de4972365269638c18c800c921f5d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba", "patch": "@@ -2989,9 +2989,6 @@ duplicate_decls (newdecl, olddecl)\n \t\t\t     DECL_TEMPLATE_RESULT (olddecl)))\n \tcp_error (\"invalid redeclaration of %D\", newdecl);\n       TREE_TYPE (olddecl) = TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl));\n-      DECL_TEMPLATE_PARMS (olddecl) = DECL_TEMPLATE_PARMS (newdecl);\n-      if (DECL_TEMPLATE_INFO (newdecl))\n-\tDECL_TEMPLATE_INFO (olddecl) = DECL_TEMPLATE_INFO (newdecl);\n       DECL_TEMPLATE_SPECIALIZATIONS (olddecl) \n \t= chainon (DECL_TEMPLATE_SPECIALIZATIONS (olddecl),\n \t\t   DECL_TEMPLATE_SPECIALIZATIONS (newdecl));\n@@ -3123,11 +3120,7 @@ duplicate_decls (newdecl, olddecl)\n       DECL_IN_AGGR_P (newdecl) = DECL_IN_AGGR_P (olddecl);\n       DECL_ACCESS (newdecl) = DECL_ACCESS (olddecl);\n       DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);\n-      if (DECL_TEMPLATE_INFO (newdecl) == NULL_TREE)\n-\t{\n-\t  DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n-\t  DECL_USE_TEMPLATE (newdecl) = DECL_USE_TEMPLATE (olddecl);\n-\t}\n+      DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n       olddecl_friend = DECL_FRIEND_P (olddecl);\n     }\n "}, {"sha": "655a72b8dd9b8234dd9ba4804f85627972d1426c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 89, "deletions": 52, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba", "patch": "@@ -831,15 +831,22 @@ register_specialization (spec, tmpl, args)\n \n \t\t       We transform the existing DECL in place so that\n \t\t       any pointers to it become pointers to the\n-\t\t       updated declaration.  */\n-\t\t    duplicate_decls (spec, TREE_VALUE (s));\n-\t\t    return TREE_VALUE (s);\n+\t\t       updated declaration.  \n+\n+\t\t       If there was a definition for the template, but\n+\t\t       not for the specialization, we want this to\n+\t\t       look as if there is no definition, and vice\n+\t\t       versa.  */\n+\t\t    DECL_INITIAL (fn) = NULL_TREE;\n+\t\t    duplicate_decls (spec, fn);\n+\n+\t\t    return fn;\n \t\t  }\n \t      }\n \t    else if (DECL_TEMPLATE_SPECIALIZATION (fn))\n \t      {\n-\t\tduplicate_decls (spec, TREE_VALUE (s));\n-\t\treturn TREE_VALUE (s);\n+\t\tduplicate_decls (spec, fn);\n+\t\treturn fn;\n \t      }\n \t  }\n       }\n@@ -1369,7 +1376,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t    /* This is not really a declaration of a specialization.\n \t       It's just the name of an instantiation.  But, it's not\n \t       a request for an instantiation, either.  */\n-\t      SET_DECL_IMPLICIT_INSTANTIATION (decl);\n+\t    SET_DECL_IMPLICIT_INSTANTIATION (decl);\n \n \t  /* Register this specialization so that we can find it\n \t     again.  */\n@@ -4247,16 +4254,30 @@ tsubst_friend_function (decl, args)\n   if (DECL_NAMESPACE_SCOPE_P (new_friend))\n     {\n       tree old_decl;\n-      tree new_friend_args;\n-\n+      tree new_friend_template_info;\n+      tree new_friend_result_template_info;\n+      int  new_friend_is_defn;\n+\n+      /* We must save some information from NEW_FRIEND before calling\n+\t duplicate decls since that function will free NEW_FRIEND if\n+\t possible.  */\n+      new_friend_template_info = DECL_TEMPLATE_INFO (new_friend);\n       if (TREE_CODE (new_friend) == TEMPLATE_DECL)\n-\t/* This declaration is a `primary' template.  */\n-\tDECL_PRIMARY_TEMPLATE (new_friend) = new_friend;\n+\t{\n+\t  /* This declaration is a `primary' template.  */\n+\t  DECL_PRIMARY_TEMPLATE (new_friend) = new_friend;\n+\t  \n+\t  new_friend_is_defn \n+\t    = DECL_INITIAL (DECL_RESULT (new_friend)) != NULL_TREE;\n+\t  new_friend_result_template_info\n+\t    = DECL_TEMPLATE_INFO (DECL_RESULT (new_friend));\n+\t}\n+      else\n+\t{\n+\t  new_friend_is_defn = DECL_INITIAL (new_friend) != NULL_TREE;\n+\t  new_friend_result_template_info = NULL_TREE;\n+\t}\n \n-      /* We must save the DECL_TI_ARGS for NEW_FRIEND here because\n-\t pushdecl may call duplicate_decls which will free NEW_FRIEND\n-\t if possible.  */\n-      new_friend_args = DECL_TI_ARGS (new_friend);\n       old_decl = pushdecl_namespace_level (new_friend);\n \n       if (old_decl != new_friend)\n@@ -4295,36 +4316,55 @@ tsubst_friend_function (decl, args)\n \t     when `C<int>' is instantiated.  Now, `f(int)' is defined\n \t     in the class.  */\n \n-\t  if (TREE_CODE (old_decl) != TEMPLATE_DECL)\n-\t    /* duplicate_decls will take care of this case.  */\n+\t  if (!new_friend_is_defn)\n+\t    /* On the other hand, if the in-class declaration does\n+\t       *not* provide a definition, then we don't want to alter\n+\t       existing definitions.  We can just leave everything\n+\t       alone.  */\n \t    ;\n-\t  else \n+\t  else\n \t    {\n-\t      tree t;\n-\n-\t      for (t = DECL_TEMPLATE_SPECIALIZATIONS (old_decl); \n-\t\t   t != NULL_TREE;\n-\t\t   t = TREE_CHAIN (t))\n+\t      /* Overwrite whatever template info was there before, if\n+\t\t any, with the new template information pertaining to\n+\t\t the declaration.  */\n+\t      DECL_TEMPLATE_INFO (old_decl) = new_friend_template_info;\n+\n+\t      if (TREE_CODE (old_decl) != TEMPLATE_DECL)\n+\t\t/* duplicate_decls will take care of this case.  */\n+\t\t;\n+\t      else \n \t\t{\n-\t\t  tree spec = TREE_VALUE (t);\n+\t\t  tree t;\n+\t\t  tree new_friend_args;\n+\n+\t\t  DECL_TEMPLATE_INFO (DECL_RESULT (old_decl)) \n+\t\t    = new_friend_result_template_info;\n+\t\t    \n+\t\t  new_friend_args = TI_ARGS (new_friend_template_info);\n+\t\t  for (t = DECL_TEMPLATE_SPECIALIZATIONS (old_decl); \n+\t\t       t != NULL_TREE;\n+\t\t       t = TREE_CHAIN (t))\n+\t\t    {\n+\t\t      tree spec = TREE_VALUE (t);\n \t\t  \n-\t\t  DECL_TI_ARGS (spec) \n-\t\t    = add_outermost_template_args (new_friend_args,\n-\t\t\t\t\t\t   DECL_TI_ARGS (spec));\n-\t\t  DECL_TI_ARGS (spec)\n-\t\t    = copy_to_permanent (DECL_TI_ARGS (spec));\n-\t\t}\n-\n-\t      /* Now, since specializations are always supposed to\n-\t\t hang off of the most general template, we must move\n-\t\t them.  */\n-\t      t = most_general_template (old_decl);\n-\t      if (t != old_decl)\n-\t\t{\n-\t\t  DECL_TEMPLATE_SPECIALIZATIONS (t)\n-\t\t    = chainon (DECL_TEMPLATE_SPECIALIZATIONS (t),\n-\t\t\t       DECL_TEMPLATE_SPECIALIZATIONS (old_decl));\n-\t\t  DECL_TEMPLATE_SPECIALIZATIONS (old_decl) = NULL_TREE;\n+\t\t      DECL_TI_ARGS (spec) \n+\t\t\t= add_outermost_template_args (new_friend_args,\n+\t\t\t\t\t\t       DECL_TI_ARGS (spec));\n+\t\t      DECL_TI_ARGS (spec)\n+\t\t\t= copy_to_permanent (DECL_TI_ARGS (spec));\n+\t\t    }\n+\n+\t\t  /* Now, since specializations are always supposed to\n+\t\t     hang off of the most general template, we must move\n+\t\t     them.  */\n+\t\t  t = most_general_template (old_decl);\n+\t\t  if (t != old_decl)\n+\t\t    {\n+\t\t      DECL_TEMPLATE_SPECIALIZATIONS (t)\n+\t\t\t= chainon (DECL_TEMPLATE_SPECIALIZATIONS (t),\n+\t\t\t\t   DECL_TEMPLATE_SPECIALIZATIONS (old_decl));\n+\t\t      DECL_TEMPLATE_SPECIALIZATIONS (old_decl) = NULL_TREE;\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -5312,7 +5352,6 @@ tsubst_decl (t, args, type, in_decl)\n \tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args, t);\n \tDECL_MAIN_VARIANT (r) = r;\n \tDECL_RESULT (r) = NULL_TREE;\n-\tDECL_INITIAL (r) = NULL_TREE;\n \n \tTREE_STATIC (r) = 0;\n \tTREE_PUBLIC (r) = TREE_PUBLIC (t);\n@@ -8285,9 +8324,13 @@ regenerate_decl_from_template (decl, tmpl)\n     }\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n-    /* Convince duplicate_decls to use the DECL_ARGUMENTS from the\n-       new decl.  */ \n-    DECL_INITIAL (new_decl) = error_mark_node;\n+    {\n+      /* Convince duplicate_decls to use the DECL_ARGUMENTS from the\n+\t new decl.  */ \n+      DECL_INITIAL (new_decl) = error_mark_node;\n+      /* And don't complain about a duplicate definition.  */\n+      DECL_INITIAL (decl) = NULL_TREE;\n+    }\n \n   /* The immediate parent of the new template is still whatever it was\n      before, even though tsubst sets DECL_TI_TEMPLATE up as the most\n@@ -8303,9 +8346,6 @@ regenerate_decl_from_template (decl, tmpl)\n   /* Call duplicate decls to merge the old and new declarations.  */\n   duplicate_decls (new_decl, decl);\n \n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    DECL_INITIAL (new_decl) = NULL_TREE;\n-\n   /* Now, re-register the specialization.  */\n   register_specialization (decl, gen_tmpl, args);\n }\n@@ -8332,8 +8372,7 @@ instantiate_decl (d)\n   my_friendly_assert (TREE_CODE (d) == FUNCTION_DECL\n \t\t      || TREE_CODE (d) == VAR_DECL, 0);\n \n-  if ((TREE_CODE (d) == FUNCTION_DECL && DECL_INITIAL (d))\n-      || (TREE_CODE (d) == VAR_DECL && !DECL_IN_AGGR_P (d)))\n+  if (DECL_TEMPLATE_INSTANTIATED (d))\n     /* D has already been instantiated.  It might seem reasonable to\n        check whether or not D is an explict instantiation, and, if so,\n        stop here.  But when an explicit instantiation is deferred\n@@ -8398,9 +8437,6 @@ instantiate_decl (d)\n \t cannot restructure the loop to just keep going until we find\n \t a template with a definition, since that might go too far if\n \t a specialization was declared, but not defined.  */\n-      my_friendly_assert (!(TREE_CODE (d) == FUNCTION_DECL\n-\t\t\t    && DECL_INITIAL (DECL_TEMPLATE_RESULT (td))),\n-\t\t\t  0);\n       my_friendly_assert (!(TREE_CODE (d) == VAR_DECL\n \t\t\t    && !DECL_IN_AGGR_P (DECL_TEMPLATE_RESULT (td))), \n \t\t\t  0); \n@@ -8483,6 +8519,7 @@ instantiate_decl (d)\n     }\n \n   regenerate_decl_from_template (d, td);\n+  DECL_TEMPLATE_INSTANTIATED (d) = 1;\n \n   /* We already set the file and line above.  Reset them now in case\n      they changed as a result of calling regenerate_decl_from_template.  */"}, {"sha": "4a9042ad3ecf982279af72e6b852f1be21767988", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend36.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend36.C?ref=fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba", "patch": "@@ -0,0 +1,12 @@\n+// Build don't link:\n+\n+template <class T>\n+void f(T) {} // ERROR - previously defined here\n+\n+template <class U>\n+struct S {\n+  template <class T>\n+  friend void f(T) {} // ERROR - redeclaration\n+};\n+\n+S<int> si;"}, {"sha": "e5e87b4608977b844b236d32fca09bd6643b52dd", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ttp53.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp53.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp53.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp53.C?ref=fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba", "patch": "@@ -13,7 +13,7 @@ class H{\n public:\n #endif\n   template<template<class, class> class Caster, typename Source>\n-  static H<Type> cast(const H<Source>& s); // gets bogus error - candidate - XFAIL *-*-*\n+  static H<Type> cast(const H<Source>& s);\n \n #ifndef OK\n   template <typename Target, typename Source>\n@@ -26,10 +26,10 @@ template <class, class> class caster;\n \n template <typename Target, typename Source>\n H<Target> foo(const H<Source>& s){\n-  return H<Target>::template cast<caster, Source>(s); // gets bogus error - no match - XFAIL *-*-*\n+  return H<Target>::template cast<caster, Source>(s);\n }\n \n int main(){\n   H<int> i;\n-  foo<const int>(i); // gets bogus error - instantiated from here - XFAIL *-*-*\n+  foo<const int>(i);\n }"}]}