{"sha": "3157879227a4b4e1e0921483b067607fa48aa050", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE1Nzg3OTIyN2E0YjRlMWUwOTIxNDgzYjA2NzYwN2ZhNDhhYTA1MA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-09-05T19:41:16Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-09-05T19:41:16Z"}, "message": "re PR libstdc++/54296 (using the object in the map to erase element from the map crashes)\n\n2012-09-05  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/54296\n\t* include/bits/hashtable.h (_M_erase(size_type, __node_base*,\n\t__node_type*)): New.\n\t(erase(const_iterator)): Use latter.\n\t(_M_erase(std::true_type, const key_type&)): New, likewise.\n\t(_M_erase(std::false_type, const key_type&)): New. Find all nodes\n\tmatching the key before deallocating them so that the key doesn't\n\tget invalidated.\n\t(erase(const key_type&)): Use the new member functions.\n\t* testsuite/23_containers/unordered_map/erase/54296.cc: New.\n\t* testsuite/23_containers/unordered_multimap/erase/54296.cc: New.\n\nFrom-SVN: r190991", "tree": {"sha": "9f144135a489ba7ffa36c5d8d1fcd48b17eb1c51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f144135a489ba7ffa36c5d8d1fcd48b17eb1c51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3157879227a4b4e1e0921483b067607fa48aa050", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3157879227a4b4e1e0921483b067607fa48aa050", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3157879227a4b4e1e0921483b067607fa48aa050", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3157879227a4b4e1e0921483b067607fa48aa050/comments", "author": null, "committer": null, "parents": [{"sha": "b413068c9fd88857fee03d7e7cf966bc2add5a6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b413068c9fd88857fee03d7e7cf966bc2add5a6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b413068c9fd88857fee03d7e7cf966bc2add5a6f"}], "stats": {"total": 332, "additions": 299, "deletions": 33}, "files": [{"sha": "707e474b8995f2181666e26d16a9b78070bd5fe2", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3157879227a4b4e1e0921483b067607fa48aa050/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3157879227a4b4e1e0921483b067607fa48aa050/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3157879227a4b4e1e0921483b067607fa48aa050", "patch": "@@ -1,3 +1,17 @@\n+2012-09-05  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/54296\n+\t* include/bits/hashtable.h (_M_erase(size_type, __node_base*,\n+\t__node_type*)): New.\n+\t(erase(const_iterator)): Use latter.\n+\t(_M_erase(std::true_type, const key_type&)): New, likewise.\n+\t(_M_erase(std::false_type, const key_type&)): New. Find all nodes\n+\tmatching the key before deallocating them so that the key doesn't\n+\tget invalidated.\n+\t(erase(const key_type&)): Use the new member functions.\n+\t* testsuite/23_containers/unordered_map/erase/54296.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/erase/54296.cc: New.\n+\n 2012-09-05  Ulrich Drepper  <drepper@gmail.com>\n \n \t* src/c++11/random.cc (random_device::_M_init): Check whether cpuid"}, {"sha": "44badc088fe6b3553b29d36da9762923a1b1efcb", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 81, "deletions": 33, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3157879227a4b4e1e0921483b067607fa48aa050/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3157879227a4b4e1e0921483b067607fa48aa050/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=3157879227a4b4e1e0921483b067607fa48aa050", "patch": "@@ -612,6 +612,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \titerator\n \t_M_insert(_Arg&&, std::false_type);\n \n+      size_type\n+      _M_erase(std::true_type, const key_type&);\n+\n+      size_type\n+      _M_erase(std::false_type, const key_type&);\n+\n+      iterator\n+      _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);\n+\n     public:\n       // Emplace\n       template<typename... _Args>\n@@ -636,7 +645,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return erase(const_iterator(__it)); }\n \n       size_type\n-      erase(const key_type&);\n+      erase(const key_type& __k)\n+      { return _M_erase(__unique_keys(), __k); }\n \n       iterator\n       erase(const_iterator, const_iterator);\n@@ -1430,7 +1440,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // is why we need buckets to contain the before begin to make\n       // this research fast.\n       __node_base* __prev_n = _M_get_previous_node(__bkt, __n);\n-      if (__n == _M_bucket_begin(__bkt))\n+      return _M_erase(__bkt, __prev_n, __n);\n+    }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t_Traits>::iterator\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)\n+    {\n+      if (__prev_n == _M_buckets[__bkt])\n \t_M_remove_bucket_begin(__bkt, __n->_M_next(),\n \t   __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);\n       else if (__n->_M_nxt)\n@@ -1457,7 +1481,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t_Traits>::size_type\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    erase(const key_type& __k)\n+    _M_erase(std::true_type, const key_type& __k)\n+    {\n+      __hash_code __code = this->_M_hash_code(__k);\n+      std::size_t __bkt = _M_bucket_index(__k, __code);\n+\n+      // Look for the node before the first matching node.\n+      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);\n+      if (!__prev_n)\n+\treturn 0;\n+\n+      // We found a matching node, erase it.\n+      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);\n+      _M_erase(__bkt, __prev_n, __n);\n+      return 1;\n+    }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t_Traits>::size_type\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_erase(std::false_type, const key_type& __k)\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __bkt = _M_bucket_index(__k, __code);\n@@ -1466,43 +1515,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);\n       if (!__prev_n)\n \treturn 0;\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 526. Is it undefined if a function in the standard changes\n+      // in parameters?\n+      // We use one loop to find all matching nodes and another to deallocate\n+      // them so that the key stays valid during the first loop. It might be\n+      // invalidated indirectly when destroying nodes.\n       __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);\n-      bool __is_bucket_begin = _M_buckets[__bkt] == __prev_n;\n+      __node_type* __n_last = __n;\n+      std::size_t __n_last_bkt = __bkt;\n+      do\n+\t{\n+\t  __n_last = __n_last->_M_next();\n+\t  if (!__n_last)\n+\t    break;\n+\t  __n_last_bkt = _M_bucket_index(__n_last);\n+\t}\n+      while (__n_last_bkt == __bkt && this->_M_equals(__k, __code, __n_last));\n \n-      // We found a matching node, start deallocation loop from it\n-      std::size_t __next_bkt = __bkt;\n-      __node_type* __next_n = __n;\n+      // Deallocate nodes.\n       size_type __result = 0;\n-      __node_type* __saved_n = nullptr;\n       do\n \t{\n-\t  __node_type* __p = __next_n;\n-\t  __next_n = __p->_M_next();\n-\n-\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t  // 526. Is it undefined if a function in the standard changes\n-\t  // in parameters?\n-\t  if (std::__addressof(this->_M_extract()(__p->_M_v))\n-\t      != std::__addressof(__k))\n-\t    _M_deallocate_node(__p);\n-\t  else\n-\t    __saved_n = __p;\n-\t  --_M_element_count;\n+\t  __node_type* __p = __n->_M_next();\n+\t  _M_deallocate_node(__n);\n+\t  __n = __p;\n \t  ++__result;\n-\t  if (!__next_n)\n-\t    break;\n-\t  __next_bkt = _M_bucket_index(__next_n);\n+\t  --_M_element_count;\n \t}\n-      while (__next_bkt == __bkt && this->_M_equals(__k, __code, __next_n));\n-\n-      if (__saved_n)\n-\t_M_deallocate_node(__saved_n);\n-      if (__is_bucket_begin)\n-\t_M_remove_bucket_begin(__bkt, __next_n, __next_bkt);\n-      else if (__next_n && __next_bkt != __bkt)\n-\t_M_buckets[__next_bkt] = __prev_n;\n-      if (__prev_n)\n-\t__prev_n->_M_nxt = __next_n;\n+      while (__n != __n_last);\n+\n+      if (__prev_n == _M_buckets[__bkt])\n+\t_M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);\n+      else if (__n_last && __n_last_bkt != __bkt)\n+\t_M_buckets[__n_last_bkt] = __prev_n;\n+      __prev_n->_M_nxt = __n_last;\n       return __result;\n     }\n "}, {"sha": "40a548690d4d268d5eda21da6cb474374a8c6a48", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/erase/54276.cc", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3157879227a4b4e1e0921483b067607fa48aa050/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ferase%2F54276.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3157879227a4b4e1e0921483b067607fa48aa050/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ferase%2F54276.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ferase%2F54276.cc?ref=3157879227a4b4e1e0921483b067607fa48aa050", "patch": "@@ -0,0 +1,103 @@\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <set>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+struct A\n+{\n+  int x;\n+  static std::set<const A*> destroyed;\n+\n+  A()\n+  { destroyed.erase(this); }\n+\n+  A(const A& a)\n+    : x(a.x)\n+  { destroyed.erase(this); }\n+\n+  ~A()\n+  { destroyed.insert(this); }\n+\n+  bool\n+  operator==(const A& other) const\n+  {\n+    VERIFY( destroyed.find(this) == destroyed.end() );\n+    VERIFY( destroyed.find(&other) == destroyed.end() );\n+    return x == other.x;\n+  }\n+};\n+\n+std::set<const A*> A::destroyed;\n+\n+struct hasher\n+{\n+  std::size_t operator()(const A& a) const\n+  {\n+    VERIFY( A::destroyed.find(&a) == A::destroyed.end() );\n+    return a.x / 10;\n+  }\n+};\n+\n+void test01()\n+{\n+  typedef std::unordered_map<A, A, hasher> UMap;\n+  UMap map;\n+\n+  A::destroyed.clear();\n+  A a;\n+  a.x = 0;\n+  map.insert({a, a});\n+  a.x = 1;\n+  map.insert({a, a});\n+  VERIFY( map.size() == 2 );\n+  std::size_t bkt = map.bucket(a);\n+  VERIFY( map.bucket_size(bkt) == 2 );\n+\n+  VERIFY( map.erase( map.begin(bkt)->first ) == 1 );\n+}\n+\n+void test02()\n+{\n+  typedef std::unordered_map<A, A, hasher> UMap;\n+  UMap map;\n+\n+  A::destroyed.clear();\n+  A a;\n+  a.x = 0;\n+  map.insert({a, a});\n+  a.x = 1;\n+  map.insert({a, a});\n+  VERIFY( map.size() == 2 );\n+  std::size_t bkt = map.bucket(a);\n+  VERIFY( map.bucket_size(bkt) == 2 );\n+\n+  VERIFY( map.erase( map.begin(bkt)->second ) == 1 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "1cfb7346b367cf3656b5f2a21a967c8df51de6ff", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/erase/54276.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3157879227a4b4e1e0921483b067607fa48aa050/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F54276.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3157879227a4b4e1e0921483b067607fa48aa050/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F54276.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F54276.cc?ref=3157879227a4b4e1e0921483b067607fa48aa050", "patch": "@@ -0,0 +1,101 @@\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <set>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+struct A\n+{\n+  int x;\n+  static std::set<const A*> destroyed;\n+\n+  A()\n+  { destroyed.erase(this); }\n+\n+  A(const A& a)\n+    : x(a.x)\n+  { destroyed.erase(this); }\n+\n+  ~A()\n+  { destroyed.insert(this); }\n+\n+  bool\n+  operator==(const A& other) const\n+  {\n+    VERIFY( destroyed.find(this) == destroyed.end() );\n+    VERIFY( destroyed.find(&other) == destroyed.end() );\n+    return x == other.x;\n+  }\n+};\n+\n+std::set<const A*> A::destroyed;\n+\n+struct hasher\n+{\n+  std::size_t operator()(const A& a) const\n+  {\n+    VERIFY( A::destroyed.find(&a) == A::destroyed.end() );\n+    return a.x / 10;\n+  }\n+};\n+\n+void test01()\n+{\n+  typedef std::unordered_multimap<A, A, hasher> UMMap;\n+  UMMap map;\n+\n+  A::destroyed.clear();\n+  A a;\n+  a.x = 0;\n+  map.insert({a, a});\n+  map.insert({a, a});\n+  VERIFY( map.size() == 2 );\n+  std::size_t bkt = map.bucket(a);\n+  VERIFY( map.bucket_size(bkt) == 2 );\n+\n+  VERIFY( map.erase( map.begin(bkt)->first ) == 2 );\n+}\n+\n+void test02()\n+{\n+  typedef std::unordered_multimap<A, A, hasher> UMMap;\n+  UMMap map;\n+\n+  A::destroyed.clear();\n+  A a;\n+  a.x = 0;\n+  map.insert({a, a});\n+  map.insert({a, a});\n+  VERIFY( map.size() == 2 );\n+  std::size_t bkt = map.bucket(a);\n+  VERIFY( map.bucket_size(bkt) == 2 );\n+\n+  VERIFY( map.erase( map.begin(bkt)->second ) == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}]}