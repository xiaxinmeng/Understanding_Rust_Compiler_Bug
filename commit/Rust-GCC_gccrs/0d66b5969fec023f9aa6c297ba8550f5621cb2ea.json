{"sha": "0d66b5969fec023f9aa6c297ba8550f5621cb2ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ2NmI1OTY5ZmVjMDIzZjlhYTZjMjk3YmE4NTUwZjU2MjFjYjJlYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T09:57:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T09:57:49Z"}, "message": "[multiple changes]\n\n2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_disp.adb (Check_Dispatching_Call): Major rewriting to\n\thandle some complex cases of tag indeterminate calls that are\n\tactuals in other dispatching calls that are themselves tag\n\tindeterminate.\n\t(Check_Dispatching_Context): Add parameter to support recursive\n\tcheck for an enclosing construct that may provide a tag for a\n\ttag-indeterminate call.\n\n2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Depends_In_Decl_Part):\n\tAdd global variables Task_Input_Seen and Task_Output_Seen.\n\t(Analyze_Global_Item): Detect an illegal use of the current\n\tinstance of a single protected/task type in a global annotation.\n\t(Analyze_Input_Output): Inputs and output related to the current\n\tinstance of a task unit are now tracked.\n\t(Check_Usage): Require\n\tthe presence of the current instance of a task unit only when\n\tone input/output is available.\t(Current_Task_Instance_Seen):\n\tNew routine.\n\t(Is_CCT_Instance): New parameter profile. Update\n\tthe comment on usage. The routine now properly recognizes several\n\tcases related to single protected/task types.\n\n2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): Use New_Freeze_Node\n\tto create a brand new freeze node. This handles a case where an\n\tignored Ghost context is freezing something which is not ignored\n\tGhost and whose freeze node should not be removed from the tree.\n\t(New_Freeze_Node): New routine.\n\n2016-04-18  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* sigtramp.h (__gnat_set_is_vxsim) New function to\n\ttell sigtramp-vxworks to handle vxsim signal contexts.\t*\n\tsigtramp-vxworks.c (__gnat_sigtramp) Take into account the\n\tdifferences in the sigcontext structure between the expected\n\tregular x86 or x86_64 ones and the ones received in case of\n\texexution on the vxworks simulator.\n\t* init.c: also compute is_vxsim in case of x86_64-vx7 target. Provide\n\tthis information to sigtramp-vxworks.c. Remove the old mechanism for\n\tvxsim.\n\t* init-vxsim.c, sigtramp-vxworks-vxsim.c: remove, now obsolete.\n\n2016-04-18  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_ch3.adb (Inline_Init_Proc): New function returning\n\twhether the initialization procedure of a type should be\n\tinlined.  Return again True for controlled type themselves.\n\t(Build_Array_Init_Proc): Call it to set Set_Is_Inlined on Init_Proc.\n\t(Build_Record_Init_Proc): Likewise.\n\nFrom-SVN: r235110", "tree": {"sha": "6020598037499e70045bcc3796b5a74b15769ff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6020598037499e70045bcc3796b5a74b15769ff3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d66b5969fec023f9aa6c297ba8550f5621cb2ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d66b5969fec023f9aa6c297ba8550f5621cb2ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d66b5969fec023f9aa6c297ba8550f5621cb2ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/comments", "author": null, "committer": null, "parents": [{"sha": "a86c18d9fa6e2444917934fc4b7d5f22f957d51b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a86c18d9fa6e2444917934fc4b7d5f22f957d51b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a86c18d9fa6e2444917934fc4b7d5f22f957d51b"}], "stats": {"total": 878, "additions": 497, "deletions": 381}, "files": [{"sha": "c4e73d113285476228270d0c3d409c5c7c98e11a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0d66b5969fec023f9aa6c297ba8550f5621cb2ea", "patch": "@@ -1,3 +1,58 @@\n+2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_disp.adb (Check_Dispatching_Call): Major rewriting to\n+\thandle some complex cases of tag indeterminate calls that are\n+\tactuals in other dispatching calls that are themselves tag\n+\tindeterminate.\n+\t(Check_Dispatching_Context): Add parameter to support recursive\n+\tcheck for an enclosing construct that may provide a tag for a\n+\ttag-indeterminate call.\n+\n+2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Depends_In_Decl_Part):\n+\tAdd global variables Task_Input_Seen and Task_Output_Seen.\n+\t(Analyze_Global_Item): Detect an illegal use of the current\n+\tinstance of a single protected/task type in a global annotation.\n+\t(Analyze_Input_Output): Inputs and output related to the current\n+\tinstance of a task unit are now tracked.\n+\t(Check_Usage): Require\n+\tthe presence of the current instance of a task unit only when\n+\tone input/output is available.\t(Current_Task_Instance_Seen):\n+\tNew routine.\n+\t(Is_CCT_Instance): New parameter profile. Update\n+\tthe comment on usage. The routine now properly recognizes several\n+\tcases related to single protected/task types.\n+\n+2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): Use New_Freeze_Node\n+\tto create a brand new freeze node. This handles a case where an\n+\tignored Ghost context is freezing something which is not ignored\n+\tGhost and whose freeze node should not be removed from the tree.\n+\t(New_Freeze_Node): New routine.\n+\n+2016-04-18  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* sigtramp.h (__gnat_set_is_vxsim) New function to\n+\ttell sigtramp-vxworks to handle vxsim signal contexts.\t*\n+\tsigtramp-vxworks.c (__gnat_sigtramp) Take into account the\n+\tdifferences in the sigcontext structure between the expected\n+\tregular x86 or x86_64 ones and the ones received in case of\n+\texexution on the vxworks simulator.\n+\t* init.c: also compute is_vxsim in case of x86_64-vx7 target. Provide\n+\tthis information to sigtramp-vxworks.c. Remove the old mechanism for\n+\tvxsim.\n+\t* init-vxsim.c, sigtramp-vxworks-vxsim.c: remove, now obsolete.\n+\n+2016-04-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch3.adb (Inline_Init_Proc): New function returning\n+\twhether the initialization procedure of a type should be\n+\tinlined.  Return again True for controlled type themselves.\n+\t(Build_Array_Init_Proc): Call it to set Set_Is_Inlined on Init_Proc.\n+\t(Build_Record_Init_Proc): Likewise.\n+\n 2016-04-18  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnatvsn.ads (Library_Version): Bump to 7."}, {"sha": "a858f759e823bd823cde090935d79807c446aa1a", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=0d66b5969fec023f9aa6c297ba8550f5621cb2ea", "patch": "@@ -226,6 +226,9 @@ package body Exp_Ch3 is\n    --\n    --  The caller must append additional entries for discriminants if required.\n \n+   function Inline_Init_Proc (Typ : Entity_Id) return Boolean;\n+   --  Returns true if the initialization procedure of Typ should be inlined\n+\n    function In_Runtime (E : Entity_Id) return Boolean;\n    --  Check if E is defined in the RTL (in a child of Ada or System). Used\n    --  to avoid to bring in the overhead of _Input, _Output for tagged types.\n@@ -756,14 +759,10 @@ package body Exp_Ch3 is\n             Set_Debug_Info_Off (Proc_Id);\n          end if;\n \n-         --  Set inlined unless tasks are around, in which case we do not\n-         --  want to inline, because nested stuff may cause difficulties in\n-         --  inter-unit inlining, and furthermore there is in any case no\n-         --  point in inlining such complex init procs.\n+         --  Set Inlined on Init_Proc if it is set on the Init_Proc of the\n+         --  component type itself (see also Build_Record_Init_Proc).\n \n-         if not Has_Task (Proc_Id) then\n-            Set_Is_Inlined (Proc_Id);\n-         end if;\n+         Set_Is_Inlined (Proc_Id, Inline_Init_Proc (Comp_Type));\n \n          --  Associate Init_Proc with type, and determine if the procedure\n          --  is null (happens because of the Initialize_Scalars pragma case,\n@@ -3592,28 +3591,17 @@ package body Exp_Ch3 is\n          Build_Offset_To_Top_Functions;\n          Build_CPP_Init_Procedure;\n          Build_Init_Procedure;\n-         Set_Is_Public (Proc_Id, Is_Public (Rec_Ent));\n-\n-         --  The initialization of protected records is not worth inlining.\n-         --  In addition, when compiled for another unit for inlining purposes,\n-         --  it may make reference to entities that have not been elaborated\n-         --  yet. Similar considerations apply to task types and types that\n-         --  need finalization.\n-\n-         if not Is_Concurrent_Type (Rec_Type)\n-           and then not Has_Task (Rec_Type)\n-           and then not Needs_Finalization (Rec_Type)\n-         then\n-            Set_Is_Inlined  (Proc_Id);\n-         end if;\n \n+         Set_Is_Public      (Proc_Id, Is_Public (Rec_Ent));\n          Set_Is_Internal    (Proc_Id);\n          Set_Has_Completion (Proc_Id);\n \n          if not Debug_Generated_Code then\n             Set_Debug_Info_Off (Proc_Id);\n          end if;\n \n+         Set_Is_Inlined (Proc_Id, Inline_Init_Proc (Rec_Type));\n+\n          --  Do not build an aggregate if Modify_Tree_For_C, this isn't\n          --  needed and may generate early references to non frozen types\n          --  since we expand aggregate much more systematically.\n@@ -8230,6 +8218,34 @@ package body Exp_Ch3 is\n       end if;\n    end Has_New_Non_Standard_Rep;\n \n+   ----------------------\n+   -- Inline_Init_Proc --\n+   ----------------------\n+\n+   function Inline_Init_Proc (Typ : Entity_Id) return Boolean is\n+   begin\n+      --  The initialization proc of protected records is not worth inlining.\n+      --  In addition, when compiled for another unit for inlining purposes,\n+      --  it may make reference to entities that have not been elaborated yet.\n+      --  The initialization proc of records that need finalization contains\n+      --  a nested clean-up procedure that makes it impractical to inline as\n+      --  well, except for simple controlled types themselves. And similar\n+      --  considerations apply to task types.\n+\n+      if Is_Concurrent_Type (Typ) then\n+         return False;\n+\n+      elsif Needs_Finalization (Typ) and then not Is_Controlled (Typ) then\n+         return False;\n+\n+      elsif Has_Task (Typ) then\n+         return False;\n+\n+      else\n+         return True;\n+      end if;\n+   end Inline_Init_Proc;\n+\n    ----------------\n    -- In_Runtime --\n    ----------------"}, {"sha": "736535eafaf7fc5f0eca2ba2317aaeea36765b48", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=0d66b5969fec023f9aa6c297ba8550f5621cb2ea", "patch": "@@ -1997,6 +1997,9 @@ package body Freeze is\n       --  call, but rather must go in the package holding the function, so that\n       --  the backend can process it in the proper context.\n \n+      function New_Freeze_Node return Node_Id;\n+      --  Create a new freeze node for entity E\n+\n       procedure Wrap_Imported_Subprogram (E : Entity_Id);\n       --  If E is an entity for an imported subprogram with pre/post-conditions\n       --  then this procedure will create a wrapper to ensure that proper run-\n@@ -4589,6 +4592,39 @@ package body Freeze is\n          Append_List (Result, Decls);\n       end Late_Freeze_Subprogram;\n \n+      ---------------------\n+      -- New_Freeze_Node --\n+      ---------------------\n+\n+      function New_Freeze_Node return Node_Id is\n+         Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+         Result          : Node_Id;\n+\n+      begin\n+         --  Handle the case where an ignored Ghost subprogram freezes the type\n+         --  of one of its formals. The type can either be non-Ghost or checked\n+         --  Ghost. Since the freeze node for the type is generated in the\n+         --  context of the subprogram, the node will be incorrectly flagged as\n+         --  ignored Ghost and erroneously removed from the tree.\n+\n+         --    type Typ is ...;\n+         --    procedure Ignored_Ghost_Proc (Formal : Typ) with Ghost;\n+\n+         --  Reset the Ghost mode to \"none\". This preserves the freeze node.\n+\n+         if Ghost_Mode = Ignore\n+           and then not Is_Ignored_Ghost_Entity (E)\n+           and then not Is_Ignored_Ghost_Node (E)\n+         then\n+            Ghost_Mode := None;\n+         end if;\n+\n+         Result := New_Node (N_Freeze_Entity, Loc);\n+\n+         Ghost_Mode := Save_Ghost_Mode;\n+         return Result;\n+      end New_Freeze_Node;\n+\n       ------------------------------\n       -- Wrap_Imported_Subprogram --\n       ------------------------------\n@@ -6281,7 +6317,7 @@ package body Freeze is\n             Set_Sloc (F_Node, Loc);\n \n          else\n-            F_Node := New_Node (N_Freeze_Entity, Loc);\n+            F_Node := New_Freeze_Node;\n             Set_Freeze_Node (E, F_Node);\n             Set_Access_Types_To_Process (F_Node, No_Elist);\n             Set_TSS_Elist (F_Node, No_Elist);\n@@ -6299,9 +6335,7 @@ package body Freeze is\n          --  subtypes can only be elaborated after the type itself, and they\n          --  need an itype reference.\n \n-         if Ekind (E) = E_Record_Type\n-           and then Has_Discriminants (E)\n-         then\n+         if Ekind (E) = E_Record_Type and then Has_Discriminants (E) then\n             declare\n                Comp : Entity_Id;\n                IR   : Node_Id;"}, {"sha": "9466dbc7915d850fdd850e5346c47f1f56d0dd1e", "filename": "gcc/ada/init-vxsim.c", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a86c18d9fa6e2444917934fc4b7d5f22f957d51b/gcc%2Fada%2Finit-vxsim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a86c18d9fa6e2444917934fc4b7d5f22f957d51b/gcc%2Fada%2Finit-vxsim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit-vxsim.c?ref=a86c18d9fa6e2444917934fc4b7d5f22f957d51b", "patch": "@@ -1,62 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                           I N I T - V X S I M                            *\n- *                                                                          *\n- *                          C Implementation File                           *\n- *                                                                          *\n- *          Copyright (C) 1992-2015, Free Software Foundation, Inc.         *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n- *                                                                          *\n- * As a special exception under Section 7 of GPL version 3, you are granted *\n- * additional permissions described in the GCC Runtime Library Exception,   *\n- * version 3.1, as published by the Free Software Foundation.               *\n- *                                                                          *\n- * You should have received a copy of the GNU General Public License and    *\n- * a copy of the GCC Runtime Library Exception along with this program;     *\n- * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    *\n- * <http://www.gnu.org/licenses/>.                                          *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/* This file is an addition to init.c that must be compiled with the CPU\n-   specified for running under vxsim for x86-vxworks6, as the signal context\n-   structure is different for vxsim vs. real hardware.  */\n-\n-#undef CPU\n-#define CPU __VXSIM_CPU__\n-\n-#include \"vxWorks.h\"\n-#include \"tconfig.h\"\n-\n-#include <signal.h>\n-#include <taskLib.h>\n-\n-#ifndef __RTP__\n-#include <intLib.h>\n-#include <iv.h>\n-#endif\n-\n-extern void\n-__gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED,\n-\t\t   void *sc ATTRIBUTE_UNUSED);\n-\n-/* Process the vxsim signal context.  */\n-void\n-__gnat_vxsim_error_handler (int sig, siginfo_t *si, void *sc)\n-{\n-  #include \"sigtramp.h\"\n-\n-  __gnat_sigtramp_vxsim (sig, (void *)si, (void *)sc,\n-\t\t   (__sigtramphandler_t *)&__gnat_map_signal);\n-}"}, {"sha": "43ea1e78dad3338c4c3ae17890bcc144c0627b04", "filename": "gcc/ada/init.c", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=0d66b5969fec023f9aa6c297ba8550f5621cb2ea", "patch": "@@ -1705,10 +1705,12 @@ __gnat_install_handler (void)\n \n #include <signal.h>\n #include <taskLib.h>\n-#if defined (__i386__) && !defined (VTHREADS)\n+#if (defined (__i386__) || defined (__x86_64__)) && !defined (VTHREADS)\n #include <sysLib.h>\n #endif\n \n+#include \"sigtramp.h\"\n+\n #ifndef __RTP__\n #include <intLib.h>\n #include <iv.h>\n@@ -1814,7 +1816,9 @@ __gnat_clear_exception_count (void)\n /* Handle different SIGnal to exception mappings in different VxWorks\n    versions.  */\n void\n-__gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED, void *sc)\n+__gnat_map_signal (int sig,\n+                   siginfo_t *si ATTRIBUTE_UNUSED,\n+                   void *sc ATTRIBUTE_UNUSED)\n {\n   struct Exception_Data *exception;\n   const char *msg;\n@@ -1924,14 +1928,6 @@ __gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED, void *sc)\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n-#if defined (__i386__) && !defined (VTHREADS) && _WRS_VXWORKS_MAJOR < 7\n-\n-extern void\n-__gnat_vxsim_error_handler (int sig, siginfo_t *si, void *sc);\n-\n-static int is_vxsim = 0;\n-#endif\n-\n #if defined (ARMEL) && (_WRS_VXWORKS_MAJOR >= 7)\n \n /* ARM-vx7 case with arm unwinding exceptions */\n@@ -2015,19 +2011,8 @@ __gnat_error_handler (int sig, siginfo_t *si, void *sc)\n   __gnat_adjust_context_for_raise (sig, sc);\n #endif\n \n-#if defined (__i386__) && !defined (VTHREADS) && (__WRS_VXWORKS_MAJOR < 7)\n-   /* On x86, the vxsim signal context is subtly different and is processeed\n-      by a handler compiled especially for vxsim.\n-      Vxsim is not supported anymore on our vxworks-7 port.  */\n-\n-  if (is_vxsim)\n-    __gnat_vxsim_error_handler (sig, si, sc);\n-#endif\n-\n-# include \"sigtramp.h\"\n-\n   __gnat_sigtramp (sig, (void *)si, (void *)sc,\n-\t\t   (__sigtramphandler_t *)&__gnat_map_signal);\n+                   (__sigtramphandler_t *)&__gnat_map_signal);\n \n #else\n   __gnat_map_signal (sig, si, sc);\n@@ -2057,7 +2042,6 @@ void\n __gnat_install_handler (void)\n {\n   struct sigaction act;\n-  char *model ATTRIBUTE_UNUSED;\n \n   /* Setup signal handler to map synchronous signals to appropriate\n      exceptions.  Make sure that the handler isn't interrupted by another\n@@ -2108,13 +2092,17 @@ __gnat_install_handler (void)\n   trap_0_entry->inst_fourth = 0xa1480000;\n #endif\n \n-#if defined (__i386__) && !defined (VTHREADS) && _WRS_VXWORKS_MAJOR != 7\n+#ifdef __HANDLE_VXSIM_SC\n   /*  By experiment, found that sysModel () returns the following string\n       prefix for vxsim when running on Linux and Windows.  */\n-  model = sysModel ();\n-  if ((strncmp (model, \"Linux\", 5) == 0)\n-      || (strncmp (model, \"Windows\", 7) == 0))\n-    is_vxsim = 1;\n+  {\n+    char *model = sysModel ();\n+    if ((strncmp (model, \"Linux\", 5) == 0)\n+        || (strncmp (model, \"Windows\", 7) == 0)\n+        || (strncmp (model, \"SIMLINUX\", 8) == 0) /* vx7 */\n+        || (strncmp (model, \"SIMWINDOWS\", 10) == 0)) /* ditto */\n+      __gnat_set_is_vxsim (TRUE);\n+  }\n #endif\n \n   __gnat_handler_installed = 1;"}, {"sha": "2d9a74611023a62930013db4e4cee16be89b710c", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 114, "deletions": 68, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=0d66b5969fec023f9aa6c297ba8550f5621cb2ea", "patch": "@@ -409,7 +409,7 @@ package body Sem_Disp is\n       --  fact direct. This routine detects the above case and modifies the\n       --  call accordingly.\n \n-      procedure Check_Dispatching_Context;\n+      procedure Check_Dispatching_Context (Call : Node_Id);\n       --  If the call is tag-indeterminate and the entity being called is\n       --  abstract, verify that the context is a call that will eventually\n       --  provide a tag for dispatching, or has provided one already.\n@@ -508,10 +508,9 @@ package body Sem_Disp is\n       -- Check_Dispatching_Context --\n       -------------------------------\n \n-      procedure Check_Dispatching_Context is\n-         Subp : constant Entity_Id := Entity (Name (N));\n+      procedure Check_Dispatching_Context (Call : Node_Id) is\n+         Subp : constant Entity_Id := Entity (Name (Call));\n          Typ  : constant Entity_Id := Etype (Subp);\n-         Par  : Node_Id;\n \n          procedure Abstract_Context_Error;\n          --  Error for abstract call dispatching on result is not dispatching\n@@ -536,11 +535,15 @@ package body Sem_Disp is\n             end if;\n          end Abstract_Context_Error;\n \n+         --  Local variables\n+\n+         Par : Node_Id;\n+\n       --  Start of processing for Check_Dispatching_Context\n \n       begin\n          if Is_Abstract_Subprogram (Subp)\n-           and then No (Controlling_Argument (N))\n+           and then No (Controlling_Argument (Call))\n          then\n             if Present (Alias (Subp))\n               and then not Is_Abstract_Subprogram (Alias (Subp))\n@@ -565,7 +568,8 @@ package body Sem_Disp is\n             --  but will be legal in overridings of the operation.\n \n             elsif In_Spec_Expression\n-              and then Is_Subprogram (Current_Scope)\n+              and then (Is_Subprogram (Current_Scope)\n+                 or else Chars (Current_Scope) = Name_Postcondition)\n               and then\n                 ((Nkind (Parent (Current_Scope)) = N_Procedure_Specification\n                    and then Null_Present (Parent (Current_Scope)))\n@@ -588,82 +592,110 @@ package body Sem_Disp is\n \n                if not Is_Tagged_Type (Typ)\n                  and then not\n-                    (Ekind (Typ) = E_Anonymous_Access_Type\n-                      and then Is_Tagged_Type (Designated_Type (Typ)))\n+                   (Ekind (Typ) = E_Anonymous_Access_Type\n+                     and then Is_Tagged_Type (Designated_Type (Typ)))\n                then\n                   Abstract_Context_Error;\n                   return;\n                end if;\n \n-               Par := Parent (N);\n+               Par := Parent (Call);\n \n                if Nkind (Par) = N_Parameter_Association then\n                   Par := Parent (Par);\n                end if;\n \n-               while Present (Par) loop\n-                  if Nkind_In (Par, N_Function_Call,\n-                                    N_Procedure_Call_Statement)\n-                    and then Is_Entity_Name (Name (Par))\n-                  then\n-                     declare\n-                        Enc_Subp : constant Entity_Id := Entity (Name (Par));\n-                        A : Node_Id;\n-                        F : Entity_Id;\n-\n-                     begin\n-                        --  Find formal for which call is the actual, and is\n-                        --  a controlling argument.\n-\n-                        F := First_Formal (Enc_Subp);\n-                        A := First_Actual (Par);\n-\n-                        while Present (F) loop\n-                           if Is_Controlling_Formal (F)\n-                             and then (N = A or else Parent (N) = A)\n-                           then\n-                              return;\n-                           end if;\n+               if Nkind (Par) = N_Qualified_Expression\n+                 or else Nkind (Par) = N_Unchecked_Type_Conversion\n+               then\n+                  Par := Parent (Par);\n+               end if;\n \n-                           Next_Formal (F);\n-                           Next_Actual (A);\n-                        end loop;\n+               if Nkind_In (Par, N_Function_Call, N_Procedure_Call_Statement)\n+                 and then Is_Entity_Name (Name (Par))\n+               then\n+                  declare\n+                     Enc_Subp : constant Entity_Id := Entity (Name (Par));\n+                     A        : Node_Id;\n+                     F        : Entity_Id;\n+                     Control  : Entity_Id;\n+                     Ret_Type : Entity_Id;\n \n-                        Error_Msg_N\n-                          (\"call to abstract function must be dispatching\", N);\n-                        return;\n-                     end;\n+                  begin\n+                     --  Find controlling formal that can provide tag for the\n+                     --  tag-indeterminate actual. The corresponding actual\n+                     --  must be the corresponding class-wide type.\n \n-                  --  For equalitiy operators, one of the operands must be\n-                  --  statically or dynamically tagged.\n+                     F := First_Formal (Enc_Subp);\n+                     A := First_Actual (Par);\n \n-                  elsif Nkind_In (Par, N_Op_Eq, N_Op_Ne) then\n-                     if N = Right_Opnd (Par)\n-                       and then Is_Tag_Indeterminate (Left_Opnd (Par))\n-                     then\n-                        Abstract_Context_Error;\n+                     --  Find controlling type of call. Dereference if function\n+                     --  returns an access type.\n \n-                     elsif N = Left_Opnd (Par)\n-                       and then Is_Tag_Indeterminate (Right_Opnd (Par))\n-                     then\n-                        Abstract_Context_Error;\n+                     Ret_Type := Etype (Call);\n+                     if Is_Access_Type (Etype (Call)) then\n+                        Ret_Type := Designated_Type (Ret_Type);\n                      end if;\n \n-                     return;\n+                     while Present (F) loop\n+                        Control := Etype (A);\n \n-                  elsif Nkind (Par) = N_Assignment_Statement then\n-                     return;\n+                        if Is_Access_Type (Control) then\n+                           Control := Designated_Type (Control);\n+                        end if;\n+\n+                        if Is_Controlling_Formal (F)\n+                          and then not (Call = A or else Parent (Call) = A)\n+                          and then Control = Class_Wide_Type (Ret_Type)\n+                        then\n+                           return;\n+                        end if;\n+\n+                        Next_Formal (F);\n+                        Next_Actual (A);\n+                     end loop;\n \n-                  elsif Nkind (Par) = N_Qualified_Expression\n-                    or else Nkind (Par) = N_Unchecked_Type_Conversion\n+                     if Nkind (Par) = N_Function_Call\n+                       and then Is_Tag_Indeterminate (Par)\n+                     then\n+                        --  The parent may be an actual of an enclosing call\n+\n+                        Check_Dispatching_Context (Par);\n+                        return;\n+\n+                     else\n+                        Error_Msg_N\n+                          (\"call to abstract function must be dispatching\",\n+                           Call);\n+                        return;\n+                     end if;\n+                  end;\n+\n+               --  For equality operators, one of the operands must be\n+               --  statically or dynamically tagged.\n+\n+               elsif Nkind_In (Par, N_Op_Eq, N_Op_Ne) then\n+                  if N = Right_Opnd (Par)\n+                    and then Is_Tag_Indeterminate (Left_Opnd (Par))\n                   then\n-                     Par := Parent (Par);\n+                     Abstract_Context_Error;\n \n-                  else\n+                  elsif N = Left_Opnd (Par)\n+                    and then Is_Tag_Indeterminate (Right_Opnd (Par))\n+                  then\n                      Abstract_Context_Error;\n-                     return;\n                   end if;\n-               end loop;\n+\n+                  return;\n+\n+               --  The left-hand side of an assignment provides the tag\n+\n+               elsif Nkind (Par) = N_Assignment_Statement then\n+                  return;\n+\n+               else\n+                  Abstract_Context_Error;\n+               end if;\n             end if;\n          end if;\n       end Check_Dispatching_Context;\n@@ -813,11 +845,12 @@ package body Sem_Disp is\n                Next_Formal (Formal);\n             end loop;\n \n-            Check_Dispatching_Context;\n+            Check_Dispatching_Context (N);\n+\n+         elsif Nkind (N) /= N_Function_Call then\n \n-         else\n             --  The call is not dispatching, so check that there aren't any\n-            --  tag-indeterminate abstract calls left.\n+            --  tag-indeterminate abstract calls left among its actuals.\n \n             Actual := First_Actual (N);\n             while Present (Actual) loop\n@@ -836,7 +869,7 @@ package body Sem_Disp is\n                   then\n                      Func := Empty;\n \n-                  --  Ditto if it is an explicit dereference.\n+                  --  Ditto if it is an explicit dereference\n \n                   elsif Nkind (Original_Node (Actual)) = N_Explicit_Dereference\n                   then\n@@ -848,28 +881,41 @@ package body Sem_Disp is\n                   else\n                      Func :=\n                        Entity (Name (Original_Node\n-                                       (Expression (Original_Node (Actual)))));\n+                         (Expression (Original_Node (Actual)))));\n                   end if;\n \n                   if Present (Func) and then Is_Abstract_Subprogram (Func) then\n                      Error_Msg_N\n-                       (\"call to abstract function must be dispatching\", N);\n+                       (\"call to abstract function must be dispatching\",\n+                        Actual);\n                   end if;\n                end if;\n \n                Next_Actual (Actual);\n             end loop;\n \n-            Check_Dispatching_Context;\n+            Check_Dispatching_Context (N);\n+            return;\n+\n+         elsif Nkind (Parent (N)) in N_Subexpr then\n+            Check_Dispatching_Context (N);\n+\n+         elsif Nkind (Parent (N)) = N_Assignment_Statement\n+           and then Is_Class_Wide_Type (Etype (Name (Parent (N))))\n+         then\n+            return;\n+\n+         elsif Is_Abstract_Subprogram (Subp_Entity) then\n+            Check_Dispatching_Context (N);\n+            return;\n          end if;\n \n       else\n-\n          --  If dispatching on result, the enclosing call, if any, will\n          --  determine the controlling argument. Otherwise this is the\n          --  primitive operation of the root type.\n \n-         Check_Dispatching_Context;\n+         Check_Dispatching_Context (N);\n       end if;\n    end Check_Dispatching_Call;\n "}, {"sha": "534681a8294d13c91595e43de786f06ac8bb348d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 169, "deletions": 36, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0d66b5969fec023f9aa6c297ba8550f5621cb2ea", "patch": "@@ -245,10 +245,13 @@ package body Sem_Prag is\n    --  Determine whether dependency clause Clause is surrounded by extra\n    --  parentheses. If this is the case, issue an error message.\n \n-   function Is_CCT_Instance (Ref : Node_Id) return Boolean;\n+   function Is_CCT_Instance\n+     (Ref_Id     : Entity_Id;\n+      Context_Id : Entity_Id) return Boolean;\n    --  Subsidiary to the analysis of pragmas [Refined_]Depends and [Refined_]\n-   --  Global. Determine whether reference Ref denotes the current instance of\n-   --  a concurrent type.\n+   --  Global. Determine whether entity Ref_Id denotes the current instance of\n+   --  a concurrent type. Context_Id denotes the associated context where the\n+   --  pragma appears.\n \n    function Is_Unconstrained_Or_Tagged_Item (Item : Entity_Id) return Boolean;\n    --  Subsidiary to Collect_Subprogram_Inputs_Outputs and the analysis of\n@@ -559,6 +562,10 @@ package body Sem_Prag is\n       --  Two lists containing the full set of inputs and output of the related\n       --  subprograms. Note that these lists contain both nodes and entities.\n \n+      Task_Input_Seen  : Boolean := False;\n+      Task_Output_Seen : Boolean := False;\n+      --  Flags used to track the implicit dependence of a task unit on itself\n+\n       procedure Add_Item_To_Name_Buffer (Item_Id : Entity_Id);\n       --  Subsidiary routine to Check_Role and Check_Usage. Add the item kind\n       --  to the name buffer. The individual kinds are as follows:\n@@ -590,7 +597,7 @@ package body Sem_Prag is\n          Item_Id  : Entity_Id;\n          Is_Input : Boolean;\n          Self_Ref : Boolean);\n-      --  Ensure that an item fulfils its designated input and/or output role\n+      --  Ensure that an item fulfills its designated input and/or output role\n       --  as specified by pragma Global (if any) or the enclosing context. If\n       --  this is not the case, emit an error. Item and Item_Id denote the\n       --  attributes of an item. Flag Is_Input should be set when item comes\n@@ -763,10 +770,31 @@ package body Sem_Prag is\n             Null_Seen     : in out Boolean;\n             Non_Null_Seen : in out Boolean)\n          is\n+            procedure Current_Task_Instance_Seen;\n+            --  Set the appropriate global flag when the current instance of a\n+            --  task unit is encountered.\n+\n+            --------------------------------\n+            -- Current_Task_Instance_Seen --\n+            --------------------------------\n+\n+            procedure Current_Task_Instance_Seen is\n+            begin\n+               if Is_Input then\n+                  Task_Input_Seen := True;\n+               else\n+                  Task_Output_Seen := True;\n+               end if;\n+            end Current_Task_Instance_Seen;\n+\n+            --  Local variables\n+\n             Is_Output : constant Boolean := not Is_Input;\n             Grouped   : Node_Id;\n             Item_Id   : Entity_Id;\n \n+         --  Start of processing for Analyze_Input_Output\n+\n          begin\n             --  Multiple input or output items appear as an aggregate\n \n@@ -899,18 +927,45 @@ package body Sem_Prag is\n \n                     Ekind_In (Item_Id, E_Abstract_State, E_Variable)\n                   then\n-                     --  The item denotes a concurrent type, but it is not the\n-                     --  current instance of an enclosing concurrent type.\n+                     --  The item denotes a concurrent type. Note that single\n+                     --  protected/task types are not considered here because\n+                     --  they behave as objects in the context of pragma\n+                     --  [Refined_]Depends.\n+\n+                     if Ekind_In (Item_Id, E_Protected_Type, E_Task_Type) then\n+\n+                        --  This use is legal as long as the concurrent type is\n+                        --  the current instance of an enclosing type.\n+\n+                        if Is_CCT_Instance (Item_Id, Spec_Id) then\n \n-                     if Ekind_In (Item_Id, E_Protected_Type, E_Task_Type)\n-                       and then not Is_CCT_Instance (Item)\n+                           --  The dependence of a task unit on itself is\n+                           --  implicit and may or may not be explicitly\n+                           --  specified (SPARK RM 6.1.4).\n+\n+                           if Ekind (Item_Id) = E_Task_Type then\n+                              Current_Task_Instance_Seen;\n+                           end if;\n+\n+                        --  Otherwise this is not the current instance\n+\n+                        else\n+                           SPARK_Msg_N\n+                             (\"invalid use of subtype mark in dependency \"\n+                              & \"relation\", Item);\n+                        end if;\n+\n+                     --  The dependency of a task unit on itself is implicit\n+                     --  and may or may not be explicitly specified\n+                     --  (SPARK RM 6.1.4).\n+\n+                     elsif Is_Single_Task_Object (Item_Id)\n+                       and then Is_CCT_Instance (Item_Id, Spec_Id)\n                      then\n-                        SPARK_Msg_N\n-                          (\"invalid use of subtype mark in dependency \"\n-                           & \"relation\", Item);\n+                        Current_Task_Instance_Seen;\n                      end if;\n \n-                     --  Ensure that the item fulfils its role as input and/or\n+                     --  Ensure that the item fulfills its role as input and/or\n                      --  output as specified by pragma Global or the enclosing\n                      --  context.\n \n@@ -1427,14 +1482,31 @@ package body Sem_Prag is\n             if Present (Item_Id)\n               and then not Contains (Used_Items, Item_Id)\n             then\n-               --  The current instance of a concurrent type behaves as a\n-               --  formal parameter (SPARK RM 6.1.4).\n+               if Is_Formal (Item_Id) then\n+                  Usage_Error (Item_Id);\n \n-               if Is_Formal (Item_Id)\n-                 or else Ekind_In (Item_Id, E_Protected_Type, E_Task_Type)\n+               --  The current instance of a protected type behaves as a formal\n+               --  parameter (SPARK RM 6.1.4).\n+\n+               elsif Ekind (Item_Id) = E_Protected_Type\n+                 or else Is_Single_Protected_Object (Item_Id)\n                then\n                   Usage_Error (Item_Id);\n \n+               --  The current instance of a task type behaves as a formal\n+               --  parameter (SPARK RM 6.1.4).\n+\n+               elsif Ekind (Item_Id) = E_Task_Type\n+                 or else Is_Single_Task_Object (Item_Id)\n+               then\n+                  --  The dependence of a task unit on itself is implicit and\n+                  --  may or may not be explicitly specified (SPARK RM 6.1.4).\n+                  --  Emit an error if only one input/output is present.\n+\n+                  if Task_Input_Seen /= Task_Output_Seen then\n+                     Usage_Error (Item_Id);\n+                  end if;\n+\n                --  States and global objects are not used properly only when\n                --  the subprogram is subject to pragma Global.\n \n@@ -2036,20 +2108,18 @@ package body Sem_Prag is\n                   end if;\n \n                --  A global item may denote a concurrent type as long as it is\n-               --  the current instance of an enclosing concurrent type\n+               --  the current instance of an enclosing protected or task type\n                --  (SPARK RM 6.1.4).\n \n                elsif Ekind_In (Item_Id, E_Protected_Type, E_Task_Type) then\n-                  if Is_CCT_Instance (Item) then\n+                  if Is_CCT_Instance (Item_Id, Spec_Id) then\n \n                      --  Pragma [Refined_]Global associated with a protected\n                      --  subprogram cannot mention the current instance of a\n                      --  protected type because the instance behaves as a\n                      --  formal parameter.\n \n-                     if Ekind (Item_Id) = E_Protected_Type\n-                       and then Scope (Spec_Id) = Item_Id\n-                     then\n+                     if Ekind (Item_Id) = E_Protected_Type then\n                         Error_Msg_Name_1 := Chars (Item_Id);\n                         SPARK_Msg_NE\n                           (Fix_Msg (Spec_Id, \"global item of subprogram & \"\n@@ -2061,9 +2131,7 @@ package body Sem_Prag is\n                      --  cannot mention the current instance of a task type\n                      --  because the instance behaves as a formal parameter.\n \n-                     elsif Ekind (Item_Id) = E_Task_Type\n-                       and then Spec_Id = Item_Id\n-                     then\n+                     else pragma Assert (Ekind (Item_Id) = E_Task_Type);\n                         Error_Msg_Name_1 := Chars (Item_Id);\n                         SPARK_Msg_NE\n                           (Fix_Msg (Spec_Id, \"global item of subprogram & \"\n@@ -2081,6 +2149,39 @@ package body Sem_Prag is\n                      return;\n                   end if;\n \n+               --  A global item may denote the anonymous object created for a\n+               --  single protected/task type as long as the current instance\n+               --  is the same single type (SPARK RM 6.1.4).\n+\n+               elsif Is_Single_Concurrent_Object (Item_Id)\n+                 and then Is_CCT_Instance (Item_Id, Spec_Id)\n+               then\n+                  --  Pragma [Refined_]Global associated with a protected\n+                  --  subprogram cannot mention the current instance of a\n+                  --  protected type because the instance behaves as a formal\n+                  --  parameter.\n+\n+                  if Is_Single_Protected_Object (Item_Id) then\n+                     Error_Msg_Name_1 := Chars (Item_Id);\n+                     SPARK_Msg_NE\n+                       (Fix_Msg (Spec_Id, \"global item of subprogram & cannot \"\n+                        & \"reference current instance of protected type %\"),\n+                        Item, Spec_Id);\n+                     return;\n+\n+                  --  Pragma [Refined_]Global associated with a task type\n+                  --  cannot mention the current instance of a task type\n+                  --  because the instance behaves as a formal parameter.\n+\n+                  else pragma Assert (Is_Single_Task_Object (Item_Id));\n+                     Error_Msg_Name_1 := Chars (Item_Id);\n+                     SPARK_Msg_NE\n+                       (Fix_Msg (Spec_Id, \"global item of subprogram & cannot \"\n+                        & \"reference current instance of task type %\"),\n+                        Item, Spec_Id);\n+                     return;\n+                  end if;\n+\n                --  A formal object may act as a global item inside a generic\n \n                elsif Is_Formal_Object (Item_Id) then\n@@ -27455,23 +27556,55 @@ package body Sem_Prag is\n    -- Is_CCT_Instance --\n    ---------------------\n \n-   function Is_CCT_Instance (Ref : Node_Id) return Boolean is\n-      Ref_Id : constant Entity_Id := Entity (Ref);\n-      S      : Entity_Id;\n+   function Is_CCT_Instance\n+     (Ref_Id     : Entity_Id;\n+      Context_Id : Entity_Id) return Boolean\n+   is\n+      S   : Entity_Id;\n+      Typ : Entity_Id;\n \n    begin\n-      --  Climb the scope chain looking for an enclosing concurrent type that\n-      --  matches the referenced entity.\n+      --  When the reference denotes a single protected type, the context is\n+      --  either a protected subprogram or its body.\n \n-      S := Current_Scope;\n-      while Present (S) and then S /= Standard_Standard loop\n-         if Ekind_In (S, E_Protected_Type, E_Task_Type) and then S = Ref_Id\n-         then\n-            return True;\n+      if Is_Single_Protected_Object (Ref_Id) then\n+         Typ := Scope (Context_Id);\n+\n+         return\n+           Ekind (Typ) = E_Protected_Type\n+             and then Present (Anonymous_Object (Typ))\n+             and then Anonymous_Object (Typ) = Ref_Id;\n+\n+      --  When the reference denotes a single task type, the context is either\n+      --  the same type or if inside the body, the anonymous task type.\n+\n+      elsif Is_Single_Task_Object (Ref_Id) then\n+         if Ekind (Context_Id) = E_Task_Type then\n+            return\n+              Present (Anonymous_Object (Context_Id))\n+                and then Anonymous_Object (Context_Id) = Ref_Id;\n+         else\n+            return Ref_Id = Context_Id;\n          end if;\n \n-         S := Scope (S);\n-      end loop;\n+      --  Otherwise the reference denotes a protected or a task type. Climb the\n+      --  scope chain looking for an enclosing concurrent type that matches the\n+      --  referenced entity.\n+\n+      else\n+         pragma Assert (Ekind_In (Ref_Id, E_Protected_Type, E_Task_Type));\n+\n+         S := Current_Scope;\n+         while Present (S) and then S /= Standard_Standard loop\n+            if Ekind_In (S, E_Protected_Type, E_Task_Type)\n+              and then S = Ref_Id\n+            then\n+               return True;\n+            end if;\n+\n+            S := Scope (S);\n+         end loop;\n+      end if;\n \n       return False;\n    end Is_CCT_Instance;"}, {"sha": "918d9e5d4fa331c35e4b21223258f6d4c7ddd832", "filename": "gcc/ada/sigtramp-vxworks-vxsim.c", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a86c18d9fa6e2444917934fc4b7d5f22f957d51b/gcc%2Fada%2Fsigtramp-vxworks-vxsim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a86c18d9fa6e2444917934fc4b7d5f22f957d51b/gcc%2Fada%2Fsigtramp-vxworks-vxsim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-vxworks-vxsim.c?ref=a86c18d9fa6e2444917934fc4b7d5f22f957d51b", "patch": "@@ -1,141 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                             S I G T R A M P                              *\n- *                                                                          *\n- *                         Asm Implementation File                          *\n- *                                                                          *\n- *         Copyright (C) 2011-2015, Free Software Foundation, Inc.          *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n- *                                                                          *\n- * As a special exception under Section 7 of GPL version 3, you are granted *\n- * additional permissions described in the GCC Runtime Library Exception,   *\n- * version 3.1, as published by the Free Software Foundation.               *\n- *                                                                          *\n- * In particular,  you can freely  distribute your programs  built with the *\n- * GNAT Pro compiler, including any required library run-time units,  using *\n- * any licensing terms  of your choosing.  See the AdaCore Software License *\n- * for full details.                                                        *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/********************************************************\n- * VxWorks VXSIM version of the __gnat_sigtramp service *\n- ********************************************************/\n-\n-#undef CPU\n-#define CPU __VXSIM_CPU__\n-\n-#include \"sigtramp.h\"\n-/* See sigtramp.h for a general explanation of functionality.  */\n-\n-#include <vxWorks.h>\n-#include <arch/../regs.h>\n-#ifndef __RTP__\n-#include <sigLib.h>\n-#else\n-#include <signal.h>\n-#include <regs.h>\n-\n-typedef struct mcontext\n-  {\n-    REG_SET     regs;\n-  } mcontext_t;\n-\n-typedef struct ucontext\n-  {\n-    mcontext_t          uc_mcontext;    /* register set */\n-    struct ucontext *   uc_link;        /* not used */\n-    sigset_t            uc_sigmask;     /* set of signals blocked */\n-    stack_t             uc_stack;       /* stack of context signaled */\n-  } ucontext_t;\n-#endif\n-\n-/* ----------------------\n-   -- General comments --\n-   ----------------------\n-\n-   Stubs are generated from toplevel asms and .cfi directives, much simpler\n-   to use and check for correctness than manual encodings of CFI byte\n-   sequences.  The general idea is to establish CFA as sigcontext->sc_pregs\n-   (for DKM) and mcontext (for RTP) and state where to find the registers as\n-   offsets from there.\n-\n-   As of today, we support a stub providing CFI info for common\n-   registers (GPRs, LR, ...). We might need variants with support for floating\n-   point or altivec registers as well at some point.\n-\n-   Checking which variant should apply and getting at sc_pregs / mcontext\n-   is simpler to express in C (we can't use offsetof in toplevel asms and\n-   hardcoding constants is not workable with the flurry of VxWorks variants),\n-   so this is the choice for our toplevel interface.\n-\n-   Note that the registers we \"restore\" here are those to which we have\n-   direct access through the system sigcontext structure, which includes\n-   only a partial set of the non-volatiles ABI-wise.  */\n-\n-/* -------------------------------------------\n-   -- Prototypes for our internal asm stubs --\n-   -------------------------------------------\n-\n-   Eventhough our symbols will remain local, the prototype claims \"extern\"\n-   and not \"static\" to prevent compiler complaints about a symbol used but\n-   never defined.  */\n-\n-/* sigtramp stub providing CFI info for common registers.  */\n-\n-extern void __gnat_sigtramp_vxsim_common\n-(int signo, void *siginfo, void *sigcontext,\n- __sigtramphandler_t * handler, void * sc_pregs);\n-\n-\n-/* -------------------------------------\n-   -- Common interface implementation --\n-   -------------------------------------\n-\n-   We enforce optimization to minimize the overhead of the extra layer.  */\n-\n-void __gnat_sigtramp_vxsim (int signo, void *si, void *sc,\n-\t\t      __sigtramphandler_t * handler)\n-     __attribute__((optimize(2)));\n-\n-void __gnat_sigtramp_vxsim (int signo, void *si, void *sc,\n-\t\t      __sigtramphandler_t * handler)\n-{\n-#ifdef __RTP__\n-  mcontext_t *mcontext = &((ucontext_t *) sc)->uc_mcontext;\n-\n-  /* Pass MCONTEXT in the fifth position so that the assembly code can find\n-     it at the same stack location or in the same register as SC_PREGS.  */\n-  __gnat_sigtramp_vxsim_common (signo, si, mcontext, handler, mcontext);\n-#else\n-  struct sigcontext * sctx = (struct sigcontext *) sc;\n-\n-  __gnat_sigtramp_vxsim_common (signo, si, sctx, handler, sctx->sc_pregs);\n-#endif\n-}\n-\n-/* Include the target specific bits.  */\n-#include \"sigtramp-vxworks-target.inc\"\n-\n-/* sigtramp stub for common registers.  */\n-\n-#define TRAMP_COMMON __gnat_sigtramp_vxsim_common\n-\n-asm (SIGTRAMP_START(TRAMP_COMMON));\n-asm (CFI_DEF_CFA);\n-asm (CFI_COMMON_REGS);\n-asm (SIGTRAMP_BODY);\n-asm (SIGTRAMP_END(TRAMP_COMMON));\n-\n-"}, {"sha": "e9dd9aa1ce8c4ad1902c4274f0f918b888e1dea5", "filename": "gcc/ada/sigtramp-vxworks.c", "status": "modified", "additions": 61, "deletions": 15, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Fsigtramp-vxworks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Fsigtramp-vxworks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-vxworks.c?ref=0d66b5969fec023f9aa6c297ba8550f5621cb2ea", "patch": "@@ -89,50 +89,96 @@ typedef struct ucontext\n    and not \"static\" to prevent compiler complaints about a symbol used but\n    never defined.  */\n \n-/* sigtramp stub providing CFI info for common registers.  */\n+#define TRAMP_COMMON __gnat_sigtramp_common\n \n-extern void __gnat_sigtramp_common\n-(int signo, void *siginfo, void *sigcontext,\n- __sigtramphandler_t * handler, void * sc_pregs);\n+/* sigtramp stub providing CFI info for common registers.  */\n \n+extern void\n+TRAMP_COMMON (int signo, void *siginfo, void *sigcontext,\n+              __sigtramphandler_t * handler, REG_SET * sc_pregs);\n \n /* -------------------------------------\n    -- Common interface implementation --\n    -------------------------------------\n \n    We enforce optimization to minimize the overhead of the extra layer.  */\n \n+#if defined(__vxworks) && (defined (__i386__) || defined (__x86_64__)) && !defined (VTHREADS)\n+static int __gnat_is_vxsim = 0;\n+\n+void __gnat_set_is_vxsim(int val) {\n+  __gnat_is_vxsim = val;\n+}\n+#endif\n+\n void __gnat_sigtramp (int signo, void *si, void *sc,\n \t\t      __sigtramphandler_t * handler)\n      __attribute__((optimize(2)));\n \n void __gnat_sigtramp (int signo, void *si, void *sc,\n \t\t      __sigtramphandler_t * handler)\n {\n-#ifdef __RTP__\n+  REG_SET *pregs;\n+\n+  /* VXSIM uses a different signal context structure than the regular x86\n+     targets:\n+     * on x86-vx6: two 32-bit values are added at the end of the REG_SET, plus\n+       an explicit padding of 0xc8 characters (200 characters). The sigcontext\n+       containing a complete REG_SET just before the field 'sc_pregs', this\n+       adds a 208 bytes offset to get the value of 'sc_pregs'.\n+     * on x86-vx7: the same offset is used on vx7: 3 32-bit values are present\n+       at the enf of the reg set, but the padding is then of 0xc4 characters.\n+     * on x86_64-vx7: two 64-bit values are added at the beginning of the\n+       REG_SET. This adds a 16 bytes offset to get the value of 'sc_pregs',\n+       and another 16 bytes offset within the pregs structure to retrieve the\n+       registers list.\n+  */\n+\n+  /* Retrieve the registers to restore : */\n+#ifndef __RTP__\n+#ifdef __HANDLE_VXSIM_SC\n+#if defined(__i386__)\n+  /* move sctx 208 bytes further, so that the vxsim's sc_pregs field coincide\n+     with the expected x86 one */\n+  struct sigcontext * sctx =\n+    (struct sigcontext *) (sc + (__gnat_is_vxsim ? 208 : 0));\n+#elif defined(__x86_64__)\n+  /* move sctx 16 bytes further, so that the vxsim's sc_pregs field coincide\n+     with the expected x86_64 one */\n+  struct sigcontext * sctx =\n+    (struct sigcontext *) (sc + (__gnat_is_vxsim ? 16 : 0));\n+#endif /* __i386__ || __x86_64__ */\n+#else  /* __HANDLE_VXSIM_SC__ */\n+  struct sigcontext * sctx = (struct sigcontext *) sc;\n+#endif\n+\n+  pregs = sctx->sc_pregs;\n+\n+#else /* !defined(__RTP__) */\n+\n   mcontext_t *mcontext = &((ucontext_t *) sc)->uc_mcontext;\n+  /* No specific offset in this case for vxsim */\n+  pregs = &(mcontext->regs);\n \n-  /* Pass MCONTEXT in the fifth position so that the assembly code can find\n-     it at the same stack location or in the same register as SC_PREGS.  */\n-  __gnat_sigtramp_common (signo, si, mcontext, handler, mcontext);\n-#else\n-  struct sigcontext * sctx = (struct sigcontext *) sc;\n+#endif /* !defined(__RTP__) */\n \n-  __gnat_sigtramp_common (signo, si, sctx, handler, sctx->sc_pregs);\n+#if defined (__HANDLE_VXSIM_SC) && defined (__x86_64__)\n+  /* Ignore the first two values, that are not registers in case of\n+     vxsim */\n+  pregs = (REG_SET *) ((void *)pregs + (__gnat_is_vxsim ? 16 : 0));\n #endif\n+\n+  /* And now call the real signal trampoline with the list of registers */\n+  __gnat_sigtramp_common (signo, si, sc, handler, pregs);\n }\n \n /* Include the target specific bits.  */\n #include \"sigtramp-vxworks-target.inc\"\n \n /* sigtramp stub for common registers.  */\n \n-#define TRAMP_COMMON __gnat_sigtramp_common\n-\n asm (SIGTRAMP_START(TRAMP_COMMON));\n asm (CFI_DEF_CFA);\n asm (CFI_COMMON_REGS);\n asm (SIGTRAMP_BODY);\n asm (SIGTRAMP_END(TRAMP_COMMON));\n-\n-"}, {"sha": "7314d6f7db64c097e344b19d65a296bc6ce7e6bf", "filename": "gcc/ada/sigtramp.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Fsigtramp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d66b5969fec023f9aa6c297ba8550f5621cb2ea/gcc%2Fada%2Fsigtramp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp.h?ref=0d66b5969fec023f9aa6c297ba8550f5621cb2ea", "patch": "@@ -43,14 +43,15 @@ extern \"C\" {\n    system headers so call it something unique.  */\n typedef void __sigtramphandler_t (int signo, void *siginfo, void *sigcontext);\n \n-#if defined(__vxworks) && (CPU == SIMNT || CPU == SIMPENTIUM || CPU == SIMLINUX)\n-/* Vxsim requires a specially compiled handler.  */\n-extern void __gnat_sigtramp_vxsim (int signo, void *siginfo, void *sigcontext,\n-\t\t\t\t   __sigtramphandler_t * handler);\n-#else\n+/* The vxsim target has a different sigcontext structure than the one we're\n+   compiling the run-time with. We thus need to adjust it in this case */\n+#if defined(__vxworks) && (defined (__i386__) || defined (__x86_64__)) && !defined (VTHREADS)\n+#define __HANDLE_VXSIM_SC\n+extern void __gnat_set_is_vxsim(int val);\n+#endif\n+\n extern void __gnat_sigtramp (int signo, void *siginfo, void *sigcontext,\n \t\t\t     __sigtramphandler_t * handler);\n-#endif\n \n /* The signal trampoline is to be called from an established signal handler.\n    It sets up the DWARF CFI and calls HANDLER (SIGNO, SIGINFO, SIGCONTEXT)."}]}