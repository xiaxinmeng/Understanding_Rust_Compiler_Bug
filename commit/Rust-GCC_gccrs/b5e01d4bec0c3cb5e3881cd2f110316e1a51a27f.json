{"sha": "b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVlMDFkNGJlYzBjM2NiNWUzODgxY2QyZjExMDMxNmUxYTUxYTI3Zg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-02-11T19:34:11Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-02-11T19:34:11Z"}, "message": "optabs.h (enum optab_index): Add new OTI_pow and OTI_atan2.\n\n\n\t* optabs.h (enum optab_index): Add new OTI_pow and OTI_atan2.\n\t(pow_optab, atan2_optab): Define corresponding macros.\n\t* optabs.c (init_optabs): Initialize pow_optab and atan2_optab.\n\t* genopinit.c (optabs): Implement pow_optab and atan2_optab\n\tusing pow?f3 and atan2?f3 patterns.\n\t* builtins.c (expand_errno_check): New function to update errno\n\tif necessary, split out from expand_builtin_mathfn.\n\t(expand_builtin_mathfn): Use expand_errno_check.\n\t(expand_builtin_mathfn_2): New function to handle expanding binary\n\tmath functions, reusing the code in expand_errno_check.\n\t(expand_builtin): Handle the pow and atan2 math built-ins,\n\tBUILT_IN_{POW,POWF,POWL,ATAN2,ATAN2F,ATAN2L} via the new function\n\texpand_builtin_mathfn_2.\n\n\t* doc/md.texi: Document new pow?f3 and atan2?f3 patterns.\n\nFrom-SVN: r62708", "tree": {"sha": "7ceaf59c454cfc0fade6ccb54dfb5372b71cd8d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ceaf59c454cfc0fade6ccb54dfb5372b71cd8d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/comments", "author": null, "committer": null, "parents": [{"sha": "290a4db98103f24105c77df2e78396892ae3957f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/290a4db98103f24105c77df2e78396892ae3957f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/290a4db98103f24105c77df2e78396892ae3957f"}], "stats": {"total": 234, "additions": 203, "deletions": 31}, "files": [{"sha": "b162e12186f9e3357fe49e14a35a456b3aa43a21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f", "patch": "@@ -1,3 +1,21 @@\n+2003-02-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* optabs.h (enum optab_index): Add new OTI_pow and OTI_atan2.\n+\t(pow_optab, atan2_optab): Define corresponding macros.\n+\t* optabs.c (init_optabs): Initialize pow_optab and atan2_optab.\n+\t* genopinit.c (optabs): Implement pow_optab and atan2_optab\n+\tusing pow?f3 and atan2?f3 patterns.\n+\t* builtins.c (expand_errno_check): New function to update errno\n+\tif necessary, split out from expand_builtin_mathfn.\n+\t(expand_builtin_mathfn): Use expand_errno_check.\n+\t(expand_builtin_mathfn_2): New function to handle expanding binary\n+\tmath functions, reusing the code in expand_errno_check.\n+\t(expand_builtin): Handle the pow and atan2 math built-ins,\n+\tBUILT_IN_{POW,POWF,POWL,ATAN2,ATAN2F,ATAN2L} via the new function\n+\texpand_builtin_mathfn_2.\n+\n+\t* doc/md.texi: Document new pow?f3 and atan2?f3 patterns.\n+\n Tue Feb 11 19:03:22 MET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* combine.c (combine_simplify_rtx): Fix folding of"}, {"sha": "94788083b3af4ca70b3dfb4f0051fd76b6ec609c", "filename": "gcc/builtins.c", "status": "modified", "additions": 149, "deletions": 26, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f", "patch": "@@ -99,7 +99,9 @@ static rtx expand_builtin_apply\t\tPARAMS ((rtx, rtx, rtx));\n static void expand_builtin_return\tPARAMS ((rtx));\n static enum type_class type_to_class\tPARAMS ((tree));\n static rtx expand_builtin_classify_type\tPARAMS ((tree));\n+static void expand_errno_check\t\tPARAMS ((tree, rtx));\n static rtx expand_builtin_mathfn\tPARAMS ((tree, rtx, rtx));\n+static rtx expand_builtin_mathfn_2\tPARAMS ((tree, rtx, rtx));\n static rtx expand_builtin_constant_p\tPARAMS ((tree));\n static rtx expand_builtin_args_info\tPARAMS ((tree));\n static rtx expand_builtin_next_arg\tPARAMS ((tree));\n@@ -1655,6 +1657,50 @@ mathfn_built_in (type, fn)\n   return implicit_built_in_decls[fcode];\n }\n \n+/* If errno must be maintained, expand the RTL to check if the result,\n+   TARGET, of a built-in function call, EXP, is NaN, and if so set\n+   errno to EDOM.  */\n+\n+static void\n+expand_errno_check (exp, target)\n+     tree exp;\n+     rtx target;\n+{\n+  rtx lab;\n+\n+  if (flag_errno_math && errno_set && HONOR_NANS (GET_MODE (target)))\n+    {\n+      lab = gen_label_rtx ();\n+\n+      /* Test the result; if it is NaN, set errno=EDOM because\n+\t the argument was not in the domain.  */\n+      emit_cmp_and_jump_insns (target, target, EQ, 0, GET_MODE (target),\n+\t\t\t       0, lab);\n+\n+#ifdef TARGET_EDOM\n+      {\n+#ifdef GEN_ERRNO_RTX\n+\trtx errno_rtx = GEN_ERRNO_RTX;\n+#else\n+\trtx errno_rtx\n+\t  = gen_rtx_MEM (word_mode, gen_rtx_SYMBOL_REF (Pmode, \"errno\"));\n+#endif\n+\n+\temit_move_insn (errno_rtx, GEN_INT (TARGET_EDOM));\n+      }\n+#else\n+      /* We can't set errno=EDOM directly; let the library call do it.\n+\t Pop the arguments right away in case the call gets deleted.  */\n+      NO_DEFER_POP;\n+      expand_call (exp, target, 0);\n+      OK_DEFER_POP;\n+#endif\n+\n+      emit_label (lab);\n+    }\n+}\n+\n+\n /* Expand a call to one of the builtin math functions (sin, cos, or sqrt).\n    Return 0 if a normal call should be emitted rather than expanding the\n    function in-line.  EXP is the expression that is a call to the builtin\n@@ -1760,41 +1806,105 @@ expand_builtin_mathfn (exp, target, subtarget)\n       return 0;\n     }\n \n-  /* If errno must be maintained, we must set it to EDOM for NaN results.  */\n+  expand_errno_check (exp, target);\n \n-  if (flag_errno_math && errno_set && HONOR_NANS (argmode))\n+  /* Output the entire sequence.  */\n+  insns = get_insns ();\n+  end_sequence ();\n+  emit_insn (insns);\n+\n+  return target;\n+}\n+\n+/* Expand a call to the builtin binary math functions (pow and atan2).\n+   Return 0 if a normal call should be emitted rather than expanding the\n+   function in-line.  EXP is the expression that is a call to the builtin\n+   function; if convenient, the result should be placed in TARGET.\n+   SUBTARGET may be used as the target for computing one of EXP's\n+   operands.  */\n+\n+static rtx\n+expand_builtin_mathfn_2 (exp, target, subtarget)\n+     tree exp;\n+     rtx target, subtarget;\n+{\n+  optab builtin_optab;\n+  rtx op0, op1, insns;\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg0, arg1;\n+  enum machine_mode argmode;\n+  bool errno_set = true;\n+  bool stable = true;\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg0 = TREE_VALUE (arglist);\n+  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+  /* Stabilize the arguments.  */\n+  if (TREE_CODE (arg0) != VAR_DECL && TREE_CODE (arg0) != PARM_DECL)\n+    {\n+      arg0 = save_expr (arg0);\n+      TREE_VALUE (arglist) = arg0;\n+      stable = false;\n+    }\n+  if (TREE_CODE (arg1) != VAR_DECL && TREE_CODE (arg1) != PARM_DECL)\n     {\n-      rtx lab1;\n+      arg1 = save_expr (arg1);\n+      TREE_VALUE (TREE_CHAIN (arglist)) = arg1;\n+      stable = false;\n+    }\n \n-      lab1 = gen_label_rtx ();\n+  if (! stable)\n+    {\n+      exp = copy_node (exp);\n+      arglist = tree_cons (NULL_TREE, arg0,\n+\t\t\t   build_tree_list (NULL_TREE, arg1));\n+      TREE_OPERAND (exp, 1) = arglist;\n+    }\n \n-      /* Test the result; if it is NaN, set errno=EDOM because\n-\t the argument was not in the domain.  */\n-      emit_cmp_and_jump_insns (target, target, EQ, 0, GET_MODE (target),\n-\t\t\t       0, lab1);\n+  op0 = expand_expr (arg0, subtarget, VOIDmode, 0);\n+  op1 = expand_expr (arg1, 0, VOIDmode, 0);\n \n-#ifdef TARGET_EDOM\n-      {\n-#ifdef GEN_ERRNO_RTX\n-\trtx errno_rtx = GEN_ERRNO_RTX;\n-#else\n-\trtx errno_rtx\n-\t  = gen_rtx_MEM (word_mode, gen_rtx_SYMBOL_REF (Pmode, \"errno\"));\n-#endif\n+  /* Make a suitable register to place result in.  */\n+  target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n \n-\temit_move_insn (errno_rtx, GEN_INT (TARGET_EDOM));\n-      }\n-#else\n-      /* We can't set errno=EDOM directly; let the library call do it.\n-\t Pop the arguments right away in case the call gets deleted.  */\n-      NO_DEFER_POP;\n-      expand_call (exp, target, 0);\n-      OK_DEFER_POP;\n-#endif\n+  emit_queue ();\n+  start_sequence ();\n+\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    case BUILT_IN_POW:\n+    case BUILT_IN_POWF:\n+    case BUILT_IN_POWL:\n+      builtin_optab = pow_optab; break;\n+    case BUILT_IN_ATAN2:\n+    case BUILT_IN_ATAN2F:\n+    case BUILT_IN_ATAN2L:\n+      builtin_optab = atan2_optab; break;\n+    default:\n+      abort ();\n+    }\n+\n+  /* Compute into TARGET.\n+     Set TARGET to wherever the result comes back.  */\n+  argmode = TYPE_MODE (TREE_TYPE (arg0));\n+  target = expand_binop (argmode, builtin_optab, op0, op1,\n+\t\t\t target, 0, OPTAB_DIRECT);\n \n-      emit_label (lab1);\n+  /* If we were unable to expand via the builtin, stop the\n+     sequence (without outputting the insns) and return 0, causing\n+     a call to the library function.  */\n+  if (target == 0)\n+    {\n+      end_sequence ();\n+      return 0;\n     }\n \n+  expand_errno_check (exp, target);\n+\n   /* Output the entire sequence.  */\n   insns = get_insns ();\n   end_sequence ();\n@@ -4047,6 +4157,19 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \treturn target;\n       break;\n \n+    case BUILT_IN_POW:\n+    case BUILT_IN_POWF:\n+    case BUILT_IN_POWL:\n+    case BUILT_IN_ATAN2:\n+    case BUILT_IN_ATAN2F:\n+    case BUILT_IN_ATAN2L:\n+      if (! flag_unsafe_math_optimizations)\n+\tbreak;\n+      target = expand_builtin_mathfn_2 (exp, target, subtarget);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     case BUILT_IN_APPLY_ARGS:\n       return expand_builtin_apply_args ();\n "}, {"sha": "da7e38b0eab0c2ef0962b030af0b427b1e41e710", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f", "patch": "@@ -1,5 +1,5 @@\n-@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1996, 1998, 1999, 2000, 2001, 2002\n-@c Free Software Foundation, Inc.\n+@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1996, 1998, 1999, 2000, 2001,\n+@c 2002, 2003 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -2607,6 +2607,27 @@ corresponds to the C data type @code{double} and the @code{logf}\n built-in function uses the mode which corresponds to the C data\n type @code{float}.\n \n+@cindex @code{pow@var{m}3} instruction pattern\n+@item @samp{pow@var{m}3}\n+Store the value of operand 1 raised to the exponent operand 2\n+into operand 0.\n+\n+The @code{pow} built-in function of C always uses the mode which\n+corresponds to the C data type @code{double} and the @code{powf}\n+built-in function uses the mode which corresponds to the C data\n+type @code{float}.\n+\n+@cindex @code{atan2@var{m}3} instruction pattern\n+@item @samp{atan2@var{m}3}\n+Store the arc tangent (inverse tangent) of operand 1 divided by\n+operand 2 into operand 0, using the signs of both arguments to\n+determine the quadrant of the result.\n+\n+The @code{atan2} built-in function of C always uses the mode which\n+corresponds to the C data type @code{double} and the @code{atan2f}\n+built-in function uses the mode which corresponds to the C data\n+type @code{float}.\n+\n @cindex @code{floor@var{m}2} instruction pattern\n @item @samp{floor@var{m}2}\n Store the largest integral value not greater than argument."}, {"sha": "5d996b5919930e85f7d6d8d5e535accd23744d30", "filename": "gcc/genopinit.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f", "patch": "@@ -1,6 +1,6 @@\n /* Generate code to initialize optabs from machine description.\n-   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n+   2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -105,6 +105,8 @@ static const char * const optabs[] =\n   \"smax_optab->handlers[$A].insn_code = CODE_FOR_$(max$F$a3$)\",\n   \"umin_optab->handlers[$A].insn_code = CODE_FOR_$(umin$I$a3$)\",\n   \"umax_optab->handlers[$A].insn_code = CODE_FOR_$(umax$I$a3$)\",\n+  \"pow_optab->handlers[$A].insn_code = CODE_FOR_$(pow$a3$)\",\n+  \"atan2_optab->handlers[$A].insn_code = CODE_FOR_$(atan2$a3$)\",\n   \"neg_optab->handlers[$A].insn_code = CODE_FOR_$(neg$P$a2$)\",\n   \"negv_optab->handlers[(int) $A].insn_code =\\n\\\n     neg_optab->handlers[(int) $A].insn_code = CODE_FOR_$(neg$F$a2$)\","}, {"sha": "93b14984c3144d527fc0c99f46243a096ec5fad8", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f", "patch": "@@ -5512,6 +5512,8 @@ init_optabs ()\n   smax_optab = init_optab (SMAX);\n   umin_optab = init_optab (UMIN);\n   umax_optab = init_optab (UMAX);\n+  pow_optab = init_optab (UNKNOWN);\n+  atan2_optab = init_optab (UNKNOWN);\n \n   /* These three have codes assigned exclusively for the sake of\n      have_insn_for.  */"}, {"sha": "e9f95fa90914fe7c2840d00173fc06d20e537213", "filename": "gcc/optabs.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=b5e01d4bec0c3cb5e3881cd2f110316e1a51a27f", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for code generation pass of GNU compiler.\n-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -108,6 +108,10 @@ enum optab_index\n   OTI_umin,\n   /* Unsigned maximum value */\n   OTI_umax,\n+  /* Power */\n+  OTI_pow,\n+  /* Arc tangent of y/x */\n+  OTI_atan2,\n \n   /* Move instruction.  */\n   OTI_mov,\n@@ -202,6 +206,8 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define smax_optab (optab_table[OTI_smax])\n #define umin_optab (optab_table[OTI_umin])\n #define umax_optab (optab_table[OTI_umax])\n+#define pow_optab (optab_table[OTI_pow])\n+#define atan2_optab (optab_table[OTI_atan2])\n \n #define mov_optab (optab_table[OTI_mov])\n #define movstrict_optab (optab_table[OTI_movstrict])"}]}