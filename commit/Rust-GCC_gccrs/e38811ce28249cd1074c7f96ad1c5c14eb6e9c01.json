{"sha": "e38811ce28249cd1074c7f96ad1c5c14eb6e9c01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM4ODExY2UyODI0OWNkMTA3NGM3Zjk2YWQxYzVjMTRlYjZlOWMwMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-04-28T09:08:42Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-04-28T09:08:42Z"}, "message": "tree-ssa-structalias.c (find_func_aliases_for_builtin_call): New function split out from ...\n\n2011-04-28  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c (find_func_aliases_for_builtin_call):\n\tNew function split out from ...\n\t(find_func_aliases): ... here.  Call it.\n\t(find_func_aliases_for_call): Likewise.\n\nFrom-SVN: r173060", "tree": {"sha": "627ed259ad17e9e5abbb80a5a9c55e5ca285d7ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/627ed259ad17e9e5abbb80a5a9c55e5ca285d7ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e38811ce28249cd1074c7f96ad1c5c14eb6e9c01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38811ce28249cd1074c7f96ad1c5c14eb6e9c01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e38811ce28249cd1074c7f96ad1c5c14eb6e9c01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38811ce28249cd1074c7f96ad1c5c14eb6e9c01/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a300121e62712fdafb2b508f8a392cffccf075c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a300121e62712fdafb2b508f8a392cffccf075c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a300121e62712fdafb2b508f8a392cffccf075c8"}], "stats": {"total": 674, "additions": 356, "deletions": 318}, "files": [{"sha": "7c74bba013df4e3014b9492e4596ba5585742491", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38811ce28249cd1074c7f96ad1c5c14eb6e9c01/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38811ce28249cd1074c7f96ad1c5c14eb6e9c01/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e38811ce28249cd1074c7f96ad1c5c14eb6e9c01", "patch": "@@ -1,3 +1,10 @@\n+2011-04-28  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c (find_func_aliases_for_builtin_call):\n+\tNew function split out from ...\n+\t(find_func_aliases): ... here.  Call it.\n+\t(find_func_aliases_for_call): Likewise.\n+\n 2011-04-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* internal-fn.h (internal_fn_name_array): Declare."}, {"sha": "6dc0a2c8596e106a53c373467ec34e0a9246fe2f", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 349, "deletions": 318, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38811ce28249cd1074c7f96ad1c5c14eb6e9c01/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38811ce28249cd1074c7f96ad1c5c14eb6e9c01/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=e38811ce28249cd1074c7f96ad1c5c14eb6e9c01", "patch": "@@ -3959,375 +3959,406 @@ get_fi_for_callee (gimple call)\n     gcc_unreachable ();\n }\n \n-/* Walk statement T setting up aliasing constraints according to the\n-   references found in T.  This function is the main part of the\n-   constraint builder.  AI points to auxiliary alias information used\n-   when building alias sets and computing alias grouping heuristics.  */\n+/* Create constraints for the builtin call T.  Return true if the call\n+   was handled, otherwise false.  */\n \n-static void\n-find_func_aliases (gimple origt)\n+static bool\n+find_func_aliases_for_builtin_call (gimple t)\n {\n-  gimple t = origt;\n+  tree fndecl = gimple_call_fndecl (t);\n   VEC(ce_s, heap) *lhsc = NULL;\n   VEC(ce_s, heap) *rhsc = NULL;\n-  struct constraint_expr *c;\n   varinfo_t fi;\n \n-  /* Now build constraints expressions.  */\n-  if (gimple_code (t) == GIMPLE_PHI)\n-    {\n-      size_t i;\n-      unsigned int j;\n-\n-      /* For a phi node, assign all the arguments to\n-\t the result.  */\n-      get_constraint_for (gimple_phi_result (t), &lhsc);\n-      for (i = 0; i < gimple_phi_num_args (t); i++)\n+  if (fndecl != NULL_TREE\n+      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+    /* ???  All builtins that are handled here need to be handled\n+       in the alias-oracle query functions explicitly!  */\n+    switch (DECL_FUNCTION_CODE (fndecl))\n+      {\n+      /* All the following functions return a pointer to the same object\n+\t as their first argument points to.  The functions do not add\n+\t to the ESCAPED solution.  The functions make the first argument\n+\t pointed to memory point to what the second argument pointed to\n+\t memory points to.  */\n+      case BUILT_IN_STRCPY:\n+      case BUILT_IN_STRNCPY:\n+      case BUILT_IN_BCOPY:\n+      case BUILT_IN_MEMCPY:\n+      case BUILT_IN_MEMMOVE:\n+      case BUILT_IN_MEMPCPY:\n+      case BUILT_IN_STPCPY:\n+      case BUILT_IN_STPNCPY:\n+      case BUILT_IN_STRCAT:\n+      case BUILT_IN_STRNCAT:\n \t{\n-\t  tree strippedrhs = PHI_ARG_DEF (t, i);\n-\n-\t  STRIP_NOPS (strippedrhs);\n-\t  get_constraint_for_rhs (gimple_phi_arg_def (t, i), &rhsc);\n-\n-\t  FOR_EACH_VEC_ELT (ce_s, lhsc, j, c)\n+\t  tree res = gimple_call_lhs (t);\n+\t  tree dest = gimple_call_arg (t, (DECL_FUNCTION_CODE (fndecl)\n+\t\t\t\t\t   == BUILT_IN_BCOPY ? 1 : 0));\n+\t  tree src = gimple_call_arg (t, (DECL_FUNCTION_CODE (fndecl)\n+\t\t\t\t\t  == BUILT_IN_BCOPY ? 0 : 1));\n+\t  if (res != NULL_TREE)\n \t    {\n-\t      struct constraint_expr *c2;\n-\t      while (VEC_length (ce_s, rhsc) > 0)\n-\t\t{\n-\t\t  c2 = VEC_last (ce_s, rhsc);\n-\t\t  process_constraint (new_constraint (*c, *c2));\n-\t\t  VEC_pop (ce_s, rhsc);\n-\t\t}\n+\t      get_constraint_for (res, &lhsc);\n+\t      if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_MEMPCPY\n+\t\t  || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STPCPY\n+\t\t  || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STPNCPY)\n+\t\tget_constraint_for_ptr_offset (dest, NULL_TREE, &rhsc);\n+\t      else\n+\t\tget_constraint_for (dest, &rhsc);\n+\t      process_all_all_constraints (lhsc, rhsc);\n+\t      VEC_free (ce_s, heap, lhsc);\n+\t      VEC_free (ce_s, heap, rhsc);\n \t    }\n+\t  get_constraint_for_ptr_offset (dest, NULL_TREE, &lhsc);\n+\t  get_constraint_for_ptr_offset (src, NULL_TREE, &rhsc);\n+\t  do_deref (&lhsc);\n+\t  do_deref (&rhsc);\n+\t  process_all_all_constraints (lhsc, rhsc);\n+\t  VEC_free (ce_s, heap, lhsc);\n+\t  VEC_free (ce_s, heap, rhsc);\n+\t  return true;\n \t}\n-    }\n-  /* In IPA mode, we need to generate constraints to pass call\n-     arguments through their calls.   There are two cases,\n-     either a GIMPLE_CALL returning a value, or just a plain\n-     GIMPLE_CALL when we are not.\n-\n-     In non-ipa mode, we need to generate constraints for each\n-     pointer passed by address.  */\n-  else if (is_gimple_call (t))\n-    {\n-      tree fndecl = gimple_call_fndecl (t);\n-      if (fndecl != NULL_TREE\n-\t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n-\t/* ???  All builtins that are handled here need to be handled\n-\t   in the alias-oracle query functions explicitly!  */\n-\tswitch (DECL_FUNCTION_CODE (fndecl))\n-\t  {\n-\t  /* All the following functions return a pointer to the same object\n-\t     as their first argument points to.  The functions do not add\n-\t     to the ESCAPED solution.  The functions make the first argument\n-\t     pointed to memory point to what the second argument pointed to\n-\t     memory points to.  */\n-\t  case BUILT_IN_STRCPY:\n-\t  case BUILT_IN_STRNCPY:\n-\t  case BUILT_IN_BCOPY:\n-\t  case BUILT_IN_MEMCPY:\n-\t  case BUILT_IN_MEMMOVE:\n-\t  case BUILT_IN_MEMPCPY:\n-\t  case BUILT_IN_STPCPY:\n-\t  case BUILT_IN_STPNCPY:\n-\t  case BUILT_IN_STRCAT:\n-\t  case BUILT_IN_STRNCAT:\n+      case BUILT_IN_MEMSET:\n+\t{\n+\t  tree res = gimple_call_lhs (t);\n+\t  tree dest = gimple_call_arg (t, 0);\n+\t  unsigned i;\n+\t  ce_s *lhsp;\n+\t  struct constraint_expr ac;\n+\t  if (res != NULL_TREE)\n \t    {\n-\t      tree res = gimple_call_lhs (t);\n-\t      tree dest = gimple_call_arg (t, (DECL_FUNCTION_CODE (fndecl)\n-\t\t\t\t\t       == BUILT_IN_BCOPY ? 1 : 0));\n-\t      tree src = gimple_call_arg (t, (DECL_FUNCTION_CODE (fndecl)\n-\t\t\t\t\t      == BUILT_IN_BCOPY ? 0 : 1));\n-\t      if (res != NULL_TREE)\n-\t\t{\n-\t\t  get_constraint_for (res, &lhsc);\n-\t\t  if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_MEMPCPY\n-\t\t      || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STPCPY\n-\t\t      || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STPNCPY)\n-\t\t    get_constraint_for_ptr_offset (dest, NULL_TREE, &rhsc);\n-\t\t  else\n-\t\t    get_constraint_for (dest, &rhsc);\n-\t\t  process_all_all_constraints (lhsc, rhsc);\n-\t\t  VEC_free (ce_s, heap, lhsc);\n-\t\t  VEC_free (ce_s, heap, rhsc);\n-\t\t}\n-\t      get_constraint_for_ptr_offset (dest, NULL_TREE, &lhsc);\n-\t      get_constraint_for_ptr_offset (src, NULL_TREE, &rhsc);\n-\t      do_deref (&lhsc);\n-\t      do_deref (&rhsc);\n+\t      get_constraint_for (res, &lhsc);\n+\t      get_constraint_for (dest, &rhsc);\n \t      process_all_all_constraints (lhsc, rhsc);\n \t      VEC_free (ce_s, heap, lhsc);\n \t      VEC_free (ce_s, heap, rhsc);\n-\t      return;\n \t    }\n-\t  case BUILT_IN_MEMSET:\n+\t  get_constraint_for_ptr_offset (dest, NULL_TREE, &lhsc);\n+\t  do_deref (&lhsc);\n+\t  if (flag_delete_null_pointer_checks\n+\t      && integer_zerop (gimple_call_arg (t, 1)))\n \t    {\n-\t      tree res = gimple_call_lhs (t);\n-\t      tree dest = gimple_call_arg (t, 0);\n-\t      unsigned i;\n-\t      ce_s *lhsp;\n-\t      struct constraint_expr ac;\n-\t      if (res != NULL_TREE)\n-\t\t{\n-\t\t  get_constraint_for (res, &lhsc);\n-\t\t  get_constraint_for (dest, &rhsc);\n-\t\t  process_all_all_constraints (lhsc, rhsc);\n-\t\t  VEC_free (ce_s, heap, lhsc);\n-\t\t  VEC_free (ce_s, heap, rhsc);\n-\t\t}\n-\t      get_constraint_for_ptr_offset (dest, NULL_TREE, &lhsc);\n-\t      do_deref (&lhsc);\n-\t      if (flag_delete_null_pointer_checks\n-\t\t  && integer_zerop (gimple_call_arg (t, 1)))\n-\t\t{\n-\t\t  ac.type = ADDRESSOF;\n-\t\t  ac.var = nothing_id;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  ac.type = SCALAR;\n-\t\t  ac.var = integer_id;\n-\t\t}\n-\t      ac.offset = 0;\n-\t      FOR_EACH_VEC_ELT (ce_s, lhsc, i, lhsp)\n-\t\tprocess_constraint (new_constraint (*lhsp, ac));\n-\t      VEC_free (ce_s, heap, lhsc);\n-\t      return;\n+\t      ac.type = ADDRESSOF;\n+\t      ac.var = nothing_id;\n \t    }\n-\t  /* All the following functions do not return pointers, do not\n-\t     modify the points-to sets of memory reachable from their\n-\t     arguments and do not add to the ESCAPED solution.  */\n-\t  case BUILT_IN_SINCOS:\n-\t  case BUILT_IN_SINCOSF:\n-\t  case BUILT_IN_SINCOSL:\n-\t  case BUILT_IN_FREXP:\n-\t  case BUILT_IN_FREXPF:\n-\t  case BUILT_IN_FREXPL:\n-\t  case BUILT_IN_GAMMA_R:\n-\t  case BUILT_IN_GAMMAF_R:\n-\t  case BUILT_IN_GAMMAL_R:\n-\t  case BUILT_IN_LGAMMA_R:\n-\t  case BUILT_IN_LGAMMAF_R:\n-\t  case BUILT_IN_LGAMMAL_R:\n-\t  case BUILT_IN_MODF:\n-\t  case BUILT_IN_MODFF:\n-\t  case BUILT_IN_MODFL:\n-\t  case BUILT_IN_REMQUO:\n-\t  case BUILT_IN_REMQUOF:\n-\t  case BUILT_IN_REMQUOL:\n-\t  case BUILT_IN_FREE:\n-\t    return;\n-\t  /* Trampolines are special - they set up passing the static\n-\t     frame.  */\n-\t  case BUILT_IN_INIT_TRAMPOLINE:\n+\t  else\n \t    {\n-\t      tree tramp = gimple_call_arg (t, 0);\n-\t      tree nfunc = gimple_call_arg (t, 1);\n-\t      tree frame = gimple_call_arg (t, 2);\n-\t      unsigned i;\n-\t      struct constraint_expr lhs, *rhsp;\n-\t      if (in_ipa_mode)\n-\t\t{\n-\t\t  varinfo_t nfi = NULL;\n-\t\t  gcc_assert (TREE_CODE (nfunc) == ADDR_EXPR);\n-\t\t  nfi = lookup_vi_for_tree (TREE_OPERAND (nfunc, 0));\n-\t\t  if (nfi)\n-\t\t    {\n-\t\t      lhs = get_function_part_constraint (nfi, fi_static_chain);\n-\t\t      get_constraint_for (frame, &rhsc);\n-\t\t      FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n-\t\t\tprocess_constraint (new_constraint (lhs, *rhsp));\n-\t\t      VEC_free (ce_s, heap, rhsc);\n-\n-\t\t      /* Make the frame point to the function for\n-\t\t\t the trampoline adjustment call.  */\n-\t\t      get_constraint_for (tramp, &lhsc);\n-\t\t      do_deref (&lhsc);\n-\t\t      get_constraint_for (nfunc, &rhsc);\n-\t\t      process_all_all_constraints (lhsc, rhsc);\n-\t\t      VEC_free (ce_s, heap, rhsc);\n-\t\t      VEC_free (ce_s, heap, lhsc);\n-\n-\t\t      return;\n-\t\t    }\n-\t\t}\n-\t      /* Else fallthru to generic handling which will let\n-\t         the frame escape.  */\n-\t      break;\n+\t      ac.type = SCALAR;\n+\t      ac.var = integer_id;\n \t    }\n-\t  case BUILT_IN_ADJUST_TRAMPOLINE:\n+\t  ac.offset = 0;\n+\t  FOR_EACH_VEC_ELT (ce_s, lhsc, i, lhsp)\n+\t      process_constraint (new_constraint (*lhsp, ac));\n+\t  VEC_free (ce_s, heap, lhsc);\n+\t  return true;\n+\t}\n+      /* All the following functions do not return pointers, do not\n+\t modify the points-to sets of memory reachable from their\n+\t arguments and do not add to the ESCAPED solution.  */\n+      case BUILT_IN_SINCOS:\n+      case BUILT_IN_SINCOSF:\n+      case BUILT_IN_SINCOSL:\n+      case BUILT_IN_FREXP:\n+      case BUILT_IN_FREXPF:\n+      case BUILT_IN_FREXPL:\n+      case BUILT_IN_GAMMA_R:\n+      case BUILT_IN_GAMMAF_R:\n+      case BUILT_IN_GAMMAL_R:\n+      case BUILT_IN_LGAMMA_R:\n+      case BUILT_IN_LGAMMAF_R:\n+      case BUILT_IN_LGAMMAL_R:\n+      case BUILT_IN_MODF:\n+      case BUILT_IN_MODFF:\n+      case BUILT_IN_MODFL:\n+      case BUILT_IN_REMQUO:\n+      case BUILT_IN_REMQUOF:\n+      case BUILT_IN_REMQUOL:\n+      case BUILT_IN_FREE:\n+\treturn true;\n+      /* Trampolines are special - they set up passing the static\n+\t frame.  */\n+      case BUILT_IN_INIT_TRAMPOLINE:\n+\t{\n+\t  tree tramp = gimple_call_arg (t, 0);\n+\t  tree nfunc = gimple_call_arg (t, 1);\n+\t  tree frame = gimple_call_arg (t, 2);\n+\t  unsigned i;\n+\t  struct constraint_expr lhs, *rhsp;\n+\t  if (in_ipa_mode)\n \t    {\n-\t      tree tramp = gimple_call_arg (t, 0);\n-\t      tree res = gimple_call_lhs (t);\n-\t      if (in_ipa_mode && res)\n+\t      varinfo_t nfi = NULL;\n+\t      gcc_assert (TREE_CODE (nfunc) == ADDR_EXPR);\n+\t      nfi = lookup_vi_for_tree (TREE_OPERAND (nfunc, 0));\n+\t      if (nfi)\n \t\t{\n-\t\t  get_constraint_for (res, &lhsc);\n-\t\t  get_constraint_for (tramp, &rhsc);\n-\t\t  do_deref (&rhsc);\n+\t\t  lhs = get_function_part_constraint (nfi, fi_static_chain);\n+\t\t  get_constraint_for (frame, &rhsc);\n+\t\t  FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n+\t\t      process_constraint (new_constraint (lhs, *rhsp));\n+\t\t  VEC_free (ce_s, heap, rhsc);\n+\n+\t\t  /* Make the frame point to the function for\n+\t\t     the trampoline adjustment call.  */\n+\t\t  get_constraint_for (tramp, &lhsc);\n+\t\t  do_deref (&lhsc);\n+\t\t  get_constraint_for (nfunc, &rhsc);\n \t\t  process_all_all_constraints (lhsc, rhsc);\n \t\t  VEC_free (ce_s, heap, rhsc);\n \t\t  VEC_free (ce_s, heap, lhsc);\n+\n+\t\t  return true;\n \t\t}\n-\t      return;\n \t    }\n-\t  /* Variadic argument handling needs to be handled in IPA\n-\t     mode as well.  */\n-\t  case BUILT_IN_VA_START:\n+\t  /* Else fallthru to generic handling which will let\n+\t     the frame escape.  */\n+\t  break;\n+\t}\n+      case BUILT_IN_ADJUST_TRAMPOLINE:\n+\t{\n+\t  tree tramp = gimple_call_arg (t, 0);\n+\t  tree res = gimple_call_lhs (t);\n+\t  if (in_ipa_mode && res)\n \t    {\n-\t      if (in_ipa_mode)\n-\t\t{\n-\t\t  tree valist = gimple_call_arg (t, 0);\n-\t\t  struct constraint_expr rhs, *lhsp;\n-\t\t  unsigned i;\n-\t\t  /* The va_list gets access to pointers in variadic\n-\t\t     arguments.  */\n-\t\t  fi = lookup_vi_for_tree (cfun->decl);\n-\t\t  gcc_assert (fi != NULL);\n-\t\t  get_constraint_for (valist, &lhsc);\n-\t\t  do_deref (&lhsc);\n-\t\t  rhs = get_function_part_constraint (fi, ~0);\n-\t\t  rhs.type = ADDRESSOF;\n-\t\t  FOR_EACH_VEC_ELT (ce_s, lhsc, i, lhsp)\n-\t\t    process_constraint (new_constraint (*lhsp, rhs));\n-\t\t  VEC_free (ce_s, heap, lhsc);\n-\t\t  /* va_list is clobbered.  */\n-\t\t  make_constraint_to (get_call_clobber_vi (t)->id, valist);\n-\t\t  return;\n-\t\t}\n-\t      break;\n+\t      get_constraint_for (res, &lhsc);\n+\t      get_constraint_for (tramp, &rhsc);\n+\t      do_deref (&rhsc);\n+\t      process_all_all_constraints (lhsc, rhsc);\n+\t      VEC_free (ce_s, heap, rhsc);\n+\t      VEC_free (ce_s, heap, lhsc);\n \t    }\n-\t  /* va_end doesn't have any effect that matters.  */\n-\t  case BUILT_IN_VA_END:\n-\t    return;\n-\t  /* Alternate return.  Simply give up for now.  */\n-\t  case BUILT_IN_RETURN:\n+\t  return true;\n+\t}\n+      /* Variadic argument handling needs to be handled in IPA\n+\t mode as well.  */\n+      case BUILT_IN_VA_START:\n+\t{\n+\t  if (in_ipa_mode)\n \t    {\n-\t      fi = NULL;\n-\t      if (!in_ipa_mode\n-\t\t  || !(fi = get_vi_for_tree (cfun->decl)))\n-\t\tmake_constraint_from (get_varinfo (escaped_id), anything_id);\n-\t      else if (in_ipa_mode\n-\t\t       && fi != NULL)\n-\t\t{\n-\t\t  struct constraint_expr lhs, rhs;\n-\t\t  lhs = get_function_part_constraint (fi, fi_result);\n-\t\t  rhs.var = anything_id;\n-\t\t  rhs.offset = 0;\n-\t\t  rhs.type = SCALAR;\n-\t\t  process_constraint (new_constraint (lhs, rhs));\n-\t\t}\n-\t      return;\n+\t      tree valist = gimple_call_arg (t, 0);\n+\t      struct constraint_expr rhs, *lhsp;\n+\t      unsigned i;\n+\t      /* The va_list gets access to pointers in variadic\n+\t\t arguments.  */\n+\t      fi = lookup_vi_for_tree (cfun->decl);\n+\t      gcc_assert (fi != NULL);\n+\t      get_constraint_for (valist, &lhsc);\n+\t      do_deref (&lhsc);\n+\t      rhs = get_function_part_constraint (fi, ~0);\n+\t      rhs.type = ADDRESSOF;\n+\t      FOR_EACH_VEC_ELT (ce_s, lhsc, i, lhsp)\n+\t\t  process_constraint (new_constraint (*lhsp, rhs));\n+\t      VEC_free (ce_s, heap, lhsc);\n+\t      /* va_list is clobbered.  */\n+\t      make_constraint_to (get_call_clobber_vi (t)->id, valist);\n+\t      return true;\n \t    }\n-\t  /* printf-style functions may have hooks to set pointers to\n-\t     point to somewhere into the generated string.  Leave them\n-\t     for a later excercise...  */\n-\t  default:\n-\t    /* Fallthru to general call handling.  */;\n-\t  }\n-      if (!in_ipa_mode\n-\t  || gimple_call_internal_p (t)\n-\t  || (fndecl\n-\t      && (!(fi = lookup_vi_for_tree (fndecl))\n-\t\t  || !fi->is_fn_info)))\n+\t  break;\n+\t}\n+      /* va_end doesn't have any effect that matters.  */\n+      case BUILT_IN_VA_END:\n+\treturn true;\n+      /* Alternate return.  Simply give up for now.  */\n+      case BUILT_IN_RETURN:\n \t{\n-\t  VEC(ce_s, heap) *rhsc = NULL;\n-\t  int flags = gimple_call_flags (t);\n-\n-\t  /* Const functions can return their arguments and addresses\n-\t     of global memory but not of escaped memory.  */\n-\t  if (flags & (ECF_CONST|ECF_NOVOPS))\n+\t  fi = NULL;\n+\t  if (!in_ipa_mode\n+\t      || !(fi = get_vi_for_tree (cfun->decl)))\n+\t    make_constraint_from (get_varinfo (escaped_id), anything_id);\n+\t  else if (in_ipa_mode\n+\t\t   && fi != NULL)\n \t    {\n-\t      if (gimple_call_lhs (t))\n-\t\thandle_const_call (t, &rhsc);\n+\t      struct constraint_expr lhs, rhs;\n+\t      lhs = get_function_part_constraint (fi, fi_result);\n+\t      rhs.var = anything_id;\n+\t      rhs.offset = 0;\n+\t      rhs.type = SCALAR;\n+\t      process_constraint (new_constraint (lhs, rhs));\n \t    }\n-\t  /* Pure functions can return addresses in and of memory\n-\t     reachable from their arguments, but they are not an escape\n-\t     point for reachable memory of their arguments.  */\n-\t  else if (flags & (ECF_PURE|ECF_LOOPING_CONST_OR_PURE))\n-\t    handle_pure_call (t, &rhsc);\n-\t  else\n-\t    handle_rhs_call (t, &rhsc);\n+\t  return true;\n+\t}\n+      /* printf-style functions may have hooks to set pointers to\n+\t point to somewhere into the generated string.  Leave them\n+\t for a later excercise...  */\n+      default:\n+\t/* Fallthru to general call handling.  */;\n+      }\n+\n+  return false;\n+}\n+\n+/* Create constraints for the call T.  */\n+\n+static void\n+find_func_aliases_for_call (gimple t)\n+{\n+  tree fndecl = gimple_call_fndecl (t);\n+  VEC(ce_s, heap) *lhsc = NULL;\n+  VEC(ce_s, heap) *rhsc = NULL;\n+  varinfo_t fi;\n+\n+  if (fndecl != NULL_TREE\n+      && DECL_BUILT_IN (fndecl)\n+      && find_func_aliases_for_builtin_call (t))\n+    return;\n+\n+  if (!in_ipa_mode\n+      || gimple_call_internal_p (t)\n+      || (fndecl\n+\t  && (!(fi = lookup_vi_for_tree (fndecl))\n+\t      || !fi->is_fn_info)))\n+    {\n+      VEC(ce_s, heap) *rhsc = NULL;\n+      int flags = gimple_call_flags (t);\n+\n+      /* Const functions can return their arguments and addresses\n+\t of global memory but not of escaped memory.  */\n+      if (flags & (ECF_CONST|ECF_NOVOPS))\n+\t{\n \t  if (gimple_call_lhs (t))\n-\t    handle_lhs_call (t, gimple_call_lhs (t), flags, rhsc, fndecl);\n-\t  VEC_free (ce_s, heap, rhsc);\n+\t    handle_const_call (t, &rhsc);\n \t}\n+      /* Pure functions can return addresses in and of memory\n+\t reachable from their arguments, but they are not an escape\n+\t point for reachable memory of their arguments.  */\n+      else if (flags & (ECF_PURE|ECF_LOOPING_CONST_OR_PURE))\n+\thandle_pure_call (t, &rhsc);\n       else\n-\t{\n-\t  tree lhsop;\n-\t  unsigned j;\n+\thandle_rhs_call (t, &rhsc);\n+      if (gimple_call_lhs (t))\n+\thandle_lhs_call (t, gimple_call_lhs (t), flags, rhsc, fndecl);\n+      VEC_free (ce_s, heap, rhsc);\n+    }\n+  else\n+    {\n+      tree lhsop;\n+      unsigned j;\n \n-\t  fi = get_fi_for_callee (t);\n+      fi = get_fi_for_callee (t);\n \n-\t  /* Assign all the passed arguments to the appropriate incoming\n-\t     parameters of the function.  */\n-\t  for (j = 0; j < gimple_call_num_args (t); j++)\n-\t    {\n-\t      struct constraint_expr lhs ;\n-\t      struct constraint_expr *rhsp;\n-\t      tree arg = gimple_call_arg (t, j);\n-\n-\t      get_constraint_for_rhs (arg, &rhsc);\n-\t      lhs = get_function_part_constraint (fi, fi_parm_base + j);\n-\t      while (VEC_length (ce_s, rhsc) != 0)\n-\t\t{\n-\t\t  rhsp = VEC_last (ce_s, rhsc);\n-\t\t  process_constraint (new_constraint (lhs, *rhsp));\n-\t\t  VEC_pop (ce_s, rhsc);\n-\t\t}\n-\t    }\n+      /* Assign all the passed arguments to the appropriate incoming\n+\t parameters of the function.  */\n+      for (j = 0; j < gimple_call_num_args (t); j++)\n+\t{\n+\t  struct constraint_expr lhs ;\n+\t  struct constraint_expr *rhsp;\n+\t  tree arg = gimple_call_arg (t, j);\n \n-\t  /* If we are returning a value, assign it to the result.  */\n-\t  lhsop = gimple_call_lhs (t);\n-\t  if (lhsop)\n+\t  get_constraint_for_rhs (arg, &rhsc);\n+\t  lhs = get_function_part_constraint (fi, fi_parm_base + j);\n+\t  while (VEC_length (ce_s, rhsc) != 0)\n \t    {\n-\t      struct constraint_expr rhs;\n-\t      struct constraint_expr *lhsp;\n-\n-\t      get_constraint_for (lhsop, &lhsc);\n-\t      rhs = get_function_part_constraint (fi, fi_result);\n-\t      if (fndecl\n-\t\t  && DECL_RESULT (fndecl)\n-\t\t  && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))\n-\t\t{\n-\t\t  VEC(ce_s, heap) *tem = NULL;\n-\t\t  VEC_safe_push (ce_s, heap, tem, &rhs);\n-\t\t  do_deref (&tem);\n-\t\t  rhs = *VEC_index (ce_s, tem, 0);\n-\t\t  VEC_free(ce_s, heap, tem);\n-\t\t}\n-\t      FOR_EACH_VEC_ELT (ce_s, lhsc, j, lhsp)\n-\t\tprocess_constraint (new_constraint (*lhsp, rhs));\n+\t      rhsp = VEC_last (ce_s, rhsc);\n+\t      process_constraint (new_constraint (lhs, *rhsp));\n+\t      VEC_pop (ce_s, rhsc);\n \t    }\n+\t}\n \n-\t  /* If we pass the result decl by reference, honor that.  */\n-\t  if (lhsop\n-\t      && fndecl\n+      /* If we are returning a value, assign it to the result.  */\n+      lhsop = gimple_call_lhs (t);\n+      if (lhsop)\n+\t{\n+\t  struct constraint_expr rhs;\n+\t  struct constraint_expr *lhsp;\n+\n+\t  get_constraint_for (lhsop, &lhsc);\n+\t  rhs = get_function_part_constraint (fi, fi_result);\n+\t  if (fndecl\n \t      && DECL_RESULT (fndecl)\n \t      && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))\n \t    {\n-\t      struct constraint_expr lhs;\n-\t      struct constraint_expr *rhsp;\n-\n-\t      get_constraint_for_address_of (lhsop, &rhsc);\n-\t      lhs = get_function_part_constraint (fi, fi_result);\n-\t      FOR_EACH_VEC_ELT (ce_s, rhsc, j, rhsp)\n-\t\tprocess_constraint (new_constraint (lhs, *rhsp));\n-\t      VEC_free (ce_s, heap, rhsc);\n+\t      VEC(ce_s, heap) *tem = NULL;\n+\t      VEC_safe_push (ce_s, heap, tem, &rhs);\n+\t      do_deref (&tem);\n+\t      rhs = *VEC_index (ce_s, tem, 0);\n+\t      VEC_free(ce_s, heap, tem);\n \t    }\n+\t  FOR_EACH_VEC_ELT (ce_s, lhsc, j, lhsp)\n+\t      process_constraint (new_constraint (*lhsp, rhs));\n+\t}\n \n-\t  /* If we use a static chain, pass it along.  */\n-\t  if (gimple_call_chain (t))\n-\t    {\n-\t      struct constraint_expr lhs;\n-\t      struct constraint_expr *rhsp;\n+      /* If we pass the result decl by reference, honor that.  */\n+      if (lhsop\n+\t  && fndecl\n+\t  && DECL_RESULT (fndecl)\n+\t  && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))\n+\t{\n+\t  struct constraint_expr lhs;\n+\t  struct constraint_expr *rhsp;\n \n-\t      get_constraint_for (gimple_call_chain (t), &rhsc);\n-\t      lhs = get_function_part_constraint (fi, fi_static_chain);\n-\t      FOR_EACH_VEC_ELT (ce_s, rhsc, j, rhsp)\n-\t\tprocess_constraint (new_constraint (lhs, *rhsp));\n+\t  get_constraint_for_address_of (lhsop, &rhsc);\n+\t  lhs = get_function_part_constraint (fi, fi_result);\n+\t  FOR_EACH_VEC_ELT (ce_s, rhsc, j, rhsp)\n+\t      process_constraint (new_constraint (lhs, *rhsp));\n+\t  VEC_free (ce_s, heap, rhsc);\n+\t}\n+\n+      /* If we use a static chain, pass it along.  */\n+      if (gimple_call_chain (t))\n+\t{\n+\t  struct constraint_expr lhs;\n+\t  struct constraint_expr *rhsp;\n+\n+\t  get_constraint_for (gimple_call_chain (t), &rhsc);\n+\t  lhs = get_function_part_constraint (fi, fi_static_chain);\n+\t  FOR_EACH_VEC_ELT (ce_s, rhsc, j, rhsp)\n+\t      process_constraint (new_constraint (lhs, *rhsp));\n+\t}\n+    }\n+}\n+\n+/* Walk statement T setting up aliasing constraints according to the\n+   references found in T.  This function is the main part of the\n+   constraint builder.  AI points to auxiliary alias information used\n+   when building alias sets and computing alias grouping heuristics.  */\n+\n+static void\n+find_func_aliases (gimple origt)\n+{\n+  gimple t = origt;\n+  VEC(ce_s, heap) *lhsc = NULL;\n+  VEC(ce_s, heap) *rhsc = NULL;\n+  struct constraint_expr *c;\n+  varinfo_t fi;\n+\n+  /* Now build constraints expressions.  */\n+  if (gimple_code (t) == GIMPLE_PHI)\n+    {\n+      size_t i;\n+      unsigned int j;\n+\n+      /* For a phi node, assign all the arguments to\n+\t the result.  */\n+      get_constraint_for (gimple_phi_result (t), &lhsc);\n+      for (i = 0; i < gimple_phi_num_args (t); i++)\n+\t{\n+\t  tree strippedrhs = PHI_ARG_DEF (t, i);\n+\n+\t  STRIP_NOPS (strippedrhs);\n+\t  get_constraint_for_rhs (gimple_phi_arg_def (t, i), &rhsc);\n+\n+\t  FOR_EACH_VEC_ELT (ce_s, lhsc, j, c)\n+\t    {\n+\t      struct constraint_expr *c2;\n+\t      while (VEC_length (ce_s, rhsc) > 0)\n+\t\t{\n+\t\t  c2 = VEC_last (ce_s, rhsc);\n+\t\t  process_constraint (new_constraint (*c, *c2));\n+\t\t  VEC_pop (ce_s, rhsc);\n+\t\t}\n \t    }\n \t}\n     }\n+  /* In IPA mode, we need to generate constraints to pass call\n+     arguments through their calls.   There are two cases,\n+     either a GIMPLE_CALL returning a value, or just a plain\n+     GIMPLE_CALL when we are not.\n+\n+     In non-ipa mode, we need to generate constraints for each\n+     pointer passed by address.  */\n+  else if (is_gimple_call (t))\n+    find_func_aliases_for_call (t);\n+    \n   /* Otherwise, just a regular assignment statement.  Only care about\n      operations with pointer result, others are dealt with as escape\n      points if they have pointer operands.  */"}]}