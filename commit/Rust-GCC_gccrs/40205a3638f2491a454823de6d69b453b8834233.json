{"sha": "40205a3638f2491a454823de6d69b453b8834233", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAyMDVhMzYzOGYyNDkxYTQ1NDgyM2RlNmQ2OWI0NTNiODgzNDIzMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2005-02-23T09:00:22Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-02-23T09:00:22Z"}, "message": "re PR ada/19902 (ACATS cxa3004 cxb3006 fail at compile time \"ambiguous expression\")\n\n\tPR ada/19902\n\t* ada/acats/tests/cxa/cxa3004.a: Remove.\n\t* ada/acats/tests/cxb/cxb30061.am: Likewise.\n\nFrom-SVN: r95446", "tree": {"sha": "ef410a9d9c792ab1bd1d410658ba630c42194c44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef410a9d9c792ab1bd1d410658ba630c42194c44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40205a3638f2491a454823de6d69b453b8834233", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40205a3638f2491a454823de6d69b453b8834233", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40205a3638f2491a454823de6d69b453b8834233", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40205a3638f2491a454823de6d69b453b8834233/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1144f8d5ca6ef0a7e563809249a374648802ed85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1144f8d5ca6ef0a7e563809249a374648802ed85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1144f8d5ca6ef0a7e563809249a374648802ed85"}], "stats": {"total": 645, "additions": 6, "deletions": 639}, "files": [{"sha": "108bea59b684b895b2c442af52e1199d40369a83", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40205a3638f2491a454823de6d69b453b8834233/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40205a3638f2491a454823de6d69b453b8834233/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=40205a3638f2491a454823de6d69b453b8834233", "patch": "@@ -1,3 +1,9 @@\n+2005-02-23  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR ada/19902\n+\t* ada/acats/tests/cxa/cxa3004.a: Remove.\n+\t* ada/acats/tests/cxb/cxb30061.am: Likewise.\n+\n 2005-02-22  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/20073"}, {"sha": "ed2023e37e535162ca12bf102c87339549698e55", "filename": "gcc/testsuite/ada/acats/tests/cxa/cxa3004.a", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1144f8d5ca6ef0a7e563809249a374648802ed85/gcc%2Ftestsuite%2Fada%2Facats%2Ftests%2Fcxa%2Fcxa3004.a", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1144f8d5ca6ef0a7e563809249a374648802ed85/gcc%2Ftestsuite%2Fada%2Facats%2Ftests%2Fcxa%2Fcxa3004.a", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fada%2Facats%2Ftests%2Fcxa%2Fcxa3004.a?ref=1144f8d5ca6ef0a7e563809249a374648802ed85", "patch": "@@ -1,235 +0,0 @@\n--- CXA3004.A\n---\n---                             Grant of Unlimited Rights\n---\n---     Under contracts F33600-87-D-0337, F33600-84-D-0280, MDA903-79-C-0687,\n---     F08630-91-C-0015, and DCA100-97-D-0025, the U.S. Government obtained \n---     unlimited rights in the software and documentation contained herein.\n---     Unlimited rights are defined in DFAR 252.227-7013(a)(19).  By making \n---     this public release, the Government intends to confer upon all \n---     recipients unlimited rights  equal to those held by the Government.  \n---     These rights include rights to use, duplicate, release or disclose the \n---     released technical data and computer software in whole or in part, in \n---     any manner and for any purpose whatsoever, and to have or permit others \n---     to do so.\n---\n---                                    DISCLAIMER\n---\n---     ALL MATERIALS OR INFORMATION HEREIN RELEASED, MADE AVAILABLE OR\n---     DISCLOSED ARE AS IS.  THE GOVERNMENT MAKES NO EXPRESS OR IMPLIED \n---     WARRANTY AS TO ANY MATTER WHATSOEVER, INCLUDING THE CONDITIONS OF THE\n---     SOFTWARE, DOCUMENTATION OR OTHER INFORMATION RELEASED, MADE AVAILABLE \n---     OR DISCLOSED, OR THE OWNERSHIP, MERCHANTABILITY, OR FITNESS FOR A\n---     PARTICULAR PURPOSE OF SAID MATERIAL.\n---*\n---\n--- OBJECTIVE:\n---      Check that the functions defined in package Ada.Characters.Handling\n---      for classification of and conversion between Wide_Character and\n---      Character values produce correct results when given the appropriate\n---      Character and String inputs.\n---\n--- TEST DESCRIPTION:\n---      This test demonstrates the functions defined in package \n---      Ada.Characters.Handling which provide for the classification of and \n---      conversion between Wide_Characters and Characters, in character \n---      variables and strings.\n---      Each of the functions is provided with input values that are of the \n---      appropriate range. The results of the function processing are \n---      subsequently evaluated.\n---      \n--- APPLICABILITY CRITERIA: \n---      Applicable to all implementations using the Latin_1 set as the\n---      definition of Character.\n---\n---       \n--- CHANGE HISTORY:\n---      06 Dec 94   SAIC    ACVC 2.0\n---      27 Dec 94   SAIC    Corrected variable names.\n---\n---!\n-\n-with Report;\n-with Ada.Characters.Handling;\n-\n-procedure CXA3004 is\n-begin\n-\n-   Report.Test (\"CXA3004\", \"Check that the functions defined in package \"  &\n-                           \"Ada.Characters.Handling for classification \"   &\n-                           \"of and conversion between Wide_Character and \" &\n-                           \"Character values produce correct results \"     &\n-                           \"when given the appropriate Character \"         &\n-                           \"and String inputs\");\n-\n-   Test_Block:\n-   declare\n-\n-      package ACH renames Ada.Characters.Handling;\n-\n-      Char_End      : Integer        := 255;\n-      WC_Start      : Integer        := 256;\n-      Sub_Char      : Character      := '*';\n-\n-      Blank         : Character      := ' ';\n-      First_Char    : Character      := Character'First;\n-      Last_Char     : Character      := Character'Last;\n-      F_Char        : Character      := 'F';\n-\n-\n-      First_Wide_Char        : Wide_Character := Wide_Character'First;\n-      Last_Non_Wide_Char     : Wide_Character := Wide_Character'Val(Char_End);\n-      First_Unique_Wide_Char : Wide_Character := Wide_Character'Val(WC_Start);\n-      Last_Wide_Char         : Wide_Character := Wide_Character'Last;\n-\n-      A_String      : String (1..3)      := First_Char & 'X' & Last_Char;\n-      A_Wide_String : Wide_String (1..3) := First_Wide_Char            & \n-                                            ACH.To_Wide_Character('X') & \n-                                            ACH.To_Wide_Character(Last_Char);\n-\n-      Unique_Wide_String : Wide_String (1..2) := First_Unique_Wide_Char &\n-                                                 Last_Wide_Char;\n-\n-      Mixed_Wide_String  : Wide_String (1..6) := ACH.To_Wide_Character('A') & \n-                                                 First_Wide_Char            &\n-                                                 Last_Non_Wide_Char         & \n-                                                 First_Unique_Wide_Char     & \n-                                                 Last_Wide_Char             &\n-                                                 ACH.To_Wide_Character('Z');\n-\n-\n-      Basic_Char         : Character          := 'A';\n-      Basic_Wide_Char    : Wide_Character     := 'A';\n-      Basic_String       : String (1..6)      := \"ABCXYZ\";\n-      Basic_Wide_String  : Wide_String (1..6) := \"ABCXYZ\";\n-\n-   begin\n-\n-\n-      -- Function Is_Character\n-\n-\n-      if not ACH.Is_Character(First_Wide_Char) then\n-         Report.Failed (\"Incorrect result from Is_Character - 1\");\n-      end if;\n-\n-\n-      if ACH.Is_Character(First_Unique_Wide_Char) or        \n-         ACH.Is_Character(Last_Wide_Char)\n-      then\n-         Report.Failed (\"Incorrect result from Is_Character - 2\");\n-      end if;\n-       \n-\n-      -- Function Is_String\n-\n-\n-      if not ACH.Is_String(A_Wide_String) then\n-         Report.Failed (\"Incorrect result from Is_String - 1\");\n-      end if;\n-\n-\n-      if ACH.Is_String(Unique_Wide_String) or\n-         ACH.Is_String(Mixed_Wide_String)\n-      then\n-         Report.Failed (\"Incorrect result from Is_String - 2\");\n-      end if;\n-      \n-\n-      -- Function To_Character\n-\n-\n-      -- Use default substitution character in call of To_Character.\n-\n-      if ACH.To_Character(First_Wide_Char)    /= First_Char or \n-         ACH.To_Character(Last_Non_Wide_Char) /= Last_Char\n-      then\n-         Report.Failed (\"Incorrect result from To_Character - 1\");\n-      end if;\n-\n-\n-      -- Provide a substitution character for use with To_Character.\n-\n-      if ACH.To_Character(First_Unique_Wide_Char, Blank)    /= Blank    or\n-         ACH.To_Character(First_Unique_Wide_Char, Sub_Char) /= Sub_Char or\n-         ACH.To_Character(Last_Wide_Char)                   /= ' '  -- default\n-      then\n-         Report.Failed (\"Incorrect result from To_Character - 2\");\n-      end if;\n-\n-\n-      -- Function To_String\n-\n-\n-      if ACH.To_String(A_Wide_String) /=  A_String then\n-         Report.Failed (\"Incorrect result from To_String - 1\");\n-      end if;\n-\n-     \n-      if ACH.To_String(Unique_Wide_String, Sub_Char) /= \"**\" then\n-         Report.Failed (\"Incorrect result from To_String - 2\");\n-      end if;\n-\n-\n-\n-      if ACH.To_String(Mixed_Wide_String,  Sub_Char) /= \n-         ('A' & First_Char & Last_Char & \"**\" & 'Z')   or\n-         ACH.To_String(Mixed_Wide_String,  Sub_Char) /= \n-         (ACH.To_Character(Mixed_Wide_String(1), Sub_Char) &\n-          ACH.To_Character(Mixed_Wide_String(2), Sub_Char) &\n-          ACH.To_Character(Mixed_Wide_String(3), Sub_Char) &\n-          ACH.To_Character(Mixed_Wide_String(4), Sub_Char) &\n-          ACH.To_Character(Mixed_Wide_String(5), Sub_Char) &\n-          ACH.To_Character(Mixed_Wide_String(6), Sub_Char)) \n-      then\n-         Report.Failed (\"Incorrect result from To_String - 3\");\n-      end if;\n-\n-\n-      -- Function To_Wide_Character\n-\n-\n-      if ACH.To_Wide_Character(Basic_Char) /= Basic_Wide_Char then\n-         Report.Failed (\"Incorrect result from To_Wide_Character\");\n-      end if;\n-\n-    \n-      -- Function To_Wide_String\n-\n-\n-      if not (ACH.To_Wide_String(Basic_String) = Basic_Wide_String) then\n-         Report.Failed (\"Incorrect result from To_Wide_String\");\n-      end if;\n-\n-\n-      -- Functions Used In Combination\n-\n-      if not ACH.Is_Character (ACH.To_Wide_Character (\n-        ACH.To_Character(First_Wide_Char))) \n-      then\n-         Report.Failed (\"Incorrect result from functions in combination - 1\");\n-      end if;\n-\n-\n-      if not ACH.Is_String(ACH.To_Wide_String(ACH.To_String(A_Wide_String)))\n-      then\n-         Report.Failed (\"Incorrect result from functions in combination - 2\");\n-      end if;\n-\n-\n-      if ACH.To_String(ACH.To_Wide_Character('A')    &\n-                       ACH.To_Wide_Character(F_Char) &\n-                       ACH.To_Wide_Character('Z'))     /=  \"AFZ\"\n-      then\n-         Report.Failed (\"Incorrect result from functions in combination - 3\");\n-      end if;\n-         \n-\n-   exception\n-      when others => Report.Failed (\"Exception raised in Test_Block\");\n-   end Test_Block;\n-\n-\n-   Report.Result;\n-\n-end CXA3004;"}, {"sha": "d31345a8eb1291bcbae072b23dc808c57054ec11", "filename": "gcc/testsuite/ada/acats/tests/cxb/cxb30061.am", "status": "removed", "additions": 0, "deletions": 404, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1144f8d5ca6ef0a7e563809249a374648802ed85/gcc%2Ftestsuite%2Fada%2Facats%2Ftests%2Fcxb%2Fcxb30061.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1144f8d5ca6ef0a7e563809249a374648802ed85/gcc%2Ftestsuite%2Fada%2Facats%2Ftests%2Fcxb%2Fcxb30061.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fada%2Facats%2Ftests%2Fcxb%2Fcxb30061.am?ref=1144f8d5ca6ef0a7e563809249a374648802ed85", "patch": "@@ -1,404 +0,0 @@\n--- CXB30061.AM\n---\n---                             Grant of Unlimited Rights\n---\n---     Under contracts F33600-87-D-0337, F33600-84-D-0280, MDA903-79-C-0687,\n---     F08630-91-C-0015, and DCA100-97-D-0025, the U.S. Government obtained\n---     unlimited rights in the software and documentation contained herein.\n---     Unlimited rights are defined in DFAR 252.227-7013(a)(19).  By making\n---     this public release, the Government intends to confer upon all\n---     recipients unlimited rights  equal to those held by the Government.\n---     These rights include rights to use, duplicate, release or disclose the\n---     released technical data and computer software in whole or in part, in\n---     any manner and for any purpose whatsoever, and to have or permit others\n---     to do so.\n---\n---                                    DISCLAIMER\n---\n---     ALL MATERIALS OR INFORMATION HEREIN RELEASED, MADE AVAILABLE OR\n---     DISCLOSED ARE AS IS.  THE GOVERNMENT MAKES NO EXPRESS OR IMPLIED\n---     WARRANTY AS TO ANY MATTER WHATSOEVER, INCLUDING THE CONDITIONS OF THE\n---     SOFTWARE, DOCUMENTATION OR OTHER INFORMATION RELEASED, MADE AVAILABLE\n---     OR DISCLOSED, OR THE OWNERSHIP, MERCHANTABILITY, OR FITNESS FOR A\n---     PARTICULAR PURPOSE OF SAID MATERIAL.\n---*\n---\n--- OBJECTIVE:\n---      Check that the function To_C maps between the Ada type Wide_Character\n---      and the C type wchar_t.\n---\n---      Check that the function To_Ada maps between the C type wchar_t and\n---      the Ada type Wide_Character.\n---\n---      Check that the function Is_Nul_Terminated returns True if the\n---      wchar_array parameter contains wide_nul, and otherwise False.\n---\n---      Check that the function To_C produces a correct wchar_array result,\n---      with lower bound of 0, and length dependent upon the Item and\n---      Append_Nul parameters.\n---\n---      Check that the function To_Ada produces a correct wide_string result,\n---      with lower bound of 1, and length dependent upon the Item and\n---      Trim_Nul parameters.\n---\n---      Check that the function To_Ada raises Terminator_Error if the\n---      parameter Trim_Nul is set to True, but the actual Item parameter\n---      does not contain the wide_nul wchar_t.\n---\n--- TEST DESCRIPTION:\n---      This test uses a variety of Wide_Character, wchar_t, Wide_String, and\n---      wchar_array objects to test versions of the To_C, To_Ada, and\n---      Is_Nul_Terminated functions.\n---\n---      This test assumes that the following characters are all included\n---      in the implementation defined type Interfaces.C.wchar_t:\n---      ' ', ',', '.', '0'..'9', 'a'..'z' and 'A'..'Z'.\n---\n--- APPLICABILITY CRITERIA:\n---      This test is applicable to all implementations that provide\n---      package Interfaces.C.  If an implementation provides\n---      package Interfaces.C, this test must compile, execute, and\n---      report \"PASSED\".\n---\n--- SPECIAL REQUIREMENTS:\n---      The file CXB30060.C must be compiled with a C compiler.\n---      Implementation dialects of C may require alteration of\n---      the C program syntax (see individual C files).\n---\n---      Note that the compiled C code must be bound with the compiled Ada\n---      code to create an executable image.  An implementation must provide\n---      the necessary commands to accomplish this.\n---\n---      Note that the C code included in CXB30060.C conforms\n---      to ANSI-C.  Modifications to these files may be required for other\n---      C compilers.  An implementation must provide the necessary\n---      modifications to satisfy the function requirements.\n---\n--- TEST FILES:\n---      The following files comprise this test:\n---\n---         CXB30060.C\n---         CXB30061.AM\n---\n--- CHANGE HISTORY:\n---      07 Sep 95   SAIC    Initial prerelease version.\n---      09 May 96   SAIC    Incorporated reviewer comments for ACVC 2.1.\n---      13 Sep 99   RLB     Replaced (bogus) Unchecked_Conversions with a\n---                          C function character generator.\n---\n---!\n-\n-with Report;\n-with Interfaces.C;                                            -- N/A => ERROR\n-with Ada.Characters.Latin_1;\n-with Ada.Characters.Handling;\n-with Ada.Exceptions;\n-with Ada.Strings.Wide_Fixed;\n-with Impdef;\n-\n-procedure CXB30061 is\n-begin\n-\n-   Report.Test (\"CXB3006\", \"Check that the functions To_C and To_Ada \" &\n-                           \"produce correct results\");\n-\n-   Test_Block:\n-   declare\n-\n-      use Interfaces, Interfaces.C;\n-      use Ada.Characters, Ada.Characters.Latin_1, Ada.Characters.Handling;\n-      use Ada.Strings.Wide_Fixed;\n-\n-      First_Character,\n-      Last_Character  : Character;\n-      TC_wchar_t,\n-      TC_Low_wchar_t,\n-      TC_High_wchar_t : wchar_t           := wchar_t'First;\n-      TC_Wide_String  : Wide_String(1..8) := (others => Wide_Character'First);\n-      TC_wchar_array  : wchar_array(0..7) := (others => C.wide_nul);\n-\n-      -- The function Char_Gen returns a character corresponding to its\n-      -- argument.\n-      --     Value   0 ..  9 ==> '0' .. '9'\n-      --     Value  10 .. 19 ==> 'A' .. 'J'\n-      --     Value  20 .. 29 ==> 'k' .. 't'\n-      --     Value  30       ==> ' '\n-      --     Value  31       ==> '.'\n-      --     Value  32       ==> ','\n-\n-      function Char_Gen (Value   : in int) return wchar_t;\n-\n-      -- Use the user-defined C function char_gen as a completion to the\n-      -- function specification above.\n-\n-      pragma Import (Convention    => C,\n-                     Entity        => Char_Gen,\n-                     External_Name => Impdef.CXB30060_External_Name);\n-\n-   begin\n-\n-      -- Check that the functions To_C and To_Ada map between the Ada type\n-      -- Wide_Character and the C type wchar_t.\n-\n-      if To_C(To_Wide_Character(Ada.Characters.Latin_1.NUL)) /=\n-         Interfaces.C.wide_nul\n-      then\n-         Report.Failed(\"Incorrect result from To_C with NUL character input\");\n-      end if;\n-\n-      First_Character := Report.Ident_Char('k');\n-      Last_Character  := Report.Ident_Char('t');\n-      for i in First_Character..Last_Character loop\n-         if To_C(Item => To_Wide_Character(i)) /=\n-\t    Char_Gen(Character'Pos(i) - Character'Pos('k') + 20)\n-         then\n-            Report.Failed(\"Incorrect result from To_C with lower case \" &\n-                          \"alphabetic wide character input\");\n-         end if;\n-      end loop;\n-\n-      First_Character := Report.Ident_Char('A');\n-      Last_Character  := Report.Ident_Char('J');\n-      for i in First_Character..Last_Character loop\n-         if To_C(Item => To_Wide_Character(i)) /=\n-\t    Char_Gen(Character'Pos(i) - Character'Pos('A') + 10)\n-         then\n-            Report.Failed(\"Incorrect result from To_C with upper case \" &\n-                          \"alphabetic wide character input\");\n-         end if;\n-      end loop;\n-\n-      First_Character := Report.Ident_Char('0');\n-      Last_Character  := Report.Ident_Char('9');\n-      for i in First_Character..Last_Character loop\n-         if To_C(Item => To_Wide_Character(i)) /=\n-\t    Char_Gen(Character'Pos(i) - Character'Pos('0'))\n-         then\n-            Report.Failed(\"Incorrect result from To_C with digit \" &\n-                          \"wide character input\");\n-         end if;\n-      end loop;\n-\n-      if To_C(Item => To_Wide_Character(' ')) /= Char_Gen(30)\n-      then\n-            Report.Failed(\"Incorrect result from To_C with space \" &\n-                          \"wide character input\");\n-      end if;\n-\n-      if To_C(Item => To_Wide_Character('.')) /= Char_Gen(31)\n-      then\n-            Report.Failed(\"Incorrect result from To_C with dot \" &\n-                          \"wide character input\");\n-      end if;\n-\n-      if To_C(Item => To_Wide_Character(',')) /= Char_Gen(32)\n-      then\n-            Report.Failed(\"Incorrect result from To_C with comma \" &\n-                          \"wide character input\");\n-      end if;\n-\n-      if To_Ada(Interfaces.C.wide_nul) /=\n-         To_Wide_Character(Ada.Characters.Latin_1.NUL)\n-      then\n-         Report.Failed(\"Incorrect result from To_Ada with wide_nul \" &\n-                       \"wchar_t input\");\n-      end if;\n-\n-      for Code in int range\n-         int(Report.Ident_Int(20)) .. int(Report.Ident_Int(29)) loop\n-            -- 'k' .. 't'\n-         if To_Ada(Item => Char_Gen(Code)) /=\n-\t    To_Wide_Character(Character'Val (Character'Pos('k') + (Code - 20)))\n-         then\n-            Report.Failed(\"Incorrect result from To_Ada with lower case \" &\n-                          \"alphabetic wchar_t input\");\n-         end if;\n-      end loop;\n-\n-      for Code in int range\n-         int(Report.Ident_Int(10)) .. int(Report.Ident_Int(19)) loop\n-            -- 'A' .. 'J'\n-         if To_Ada(Item => Char_Gen(Code)) /=\n-\t    To_Wide_Character(Character'Val (Character'Pos('A') + (Code - 10)))\n-         then\n-            Report.Failed(\"Incorrect result from To_Ada with upper case \" &\n-                          \"alphabetic wchar_t input\");\n-         end if;\n-      end loop;\n-\n-      for Code in int range\n-         int(Report.Ident_Int(0)) .. int(Report.Ident_Int(9)) loop\n-            -- '0' .. '9'\n-         if To_Ada(Item => Char_Gen(Code)) /=\n-\t    To_Wide_Character(Character'Val (Character'Pos('0') + (Code)))\n-         then\n-            Report.Failed(\"Incorrect result from To_Ada with digit \" &\n-                          \"wchar_t input\");\n-         end if;\n-      end loop;\n-\n-      if To_Ada(Item => Char_Gen(30)) /= ' ' then\n-         Report.Failed(\"Incorrect result from To_Ada with space \" &\n-                       \"char input\");\n-      end if;\n-      if To_Ada(Item => Char_Gen(31)) /= '.' then\n-         Report.Failed(\"Incorrect result from To_Ada with dot \" &\n-                       \"char input\");\n-      end if;\n-      if To_Ada(Item => Char_Gen(32)) /= ',' then\n-         Report.Failed(\"Incorrect result from To_Ada with comma \" &\n-                       \"char input\");\n-      end if;\n-\n-      -- Check that the function Is_Nul_Terminated produces correct results\n-      -- whether or not the wchar_array argument contains the\n-      -- Ada.Interfaces.C.wide_nul character.\n-\n-      TC_Wide_String := \"abcdefgh\";\n-      if Is_Nul_Terminated(Item => To_C(TC_Wide_String, Append_Nul => False))\n-      then\n-         Report.Failed(\"Incorrect result from Is_Nul_Terminated when no \" &\n-                       \"wide_nul wchar_t is present\");\n-      end if;\n-\n-      if not Is_Nul_Terminated(To_C(TC_Wide_String, Append_Nul => True)) then\n-         Report.Failed(\"Incorrect result from Is_Nul_Terminated when the \" &\n-                       \"wide_nul wchar_t is present\");\n-      end if;\n-\n-\n-\n-      -- Now that we've tested the character/char versions of To_Ada and To_C,\n-      -- use them to test the string versions.\n-\n-      declare\n-         i                    : size_t  := 0;\n-         j                    : integer := 1;\n-         Incorrect_Conversion : Boolean := False;\n-\n-         TC_No_wide_nul       : constant wchar_array := To_C(TC_Wide_String,\n-                                                             False);\n-         TC_wide_nul_Appended : constant wchar_array := To_C(TC_Wide_String,\n-                                                             True);\n-      begin\n-\n-         -- Check that the function To_C produces a wchar_array result with\n-         -- lower bound of 0, and length dependent upon the Item and\n-         -- Append_Nul parameters (if Append_Nul is True, length is\n-         -- Item'Length + 1; if False, length is Item'Length).\n-\n-         if TC_No_wide_nul'First /= 0 or TC_wide_nul_Appended'First /= 0 then\n-            Report.Failed(\"Incorrect lower bound from Function To_C\");\n-         end if;\n-\n-         if TC_No_wide_nul'Length /= TC_Wide_String'Length then\n-            Report.Failed(\"Incorrect length returned from Function To_C \" &\n-                          \"when Append_Nul => False\");\n-         end if;\n-\n-         if TC_wide_nul_Appended'Length /= TC_Wide_String'Length + 1 then\n-            Report.Failed(\"Incorrect length returned from Function To_C \" &\n-                          \"when Append_Nul => True\");\n-         end if;\n-\n-         if not Is_Nul_Terminated(TC_wide_nul_Appended) then\n-            Report.Failed(\"No wide_nul appended to the wide_string \"    &\n-                          \"parameter during conversion to wchar_array \" &\n-                          \"by function To_C\");\n-         end if;\n-\n-         for TC_char in Report.Ident_Char('a')..Report.Ident_Char('h') loop\n-            if TC_No_wide_nul(i)       /= To_C(To_Wide_Character(TC_char)) or\n-               TC_wide_nul_Appended(i) /= To_C(To_Wide_Character(TC_char)) then\n-               -- Use single character To_C.\n-               Incorrect_Conversion := True;\n-            end if;\n-            i := i + 1;\n-         end loop;\n-\n-         if Incorrect_Conversion then\n-            Report.Failed(\"Incorrect result from To_C with wide_string input \" &\n-                          \"and wchar_array result\");\n-         end if;\n-\n-\n-         -- Check that the function To_Ada produces a wide_string result with\n-         -- lower bound of 1, and length dependent upon the Item and\n-         -- Trim_Nul parameters (if Trim_Nul is False, length is Item'Length;\n-         -- if False, length will be the length of the slice of Item prior to\n-         -- the first wide_nul).\n-\n-         declare\n-            TC_No_NUL_Wide_String       : constant Wide_String :=\n-              To_Ada(Item => TC_wide_nul_Appended, Trim_Nul => True);\n-\n-            TC_NUL_Appended_Wide_String : constant Wide_String :=\n-              To_Ada(TC_wide_nul_Appended, False);\n-\n-         begin\n-\n-            if TC_No_NUL_Wide_String'First       /= 1 or\n-               TC_NUL_Appended_Wide_String'First /= 1\n-            then\n-               Report.Failed(\"Incorrect lower bound from Function To_Ada\");\n-            end if;\n-\n-            if TC_No_NUL_Wide_String'Length /= TC_Wide_String'Length then\n-               Report.Failed(\"Incorrect length returned from Function \" &\n-                             \"To_Ada when Trim_Nul => True\");\n-            end if;\n-\n-            if TC_NUL_Appended_Wide_String'Length /=\n-               TC_Wide_String'Length + 1\n-            then\n-               Report.Failed(\"Incorrect length returned from Function \" &\n-                             \"To_Ada when Trim_Nul => False\");\n-            end if;\n-\n-            for TC_Character in Wide_Character'('a') .. Wide_Character'('h') loop\n-               if TC_No_NUL_Wide_String(j)       /= TC_Character or\n-                  TC_NUL_Appended_Wide_String(j) /= TC_Character\n-               then\n-                  Report.Failed(\"Incorrect result from To_Ada with \" &\n-                                \"char_array input, index = \"         &\n-                                Integer'Image(j));\n-               end if;\n-               j := j + 1;\n-            end loop;\n-\n-         end;\n-\n-\n-         -- Check that the function To_Ada raises Terminator_Error if the\n-         -- parameter Trim_Nul is set to True, but the actual Item parameter\n-         -- does not contain the wide_nul wchar_t.\n-\n-         begin\n-            TC_Wide_String := To_Ada(TC_No_wide_nul, Trim_Nul => True);\n-            Report.Failed(\"Terminator_Error not raised when Item \"    &\n-                          \"parameter of To_Ada does not contain the \" &\n-                          \"wide_nul wchar_t, but parameter Trim_Nul \" &\n-                          \"=> True\");\n-            Report.Comment\n-              (To_String(TC_Wide_String) & \" printed to defeat optimization\");\n-         exception\n-            when Terminator_Error => null;  -- OK, expected exception.\n-            when others           =>\n-               Report.Failed(\"Incorrect exception raised by function \"  &\n-                             \"To_Ada when the Item parameter does not \" &\n-                             \"contain the wide_nul wchar_t, but \"       &\n-                             \"parameter Trim_Nul => True\");\n-         end;\n-\n-      end;\n-\n-   exception\n-      when The_Error : others =>\n-         Report.Failed\n-           (\"The following exception was raised in the Test_Block: \" &\n-            Ada.Exceptions.Exception_Name(The_Error));\n-   end Test_Block;\n-\n-   Report.Result;\n-\n-end CXB30061;"}]}