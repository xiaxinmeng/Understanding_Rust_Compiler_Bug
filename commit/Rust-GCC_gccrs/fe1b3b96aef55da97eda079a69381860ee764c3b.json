{"sha": "fe1b3b96aef55da97eda079a69381860ee764c3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUxYjNiOTZhZWY1NWRhOTdlZGEwNzlhNjkzODE4NjBlZTc2NGMzYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-09T07:40:14Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-09T07:40:14Z"}, "message": "decl.c (store_parm_decls): Generate cleanup code at semantic-analysis time.\n\n\t* decl.c (store_parm_decls): Generate cleanup code at\n\tsemantic-analysis time.  Destroy objects in the correct order.\n\nFrom-SVN: r30456", "tree": {"sha": "f7fcdbac2e31f70e51aace4baffde1bae90e5d71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7fcdbac2e31f70e51aace4baffde1bae90e5d71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe1b3b96aef55da97eda079a69381860ee764c3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1b3b96aef55da97eda079a69381860ee764c3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe1b3b96aef55da97eda079a69381860ee764c3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1b3b96aef55da97eda079a69381860ee764c3b/comments", "author": null, "committer": null, "parents": [{"sha": "312618c7d082170511d341cf08918e543490361b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/312618c7d082170511d341cf08918e543490361b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/312618c7d082170511d341cf08918e543490361b"}], "stats": {"total": 92, "additions": 67, "deletions": 25}, "files": [{"sha": "24ef9a45aabb2e62b7bfc71d3041721b70cd2ec0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1b3b96aef55da97eda079a69381860ee764c3b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1b3b96aef55da97eda079a69381860ee764c3b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fe1b3b96aef55da97eda079a69381860ee764c3b", "patch": "@@ -1,3 +1,8 @@\n+1999-11-08  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl.c (store_parm_decls): Generate cleanup code at\n+\tsemantic-analysis time.  Destroy objects in the correct order.\n+\n 1999-11-07  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (begin_new_placement): Remove."}, {"sha": "e7a10b420807d340e04bbe0a90ddb2c56fe3d10b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1b3b96aef55da97eda079a69381860ee764c3b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1b3b96aef55da97eda079a69381860ee764c3b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fe1b3b96aef55da97eda079a69381860ee764c3b", "patch": "@@ -13163,26 +13163,26 @@ store_parm_decls ()\n \t  next = TREE_CHAIN (parm);\n \t  if (TREE_CODE (parm) == PARM_DECL)\n \t    {\n-\t      tree cleanup;\n-\t      \n+\t      tree type = TREE_TYPE (parm);\n+\n \t      if (doing_semantic_analysis_p ())\n \t\t{\n+\t\t  tree cleanup;\n+\t      \n \t\t  if (DECL_NAME (parm) == NULL_TREE\n-\t\t      || TREE_CODE (TREE_TYPE (parm)) != VOID_TYPE)\n+\t\t      || TREE_CODE (parm) != VOID_TYPE)\n \t\t    pushdecl (parm);\n \t\t  else\n \t\t    cp_error (\"parameter `%D' declared void\", parm);\n-\t\t}\n-\n-\t      if (! building_stmt_tree ()\n-\t\t  && (cleanup = maybe_build_cleanup (parm), cleanup))\n-\t\t{\n-\t\t  expand_decl (parm);\n-\t\t  parms_have_cleanups = 1;\n \n-\t\t  /* Keep track of the cleanups.  */\n-\t\t  cleanups = tree_cons (parm, cleanup, cleanups);\n+\t\t  cleanup = maybe_build_cleanup (parm);\n+\t\t  \n+\t\t  if (cleanup)\n+\t\t    cleanups = tree_cons (parm, cleanup, cleanups);\n \t\t}\n+\t      else if (type != error_mark_node\n+\t\t       && TYPE_NEEDS_DESTRUCTOR (type))\n+\t\tparms_have_cleanups = 1;\n \t    }\n \t  else\n \t    {\n@@ -13200,9 +13200,6 @@ store_parm_decls ()\n \t     PARM_DECLs that were pushed into scope by the loop above.  */\n \t  DECL_ARGUMENTS (fndecl) = getdecls ();\n \t  storetags (chainon (parmtags, gettags ()));\n-\n-\t  /* We built up the cleanups in reversed order.  */\n-\t  cleanups = nreverse (cleanups);\n \t}\n     }\n   else\n@@ -13230,16 +13227,12 @@ store_parm_decls ()\n   /* Now that we have initialized the parms, we can start their\n      cleanups.  We cannot do this before, since expand_decl_cleanup\n      should not be called before the parm can be used.  */\n-  if (cleanups && !building_stmt_tree ())\n-    while (cleanups)\n-      {\n-\tif (! expand_decl_cleanup (TREE_PURPOSE (cleanups), \n-\t\t\t\t   TREE_VALUE (cleanups)))\n-\t  cp_error (\"parser lost in parsing declaration of `%D'\",\n-\t\t    TREE_PURPOSE (cleanups));\n-\t\n-\tcleanups = TREE_CHAIN (cleanups);\n-      }\n+  while (cleanups)\n+    {\n+      finish_decl_cleanup (TREE_PURPOSE (cleanups), \n+\t\t\t   TREE_VALUE (cleanups));\n+      cleanups = TREE_CHAIN (cleanups);\n+    }\n \n   /* Create a binding contour which can be used to catch\n      cleanup-generated temporaries.  Also, if the return value needs or"}, {"sha": "60448490a62304a27ae41521297f6c891d07433c", "filename": "gcc/testsuite/g++.old-deja/g++.other/dtor6.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1b3b96aef55da97eda079a69381860ee764c3b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1b3b96aef55da97eda079a69381860ee764c3b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor6.C?ref=fe1b3b96aef55da97eda079a69381860ee764c3b", "patch": "@@ -0,0 +1,44 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+extern \"C\" void abort ();\n+\n+int count;\n+\n+struct S\n+{\n+  S ();\n+  S (const S&);\n+  ~S ();\n+\n+  int i;\n+};\n+\n+S::S ()\n+{\n+  i = count++;\n+}\n+\n+S::S (const S&)\n+{\n+  i = count++;\n+}\n+\n+S::~S ()\n+{\n+  if (--count != i)\n+    abort ();\n+}\n+\n+void f (S, S)\n+{\n+}\n+\n+int main ()\n+{\n+  {\n+    S s;\n+    f (s, s);\n+  }\n+  return count != 0;\n+}\n+"}]}