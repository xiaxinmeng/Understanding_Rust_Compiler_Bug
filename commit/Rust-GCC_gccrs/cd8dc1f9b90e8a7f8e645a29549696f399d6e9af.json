{"sha": "cd8dc1f9b90e8a7f8e645a29549696f399d6e9af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q4ZGMxZjliOTBlOGE3ZjhlNjQ1YTI5NTQ5Njk2ZjM5OWQ2ZTlhZg==", "commit": {"author": {"name": "Wolfgang Gellerich", "email": "gellerich@de.ibm.com", "date": "2006-10-17T14:12:13Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2006-10-17T14:12:13Z"}, "message": "contraints.md: New file.\n\n2006-10-17  Wolfgang Gellerich  <gellerich@de.ibm.com>\n\n\t* config/s390/contraints.md: New file.\n        * config/s390/s390-protos.h (s390_mem_constraint, \n\ts390_O_constraint_str, s390_N_constraint_str, \n\ts390_float_const_zero_p): Function prototypes added.\n\t* config/s390/s390.c (s390_extra_constraint_str, \n\ts390_const_double_ok_for_constraint_p, \n\ts390_const_ok_for_constraint_p): Functions removed.\n        (s390_mem_constraint, s390_O_constraint_str, s390_N_constraint_str,\n\ts390_float_const_zero_p): New functions.\n\t* config/s390/s390.h (REG_CLASS_FROM_LETTER, CONST_OK_FOR_CONSTRAINT_P,\n\tCONST_DOUBLE_OK_FOR_CONSTRAINT_P, EXTRA_CONSTRAINT_STR, \n\tEXTRA_MEMORY_CONSTRAINT, EXTRA_ADDRESS_CONSTRAINT, CONSTRAINT_LEN): \n\tMacro definitions removed.\n\t(s390_const_ok_for_constraint_p, s390_const_double_ok_for_constraint_p,\n\ts390_extra_constraint_str): Functions removed.\n\nFrom-SVN: r117826", "tree": {"sha": "a8dc4679f000ab259f2dc58c56d7aa7d5bea27ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8dc4679f000ab259f2dc58c56d7aa7d5bea27ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/comments", "author": null, "committer": null, "parents": [{"sha": "4d79381119ed02f9d80de7898935ac5686d119bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d79381119ed02f9d80de7898935ac5686d119bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d79381119ed02f9d80de7898935ac5686d119bd"}], "stats": {"total": 740, "additions": 565, "deletions": 175}, "files": [{"sha": "d261a5795edba211e94d29b1e862a4ee2c3f1e4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd8dc1f9b90e8a7f8e645a29549696f399d6e9af", "patch": "@@ -1,3 +1,21 @@\n+2006-10-17  Wolfgang Gellerich  <gellerich@de.ibm.com>\n+\n+\t* config/s390/contraints.md: New file.\n+        * config/s390/s390-protos.h (s390_mem_constraint, \n+\ts390_O_constraint_str, s390_N_constraint_str, \n+\ts390_float_const_zero_p): Function prototypes added.\n+\t* config/s390/s390.c (s390_extra_constraint_str, \n+\ts390_const_double_ok_for_constraint_p, \n+\ts390_const_ok_for_constraint_p): Functions removed.\n+        (s390_mem_constraint, s390_O_constraint_str, s390_N_constraint_str,\n+\ts390_float_const_zero_p): New functions.\n+\t* config/s390/s390.h (REG_CLASS_FROM_LETTER, CONST_OK_FOR_CONSTRAINT_P,\n+\tCONST_DOUBLE_OK_FOR_CONSTRAINT_P, EXTRA_CONSTRAINT_STR, \n+\tEXTRA_MEMORY_CONSTRAINT, EXTRA_ADDRESS_CONSTRAINT, CONSTRAINT_LEN): \n+\tMacro definitions removed.\n+\t(s390_const_ok_for_constraint_p, s390_const_double_ok_for_constraint_p,\n+\ts390_extra_constraint_str): Functions removed.\n+\n 2006-10-17  Andrew Pinsiki  <pinskia@gmail.com>\n \t    Richard Sandiford  <richard@codesourcery.com>\n "}, {"sha": "cfc8aa51f3fda57881d34b2692cb116761d091c3", "filename": "gcc/config/s390/constraints.md", "status": "added", "additions": 438, "deletions": 0, "changes": 438, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/gcc%2Fconfig%2Fs390%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/gcc%2Fconfig%2Fs390%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fconstraints.md?ref=cd8dc1f9b90e8a7f8e645a29549696f399d6e9af", "patch": "@@ -0,0 +1,438 @@\n+;; Constraints definitions belonging to the gcc backend for IBM S/390.\n+;; Copyright (C) 2006 Free Software Foundation, Inc.\n+;; Written by Wolfgang Gellerich, using code and information found in\n+;; files s390.md, s390.h, and s390.c.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 2, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+\n+;;\n+;; Special constraints for s/390 machine description:\n+;;\n+;;    a -- Any address register from 1 to 15.\n+;;    c -- Condition code register 33.\n+;;    d -- Any register from 0 to 15.\n+;;    f -- Floating point registers.\n+;;    t -- Access registers 36 and 37.\n+;;    G -- Const double zero operand\n+;;    I -- An 8-bit constant (0..255).\n+;;    J -- A 12-bit constant (0..4095).\n+;;    K -- A 16-bit constant (-32768..32767).\n+;;    L -- Value appropriate as displacement.\n+;;         (0..4095) for short displacement\n+;;         (-524288..524287) for long displacement\n+;;    M -- Constant integer with a value of 0x7fffffff.\n+;;    N -- Multiple letter constraint followed by 4 parameter letters.\n+;;         0..9,x:  number of the part counting from most to least significant\n+;;         H,Q:     mode of the part\n+;;         D,S,H:   mode of the containing operand\n+;;         0,F:     value of the other parts (F - all bits set)\n+;;\n+;;         The constraint matches if the specified part of a constant\n+;;         has a value different from its other parts.  If the letter x\n+;;         is specified instead of a part number, the constraint matches\n+;;         if there is any single part with non-default value.\n+;;    O -- Multiple letter constraint followed by 1 parameter.\n+;;         s:  Signed extended immediate value (-2G .. 2G-1).\n+;;         p:  Positive extended immediate value (0 .. 4G-1).\n+;;         n:  Negative extended immediate value (-4G .. -1).\n+;;         These constraints do not accept any operand if the machine does\n+;;         not provide the extended-immediate facility.\n+;;    P -- Any integer constant that can be loaded without literal pool.\n+;;    Q -- Memory reference without index register and with short displacement.\n+;;    R -- Memory reference with index register and short displacement.\n+;;    S -- Memory reference without index register but with long displacement.\n+;;    T -- Memory reference with index register and long displacement.\n+;;    A -- Multiple letter constraint followed by Q, R, S, or T:\n+;;         Offsettable memory reference of type specified by second letter.\n+;;    B -- Multiple letter constraint followed by Q, R, S, or T:\n+;;         Memory reference of the type specified by second letter that\n+;;         does *not* refer to a literal pool entry.\n+;;    U -- Pointer with short displacement.\n+;;    W -- Pointer with long displacement.\n+;;    Y -- Shift count operand.\n+;;\n+\n+\n+;;\n+;;  Register constraints.\n+;;\n+\n+(define_register_constraint \"a\" \n+  \"ADDR_REGS\"\n+  \"Any address register from 1 to 15.\")\n+\n+\n+(define_register_constraint \"c\" \n+  \"CC_REGS\"\n+  \"Condition code register 33\")\n+\n+\n+(define_register_constraint \"d\" \n+  \"GENERAL_REGS\"\n+  \"Any register from 0 to 15\")\n+\n+\n+(define_register_constraint \"f\" \n+  \"FP_REGS\"\n+  \"Floating point registers\")\n+\n+\n+(define_register_constraint \"t\" \n+  \"ACCESS_REGS\"\n+  \"@internal\n+   Access registers 36 and 37\")\n+\n+\n+;;\n+;;  General constraints for constants.\n+;;\n+\n+(define_constraint \"G\"\n+  \"@internal\n+   Const double zero operand\"\n+   (and (match_code \"const_double\")\n+        (match_test \"s390_float_const_zero_p (op)\")))\n+\n+\n+(define_constraint \"I\"\n+  \"An 8-bit constant (0..255)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned int) ival <= 255\")))\n+\n+\n+(define_constraint \"J\"\n+  \"A 12-bit constant (0..4095)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned int) ival <= 4095\")))\n+\n+\n+(define_constraint \"K\"\n+  \"A 16-bit constant (-32768..32767)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -32768 && ival <= 32767\")))\n+\n+\n+\n+(define_constraint \"L\"\n+  \"Value appropriate as displacement.\n+      (0..4095) for short displacement\n+      (-524288..524287) for long displacement\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_LONG_DISPLACEMENT ?\n+              (ival >= -524288 && ival <= 524287)\n+            : (ival >= 0 && ival <= 4095)\")))\n+\n+\n+(define_constraint \"M\"\n+  \"Constant integer with a value of 0x7fffffff\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 2147483647\")))\n+\n+\n+(define_constraint \"P\"\n+  \"@internal\n+   Any integer constant that can be loaded without literal pool\"\n+   (and (match_code \"const_int\")\n+        (match_test \"legitimate_reload_constant_p (GEN_INT (ival))\")))\n+\n+\n+(define_address_constraint \"Y\"\n+  \"Shift count operand\"\n+\n+;; Simply check for the basic form of a shift count.  Reload will\n+;; take care of making sure we have a proper base register.\n+\n+  (match_test \"s390_decompose_shift_count (op, NULL, NULL)\"  ))\n+\n+\n+;;    N -- Multiple letter constraint followed by 4 parameter letters.\n+;;         0..9,x:  number of the part counting from most to least significant\n+;;         H,Q:     mode of the part\n+;;         D,S,H:   mode of the containing operand\n+;;         0,F:     value of the other parts (F = all bits set)\n+;;\n+;;         The constraint matches if the specified part of a constant\n+;;         has a value different from its other parts.  If the letter x\n+;;         is specified instead of a part number, the constraint matches\n+;;         if there is any single part with non-default value.\n+;;\n+;; The following patterns define only those constraints that are actually \n+;; used in s390.md.  If you need an additional one, simply add it in the \n+;; obvious way.  Function s390_N_constraint_str is ready to handle all \n+;; combinations.\n+;;\n+\n+\n+(define_constraint \"NxQS0\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"xQS0\\\", ival)\")))\n+\n+\n+(define_constraint \"NxQD0\"\n+  \"@internal\"\n+   (and (match_code \"const_int\")\n+        (match_test \"s390_N_constraint_str (\\\"xQD0\\\", ival)\")))\n+\n+\n+(define_constraint \"N3HD0\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"3HD0\\\", ival)\")))\n+\n+\n+(define_constraint \"N2HD0\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"2HD0\\\", ival)\")))\n+\n+\n+(define_constraint \"N1SD0\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"1SD0\\\", ival)\")))\n+\n+\n+(define_constraint \"N1HS0\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"1HS0\\\", ival)\")))\n+\n+\n+(define_constraint \"N1HD0\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"1HD0\\\", ival)\")))\n+\n+\n+(define_constraint \"N0SD0\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"0SD0\\\", ival)\")))\n+\n+\n+(define_constraint \"N0HS0\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"0HS0\\\", ival)\")))\n+\n+\n+(define_constraint \"N0HD0\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"0HD0\\\", ival)\")))\n+\n+\n+(define_constraint \"NxQDF\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"xQDF\\\", ival)\")))\n+\n+\n+(define_constraint \"N1SDF\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"1SDF\\\", ival)\")))\n+\n+\n+(define_constraint \"N0SDF\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"0SDF\\\", ival)\")))\n+\n+\n+(define_constraint \"N3HDF\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"3HDF\\\", ival)\")))\n+\n+\n+(define_constraint \"N2HDF\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"2HDF\\\", ival)\")))\n+\n+\n+(define_constraint \"N1HDF\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"1HDF\\\", ival)\")))\n+\n+\n+(define_constraint \"N0HDF\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"0HDF\\\", ival)\")))\n+\n+\n+(define_constraint \"N0HSF\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"0HSF\\\", ival)\")))\n+\n+\n+(define_constraint \"N1HSF\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"1HSF\\\", ival)\")))\n+\n+\n+(define_constraint \"NxQSF\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"xQSF\\\", ival)\")))\n+\n+\n+(define_constraint \"NxQHF\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"xQHF\\\", ival)\")))\n+\n+\n+(define_constraint \"NxQH0\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_N_constraint_str (\\\"xQH0\\\", ival)\")))\n+\n+\n+\n+\n+;;\n+;; Double-letter constraints starting with O follow.\n+;;\n+\n+\n+(define_constraint \"Os\"\n+  \"@internal\n+   Signed extended immediate value (-2G .. 2G-1).\n+   This constraint will only match if the machine provides\n+   the extended-immediate facility.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_O_constraint_str ('s', ival)\")))\n+\n+\n+(define_constraint \"Op\"\n+  \"@internal\n+   Positive extended immediate value (0 .. 4G-1).\n+   This constraint will only match if the machine provides\n+   the extended-immediate facility.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_O_constraint_str ('p', ival)\")))\n+\n+\n+(define_constraint \"On\"\n+  \"@internal\n+   Negative extended immediate value (-4G .. -1).\n+   This constraint will only match if the machine provides\n+   the extended-immediate facility.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_O_constraint_str ('n', ival)\")))\n+\n+\n+\n+\n+;;\n+;; Memory constraints follow.\n+;;\n+\n+(define_memory_constraint \"Q\"\n+  \"Memory reference without index register and with short displacement\"\n+  (match_test \"s390_mem_constraint (\\\"Q\\\", op)\"))\n+\n+\n+\n+(define_memory_constraint \"R\"\n+  \"Memory reference with index register and short displacement\"\n+  (match_test \"s390_mem_constraint (\\\"R\\\", op)\"))\n+\n+\n+(define_memory_constraint \"S\"\n+  \"Memory reference without index register but with long displacement\"\n+  (match_test \"s390_mem_constraint (\\\"S\\\", op)\"))\n+\n+\n+(define_memory_constraint \"T\"\n+  \"Memory reference with index register and long displacement\"\n+  (match_test \"s390_mem_constraint (\\\"T\\\", op)\"))\n+\n+\n+\n+(define_memory_constraint \"AQ\"\n+  \"@internal \n+   Offsettable memory reference without index register and with short displacement\"\n+  (match_test \"s390_mem_constraint (\\\"AQ\\\", op)\"))\n+\n+\n+(define_memory_constraint \"AR\"\n+  \"@internal \n+   Offsettable memory reference with index register and short displacement\"\n+  (match_test \"s390_mem_constraint (\\\"AR\\\", op)\"))\n+\n+\n+(define_memory_constraint \"AS\"\n+  \"@internal \n+   Offsettable memory reference without index register but with long displacement\"\n+  (match_test \"s390_mem_constraint (\\\"AS\\\", op)\"))\n+\n+\n+(define_memory_constraint \"AT\"\n+  \"@internal \n+   Offsettable memory reference with index register and long displacement\"\n+  (match_test \"s390_mem_constraint (\\\"AT\\\", op)\"))\n+\n+\n+\n+(define_constraint \"BQ\"\n+  \"@internal \n+   Memory reference without index register and with short \n+   displacement that does *not* refer to a literal pool entry.\"\n+  (match_test \"s390_mem_constraint (\\\"BQ\\\", op)\"))\n+\n+\n+(define_constraint \"BR\"\n+  \"@internal \n+   Memory reference with index register and short displacement that\n+   does *not* refer to a literal pool entry. \"\n+  (match_test \"s390_mem_constraint (\\\"BR\\\", op)\"))\n+\n+\n+(define_constraint \"BS\"\n+  \"@internal \n+   Memory reference without index register but with long displacement\n+   that does *not* refer to a literal pool entry. \"\n+  (match_test \"s390_mem_constraint (\\\"BS\\\", op)\"))\n+\n+\n+(define_constraint \"BT\"\n+  \"@internal \n+   Memory reference with index register and long displacement that\n+   does *not* refer to a literal pool entry. \"\n+  (match_test \"s390_mem_constraint (\\\"BT\\\", op)\"))\n+\n+\n+\n+(define_address_constraint \"U\"\n+  \"Pointer with short displacement\"\n+  (match_test \"s390_mem_constraint (\\\"U\\\", op)\"))\n+\n+\n+\n+(define_address_constraint \"W\"\n+  \"Pointer with long displacement\"\n+  (match_test \"s390_mem_constraint (\\\"W\\\", op)\"))"}, {"sha": "8b2db858bd912d556f06b2a18d3caafc2144297d", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=cd8dc1f9b90e8a7f8e645a29549696f399d6e9af", "patch": "@@ -19,6 +19,18 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n+\n+\n+/* Prototypes of functions used for constraint evaluation in \n+   constraints.c.  */\n+\n+extern int s390_mem_constraint (const char *str, rtx op);\n+extern int s390_O_constraint_str (const char c, HOST_WIDE_INT value);\n+extern int s390_N_constraint_str (const char *str, HOST_WIDE_INT value);\n+extern int s390_float_const_zero_p (rtx value);\n+\n+\n+\n /* Declare functions in s390.c.  */\n \n extern void optimization_options (int, int);"}, {"sha": "b6aeee1129326aa9fe62fa2d7522f5380ab0eda6", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 92, "deletions": 103, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=cd8dc1f9b90e8a7f8e645a29549696f399d6e9af", "patch": "@@ -1842,14 +1842,16 @@ s390_legitimate_address_without_index_p (rtx op)\n   return true;\n }\n \n-/* Return 1 if OP is a valid operand for a C constraint, 0 else.  */\n+\n+/* Evaluates constraint strings described by the regular expression\n+   ([A|B](Q|R|S|T))|U|W and returns 1 if OP is a valid operand for the\n+   constraint given in STR, or 0 else.  */\n \n int\n-s390_extra_constraint_str (rtx op, int c, const char * str)\n+s390_mem_constraint (const char *str, rtx op)\n {\n   struct s390_address addr;\n-\n-  gcc_assert (c == str[0]);\n+  char c = str[0];\n \n   /* Check for offsettable variants of memory constraints.  */\n   if (c == 'A')\n@@ -1859,8 +1861,7 @@ s390_extra_constraint_str (rtx op, int c, const char * str)\n \treturn 0;\n \n       if ((reload_completed || reload_in_progress)\n-\t  ? !offsettable_memref_p (op)\n-\t  : !offsettable_nonstrict_memref_p (op))\n+\t  ? !offsettable_memref_p (op) : !offsettable_nonstrict_memref_p (op))\n \treturn 0;\n \n       c = str[1];\n@@ -1968,132 +1969,120 @@ s390_extra_constraint_str (rtx op, int c, const char * str)\n   return 1;\n }\n \n-/* Return true if VALUE matches the constraint STR.  */\n+\n+\n+/* Evaluates constraint strings starting with letter O.  Input\n+   parameter C is the second letter following the \"O\" in the constraint\n+   string. Returns 1 if VALUE meets the respective constraint and 0\n+   otherwise.  */\n \n int\n-s390_const_double_ok_for_constraint_p (rtx value,\n-\t\t\t\t       int c,\n-\t\t\t\t       const char * str)\n+s390_O_constraint_str (const char c, HOST_WIDE_INT value)\n {\n-  gcc_assert (c == str[0]);\n+  if (!TARGET_EXTIMM)\n+    return 0;\n \n-  switch (str[0])\n+  switch (c)\n     {\n-    case 'G':\n-      /* The floating point zero constant.  */\n-      return (GET_MODE_CLASS (GET_MODE (value)) == MODE_FLOAT\n-              && value == CONST0_RTX (GET_MODE (value)));\n-      \n+    case 's':\n+      return trunc_int_for_mode (value, SImode) == value;\n+\n+    case 'p':\n+      return value == 0\n+\t|| s390_single_part (GEN_INT (value), DImode, SImode, 0) == 1;\n+\n+    case 'n':\n+      return value == -1\n+\t|| s390_single_part (GEN_INT (value), DImode, SImode, -1) == 1;\n+\n     default:\n-      return 0;\n+      gcc_unreachable ();\n     }\n }\n \n-/* Return true if VALUE matches the constraint STR.  */\n+\n+/* Evaluates constraint strings starting with letter N.  Parameter STR\n+   contains the letters following letter \"N\" in the constraint string.\n+   Returns true if VALUE matches the constraint.  */\n \n int\n-s390_const_ok_for_constraint_p (HOST_WIDE_INT value,\n-\t\t\t\tint c,\n-\t\t\t\tconst char * str)\n+s390_N_constraint_str (const char *str, HOST_WIDE_INT value)\n {\n   enum machine_mode mode, part_mode;\n   int def;\n   int part, part_goal;\n \n-  gcc_assert (c == str[0]);\n-\n-  switch (str[0])\n-    {\n-    case 'I':\n-      return (unsigned int)value < 256;\n-\n-    case 'J':\n-      return (unsigned int)value < 4096;\n \n-    case 'K':\n-      return value >= -32768 && value < 32768;\n-\n-    case 'L':\n-      return (TARGET_LONG_DISPLACEMENT ?\n-\t      (value >= -524288 && value <= 524287)\n-\t      : (value >= 0 && value <= 4095));\n-    case 'M':\n-      return value == 2147483647;\n-\n-    case 'N':\n-      if (str[1] == 'x')\n-\tpart_goal = -1;\n-      else\n-\tpart_goal = str[1] - '0';\n-\n-      switch (str[2])\n-\t{\n-  \tcase 'Q': part_mode = QImode; break;\n- \tcase 'H': part_mode = HImode; break;\n- \tcase 'S': part_mode = SImode; break;\n-\tdefault:  return 0;\n-\t}\n-\n-      switch (str[3])\n-\t{\n-\tcase 'H': mode = HImode; break;\n-\tcase 'S': mode = SImode; break;\n-\tcase 'D': mode = DImode; break;\n-\tdefault: return 0;\n-\t}\n-\n-      switch (str[4])\n-\t{\n-\tcase '0': def = 0;  break;\n-\tcase 'F': def = -1; break;\n-\tdefault: return 0;\n-\t}\n-\n-      if (GET_MODE_SIZE (mode) <= GET_MODE_SIZE (part_mode))\n-\treturn 0;\n-\n-      part = s390_single_part (GEN_INT (value), mode, part_mode, def);\n-      if (part < 0)\n-\treturn 0;\n-      if (part_goal != -1 && part_goal != part)\n-\treturn 0;\n+  if (str[0] == 'x')\n+    part_goal = -1;\n+  else\n+    part_goal = str[0] - '0';\n \n+  switch (str[1])\n+    {\n+    case 'Q':\n+      part_mode = QImode;\n       break;\n-\n-    case 'O':\n-      if (!TARGET_EXTIMM)\n-\treturn 0;\n-      \n-      switch (str[1])\n-\t{\n-\tcase 's':\n-\t  return trunc_int_for_mode (value, SImode) == value;\n-\t  \n-\tcase 'p':\n-\t  return value == 0\n-\t    || s390_single_part (GEN_INT (value), DImode, SImode, 0) == 1;\n-\t  \n-\tcase 'n':\n-\t  return \n-\t    (value == -1\n-\t     || s390_single_part (GEN_INT (value), DImode, SImode, -1) == 1)\n-\t    && value != -((HOST_WIDE_INT)1 << 32);\n-\t  \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+    case 'H':\n+      part_mode = HImode;\n+      break;\n+    case 'S':\n+      part_mode = SImode;\n       break;\n+    default:\n+      return 0;\n+    }\n \n-    case 'P':\n-      return legitimate_reload_constant_p (GEN_INT (value));\n+  switch (str[2])\n+    {\n+    case 'H':\n+      mode = HImode;\n+      break;\n+    case 'S':\n+      mode = SImode;\n+      break;\n+    case 'D':\n+      mode = DImode;\n+      break;\n+    default:\n+      return 0;\n+    }\n \n+  switch (str[3])\n+    {\n+    case '0':\n+      def = 0;\n+      break;\n+    case 'F':\n+      def = -1;\n+      break;\n     default:\n       return 0;\n     }\n \n+  if (GET_MODE_SIZE (mode) <= GET_MODE_SIZE (part_mode))\n+    return 0;\n+\n+  part = s390_single_part (GEN_INT (value), mode, part_mode, def);\n+  if (part < 0)\n+    return 0;\n+  if (part_goal != -1 && part_goal != part)\n+    return 0;\n+\n   return 1;\n }\n \n+\n+/* Returns true if the input parameter VALUE is a float zero.  */\n+\n+int\n+s390_float_const_zero_p (rtx value)\n+{\n+  return (GET_MODE_CLASS (GET_MODE (value)) == MODE_FLOAT\n+\t  && value == CONST0_RTX (GET_MODE (value)));\n+}\n+\n+\n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.  "}, {"sha": "ba7a036e1ec30b3bfddb65c7bdbe22bf29eff1ec", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=cd8dc1f9b90e8a7f8e645a29549696f399d6e9af", "patch": "@@ -481,34 +481,6 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n   : MODE)\n \n \n-/* Define various machine-dependent constraint letters.  */\n-\n-#define REG_CLASS_FROM_LETTER(C)                                        \\\n-  ((C) == 'a' ? ADDR_REGS :                                             \\\n-   (C) == 'd' ? GENERAL_REGS :                                          \\\n-   (C) == 'f' ? FP_REGS :                                               \\\n-   (C) == 'c' ? CC_REGS : \t\t\t\t\t\t\\\n-   (C) == 't' ? ACCESS_REGS : NO_REGS)\n-\n-#define CONST_OK_FOR_CONSTRAINT_P(VALUE, C, STR)                          \\\n-  s390_const_ok_for_constraint_p ((VALUE), (C), (STR))\n-\n-#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(VALUE, C, STR)\t\t\t\\\n-  s390_const_double_ok_for_constraint_p ((VALUE), (C), (STR))\n-\n-#define EXTRA_CONSTRAINT_STR(OP, C, STR)                               \t\\\n-  s390_extra_constraint_str ((OP), (C), (STR))\n-#define EXTRA_MEMORY_CONSTRAINT(C, STR)\t\t\t\t\t\\\n-  ((C) == 'Q' || (C) == 'R' || (C) == 'S' || (C) == 'T' || (C) == 'A')\n-#define EXTRA_ADDRESS_CONSTRAINT(C, STR)\t\t\t\t\\\n-  ((C) == 'U' || (C) == 'W' || (C) == 'Y')\n-\n-#define CONSTRAINT_LEN(C, STR)                                  \t\\\n-  ((C) == 'N' ? 5 : \t                                                \\\n-   (C) == 'O' ? 2 :\t\t\t\t\t\t\t\\\n-   (C) == 'A' ? 2 :\t\t\t\t\t\t\t\\\n-   (C) == 'B' ? 2 : DEFAULT_CONSTRAINT_LEN ((C), (STR)))\n-\n /* Stack layout and calling conventions.  */\n \n /* Our stack grows from higher to lower addresses.  However, local variables"}, {"sha": "23484098f790fa1402f753de02b78306a69822a8", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 5, "deletions": 44, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8dc1f9b90e8a7f8e645a29549696f399d6e9af/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=cd8dc1f9b90e8a7f8e645a29549696f399d6e9af", "patch": "@@ -22,51 +22,9 @@\n ;; 02110-1301, USA.\n \n ;;\n-;; Special constraints for s/390 machine description:\n-;;\n-;;    a -- Any address register from 1 to 15.\n-;;    c -- Condition code register 33.\n-;;    d -- Any register from 0 to 15.\n-;;    f -- Floating point registers.\n-;;    t -- Access registers 36 and 37.\n-;;    G -- Const double zero operand\n-;;    I -- An 8-bit constant (0..255).\n-;;    J -- A 12-bit constant (0..4095).\n-;;    K -- A 16-bit constant (-32768..32767).\n-;;    L -- Value appropriate as displacement.\n-;;         (0..4095) for short displacement\n-;;         (-524288..524287) for long displacement\n-;;    M -- Constant integer with a value of 0x7fffffff.\n-;;    N -- Multiple letter constraint followed by 4 parameter letters.\n-;;         0..9,x:  number of the part counting from most to least significant\n-;;         H,Q:     mode of the part\n-;;         D,S,H:   mode of the containing operand\n-;;         0,F:     value of the other parts (F - all bits set)\n-;;\n-;;         The constraint matches if the specified part of a constant\n-;;         has a value different from its other parts.  If the letter x\n-;;         is specified instead of a part number, the constraint matches\n-;;         if there is any single part with non-default value.\n-;;    O -- Multiple letter constraint followed by 1 parameter.\n-;;         s:  Signed extended immediate value (-2G .. 2G-1).\n-;;         p:  Positive extended immediate value (0 .. 4G-1).\n-;;         n:  Negative extended immediate value (-4G+1 .. -1).\n-;;         These constraints do not accept any operand if the machine does\n-;;         not provide the extended-immediate facility.\n-;;    P -- Any integer constant that can be loaded without literal pool.\n-;;    Q -- Memory reference without index register and with short displacement.\n-;;    R -- Memory reference with index register and short displacement.\n-;;    S -- Memory reference without index register but with long displacement.\n-;;    T -- Memory reference with index register and long displacement.\n-;;    A -- Multiple letter constraint followed by Q, R, S, or T:\n-;;         Offsettable memory reference of type specified by second letter.\n-;;    B -- Multiple letter constraint followed by Q, R, S, or T:\n-;;         Memory reference of the type specified by second letter that\n-;;         does *not* refer to a literal pool entry.\n-;;    U -- Pointer with short displacement.\n-;;    W -- Pointer with long displacement.\n-;;    Y -- Shift count operand.\n+;; See constraints.md for a description of constraints specific to s390.\n ;;\n+\n ;; Special formats used for outputting 390 instructions.\n ;;\n ;;     %C: print opcode suffix for branch condition.\n@@ -243,6 +201,9 @@\n ;; Predicates\n (include \"predicates.md\")\n \n+;; Constraint definitions\n+(include \"constraints.md\")\n+\n ;; Other includes\n (include \"tpf.md\")\n "}]}