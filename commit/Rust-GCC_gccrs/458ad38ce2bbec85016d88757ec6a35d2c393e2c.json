{"sha": "458ad38ce2bbec85016d88757ec6a35d2c393e2c", "node_id": "C_kwDOANBUbNoAKDQ1OGFkMzhjZTJiYmVjODUwMTZkODg3NTdlYzZhMzVkMmMzOTNlMmM", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-04T18:51:14Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-04T18:51:14Z"}, "message": "analyzer: reduce svalue depth limit from 13 to 12 [PR103521]\n\nPR analyzer/103521 reports that commit r12-5585-g132902177138c09803d639e12b1daebf2b9edddc\n(\"analyzer: further false leak fixes due to overzealous state merging [PR103217]\")\nled to failures of gcc.dg/analyzer/pr93032-mztools.c on some targets,\nwhere rather than reporting FILE * leaks, the analyzer would hit\ncomplexity limits and give up.\n\nThe cause is that pr93032-mztools.c has some 'unsigned char' values that\nare copied to 'char'.  On targets where 'char' defaults to being signed,\nthis leads to casts, whereas on targets where 'char' defaults to being\nunsigned, no casts are needed.\n\nWhen the casts occur, various symbolic values within the loop (the\nlocals 'crc', 'cpsize', and 'uncpsize') become sufficiently complex as\nto hit the --param=analyzer-max-svalue-depth= limit, and are treated as\nUNKNOWN, allowing the analysis of the loop to quickly terminate, with\nmuch of this state as UNKNOWN (but retaining the FILE * information, and\nthus correctly reporting the FILE * leaks).\n\nWithout the casts, the symbolic values for these variables don't quite\nhit the complexity limit, and the analyzer attempts to track these\nvalues in the loop, leading to the analyzer eventually hitting the\nper-program-point limit on the number of states, and giving up on\nthese execution paths, thus failing to report the FILE * leaks.\n\nThis patch tweaks the default value of the param:\n  --param=analyzer-max-svalue-depth=.\nfrom 13 down to 12.  This allows the pr93032-mztools.c testcase to\nsucceeed with both -fsigned-char and -funsigned-char, and thus allows\nthis integration test to succeed on both styles of target without\nrequiring extra command-line flags.  The patch duplicates the test so\nit runs with both -fsigned-char and -funsigned-char.\n\nMy hope is that this will allow similar cases to terminate loop analysis\nearlier.  I tried reducing it further, but doing so caused some test\ncases to regress.\n\nThe tradeoff here is between:\n(a) precision of individual states in the analysis, versus\n(b) maximizing code-path coverage in the analysis\n\nI can imagine a more nuanced approach that splits the current\nper-program-point hard limit into soft and hard limits: on hitting the\nsoft limit at a program point, go into a less precise mode for states\nat that program point, in the hope that we can fully explore execution\npaths beyond it without hitting the hard limit, but this seems like\nGCC 13 material.\n\nAnother possible future fix might be for the analysis plan to make an\nattempt to prioritize parts of the code in an enode budget, rather than\nsetting the same hard limit uniformly across all program points.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/103521\n\t* analyzer.opt (-param=analyzer-max-svalue-depth=): Reduce from 13\n\tto 12.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/103521\n\t* gcc.dg/analyzer/pr93032-mztools.c: Move to...\n\t* gcc.dg/analyzer/pr93032-mztools-signed-char.c: ...this, adding\n\t-fsigned-char to args, and...\n\t* gcc.dg/analyzer/pr93032-mztools-unsigned-char.c: ...copy to here,\n\tadding -funsigned-char to args.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "eb274cae2398784c882c20f8d57a97a2cabd79a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb274cae2398784c882c20f8d57a97a2cabd79a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/458ad38ce2bbec85016d88757ec6a35d2c393e2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/458ad38ce2bbec85016d88757ec6a35d2c393e2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/458ad38ce2bbec85016d88757ec6a35d2c393e2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/458ad38ce2bbec85016d88757ec6a35d2c393e2c/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3402486afa8b6f98d6b0cc05cd229526bc7611f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3402486afa8b6f98d6b0cc05cd229526bc7611f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3402486afa8b6f98d6b0cc05cd229526bc7611f"}], "stats": {"total": 335, "additions": 334, "deletions": 1}, "files": [{"sha": "b9d2ece273ce0c1bb8f13d9745f05b1ba441bbfe", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458ad38ce2bbec85016d88757ec6a35d2c393e2c/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458ad38ce2bbec85016d88757ec6a35d2c393e2c/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=458ad38ce2bbec85016d88757ec6a35d2c393e2c", "patch": "@@ -43,7 +43,7 @@ Common Joined UInteger Var(param_analyzer_max_recursion_depth) Init(2) Param\n The maximum number of times a callsite can appear in a call stack within the analyzer, before terminating analysis of a call that would recurse deeper.\n \n -param=analyzer-max-svalue-depth=\n-Common Joined UInteger Var(param_analyzer_max_svalue_depth) Init(13) Param\n+Common Joined UInteger Var(param_analyzer_max_svalue_depth) Init(12) Param\n The maximum depth of a symbolic value, before approximating the value as unknown.\n \n -param=analyzer-min-snodes-for-call-summary="}, {"sha": "1f3df7c211f425fdccd3d944152711871d97645a", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93032-mztools-signed-char.c", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458ad38ce2bbec85016d88757ec6a35d2c393e2c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93032-mztools-signed-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458ad38ce2bbec85016d88757ec6a35d2c393e2c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93032-mztools-signed-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93032-mztools-signed-char.c?ref=458ad38ce2bbec85016d88757ec6a35d2c393e2c", "patch": "@@ -4,6 +4,7 @@\n    removed.  */\n \n /* { dg-do \"compile\" } */\n+/* { dg-additional-options \"-fsigned-char\" } */\n \n /* Minimal replacement of system headers.  */\n ", "previous_filename": "gcc/testsuite/gcc.dg/analyzer/pr93032-mztools.c"}, {"sha": "db9678d1caa9102e6e6853e5b450976b91110beb", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93032-mztools-unsigned-char.c", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458ad38ce2bbec85016d88757ec6a35d2c393e2c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93032-mztools-unsigned-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458ad38ce2bbec85016d88757ec6a35d2c393e2c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93032-mztools-unsigned-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93032-mztools-unsigned-char.c?ref=458ad38ce2bbec85016d88757ec6a35d2c393e2c", "patch": "@@ -0,0 +1,332 @@\n+/* Integration test to ensure we issue FILE * leak diagnostics for\n+   this particular non-trivial case.\n+   Adapted from zlib/contrib/minizip/mztools.c, with all #includes\n+   removed.  */\n+\n+/* { dg-do \"compile\" } */\n+/* { dg-additional-options \"-funsigned-char\" } */\n+\n+/* Minimal replacement of system headers.  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+#define NULL ((void *) 0)\n+\n+typedef struct _IO_FILE FILE;\n+extern FILE *fopen(const char *__restrict __filename,\n+\t\t   const char *__restrict __modes);\n+extern size_t fread (void *__restrict __ptr, size_t __size,\n+\t\t     size_t __n, FILE *__restrict __stream);\n+extern size_t fwrite (const void *__restrict __ptr, size_t __size,\n+\t\t      size_t __n, FILE *__restrict __s);\n+extern int fclose (FILE *__stream);\n+extern int remove (const char *__filename)\n+  __attribute__ ((__nothrow__ , __leaf__));\n+\n+extern void *malloc (size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__malloc__));\n+extern void free (void *__ptr)\n+  __attribute__ ((__nothrow__ , __leaf__));\n+\n+extern size_t strlen (const char *__s)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__pure__))\n+  __attribute__ ((__nonnull__ (1)));\n+\n+/* Minimal replacement of zlib headers.  */\n+\n+#define ZEXPORT\n+typedef unsigned long  uLong; /* 32 bits or more */\n+#define Z_OK            0\n+#define Z_ERRNO        (-1)\n+#define Z_STREAM_ERROR (-2)\n+#define Z_MEM_ERROR    (-4)\n+\n+/*\n+  Additional tools for Minizip\n+  Code: Xavier Roche '2004\n+  License: Same as ZLIB (www.gzip.org)\n+*/\n+\n+/* Code */\n+\n+#define READ_8(adr)  ((unsigned char)*(adr))\n+#define READ_16(adr) ( READ_8(adr) | (READ_8(adr+1) << 8) )\n+#define READ_32(adr) ( READ_16(adr) | (READ_16((adr)+2) << 16) )\n+\n+#define WRITE_8(buff, n) do { \\\n+  *((unsigned char*)(buff)) = (unsigned char) ((n) & 0xff); \\\n+} while(0)\n+#define WRITE_16(buff, n) do { \\\n+  WRITE_8((unsigned char*)(buff), n); \\\n+  WRITE_8(((unsigned char*)(buff)) + 1, (n) >> 8); \\\n+} while(0)\n+#define WRITE_32(buff, n) do { \\\n+  WRITE_16((unsigned char*)(buff), (n) & 0xffff); \\\n+  WRITE_16((unsigned char*)(buff) + 2, (n) >> 16); \\\n+} while(0)\n+\n+extern int ZEXPORT unzRepair(file, fileOut, fileOutTmp, nRecovered, bytesRecovered)\n+const char* file;\n+const char* fileOut;\n+const char* fileOutTmp;\n+uLong* nRecovered;\n+uLong* bytesRecovered;\n+{\n+  int err = Z_OK;\n+  FILE* fpZip = fopen(file, \"rb\");\n+  FILE* fpOut = fopen(fileOut, \"wb\");\n+  FILE* fpOutCD = fopen(fileOutTmp, \"wb\");\n+  if (fpZip != NULL && fpOut != NULL) {\n+    int entries = 0;\n+    uLong totalBytes = 0;\n+    char header[30];\n+    char filename[1024];\n+    char extra[1024];\n+    int offset = 0;\n+    int offsetCD = 0;\n+    while ( fread(header, 1, 30, fpZip) == 30 ) {\n+      int currentOffset = offset;\n+\n+      /* File entry */\n+      if (READ_32(header) == 0x04034b50) {\n+        unsigned int version = READ_16(header + 4);\n+        unsigned int gpflag = READ_16(header + 6);\n+        unsigned int method = READ_16(header + 8);\n+        unsigned int filetime = READ_16(header + 10);\n+        unsigned int filedate = READ_16(header + 12);\n+        unsigned int crc = READ_32(header + 14); /* crc */\n+        unsigned int cpsize = READ_32(header + 18); /* compressed size */\n+        unsigned int uncpsize = READ_32(header + 22); /* uncompressed sz */\n+        unsigned int fnsize = READ_16(header + 26); /* file name length */\n+        unsigned int extsize = READ_16(header + 28); /* extra field length */\n+        filename[0] = extra[0] = '\\0';\n+\n+        /* Header */\n+        if (fwrite(header, 1, 30, fpOut) == 30) {\n+          offset += 30;\n+        } else {\n+          err = Z_ERRNO;\n+          break;\n+        }\n+\n+        /* Filename */\n+        if (fnsize > 0) {\n+          if (fnsize < sizeof(filename)) {\n+            if (fread(filename, 1, fnsize, fpZip) == fnsize) {\n+                if (fwrite(filename, 1, fnsize, fpOut) == fnsize) {\n+                offset += fnsize;\n+              } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            } else {\n+              err = Z_ERRNO;\n+              break;\n+            }\n+          } else {\n+            err = Z_ERRNO;\n+            break;\n+          }\n+        } else {\n+          err = Z_STREAM_ERROR;\n+          break;\n+        }\n+\n+        /* Extra field */\n+        if (extsize > 0) {\n+          if (extsize < sizeof(extra)) {\n+            if (fread(extra, 1, extsize, fpZip) == extsize) {\n+              if (fwrite(extra, 1, extsize, fpOut) == extsize) {\n+                offset += extsize;\n+                } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            } else {\n+              err = Z_ERRNO;\n+              break;\n+            }\n+          } else {\n+            err = Z_ERRNO;\n+            break;\n+          }\n+        }\n+\n+        /* Data */\n+        {\n+          int dataSize = cpsize;\n+          if (dataSize == 0) {\n+            dataSize = uncpsize;\n+          }\n+          if (dataSize > 0) {\n+            char* data = malloc(dataSize);\n+            if (data != NULL) {\n+              if ((int)fread(data, 1, dataSize, fpZip) == dataSize) {\n+                if ((int)fwrite(data, 1, dataSize, fpOut) == dataSize) {\n+                  offset += dataSize;\n+                  totalBytes += dataSize;\n+                } else {\n+                  err = Z_ERRNO;\n+                }\n+              } else {\n+                err = Z_ERRNO;\n+              }\n+              free(data);\n+              if (err != Z_OK) {\n+                break;\n+              }\n+            } else {\n+              err = Z_MEM_ERROR;\n+              break;\n+            }\n+          }\n+        }\n+\n+        /* Central directory entry */\n+        {\n+          char header[46];\n+          char* comment = \"\";\n+          int comsize = (int) strlen(comment);\n+          WRITE_32(header, 0x02014b50);\n+          WRITE_16(header + 4, version);\n+          WRITE_16(header + 6, version);\n+          WRITE_16(header + 8, gpflag);\n+          WRITE_16(header + 10, method);\n+          WRITE_16(header + 12, filetime);\n+          WRITE_16(header + 14, filedate);\n+          WRITE_32(header + 16, crc);\n+          WRITE_32(header + 20, cpsize);\n+          WRITE_32(header + 24, uncpsize);\n+          WRITE_16(header + 28, fnsize);\n+          WRITE_16(header + 30, extsize);\n+          WRITE_16(header + 32, comsize);\n+          WRITE_16(header + 34, 0);     /* disk # */\n+          WRITE_16(header + 36, 0);     /* int attrb */\n+          WRITE_32(header + 38, 0);     /* ext attrb */\n+          WRITE_32(header + 42, currentOffset);\n+          /* Header */\n+          if (fwrite(header, 1, 46, fpOutCD) == 46) {\n+            offsetCD += 46;\n+\n+            /* Filename */\n+            if (fnsize > 0) {\n+              if (fwrite(filename, 1, fnsize, fpOutCD) == fnsize) {\n+                offsetCD += fnsize;\n+              } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            } else {\n+              err = Z_STREAM_ERROR;\n+              break;\n+            }\n+\n+            /* Extra field */\n+            if (extsize > 0) {\n+              if (fwrite(extra, 1, extsize, fpOutCD) == extsize) {\n+                offsetCD += extsize;\n+              } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            }\n+\n+            /* Comment field */\n+            if (comsize > 0) {\n+              if ((int)fwrite(comment, 1, comsize, fpOutCD) == comsize) {\n+                offsetCD += comsize;\n+              } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            }\n+\n+\n+          } else {\n+            err = Z_ERRNO;\n+            break;\n+          }\n+        }\n+\n+        /* Success */\n+        entries++;\n+\n+      } else {\n+        break;\n+      }\n+    }\n+\n+    /* Final central directory  */\n+    {\n+      int entriesZip = entries;\n+      char header[22];\n+      char* comment = \"\"; // \"ZIP File recovered by zlib/minizip/mztools\";\n+      int comsize = (int) strlen(comment);\n+      if (entriesZip > 0xffff) {\n+        entriesZip = 0xffff;\n+      }\n+      WRITE_32(header, 0x06054b50);\n+      WRITE_16(header + 4, 0);    /* disk # */\n+      WRITE_16(header + 6, 0);    /* disk # */\n+      WRITE_16(header + 8, entriesZip);   /* hack */\n+      WRITE_16(header + 10, entriesZip);  /* hack */\n+      WRITE_32(header + 12, offsetCD);    /* size of CD */\n+      WRITE_32(header + 16, offset);      /* offset to CD */\n+      WRITE_16(header + 20, comsize);     /* comment */\n+\n+      /* Header */\n+      if (fwrite(header, 1, 22, fpOutCD) == 22) {\n+\n+        /* Comment field */\n+        if (comsize > 0) {\n+          if ((int)fwrite(comment, 1, comsize, fpOutCD) != comsize) {\n+            err = Z_ERRNO;\n+          }\n+        }\n+\n+      } else {\n+        err = Z_ERRNO;\n+      }\n+    }\n+\n+    /* Final merge (file + central directory) */\n+    fclose(fpOutCD);\n+    if (err == Z_OK) {\n+      fpOutCD = fopen(fileOutTmp, \"rb\");\n+      if (fpOutCD != NULL) {\n+        int nRead;\n+        char buffer[8192];\n+        while ( (nRead = (int)fread(buffer, 1, sizeof(buffer), fpOutCD)) > 0) {\n+          if ((int)fwrite(buffer, 1, nRead, fpOut) != nRead) {\n+            err = Z_ERRNO;\n+            break;\n+          }\n+        }\n+        fclose(fpOutCD);\n+      }\n+    }\n+\n+    /* Close */\n+    fclose(fpZip);\n+    fclose(fpOut);\n+\n+    /* Wipe temporary file */\n+    (void)remove(fileOutTmp);\n+\n+    /* Number of recovered entries */\n+    if (err == Z_OK) {\n+      if (nRecovered != NULL) {\n+        *nRecovered = entries;\n+      }\n+      if (bytesRecovered != NULL) {\n+        *bytesRecovered = totalBytes;\n+      }\n+    }\n+  } else {\n+    err = Z_STREAM_ERROR;\n+  }\n+  return err; /* { dg-warning \"leak of FILE 'fpZip'\" \"leak of fpZip\" } */\n+  /* { dg-warning \"leak of FILE 'fpOut'\" \"leak of fpOut\" { target *-*-* } .-1 } */\n+  /* { dg-warning \"leak of FILE 'fpOutCD'\" \"leak of fpOutCD\" { target *-*-* } .-2 } */\n+}"}]}