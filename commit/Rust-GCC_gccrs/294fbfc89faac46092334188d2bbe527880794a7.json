{"sha": "294fbfc89faac46092334188d2bbe527880794a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk0ZmJmYzg5ZmFhYzQ2MDkyMzM0MTg4ZDJiYmU1Mjc4ODA3OTRhNw==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-08-29T16:58:39Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-08-29T16:58:39Z"}, "message": "re PR fortran/13910 (Cannot initialize variables with declation as allowed by g77)\n\nfortran/\nPR fortran/13910\n* decl.c (free_variable, free_value, gfc_free_data, var_list,\nvar_element, top_var_list, match_data_constant, top_val_list,\ngfc_match_data): Move here from match.c.\n(match_old_style_init): New function.\n(variable_decl): Match old-style initialization.\n* expr.c (gfc_get_variable_expr): New function.\n* gfortran.h (gfc_get_variable_expr): Add prototype.\n* gfortran.texi: Start documentation for supported extensions.\n* match.c: Remove the functions moved to decl.c.\n* match.h (gfc_match_data): Move prototype to under decl.c.\n* symbol.c (gfc_find_sym_tree, gfc_find_symbol): Add/correct\ncomments.\n\ntestsuite/\nPR fortran/13910\n* gfortran.dg/oldstyle_1.f90: New test.\n\nFrom-SVN: r86729", "tree": {"sha": "7bdfd86accd5c303039855aeeec2bd0434510805", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bdfd86accd5c303039855aeeec2bd0434510805"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/294fbfc89faac46092334188d2bbe527880794a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/294fbfc89faac46092334188d2bbe527880794a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/294fbfc89faac46092334188d2bbe527880794a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/294fbfc89faac46092334188d2bbe527880794a7/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "048c989961b261b522d1af001cec42518361e36b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/048c989961b261b522d1af001cec42518361e36b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/048c989961b261b522d1af001cec42518361e36b"}], "stats": {"total": 912, "additions": 551, "deletions": 361}, "files": [{"sha": "d1f3edb2b8f4e517dbf28df5d4647dd4783d6589", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=294fbfc89faac46092334188d2bbe527880794a7", "patch": "@@ -1,3 +1,19 @@\n+2004-08-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/13910\n+\t* decl.c (free_variable, free_value, gfc_free_data, var_list,\n+\tvar_element, top_var_list, match_data_constant, top_val_list,\n+\tgfc_match_data): Move here from match.c.\n+\t(match_old_style_init): New function.\n+\t(variable_decl): Match old-style initialization.\n+\t* expr.c (gfc_get_variable_expr): New function.\n+\t* gfortran.h (gfc_get_variable_expr): Add prototype.\n+\t* gfortran.texi: Start documentation for supported extensions.\n+\t* match.c: Remove the functions moved to decl.c.\n+\t* match.h (gfc_match_data): Move prototype to under decl.c.\n+\t* symbol.c (gfc_find_sym_tree, gfc_find_symbol): Add/correct\n+\tcomments.\n+\n 2004-08-29  Steven G. Kargl  <kargls@comcast.net>\n \tPaul Brook  <paul@codesourcery.com>\n "}, {"sha": "a3aa28b06dfa1b9f4335ba9c980f1ca7cf88b48d", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 417, "deletions": 0, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=294fbfc89faac46092334188d2bbe527880794a7", "patch": "@@ -48,6 +48,405 @@ static int colon_seen;\n gfc_symbol *gfc_new_block;\n \n \n+/********************* DATA statement subroutines *********************/\n+\n+/* Free a gfc_data_variable structure and everything beneath it.  */\n+\n+static void\n+free_variable (gfc_data_variable * p)\n+{\n+  gfc_data_variable *q;\n+\n+  for (; p; p = q)\n+    {\n+      q = p->next;\n+      gfc_free_expr (p->expr);\n+      gfc_free_iterator (&p->iter, 0);\n+      free_variable (p->list);\n+\n+      gfc_free (p);\n+    }\n+}\n+\n+\n+/* Free a gfc_data_value structure and everything beneath it.  */\n+\n+static void\n+free_value (gfc_data_value * p)\n+{\n+  gfc_data_value *q;\n+\n+  for (; p; p = q)\n+    {\n+      q = p->next;\n+      gfc_free_expr (p->expr);\n+      gfc_free (p);\n+    }\n+}\n+\n+\n+/* Free a list of gfc_data structures.  */\n+\n+void\n+gfc_free_data (gfc_data * p)\n+{\n+  gfc_data *q;\n+\n+  for (; p; p = q)\n+    {\n+      q = p->next;\n+\n+      free_variable (p->var);\n+      free_value (p->value);\n+\n+      gfc_free (p);\n+    }\n+}\n+\n+\n+static match var_element (gfc_data_variable *);\n+\n+/* Match a list of variables terminated by an iterator and a right\n+   parenthesis.  */\n+\n+static match\n+var_list (gfc_data_variable * parent)\n+{\n+  gfc_data_variable *tail, var;\n+  match m;\n+\n+  m = var_element (&var);\n+  if (m == MATCH_ERROR)\n+    return MATCH_ERROR;\n+  if (m == MATCH_NO)\n+    goto syntax;\n+\n+  tail = gfc_get_data_variable ();\n+  *tail = var;\n+\n+  parent->list = tail;\n+\n+  for (;;)\n+    {\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+\n+      m = gfc_match_iterator (&parent->iter, 1);\n+      if (m == MATCH_YES)\n+\tbreak;\n+      if (m == MATCH_ERROR)\n+\treturn MATCH_ERROR;\n+\n+      m = var_element (&var);\n+      if (m == MATCH_ERROR)\n+\treturn MATCH_ERROR;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+\n+      tail->next = gfc_get_data_variable ();\n+      tail = tail->next;\n+\n+      *tail = var;\n+    }\n+\n+  if (gfc_match_char (')') != MATCH_YES)\n+    goto syntax;\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (ST_DATA);\n+  return MATCH_ERROR;\n+}\n+\n+\n+/* Match a single element in a data variable list, which can be a\n+   variable-iterator list.  */\n+\n+static match\n+var_element (gfc_data_variable * new)\n+{\n+  match m;\n+  gfc_symbol *sym;\n+\n+  memset (new, 0, sizeof (gfc_data_variable));\n+\n+  if (gfc_match_char ('(') == MATCH_YES)\n+    return var_list (new);\n+\n+  m = gfc_match_variable (&new->expr, 0);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  sym = new->expr->symtree->n.sym;\n+\n+  if(sym->value != NULL)\n+    {\n+      gfc_error (\"Variable '%s' at %C already has an initialization\",\n+\t\t sym->name);\n+      return MATCH_ERROR;\n+    }\n+\n+#if 0 // TODO: Find out where to move this message\n+  if (sym->attr.in_common)\n+    /* See if sym is in the blank common block.  */\n+    for (t = &sym->ns->blank_common; t; t = t->common_next)\n+      if (sym == t->head)\n+\t{\n+\t  gfc_error (\"DATA statement at %C may not initialize variable \"\n+\t\t     \"'%s' from blank COMMON\", sym->name);\n+\t  return MATCH_ERROR;\n+\t}\n+#endif\n+\n+  if (gfc_add_data (&sym->attr, &new->expr->where) == FAILURE)\n+    return MATCH_ERROR;\n+\n+  return MATCH_YES;\n+}\n+\n+\n+/* Match the top-level list of data variables.  */\n+\n+static match\n+top_var_list (gfc_data * d)\n+{\n+  gfc_data_variable var, *tail, *new;\n+  match m;\n+\n+  tail = NULL;\n+\n+  for (;;)\n+    {\n+      m = var_element (&var);\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+      if (m == MATCH_ERROR)\n+\treturn MATCH_ERROR;\n+\n+      new = gfc_get_data_variable ();\n+      *new = var;\n+\n+      if (tail == NULL)\n+\td->var = new;\n+      else\n+\ttail->next = new;\n+\n+      tail = new;\n+\n+      if (gfc_match_char ('/') == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (ST_DATA);\n+  return MATCH_ERROR;\n+}\n+\n+\n+static match\n+match_data_constant (gfc_expr ** result)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  gfc_symbol *sym;\n+  gfc_expr *expr;\n+  match m;\n+\n+  m = gfc_match_literal_constant (&expr, 1);\n+  if (m == MATCH_YES)\n+    {\n+      *result = expr;\n+      return MATCH_YES;\n+    }\n+\n+  if (m == MATCH_ERROR)\n+    return MATCH_ERROR;\n+\n+  m = gfc_match_null (result);\n+  if (m != MATCH_NO)\n+    return m;\n+\n+  m = gfc_match_name (name);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  if (gfc_find_symbol (name, NULL, 1, &sym))\n+    return MATCH_ERROR;\n+\n+  if (sym == NULL\n+      || (sym->attr.flavor != FL_PARAMETER && sym->attr.flavor != FL_DERIVED))\n+    {\n+      gfc_error (\"Symbol '%s' must be a PARAMETER in DATA statement at %C\",\n+\t\t name);\n+      return MATCH_ERROR;\n+    }\n+  else if (sym->attr.flavor == FL_DERIVED)\n+    return gfc_match_structure_constructor (sym, result);\n+\n+  *result = gfc_copy_expr (sym->value);\n+  return MATCH_YES;\n+}\n+\n+\n+/* Match a list of values in a DATA statement.  The leading '/' has\n+   already been seen at this point.  */\n+\n+static match\n+top_val_list (gfc_data * data)\n+{\n+  gfc_data_value *new, *tail;\n+  gfc_expr *expr;\n+  const char *msg;\n+  match m;\n+\n+  tail = NULL;\n+\n+  for (;;)\n+    {\n+      m = match_data_constant (&expr);\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+      if (m == MATCH_ERROR)\n+\treturn MATCH_ERROR;\n+\n+      new = gfc_get_data_value ();\n+\n+      if (tail == NULL)\n+\tdata->value = new;\n+      else\n+\ttail->next = new;\n+\n+      tail = new;\n+\n+      if (expr->ts.type != BT_INTEGER || gfc_match_char ('*') != MATCH_YES)\n+\t{\n+\t  tail->expr = expr;\n+\t  tail->repeat = 1;\n+\t}\n+      else\n+\t{\n+\t  signed int tmp;\n+\t  msg = gfc_extract_int (expr, &tmp);\n+\t  gfc_free_expr (expr);\n+\t  if (msg != NULL)\n+\t    {\n+\t      gfc_error (msg);\n+\t      return MATCH_ERROR;\n+\t    }\n+\t  tail->repeat = tmp;\n+\n+\t  m = match_data_constant (&tail->expr);\n+\t  if (m == MATCH_NO)\n+\t    goto syntax;\n+\t  if (m == MATCH_ERROR)\n+\t    return MATCH_ERROR;\n+\t}\n+\n+      if (gfc_match_char ('/') == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') == MATCH_NO)\n+\tgoto syntax;\n+    }\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (ST_DATA);\n+  return MATCH_ERROR;\n+}\n+\n+\n+/* Matches an old style initialization.  */\n+\n+static match\n+match_old_style_init (const char *name)\n+{\n+  match m;\n+  gfc_symtree *st;\n+  gfc_data *newdata;\n+\n+  /* Set up data structure to hold initializers.  */\n+  gfc_find_sym_tree (name, NULL, 0, &st);\n+\t  \n+  newdata = gfc_get_data ();\n+  newdata->var = gfc_get_data_variable ();\n+  newdata->var->expr = gfc_get_variable_expr (st);\n+\n+  /* Match initial value list. This also eats the terminal\n+     '/'.  */\n+  m = top_val_list (newdata);\n+  if (m != MATCH_YES)\n+    {\n+      gfc_free (newdata);\n+      return m;\n+    }\n+\n+  if (gfc_pure (NULL))\n+    {\n+      gfc_error (\"Initialization at %C is not allowed in a PURE procedure\");\n+      gfc_free (newdata);\n+      return MATCH_ERROR;\n+    }\n+\n+  /* Chain in namespace list of DATA initializers.  */\n+  newdata->next = gfc_current_ns->data;\n+  gfc_current_ns->data = newdata;\n+\n+  return m;\n+}\n+\n+/* Match the stuff following a DATA statement. If ERROR_FLAG is set,\n+   we are matching a DATA stement and are therefore issuing an error\n+   if we encounter something unexpected, if not, we're trying to match \n+   an old-style intialization expression of the form INTEGER I /2/.   */\n+\n+match\n+gfc_match_data (void)\n+{\n+  gfc_data *new;\n+  match m;\n+\n+  for (;;)\n+    {\n+      new = gfc_get_data ();\n+      new->where = gfc_current_locus;\n+\n+      m = top_var_list (new);\n+      if (m != MATCH_YES)\n+\tgoto cleanup;\n+\n+      m = top_val_list (new);\n+      if (m != MATCH_YES)\n+\tgoto cleanup;\n+\n+      new->next = gfc_current_ns->data;\n+      gfc_current_ns->data = new;\n+\n+      if (gfc_match_eos () == MATCH_YES)\n+\tbreak;\n+\n+      gfc_match_char (',');\t/* Optional comma */\n+    }\n+\n+  if (gfc_pure (NULL))\n+    {\n+      gfc_error (\"DATA statement at %C is not allowed in a PURE procedure\");\n+      return MATCH_ERROR;\n+    }\n+\n+  return MATCH_YES;\n+\n+cleanup:\n+  gfc_free_data (new);\n+  return MATCH_ERROR;\n+}\n+\n+\n+/************************ Declaration statements *********************/\n+\n /* Match an intent specification.  Since this can only happen after an\n    INTENT word, a legal intent-spec must follow.  */\n \n@@ -524,6 +923,24 @@ variable_decl (void)\n       goto cleanup;\n     }\n \n+  /* We allow old-style initializations of the form\n+       integer i /2/, j(4) /3*3, 1/\n+     (if no colon has been seen). These are different from data\n+     statements in that initializers are only allowed to apply to the\n+     variable immediately preceding, i.e.\n+       integer i, j /1, 2/\n+     is not allowed. Therefore we have to do some work manually, that\n+     could otherwise be let to the matchers for DATA statements.  */\n+\n+  if (!colon_seen && gfc_match (\" /\") == MATCH_YES)\n+    {\n+      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Old-style \"\n+\t\t\t  \"initialization at %C\") == FAILURE)\n+\treturn MATCH_ERROR;\n+     \n+      return match_old_style_init (name);\n+    }\n+\n   /* The double colon must be present in order to have initializers.\n      Otherwise the statement is ambiguous with an assignment statement.  */\n   if (colon_seen)"}, {"sha": "ab830645074ca1ac7343d6754adad6017ca26238", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=294fbfc89faac46092334188d2bbe527880794a7", "patch": "@@ -1983,3 +1983,30 @@ gfc_default_initializer (gfc_typespec *ts)\n     }\n   return init;\n }\n+\n+\n+/* Given a symbol, create an expression node with that symbol as a\n+   variable. If the symbol is array valued, setup a reference of the\n+   whole array.  */\n+\n+gfc_expr *\n+gfc_get_variable_expr (gfc_symtree * var)\n+{\n+  gfc_expr *e;\n+\n+  e = gfc_get_expr ();\n+  e->expr_type = EXPR_VARIABLE;\n+  e->symtree = var;\n+  e->ts = var->n.sym->ts;\n+\n+  if (var->n.sym->as != NULL)\n+    {\n+      e->rank = var->n.sym->as->rank;\n+      e->ref = gfc_get_ref ();\n+      e->ref->type = REF_ARRAY;\n+      e->ref->u.ar.type = AR_FULL;\n+    }\n+\n+  return e;\n+}\n+"}, {"sha": "3c5e69a906bbe9ae75c22e580cb6fdff135d9694", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=294fbfc89faac46092334188d2bbe527880794a7", "patch": "@@ -789,6 +789,8 @@ typedef struct gfc_namespace\n   gfc_access default_access, operator_access[GFC_INTRINSIC_OPS];\n \n   gfc_st_label *st_labels;\n+  /* This list holds information about all the data initializers in\n+     this namespace.  */\n   struct gfc_data *data;\n \n   gfc_charlen *cl_list;\n@@ -1688,6 +1690,8 @@ try gfc_check_pointer_assign (gfc_expr *, gfc_expr *);\n try gfc_check_assign_symbol (gfc_symbol *, gfc_expr *);\n \n gfc_expr *gfc_default_initializer (gfc_typespec *);\n+gfc_expr *gfc_get_variable_expr (gfc_symtree *);\n+\n \n /* st.c */\n extern gfc_code new_st;"}, {"sha": "8f6c0e6ecf4237148cc21207be40bd205fdfdd17", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=294fbfc89faac46092334188d2bbe527880794a7", "patch": "@@ -128,9 +128,10 @@ not accurately reflect the status of the most recent @command{gfortran}.\n * GFORTRAN and GCC::\t    You can compile Fortran, C, or other programs.\n * GFORTRAN and G77::     Why we choose to start from scratch.\n * Invoking GFORTRAN::    Command options supported by @command{gfortran}.\n-* Project Status::  Status of GFORTRAN, Roadmap, proposed extensions.\n+* Project Status::  Status of @command{gfortran}, Roadmap, proposed extensions.\n * Contributing::    Helping you can help.\n-* Standards::\t    Standards supported by GFORTRAN.\n+* Standards::\t    Standards supported by @command{gfortran}\n+* Extensions::      Laguage extensions implemented by @command{gfortran}\n * Index::\t    Index of this documentation.\n @end menu\n \n@@ -608,7 +609,71 @@ Variable for swapping endianness during unformatted read.\n Variable for swapping Endianness during unformatted write.\n @end itemize\n \n+@c ---------------------------------------------------------------------\n+@c Extensions\n+@c ---------------------------------------------------------------------\n+\n+@c Maybe this chapter should be merged with the 'Standards' section,\n+@c whenever that is written :-)\n+\n+@node Extensions\n+@chapter Extensions\n+@cindex Extension\n+\n+@command{gfortran} implements a number of extensions over standard\n+Fortran. This chapter contains information on their syntax and\n+meaning.\n+\n+@menu\n+* Old-style kind specifications::\n+* Old-style variable initialization::\n+@end menu\n \n+@node Old-style kind specifications\n+@section Old-style kind specifications\n+@cindex Kind specifications\n+\n+@command{gfortran} allows old-style kind specifications in\n+declarations. These look like:\n+@smallexample\n+      TYPESPEC*k x,y,z\n+@end smallexample\n+where @code{TYPESPEC} is a basic type, and where @code{k} is a valid kind\n+number for that type. The statement then declares @code{x}, @code{y}\n+and @code{z} to be of type @code{TYPESPEC} with kind @code{k}. In\n+other words, it is equivalent to the standard conforming declaration\n+@smallexample\n+      TYPESPEC(k) x,y,z\n+@end smallexample\n+\n+@node Old-style variable initialization\n+@section Old-style variable initialization\n+@cindex Initialization\n+\n+@command{gfortran} allows old-style initialization of variables of the\n+form:\n+@smallexample\n+      INTEGER*4 i/1/,j/2/\n+      REAL*8 x(2,2) /3*0.,1./\n+@end smallexample\n+These are only allowed in declarations without double colons\n+(@code{::}), as these were introduced in Fortran 90 which also\n+introduced a new syntax for variable initializations. The syntax for\n+the individual initializers is as for the @code{DATA} statement, but\n+unlike in a @code{DATA} statement, an initializer only applies to the\n+variable immediately preceding. In other words, something like\n+@code{INTEGER I,J/2,3/} is not valid.\n+\n+Examples of standard conforming code equivalent to the above example, are:\n+@smallexample\n+! Fortran 90\n+      INTEGER(4) :: i = 1, j = 2\n+      REAL(8) :: x(2,2) = RESHAPE((/0.,0.,0.,1./),SHAPE(x))\n+! Fortran 77\n+      INTEGER  i, j\n+      DOUBLE PRECISION x(2,2)\n+      DATA i,j,x /1,2,3*0.,1./\n+@end smallexample\n \n @c ---------------------------------------------------------------------\n @c Contributing"}, {"sha": "f9628e8164fedde07f9074e167a81644d1d18830", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 0, "deletions": 355, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=294fbfc89faac46092334188d2bbe527880794a7", "patch": "@@ -2614,361 +2614,6 @@ gfc_match_st_function (void)\n }\n \n \n-/********************* DATA statement subroutines *********************/\n-\n-/* Free a gfc_data_variable structure and everything beneath it.  */\n-\n-static void\n-free_variable (gfc_data_variable * p)\n-{\n-  gfc_data_variable *q;\n-\n-  for (; p; p = q)\n-    {\n-      q = p->next;\n-      gfc_free_expr (p->expr);\n-      gfc_free_iterator (&p->iter, 0);\n-      free_variable (p->list);\n-\n-      gfc_free (p);\n-    }\n-}\n-\n-\n-/* Free a gfc_data_value structure and everything beneath it.  */\n-\n-static void\n-free_value (gfc_data_value * p)\n-{\n-  gfc_data_value *q;\n-\n-  for (; p; p = q)\n-    {\n-      q = p->next;\n-      gfc_free_expr (p->expr);\n-      gfc_free (p);\n-    }\n-}\n-\n-\n-/* Free a list of gfc_data structures.  */\n-\n-void\n-gfc_free_data (gfc_data * p)\n-{\n-  gfc_data *q;\n-\n-  for (; p; p = q)\n-    {\n-      q = p->next;\n-\n-      free_variable (p->var);\n-      free_value (p->value);\n-\n-      gfc_free (p);\n-    }\n-}\n-\n-\n-static match var_element (gfc_data_variable *);\n-\n-/* Match a list of variables terminated by an iterator and a right\n-   parenthesis.  */\n-\n-static match\n-var_list (gfc_data_variable * parent)\n-{\n-  gfc_data_variable *tail, var;\n-  match m;\n-\n-  m = var_element (&var);\n-  if (m == MATCH_ERROR)\n-    return MATCH_ERROR;\n-  if (m == MATCH_NO)\n-    goto syntax;\n-\n-  tail = gfc_get_data_variable ();\n-  *tail = var;\n-\n-  parent->list = tail;\n-\n-  for (;;)\n-    {\n-      if (gfc_match_char (',') != MATCH_YES)\n-\tgoto syntax;\n-\n-      m = gfc_match_iterator (&parent->iter, 1);\n-      if (m == MATCH_YES)\n-\tbreak;\n-      if (m == MATCH_ERROR)\n-\treturn MATCH_ERROR;\n-\n-      m = var_element (&var);\n-      if (m == MATCH_ERROR)\n-\treturn MATCH_ERROR;\n-      if (m == MATCH_NO)\n-\tgoto syntax;\n-\n-      tail->next = gfc_get_data_variable ();\n-      tail = tail->next;\n-\n-      *tail = var;\n-    }\n-\n-  if (gfc_match_char (')') != MATCH_YES)\n-    goto syntax;\n-  return MATCH_YES;\n-\n-syntax:\n-  gfc_syntax_error (ST_DATA);\n-  return MATCH_ERROR;\n-}\n-\n-\n-/* Match a single element in a data variable list, which can be a\n-   variable-iterator list.  */\n-\n-static match\n-var_element (gfc_data_variable * new)\n-{\n-  match m;\n-  gfc_symbol *sym;\n-\n-  memset (new, '\\0', sizeof (gfc_data_variable));\n-\n-  if (gfc_match_char ('(') == MATCH_YES)\n-    return var_list (new);\n-\n-  m = gfc_match_variable (&new->expr, 0);\n-  if (m != MATCH_YES)\n-    return m;\n-\n-  sym = new->expr->symtree->n.sym;\n-\n-  if(sym->value != NULL)\n-    {\n-      gfc_error (\"Variable '%s' at %C already has an initialization\",\n-\t\t sym->name);\n-      return MATCH_ERROR;\n-    }\n-\n-#if 0 // TODO: Find out where to move this message\n-  if (sym->attr.in_common)\n-    /* See if sym is in the blank common block.  */\n-    for (t = &sym->ns->blank_common; t; t = t->common_next)\n-      if (sym == t->head)\n-\t{\n-\t  gfc_error (\"DATA statement at %C may not initialize variable \"\n-\t\t     \"'%s' from blank COMMON\", sym->name);\n-\t  return MATCH_ERROR;\n-\t}\n-#endif\n-\n-  if (gfc_add_data (&sym->attr, &new->expr->where) == FAILURE)\n-    return MATCH_ERROR;\n-\n-  return MATCH_YES;\n-}\n-\n-\n-/* Match the top-level list of data variables.  */\n-\n-static match\n-top_var_list (gfc_data * d)\n-{\n-  gfc_data_variable var, *tail, *new;\n-  match m;\n-\n-  tail = NULL;\n-\n-  for (;;)\n-    {\n-      m = var_element (&var);\n-      if (m == MATCH_NO)\n-\tgoto syntax;\n-      if (m == MATCH_ERROR)\n-\treturn MATCH_ERROR;\n-\n-      new = gfc_get_data_variable ();\n-      *new = var;\n-\n-      if (tail == NULL)\n-\td->var = new;\n-      else\n-\ttail->next = new;\n-\n-      tail = new;\n-\n-      if (gfc_match_char ('/') == MATCH_YES)\n-\tbreak;\n-      if (gfc_match_char (',') != MATCH_YES)\n-\tgoto syntax;\n-    }\n-\n-  return MATCH_YES;\n-\n-syntax:\n-  gfc_syntax_error (ST_DATA);\n-  return MATCH_ERROR;\n-}\n-\n-\n-static match\n-match_data_constant (gfc_expr ** result)\n-{\n-  char name[GFC_MAX_SYMBOL_LEN + 1];\n-  gfc_symbol *sym;\n-  gfc_expr *expr;\n-  match m;\n-\n-  m = gfc_match_literal_constant (&expr, 1);\n-  if (m == MATCH_YES)\n-    {\n-      *result = expr;\n-      return MATCH_YES;\n-    }\n-\n-  if (m == MATCH_ERROR)\n-    return MATCH_ERROR;\n-\n-  m = gfc_match_null (result);\n-  if (m != MATCH_NO)\n-    return m;\n-\n-  m = gfc_match_name (name);\n-  if (m != MATCH_YES)\n-    return m;\n-\n-  if (gfc_find_symbol (name, NULL, 1, &sym))\n-    return MATCH_ERROR;\n-\n-  if (sym == NULL\n-      || (sym->attr.flavor != FL_PARAMETER && sym->attr.flavor != FL_DERIVED))\n-    {\n-      gfc_error (\"Symbol '%s' must be a PARAMETER in DATA statement at %C\",\n-\t\t name);\n-      return MATCH_ERROR;\n-    }\n-  else if (sym->attr.flavor == FL_DERIVED)\n-    return gfc_match_structure_constructor (sym, result);\n-\n-  *result = gfc_copy_expr (sym->value);\n-  return MATCH_YES;\n-}\n-\n-\n-/* Match a list of values in a DATA statement.  The leading '/' has\n-   already been seen at this point.  */\n-\n-static match\n-top_val_list (gfc_data * data)\n-{\n-  gfc_data_value *new, *tail;\n-  gfc_expr *expr;\n-  const char *msg;\n-  match m;\n-\n-  tail = NULL;\n-\n-  for (;;)\n-    {\n-      m = match_data_constant (&expr);\n-      if (m == MATCH_NO)\n-\tgoto syntax;\n-      if (m == MATCH_ERROR)\n-\treturn MATCH_ERROR;\n-\n-      new = gfc_get_data_value ();\n-\n-      if (tail == NULL)\n-\tdata->value = new;\n-      else\n-\ttail->next = new;\n-\n-      tail = new;\n-\n-      if (expr->ts.type != BT_INTEGER || gfc_match_char ('*') != MATCH_YES)\n-\t{\n-\t  tail->expr = expr;\n-\t  tail->repeat = 1;\n-\t}\n-      else\n-\t{\n-\t  signed int tmp;\n-\t  msg = gfc_extract_int (expr, &tmp);\n-\t  gfc_free_expr (expr);\n-\t  if (msg != NULL)\n-\t    {\n-\t      gfc_error (msg);\n-\t      return MATCH_ERROR;\n-\t    }\n-\t  tail->repeat = tmp;\n-\n-\t  m = match_data_constant (&tail->expr);\n-\t  if (m == MATCH_NO)\n-\t    goto syntax;\n-\t  if (m == MATCH_ERROR)\n-\t    return MATCH_ERROR;\n-\t}\n-\n-      if (gfc_match_char ('/') == MATCH_YES)\n-\tbreak;\n-      if (gfc_match_char (',') == MATCH_NO)\n-\tgoto syntax;\n-    }\n-\n-  return MATCH_YES;\n-\n-syntax:\n-  gfc_syntax_error (ST_DATA);\n-  return MATCH_ERROR;\n-}\n-\n-\n-/* Match a DATA statement.  */\n-\n-match\n-gfc_match_data (void)\n-{\n-  gfc_data *new;\n-  match m;\n-\n-  for (;;)\n-    {\n-      new = gfc_get_data ();\n-      new->where = gfc_current_locus;\n-\n-      m = top_var_list (new);\n-      if (m != MATCH_YES)\n-\tgoto cleanup;\n-\n-      m = top_val_list (new);\n-      if (m != MATCH_YES)\n-\tgoto cleanup;\n-\n-      new->next = gfc_current_ns->data;\n-      gfc_current_ns->data = new;\n-\n-      if (gfc_match_eos () == MATCH_YES)\n-\tbreak;\n-\n-      gfc_match_char (',');\t/* Optional comma */\n-    }\n-\n-  if (gfc_pure (NULL))\n-    {\n-      gfc_error (\"DATA statement at %C is not allowed in a PURE procedure\");\n-      return MATCH_ERROR;\n-    }\n-\n-  return MATCH_YES;\n-\n-cleanup:\n-  gfc_free_data (new);\n-  return MATCH_ERROR;\n-}\n-\n-\n /***************** SELECT CASE subroutines ******************/\n \n /* Free a single case structure.  */"}, {"sha": "1d46e85960cdd5d52c5b739af56898e2faa6b2e3", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=294fbfc89faac46092334188d2bbe527880794a7", "patch": "@@ -80,7 +80,6 @@ match gfc_match_namelist (void);\n match gfc_match_module (void);\n match gfc_match_equivalence (void);\n match gfc_match_st_function (void);\n-match gfc_match_data (void);\n match gfc_match_case (void);\n match gfc_match_select (void);\n match gfc_match_where (gfc_statement *);\n@@ -93,6 +92,7 @@ gfc_common_head *gfc_get_common (const char *, int);\n \n /* decl.c */\n \n+match gfc_match_data (void);\n match gfc_match_null (gfc_expr **);\n match gfc_match_kind_spec (gfc_typespec *);\n match gfc_match_old_kind_spec (gfc_typespec *);"}, {"sha": "25419cc212a395267e4c802bfb9e3ee8069a159d", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=294fbfc89faac46092334188d2bbe527880794a7", "patch": "@@ -1763,13 +1763,13 @@ ambiguous_symbol (const char *name, gfc_symtree * st)\n }\n \n \n-/* Search for a symbol starting in the current namespace, resorting to\n+/* Search for a symtree starting in the current namespace, resorting to\n    any parent namespaces if requested by a nonzero parent_flag.\n-   Returns nonzero if the symbol is ambiguous.  */\n+   Returns nonzero if the name is ambiguous.  */\n \n int\n gfc_find_sym_tree (const char *name, gfc_namespace * ns, int parent_flag,\n-\t\t gfc_symtree ** result)\n+\t\t   gfc_symtree ** result)\n {\n   gfc_symtree *st;\n \n@@ -1803,6 +1803,8 @@ gfc_find_sym_tree (const char *name, gfc_namespace * ns, int parent_flag,\n }\n \n \n+/* Same, but returns the symbol instead.  */\n+\n int\n gfc_find_symbol (const char *name, gfc_namespace * ns, int parent_flag,\n \t\t gfc_symbol ** result)"}, {"sha": "ada3528d9e2dfe82502cf1c47037f84d1c9c69bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=294fbfc89faac46092334188d2bbe527880794a7", "patch": "@@ -1,3 +1,8 @@\n+2004-08-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/13910\n+\t* gfortran.dg/oldstyle_1.f90: New test.\n+\n 2004-08-29  Steven G. Kargl  <kargls@comcast.net>\n \tPaul Brook  <paul@codesourcery.com>\n "}, {"sha": "e26c467bf85beddd934b688dae5d85aaf78c0a86", "filename": "gcc/testsuite/gfortran.dg/oldstyle_1.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ftestsuite%2Fgfortran.dg%2Foldstyle_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294fbfc89faac46092334188d2bbe527880794a7/gcc%2Ftestsuite%2Fgfortran.dg%2Foldstyle_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Foldstyle_1.f90?ref=294fbfc89faac46092334188d2bbe527880794a7", "patch": "@@ -0,0 +1,9 @@\n+      integer i, j /1/, g/2/, h ! { dg-warning \"\" \"\" }\n+      integer k, l(3) /2*2,1/   ! { dg-warning \"\" \"\" }\n+      real pi /3.1416/, e       ! { dg-warning \"\" \"\" }\n+\n+      if (j /= 1) call abort ()\n+      if (g /= 2) call abort ()\n+      if (any(l /= (/2,2,1/))) call abort ()\n+      if (pi /= 3.1416) call abort ()\n+      end"}]}