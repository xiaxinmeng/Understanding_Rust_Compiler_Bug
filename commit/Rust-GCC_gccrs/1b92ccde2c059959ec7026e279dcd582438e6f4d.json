{"sha": "1b92ccde2c059959ec7026e279dcd582438e6f4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI5MmNjZGUyYzA1OTk1OWVjNzAyNmUyNzlkY2Q1ODI0MzhlNmY0ZA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-06-07T10:46:21Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-06-07T10:46:21Z"}, "message": "(aff_combination_expand): Move (T1)(X *+- CST) simplification to ...\n\n\t(tree_to_aff_combination): ... here.\n\nFrom-SVN: r248955", "tree": {"sha": "9801edcf834ea82a25604d18148dce5d6da8ee97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9801edcf834ea82a25604d18148dce5d6da8ee97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b92ccde2c059959ec7026e279dcd582438e6f4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b92ccde2c059959ec7026e279dcd582438e6f4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b92ccde2c059959ec7026e279dcd582438e6f4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b92ccde2c059959ec7026e279dcd582438e6f4d/comments", "author": null, "committer": null, "parents": [{"sha": "c18101f5d1d45dd340a753bbb9c51478cfe522d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c18101f5d1d45dd340a753bbb9c51478cfe522d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c18101f5d1d45dd340a753bbb9c51478cfe522d6"}], "stats": {"total": 58, "additions": 36, "deletions": 22}, "files": [{"sha": "4222568edcc4b728316bdcc5a1e614f0dce938cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b92ccde2c059959ec7026e279dcd582438e6f4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b92ccde2c059959ec7026e279dcd582438e6f4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b92ccde2c059959ec7026e279dcd582438e6f4d", "patch": "@@ -1,3 +1,8 @@\n+2017-06-07  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t(aff_combination_expand): Move (T1)(X *+- CST) simplification to ...\n+\t(tree_to_aff_combination): ... here.\n+\n 2017-06-07  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (ivopts_estimate_reg_pressure): New"}, {"sha": "cbe2bdb4b6ac1b8e0979c20da567f563a6092057", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b92ccde2c059959ec7026e279dcd582438e6f4d/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b92ccde2c059959ec7026e279dcd582438e6f4d/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=1b92ccde2c059959ec7026e279dcd582438e6f4d", "patch": "@@ -363,6 +363,33 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n       aff_combination_add (comb, &tmp);\n       return;\n \n+    CASE_CONVERT:\n+      {\n+\ttree otype = TREE_TYPE (expr);\n+\ttree inner = TREE_OPERAND (expr, 0);\n+\ttree itype = TREE_TYPE (inner);\n+\tenum tree_code icode = TREE_CODE (inner);\n+\n+\t/* In principle this is a valid folding, but it isn't necessarily\n+\t   an optimization, so do it here and not in fold_unary.  */\n+\tif ((icode == PLUS_EXPR || icode == MINUS_EXPR || icode == MULT_EXPR)\n+\t    && TREE_CODE (itype) == INTEGER_TYPE\n+\t    && TREE_CODE (otype) == INTEGER_TYPE\n+\t    && TYPE_PRECISION (otype) > TYPE_PRECISION (itype)\n+\t    && TYPE_OVERFLOW_UNDEFINED (itype)\n+\t    && TREE_CODE (TREE_OPERAND (inner, 1)) == INTEGER_CST)\n+\t  {\n+\t    /* Convert (T1)(X *+- CST) into (T1)X *+- (T1)CST if X's type has\n+\t       undefined overflow behavior.  */\n+\t    tree op0 = fold_convert (otype, TREE_OPERAND (inner, 0));\n+\t    tree op1 = fold_convert (otype, TREE_OPERAND (inner, 1));\n+\t    expr = fold_build2 (icode, otype, op0, op1);\n+\t    tree_to_aff_combination (expr, type, comb);\n+\t    return;\n+\t  }\n+      }\n+      break;\n+\n     default:\n       break;\n     }\n@@ -639,28 +666,10 @@ aff_combination_expand (aff_tree *comb ATTRIBUTE_UNUSED,\n \t  exp = XNEW (struct name_expansion);\n \t  exp->in_progress = 1;\n \t  *slot = exp;\n-\t  /* In principle this is a generally valid folding, but\n-\t     it is not unconditionally an optimization, so do it\n-\t     here and not in fold_unary.  */\n-\t  /* Convert (T1)(X *+- CST) into (T1)X *+- (T1)CST if T1 is wider\n-\t     than the type of X and overflow for the type of X is\n-\t     undefined.  */\n-\t  if (e != name\n-\t      && INTEGRAL_TYPE_P (type)\n-\t      && INTEGRAL_TYPE_P (TREE_TYPE (name))\n-\t      && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (name))\n-\t      && TYPE_PRECISION (type) > TYPE_PRECISION (TREE_TYPE (name))\n-\t      && (code == PLUS_EXPR || code == MINUS_EXPR || code == MULT_EXPR)\n-\t      && TREE_CODE (gimple_assign_rhs2 (def)) == INTEGER_CST)\n-\t    rhs = fold_build2 (code, type,\n-\t\t\t       fold_convert (type, gimple_assign_rhs1 (def)),\n-\t\t\t       fold_convert (type, gimple_assign_rhs2 (def)));\n-\t  else\n-\t    {\n-\t      rhs = gimple_assign_rhs_to_tree (def);\n-\t      if (e != name)\n-\t\trhs = fold_convert (type, rhs);\n-\t    }\n+\t  rhs = gimple_assign_rhs_to_tree (def);\n+\t  if (e != name)\n+\t    rhs = fold_convert (type, rhs);\n+\n \t  tree_to_aff_combination_expand (rhs, comb->type, &current, cache);\n \t  exp->expansion = current;\n \t  exp->in_progress = 0;"}]}