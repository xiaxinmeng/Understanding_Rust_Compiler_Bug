{"sha": "40c3294835c9e8e416c0eae4688c1160ffc8ad3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBjMzI5NDgzNWM5ZThlNDE2YzBlYWU0Njg4YzExNjBmZmM4YWQzZg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-01-14T06:17:38Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-01-14T06:17:38Z"}, "message": "re PR fortran/41478 (Corrupted memory using PACK for derived-types with allocated components)\n\n2010-01-14  Paul Thomas  <pault@gcc.gnu.org>\n\n        PR fortran/41478\n        * trans-array.c (duplicate_allocatable):  Static version of\n\tgfc_duplicate_allocatable with provision to handle scalar\n\tcomponents. New boolean argument to switch off call to malloc\n\tif true.\n\t(gfc_duplicate_allocatable): New function to call above with\n\tnew argument false.\n\t(gfc_copy_allocatable_data): New function to call above with\n\tnew argument true.\n\t(structure_alloc_comps): Do not apply indirect reference to\n\tscalar pointers. Add new section to copy allocatable components\n\tof arrays. Extend copying of allocatable components to include\n\tscalars.\n\t(gfc_copy_only_alloc_comp): New function to copy allocatable\n\tcomponent derived types, without allocating the base structure.\n\t* trans-array.h : Add primitive for gfc_copy_allocatable_data.\n\tAdd primitive for gfc_copy_only_alloc_comp.\n\t* trans-expr.c (gfc_conv_procedure_call): After calls to\n\ttransformational functions with results that are derived types\n\twith allocatable components, copy the components in the result.\n\t(gfc_trans_arrayfunc_assign): Deallocate allocatable components\n\tof lhs derived types before allocation.\n\t\n\n2010-01-14  Paul Thomas  <pault@gcc.gnu.org>\n\n        PR fortran/41478\n        * gfortran.dg/alloc_comp_scalar_1.f90: New test.\n        * gfortran.dg/alloc_comp_transformational_1.f90: New test.\n\nFrom-SVN: r155877", "tree": {"sha": "00205ae58b6e5ce1f062de0463815660141dcdc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00205ae58b6e5ce1f062de0463815660141dcdc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40c3294835c9e8e416c0eae4688c1160ffc8ad3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c3294835c9e8e416c0eae4688c1160ffc8ad3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40c3294835c9e8e416c0eae4688c1160ffc8ad3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/comments", "author": null, "committer": null, "parents": [{"sha": "08b02036337225eb9b58497c704efaa2b41918bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b02036337225eb9b58497c704efaa2b41918bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b02036337225eb9b58497c704efaa2b41918bc"}], "stats": {"total": 312, "additions": 278, "deletions": 34}, "files": [{"sha": "204d242022159e1e6170d1f07a3030343d44ad81", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=40c3294835c9e8e416c0eae4688c1160ffc8ad3f", "patch": "@@ -1,3 +1,28 @@\n+2010-01-14  Paul Thomas  <pault@gcc.gnu.org>\n+\n+        PR fortran/41478\n+        * trans-array.c (duplicate_allocatable):  Static version of\n+\tgfc_duplicate_allocatable with provision to handle scalar\n+\tcomponents. New boolean argument to switch off call to malloc\n+\tif true.\n+\t(gfc_duplicate_allocatable): New function to call above with\n+\tnew argument false.\n+\t(gfc_copy_allocatable_data): New function to call above with\n+\tnew argument true.\n+\t(structure_alloc_comps): Do not apply indirect reference to\n+\tscalar pointers. Add new section to copy allocatable components\n+\tof arrays. Extend copying of allocatable components to include\n+\tscalars.\n+\t(gfc_copy_only_alloc_comp): New function to copy allocatable\n+\tcomponent derived types, without allocating the base structure.\n+\t* trans-array.h : Add primitive for gfc_copy_allocatable_data.\n+\tAdd primitive for gfc_copy_only_alloc_comp.\n+\t* trans-expr.c (gfc_conv_procedure_call): After calls to\n+\ttransformational functions with results that are derived types\n+\twith allocatable components, copy the components in the result.\n+\t(gfc_trans_arrayfunc_assign): Deallocate allocatable components\n+\tof lhs derived types before allocation.\n+\t\n 2010-01-14  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/42481"}, {"sha": "d512da4db6b3b6fcab790df50baf3ac7cd6e7b7c", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 99, "deletions": 28, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=40c3294835c9e8e416c0eae4688c1160ffc8ad3f", "patch": "@@ -5711,10 +5711,12 @@ get_full_array_size (stmtblock_t *block, tree decl, int rank)\n }\n \n \n-/* Allocate dest to the same size as src, and copy src -> dest.  */\n+/* Allocate dest to the same size as src, and copy src -> dest.\n+   If no_malloc is set, only the copy is done.  */\n \n-tree\n-gfc_duplicate_allocatable(tree dest, tree src, tree type, int rank)\n+static tree\n+duplicate_allocatable(tree dest, tree src, tree type, int rank,\n+\t\t      bool no_malloc)\n {\n   tree tmp;\n   tree size;\n@@ -5723,47 +5725,97 @@ gfc_duplicate_allocatable(tree dest, tree src, tree type, int rank)\n   tree null_data;\n   stmtblock_t block;\n \n-  /* If the source is null, set the destination to null.  */\n+  /* If the source is null, set the destination to null.  Then,\n+     allocate memory to the destination.  */\n   gfc_init_block (&block);\n-  gfc_conv_descriptor_data_set (&block, dest, null_pointer_node);\n-  null_data = gfc_finish_block (&block);\n \n-  gfc_init_block (&block);\n+  if (rank == 0)\n+    {\n+      tmp = null_pointer_node;\n+      tmp = fold_build2 (MODIFY_EXPR, type, dest, tmp);\n+      gfc_add_expr_to_block (&block, tmp);\n+      null_data = gfc_finish_block (&block);\n+\n+      gfc_init_block (&block);\n+      size = TYPE_SIZE_UNIT (type);\n+      if (!no_malloc)\n+\t{\n+\t  tmp = gfc_call_malloc (&block, type, size);\n+\t  tmp = fold_build2 (MODIFY_EXPR, void_type_node, dest,\n+\t\t\t     fold_convert (type, tmp));\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+\n+      tmp = built_in_decls[BUILT_IN_MEMCPY];\n+      tmp = build_call_expr_loc (input_location, tmp, 3,\n+\t\t\t\t dest, src, size);\n+    }\n+  else\n+    {\n+      gfc_conv_descriptor_data_set (&block, dest, null_pointer_node);\n+      null_data = gfc_finish_block (&block);\n+\n+      gfc_init_block (&block);\n+      nelems = get_full_array_size (&block, src, rank);\n+      tmp = fold_convert (gfc_array_index_type,\n+\t\t\t  TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+      size = fold_build2 (MULT_EXPR, gfc_array_index_type, nelems, tmp);\n+      if (!no_malloc)\n+\t{\n+\t  tmp = TREE_TYPE (gfc_conv_descriptor_data_get (src));\n+\t  tmp = gfc_call_malloc (&block, tmp, size);\n+\t  gfc_conv_descriptor_data_set (&block, dest, tmp);\n+\t}\n+\n+      /* We know the temporary and the value will be the same length,\n+\t so can use memcpy.  */\n+      tmp = built_in_decls[BUILT_IN_MEMCPY];\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\ttmp, 3, gfc_conv_descriptor_data_get (dest),\n+\t\t\tgfc_conv_descriptor_data_get (src), size);\n+    }\n \n-  nelems = get_full_array_size (&block, src, rank);\n-  size = fold_build2 (MULT_EXPR, gfc_array_index_type, nelems,\n-\t\t      fold_convert (gfc_array_index_type,\n-\t\t\t\t    TYPE_SIZE_UNIT (gfc_get_element_type (type))));\n-\n-  /* Allocate memory to the destination.  */\n-  tmp = gfc_call_malloc (&block, TREE_TYPE (gfc_conv_descriptor_data_get (src)),\n-\t\t\t size);\n-  gfc_conv_descriptor_data_set (&block, dest, tmp);\n-\n-  /* We know the temporary and the value will be the same length,\n-     so can use memcpy.  */\n-  tmp = built_in_decls[BUILT_IN_MEMCPY];\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t tmp, 3, gfc_conv_descriptor_data_get (dest),\n-  \t\t\t gfc_conv_descriptor_data_get (src), size);\n   gfc_add_expr_to_block (&block, tmp);\n   tmp = gfc_finish_block (&block);\n \n   /* Null the destination if the source is null; otherwise do\n      the allocate and copy.  */\n-  null_cond = gfc_conv_descriptor_data_get (src);\n+  if (rank == 0)\n+    null_cond = src;\n+  else\n+    null_cond = gfc_conv_descriptor_data_get (src);\n+\n   null_cond = convert (pvoid_type_node, null_cond);\n   null_cond = fold_build2 (NE_EXPR, boolean_type_node,\n \t\t\t   null_cond, null_pointer_node);\n   return build3_v (COND_EXPR, null_cond, tmp, null_data);\n }\n \n \n+/* Allocate dest to the same size as src, and copy data src -> dest.  */\n+\n+tree\n+gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank)\n+{\n+  return duplicate_allocatable(dest, src, type, rank, false);\n+}\n+\n+\n+/* Copy data src -> dest.  */\n+\n+tree\n+gfc_copy_allocatable_data (tree dest, tree src, tree type, int rank)\n+{\n+  return duplicate_allocatable(dest, src, type, rank, true);\n+}\n+\n+\n /* Recursively traverse an object of derived type, generating code to\n    deallocate, nullify or copy allocatable components.  This is the work horse\n    function for the functions named in this enum.  */\n \n-enum {DEALLOCATE_ALLOC_COMP = 1, NULLIFY_ALLOC_COMP, COPY_ALLOC_COMP};\n+enum {DEALLOCATE_ALLOC_COMP = 1, NULLIFY_ALLOC_COMP, COPY_ALLOC_COMP,\n+      COPY_ONLY_ALLOC_COMP};\n \n static tree\n structure_alloc_comps (gfc_symbol * der_type, tree decl,\n@@ -5786,7 +5838,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n   gfc_init_block (&fnblock);\n \n-  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+  if (POINTER_TYPE_P (TREE_TYPE (decl)) && rank != 0)\n     decl = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t    decl);\n \n@@ -5841,6 +5893,14 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t  dref = gfc_build_array_ref (tmp, index, NULL);\n \t  tmp = structure_alloc_comps (der_type, vref, dref, rank, purpose);\n \t}\n+      else if (purpose == COPY_ONLY_ALLOC_COMP)\n+        {\n+\t  tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t gfc_conv_array_data (dest));\n+\t  dref = gfc_build_array_ref (tmp, index, NULL);\n+\t  tmp = structure_alloc_comps (der_type, vref, dref, rank,\n+\t\t\t\t       COPY_ALLOC_COMP);\n+\t}\n       else\n         tmp = structure_alloc_comps (der_type, vref, NULL_TREE, rank, purpose);\n \n@@ -5978,7 +6038,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t  if (c->attr.allocatable && !cmp_has_alloc_comps)\n \t    {\n-\t      tmp = gfc_duplicate_allocatable(dcmp, comp, ctype, c->as->rank);\n+\t      rank = c->as ? c->as->rank : 0;\n+\t      tmp = gfc_duplicate_allocatable(dcmp, comp, ctype, rank);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \n@@ -6025,7 +6086,7 @@ gfc_deallocate_alloc_comp (gfc_symbol * der_type, tree decl, int rank)\n \n \n /* Recursively traverse an object of derived type, generating code to\n-   copy its allocatable components.  */\n+   copy it and its allocatable components.  */\n \n tree\n gfc_copy_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank)\n@@ -6034,6 +6095,16 @@ gfc_copy_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank)\n }\n \n \n+/* Recursively traverse an object of derived type, generating code to\n+   copy only its allocatable components.  */\n+\n+tree\n+gfc_copy_only_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank)\n+{\n+  return structure_alloc_comps (der_type, decl, dest, rank, COPY_ONLY_ALLOC_COMP);\n+}\n+\n+\n /* NULLIFY an allocatable/pointer array on function entry, free it on exit.\n    Do likewise, recursively if necessary, with the allocatable components of\n    derived types.  */"}, {"sha": "6807fcbe61231db82c5efafc673511bd9f2d7ae8", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=40c3294835c9e8e416c0eae4688c1160ffc8ad3f", "patch": "@@ -45,14 +45,18 @@ tree gfc_trans_g77_array (gfc_symbol *, tree);\n /* Generate code to deallocate an array, if it is allocated.  */\n tree gfc_trans_dealloc_allocated (tree);\n \n-tree gfc_duplicate_allocatable(tree dest, tree src, tree type, int rank);\n+tree gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank);\n+\n+tree gfc_copy_allocatable_data (tree dest, tree src, tree type, int rank);\n \n tree gfc_nullify_alloc_comp (gfc_symbol *, tree, int);\n \n tree gfc_deallocate_alloc_comp (gfc_symbol *, tree, int);\n \n tree gfc_copy_alloc_comp (gfc_symbol *, tree, tree, int);\n \n+tree gfc_copy_only_alloc_comp (gfc_symbol *, tree, tree, int);\n+\n /* Add initialization for deferred arrays.  */\n tree gfc_trans_deferred_array (gfc_symbol *, tree);\n /* Generate an initializer for a static pointer or allocatable array.  */"}, {"sha": "bb69d454e92db96aff7c72031ea14dc681016325", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=40c3294835c9e8e416c0eae4688c1160ffc8ad3f", "patch": "@@ -2757,6 +2757,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   tree var;\n   tree len;\n   tree stringargs;\n+  tree result = NULL;\n   gfc_formal_arglist *formal;\n   int has_alternate_specifier = 0;\n   bool need_interface_mapping;\n@@ -3288,6 +3289,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    se->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\tse->expr);\n \n+\t  result = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\tse->expr);\n \t  retargs = gfc_chainon_list (retargs, se->expr);\n \t}\n       else if (comp && comp->attr.dimension)\n@@ -3310,8 +3313,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t       callee_alloc, &se->ss->expr->where);\n \n \t  /* Pass the temporary as the first argument.  */\n-\t  tmp = info->descriptor;\n-\t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t  result = info->descriptor;\n+\t  tmp = gfc_build_addr_expr (NULL_TREE, result);\n \t  retargs = gfc_chainon_list (retargs, tmp);\n \t}\n       else if (!comp && sym->result->attr.dimension)\n@@ -3334,8 +3337,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t       callee_alloc, &se->ss->expr->where);\n \n \t  /* Pass the temporary as the first argument.  */\n-\t  tmp = info->descriptor;\n-\t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t  result = info->descriptor;\n+\t  tmp = gfc_build_addr_expr (NULL_TREE, result);\n \t  retargs = gfc_chainon_list (retargs, tmp);\n \t}\n       else if (ts.type == BT_CHARACTER)\n@@ -3487,7 +3490,36 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n   /* Follow the function call with the argument post block.  */\n   if (byref)\n-    gfc_add_block_to_block (&se->pre, &post);\n+    {\n+      gfc_add_block_to_block (&se->pre, &post);\n+\n+      /* Transformational functions of derived types with allocatable\n+         components must have the result allocatable components copied.  */\n+      arg = expr->value.function.actual;\n+      if (result && arg && expr->rank\n+\t    && expr->value.function.isym\n+\t    && expr->value.function.isym->transformational\n+\t    && arg->expr->ts.type == BT_DERIVED\n+\t    && arg->expr->ts.u.derived->attr.alloc_comp)\n+\t{\n+\t  tree tmp2;\n+\t  /* Copy the allocatable components.  We have to use a\n+\t     temporary here to prevent source allocatable components\n+\t     from being corrupted.  */\n+\t  tmp2 = gfc_evaluate_now (result, &se->pre);\n+\t  tmp = gfc_copy_alloc_comp (arg->expr->ts.u.derived,\n+\t\t\t\t     result, tmp2, expr->rank);\n+\t  gfc_add_expr_to_block (&se->pre, tmp);\n+\t  tmp = gfc_copy_allocatable_data (result, tmp2, TREE_TYPE(tmp2),\n+\t\t\t\t           expr->rank);\n+\t  gfc_add_expr_to_block (&se->pre, tmp);\n+\n+\t  /* Finally free the temporary's data field.  */\n+\t  tmp = gfc_conv_descriptor_data_get (tmp2);\n+\t  tmp = gfc_deallocate_with_status (tmp, NULL_TREE, true, NULL);\n+\t  gfc_add_expr_to_block (&se->pre, tmp);\n+\t}\n+    }\n   else\n     gfc_add_block_to_block (&se->post, &post);\n \n@@ -4906,6 +4938,15 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n \n   gfc_conv_array_parameter (&se, expr1, ss, 0, NULL, NULL, NULL);\n \n+  if (expr1->ts.type == BT_DERIVED\n+\t&& expr1->ts.u.derived->attr.alloc_comp)\n+    {\n+      tree tmp;\n+      tmp = gfc_deallocate_alloc_comp (expr1->ts.u.derived, se.expr,\n+\t\t\t\t       expr1->rank);\n+      gfc_add_expr_to_block (&se.pre, tmp);\n+    }\n+\n   se.direct_byref = 1;\n   se.ss = gfc_walk_expr (expr2);\n   gcc_assert (se.ss != gfc_ss_terminator);"}, {"sha": "ffe006a646e02a60cf0266bbedd645e075974e59", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=40c3294835c9e8e416c0eae4688c1160ffc8ad3f", "patch": "@@ -1,3 +1,9 @@\n+2010-01-14  Paul Thomas  <pault@gcc.gnu.org>\n+\n+        PR fortran/41478\n+        * gfortran.dg/alloc_comp_scalar_1.f90: New test.\n+        * gfortran.dg/alloc_comp_transformational_1.f90: New test.\n+\n 2010-01-14  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/42481"}, {"sha": "82cf71fc4fe815da68f2b8d2d0f1acdd43110ca5", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_scalar_1.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_scalar_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_scalar_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_scalar_1.f90?ref=40c3294835c9e8e416c0eae4688c1160ffc8ad3f", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run }\n+! Test the fix for comment #8 of PR41478, in which copying\n+! allocatable scalar components caused a segfault.\n+! \n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+program main\n+  type :: container_t\n+    integer, allocatable :: entry\n+  end type container_t\n+  type(container_t), dimension(1) :: a1, a2\n+  allocate (a1(1)%entry, a2(1)%entry)\n+  a2(1)%entry = 1\n+  a1(1:1) = pack (a2(1:1), mask = [.true.])\n+  deallocate (a2(1)%entry)\n+  if (a1(1)%entry .ne. 1) call abort\n+end program main"}, {"sha": "13ee8a88bde0b99b9bee3d977caa095ddae2a511", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_transformational_1.f90", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_transformational_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c3294835c9e8e416c0eae4688c1160ffc8ad3f/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_transformational_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_transformational_1.f90?ref=40c3294835c9e8e416c0eae4688c1160ffc8ad3f", "patch": "@@ -0,0 +1,80 @@\n+! { dg-do run }\n+! Tests the fix for PR41478, in which double frees would occur because\n+! transformational intrinsics did not copy the allocatable components\n+! so that they were (sometimes) freed twice on exit.  In addition,\n+! The original allocatable components of a1 were not freed, so that\n+! memory leakage occurred.\n+!\n+! Contributed by Juergen Reuter <reuter@physik.uni-freiburg.de>\n+!\n+  type :: container_t\n+    integer, dimension(:), allocatable :: entry\n+    integer index\n+  end type container_t\n+  call foo\n+  call bar\n+contains\n+!\n+! This is the reported problem.\n+!\n+  subroutine foo\n+    type(container_t), dimension(4) :: a1, a2, a3\n+    integer :: i\n+    do i = 1, 4\n+      allocate (a1(i)%entry (2), a2(i)%entry (2), a3(i)%entry (2))\n+      a1(i)%entry = [1,2]\n+      a2(i)%entry = [3,4]\n+      a3(i)%entry = [4,5]\n+      a1(i)%index = i\n+      a2(i)%index = i\n+      a3(i)%index = i\n+    end do\n+    a1(1:2) = pack (a2, [.true., .false., .true., .false.])\n+    do i = 1, 4\n+      if (.not.allocated (a1(i)%entry)) call abort\n+      if (i .gt. 2) then\n+        if (any (a1(i)%entry .ne. [1,2])) call abort\n+      else\n+        if (any (a1(i)%entry .ne. [3,4])) call abort\n+      end if\n+    end do\n+!\n+! Now check unpack\n+!\n+    a1 = unpack (a1, [.true., .true., .false., .false.], a3)\n+    if (any (a1%index .ne. [1,3,3,4])) call abort\n+    do i = 1, 4\n+      if (.not.allocated (a1(i)%entry)) call abort\n+      if (i .gt. 2) then\n+        if (any (a1(i)%entry .ne. [4,5])) call abort\n+      else\n+        if (any (a1(i)%entry .ne. [3,4])) call abort\n+      end if\n+    end do\n+  end subroutine\n+!\n+! Other all transformational intrinsics display it. Having done\n+! PACK and UNPACK, just use TRANSPOSE as a demonstrator.\n+!\n+  subroutine bar\n+    type(container_t), dimension(2,2) :: a1, a2\n+    integer :: i, j\n+    do i = 1, 2\n+      do j = 1, 2\n+        allocate (a1(i, j)%entry (2), a2(i, j)%entry (2))\n+        a1(i, j)%entry = [i,j]\n+        a2(i, j)%entry = [i,j]\n+        a1(i,j)%index = j + (i - 1)*2\n+        a2(i,j)%index = j + (i - 1)*2\n+      end do\n+    end do\n+    a1 = transpose (a2)\n+    do i = 1, 2\n+      do j = 1, 2\n+        if (a1(i,j)%index .ne. i + (j - 1)*2) call abort\n+        if (any (a1(i,j)%entry .ne. [j,i])) call abort\n+      end do\n+    end do\n+  end subroutine\n+end\n+"}]}