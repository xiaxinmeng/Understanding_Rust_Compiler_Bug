{"sha": "1a3c3ee9bc4639fc67e037b6837d2625327555fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEzYzNlZTliYzQ2MzlmYzY3ZTAzN2I2ODM3ZDI2MjUzMjc1NTVmZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-06-15T18:17:58Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-06-15T18:17:58Z"}, "message": "vsx.md (VSINT_84): Add DImode to enable loading DImode constants with XXSPLTIB in vector registers.\n\n[gcc]\n2016-06-15  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/vsx.md (VSINT_84): Add DImode to enable loading\n\tDImode constants with XXSPLTIB in vector registers.\n\t(vsx_extract_<mode>, V2DImode/V2DFmode): Combine both\n\tvsx_extract_<mode>_internal{1,2} into a single insn that handles\n\tdirect move (both ISA 2.07 and ISA 3.0 versions), and optimizes\n\textraction of the element at the top of the register as a scalar\n\tvalue.\n\t(vsx_extract_<mode>_internal1): Likewise.\n\t(vsx_extract_<mode>_internal2): Likewise.\n\t* config/rs6000/constraints.md (wi constraint): Remove a comment\n\tabout DImode not being allowed in Altivec registers.\n\t(wB constraint): New constraint for constants that can be\n\tgenerated in Altivec registers with VSPLTISW/VUPKHSW.\n\t* config/rs6000/predicates.md (xxspltib_constant_split): Update\n\tcomments.\n\t(xxspltib_constant_nosplit): Likewise.\n\t* config/rs6000/rs6000-cpus.def (ISA_2_6_MASKS_SERVER): Add\n\tsupport for -mupper-regs-di to enable DImode to go into Altivec\n\tregisters.\n\t(POWERPC_MASKS): Likewise.\n\t(power7 cpu): Likewise.\n\t* config/rs6000/rs6000.opt (-mupper-regs-di): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Add support\n\tfor DImode being allowed in Altivec registers.  Update wi/wj\n\tconstraints.  Set scalar_in_vmx_p flag.\n\t(rs6000_option_override_internal): Add checks for -mupper-regs-di.\n\t(xxspltib_constant_p): Allow CONST_INT's with VOIDmode.  Don't\n\treturn true if we could use VSPLTISW/VUPKHSW instead of XXSPLTIB.\n\t(rs6000_opt_masks): Add -mupper-regs-di.\n\t* config/rs6000/rs6000.md (lfiwax): Update clobbers that don't use\n\tdirect move to use wi and not wj.\n\t(lfiwzx): Likewise.\n\t(floatsi<mode>2_lfiwax_mem): Combine alternatives into a single\n\talternative.\n\t(floatunssi<mode>2_lfiwzx_mem): Likewise.\n\t(fix_trunc<mode>di2_fctidz): Change second alternative to allow\n\tany VSX register, instead of just Altivec registers, to allow\n\teither operand to be an Altivec register or both.\n\t(fixuns_trunc<mode>di2_fctiduz): Likewise.\n\t(movdi_internal32): Add support for -mupper-regs-di.  Add support\n\tto load constants via XXSPLTIB or VSPLTISW.  Add spacing to allow\n\tthe alternatives and attributes to be lined up to be easier to\n\tread.\n\t(movdi_internal64): Likewise.\n\t(64-bit DImode splitters): Change predicates to only split loading\n\tup GPR registers.  Add splits for using XXSPLTIB or VSPLTISW to\n\tload constants in ISA 3.0 or ISA 2.07 respectively.\n\t* doc/invoke.texi (RS/6000 and PowerPC Options): Document\n\t-mupper-regs-di.  Update -mupper-regs-df and -mupper-regs-sf to\n\tmention -mcpu=power9 sets these options.\n\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Document the\n\twB constraint.\n\n[gcc/testsuite]\n2016-06-15  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/p9-dimode1.c: New test.\n\t* gcc.target/powerpc/p9-dimode2.c: Likewise.\n\nFrom-SVN: r237490", "tree": {"sha": "9917dcc32fe15017167df4cd8eaa5d72cccae942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9917dcc32fe15017167df4cd8eaa5d72cccae942"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a3c3ee9bc4639fc67e037b6837d2625327555fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a3c3ee9bc4639fc67e037b6837d2625327555fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a3c3ee9bc4639fc67e037b6837d2625327555fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a3c3ee9bc4639fc67e037b6837d2625327555fd/comments", "author": null, "committer": null, "parents": [{"sha": "61daecc46bd5dd2c24041651803bee8eeedae68d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61daecc46bd5dd2c24041651803bee8eeedae68d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61daecc46bd5dd2c24041651803bee8eeedae68d"}], "stats": {"total": 495, "additions": 396, "deletions": 99}, "files": [{"sha": "2650405a3f786f41b7453c17e1c2be5d83f1efc8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -1,3 +1,58 @@\n+2016-06-15  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/vsx.md (VSINT_84): Add DImode to enable loading\n+\tDImode constants with XXSPLTIB in vector registers.\n+\t(vsx_extract_<mode>, V2DImode/V2DFmode): Combine both\n+\tvsx_extract_<mode>_internal{1,2} into a single insn that handles\n+\tdirect move (both ISA 2.07 and ISA 3.0 versions), and optimizes\n+\textraction of the element at the top of the register as a scalar\n+\tvalue.\n+\t(vsx_extract_<mode>_internal1): Likewise.\n+\t(vsx_extract_<mode>_internal2): Likewise.\n+\t* config/rs6000/constraints.md (wi constraint): Remove a comment\n+\tabout DImode not being allowed in Altivec registers.\n+\t(wB constraint): New constraint for constants that can be\n+\tgenerated in Altivec registers with VSPLTISW/VUPKHSW.\n+\t* config/rs6000/predicates.md (xxspltib_constant_split): Update\n+\tcomments.\n+\t(xxspltib_constant_nosplit): Likewise.\n+\t* config/rs6000/rs6000-cpus.def (ISA_2_6_MASKS_SERVER): Add\n+\tsupport for -mupper-regs-di to enable DImode to go into Altivec\n+\tregisters.\n+\t(POWERPC_MASKS): Likewise.\n+\t(power7 cpu): Likewise.\n+\t* config/rs6000/rs6000.opt (-mupper-regs-di): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Add support\n+\tfor DImode being allowed in Altivec registers.  Update wi/wj\n+\tconstraints.  Set scalar_in_vmx_p flag.\n+\t(rs6000_option_override_internal): Add checks for -mupper-regs-di.\n+\t(xxspltib_constant_p): Allow CONST_INT's with VOIDmode.  Don't\n+\treturn true if we could use VSPLTISW/VUPKHSW instead of XXSPLTIB.\n+\t(rs6000_opt_masks): Add -mupper-regs-di.\n+\t* config/rs6000/rs6000.md (lfiwax): Update clobbers that don't use\n+\tdirect move to use wi and not wj.\n+\t(lfiwzx): Likewise.\n+\t(floatsi<mode>2_lfiwax_mem): Combine alternatives into a single\n+\talternative.\n+\t(floatunssi<mode>2_lfiwzx_mem): Likewise.\n+\t(fix_trunc<mode>di2_fctidz): Change second alternative to allow\n+\tany VSX register, instead of just Altivec registers, to allow\n+\teither operand to be an Altivec register or both.\n+\t(fixuns_trunc<mode>di2_fctiduz): Likewise.\n+\t(movdi_internal32): Add support for -mupper-regs-di.  Add support\n+\tto load constants via XXSPLTIB or VSPLTISW.  Add spacing to allow\n+\tthe alternatives and attributes to be lined up to be easier to\n+\tread.\n+\t(movdi_internal64): Likewise.\n+\t(64-bit DImode splitters): Change predicates to only split loading\n+\tup GPR registers.  Add splits for using XXSPLTIB or VSPLTISW to\n+\tload constants in ISA 3.0 or ISA 2.07 respectively.\n+\t* doc/invoke.texi (RS/6000 and PowerPC Options): Document\n+\t-mupper-regs-di.  Update -mupper-regs-df and -mupper-regs-sf to\n+\tmention -mcpu=power9 sets these options.\n+\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Document the\n+\twB constraint.\n+\n 2016-06-15  Pitchumani Sivanupandi  <pitchumani.s@atmel.com>\n \n \tPR target/67353"}, {"sha": "8ef8f9b429e780e4a13128edf0a72e010c5e419a", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -77,8 +77,6 @@\n (define_register_constraint \"wh\" \"rs6000_constraints[RS6000_CONSTRAINT_wh]\"\n   \"Floating point register if direct moves are available, or NO_REGS.\")\n \n-;; At present, DImode is not allowed in the Altivec registers.  If in the\n-;; future it is allowed, wi/wj can be set to VSX_REGS instead of FLOAT_REGS.\n (define_register_constraint \"wi\" \"rs6000_constraints[RS6000_CONSTRAINT_wi]\"\n   \"FP or VSX register to hold 64-bit integers for VSX insns or NO_REGS.\")\n \n@@ -135,6 +133,13 @@\n (define_register_constraint \"wz\" \"rs6000_constraints[RS6000_CONSTRAINT_wz]\"\n   \"Floating point register if the LFIWZX instruction is enabled or NO_REGS.\")\n \n+;; wB needs ISA 2.07 VUPKHSW\n+(define_constraint \"wB\"\n+  \"Signed 5-bit constant integer that can be loaded into an altivec register.\"\n+  (and (match_code \"const_int\")\n+       (and (match_test \"TARGET_P8_VECTOR\")\n+\t    (match_operand 0 \"s5bit_cint_operand\"))))\n+\n (define_constraint \"wD\"\n   \"Int constant that is the element number of the 64-bit scalar in a vector.\"\n   (and (match_code \"const_int\")"}, {"sha": "3d0f48ea712fbf9454a8baa42be7497b0bbc3911", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -565,9 +565,8 @@\n     }\n })\n \n-;; Return 1 if the operand is a CONST_VECTOR or VEC_DUPLICATE of a constant\n-;; that can loaded with a XXSPLTIB instruction and then a VUPKHSB, VECSB2W or\n-;; VECSB2D instruction.\n+;; Return 1 if the operand is a constant that can loaded with a XXSPLTIB\n+;; instruction and then a VUPKHSB, VECSB2W or VECSB2D instruction.\n \n (define_predicate \"xxspltib_constant_split\"\n   (match_code \"const_vector,vec_duplicate,const_int\")\n@@ -582,8 +581,8 @@\n })\n \n \n-;; Return 1 if the operand is a CONST_VECTOR that can loaded directly with a\n-;; XXSPLTIB instruction.\n+;; Return 1 if the operand is constant that can loaded directly with a XXSPLTIB\n+;; instruction.\n \n (define_predicate \"xxspltib_constant_nosplit\"\n   (match_code \"const_vector,vec_duplicate,const_int\")"}, {"sha": "a67b2d91b4e88595525a6b9c42ea8047a58ad43c", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -45,6 +45,7 @@\n \t\t\t\t | OPTION_MASK_POPCNTD\t\t\t\\\n \t\t\t\t | OPTION_MASK_ALTIVEC\t\t\t\\\n \t\t\t\t | OPTION_MASK_VSX\t\t\t\\\n+\t\t\t\t | OPTION_MASK_UPPER_REGS_DI\t\t\\\n \t\t\t\t | OPTION_MASK_UPPER_REGS_DF)\n \n /* For now, don't provide an embedded version of ISA 2.07.  */\n@@ -119,6 +120,7 @@\n \t\t\t\t | OPTION_MASK_SOFT_FLOAT\t\t\\\n \t\t\t\t | OPTION_MASK_STRICT_ALIGN_OPTIONAL\t\\\n \t\t\t\t | OPTION_MASK_TOC_FUSION\t\t\\\n+\t\t\t\t | OPTION_MASK_UPPER_REGS_DI\t\t\\\n \t\t\t\t | OPTION_MASK_UPPER_REGS_DF\t\t\\\n \t\t\t\t | OPTION_MASK_UPPER_REGS_SF\t\t\\\n \t\t\t\t | OPTION_MASK_VSX\t\t\t\\\n@@ -211,7 +213,8 @@ RS6000_CPU (\"power6x\", PROCESSOR_POWER6, MASK_POWERPC64 | MASK_PPC_GPOPT\n RS6000_CPU (\"power7\", PROCESSOR_POWER7,   /* Don't add MASK_ISEL by default */\n \t    POWERPC_7400_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_MFCRF\n \t    | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP | MASK_POPCNTD\n-\t    | MASK_VSX | MASK_RECIP_PRECISION | OPTION_MASK_UPPER_REGS_DF)\n+\t    | MASK_VSX | MASK_RECIP_PRECISION | OPTION_MASK_UPPER_REGS_DF\n+\t    | OPTION_MASK_UPPER_REGS_DI)\n RS6000_CPU (\"power8\", PROCESSOR_POWER8, MASK_POWERPC64 | ISA_2_7_MASKS_SERVER)\n RS6000_CPU (\"power9\", PROCESSOR_POWER9, MASK_POWERPC64 | ISA_3_0_MASKS_SERVER)\n RS6000_CPU (\"powerpc\", PROCESSOR_POWERPC, 0)"}, {"sha": "7e9e908619a3747400f412542dd37b6ec5ff3c1d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -1938,7 +1938,8 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n \t  || FLOAT128_VECTOR_P (mode)\n \t  || reg_addr[mode].scalar_in_vmx_p\n \t  || (TARGET_VSX_TIMODE && mode == TImode)\n-\t  || (TARGET_VADDUQM && mode == V1TImode)))\n+\t  || (TARGET_VADDUQM && mode == V1TImode)\n+\t  || (TARGET_UPPER_REGS_DI && mode == DImode)))\n     {\n       if (FP_REGNO_P (regno))\n \treturn FP_REGNO_P (last_regno);\n@@ -3082,7 +3083,6 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       rs6000_constraints[RS6000_CONSTRAINT_wa] = VSX_REGS;\n       rs6000_constraints[RS6000_CONSTRAINT_wd] = VSX_REGS;\t/* V2DFmode  */\n       rs6000_constraints[RS6000_CONSTRAINT_wf] = VSX_REGS;\t/* V4SFmode  */\n-      rs6000_constraints[RS6000_CONSTRAINT_wi] = FLOAT_REGS;\t/* DImode  */\n \n       if (TARGET_VSX_TIMODE)\n \trs6000_constraints[RS6000_CONSTRAINT_wt] = VSX_REGS;\t/* TImode  */\n@@ -3094,6 +3094,11 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t}\n       else\n \trs6000_constraints[RS6000_CONSTRAINT_ws] = FLOAT_REGS;\n+\n+      if (TARGET_UPPER_REGS_DF)\t\t\t\t\t/* DImode  */\n+\trs6000_constraints[RS6000_CONSTRAINT_wi] = VSX_REGS;\n+      else\n+\trs6000_constraints[RS6000_CONSTRAINT_wi] = FLOAT_REGS;\n     }\n \n   /* Add conditional constraints based on various options, to allow us to\n@@ -3306,6 +3311,9 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       if (TARGET_UPPER_REGS_DF)\n \treg_addr[DFmode].scalar_in_vmx_p = true;\n \n+      if (TARGET_UPPER_REGS_DI)\n+\treg_addr[DImode].scalar_in_vmx_p = true;\n+\n       if (TARGET_UPPER_REGS_SF)\n \treg_addr[SFmode].scalar_in_vmx_p = true;\n     }\n@@ -4085,9 +4093,9 @@ rs6000_option_override_internal (bool global_init_p)\n       rs6000_isa_flags &= ~OPTION_MASK_DFP;\n     }\n \n-  /* Allow an explicit -mupper-regs to set both -mupper-regs-df and\n-     -mupper-regs-sf, depending on the cpu, unless the user explicitly also set\n-     the individual option.  */\n+  /* Allow an explicit -mupper-regs to set -mupper-regs-df, -mupper-regs-di,\n+     and -mupper-regs-sf, depending on the cpu, unless the user explicitly also\n+     set the individual option.  */\n   if (TARGET_UPPER_REGS > 0)\n     {\n       if (TARGET_VSX\n@@ -4096,6 +4104,12 @@ rs6000_option_override_internal (bool global_init_p)\n \t  rs6000_isa_flags |= OPTION_MASK_UPPER_REGS_DF;\n \t  rs6000_isa_flags_explicit |= OPTION_MASK_UPPER_REGS_DF;\n \t}\n+      if (TARGET_VSX\n+\t  && !(rs6000_isa_flags_explicit & OPTION_MASK_UPPER_REGS_DI))\n+\t{\n+\t  rs6000_isa_flags |= OPTION_MASK_UPPER_REGS_DI;\n+\t  rs6000_isa_flags_explicit |= OPTION_MASK_UPPER_REGS_DI;\n+\t}\n       if (TARGET_P8_VECTOR\n \t  && !(rs6000_isa_flags_explicit & OPTION_MASK_UPPER_REGS_SF))\n \t{\n@@ -4111,6 +4125,12 @@ rs6000_option_override_internal (bool global_init_p)\n \t  rs6000_isa_flags &= ~OPTION_MASK_UPPER_REGS_DF;\n \t  rs6000_isa_flags_explicit |= OPTION_MASK_UPPER_REGS_DF;\n \t}\n+      if (TARGET_VSX\n+\t  && !(rs6000_isa_flags_explicit & OPTION_MASK_UPPER_REGS_DI))\n+\t{\n+\t  rs6000_isa_flags &= ~OPTION_MASK_UPPER_REGS_DI;\n+\t  rs6000_isa_flags_explicit |= OPTION_MASK_UPPER_REGS_DI;\n+\t}\n       if (TARGET_P8_VECTOR\n \t  && !(rs6000_isa_flags_explicit & OPTION_MASK_UPPER_REGS_SF))\n \t{\n@@ -4126,6 +4146,13 @@ rs6000_option_override_internal (bool global_init_p)\n       rs6000_isa_flags &= ~OPTION_MASK_UPPER_REGS_DF;\n     }\n \n+  if (TARGET_UPPER_REGS_DI && !TARGET_VSX)\n+    {\n+      if (rs6000_isa_flags_explicit & OPTION_MASK_UPPER_REGS_DF)\n+\terror (\"-mupper-regs-di requires -mvsx\");\n+      rs6000_isa_flags &= ~OPTION_MASK_UPPER_REGS_DF;\n+    }\n+\n   if (TARGET_UPPER_REGS_SF && !TARGET_P8_VECTOR)\n     {\n       if (rs6000_isa_flags_explicit & OPTION_MASK_UPPER_REGS_SF)\n@@ -4386,6 +4413,7 @@ rs6000_option_override_internal (bool global_init_p)\n   if (TARGET_FLOAT128_HW\n       && (rs6000_isa_flags & (OPTION_MASK_P9_VECTOR\n \t\t\t      | OPTION_MASK_DIRECT_MOVE\n+\t\t\t      | OPTION_MASK_UPPER_REGS_DI\n \t\t\t      | OPTION_MASK_UPPER_REGS_DF\n \t\t\t      | OPTION_MASK_UPPER_REGS_SF)) == 0)\n     {\n@@ -6284,7 +6312,7 @@ xxspltib_constant_p (rtx op,\n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n \n-  else if (mode != GET_MODE (op))\n+  else if (mode != GET_MODE (op) && GET_MODE (op) != VOIDmode)\n     return false;\n \n   /* Handle (vec_duplicate <constant>).  */\n@@ -6337,8 +6365,8 @@ xxspltib_constant_p (rtx op,\n     }\n \n   /* Handle integer constants being loaded into the upper part of the VSX\n-     register as a scalar.  If the value isn't 0/-1, only allow it if\n-     the mode can go in Altivec registers.  */\n+     register as a scalar.  If the value isn't 0/-1, only allow it if the mode\n+     can go in Altivec registers.  Prefer VSPLTISW/VUPKHSW over XXSPLITIB.  */\n   else if (CONST_INT_P (op))\n     {\n       if (!SCALAR_INT_MODE_P (mode))\n@@ -6348,9 +6376,14 @@ xxspltib_constant_p (rtx op,\n       if (!IN_RANGE (value, -128, 127))\n \treturn false;\n \n-      if (!IN_RANGE (value, -1, 0)\n-\t  && (reg_addr[mode].addr_mask[RELOAD_REG_VMX] & RELOAD_REG_VALID) == 0)\n-\treturn false;\n+      if (!IN_RANGE (value, -1, 0))\n+\t{\n+\t  if (!(reg_addr[mode].addr_mask[RELOAD_REG_VMX] & RELOAD_REG_VALID))\n+\t    return false;\n+\n+\t  if (EASY_VECTOR_15 (value))\n+\t    return false;\n+\t}\n     }\n \n   else\n@@ -35485,6 +35518,7 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"string\",\t\t\tOPTION_MASK_STRING,\t\tfalse, true  },\n   { \"toc-fusion\",\t\tOPTION_MASK_TOC_FUSION,\t\tfalse, true  },\n   { \"update\",\t\t\tOPTION_MASK_NO_UPDATE,\t\ttrue , true  },\n+  { \"upper-regs-di\",\t\tOPTION_MASK_UPPER_REGS_DI,\tfalse, true  },\n   { \"upper-regs-df\",\t\tOPTION_MASK_UPPER_REGS_DF,\tfalse, true  },\n   { \"upper-regs-sf\",\t\tOPTION_MASK_UPPER_REGS_SF,\tfalse, true  },\n   { \"vsx\",\t\t\tOPTION_MASK_VSX,\t\tfalse, true  },"}, {"sha": "3825cc011d6d8caec0d271dd783622a6e92ec707", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 130, "deletions": 22, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -4866,7 +4866,7 @@\n (define_insn_and_split \"floatsi<mode>2_lfiwax\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Fv>\")\n \t(float:SFDF (match_operand:SI 1 \"nonimmediate_operand\" \"r\")))\n-   (clobber (match_scratch:DI 2 \"=wj\"))]\n+   (clobber (match_scratch:DI 2 \"=wi\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n    && <SI_CONVERT_FP> && can_create_pseudo_p ()\"\n   \"#\"\n@@ -4905,11 +4905,11 @@\n    (set_attr \"type\" \"fpload\")])\n \n (define_insn_and_split \"floatsi<mode>2_lfiwax_mem\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fa>\")\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Fv>\")\n \t(float:SFDF\n \t (sign_extend:DI\n-\t  (match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z,Z\"))))\n-   (clobber (match_scratch:DI 2 \"=0,d\"))]\n+\t  (match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z\"))))\n+   (clobber (match_scratch:DI 2 \"=wi\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n    && <SI_CONVERT_FP>\"\n   \"#\"\n@@ -4941,7 +4941,7 @@\n (define_insn_and_split \"floatunssi<mode>2_lfiwzx\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Fv>\")\n \t(unsigned_float:SFDF (match_operand:SI 1 \"nonimmediate_operand\" \"r\")))\n-   (clobber (match_scratch:DI 2 \"=wj\"))]\n+   (clobber (match_scratch:DI 2 \"=wi\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\n    && <SI_CONVERT_FP>\"\n   \"#\"\n@@ -4980,11 +4980,11 @@\n    (set_attr \"type\" \"fpload\")])\n \n (define_insn_and_split \"floatunssi<mode>2_lfiwzx_mem\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fa>\")\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Fv>\")\n \t(unsigned_float:SFDF\n \t (zero_extend:DI\n-\t  (match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z,Z\"))))\n-   (clobber (match_scratch:DI 2 \"=0,d\"))]\n+\t  (match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z\"))))\n+   (clobber (match_scratch:DI 2 \"=wi\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\n    && <SI_CONVERT_FP>\"\n   \"#\"\n@@ -5288,7 +5288,7 @@\n \n (define_insn \"*fix_trunc<mode>di2_fctidz\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi\")\n-\t(fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fa>\")))]\n+\t(fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n     && TARGET_FCFID\"\n   \"@\n@@ -5360,7 +5360,7 @@\n \n (define_insn \"*fixuns_trunc<mode>di2_fctiduz\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi\")\n-\t(unsigned_fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fa>\")))]\n+\t(unsigned_fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n     && TARGET_FCTIDUZ\"\n   \"@\n@@ -7700,9 +7700,25 @@\n ;; non-offsettable address by using r->r which won't make progress.\n ;; Use of fprs is disparaged slightly otherwise reload prefers to reload\n ;; a gpr into a fpr instead of reloading an invalid 'Y' address\n+\n+;;        GPR store  GPR load   GPR move   FPR store  FPR load    FPR move\n+;;        GPR const  AVX store  AVX store  AVX load   AVX load    VSX move\n+;;        P9 0       P9 -1      AVX 0/-1   VSX 0      VSX -1      P9 const\n+;;        AVX const  \n+\n (define_insn \"*movdi_internal32\"\n-  [(set (match_operand:DI 0 \"rs6000_nonimmediate_operand\" \"=Y,r,r,?m,?*d,?*d,r\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,d,m,d,IJKnGHF\"))]\n+  [(set (match_operand:DI 0 \"rs6000_nonimmediate_operand\"\n+         \"=Y,        r,         r,         ?m,        ?*d,        ?*d,\n+          r,         ?Y,        ?Z,        ?*wb,      ?*wv,       ?wi,\n+          ?wo,       ?wo,       ?wv,       ?wi,       ?wi,        ?wv,\n+          ?wv\")\n+\n+\t(match_operand:DI 1 \"input_operand\"\n+          \"r,        Y,         r,         d,         m,          d,\n+           IJKnGHF,  wb,        wv,        Y,         Z,          wi,\n+           Oj,       wM,        OjwM,      Oj,        wM,         wS,\n+           wB\"))]\n+\n   \"! TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\"\n@@ -7713,8 +7729,24 @@\n    stfd%U0%X0 %1,%0\n    lfd%U1%X1 %0,%1\n    fmr %0,%1\n+   #\n+   stxsd %1,%0\n+   stxsdx %x1,%y0\n+   lxsd %0,%1\n+   lxsdx %x0,%y1\n+   xxlor %x0,%x1,%x1\n+   xxspltib %x0,0\n+   xxspltib %x0,255\n+   vspltisw %0,%1\n+   xxlxor %x0,%x0,%x0\n+   xxlorc %x0,%x0,%x0\n+   #\n    #\"\n-  [(set_attr \"type\" \"store,load,*,fpstore,fpload,fp,*\")])\n+  [(set_attr \"type\"\n+               \"store,     load,      *,         fpstore,   fpload,     fp,\n+                *,         fpstore,   fpstore,   fpload,    fpload,     vecsimple,\n+                vecsimple, vecsimple, vecsimple, vecsimple, vecsimple,  vecsimple,\n+                vecsimple\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n@@ -7744,9 +7776,26 @@\n   [(pc)]\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n+;;              GPR store  GPR load   GPR move   GPR li     GPR lis     GPR #\n+;;              FPR store  FPR load   FPR move   AVX store  AVX store   AVX load\n+;;              AVX load   VSX move   P9 0       P9 -1      AVX 0/-1    VSX 0\n+;;              VSX -1     P9 const   AVX const  From SPR   To SPR      SPR<->SPR\n+;;              FPR->GPR   GPR->FPR   VSX->GPR   GPR->VSX\n (define_insn \"*movdi_internal64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r,?m,?*d,?*d,r,*h,*h,r,?*wg,r,?*wj,?*wi\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,I,L,nF,d,m,d,*h,r,0,*wg,r,*wj,r,O\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\"\n+               \"=Y,        r,         r,         r,         r,          r,\n+                ?m,        ?*d,       ?*d,       ?Y,        ?Z,         ?*wb,\n+                ?*wv,      ?wi,       ?wo,       ?wo,       ?wv,        ?wi,\n+                ?wi,       ?wv,       ?wv,       r,         *h,         *h,\n+                ?*r,       ?*wg,      ?*r,       ?*wj\")\n+\n+\t(match_operand:DI 1 \"input_operand\"\n+                \"r,        Y,         r,         I,         L,          nF,\n+                 d,        m,         d,         wb,        wv,         Y,\n+                 Z,        wi,        Oj,        wM,        OjwM,       Oj,\n+                 wM,       wS,        wB,        *h,        r,          0,\n+                 wg,       r,         wj,        r\"))]\n+\n   \"TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\"\n@@ -7760,21 +7809,43 @@\n    stfd%U0%X0 %1,%0\n    lfd%U1%X1 %0,%1\n    fmr %0,%1\n+   stxsd %1,%0\n+   stxsdx %x1,%y0\n+   lxsd %0,%1\n+   lxsdx %x0,%y1\n+   xxlor %x0,%x1,%x1\n+   xxspltib %x0,0\n+   xxspltib %x0,255\n+   vspltisw %0,%1\n+   xxlxor %x0,%x0,%x0\n+   xxlorc %x0,%x0,%x0\n+   #\n+   #\n    mf%1 %0\n    mt%0 %1\n    nop\n    mftgpr %0,%1\n    mffgpr %0,%1\n    mfvsrd %0,%x1\n-   mtvsrd %x0,%1\n-   xxlxor %x0,%x0,%x0\"\n-  [(set_attr \"type\" \"store,load,*,*,*,*,fpstore,fpload,fp,mfjmpr,mtjmpr,*,mftgpr,mffgpr,mftgpr,mffgpr,vecsimple\")\n-   (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4,4,4,4,4\")])\n+   mtvsrd %x0,%1\"\n+  [(set_attr \"type\"\n+               \"store,     load,      *,         *,         *,          *,\n+                fpstore,   fpload,    fp,        fpstore,   fpstore,    fpload,\n+                fpload,    vecsimple, vecsimple, vecsimple, vecsimple,  vecsimple,\n+                vecsimple, vecsimple, vecsimple, mfjmpr,    mtjmpr,     *,\n+                mftgpr,    mffgpr,    mftgpr,    mffgpr\")\n+\n+   (set_attr \"length\"\n+               \"4,         4,         4,         4,         4,          20,\n+                4,         4,         4,         4,         4,          4,\n+                4,         4,         4,         4,         4,          8,\n+                8,         4,         4,         4,         4,          4,\n+                4,         4,         4,         4\")])\n \n ; Some DImode loads are best done as a load of -1 followed by a mask\n ; instruction.\n (define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\")\n+  [(set (match_operand:DI 0 \"int_reg_operand_not_pseudo\")\n \t(match_operand:DI 1 \"const_int_operand\"))]\n   \"TARGET_POWERPC64\n    && num_insns_constant (operands[1], DImode) > 1\n@@ -7791,7 +7862,7 @@\n ;; When non-easy constants can go in the TOC, this should use\n ;; easy_fp_constant predicate.\n (define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+  [(set (match_operand:DI 0 \"int_reg_operand_not_pseudo\" \"\")\n \t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n   \"TARGET_POWERPC64 && num_insns_constant (operands[1], DImode) > 1\"\n   [(set (match_dup 0) (match_dup 2))\n@@ -7805,7 +7876,7 @@\n }\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+  [(set (match_operand:DI 0 \"int_reg_operand_not_pseudo\" \"\")\n \t(match_operand:DI 1 \"const_scalar_int_operand\" \"\"))]\n   \"TARGET_POWERPC64 && num_insns_constant (operands[1], DImode) > 1\"\n   [(set (match_dup 0) (match_dup 2))\n@@ -7817,6 +7888,43 @@\n   else\n     FAIL;\n }\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"altivec_register_operand\" \"\")\n+\t(match_operand:DI 1 \"s5bit_cint_operand\" \"\"))]\n+  \"TARGET_UPPER_REGS_DI && TARGET_VSX && reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  int r = REGNO (op0);\n+  rtx op0_v4si = gen_rtx_REG (V4SImode, r);\n+\n+  emit_insn (gen_altivec_vspltisw (op0_v4si, op1));\n+  if (op1 != const0_rtx && op1 != constm1_rtx)\n+    {\n+      rtx op0_v2di = gen_rtx_REG (V2DImode, r);\n+      emit_insn (gen_altivec_vupkhsw (op0_v2di, op0_v4si));\n+    }\n+  DONE;\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"altivec_register_operand\" \"\")\n+\t(match_operand:DI 1 \"xxspltib_constant_split\" \"\"))]\n+  \"TARGET_UPPER_REGS_DI && TARGET_P9_VECTOR && reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  int r = REGNO (op0);\n+  rtx op0_v16qi = gen_rtx_REG (V16QImode, r);\n+\n+  emit_insn (gen_xxspltib_v16qi (op0_v16qi, op1));\n+  emit_insn (gen_vsx_sign_extend_qi_di (operands[0], op0_v16qi));\n+  DONE;\n+})\n+\n \f\n ;; TImode/PTImode is similar, except that we usually want to compute the\n ;; address into a register and use lsi/stsi (the exception is during reload)."}, {"sha": "4b9905fe7674d71d04f43b7299f6dddee6b8ee54", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -597,6 +597,10 @@ mupper-regs\n Target Report Var(TARGET_UPPER_REGS) Init(-1) Save\n Allow float/double variables in upper registers if cpu allows it.\n \n+mupper-regs-di\n+Target Report Mask(UPPER_REGS_DI) Var(rs6000_isa_flags)\n+Allow 64-bit integer variables in upper registers with -mcpu=power7 or -mvsx.\n+\n moptimize-swaps\n Target Undocumented Var(rs6000_optimize_swaps) Init(1) Save\n Analyze and remove doubleword swaps from VSX computations."}, {"sha": "a07d66e17f03858542cdff05ac8f1f3abd096ca1", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 46, "deletions": 54, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -260,7 +260,7 @@\n \t\t\t    (V2DI\t\"wi\")])\n \n ;; Iterators for loading constants with xxspltib\n-(define_mode_iterator VSINT_84  [V4SI V2DI])\n+(define_mode_iterator VSINT_84  [V4SI V2DI DI])\n (define_mode_iterator VSINT_842 [V8HI V4SI V2DI])\n \n ;; Constants for creating unspecs\n@@ -2095,77 +2095,69 @@\n   [(set_attr \"type\" \"vecperm\")])\n \n ;; Extract a DF/DI element from V2DF/V2DI\n-(define_expand \"vsx_extract_<mode>\"\n-  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"\")\n-\t(vec_select:<VS_scalar> (match_operand:VSX_D 1 \"register_operand\" \"\")\n-\t\t       (parallel\n-\t\t\t[(match_operand:QI 2 \"u5bit_cint_operand\" \"\")])))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"\")\n-\n ;; Optimize cases were we can do a simple or direct move.\n ;; Or see if we can avoid doing the move at all\n-(define_insn \"*vsx_extract_<mode>_internal1\"\n-  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"=d,<VS_64reg>,r,r\")\n+\n+;; There are some unresolved problems with reload that show up if an Altivec\n+;; register was picked.  Limit the scalar value to FPRs for now.\n+\n+(define_insn \"vsx_extract_<mode>\"\n+  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\"\n+            \"=d,     wm,      wo,    d\")\n+\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_D 1 \"register_operand\" \"d,<VS_64reg>,<VS_64dm>,<VS_64dm>\")\n+\t (match_operand:VSX_D 1 \"gpc_reg_operand\"\n+            \"<VSa>, <VSa>,  <VSa>,  <VSa>\")\n+\n \t (parallel\n-\t  [(match_operand:QI 2 \"vsx_scalar_64bit\" \"wD,wD,wD,wL\")])))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+\t  [(match_operand:QI 2 \"const_0_to_1_operand\"\n+            \"wD,    wD,     wL,     n\")])))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n {\n+  int element = INTVAL (operands[2]);\n   int op0_regno = REGNO (operands[0]);\n   int op1_regno = REGNO (operands[1]);\n+  int fldDM;\n \n-  if (op0_regno == op1_regno)\n-    return \"nop\";\n-\n-  if (INT_REGNO_P (op0_regno))\n-    return ((INTVAL (operands[2]) == VECTOR_ELEMENT_MFVSRLD_64BIT)\n-\t    ? \"mfvsrdl %0,%x1\"\n-\t    : \"mfvsrd %0,%x1\");\n+  gcc_assert (IN_RANGE (element, 0, 1));\n+  gcc_assert (VSX_REGNO_P (op1_regno));\n \n-  if (FP_REGNO_P (op0_regno) && FP_REGNO_P (op1_regno))\n-    return \"fmr %0,%1\";\n+  if (element == VECTOR_ELEMENT_SCALAR_64BIT)\n+    {\n+      if (op0_regno == op1_regno)\n+\treturn ASM_COMMENT_START \" vec_extract to same register\";\n \n-  return \"xxlor %x0,%x1,%x1\";\n-}\n-  [(set_attr \"type\" \"fp,vecsimple,mftgpr,mftgpr\")\n-   (set_attr \"length\" \"4\")])\n+      else if (INT_REGNO_P (op0_regno) && TARGET_DIRECT_MOVE\n+\t       && TARGET_POWERPC64)\n+\treturn \"mfvsrd %0,%x1\";\n \n-(define_insn \"*vsx_extract_<mode>_internal2\"\n-  [(set (match_operand:<VS_scalar> 0 \"vsx_register_operand\" \"=d,<VS_64reg>,<VS_64reg>\")\n-\t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_D 1 \"vsx_register_operand\" \"d,wd,wd\")\n-\t (parallel [(match_operand:QI 2 \"u5bit_cint_operand\" \"wD,wD,i\")])))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\n-   && (!TARGET_POWERPC64 || !TARGET_DIRECT_MOVE\n-       || INTVAL (operands[2]) != VECTOR_ELEMENT_SCALAR_64BIT)\"\n-{\n-  int fldDM;\n-  gcc_assert (UINTVAL (operands[2]) <= 1);\n+      else if (FP_REGNO_P (op0_regno) && FP_REGNO_P (op1_regno))\n+\treturn \"fmr %0,%1\";\n \n-  if (INTVAL (operands[2]) == VECTOR_ELEMENT_SCALAR_64BIT)\n-    {\n-      int op0_regno = REGNO (operands[0]);\n-      int op1_regno = REGNO (operands[1]);\n+      else if (VSX_REGNO_P (op0_regno))\n+\treturn \"xxlor %x0,%x1,%x1\";\n \n-      if (op0_regno == op1_regno)\n-\treturn \"nop\";\n+      else\n+\tgcc_unreachable ();\n+    }\n \n-      if (FP_REGNO_P (op0_regno) && FP_REGNO_P (op1_regno))\n-\treturn \"fmr %0,%1\";\n+  else if (element == VECTOR_ELEMENT_MFVSRLD_64BIT && INT_REGNO_P (op0_regno)\n+\t   && TARGET_P9_VECTOR && TARGET_POWERPC64 && TARGET_DIRECT_MOVE)\n+    return \"mfvsrdl %0,%x1\";\n \n-      return \"xxlor %x0,%x1,%x1\";\n+  else if (VSX_REGNO_P (op0_regno))\n+    {\n+      fldDM = element << 1;\n+      if (!BYTES_BIG_ENDIAN)\n+\tfldDM = 3 - fldDM;\n+      operands[3] = GEN_INT (fldDM);\n+      return \"xxpermdi %x0,%x1,%x1,%3\";\n     }\n \n-  fldDM = INTVAL (operands[2]) << 1;\n-  if (!BYTES_BIG_ENDIAN)\n-    fldDM = 3 - fldDM;\n-  operands[3] = GEN_INT (fldDM);\n-  return \"xxpermdi %x0,%x1,%x1,%3\";\n+  else\n+    gcc_unreachable ();\n }\n-  [(set_attr \"type\" \"fp,vecsimple,vecperm\")\n-   (set_attr \"length\" \"4\")])\n+  [(set_attr \"type\" \"vecsimple,mftgpr,mftgpr,vecperm\")])\n \n ;; Optimize extracting a single scalar element from memory if the scalar is in\n ;; the correct location to use a single load."}, {"sha": "787347868291610a4897e5c49a4bef6916d4d1db", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -1009,6 +1009,7 @@ See RS/6000 and PowerPC Options.\n -mquad-memory-atomic -mno-quad-memory-atomic @gol\n -mcompat-align-parm -mno-compat-align-parm @gol\n -mupper-regs-df -mno-upper-regs-df -mupper-regs-sf -mno-upper-regs-sf @gol\n+-mupper-regs-di -mno-upper-regs-di @gol\n -mupper-regs -mno-upper-regs -mmodulo -mno-modulo @gol\n -mfloat128 -mno-float128 -mfloat128-hardware -mno-float128-hardware @gol\n -mpower9-fusion -mno-mpower9-fusion -mpower9-vector -mno-power9-vector @gol\n@@ -20255,6 +20256,17 @@ Generate code that uses (does not use) the atomic quad word memory\n instructions.  The @option{-mquad-memory-atomic} option requires use of\n 64-bit mode.\n \n+@item -mupper-regs-di\n+@itemx -mno-upper-regs-di\n+@opindex mupper-regs-di\n+@opindex mno-upper-regs-di\n+Generate code that uses (does not use) the scalar instructions that\n+target all 64 registers in the vector/scalar floating point register\n+set that were added in version 2.06 of the PowerPC ISA when processing\n+integers.  @option{-mupper-regs-di} is turned on by default if you use\n+any of the @option{-mcpu=power7}, @option{-mcpu=power8},\n+@option{-mcpu=power9}, or @option{-mvsx} options.\n+\n @item -mupper-regs-df\n @itemx -mno-upper-regs-df\n @opindex mupper-regs-df\n@@ -20263,8 +20275,8 @@ Generate code that uses (does not use) the scalar double precision\n instructions that target all 64 registers in the vector/scalar\n floating point register set that were added in version 2.06 of the\n PowerPC ISA.  @option{-mupper-regs-df} is turned on by default if you\n-use any of the @option{-mcpu=power7}, @option{-mcpu=power8}, or\n-@option{-mvsx} options.\n+use any of the @option{-mcpu=power7}, @option{-mcpu=power8},\n+@option{-mcpu=power9}, or @option{-mvsx} options.\n \n @item -mupper-regs-sf\n @itemx -mno-upper-regs-sf\n@@ -20274,8 +20286,8 @@ Generate code that uses (does not use) the scalar single precision\n instructions that target all 64 registers in the vector/scalar\n floating point register set that were added in version 2.07 of the\n PowerPC ISA.  @option{-mupper-regs-sf} is turned on by default if you\n-use either of the @option{-mcpu=power8} or @option{-mpower8-vector}\n-options.\n+use either of the @option{-mcpu=power8}, @option{-mpower8-vector}, or\n+@option{-mpower9} options.\n \n @item -mupper-regs\n @itemx -mno-upper-regs"}, {"sha": "1a52ff0688f7f0aa1dff49552ba6d753bd149dc2", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -3211,6 +3211,9 @@ FP or VSX register to perform ISA 2.07 float ops or NO_REGS.\n @item wz\n Floating point register if the LFIWZX instruction is enabled or NO_REGS.\n \n+@item wB\n+Signed 5-bit constant integer that can be loaded into an altivec register.\n+\n @item wD\n Int constant that is the element number of the 64-bit scalar in a vector.\n "}, {"sha": "be12713dd9b964a35279bf4d1ec5e74ee82232b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -1,3 +1,8 @@\n+2016-06-15  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/p9-dimode1.c: New test.\n+\t* gcc.target/powerpc/p9-dimode2.c: Likewise.\n+\n 2016-06-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/compile/20160615-1.c: New test."}, {"sha": "6ba610ba9380eb77792bc8536a3c7d30d73a587a", "filename": "gcc/testsuite/gcc.target/powerpc/p9-dimode1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-dimode1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-dimode1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-dimode1.c?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2 -mupper-regs-di\" } */\n+\n+/* Verify P9 changes to allow DImode into Altivec registers, and generate\n+   constants using XXSPLTIB.  */\n+\n+#ifndef _ARCH_PPC64\n+#error \"This code is 64-bit.\"\n+#endif\n+\n+double\n+p9_zero (void)\n+{\n+  long l = 0;\n+  double ret;\n+\n+  __asm__ (\"xxlor %x0,%x1,%x1\" : \"=&d\" (ret) : \"wi\" (l));\n+\n+  return ret;\n+}\n+\n+double\n+p9_plus_1 (void)\n+{\n+  long l = 1;\n+  double ret;\n+\n+  __asm__ (\"xxlor %x0,%x1,%x1\" : \"=&d\" (ret) : \"wi\" (l));\n+\n+  return ret;\n+}\n+\n+double\n+p9_minus_1 (void)\n+{\n+  long l = -1;\n+  double ret;\n+\n+  __asm__ (\"xxlor %x0,%x1,%x1\" : \"=&d\" (ret) : \"wi\" (l));\n+\n+  return ret;\n+}\n+\n+/* { dg-final { scan-assembler     \"xxspltib\" } } */\n+/* { dg-final { scan-assembler-not \"mtvsrd\"   } } */\n+/* { dg-final { scan-assembler-not \"lfd\"      } } */\n+/* { dg-final { scan-assembler-not \"ld\"       } } */\n+/* { dg-final { scan-assembler-not \"lxsd\"     } } */"}, {"sha": "0567a6552777d0f74d92ab17f6bf403cee4330f8", "filename": "gcc/testsuite/gcc.target/powerpc/p9-dimode2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-dimode2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c3ee9bc4639fc67e037b6837d2625327555fd/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-dimode2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-dimode2.c?ref=1a3c3ee9bc4639fc67e037b6837d2625327555fd", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2 -mupper-regs-di\" } */\n+\n+/* Verify that large integer constants are loaded via direct move instead of being\n+   loaded from memory.  */\n+\n+#ifndef _ARCH_PPC64\n+#error \"This code is 64-bit.\"\n+#endif\n+\n+double\n+p9_large (void)\n+{\n+  long l = 0x12345678;\n+  double ret;\n+\n+  __asm__ (\"xxlor %x0,%x1,%x1\" : \"=&d\" (ret) : \"wi\" (l));\n+\n+  return ret;\n+}\n+\n+/* { dg-final { scan-assembler     \"mtvsrd\"   } } */\n+/* { dg-final { scan-assembler-not \"ld\"       } } */\n+/* { dg-final { scan-assembler-not \"lfd\"      } } */\n+/* { dg-final { scan-assembler-not \"lxsd\"     } } */"}]}