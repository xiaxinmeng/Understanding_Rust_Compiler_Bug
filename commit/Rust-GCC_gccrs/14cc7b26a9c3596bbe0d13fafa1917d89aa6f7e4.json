{"sha": "14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRjYzdiMjZhOWMzNTk2YmJlMGQxM2ZhZmExOTE3ZDg5YWE2ZjdlNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-02-08T11:37:40Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-02-08T11:37:40Z"}, "message": "trans.c (gnat_to_gnu): Minor tweak.\n\n\t* gcc-interface/trans.c (gnat_to_gnu) <N_Aggregate>: Minor tweak.\n\t* gcc-interface/utils.c (convert): Do not pad when doing an unchecked\n\tconversion here.  Use TREE_CONSTANT throughout the function.\n\t(unchecked_convert): Also pad if the source is a CONSTRUCTOR and the\n\tdestination is a more aligned array type or a larger aggregate type,\n\tbut not between original and packable versions of a type.\n\nFrom-SVN: r268679", "tree": {"sha": "d0eab903042d61eeb3fc2bfedd12d5463929e88e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0eab903042d61eeb3fc2bfedd12d5463929e88e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4/comments", "author": null, "committer": null, "parents": [{"sha": "694b3bb3c33643ce697019db6d6eeeede4def168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/694b3bb3c33643ce697019db6d6eeeede4def168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/694b3bb3c33643ce697019db6d6eeeede4def168"}], "stats": {"total": 63, "additions": 42, "deletions": 21}, "files": [{"sha": "9003beccacecdeb754cc3196b120040885cb5612", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4", "patch": "@@ -1,3 +1,12 @@\n+2019-02-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gnat_to_gnu) <N_Aggregate>: Minor tweak.\n+\t* gcc-interface/utils.c (convert): Do not pad when doing an unchecked\n+\tconversion here.  Use TREE_CONSTANT throughout the function.\n+\t(unchecked_convert): Also pad if the source is a CONSTRUCTOR and the\n+\tdestination is a more aligned array type or a larger aggregate type,\n+\tbut not between original and packable versions of a type.\n+\n 2019-02-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (max_size) <tcc_unary>: Be prepared for an"}, {"sha": "155cb4b27abc3ac6063c4f630b400714c244b258", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4", "patch": "@@ -7230,20 +7230,19 @@ gnat_to_gnu (Node_Id gnat_node)\n       {\n \ttree gnu_aggr_type;\n \n-\t/* ??? It is wrong to evaluate the type now, but there doesn't\n-\t   seem to be any other practical way of doing it.  */\n-\n+\t/* Check that this aggregate has not slipped through the cracks.  */\n \tgcc_assert (!Expansion_Delayed (gnat_node));\n \n-\tgnu_aggr_type = gnu_result_type\n-\t  = get_unpadded_type (Etype (gnat_node));\n+\tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n \tif (TREE_CODE (gnu_result_type) == RECORD_TYPE\n \t    && TYPE_CONTAINS_TEMPLATE_P (gnu_result_type))\n \t  gnu_aggr_type\n \t    = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_result_type)));\n \telse if (TREE_CODE (gnu_result_type) == VECTOR_TYPE)\n \t  gnu_aggr_type = TYPE_REPRESENTATIVE_ARRAY (gnu_result_type);\n+\telse\n+\t  gnu_aggr_type = gnu_result_type;\n \n \tif (Null_Record_Present (gnat_node))\n \t  gnu_result = gnat_build_constructor (gnu_aggr_type, NULL);"}, {"sha": "da4e1009e8c5fb522de3317193155854102de395", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=14cc7b26a9c3596bbe0d13fafa1917d89aa6f7e4", "patch": "@@ -4356,19 +4356,12 @@ convert (tree type, tree expr)\n \n       /* If the inner type is of self-referential size and the expression type\n \t is a record, do this as an unchecked conversion unless both types are\n-\t essentially the same.  But first pad the expression if possible to\n-\t have the same size on both sides.  */\n+\t essentially the same.  */\n       if (ecode == RECORD_TYPE\n \t  && CONTAINS_PLACEHOLDER_P (DECL_SIZE (TYPE_FIELDS (type)))\n \t  && TYPE_MAIN_VARIANT (etype)\n \t     != TYPE_MAIN_VARIANT (TREE_TYPE (TYPE_FIELDS (type))))\n-\t{\n-\t  if (TREE_CODE (TYPE_SIZE (etype)) == INTEGER_CST)\n-\t    expr = convert (maybe_pad_type (etype, TYPE_SIZE (type), 0, Empty,\n-\t\t\t\t\t    false, false, false, true),\n-\t\t\t    expr);\n-\t  return unchecked_convert (type, expr, false);\n-\t}\n+\treturn unchecked_convert (type, expr, false);\n \n       /* If we are converting between array types with variable size, do the\n \t final conversion as an unchecked conversion, again to avoid the need\n@@ -4483,9 +4476,9 @@ convert (tree type, tree expr)\n     case STRING_CST:\n       /* If we are converting a STRING_CST to another constrained array type,\n \t just make a new one in the proper type.  */\n-      if (code == ecode && AGGREGATE_TYPE_P (etype)\n-\t  && !(TREE_CODE (TYPE_SIZE (etype)) == INTEGER_CST\n-\t       && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST))\n+      if (code == ecode\n+\t  && !(TREE_CONSTANT (TYPE_SIZE (etype))\n+\t       && !TREE_CONSTANT (TYPE_SIZE (type))))\n \t{\n \t  expr = copy_node (expr);\n \t  TREE_TYPE (expr) = type;\n@@ -5332,7 +5325,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n      so we skip all expressions that are references.  */\n   else if (!REFERENCE_CLASS_P (expr)\n \t   && !AGGREGATE_TYPE_P (etype)\n-\t   && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t   && TREE_CONSTANT (TYPE_SIZE (type))\n \t   && (c = tree_int_cst_compare (TYPE_SIZE (etype), TYPE_SIZE (type))))\n     {\n       if (c < 0)\n@@ -5380,10 +5373,13 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n       return unchecked_convert (type, expr, notrunc_p);\n     }\n \n-  /* If we are converting a CONSTRUCTOR to a more aligned RECORD_TYPE, bump\n-     the alignment of the CONSTRUCTOR to speed up the copy operation.  */\n+  /* If we are converting a CONSTRUCTOR to a more aligned aggregate type, bump\n+     the alignment of the CONSTRUCTOR to speed up the copy operation.  But do\n+     not do it for a conversion between original and packable version to avoid\n+     an infinite recursion.  */\n   else if (TREE_CODE (expr) == CONSTRUCTOR\n-\t   && code == RECORD_TYPE\n+\t   && AGGREGATE_TYPE_P (type)\n+\t   && TYPE_NAME (type) != TYPE_NAME (etype)\n \t   && TYPE_ALIGN (etype) < TYPE_ALIGN (type))\n     {\n       expr = convert (maybe_pad_type (etype, NULL_TREE, TYPE_ALIGN (type),\n@@ -5392,6 +5388,23 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n       return unchecked_convert (type, expr, notrunc_p);\n     }\n \n+  /* If we are converting a CONSTRUCTOR to a larger aggregate type, bump the\n+     size of the CONSTRUCTOR to make sure there are enough allocated bytes.\n+     But do not do it for a conversion between original and packable version\n+     to avoid an infinite recursion.  */\n+  else if (TREE_CODE (expr) == CONSTRUCTOR\n+\t   && AGGREGATE_TYPE_P (type)\n+\t   && TYPE_NAME (type) != TYPE_NAME (etype)\n+\t   && TREE_CONSTANT (TYPE_SIZE (type))\n+\t   && (!TREE_CONSTANT (TYPE_SIZE (etype))\n+\t       || tree_int_cst_lt (TYPE_SIZE (etype), TYPE_SIZE (type))))\n+    {\n+      expr = convert (maybe_pad_type (etype, TYPE_SIZE (type), 0,\n+\t\t\t\t      Empty, false, false, false, true),\n+\t\t      expr);\n+      return unchecked_convert (type, expr, notrunc_p);\n+    }\n+\n   /* Otherwise, just build a VIEW_CONVERT_EXPR of the expression.  */\n   else\n     {"}]}