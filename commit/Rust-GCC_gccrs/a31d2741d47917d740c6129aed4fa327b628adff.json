{"sha": "a31d2741d47917d740c6129aed4fa327b628adff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMxZDI3NDFkNDc5MTdkNzQwYzYxMjlhZWQ0ZmEzMjdiNjI4YWRmZg==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2014-06-18T10:43:50Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2014-06-18T10:43:50Z"}, "message": "re PR tree-optimization/61517 (wrong code at -Os and above on x86_64-linux-gnu)\n\n2014-06-18  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    PR tree-optimization/61517\n    * tree-ssa-math-opts.c (find_bswap_or_nop_1): Adapt to return a stmt\n    whose rhs's first tree is the source expression instead of the\n    expression itself.\n    (find_bswap_or_nop): Likewise.\n    (bsap_replace): Rename stmt in cur_stmt. Pass gsi by value and src as a\n    gimple stmt whose rhs's first tree is the source. In the memory source\n    case, move the stmt to be replaced close to one of the original load to\n    avoid the problem of a store between the load and the stmt's original\n    location.\n    (pass_optimize_bswap::execute): Adapt to change in bswap_replace's\n    signature.\n\n    gcc/testsuite/\n    * gcc.c-torture/execute/bswap-2.c (incorrect_read_le32): New.\n    (incorrect_read_be32): Likewise.\n    (main): Call incorrect_read_* to test stmt replacement is made by\n    bswap at the right place.\n    * gcc.c-torture/execute/pr61517.c: New test.\n\nFrom-SVN: r211778", "tree": {"sha": "e8d3e1567ee299b39a8ee648fa069544453c5308", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8d3e1567ee299b39a8ee648fa069544453c5308"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a31d2741d47917d740c6129aed4fa327b628adff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a31d2741d47917d740c6129aed4fa327b628adff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a31d2741d47917d740c6129aed4fa327b628adff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a31d2741d47917d740c6129aed4fa327b628adff/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0f37b26c5b459cc601ad226a6e4a13b45f5e454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0f37b26c5b459cc601ad226a6e4a13b45f5e454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0f37b26c5b459cc601ad226a6e4a13b45f5e454"}], "stats": {"total": 255, "additions": 172, "deletions": 83}, "files": [{"sha": "da64ccad7476fa5363be7d825e3a23d70f905efc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a31d2741d47917d740c6129aed4fa327b628adff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a31d2741d47917d740c6129aed4fa327b628adff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a31d2741d47917d740c6129aed4fa327b628adff", "patch": "@@ -1,3 +1,18 @@\n+2014-06-18  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/61517\n+\t* tree-ssa-math-opts.c (find_bswap_or_nop_1): Adapt to return a stmt\n+\twhose rhs's first tree is the source expression instead of the\n+\texpression itself.\n+\t(find_bswap_or_nop): Likewise.\n+\t(bsap_replace): Rename stmt in cur_stmt. Pass gsi by value and src as a\n+\tgimple stmt whose rhs's first tree is the source. In the memory source\n+\tcase, move the stmt to be replaced close to one of the original load to\n+\tavoid the problem of a store between the load and the stmt's original\n+\tlocation.\n+\t(pass_optimize_bswap::execute): Adapt to change in bswap_replace's\n+\tsignature.\n+\n 2014-06-18  Andreas Schwab  <schwab@suse.de>\n \n \tPR rtl-optimization/54555"}, {"sha": "c67305601e6b6501ca8527a98072d985aa33af2e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a31d2741d47917d740c6129aed4fa327b628adff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a31d2741d47917d740c6129aed4fa327b628adff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a31d2741d47917d740c6129aed4fa327b628adff", "patch": "@@ -1,3 +1,12 @@\n+2014-06-18  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/61517\n+\t* gcc.c-torture/execute/bswap-2.c (incorrect_read_le32): New.\n+\t(incorrect_read_be32): Likewise.\n+\t(main): Call incorrect_read_* to test stmt replacement is made by\n+\tbswap at the right place.\n+\t* gcc.c-torture/execute/pr61517.c: New test.\n+\n 2014-06-18  Andreas Schwab  <schwab@suse.de>\n \n \tPR rtl-optimization/54555"}, {"sha": "88132fe78592da0303d0a7beeb8feb5926064415", "filename": "gcc/testsuite/gcc.c-torture/execute/bswap-2.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a31d2741d47917d740c6129aed4fa327b628adff/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbswap-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a31d2741d47917d740c6129aed4fa327b628adff/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbswap-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbswap-2.c?ref=a31d2741d47917d740c6129aed4fa327b628adff", "patch": "@@ -66,6 +66,32 @@ fake_read_be32 (char *x, char *y)\n   return c3 | c2 << 8 | c1 << 16 | c0 << 24;\n }\n \n+__attribute__ ((noinline, noclone)) uint32_t\n+incorrect_read_le32 (char *x, char *y)\n+{\n+  unsigned char c0, c1, c2, c3;\n+\n+  c0 = x[0];\n+  c1 = x[1];\n+  c2 = x[2];\n+  c3 = x[3];\n+  *y = 1;\n+  return c0 | c1 << 8 | c2 << 16 | c3 << 24;\n+}\n+\n+__attribute__ ((noinline, noclone)) uint32_t\n+incorrect_read_be32 (char *x, char *y)\n+{\n+  unsigned char c0, c1, c2, c3;\n+\n+  c0 = x[0];\n+  c1 = x[1];\n+  c2 = x[2];\n+  c3 = x[3];\n+  *y = 1;\n+  return c3 | c2 << 8 | c1 << 16 | c0 << 24;\n+}\n+\n int\n main ()\n {\n@@ -92,8 +118,17 @@ main ()\n   out = fake_read_le32 (cin, &cin[2]);\n   if (out != 0x89018583)\n     __builtin_abort ();\n+  cin[2] = 0x87;\n   out = fake_read_be32 (cin, &cin[2]);\n   if (out != 0x83850189)\n     __builtin_abort ();\n+  cin[2] = 0x87;\n+  out = incorrect_read_le32 (cin, &cin[2]);\n+  if (out != 0x89878583)\n+    __builtin_abort ();\n+  cin[2] = 0x87;\n+  out = incorrect_read_be32 (cin, &cin[2]);\n+  if (out != 0x83858789)\n+    __builtin_abort ();\n   return 0;\n }"}, {"sha": "fc9bbe85a4183732f1cc416555f0deeaed82a3ca", "filename": "gcc/testsuite/gcc.c-torture/execute/pr61517.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a31d2741d47917d740c6129aed4fa327b628adff/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr61517.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a31d2741d47917d740c6129aed4fa327b628adff/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr61517.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr61517.c?ref=a31d2741d47917d740c6129aed4fa327b628adff", "patch": "@@ -0,0 +1,19 @@\n+int a, b, *c = &a;\n+unsigned short d;\n+\n+int\n+main ()\n+{\n+  unsigned int e = a;\n+  *c = 1;\n+  if (!b)\n+    {\n+      d = e;\n+      *c = d | e;\n+    }\n+\n+  if (a != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "21345473e774c61a1bc058a5cd2bee3ad2a40340", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 94, "deletions": 83, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a31d2741d47917d740c6129aed4fa327b628adff/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a31d2741d47917d740c6129aed4fa327b628adff/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=a31d2741d47917d740c6129aed4fa327b628adff", "patch": "@@ -1806,28 +1806,28 @@ find_bswap_or_nop_load (gimple stmt, tree ref, struct symbolic_number *n)\n \n /* find_bswap_or_nop_1 invokes itself recursively with N and tries to perform\n    the operation given by the rhs of STMT on the result.  If the operation\n-   could successfully be executed the function returns the tree expression of\n-   the source operand and NULL otherwise.  */\n+   could successfully be executed the function returns a gimple stmt whose\n+   rhs's first tree is the expression of the source operand and NULL\n+   otherwise.  */\n \n-static tree\n+static gimple\n find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n {\n   enum tree_code code;\n   tree rhs1, rhs2 = NULL;\n-  gimple rhs1_stmt, rhs2_stmt;\n-  tree source_expr1;\n+  gimple rhs1_stmt, rhs2_stmt, source_stmt1;\n   enum gimple_rhs_class rhs_class;\n \n   if (!limit || !is_gimple_assign (stmt))\n-    return NULL_TREE;\n+    return NULL;\n \n   rhs1 = gimple_assign_rhs1 (stmt);\n \n   if (find_bswap_or_nop_load (stmt, rhs1, n))\n-    return rhs1;\n+    return stmt;\n \n   if (TREE_CODE (rhs1) != SSA_NAME)\n-    return NULL_TREE;\n+    return NULL;\n \n   code = gimple_assign_rhs_code (stmt);\n   rhs_class = gimple_assign_rhs_class (stmt);\n@@ -1850,18 +1850,18 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t  && code != RROTATE_EXPR\n \t  && code != NOP_EXPR\n \t  && code != CONVERT_EXPR)\n-\treturn NULL_TREE;\n+\treturn NULL;\n \n-      source_expr1 = find_bswap_or_nop_1 (rhs1_stmt, n, limit - 1);\n+      source_stmt1 = find_bswap_or_nop_1 (rhs1_stmt, n, limit - 1);\n \n       /* If find_bswap_or_nop_1 returned NULL, STMT is a leaf node and\n \t we have to initialize the symbolic number.  */\n-      if (!source_expr1)\n+      if (!source_stmt1)\n \t{\n \t  if (gimple_assign_load_p (stmt)\n \t      || !init_symbolic_number (n, rhs1))\n-\t    return NULL_TREE;\n-\t  source_expr1 = rhs1;\n+\t    return NULL;\n+\t  source_stmt1 = stmt;\n \t}\n \n       switch (code)\n@@ -1875,7 +1875,7 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t    /* Only constants masking full bytes are allowed.  */\n \t    for (i = 0; i < size; i++, tmp >>= BITS_PER_UNIT)\n \t      if ((tmp & 0xff) != 0 && (tmp & 0xff) != 0xff)\n-\t\treturn NULL_TREE;\n+\t\treturn NULL;\n \n \t    n->n &= val;\n \t  }\n@@ -1885,7 +1885,7 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \tcase LROTATE_EXPR:\n \tcase RROTATE_EXPR:\n \t  if (!do_shift_rotate (code, n, (int)TREE_INT_CST_LOW (rhs2)))\n-\t    return NULL_TREE;\n+\t    return NULL;\n \t  break;\n \tCASE_CONVERT:\n \t  {\n@@ -1895,16 +1895,16 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t    type = gimple_expr_type (stmt);\n \t    type_size = TYPE_PRECISION (type);\n \t    if (type_size % BITS_PER_UNIT != 0)\n-\t      return NULL_TREE;\n+\t      return NULL;\n \t    if (type_size > (int)sizeof (uint64_t) * 8)\n-\t      return NULL_TREE;\n+\t      return NULL;\n \n \t    /* Sign extension: result is dependent on the value.  */\n \t    old_type_size = TYPE_PRECISION (n->type);\n \t    if (!TYPE_UNSIGNED (n->type)\n \t\t&& type_size > old_type_size\n \t\t&& n->n & (0xff << (old_type_size - 8)))\n-\t      return NULL_TREE;\n+\t      return NULL;\n \n \t    if (type_size / BITS_PER_UNIT < (int)(sizeof (int64_t)))\n \t      {\n@@ -1918,9 +1918,9 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t  }\n \t  break;\n \tdefault:\n-\t  return NULL_TREE;\n+\t  return NULL;\n \t};\n-      return verify_symbolic_number_p (n, stmt) ? source_expr1 : NULL;\n+      return verify_symbolic_number_p (n, stmt) ? source_stmt1 : NULL;\n     }\n \n   /* Handle binary rhs.  */\n@@ -1930,37 +1930,38 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n       int i, size;\n       struct symbolic_number n1, n2;\n       uint64_t mask;\n-      tree source_expr2;\n+      gimple source_stmt2;\n \n       if (code != BIT_IOR_EXPR)\n-\treturn NULL_TREE;\n+\treturn NULL;\n \n       if (TREE_CODE (rhs2) != SSA_NAME)\n-\treturn NULL_TREE;\n+\treturn NULL;\n \n       rhs2_stmt = SSA_NAME_DEF_STMT (rhs2);\n \n       switch (code)\n \t{\n \tcase BIT_IOR_EXPR:\n-\t  source_expr1 = find_bswap_or_nop_1 (rhs1_stmt, &n1, limit - 1);\n+\t  source_stmt1 = find_bswap_or_nop_1 (rhs1_stmt, &n1, limit - 1);\n \n-\t  if (!source_expr1)\n-\t    return NULL_TREE;\n+\t  if (!source_stmt1)\n+\t    return NULL;\n \n-\t  source_expr2 = find_bswap_or_nop_1 (rhs2_stmt, &n2, limit - 1);\n+\t  source_stmt2 = find_bswap_or_nop_1 (rhs2_stmt, &n2, limit - 1);\n \n-\t  if (!source_expr2)\n-\t    return NULL_TREE;\n+\t  if (!source_stmt2)\n+\t    return NULL;\n \n \t  if (TYPE_PRECISION (n1.type) != TYPE_PRECISION (n2.type))\n-\t    return NULL_TREE;\n+\t    return NULL;\n \n \t  if (!n1.vuse != !n2.vuse ||\n \t  (n1.vuse && !operand_equal_p (n1.vuse, n2.vuse, 0)))\n-\t    return NULL_TREE;\n+\t    return NULL;\n \n-\t  if (source_expr1 != source_expr2)\n+\t  if (gimple_assign_rhs1 (source_stmt1)\n+\t      != gimple_assign_rhs1 (source_stmt2))\n \t    {\n \t      int64_t inc, mask;\n \t      unsigned i;\n@@ -1969,10 +1970,10 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \n \t      if (!n1.base_addr || !n2.base_addr\n \t\t  || !operand_equal_p (n1.base_addr, n2.base_addr, 0))\n-\t\treturn NULL_TREE;\n+\t\treturn NULL;\n \t      if (!n1.offset != !n2.offset ||\n \t          (n1.offset && !operand_equal_p (n1.offset, n2.offset, 0)))\n-\t\treturn NULL_TREE;\n+\t\treturn NULL;\n \n \t      /* We swap n1 with n2 to have n1 < n2.  */\n \t      if (n2.bytepos < n1.bytepos)\n@@ -1982,14 +1983,14 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t\t  tmpn = n2;\n \t\t  n2 = n1;\n \t\t  n1 = tmpn;\n-\t\t  source_expr1 = source_expr2;\n+\t\t  source_stmt1 = source_stmt2;\n \t\t}\n \n \t      off_sub = n2.bytepos - n1.bytepos;\n \n \t      /* Check that the range of memory covered < biggest int size.  */\n \t      if (off_sub + n2.range > (int) sizeof (int64_t))\n-\t        return NULL_TREE;\n+\t\treturn NULL;\n \t      n->range = n2.range + off_sub;\n \n \t      /* Reinterpret byte marks in symbolic number holding the value of\n@@ -2028,30 +2029,31 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t      masked1 = n1.n & mask;\n \t      masked2 = n2.n & mask;\n \t      if (masked1 && masked2 && masked1 != masked2)\n-\t\treturn NULL_TREE;\n+\t\treturn NULL;\n \t    }\n \t  n->n = n1.n | n2.n;\n \n \t  if (!verify_symbolic_number_p (n, stmt))\n-\t    return NULL_TREE;\n+\t    return NULL;\n \n \t  break;\n \tdefault:\n-\t  return NULL_TREE;\n+\t  return NULL;\n \t}\n-      return source_expr1;\n+      return source_stmt1;\n     }\n-  return NULL_TREE;\n+  return NULL;\n }\n \n /* Check if STMT completes a bswap implementation or a read in a given\n    endianness consisting of ORs, SHIFTs and ANDs and sets *BSWAP\n    accordingly.  It also sets N to represent the kind of operations\n    performed: size of the resulting expression and whether it works on\n    a memory source, and if so alias-set and vuse.  At last, the\n-   function returns the source tree expression.  */\n+   function returns a stmt whose rhs's first tree is the source\n+   expression.  */\n \n-static tree\n+static gimple\n find_bswap_or_nop (gimple stmt, struct symbolic_number *n, bool *bswap)\n {\n /* The number which the find_bswap_or_nop_1 result should match in order\n@@ -2060,7 +2062,7 @@ find_bswap_or_nop (gimple stmt, struct symbolic_number *n, bool *bswap)\n   uint64_t cmpxchg = CMPXCHG;\n   uint64_t cmpnop = CMPNOP;\n \n-  tree source_expr;\n+  gimple source_stmt;\n   int limit;\n \n   /* The last parameter determines the depth search limit.  It usually\n@@ -2070,10 +2072,10 @@ find_bswap_or_nop (gimple stmt, struct symbolic_number *n, bool *bswap)\n      in libgcc, and for initial shift/and operation of the src operand.  */\n   limit = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (gimple_expr_type (stmt)));\n   limit += 1 + (int) ceil_log2 ((unsigned HOST_WIDE_INT) limit);\n-  source_expr =  find_bswap_or_nop_1 (stmt, n, limit);\n+  source_stmt =  find_bswap_or_nop_1 (stmt, n, limit);\n \n-  if (!source_expr)\n-    return NULL_TREE;\n+  if (!source_stmt)\n+    return NULL;\n \n   /* Find real size of result (highest non zero byte).  */\n   if (n->base_addr)\n@@ -2103,14 +2105,14 @@ find_bswap_or_nop (gimple stmt, struct symbolic_number *n, bool *bswap)\n   else if (n->n == cmpxchg)\n     *bswap = true;\n   else\n-    return NULL_TREE;\n+    return NULL;\n \n   /* Useless bit manipulation performed by code.  */\n   if (!n->base_addr && n->n == cmpnop)\n-    return NULL_TREE;\n+    return NULL;\n \n   n->range *= BITS_PER_UNIT;\n-  return source_expr;\n+  return source_stmt;\n }\n \n namespace {\n@@ -2146,26 +2148,30 @@ class pass_optimize_bswap : public gimple_opt_pass\n \n }; // class pass_optimize_bswap\n \n-/* Perform the bswap optimization: replace the statement STMT at GSI\n-   with load type, VUSE and set-alias as described by N if a memory\n-   source is involved (N->base_addr is non null), followed by the\n-   builtin bswap invocation in FNDECL if BSWAP is true.  SRC gives\n-   the source on which STMT is operating and N->range gives the\n-   size of the expression involved for maintaining some statistics.  */\n+/* Perform the bswap optimization: replace the statement CUR_STMT at\n+   GSI with a load of type, VUSE and set-alias as described by N if a\n+   memory source is involved (N->base_addr is non null), followed by\n+   the builtin bswap invocation in FNDECL if BSWAP is true.  SRC_STMT\n+   gives where should the replacement be made.  It also gives the\n+   source on which CUR_STMT is operating via its rhs's first tree nad\n+   N->range gives the size of the expression involved for maintaining\n+   some statistics.  */\n \n static bool\n-bswap_replace (gimple stmt, gimple_stmt_iterator *gsi, tree src, tree fndecl,\n-\t       tree bswap_type, tree load_type, struct symbolic_number *n,\n-\t       bool bswap)\n+bswap_replace (gimple cur_stmt, gimple_stmt_iterator gsi, gimple src_stmt,\n+\t       tree fndecl, tree bswap_type, tree load_type,\n+\t       struct symbolic_number *n, bool bswap)\n {\n-  tree tmp, tgt;\n+  tree src, tmp, tgt;\n   gimple call;\n \n-  tgt = gimple_assign_lhs (stmt);\n+  src = gimple_assign_rhs1 (src_stmt);\n+  tgt = gimple_assign_lhs (cur_stmt);\n \n   /* Need to load the value from memory first.  */\n   if (n->base_addr)\n     {\n+      gimple_stmt_iterator gsi_ins = gsi_for_stmt (src_stmt);\n       tree addr_expr, addr_tmp, val_expr, val_tmp;\n       tree load_offset_ptr, aligned_load_type;\n       gimple addr_stmt, load_stmt;\n@@ -2175,6 +2181,9 @@ bswap_replace (gimple stmt, gimple_stmt_iterator *gsi, tree src, tree fndecl,\n       if (bswap && SLOW_UNALIGNED_ACCESS (TYPE_MODE (load_type), align))\n \treturn false;\n \n+      gsi_move_before (&gsi, &gsi_ins);\n+      gsi = gsi_for_stmt (cur_stmt);\n+\n       /*  Compute address to load from and cast according to the size\n \t  of the load.  */\n       addr_expr = build_fold_addr_expr (unshare_expr (src));\n@@ -2185,7 +2194,7 @@ bswap_replace (gimple stmt, gimple_stmt_iterator *gsi, tree src, tree fndecl,\n \t  addr_tmp = make_temp_ssa_name (TREE_TYPE (addr_expr), NULL,\n \t\t\t\t\t \"load_src\");\n \t  addr_stmt = gimple_build_assign (addr_tmp, addr_expr);\n-\t  gsi_insert_before (gsi, addr_stmt, GSI_SAME_STMT);\n+\t  gsi_insert_before (&gsi, addr_stmt, GSI_SAME_STMT);\n \t}\n \n       /* Perform the load.  */\n@@ -2215,21 +2224,24 @@ bswap_replace (gimple stmt, gimple_stmt_iterator *gsi, tree src, tree fndecl,\n \t\t\t\t\t    \"load_dst\");\n \t      load_stmt = gimple_build_assign (val_tmp, val_expr);\n \t      gimple_set_vuse (load_stmt, n->vuse);\n-\t      gsi_insert_before (gsi, load_stmt, GSI_SAME_STMT);\n-\t      gimple_assign_set_rhs_with_ops_1 (gsi, NOP_EXPR, val_tmp,\n+\t      gsi_insert_before (&gsi, load_stmt, GSI_SAME_STMT);\n+\t      gimple_assign_set_rhs_with_ops_1 (&gsi, NOP_EXPR, val_tmp,\n \t\t\t\t\t\tNULL_TREE, NULL_TREE);\n \t    }\n \t  else\n-\t    gimple_assign_set_rhs_with_ops_1 (gsi, MEM_REF, val_expr,\n-\t\t\t\t\t      NULL_TREE, NULL_TREE);\n-\t  update_stmt (gsi_stmt (*gsi));\n+\t    {\n+\t      gimple_assign_set_rhs_with_ops_1 (&gsi, MEM_REF, val_expr,\n+\t\t\t\t\t\tNULL_TREE, NULL_TREE);\n+\t      gimple_set_vuse (cur_stmt, n->vuse);\n+\t    }\n+\t  update_stmt (cur_stmt);\n \n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file,\n \t\t       \"%d bit load in target endianness found at: \",\n \t\t       (int)n->range);\n-\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t      print_gimple_stmt (dump_file, cur_stmt, 0, 0);\n \t    }\n \t  return true;\n \t}\n@@ -2238,7 +2250,7 @@ bswap_replace (gimple stmt, gimple_stmt_iterator *gsi, tree src, tree fndecl,\n \t  val_tmp = make_temp_ssa_name (aligned_load_type, NULL, \"load_dst\");\n \t  load_stmt = gimple_build_assign (val_tmp, val_expr);\n \t  gimple_set_vuse (load_stmt, n->vuse);\n-\t  gsi_insert_before (gsi, load_stmt, GSI_SAME_STMT);\n+\t  gsi_insert_before (&gsi, load_stmt, GSI_SAME_STMT);\n \t}\n       src = val_tmp;\n     }\n@@ -2261,7 +2273,7 @@ bswap_replace (gimple stmt, gimple_stmt_iterator *gsi, tree src, tree fndecl,\n       gimple convert_stmt;\n       tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapsrc\");\n       convert_stmt = gimple_build_assign_with_ops (NOP_EXPR, tmp, src, NULL);\n-      gsi_insert_before (gsi, convert_stmt, GSI_SAME_STMT);\n+      gsi_insert_before (&gsi, convert_stmt, GSI_SAME_STMT);\n     }\n \n   call = gimple_build_call (fndecl, 1, tmp);\n@@ -2274,7 +2286,7 @@ bswap_replace (gimple stmt, gimple_stmt_iterator *gsi, tree src, tree fndecl,\n       gimple convert_stmt;\n       tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapdst\");\n       convert_stmt = gimple_build_assign_with_ops (NOP_EXPR, tgt, tmp, NULL);\n-      gsi_insert_after (gsi, convert_stmt, GSI_SAME_STMT);\n+      gsi_insert_after (&gsi, convert_stmt, GSI_SAME_STMT);\n     }\n \n   gimple_call_set_lhs (call, tmp);\n@@ -2283,11 +2295,11 @@ bswap_replace (gimple stmt, gimple_stmt_iterator *gsi, tree src, tree fndecl,\n     {\n       fprintf (dump_file, \"%d bit bswap implementation found at: \",\n \t       (int)n->range);\n-      print_gimple_stmt (dump_file, stmt, 0, 0);\n+      print_gimple_stmt (dump_file, cur_stmt, 0, 0);\n     }\n \n-  gsi_insert_after (gsi, call, GSI_SAME_STMT);\n-  gsi_remove (gsi, true);\n+  gsi_insert_after (&gsi, call, GSI_SAME_STMT);\n+  gsi_remove (&gsi, true);\n   return true;\n }\n \n@@ -2348,19 +2360,18 @@ pass_optimize_bswap::execute (function *fun)\n \t patterns, the wider variant wouldn't be detected.  */\n       for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n         {\n-\t  gimple stmt = gsi_stmt (gsi);\n-\t  tree fndecl = NULL_TREE, bswap_type = NULL_TREE;\n-\t  tree src, load_type;\n+\t  gimple src_stmt, cur_stmt = gsi_stmt (gsi);\n+\t  tree fndecl = NULL_TREE, bswap_type = NULL_TREE, load_type;\n \t  struct symbolic_number n;\n \t  bool bswap;\n \n-\t  if (!is_gimple_assign (stmt)\n-\t      || gimple_assign_rhs_code (stmt) != BIT_IOR_EXPR)\n+\t  if (!is_gimple_assign (cur_stmt)\n+\t      || gimple_assign_rhs_code (cur_stmt) != BIT_IOR_EXPR)\n \t    continue;\n \n-\t  src = find_bswap_or_nop (stmt, &n, &bswap);\n+\t  src_stmt = find_bswap_or_nop (cur_stmt, &n, &bswap);\n \n-\t  if (!src)\n+\t  if (!src_stmt)\n \t    continue;\n \n \t  switch (n.range)\n@@ -2396,8 +2407,8 @@ pass_optimize_bswap::execute (function *fun)\n \t  if (bswap && !fndecl)\n \t    continue;\n \n-\t  if (bswap_replace (stmt, &gsi, src, fndecl, bswap_type, load_type,\n-\t\t\t     &n, bswap))\n+\t  if (bswap_replace (cur_stmt, gsi, src_stmt, fndecl, bswap_type,\n+\t\t\t     load_type, &n, bswap))\n \t    changed = true;\n \t}\n     }"}]}