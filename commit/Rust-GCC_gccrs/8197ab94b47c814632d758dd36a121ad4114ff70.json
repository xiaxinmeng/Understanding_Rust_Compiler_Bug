{"sha": "8197ab94b47c814632d758dd36a121ad4114ff70", "node_id": "C_kwDOANBUbNoAKDgxOTdhYjk0YjQ3YzgxNDYzMmQ3NThkZDM2YTEyMWFkNDExNGZmNzA", "commit": {"author": {"name": "Jonathan Wright", "email": "jonathan.wright@arm.com", "date": "2021-09-10T15:48:02Z"}, "committer": {"name": "Jonathan Wright", "email": "jonathan.wright@arm.com", "date": "2021-11-04T14:50:40Z"}, "message": "aarch64: Move Neon vector-tuple type declaration into the compiler\n\nDeclare the Neon vector-tuple types inside the compiler instead of in\nthe arm_neon.h header. This is a necessary first step before adding\ncorresponding machine modes to the AArch64 backend.\n\nThe vector-tuple types are implemented using a #pragma. This means\ninitialization of builtin functions that have vector-tuple types as\narguments or return values has to be delayed until the #pragma is\nhandled.\n\ngcc/ChangeLog:\n\n2021-09-10  Jonathan Wright  <jonathan.wright@arm.com>\n\n\t* config/aarch64/aarch64-builtins.c (aarch64_init_simd_builtins):\n\tFactor out main loop to...\n\t(aarch64_init_simd_builtin_functions): This new function.\n\t(register_tuple_type): Define.\n\t(aarch64_scalar_builtin_type_p): Define.\n\t(handle_arm_neon_h): Define.\n\t* config/aarch64/aarch64-c.c (aarch64_pragma_aarch64): Handle\n\tpragma for arm_neon.h.\n\t* config/aarch64/aarch64-protos.h (aarch64_advsimd_struct_mode_p):\n\tDeclare.\n\t(handle_arm_neon_h): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_advsimd_struct_mode_p):\n\tRemove static modifier.\n\t* config/aarch64/arm_neon.h (target): Remove Neon vector\n\tstructure type definitions.", "tree": {"sha": "d6552d642af27bab058d947e171edd257b3aee5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6552d642af27bab058d947e171edd257b3aee5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8197ab94b47c814632d758dd36a121ad4114ff70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8197ab94b47c814632d758dd36a121ad4114ff70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8197ab94b47c814632d758dd36a121ad4114ff70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8197ab94b47c814632d758dd36a121ad4114ff70/comments", "author": {"login": "jwright-arm", "id": 31624044, "node_id": "MDQ6VXNlcjMxNjI0MDQ0", "avatar_url": "https://avatars.githubusercontent.com/u/31624044?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwright-arm", "html_url": "https://github.com/jwright-arm", "followers_url": "https://api.github.com/users/jwright-arm/followers", "following_url": "https://api.github.com/users/jwright-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jwright-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwright-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwright-arm/subscriptions", "organizations_url": "https://api.github.com/users/jwright-arm/orgs", "repos_url": "https://api.github.com/users/jwright-arm/repos", "events_url": "https://api.github.com/users/jwright-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jwright-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwright-arm", "id": 31624044, "node_id": "MDQ6VXNlcjMxNjI0MDQ0", "avatar_url": "https://avatars.githubusercontent.com/u/31624044?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwright-arm", "html_url": "https://github.com/jwright-arm", "followers_url": "https://api.github.com/users/jwright-arm/followers", "following_url": "https://api.github.com/users/jwright-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jwright-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwright-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwright-arm/subscriptions", "organizations_url": "https://api.github.com/users/jwright-arm/orgs", "repos_url": "https://api.github.com/users/jwright-arm/repos", "events_url": "https://api.github.com/users/jwright-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jwright-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbe58ba97aff3270877d7fd5600c17687b85964c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe58ba97aff3270877d7fd5600c17687b85964c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbe58ba97aff3270877d7fd5600c17687b85964c"}], "stats": {"total": 583, "additions": 107, "deletions": 476}, "files": [{"sha": "eff4cdc6a7b764bed9f4387adbb4707d4fe87c49", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 100, "deletions": 25, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8197ab94b47c814632d758dd36a121ad4114ff70/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8197ab94b47c814632d758dd36a121ad4114ff70/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=8197ab94b47c814632d758dd36a121ad4114ff70", "patch": "@@ -1046,32 +1046,22 @@ aarch64_init_fcmla_laneq_builtins (void)\n }\n \n void\n-aarch64_init_simd_builtins (void)\n+aarch64_init_simd_builtin_functions (bool called_from_pragma)\n {\n   unsigned int i, fcode = AARCH64_SIMD_PATTERN_START;\n \n-  if (aarch64_simd_builtins_initialized_p)\n-    return;\n-\n-  aarch64_simd_builtins_initialized_p = true;\n-\n-  aarch64_init_simd_builtin_types ();\n-\n-  /* Strong-typing hasn't been implemented for all AdvSIMD builtin intrinsics.\n-     Therefore we need to preserve the old __builtin scalar types.  It can be\n-     removed once all the intrinsics become strongly typed using the qualifier\n-     system.  */\n-  aarch64_init_simd_builtin_scalar_types ();\n- \n-  tree lane_check_fpr = build_function_type_list (void_type_node,\n-\t\t\t\t\t\t  size_type_node,\n-\t\t\t\t\t\t  size_type_node,\n-\t\t\t\t\t\t  intSI_type_node,\n-\t\t\t\t\t\t  NULL);\n-  aarch64_builtin_decls[AARCH64_SIMD_BUILTIN_LANE_CHECK]\n-    = aarch64_general_add_builtin (\"__builtin_aarch64_im_lane_boundsi\",\n-\t\t\t\t   lane_check_fpr,\n-\t\t\t\t   AARCH64_SIMD_BUILTIN_LANE_CHECK);\n+  if (!called_from_pragma)\n+    {\n+      tree lane_check_fpr = build_function_type_list (void_type_node,\n+\t\t\t\t\t\t      size_type_node,\n+\t\t\t\t\t\t      size_type_node,\n+\t\t\t\t\t\t      intSI_type_node,\n+\t\t\t\t\t\t      NULL);\n+      aarch64_builtin_decls[AARCH64_SIMD_BUILTIN_LANE_CHECK]\n+\t= aarch64_general_add_builtin (\"__builtin_aarch64_im_lane_boundsi\",\n+\t\t\t\t       lane_check_fpr,\n+\t\t\t\t       AARCH64_SIMD_BUILTIN_LANE_CHECK);\n+    }\n \n   for (i = 0; i < ARRAY_SIZE (aarch64_simd_builtin_data); i++, fcode++)\n     {\n@@ -1101,6 +1091,18 @@ aarch64_init_simd_builtins (void)\n       tree return_type = void_type_node, args = void_list_node;\n       tree eltype;\n \n+      int struct_mode_args = 0;\n+      for (int j = op_num; j >= 0; j--)\n+\t{\n+\t  machine_mode op_mode = insn_data[d->code].operand[j].mode;\n+\t  if (aarch64_advsimd_struct_mode_p (op_mode))\n+\t    struct_mode_args++;\n+\t}\n+\n+      if ((called_from_pragma && struct_mode_args == 0)\n+\t  || (!called_from_pragma && struct_mode_args > 0))\n+\tcontinue;\n+\n       /* Build a function type directly from the insn_data for this\n \t builtin.  The build_function_type () function takes care of\n \t removing duplicates for us.  */\n@@ -1174,9 +1176,82 @@ aarch64_init_simd_builtins (void)\n       fndecl = aarch64_general_add_builtin (namebuf, ftype, fcode, attrs);\n       aarch64_builtin_decls[fcode] = fndecl;\n     }\n+}\n+\n+/* Register the tuple type that contains NUM_VECTORS of the AdvSIMD type\n+   indexed by TYPE_INDEX.  */\n+static void\n+register_tuple_type (unsigned int num_vectors, unsigned int type_index)\n+{\n+  aarch64_simd_type_info *type = &aarch64_simd_types[type_index];\n+\n+  /* Synthesize the name of the user-visible vector tuple type.  */\n+  const char *vector_type_name = type->name;\n+  char tuple_type_name[sizeof (\"bfloat16x4x2_t\")];\n+  snprintf (tuple_type_name, sizeof (tuple_type_name), \"%.*sx%d_t\",\n+\t    (int) strlen (vector_type_name) - 4, vector_type_name + 2,\n+\t    num_vectors);\n+  tuple_type_name[0] = TOLOWER (tuple_type_name[0]);\n+\n+  tree vector_type = type->itype;\n+  tree array_type = build_array_type_nelts (vector_type, num_vectors);\n+  unsigned int alignment\n+\t= (known_eq (GET_MODE_SIZE (type->mode), 16) ? 128 : 64);\n+  gcc_assert (TYPE_MODE_RAW (array_type) == TYPE_MODE (array_type)\n+\t      && TYPE_ALIGN (array_type) == alignment);\n+\n+  tree field = build_decl (input_location, FIELD_DECL,\n+\t\t\t   get_identifier (\"val\"), array_type);\n+\n+  tree t = lang_hooks.types.simulate_record_decl (input_location,\n+\t\t\t\t\t\t  tuple_type_name,\n+\t\t\t\t\t\t  make_array_slice (&field,\n+\t\t\t\t\t\t\t\t    1));\n+  gcc_assert (TYPE_MODE_RAW (t) == TYPE_MODE (t)\n+\t      && TYPE_ALIGN (t) == alignment);\n+}\n+\n+static bool\n+aarch64_scalar_builtin_type_p (aarch64_simd_type t)\n+{\n+  return (t == Poly8_t || t == Poly16_t || t == Poly64_t || t == Poly128_t);\n+}\n+\n+/* Implement #pragma GCC aarch64 \"arm_neon.h\".  */\n+void\n+handle_arm_neon_h (void)\n+{\n+  /* Register the AdvSIMD vector tuple types.  */\n+  for (unsigned int i = 0; i < ARM_NEON_H_TYPES_LAST; i++)\n+    for (unsigned int count = 2; count <= 4; ++count)\n+      if (!aarch64_scalar_builtin_type_p (aarch64_simd_types[i].type))\n+\tregister_tuple_type (count, i);\n+\n+  aarch64_init_simd_builtin_functions (true);\n+}\n+\n+void\n+aarch64_init_simd_builtins (void)\n+{\n+  if (aarch64_simd_builtins_initialized_p)\n+    return;\n+\n+  aarch64_simd_builtins_initialized_p = true;\n+\n+  aarch64_init_simd_builtin_types ();\n+\n+  /* Strong-typing hasn't been implemented for all AdvSIMD builtin intrinsics.\n+     Therefore we need to preserve the old __builtin scalar types.  It can be\n+     removed once all the intrinsics become strongly typed using the qualifier\n+     system.  */\n+  aarch64_init_simd_builtin_scalar_types ();\n+\n+  aarch64_init_simd_builtin_functions (false);\n+  if (in_lto_p)\n+    handle_arm_neon_h ();\n \n-   /* Initialize the remaining fcmla_laneq intrinsics.  */\n-   aarch64_init_fcmla_laneq_builtins ();\n+  /* Initialize the remaining fcmla_laneq intrinsics.  */\n+  aarch64_init_fcmla_laneq_builtins ();\n }\n \n static void"}, {"sha": "d6653e474dec9bcddde2106f36ceb22f1d43375c", "filename": "gcc/config/aarch64/aarch64-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8197ab94b47c814632d758dd36a121ad4114ff70/gcc%2Fconfig%2Faarch64%2Faarch64-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8197ab94b47c814632d758dd36a121ad4114ff70/gcc%2Fconfig%2Faarch64%2Faarch64-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-c.c?ref=8197ab94b47c814632d758dd36a121ad4114ff70", "patch": "@@ -296,6 +296,8 @@ aarch64_pragma_aarch64 (cpp_reader *)\n   const char *name = TREE_STRING_POINTER (x);\n   if (strcmp (name, \"arm_sve.h\") == 0)\n     aarch64_sve::handle_arm_sve_h ();\n+  else if (strcmp (name, \"arm_neon.h\") == 0)\n+    handle_arm_neon_h ();\n   else\n     error (\"unknown %<#pragma GCC aarch64%> option %qs\", name);\n }"}, {"sha": "f7887d06139f01c1591c4e755538d94e5e608a52", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8197ab94b47c814632d758dd36a121ad4114ff70/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8197ab94b47c814632d758dd36a121ad4114ff70/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=8197ab94b47c814632d758dd36a121ad4114ff70", "patch": "@@ -743,6 +743,7 @@ unsigned HOST_WIDE_INT aarch64_and_split_imm2 (HOST_WIDE_INT val_in);\n bool aarch64_and_bitmask_imm (unsigned HOST_WIDE_INT val_in, machine_mode mode);\n int aarch64_branch_cost (bool, bool);\n enum aarch64_symbol_type aarch64_classify_symbolic_expression (rtx);\n+bool aarch64_advsimd_struct_mode_p (machine_mode mode);\n opt_machine_mode aarch64_vq_mode (scalar_mode);\n opt_machine_mode aarch64_full_sve_mode (scalar_mode);\n bool aarch64_can_const_movi_rtx_p (rtx x, machine_mode mode);\n@@ -968,6 +969,7 @@ rtx aarch64_general_expand_builtin (unsigned int, tree, rtx, int);\n tree aarch64_general_builtin_decl (unsigned, bool);\n tree aarch64_general_builtin_rsqrt (unsigned int);\n tree aarch64_builtin_vectorized_function (unsigned int, tree, tree);\n+void handle_arm_neon_h (void);\n \n namespace aarch64_sve {\n   void init_builtins ();"}, {"sha": "1780751d8498ef77d043b212ad40a4faf91a2211", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8197ab94b47c814632d758dd36a121ad4114ff70/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8197ab94b47c814632d758dd36a121ad4114ff70/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8197ab94b47c814632d758dd36a121ad4114ff70", "patch": "@@ -2864,7 +2864,7 @@ aarch64_estimated_sve_vq ()\n }\n \n /* Return true if MODE is any of the Advanced SIMD structure modes.  */\n-static bool\n+bool\n aarch64_advsimd_struct_mode_p (machine_mode mode)\n {\n   return (TARGET_SIMD"}, {"sha": "ed0dfa952b901f7929ad8202a9d485a848c30c19", "filename": "gcc/config/aarch64/arm_neon.h", "status": "modified", "additions": 2, "deletions": 450, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8197ab94b47c814632d758dd36a121ad4114ff70/gcc%2Fconfig%2Faarch64%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8197ab94b47c814632d758dd36a121ad4114ff70/gcc%2Fconfig%2Faarch64%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Farm_neon.h?ref=8197ab94b47c814632d758dd36a121ad4114ff70", "patch": "@@ -30,6 +30,8 @@\n #pragma GCC push_options\n #pragma GCC target (\"+nothing+simd\")\n \n+#pragma GCC aarch64 \"arm_neon.h\"\n+\n #include <stdint.h>\n \n #define __AARCH64_UINT64_C(__C) ((uint64_t) __C)\n@@ -76,456 +78,6 @@ typedef double float64_t;\n typedef __Bfloat16x4_t bfloat16x4_t;\n typedef __Bfloat16x8_t bfloat16x8_t;\n \n-typedef struct bfloat16x4x2_t\n-{\n-  bfloat16x4_t val[2];\n-} bfloat16x4x2_t;\n-\n-typedef struct bfloat16x8x2_t\n-{\n-  bfloat16x8_t val[2];\n-} bfloat16x8x2_t;\n-\n-typedef struct bfloat16x4x3_t\n-{\n-  bfloat16x4_t val[3];\n-} bfloat16x4x3_t;\n-\n-typedef struct bfloat16x8x3_t\n-{\n-  bfloat16x8_t val[3];\n-} bfloat16x8x3_t;\n-\n-typedef struct bfloat16x4x4_t\n-{\n-  bfloat16x4_t val[4];\n-} bfloat16x4x4_t;\n-\n-typedef struct bfloat16x8x4_t\n-{\n-  bfloat16x8_t val[4];\n-} bfloat16x8x4_t;\n-\n-typedef struct int8x8x2_t\n-{\n-  int8x8_t val[2];\n-} int8x8x2_t;\n-\n-typedef struct int8x16x2_t\n-{\n-  int8x16_t val[2];\n-} int8x16x2_t;\n-\n-typedef struct int16x4x2_t\n-{\n-  int16x4_t val[2];\n-} int16x4x2_t;\n-\n-typedef struct int16x8x2_t\n-{\n-  int16x8_t val[2];\n-} int16x8x2_t;\n-\n-typedef struct int32x2x2_t\n-{\n-  int32x2_t val[2];\n-} int32x2x2_t;\n-\n-typedef struct int32x4x2_t\n-{\n-  int32x4_t val[2];\n-} int32x4x2_t;\n-\n-typedef struct int64x1x2_t\n-{\n-  int64x1_t val[2];\n-} int64x1x2_t;\n-\n-typedef struct int64x2x2_t\n-{\n-  int64x2_t val[2];\n-} int64x2x2_t;\n-\n-typedef struct uint8x8x2_t\n-{\n-  uint8x8_t val[2];\n-} uint8x8x2_t;\n-\n-typedef struct uint8x16x2_t\n-{\n-  uint8x16_t val[2];\n-} uint8x16x2_t;\n-\n-typedef struct uint16x4x2_t\n-{\n-  uint16x4_t val[2];\n-} uint16x4x2_t;\n-\n-typedef struct uint16x8x2_t\n-{\n-  uint16x8_t val[2];\n-} uint16x8x2_t;\n-\n-typedef struct uint32x2x2_t\n-{\n-  uint32x2_t val[2];\n-} uint32x2x2_t;\n-\n-typedef struct uint32x4x2_t\n-{\n-  uint32x4_t val[2];\n-} uint32x4x2_t;\n-\n-typedef struct uint64x1x2_t\n-{\n-  uint64x1_t val[2];\n-} uint64x1x2_t;\n-\n-typedef struct uint64x2x2_t\n-{\n-  uint64x2_t val[2];\n-} uint64x2x2_t;\n-\n-typedef struct float16x4x2_t\n-{\n-  float16x4_t val[2];\n-} float16x4x2_t;\n-\n-typedef struct float16x8x2_t\n-{\n-  float16x8_t val[2];\n-} float16x8x2_t;\n-\n-typedef struct float32x2x2_t\n-{\n-  float32x2_t val[2];\n-} float32x2x2_t;\n-\n-typedef struct float32x4x2_t\n-{\n-  float32x4_t val[2];\n-} float32x4x2_t;\n-\n-typedef struct float64x2x2_t\n-{\n-  float64x2_t val[2];\n-} float64x2x2_t;\n-\n-typedef struct float64x1x2_t\n-{\n-  float64x1_t val[2];\n-} float64x1x2_t;\n-\n-typedef struct poly8x8x2_t\n-{\n-  poly8x8_t val[2];\n-} poly8x8x2_t;\n-\n-typedef struct poly8x16x2_t\n-{\n-  poly8x16_t val[2];\n-} poly8x16x2_t;\n-\n-typedef struct poly16x4x2_t\n-{\n-  poly16x4_t val[2];\n-} poly16x4x2_t;\n-\n-typedef struct poly16x8x2_t\n-{\n-  poly16x8_t val[2];\n-} poly16x8x2_t;\n-\n-typedef struct poly64x1x2_t\n-{\n-  poly64x1_t val[2];\n-} poly64x1x2_t;\n-\n-typedef struct poly64x1x3_t\n-{\n-  poly64x1_t val[3];\n-} poly64x1x3_t;\n-\n-typedef struct poly64x1x4_t\n-{\n-  poly64x1_t val[4];\n-} poly64x1x4_t;\n-\n-typedef struct poly64x2x2_t\n-{\n-  poly64x2_t val[2];\n-} poly64x2x2_t;\n-\n-typedef struct poly64x2x3_t\n-{\n-  poly64x2_t val[3];\n-} poly64x2x3_t;\n-\n-typedef struct poly64x2x4_t\n-{\n-  poly64x2_t val[4];\n-} poly64x2x4_t;\n-\n-typedef struct int8x8x3_t\n-{\n-  int8x8_t val[3];\n-} int8x8x3_t;\n-\n-typedef struct int8x16x3_t\n-{\n-  int8x16_t val[3];\n-} int8x16x3_t;\n-\n-typedef struct int16x4x3_t\n-{\n-  int16x4_t val[3];\n-} int16x4x3_t;\n-\n-typedef struct int16x8x3_t\n-{\n-  int16x8_t val[3];\n-} int16x8x3_t;\n-\n-typedef struct int32x2x3_t\n-{\n-  int32x2_t val[3];\n-} int32x2x3_t;\n-\n-typedef struct int32x4x3_t\n-{\n-  int32x4_t val[3];\n-} int32x4x3_t;\n-\n-typedef struct int64x1x3_t\n-{\n-  int64x1_t val[3];\n-} int64x1x3_t;\n-\n-typedef struct int64x2x3_t\n-{\n-  int64x2_t val[3];\n-} int64x2x3_t;\n-\n-typedef struct uint8x8x3_t\n-{\n-  uint8x8_t val[3];\n-} uint8x8x3_t;\n-\n-typedef struct uint8x16x3_t\n-{\n-  uint8x16_t val[3];\n-} uint8x16x3_t;\n-\n-typedef struct uint16x4x3_t\n-{\n-  uint16x4_t val[3];\n-} uint16x4x3_t;\n-\n-typedef struct uint16x8x3_t\n-{\n-  uint16x8_t val[3];\n-} uint16x8x3_t;\n-\n-typedef struct uint32x2x3_t\n-{\n-  uint32x2_t val[3];\n-} uint32x2x3_t;\n-\n-typedef struct uint32x4x3_t\n-{\n-  uint32x4_t val[3];\n-} uint32x4x3_t;\n-\n-typedef struct uint64x1x3_t\n-{\n-  uint64x1_t val[3];\n-} uint64x1x3_t;\n-\n-typedef struct uint64x2x3_t\n-{\n-  uint64x2_t val[3];\n-} uint64x2x3_t;\n-\n-typedef struct float16x4x3_t\n-{\n-  float16x4_t val[3];\n-} float16x4x3_t;\n-\n-typedef struct float16x8x3_t\n-{\n-  float16x8_t val[3];\n-} float16x8x3_t;\n-\n-typedef struct float32x2x3_t\n-{\n-  float32x2_t val[3];\n-} float32x2x3_t;\n-\n-typedef struct float32x4x3_t\n-{\n-  float32x4_t val[3];\n-} float32x4x3_t;\n-\n-typedef struct float64x2x3_t\n-{\n-  float64x2_t val[3];\n-} float64x2x3_t;\n-\n-typedef struct float64x1x3_t\n-{\n-  float64x1_t val[3];\n-} float64x1x3_t;\n-\n-typedef struct poly8x8x3_t\n-{\n-  poly8x8_t val[3];\n-} poly8x8x3_t;\n-\n-typedef struct poly8x16x3_t\n-{\n-  poly8x16_t val[3];\n-} poly8x16x3_t;\n-\n-typedef struct poly16x4x3_t\n-{\n-  poly16x4_t val[3];\n-} poly16x4x3_t;\n-\n-typedef struct poly16x8x3_t\n-{\n-  poly16x8_t val[3];\n-} poly16x8x3_t;\n-\n-typedef struct int8x8x4_t\n-{\n-  int8x8_t val[4];\n-} int8x8x4_t;\n-\n-typedef struct int8x16x4_t\n-{\n-  int8x16_t val[4];\n-} int8x16x4_t;\n-\n-typedef struct int16x4x4_t\n-{\n-  int16x4_t val[4];\n-} int16x4x4_t;\n-\n-typedef struct int16x8x4_t\n-{\n-  int16x8_t val[4];\n-} int16x8x4_t;\n-\n-typedef struct int32x2x4_t\n-{\n-  int32x2_t val[4];\n-} int32x2x4_t;\n-\n-typedef struct int32x4x4_t\n-{\n-  int32x4_t val[4];\n-} int32x4x4_t;\n-\n-typedef struct int64x1x4_t\n-{\n-  int64x1_t val[4];\n-} int64x1x4_t;\n-\n-typedef struct int64x2x4_t\n-{\n-  int64x2_t val[4];\n-} int64x2x4_t;\n-\n-typedef struct uint8x8x4_t\n-{\n-  uint8x8_t val[4];\n-} uint8x8x4_t;\n-\n-typedef struct uint8x16x4_t\n-{\n-  uint8x16_t val[4];\n-} uint8x16x4_t;\n-\n-typedef struct uint16x4x4_t\n-{\n-  uint16x4_t val[4];\n-} uint16x4x4_t;\n-\n-typedef struct uint16x8x4_t\n-{\n-  uint16x8_t val[4];\n-} uint16x8x4_t;\n-\n-typedef struct uint32x2x4_t\n-{\n-  uint32x2_t val[4];\n-} uint32x2x4_t;\n-\n-typedef struct uint32x4x4_t\n-{\n-  uint32x4_t val[4];\n-} uint32x4x4_t;\n-\n-typedef struct uint64x1x4_t\n-{\n-  uint64x1_t val[4];\n-} uint64x1x4_t;\n-\n-typedef struct uint64x2x4_t\n-{\n-  uint64x2_t val[4];\n-} uint64x2x4_t;\n-\n-typedef struct float16x4x4_t\n-{\n-  float16x4_t val[4];\n-} float16x4x4_t;\n-\n-typedef struct float16x8x4_t\n-{\n-  float16x8_t val[4];\n-} float16x8x4_t;\n-\n-typedef struct float32x2x4_t\n-{\n-  float32x2_t val[4];\n-} float32x2x4_t;\n-\n-typedef struct float32x4x4_t\n-{\n-  float32x4_t val[4];\n-} float32x4x4_t;\n-\n-typedef struct float64x2x4_t\n-{\n-  float64x2_t val[4];\n-} float64x2x4_t;\n-\n-typedef struct float64x1x4_t\n-{\n-  float64x1_t val[4];\n-} float64x1x4_t;\n-\n-typedef struct poly8x8x4_t\n-{\n-  poly8x8_t val[4];\n-} poly8x8x4_t;\n-\n-typedef struct poly8x16x4_t\n-{\n-  poly8x16_t val[4];\n-} poly8x16x4_t;\n-\n-typedef struct poly16x4x4_t\n-{\n-  poly16x4_t val[4];\n-} poly16x4x4_t;\n-\n-typedef struct poly16x8x4_t\n-{\n-  poly16x8_t val[4];\n-} poly16x8x4_t;\n-\n /* __aarch64_vdup_lane internal macros.  */\n #define __aarch64_vdup_lane_any(__size, __q, __a, __b) \\\n   vdup##__q##_n_##__size (__aarch64_vget_lane_any (__a, __b))"}]}