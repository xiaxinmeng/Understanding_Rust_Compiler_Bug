{"sha": "c74985e3ee7f30091582908b1bdf3cdec5218897", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc0OTg1ZTNlZTdmMzAwOTE1ODI5MDhiMWJkZjNjZGVjNTIxODg5Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-06-14T11:24:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-06-14T11:24:48Z"}, "message": "cp-gimplify.c (cp_genericize_r): Turn most of the function into a switch (TREE_CODE (stmt)) statement from long...\n\n\t* cp-gimplify.c (cp_genericize_r): Turn most of the function\n\tinto a switch (TREE_CODE (stmt)) statement from long else if\n\tsequence.\n\nFrom-SVN: r249191", "tree": {"sha": "07bbde3b7f48286a06ca839ba5975e675dccf40c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07bbde3b7f48286a06ca839ba5975e675dccf40c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c74985e3ee7f30091582908b1bdf3cdec5218897", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c74985e3ee7f30091582908b1bdf3cdec5218897", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c74985e3ee7f30091582908b1bdf3cdec5218897", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c74985e3ee7f30091582908b1bdf3cdec5218897/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "938a807a68f4ee61343b4f0b03b2cc8110d3c0b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/938a807a68f4ee61343b4f0b03b2cc8110d3c0b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/938a807a68f4ee61343b4f0b03b2cc8110d3c0b9"}], "stats": {"total": 591, "additions": 316, "deletions": 275}, "files": [{"sha": "b933392d58391e5afe18be6ac1b905a828c8cb03", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c74985e3ee7f30091582908b1bdf3cdec5218897/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c74985e3ee7f30091582908b1bdf3cdec5218897/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c74985e3ee7f30091582908b1bdf3cdec5218897", "patch": "@@ -1,3 +1,9 @@\n+2017-06-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-gimplify.c (cp_genericize_r): Turn most of the function\n+\tinto a switch (TREE_CODE (stmt)) statement from long else if\n+\tsequence.\n+\n 2017-06-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/80973"}, {"sha": "f010f6c63be10fbf08bda6a56ef83dbda72a3413", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 310, "deletions": 275, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c74985e3ee7f30091582908b1bdf3cdec5218897/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c74985e3ee7f30091582908b1bdf3cdec5218897/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=c74985e3ee7f30091582908b1bdf3cdec5218897", "patch": "@@ -1118,132 +1118,135 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n       return NULL_TREE;\n     }\n \n-  if (TREE_CODE (stmt) == ADDR_EXPR\n-      && is_invisiref_parm (TREE_OPERAND (stmt, 0)))\n+  switch (TREE_CODE (stmt))\n     {\n-      /* If in an OpenMP context, note var uses.  */\n-      if (__builtin_expect (wtd->omp_ctx != NULL, 0)\n-\t  && omp_var_to_track (TREE_OPERAND (stmt, 0)))\n-\tomp_cxx_notice_variable (wtd->omp_ctx, TREE_OPERAND (stmt, 0));\n-      *stmt_p = fold_convert (TREE_TYPE (stmt), TREE_OPERAND (stmt, 0));\n-      *walk_subtrees = 0;\n-    }\n-  else if (TREE_CODE (stmt) == RETURN_EXPR\n-\t   && TREE_OPERAND (stmt, 0)\n-\t   && is_invisiref_parm (TREE_OPERAND (stmt, 0)))\n-    /* Don't dereference an invisiref RESULT_DECL inside a RETURN_EXPR.  */\n-    *walk_subtrees = 0;\n-  else if (TREE_CODE (stmt) == OMP_CLAUSE)\n-    switch (OMP_CLAUSE_CODE (stmt))\n-      {\n-      case OMP_CLAUSE_LASTPRIVATE:\n-\t/* Don't dereference an invisiref in OpenMP clauses.  */\n-\tif (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))\n-\t  {\n-\t    *walk_subtrees = 0;\n-\t    if (OMP_CLAUSE_LASTPRIVATE_STMT (stmt))\n-\t      cp_walk_tree (&OMP_CLAUSE_LASTPRIVATE_STMT (stmt),\n-\t\t\t    cp_genericize_r, data, NULL);\n-\t  }\n-\tbreak;\n-      case OMP_CLAUSE_PRIVATE:\n-\t/* Don't dereference an invisiref in OpenMP clauses.  */\n-\tif (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))\n+    case ADDR_EXPR:\n+      if (is_invisiref_parm (TREE_OPERAND (stmt, 0)))\n+\t{\n+\t  /* If in an OpenMP context, note var uses.  */\n+\t  if (__builtin_expect (wtd->omp_ctx != NULL, 0)\n+\t      && omp_var_to_track (TREE_OPERAND (stmt, 0)))\n+\t    omp_cxx_notice_variable (wtd->omp_ctx, TREE_OPERAND (stmt, 0));\n+\t  *stmt_p = fold_convert (TREE_TYPE (stmt), TREE_OPERAND (stmt, 0));\n \t  *walk_subtrees = 0;\n-\telse if (wtd->omp_ctx != NULL)\n-\t  {\n-\t    /* Private clause doesn't cause any references to the\n-\t       var in outer contexts, avoid calling\n-\t       omp_cxx_notice_variable for it.  */\n-\t    struct cp_genericize_omp_taskreg *old = wtd->omp_ctx;\n-\t    wtd->omp_ctx = NULL;\n-\t    cp_walk_tree (&OMP_CLAUSE_DECL (stmt), cp_genericize_r,\n-\t\t\t  data, NULL);\n-\t    wtd->omp_ctx = old;\n+\t}\n+      break;\n+\n+    case RETURN_EXPR:\n+      if (TREE_OPERAND (stmt, 0) && is_invisiref_parm (TREE_OPERAND (stmt, 0)))\n+\t/* Don't dereference an invisiref RESULT_DECL inside a RETURN_EXPR.  */\n+\t*walk_subtrees = 0;\n+      break;\n+\n+    case OMP_CLAUSE:\n+      switch (OMP_CLAUSE_CODE (stmt))\n+\t{\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  /* Don't dereference an invisiref in OpenMP clauses.  */\n+\t  if (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))\n+\t    {\n+\t      *walk_subtrees = 0;\n+\t      if (OMP_CLAUSE_LASTPRIVATE_STMT (stmt))\n+\t\tcp_walk_tree (&OMP_CLAUSE_LASTPRIVATE_STMT (stmt),\n+\t\t\t      cp_genericize_r, data, NULL);\n+\t    }\n+\t  break;\n+\tcase OMP_CLAUSE_PRIVATE:\n+\t  /* Don't dereference an invisiref in OpenMP clauses.  */\n+\t  if (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))\n \t    *walk_subtrees = 0;\n-\t  }\n-\tbreak;\n-      case OMP_CLAUSE_SHARED:\n-      case OMP_CLAUSE_FIRSTPRIVATE:\n-      case OMP_CLAUSE_COPYIN:\n-      case OMP_CLAUSE_COPYPRIVATE:\n-\t/* Don't dereference an invisiref in OpenMP clauses.  */\n-\tif (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))\n-\t  *walk_subtrees = 0;\n-\tbreak;\n-      case OMP_CLAUSE_REDUCTION:\n-\t/* Don't dereference an invisiref in reduction clause's\n-\t   OMP_CLAUSE_DECL either.  OMP_CLAUSE_REDUCTION_{INIT,MERGE}\n-\t   still needs to be genericized.  */\n-\tif (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))\n-\t  {\n+\t  else if (wtd->omp_ctx != NULL)\n+\t    {\n+\t      /* Private clause doesn't cause any references to the\n+\t\t var in outer contexts, avoid calling\n+\t\t omp_cxx_notice_variable for it.  */\n+\t      struct cp_genericize_omp_taskreg *old = wtd->omp_ctx;\n+\t      wtd->omp_ctx = NULL;\n+\t      cp_walk_tree (&OMP_CLAUSE_DECL (stmt), cp_genericize_r,\n+\t\t\t    data, NULL);\n+\t      wtd->omp_ctx = old;\n+\t      *walk_subtrees = 0;\n+\t    }\n+\t  break;\n+\tcase OMP_CLAUSE_SHARED:\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\tcase OMP_CLAUSE_COPYIN:\n+\tcase OMP_CLAUSE_COPYPRIVATE:\n+\t  /* Don't dereference an invisiref in OpenMP clauses.  */\n+\t  if (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))\n \t    *walk_subtrees = 0;\n-\t    if (OMP_CLAUSE_REDUCTION_INIT (stmt))\n-\t      cp_walk_tree (&OMP_CLAUSE_REDUCTION_INIT (stmt),\n-\t\t\t    cp_genericize_r, data, NULL);\n-\t    if (OMP_CLAUSE_REDUCTION_MERGE (stmt))\n-\t      cp_walk_tree (&OMP_CLAUSE_REDUCTION_MERGE (stmt),\n-\t\t\t    cp_genericize_r, data, NULL);\n-\t  }\n-\tbreak;\n-      default:\n-\tbreak;\n-      }\n-  else if (IS_TYPE_OR_DECL_P (stmt))\n-    *walk_subtrees = 0;\n-\n-  /* Due to the way voidify_wrapper_expr is written, we don't get a chance\n-     to lower this construct before scanning it, so we need to lower these\n-     before doing anything else.  */\n-  else if (TREE_CODE (stmt) == CLEANUP_STMT)\n-    *stmt_p = build2_loc (EXPR_LOCATION (stmt),\n-\t\t\t  CLEANUP_EH_ONLY (stmt) ? TRY_CATCH_EXPR\n-\t\t\t\t\t\t : TRY_FINALLY_EXPR,\n-\t\t\t  void_type_node,\n-\t\t\t  CLEANUP_BODY (stmt),\n-\t\t\t  CLEANUP_EXPR (stmt));\n-\n-  else if (TREE_CODE (stmt) == IF_STMT)\n-    {\n+\t  break;\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  /* Don't dereference an invisiref in reduction clause's\n+\t     OMP_CLAUSE_DECL either.  OMP_CLAUSE_REDUCTION_{INIT,MERGE}\n+\t     still needs to be genericized.  */\n+\t  if (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))\n+\t    {\n+\t      *walk_subtrees = 0;\n+\t      if (OMP_CLAUSE_REDUCTION_INIT (stmt))\n+\t\tcp_walk_tree (&OMP_CLAUSE_REDUCTION_INIT (stmt),\n+\t\t\t      cp_genericize_r, data, NULL);\n+\t      if (OMP_CLAUSE_REDUCTION_MERGE (stmt))\n+\t\tcp_walk_tree (&OMP_CLAUSE_REDUCTION_MERGE (stmt),\n+\t\t\t      cp_genericize_r, data, NULL);\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+\n+    /* Due to the way voidify_wrapper_expr is written, we don't get a chance\n+       to lower this construct before scanning it, so we need to lower these\n+       before doing anything else.  */\n+    case CLEANUP_STMT:\n+      *stmt_p = build2_loc (EXPR_LOCATION (stmt),\n+\t\t\t    CLEANUP_EH_ONLY (stmt) ? TRY_CATCH_EXPR\n+\t\t\t\t\t\t   : TRY_FINALLY_EXPR,\n+\t\t\t    void_type_node,\n+\t\t\t    CLEANUP_BODY (stmt),\n+\t\t\t    CLEANUP_EXPR (stmt));\n+      break;\n+\n+    case IF_STMT:\n       genericize_if_stmt (stmt_p);\n       /* *stmt_p has changed, tail recurse to handle it again.  */\n       return cp_genericize_r (stmt_p, walk_subtrees, data);\n-    }\n \n-  /* COND_EXPR might have incompatible types in branches if one or both\n-     arms are bitfields.  Fix it up now.  */\n-  else if (TREE_CODE (stmt) == COND_EXPR)\n-    {\n-      tree type_left\n-\t= (TREE_OPERAND (stmt, 1)\n-\t   ? is_bitfield_expr_with_lowered_type (TREE_OPERAND (stmt, 1))\n-\t   : NULL_TREE);\n-      tree type_right\n-\t= (TREE_OPERAND (stmt, 2)\n-\t   ? is_bitfield_expr_with_lowered_type (TREE_OPERAND (stmt, 2))\n-\t   : NULL_TREE);\n-      if (type_left\n-\t  && !useless_type_conversion_p (TREE_TYPE (stmt),\n-\t\t\t\t\t TREE_TYPE (TREE_OPERAND (stmt, 1))))\n-\t{\n-\t  TREE_OPERAND (stmt, 1)\n-\t    = fold_convert (type_left, TREE_OPERAND (stmt, 1));\n-\t  gcc_assert (useless_type_conversion_p (TREE_TYPE (stmt),\n-\t\t\t\t\t\t type_left));\n-\t}\n-      if (type_right\n-\t  && !useless_type_conversion_p (TREE_TYPE (stmt),\n-\t\t\t\t\t TREE_TYPE (TREE_OPERAND (stmt, 2))))\n-\t{\n-\t  TREE_OPERAND (stmt, 2)\n-\t    = fold_convert (type_right, TREE_OPERAND (stmt, 2));\n-\t  gcc_assert (useless_type_conversion_p (TREE_TYPE (stmt),\n-\t\t\t\t\t\t type_right));\n-\t}\n-    }\n+    /* COND_EXPR might have incompatible types in branches if one or both\n+       arms are bitfields.  Fix it up now.  */\n+    case COND_EXPR:\n+      {\n+\ttree type_left\n+\t  = (TREE_OPERAND (stmt, 1)\n+\t     ? is_bitfield_expr_with_lowered_type (TREE_OPERAND (stmt, 1))\n+\t     : NULL_TREE);\n+\ttree type_right\n+\t  = (TREE_OPERAND (stmt, 2)\n+\t     ? is_bitfield_expr_with_lowered_type (TREE_OPERAND (stmt, 2))\n+\t     : NULL_TREE);\n+\tif (type_left\n+\t    && !useless_type_conversion_p (TREE_TYPE (stmt),\n+\t\t\t\t\t   TREE_TYPE (TREE_OPERAND (stmt, 1))))\n+\t  {\n+\t    TREE_OPERAND (stmt, 1)\n+\t      = fold_convert (type_left, TREE_OPERAND (stmt, 1));\n+\t    gcc_assert (useless_type_conversion_p (TREE_TYPE (stmt),\n+\t\t\t\t\t\t   type_left));\n+\t  }\n+\tif (type_right\n+\t    && !useless_type_conversion_p (TREE_TYPE (stmt),\n+\t\t\t\t\t   TREE_TYPE (TREE_OPERAND (stmt, 2))))\n+\t  {\n+\t    TREE_OPERAND (stmt, 2)\n+\t      = fold_convert (type_right, TREE_OPERAND (stmt, 2));\n+\t    gcc_assert (useless_type_conversion_p (TREE_TYPE (stmt),\n+\t\t\t\t\t\t   type_right));\n+\t  }\n+      }\n+      break;\n \n-  else if (TREE_CODE (stmt) == BIND_EXPR)\n-    {\n+    case BIND_EXPR:\n       if (__builtin_expect (wtd->omp_ctx != NULL, 0))\n \t{\n \t  tree decl;\n@@ -1281,113 +1284,118 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n       cp_walk_tree (&BIND_EXPR_BODY (stmt),\n \t\t    cp_genericize_r, data, NULL);\n       wtd->bind_expr_stack.pop ();\n-    }\n+      break;\n \n-  else if (TREE_CODE (stmt) == USING_STMT)\n-    {\n-      tree block = NULL_TREE;\n+    case USING_STMT:\n+      {\n+\ttree block = NULL_TREE;\n+\n+\t/* Get the innermost inclosing GIMPLE_BIND that has a non NULL\n+\t   BLOCK, and append an IMPORTED_DECL to its\n+\t   BLOCK_VARS chained list.  */\n+\tif (wtd->bind_expr_stack.exists ())\n+\t  {\n+\t    int i;\n+\t    for (i = wtd->bind_expr_stack.length () - 1; i >= 0; i--)\n+\t      if ((block = BIND_EXPR_BLOCK (wtd->bind_expr_stack[i])))\n+\t\tbreak;\n+\t  }\n+\tif (block)\n+\t  {\n+\t    tree using_directive;\n+\t    gcc_assert (TREE_OPERAND (stmt, 0));\n \n-      /* Get the innermost inclosing GIMPLE_BIND that has a non NULL\n-         BLOCK, and append an IMPORTED_DECL to its\n-\t BLOCK_VARS chained list.  */\n-      if (wtd->bind_expr_stack.exists ())\n+\t    using_directive = make_node (IMPORTED_DECL);\n+\t    TREE_TYPE (using_directive) = void_type_node;\n+\n+\t    IMPORTED_DECL_ASSOCIATED_DECL (using_directive)\n+\t      = TREE_OPERAND (stmt, 0);\n+\t    DECL_CHAIN (using_directive) = BLOCK_VARS (block);\n+\t    BLOCK_VARS (block) = using_directive;\n+\t  }\n+\t/* The USING_STMT won't appear in GENERIC.  */\n+\t*stmt_p = build1 (NOP_EXPR, void_type_node, integer_zero_node);\n+\t*walk_subtrees = 0;\n+      }\n+      break;\n+\n+    case DECL_EXPR:\n+      if (TREE_CODE (DECL_EXPR_DECL (stmt)) == USING_DECL)\n \t{\n-\t  int i;\n-\t  for (i = wtd->bind_expr_stack.length () - 1; i >= 0; i--)\n-\t    if ((block = BIND_EXPR_BLOCK (wtd->bind_expr_stack[i])))\n-\t      break;\n+\t  /* Using decls inside DECL_EXPRs are just dropped on the floor.  */\n+\t  *stmt_p = build1 (NOP_EXPR, void_type_node, integer_zero_node);\n+\t  *walk_subtrees = 0;\n \t}\n-      if (block)\n+      else\n \t{\n-\t  tree using_directive;\n-\t  gcc_assert (TREE_OPERAND (stmt, 0));\n-\n-\t  using_directive = make_node (IMPORTED_DECL);\n-\t  TREE_TYPE (using_directive) = void_type_node;\n-\n-\t  IMPORTED_DECL_ASSOCIATED_DECL (using_directive)\n-\t    = TREE_OPERAND (stmt, 0);\n-\t  DECL_CHAIN (using_directive) = BLOCK_VARS (block);\n-\t  BLOCK_VARS (block) = using_directive;\n+\t  tree d = DECL_EXPR_DECL (stmt);\n+\t  if (VAR_P (d))\n+\t    gcc_assert (CP_DECL_THREAD_LOCAL_P (d) == DECL_THREAD_LOCAL_P (d));\n \t}\n-      /* The USING_STMT won't appear in GENERIC.  */\n-      *stmt_p = build1 (NOP_EXPR, void_type_node, integer_zero_node);\n-      *walk_subtrees = 0;\n-    }\n-\n-  else if (TREE_CODE (stmt) == DECL_EXPR\n-\t   && TREE_CODE (DECL_EXPR_DECL (stmt)) == USING_DECL)\n-    {\n-      /* Using decls inside DECL_EXPRs are just dropped on the floor.  */\n-      *stmt_p = build1 (NOP_EXPR, void_type_node, integer_zero_node);\n-      *walk_subtrees = 0;\n-    }\n-  else if (TREE_CODE (stmt) == DECL_EXPR)\n-    {\n-      tree d = DECL_EXPR_DECL (stmt);\n-      if (VAR_P (d))\n-\tgcc_assert (CP_DECL_THREAD_LOCAL_P (d) == DECL_THREAD_LOCAL_P (d));\n-    }\n-  else if (TREE_CODE (stmt) == OMP_PARALLEL\n-\t   || TREE_CODE (stmt) == OMP_TASK\n-\t   || TREE_CODE (stmt) == OMP_TASKLOOP)\n-    {\n-      struct cp_genericize_omp_taskreg omp_ctx;\n-      tree c, decl;\n-      splay_tree_node n;\n+      break;\n \n-      *walk_subtrees = 0;\n-      cp_walk_tree (&OMP_CLAUSES (stmt), cp_genericize_r, data, NULL);\n-      omp_ctx.is_parallel = TREE_CODE (stmt) == OMP_PARALLEL;\n-      omp_ctx.default_shared = omp_ctx.is_parallel;\n-      omp_ctx.outer = wtd->omp_ctx;\n-      omp_ctx.variables = splay_tree_new (splay_tree_compare_decl_uid, 0, 0);\n-      wtd->omp_ctx = &omp_ctx;\n-      for (c = OMP_CLAUSES (stmt); c; c = OMP_CLAUSE_CHAIN (c))\n-\tswitch (OMP_CLAUSE_CODE (c))\n-\t  {\n-\t  case OMP_CLAUSE_SHARED:\n-\t  case OMP_CLAUSE_PRIVATE:\n-\t  case OMP_CLAUSE_FIRSTPRIVATE:\n-\t  case OMP_CLAUSE_LASTPRIVATE:\n-\t    decl = OMP_CLAUSE_DECL (c);\n-\t    if (decl == error_mark_node || !omp_var_to_track (decl))\n+    case OMP_PARALLEL:\n+    case OMP_TASK:\n+    case OMP_TASKLOOP:\n+      {\n+\tstruct cp_genericize_omp_taskreg omp_ctx;\n+\ttree c, decl;\n+\tsplay_tree_node n;\n+\n+\t*walk_subtrees = 0;\n+\tcp_walk_tree (&OMP_CLAUSES (stmt), cp_genericize_r, data, NULL);\n+\tomp_ctx.is_parallel = TREE_CODE (stmt) == OMP_PARALLEL;\n+\tomp_ctx.default_shared = omp_ctx.is_parallel;\n+\tomp_ctx.outer = wtd->omp_ctx;\n+\tomp_ctx.variables = splay_tree_new (splay_tree_compare_decl_uid, 0, 0);\n+\twtd->omp_ctx = &omp_ctx;\n+\tfor (c = OMP_CLAUSES (stmt); c; c = OMP_CLAUSE_CHAIN (c))\n+\t  switch (OMP_CLAUSE_CODE (c))\n+\t    {\n+\t    case OMP_CLAUSE_SHARED:\n+\t    case OMP_CLAUSE_PRIVATE:\n+\t    case OMP_CLAUSE_FIRSTPRIVATE:\n+\t    case OMP_CLAUSE_LASTPRIVATE:\n+\t      decl = OMP_CLAUSE_DECL (c);\n+\t      if (decl == error_mark_node || !omp_var_to_track (decl))\n+\t\tbreak;\n+\t      n = splay_tree_lookup (omp_ctx.variables, (splay_tree_key) decl);\n+\t      if (n != NULL)\n+\t\tbreak;\n+\t      splay_tree_insert (omp_ctx.variables, (splay_tree_key) decl,\n+\t\t\t\t OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED\n+\t\t\t\t ? OMP_CLAUSE_DEFAULT_SHARED\n+\t\t\t\t : OMP_CLAUSE_DEFAULT_PRIVATE);\n+\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_PRIVATE && omp_ctx.outer)\n+\t\tomp_cxx_notice_variable (omp_ctx.outer, decl);\n \t      break;\n-\t    n = splay_tree_lookup (omp_ctx.variables, (splay_tree_key) decl);\n-\t    if (n != NULL)\n+\t    case OMP_CLAUSE_DEFAULT:\n+\t      if (OMP_CLAUSE_DEFAULT_KIND (c) == OMP_CLAUSE_DEFAULT_SHARED)\n+\t\tomp_ctx.default_shared = true;\n+\t    default:\n \t      break;\n-\t    splay_tree_insert (omp_ctx.variables, (splay_tree_key) decl,\n-\t\t\t       OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED\n-\t\t\t       ? OMP_CLAUSE_DEFAULT_SHARED\n-\t\t\t       : OMP_CLAUSE_DEFAULT_PRIVATE);\n-\t    if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_PRIVATE\n-\t\t&& omp_ctx.outer)\n-\t      omp_cxx_notice_variable (omp_ctx.outer, decl);\n-\t    break;\n-\t  case OMP_CLAUSE_DEFAULT:\n-\t    if (OMP_CLAUSE_DEFAULT_KIND (c) == OMP_CLAUSE_DEFAULT_SHARED)\n-\t      omp_ctx.default_shared = true;\n-\t  default:\n-\t    break;\n-\t  }\n-      if (TREE_CODE (stmt) == OMP_TASKLOOP)\n-\tgenericize_omp_for_stmt (stmt_p, walk_subtrees, data);\n-      else\n-\tcp_walk_tree (&OMP_BODY (stmt), cp_genericize_r, data, NULL);\n-      wtd->omp_ctx = omp_ctx.outer;\n-      splay_tree_delete (omp_ctx.variables);\n-    }\n-  else if (TREE_CODE (stmt) == TRY_BLOCK)\n-    {\n-      *walk_subtrees = 0;\n-      tree try_block = wtd->try_block;\n-      wtd->try_block = stmt;\n-      cp_walk_tree (&TRY_STMTS (stmt), cp_genericize_r, data, NULL);\n-      wtd->try_block = try_block;\n-      cp_walk_tree (&TRY_HANDLERS (stmt), cp_genericize_r, data, NULL);\n-    }\n-  else if (TREE_CODE (stmt) == MUST_NOT_THROW_EXPR)\n-    {\n+\t    }\n+\tif (TREE_CODE (stmt) == OMP_TASKLOOP)\n+\t  genericize_omp_for_stmt (stmt_p, walk_subtrees, data);\n+\telse\n+\t  cp_walk_tree (&OMP_BODY (stmt), cp_genericize_r, data, NULL);\n+\twtd->omp_ctx = omp_ctx.outer;\n+\tsplay_tree_delete (omp_ctx.variables);\n+      }\n+      break;\n+\n+    case TRY_BLOCK:\n+      {\n+        *walk_subtrees = 0;\n+        tree try_block = wtd->try_block;\n+        wtd->try_block = stmt;\n+        cp_walk_tree (&TRY_STMTS (stmt), cp_genericize_r, data, NULL);\n+        wtd->try_block = try_block;\n+        cp_walk_tree (&TRY_HANDLERS (stmt), cp_genericize_r, data, NULL);\n+      }\n+      break;\n+\n+    case MUST_NOT_THROW_EXPR:\n       /* MUST_NOT_THROW_COND might be something else with TM.  */\n       if (MUST_NOT_THROW_COND (stmt) == NULL_TREE)\n \t{\n@@ -1397,78 +1405,99 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t  cp_walk_tree (&TREE_OPERAND (stmt, 0), cp_genericize_r, data, NULL);\n \t  wtd->try_block = try_block;\n \t}\n-    }\n-  else if (TREE_CODE (stmt) == THROW_EXPR)\n-    {\n-      location_t loc = location_of (stmt);\n-      if (TREE_NO_WARNING (stmt))\n-\t/* Never mind.  */;\n-      else if (wtd->try_block)\n-\t{\n-\t  if (TREE_CODE (wtd->try_block) == MUST_NOT_THROW_EXPR\n-\t      && warning_at (loc, OPT_Wterminate,\n-\t\t\t     \"throw will always call terminate()\")\n-\t      && cxx_dialect >= cxx11\n-\t      && DECL_DESTRUCTOR_P (current_function_decl))\n-\t    inform (loc, \"in C++11 destructors default to noexcept\");\n-\t}\n-      else\n-\t{\n-\t  if (warn_cxx11_compat && cxx_dialect < cxx11\n-\t      && DECL_DESTRUCTOR_P (current_function_decl)\n-\t      && (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl))\n-\t\t  == NULL_TREE)\n-\t      && (get_defaulted_eh_spec (current_function_decl)\n-\t\t  == empty_except_spec))\n-\t    warning_at (loc, OPT_Wc__11_compat,\n-\t\t\t\"in C++11 this throw will terminate because \"\n-\t\t\t\"destructors default to noexcept\");\n-\t}\n-    }\n-  else if (TREE_CODE (stmt) == CONVERT_EXPR)\n-    gcc_assert (!CONVERT_EXPR_VBASE_PATH (stmt));\n-  else if (TREE_CODE (stmt) == FOR_STMT)\n-    genericize_for_stmt (stmt_p, walk_subtrees, data);\n-  else if (TREE_CODE (stmt) == WHILE_STMT)\n-    genericize_while_stmt (stmt_p, walk_subtrees, data);\n-  else if (TREE_CODE (stmt) == DO_STMT)\n-    genericize_do_stmt (stmt_p, walk_subtrees, data);\n-  else if (TREE_CODE (stmt) == SWITCH_STMT)\n-    genericize_switch_stmt (stmt_p, walk_subtrees, data);\n-  else if (TREE_CODE (stmt) == CONTINUE_STMT)\n-    genericize_continue_stmt (stmt_p);\n-  else if (TREE_CODE (stmt) == BREAK_STMT)\n-    genericize_break_stmt (stmt_p);\n-  else if (TREE_CODE (stmt) == OMP_FOR\n-\t   || TREE_CODE (stmt) == OMP_SIMD\n-\t   || TREE_CODE (stmt) == OMP_DISTRIBUTE)\n-    genericize_omp_for_stmt (stmt_p, walk_subtrees, data);\n-  else if (TREE_CODE (stmt) == PTRMEM_CST)\n-    {\n+      break;\n+\n+    case THROW_EXPR:\n+      {\n+\tlocation_t loc = location_of (stmt);\n+\tif (TREE_NO_WARNING (stmt))\n+\t  /* Never mind.  */;\n+\telse if (wtd->try_block)\n+\t  {\n+\t    if (TREE_CODE (wtd->try_block) == MUST_NOT_THROW_EXPR\n+\t\t&& warning_at (loc, OPT_Wterminate,\n+\t\t\t       \"throw will always call terminate()\")\n+\t\t&& cxx_dialect >= cxx11\n+\t\t&& DECL_DESTRUCTOR_P (current_function_decl))\n+\t      inform (loc, \"in C++11 destructors default to noexcept\");\n+\t  }\n+\telse\n+\t  {\n+\t    if (warn_cxx11_compat && cxx_dialect < cxx11\n+\t\t&& DECL_DESTRUCTOR_P (current_function_decl)\n+\t\t&& (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl))\n+\t\t    == NULL_TREE)\n+\t\t&& (get_defaulted_eh_spec (current_function_decl)\n+\t\t    == empty_except_spec))\n+\t      warning_at (loc, OPT_Wc__11_compat,\n+\t\t\t  \"in C++11 this throw will terminate because \"\n+\t\t\t  \"destructors default to noexcept\");\n+\t  }\n+      }\n+      break;\n+\n+    case CONVERT_EXPR:\n+      gcc_assert (!CONVERT_EXPR_VBASE_PATH (stmt));\n+      break;\n+\n+    case FOR_STMT:\n+      genericize_for_stmt (stmt_p, walk_subtrees, data);\n+      break;\n+\n+    case WHILE_STMT:\n+      genericize_while_stmt (stmt_p, walk_subtrees, data);\n+      break;\n+\n+    case DO_STMT:\n+      genericize_do_stmt (stmt_p, walk_subtrees, data);\n+      break;\n+\n+    case SWITCH_STMT:\n+      genericize_switch_stmt (stmt_p, walk_subtrees, data);\n+      break;\n+\n+    case CONTINUE_STMT:\n+      genericize_continue_stmt (stmt_p);\n+      break;\n+\n+    case BREAK_STMT:\n+      genericize_break_stmt (stmt_p);\n+      break;\n+\n+    case OMP_FOR:\n+    case OMP_SIMD:\n+    case OMP_DISTRIBUTE:\n+      genericize_omp_for_stmt (stmt_p, walk_subtrees, data);\n+      break;\n+\n+    case PTRMEM_CST:\n       /* By the time we get here we're handing off to the back end, so we don't\n \t need or want to preserve PTRMEM_CST anymore.  */\n       *stmt_p = cplus_expand_constant (stmt);\n       *walk_subtrees = 0;\n-    }\n-  else if (TREE_CODE (stmt) == MEM_REF)\n-    {\n+      break;\n+\n+    case MEM_REF:\n       /* For MEM_REF, make sure not to sanitize the second operand even\n-         if it has reference type.  It is just an offset with a type\n+\t if it has reference type.  It is just an offset with a type\n \t holding other information.  There is no other processing we\n \t need to do for INTEGER_CSTs, so just ignore the second argument\n \t unconditionally.  */\n       cp_walk_tree (&TREE_OPERAND (stmt, 0), cp_genericize_r, data, NULL);\n       *walk_subtrees = 0;\n-    }\n-  else if (sanitize_flags_p ((SANITIZE_NULL\n-\t\t\t      | SANITIZE_ALIGNMENT | SANITIZE_VPTR))\n-\t   && !wtd->no_sanitize_p)\n-    {\n-      if (sanitize_flags_p (SANITIZE_NULL | SANITIZE_ALIGNMENT)\n-\t  && TREE_CODE (stmt) == NOP_EXPR\n+      break;\n+\n+    case NOP_EXPR:\n+      if (!wtd->no_sanitize_p\n+\t  && sanitize_flags_p (SANITIZE_NULL | SANITIZE_ALIGNMENT)\n \t  && TREE_CODE (TREE_TYPE (stmt)) == REFERENCE_TYPE)\n \tubsan_maybe_instrument_reference (stmt_p);\n-      else if (TREE_CODE (stmt) == CALL_EXPR)\n+      break;\n+\n+    case CALL_EXPR:\n+      if (!wtd->no_sanitize_p\n+\t  && sanitize_flags_p ((SANITIZE_NULL\n+\t\t\t\t| SANITIZE_ALIGNMENT | SANITIZE_VPTR)))\n \t{\n \t  tree fn = CALL_EXPR_FN (stmt);\n \t  if (fn != NULL_TREE\n@@ -1486,6 +1515,12 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t\tcp_ubsan_maybe_instrument_member_call (stmt);\n \t    }\n \t}\n+      break;\n+\n+    default:\n+      if (IS_TYPE_OR_DECL_P (stmt))\n+\t*walk_subtrees = 0;\n+      break;\n     }\n \n   p_set->add (*stmt_p);"}]}