{"sha": "00c072ae51c132e346eab0c6f8c176542efbcd5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBjMDcyYWU1MWMxMzJlMzQ2ZWFiMGM2ZjhjMTc2NTQyZWZiY2Q1YQ==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2016-04-28T09:53:13Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2016-04-28T09:53:13Z"}, "message": "[ARC] Add SIMD extensions for ARC HS\n\ngcc/\n2016-04-28  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc.c (arc_vector_mode_supported_p): Add support for\n\tthe new ARC HS SIMD instructions.\n\t(arc_preferred_simd_mode): New function.\n\t(arc_autovectorize_vector_sizes): Likewise.\n\t(TARGET_VECTORIZE_PREFERRED_SIMD_MODE)\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Define.\n\t(arc_init_reg_tables): Accept new ARC HS SIMD modes.\n\t(arc_init_builtins): Add new SIMD builtin types.\n\t(arc_split_move): Handle 64 bit vector moves.\n\t* config/arc/arc.h (TARGET_PLUS_DMPY, TARGET_PLUS_MACD)\n\t(TARGET_PLUS_QMACW): Define.\n\t* config/arc/builtins.def (QMACH, QMACHU, QMPYH, QMPYHU, DMACH)\n\t(DMACHU, DMPYH, DMPYHU, DMACWH, DMACWHU, VMAC2H, VMAC2HU, VMPY2H)\n\t(VMPY2HU, VADDSUB2H, VSUBADD2H, VADDSUB, VSUBADD, VADDSUB4H)\n\t(VSUBADD4H): New builtins.\n\t* config/arc/simdext.md: Add new ARC HS SIMD instructions.\n\t* testsuite/gcc.target/arc/builtin_simdarc.c: New file.\n\nFrom-SVN: r235551", "tree": {"sha": "146450a4a2fcb549676ac1fec42051bbc2176e40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/146450a4a2fcb549676ac1fec42051bbc2176e40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00c072ae51c132e346eab0c6f8c176542efbcd5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c072ae51c132e346eab0c6f8c176542efbcd5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00c072ae51c132e346eab0c6f8c176542efbcd5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c072ae51c132e346eab0c6f8c176542efbcd5a/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "174f66220d4d39ed503ded1ec3e7ba514cc4283e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174f66220d4d39ed503ded1ec3e7ba514cc4283e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174f66220d4d39ed503ded1ec3e7ba514cc4283e"}], "stats": {"total": 774, "additions": 767, "deletions": 7}, "files": [{"sha": "f557c9ff453748495447d46a12370a3538c38bff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c072ae51c132e346eab0c6f8c176542efbcd5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c072ae51c132e346eab0c6f8c176542efbcd5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00c072ae51c132e346eab0c6f8c176542efbcd5a", "patch": "@@ -1,3 +1,23 @@\n+2016-04-28  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc.c (arc_vector_mode_supported_p): Add support for\n+\tthe new ARC HS SIMD instructions.\n+\t(arc_preferred_simd_mode): New function.\n+\t(arc_autovectorize_vector_sizes): Likewise.\n+\t(TARGET_VECTORIZE_PREFERRED_SIMD_MODE)\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Define.\n+\t(arc_init_reg_tables): Accept new ARC HS SIMD modes.\n+\t(arc_init_builtins): Add new SIMD builtin types.\n+\t(arc_split_move): Handle 64 bit vector moves.\n+\t* config/arc/arc.h (TARGET_PLUS_DMPY, TARGET_PLUS_MACD)\n+\t(TARGET_PLUS_QMACW): Define.\n+\t* config/arc/builtins.def (QMACH, QMACHU, QMPYH, QMPYHU, DMACH)\n+\t(DMACHU, DMPYH, DMPYHU, DMACWH, DMACWHU, VMAC2H, VMAC2HU, VMPY2H)\n+\t(VMPY2HU, VADDSUB2H, VSUBADD2H, VADDSUB, VSUBADD, VADDSUB4H)\n+\t(VSUBADD4H): New builtins.\n+\t* config/arc/simdext.md: Add new ARC HS SIMD instructions.\n+\t* testsuite/gcc.target/arc/builtin_simdarc.c: New file.\n+\n 2016-04-28  Eduard Sanou  <dhole@openmailbox.org>\n \t    Matthias Klose  <doko@debian.org>\n "}, {"sha": "d120946a5f2fa78ecf8df464d108ffa8adb0a536", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 105, "deletions": 7, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c072ae51c132e346eab0c6f8c176542efbcd5a/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c072ae51c132e346eab0c6f8c176542efbcd5a/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=00c072ae51c132e346eab0c6f8c176542efbcd5a", "patch": "@@ -247,16 +247,47 @@ static bool arc_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT,\n static bool\n arc_vector_mode_supported_p (machine_mode mode)\n {\n-  if (!TARGET_SIMD_SET)\n-    return false;\n+  switch (mode)\n+    {\n+    case V2HImode:\n+      return TARGET_PLUS_DMPY;\n+    case V4HImode:\n+    case V2SImode:\n+      return TARGET_PLUS_QMACW;\n+    case V4SImode:\n+    case V8HImode:\n+      return TARGET_SIMD_SET;\n \n-  if ((mode == V4SImode)\n-      || (mode == V8HImode))\n-    return true;\n+    default:\n+      return false;\n+    }\n+}\n \n-  return false;\n+/* Implements target hook TARGET_VECTORIZE_PREFERRED_SIMD_MODE.  */\n+\n+static enum machine_mode\n+arc_preferred_simd_mode (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case HImode:\n+      return TARGET_PLUS_QMACW ? V4HImode : V2HImode;\n+    case SImode:\n+      return V2SImode;\n+\n+    default:\n+      return word_mode;\n+    }\n }\n \n+/* Implements target hook\n+   TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES.  */\n+\n+static unsigned int\n+arc_autovectorize_vector_sizes (void)\n+{\n+  return TARGET_PLUS_QMACW ? (8 | 4) : 0;\n+}\n \n /* TARGET_PRESERVE_RELOAD_P is still awaiting patch re-evaluation / review.  */\n static bool arc_preserve_reload_p (rtx in) ATTRIBUTE_UNUSED;\n@@ -345,6 +376,12 @@ static void arc_finalize_pic (void);\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P arc_vector_mode_supported_p\n \n+#undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n+#define TARGET_VECTORIZE_PREFERRED_SIMD_MODE arc_preferred_simd_mode\n+\n+#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n+#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES arc_autovectorize_vector_sizes\n+\n #undef TARGET_CAN_USE_DOLOOP_P\n #define TARGET_CAN_USE_DOLOOP_P arc_can_use_doloop_p\n \n@@ -1214,7 +1251,12 @@ arc_init_reg_tables (void)\n \t    arc_mode_class[i] = 0;\n \t  break;\n \tcase MODE_VECTOR_INT:\n-\t  arc_mode_class [i] = (1<< (int) V_MODE);\n+\t  if (GET_MODE_SIZE (m) == 4)\n+\t    arc_mode_class[i] = (1 << (int) S_MODE);\n+\t  else if (GET_MODE_SIZE (m) == 8)\n+\t    arc_mode_class[i] = (1 << (int) D_MODE);\n+\t  else\n+\t    arc_mode_class[i] = (1 << (int) V_MODE);\n \t  break;\n \tcase MODE_CC:\n \tdefault:\n@@ -5277,6 +5319,15 @@ arc_builtin_decl (unsigned id, bool initialize_p ATTRIBUTE_UNUSED)\n static void\n arc_init_builtins (void)\n {\n+  tree V4HI_type_node;\n+  tree V2SI_type_node;\n+  tree V2HI_type_node;\n+\n+  /* Vector types based on HS SIMD elements.  */\n+  V4HI_type_node = build_vector_type_for_mode (intHI_type_node, V4HImode);\n+  V2SI_type_node = build_vector_type_for_mode (intSI_type_node, V2SImode);\n+  V2HI_type_node = build_vector_type_for_mode (intHI_type_node, V2HImode);\n+\n   tree pcvoid_type_node\n     = build_pointer_type (build_qualified_type (void_type_node,\n \t\t\t\t\t\tTYPE_QUAL_CONST));\n@@ -5341,6 +5392,28 @@ arc_init_builtins (void)\n   tree v8hi_ftype_v8hi\n     = build_function_type_list (V8HI_type_node, V8HI_type_node,\n \t\t\t\tNULL_TREE);\n+  /* ARCv2 SIMD types.  */\n+  tree long_ftype_v4hi_v4hi\n+    = build_function_type_list (long_long_integer_type_node,\n+\t\t\t\tV4HI_type_node,\tV4HI_type_node, NULL_TREE);\n+  tree int_ftype_v2hi_v2hi\n+    = build_function_type_list (integer_type_node,\n+\t\t\t\tV2HI_type_node, V2HI_type_node, NULL_TREE);\n+  tree v2si_ftype_v2hi_v2hi\n+    = build_function_type_list (V2SI_type_node,\n+\t\t\t\tV2HI_type_node, V2HI_type_node, NULL_TREE);\n+  tree v2hi_ftype_v2hi_v2hi\n+    = build_function_type_list (V2HI_type_node,\n+\t\t\t\tV2HI_type_node, V2HI_type_node, NULL_TREE);\n+  tree v2si_ftype_v2si_v2si\n+    = build_function_type_list (V2SI_type_node,\n+\t\t\t\tV2SI_type_node, V2SI_type_node, NULL_TREE);\n+  tree v4hi_ftype_v4hi_v4hi\n+    = build_function_type_list (V4HI_type_node,\n+\t\t\t\tV4HI_type_node, V4HI_type_node, NULL_TREE);\n+  tree long_ftype_v2si_v2hi\n+    = build_function_type_list (long_long_integer_type_node,\n+\t\t\t\tV2SI_type_node, V2HI_type_node, NULL_TREE);\n \n   /* Add the builtins.  */\n #define DEF_BUILTIN(NAME, N_ARGS, TYPE, ICODE, MASK)\t\t\t\\\n@@ -8706,6 +8779,31 @@ arc_split_move (rtx *operands)\n       return;\n     }\n \n+  if (TARGET_PLUS_QMACW\n+      && GET_CODE (operands[1]) == CONST_VECTOR)\n+    {\n+      HOST_WIDE_INT intval0, intval1;\n+      if (GET_MODE (operands[1]) == V2SImode)\n+\t{\n+\t  intval0 = INTVAL (XVECEXP (operands[1], 0, 0));\n+\t  intval1 = INTVAL (XVECEXP (operands[1], 0, 1));\n+\t}\n+      else\n+\t{\n+\t  intval1  = INTVAL (XVECEXP (operands[1], 0, 3)) << 16;\n+\t  intval1 |= INTVAL (XVECEXP (operands[1], 0, 2)) & 0xFFFF;\n+\t  intval0  = INTVAL (XVECEXP (operands[1], 0, 1)) << 16;\n+\t  intval0 |= INTVAL (XVECEXP (operands[1], 0, 0)) & 0xFFFF;\n+\t}\n+      xop[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\n+      xop[3] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n+      xop[2] = GEN_INT (trunc_int_for_mode (intval0, SImode));\n+      xop[1] = GEN_INT (trunc_int_for_mode (intval1, SImode));\n+      emit_move_insn (xop[0], xop[2]);\n+      emit_move_insn (xop[3], xop[1]);\n+      return;\n+    }\n+\n   for (i = 0; i < 2; i++)\n     {\n       if (MEM_P (operands[i]) && auto_inc_p (XEXP (operands[i], 0)))"}, {"sha": "5100a5b8f821f3e5a6dfa5f986790ddc3ac60674", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c072ae51c132e346eab0c6f8c176542efbcd5a/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c072ae51c132e346eab0c6f8c176542efbcd5a/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=00c072ae51c132e346eab0c6f8c176542efbcd5a", "patch": "@@ -1724,6 +1724,12 @@ enum\n /* Any multiplication feature macro.  */\n #define TARGET_ANY_MPY\t\t\t\t\t\t\\\n   (TARGET_MPY || TARGET_MUL64_SET || TARGET_MULMAC_32BY16_SET)\n+/* PLUS_DMPY feature macro.  */\n+#define TARGET_PLUS_DMPY  ((arc_mpy_option > 6) && TARGET_HS)\n+/* PLUS_MACD feature macro.  */\n+#define TARGET_PLUS_MACD  ((arc_mpy_option > 7) && TARGET_HS)\n+/* PLUS_QMACW feature macro.  */\n+#define TARGET_PLUS_QMACW ((arc_mpy_option > 8) && TARGET_HS)\n \n /* ARC600 and ARC601 feature macro.  */\n #define TARGET_ARC600_FAMILY (TARGET_ARC600 || TARGET_ARC601)"}, {"sha": "8c71d30a459a74fe5e7d2c4c98a4f6a942616997", "filename": "gcc/config/arc/builtins.def", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c072ae51c132e346eab0c6f8c176542efbcd5a/gcc%2Fconfig%2Farc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c072ae51c132e346eab0c6f8c176542efbcd5a/gcc%2Fconfig%2Farc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fbuiltins.def?ref=00c072ae51c132e346eab0c6f8c176542efbcd5a", "patch": "@@ -193,3 +193,30 @@ DEF_BUILTIN (VINTI, 1, void_ftype_int, vinti_insn, TARGET_SIMD_SET)\n \n /* END SIMD marker.  */\n DEF_BUILTIN (SIMD_END, 0, void_ftype_void, nothing, 0)\n+\n+/* ARCv2 SIMD instructions that use/clobber the accumulator reg.  */\n+DEF_BUILTIN (QMACH,      2, long_ftype_v4hi_v4hi,   qmach,      TARGET_PLUS_QMACW)\n+DEF_BUILTIN (QMACHU,     2, long_ftype_v4hi_v4hi,   qmachu,     TARGET_PLUS_QMACW)\n+DEF_BUILTIN (QMPYH,      2, long_ftype_v4hi_v4hi,   qmpyh,      TARGET_PLUS_QMACW)\n+DEF_BUILTIN (QMPYHU,     2, long_ftype_v4hi_v4hi,   qmpyhu,     TARGET_PLUS_QMACW)\n+\n+DEF_BUILTIN (DMACH,      2, int_ftype_v2hi_v2hi,    dmach,      TARGET_PLUS_DMPY)\n+DEF_BUILTIN (DMACHU,     2, int_ftype_v2hi_v2hi,    dmachu,     TARGET_PLUS_DMPY)\n+DEF_BUILTIN (DMPYH,      2, int_ftype_v2hi_v2hi,    dmpyh,      TARGET_PLUS_DMPY)\n+DEF_BUILTIN (DMPYHU,     2, int_ftype_v2hi_v2hi,    dmpyhu,     TARGET_PLUS_DMPY)\n+\n+DEF_BUILTIN (DMACWH,     2, long_ftype_v2si_v2hi,   dmacwh,     TARGET_PLUS_QMACW)\n+DEF_BUILTIN (DMACWHU,    2, long_ftype_v2si_v2hi,   dmacwhu,    TARGET_PLUS_QMACW)\n+\n+DEF_BUILTIN (VMAC2H,     2, v2si_ftype_v2hi_v2hi,   vmac2h,     TARGET_PLUS_MACD)\n+DEF_BUILTIN (VMAC2HU,    2, v2si_ftype_v2hi_v2hi,   vmac2hu,    TARGET_PLUS_MACD)\n+DEF_BUILTIN (VMPY2H,     2, v2si_ftype_v2hi_v2hi,   vmpy2h,     TARGET_PLUS_MACD)\n+DEF_BUILTIN (VMPY2HU,    2, v2si_ftype_v2hi_v2hi,   vmpy2hu,    TARGET_PLUS_MACD)\n+\n+/* Combined add/sub HS SIMD instructions.  */\n+DEF_BUILTIN (VADDSUB2H,  2, v2hi_ftype_v2hi_v2hi,   addsubv2hi3, TARGET_PLUS_DMPY)\n+DEF_BUILTIN (VSUBADD2H,  2, v2hi_ftype_v2hi_v2hi,   subaddv2hi3, TARGET_PLUS_DMPY)\n+DEF_BUILTIN (VADDSUB,    2, v2si_ftype_v2si_v2si,   addsubv2si3, TARGET_PLUS_QMACW)\n+DEF_BUILTIN (VSUBADD,    2, v2si_ftype_v2si_v2si,   subaddv2si3, TARGET_PLUS_QMACW)\n+DEF_BUILTIN (VADDSUB4H,  2, v4hi_ftype_v4hi_v4hi,   addsubv4hi3, TARGET_PLUS_QMACW)\n+DEF_BUILTIN (VSUBADD4H,  2, v4hi_ftype_v4hi_v4hi,   subaddv4hi3, TARGET_PLUS_QMACW)"}, {"sha": "51869e367726522dc70b2191df1f9228455239cd", "filename": "gcc/config/arc/simdext.md", "status": "modified", "additions": 571, "deletions": 0, "changes": 571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c072ae51c132e346eab0c6f8c176542efbcd5a/gcc%2Fconfig%2Farc%2Fsimdext.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c072ae51c132e346eab0c6f8c176542efbcd5a/gcc%2Fconfig%2Farc%2Fsimdext.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fsimdext.md?ref=00c072ae51c132e346eab0c6f8c176542efbcd5a", "patch": "@@ -1288,3 +1288,574 @@\n   [(set_attr \"type\" \"simd_vcontrol\")\n    (set_attr \"length\" \"4\")\n    (set_attr \"cond\" \"nocond\")])\n+\n+;; New ARCv2 SIMD extensions\n+\n+;;64-bit vectors of halwords and words\n+(define_mode_iterator VWH [V4HI V2SI])\n+\n+;;double element vectors\n+(define_mode_iterator VDV [V2HI V2SI])\n+(define_mode_attr V_addsub [(V2HI \"HI\") (V2SI \"SI\")])\n+(define_mode_attr V_addsub_suffix [(V2HI \"2h\") (V2SI \"\")])\n+\n+;;all vectors\n+(define_mode_iterator VCT [V2HI V4HI V2SI])\n+(define_mode_attr V_suffix [(V2HI \"2h\") (V4HI \"4h\") (V2SI \"2\")])\n+\n+;; Widening operations.\n+(define_code_iterator SE [sign_extend zero_extend])\n+(define_code_attr V_US [(sign_extend \"s\") (zero_extend \"u\")])\n+(define_code_attr V_US_suffix [(sign_extend \"\") (zero_extend \"u\")])\n+\n+\n+;; Move patterns\n+(define_expand \"movv2hi\"\n+  [(set (match_operand:V2HI 0 \"move_dest_operand\" \"\")\n+\t(match_operand:V2HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"{\n+    if (prepare_move_operands (operands, V2HImode))\n+         DONE;\n+   }\")\n+\n+(define_insn_and_split \"*movv2hi_insn\"\n+  [(set (match_operand:V2HI 0 \"nonimmediate_operand\" \"=r,r,r,m\")\n+\t(match_operand:V2HI 1 \"general_operand\"       \"i,r,m,r\"))]\n+  \"(register_operand (operands[0], V2HImode)\n+    || register_operand (operands[1], V2HImode))\"\n+  \"@\n+   #\n+   mov%? %0, %1\n+   ld%U1%V1 %0,%1\n+   st%U0%V0 %1,%0\"\n+  \"reload_completed && GET_CODE (operands[1]) == CONST_VECTOR\"\n+  [(set (match_dup 0) (match_dup 2))]\n+  {\n+   HOST_WIDE_INT intval = INTVAL (XVECEXP (operands[1], 0, 1)) << 16;\n+   intval |= INTVAL (XVECEXP (operands[1], 0, 0)) & 0xFFFF;\n+\n+   operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\n+   operands[2] = GEN_INT (trunc_int_for_mode (intval, SImode));\n+  }\n+  [(set_attr \"type\" \"move,move,load,store\")\n+   (set_attr \"predicable\" \"yes,yes,no,no\")\n+   (set_attr \"iscompact\"  \"false,false,false,false\")\n+   ])\n+\n+(define_expand \"movmisalignv2hi\"\n+ [(set (match_operand:V2HI 0 \"general_operand\" \"\")\n+       (match_operand:V2HI 1 \"general_operand\" \"\"))]\n+ \"\"\n+{\n+ if (!register_operand (operands[0], V2HImode)\n+      && !register_operand (operands[1], V2HImode))\n+    operands[1] = force_reg (V2HImode, operands[1]);\n+})\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:VWH 0 \"move_dest_operand\" \"\")\n+\t(match_operand:VWH 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"{\n+    if (GET_CODE (operands[0]) == MEM)\n+     operands[1] = force_reg (<MODE>mode, operands[1]);\n+   }\")\n+\n+(define_insn_and_split \"*mov<mode>_insn\"\n+  [(set (match_operand:VWH 0 \"move_dest_operand\" \"=r,r,r,m\")\n+\t(match_operand:VWH 1 \"general_operand\"    \"i,r,m,r\"))]\n+  \"TARGET_PLUS_QMACW\n+   && (register_operand (operands[0], <MODE>mode)\n+       || register_operand (operands[1], <MODE>mode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+     default:\n+       return \\\"#\\\";\n+\n+     case 1:\n+       return \\\"vadd2 %0, %1, 0\\\";\n+\n+     case 2:\n+       if (TARGET_LL64)\n+         return \\\"ldd%U1%V1 %0,%1\\\";\n+       return \\\"#\\\";\n+\n+     case 3:\n+       if (TARGET_LL64)\n+\t   return \\\"std%U0%V0 %1,%0\\\";\n+\t return \\\"#\\\";\n+    }\n+}\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  {\n+   arc_split_move (operands);\n+   DONE;\n+  }\n+  [(set_attr \"type\" \"move,move,load,store\")\n+   (set_attr \"predicable\" \"yes,no,no,no\")\n+   (set_attr \"iscompact\"  \"false,false,false,false\")\n+   ])\n+\n+(define_expand \"movmisalign<mode>\"\n+ [(set (match_operand:VWH 0 \"general_operand\" \"\")\n+       (match_operand:VWH 1 \"general_operand\" \"\"))]\n+ \"\"\n+{\n+ if (!register_operand (operands[0], <MODE>mode)\n+      && !register_operand (operands[1], <MODE>mode))\n+    operands[1] = force_reg (<MODE>mode, operands[1]);\n+})\n+\n+(define_insn \"bswapv2hi2\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=r,r\")\n+        (bswap:V2HI (match_operand:V2HI 1 \"nonmemory_operand\" \"r,i\")))]\n+  \"TARGET_V2 && TARGET_SWAP\"\n+  \"swape %0, %1\"\n+  [(set_attr \"length\" \"4,8\")\n+   (set_attr \"type\" \"two_cycle_core\")])\n+\n+;; Simple arithmetic insns\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:VCT 0 \"register_operand\"          \"=r,r\")\n+\t(plus:VCT (match_operand:VCT 1 \"register_operand\" \"0,r\")\n+\t\t  (match_operand:VCT 2 \"register_operand\" \"r,r\")))]\n+  \"TARGET_PLUS_DMPY\"\n+  \"vadd<V_suffix>%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:VCT 0 \"register_operand\"           \"=r,r\")\n+\t(minus:VCT (match_operand:VCT 1 \"register_operand\" \"0,r\")\n+\t\t   (match_operand:VCT 2 \"register_operand\" \"r,r\")))]\n+  \"TARGET_PLUS_DMPY\"\n+  \"vsub<V_suffix>%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+;; Combined arithmetic ops\n+(define_insn \"addsub<mode>3\"\n+  [(set (match_operand:VDV 0 \"register_operand\" \"=r,r\")\n+\t(vec_concat:VDV\n+\t (plus:<V_addsub> (vec_select:<V_addsub> (match_operand:VDV 1 \"register_operand\" \"0,r\")\n+\t\t\t\t\t\t (parallel [(const_int 0)]))\n+\t\t\t  (vec_select:<V_addsub> (match_operand:VDV 2 \"register_operand\" \"r,r\")\n+\t\t\t\t\t\t (parallel [(const_int 0)])))\n+\t (minus:<V_addsub> (vec_select:<V_addsub> (match_dup 1) (parallel [(const_int 1)]))\n+\t\t\t   (vec_select:<V_addsub> (match_dup 2) (parallel [(const_int 1)])))))]\n+  \"TARGET_PLUS_DMPY\"\n+  \"vaddsub<V_addsub_suffix>%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"subadd<mode>3\"\n+  [(set (match_operand:VDV 0 \"register_operand\" \"=r,r\")\n+\t(vec_concat:VDV\n+\t (minus:<V_addsub> (vec_select:<V_addsub> (match_operand:VDV 1 \"register_operand\" \"0,r\")\n+\t\t\t\t\t\t  (parallel [(const_int 0)]))\n+\t\t\t   (vec_select:<V_addsub> (match_operand:VDV 2 \"register_operand\" \"r,r\")\n+\t\t\t\t\t\t  (parallel [(const_int 0)])))\n+\t (plus:<V_addsub> (vec_select:<V_addsub> (match_dup 1) (parallel [(const_int 1)]))\n+\t\t\t  (vec_select:<V_addsub> (match_dup 2) (parallel [(const_int 1)])))))]\n+  \"TARGET_PLUS_DMPY\"\n+  \"vsubadd<V_addsub_suffix>%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"addsubv4hi3\"\n+  [(set (match_operand:V4HI 0 \"even_register_operand\" \"=r,r\")\n+\t(vec_concat:V4HI\n+\t (vec_concat:V2HI\n+\t  (plus:HI (vec_select:HI (match_operand:V4HI 1 \"even_register_operand\" \"0,r\")\n+\t\t\t\t  (parallel [(const_int 0)]))\n+\t\t   (vec_select:HI (match_operand:V4HI 2 \"even_register_operand\" \"r,r\")\n+\t\t\t\t  (parallel [(const_int 0)])))\n+\t  (minus:HI (vec_select:HI (match_dup 1) (parallel [(const_int 1)]))\n+\t\t    (vec_select:HI (match_dup 2) (parallel [(const_int 1)]))))\n+\t (vec_concat:V2HI\n+\t  (plus:HI (vec_select:HI (match_dup 1) (parallel [(const_int 2)]))\n+\t\t   (vec_select:HI (match_dup 2) (parallel [(const_int 2)])))\n+\t  (minus:HI (vec_select:HI (match_dup 1) (parallel [(const_int 3)]))\n+\t\t    (vec_select:HI (match_dup 2) (parallel [(const_int 3)]))))\n+\t ))]\n+  \"TARGET_PLUS_QMACW\"\n+  \"vaddsub4h%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"subaddv4hi3\"\n+  [(set (match_operand:V4HI 0 \"even_register_operand\" \"=r,r\")\n+\t(vec_concat:V4HI\n+\t (vec_concat:V2HI\n+\t  (minus:HI (vec_select:HI (match_operand:V4HI 1 \"even_register_operand\" \"0,r\")\n+\t\t\t\t   (parallel [(const_int 0)]))\n+\t\t    (vec_select:HI (match_operand:V4HI 2 \"even_register_operand\" \"r,r\")\n+\t\t\t\t  (parallel [(const_int 0)])))\n+\t  (plus:HI (vec_select:HI (match_dup 1) (parallel [(const_int 1)]))\n+\t\t   (vec_select:HI (match_dup 2) (parallel [(const_int 1)]))))\n+\t (vec_concat:V2HI\n+\t  (minus:HI (vec_select:HI (match_dup 1) (parallel [(const_int 2)]))\n+\t\t    (vec_select:HI (match_dup 2) (parallel [(const_int 2)])))\n+\t  (plus:HI (vec_select:HI (match_dup 1) (parallel [(const_int 3)]))\n+\t\t   (vec_select:HI (match_dup 2) (parallel [(const_int 3)]))))\n+\t ))]\n+  \"TARGET_PLUS_QMACW\"\n+  \"vsubadd4h%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+;; Multiplication\n+(define_insn \"dmpyh<V_US_suffix>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI\n+\t (mult:SI\n+\t  (SE:SI\n+\t   (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"0,r\")\n+\t\t\t  (parallel [(const_int 0)])))\n+\t  (SE:SI\n+\t   (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"r,r\")\n+\t\t\t  (parallel [(const_int 0)]))))\n+\t (mult:SI\n+\t  (SE:SI (vec_select:HI (match_dup 1) (parallel [(const_int 1)])))\n+\t  (SE:SI (vec_select:HI (match_dup 2) (parallel [(const_int 1)]))))))\n+   (set (reg:DI ARCV2_ACC)\n+\t(zero_extend:DI\n+\t (plus:SI\n+\t  (mult:SI\n+\t   (SE:SI (vec_select:HI (match_dup 1) (parallel [(const_int 0)])))\n+\t   (SE:SI (vec_select:HI (match_dup 2) (parallel [(const_int 0)]))))\n+\t  (mult:SI\n+\t   (SE:SI (vec_select:HI (match_dup 1) (parallel [(const_int 1)])))\n+\t   (SE:SI (vec_select:HI (match_dup 2) (parallel [(const_int 1)])))))))]\n+  \"TARGET_PLUS_DMPY\"\n+  \"dmpy<V_US_suffix>%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+;; We can use dmac as well here.  To be investigated which version\n+;; brings more.\n+(define_expand \"sdot_prodv2hi\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:V2HI 1 \"register_operand\" \"\")\n+   (match_operand:V2HI 2 \"register_operand\" \"\")\n+   (match_operand:SI 3 \"register_operand\" \"\")]\n+  \"TARGET_PLUS_DMPY\"\n+{\n+ rtx t = gen_reg_rtx (SImode);\n+ emit_insn (gen_dmpyh (t, operands[1], operands[2]));\n+ emit_insn (gen_addsi3 (operands[0], operands[3], t));\n+ DONE;\n+})\n+\n+(define_expand \"udot_prodv2hi\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:V2HI 1 \"register_operand\" \"\")\n+   (match_operand:V2HI 2 \"register_operand\" \"\")\n+   (match_operand:SI 3 \"register_operand\" \"\")]\n+  \"TARGET_PLUS_DMPY\"\n+{\n+ rtx t = gen_reg_rtx (SImode);\n+ emit_insn (gen_dmpyhu (t, operands[1], operands[2]));\n+ emit_insn (gen_addsi3 (operands[0], operands[3], t));\n+ DONE;\n+})\n+\n+(define_insn \"arc_vec_<V_US>mult_lo_v4hi\"\n+ [(set (match_operand:V2SI 0 \"even_register_operand\"                     \"=r,r\")\n+       (mult:V2SI (SE:V2SI (vec_select:V2HI\n+\t\t\t    (match_operand:V4HI 1 \"even_register_operand\" \"0,r\")\n+\t\t\t    (parallel [(const_int 0) (const_int 1)])))\n+\t\t  (SE:V2SI (vec_select:V2HI\n+\t\t\t    (match_operand:V4HI 2 \"even_register_operand\" \"r,r\")\n+\t\t\t    (parallel [(const_int 0) (const_int 1)])))))\n+  (set (reg:V2SI ARCV2_ACC)\n+       (mult:V2SI (SE:V2SI (vec_select:V2HI (match_dup 1)\n+\t\t\t\t\t    (parallel [(const_int 0) (const_int 1)])))\n+\t\t  (SE:V2SI (vec_select:V2HI (match_dup 2)\n+\t\t\t\t\t    (parallel [(const_int 0) (const_int 1)])))))\n+  ]\n+  \"TARGET_PLUS_MACD\"\n+  \"vmpy2h<V_US_suffix>%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"arc_vec_<V_US>multacc_lo_v4hi\"\n+  [(set (reg:V2SI ARCV2_ACC)\n+\t(mult:V2SI (SE:V2SI (vec_select:V2HI\n+\t\t\t     (match_operand:V4HI 0 \"even_register_operand\" \"r\")\n+\t\t\t     (parallel [(const_int 0) (const_int 1)])))\n+\t\t   (SE:V2SI (vec_select:V2HI\n+\t\t\t     (match_operand:V4HI 1 \"even_register_operand\" \"r\")\n+\t\t\t     (parallel [(const_int 0) (const_int 1)])))))\n+  ]\n+  \"TARGET_PLUS_MACD\"\n+  \"vmpy2h<V_US_suffix>%? 0, %0, %1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"no\")\n+   (set_attr \"cond\" \"nocond\")])\n+\n+(define_expand \"vec_widen_<V_US>mult_lo_v4hi\"\n+ [(set (match_operand:V2SI 0 \"even_register_operand\"                 \"\")\n+       (mult:V2SI (SE:V2SI (vec_select:V2HI\n+\t\t\t    (match_operand:V4HI 1 \"even_register_operand\" \"\")\n+\t\t\t    (parallel [(const_int 0) (const_int 1)])))\n+\t\t  (SE:V2SI (vec_select:V2HI\n+\t\t\t    (match_operand:V4HI 2 \"even_register_operand\" \"\")\n+\t\t\t    (parallel [(const_int 0) (const_int 1)])))))]\n+  \"TARGET_PLUS_QMACW\"\n+  {\n+     emit_insn (gen_arc_vec_<V_US>mult_lo_v4hi (operands[0],\n+\t\t\t\t\t\toperands[1],\n+\t\t\t\t\t\toperands[2]));\n+     DONE;\n+  }\n+)\n+\n+(define_insn \"arc_vec_<V_US>mult_hi_v4hi\"\n+ [(set (match_operand:V2SI 0 \"even_register_operand\"                     \"=r,r\")\n+       (mult:V2SI (SE:V2SI (vec_select:V2HI\n+\t\t\t    (match_operand:V4HI 1 \"even_register_operand\" \"0,r\")\n+\t\t\t    (parallel [(const_int 2) (const_int 3)])))\n+\t\t  (SE:V2SI (vec_select:V2HI\n+\t\t\t    (match_operand:V4HI 2 \"even_register_operand\" \"r,r\")\n+\t\t\t    (parallel [(const_int 2) (const_int 3)])))))\n+  (set (reg:V2SI ARCV2_ACC)\n+       (mult:V2SI (SE:V2SI (vec_select:V2HI (match_dup 1)\n+\t\t\t\t\t    (parallel [(const_int 2) (const_int 3)])))\n+\t\t  (SE:V2SI (vec_select:V2HI (match_dup 2)\n+\t\t\t\t\t    (parallel [(const_int 2) (const_int 3)])))))\n+  ]\n+  \"TARGET_PLUS_QMACW\"\n+  \"vmpy2h<V_US_suffix>%? %0, %R1, %R2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_expand \"vec_widen_<V_US>mult_hi_v4hi\"\n+ [(set (match_operand:V2SI 0 \"even_register_operand\"                               \"\")\n+       (mult:V2SI (SE:V2SI (vec_select:V2HI\n+\t\t\t\t     (match_operand:V4HI 1 \"even_register_operand\" \"\")\n+\t\t\t\t     (parallel [(const_int 2) (const_int 3)])))\n+\t\t  (SE:V2SI (vec_select:V2HI\n+\t\t\t\t     (match_operand:V4HI 2 \"even_register_operand\" \"\")\n+\t\t\t\t     (parallel [(const_int 2) (const_int 3)])))))]\n+  \"TARGET_PLUS_MACD\"\n+  {\n+     emit_insn (gen_arc_vec_<V_US>mult_hi_v4hi (operands[0],\n+\t\t\t\t\t\toperands[1],\n+\t\t\t\t\t\toperands[2]));\n+     DONE;\n+  }\n+)\n+\n+(define_insn \"arc_vec_<V_US>mac_hi_v4hi\"\n+ [(set (match_operand:V2SI 0 \"even_register_operand\"                     \"=r,r\")\n+       (plus:V2SI\n+\t(reg:V2SI ARCV2_ACC)\n+\t(mult:V2SI (SE:V2SI (vec_select:V2HI\n+\t\t\t     (match_operand:V4HI 1 \"even_register_operand\" \"0,r\")\n+\t\t\t     (parallel [(const_int 2) (const_int 3)])))\n+\t\t   (SE:V2SI (vec_select:V2HI\n+\t\t\t     (match_operand:V4HI 2 \"even_register_operand\" \"r,r\")\n+\t\t\t     (parallel [(const_int 2) (const_int 3)]))))))\n+  (set (reg:V2SI ARCV2_ACC)\n+       (plus:V2SI\n+\t(reg:V2SI ARCV2_ACC)\n+\t(mult:V2SI (SE:V2SI (vec_select:V2HI (match_dup 1)\n+\t\t\t\t\t     (parallel [(const_int 2) (const_int 3)])))\n+\t\t   (SE:V2SI (vec_select:V2HI (match_dup 2)\n+\t\t\t\t\t     (parallel [(const_int 2) (const_int 3)]))))))\n+  ]\n+  \"TARGET_PLUS_MACD\"\n+  \"vmac2h<V_US_suffix>%? %0, %R1, %R2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+;; Builtins\n+(define_insn \"dmach\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(unspec:SI [(match_operand:V2HI 1 \"register_operand\" \"0,r\")\n+\t\t    (match_operand:V2HI 2 \"register_operand\" \"r,r\")\n+\t\t    (reg:DI ARCV2_ACC)]\n+\t\t   UNSPEC_ARC_DMACH))\n+   (clobber (reg:DI ARCV2_ACC))]\n+  \"TARGET_PLUS_DMPY\"\n+  \"dmach%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"dmachu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(unspec:SI [(match_operand:V2HI 1 \"register_operand\" \"0,r\")\n+\t\t    (match_operand:V2HI 2 \"register_operand\" \"r,r\")\n+\t\t    (reg:DI ARCV2_ACC)]\n+\t\t   UNSPEC_ARC_DMACHU))\n+   (clobber (reg:DI ARCV2_ACC))]\n+  \"TARGET_PLUS_DMPY\"\n+  \"dmachu%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"dmacwh\"\n+  [(set (match_operand:DI 0 \"even_register_operand\" \"=r,r\")\n+\t(unspec:DI [(match_operand:V2SI 1 \"even_register_operand\" \"0,r\")\n+\t\t    (match_operand:V2HI 2 \"register_operand\"      \"r,r\")\n+\t\t    (reg:DI ARCV2_ACC)]\n+\t\t   UNSPEC_ARC_DMACWH))\n+   (clobber (reg:DI ARCV2_ACC))]\n+  \"TARGET_PLUS_QMACW\"\n+  \"dmacwh%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"dmacwhu\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(unspec:DI [(match_operand:V2SI 1 \"even_register_operand\" \"0,r\")\n+\t\t    (match_operand:V2HI 2 \"register_operand\"      \"r,r\")\n+\t\t    (reg:DI ARCV2_ACC)]\n+\t\t   UNSPEC_ARC_DMACWHU))\n+   (clobber (reg:DI ARCV2_ACC))]\n+  \"TARGET_PLUS_QMACW\"\n+  \"dmacwhu%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"vmac2h\"\n+  [(set (match_operand:V2SI 0 \"even_register_operand\" \"=r,r\")\n+\t(unspec:V2SI [(match_operand:V2HI 1 \"register_operand\" \"0,r\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"r,r\")\n+\t\t      (reg:DI ARCV2_ACC)]\n+\t\t     UNSPEC_ARC_VMAC2H))\n+   (clobber (reg:DI ARCV2_ACC))]\n+  \"TARGET_PLUS_MACD\"\n+  \"vmac2h%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"vmac2hu\"\n+  [(set (match_operand:V2SI 0 \"even_register_operand\" \"=r,r\")\n+\t(unspec:V2SI [(match_operand:V2HI 1 \"register_operand\" \"0,r\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"r,r\")\n+\t\t      (reg:DI ARCV2_ACC)]\n+\t\t   UNSPEC_ARC_VMAC2HU))\n+   (clobber (reg:DI ARCV2_ACC))]\n+  \"TARGET_PLUS_MACD\"\n+  \"vmac2hu%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"vmpy2h\"\n+  [(set (match_operand:V2SI 0 \"even_register_operand\" \"=r,r\")\n+\t(unspec:V2SI [(match_operand:V2HI 1 \"register_operand\" \"0,r\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"r,r\")]\n+\t\t     UNSPEC_ARC_VMPY2H))\n+   (clobber (reg:DI ARCV2_ACC))]\n+  \"TARGET_PLUS_MACD\"\n+  \"vmpy2h%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"vmpy2hu\"\n+  [(set (match_operand:V2SI 0 \"even_register_operand\" \"=r,r\")\n+\t(unspec:V2SI [(match_operand:V2HI 1 \"register_operand\" \"0,r\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"r,r\")]\n+\t\t     UNSPEC_ARC_VMPY2HU))\n+   (clobber (reg:DI ARCV2_ACC))]\n+  \"TARGET_PLUS_MACD\"\n+  \"vmpy2hu%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"qmach\"\n+  [(set (match_operand:DI 0 \"even_register_operand\" \"=r,r\")\n+\t(unspec:DI [(match_operand:V4HI 1 \"even_register_operand\" \"0,r\")\n+\t\t    (match_operand:V4HI 2 \"even_register_operand\" \"r,r\")\n+\t\t    (reg:DI ARCV2_ACC)]\n+\t\t     UNSPEC_ARC_QMACH))\n+   (clobber (reg:DI ARCV2_ACC))]\n+  \"TARGET_PLUS_QMACW\"\n+  \"qmach%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"qmachu\"\n+  [(set (match_operand:DI 0 \"even_register_operand\" \"=r,r\")\n+\t(unspec:DI [(match_operand:V4HI 1 \"even_register_operand\" \"0,r\")\n+\t\t    (match_operand:V4HI 2 \"even_register_operand\" \"r,r\")\n+\t\t    (reg:DI ARCV2_ACC)]\n+\t\t   UNSPEC_ARC_QMACHU))\n+   (clobber (reg:DI ARCV2_ACC))]\n+  \"TARGET_PLUS_QMACW\"\n+  \"qmachu%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"qmpyh\"\n+  [(set (match_operand:DI 0 \"even_register_operand\" \"=r,r\")\n+\t(unspec:DI [(match_operand:V4HI 1 \"even_register_operand\" \"0,r\")\n+\t\t    (match_operand:V4HI 2 \"even_register_operand\" \"r,r\")]\n+\t\t     UNSPEC_ARC_QMPYH))\n+   (clobber (reg:DI ARCV2_ACC))]\n+  \"TARGET_PLUS_QMACW\"\n+  \"qmpyh%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])\n+\n+(define_insn \"qmpyhu\"\n+  [(set (match_operand:DI 0 \"even_register_operand\" \"=r,r\")\n+\t(unspec:DI [(match_operand:V4HI 1 \"even_register_operand\" \"0,r\")\n+\t\t    (match_operand:V4HI 2 \"even_register_operand\" \"r,r\")]\n+\t\t   UNSPEC_ARC_QMPYHU))\n+   (clobber (reg:DI ARCV2_ACC))]\n+  \"TARGET_PLUS_QMACW\"\n+  \"qmpyhu%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")])"}, {"sha": "68aae40ca58e99f3d2faed72ad6154c89e5d363c", "filename": "gcc/testsuite/gcc.target/arc/builtin_simdarc.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c072ae51c132e346eab0c6f8c176542efbcd5a/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_simdarc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c072ae51c132e346eab0c6f8c176542efbcd5a/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_simdarc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_simdarc.c?ref=00c072ae51c132e346eab0c6f8c176542efbcd5a", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=archs -O2 -Werror-implicit-function-declaration -mmpy-option=9\" } */\n+\n+#define STEST(name, rettype, op1type, op2type)\t\\\n+  rettype test_ ## name\t\t\t\t\\\n+  (op1type a, op2type b)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return __builtin_arc_ ## name (a, b);\t\\\n+  }\n+\n+typedef short v2hi __attribute__ ((vector_size (4)));\n+typedef short v4hi __attribute__ ((vector_size (8)));\n+typedef int   v2si __attribute__ ((vector_size (8)));\n+\n+STEST (qmach,  long long, v4hi, v4hi)\n+STEST (qmachu, long long, v4hi, v4hi)\n+STEST (qmpyh,  long long, v4hi, v4hi)\n+STEST (qmpyhu, long long, v4hi, v4hi)\n+\n+STEST (dmach,  int, v2hi, v2hi)\n+STEST (dmachu, int, v2hi, v2hi)\n+STEST (dmpyh,  int, v2hi, v2hi)\n+STEST (dmpyhu, int, v2hi, v2hi)\n+\n+STEST (dmacwh,  long, v2si, v2hi)\n+STEST (dmacwhu, long, v2si, v2hi)\n+\n+STEST (vmac2h,  v2si, v2hi, v2hi)\n+STEST (vmac2hu, v2si, v2hi, v2hi)\n+STEST (vmpy2h,  v2si, v2hi, v2hi)\n+STEST (vmpy2hu, v2si, v2hi, v2hi)\n+\n+STEST (vaddsub2h, v2hi, v2hi, v2hi)\n+STEST (vsubadd2h, v2hi, v2hi, v2hi)\n+STEST (vaddsub,   v2si, v2si, v2si)\n+STEST (vsubadd,   v2si, v2si, v2si)\n+STEST (vaddsub4h, v4hi, v4hi, v4hi)\n+STEST (vsubadd4h, v4hi, v4hi, v4hi)"}]}