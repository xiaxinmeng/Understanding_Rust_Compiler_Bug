{"sha": "642a35f1b4db429d4f5c00e0af47cab74f112274", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQyYTM1ZjFiNGRiNDI5ZDRmNWMwMGUwYWY0N2NhYjc0ZjExMjI3NA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-08-27T17:16:17Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-08-27T17:16:17Z"}, "message": "(TARGET_MINIMAL_TOC): New macro.\n\n(TARGET_SWITCHES): Add -mminimal-toc and -mno-minimal-toc.\n(ELIMINABLE_REGS): Add elimination for r30.\n(CAN_ELIMINATE): Add case for r30.\n(INITIAL_ELIMINATION_OFFSET): Add case for r30.\n(toc_section): When TARET_MINIMAL_TOC, initialize toc_table.\n\nFrom-SVN: r5219", "tree": {"sha": "0b34c8b9e140499373e04fb3465c8b213434cd71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b34c8b9e140499373e04fb3465c8b213434cd71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/642a35f1b4db429d4f5c00e0af47cab74f112274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642a35f1b4db429d4f5c00e0af47cab74f112274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/642a35f1b4db429d4f5c00e0af47cab74f112274", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642a35f1b4db429d4f5c00e0af47cab74f112274/comments", "author": null, "committer": null, "parents": [{"sha": "1875cc885952eed1ba9d7a7a12883d2f230573fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1875cc885952eed1ba9d7a7a12883d2f230573fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1875cc885952eed1ba9d7a7a12883d2f230573fe"}], "stats": {"total": 53, "additions": 48, "deletions": 5}, "files": [{"sha": "a7c6b1595be27a80d822e6b7831cce07613a4f93", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642a35f1b4db429d4f5c00e0af47cab74f112274/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642a35f1b4db429d4f5c00e0af47cab74f112274/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=642a35f1b4db429d4f5c00e0af47cab74f112274", "patch": "@@ -70,6 +70,16 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define TARGET_FP_IN_TOC  (target_flags & 1)\n \n+/* Flag to output only one TOC entry per module.  Normally linking fails if\n+   there are more than 16K unique variables/constants in an executable.  With\n+   this option, linking fails only if there are more than 16K modules, or\n+   if there are more than 16K unique variables/constant in a single module.\n+\n+   This is at the cost of having 2 extra loads and one extra store per\n+   function, and one less allocatable register.  */\n+\n+#define TARGET_MINIMAL_TOC (target_flags & 2)\n+\n extern int target_flags;\n \n /* Macro to define tables used to set the flags.\n@@ -81,6 +91,8 @@ extern int target_flags;\n #define TARGET_SWITCHES\t\t\\\n   {{\"fp-in-toc\", 1},\t\t\\\n    {\"no-fp-in-toc\", -1},\t\\\n+   {\"minimal-toc\", 2},\t\t\\\n+   {\"no-minimal-toc\", -2},\t\\\n    { \"\", TARGET_DEFAULT}}\n \n #define TARGET_DEFAULT 1\n@@ -884,7 +896,12 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n    We have two registers that can be eliminated on the RS/6000.  First, the\n    frame pointer register can often be eliminated in favor of the stack\n    pointer register.  Secondly, the argument pointer register can always be\n-   eliminated; it is replaced with either the stack or frame pointer.  */\n+   eliminated; it is replaced with either the stack or frame pointer.\n+\n+   In addition, we use the elimination mechanism to see if r30 is needed\n+   Initially we assume that it isn't.  If it is, we spill it.  This is done\n+   by making it an eliminable register.  We replace it with itself so that\n+   if it isn't needed, then existing uses won't be modified.  */\n \n /* This is an array of structures.  Each structure initializes one pair\n    of eliminable registers.  The \"from\" register number is given first,\n@@ -893,17 +910,22 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n #define ELIMINABLE_REGS\t\t\t\t\\\n {{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n  { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n- { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM} }\n+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n+ { 30, 30} }\n \n /* Given FROM and TO register numbers, say whether this elimination is allowed.\n    Frame pointer elimination is automatically handled.\n \n    For the RS/6000, if frame pointer elimination is being done, we would like\n-   to convert ap into fp, not sp.  */\n+   to convert ap into fp, not sp.\n+\n+   We need r30 if -mmininal-toc was specified, and there are constant pool\n+   references.  */\n \n #define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n  ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\\\n   ? ! frame_pointer_needed\t\t\t\t\t\\\n+  : (FROM) == 30 ? ! TARGET_MINIMAL_TOC || get_pool_size () == 0 \\\n   : 1)\n \n /* Define the offset between two registers, one to be eliminated, and the other\n@@ -931,6 +953,8 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n       else\t\t\t\t\t\t\t\t\\\n \t(OFFSET) = 0;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+  else if ((FROM) == 30)\t\t\t\t\t\t\\\n+    (OFFSET) = 0;\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     abort ();\t\t\t\t\t\t\t\t\\\n }\n@@ -1465,9 +1489,28 @@ read_only_private_data_section ()\t\t\t\\\n void\t\t\t\t\t\t\t\\\n toc_section ()\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n-  if (in_section != toc)\t\t\t\t\\\n-    fprintf (asm_out_file, \".toc\\n\");\t\t\t\\\n+  if (TARGET_MINIMAL_TOC)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      static int toc_initialized = 0;\t\t\t\\\n \t\t\t\t\t\t\t\\\n+      /* toc_section is always called at least once from ASM_FILE_START, \\\n+\t so this is guaranteed to always be defined once and only once   \\\n+\t in each file.  */\t\t\t\t\t\t \\\n+      if (! toc_initialized)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  fprintf (asm_out_file, \".toc\\nLCTOC..0:\\n\");\t\\\n+\t  fprintf (asm_out_file, \"\\t.tc toc_table[TC],toc_table[RW]\\n\"); \\\n+\t  toc_initialized = 1;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      if (in_section != toc)\t\t\t\t\\\n+\tfprintf (asm_out_file, \".csect toc_table[RW]\\n\"); \\\n+    }\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (in_section != toc)\t\t\t\t\\\n+        fprintf (asm_out_file, \".toc\\n\");\t\t\\\n+    }\t\t\t\t\t\t\t\\\n   in_section = toc;\t\t\t\t\t\\\n }\n "}]}