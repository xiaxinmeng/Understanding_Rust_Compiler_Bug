{"sha": "6f966f06146be7689af471d152e18ff50c609d99", "node_id": "C_kwDOANBUbNoAKDZmOTY2ZjA2MTQ2YmU3Njg5YWY0NzFkMTUyZTE4ZmY1MGM2MDlkOTk", "commit": {"author": {"name": "Stefan Schulze Frielinghaus", "email": "stefansf@linux.ibm.com", "date": "2021-10-11T07:59:13Z"}, "committer": {"name": "Stefan Schulze Frielinghaus", "email": "stefansf@linux.ibm.com", "date": "2021-10-11T07:59:13Z"}, "message": "ldist: Recognize strlen and rawmemchr like loops\n\nThis patch adds support for recognizing loops which mimic the behaviour\nof functions strlen and rawmemchr, and replaces those with internal\nfunction calls in case a target provides them.  In contrast to the\nstandard strlen and rawmemchr functions, this patch also supports\ndifferent instances where the memory pointed to is interpreted as 8, 16,\nand 32-bit sized, respectively.\n\ngcc/ChangeLog:\n\n\t* builtins.c (get_memory_rtx): Change to external linkage.\n\t* builtins.h (get_memory_rtx): Add function prototype.\n\t* doc/md.texi (rawmemchr<mode>): Document.\n\t* internal-fn.c (expand_RAWMEMCHR): Define.\n\t* internal-fn.def (RAWMEMCHR): Add.\n\t* optabs.def (rawmemchr_optab): Add.\n\t* tree-loop-distribution.c (find_single_drs): Change return code\n\tbehaviour by also returning true if no single store was found\n\tbut a single load.\n\t(loop_distribution::classify_partition): Respect the new return\n\tcode behaviour of function find_single_drs.\n\t(loop_distribution::execute): Call new function\n\ttransform_reduction_loop in order to replace rawmemchr or strlen\n\tlike loops by calls into builtins.\n\t(generate_reduction_builtin_1): New function.\n\t(generate_rawmemchr_builtin): New function.\n\t(generate_strlen_builtin_1): New function.\n\t(generate_strlen_builtin): New function.\n\t(generate_strlen_builtin_using_rawmemchr): New function.\n\t(reduction_var_overflows_first): New function.\n\t(determine_reduction_stmt_1): New function.\n\t(determine_reduction_stmt): New function.\n\t(loop_distribution::transform_reduction_loop): New function.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/ldist-rawmemchr-1.c: New test.\n\t* gcc.dg/tree-ssa/ldist-rawmemchr-2.c: New test.\n\t* gcc.dg/tree-ssa/ldist-strlen-1.c: New test.\n\t* gcc.dg/tree-ssa/ldist-strlen-2.c: New test.\n\t* gcc.dg/tree-ssa/ldist-strlen-3.c: New test.", "tree": {"sha": "72af686fdc3b931398a2f5837d57d2a364616302", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72af686fdc3b931398a2f5837d57d2a364616302"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f966f06146be7689af471d152e18ff50c609d99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f966f06146be7689af471d152e18ff50c609d99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f966f06146be7689af471d152e18ff50c609d99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f966f06146be7689af471d152e18ff50c609d99/comments", "author": {"login": "stefan-sf-ibm", "id": 73470131, "node_id": "MDQ6VXNlcjczNDcwMTMx", "avatar_url": "https://avatars.githubusercontent.com/u/73470131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stefan-sf-ibm", "html_url": "https://github.com/stefan-sf-ibm", "followers_url": "https://api.github.com/users/stefan-sf-ibm/followers", "following_url": "https://api.github.com/users/stefan-sf-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/stefan-sf-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/stefan-sf-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stefan-sf-ibm/subscriptions", "organizations_url": "https://api.github.com/users/stefan-sf-ibm/orgs", "repos_url": "https://api.github.com/users/stefan-sf-ibm/repos", "events_url": "https://api.github.com/users/stefan-sf-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/stefan-sf-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stefan-sf-ibm", "id": 73470131, "node_id": "MDQ6VXNlcjczNDcwMTMx", "avatar_url": "https://avatars.githubusercontent.com/u/73470131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stefan-sf-ibm", "html_url": "https://github.com/stefan-sf-ibm", "followers_url": "https://api.github.com/users/stefan-sf-ibm/followers", "following_url": "https://api.github.com/users/stefan-sf-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/stefan-sf-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/stefan-sf-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stefan-sf-ibm/subscriptions", "organizations_url": "https://api.github.com/users/stefan-sf-ibm/orgs", "repos_url": "https://api.github.com/users/stefan-sf-ibm/repos", "events_url": "https://api.github.com/users/stefan-sf-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/stefan-sf-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9abf8c9534144fe9b4948a3104655983821ca7a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abf8c9534144fe9b4948a3104655983821ca7a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9abf8c9534144fe9b4948a3104655983821ca7a1"}], "stats": {"total": 886, "additions": 855, "deletions": 31}, "files": [{"sha": "f1c3fea3583d3cb59e225d7efac54c515d471c04", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6f966f06146be7689af471d152e18ff50c609d99", "patch": "@@ -105,7 +105,6 @@ builtin_info_type builtin_info[(int)END_BUILTINS];\n bool force_folding_builtin_constant_p;\n \n static int target_char_cast (tree, char *);\n-static rtx get_memory_rtx (tree, tree);\n static int apply_args_size (void);\n static int apply_result_size (void);\n static rtx result_vector (int, rtx);\n@@ -1355,7 +1354,7 @@ expand_builtin_prefetch (tree exp)\n    the maximum length of the block of memory that might be accessed or\n    NULL if unknown.  */\n \n-static rtx\n+rtx\n get_memory_rtx (tree exp, tree len)\n {\n   tree orig_exp = exp;"}, {"sha": "5e4d86e9c37b06f3f2208e9a25de9cdc4fd61685", "filename": "gcc/builtins.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=6f966f06146be7689af471d152e18ff50c609d99", "patch": "@@ -146,6 +146,7 @@ extern char target_percent_s[3];\n extern char target_percent_c[3];\n extern char target_percent_s_newline[4];\n extern bool target_char_cst_p (tree t, char *p);\n+extern rtx get_memory_rtx (tree exp, tree len);\n \n extern internal_fn associated_internal_fn (tree);\n extern internal_fn replacement_internal_fn (gcall *);"}, {"sha": "41f1850bf6e95005647ca97a495a97d7e184d137", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=6f966f06146be7689af471d152e18ff50c609d99", "patch": "@@ -6697,6 +6697,13 @@ operand 2 is the character to search for (normally zero),\n and operand 3 is a constant describing the known alignment\n of the beginning of the string.\n \n+@cindex @code{rawmemchr@var{m}} instruction pattern\n+@item @samp{rawmemchr@var{m}}\n+Scan memory referred to by operand 1 for the first occurrence of operand 2.\n+Operand 1 is a @code{mem} and operand 2 a @code{const_int} of mode @var{m}.\n+Operand 0 is the result, i.e., a pointer to the first occurrence of operand 2\n+in the memory block given by operand 1.\n+\n @cindex @code{float@var{m}@var{n}2} instruction pattern\n @item @samp{float@var{m}@var{n}2}\n Convert signed integer operand 1 (valid for fixed point mode @var{m}) to"}, {"sha": "6bc256832f7ddd82e7f4e1b388dd55566e50de02", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=6f966f06146be7689af471d152e18ff50c609d99", "patch": "@@ -2934,6 +2934,36 @@ expand_VEC_CONVERT (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* Expand IFN_RAWMEMCHAR internal function.  */\n+\n+void\n+expand_RAWMEMCHR (internal_fn, gcall *stmt)\n+{\n+  expand_operand ops[3];\n+\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+  machine_mode lhs_mode = TYPE_MODE (TREE_TYPE (lhs));\n+  rtx lhs_rtx = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  create_output_operand (&ops[0], lhs_rtx, lhs_mode);\n+\n+  tree mem = gimple_call_arg (stmt, 0);\n+  rtx mem_rtx = get_memory_rtx (mem, NULL);\n+  create_fixed_operand (&ops[1], mem_rtx);\n+\n+  tree pattern = gimple_call_arg (stmt, 1);\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (pattern));\n+  rtx pattern_rtx = expand_normal (pattern);\n+  create_input_operand (&ops[2], pattern_rtx, mode);\n+\n+  insn_code icode = direct_optab_handler (rawmemchr_optab, mode);\n+\n+  expand_insn (icode, 3, ops);\n+  if (!rtx_equal_p (lhs_rtx, ops[0].value))\n+    emit_move_insn (lhs_rtx, ops[0].value);\n+}\n+\n /* Expand the IFN_UNIQUE function according to its first argument.  */\n \n static void"}, {"sha": "01f60a6cf260b5b6b26f0661b451c43277c90b20", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=6f966f06146be7689af471d152e18ff50c609d99", "patch": "@@ -352,6 +352,7 @@ DEF_INTERNAL_FN (MUL_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (TSAN_FUNC_EXIT, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (VA_ARG, ECF_NOTHROW | ECF_LEAF, NULL)\n DEF_INTERNAL_FN (VEC_CONVERT, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (RAWMEMCHR, ECF_PURE | ECF_LEAF | ECF_NOTHROW, NULL)\n \n /* An unduplicable, uncombinable function.  Generally used to preserve\n    a CFG property in the face of jump threading, tail merging or"}, {"sha": "f02c7b729a51595884876cc8ff46113f6054af55", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=6f966f06146be7689af471d152e18ff50c609d99", "patch": "@@ -267,6 +267,7 @@ OPTAB_D (cpymem_optab, \"cpymem$a\")\n OPTAB_D (movmem_optab, \"movmem$a\")\n OPTAB_D (setmem_optab, \"setmem$a\")\n OPTAB_D (strlen_optab, \"strlen$a\")\n+OPTAB_D (rawmemchr_optab, \"rawmemchr$a\")\n \n OPTAB_DC(fma_optab, \"fma$a4\", FMA)\n OPTAB_D (fms_optab, \"fms$a4\")"}, {"sha": "6abfd27835159e4c726132f9f4e6685a4337090f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-rawmemchr-1.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-rawmemchr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-rawmemchr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-rawmemchr-1.c?ref=6f966f06146be7689af471d152e18ff50c609d99", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do run { target s390x-*-* } } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-details\" } */\n+/* { dg-final { scan-tree-dump-times \"generated rawmemchrQI\" 2 \"ldist\" { target s390x-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"generated rawmemchrHI\" 2 \"ldist\" { target s390x-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"generated rawmemchrSI\" 2 \"ldist\" { target s390x-*-* } } } */\n+\n+/* Rawmemchr pattern: reduction stmt and no store */\n+\n+#include <stdint.h>\n+#include <assert.h>\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void* malloc (size_t);\n+extern void* memset (void*, int, size_t);\n+\n+#define test(T, pattern)   \\\n+__attribute__((noinline))  \\\n+T *test_##T (T *p)         \\\n+{                          \\\n+  while (*p != (T)pattern) \\\n+    ++p;                   \\\n+  return p;                \\\n+}\n+\n+test (uint8_t,  0xab)\n+test (uint16_t, 0xabcd)\n+test (uint32_t, 0xabcdef15)\n+\n+test (int8_t,  0xab)\n+test (int16_t, 0xabcd)\n+test (int32_t, 0xabcdef15)\n+\n+#define run(T, pattern, i)      \\\n+{                               \\\n+T *q = p;                       \\\n+q[i] = (T)pattern;              \\\n+assert (test_##T (p) == &q[i]); \\\n+q[i] = 0;                       \\\n+}\n+\n+int main(void)\n+{\n+  void *p = malloc (1024);\n+  assert (p);\n+  memset (p, 0, 1024);\n+\n+  run (uint8_t, 0xab, 0);\n+  run (uint8_t, 0xab, 1);\n+  run (uint8_t, 0xab, 13);\n+\n+  run (uint16_t, 0xabcd, 0);\n+  run (uint16_t, 0xabcd, 1);\n+  run (uint16_t, 0xabcd, 13);\n+\n+  run (uint32_t, 0xabcdef15, 0);\n+  run (uint32_t, 0xabcdef15, 1);\n+  run (uint32_t, 0xabcdef15, 13);\n+\n+  run (int8_t, 0xab, 0);\n+  run (int8_t, 0xab, 1);\n+  run (int8_t, 0xab, 13);\n+\n+  run (int16_t, 0xabcd, 0);\n+  run (int16_t, 0xabcd, 1);\n+  run (int16_t, 0xabcd, 13);\n+\n+  run (int32_t, 0xabcdef15, 0);\n+  run (int32_t, 0xabcdef15, 1);\n+  run (int32_t, 0xabcdef15, 13);\n+\n+  return 0;\n+}"}, {"sha": "00d6ea0f8e9f83646dd0e9f8d68845fc1ad2d265", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-rawmemchr-2.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-rawmemchr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-rawmemchr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-rawmemchr-2.c?ref=6f966f06146be7689af471d152e18ff50c609d99", "patch": "@@ -0,0 +1,83 @@\n+/* { dg-do run { target s390x-*-* } } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-details\" } */\n+/* { dg-final { scan-tree-dump-times \"generated rawmemchrQI\" 2 \"ldist\" { target s390x-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"generated rawmemchrHI\" 2 \"ldist\" { target s390x-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"generated rawmemchrSI\" 2 \"ldist\" { target s390x-*-* } } } */\n+\n+/* Rawmemchr pattern: reduction stmt and store */\n+\n+#include <stdint.h>\n+#include <assert.h>\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void* malloc (size_t);\n+extern void* memset (void*, int, size_t);\n+\n+uint8_t *p_uint8_t;\n+uint16_t *p_uint16_t;\n+uint32_t *p_uint32_t;\n+\n+int8_t *p_int8_t;\n+int16_t *p_int16_t;\n+int32_t *p_int32_t;\n+\n+#define test(T, pattern)    \\\n+__attribute__((noinline))   \\\n+T *test_##T (void)          \\\n+{                           \\\n+  while (*p_##T != pattern) \\\n+    ++p_##T;                \\\n+  return p_##T;             \\\n+}\n+\n+test (uint8_t,  0xab)\n+test (uint16_t, 0xabcd)\n+test (uint32_t, 0xabcdef15)\n+\n+test (int8_t,  (int8_t)0xab)\n+test (int16_t, (int16_t)0xabcd)\n+test (int32_t, (int32_t)0xabcdef15)\n+\n+#define run(T, pattern, i) \\\n+{                          \\\n+T *q = p;                  \\\n+q[i] = pattern;            \\\n+p_##T = p;                 \\\n+T *r = test_##T ();        \\\n+assert (r == p_##T);       \\\n+assert (r == &q[i]);       \\\n+q[i] = 0;                  \\\n+}\n+\n+int main(void)\n+{\n+  void *p = malloc (1024);\n+  assert (p);\n+  memset (p, '\\0', 1024);\n+\n+  run (uint8_t, 0xab, 0);\n+  run (uint8_t, 0xab, 1);\n+  run (uint8_t, 0xab, 13);\n+\n+  run (uint16_t, 0xabcd, 0);\n+  run (uint16_t, 0xabcd, 1);\n+  run (uint16_t, 0xabcd, 13);\n+\n+  run (uint32_t, 0xabcdef15, 0);\n+  run (uint32_t, 0xabcdef15, 1);\n+  run (uint32_t, 0xabcdef15, 13);\n+\n+  run (int8_t, (int8_t)0xab, 0);\n+  run (int8_t, (int8_t)0xab, 1);\n+  run (int8_t, (int8_t)0xab, 13);\n+\n+  run (int16_t, (int16_t)0xabcd, 0);\n+  run (int16_t, (int16_t)0xabcd, 1);\n+  run (int16_t, (int16_t)0xabcd, 13);\n+\n+  run (int32_t, (int32_t)0xabcdef15, 0);\n+  run (int32_t, (int32_t)0xabcdef15, 1);\n+  run (int32_t, (int32_t)0xabcdef15, 13);\n+\n+  return 0;\n+}"}, {"sha": "918b60099e429fa5e2e4439a8310ba302fd6f08f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-strlen-1.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-strlen-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-strlen-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-strlen-1.c?ref=6f966f06146be7689af471d152e18ff50c609d99", "patch": "@@ -0,0 +1,100 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-details\" } */\n+/* { dg-final { scan-tree-dump-times \"generated strlenQI\\n\" 4 \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"generated strlenHI\\n\" 4 \"ldist\" { target s390x-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"generated strlenSI\\n\" 4 \"ldist\" { target s390x-*-* } } } */\n+\n+#include <stdint.h>\n+#include <assert.h>\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void* malloc (size_t);\n+extern void* memset (void*, int, size_t);\n+\n+#define test(T, U)        \\\n+__attribute__((noinline)) \\\n+U test_##T##U (T *s)      \\\n+{                         \\\n+  U i;                    \\\n+  for (i=0; s[i]; ++i);   \\\n+  return i;               \\\n+}\n+\n+test (uint8_t,  size_t)\n+test (uint16_t, size_t)\n+test (uint32_t, size_t)\n+test (uint8_t,  int)\n+test (uint16_t, int)\n+test (uint32_t, int)\n+\n+test (int8_t,  size_t)\n+test (int16_t, size_t)\n+test (int32_t, size_t)\n+test (int8_t,  int)\n+test (int16_t, int)\n+test (int32_t, int)\n+\n+#define run(T, U, i)             \\\n+{                                \\\n+T *q = p;                        \\\n+q[i] = 0;                        \\\n+assert (test_##T##U (p) == i);   \\\n+memset (&q[i], 0xf, sizeof (T)); \\\n+}\n+\n+int main(void)\n+{\n+  void *p = malloc (1024);\n+  assert (p);\n+  memset (p, 0xf, 1024);\n+\n+  run (uint8_t, size_t, 0);\n+  run (uint8_t, size_t, 1);\n+  run (uint8_t, size_t, 13);\n+\n+  run (int8_t, size_t, 0);\n+  run (int8_t, size_t, 1);\n+  run (int8_t, size_t, 13);\n+\n+  run (uint8_t, int, 0);\n+  run (uint8_t, int, 1);\n+  run (uint8_t, int, 13);\n+\n+  run (int8_t, int, 0);\n+  run (int8_t, int, 1);\n+  run (int8_t, int, 13);\n+\n+  run (uint16_t, size_t, 0);\n+  run (uint16_t, size_t, 1);\n+  run (uint16_t, size_t, 13);\n+\n+  run (int16_t, size_t, 0);\n+  run (int16_t, size_t, 1);\n+  run (int16_t, size_t, 13);\n+\n+  run (uint16_t, int, 0);\n+  run (uint16_t, int, 1);\n+  run (uint16_t, int, 13);\n+\n+  run (int16_t, int, 0);\n+  run (int16_t, int, 1);\n+  run (int16_t, int, 13);\n+\n+  run (uint32_t, size_t, 0);\n+  run (uint32_t, size_t, 1);\n+  run (uint32_t, size_t, 13);\n+\n+  run (int32_t, size_t, 0);\n+  run (int32_t, size_t, 1);\n+  run (int32_t, size_t, 13);\n+\n+  run (uint32_t, int, 0);\n+  run (uint32_t, int, 1);\n+  run (uint32_t, int, 13);\n+\n+  run (int32_t, int, 0);\n+  run (int32_t, int, 1);\n+  run (int32_t, int, 13);\n+\n+  return 0;\n+}"}, {"sha": "e25d6ea5b568ea83ffd2ce86e7d3098a26a75ac3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-strlen-2.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-strlen-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-strlen-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-strlen-2.c?ref=6f966f06146be7689af471d152e18ff50c609d99", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-details\" } */\n+/* { dg-final { scan-tree-dump-times \"generated strlenQI\\n\" 3 \"ldist\" } } */\n+\n+#include <assert.h>\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void* malloc (size_t);\n+extern void* memset (void*, int, size_t);\n+\n+__attribute__((noinline))\n+int test_pos (char *s)\n+{\n+  int i;\n+  for (i=42; s[i]; ++i);\n+  return i;\n+}\n+\n+__attribute__((noinline))\n+int test_neg (char *s)\n+{\n+  int i;\n+  for (i=-42; s[i]; ++i);\n+  return i;\n+}\n+\n+__attribute__((noinline))\n+int test_including_null_char (char *s)\n+{\n+  int i;\n+  for (i=1; s[i-1]; ++i);\n+  return i;\n+}\n+\n+int main(void)\n+{\n+  void *p = malloc (1024);\n+  assert (p);\n+  memset (p, 0xf, 1024);\n+  char *s = (char *)p + 100;\n+\n+  s[42+13] = 0;\n+  assert (test_pos (s) == 42+13);\n+  s[42+13] = 0xf;\n+\n+  s[13] = 0;\n+  assert (test_neg (s) == 13);\n+  s[13] = 0xf;\n+\n+  s[-13] = 0;\n+  assert (test_neg (s) == -13);\n+  s[-13] = 0xf;\n+\n+  s[13] = 0;\n+  assert (test_including_null_char (s) == 13+1);\n+\n+  return 0;\n+}"}, {"sha": "370fd5eb08899085bd029e50b8a6bbb0dbebb79f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-strlen-3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-strlen-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-strlen-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-strlen-3.c?ref=6f966f06146be7689af471d152e18ff50c609d99", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-details\" } */\n+/* { dg-final { scan-tree-dump-times \"generated strlenSI\\n\" 1 \"ldist\" { target s390x-*-* } } } */\n+\n+extern int s[];\n+\n+int test ()\n+{\n+  int i = 0;\n+  for (; s[i]; ++i);\n+  return i;\n+}"}, {"sha": "fb9250031b558b35388ee9388deb2b1463fa896b", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 489, "deletions": 29, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f966f06146be7689af471d152e18ff50c609d99/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=6f966f06146be7689af471d152e18ff50c609d99", "patch": "@@ -116,6 +116,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-eh.h\"\n #include \"gimple-fold.h\"\n #include \"tree-affine.h\"\n+#include \"intl.h\"\n+#include \"rtl.h\"\n+#include \"memmodel.h\"\n+#include \"optabs.h\"\n \n \n #define MAX_DATAREFS_NUM \\\n@@ -651,6 +655,10 @@ class loop_distribution\n \t\t       control_dependences *cd, int *nb_calls, bool *destroy_p,\n \t\t       bool only_patterns_p);\n \n+  /* Transform loops which mimic the effects of builtins rawmemchr or strlen and\n+     replace them accordingly.  */\n+  bool transform_reduction_loop (loop_p loop);\n+\n   /* Compute topological order for basic blocks.  Topological order is\n      needed because data dependence is computed for data references in\n      lexicographical order.  */\n@@ -1492,14 +1500,14 @@ loop_distribution::build_rdg_partition_for_vertex (struct graph *rdg, int v)\n    data references.  */\n \n static bool\n-find_single_drs (class loop *loop, struct graph *rdg, partition *partition,\n+find_single_drs (class loop *loop, struct graph *rdg, const bitmap &partition_stmts,\n \t\t data_reference_p *dst_dr, data_reference_p *src_dr)\n {\n   unsigned i;\n   data_reference_p single_ld = NULL, single_st = NULL;\n   bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP (partition->stmts, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (partition_stmts, 0, i, bi)\n     {\n       gimple *stmt = RDG_STMT (rdg, i);\n       data_reference_p dr;\n@@ -1540,44 +1548,47 @@ find_single_drs (class loop *loop, struct graph *rdg, partition *partition,\n \t}\n     }\n \n-  if (!single_st)\n-    return false;\n-\n-  /* Bail out if this is a bitfield memory reference.  */\n-  if (TREE_CODE (DR_REF (single_st)) == COMPONENT_REF\n-      && DECL_BIT_FIELD (TREE_OPERAND (DR_REF (single_st), 1)))\n+  if (!single_ld && !single_st)\n     return false;\n \n-  /* Data reference must be executed exactly once per iteration of each\n-     loop in the loop nest.  We only need to check dominance information\n-     against the outermost one in a perfect loop nest because a bb can't\n-     dominate outermost loop's latch without dominating inner loop's.  */\n-  basic_block bb_st = gimple_bb (DR_STMT (single_st));\n-  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb_st))\n-    return false;\n+  basic_block bb_ld = NULL;\n+  basic_block bb_st = NULL;\n \n   if (single_ld)\n     {\n-      gimple *store = DR_STMT (single_st), *load = DR_STMT (single_ld);\n-      /* Direct aggregate copy or via an SSA name temporary.  */\n-      if (load != store\n-\t  && gimple_assign_lhs (load) != gimple_assign_rhs1 (store))\n-\treturn false;\n-\n       /* Bail out if this is a bitfield memory reference.  */\n       if (TREE_CODE (DR_REF (single_ld)) == COMPONENT_REF\n \t  && DECL_BIT_FIELD (TREE_OPERAND (DR_REF (single_ld), 1)))\n \treturn false;\n \n-      /* Load and store must be in the same loop nest.  */\n-      basic_block bb_ld = gimple_bb (DR_STMT (single_ld));\n-      if (bb_st->loop_father != bb_ld->loop_father)\n+      /* Data reference must be executed exactly once per iteration of each\n+\t loop in the loop nest.  We only need to check dominance information\n+\t against the outermost one in a perfect loop nest because a bb can't\n+\t dominate outermost loop's latch without dominating inner loop's.  */\n+      bb_ld = gimple_bb (DR_STMT (single_ld));\n+      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb_ld))\n+\treturn false;\n+    }\n+\n+  if (single_st)\n+    {\n+      /* Bail out if this is a bitfield memory reference.  */\n+      if (TREE_CODE (DR_REF (single_st)) == COMPONENT_REF\n+\t  && DECL_BIT_FIELD (TREE_OPERAND (DR_REF (single_st), 1)))\n \treturn false;\n \n       /* Data reference must be executed exactly once per iteration.\n-\t Same as single_st, we only need to check against the outermost\n+\t Same as single_ld, we only need to check against the outermost\n \t loop.  */\n-      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb_ld))\n+      bb_st = gimple_bb (DR_STMT (single_st));\n+      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb_st))\n+\treturn false;\n+    }\n+\n+  if (single_ld && single_st)\n+    {\n+      /* Load and store must be in the same loop nest.  */\n+      if (bb_st->loop_father != bb_ld->loop_father)\n \treturn false;\n \n       edge e = single_exit (bb_st->loop_father);\n@@ -1852,9 +1863,19 @@ loop_distribution::classify_partition (loop_p loop,\n     return has_reduction;\n \n   /* Find single load/store data references for builtin partition.  */\n-  if (!find_single_drs (loop, rdg, partition, &single_st, &single_ld))\n+  if (!find_single_drs (loop, rdg, partition->stmts, &single_st, &single_ld)\n+      || !single_st)\n     return has_reduction;\n \n+  if (single_ld && single_st)\n+    {\n+      gimple *store = DR_STMT (single_st), *load = DR_STMT (single_ld);\n+      /* Direct aggregate copy or via an SSA name temporary.  */\n+      if (load != store\n+\t  && gimple_assign_lhs (load) != gimple_assign_rhs1 (store))\n+\treturn has_reduction;\n+    }\n+\n   partition->loc = gimple_location (DR_STMT (single_st));\n \n   /* Classify the builtin kind.  */\n@@ -3260,6 +3281,428 @@ find_seed_stmts_for_distribution (class loop *loop, vec<gimple *> *work_list)\n   return work_list->length () > 0;\n }\n \n+/* A helper function for generate_{rawmemchr,strlen}_builtin functions in order\n+   to place new statements SEQ before LOOP and replace the old reduction\n+   variable with the new one.  */\n+\n+static void\n+generate_reduction_builtin_1 (loop_p loop, gimple_seq &seq,\n+\t\t\t      tree reduction_var_old, tree reduction_var_new,\n+\t\t\t      const char *info, machine_mode load_mode)\n+{\n+  /* Place new statements before LOOP.  */\n+  gimple_stmt_iterator gsi = gsi_last_bb (loop_preheader_edge (loop)->src);\n+  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n+\n+  /* Replace old reduction variable with new one.  */\n+  imm_use_iterator iter;\n+  gimple *stmt;\n+  use_operand_p use_p;\n+  FOR_EACH_IMM_USE_STMT (stmt, iter, reduction_var_old)\n+    {\n+      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\tSET_USE (use_p, reduction_var_new);\n+\n+      update_stmt (stmt);\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, info, GET_MODE_NAME (load_mode));\n+}\n+\n+/* Generate a call to rawmemchr and place it before LOOP.  REDUCTION_VAR is\n+   replaced with a fresh SSA name representing the result of the call.  */\n+\n+static void\n+generate_rawmemchr_builtin (loop_p loop, tree reduction_var,\n+\t\t\t    data_reference_p store_dr, tree base, tree pattern,\n+\t\t\t    location_t loc)\n+{\n+  gimple_seq seq = NULL;\n+\n+  tree mem = force_gimple_operand (base, &seq, true, NULL_TREE);\n+  gimple *fn_call = gimple_build_call_internal (IFN_RAWMEMCHR, 2, mem, pattern);\n+  tree reduction_var_new = copy_ssa_name (reduction_var);\n+  gimple_call_set_lhs (fn_call, reduction_var_new);\n+  gimple_set_location (fn_call, loc);\n+  gimple_seq_add_stmt (&seq, fn_call);\n+\n+  if (store_dr)\n+    {\n+      gassign *g = gimple_build_assign (DR_REF (store_dr), reduction_var_new);\n+      gimple_seq_add_stmt (&seq, g);\n+    }\n+\n+  generate_reduction_builtin_1 (loop, seq, reduction_var, reduction_var_new,\n+\t\t\t\t\"generated rawmemchr%s\\n\",\n+\t\t\t\tTYPE_MODE (TREE_TYPE (TREE_TYPE (base))));\n+}\n+\n+/* Helper function for generate_strlen_builtin(,_using_rawmemchr)  */\n+\n+static void\n+generate_strlen_builtin_1 (loop_p loop, gimple_seq &seq,\n+\t\t\t   tree reduction_var_old, tree reduction_var_new,\n+\t\t\t   machine_mode mode, tree start_len)\n+{\n+  /* REDUCTION_VAR_NEW has either size type or ptrdiff type and must be\n+     converted if types of old and new reduction variable are not compatible. */\n+  reduction_var_new = gimple_convert (&seq, TREE_TYPE (reduction_var_old),\n+\t\t\t\t      reduction_var_new);\n+\n+  /* Loops of the form `for (i=42; s[i]; ++i);` have an additional start\n+     length.  */\n+  if (!integer_zerop (start_len))\n+    {\n+      tree lhs = make_ssa_name (TREE_TYPE (reduction_var_new));\n+      gimple *g = gimple_build_assign (lhs, PLUS_EXPR, reduction_var_new,\n+\t\t\t\t       start_len);\n+      gimple_seq_add_stmt (&seq, g);\n+      reduction_var_new = lhs;\n+    }\n+\n+  generate_reduction_builtin_1 (loop, seq, reduction_var_old, reduction_var_new,\n+\t\t\t\t\"generated strlen%s\\n\", mode);\n+}\n+\n+/* Generate a call to strlen and place it before LOOP.  REDUCTION_VAR is\n+   replaced with a fresh SSA name representing the result of the call.  */\n+\n+static void\n+generate_strlen_builtin (loop_p loop, tree reduction_var, tree base,\n+\t\t\t tree start_len, location_t loc)\n+{\n+  gimple_seq seq = NULL;\n+\n+  tree reduction_var_new = make_ssa_name (size_type_node);\n+\n+  tree mem = force_gimple_operand (base, &seq, true, NULL_TREE);\n+  tree fn = build_fold_addr_expr (builtin_decl_implicit (BUILT_IN_STRLEN));\n+  gimple *fn_call = gimple_build_call (fn, 1, mem);\n+  gimple_call_set_lhs (fn_call, reduction_var_new);\n+  gimple_set_location (fn_call, loc);\n+  gimple_seq_add_stmt (&seq, fn_call);\n+\n+  generate_strlen_builtin_1 (loop, seq, reduction_var, reduction_var_new,\n+\t\t\t     QImode, start_len);\n+}\n+\n+/* Generate code in order to mimic the behaviour of strlen but this time over\n+   an array of elements with mode different than QI.  REDUCTION_VAR is replaced\n+   with a fresh SSA name representing the result, i.e., the length.  */\n+\n+static void\n+generate_strlen_builtin_using_rawmemchr (loop_p loop, tree reduction_var,\n+\t\t\t\t\t tree base, tree load_type,\n+\t\t\t\t\t tree start_len, location_t loc)\n+{\n+  gimple_seq seq = NULL;\n+\n+  tree start = force_gimple_operand (base, &seq, true, NULL_TREE);\n+  tree zero = build_zero_cst (load_type);\n+  gimple *fn_call = gimple_build_call_internal (IFN_RAWMEMCHR, 2, start, zero);\n+  tree end = make_ssa_name (TREE_TYPE (base));\n+  gimple_call_set_lhs (fn_call, end);\n+  gimple_set_location (fn_call, loc);\n+  gimple_seq_add_stmt (&seq, fn_call);\n+\n+  /* Determine the number of elements between START and END by\n+     evaluating (END - START) / sizeof (*START).  */\n+  tree diff = make_ssa_name (ptrdiff_type_node);\n+  gimple *diff_stmt = gimple_build_assign (diff, POINTER_DIFF_EXPR, end, start);\n+  gimple_seq_add_stmt (&seq, diff_stmt);\n+  /* Let SIZE be the size of each character.  */\n+  tree size = gimple_convert (&seq, ptrdiff_type_node,\n+\t\t\t      TYPE_SIZE_UNIT (load_type));\n+  tree count = make_ssa_name (ptrdiff_type_node);\n+  gimple *count_stmt = gimple_build_assign (count, TRUNC_DIV_EXPR, diff, size);\n+  gimple_seq_add_stmt (&seq, count_stmt);\n+\n+  generate_strlen_builtin_1 (loop, seq, reduction_var, count,\n+\t\t\t     TYPE_MODE (load_type),\n+\t\t\t     start_len);\n+}\n+\n+/* Return true if we can count at least as many characters by taking pointer\n+   difference as we can count via reduction_var without an overflow.  Thus\n+   compute 2^n < (2^(m-1) / s) where n = TYPE_PRECISION (reduction_var),\n+   m = TYPE_PRECISION (ptrdiff_type_node), and s = size of each character.  */\n+static bool\n+reduction_var_overflows_first (tree reduction_var, tree load_type)\n+{\n+  widest_int n2 = wi::lshift (1, TYPE_PRECISION (reduction_var));;\n+  widest_int m2 = wi::lshift (1, TYPE_PRECISION (ptrdiff_type_node) - 1);\n+  widest_int s = wi::to_widest (TYPE_SIZE_UNIT (load_type));\n+  return wi::ltu_p (n2, wi::udiv_trunc (m2, s));\n+}\n+\n+static gimple *\n+determine_reduction_stmt_1 (const loop_p loop, const basic_block *bbs)\n+{\n+  gimple *reduction_stmt = NULL;\n+\n+  for (unsigned i = 0, ninsns = 0; i < loop->num_nodes; ++i)\n+    {\n+      basic_block bb = bbs[i];\n+\n+      for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);\n+\t   gsi_next_nondebug (&bsi))\n+\t{\n+\t  gphi *phi = bsi.phi ();\n+\t  if (virtual_operand_p (gimple_phi_result (phi)))\n+\t    continue;\n+\t  if (stmt_has_scalar_dependences_outside_loop (loop, phi))\n+\t    {\n+\t      if (reduction_stmt)\n+\t\treturn NULL;\n+\t      reduction_stmt = phi;\n+\t    }\n+\t}\n+\n+      for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n+\t   gsi_next_nondebug (&bsi), ++ninsns)\n+\t{\n+\t  /* Bail out early for loops which are unlikely to match.  */\n+\t  if (ninsns > 16)\n+\t    return NULL;\n+\t  gimple *stmt = gsi_stmt (bsi);\n+\t  if (gimple_clobber_p (stmt))\n+\t    continue;\n+\t  if (gimple_code (stmt) == GIMPLE_LABEL)\n+\t    continue;\n+\t  if (gimple_has_volatile_ops (stmt))\n+\t    return NULL;\n+\t  if (stmt_has_scalar_dependences_outside_loop (loop, stmt))\n+\t    {\n+\t      if (reduction_stmt)\n+\t\treturn NULL;\n+\t      reduction_stmt = stmt;\n+\t    }\n+\t}\n+    }\n+\n+  return reduction_stmt;\n+}\n+\n+/* If LOOP has a single non-volatile reduction statement, then return a pointer\n+   to it.  Otherwise return NULL.  */\n+static gimple *\n+determine_reduction_stmt (const loop_p loop)\n+{\n+  basic_block *bbs = get_loop_body (loop);\n+  gimple *reduction_stmt = determine_reduction_stmt_1 (loop, bbs);\n+  XDELETEVEC (bbs);\n+  return reduction_stmt;\n+}\n+\n+/* Transform loops which mimic the effects of builtins rawmemchr or strlen and\n+   replace them accordingly.  For example, a loop of the form\n+\n+     for (; *p != 42; ++p);\n+\n+   is replaced by\n+\n+     p = rawmemchr<MODE> (p, 42);\n+\n+   under the assumption that rawmemchr is available for a particular MODE.\n+   Another example is\n+\n+     int i;\n+     for (i = 42; s[i]; ++i);\n+\n+   which is replaced by\n+\n+     i = (int)strlen (&s[42]) + 42;\n+\n+   for some character array S.  In case array S is not of type character array\n+   we end up with\n+\n+     i = (int)(rawmemchr<MODE> (&s[42], 0) - &s[42]) + 42;\n+\n+   assuming that rawmemchr is available for a particular MODE.  */\n+\n+bool\n+loop_distribution::transform_reduction_loop (loop_p loop)\n+{\n+  gimple *reduction_stmt;\n+  data_reference_p load_dr = NULL, store_dr = NULL;\n+\n+  edge e = single_exit (loop);\n+  gcond *cond = safe_dyn_cast <gcond *> (last_stmt (e->src));\n+  if (!cond)\n+    return false;\n+  /* Ensure loop condition is an (in)equality test and loop is exited either if\n+     the inequality test fails or the equality test succeeds.  */\n+  if (!(e->flags & EDGE_FALSE_VALUE && gimple_cond_code (cond) == NE_EXPR)\n+      && !(e->flags & EDGE_TRUE_VALUE && gimple_cond_code (cond) == EQ_EXPR))\n+    return false;\n+  /* A limitation of the current implementation is that we only support\n+     constant patterns in (in)equality tests.  */\n+  tree pattern = gimple_cond_rhs (cond);\n+  if (TREE_CODE (pattern) != INTEGER_CST)\n+    return false;\n+\n+  reduction_stmt = determine_reduction_stmt (loop);\n+\n+  /* A limitation of the current implementation is that we require a reduction\n+     statement.  Therefore, loops without a reduction statement as in the\n+     following are not recognized:\n+     int *p;\n+     void foo (void) { for (; *p; ++p); } */\n+  if (reduction_stmt == NULL)\n+    return false;\n+\n+  /* Reduction variables are guaranteed to be SSA names.  */\n+  tree reduction_var;\n+  switch (gimple_code (reduction_stmt))\n+    {\n+    case GIMPLE_ASSIGN:\n+    case GIMPLE_PHI:\n+      reduction_var = gimple_get_lhs (reduction_stmt);\n+      break;\n+    default:\n+      /* Bail out e.g. for GIMPLE_CALL.  */\n+      return false;\n+    }\n+\n+  struct graph *rdg = build_rdg (loop, NULL);\n+  if (rdg == NULL)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Loop %d not transformed: failed to build the RDG.\\n\",\n+\t\t loop->num);\n+\n+      return false;\n+    }\n+  auto_bitmap partition_stmts;\n+  bitmap_set_range (partition_stmts, 0, rdg->n_vertices);\n+  find_single_drs (loop, rdg, partition_stmts, &store_dr, &load_dr);\n+  free_rdg (rdg);\n+\n+  /* Bail out if there is no single load.  */\n+  if (load_dr == NULL)\n+    return false;\n+\n+  /* Reaching this point we have a loop with a single reduction variable,\n+     a single load, and an optional single store.  */\n+\n+  tree load_ref = DR_REF (load_dr);\n+  tree load_type = TREE_TYPE (load_ref);\n+  tree load_access_base = build_fold_addr_expr (load_ref);\n+  tree load_access_size = TYPE_SIZE_UNIT (load_type);\n+  affine_iv load_iv, reduction_iv;\n+\n+  if (!INTEGRAL_TYPE_P (load_type)\n+      || !type_has_mode_precision_p (load_type))\n+    return false;\n+\n+  /* We already ensured that the loop condition tests for (in)equality where the\n+     rhs is a constant pattern. Now ensure that the lhs is the result of the\n+     load.  */\n+  if (gimple_cond_lhs (cond) != gimple_assign_lhs (DR_STMT (load_dr)))\n+    return false;\n+\n+  /* Bail out if no affine induction variable with constant step can be\n+     determined.  */\n+  if (!simple_iv (loop, loop, load_access_base, &load_iv, false))\n+    return false;\n+\n+  /* Bail out if memory accesses are not consecutive or not growing.  */\n+  if (!operand_equal_p (load_iv.step, load_access_size, 0))\n+    return false;\n+\n+  if (!simple_iv (loop, loop, reduction_var, &reduction_iv, false))\n+    return false;\n+\n+  /* Handle rawmemchr like loops.  */\n+  if (operand_equal_p (load_iv.base, reduction_iv.base)\n+      && operand_equal_p (load_iv.step, reduction_iv.step))\n+    {\n+      if (store_dr)\n+\t{\n+\t  /* Ensure that we store to X and load from X+I where I>0.  */\n+\t  if (TREE_CODE (load_iv.base) != POINTER_PLUS_EXPR\n+\t      || !integer_onep (TREE_OPERAND (load_iv.base, 1)))\n+\t    return false;\n+\t  tree ptr_base = TREE_OPERAND (load_iv.base, 0);\n+\t  if (TREE_CODE (ptr_base) != SSA_NAME)\n+\t    return false;\n+\t  gimple *def = SSA_NAME_DEF_STMT (ptr_base);\n+\t  if (!gimple_assign_single_p (def)\n+\t      || gimple_assign_rhs1 (def) != DR_REF (store_dr))\n+\t    return false;\n+\t  /* Ensure that the reduction value is stored.  */\n+\t  if (gimple_assign_rhs1 (DR_STMT (store_dr)) != reduction_var)\n+\t    return false;\n+\t}\n+      /* Bail out if target does not provide rawmemchr for a certain mode.  */\n+      machine_mode mode = TYPE_MODE (load_type);\n+      if (direct_optab_handler (rawmemchr_optab, mode) == CODE_FOR_nothing)\n+\treturn false;\n+      location_t loc = gimple_location (DR_STMT (load_dr));\n+      generate_rawmemchr_builtin (loop, reduction_var, store_dr, load_iv.base,\n+\t\t\t\t  pattern, loc);\n+      return true;\n+    }\n+\n+  /* Handle strlen like loops.  */\n+  if (store_dr == NULL\n+      && integer_zerop (pattern)\n+      && TREE_CODE (reduction_iv.base) == INTEGER_CST\n+      && TREE_CODE (reduction_iv.step) == INTEGER_CST\n+      && integer_onep (reduction_iv.step))\n+    {\n+      location_t loc = gimple_location (DR_STMT (load_dr));\n+      /* While determining the length of a string an overflow might occur.\n+\t If an overflow only occurs in the loop implementation and not in the\n+\t strlen implementation, then either the overflow is undefined or the\n+\t truncated result of strlen equals the one of the loop.  Otherwise if\n+\t an overflow may also occur in the strlen implementation, then\n+\t replacing a loop by a call to strlen is sound whenever we ensure that\n+\t if an overflow occurs in the strlen implementation, then also an\n+\t overflow occurs in the loop implementation which is undefined.  It\n+\t seems reasonable to relax this and assume that the strlen\n+\t implementation cannot overflow in case sizetype is big enough in the\n+\t sense that an overflow can only happen for string objects which are\n+\t bigger than half of the address space; at least for 32-bit targets and\n+\t up.\n+\n+\t For strlen which makes use of rawmemchr the maximal length of a string\n+\t which can be determined without an overflow is PTRDIFF_MAX / S where\n+\t each character has size S.  Since an overflow for ptrdiff type is\n+\t undefined we have to make sure that if an overflow occurs, then an\n+\t overflow occurs in the loop implementation, too, and this is\n+\t undefined, too.  Similar as before we relax this and assume that no\n+\t string object is larger than half of the address space; at least for\n+\t 32-bit targets and up.  */\n+      if (TYPE_MODE (load_type) == TYPE_MODE (char_type_node)\n+\t  && TYPE_PRECISION (load_type) == TYPE_PRECISION (char_type_node)\n+\t  && ((TYPE_PRECISION (sizetype) >= TYPE_PRECISION (ptr_type_node) - 1\n+\t       && TYPE_PRECISION (ptr_type_node) >= 32)\n+\t      || (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (reduction_var))\n+\t\t  && TYPE_PRECISION (reduction_var) <= TYPE_PRECISION (sizetype)))\n+\t  && builtin_decl_implicit (BUILT_IN_STRLEN))\n+\tgenerate_strlen_builtin (loop, reduction_var, load_iv.base,\n+\t\t\t\t reduction_iv.base, loc);\n+      else if (direct_optab_handler (rawmemchr_optab, TYPE_MODE (load_type))\n+\t       != CODE_FOR_nothing\n+\t       && ((TYPE_PRECISION (ptrdiff_type_node) == TYPE_PRECISION (ptr_type_node)\n+\t\t    && TYPE_PRECISION (ptrdiff_type_node) >= 32)\n+\t\t   || (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (reduction_var))\n+\t\t       && reduction_var_overflows_first (reduction_var, load_type))))\n+\tgenerate_strlen_builtin_using_rawmemchr (loop, reduction_var,\n+\t\t\t\t\t\t load_iv.base,\n+\t\t\t\t\t\t load_type,\n+\t\t\t\t\t\t reduction_iv.base, loc);\n+      else\n+\treturn false;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Given innermost LOOP, return the outermost enclosing loop that forms a\n    perfect loop nest.  */\n \n@@ -3324,10 +3767,27 @@ loop_distribution::execute (function *fun)\n \t      && !optimize_loop_for_speed_p (loop)))\n \tcontinue;\n \n-      /* Don't distribute loop if niters is unknown.  */\n+      /* If niters is unknown don't distribute loop but rather try to transform\n+\t it to a call to a builtin.  */\n       tree niters = number_of_latch_executions (loop);\n       if (niters == NULL_TREE || niters == chrec_dont_know)\n-\tcontinue;\n+\t{\n+\t  datarefs_vec.create (20);\n+\t  if (transform_reduction_loop (loop))\n+\t    {\n+\t      changed = true;\n+\t      loops_to_be_destroyed.safe_push (loop);\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_user_location_t loc = find_loop_location (loop);\n+\t\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS,\n+\t\t\t\t   loc, \"Loop %d transformed into a builtin.\\n\",\n+\t\t\t\t   loop->num);\n+\t\t}\n+\t    }\n+\t  free_data_refs (datarefs_vec);\n+\t  continue;\n+\t}\n \n       /* Get the perfect loop nest for distribution.  */\n       loop = prepare_perfect_loop_nest (loop);"}]}