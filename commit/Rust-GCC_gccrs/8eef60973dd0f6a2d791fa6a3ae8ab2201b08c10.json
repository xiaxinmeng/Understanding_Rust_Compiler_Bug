{"sha": "8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVlZjYwOTczZGQwZjZhMmQ3OTFmYTZhM2FlOGFiMjIwMWIwOGMxMA==", "commit": {"author": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-05-04T16:19:20Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-05-04T16:19:20Z"}, "message": "[PR 80622] Treat const pools as initialized in SRA\n\n2017-05-04  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/80622\n\t* tree-sra.c (comes_initialized_p): New function.\n\t(build_accesses_from_assign): Only set write lazily when\n\tcomes_initialized_p is false.\n\t(analyze_access_subtree): Use comes_initialized_p.\n\t(propagate_subaccesses_across_link): Assert !comes_initialized_p\n\tinstead of testing for PARM_DECL.\n\ntestsuite/\n\t* gcc.dg/tree-ssa/pr80622.c: New test.\n\nFrom-SVN: r247604", "tree": {"sha": "b243ad6fcb4a06083e1de72298e2887b16d71adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b243ad6fcb4a06083e1de72298e2887b16d71adf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10/comments", "author": null, "committer": null, "parents": [{"sha": "9bf2f779045072c0db1e57f67fbc864caf212585", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf2f779045072c0db1e57f67fbc864caf212585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bf2f779045072c0db1e57f67fbc864caf212585"}], "stats": {"total": 67, "additions": 57, "deletions": 10}, "files": [{"sha": "a59b8227ee31a31ffc9ca12833f02f3ecf5874b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10", "patch": "@@ -1,4 +1,14 @@\n-2016-05-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+2017-05-04  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/80622\n+\t* tree-sra.c (comes_initialized_p): New function.\n+\t(build_accesses_from_assign): Only set write lazily when\n+\tcomes_initialized_p is false.\n+\t(analyze_access_subtree): Use comes_initialized_p.\n+\t(propagate_subaccesses_across_link): Assert !comes_initialized_p\n+\tinstead of testing for PARM_DECL.\n+\n+2017-05-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.md (prefetch); Adjust predicate and\n \tconstraint on operand 0 to allow more general addressing modes."}, {"sha": "feb65d55f5320e4f6384cfcf3f1069c424180dd0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10", "patch": "@@ -1,4 +1,9 @@\n-2016-05-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+2017-05-04  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/80622\n+\t* gcc.dg/tree-ssa/pr80622.c: New test.\n+\n+2017-05-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/aarch64/prfm_imm_offset_1.c: New test.\n "}, {"sha": "96dcb8fcdc04b7dfb3e6e936ca8cf4ea2089f370", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr80622.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr80622.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr80622.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr80622.c?ref=8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O\" } */\n+\n+struct S { int d; char e; int f; char g; } a;\n+char c;\n+\n+int\n+main ()\n+{\n+  struct S b[][1] = {3, 0, 3, 4, 3, 0, 3, 4, 3, 0, 3, 4, 3, 0, 3, 4, 3,\n+                      0, 3, 4, 3, 0, 3, 4, 3, 0, 3, 4, 3, 0, 3, 4, 3, 0,\n+                      3, 4, 3, 4, 7, 7, 3, 5, 0, 3, 4, 7, 7, 3, 5, 0, 3,\n+                      4, 3, 4, 7, 7, 3, 5, 0, 3, 4, 7, 7, 3, 5, 0, 3, 4};\n+  a = b[4][0];\n+  c = b[4][0].e;\n+  if (a.g != 4)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "8ac9c0783ff0988417fcb0edcebfa101bb009e65", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=8eef60973dd0f6a2d791fa6a3ae8ab2201b08c10", "patch": "@@ -1305,6 +1305,15 @@ disqualify_if_bad_bb_terminating_stmt (gimple *stmt, tree lhs, tree rhs)\n   return false;\n }\n \n+/* Return true if the nature of BASE is such that it contains data even if\n+   there is no write to it in the function.  */\n+\n+static bool\n+comes_initialized_p (tree base)\n+{\n+  return TREE_CODE (base) == PARM_DECL || constant_decl_p (base);\n+}\n+\n /* Scan expressions occurring in STMT, create access structures for all accesses\n    to candidates for scalarization and remove those candidates which occur in\n    statements or expressions that prevent them from being split apart.  Return\n@@ -1364,8 +1373,10 @@ build_accesses_from_assign (gimple *stmt)\n       link->racc = racc;\n       add_link_to_rhs (racc, link);\n       /* Let's delay marking the areas as written until propagation of accesses\n-\t across link.  */\n-      lacc->write = false;\n+\t across link, unless the nature of rhs tells us that its data comes\n+\t from elsewhere.  */\n+      if (!comes_initialized_p (racc->base))\n+\tlacc->write = false;\n     }\n \n   return lacc || racc;\n@@ -2472,8 +2483,7 @@ analyze_access_subtree (struct access *root, struct access *parent,\n \n   if (!hole || root->grp_total_scalarization)\n     root->grp_covered = 1;\n-  else if (root->grp_write || TREE_CODE (root->base) == PARM_DECL\n-\t   || constant_decl_p (root->base))\n+  else if (root->grp_write || comes_initialized_p (root->base))\n     root->grp_unscalarized_data = 1; /* not covered and written to */\n   return sth_created;\n }\n@@ -2581,11 +2591,14 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n \n   /* IF the LHS is still not marked as being written to, we only need to do so\n      if the RHS at this level actually was.  */\n-  if (!lacc->grp_write &&\n-      (racc->grp_write || TREE_CODE (racc->base) == PARM_DECL))\n+  if (!lacc->grp_write)\n     {\n-      lacc->grp_write = true;\n-      ret = true;\n+      gcc_checking_assert (!comes_initialized_p (racc->base));\n+      if (racc->grp_write)\n+\t{\n+\t  lacc->grp_write = true;\n+\t  ret = true;\n+\t}\n     }\n \n   if (is_gimple_reg_type (lacc->type)"}]}