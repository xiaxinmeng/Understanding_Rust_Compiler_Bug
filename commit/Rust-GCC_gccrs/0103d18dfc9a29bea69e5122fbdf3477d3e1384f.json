{"sha": "0103d18dfc9a29bea69e5122fbdf3477d3e1384f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEwM2QxOGRmYzlhMjliZWE2OWU1MTIyZmJkZjM0NzdkM2UxMzg0Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-07-17T12:24:19Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-07-17T12:24:19Z"}, "message": "Support EAF_NOT_RETURNED in tree-ssa-structalias\n\ngcc/ChangeLog:\n\n2021-07-17  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* tree-ssa-structalias.c (handle_rhs_call): Support EAF_NOT_RETURNED.\n\t(handle_const_call): Liekise\n\t(handle_pure_call): Liekise\n\ngcc/testsuite/ChangeLog:\n\n2021-07-17  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* gcc.dg/tree-ssa/modref-6.c: New test.", "tree": {"sha": "9fe3565e7180214721b02402523f49326a29d5eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fe3565e7180214721b02402523f49326a29d5eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0103d18dfc9a29bea69e5122fbdf3477d3e1384f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0103d18dfc9a29bea69e5122fbdf3477d3e1384f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0103d18dfc9a29bea69e5122fbdf3477d3e1384f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0103d18dfc9a29bea69e5122fbdf3477d3e1384f/comments", "author": null, "committer": null, "parents": [{"sha": "704e8a825c78b9a8424c291509413bbb48e602c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/704e8a825c78b9a8424c291509413bbb48e602c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/704e8a825c78b9a8424c291509413bbb48e602c7"}], "stats": {"total": 67, "additions": 59, "deletions": 8}, "files": [{"sha": "8db9a1d619c10acfa30d01f434a4e2ae1cb5a5a6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-6.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0103d18dfc9a29bea69e5122fbdf3477d3e1384f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0103d18dfc9a29bea69e5122fbdf3477d3e1384f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-6.c?ref=0103d18dfc9a29bea69e5122fbdf3477d3e1384f", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-options \"-O2 -fdump-tree-modref1 -fdump-tree-optimized\"  } */\n+/* { dg-do compile } */\n+int c;\n+__attribute__ ((noinline))\n+int *test (int *b)\n+{\n+  c++;\n+  return *b ? &c : 0;\n+}\n+__attribute__ ((noinline, pure))\n+int *pure_test (int *b)\n+{\n+  return *b && c ? &c : 0;\n+}\n+__attribute__ ((noinline, const))\n+int *const_test (int *b)\n+{\n+  return b ? &c : 0;\n+}\n+void escape (int *);\n+\n+int test2()\n+{\n+   int a = 42;\n+   escape (test (&a));\n+   escape (pure_test (&a));\n+   escape (const_test (&a));\n+   return a;\n+}\n+/* Flags for normal call.  */\n+/* { dg-final { scan-tree-dump \"parm 0 flags: direct noclobber noescape nodirectescape not_returned\" \"modref1\"  } } */\n+/* Flags for pure call.  */\n+/* { dg-final { scan-tree-dump \"parm 0 flags: direct not_returned\" \"modref1\"  } } */\n+/* Flags for const call.  */\n+/* { dg-final { scan-tree-dump \"parm 0 flags: unused not_returned\" \"modref1\"  } } */\n+/* Overall we want to make \"int a\" non escaping.  */\n+/* { dg-final { scan-tree-dump \"return 42\" \"optimized\"  } } */"}, {"sha": "71894b38ff92db9adc479ca1cecf5feb61ea11d5", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0103d18dfc9a29bea69e5122fbdf3477d3e1384f/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0103d18dfc9a29bea69e5122fbdf3477d3e1384f/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=0103d18dfc9a29bea69e5122fbdf3477d3e1384f", "patch": "@@ -4082,9 +4082,12 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n \t  if (!(flags & EAF_DIRECT))\n \t    make_transitive_closure_constraints (tem);\n \t  make_copy_constraint (uses, tem->id);\n+\t  /* TODO: This is overly conservative when some parameters are\n+\t     returned while others are not.  */\n+\t  if (!(flags & EAF_NOT_RETURNED))\n+\t    returns_uses = true;\n \t  if (!(flags & (EAF_NOESCAPE | EAF_DIRECT)))\n \t    make_indirect_escape_constraint (tem);\n-\t  returns_uses = true;\n \t}\n       else if (flags & (EAF_NOESCAPE | EAF_NODIRECTESCAPE))\n \t{\n@@ -4098,6 +4101,8 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n \t  if (!(flags & EAF_DIRECT))\n \t    make_transitive_closure_constraints (tem);\n \t  make_copy_constraint (uses, tem->id);\n+\t  if (!(flags & EAF_NOT_RETURNED))\n+\t    returns_uses = true;\n \t  make_copy_constraint (clobbers, tem->id);\n \t  /* Add *tem = nonlocal, do not add *tem = callused as\n \t     EAF_NOESCAPE parameters do not escape to other parameters\n@@ -4111,7 +4116,6 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n \t  process_constraint (new_constraint (lhs, rhs));\n \t  if (!(flags & (EAF_NOESCAPE | EAF_DIRECT)))\n \t    make_indirect_escape_constraint (tem);\n-\t  returns_uses = true;\n \t}\n       else\n \tmake_escape_constraint (arg);\n@@ -4261,13 +4265,18 @@ handle_const_call (gcall *stmt, vec<ce_s> *results)\n \n   /* May return offsetted arguments.  */\n   varinfo_t tem = NULL;\n-  if (gimple_call_num_args (stmt) != 0)\n-    {\n-      tem = new_var_info (NULL_TREE, \"callarg\", true);\n-      tem->is_reg_var = true;\n-    }\n   for (k = 0; k < gimple_call_num_args (stmt); ++k)\n     {\n+      int flags = gimple_call_arg_flags (stmt, k);\n+\n+      /* If the argument is not used or not returned we can ignore it.  */\n+      if (flags & (EAF_UNUSED | EAF_NOT_RETURNED))\n+\tcontinue;\n+      if (!tem)\n+\t{\n+\t  tem = new_var_info (NULL_TREE, \"callarg\", true);\n+\t  tem->is_reg_var = true;\n+\t}\n       tree arg = gimple_call_arg (stmt, k);\n       auto_vec<ce_s> argc;\n       get_constraint_for_rhs (arg, &argc);\n@@ -4298,6 +4307,7 @@ handle_pure_call (gcall *stmt, vec<ce_s> *results)\n   struct constraint_expr rhsc;\n   unsigned i;\n   varinfo_t uses = NULL;\n+  bool record_uses = false;\n \n   /* Memory reached from pointer arguments is call-used.  */\n   for (i = 0; i < gimple_call_num_args (stmt); ++i)\n@@ -4315,6 +4325,8 @@ handle_pure_call (gcall *stmt, vec<ce_s> *results)\n \t  make_transitive_closure_constraints (uses);\n \t}\n       make_constraint_to (uses->id, arg);\n+      if (!(flags & EAF_NOT_RETURNED))\n+\trecord_uses = true;\n     }\n \n   /* The static chain is used as well.  */\n@@ -4327,6 +4339,7 @@ handle_pure_call (gcall *stmt, vec<ce_s> *results)\n \t  make_transitive_closure_constraints (uses);\n \t}\n       make_constraint_to (uses->id, gimple_call_chain (stmt));\n+      record_uses = true;\n     }\n \n   /* And if we applied NRV the address of the return slot.  */\n@@ -4343,10 +4356,11 @@ handle_pure_call (gcall *stmt, vec<ce_s> *results)\n       auto_vec<ce_s> tmpc;\n       get_constraint_for_address_of (gimple_call_lhs (stmt), &tmpc);\n       make_constraints_to (uses->id, tmpc);\n+      record_uses = true;\n     }\n \n   /* Pure functions may return call-used and nonlocal memory.  */\n-  if (uses)\n+  if (record_uses)\n     {\n       rhsc.var = uses->id;\n       rhsc.offset = 0;"}]}