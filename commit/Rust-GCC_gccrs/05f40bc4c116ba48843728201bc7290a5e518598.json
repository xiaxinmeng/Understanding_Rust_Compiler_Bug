{"sha": "05f40bc4c116ba48843728201bc7290a5e518598", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVmNDBiYzRjMTE2YmE0ODg0MzcyODIwMWJjNzI5MGE1ZTUxODU5OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-09-14T21:01:56Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-09-14T21:11:17Z"}, "message": "libbacktrace: support MiniDebugInfo\n\nlibbacktrace/ChangeLog:\n\tPR libbacktrace/93608\n\tAdd support for MiniDebugInfo.\n\t* elf.c (struct elf_view): Define.  Replace most uses of\n\tbacktrace_view with elf_view.\n\t(elf_get_view): New static functions.  Replace most calls of\n\tbacktrace_get_view with elf_get_view.\n\t(elf_release_view): New static functions.  Replace most calls of\n\tbacktrace_release_view with elf_release_view.\n\t(elf_uncompress_failed): Rename from elf_zlib_failed.  Change all\n\tcallers.\n\t(LZMA_STATES, LZMA_POS_STATES, LZMA_DIST_STATES): Define.\n\t(LZMA_DIST_SLOTS, LZMA_DIST_MODEL_START): Define.\n\t(LZMA_DIST_MODEL_END, LZMA_FULL_DISTANCES): Define.\n\t(LZMA_ALIGN_SIZE, LZMA_LEN_LOW_SYMBOLS): Define.\n\t(LZMA_LEN_MID_SYMBOLS, LZMA_LEN_HIGH_SYMBOLS): Define.\n\t(LZMA_LITERAL_CODERS_MAX, LZMA_LITERAL_CODER_SIZE): Define.\n\t(LZMA_PROB_IS_MATCH_LEN, LZMA_PROB_IS_REP_LEN): Define.\n\t(LZMA_PROB_IS_REP0_LEN, LZMA_PROB_IS_REP1_LEN): Define.\n\t(LZMA_PROB_IS_REP2_LEN, LZMA_PROB_IS_REP0_LONG_LEN): Define.\n\t(LZMA_PROB_DIST_SLOT_LEN, LZMA_PROB_DIST_SPECIAL_LEN): Define.\n\t(LZMA_PROB_DIST_ALIGN_LEN): Define.\n\t(LZMA_PROB_MATCH_LEN_CHOICE_LEN): Define.\n\t(LZMA_PROB_MATCH_LEN_CHOICE2_LEN): Define.\n\t(LZMA_PROB_MATCH_LEN_LOW_LEN): Define.\n\t(LZMA_PROB_MATCH_LEN_MID_LEN): Define.\n\t(LZMA_PROB_MATCH_LEN_HIGH_LEN): Define.\n\t(LZMA_PROB_REP_LEN_CHOICE_LEN): Define.\n\t(LZMA_PROB_REP_LEN_CHOICE2_LEN): Define.\n\t(LZMA_PROB_REP_LEN_LOW_LEN): Define.\n\t(LZMA_PROB_REP_LEN_MID_LEN): Define.\n\t(LZMA_PROB_REP_LEN_HIGH_LEN): Define.\n\t(LZMA_PROB_LITERAL_LEN): Define.\n\t(LZMA_PROB_IS_MATCH_OFFSET, LZMA_PROB_IS_REP_OFFSET): Define.\n\t(LZMA_PROB_IS_REP0_OFFSET, LZMA_PROB_IS_REP1_OFFSET): Define.\n\t(LZMA_PROB_IS_REP2_OFFSET): Define.\n\t(LZMA_PROB_IS_REP0_LONG_OFFSET): Define.\n\t(LZMA_PROB_DIST_SLOT_OFFSET): Define.\n\t(LZMA_PROB_DIST_SPECIAL_OFFSET): Define.\n\t(LZMA_PROB_DIST_ALIGN_OFFSET): Define.\n\t(LZMA_PROB_MATCH_LEN_CHOICE_OFFSET): Define.\n\t(LZMA_PROB_MATCH_LEN_CHOICE2_OFFSET): Define.\n\t(LZMA_PROB_MATCH_LEN_LOW_OFFSET): Define.\n\t(LZMA_PROB_MATCH_LEN_MID_OFFSET): Define.\n\t(LZMA_PROB_MATCH_LEN_HIGH_OFFSET): Define.\n\t(LZMA_PROB_REP_LEN_CHOICE_OFFSET): Define.\n\t(LZMA_PROB_REP_LEN_CHOICE2_OFFSET): Define.\n\t(LZMA_PROB_REP_LEN_LOW_OFFSET): Define.\n\t(LZMA_PROB_REP_LEN_MID_OFFSET): Define.\n\t(LZMA_PROB_REP_LEN_HIGH_OFFSET): Define.\n\t(LZMA_PROB_LITERAL_OFFSET): Define.\n\t(LZMA_PROB_TOTAL_COUNT): Define.\n\t(LZMA_IS_MATCH, LZMA_IS_REP, LZMA_IS_REP0): Define.\n\t(LZMA_IS_REP1, LZMA_IS_REP2, LZMA_IS_REP0_LONG): Define.\n\t(LZMA_DIST_SLOT, LZMA_DIST_SPECIAL, LZMA_DIST_ALIGN): Define.\n\t(LZMA_MATCH_LEN_CHOICE, LZMA_MATCH_LEN_CHOICE2): Define.\n\t(LZMA_MATCH_LEN_LOW, LZMA_MATCH_LEN_MID): Define.\n\t(LZMA_MATCH_LEN_HIGH, LZMA_REP_LEN_CHOICE): Define.\n\t(LZMA_REP_LEN_CHOICE2, LZMA_REP_LEN_LOW): Define.\n\t(LZMA_REP_LEN_MID, LZMA_REP_LEN_HIGH, LZMA_LITERAL): Define.\n\t(elf_lzma_varint): New static function.\n\t(elf_lzma_range_normalize): New static function.\n\t(elf_lzma_bit, elf_lzma_integer): New static functions.\n\t(elf_lzma_reverse_integer): New static function.\n\t(elf_lzma_len, elf_uncompress_lzma_block): New static functions.\n\t(elf_uncompress_lzma): New static function.\n\t(backtrace_uncompress_lzma): New function.\n\t(elf_add): Add memory and memory_size parameters.  Change all\n\tcallers.  Look for .gnu_debugdata section, and, if found,\n\tdecompress it and use it for symbols and debug info.  Permit the\n\tdescriptor parameter to be -1.\n\t* internal.h (backtrace_uncompress_lzma): Declare.\n\t* mtest.c: New file.\n\t* xztest.c: New file.\n\t* configure.ac: Check for nm, xz, and comm programs.  Check for\n\tliblzma library.\n\t(HAVE_MINIDEBUG): Define.\n\t* Makefile.am (mtest_SOURCES): Define.\n\t(mtest_CFLAGS, mtest_LDADD): Define.\n\t(TESTS): Add mtest_minidebug if HAVE_MINIDEBUG.\n\t(%_minidebug): New pattern rule, if HAVE_MINIDEBUG.\n\t(xztest_SOURCES, xztest_CFLAGS, xztest_LDADD): Define.\n\t(xztest_alloc_SOURCES, xztest_alloc_CFLAGS): Define\n\t(xztest_alloc_LDADD): Define.\n\t(BUILDTESTS): Add mtest, xztest, xztest_alloc.\n\t(CLEANFILES): Add files created by minidebug pattern.\n\t(btest.lo): Correct INCDIR reference.\n\t(mtest.lo, xztest.lo, ztest.lo): New targets.\n\t* configure: Regenerate.\n\t* config.h.in: Regenerate.\n\t* Makefile.in: Regenerate.", "tree": {"sha": "98fc1d2937d6781d3e3f8c45492a87cdf3adae01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98fc1d2937d6781d3e3f8c45492a87cdf3adae01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05f40bc4c116ba48843728201bc7290a5e518598", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05f40bc4c116ba48843728201bc7290a5e518598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05f40bc4c116ba48843728201bc7290a5e518598", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05f40bc4c116ba48843728201bc7290a5e518598/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd6743e9c412b35e4ec7d8ebd7df8b0eeece3f01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd6743e9c412b35e4ec7d8ebd7df8b0eeece3f01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd6743e9c412b35e4ec7d8ebd7df8b0eeece3f01"}], "stats": {"total": 3079, "additions": 2913, "deletions": 166}, "files": [{"sha": "4d349386c9b9452a21accbda134a43096239f9d3", "filename": "libbacktrace/Makefile.am", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.am?ref=05f40bc4c116ba48843728201bc7290a5e518598", "patch": "@@ -478,13 +478,61 @@ endif HAVE_DSYMUTIL\n \n endif\n \n+mtest_SOURCES = mtest.c testlib.c\n+mtest_CFLAGS = $(libbacktrace_TEST_CFLAGS) -O\n+mtest_LDADD = libbacktrace.la\n+\n+BUILDTESTS += mtest\n+\n+if HAVE_MINIDEBUG\n+\n+TESTS += mtest_minidebug\n+\n+%_minidebug: %\n+\t$(NM) -D $< -P --defined-only | $(AWK) '{ print $$1 }' | sort > $<.dsyms\n+\t$(NM) $< -P --defined-only | $(AWK) '{ if ($$2 == \"T\" || $$2 == \"t\" || $$2 == \"D\") print $$1 }' | sort > $<.fsyms\n+\t$(COMM) -13 $<.dsyms $<.fsyms > $<.keepsyms\n+\t$(OBJCOPY) --only-keep-debug $< $<.dbg\n+\t$(OBJCOPY) -S --remove-section .gdb_index --remove-section .comment --keep-symbols=$<.keepsyms $<.dbg $<.mdbg\n+\t$(OBJCOPY) --strip-all --remove-section ..comment $< $<.strip\n+\trm -f $<.mdbg.xz\n+\t$(XZ) $<.mdbg\n+\t$(OBJCOPY) --add-section .gnu_debugdata=$<.mdbg.xz $<.strip\n+\tmv $<.strip $@\n+\n+endif HAVE_MINIDEBUG\n+\n endif NATIVE\n \n+if HAVE_ELF\n+\n+xztest_SOURCES = xztest.c testlib.c\n+xztest_CFLAGS = $(libbacktrace_TEST_CFLAGS) -DSRCDIR=\\\"$(srcdir)\\\"\n+xztest_LDADD = libbacktrace.la\n+\n+xztest_alloc_SOURCES = $(xztest_SOURCES)\n+xztest_alloc_CFLAGS = $(xztest_CFLAGS)\n+xztest_alloc_LDADD = libbacktrace_alloc.la\n+\n+if HAVE_LIBLZMA\n+xztest_LDADD += -llzma\n+xztest_alloc_LDADD += -llzma\n+endif\n+\n+xztest_LDADD += $(CLOCK_GETTIME_LINK)\n+xztest_alloc_LDADD += $(CLOCK_GETTIME_LINK)\n+\n+BUILDTESTS += xztest xztest_alloc\n+\n+endif HAVE_ELF\n+\n check_PROGRAMS += $(BUILDTESTS)\n \n TESTS += $(BUILDTESTS)\n \n-CLEANFILES = $(TESTS) *.debug elf_for_test.c edtest2_build.c gen_edtest2_build\n+CLEANFILES = \\\n+\t$(TESTS) *.debug elf_for_test.c edtest2_build.c gen_edtest2_build \\\n+\t*.dsyms *.fsyms *.keepsyms *.dbg *.mdbg *.mdbg.xz *.strip\n \n clean-local:\n \t-rm -rf usr\n@@ -504,14 +552,15 @@ clean-local:\n INCDIR = $(top_srcdir)/../include\n alloc.lo: config.h backtrace.h internal.h\n backtrace.lo: config.h backtrace.h internal.h\n-btest.lo: (INCDIR)/filenames.h backtrace.h backtrace-supported.h\n+btest.lo: $(INCDIR)/filenames.h backtrace.h backtrace-supported.h\n dwarf.lo: config.h $(INCDIR)/dwarf2.h $(INCDIR)/dwarf2.def \\\n \t$(INCDIR)/filenames.h backtrace.h internal.h\n elf.lo: config.h backtrace.h internal.h\n fileline.lo: config.h backtrace.h internal.h\n macho.lo: config.h backtrace.h internal.h\n mmap.lo: config.h backtrace.h internal.h\n mmapio.lo: config.h backtrace.h internal.h\n+mtest.lo: backtrace.h backtrace-supported.h\n nounwind.lo: config.h internal.h\n pecoff.lo: config.h backtrace.h internal.h\n posix.lo: config.h backtrace.h internal.h\n@@ -523,5 +572,7 @@ stest.lo: config.h backtrace.h internal.h\n state.lo: config.h backtrace.h backtrace-supported.h internal.h\n unknown.lo: config.h backtrace.h internal.h\n xcoff.lo: config.h backtrace.h internal.h\n+xztest.lo: config.h backtrace.h backtrace-supported.h internal.h testlib.h\n+ztest.lo: config.h backtrace.h backtrace-supported.h internal.h testlib.h\n \n include $(top_srcdir)/../multilib.am"}, {"sha": "201cee36d349369516dfbdf773797d9149f75a14", "filename": "libbacktrace/Makefile.in", "status": "modified", "additions": 152, "deletions": 11, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.in?ref=05f40bc4c116ba48843728201bc7290a5e518598", "patch": "@@ -121,10 +121,10 @@ build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) $(am__EXEEXT_3) \\\n-\t$(am__EXEEXT_12)\n+\t$(am__EXEEXT_14)\n TESTS = $(am__append_4) $(am__append_7) $(am__append_9) \\\n \t$(am__append_12) $(am__append_13) $(am__append_20) \\\n-\t$(am__EXEEXT_12)\n+\t$(am__append_25) $(am__EXEEXT_14)\n @HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_1 = libbacktrace_elf_for_test.la\n @NATIVE_TRUE@am__append_2 = test_elf_32 test_elf_64 test_macho \\\n @NATIVE_TRUE@\ttest_xcoff_32 test_xcoff_64 test_pecoff \\\n@@ -157,6 +157,11 @@ TESTS = $(am__append_4) $(am__append_7) $(am__append_9) \\\n @HAVE_DWARF5_TRUE@@NATIVE_TRUE@am__append_22 = dwarf5 dwarf5_alloc\n @HAVE_DSYMUTIL_TRUE@@HAVE_DWARF5_TRUE@@NATIVE_TRUE@am__append_23 = dwarf5.dSYM \\\n @HAVE_DSYMUTIL_TRUE@@HAVE_DWARF5_TRUE@@NATIVE_TRUE@\tdwarf5_alloc.dSYM\n+@NATIVE_TRUE@am__append_24 = mtest\n+@HAVE_MINIDEBUG_TRUE@@NATIVE_TRUE@am__append_25 = mtest_minidebug\n+@HAVE_ELF_TRUE@@HAVE_LIBLZMA_TRUE@am__append_26 = -llzma\n+@HAVE_ELF_TRUE@@HAVE_LIBLZMA_TRUE@am__append_27 = -llzma\n+@HAVE_ELF_TRUE@am__append_28 = xztest xztest_alloc\n subdir = .\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/cet.m4 \\\n@@ -235,9 +240,12 @@ libbacktrace_noformat_la_OBJECTS =  \\\n @HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tctesta_alloc$(EXEEXT)\n @HAVE_DWARF5_TRUE@@NATIVE_TRUE@am__EXEEXT_11 = dwarf5$(EXEEXT) \\\n @HAVE_DWARF5_TRUE@@NATIVE_TRUE@\tdwarf5_alloc$(EXEEXT)\n-am__EXEEXT_12 = $(am__EXEEXT_4) $(am__EXEEXT_5) $(am__EXEEXT_6) \\\n+@NATIVE_TRUE@am__EXEEXT_12 = mtest$(EXEEXT)\n+@HAVE_ELF_TRUE@am__EXEEXT_13 = xztest$(EXEEXT) xztest_alloc$(EXEEXT)\n+am__EXEEXT_14 = $(am__EXEEXT_4) $(am__EXEEXT_5) $(am__EXEEXT_6) \\\n \t$(am__EXEEXT_7) $(am__EXEEXT_8) $(am__EXEEXT_9) \\\n-\t$(am__EXEEXT_10) $(am__EXEEXT_11)\n+\t$(am__EXEEXT_10) $(am__EXEEXT_11) $(am__EXEEXT_12) \\\n+\t$(am__EXEEXT_13)\n @NATIVE_TRUE@am_allocfail_OBJECTS = allocfail-allocfail.$(OBJEXT) \\\n @NATIVE_TRUE@\tallocfail-testlib.$(OBJEXT)\n allocfail_OBJECTS = $(am_allocfail_OBJECTS)\n@@ -355,6 +363,13 @@ edtest_alloc_OBJECTS = $(am_edtest_alloc_OBJECTS)\n edtest_alloc_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(edtest_alloc_CFLAGS) \\\n \t$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\n+@NATIVE_TRUE@am_mtest_OBJECTS = mtest-mtest.$(OBJEXT) \\\n+@NATIVE_TRUE@\tmtest-testlib.$(OBJEXT)\n+mtest_OBJECTS = $(am_mtest_OBJECTS)\n+@NATIVE_TRUE@mtest_DEPENDENCIES = libbacktrace.la\n+mtest_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(mtest_CFLAGS) $(CFLAGS) \\\n+\t$(AM_LDFLAGS) $(LDFLAGS) -o $@\n @NATIVE_TRUE@am_stest_OBJECTS = stest-stest.$(OBJEXT)\n stest_OBJECTS = $(am_stest_OBJECTS)\n @NATIVE_TRUE@stest_DEPENDENCIES = libbacktrace.la\n@@ -465,6 +480,23 @@ unittest_alloc_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \\\n \t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \\\n \t$(unittest_alloc_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o \\\n \t$@\n+@HAVE_ELF_TRUE@am_xztest_OBJECTS = xztest-xztest.$(OBJEXT) \\\n+@HAVE_ELF_TRUE@\txztest-testlib.$(OBJEXT)\n+xztest_OBJECTS = $(am_xztest_OBJECTS)\n+@HAVE_ELF_TRUE@xztest_DEPENDENCIES = libbacktrace.la \\\n+@HAVE_ELF_TRUE@\t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)\n+xztest_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(xztest_CFLAGS) $(CFLAGS) \\\n+\t$(AM_LDFLAGS) $(LDFLAGS) -o $@\n+@HAVE_ELF_TRUE@am__objects_12 = xztest_alloc-xztest.$(OBJEXT) \\\n+@HAVE_ELF_TRUE@\txztest_alloc-testlib.$(OBJEXT)\n+@HAVE_ELF_TRUE@am_xztest_alloc_OBJECTS = $(am__objects_12)\n+xztest_alloc_OBJECTS = $(am_xztest_alloc_OBJECTS)\n+@HAVE_ELF_TRUE@xztest_alloc_DEPENDENCIES = libbacktrace_alloc.la \\\n+@HAVE_ELF_TRUE@\t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)\n+xztest_alloc_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(xztest_alloc_CFLAGS) \\\n+\t$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\n @HAVE_ELF_TRUE@@NATIVE_TRUE@am_ztest_OBJECTS = ztest-ztest.$(OBJEXT) \\\n @HAVE_ELF_TRUE@@NATIVE_TRUE@\tztest-testlib.$(OBJEXT)\n ztest_OBJECTS = $(am_ztest_OBJECTS)\n@@ -474,11 +506,11 @@ ztest_OBJECTS = $(am_ztest_OBJECTS)\n ztest_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ztest_CFLAGS) $(CFLAGS) \\\n \t$(AM_LDFLAGS) $(LDFLAGS) -o $@\n-@HAVE_ELF_TRUE@@NATIVE_TRUE@am__objects_12 =  \\\n+@HAVE_ELF_TRUE@@NATIVE_TRUE@am__objects_13 =  \\\n @HAVE_ELF_TRUE@@NATIVE_TRUE@\tztest_alloc-ztest.$(OBJEXT) \\\n @HAVE_ELF_TRUE@@NATIVE_TRUE@\tztest_alloc-testlib.$(OBJEXT)\n @HAVE_ELF_TRUE@@NATIVE_TRUE@am_ztest_alloc_OBJECTS =  \\\n-@HAVE_ELF_TRUE@@NATIVE_TRUE@\t$(am__objects_12)\n+@HAVE_ELF_TRUE@@NATIVE_TRUE@\t$(am__objects_13)\n ztest_alloc_OBJECTS = $(am_ztest_alloc_OBJECTS)\n @HAVE_ELF_TRUE@@NATIVE_TRUE@ztest_alloc_DEPENDENCIES =  \\\n @HAVE_ELF_TRUE@@NATIVE_TRUE@\tlibbacktrace_alloc.la \\\n@@ -530,13 +562,14 @@ SOURCES = $(libbacktrace_la_SOURCES) $(EXTRA_libbacktrace_la_SOURCES) \\\n \t$(ctesta_alloc_SOURCES) $(ctestg_SOURCES) \\\n \t$(ctestg_alloc_SOURCES) $(dwarf5_SOURCES) \\\n \t$(dwarf5_alloc_SOURCES) $(edtest_SOURCES) \\\n-\t$(edtest_alloc_SOURCES) $(stest_SOURCES) \\\n+\t$(edtest_alloc_SOURCES) $(mtest_SOURCES) $(stest_SOURCES) \\\n \t$(stest_alloc_SOURCES) $(test_elf_32_SOURCES) \\\n \t$(test_elf_64_SOURCES) $(test_macho_SOURCES) \\\n \t$(test_pecoff_SOURCES) $(test_unknown_SOURCES) \\\n \t$(test_xcoff_32_SOURCES) $(test_xcoff_64_SOURCES) \\\n \t$(ttest_SOURCES) $(ttest_alloc_SOURCES) $(unittest_SOURCES) \\\n-\t$(unittest_alloc_SOURCES) $(ztest_SOURCES) \\\n+\t$(unittest_alloc_SOURCES) $(xztest_SOURCES) \\\n+\t$(xztest_alloc_SOURCES) $(ztest_SOURCES) \\\n \t$(ztest_alloc_SOURCES)\n am__can_run_installinfo = \\\n   case $$AM_UPDATE_INFO_DIR in \\\n@@ -786,6 +819,7 @@ CC = @CC@\n CET_HOST_FLAGS = @CET_HOST_FLAGS@\n CFLAGS = @CFLAGS@\n CLOCK_GETTIME_LINK = @CLOCK_GETTIME_LINK@\n+COMM = @COMM@\n CPP = @CPP@\n CPPFLAGS = @CPPFLAGS@\n CYGPATH_W = @CYGPATH_W@\n@@ -844,6 +878,7 @@ STRIP = @STRIP@\n VERSION = @VERSION@\n VIEW_FILE = @VIEW_FILE@\n WARN_FLAGS = @WARN_FLAGS@\n+XZ = @XZ@\n abs_builddir = @abs_builddir@\n abs_srcdir = @abs_srcdir@\n abs_top_builddir = @abs_top_builddir@\n@@ -953,7 +988,8 @@ libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n # Add a test to this variable if you want it to be built and run.\n BUILDTESTS = $(am__append_2) $(am__append_10) $(am__append_11) \\\n \t$(am__append_16) $(am__append_17) $(am__append_18) \\\n-\t$(am__append_21) $(am__append_22)\n+\t$(am__append_21) $(am__append_22) $(am__append_24) \\\n+\t$(am__append_28)\n \n # Add a file to this variable if you want it to be built for testing.\n check_DATA = $(am__append_5) $(am__append_19) $(am__append_23)\n@@ -1078,7 +1114,21 @@ libbacktrace_TEST_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) -g\n @HAVE_DWARF5_TRUE@@NATIVE_TRUE@dwarf5_alloc_SOURCES = $(dwarf5_SOURCES)\n @HAVE_DWARF5_TRUE@@NATIVE_TRUE@dwarf5_alloc_CFLAGS = $(dwarf5_CFLAGS)\n @HAVE_DWARF5_TRUE@@NATIVE_TRUE@dwarf5_alloc_LDADD = libbacktrace_alloc.la\n-CLEANFILES = $(TESTS) *.debug elf_for_test.c edtest2_build.c gen_edtest2_build\n+@NATIVE_TRUE@mtest_SOURCES = mtest.c testlib.c\n+@NATIVE_TRUE@mtest_CFLAGS = $(libbacktrace_TEST_CFLAGS) -O\n+@NATIVE_TRUE@mtest_LDADD = libbacktrace.la\n+@HAVE_ELF_TRUE@xztest_SOURCES = xztest.c testlib.c\n+@HAVE_ELF_TRUE@xztest_CFLAGS = $(libbacktrace_TEST_CFLAGS) -DSRCDIR=\\\"$(srcdir)\\\"\n+@HAVE_ELF_TRUE@xztest_LDADD = libbacktrace.la $(am__append_26) \\\n+@HAVE_ELF_TRUE@\t$(CLOCK_GETTIME_LINK)\n+@HAVE_ELF_TRUE@xztest_alloc_SOURCES = $(xztest_SOURCES)\n+@HAVE_ELF_TRUE@xztest_alloc_CFLAGS = $(xztest_CFLAGS)\n+@HAVE_ELF_TRUE@xztest_alloc_LDADD = libbacktrace_alloc.la \\\n+@HAVE_ELF_TRUE@\t$(am__append_27) $(CLOCK_GETTIME_LINK)\n+CLEANFILES = \\\n+\t$(TESTS) *.debug elf_for_test.c edtest2_build.c gen_edtest2_build \\\n+\t*.dsyms *.fsyms *.keepsyms *.dbg *.mdbg *.mdbg.xz *.strip\n+\n \n # We can't use automake's automatic dependency tracking, because it\n # breaks when using bootstrap-lean.  Automatic dependency tracking\n@@ -1259,6 +1309,10 @@ edtest_alloc$(EXEEXT): $(edtest_alloc_OBJECTS) $(edtest_alloc_DEPENDENCIES) $(EX\n \t@rm -f edtest_alloc$(EXEEXT)\n \t$(AM_V_CCLD)$(edtest_alloc_LINK) $(edtest_alloc_OBJECTS) $(edtest_alloc_LDADD) $(LIBS)\n \n+mtest$(EXEEXT): $(mtest_OBJECTS) $(mtest_DEPENDENCIES) $(EXTRA_mtest_DEPENDENCIES) \n+\t@rm -f mtest$(EXEEXT)\n+\t$(AM_V_CCLD)$(mtest_LINK) $(mtest_OBJECTS) $(mtest_LDADD) $(LIBS)\n+\n stest$(EXEEXT): $(stest_OBJECTS) $(stest_DEPENDENCIES) $(EXTRA_stest_DEPENDENCIES) \n \t@rm -f stest$(EXEEXT)\n \t$(AM_V_CCLD)$(stest_LINK) $(stest_OBJECTS) $(stest_LDADD) $(LIBS)\n@@ -1311,6 +1365,14 @@ unittest_alloc$(EXEEXT): $(unittest_alloc_OBJECTS) $(unittest_alloc_DEPENDENCIES\n \t@rm -f unittest_alloc$(EXEEXT)\n \t$(AM_V_CCLD)$(unittest_alloc_LINK) $(unittest_alloc_OBJECTS) $(unittest_alloc_LDADD) $(LIBS)\n \n+xztest$(EXEEXT): $(xztest_OBJECTS) $(xztest_DEPENDENCIES) $(EXTRA_xztest_DEPENDENCIES) \n+\t@rm -f xztest$(EXEEXT)\n+\t$(AM_V_CCLD)$(xztest_LINK) $(xztest_OBJECTS) $(xztest_LDADD) $(LIBS)\n+\n+xztest_alloc$(EXEEXT): $(xztest_alloc_OBJECTS) $(xztest_alloc_DEPENDENCIES) $(EXTRA_xztest_alloc_DEPENDENCIES) \n+\t@rm -f xztest_alloc$(EXEEXT)\n+\t$(AM_V_CCLD)$(xztest_alloc_LINK) $(xztest_alloc_OBJECTS) $(xztest_alloc_LDADD) $(LIBS)\n+\n ztest$(EXEEXT): $(ztest_OBJECTS) $(ztest_DEPENDENCIES) $(EXTRA_ztest_DEPENDENCIES) \n \t@rm -f ztest$(EXEEXT)\n \t$(AM_V_CCLD)$(ztest_LINK) $(ztest_OBJECTS) $(ztest_LDADD) $(LIBS)\n@@ -1514,6 +1576,18 @@ edtest_alloc-testlib.o: testlib.c\n edtest_alloc-testlib.obj: testlib.c\n \t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(edtest_alloc_CFLAGS) $(CFLAGS) -c -o edtest_alloc-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n \n+mtest-mtest.o: mtest.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(mtest_CFLAGS) $(CFLAGS) -c -o mtest-mtest.o `test -f 'mtest.c' || echo '$(srcdir)/'`mtest.c\n+\n+mtest-mtest.obj: mtest.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(mtest_CFLAGS) $(CFLAGS) -c -o mtest-mtest.obj `if test -f 'mtest.c'; then $(CYGPATH_W) 'mtest.c'; else $(CYGPATH_W) '$(srcdir)/mtest.c'; fi`\n+\n+mtest-testlib.o: testlib.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(mtest_CFLAGS) $(CFLAGS) -c -o mtest-testlib.o `test -f 'testlib.c' || echo '$(srcdir)/'`testlib.c\n+\n+mtest-testlib.obj: testlib.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(mtest_CFLAGS) $(CFLAGS) -c -o mtest-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n+\n stest-stest.o: stest.c\n \t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(stest_CFLAGS) $(CFLAGS) -c -o stest-stest.o `test -f 'stest.c' || echo '$(srcdir)/'`stest.c\n \n@@ -1658,6 +1732,30 @@ unittest_alloc-testlib.o: testlib.c\n unittest_alloc-testlib.obj: testlib.c\n \t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(unittest_alloc_CFLAGS) $(CFLAGS) -c -o unittest_alloc-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n \n+xztest-xztest.o: xztest.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xztest_CFLAGS) $(CFLAGS) -c -o xztest-xztest.o `test -f 'xztest.c' || echo '$(srcdir)/'`xztest.c\n+\n+xztest-xztest.obj: xztest.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xztest_CFLAGS) $(CFLAGS) -c -o xztest-xztest.obj `if test -f 'xztest.c'; then $(CYGPATH_W) 'xztest.c'; else $(CYGPATH_W) '$(srcdir)/xztest.c'; fi`\n+\n+xztest-testlib.o: testlib.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xztest_CFLAGS) $(CFLAGS) -c -o xztest-testlib.o `test -f 'testlib.c' || echo '$(srcdir)/'`testlib.c\n+\n+xztest-testlib.obj: testlib.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xztest_CFLAGS) $(CFLAGS) -c -o xztest-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n+\n+xztest_alloc-xztest.o: xztest.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xztest_alloc_CFLAGS) $(CFLAGS) -c -o xztest_alloc-xztest.o `test -f 'xztest.c' || echo '$(srcdir)/'`xztest.c\n+\n+xztest_alloc-xztest.obj: xztest.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xztest_alloc_CFLAGS) $(CFLAGS) -c -o xztest_alloc-xztest.obj `if test -f 'xztest.c'; then $(CYGPATH_W) 'xztest.c'; else $(CYGPATH_W) '$(srcdir)/xztest.c'; fi`\n+\n+xztest_alloc-testlib.o: testlib.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xztest_alloc_CFLAGS) $(CFLAGS) -c -o xztest_alloc-testlib.o `test -f 'testlib.c' || echo '$(srcdir)/'`testlib.c\n+\n+xztest_alloc-testlib.obj: testlib.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xztest_alloc_CFLAGS) $(CFLAGS) -c -o xztest_alloc-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n+\n ztest-ztest.o: ztest.c\n \t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ztest_CFLAGS) $(CFLAGS) -c -o ztest-ztest.o `test -f 'ztest.c' || echo '$(srcdir)/'`ztest.c\n \n@@ -1933,6 +2031,13 @@ btest_gnudebuglink.log: btest_gnudebuglink\n \t--log-file $$b.log --trs-file $$b.trs \\\n \t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n \t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n+mtest_minidebug.log: mtest_minidebug\n+\t@p='mtest_minidebug'; \\\n+\tb='mtest_minidebug'; \\\n+\t$(am__check_pre) $(LOG_DRIVER) --test-name \"$$f\" \\\n+\t--log-file $$b.log --trs-file $$b.trs \\\n+\t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n+\t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n test_elf_32.log: test_elf_32$(EXEEXT)\n \t@p='test_elf_32$(EXEEXT)'; \\\n \tb='test_elf_32'; \\\n@@ -2115,6 +2220,27 @@ dwarf5_alloc.log: dwarf5_alloc$(EXEEXT)\n \t--log-file $$b.log --trs-file $$b.trs \\\n \t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n \t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n+mtest.log: mtest$(EXEEXT)\n+\t@p='mtest$(EXEEXT)'; \\\n+\tb='mtest'; \\\n+\t$(am__check_pre) $(LOG_DRIVER) --test-name \"$$f\" \\\n+\t--log-file $$b.log --trs-file $$b.trs \\\n+\t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n+\t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n+xztest.log: xztest$(EXEEXT)\n+\t@p='xztest$(EXEEXT)'; \\\n+\tb='xztest'; \\\n+\t$(am__check_pre) $(LOG_DRIVER) --test-name \"$$f\" \\\n+\t--log-file $$b.log --trs-file $$b.trs \\\n+\t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n+\t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n+xztest_alloc.log: xztest_alloc$(EXEEXT)\n+\t@p='xztest_alloc$(EXEEXT)'; \\\n+\tb='xztest_alloc'; \\\n+\t$(am__check_pre) $(LOG_DRIVER) --test-name \"$$f\" \\\n+\t--log-file $$b.log --trs-file $$b.trs \\\n+\t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n+\t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n .test.log:\n \t@p='$<'; \\\n \t$(am__set_b); \\\n@@ -2323,18 +2449,31 @@ uninstall-am:\n @NATIVE_TRUE@\t  $<\n @NATIVE_TRUE@\t$(OBJCOPY) --strip-debug $< $@\n \n+@HAVE_MINIDEBUG_TRUE@@NATIVE_TRUE@%_minidebug: %\n+@HAVE_MINIDEBUG_TRUE@@NATIVE_TRUE@\t$(NM) -D $< -P --defined-only | $(AWK) '{ print $$1 }' | sort > $<.dsyms\n+@HAVE_MINIDEBUG_TRUE@@NATIVE_TRUE@\t$(NM) $< -P --defined-only | $(AWK) '{ if ($$2 == \"T\" || $$2 == \"t\" || $$2 == \"D\") print $$1 }' | sort > $<.fsyms\n+@HAVE_MINIDEBUG_TRUE@@NATIVE_TRUE@\t$(COMM) -13 $<.dsyms $<.fsyms > $<.keepsyms\n+@HAVE_MINIDEBUG_TRUE@@NATIVE_TRUE@\t$(OBJCOPY) --only-keep-debug $< $<.dbg\n+@HAVE_MINIDEBUG_TRUE@@NATIVE_TRUE@\t$(OBJCOPY) -S --remove-section .gdb_index --remove-section .comment --keep-symbols=$<.keepsyms $<.dbg $<.mdbg\n+@HAVE_MINIDEBUG_TRUE@@NATIVE_TRUE@\t$(OBJCOPY) --strip-all --remove-section ..comment $< $<.strip\n+@HAVE_MINIDEBUG_TRUE@@NATIVE_TRUE@\trm -f $<.mdbg.xz\n+@HAVE_MINIDEBUG_TRUE@@NATIVE_TRUE@\t$(XZ) $<.mdbg\n+@HAVE_MINIDEBUG_TRUE@@NATIVE_TRUE@\t$(OBJCOPY) --add-section .gnu_debugdata=$<.mdbg.xz $<.strip\n+@HAVE_MINIDEBUG_TRUE@@NATIVE_TRUE@\tmv $<.strip $@\n+\n clean-local:\n \t-rm -rf usr\n alloc.lo: config.h backtrace.h internal.h\n backtrace.lo: config.h backtrace.h internal.h\n-btest.lo: (INCDIR)/filenames.h backtrace.h backtrace-supported.h\n+btest.lo: $(INCDIR)/filenames.h backtrace.h backtrace-supported.h\n dwarf.lo: config.h $(INCDIR)/dwarf2.h $(INCDIR)/dwarf2.def \\\n \t$(INCDIR)/filenames.h backtrace.h internal.h\n elf.lo: config.h backtrace.h internal.h\n fileline.lo: config.h backtrace.h internal.h\n macho.lo: config.h backtrace.h internal.h\n mmap.lo: config.h backtrace.h internal.h\n mmapio.lo: config.h backtrace.h internal.h\n+mtest.lo: backtrace.h backtrace-supported.h\n nounwind.lo: config.h internal.h\n pecoff.lo: config.h backtrace.h internal.h\n posix.lo: config.h backtrace.h internal.h\n@@ -2346,6 +2485,8 @@ stest.lo: config.h backtrace.h internal.h\n state.lo: config.h backtrace.h backtrace-supported.h internal.h\n unknown.lo: config.h backtrace.h internal.h\n xcoff.lo: config.h backtrace.h internal.h\n+xztest.lo: config.h backtrace.h backtrace-supported.h internal.h testlib.h\n+ztest.lo: config.h backtrace.h backtrace-supported.h internal.h testlib.h\n \n # GNU Make needs to see an explicit $(MAKE) variable in the command it\n # runs to enable its job server during parallel builds.  Hence the"}, {"sha": "cdb416e6406129911d2a149d2f4339dd86ebc3dc", "filename": "libbacktrace/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfig.h.in?ref=05f40bc4c116ba48843728201bc7290a5e518598", "patch": "@@ -46,6 +46,9 @@\n    <sys/sysctl.h>. */\n #undef HAVE_KERN_PROC_ARGS\n \n+/* Define if -llzma is available. */\n+#undef HAVE_LIBLZMA\n+\n /* Define to 1 if you have the <link.h> header file. */\n #undef HAVE_LINK_H\n "}, {"sha": "031a15602c628784be3ccfd42e27d9d7491ad6bc", "filename": "libbacktrace/configure", "status": "modified", "additions": 221, "deletions": 3, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=05f40bc4c116ba48843728201bc7290a5e518598", "patch": "@@ -635,6 +635,16 @@ LTLIBOBJS\n LIBOBJS\n NATIVE_FALSE\n NATIVE_TRUE\n+HAVE_LIBLZMA_FALSE\n+HAVE_LIBLZMA_TRUE\n+HAVE_MINIDEBUG_FALSE\n+HAVE_MINIDEBUG_TRUE\n+HAVE_COMM_FALSE\n+HAVE_COMM_TRUE\n+COMM\n+HAVE_XZ_FALSE\n+HAVE_XZ_TRUE\n+XZ\n HAVE_DSYMUTIL_FALSE\n HAVE_DSYMUTIL_TRUE\n HAVE_OBJCOPY_DEBUGLINK_FALSE\n@@ -804,7 +814,8 @@ LIBS\n CPPFLAGS\n CPP\n OBJCOPY\n-DSYMUTIL'\n+DSYMUTIL\n+NM'\n \n \n # Initialize some variables set by options.\n@@ -1460,6 +1471,7 @@ Some influential environment variables:\n   CPP         C preprocessor\n   OBJCOPY     location of objcopy\n   DSYMUTIL    location of dsymutil\n+  NM          location of nm\n \n Use these variables to override the choices made by `configure' or to help\n it to find libraries and programs with nonstandard names/locations.\n@@ -11505,7 +11517,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11508 \"configure\"\n+#line 11520 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11611,7 +11623,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11614 \"configure\"\n+#line 11626 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -13857,6 +13869,196 @@ else\n fi\n \n \n+\n+# Extract the first word of \"nm\", so it can be a program name with args.\n+set dummy nm; ac_word=$2\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n+$as_echo_n \"checking for $ac_word... \" >&6; }\n+if ${ac_cv_prog_NM+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"$NM\"; then\n+  ac_cv_prog_NM=\"$NM\" # Let the user override the test.\n+else\n+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n+    ac_cv_prog_NM=\"nm\"\n+    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n+    break 2\n+  fi\n+done\n+  done\n+IFS=$as_save_IFS\n+\n+fi\n+fi\n+NM=$ac_cv_prog_NM\n+if test -n \"$NM\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $NM\" >&5\n+$as_echo \"$NM\" >&6; }\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+fi\n+\n+\n+\n+# Extract the first word of \"xz\", so it can be a program name with args.\n+set dummy xz; ac_word=$2\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n+$as_echo_n \"checking for $ac_word... \" >&6; }\n+if ${ac_cv_prog_XZ+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"$XZ\"; then\n+  ac_cv_prog_XZ=\"$XZ\" # Let the user override the test.\n+else\n+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n+    ac_cv_prog_XZ=\"xz\"\n+    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n+    break 2\n+  fi\n+done\n+  done\n+IFS=$as_save_IFS\n+\n+fi\n+fi\n+XZ=$ac_cv_prog_XZ\n+if test -n \"$XZ\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $XZ\" >&5\n+$as_echo \"$XZ\" >&6; }\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+fi\n+\n+\n+ if test \"$XZ\" != \"\"; then\n+  HAVE_XZ_TRUE=\n+  HAVE_XZ_FALSE='#'\n+else\n+  HAVE_XZ_TRUE='#'\n+  HAVE_XZ_FALSE=\n+fi\n+\n+# Extract the first word of \"comm\", so it can be a program name with args.\n+set dummy comm; ac_word=$2\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n+$as_echo_n \"checking for $ac_word... \" >&6; }\n+if ${ac_cv_prog_COMM+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"$COMM\"; then\n+  ac_cv_prog_COMM=\"$COMM\" # Let the user override the test.\n+else\n+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n+    ac_cv_prog_COMM=\"comm\"\n+    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n+    break 2\n+  fi\n+done\n+  done\n+IFS=$as_save_IFS\n+\n+fi\n+fi\n+COMM=$ac_cv_prog_COMM\n+if test -n \"$COMM\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $COMM\" >&5\n+$as_echo \"$COMM\" >&6; }\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+fi\n+\n+\n+ if test \"$COMM\" != \"\"; then\n+  HAVE_COMM_TRUE=\n+  HAVE_COMM_FALSE='#'\n+else\n+  HAVE_COMM_TRUE='#'\n+  HAVE_COMM_FALSE=\n+fi\n+\n+\n+ if test \"${with_target_subdir}\" = \"\" -a \"$FORMAT_FILE\" = \"elf.lo\" -a \"${OBJCOPY}\" != \"\" -a \"${NM}\" != \"\" -a \"${XZ}\" != \"\" -a \"${COMM}\" != \"\"; then\n+  HAVE_MINIDEBUG_TRUE=\n+  HAVE_MINIDEBUG_FALSE='#'\n+else\n+  HAVE_MINIDEBUG_TRUE='#'\n+  HAVE_MINIDEBUG_FALSE=\n+fi\n+\n+\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for lzma_auto_decoder in -llzma\" >&5\n+$as_echo_n \"checking for lzma_auto_decoder in -llzma... \" >&6; }\n+if ${ac_cv_lib_lzma_lzma_auto_decoder+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-llzma  $LIBS\"\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+/* Override any GCC internal prototype to avoid an error.\n+   Use char because int might match the return type of a GCC\n+   builtin and then its argument prototype would still apply.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+char lzma_auto_decoder ();\n+int\n+main ()\n+{\n+return lzma_auto_decoder ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  ac_cv_lib_lzma_lzma_auto_decoder=yes\n+else\n+  ac_cv_lib_lzma_lzma_auto_decoder=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_lzma_lzma_auto_decoder\" >&5\n+$as_echo \"$ac_cv_lib_lzma_lzma_auto_decoder\" >&6; }\n+if test \"x$ac_cv_lib_lzma_lzma_auto_decoder\" = xyes; then :\n+\n+$as_echo \"#define HAVE_LIBLZMA 1\" >>confdefs.h\n+\n+fi\n+\n+ if test \"$ac_cv_lib_lzma_lzma_auto_decoder\" = yes; then\n+  HAVE_LIBLZMA_TRUE=\n+  HAVE_LIBLZMA_FALSE='#'\n+else\n+  HAVE_LIBLZMA_TRUE='#'\n+  HAVE_LIBLZMA_FALSE=\n+fi\n+\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether tests can run\" >&5\n $as_echo_n \"checking whether tests can run... \" >&6; }\n if ${libbacktrace_cv_sys_native+:} false; then :\n@@ -14073,6 +14275,22 @@ if test -z \"${HAVE_DSYMUTIL_TRUE}\" && test -z \"${HAVE_DSYMUTIL_FALSE}\"; then\n   as_fn_error $? \"conditional \\\"HAVE_DSYMUTIL\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${HAVE_XZ_TRUE}\" && test -z \"${HAVE_XZ_FALSE}\"; then\n+  as_fn_error $? \"conditional \\\"HAVE_XZ\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n+if test -z \"${HAVE_COMM_TRUE}\" && test -z \"${HAVE_COMM_FALSE}\"; then\n+  as_fn_error $? \"conditional \\\"HAVE_COMM\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n+if test -z \"${HAVE_MINIDEBUG_TRUE}\" && test -z \"${HAVE_MINIDEBUG_FALSE}\"; then\n+  as_fn_error $? \"conditional \\\"HAVE_MINIDEBUG\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n+if test -z \"${HAVE_LIBLZMA_TRUE}\" && test -z \"${HAVE_LIBLZMA_FALSE}\"; then\n+  as_fn_error $? \"conditional \\\"HAVE_LIBLZMA\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${NATIVE_TRUE}\" && test -z \"${NATIVE_FALSE}\"; then\n   as_fn_error $? \"conditional \\\"NATIVE\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "0659ea604848e59893e19b2595521e1af3a64fcb", "filename": "libbacktrace/configure.ac", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=05f40bc4c116ba48843728201bc7290a5e518598", "patch": "@@ -512,6 +512,21 @@ AC_ARG_VAR(DSYMUTIL, [location of dsymutil])\n AC_CHECK_PROG(DSYMUTIL, dsymutil, dsymutil)\n AM_CONDITIONAL(HAVE_DSYMUTIL, test -n \"${DSYMUTIL}\")\n \n+AC_ARG_VAR(NM, [location of nm])\n+AC_CHECK_PROG(NM, nm, nm)\n+\n+AC_CHECK_PROG(XZ, xz, xz)\n+AM_CONDITIONAL(HAVE_XZ, test \"$XZ\" != \"\")\n+AC_CHECK_PROG(COMM, comm, comm)\n+AM_CONDITIONAL(HAVE_COMM, test \"$COMM\" != \"\")\n+\n+AM_CONDITIONAL(HAVE_MINIDEBUG,\n+  test \"${with_target_subdir}\" = \"\" -a \"$FORMAT_FILE\" = \"elf.lo\" -a \"${OBJCOPY}\" != \"\" -a \"${NM}\" != \"\" -a \"${XZ}\" != \"\" -a \"${COMM}\" != \"\")\n+\n+AC_CHECK_LIB([lzma], [lzma_auto_decoder],\n+    [AC_DEFINE(HAVE_LIBLZMA, 1, [Define if -llzma is available.])])\n+AM_CONDITIONAL(HAVE_LIBLZMA, test \"$ac_cv_lib_lzma_lzma_auto_decoder\" = yes)\n+\n AC_CACHE_CHECK([whether tests can run],\n   [libbacktrace_cv_sys_native],\n   [AC_RUN_IFELSE([AC_LANG_PROGRAM([], [return 0;])],"}, {"sha": "dd00470824687774e4118e4c0d08e279682c7357", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 1551, "deletions": 150, "changes": 1701, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=05f40bc4c116ba48843728201bc7290a5e518598", "patch": "@@ -390,6 +390,14 @@ struct elf_syminfo_data\n   size_t count;\n };\n \n+/* A view that works for either a file or memory.  */\n+\n+struct elf_view\n+{\n+  struct backtrace_view view;\n+  int release; /* If non-zero, must call backtrace_release_view.  */\n+};\n+\n /* Information about PowerPC64 ELFv1 .opd section.  */\n \n struct elf_ppc64_opd_data\n@@ -401,9 +409,48 @@ struct elf_ppc64_opd_data\n   /* Size of the .opd section.  */\n   size_t size;\n   /* Corresponding section view.  */\n-  struct backtrace_view view;\n+  struct elf_view view;\n };\n \n+/* Create a view of SIZE bytes from DESCRIPTOR/MEMORY at OFFSET.  */\n+\n+static int\n+elf_get_view (struct backtrace_state *state, int descriptor,\n+\t      const unsigned char *memory, size_t memory_size, off_t offset,\n+\t      uint64_t size, backtrace_error_callback error_callback,\n+\t      void *data, struct elf_view *view)\n+{\n+  if (memory == NULL)\n+    {\n+      view->release = 1;\n+      return backtrace_get_view (state, descriptor, offset, size,\n+\t\t\t\t error_callback, data, &view->view);\n+    }\n+  else\n+    {\n+      if ((uint64_t) offset + size > (uint64_t) memory_size)\n+\t{\n+\t  error_callback (data, \"out of range for in-memory file\", 0);\n+\t  return 0;\n+\t}\n+      view->view.data = (const void *) (memory + offset);\n+      view->view.base = NULL;\n+      view->view.len = size;\n+      view->release = 0;\n+      return 1;\n+    }\n+}\n+\n+/* Release a view read by elf_get_view.  */\n+\n+static void\n+elf_release_view (struct backtrace_state *state, struct elf_view *view,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  if (view->release)\n+    backtrace_release_view (state, &view->view, error_callback, data);\n+}\n+\n /* Compute the CRC-32 of BUF/LEN.  This uses the CRC used for\n    .gnu_debuglink files.  */\n \n@@ -1035,7 +1082,7 @@ elf_open_debugfile_by_debuglink (struct backtrace_state *state,\n    when this code is compiled with -g.  */\n \n static void\n-elf_zlib_failed(void)\n+elf_uncompress_failed(void)\n {\n }\n \n@@ -1062,7 +1109,7 @@ elf_zlib_fetch (const unsigned char **ppin, const unsigned char *pinend,\n \n   if (unlikely (pinend - pin < 4))\n     {\n-      elf_zlib_failed ();\n+      elf_uncompress_failed ();\n       return 0;\n     }\n \n@@ -1192,7 +1239,7 @@ elf_zlib_inflate_table (unsigned char *codes, size_t codes_len,\n     {\n       if (unlikely (codes[i] >= 16))\n \t{\n-\t  elf_zlib_failed ();\n+\t  elf_uncompress_failed ();\n \t  return 0;\n \t}\n \n@@ -1229,7 +1276,7 @@ elf_zlib_inflate_table (unsigned char *codes, size_t codes_len,\n \n       if (unlikely (jcnt > (1U << j)))\n \t{\n-\t  elf_zlib_failed ();\n+\t  elf_uncompress_failed ();\n \t  return 0;\n \t}\n \n@@ -1249,7 +1296,7 @@ elf_zlib_inflate_table (unsigned char *codes, size_t codes_len,\n \n \t  if (unlikely ((val & ~HUFFMAN_VALUE_MASK) != 0))\n \t    {\n-\t      elf_zlib_failed ();\n+\t      elf_uncompress_failed ();\n \t      return 0;\n \t    }\n \n@@ -1265,7 +1312,7 @@ elf_zlib_inflate_table (unsigned char *codes, size_t codes_len,\n \t    {\n \t      if (unlikely (table[ind] != 0))\n \t\t{\n-\t\t  elf_zlib_failed ();\n+\t\t  elf_uncompress_failed ();\n \t\t  return 0;\n \t\t}\n \t      table[ind] = tval;\n@@ -1353,7 +1400,7 @@ elf_zlib_inflate_table (unsigned char *codes, size_t codes_len,\n \t}\n       if (unlikely (jcnt != 0))\n \t{\n-\t  elf_zlib_failed ();\n+\t  elf_uncompress_failed ();\n \t  return 0;\n \t}\n     }\n@@ -1406,7 +1453,7 @@ elf_zlib_inflate_table (unsigned char *codes, size_t codes_len,\n \t\t  if (unlikely ((next_secondary & HUFFMAN_VALUE_MASK)\n \t\t\t\t!= next_secondary))\n \t\t    {\n-\t\t      elf_zlib_failed ();\n+\t\t      elf_uncompress_failed ();\n \t\t      return 0;\n \t\t    }\n \n@@ -1424,15 +1471,15 @@ elf_zlib_inflate_table (unsigned char *codes, size_t codes_len,\n \t\t  if (unlikely ((tprimary & (1U << HUFFMAN_SECONDARY_SHIFT))\n \t\t\t\t== 0))\n \t\t    {\n-\t\t      elf_zlib_failed ();\n+\t\t      elf_uncompress_failed ();\n \t\t      return 0;\n \t\t    }\n \t\t  secondary = tprimary & HUFFMAN_VALUE_MASK;\n \t\t  secondary_bits = ((tprimary >> HUFFMAN_BITS_SHIFT)\n \t\t\t\t    & HUFFMAN_BITS_MASK);\n \t\t  if (unlikely (secondary_bits < j - 8))\n \t\t    {\n-\t\t      elf_zlib_failed ();\n+\t\t      elf_uncompress_failed ();\n \t\t      return 0;\n \t\t    }\n \t\t}\n@@ -1448,7 +1495,7 @@ elf_zlib_inflate_table (unsigned char *codes, size_t codes_len,\n \t    {\n \t      if (unlikely (table[secondary + 0x100 + ind] != 0))\n \t\t{\n-\t\t  elf_zlib_failed ();\n+\t\t  elf_uncompress_failed ();\n \t\t  return 0;\n \t\t}\n \t      table[secondary + 0x100 + ind] = tval;\n@@ -1664,28 +1711,28 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n       if (unlikely ((pin[0] & 0xf) != 8)) /* 8 is zlib encoding.  */\n \t{\n \t  /* Unknown compression method.  */\n-\t  elf_zlib_failed ();\n+\t  elf_uncompress_failed ();\n \t  return 0;\n \t}\n       if (unlikely ((pin[0] >> 4) > 7))\n \t{\n \t  /* Window size too large.  Other than this check, we don't\n \t     care about the window size.  */\n-\t  elf_zlib_failed ();\n+\t  elf_uncompress_failed ();\n \t  return 0;\n \t}\n       if (unlikely ((pin[1] & 0x20) != 0))\n \t{\n \t  /* Stream expects a predefined dictionary, but we have no\n \t     dictionary.  */\n-\t  elf_zlib_failed ();\n+\t  elf_uncompress_failed ();\n \t  return 0;\n \t}\n       val = (pin[0] << 8) | pin[1];\n       if (unlikely (val % 31 != 0))\n \t{\n \t  /* Header check failure.  */\n-\t  elf_zlib_failed ();\n+\t  elf_uncompress_failed ();\n \t  return 0;\n \t}\n       pin += 2;\n@@ -1722,7 +1769,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t  if (unlikely (type == 3))\n \t    {\n \t      /* Invalid block type.  */\n-\t      elf_zlib_failed ();\n+\t      elf_uncompress_failed ();\n \t      return 0;\n \t    }\n \n@@ -1745,7 +1792,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t      if (unlikely ((pinend - pin) < 4))\n \t\t{\n \t\t  /* Missing length.  */\n-\t\t  elf_zlib_failed ();\n+\t\t  elf_uncompress_failed ();\n \t\t  return 0;\n \t\t}\n \t      len = pin[0] | (pin[1] << 8);\n@@ -1755,14 +1802,14 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t      if (unlikely (len != lenc))\n \t\t{\n \t\t  /* Corrupt data.  */\n-\t\t  elf_zlib_failed ();\n+\t\t  elf_uncompress_failed ();\n \t\t  return 0;\n \t\t}\n \t      if (unlikely (len > (unsigned int) (pinend - pin)\n \t\t\t    || len > (unsigned int) (poutend - pout)))\n \t\t{\n \t\t  /* Not enough space in buffers.  */\n-\t\t  elf_zlib_failed ();\n+\t\t  elf_uncompress_failed ();\n \t\t  return 0;\n \t\t}\n \t      memcpy (pout, pin, len);\n@@ -1812,7 +1859,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t      if (unlikely (nlit > 286 || ndist > 30))\n \t\t{\n \t\t  /* Values out of range.  */\n-\t\t  elf_zlib_failed ();\n+\t\t  elf_uncompress_failed ();\n \t\t  return 0;\n \t\t}\n \n@@ -1977,7 +2024,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t\t     a secondary table is never necessary.  */\n \t\t  if (unlikely ((t & (1U << HUFFMAN_SECONDARY_SHIFT)) != 0))\n \t\t    {\n-\t\t      elf_zlib_failed ();\n+\t\t      elf_uncompress_failed ();\n \t\t      return 0;\n \t\t    }\n \n@@ -1997,7 +2044,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \n \t\t      if (unlikely (plen == plenbase))\n \t\t\t{\n-\t\t\t  elf_zlib_failed ();\n+\t\t\t  elf_uncompress_failed ();\n \t\t\t  return 0;\n \t\t\t}\n \n@@ -2010,7 +2057,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t\t      bits -= 2;\n \t\t      if (unlikely ((unsigned int) (plenend - plen) < c))\n \t\t\t{\n-\t\t\t  elf_zlib_failed ();\n+\t\t\t  elf_uncompress_failed ();\n \t\t\t  return 0;\n \t\t\t}\n \n@@ -2045,7 +2092,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t\t      bits -= 3;\n \t\t      if (unlikely ((unsigned int) (plenend - plen) < c))\n \t\t\t{\n-\t\t\t  elf_zlib_failed ();\n+\t\t\t  elf_uncompress_failed ();\n \t\t\t  return 0;\n \t\t\t}\n \n@@ -2091,7 +2138,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t\t      bits -= 7;\n \t\t      if (unlikely ((unsigned int) (plenend - plen) < c))\n \t\t\t{\n-\t\t\t  elf_zlib_failed ();\n+\t\t\t  elf_uncompress_failed ();\n \t\t\t  return 0;\n \t\t\t}\n \n@@ -2100,7 +2147,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      elf_zlib_failed ();\n+\t\t      elf_uncompress_failed ();\n \t\t      return 0;\n \t\t    }\n \t\t}\n@@ -2110,7 +2157,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t      plen = plenbase;\n \t      if (unlikely (plen[256] == 0))\n \t\t{\n-\t\t  elf_zlib_failed ();\n+\t\t  elf_uncompress_failed ();\n \t\t  return 0;\n \t\t}\n \n@@ -2162,7 +2209,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t\t{\n \t\t  if (unlikely (pout == poutend))\n \t\t    {\n-\t\t      elf_zlib_failed ();\n+\t\t      elf_uncompress_failed ();\n \t\t      return 0;\n \t\t    }\n \n@@ -2191,7 +2238,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t\t    len = 258;\n \t\t  else if (unlikely (lit > 285))\n \t\t    {\n-\t\t      elf_zlib_failed ();\n+\t\t      elf_uncompress_failed ();\n \t\t      return 0;\n \t\t    }\n \t\t  else\n@@ -2244,13 +2291,13 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \n \t\t      if (unlikely (pout == porigout))\n \t\t\t{\n-\t\t\t  elf_zlib_failed ();\n+\t\t\t  elf_uncompress_failed ();\n \t\t\t  return 0;\n \t\t\t}\n \n \t\t      if (unlikely ((unsigned int) (poutend - pout) < len))\n \t\t\t{\n-\t\t\t  elf_zlib_failed ();\n+\t\t\t  elf_uncompress_failed ();\n \t\t\t  return 0;\n \t\t\t}\n \n@@ -2259,7 +2306,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \t\t    }\n \t\t  else if (unlikely (dist > 29))\n \t\t    {\n-\t\t      elf_zlib_failed ();\n+\t\t      elf_uncompress_failed ();\n \t\t      return 0;\n \t\t    }\n \t\t  else\n@@ -2290,13 +2337,13 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n \n \t\t      if (unlikely ((unsigned int) (pout - porigout) < dist))\n \t\t\t{\n-\t\t\t  elf_zlib_failed ();\n+\t\t\t  elf_uncompress_failed ();\n \t\t\t  return 0;\n \t\t\t}\n \n \t\t      if (unlikely ((unsigned int) (poutend - pout) < len))\n \t\t\t{\n-\t\t\t  elf_zlib_failed ();\n+\t\t\t  elf_uncompress_failed ();\n \t\t\t  return 0;\n \t\t\t}\n \n@@ -2326,7 +2373,7 @@ elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n   /* We should have filled the output buffer.  */\n   if (unlikely (pout != poutend))\n     {\n-      elf_zlib_failed ();\n+      elf_uncompress_failed ();\n       return 0;\n     }\n \n@@ -2453,7 +2500,7 @@ elf_zlib_verify_checksum (const unsigned char *checkbytes,\n \n   if (unlikely ((s2 << 16) + s1 != cksum))\n     {\n-      elf_zlib_failed ();\n+      elf_uncompress_failed ();\n       return 0;\n     }\n \n@@ -2608,6 +2655,1311 @@ backtrace_uncompress_zdebug (struct backtrace_state *state,\n   return ret;\n }\n \n+/* Number of LZMA states.  */\n+#define LZMA_STATES (12)\n+\n+/* Number of LZMA position states.  The pb value of the property byte\n+   is the number of bits to include in these states, and the maximum\n+   value of pb is 4.  */\n+#define LZMA_POS_STATES (16)\n+\n+/* Number of LZMA distance states.  These are used match distances\n+   with a short match length: up to 4 bytes.  */\n+#define LZMA_DIST_STATES (4)\n+\n+/* Number of LZMA distance slots.  LZMA uses six bits to encode larger\n+   match lengths, so 1 << 6 possible probabilities.  */\n+#define LZMA_DIST_SLOTS (64)\n+\n+/* LZMA distances 0 to 3 are encoded directly, larger values use a\n+   probability model.  */\n+#define LZMA_DIST_MODEL_START (4)\n+\n+/* The LZMA probability model ends at 14.  */\n+#define LZMA_DIST_MODEL_END (14)\n+\n+/* LZMA distance slots for distances less than 127.  */\n+#define LZMA_FULL_DISTANCES (128)\n+\n+/* LZMA uses four alignment bits.  */\n+#define LZMA_ALIGN_SIZE (16)\n+\n+/* LZMA match length is encoded with 4, 5, or 10 bits, some of which\n+   are already known.  */\n+#define LZMA_LEN_LOW_SYMBOLS (8)\n+#define LZMA_LEN_MID_SYMBOLS (8)\n+#define LZMA_LEN_HIGH_SYMBOLS (256)\n+\n+/* LZMA literal encoding.  */\n+#define LZMA_LITERAL_CODERS_MAX (16)\n+#define LZMA_LITERAL_CODER_SIZE (0x300)\n+\n+/* LZMA is based on a large set of probabilities, each managed\n+   independently.  Each probability is an 11 bit number that we store\n+   in a uint16_t.  We use a single large array of probabilities.  */\n+\n+/* Lengths of entries in the LZMA probabilities array.  The names used\n+   here are copied from the Linux kernel implementation.  */\n+\n+#define LZMA_PROB_IS_MATCH_LEN (LZMA_STATES * LZMA_POS_STATES)\n+#define LZMA_PROB_IS_REP_LEN LZMA_STATES\n+#define LZMA_PROB_IS_REP0_LEN LZMA_STATES\n+#define LZMA_PROB_IS_REP1_LEN LZMA_STATES\n+#define LZMA_PROB_IS_REP2_LEN LZMA_STATES\n+#define LZMA_PROB_IS_REP0_LONG_LEN (LZMA_STATES * LZMA_POS_STATES)\n+#define LZMA_PROB_DIST_SLOT_LEN (LZMA_DIST_STATES * LZMA_DIST_SLOTS)\n+#define LZMA_PROB_DIST_SPECIAL_LEN (LZMA_FULL_DISTANCES - LZMA_DIST_MODEL_END)\n+#define LZMA_PROB_DIST_ALIGN_LEN LZMA_ALIGN_SIZE\n+#define LZMA_PROB_MATCH_LEN_CHOICE_LEN 1\n+#define LZMA_PROB_MATCH_LEN_CHOICE2_LEN 1\n+#define LZMA_PROB_MATCH_LEN_LOW_LEN (LZMA_POS_STATES * LZMA_LEN_LOW_SYMBOLS)\n+#define LZMA_PROB_MATCH_LEN_MID_LEN (LZMA_POS_STATES * LZMA_LEN_MID_SYMBOLS)\n+#define LZMA_PROB_MATCH_LEN_HIGH_LEN LZMA_LEN_HIGH_SYMBOLS\n+#define LZMA_PROB_REP_LEN_CHOICE_LEN 1\n+#define LZMA_PROB_REP_LEN_CHOICE2_LEN 1\n+#define LZMA_PROB_REP_LEN_LOW_LEN (LZMA_POS_STATES * LZMA_LEN_LOW_SYMBOLS)\n+#define LZMA_PROB_REP_LEN_MID_LEN (LZMA_POS_STATES * LZMA_LEN_MID_SYMBOLS)\n+#define LZMA_PROB_REP_LEN_HIGH_LEN LZMA_LEN_HIGH_SYMBOLS\n+#define LZMA_PROB_LITERAL_LEN \\\n+  (LZMA_LITERAL_CODERS_MAX * LZMA_LITERAL_CODER_SIZE)\n+\n+/* Offsets into the LZMA probabilities array.  This is mechanically\n+   generated from the above lengths.  */\n+\n+#define LZMA_PROB_IS_MATCH_OFFSET 0\n+#define LZMA_PROB_IS_REP_OFFSET \\\n+  (LZMA_PROB_IS_MATCH_OFFSET + LZMA_PROB_IS_MATCH_LEN)\n+#define LZMA_PROB_IS_REP0_OFFSET \\\n+  (LZMA_PROB_IS_REP_OFFSET + LZMA_PROB_IS_REP_LEN)\n+#define LZMA_PROB_IS_REP1_OFFSET \\\n+  (LZMA_PROB_IS_REP0_OFFSET + LZMA_PROB_IS_REP0_LEN)\n+#define LZMA_PROB_IS_REP2_OFFSET \\\n+  (LZMA_PROB_IS_REP1_OFFSET + LZMA_PROB_IS_REP1_LEN)\n+#define LZMA_PROB_IS_REP0_LONG_OFFSET \\\n+  (LZMA_PROB_IS_REP2_OFFSET + LZMA_PROB_IS_REP2_LEN)\n+#define LZMA_PROB_DIST_SLOT_OFFSET \\\n+  (LZMA_PROB_IS_REP0_LONG_OFFSET + LZMA_PROB_IS_REP0_LONG_LEN)\n+#define LZMA_PROB_DIST_SPECIAL_OFFSET \\\n+  (LZMA_PROB_DIST_SLOT_OFFSET + LZMA_PROB_DIST_SLOT_LEN)\n+#define LZMA_PROB_DIST_ALIGN_OFFSET \\\n+  (LZMA_PROB_DIST_SPECIAL_OFFSET + LZMA_PROB_DIST_SPECIAL_LEN)\n+#define LZMA_PROB_MATCH_LEN_CHOICE_OFFSET \\\n+  (LZMA_PROB_DIST_ALIGN_OFFSET + LZMA_PROB_DIST_ALIGN_LEN)\n+#define LZMA_PROB_MATCH_LEN_CHOICE2_OFFSET \\\n+  (LZMA_PROB_MATCH_LEN_CHOICE_OFFSET + LZMA_PROB_MATCH_LEN_CHOICE_LEN)\n+#define LZMA_PROB_MATCH_LEN_LOW_OFFSET \\\n+  (LZMA_PROB_MATCH_LEN_CHOICE2_OFFSET + LZMA_PROB_MATCH_LEN_CHOICE2_LEN)\n+#define LZMA_PROB_MATCH_LEN_MID_OFFSET \\\n+  (LZMA_PROB_MATCH_LEN_LOW_OFFSET + LZMA_PROB_MATCH_LEN_LOW_LEN)\n+#define LZMA_PROB_MATCH_LEN_HIGH_OFFSET \\\n+  (LZMA_PROB_MATCH_LEN_MID_OFFSET + LZMA_PROB_MATCH_LEN_MID_LEN)\n+#define LZMA_PROB_REP_LEN_CHOICE_OFFSET \\\n+  (LZMA_PROB_MATCH_LEN_HIGH_OFFSET + LZMA_PROB_MATCH_LEN_HIGH_LEN)\n+#define LZMA_PROB_REP_LEN_CHOICE2_OFFSET \\\n+  (LZMA_PROB_REP_LEN_CHOICE_OFFSET + LZMA_PROB_REP_LEN_CHOICE_LEN)\n+#define LZMA_PROB_REP_LEN_LOW_OFFSET \\\n+  (LZMA_PROB_REP_LEN_CHOICE2_OFFSET + LZMA_PROB_REP_LEN_CHOICE2_LEN)\n+#define LZMA_PROB_REP_LEN_MID_OFFSET \\\n+  (LZMA_PROB_REP_LEN_LOW_OFFSET + LZMA_PROB_REP_LEN_LOW_LEN)\n+#define LZMA_PROB_REP_LEN_HIGH_OFFSET \\\n+  (LZMA_PROB_REP_LEN_MID_OFFSET + LZMA_PROB_REP_LEN_MID_LEN)\n+#define LZMA_PROB_LITERAL_OFFSET \\\n+  (LZMA_PROB_REP_LEN_HIGH_OFFSET + LZMA_PROB_REP_LEN_HIGH_LEN)\n+\n+#define LZMA_PROB_TOTAL_COUNT \\\n+  (LZMA_PROB_LITERAL_OFFSET + LZMA_PROB_LITERAL_LEN)\n+\n+/* Check that the number of LZMA probabilities is the same as the\n+   Linux kernel implementation.  */\n+\n+#if LZMA_PROB_TOTAL_COUNT != 1846 + (1 << 4) * 0x300\n+ #error Wrong number of LZMA probabilities\n+#endif\n+\n+/* Expressions for the offset in the LZMA probabilities array of a\n+   specific probability.  */\n+\n+#define LZMA_IS_MATCH(state, pos) \\\n+  (LZMA_PROB_IS_MATCH_OFFSET + (state) * LZMA_POS_STATES + (pos))\n+#define LZMA_IS_REP(state) \\\n+  (LZMA_PROB_IS_REP_OFFSET + (state))\n+#define LZMA_IS_REP0(state) \\\n+  (LZMA_PROB_IS_REP0_OFFSET + (state))\n+#define LZMA_IS_REP1(state) \\\n+  (LZMA_PROB_IS_REP1_OFFSET + (state))\n+#define LZMA_IS_REP2(state) \\\n+  (LZMA_PROB_IS_REP2_OFFSET + (state))\n+#define LZMA_IS_REP0_LONG(state, pos) \\\n+  (LZMA_PROB_IS_REP0_LONG_OFFSET + (state) * LZMA_POS_STATES + (pos))\n+#define LZMA_DIST_SLOT(dist, slot) \\\n+  (LZMA_PROB_DIST_SLOT_OFFSET + (dist) * LZMA_DIST_SLOTS + (slot))\n+#define LZMA_DIST_SPECIAL(dist) \\\n+  (LZMA_PROB_DIST_SPECIAL_OFFSET + (dist))\n+#define LZMA_DIST_ALIGN(dist) \\\n+  (LZMA_PROB_DIST_ALIGN_OFFSET + (dist))\n+#define LZMA_MATCH_LEN_CHOICE \\\n+  LZMA_PROB_MATCH_LEN_CHOICE_OFFSET\n+#define LZMA_MATCH_LEN_CHOICE2 \\\n+  LZMA_PROB_MATCH_LEN_CHOICE2_OFFSET\n+#define LZMA_MATCH_LEN_LOW(pos, sym) \\\n+  (LZMA_PROB_MATCH_LEN_LOW_OFFSET + (pos) * LZMA_LEN_LOW_SYMBOLS + (sym))\n+#define LZMA_MATCH_LEN_MID(pos, sym) \\\n+  (LZMA_PROB_MATCH_LEN_MID_OFFSET + (pos) * LZMA_LEN_MID_SYMBOLS + (sym))\n+#define LZMA_MATCH_LEN_HIGH(sym) \\\n+  (LZMA_PROB_MATCH_LEN_HIGH_OFFSET + (sym))\n+#define LZMA_REP_LEN_CHOICE \\\n+  LZMA_PROB_REP_LEN_CHOICE_OFFSET\n+#define LZMA_REP_LEN_CHOICE2 \\\n+  LZMA_PROB_REP_LEN_CHOICE2_OFFSET\n+#define LZMA_REP_LEN_LOW(pos, sym) \\\n+  (LZMA_PROB_REP_LEN_LOW_OFFSET + (pos) * LZMA_LEN_LOW_SYMBOLS + (sym))\n+#define LZMA_REP_LEN_MID(pos, sym) \\\n+  (LZMA_PROB_REP_LEN_MID_OFFSET + (pos) * LZMA_LEN_MID_SYMBOLS + (sym))\n+#define LZMA_REP_LEN_HIGH(sym) \\\n+  (LZMA_PROB_REP_LEN_HIGH_OFFSET + (sym))\n+#define LZMA_LITERAL(code, size) \\\n+  (LZMA_PROB_LITERAL_OFFSET + (code) * LZMA_LITERAL_CODER_SIZE + (size))\n+\n+/* Read an LZMA varint from BUF, reading and updating *POFFSET,\n+   setting *VAL.  Returns 0 on error, 1 on success.  */\n+\n+static int\n+elf_lzma_varint (const unsigned char *compressed, size_t compressed_size,\n+\t\t size_t *poffset, uint64_t *val)\n+{\n+  size_t off;\n+  int i;\n+  uint64_t v;\n+  unsigned char b;\n+\n+  off = *poffset;\n+  i = 0;\n+  v = 0;\n+  while (1)\n+    {\n+      if (unlikely (off >= compressed_size))\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n+      b = compressed[off];\n+      v |= (b & 0x7f) << (i * 7);\n+      ++off;\n+      if ((b & 0x80) == 0)\n+\t{\n+\t  *poffset = off;\n+\t  *val = v;\n+\t  return 1;\n+\t}\n+      ++i;\n+      if (unlikely (i >= 9))\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n+    }\n+}\n+\n+/* Normalize the LZMA range decoder, pulling in an extra input byte if\n+   needed.  */\n+\n+static void\n+elf_lzma_range_normalize (const unsigned char *compressed,\n+\t\t\t  size_t compressed_size, size_t *poffset,\n+\t\t\t  uint32_t *prange, uint32_t *pcode)\n+{\n+  if (*prange < (1U << 24))\n+    {\n+      if (unlikely (*poffset >= compressed_size))\n+\t{\n+\t  /* We assume this will be caught elsewhere.  */\n+\t  elf_uncompress_failed ();\n+\t  return;\n+\t}\n+      *prange <<= 8;\n+      *pcode <<= 8;\n+      *pcode += compressed[*poffset];\n+      ++*poffset;\n+    }\n+}\n+\n+/* Read and return a single bit from the LZMA stream, reading and\n+   updating *PROB.  Each bit comes from the range coder.  */\n+\n+static int\n+elf_lzma_bit (const unsigned char *compressed, size_t compressed_size,\n+\t      uint16_t *prob, size_t *poffset, uint32_t *prange,\n+\t      uint32_t *pcode)\n+{\n+  uint32_t bound;\n+\n+  elf_lzma_range_normalize (compressed, compressed_size, poffset,\n+\t\t\t    prange, pcode);\n+  bound = (*prange >> 11) * (uint32_t) *prob;\n+  if (*pcode < bound)\n+    {\n+      *prange = bound;\n+      *prob += ((1U << 11) - *prob) >> 5;\n+      return 0;\n+    }\n+  else\n+    {\n+      *prange -= bound;\n+      *pcode -= bound;\n+      *prob -= *prob >> 5;\n+      return 1;\n+    }\n+}\n+\n+/* Read an integer of size BITS from the LZMA stream, most significant\n+   bit first.  The bits are predicted using PROBS.  */\n+\n+static uint32_t\n+elf_lzma_integer (const unsigned char *compressed, size_t compressed_size,\n+\t\t  uint16_t *probs, uint32_t bits, size_t *poffset,\n+\t\t  uint32_t *prange, uint32_t *pcode)\n+{\n+  uint32_t sym;\n+  uint32_t i;\n+\n+  sym = 1;\n+  for (i = 0; i < bits; i++)\n+    {\n+      int bit;\n+\n+      bit = elf_lzma_bit (compressed, compressed_size, probs + sym, poffset,\n+\t\t\t  prange, pcode);\n+      sym <<= 1;\n+      sym += bit;\n+    }\n+  return sym - (1 << bits);\n+}\n+\n+/* Read an integer of size BITS from the LZMA stream, least\n+   significant bit first.  The bits are predicted using PROBS.  */\n+\n+static uint32_t\n+elf_lzma_reverse_integer (const unsigned char *compressed,\n+\t\t\t  size_t compressed_size, uint16_t *probs,\n+\t\t\t  uint32_t bits, size_t *poffset, uint32_t *prange,\n+\t\t\t  uint32_t *pcode)\n+{\n+  uint32_t sym;\n+  uint32_t val;\n+  uint32_t i;\n+\n+  sym = 1;\n+  val = 0;\n+  for (i = 0; i < bits; i++)\n+    {\n+      int bit;\n+\n+      bit = elf_lzma_bit (compressed, compressed_size, probs + sym, poffset,\n+\t\t\t  prange, pcode);\n+      sym <<= 1;\n+      sym += bit;\n+      val += bit << i;\n+    }\n+  return val;\n+}\n+\n+/* Read a length from the LZMA stream.  IS_REP picks either LZMA_MATCH\n+   or LZMA_REP probabilities.  */\n+\n+static uint32_t\n+elf_lzma_len (const unsigned char *compressed, size_t compressed_size,\n+\t      uint16_t *probs, int is_rep, unsigned int pos_state,\n+\t      size_t *poffset, uint32_t *prange, uint32_t *pcode)\n+{\n+  uint16_t *probs_choice;\n+  uint16_t *probs_sym;\n+  uint32_t bits;\n+  uint32_t len;\n+\n+  probs_choice = probs + (is_rep\n+\t\t\t  ? LZMA_REP_LEN_CHOICE\n+\t\t\t  : LZMA_MATCH_LEN_CHOICE);\n+  if (elf_lzma_bit (compressed, compressed_size, probs_choice, poffset,\n+\t\t    prange, pcode))\n+    {\n+      probs_choice = probs + (is_rep\n+\t\t\t      ? LZMA_REP_LEN_CHOICE2\n+\t\t\t      : LZMA_MATCH_LEN_CHOICE2);\n+      if (elf_lzma_bit (compressed, compressed_size, probs_choice,\n+\t\t\tpoffset, prange, pcode))\n+\t{\n+\t  probs_sym = probs + (is_rep\n+\t\t\t       ? LZMA_REP_LEN_HIGH (0)\n+\t\t\t       : LZMA_MATCH_LEN_HIGH (0));\n+\t  bits = 8;\n+\t  len = 2 + 8 + 8;\n+\t}\n+      else\n+\t{\n+\t  probs_sym = probs + (is_rep\n+\t\t\t       ? LZMA_REP_LEN_MID (pos_state, 0)\n+\t\t\t       : LZMA_MATCH_LEN_MID (pos_state, 0));\n+\t  bits = 3;\n+\t  len = 2 + 8;\n+\t}\n+    }\n+  else\n+    {\n+      probs_sym = probs + (is_rep\n+\t\t\t   ? LZMA_REP_LEN_LOW (pos_state, 0)\n+\t\t\t   : LZMA_MATCH_LEN_LOW (pos_state, 0));\n+      bits = 3;\n+      len = 2;\n+    }\n+\n+  len += elf_lzma_integer (compressed, compressed_size, probs_sym, bits,\n+\t\t\t   poffset, prange, pcode);\n+  return len;\n+}\n+\n+/* Uncompress one LZMA block from a minidebug file.  The compressed\n+   data is at COMPRESSED + *POFFSET.  Update *POFFSET.  Store the data\n+   into the memory at UNCOMPRESSED, size UNCOMPRESSED_SIZE.  CHECK is\n+   the stream flag from the xz header.  Return 1 on successful\n+   decompression.  */\n+\n+static int\n+elf_uncompress_lzma_block (const unsigned char *compressed,\n+\t\t\t   size_t compressed_size, unsigned char check,\n+\t\t\t   uint16_t *probs, unsigned char *uncompressed,\n+\t\t\t   size_t uncompressed_size, size_t *poffset)\n+{\n+  size_t off;\n+  size_t block_header_offset;\n+  size_t block_header_size;\n+  unsigned char block_flags;\n+  uint64_t header_compressed_size;\n+  uint64_t header_uncompressed_size;\n+  unsigned char lzma2_properties;\n+  uint32_t computed_crc;\n+  uint32_t stream_crc;\n+  size_t uncompressed_offset;\n+  size_t dict_start_offset;\n+  unsigned int lc;\n+  unsigned int lp;\n+  unsigned int pb;\n+  uint32_t range;\n+  uint32_t code;\n+  uint32_t lstate;\n+  uint32_t dist[4];\n+\n+  off = *poffset;\n+  block_header_offset = off;\n+\n+  /* Block header size is a single byte.  */\n+  if (unlikely (off >= compressed_size))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  block_header_size = (compressed[off] + 1) * 4;\n+  if (unlikely (off + block_header_size > compressed_size))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  /* Block flags.  */\n+  block_flags = compressed[off + 1];\n+  if (unlikely ((block_flags & 0x3c) != 0))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  off += 2;\n+\n+  /* Optional compressed size.  */\n+  header_compressed_size = 0;\n+  if ((block_flags & 0x40) != 0)\n+    {\n+      *poffset = off;\n+      if (!elf_lzma_varint (compressed, compressed_size, poffset,\n+\t\t\t    &header_compressed_size))\n+\treturn 0;\n+      off = *poffset;\n+    }\n+\n+  /* Optional uncompressed size.  */\n+  header_uncompressed_size = 0;\n+  if ((block_flags & 0x80) != 0)\n+    {\n+      *poffset = off;\n+      if (!elf_lzma_varint (compressed, compressed_size, poffset,\n+\t\t\t    &header_uncompressed_size))\n+\treturn 0;\n+      off = *poffset;\n+    }\n+\n+  /* The recipe for creating a minidebug file is to run the xz program\n+     with no arguments, so we expect exactly one filter: lzma2.  */\n+\n+  if (unlikely ((block_flags & 0x3) != 0))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  if (unlikely (off + 2 >= block_header_offset + block_header_size))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  /* The filter ID for LZMA2 is 0x21.  */\n+  if (unlikely (compressed[off] != 0x21))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  ++off;\n+\n+  /* The size of the filter properties for LZMA2 is 1.  */\n+  if (unlikely (compressed[off] != 1))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  ++off;\n+\n+  lzma2_properties = compressed[off];\n+  ++off;\n+\n+  if (unlikely (lzma2_properties > 40))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  /* The properties describe the dictionary size, but we don't care\n+     what that is.  */\n+\n+  /* Block header padding.  */\n+  if (unlikely (off + 4 > compressed_size))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  off = (off + 3) &~ (size_t) 3;\n+\n+  if (unlikely (off + 4 > compressed_size))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  /* Block header CRC.  */\n+  computed_crc = elf_crc32 (0, compressed + block_header_offset,\n+\t\t\t    block_header_size - 4);\n+  stream_crc = (compressed[off]\n+\t\t| (compressed[off + 1] << 8)\n+\t\t| (compressed[off + 2] << 16)\n+\t\t| (compressed[off + 3] << 24));\n+  if (unlikely (computed_crc != stream_crc))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  off += 4;\n+\n+  /* Read a sequence of LZMA2 packets.  */\n+\n+  uncompressed_offset = 0;\n+  dict_start_offset = 0;\n+  lc = 0;\n+  lp = 0;\n+  pb = 0;\n+  lstate = 0;\n+  while (off < compressed_size)\n+    {\n+      unsigned char control;\n+\n+      range = 0xffffffff;\n+      code = 0;\n+\n+      control = compressed[off];\n+      ++off;\n+      if (unlikely (control == 0))\n+\t{\n+\t  /* End of packets.  */\n+\t  break;\n+\t}\n+\n+      if (control == 1 || control >= 0xe0)\n+\t{\n+\t  /* Reset dictionary to empty.  */\n+\t  dict_start_offset = uncompressed_offset;\n+\t}\n+\n+      if (control < 0x80)\n+\t{\n+\t  size_t chunk_size;\n+\n+\t  /* The only valid values here are 1 or 2.  A 1 means to\n+\t     reset the dictionary (done above).  Then we see an\n+\t     uncompressed chunk.  */\n+\n+\t  if (unlikely (control > 2))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\n+\t  /* An uncompressed chunk is a two byte size followed by\n+\t     data.  */\n+\n+\t  if (unlikely (off + 2 > compressed_size))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\n+\t  chunk_size = compressed[off] << 8;\n+\t  chunk_size += compressed[off + 1];\n+\t  ++chunk_size;\n+\n+\t  off += 2;\n+\n+\t  if (unlikely (off + chunk_size > compressed_size))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\t  if (unlikely (uncompressed_offset + chunk_size > uncompressed_size))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\n+\t  memcpy (uncompressed + uncompressed_offset, compressed + off,\n+\t\t  chunk_size);\n+\t  uncompressed_offset += chunk_size;\n+\t  off += chunk_size;\n+\t}\n+      else\n+\t{\n+\t  size_t uncompressed_chunk_start;\n+\t  size_t uncompressed_chunk_size;\n+\t  size_t compressed_chunk_size;\n+\t  size_t limit;\n+\n+\t  /* An LZMA chunk.  This starts with an uncompressed size and\n+\t     a compressed size.  */\n+\n+\t  if (unlikely (off + 4 >= compressed_size))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\n+\t  uncompressed_chunk_start = uncompressed_offset;\n+\n+\t  uncompressed_chunk_size = (control & 0x1f) << 16;\n+\t  uncompressed_chunk_size += compressed[off] << 8;\n+\t  uncompressed_chunk_size += compressed[off + 1];\n+\t  ++uncompressed_chunk_size;\n+\n+\t  compressed_chunk_size = compressed[off + 2] << 8;\n+\t  compressed_chunk_size += compressed[off + 3];\n+\t  ++compressed_chunk_size;\n+\n+\t  off += 4;\n+\n+\t  /* Bit 7 (0x80) is set.\n+\t     Bits 6 and 5 (0x40 and 0x20) are as follows:\n+\t     0: don't reset anything\n+\t     1: reset state\n+\t     2: reset state, read properties\n+\t     3: reset state, read properties, reset dictionary (done above) */\n+\n+\t  if (control >= 0xc0)\n+\t    {\n+\t      unsigned char props;\n+\n+\t      /* Bit 6 is set, read properties.  */\n+\n+\t      if (unlikely (off >= compressed_size))\n+\t\t{\n+\t\t  elf_uncompress_failed ();\n+\t\t  return 0;\n+\t\t}\n+\t      props = compressed[off];\n+\t      ++off;\n+\t      if (unlikely (props > (4 * 5 + 4) * 9 + 8))\n+\t\t{\n+\t\t  elf_uncompress_failed ();\n+\t\t  return 0;\n+\t\t}\n+\t      pb = 0;\n+\t      while (props >= 9 * 5)\n+\t\t{\n+\t\t  props -= 9 * 5;\n+\t\t  ++pb;\n+\t\t}\n+\t      lp = 0;\n+\t      while (props > 9)\n+\t\t{\n+\t\t  props -= 9;\n+\t\t  ++lp;\n+\t\t}\n+\t      lc = props;\n+\t      if (unlikely (lc + lp > 4))\n+\t\t{\n+\t\t  elf_uncompress_failed ();\n+\t\t  return 0;\n+\t\t}\n+\t    }\n+\n+\t  if (control >= 0xa0)\n+\t    {\n+\t      size_t i;\n+\n+\t      /* Bit 5 or 6 is set, reset LZMA state.  */\n+\n+\t      lstate = 0;\n+\t      memset (&dist, 0, sizeof dist);\n+\t      for (i = 0; i < LZMA_PROB_TOTAL_COUNT; i++)\n+\t\tprobs[i] = 1 << 10;\n+\t      range = 0xffffffff;\n+\t      code = 0;\n+\t    }\n+\n+\t  /* Read the range code.  */\n+\n+\t  if (unlikely (off + 5 > compressed_size))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\n+\t  /* The byte at compressed[off] is ignored for some\n+\t     reason.  */\n+\n+\t  code = ((compressed[off + 1] << 24)\n+\t\t  + (compressed[off + 2] << 16)\n+\t\t  + (compressed[off + 3] << 8)\n+\t\t  + compressed[off + 4]);\n+\t  off += 5;\n+\n+\t  /* This is the main LZMA decode loop.  */\n+\n+\t  limit = off + compressed_chunk_size;\n+\t  *poffset = off;\n+\t  while (*poffset < limit)\n+\t    {\n+\t      unsigned int pos_state;\n+\n+\t      if (unlikely (uncompressed_offset\n+\t\t\t    == (uncompressed_chunk_start\n+\t\t\t\t+ uncompressed_chunk_size)))\n+\t\t{\n+\t\t  /* We've decompressed all the expected bytes.  */\n+\t\t  break;\n+\t\t}\n+\n+\t      pos_state = ((uncompressed_offset - dict_start_offset)\n+\t\t\t   & ((1 << pb) - 1));\n+\n+\t      if (elf_lzma_bit (compressed, compressed_size,\n+\t\t\t\tprobs + LZMA_IS_MATCH (lstate, pos_state),\n+\t\t\t\tpoffset, &range, &code))\n+\t\t{\n+\t\t  uint32_t len;\n+\n+\t\t  if (elf_lzma_bit (compressed, compressed_size,\n+\t\t\t\t    probs + LZMA_IS_REP (lstate),\n+\t\t\t\t    poffset, &range, &code))\n+\t\t    {\n+\t\t      int short_rep;\n+\t\t      uint32_t next_dist;\n+\n+\t\t      /* Repeated match.  */\n+\n+\t\t      short_rep = 0;\n+\t\t      if (elf_lzma_bit (compressed, compressed_size,\n+\t\t\t\t\tprobs + LZMA_IS_REP0 (lstate),\n+\t\t\t\t\tpoffset, &range, &code))\n+\t\t\t{\n+\t\t\t  if (elf_lzma_bit (compressed, compressed_size,\n+\t\t\t\t\t    probs + LZMA_IS_REP1 (lstate),\n+\t\t\t\t\t    poffset, &range, &code))\n+\t\t\t    {\n+\t\t\t      if (elf_lzma_bit (compressed, compressed_size,\n+\t\t\t\t\t\tprobs + LZMA_IS_REP2 (lstate),\n+\t\t\t\t\t\tpoffset, &range, &code))\n+\t\t\t\t{\n+\t\t\t\t  next_dist = dist[3];\n+\t\t\t\t  dist[3] = dist[2];\n+\t\t\t\t}\n+\t\t\t      else\n+\t\t\t\t{\n+\t\t\t\t  next_dist = dist[2];\n+\t\t\t\t}\n+\t\t\t      dist[2] = dist[1];\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      next_dist = dist[1];\n+\t\t\t    }\n+\n+\t\t\t  dist[1] = dist[0];\n+\t\t\t  dist[0] = next_dist;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  if (!elf_lzma_bit (compressed, compressed_size,\n+\t\t\t\t\t    (probs\n+\t\t\t\t\t     + LZMA_IS_REP0_LONG (lstate,\n+\t\t\t\t\t\t\t\t  pos_state)),\n+\t\t\t\t\t    poffset, &range, &code))\n+\t\t\t    short_rep = 1;\n+\t\t\t}\n+\n+\t\t      if (lstate < 7)\n+\t\t\tlstate = short_rep ? 9 : 8;\n+\t\t      else\n+\t\t\tlstate = 11;\n+\n+\t\t      if (short_rep)\n+\t\t\tlen = 1;\n+\t\t      else\n+\t\t\tlen = elf_lzma_len (compressed, compressed_size,\n+\t\t\t\t\t    probs, 1, pos_state, poffset,\n+\t\t\t\t\t    &range, &code);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      uint32_t dist_state;\n+\t\t      uint32_t dist_slot;\n+\t\t      uint16_t *probs_dist;\n+\n+\t\t      /* Match.  */\n+\n+\t\t      if (lstate < 7)\n+\t\t\tlstate = 7;\n+\t\t      else\n+\t\t\tlstate = 10;\n+\t\t      dist[3] = dist[2];\n+\t\t      dist[2] = dist[1];\n+\t\t      dist[1] = dist[0];\n+\t\t      len = elf_lzma_len (compressed, compressed_size,\n+\t\t\t\t\t  probs, 0, pos_state, poffset,\n+\t\t\t\t\t  &range, &code);\n+\n+\t\t      if (len < 4 + 2)\n+\t\t\tdist_state = len - 2;\n+\t\t      else\n+\t\t\tdist_state = 3;\n+\t\t      probs_dist = probs + LZMA_DIST_SLOT (dist_state, 0);\n+\t\t      dist_slot = elf_lzma_integer (compressed,\n+\t\t\t\t\t\t    compressed_size,\n+\t\t\t\t\t\t    probs_dist, 6,\n+\t\t\t\t\t\t    poffset, &range,\n+\t\t\t\t\t\t    &code);\n+\t\t      if (dist_slot < LZMA_DIST_MODEL_START)\n+\t\t\tdist[0] = dist_slot;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  uint32_t limit;\n+\n+\t\t\t  limit = (dist_slot >> 1) - 1;\n+\t\t\t  dist[0] = 2 + (dist_slot & 1);\n+\t\t\t  if (dist_slot < LZMA_DIST_MODEL_END)\n+\t\t\t    {\n+\t\t\t      dist[0] <<= limit;\n+\t\t\t      probs_dist = (probs\n+\t\t\t\t\t    + LZMA_DIST_SPECIAL(dist[0]\n+\t\t\t\t\t\t\t\t- dist_slot\n+\t\t\t\t\t\t\t\t- 1));\n+\t\t\t      dist[0] +=\n+\t\t\t\telf_lzma_reverse_integer (compressed,\n+\t\t\t\t\t\t\t  compressed_size,\n+\t\t\t\t\t\t\t  probs_dist,\n+\t\t\t\t\t\t\t  limit, poffset,\n+\t\t\t\t\t\t\t  &range, &code);\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      uint32_t dist0;\n+\t\t\t      uint32_t i;\n+\n+\t\t\t      dist0 = dist[0];\n+\t\t\t      for (i = 0; i < limit - 4; i++)\n+\t\t\t\t{\n+\t\t\t\t  uint32_t mask;\n+\n+\t\t\t\t  elf_lzma_range_normalize (compressed,\n+\t\t\t\t\t\t\t    compressed_size,\n+\t\t\t\t\t\t\t    poffset,\n+\t\t\t\t\t\t\t    &range, &code);\n+\t\t\t\t  range >>= 1;\n+\t\t\t\t  code -= range;\n+\t\t\t\t  mask = -(code >> 31);\n+\t\t\t\t  code += range & mask;\n+\t\t\t\t  dist0 <<= 1;\n+\t\t\t\t  dist0 += mask + 1;\n+\t\t\t\t}\n+\t\t\t      dist0 <<= 4;\n+\t\t\t      probs_dist = probs + LZMA_DIST_ALIGN (0);\n+\t\t\t      dist0 +=\n+\t\t\t\telf_lzma_reverse_integer (compressed,\n+\t\t\t\t\t\t\t  compressed_size,\n+\t\t\t\t\t\t\t  probs_dist, 4,\n+\t\t\t\t\t\t\t  poffset,\n+\t\t\t\t\t\t\t  &range, &code);\n+\t\t\t      dist[0] = dist0;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  if (unlikely (uncompressed_offset\n+\t\t\t\t- dict_start_offset < dist[0] + 1))\n+\t\t    {\n+\t\t      elf_uncompress_failed ();\n+\t\t      return 0;\n+\t\t    }\n+\t\t  if (unlikely (uncompressed_offset + len > uncompressed_size))\n+\t\t    {\n+\t\t      elf_uncompress_failed ();\n+\t\t      return 0;\n+\t\t    }\n+\n+\t\t  if (dist[0] == 0)\n+\t\t    {\n+\t\t      /* A common case, meaning repeat the last\n+\t\t\t character LEN times.  */\n+\t\t      memset (uncompressed + uncompressed_offset,\n+\t\t\t      uncompressed[uncompressed_offset - 1],\n+\t\t\t      len);\n+\t\t      uncompressed_offset += len;\n+\t\t    }\n+\t\t  else if (dist[0] + 1 >= len)\n+\t\t    {\n+\t\t      memcpy (uncompressed + uncompressed_offset,\n+\t\t\t      uncompressed + uncompressed_offset - dist[0] - 1,\n+\t\t\t      len);\n+\t\t      uncompressed_offset += len;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      while (len > 0)\n+\t\t\t{\n+\t\t\t  uint32_t copy;\n+\n+\t\t\t  copy = len < dist[0] + 1 ? len : dist[0] + 1;\n+\t\t\t  memcpy (uncompressed + uncompressed_offset,\n+\t\t\t\t  (uncompressed + uncompressed_offset\n+\t\t\t\t   - dist[0] - 1),\n+\t\t\t\t  copy);\n+\t\t\t  len -= copy;\n+\t\t\t  uncompressed_offset += copy;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  unsigned char prev;\n+\t\t  unsigned char low;\n+\t\t  size_t high;\n+\t\t  uint16_t *lit_probs;\n+\t\t  unsigned int sym;\n+\n+\t\t  /* Literal value.  */\n+\n+\t\t  if (uncompressed_offset > 0)\n+\t\t    prev = uncompressed[uncompressed_offset - 1];\n+\t\t  else\n+\t\t    prev = 0;\n+\t\t  low = prev >> (8 - lc);\n+\t\t  high = (((uncompressed_offset - dict_start_offset)\n+\t\t\t   & ((1 << lp) - 1))\n+\t\t\t  << lc);\n+\t\t  lit_probs = probs + LZMA_LITERAL (low + high, 0);\n+\t\t  if (lstate < 7)\n+\t\t    sym = elf_lzma_integer (compressed, compressed_size,\n+\t\t\t\t\t    lit_probs, 8, poffset, &range,\n+\t\t\t\t\t    &code);\n+\t\t  else\n+\t\t    {\n+\t\t      unsigned int match;\n+\t\t      unsigned int bit;\n+\t\t      unsigned int match_bit;\n+\t\t      unsigned int idx;\n+\n+\t\t      sym = 1;\n+\t\t      if (uncompressed_offset >= dist[0] + 1)\n+\t\t\tmatch = uncompressed[uncompressed_offset - dist[0] - 1];\n+\t\t      else\n+\t\t\tmatch = 0;\n+\t\t      match <<= 1;\n+\t\t      bit = 0x100;\n+\t\t      do\n+\t\t\t{\n+\t\t\t  match_bit = match & bit;\n+\t\t\t  match <<= 1;\n+\t\t\t  idx = bit + match_bit + sym;\n+\t\t\t  sym <<= 1;\n+\t\t\t  if (elf_lzma_bit (compressed, compressed_size,\n+\t\t\t\t\t    lit_probs + idx, poffset,\n+\t\t\t\t\t    &range, &code))\n+\t\t\t    {\n+\t\t\t      ++sym;\n+\t\t\t      bit &= match_bit;\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      bit &= ~ match_bit;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      while (sym < 0x100);\n+\t\t    }\n+\n+\t\t  if (unlikely (uncompressed_offset >= uncompressed_size))\n+\t\t    {\n+\t\t      elf_uncompress_failed ();\n+\t\t      return 0;\n+\t\t    }\n+\n+\t\t  uncompressed[uncompressed_offset] = (unsigned char) sym;\n+\t\t  ++uncompressed_offset;\n+\t\t  if (lstate <= 3)\n+\t\t    lstate = 0;\n+\t\t  else if (lstate <= 9)\n+\t\t    lstate -= 3;\n+\t\t  else\n+\t\t    lstate -= 6;\n+\t\t}\n+\t    }\n+\n+\t  elf_lzma_range_normalize (compressed, compressed_size, poffset,\n+\t\t\t\t    &range, &code);\n+\n+\t  off = *poffset;\n+\t}\n+    }\n+\n+  /* We have reached the end of the block.  Pad to four byte\n+     boundary.  */\n+  off = (off + 3) &~ (size_t) 3;\n+  if (unlikely (off > compressed_size))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  switch (check)\n+    {\n+    case 0:\n+      /* No check.  */\n+      break;\n+\n+    case 1:\n+      /* CRC32 */\n+      if (unlikely (off + 4 > compressed_size))\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n+      computed_crc = elf_crc32 (0, uncompressed, uncompressed_offset);\n+      stream_crc = (compressed[off]\n+\t\t    | (compressed[off + 1] << 8)\n+\t\t    | (compressed[off + 2] << 16)\n+\t\t    | (compressed[off + 3] << 24));\n+      if (computed_crc != stream_crc)\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n+      off += 4;\n+      break;\n+\n+    case 4:\n+      /* CRC64.  We don't bother computing a CRC64 checksum.  */\n+      if (unlikely (off + 8 > compressed_size))\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n+      off += 8;\n+      break;\n+\n+    case 10:\n+      /* SHA.  We don't bother computing a SHA checksum.  */\n+      if (unlikely (off + 32 > compressed_size))\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n+      off += 32;\n+      break;\n+\n+    default:\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  *poffset = off;\n+\n+  return 1;\n+}\n+\n+/* Uncompress LZMA data found in a minidebug file.  The minidebug\n+   format is described at\n+   https://sourceware.org/gdb/current/onlinedocs/gdb/MiniDebugInfo.html.\n+   Returns 0 on error, 1 on successful decompression.  For this\n+   function we return 0 on failure to decompress, as the calling code\n+   will carry on in that case.  */\n+\n+static int\n+elf_uncompress_lzma (struct backtrace_state *state,\n+\t\t     const unsigned char *compressed, size_t compressed_size,\n+\t\t     backtrace_error_callback error_callback, void *data,\n+\t\t     unsigned char **uncompressed, size_t *uncompressed_size)\n+{\n+  size_t header_size;\n+  size_t footer_size;\n+  unsigned char check;\n+  uint32_t computed_crc;\n+  uint32_t stream_crc;\n+  size_t offset;\n+  size_t index_size;\n+  size_t footer_offset;\n+  size_t index_offset;\n+  uint64_t index_compressed_size;\n+  uint64_t index_uncompressed_size;\n+  unsigned char *mem;\n+  uint16_t *probs;\n+  size_t compressed_block_size;\n+\n+  /* The format starts with a stream header and ends with a stream\n+     footer.  */\n+  header_size = 12;\n+  footer_size = 12;\n+  if (unlikely (compressed_size < header_size + footer_size))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  /* The stream header starts with a magic string.  */\n+  if (unlikely (memcmp (compressed, \"\\375\" \"7zXZ\\0\", 6) != 0))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  /* Next come stream flags.  The first byte is zero, the second byte\n+     is the check.  */\n+  if (unlikely (compressed[6] != 0))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  check = compressed[7];\n+  if (unlikely ((check & 0xf8) != 0))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  /* Next comes a CRC of the stream flags.  */\n+  computed_crc = elf_crc32 (0, compressed + 6, 2);\n+  stream_crc = (compressed[8]\n+\t\t| (compressed[9] << 8)\n+\t\t| (compressed[10] << 16)\n+\t\t| (compressed[11] << 24));\n+  if (unlikely (computed_crc != stream_crc))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  /* Now that we've parsed the header, parse the footer, so that we\n+     can get the uncompressed size.  */\n+\n+  /* The footer ends with two magic bytes.  */\n+\n+  offset = compressed_size;\n+  if (unlikely (memcmp (compressed + offset - 2, \"YZ\", 2) != 0))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  offset -= 2;\n+\n+  /* Before that are the stream flags, which should be the same as the\n+     flags in the header.  */\n+  if (unlikely (compressed[offset - 2] != 0\n+\t\t|| compressed[offset - 1] != check))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  offset -= 2;\n+\n+  /* Before that is the size of the index field, which precedes the\n+     footer.  */\n+  index_size = (compressed[offset - 4]\n+\t\t| (compressed[offset - 3] << 8)\n+\t\t| (compressed[offset - 2] << 16)\n+\t\t| (compressed[offset - 1] << 24));\n+  index_size = (index_size + 1) * 4;\n+  offset -= 4;\n+\n+  /* Before that is a footer CRC.  */\n+  computed_crc = elf_crc32 (0, compressed + offset, 6);\n+  stream_crc = (compressed[offset - 4]\n+\t\t| (compressed[offset - 3] << 8)\n+\t\t| (compressed[offset - 2] << 16)\n+\t\t| (compressed[offset - 1] << 24));\n+  if (unlikely (computed_crc != stream_crc))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  offset -= 4;\n+\n+  /* The index comes just before the footer.  */\n+  if (unlikely (offset < index_size + header_size))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  footer_offset = offset;\n+  offset -= index_size;\n+  index_offset = offset;\n+\n+  /* The index starts with a zero byte.  */\n+  if (unlikely (compressed[offset] != 0))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  ++offset;\n+\n+  /* Next is the number of blocks.  We expect zero blocks for an empty\n+     stream, and otherwise a single block.  */\n+  if (unlikely (compressed[offset] == 0))\n+    {\n+      *uncompressed = NULL;\n+      *uncompressed_size = 0;\n+      return 1;\n+    }\n+  if (unlikely (compressed[offset] != 1))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  ++offset;\n+\n+  /* Next is the compressed size and the uncompressed size.  */\n+  if (!elf_lzma_varint (compressed, compressed_size, &offset,\n+\t\t\t&index_compressed_size))\n+    return 0;\n+  if (!elf_lzma_varint (compressed, compressed_size, &offset,\n+\t\t\t&index_uncompressed_size))\n+    return 0;\n+\n+  /* Pad to a four byte boundary.  */\n+  offset = (offset + 3) &~ (size_t) 3;\n+\n+  /* Next is a CRC of the index.  */\n+  computed_crc = elf_crc32 (0, compressed + index_offset,\n+\t\t\t    offset - index_offset);\n+  stream_crc = (compressed[offset]\n+\t\t| (compressed[offset + 1] << 8)\n+\t\t| (compressed[offset + 2] << 16)\n+\t\t| (compressed[offset + 3] << 24));\n+  if (unlikely (computed_crc != stream_crc))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  offset += 4;\n+\n+  /* We should now be back at the footer.  */\n+  if (unlikely (offset != footer_offset))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+\n+  /* Allocate space to hold the uncompressed data.  If we succeed in\n+     uncompressing the LZMA data, we never free this memory.  */\n+  mem = (unsigned char *) backtrace_alloc (state, index_uncompressed_size,\n+\t\t\t\t\t   error_callback, data);\n+  if (unlikely (mem == NULL))\n+    return 0;\n+  *uncompressed = mem;\n+  *uncompressed_size = index_uncompressed_size;\n+\n+  /* Allocate space for probabilities.  */\n+  probs = ((uint16_t *)\n+\t   backtrace_alloc (state,\n+\t\t\t    LZMA_PROB_TOTAL_COUNT * sizeof (uint16_t),\n+\t\t\t    error_callback, data));\n+  if (unlikely (probs == NULL))\n+    {\n+      backtrace_free (state, mem, index_uncompressed_size, error_callback,\n+\t\t      data);\n+      return 0;\n+    }\n+\n+  /* Uncompress the block, which follows the header.  */\n+  offset = 12;\n+  if (!elf_uncompress_lzma_block (compressed, compressed_size, check, probs,\n+\t\t\t\t  mem, index_uncompressed_size, &offset))\n+    {\n+      backtrace_free (state, mem, index_uncompressed_size, error_callback,\n+\t\t      data);\n+      return 0;\n+    }\n+\n+  compressed_block_size = offset - 12;\n+  if (unlikely (compressed_block_size\n+\t\t!= ((index_compressed_size + 3) &~ (size_t) 3)))\n+    {\n+      elf_uncompress_failed ();\n+      backtrace_free (state, mem, index_uncompressed_size, error_callback,\n+\t\t      data);\n+      return 0;\n+    }\n+\n+  offset = (offset + 3) &~ (size_t) 3;\n+  if (unlikely (offset != index_offset))\n+    {\n+      elf_uncompress_failed ();\n+      backtrace_free (state, mem, index_uncompressed_size, error_callback,\n+\t\t      data);\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* This function is a hook for testing the LZMA support.  It is only\n+   used by tests.  */\n+\n+int\n+backtrace_uncompress_lzma (struct backtrace_state *state,\n+\t\t\t   const unsigned char *compressed,\n+\t\t\t   size_t compressed_size,\n+\t\t\t   backtrace_error_callback error_callback,\n+\t\t\t   void *data, unsigned char **uncompressed,\n+\t\t\t   size_t *uncompressed_size)\n+{\n+  return elf_uncompress_lzma (state, compressed, compressed_size,\n+\t\t\t      error_callback, data, uncompressed,\n+\t\t\t      uncompressed_size);\n+}\n+\n /* Add the backtrace data for one ELF file.  Returns 1 on success,\n    0 on failure (in both cases descriptor is closed) or -1 if exe\n    is non-zero and the ELF file is ET_DYN, which tells the caller that\n@@ -2616,55 +3968,61 @@ backtrace_uncompress_zdebug (struct backtrace_state *state,\n \n static int\n elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n+\t const unsigned char *memory, size_t memory_size,\n \t uintptr_t base_address, backtrace_error_callback error_callback,\n \t void *data, fileline *fileline_fn, int *found_sym, int *found_dwarf,\n \t struct dwarf_data **fileline_entry, int exe, int debuginfo,\n \t const char *with_buildid_data, uint32_t with_buildid_size)\n {\n-  struct backtrace_view ehdr_view;\n+  struct elf_view ehdr_view;\n   b_elf_ehdr ehdr;\n   off_t shoff;\n   unsigned int shnum;\n   unsigned int shstrndx;\n-  struct backtrace_view shdrs_view;\n+  struct elf_view shdrs_view;\n   int shdrs_view_valid;\n   const b_elf_shdr *shdrs;\n   const b_elf_shdr *shstrhdr;\n   size_t shstr_size;\n   off_t shstr_off;\n-  struct backtrace_view names_view;\n+  struct elf_view names_view;\n   int names_view_valid;\n   const char *names;\n   unsigned int symtab_shndx;\n   unsigned int dynsym_shndx;\n   unsigned int i;\n   struct debug_section_info sections[DEBUG_MAX];\n   struct debug_section_info zsections[DEBUG_MAX];\n-  struct backtrace_view symtab_view;\n+  struct elf_view symtab_view;\n   int symtab_view_valid;\n-  struct backtrace_view strtab_view;\n+  struct elf_view strtab_view;\n   int strtab_view_valid;\n-  struct backtrace_view buildid_view;\n+  struct elf_view buildid_view;\n   int buildid_view_valid;\n   const char *buildid_data;\n   uint32_t buildid_size;\n-  struct backtrace_view debuglink_view;\n+  struct elf_view debuglink_view;\n   int debuglink_view_valid;\n   const char *debuglink_name;\n   uint32_t debuglink_crc;\n-  struct backtrace_view debugaltlink_view;\n+  struct elf_view debugaltlink_view;\n   int debugaltlink_view_valid;\n   const char *debugaltlink_name;\n   const char *debugaltlink_buildid_data;\n   uint32_t debugaltlink_buildid_size;\n+  struct elf_view gnu_debugdata_view;\n+  int gnu_debugdata_view_valid;\n+  size_t gnu_debugdata_size;\n+  unsigned char *gnu_debugdata_uncompressed;\n+  size_t gnu_debugdata_uncompressed_size;\n   off_t min_offset;\n   off_t max_offset;\n   off_t debug_size;\n-  struct backtrace_view debug_view;\n+  struct elf_view debug_view;\n   int debug_view_valid;\n   unsigned int using_debug_view;\n   uint16_t *zdebug_table;\n-  struct backtrace_view split_debug_view[DEBUG_MAX];\n+  struct elf_view split_debug_view[DEBUG_MAX];\n   unsigned char split_debug_view_valid[DEBUG_MAX];\n   struct elf_ppc64_opd_data opd_data, *opd;\n   struct dwarf_sections dwarf_sections;\n@@ -2689,17 +4047,19 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n   debugaltlink_name = NULL;\n   debugaltlink_buildid_data = NULL;\n   debugaltlink_buildid_size = 0;\n+  gnu_debugdata_view_valid = 0;\n+  gnu_debugdata_size = 0;\n   debug_view_valid = 0;\n   memset (&split_debug_view_valid[0], 0, sizeof split_debug_view_valid);\n   opd = NULL;\n \n-  if (!backtrace_get_view (state, descriptor, 0, sizeof ehdr, error_callback,\n-\t\t\t   data, &ehdr_view))\n+  if (!elf_get_view (state, descriptor, memory, memory_size, 0, sizeof ehdr,\n+\t\t     error_callback, data, &ehdr_view))\n     goto fail;\n \n-  memcpy (&ehdr, ehdr_view.data, sizeof ehdr);\n+  memcpy (&ehdr, ehdr_view.view.data, sizeof ehdr);\n \n-  backtrace_release_view (state, &ehdr_view, error_callback, data);\n+  elf_release_view (state, &ehdr_view, error_callback, data);\n \n   if (ehdr.e_ident[EI_MAG0] != ELFMAG0\n       || ehdr.e_ident[EI_MAG1] != ELFMAG1\n@@ -2747,14 +4107,14 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n   if ((shnum == 0 || shstrndx == SHN_XINDEX)\n       && shoff != 0)\n     {\n-      struct backtrace_view shdr_view;\n+      struct elf_view shdr_view;\n       const b_elf_shdr *shdr;\n \n-      if (!backtrace_get_view (state, descriptor, shoff, sizeof shdr,\n-\t\t\t       error_callback, data, &shdr_view))\n+      if (!elf_get_view (state, descriptor, memory, memory_size, shoff,\n+\t\t\t sizeof shdr, error_callback, data, &shdr_view))\n \tgoto fail;\n \n-      shdr = (const b_elf_shdr *) shdr_view.data;\n+      shdr = (const b_elf_shdr *) shdr_view.view.data;\n \n       if (shnum == 0)\n \tshnum = shdr->sh_size;\n@@ -2778,7 +4138,7 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t    shstrndx -= 0x100;\n \t}\n \n-      backtrace_release_view (state, &shdr_view, error_callback, data);\n+      elf_release_view (state, &shdr_view, error_callback, data);\n     }\n \n   if (shnum == 0 || shstrndx == 0)\n@@ -2789,24 +4149,25 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \n   /* Read the section headers, skipping the first one.  */\n \n-  if (!backtrace_get_view (state, descriptor, shoff + sizeof (b_elf_shdr),\n-\t\t\t   (shnum - 1) * sizeof (b_elf_shdr),\n-\t\t\t   error_callback, data, &shdrs_view))\n+  if (!elf_get_view (state, descriptor, memory, memory_size,\n+\t\t     shoff + sizeof (b_elf_shdr),\n+\t\t     (shnum - 1) * sizeof (b_elf_shdr),\n+\t\t     error_callback, data, &shdrs_view))\n     goto fail;\n   shdrs_view_valid = 1;\n-  shdrs = (const b_elf_shdr *) shdrs_view.data;\n+  shdrs = (const b_elf_shdr *) shdrs_view.view.data;\n \n   /* Read the section names.  */\n \n   shstrhdr = &shdrs[shstrndx - 1];\n   shstr_size = shstrhdr->sh_size;\n   shstr_off = shstrhdr->sh_offset;\n \n-  if (!backtrace_get_view (state, descriptor, shstr_off, shstrhdr->sh_size,\n-\t\t\t   error_callback, data, &names_view))\n+  if (!elf_get_view (state, descriptor, memory, memory_size, shstr_off,\n+\t\t     shstrhdr->sh_size, error_callback, data, &names_view))\n     goto fail;\n   names_view_valid = 1;\n-  names = (const char *) names_view.data;\n+  names = (const char *) names_view.view.data;\n \n   symtab_shndx = 0;\n   dynsym_shndx = 0;\n@@ -2871,13 +4232,13 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t{\n \t  const b_elf_note *note;\n \n-\t  if (!backtrace_get_view (state, descriptor, shdr->sh_offset,\n-\t\t\t\t   shdr->sh_size, error_callback, data,\n-\t\t\t\t   &buildid_view))\n+\t  if (!elf_get_view (state, descriptor, memory, memory_size,\n+\t\t\t     shdr->sh_offset, shdr->sh_size, error_callback,\n+\t\t\t     data, &buildid_view))\n \t    goto fail;\n \n \t  buildid_view_valid = 1;\n-\t  note = (const b_elf_note *) buildid_view.data;\n+\t  note = (const b_elf_note *) buildid_view.view.data;\n \t  if (note->type == NT_GNU_BUILD_ID\n \t      && note->namesz == 4\n \t      && strncmp (note->name, \"GNU\", 4) == 0\n@@ -2905,13 +4266,13 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t  const char *debuglink_data;\n \t  size_t crc_offset;\n \n-\t  if (!backtrace_get_view (state, descriptor, shdr->sh_offset,\n-\t\t\t\t   shdr->sh_size, error_callback, data,\n-\t\t\t\t   &debuglink_view))\n+\t  if (!elf_get_view (state, descriptor, memory, memory_size,\n+\t\t\t     shdr->sh_offset, shdr->sh_size, error_callback,\n+\t\t\t     data, &debuglink_view))\n \t    goto fail;\n \n \t  debuglink_view_valid = 1;\n-\t  debuglink_data = (const char *) debuglink_view.data;\n+\t  debuglink_data = (const char *) debuglink_view.view.data;\n \t  crc_offset = strnlen (debuglink_data, shdr->sh_size);\n \t  crc_offset = (crc_offset + 3) & ~3;\n \t  if (crc_offset + 4 <= shdr->sh_size)\n@@ -2927,13 +4288,13 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t  const char *debugaltlink_data;\n \t  size_t debugaltlink_name_len;\n \n-\t  if (!backtrace_get_view (state, descriptor, shdr->sh_offset,\n-\t\t\t\t   shdr->sh_size, error_callback, data,\n-\t\t\t\t   &debugaltlink_view))\n+\t  if (!elf_get_view (state, descriptor, memory, memory_size,\n+\t\t\t     shdr->sh_offset, shdr->sh_size, error_callback,\n+\t\t\t     data, &debugaltlink_view))\n \t    goto fail;\n \n \t  debugaltlink_view_valid = 1;\n-\t  debugaltlink_data = (const char *) debugaltlink_view.data;\n+\t  debugaltlink_data = (const char *) debugaltlink_view.view.data;\n \t  debugaltlink_name = debugaltlink_data;\n \t  debugaltlink_name_len = strnlen (debugaltlink_data, shdr->sh_size);\n \t  if (debugaltlink_name_len < shdr->sh_size)\n@@ -2947,20 +4308,32 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t    }\n \t}\n \n+      if (!gnu_debugdata_view_valid\n+\t  && strcmp (name, \".gnu_debugdata\") == 0)\n+\t{\n+\t  if (!elf_get_view (state, descriptor, memory, memory_size,\n+\t\t\t     shdr->sh_offset, shdr->sh_size, error_callback,\n+\t\t\t     data, &gnu_debugdata_view))\n+\t    goto fail;\n+\n+\t  gnu_debugdata_size = shdr->sh_size;\n+\t  gnu_debugdata_view_valid = 1;\n+\t}\n+\n       /* Read the .opd section on PowerPC64 ELFv1.  */\n       if (ehdr.e_machine == EM_PPC64\n \t  && (ehdr.e_flags & EF_PPC64_ABI) < 2\n \t  && shdr->sh_type == SHT_PROGBITS\n \t  && strcmp (name, \".opd\") == 0)\n \t{\n-\t  if (!backtrace_get_view (state, descriptor, shdr->sh_offset,\n-\t\t\t\t   shdr->sh_size, error_callback, data,\n-\t\t\t\t   &opd_data.view))\n+\t  if (!elf_get_view (state, descriptor, memory, memory_size,\n+\t\t\t     shdr->sh_offset, shdr->sh_size, error_callback,\n+\t\t\t     data, &opd_data.view))\n \t    goto fail;\n \n \t  opd = &opd_data;\n \t  opd->addr = shdr->sh_addr;\n-\t  opd->data = (const char *) opd_data.view.data;\n+\t  opd->data = (const char *) opd_data.view.view.data;\n \t  opd->size = shdr->sh_size;\n \t}\n     }\n@@ -2984,15 +4357,15 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t}\n       strtab_shdr = &shdrs[strtab_shndx - 1];\n \n-      if (!backtrace_get_view (state, descriptor, symtab_shdr->sh_offset,\n-\t\t\t       symtab_shdr->sh_size, error_callback, data,\n-\t\t\t       &symtab_view))\n+      if (!elf_get_view (state, descriptor, memory, memory_size,\n+\t\t\t symtab_shdr->sh_offset, symtab_shdr->sh_size,\n+\t\t\t error_callback, data, &symtab_view))\n \tgoto fail;\n       symtab_view_valid = 1;\n \n-      if (!backtrace_get_view (state, descriptor, strtab_shdr->sh_offset,\n-\t\t\t       strtab_shdr->sh_size, error_callback, data,\n-\t\t\t       &strtab_view))\n+      if (!elf_get_view (state, descriptor, memory, memory_size,\n+\t\t\t strtab_shdr->sh_offset, strtab_shdr->sh_size,\n+\t\t\t error_callback, data, &strtab_view))\n \tgoto fail;\n       strtab_view_valid = 1;\n \n@@ -3002,8 +4375,8 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \tgoto fail;\n \n       if (!elf_initialize_syminfo (state, base_address,\n-\t\t\t\t   symtab_view.data, symtab_shdr->sh_size,\n-\t\t\t\t   strtab_view.data, strtab_shdr->sh_size,\n+\t\t\t\t   symtab_view.view.data, symtab_shdr->sh_size,\n+\t\t\t\t   strtab_view.view.data, strtab_shdr->sh_size,\n \t\t\t\t   error_callback, data, sdata, opd))\n \t{\n \t  backtrace_free (state, sdata, sizeof *sdata, error_callback, data);\n@@ -3012,7 +4385,7 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \n       /* We no longer need the symbol table, but we hold on to the\n \t string table permanently.  */\n-      backtrace_release_view (state, &symtab_view, error_callback, data);\n+      elf_release_view (state, &symtab_view, error_callback, data);\n       symtab_view_valid = 0;\n       strtab_view_valid = 0;\n \n@@ -3021,9 +4394,9 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n       elf_add_syminfo_data (state, sdata);\n     }\n \n-  backtrace_release_view (state, &shdrs_view, error_callback, data);\n+  elf_release_view (state, &shdrs_view, error_callback, data);\n   shdrs_view_valid = 0;\n-  backtrace_release_view (state, &names_view, error_callback, data);\n+  elf_release_view (state, &names_view, error_callback, data);\n   names_view_valid = 0;\n \n   /* If the debug info is in a separate file, read that one instead.  */\n@@ -3038,33 +4411,31 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t{\n \t  int ret;\n \n-\t  backtrace_release_view (state, &buildid_view, error_callback, data);\n+\t  elf_release_view (state, &buildid_view, error_callback, data);\n \t  if (debuglink_view_valid)\n-\t    backtrace_release_view (state, &debuglink_view, error_callback,\n-\t\t\t\t    data);\n+\t    elf_release_view (state, &debuglink_view, error_callback, data);\n \t  if (debugaltlink_view_valid)\n-\t    backtrace_release_view (state, &debugaltlink_view, error_callback,\n-\t\t\t\t    data);\n-\t  ret = elf_add (state, \"\", d, base_address, error_callback, data,\n-\t\t\t fileline_fn, found_sym, found_dwarf, NULL, 0, 1, NULL,\n-\t\t\t 0);\n+\t    elf_release_view (state, &debugaltlink_view, error_callback, data);\n+\t  ret = elf_add (state, \"\", d, NULL, 0, base_address, error_callback,\n+\t\t\t data, fileline_fn, found_sym, found_dwarf, NULL, 0,\n+\t\t\t 1, NULL, 0);\n \t  if (ret < 0)\n \t    backtrace_close (d, error_callback, data);\n-\t  else\n+\t  else if (descriptor >= 0)\n \t    backtrace_close (descriptor, error_callback, data);\n \t  return ret;\n \t}\n     }\n \n   if (buildid_view_valid)\n     {\n-      backtrace_release_view (state, &buildid_view, error_callback, data);\n+      elf_release_view (state, &buildid_view, error_callback, data);\n       buildid_view_valid = 0;\n     }\n \n   if (opd)\n     {\n-      backtrace_release_view (state, &opd->view, error_callback, data);\n+      elf_release_view (state, &opd->view, error_callback, data);\n       opd = NULL;\n     }\n \n@@ -3079,25 +4450,23 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t{\n \t  int ret;\n \n-\t  backtrace_release_view (state, &debuglink_view, error_callback,\n-\t\t\t\t  data);\n+\t  elf_release_view (state, &debuglink_view, error_callback, data);\n \t  if (debugaltlink_view_valid)\n-\t    backtrace_release_view (state, &debugaltlink_view, error_callback,\n-\t\t\t\t    data);\n-\t  ret = elf_add (state, \"\", d, base_address, error_callback, data,\n-\t\t\t fileline_fn, found_sym, found_dwarf, NULL, 0, 1, NULL,\n-\t\t\t 0);\n+\t    elf_release_view (state, &debugaltlink_view, error_callback, data);\n+\t  ret = elf_add (state, \"\", d, NULL, 0, base_address, error_callback,\n+\t\t\t data, fileline_fn, found_sym, found_dwarf, NULL, 0,\n+\t\t\t 1, NULL, 0);\n \t  if (ret < 0)\n \t    backtrace_close (d, error_callback, data);\n-\t  else\n+\t  else if (descriptor >= 0)\n \t    backtrace_close(descriptor, error_callback, data);\n \t  return ret;\n \t}\n     }\n \n   if (debuglink_view_valid)\n     {\n-      backtrace_release_view (state, &debuglink_view, error_callback, data);\n+      elf_release_view (state, &debuglink_view, error_callback, data);\n       debuglink_view_valid = 0;\n     }\n \n@@ -3112,12 +4481,11 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t{\n \t  int ret;\n \n-\t  ret = elf_add (state, filename, d, base_address, error_callback, data,\n-\t\t\t fileline_fn, found_sym, found_dwarf, &fileline_altlink,\n-\t\t\t 0, 1, debugaltlink_buildid_data,\n-\t\t\t debugaltlink_buildid_size);\n-\t  backtrace_release_view (state, &debugaltlink_view, error_callback,\n-\t\t\t\t  data);\n+\t  ret = elf_add (state, filename, d, NULL, 0, base_address,\n+\t\t\t error_callback, data, fileline_fn, found_sym,\n+\t\t\t found_dwarf, &fileline_altlink, 0, 1,\n+\t\t\t debugaltlink_buildid_data, debugaltlink_buildid_size);\n+\t  elf_release_view (state, &debugaltlink_view, error_callback, data);\n \t  debugaltlink_view_valid = 0;\n \t  if (ret < 0)\n \t    {\n@@ -3129,10 +4497,36 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \n   if (debugaltlink_view_valid)\n     {\n-      backtrace_release_view (state, &debugaltlink_view, error_callback, data);\n+      elf_release_view (state, &debugaltlink_view, error_callback, data);\n       debugaltlink_view_valid = 0;\n     }\n \n+  if (gnu_debugdata_view_valid)\n+    {\n+      int ret;\n+\n+      ret = elf_uncompress_lzma (state,\n+\t\t\t\t ((const unsigned char *)\n+\t\t\t\t  gnu_debugdata_view.view.data),\n+\t\t\t\t gnu_debugdata_size, error_callback, data,\n+\t\t\t\t &gnu_debugdata_uncompressed,\n+\t\t\t\t &gnu_debugdata_uncompressed_size);\n+\n+      elf_release_view (state, &gnu_debugdata_view, error_callback, data);\n+      gnu_debugdata_view_valid = 0;\n+\n+      if (ret)\n+\t{\n+\t  ret = elf_add (state, filename, -1, gnu_debugdata_uncompressed,\n+\t\t\t gnu_debugdata_uncompressed_size, base_address,\n+\t\t\t error_callback, data, fileline_fn, found_sym,\n+\t\t\t found_dwarf, NULL, 0, 0, NULL, 0);\n+\t  if (ret >= 0 && descriptor >= 0)\n+\t    backtrace_close(descriptor, error_callback, data);\n+\t  return ret;\n+\t}\n+    }\n+\n   /* Read all the debug sections in a single view, since they are\n      probably adjacent in the file.  If any of sections are\n      uncompressed, we never release this view.  */\n@@ -3165,8 +4559,11 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n     }\n   if (min_offset == 0 || max_offset == 0)\n     {\n-      if (!backtrace_close (descriptor, error_callback, data))\n-\tgoto fail;\n+      if (descriptor >= 0)\n+\t{\n+\t  if (!backtrace_close (descriptor, error_callback, data))\n+\t    goto fail;\n+\t}\n       return 1;\n     }\n \n@@ -3176,9 +4573,9 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n   if (max_offset - min_offset < 0x20000000\n       || max_offset - min_offset < debug_size + 0x10000)\n     {\n-      if (!backtrace_get_view (state, descriptor, min_offset,\n-\t\t\t       max_offset - min_offset,\n-\t\t\t       error_callback, data, &debug_view))\n+      if (!elf_get_view (state, descriptor, memory, memory_size, min_offset,\n+\t\t\t max_offset - min_offset, error_callback, data,\n+\t\t\t &debug_view))\n \tgoto fail;\n       debug_view_valid = 1;\n     }\n@@ -3196,24 +4593,28 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t  else\n \t    continue;\n \n-\t  if (!backtrace_get_view (state, descriptor, dsec->offset, dsec->size,\n-\t\t\t\t   error_callback, data, &split_debug_view[i]))\n+\t  if (!elf_get_view (state, descriptor, memory, memory_size,\n+\t\t\t     dsec->offset, dsec->size, error_callback, data,\n+\t\t\t     &split_debug_view[i]))\n \t    goto fail;\n \t  split_debug_view_valid[i] = 1;\n \n \t  if (sections[i].size != 0)\n \t    sections[i].data = ((const unsigned char *)\n-\t\t\t\tsplit_debug_view[i].data);\n+\t\t\t\tsplit_debug_view[i].view.data);\n \t  else\n \t    zsections[i].data = ((const unsigned char *)\n-\t\t\t\t split_debug_view[i].data);\n+\t\t\t\t split_debug_view[i].view.data);\n \t}\n     }\n \n   /* We've read all we need from the executable.  */\n-  if (!backtrace_close (descriptor, error_callback, data))\n-    goto fail;\n-  descriptor = -1;\n+  if (descriptor >= 0)\n+    {\n+      if (!backtrace_close (descriptor, error_callback, data))\n+\tgoto fail;\n+      descriptor = -1;\n+    }\n \n   using_debug_view = 0;\n   if (debug_view_valid)\n@@ -3224,15 +4625,15 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t    sections[i].data = NULL;\n \t  else\n \t    {\n-\t      sections[i].data = ((const unsigned char *) debug_view.data\n+\t      sections[i].data = ((const unsigned char *) debug_view.view.data\n \t\t\t\t  + (sections[i].offset - min_offset));\n \t      ++using_debug_view;\n \t    }\n \n \t  if (zsections[i].size == 0)\n \t    zsections[i].data = NULL;\n \t  else\n-\t    zsections[i].data = ((const unsigned char *) debug_view.data\n+\t    zsections[i].data = ((const unsigned char *) debug_view.view.data\n \t\t\t\t + (zsections[i].offset - min_offset));\n \t}\n     }\n@@ -3269,8 +4670,8 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \n \t  if (split_debug_view_valid[i])\n \t    {\n-\t      backtrace_release_view (state, &split_debug_view[i],\n-\t\t\t\t      error_callback, data);\n+\t      elf_release_view (state, &split_debug_view[i],\n+\t\t\t\terror_callback, data);\n \t      split_debug_view_valid[i] = 0;\n \t    }\n \t}\n@@ -3309,8 +4710,7 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t--using_debug_view;\n       else if (split_debug_view_valid[i])\n \t{\n-\t  backtrace_release_view (state, &split_debug_view[i],\n-\t\t\t\t  error_callback, data);\n+\t  elf_release_view (state, &split_debug_view[i], error_callback, data);\n \t  split_debug_view_valid[i] = 0;\n \t}\n     }\n@@ -3321,7 +4721,7 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \n   if (debug_view_valid && using_debug_view == 0)\n     {\n-      backtrace_release_view (state, &debug_view, error_callback, data);\n+      elf_release_view (state, &debug_view, error_callback, data);\n       debug_view_valid = 0;\n     }\n \n@@ -3344,30 +4744,31 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \n  fail:\n   if (shdrs_view_valid)\n-    backtrace_release_view (state, &shdrs_view, error_callback, data);\n+    elf_release_view (state, &shdrs_view, error_callback, data);\n   if (names_view_valid)\n-    backtrace_release_view (state, &names_view, error_callback, data);\n+    elf_release_view (state, &names_view, error_callback, data);\n   if (symtab_view_valid)\n-    backtrace_release_view (state, &symtab_view, error_callback, data);\n+    elf_release_view (state, &symtab_view, error_callback, data);\n   if (strtab_view_valid)\n-    backtrace_release_view (state, &strtab_view, error_callback, data);\n+    elf_release_view (state, &strtab_view, error_callback, data);\n   if (debuglink_view_valid)\n-    backtrace_release_view (state, &debuglink_view, error_callback, data);\n+    elf_release_view (state, &debuglink_view, error_callback, data);\n   if (debugaltlink_view_valid)\n-    backtrace_release_view (state, &debugaltlink_view, error_callback, data);\n+    elf_release_view (state, &debugaltlink_view, error_callback, data);\n+  if (gnu_debugdata_view_valid)\n+    elf_release_view (state, &gnu_debugdata_view, error_callback, data);\n   if (buildid_view_valid)\n-    backtrace_release_view (state, &buildid_view, error_callback, data);\n+    elf_release_view (state, &buildid_view, error_callback, data);\n   if (debug_view_valid)\n-    backtrace_release_view (state, &debug_view, error_callback, data);\n+    elf_release_view (state, &debug_view, error_callback, data);\n   for (i = 0; i < (int) DEBUG_MAX; ++i)\n     {\n       if (split_debug_view_valid[i])\n-\tbacktrace_release_view (state, &split_debug_view[i],\n-\t\t\t\terror_callback, data);\n+\telf_release_view (state, &split_debug_view[i], error_callback, data);\n     }\n   if (opd)\n-    backtrace_release_view (state, &opd->view, error_callback, data);\n-  if (descriptor != -1)\n+    elf_release_view (state, &opd->view, error_callback, data);\n+  if (descriptor >= 0)\n     backtrace_close (descriptor, error_callback, data);\n   return 0;\n }\n@@ -3429,7 +4830,7 @@ phdr_callback (struct dl_phdr_info *info, size_t size ATTRIBUTE_UNUSED,\n \treturn 0;\n     }\n \n-  if (elf_add (pd->state, filename, descriptor, info->dlpi_addr,\n+  if (elf_add (pd->state, filename, descriptor, NULL, 0, info->dlpi_addr,\n \t       pd->error_callback, pd->data, &elf_fileline_fn, pd->found_sym,\n \t       &found_dwarf, NULL, 0, 0, NULL, 0))\n     {\n@@ -3458,7 +4859,7 @@ backtrace_initialize (struct backtrace_state *state, const char *filename,\n   fileline elf_fileline_fn = elf_nodebug;\n   struct phdr_data pd;\n \n-  ret = elf_add (state, filename, descriptor, 0, error_callback, data,\n+  ret = elf_add (state, filename, descriptor, NULL, 0, 0, error_callback, data,\n \t\t &elf_fileline_fn, &found_sym, &found_dwarf, NULL, 1, 0, NULL,\n \t\t 0);\n   if (!ret)"}, {"sha": "098623374560458475c57efe00799ebdf0d85508", "filename": "libbacktrace/internal.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Finternal.h?ref=05f40bc4c116ba48843728201bc7290a5e518598", "patch": "@@ -335,4 +335,13 @@ extern int backtrace_uncompress_zdebug (struct backtrace_state *,\n \t\t\t\t\tunsigned char **uncompressed,\n \t\t\t\t\tsize_t *uncompressed_size);\n \n+/* A test-only hook for elf_uncompress_lzma.  */\n+\n+extern int backtrace_uncompress_lzma (struct backtrace_state *,\n+\t\t\t\t      const unsigned char *compressed,\n+\t\t\t\t      size_t compressed_size,\n+\t\t\t\t      backtrace_error_callback, void *data,\n+\t\t\t\t      unsigned char **uncompressed,\n+\t\t\t\t      size_t *uncompressed_size);\n+\n #endif"}, {"sha": "d90fd1e33cc36ba64c5885c262263fb41f16eea3", "filename": "libbacktrace/mtest.c", "status": "added", "additions": 401, "deletions": 0, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Fmtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Fmtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fmtest.c?ref=05f40bc4c116ba48843728201bc7290a5e518598", "patch": "@@ -0,0 +1,401 @@\n+/* mtest.c -- Minidebug test for libbacktrace library\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* This program tests using libbacktrace with a program that uses the\n+   minidebuginfo format in a .gnu_debugdata section.  See\n+   https://sourceware.org/gdb/current/onlinedocs/gdb/MiniDebugInfo.html\n+   for a bit more information about minidebuginfo.  What is relevant\n+   for libbacktrace is that we have just a symbol table, with no debug\n+   info, so we should be able to do a function backtrace, but we can't\n+   do a file/line backtrace.  */\n+\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+#include \"testlib.h\"\n+\n+static int test1 (void) __attribute__ ((noinline, noclone, unused));\n+static int f2 (int) __attribute__ ((noinline, noclone));\n+static int f3 (int, int) __attribute__ ((noinline, noclone));\n+\n+/* Collected PC values.  */\n+\n+static uintptr_t addrs[20];\n+\n+/* The backtrace callback function.  This is like callback_one in\n+   testlib.c, but it saves the PC also.  */\n+\n+static int\n+callback_mtest (void *vdata, uintptr_t pc, const char *filename, int lineno,\n+\t\tconst char *function)\n+{\n+  struct bdata *data = (struct bdata *) vdata;\n+\n+  if (data->index >= sizeof addrs / sizeof addrs[0])\n+    {\n+      fprintf (stderr, \"callback_mtest: callback called too many times\\n\");\n+      data->failed = 1;\n+      return 1;\n+    }\n+\n+  addrs[data->index] = pc;\n+\n+  return callback_one (vdata, pc, filename, lineno, function);\n+}\n+\n+/* Test the backtrace function with non-inlined functions.  (We don't\n+   test with inlined functions because they won't work with minidebug\n+   anyhow.)  */\n+\n+static int\n+test1 (void)\n+{\n+  /* Returning a value here and elsewhere avoids a tailcall which\n+     would mess up the backtrace.  */\n+  return f2 (__LINE__) + 1;\n+}\n+\n+static int\n+f2 (int f1line)\n+{\n+  return f3 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f3 (int f1line __attribute__ ((unused)), int f2line __attribute__ ((unused)))\n+{\n+  struct info all[20];\n+  struct bdata data;\n+  int i;\n+  size_t j;\n+\n+  data.all = &all[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  i = backtrace_full (state, 0, callback_mtest, error_callback_one, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test1: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (data.index < 3)\n+    {\n+      fprintf (stderr,\n+\t       \"test1: not enough frames; got %zu, expected at least 3\\n\",\n+\t       data.index);\n+      data.failed = 1;\n+    }\n+\n+  /* When using minidebug we don't expect the function name here.  */\n+\n+  for (j = 0; j < 3 && j < data.index; j++)\n+    {\n+      if (all[j].function == NULL)\n+\t{\n+\t  struct symdata symdata;\n+\n+\t  symdata.name = NULL;\n+\t  symdata.val = 0;\n+\t  symdata.size = 0;\n+\t  symdata.failed = 0;\n+\n+\t  i = backtrace_syminfo (state, addrs[j], callback_three,\n+\t\t\t\t error_callback_three, &symdata);\n+\t  if (i == 0)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"test1: [%zu], unexpected return value from \"\n+\t\t\t\"backtrace_syminfo %d\\n\"),\n+\t\t       j, i);\n+\t      data.failed = 1;\n+\t    }\n+\t  else if (symdata.name == NULL)\n+\t    {\n+\t      fprintf (stderr, \"test1: [%zu]: syminfo did not find name\\n\", j);\n+\t      data.failed = 1;\n+\t    }\n+\t  else\n+\t    all[j].function = strdup (symdata.name);\n+\t}\n+    }\n+\n+  if (all[0].function == NULL)\n+    {\n+      fprintf (stderr, \"test1: [0]: missing function name\\n\");\n+      data.failed = 1;\n+    }\n+  else if (strcmp (all[0].function, \"f3\") != 0)\n+    {\n+      fprintf (stderr, \"test1: [0]: got %s expected %s\\n\",\n+\t       all[0].function, \"f3\");\n+      data.failed = 1;\n+    }\n+\n+  if (all[1].function == NULL)\n+    {\n+      fprintf (stderr, \"test1: [1]: missing function name\\n\");\n+      data.failed = 1;\n+    }\n+  else if (strcmp (all[1].function, \"f2\") != 0)\n+    {\n+      fprintf (stderr, \"test1: [1]: got %s expected %s\\n\",\n+\t       all[0].function, \"f2\");\n+      data.failed = 1;\n+    }\n+\n+  if (all[2].function == NULL)\n+    {\n+      fprintf (stderr, \"test1: [2]: missing function name\\n\");\n+      data.failed = 1;\n+    }\n+  else if (strcmp (all[2].function, \"test1\") != 0)\n+    {\n+      fprintf (stderr, \"test1: [2]: got %s expected %s\\n\",\n+\t       all[0].function, \"test1\");\n+      data.failed = 1;\n+    }\n+\n+  printf (\"%s: backtrace_full noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+/* Test the backtrace_simple function with non-inlined functions.  */\n+\n+static int test3 (void) __attribute__ ((noinline, noclone, unused));\n+static int f22 (int) __attribute__ ((noinline, noclone));\n+static int f23 (int, int) __attribute__ ((noinline, noclone));\n+\n+static int\n+test3 (void)\n+{\n+  return f22 (__LINE__) + 1;\n+}\n+\n+static int\n+f22 (int f1line)\n+{\n+  return f23 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f23 (int f1line __attribute__ ((unused)), int f2line __attribute__ ((unused)))\n+{\n+  uintptr_t addrs[20];\n+  struct sdata data;\n+  int i;\n+\n+  data.addrs = &addrs[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  i = backtrace_simple (state, 0, callback_two, error_callback_two, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test3: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (!data.failed)\n+    {\n+      int j;\n+\n+      for (j = 0; j < 3; ++j)\n+\t{\n+\t  struct symdata symdata;\n+\n+\t  symdata.name = NULL;\n+\t  symdata.val = 0;\n+\t  symdata.size = 0;\n+\t  symdata.failed = 0;\n+\n+\t  i = backtrace_syminfo (state, addrs[j], callback_three,\n+\t\t\t\t error_callback_three, &symdata);\n+\t  if (i == 0)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"test3: [%d]: unexpected return value \"\n+\t\t\t\"from backtrace_syminfo %d\\n\"),\n+\t\t       j, i);\n+\t      symdata.failed = 1;\n+\t    }\n+\n+\t  if (!symdata.failed)\n+\t    {\n+\t      const char *expected;\n+\n+\t      switch (j)\n+\t\t{\n+\t\tcase 0:\n+\t\t  expected = \"f23\";\n+\t\t  break;\n+\t\tcase 1:\n+\t\t  expected = \"f22\";\n+\t\t  break;\n+\t\tcase 2:\n+\t\t  expected = \"test3\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  assert (0);\n+\t\t}\n+\n+\t      if (symdata.name == NULL)\n+\t\t{\n+\t\t  fprintf (stderr, \"test3: [%d]: NULL syminfo name\\n\", j);\n+\t\t  symdata.failed = 1;\n+\t\t}\n+\t      /* Use strncmp, not strcmp, because GCC might create a\n+\t\t clone.  */\n+\t      else if (strncmp (symdata.name, expected, strlen (expected))\n+\t\t       != 0)\n+\t\t{\n+\t\t  fprintf (stderr,\n+\t\t\t   (\"test3: [%d]: unexpected syminfo name \"\n+\t\t\t    \"got %s expected %s\\n\"),\n+\t\t\t   j, symdata.name, expected);\n+\t\t  symdata.failed = 1;\n+\t\t}\n+\t    }\n+\n+\t  if (symdata.failed)\n+\t    data.failed = 1;\n+\t}\n+    }\n+\n+  printf (\"%s: backtrace_simple noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+int test5 (void) __attribute__ ((unused));\n+\n+int global = 1;\n+\n+int\n+test5 (void)\n+{\n+  struct symdata symdata;\n+  int i;\n+  uintptr_t addr = (uintptr_t) &global;\n+\n+  if (sizeof (global) > 1)\n+    addr += 1;\n+\n+  symdata.name = NULL;\n+  symdata.val = 0;\n+  symdata.size = 0;\n+  symdata.failed = 0;\n+\n+  i = backtrace_syminfo (state, addr, callback_three,\n+\t\t\t error_callback_three, &symdata);\n+  if (i == 0)\n+    {\n+      fprintf (stderr,\n+\t       \"test5: unexpected return value from backtrace_syminfo %d\\n\",\n+\t       i);\n+      symdata.failed = 1;\n+    }\n+\n+  if (!symdata.failed)\n+    {\n+      if (symdata.name == NULL)\n+\t{\n+\t  fprintf (stderr, \"test5: NULL syminfo name\\n\");\n+\t  symdata.failed = 1;\n+\t}\n+      else if (!(strncmp (symdata.name, \"global\", 6) == 0\n+\t\t && (symdata.name[6] == '\\0'|| symdata.name[6] == '.')))\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo name got %s expected %s\\n\",\n+\t\t   symdata.name, \"global\");\n+\t  symdata.failed = 1;\n+\t}\n+      else if (symdata.val != (uintptr_t) &global)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo value got %lx expected %lx\\n\",\n+\t\t   (unsigned long) symdata.val,\n+\t\t   (unsigned long) (uintptr_t) &global);\n+\t  symdata.failed = 1;\n+\t}\n+      else if (symdata.size != sizeof (global))\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo size got %lx expected %lx\\n\",\n+\t\t   (unsigned long) symdata.size,\n+\t\t   (unsigned long) sizeof (global));\n+\t  symdata.failed = 1;\n+\t}\n+    }\n+\n+  printf (\"%s: backtrace_syminfo variable\\n\",\n+\t  symdata.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (symdata.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+#if BACKTRACE_SUPPORTED\n+  test1 ();\n+  test3 ();\n+#if BACKTRACE_SUPPORTS_DATA\n+  test5 ();\n+#endif\n+#endif\n+\n+  exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"}, {"sha": "4fffe99fcf0bc701c02d2191f4d954173e471d1f", "filename": "libbacktrace/xztest.c", "status": "added", "additions": 508, "deletions": 0, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Fxztest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f40bc4c116ba48843728201bc7290a5e518598/libbacktrace%2Fxztest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fxztest.c?ref=05f40bc4c116ba48843728201bc7290a5e518598", "patch": "@@ -0,0 +1,508 @@\n+/* xztest.c -- Test for libbacktrace LZMA decoder.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <limits.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#ifdef HAVE_LIBLZMA\n+#include <lzma.h>\n+#endif\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+#include \"internal.h\"\n+#include \"testlib.h\"\n+\n+#ifndef HAVE_CLOCK_GETTIME\n+\n+typedef int xclockid_t;\n+\n+static int\n+xclock_gettime (xclockid_t id ATTRIBUTE_UNUSED,\n+\t\tstruct timespec *ts ATTRIBUTE_UNUSED)\n+{\n+  errno = EINVAL;\n+  return -1;\n+}\n+\n+#define clockid_t xclockid_t\n+#define clock_gettime xclock_gettime\n+#undef CLOCK_REALTIME\n+#define CLOCK_REALTIME 0\n+\n+#endif /* !defined(HAVE_CLOCK_GETTIME) */\n+\n+#ifdef CLOCK_PROCESS_CPUTIME_ID\n+#define LIBLZMA_CLOCK_GETTIME_ARG CLOCK_PROCESS_CPUTIME_ID\n+#else\n+#define LIBLZMA_CLOCK_GETTIME_ARG CLOCK_REALTIME\n+#endif\n+\n+/* Some tests for the local lzma inflation code.  */\n+\n+struct lzma_test\n+{\n+  const char *name;\n+  const char *uncompressed;\n+  size_t uncompressed_len;\n+  const char *compressed;\n+  size_t compressed_len;\n+};\n+\n+/* Error callback.  */\n+\n+static void\n+error_callback_compress (void *vdata ATTRIBUTE_UNUSED, const char *msg,\n+\t\t\t int errnum)\n+{\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  exit (EXIT_FAILURE);\n+}\n+\n+static const struct lzma_test tests[] =\n+{\n+  {\n+    \"empty\",\n+    \"\",\n+    0,\n+    (\"\\xfd\\x37\\x7a\\x58\\x5a\\x00\\x00\\x04\\xe6\\xd6\\xb4\\x46\\x00\\x00\\x00\\x00\"\n+     \"\\x1c\\xdf\\x44\\x21\\x1f\\xb6\\xf3\\x7d\\x01\\x00\\x00\\x00\\x00\\x04\\x59\\x5a\"),\n+    32,\n+  },\n+  {\n+    \"hello\",\n+    \"hello, world\\n\",\n+    0,\n+    (\"\\xfd\\x37\\x7a\\x58\\x5a\\x00\\x00\\x04\\xe6\\xd6\\xb4\\x46\\x02\\x00\\x21\\x01\"\n+     \"\\x16\\x00\\x00\\x00\\x74\\x2f\\xe5\\xa3\\x01\\x00\\x0c\\x68\\x65\\x6c\\x6c\\x6f\"\n+     \"\\x2c\\x20\\x77\\x6f\\x72\\x6c\\x64\\x0a\\x00\\x00\\x00\\x00\\x7b\\x46\\x5a\\x81\"\n+     \"\\xc9\\x12\\xb8\\xea\\x00\\x01\\x25\\x0d\\x71\\x19\\xc4\\xb6\\x1f\\xb6\\xf3\\x7d\"\n+     \"\\x01\\x00\\x00\\x00\\x00\\x04\\x59\\x5a\"),\n+    72,\n+  },\n+  {\n+    \"goodbye\",\n+    \"goodbye, world\",\n+    0,\n+    (\"\\xfd\\x37\\x7a\\x58\\x5a\\x00\\x00\\x04\\xe6\\xd6\\xb4\\x46\\x02\\x00\\x21\\x01\"\n+     \"\\x16\\x00\\x00\\x00\\x74\\x2f\\xe5\\xa3\\x01\\x00\\x0d\\x67\\x6f\\x6f\\x64\\x62\"\n+     \"\\x79\\x65\\x2c\\x20\\x77\\x6f\\x72\\x6c\\x64\\x00\\x00\\x00\\xf6\\xf8\\xa3\\x33\"\n+     \"\\x8c\\x4e\\xc9\\x68\\x00\\x01\\x26\\x0e\\x08\\x1b\\xe0\\x04\\x1f\\xb6\\xf3\\x7d\"\n+     \"\\x01\\x00\\x00\\x00\\x00\\x04\\x59\\x5a\"),\n+    72,\n+  },\n+};\n+\n+/* Test the hand coded samples.  */\n+\n+static void\n+test_samples (struct backtrace_state *state)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < sizeof tests / sizeof tests[0]; ++i)\n+    {\n+      unsigned char *uncompressed;\n+      size_t uncompressed_len;\n+\n+      uncompressed = NULL;\n+      uncompressed_len = 0;\n+      if (!backtrace_uncompress_lzma (state,\n+\t\t\t\t      ((const unsigned char *)\n+\t\t\t\t       tests[i].compressed),\n+\t\t\t\t      tests[i].compressed_len,\n+\t\t\t\t      error_callback_compress, NULL,\n+\t\t\t\t      &uncompressed, &uncompressed_len))\n+\t{\n+\t  fprintf (stderr, \"test %s: uncompress failed\\n\", tests[i].name);\n+\t  ++failures;\n+\t}\n+      else\n+\t{\n+\t  size_t v;\n+\n+\t  v = tests[i].uncompressed_len;\n+\t  if (v == 0)\n+\t    v = strlen (tests[i].uncompressed);\n+\t  if (uncompressed_len != v)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       \"test %s: got uncompressed length %zu, want %zu\\n\",\n+\t\t       tests[i].name, uncompressed_len, v);\n+\t      ++failures;\n+\t    }\n+\t  else if (memcmp (tests[i].uncompressed, uncompressed, v) != 0)\n+\t    {\n+\t      size_t j;\n+\n+\t      fprintf (stderr, \"test %s: uncompressed data mismatch\\n\",\n+\t\t       tests[i].name);\n+\t      for (j = 0; j < v; ++j)\n+\t\tif (tests[i].uncompressed[j] != uncompressed[j])\n+\t\t  fprintf (stderr, \"  %zu: got %#x want %#x\\n\", j,\n+\t\t\t   uncompressed[j], tests[i].uncompressed[j]);\n+\t      ++failures;\n+\t    }\n+\t  else\n+\t    printf (\"PASS: lzma %s\\n\", tests[i].name);\n+\n+\t  backtrace_free (state, uncompressed, uncompressed_len,\n+\t\t\t  error_callback_compress, NULL);\n+\t}\n+    }\n+}\n+\n+#if HAVE_LIBLZMA\n+\n+/* Given a set of TRIALS timings, discard the lowest and highest\n+   values and return the mean average of the rest.  */\n+\n+static size_t\n+average_time (const size_t *times, size_t trials)\n+{\n+  size_t imax;\n+  size_t max;\n+  size_t imin;\n+  size_t min;\n+  size_t i;\n+  size_t sum;\n+\n+  imin = 0;\n+  imax = 0;\n+  min = times[0];\n+  max = times[0];\n+  for (i = 1; i < trials; ++i)\n+    {\n+      if (times[i] < min)\n+\t{\n+\t  imin = i;\n+\t  min = times[i];\n+\t}\n+      if (times[i] > max)\n+\t{\n+\t  imax = i;\n+\t  max = times[i];\n+\t}\n+    }\n+\n+  sum = 0;\n+  for (i = 0; i < trials; ++i)\n+    {\n+      if (i != imax && i != imin)\n+\tsum += times[i];\n+    }\n+  return sum / (trials - 2);\n+}\n+\n+#endif\n+\n+/* Test a larger text, if available.  */\n+\n+static void\n+test_large (struct backtrace_state *state ATTRIBUTE_UNUSED)\n+{\n+#if HAVE_LIBLZMA\n+  unsigned char *orig_buf;\n+  size_t orig_bufsize;\n+  size_t i;\n+  lzma_stream initial_stream = LZMA_STREAM_INIT;\n+  lzma_stream stream;\n+  unsigned char *compressed_buf;\n+  size_t compressed_bufsize;\n+  unsigned char *uncompressed_buf;\n+  size_t uncompressed_bufsize;\n+  unsigned char *spare_buf;\n+  int r;\n+  clockid_t cid;\n+  struct timespec ts1;\n+  struct timespec ts2;\n+  size_t ctime;\n+  size_t ztime;\n+  const size_t trials = 16;\n+  size_t ctimes[16];\n+  size_t ztimes[16];\n+  static const char * const names[] = {\n+    \"Isaac.Newton-Opticks.txt\",\n+    \"../libgo/go/testdata/Isaac.Newton-Opticks.txt\",\n+  };\n+\n+  orig_buf = NULL;\n+  orig_bufsize = 0;\n+  uncompressed_buf = NULL;\n+  compressed_buf = NULL;\n+\n+  for (i = 0; i < sizeof names / sizeof names[0]; ++i)\n+    {\n+      size_t len;\n+      char *namebuf;\n+      FILE *e;\n+      struct stat st;\n+      char *rbuf;\n+      size_t got;\n+\n+      len = strlen (SRCDIR) + strlen (names[i]) + 2;\n+      namebuf = malloc (len);\n+      if (namebuf == NULL)\n+\t{\n+\t  perror (\"malloc\");\n+\t  goto fail;\n+\t}\n+      snprintf (namebuf, len, \"%s/%s\", SRCDIR, names[i]);\n+      e = fopen (namebuf, \"r\");\n+      free (namebuf);\n+      if (e == NULL)\n+\tcontinue;\n+      if (fstat (fileno (e), &st) < 0)\n+\t{\n+\t  perror (\"fstat\");\n+\t  fclose (e);\n+\t  continue;\n+\t}\n+      rbuf = malloc (st.st_size);\n+      if (rbuf == NULL)\n+\t{\n+\t  perror (\"malloc\");\n+\t  goto fail;\n+\t}\n+      got = fread (rbuf, 1, st.st_size, e);\n+      fclose (e);\n+      if (got > 0)\n+\t{\n+\t  orig_buf = (unsigned char *) rbuf;\n+\t  orig_bufsize = got;\n+\t  break;\n+\t}\n+      free (rbuf);\n+    }\n+\n+  if (orig_buf == NULL)\n+    {\n+      /* We couldn't find an input file.  */\n+      printf (\"UNSUPPORTED: lzma large\\n\");\n+      return;\n+    }\n+\n+  stream = initial_stream;\n+  r =  lzma_easy_encoder (&stream, 6, LZMA_CHECK_CRC32);\n+  if (r != LZMA_OK)\n+    {\n+      fprintf (stderr, \"lzma_easy_encoder failed: %d\\n\", r);\n+      goto fail;\n+    }\n+\n+  compressed_bufsize = orig_bufsize + 100;\n+  compressed_buf = malloc (compressed_bufsize);\n+  if (compressed_buf == NULL)\n+    {\n+      perror (\"malloc\");\n+      goto fail;\n+    }\n+\n+  stream.next_in = orig_buf;\n+  stream.avail_in = orig_bufsize;\n+  stream.next_out = compressed_buf;\n+  stream.avail_out = compressed_bufsize;\n+\n+  do\n+    {\n+      r = lzma_code (&stream, LZMA_FINISH);\n+      if (r != LZMA_OK && r != LZMA_STREAM_END)\n+\t{\n+\t  fprintf (stderr, \"lzma_code failed: %d\\n\", r);\n+\t  goto fail;\n+\t}\n+    }\n+  while (r != LZMA_STREAM_END);\n+\n+  compressed_bufsize = stream.total_out;\n+\n+  if (!backtrace_uncompress_lzma (state, (unsigned char *) compressed_buf,\n+\t\t\t\t  compressed_bufsize,\n+\t\t\t\t  error_callback_compress, NULL,\n+\t\t\t\t  &uncompressed_buf, &uncompressed_bufsize))\n+    {\n+      fprintf (stderr, \"lzma large: backtrace_uncompress_lzma failed\\n\");\n+      goto fail;\n+    }\n+\n+  if (uncompressed_bufsize != orig_bufsize)\n+    {\n+      fprintf (stderr,\n+\t       \"lzma large: got uncompressed length %zu, want %zu\\n\",\n+\t       uncompressed_bufsize, orig_bufsize);\n+      goto fail;\n+    }\n+\n+  if (memcmp (uncompressed_buf, orig_buf, uncompressed_bufsize) != 0)\n+    {\n+      fprintf (stderr, \"lzma large: uncompressed data mismatch\\n\");\n+      goto fail;\n+    }\n+\n+  printf (\"PASS: lzma large\\n\");\n+\n+  spare_buf = malloc (orig_bufsize);\n+  if (spare_buf == NULL)\n+    {\n+      perror (\"malloc\");\n+      goto fail;\n+    }\n+\n+  for (i = 0; i < trials; ++i)\n+    {\n+      cid = LIBLZMA_CLOCK_GETTIME_ARG;\n+      if (clock_gettime (cid, &ts1) < 0)\n+\t{\n+\t  if (errno == EINVAL)\n+\t    return;\n+\t  perror (\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      if (!backtrace_uncompress_lzma (state,\n+\t\t\t\t      (unsigned char *) compressed_buf,\n+\t\t\t\t      compressed_bufsize,\n+\t\t\t\t      error_callback_compress, NULL,\n+\t\t\t\t      &uncompressed_buf,\n+\t\t\t\t      &uncompressed_bufsize))\n+\t{\n+\t  fprintf (stderr,\n+\t\t   (\"lzma large: \"\n+\t\t    \"benchmark backtrace_uncompress_lzma failed\\n\"));\n+\t  return;\n+\t}\n+\n+      if (clock_gettime (cid, &ts2) < 0)\n+\t{\n+\t  perror (\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      ctime = (ts2.tv_sec - ts1.tv_sec) * 1000000000;\n+      ctime += ts2.tv_nsec - ts1.tv_nsec;\n+      ctimes[i] = ctime;\n+\n+      stream = initial_stream;\n+\n+      r = lzma_auto_decoder (&stream, UINT64_MAX, 0);\n+      if (r != LZMA_OK)\n+\t{\n+\t  fprintf (stderr, \"lzma_stream_decoder failed: %d\\n\", r);\n+\t  goto fail;\n+\t}\n+\n+      stream.next_in = compressed_buf;\n+      stream.avail_in = compressed_bufsize;\n+      stream.next_out = spare_buf;\n+      stream.avail_out = orig_bufsize;\n+\n+      if (clock_gettime (cid, &ts1) < 0)\n+\t{\n+\t  perror(\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      do\n+\t{\n+\t  r = lzma_code (&stream, LZMA_FINISH);\n+\t  if (r != LZMA_OK && r != LZMA_STREAM_END)\n+\t    {\n+\t      fprintf (stderr, \"lzma_code failed: %d\\n\", r);\n+\t      goto fail;\n+\t    }\n+\t}\n+      while (r != LZMA_STREAM_END);\n+\n+      if (clock_gettime (cid, &ts2) < 0)\n+\t{\n+\t  perror (\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      ztime = (ts2.tv_sec - ts1.tv_sec) * 1000000000;\n+      ztime += ts2.tv_nsec - ts1.tv_nsec;\n+      ztimes[i] = ztime;\n+    }\n+\n+  /* Toss the highest and lowest times and average the rest.  */\n+  ctime = average_time (ctimes, trials);\n+  ztime = average_time (ztimes, trials);\n+\n+  printf (\"backtrace: %zu ns\\n\", ctime);\n+  printf (\"liblzma  : %zu ns\\n\", ztime);\n+  printf (\"ratio    : %g\\n\", (double) ztime / (double) ctime);\n+\n+  return;\n+\n+ fail:\n+  printf (\"FAIL: lzma large\\n\");\n+  ++failures;\n+\n+  if (orig_buf != NULL)\n+    free (orig_buf);\n+  if (compressed_buf != NULL)\n+    free (compressed_buf);\n+  if (uncompressed_buf != NULL)\n+    free (uncompressed_buf);\n+\n+#else /* !HAVE_LIBLZMA */\n+\n+ printf (\"UNSUPPORTED: lzma large\\n\");\n+\n+#endif /* !HAVE_LIBLZMA */\n+}\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  struct backtrace_state *state;\n+\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+  test_samples (state);\n+  test_large (state);\n+\n+  exit (failures != 0 ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"}]}