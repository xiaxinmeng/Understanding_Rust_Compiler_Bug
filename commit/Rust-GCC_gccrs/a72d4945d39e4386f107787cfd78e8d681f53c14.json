{"sha": "a72d4945d39e4386f107787cfd78e8d681f53c14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcyZDQ5NDVkMzllNDM4NmYxMDc3ODdjZmQ3OGU4ZDY4MWY1M2MxNA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-11-20T11:44:19Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-11-20T11:44:19Z"}, "message": "arm.c (use_return_insn): New argument, SIBLING.\n\n* arm.c (use_return_insn): New argument, SIBLING.  Support returning\nwith a single instruction if the stack has been decremented by 4\nand we have a frame pointer.  Update all callers.\n(output_return_instruction): Likewise.\n(arm_output_epilogue): Change argument to SIBLING.  Calculate\nreally_return from the new argument.  Update all callers.\n* arm.h (USE_RETURN_INSN): Pass NULL for the sibling.\n* arm.md (sibcall_epilogue): Call use_return_insn directly, and\npass the sibling call.\n* arm-protos.h (use_return_insn, arm_output_epilogue): Update\nprototypes.\n\nFrom-SVN: r73761", "tree": {"sha": "029156bebba710b4f4a4a918b838c987c8d482ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/029156bebba710b4f4a4a918b838c987c8d482ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a72d4945d39e4386f107787cfd78e8d681f53c14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a72d4945d39e4386f107787cfd78e8d681f53c14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a72d4945d39e4386f107787cfd78e8d681f53c14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a72d4945d39e4386f107787cfd78e8d681f53c14/comments", "author": null, "committer": null, "parents": [{"sha": "8d98c44cc3fd42db75b088adeb4d6d0977101cf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d98c44cc3fd42db75b088adeb4d6d0977101cf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d98c44cc3fd42db75b088adeb4d6d0977101cf3"}], "stats": {"total": 108, "additions": 92, "deletions": 16}, "files": [{"sha": "0dbbea40c98efcf89be214ab8f12aea246545586", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a72d4945d39e4386f107787cfd78e8d681f53c14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a72d4945d39e4386f107787cfd78e8d681f53c14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a72d4945d39e4386f107787cfd78e8d681f53c14", "patch": "@@ -1,3 +1,17 @@\n+2003-11-20  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (use_return_insn): New argument, SIBLING.  Support returning\n+\twith a single instruction if the stack has been decremented by 4\n+\tand we have a frame pointer.  Update all callers.\n+\t(output_return_instruction): Likewise.\n+\t(arm_output_epilogue): Change argument to SIBLING.  Calculate\n+\treally_return from the new argument.  Update all callers.\n+\t* arm.h (USE_RETURN_INSN): Pass NULL for the sibling.\n+\t* arm.md (sibcall_epilogue): Call use_return_insn directly, and\n+\tpass the sibling call.\n+\t* arm-protos.h (use_return_insn, arm_output_epilogue): Update\n+\tprototypes.\n+\n 2003-11-20  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* Makefile.in (extraclean): Delete."}, {"sha": "471254efe4e1a8d6f53aab3cb32c58abf233989e", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a72d4945d39e4386f107787cfd78e8d681f53c14/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a72d4945d39e4386f107787cfd78e8d681f53c14/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=a72d4945d39e4386f107787cfd78e8d681f53c14", "patch": "@@ -24,11 +24,11 @@\n #define GCC_ARM_PROTOS_H\n \n extern void arm_override_options (void);\n-extern int use_return_insn (int);\n+extern int use_return_insn (int, rtx);\n extern int arm_regno_class (int);\n extern void arm_finalize_pic (int);\n extern int arm_volatile_func (void);\n-extern const char *arm_output_epilogue (int);\n+extern const char *arm_output_epilogue (rtx);\n extern void arm_expand_prologue (void);\n extern HOST_WIDE_INT arm_get_frame_size\t(void);\n extern const char *arm_strip_name_encoding (const char *);"}, {"sha": "44a5fa0284782448cdefcc7a865247d74fdb5822", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 72, "deletions": 10, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a72d4945d39e4386f107787cfd78e8d681f53c14/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a72d4945d39e4386f107787cfd78e8d681f53c14/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a72d4945d39e4386f107787cfd78e8d681f53c14", "patch": "@@ -1002,14 +1002,17 @@ arm_current_func_type (void)\n   return cfun->machine->func_type;\n }\n \f\n-/* Return 1 if it is possible to return using a single instruction.  */\n+/* Return 1 if it is possible to return using a single instruction.  \n+   If SIBLING is non-null, this is a test for a return before a sibling\n+   call.  SIBLING is the call insn, so we can examine its register usage.  */\n \n int\n-use_return_insn (int iscond)\n+use_return_insn (int iscond, rtx sibling)\n {\n   int regno;\n   unsigned int func_type;\n   unsigned long saved_int_regs;\n+  unsigned HOST_WIDE_INT stack_adjust;\n \n   /* Never use a return instruction before reload has run.  */\n   if (!reload_completed)\n@@ -1025,20 +1028,61 @@ use_return_insn (int iscond)\n   /* So do interrupt functions that use the frame pointer.  */\n   if (IS_INTERRUPT (func_type) && frame_pointer_needed)\n     return 0;\n-  \n+\n+  stack_adjust = arm_get_frame_size () + current_function_outgoing_args_size;\n+\n   /* As do variadic functions.  */\n   if (current_function_pretend_args_size\n       || cfun->machine->uses_anonymous_args\n       /* Or if the function calls __builtin_eh_return () */\n       || ARM_FUNC_TYPE (func_type) == ARM_FT_EXCEPTION_HANDLER\n       /* Or if the function calls alloca */\n       || current_function_calls_alloca\n-      /* Or if there is a stack adjustment.  */\n-      || (arm_get_frame_size () + current_function_outgoing_args_size != 0))\n+      /* Or if there is a stack adjustment.  However, if the stack pointer\n+\t is saved on the stack, we can use a pre-incrementing stack load.  */\n+      || !(stack_adjust == 0 || (frame_pointer_needed && stack_adjust == 4)))\n     return 0;\n \n   saved_int_regs = arm_compute_save_reg_mask ();\n \n+  /* Unfortunately, the insn\n+\n+       ldmib sp, {..., sp, ...}\n+\n+     triggers a bug on most SA-110 based devices, such that the stack\n+     pointer won't be correctly restored if the instruction takes a\n+     page fault.  We work around this problem by poping r3 along with\n+     the other registers, since that is never slower than executing\n+     another instruction.  \n+\n+     We test for !arm_arch5 here, because code for any architecture\n+     less than this could potentially be run on one of the buggy\n+     chips.  */\n+  if (stack_adjust == 4 && !arm_arch5)\n+    {\n+      /* Validate that r3 is a call-clobbered register (always true in\n+\t the default abi) ... */\n+      if (!call_used_regs[3])\n+\treturn 0;\n+\n+      /* ... that it isn't being used for a return value (always true\n+\t until we implement return-in-regs), or for a tail-call\n+\t argument ... */\n+      if (sibling)\n+\t{\n+\t  if (GET_CODE (sibling) != CALL_INSN)\n+\t    abort ();\n+\n+\t  if (find_regno_fusage (sibling, USE, 3))\n+\t    return 0;\n+\t}\n+\n+      /* ... and that there are no call-saved registers in r0-r2\n+\t (always true in the default ABI).  */\n+      if (saved_int_regs & 0x7)\n+\treturn 0;\n+    }\n+\n   /* Can't be done if interworking with Thumb, and any registers have been\n      stacked.  */\n   if (TARGET_INTERWORK && saved_int_regs != 0)\n@@ -8194,7 +8238,24 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \t     frame_pointer_needed is true, but only if sp already\n \t     points to the base of the saved core registers.  */\n \t  if (live_regs_mask & (1 << SP_REGNUM))\n-\t    sprintf (instr, \"ldm%sfd\\t%%|sp, {\", conditional);\n+\t    {\n+\t      unsigned HOST_WIDE_INT stack_adjust =\n+\t\tarm_get_frame_size () + current_function_outgoing_args_size;\n+\t      \n+\t      if (stack_adjust != 0 && stack_adjust != 4)\n+\t\tabort ();\n+\n+\t      if (stack_adjust && arm_arch5)\n+\t\tsprintf (instr, \"ldm%sib\\t%%|sp, {\", conditional);\n+\t      else\n+\t\t{\n+\t\t  /* If we can't use ldmib (SA110 bug), then try to pop r3\n+\t\t     instead.  */\n+\t\t  if (stack_adjust)\n+\t\t    live_regs_mask |= 1 << 3;\n+\t\t  sprintf (instr, \"ldm%sfd\\t%%|sp, {\", conditional);\n+\t\t}\n+\t    }\n \t  else\n \t    sprintf (instr, \"ldm%sfd\\t%%|sp!, {\", conditional);\n \n@@ -8401,7 +8462,7 @@ arm_output_function_prologue (FILE *f, HOST_WIDE_INT frame_size)\n }\n \n const char *\n-arm_output_epilogue (int really_return)\n+arm_output_epilogue (rtx sibling)\n {\n   int reg;\n   unsigned long saved_regs_mask;\n@@ -8414,10 +8475,11 @@ arm_output_epilogue (int really_return)\n   FILE * f = asm_out_file;\n   rtx eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n   unsigned int lrm_count = 0;\n+  int really_return = (sibling == NULL);\n \n   /* If we have already generated the return instruction\n      then it is futile to generate anything else.  */\n-  if (use_return_insn (FALSE) && return_used_this_function)\n+  if (use_return_insn (FALSE, sibling) && return_used_this_function)\n     return \"\";\n \n   func_type = arm_current_func_type ();\n@@ -8730,7 +8792,7 @@ arm_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n       /* We need to take into account any stack-frame rounding.  */\n       frame_size = arm_get_frame_size ();\n \n-      if (use_return_insn (FALSE)\n+      if (use_return_insn (FALSE, NULL)\n \t  && return_used_this_function\n \t  && (frame_size + current_function_outgoing_args_size) != 0\n \t  && !frame_pointer_needed)\n@@ -10187,7 +10249,7 @@ arm_final_prescan_insn (rtx insn)\n \t      /* Fail if a conditional return is undesirable (eg on a\n \t\t StrongARM), but still allow this if optimizing for size.  */\n \t      else if (GET_CODE (scanbody) == RETURN\n-\t\t       && !use_return_insn (TRUE)\n+\t\t       && !use_return_insn (TRUE, NULL)\n \t\t       && !optimize_size)\n \t\tfail = TRUE;\n \t      else if (GET_CODE (scanbody) == RETURN"}, {"sha": "5c4a9b8ffb5ad231e0dd7a5534aceef5f8958c47", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a72d4945d39e4386f107787cfd78e8d681f53c14/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a72d4945d39e4386f107787cfd78e8d681f53c14/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=a72d4945d39e4386f107787cfd78e8d681f53c14", "patch": "@@ -1870,7 +1870,7 @@ typedef struct\n /* Determine if the epilogue should be output as RTL.\n    You should override this if you define FUNCTION_EXTRA_EPILOGUE.  */\n #define USE_RETURN_INSN(ISCOND)\t\t\t\t\\\n-  (TARGET_ARM ? use_return_insn (ISCOND) : 0)\n+  (TARGET_ARM ? use_return_insn (ISCOND, NULL) : 0)\n \n /* Definitions for register eliminations.\n "}, {"sha": "17a37704e3d9d3d959005b69e964a4c2d339cbcc", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a72d4945d39e4386f107787cfd78e8d681f53c14/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a72d4945d39e4386f107787cfd78e8d681f53c14/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=a72d4945d39e4386f107787cfd78e8d681f53c14", "patch": "@@ -9338,9 +9338,9 @@\n               (unspec_volatile [(return)] VUNSPEC_EPILOGUE)])]\n   \"TARGET_ARM\"\n   \"*\n-  if (USE_RETURN_INSN (FALSE))\n+  if (use_return_insn (FALSE, next_nonnote_insn (insn)))\n     return output_return_instruction (const_true_rtx, FALSE, FALSE);\n-  return arm_output_epilogue (FALSE);\n+  return arm_output_epilogue (next_nonnote_insn (insn));\n   \"\n ;; Length is absolute worst case\n   [(set_attr \"length\" \"44\")\n@@ -9356,7 +9356,7 @@\n   \"TARGET_EITHER\"\n   \"*\n   if (TARGET_ARM)\n-    return arm_output_epilogue (TRUE);\n+    return arm_output_epilogue (NULL);\n   else /* TARGET_THUMB */\n     return thumb_unexpanded_epilogue ();\n   \""}]}