{"sha": "12c7b51e3e3e27a31c7b0aabf93610024967339a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJjN2I1MWUzZTNlMjdhMzFjN2IwYWFiZjkzNjEwMDI0OTY3MzM5YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-06-26T10:31:55Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-06-26T10:31:55Z"}, "message": "ipa-inline.c (cgraph_mark_inline): Assert that we never inline uninlinable call.\n\n\t* ipa-inline.c (cgraph_mark_inline): Assert that we never inline\n\tuninlinable call.\n\t(cgraph_decide_inlining_of_small_function, cgraph_decide_inlining,\n\tcgraph_decide_inlining_incrementally): Move uninlinability checks to\n\tplaces other call site specific checks are performed.\n\nFrom-SVN: r126015", "tree": {"sha": "ace1d32c641c1b299e87a0a1a593bfd9d4d0c376", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ace1d32c641c1b299e87a0a1a593bfd9d4d0c376"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12c7b51e3e3e27a31c7b0aabf93610024967339a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c7b51e3e3e27a31c7b0aabf93610024967339a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12c7b51e3e3e27a31c7b0aabf93610024967339a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c7b51e3e3e27a31c7b0aabf93610024967339a/comments", "author": null, "committer": null, "parents": [{"sha": "3c8244625ae34b31808eb8e1934c30831a47ca8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c8244625ae34b31808eb8e1934c30831a47ca8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c8244625ae34b31808eb8e1934c30831a47ca8f"}], "stats": {"total": 25, "additions": 19, "deletions": 6}, "files": [{"sha": "36845348b8a711820958e8b379ffbddd8ecb5420", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c7b51e3e3e27a31c7b0aabf93610024967339a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c7b51e3e3e27a31c7b0aabf93610024967339a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12c7b51e3e3e27a31c7b0aabf93610024967339a", "patch": "@@ -1,3 +1,11 @@\n+2007-06-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (cgraph_mark_inline): Assert that we never inline\n+\tuninlinable call.\n+\t(cgraph_decide_inlining_of_small_function, cgraph_decide_inlining,\n+\tcgraph_decide_inlining_incrementally): Move uninlinability checks to\n+\tplaces other call site specific checks are performed.\n+\n 2007-06-25  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR tree-opt/32421"}, {"sha": "1aacce466c54e43f4487bc022afe0b430fbb9bf3", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c7b51e3e3e27a31c7b0aabf93610024967339a/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c7b51e3e3e27a31c7b0aabf93610024967339a/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=12c7b51e3e3e27a31c7b0aabf93610024967339a", "patch": "@@ -289,13 +289,13 @@ cgraph_mark_inline (struct cgraph_edge *edge)\n   struct cgraph_node *what = edge->callee;\n   struct cgraph_edge *e, *next;\n \n+  gcc_assert (!CALL_CANNOT_INLINE_P (edge->call_stmt));\n   /* Look for all calls, mark them inline and clone recursively\n      all inlined functions.  */\n   for (e = what->callers; e; e = next)\n     {\n       next = e->next_caller;\n-      if (e->caller == to && e->inline_failed\n-\t  && !CALL_CANNOT_INLINE_P (e->call_stmt))\n+      if (e->caller == to && e->inline_failed)\n \t{\n           cgraph_mark_inline_edge (e, true);\n \t  if (e == edge)\n@@ -884,7 +884,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t}\n       gcc_assert (edge->aux);\n       edge->aux = NULL;\n-      if (!edge->inline_failed || CALL_CANNOT_INLINE_P (edge->call_stmt))\n+      if (!edge->inline_failed)\n \tcontinue;\n \n       /* When not having profile info ready we don't weight by any way the\n@@ -950,8 +950,9 @@ cgraph_decide_inlining_of_small_functions (void)\n       else\n \t{\n \t  struct cgraph_node *callee;\n-\t  if (!cgraph_check_inline_limits (edge->caller, edge->callee,\n-\t\t\t\t\t   &edge->inline_failed, true))\n+\t  if (CALL_CANNOT_INLINE_P (edge->call_stmt)\n+\t      || !cgraph_check_inline_limits (edge->caller, edge->callee,\n+\t\t\t\t\t      &edge->inline_failed, true))\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \" Not inlining into %s:%s.\\n\",\n@@ -1116,6 +1117,7 @@ cgraph_decide_inlining (void)\n \n \t  if (node->callers && !node->callers->next_caller && !node->needed\n \t      && node->local.inlinable && node->callers->inline_failed\n+\t      && !CALL_CANNOT_INLINE_P (node->callers->call_stmt)\n \t      && !DECL_EXTERNAL (node->decl) && !DECL_COMDAT (node->decl))\n \t    {\n \t      if (dump_file)\n@@ -1278,6 +1280,8 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n       if (!e->callee->local.disregard_inline_limits\n \t  && (mode != INLINE_ALL || !e->callee->local.inlinable))\n \tcontinue;\n+      if (CALL_CANNOT_INLINE_P (e->call_stmt))\n+\tcontinue;\n       /* When the edge is already inlined, we just need to recurse into\n \t it in order to fully flatten the leaves.  */\n       if (!e->inline_failed && mode == INLINE_ALL)\n@@ -1375,7 +1379,8 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t    continue;\n \t  }\n \tif (!cgraph_check_inline_limits (node, e->callee, &e->inline_failed,\n-\t\t\t\t        false))\n+\t\t\t\t        false)\n+\t    || CALL_CANNOT_INLINE_P (e->call_stmt))\n \t  {\n \t    if (dump_file)\n \t      {"}]}