{"sha": "028059b46ec9aef7dd447792c579f35396751068", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI4MDU5YjQ2ZWM5YWVmN2RkNDQ3NzkyYzU3OWYzNTM5Njc1MTA2OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-08-03T12:00:47Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-08-03T12:00:47Z"}, "message": "aarch64: Tweak MLA vector costs\n\nThe issue-based vector costs currently assume that a multiply-add\nsequence can be implemented using a single instruction.  This is\ngenerally true for scalars (which have a 4-operand instruction)\nand SVE (which allows the output to be tied to any input).\nHowever, for Advanced SIMD, multiplying two values and adding\nan invariant will end up being a move and an MLA.\n\nThe only target to use the issue-based vector costs is Neoverse V1,\nwhich would generally prefer SVE in this case anyway.  I therefore\ndon't have a self-contained testcase.  However, the distinction\nbecomes more important with a later patch.\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_multiply_add_p): Add a vec_flags\n\tparameter.  Detect cases in which an Advanced SIMD MLA would almost\n\tcertainly require a MOV.\n\t(aarch64_count_ops): Update accordingly.", "tree": {"sha": "c18014f9620fb867bf2dd9badde458ab466e5c2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c18014f9620fb867bf2dd9badde458ab466e5c2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/028059b46ec9aef7dd447792c579f35396751068", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028059b46ec9aef7dd447792c579f35396751068", "html_url": "https://github.com/Rust-GCC/gccrs/commit/028059b46ec9aef7dd447792c579f35396751068", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028059b46ec9aef7dd447792c579f35396751068/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "537afb0857c8f60c2b60a09fad4660420cd13e8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/537afb0857c8f60c2b60a09fad4660420cd13e8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/537afb0857c8f60c2b60a09fad4660420cd13e8f"}], "stats": {"total": 25, "additions": 22, "deletions": 3}, "files": [{"sha": "19045ef69448cf49c3244a5a325f9e24496c8ca2", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028059b46ec9aef7dd447792c579f35396751068/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028059b46ec9aef7dd447792c579f35396751068/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=028059b46ec9aef7dd447792c579f35396751068", "patch": "@@ -14767,9 +14767,12 @@ aarch64_integer_truncation_p (stmt_vec_info stmt_info)\n \n /* Return true if STMT_INFO is the second part of a two-statement multiply-add\n    or multiply-subtract sequence that might be suitable for fusing into a\n-   single instruction.  */\n+   single instruction.  If VEC_FLAGS is zero, analyze the operation as\n+   a scalar one, otherwise analyze it as an operation on vectors with those\n+   VEC_* flags.  */\n static bool\n-aarch64_multiply_add_p (vec_info *vinfo, stmt_vec_info stmt_info)\n+aarch64_multiply_add_p (vec_info *vinfo, stmt_vec_info stmt_info,\n+\t\t\tunsigned int vec_flags)\n {\n   gassign *assign = dyn_cast<gassign *> (stmt_info->stmt);\n   if (!assign)\n@@ -14797,6 +14800,22 @@ aarch64_multiply_add_p (vec_info *vinfo, stmt_vec_info stmt_info)\n       if (!rhs_assign || gimple_assign_rhs_code (rhs_assign) != MULT_EXPR)\n \tcontinue;\n \n+      if (vec_flags & VEC_ADVSIMD)\n+\t{\n+\t  /* Scalar and SVE code can tie the result to any FMLA input (or none,\n+\t     although that requires a MOVPRFX for SVE).  However, Advanced SIMD\n+\t     only supports MLA forms, so will require a move if the result\n+\t     cannot be tied to the accumulator.  The most important case in\n+\t     which this is true is when the accumulator input is invariant.  */\n+\t  rhs = gimple_op (assign, 3 - i);\n+\t  if (TREE_CODE (rhs) != SSA_NAME)\n+\t    return false;\n+\t  def_stmt_info = vinfo->lookup_def (rhs);\n+\t  if (!def_stmt_info\n+\t      || STMT_VINFO_DEF_TYPE (def_stmt_info) == vect_external_def)\n+\t    return false;\n+\t}\n+\n       return true;\n     }\n   return false;\n@@ -15232,7 +15251,7 @@ aarch64_count_ops (class vec_info *vinfo, aarch64_vector_costs *costs,\n     }\n \n   /* Assume that multiply-adds will become a single operation.  */\n-  if (stmt_info && aarch64_multiply_add_p (vinfo, stmt_info))\n+  if (stmt_info && aarch64_multiply_add_p (vinfo, stmt_info, vec_flags))\n     return;\n \n   /* When costing scalar statements in vector code, the count already"}]}