{"sha": "1982388a57dbdb1e7b38c77f0aeca61ba02c60b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk4MjM4OGE1N2RiZGIxZTdiMzhjNzdmMGFlY2E2MWJhMDJjNjBiMA==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-03-19T12:56:16Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-03-19T12:56:16Z"}, "message": "[multiple changes]\n\n1999-03-19  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* parse.y (find_applicable_accessible_methods_list): Extend the\n\tsearch to superinterfaces when relevant.\n\t(search_applicable_methods_list): New function.\n1999-03-18  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* class.c (unmangle_classname): Implemented stricter testing\n\tbefore setting the QUALIFIED_P flag on an identifier.\n\nFrom-SVN: r25861", "tree": {"sha": "e12187cefe329f846025ee7fa24351f8bacc32b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e12187cefe329f846025ee7fa24351f8bacc32b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1982388a57dbdb1e7b38c77f0aeca61ba02c60b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1982388a57dbdb1e7b38c77f0aeca61ba02c60b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1982388a57dbdb1e7b38c77f0aeca61ba02c60b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1982388a57dbdb1e7b38c77f0aeca61ba02c60b0/comments", "author": null, "committer": null, "parents": [{"sha": "8db99db275183d379d0b6f2cd80942f6f5f5b4b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8db99db275183d379d0b6f2cd80942f6f5f5b4b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8db99db275183d379d0b6f2cd80942f6f5f5b4b2"}], "stats": {"total": 105, "additions": 80, "deletions": 25}, "files": [{"sha": "263f2f8b69b928113b028094f5258f4c6a06285c", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1982388a57dbdb1e7b38c77f0aeca61ba02c60b0/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1982388a57dbdb1e7b38c77f0aeca61ba02c60b0/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=1982388a57dbdb1e7b38c77f0aeca61ba02c60b0", "patch": "@@ -1,3 +1,14 @@\n+1999-03-19  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (find_applicable_accessible_methods_list): Extend the\n+\tsearch to superinterfaces when relevant.\n+\t(search_applicable_methods_list): New function.\n+\n+1999-03-18  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (unmangle_classname): Implemented stricter testing\n+\tbefore setting the QUALIFIED_P flag on an identifier.\n+\n Tue Mar 16 15:15:41 1999  Per Bothner  <bothner@cygnus.com>\n \n \t* parse.y (java_complete_lhs):  Call force_evaluation_order"}, {"sha": "53ccf3e81e8f55ceb024cf6034793ac0f52a35df", "filename": "gcc/java/class.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1982388a57dbdb1e7b38c77f0aeca61ba02c60b0/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1982388a57dbdb1e7b38c77f0aeca61ba02c60b0/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=1982388a57dbdb1e7b38c77f0aeca61ba02c60b0", "patch": "@@ -142,8 +142,18 @@ unmangle_classname (name, name_length)\n      const char *name;  int name_length;\n {\n   tree to_return = ident_subst (name, name_length, \"\", '/', '.', \"\");\n-  if (to_return != get_identifier ((char *)name))\n-    QUALIFIED_P (to_return) = 1;\n+  /* It's not sufficient to compare to_return and get_identifier\n+     (name) to determine whether to_return is qualified. There are\n+     cases in signature analysis where name will be stripped of a\n+     trailing ';'. */\n+  name = IDENTIFIER_POINTER (to_return);\n+  while (*name)\n+    if (*name++ == '.') \n+      {\n+\tQUALIFIED_P (to_return) = 1;\n+\tbreak;\n+      }\n+  \n   return to_return;\n }\n "}, {"sha": "68dfe24ccb6703a52229ea0dcd6d748bc8eb86e3", "filename": "gcc/java/parse.y", "status": "modified", "additions": 57, "deletions": 23, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1982388a57dbdb1e7b38c77f0aeca61ba02c60b0/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1982388a57dbdb1e7b38c77f0aeca61ba02c60b0/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=1982388a57dbdb1e7b38c77f0aeca61ba02c60b0", "patch": "@@ -118,6 +118,8 @@ static tree resolve_no_layout PROTO ((tree, tree));\n static int invocation_mode PROTO ((tree, int));\n static tree find_applicable_accessible_methods_list PROTO ((int, tree, \n \t\t\t\t\t\t\t    tree, tree));\n+static void search_applicable_methods_list PROTO ((int, tree, tree, tree, \n+\t\t\t\t\t\t   tree *, tree *));\n static tree find_most_specific_methods_list PROTO ((tree));\n static int argument_types_convertible PROTO ((tree, tree));\n static tree patch_invoke PROTO ((tree, tree, tree));\n@@ -7164,40 +7166,72 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n      int lc;\n      tree class, name, arglist;\n {\n-  tree method;\n   tree list = NULL_TREE, all_list = NULL_TREE;\n \n-  while (class != NULL_TREE)\n+  /* Search interfaces */\n+  if (CLASS_INTERFACE (TYPE_NAME (class)))\n     {\n-      for (method = TYPE_METHODS (class);\n-\t   method != NULL_TREE;  method = TREE_CHAIN (method))\n+      int i, n;\n+      tree basetype_vec = TYPE_BINFO_BASETYPES (class);\n+\n+      search_applicable_methods_list \n+\t(lc, TYPE_METHODS (class), name, arglist, &list, &all_list);\n+\n+      n = TREE_VEC_LENGTH (basetype_vec);\n+      for (i = 0; i < n; i++)\n \t{\n-\t  if (lc && !DECL_CONSTRUCTOR_P (method))\n-\t    continue;\n-\t  else if (!lc && (DECL_CONSTRUCTOR_P (method)\n-\t\t\t   || (GET_METHOD_NAME (method) != name)))\n-\t    continue;\n-\t  \n-\t  if (argument_types_convertible (method, arglist))\n-\t    {\n-\t      /* Retain accessible methods only */\n-\t      if (!not_accessible_p (DECL_CONTEXT (current_function_decl), \n-\t\t\t\t     method, 0))\n-\t\tlist = tree_cons (NULL_TREE, method, list);\n-\t      else\n-\t      /* Also retain all selected method here */\n-\t\tall_list = tree_cons (NULL_TREE, method, list);\n-\t    }\n+\t  tree rlist = \n+\t    find_applicable_accessible_methods_list \n+\t      (lc,  BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i)), \n+\t       name, arglist);\n+\t  all_list = chainon (rlist, (list ? list : all_list)); \n \t}\n-      /* When dealing with constructor, stop here, otherwise search\n-         other classes */\n-      class = (lc ? NULL_TREE : CLASSTYPE_SUPER (class));\n     }\n+  /* Search classes */\n+  else\n+    while (class != NULL_TREE)\n+      {\n+\tsearch_applicable_methods_list \n+\t  (lc, TYPE_METHODS (class), name, arglist, &list, &all_list);\n+\tclass = (lc ? NULL_TREE : CLASSTYPE_SUPER (class));\n+      }\n+\n   /* Either return the list obtained or all selected (but\n      inaccessible) methods for better error report. */\n   return (!list ? all_list : list);\n }\n \n+/* Effectively search for the approriate method in method */\n+\n+static void \n+search_applicable_methods_list(lc, method, name, arglist, list, all_list)\n+     int lc;\n+     tree method, name, arglist;\n+     tree *list, *all_list;\n+{\n+  for (; method; method = TREE_CHAIN (method))\n+    {\n+      /* When dealing with constructor, stop here, otherwise search\n+         other classes */\n+      if (lc && !DECL_CONSTRUCTOR_P (method))\n+\tcontinue;\n+      else if (!lc && (DECL_CONSTRUCTOR_P (method) \n+\t\t       || (GET_METHOD_NAME (method) != name)))\n+\tcontinue;\n+\t  \n+      if (argument_types_convertible (method, arglist))\n+\t{\n+\t  /* Retain accessible methods only */\n+\t  if (!not_accessible_p (DECL_CONTEXT (current_function_decl), \n+\t\t\t\t method, 0))\n+\t    *list = tree_cons (NULL_TREE, method, *list);\n+\t  else\n+\t    /* Also retain all selected method here */\n+\t    *all_list = tree_cons (NULL_TREE, method, *list);\n+\t}\n+    }\n+}    \n+\n /* 15.11.2.2 Choose the Most Specific Method */\n \n static tree"}]}