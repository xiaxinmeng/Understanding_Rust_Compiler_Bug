{"sha": "23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNhZjMyZTZlYTIwMzFjYjRiZmZjMWVkYzhkMDM2OGQ1ZTVkZmFkYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-01-27T23:22:17Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-01-27T23:22:17Z"}, "message": "Makefile.in (LIB2FUNCS_ST): Remove _gcov.\n\n\t* Makefile.in (LIB2FUNCS_ST): Remove _gcov.\n\t(LIBGCOV): New variable.\n\t(libgcc.mk): Add LIBGCOV.\n\t(LIBGCC_DEPS): Add libgcov.c.\n\t(libgcov.a): New target.\n\t(clean): Remove libgcov.a.\n\t(install-libgcc): Do libgcov too.\n\t(stage1-start, stage2-start, stage3-start, stage4-start): Deal\n\twith libgcov.a.\n\t* libgcc2.c (L_gcov): Move into ...\n\t* libgcov.c: ... here. New file.\n\t* mklibgcc.in: Add libgcov rules.\n\t* gcc.c (LINK_COMMAND_SPEC): Add -lgcov when profiling.\n\n\t* doc/invoke.texi (profile-arcs, test-coverage): Update and\n\tclarify.\n\n\t* profile.c (index_counts_file): Remove duplicate check for open file.\n\nFrom-SVN: r61905", "tree": {"sha": "2a2a67d83f3dfe20178bb96db57b38e585380170", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a2a67d83f3dfe20178bb96db57b38e585380170"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/comments", "author": null, "committer": null, "parents": [{"sha": "acabc2201e43691ffb41b2cee2de1e628dfce9f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acabc2201e43691ffb41b2cee2de1e628dfce9f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acabc2201e43691ffb41b2cee2de1e628dfce9f4"}], "stats": {"total": 1103, "additions": 602, "deletions": 501}, "files": [{"sha": "bb0804fbdfa6ea8ccea52d84f6fc9b2e0b96a6ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "patch": "@@ -1,3 +1,24 @@\n+2003-01-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* Makefile.in (LIB2FUNCS_ST): Remove _gcov.\n+\t(LIBGCOV): New variable.\n+\t(libgcc.mk): Add LIBGCOV.\n+\t(LIBGCC_DEPS): Add libgcov.c.\n+\t(libgcov.a): New target.\n+\t(clean): Remove libgcov.a.\n+\t(install-libgcc): Do libgcov too.\n+\t(stage1-start, stage2-start, stage3-start, stage4-start): Deal\n+\twith libgcov.a.\n+\t* libgcc2.c (L_gcov): Move into ...\n+\t* libgcov.c: ... here. New file.\n+\t* mklibgcc.in: Add libgcov rules.\n+\t* gcc.c (LINK_COMMAND_SPEC): Add -lgcov when profiling.\n+\n+\t* doc/invoke.texi (profile-arcs, test-coverage): Update and\n+\tclarify.\n+\t\n+\t* profile.c (index_counts_file): Remove duplicate check for open file.\n+\n 2003-01-27  Jerry Quinn  <jlquinn@optonline.net>\n \n \t* gcc/doc/invoke.texi (Optimization Options): Group together"}, {"sha": "4cb7de271163ef18f55b3ad79416b345c113fb0f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "patch": "@@ -825,7 +825,10 @@ LIB2FUNCS_2 = _floatdixf _fixunsxfsi _fixtfdi _fixunstfdi _floatditf \\\n     _addvdi3 _subvsi3 _subvdi3 _mulvsi3 _mulvdi3 _negvsi2 _negvdi2 _ctors\n \n # Defined in libgcc2.c, included only in the static library.\n-LIB2FUNCS_ST = _eprintf _gcov __gcc_bcmp\n+LIB2FUNCS_ST = _eprintf __gcc_bcmp\n+\n+# Defined in libgcov.c, included only in gcov library\n+LIBGCOV = _gcov\n \n FPBIT_FUNCS = _pack_sf _unpack_sf _addsub_sf _mul_sf _div_sf \\\n     _fpcmp_parts_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \\\n@@ -1054,6 +1057,7 @@ libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) $(LIB2ADD_ST) xgcc$(exeext\n \tLIB2FUNCS_1='$(LIB2FUNCS_1)' \\\n \tLIB2FUNCS_2='$(LIB2FUNCS_2)' \\\n \tLIB2FUNCS_ST='$(LIB2FUNCS_ST)' \\\n+\tLIBGCOV='$(LIBGCOV)' \\\n \tLIB2ADD='$(LIB2ADD)' \\\n \tLIB2ADD_ST='$(LIB2ADD_ST)' \\\n \tLIB2ADDEH='$(LIB2ADDEH)' \\\n@@ -1082,12 +1086,14 @@ libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) $(LIB2ADD_ST) xgcc$(exeext\n \n # All the things that might cause us to want to recompile bits of libgcc.\n LIBGCC_DEPS = $(GCC_PASSES) $(LANGUAGES) stmp-int-hdrs $(STMP_FIXPROTO) \\\n-\tlibgcc.mk $(srcdir)/libgcc2.c $(TCONFIG_H) \\\n+\tlibgcc.mk $(srcdir)/libgcc2.c $(srcdir)/libgcov.c $(TCONFIG_H) \\\n \t$(MACHMODE_H) longlong.h gbl-ctors.h config.status stmp-int-hdrs \\\n \ttsystem.h $(FPBIT) $(DPBIT) $(TPBIT) $(LIB2ADD) \\\n \t$(LIB2ADD_ST) $(LIB2ADDEH) $(LIB2ADDEHDEP) $(EXTRA_PARTS) \\\n \t$(srcdir)/config/$(LIB1ASMSRC)\n \n+libgcov.a: libgcc.a; @true\n+\n libgcc.a: $(LIBGCC_DEPS)\n \t$(MAKE) GCC_FOR_TARGET=\"$(GCC_FOR_TARGET)\" \\\n \t  BUILD_PREFIX=\"$(BUILD_PREFIX)\" BUILD_PREFIX_1=\"$(BUILD_PREFIX_1)\" \\\n@@ -2728,7 +2734,8 @@ mostlyclean: $(INTL_MOSTLYCLEAN) lang.mostlyclean\n # that don't exist in the distribution.\n INTL_CLEAN = intl.clean\n clean: mostlyclean $(INTL_CLEAN) lang.clean\n-\t-rm -f libgcc.a libgcc_eh.a libgcc_s$(SHLIB_EXT) libgcc_s$(SHLIB_EXT).1\n+\t-rm -f libgcc.a libgcc_eh.a libgcov.a\n+\t-rm -f libgcc_s$(SHLIB_EXT) libgcc_s$(SHLIB_EXT).1\n \t-rm -f config.h tconfig.h bconfig.h tm_p.h tm.h\n \t-rm -f cs-*\n \t-rm -rf libgcc\n@@ -2984,7 +2991,7 @@ install-man: installdirs $(GENERATED_MANPAGES) lang.install-man\n \t-chmod a-x $(DESTDIR)$(man7dir)/gpl$(man7ext)\n \n # Install the library.\n-install-libgcc: libgcc.mk libgcc.a installdirs\n+install-libgcc: libgcc.mk libgcc.a libgcov.a installdirs\n \t$(MAKE) GCC_FOR_TARGET=\"$(GCC_FOR_TARGET)\" \\\n \t  BUILD_PREFIX=\"$(BUILD_PREFIX)\" BUILD_PREFIX_1=\"$(BUILD_PREFIX_1)\" \\\n \t  AR_FOR_TARGET=\"$(AR_FOR_TARGET)\" \\\n@@ -3004,7 +3011,7 @@ install-libgcc: libgcc.mk libgcc.a installdirs\n \t  slibdir=\"$(slibdir)\" \\\n \t  -f libgcc.mk install\n \n-# Install multiple versions of libgcc.a.\n+# Install multiple versions of libgcc.a, libgcov.a.\n install-multilib: stmp-multilib installdirs\n \t$(MAKE) GCC_FOR_TARGET=\"$(GCC_FOR_TARGET)\" \\\n \t  BUILD_PREFIX=\"$(BUILD_PREFIX)\" BUILD_PREFIX_1=\"$(BUILD_PREFIX_1)\" \\\n@@ -3611,9 +3618,11 @@ stage1-start:\n \t-if [ -f as$(exeext) ] ; then (cd stage1 && $(LN_S) ../as$(exeext) .) ; else true ; fi\n \t-if [ -f ld$(exeext) ] ; then (cd stage1 && $(LN_S) ../ld$(exeext) .) ; else true ; fi\n \t-if [ -f collect-ld$(exeext) ] ; then (cd stage1 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi\n-\t-rm -f stage1/libgcc.a stage1/libgcc_eh.a\n+\t-rm -f stage1/libgcc.a stage1/libgcc_eh.a stage1/libgcov.a\n \t-cp libgcc.a stage1\n \t-$(RANLIB_FOR_TARGET) stage1/libgcc.a\n+\t-cp libgcov.a stage1\n+\t-$(RANLIB_FOR_TARGET) stage1/libgcov.a\n \t-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stage1; \\\n \t   $(RANLIB_FOR_TARGET) stage1/libgcc_eh.a; \\\n \tfi\n@@ -3641,9 +3650,11 @@ stage2-start:\n \t-if [ -f as$(exeext) ] ; then (cd stage2 && $(LN_S) ../as$(exeext) .) ; else true ; fi\n \t-if [ -f ld$(exeext) ] ; then (cd stage2 && $(LN_S) ../ld$(exeext) .) ; else true ; fi\n \t-if [ -f collect-ld$(exeext) ] ; then (cd stage2 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi\n-\t-rm -f stage2/libgcc.a stage2/libgcc_eh.a\n+\t-rm -f stage2/libgcc.a stage2/libgcov.a stage2/libgcc_eh.a\n \t-cp libgcc.a stage2\n \t-$(RANLIB_FOR_TARGET) stage2/libgcc.a\n+\t-cp libgcov.a stage2\n+\t-$(RANLIB_FOR_TARGET) stage2/libgcov.a\n \t-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stage2; \\\n \t   $(RANLIB_FOR_TARGET) stage2/libgcc_eh.a; \\\n \tfi\n@@ -3667,9 +3678,11 @@ stage3-start:\n \t-if [ -f as$(exeext) ] ; then (cd stage3 && $(LN_S) ../as$(exeext) .) ; else true ; fi\n \t-if [ -f ld$(exeext) ] ; then (cd stage3 && $(LN_S) ../ld$(exeext) .) ; else true ; fi\n \t-if [ -f collect-ld$(exeext) ] ; then (cd stage3 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi\n-\t-rm -f stage3/libgcc.a stage3/libgcc_eh.a\n+\t-rm -f stage3/libgcc.a stage3/libgcov.a stage3/libgcc_eh.a\n \t-cp libgcc.a stage3\n \t-$(RANLIB_FOR_TARGET) stage3/libgcc.a\n+\t-cp libgcov.a stage3\n+\t-$(RANLIB_FOR_TARGET) stage3/libgcov.a\n \t-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stage3; \\\n \t   $(RANLIB_FOR_TARGET) stage3/libgcc_eh.a; \\\n \tfi\n@@ -3693,9 +3706,11 @@ stage4-start:\n \t-if [ -f as$(exeext) ] ; then (cd stage4 && $(LN_S) ../as$(exeext) .) ; else true ; fi\n \t-if [ -f ld$(exeext) ] ; then (cd stage4 && $(LN_S) ../ld$(exeext) .) ; else true ; fi\n \t-if [ -f collect-ld$(exeext) ] ; then (cd stage4 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi\n-\t-rm -f stage4/libgcc.a stage4/libgcc_eh.a\n+\t-rm -f stage4/libgcc.a stage4/libgcov.a stage4/libgcc_eh.a\n \t-cp libgcc.a stage4\n \t-$(RANLIB_FOR_TARGET) stage4/libgcc.a\n+\t-cp libgcov.a stage4\n+\t-$(RANLIB_FOR_TARGET) stage4/libgcov.a\n \t-if [ -f libgcc_eh.a ] ; then cp libgcc_eh.a stage4; \\\n \t   $(RANLIB_FOR_TARGET) stage4/libgcc_eh.a; \\\n \tfi"}, {"sha": "e4c39c590111e0a8a1a47ccfa19126a42be13d4a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "patch": "@@ -3035,27 +3035,46 @@ allocation when it finishes.\n \n @item -fprofile-arcs\n @opindex fprofile-arcs\n-Instrument @dfn{arcs} during compilation to generate coverage data or\n-for profile-directed block ordering.  During execution the program\n-records how many times each branch is executed and how many times it is\n-taken.  When the compiled program exits it saves this data to a file\n-called @file{@var{auxname}.da} for each source file.  @var{auxname} is\n-generated from the name of the output file, if explicitly specified and\n-it is not the final executable, otherwise it is the basename of the\n-source file. In both cases any suffix is removed (e.g.  @file{foo.da}\n-for input file @file{dir/foo.c}, or @file{dir/foo.da} for output file\n-specified as @option{-o dir/foo.o}).\n-\n-For profile-directed block ordering, compile the program with\n-@option{-fprofile-arcs} plus optimization and code generation options,\n-generate the arc profile information by running the program on a\n-selected workload, and then compile the program again with the same\n-optimization and code generation options plus\n+Add code so that program flow @dfn{arcs} are instrumented.  During\n+execution the program records how many times each branch and call is\n+executed and how many times it is taken or returns.  When the compiled\n+program exits it saves this data to a file called\n+@file{@var{auxname}.da} for each source file. The data may be used for\n+profile-directed optimizations (@option{-fbranch-probabilities}), or for\n+test coverage analysis (@option{-ftest-coverage}). Each object file's\n+@var{auxname} is generated from the name of the output file, if\n+explicitly specified and it is not the final executable, otherwise it is\n+the basename of the source file. In both cases any suffix is removed\n+(e.g.  @file{foo.da} for input file @file{dir/foo.c}, or\n+@file{dir/foo.da} for output file specified as @option{-o dir/foo.o}).\n+\n+@itemize\n+\n+@item\n+Compile the source files with @option{-fprofile-arcs} plus optimization\n+and code generation options. For test coverage analysis, use the\n+additional @option{-ftest-coverage} option. You do not need to profile\n+every source file in a program.\n+\n+@item\n+Link your object files as normal.\n+\n+@item\n+Run the program on a representative workload to generate the arc profile\n+information. This may be repeated any number of times.\n+\n+@item\n+For profile-directed optimizations, compile the source files again with\n+the same optimization and code generation options plus\n @option{-fbranch-probabilities} (@pxref{Optimize Options,,Options that\n Control Optimization}).\n \n-The other use of @option{-fprofile-arcs} is for use with @command{gcov},\n-when it is used with the @option{-ftest-coverage} option.\n+@item\n+For test coverage analysis, use @command{gcov} to produce human readable\n+information from the @file{.bbg} and @file{.da} files. Refer to the\n+@command{gcov} documentation for further information.\n+\n+@end itemize\n \n With @option{-fprofile-arcs}, for each function of your program GCC\n creates a program flow graph, then finds a spanning tree for the graph.\n@@ -3068,34 +3087,13 @@ block must be created to hold the instrumentation code.\n @need 2000\n @item -ftest-coverage\n @opindex ftest-coverage\n-Create data files for the @command{gcov} code-coverage utility\n-(@pxref{Gcov,, @command{gcov}---a Test Coverage Program}).  See\n-@option{-fprofile-arcs} option above for a description of @var{auxname}.\n-\n-@table @gcctabopt\n-@item @var{auxname}.bb\n-A mapping from basic blocks to line numbers, which @command{gcov} uses to\n-associate basic block execution counts with line numbers.\n-\n-@item @var{auxname}.bbg\n-A list of all arcs in the program flow graph.  This allows @command{gcov}\n-to reconstruct the program flow graph, so that it can compute all basic\n-block and arc execution counts from the information in the\n-@file{@var{auxname}.da} file.\n-@end table\n-\n-Use @option{-ftest-coverage} with @option{-fprofile-arcs}; the latter\n-option adds instrumentation to the program, which then writes\n-execution counts to another data file:\n-\n-@table @gcctabopt\n-@item @var{auxname}.da\n-Runtime arc execution counts, used in conjunction with the arc\n-information in the file @file{@var{auxname}.bbg}.\n-@end table\n-\n-Coverage data will map better to the source files if\n-@option{-ftest-coverage} is used without optimization.\n+Produce a graph file that the @command{gcov} code-coverage utility\n+(@pxref{Gcov,, @command{gcov}---a Test Coverage Program}) can use to\n+show program coverage. Each source file's data file is called\n+@file{@var{auxname}.bbg}. Refer to the @option{-fprofile-arcs} option\n+above for a description of @var{auxname} and instructions on how to\n+generate test coverage data. Coverage data will match the source files\n+more closely, if you do not optimize.\n \n @item -d@var{letters}\n @opindex d"}, {"sha": "3a36d3517b13fb13666211523f4bc92bfae3af62", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "patch": "@@ -676,7 +676,8 @@ proper position among the other output files.  */\n %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\\\n     %(linker) %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r} %{s} %{t}\\\n     %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\\\n-    %{static:} %{L*} %(link_libgcc) %o %{!nostdlib:%{!nodefaultlibs:%(link_gcc_c_sequence)}}\\\n+    %{static:} %{L*} %(link_libgcc) %o %{fprofile-arcs:-lgcov}\\\n+    %{!nostdlib:%{!nodefaultlibs:%(link_gcc_c_sequence)}}\\\n     %{!A:%{!nostdlib:%{!nostartfiles:%E}}} %{T*} }}}}}}\"\n #endif\n "}, {"sha": "deb772fa6290976646e77f787aa30d1cb5b18a25", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 0, "deletions": 439, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "patch": "@@ -1235,445 +1235,6 @@ __eprintf (const char *string, const char *expression,\n #endif\n #endif\n \n-#ifdef L_gcov\n-\n-/* Gcov profile dumper. Requires atexit and stdio.  */\n-\n-#undef NULL /* Avoid errors if stdio.h and our stddef.h mismatch.  */\n-#include <stdio.h>\n-\n-#include \"gcov-io.h\"\n-#include <string.h>\n-#if defined (TARGET_HAS_F_SETLKW)\n-#include <fcntl.h>\n-#include <errno.h>\n-#endif\n-\n-/* Chain of per-object gcov structures.  */\n-static struct gcov_info *gcov_list;\n-\n-/* A program checksum allows us to distinguish program data for an\n-   object file included in multiple programs.  */\n-static unsigned gcov_crc32;\n-\n-static void\n-gcov_version_mismatch (struct gcov_info *ptr, unsigned version)\n-{\n-  unsigned expected = GCOV_VERSION;\n-  unsigned ix;\n-  char e[4], v[4];\n-\n-  for (ix = 4; ix--; expected >>= 8, version >>= 8)\n-    {\n-      e[ix] = expected;\n-      v[ix] = version;\n-    }\n-  \n-  fprintf (stderr,\n-\t   \"profiling:%s:Version mismatch - expected %.4s got %.4s\\n\",\n-\t   ptr->filename, e, v);\n-}\n-\n-/* Dump the coverage counts. We merge with existing counts when\n-   possible, to avoid growing the .da files ad infinitum. We use this\n-   program's checksum to make sure we only accumulate whole program\n-   statistics to the correct summary. An object file might be embedded\n-   in two separate programs, and we must keep the two program\n-   summaries separate.  */\n-\n-static void\n-gcov_exit (void)\n-{\n-  struct gcov_info *ptr;\n-  unsigned ix, jx;\n-  struct gcov_summary program;\n-  gcov_type program_max_one = 0;\n-  gcov_type program_max_sum = 0;\n-  gcov_type program_sum = 0;\n-  unsigned program_arcs = 0;\n-  \n-#if defined (TARGET_HAS_F_SETLKW)\n-  struct flock s_flock;\n-\n-  s_flock.l_type = F_WRLCK;\n-  s_flock.l_whence = SEEK_SET;\n-  s_flock.l_start = 0;\n-  s_flock.l_len = 0; /* Until EOF.  */\n-  s_flock.l_pid = getpid ();\n-#endif\n-\n-  memset (&program, 0, sizeof (program));\n-  program.checksum = gcov_crc32;\n-  \n-  for (ptr = gcov_list; ptr; ptr = ptr->next)\n-    {\n-      FILE *da_file;\n-      struct gcov_summary object;\n-      struct gcov_summary local_prg;\n-      int merging = 0;\n-      long base;\n-      const struct function_info *fn_info;\n-      gcov_type *count_ptr;\n-      gcov_type object_max_one = 0;\n-\n-      ptr->wkspc = 0;\n-      if (!ptr->filename)\n-\tcontinue;\n-\n-      for (ix = ptr->n_arc_counts, count_ptr = ptr->arc_counts; ix--;)\n-\t{\n-\t  gcov_type count = *count_ptr++;\n-\n-\t  if (count > object_max_one)\n-\t    object_max_one = count;\n-\t}\n-      if (object_max_one > program_max_one)\n-\tprogram_max_one = object_max_one;\n-      \n-      memset (&local_prg, 0, sizeof (local_prg));\n-      memset (&object, 0, sizeof (object));\n-      \n-      /* Open for modification */\n-      if ((da_file = fopen (ptr->filename, \"r+b\")))\n-\tmerging = 1;\n-      else if ((da_file = fopen (ptr->filename, \"w+b\")))\n-\t;\n-      else\n-\t{\n-\t  fprintf (stderr, \"profiling:%s:Cannot open\\n\", ptr->filename);\n-\t  ptr->filename = 0;\n-\t  continue;\n-\t}\n-\n-#if defined (TARGET_HAS_F_SETLKW)\n-      /* After a fork, another process might try to read and/or write\n-         the same file simultaneously.  So if we can, lock the file to\n-         avoid race conditions.  */\n-      while (fcntl (fileno (da_file), F_SETLKW, &s_flock)\n-\t     && errno == EINTR)\n-\tcontinue;\n-#endif\n-      if (merging)\n-\t{\n-\t  /* Merge data from file.  */\n-\t  unsigned tag, length;\n-\t      \n-\t  if (gcov_read_unsigned (da_file, &tag) || tag != GCOV_DATA_MAGIC)\n-\t    {\n-\t      fprintf (stderr, \"profiling:%s:Not a gcov data file\\n\",\n-\t\t       ptr->filename);\n-\t    read_fatal:;\n-\t      fclose (da_file);\n-\t      ptr->filename = 0;\n-\t      continue;\n-\t    }\n-\t  if (gcov_read_unsigned (da_file, &length) || length != GCOV_VERSION)\n-\t    {\n-\t      gcov_version_mismatch (ptr, length);\n-\t      goto read_fatal;\n-\t    }\n-\t  \n-\t  /* Merge execution counts for each function.  */\n-\t  count_ptr = ptr->arc_counts;\n-\t  for (ix = ptr->n_functions, fn_info = ptr->functions;\n-\t       ix--; fn_info++)\n-\t    {\n-\t      if (gcov_read_unsigned (da_file, &tag)\n-\t\t  || gcov_read_unsigned (da_file, &length))\n-\t\t{\n-\t\tread_error:;\n-\t\t  fprintf (stderr, \"profiling:%s:Error merging\\n\",\n-\t\t\t   ptr->filename);\n-\t\t  goto read_fatal;\n-\t\t}\n-\n-\t      /* Check function */\n-\t      if (tag != GCOV_TAG_FUNCTION)\n-\t\t{\n-\t\tread_mismatch:;\n-\t\t  fprintf (stderr, \"profiling:%s:Merge mismatch at %s\\n\",\n-\t\t\t   ptr->filename, fn_info->name);\n-\t\t  goto read_fatal;\n-\t\t}\n-\t      {\n-\t\tunsigned flength, checksum;\n-\t\t\n-\t\tif (gcov_read_unsigned (da_file, &flength)\n-\t\t    || gcov_skip_string (da_file, flength)\n-\t\t    || gcov_read_unsigned (da_file, &checksum))\n-\t\t  goto read_error;\n-\t\tif (flength != strlen (fn_info->name)\n-\t\t    || checksum != fn_info->checksum)\n-\t\t  goto read_mismatch;\n-\t      }\n-\t      /* Check arc counts */\n-\t      if (gcov_read_unsigned (da_file, &tag)\n-\t\t  || gcov_read_unsigned (da_file, &length))\n-\t\tgoto read_error;\n-\t      if (tag != GCOV_TAG_ARC_COUNTS\n-\t\t  || length / 8 != fn_info->n_arc_counts)\n-\t\tgoto read_mismatch;\n-\t      {\n-\t\tgcov_type count;\n-\t\t\n-\t\tfor (jx = fn_info->n_arc_counts; jx--; count_ptr++)\n-\t\t  if (gcov_read_counter (da_file, &count))\n-\t\t    goto read_error;\n-\t\t  else\n-\t\t    *count_ptr += count;\n-\t      }\n-\t    }\n-\n-\t  /* Check object summary */\n-\t  if (gcov_read_unsigned (da_file, &tag)\n-\t      || gcov_read_unsigned (da_file, &length))\n-\t    goto read_error;\n-\t  if (tag != GCOV_TAG_OBJECT_SUMMARY)\n-\t    goto read_mismatch;\n-\t  if (gcov_read_summary (da_file, &object))\n-\t    goto read_error;\n-\n-\t  /* Check program summary */\n-\t  while (1)\n-\t    {\n-\t      long base = ftell (da_file);\n-\t      \n-\t      if (gcov_read_unsigned (da_file, &tag)\n-\t\t  || gcov_read_unsigned (da_file, &length))\n-\t\t{\n-\t\t  if (feof (da_file))\n-\t\t    break;\n-\t\t  goto read_error;\n-\t\t}\n-\t      if (tag != GCOV_TAG_PROGRAM_SUMMARY\n-\t\t  && tag != GCOV_TAG_PLACEHOLDER_SUMMARY\n-\t\t  && tag != GCOV_TAG_INCORRECT_SUMMARY)\n-\t\tgoto read_mismatch;\n-\t      if (gcov_read_summary (da_file, &local_prg))\n-\t\tgoto read_error;\n-\t      if (local_prg.checksum != program.checksum)\n-\t\tcontinue;\n-\t      if (tag == GCOV_TAG_PLACEHOLDER_SUMMARY)\n-\t\t{\n-\t\t  fprintf (stderr,\n-\t\t\t   \"profiling:%s:Concurrent race detected\\n\",\n-\t\t\t   ptr->filename);\n-\t\t  goto read_fatal;\n-\t\t}\n-\t      merging = -1;\n-\t      if (tag != GCOV_TAG_PROGRAM_SUMMARY)\n-\t\tbreak;\n-\t      \n-\t      if (program.runs\n-\t\t  && memcmp (&program, &local_prg, sizeof (program)))\n-\t\t{\n-\t\t  fprintf (stderr, \"profiling:%s:Invocation mismatch\\n\",\n-\t\t\t   ptr->filename);\n-\t\t  local_prg.runs = 0;\n-\t\t}\n-\t      else\n-\t\tmemcpy (&program, &local_prg, sizeof (program));\n-\t      ptr->wkspc = base;\n-\t      break;\n-\t    }\n-\t  fseek (da_file, 0, SEEK_SET);\n-\t}\n-\n-      object.runs++;\n-      object.arcs = ptr->n_arc_counts;\n-      object.arc_sum = 0;\n-      if (object.arc_max_one < object_max_one)\n-\tobject.arc_max_one = object_max_one;\n-      object.arc_sum_max += object_max_one;\n-      \n-      /* Write out the data.  */\n-      if (/* magic */\n-\t  gcov_write_unsigned (da_file, GCOV_DATA_MAGIC)\n-\t  /* version number */\n-\t  || gcov_write_unsigned (da_file, GCOV_VERSION))\n-\t{\n-\twrite_error:;\n-\t  fclose (da_file);\n-\t  fprintf (stderr, \"profiling:%s:Error writing\\n\", ptr->filename);\n-\t  ptr->filename = 0;\n-\t  continue;\n-\t}\n-      \n-      /* Write execution counts for each function.  */\n-      count_ptr = ptr->arc_counts;\n-      for (ix = ptr->n_functions, fn_info = ptr->functions; ix--; fn_info++)\n-\t{\n-\t  /* Announce function.  */\n-\t  if (gcov_write_unsigned (da_file, GCOV_TAG_FUNCTION)\n-\t      || !(base = gcov_reserve_length (da_file))\n-\t      /* function name */\n-\t      || gcov_write_string (da_file, fn_info->name,\n-\t\t\t\t    strlen (fn_info->name))\n-\t      /* function checksum */\n-\t      || gcov_write_unsigned (da_file, fn_info->checksum)\n-\t      || gcov_write_length (da_file, base))\n-\t    goto write_error;\n-\t  \n-\t  /* arc counts.  */\n-\t  if (gcov_write_unsigned (da_file, GCOV_TAG_ARC_COUNTS)\n-\t      || !(base = gcov_reserve_length (da_file)))\n-\t    goto write_error;\n-\t  \n-\t  for (jx = fn_info->n_arc_counts; jx--;)\n-\t    {\n-\t      gcov_type count = *count_ptr++;\n-\t      \n-\t      object.arc_sum += count;\n-\t      if (object.arc_max_sum < count)\n-\t\tobject.arc_max_sum = count;\n-\t      if (gcov_write_counter (da_file, count))\n-\t\tgoto write_error; /* RIP Edsger Dijkstra */\n-\t    }\n-\t  if (gcov_write_length (da_file, base))\n-\t    goto write_error;\n-\t}\n-\n-      /* Object file summary.  */\n-      if (gcov_write_summary (da_file, GCOV_TAG_OBJECT_SUMMARY, &object))\n-\tgoto write_error;\n-\n-      if (merging >= 0)\n-\t{\n-\t  if (fseek (da_file, 0, SEEK_END))\n-\t    goto write_error;\n-\t  ptr->wkspc = ftell (da_file);\n-\t  if (gcov_write_summary (da_file, GCOV_TAG_PLACEHOLDER_SUMMARY,\n-\t\t\t\t  &program))\n-\t    goto write_error;\n-\t}\n-      else if (ptr->wkspc)\n-\t{\n-\t  /* Zap trailing program summary */\n-\t  if (fseek (da_file, ptr->wkspc, SEEK_SET))\n-\t    goto write_error;\n-\t  if (!local_prg.runs)\n-\t    ptr->wkspc = 0;\n-\t  if (gcov_write_unsigned (da_file,\n-\t\t\t     local_prg.runs ? GCOV_TAG_PLACEHOLDER_SUMMARY\n-\t\t\t     : GCOV_TAG_INCORRECT_SUMMARY))\n-\t    goto write_error;\n-\t}\n-      if (fflush (da_file))\n-\tgoto write_error;\n-\n-      if (fclose (da_file))\n-\t{\n-\t  fprintf (stderr, \"profiling:%s:Error closing\\n\", ptr->filename);\n-\t  ptr->filename = 0;\n-\t}\n-      else\n-\t{\n-\t  program_arcs += ptr->n_arc_counts;\n-\t  program_sum += object.arc_sum;\n-\t  if (program_max_sum < object.arc_max_sum)\n-\t    program_max_sum = object.arc_max_sum;\n-\t}\n-    }\n-\n-  /* Generate whole program statistics.  */\n-  program.runs++;\n-  program.arcs = program_arcs;\n-  program.arc_sum = program_sum;\n-  if (program.arc_max_one < program_max_one)\n-    program.arc_max_one = program_max_one;\n-  if (program.arc_max_sum < program_max_sum)\n-    program.arc_max_sum = program_max_sum;\n-  program.arc_sum_max += program_max_one;\n-  \n-  /* Upate whole program statistics.  */\n-  for (ptr = gcov_list; ptr; ptr = ptr->next)\n-    if (ptr->filename && ptr->wkspc)\n-      {\n-\tFILE *da_file;\n-\t\n-\tda_file = fopen (ptr->filename, \"r+b\");\n-\tif (!da_file)\n-\t  {\n-\t    fprintf (stderr, \"profiling:%s:Cannot open\\n\", ptr->filename);\n-\t    continue;\n-\t  }\n-\t\n-#if defined (TARGET_HAS_F_SETLKW)\n-\twhile (fcntl (fileno (da_file), F_SETLKW, &s_flock)\n-\t       && errno == EINTR)\n-\t  continue;\n-#endif\n-\tif (fseek (da_file, ptr->wkspc, SEEK_SET)\n- \t    || gcov_write_summary (da_file, GCOV_TAG_PROGRAM_SUMMARY, &program)\n- \t    || fflush (da_file))\n- \t  fprintf (stderr, \"profiling:%s:Error writing\\n\", ptr->filename);\n-\tif (fclose (da_file))\n-\t  fprintf (stderr, \"profiling:%s:Error closing\\n\", ptr->filename);\n-      }\n-}\n-\n-/* Add a new object file onto the bb chain.  Invoked automatically\n-   when running an object file's global ctors.  */\n-\n-void\n-__gcov_init (struct gcov_info *info)\n-{\n-  if (!info->version)\n-    return;\n-  if (info->version != GCOV_VERSION)\n-    gcov_version_mismatch (info, info->version);\n-  else\n-    {\n-      const char *ptr = info->filename;\n-      unsigned crc32 = gcov_crc32;\n-  \n-      do\n-\t{\n-\t  unsigned ix;\n-\t  unsigned value = *ptr << 24;\n-\n-\t  for (ix = 8; ix--; value <<= 1)\n-\t    {\n-\t      unsigned feedback;\n-\n-\t      feedback = (value ^ crc32) & 0x80000000 ? 0x04c11db7 : 0;\n-\t      crc32 <<= 1;\n-\t      crc32 ^= feedback;\n-\t    }\n-\t}\n-      while (*ptr++);\n-      \n-      gcov_crc32 = crc32;\n-      \n-      if (!gcov_list)\n-\tatexit (gcov_exit);\n-      \n-      info->next = gcov_list;\n-      gcov_list = info;\n-    }\n-  info->version = 0;\n-}\n-\n-/* Called before fork or exec - write out profile information gathered so\n-   far and reset it to zero.  This avoids duplication or loss of the\n-   profile information gathered so far.  */\n-\n-void\n-__gcov_flush (void)\n-{\n-  struct gcov_info *ptr;\n-\n-  gcov_exit ();\n-  for (ptr = gcov_list; ptr; ptr = ptr->next)\n-    {\n-      unsigned i;\n-      \n-      for (i = ptr->n_arc_counts; i--;)\n-\tptr->arc_counts[i] = 0;\n-    }\n-}\n-\n-#endif /* L_gcov */\n \f\n #ifdef L_clear_cache\n /* Clear part of an instruction cache.  */"}, {"sha": "57bfb2632652114af581d7958df4f115001b01dd", "filename": "gcc/libgcov.c", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "patch": "@@ -0,0 +1,473 @@\n+/* Routines required for instrumenting a program.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n+   2000, 2001, 2002, 2003  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* It is incorrect to include config.h here, because this file is being\n+   compiled for the target, and hence definitions concerning only the host\n+   do not apply.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+\n+#undef NULL /* Avoid errors if stdio.h and our stddef.h mismatch.  */\n+#include <stdio.h>\n+\n+#include \"gcov-io.h\"\n+#include <string.h>\n+#if defined (TARGET_HAS_F_SETLKW)\n+#include <fcntl.h>\n+#include <errno.h>\n+#endif\n+\n+/* Chain of per-object gcov structures.  */\n+static struct gcov_info *gcov_list;\n+\n+/* A program checksum allows us to distinguish program data for an\n+   object file included in multiple programs.  */\n+static unsigned gcov_crc32;\n+\n+static void\n+gcov_version_mismatch (struct gcov_info *ptr, unsigned version)\n+{\n+  unsigned expected = GCOV_VERSION;\n+  unsigned ix;\n+  char e[4], v[4];\n+\n+  for (ix = 4; ix--; expected >>= 8, version >>= 8)\n+    {\n+      e[ix] = expected;\n+      v[ix] = version;\n+    }\n+  \n+  fprintf (stderr,\n+\t   \"profiling:%s:Version mismatch - expected %.4s got %.4s\\n\",\n+\t   ptr->filename, e, v);\n+}\n+\n+/* Dump the coverage counts. We merge with existing counts when\n+   possible, to avoid growing the .da files ad infinitum. We use this\n+   program's checksum to make sure we only accumulate whole program\n+   statistics to the correct summary. An object file might be embedded\n+   in two separate programs, and we must keep the two program\n+   summaries separate.  */\n+\n+static void\n+gcov_exit (void)\n+{\n+  struct gcov_info *ptr;\n+  unsigned ix, jx;\n+  struct gcov_summary program;\n+  gcov_type program_max_one = 0;\n+  gcov_type program_max_sum = 0;\n+  gcov_type program_sum = 0;\n+  unsigned program_arcs = 0;\n+  \n+#if defined (TARGET_HAS_F_SETLKW)\n+  struct flock s_flock;\n+\n+  s_flock.l_type = F_WRLCK;\n+  s_flock.l_whence = SEEK_SET;\n+  s_flock.l_start = 0;\n+  s_flock.l_len = 0; /* Until EOF.  */\n+  s_flock.l_pid = getpid ();\n+#endif\n+\n+  memset (&program, 0, sizeof (program));\n+  program.checksum = gcov_crc32;\n+  \n+  for (ptr = gcov_list; ptr; ptr = ptr->next)\n+    {\n+      FILE *da_file;\n+      struct gcov_summary object;\n+      struct gcov_summary local_prg;\n+      int merging = 0;\n+      long base;\n+      const struct function_info *fn_info;\n+      gcov_type *count_ptr;\n+      gcov_type object_max_one = 0;\n+\n+      ptr->wkspc = 0;\n+      if (!ptr->filename)\n+\tcontinue;\n+\n+      for (ix = ptr->n_arc_counts, count_ptr = ptr->arc_counts; ix--;)\n+\t{\n+\t  gcov_type count = *count_ptr++;\n+\n+\t  if (count > object_max_one)\n+\t    object_max_one = count;\n+\t}\n+      if (object_max_one > program_max_one)\n+\tprogram_max_one = object_max_one;\n+      \n+      memset (&local_prg, 0, sizeof (local_prg));\n+      memset (&object, 0, sizeof (object));\n+      \n+      /* Open for modification */\n+      if ((da_file = fopen (ptr->filename, \"r+b\")))\n+\tmerging = 1;\n+      else if ((da_file = fopen (ptr->filename, \"w+b\")))\n+\t;\n+      else\n+\t{\n+\t  fprintf (stderr, \"profiling:%s:Cannot open\\n\", ptr->filename);\n+\t  ptr->filename = 0;\n+\t  continue;\n+\t}\n+\n+#if defined (TARGET_HAS_F_SETLKW)\n+      /* After a fork, another process might try to read and/or write\n+         the same file simultaneously.  So if we can, lock the file to\n+         avoid race conditions.  */\n+      while (fcntl (fileno (da_file), F_SETLKW, &s_flock)\n+\t     && errno == EINTR)\n+\tcontinue;\n+#endif\n+      if (merging)\n+\t{\n+\t  /* Merge data from file.  */\n+\t  unsigned tag, length;\n+\t      \n+\t  if (gcov_read_unsigned (da_file, &tag) || tag != GCOV_DATA_MAGIC)\n+\t    {\n+\t      fprintf (stderr, \"profiling:%s:Not a gcov data file\\n\",\n+\t\t       ptr->filename);\n+\t    read_fatal:;\n+\t      fclose (da_file);\n+\t      ptr->filename = 0;\n+\t      continue;\n+\t    }\n+\t  if (gcov_read_unsigned (da_file, &length) || length != GCOV_VERSION)\n+\t    {\n+\t      gcov_version_mismatch (ptr, length);\n+\t      goto read_fatal;\n+\t    }\n+\t  \n+\t  /* Merge execution counts for each function.  */\n+\t  count_ptr = ptr->arc_counts;\n+\t  for (ix = ptr->n_functions, fn_info = ptr->functions;\n+\t       ix--; fn_info++)\n+\t    {\n+\t      if (gcov_read_unsigned (da_file, &tag)\n+\t\t  || gcov_read_unsigned (da_file, &length))\n+\t\t{\n+\t\tread_error:;\n+\t\t  fprintf (stderr, \"profiling:%s:Error merging\\n\",\n+\t\t\t   ptr->filename);\n+\t\t  goto read_fatal;\n+\t\t}\n+\n+\t      /* Check function */\n+\t      if (tag != GCOV_TAG_FUNCTION)\n+\t\t{\n+\t\tread_mismatch:;\n+\t\t  fprintf (stderr, \"profiling:%s:Merge mismatch at %s\\n\",\n+\t\t\t   ptr->filename, fn_info->name);\n+\t\t  goto read_fatal;\n+\t\t}\n+\t      {\n+\t\tunsigned flength, checksum;\n+\t\t\n+\t\tif (gcov_read_unsigned (da_file, &flength)\n+\t\t    || gcov_skip_string (da_file, flength)\n+\t\t    || gcov_read_unsigned (da_file, &checksum))\n+\t\t  goto read_error;\n+\t\tif (flength != strlen (fn_info->name)\n+\t\t    || checksum != fn_info->checksum)\n+\t\t  goto read_mismatch;\n+\t      }\n+\t      /* Check arc counts */\n+\t      if (gcov_read_unsigned (da_file, &tag)\n+\t\t  || gcov_read_unsigned (da_file, &length))\n+\t\tgoto read_error;\n+\t      if (tag != GCOV_TAG_ARC_COUNTS\n+\t\t  || length / 8 != fn_info->n_arc_counts)\n+\t\tgoto read_mismatch;\n+\t      {\n+\t\tgcov_type count;\n+\t\t\n+\t\tfor (jx = fn_info->n_arc_counts; jx--; count_ptr++)\n+\t\t  if (gcov_read_counter (da_file, &count))\n+\t\t    goto read_error;\n+\t\t  else\n+\t\t    *count_ptr += count;\n+\t      }\n+\t    }\n+\n+\t  /* Check object summary */\n+\t  if (gcov_read_unsigned (da_file, &tag)\n+\t      || gcov_read_unsigned (da_file, &length))\n+\t    goto read_error;\n+\t  if (tag != GCOV_TAG_OBJECT_SUMMARY)\n+\t    goto read_mismatch;\n+\t  if (gcov_read_summary (da_file, &object))\n+\t    goto read_error;\n+\n+\t  /* Check program summary */\n+\t  while (1)\n+\t    {\n+\t      long base = ftell (da_file);\n+\t      \n+\t      if (gcov_read_unsigned (da_file, &tag)\n+\t\t  || gcov_read_unsigned (da_file, &length))\n+\t\t{\n+\t\t  if (feof (da_file))\n+\t\t    break;\n+\t\t  goto read_error;\n+\t\t}\n+\t      if (tag != GCOV_TAG_PROGRAM_SUMMARY\n+\t\t  && tag != GCOV_TAG_PLACEHOLDER_SUMMARY\n+\t\t  && tag != GCOV_TAG_INCORRECT_SUMMARY)\n+\t\tgoto read_mismatch;\n+\t      if (gcov_read_summary (da_file, &local_prg))\n+\t\tgoto read_error;\n+\t      if (local_prg.checksum != program.checksum)\n+\t\tcontinue;\n+\t      if (tag == GCOV_TAG_PLACEHOLDER_SUMMARY)\n+\t\t{\n+\t\t  fprintf (stderr,\n+\t\t\t   \"profiling:%s:Concurrent race detected\\n\",\n+\t\t\t   ptr->filename);\n+\t\t  goto read_fatal;\n+\t\t}\n+\t      merging = -1;\n+\t      if (tag != GCOV_TAG_PROGRAM_SUMMARY)\n+\t\tbreak;\n+\t      \n+\t      if (program.runs\n+\t\t  && memcmp (&program, &local_prg, sizeof (program)))\n+\t\t{\n+\t\t  fprintf (stderr, \"profiling:%s:Invocation mismatch\\n\",\n+\t\t\t   ptr->filename);\n+\t\t  local_prg.runs = 0;\n+\t\t}\n+\t      else\n+\t\tmemcpy (&program, &local_prg, sizeof (program));\n+\t      ptr->wkspc = base;\n+\t      break;\n+\t    }\n+\t  fseek (da_file, 0, SEEK_SET);\n+\t}\n+\n+      object.runs++;\n+      object.arcs = ptr->n_arc_counts;\n+      object.arc_sum = 0;\n+      if (object.arc_max_one < object_max_one)\n+\tobject.arc_max_one = object_max_one;\n+      object.arc_sum_max += object_max_one;\n+      \n+      /* Write out the data.  */\n+      if (/* magic */\n+\t  gcov_write_unsigned (da_file, GCOV_DATA_MAGIC)\n+\t  /* version number */\n+\t  || gcov_write_unsigned (da_file, GCOV_VERSION))\n+\t{\n+\twrite_error:;\n+\t  fclose (da_file);\n+\t  fprintf (stderr, \"profiling:%s:Error writing\\n\", ptr->filename);\n+\t  ptr->filename = 0;\n+\t  continue;\n+\t}\n+      \n+      /* Write execution counts for each function.  */\n+      count_ptr = ptr->arc_counts;\n+      for (ix = ptr->n_functions, fn_info = ptr->functions; ix--; fn_info++)\n+\t{\n+\t  /* Announce function.  */\n+\t  if (gcov_write_unsigned (da_file, GCOV_TAG_FUNCTION)\n+\t      || !(base = gcov_reserve_length (da_file))\n+\t      /* function name */\n+\t      || gcov_write_string (da_file, fn_info->name,\n+\t\t\t\t    strlen (fn_info->name))\n+\t      /* function checksum */\n+\t      || gcov_write_unsigned (da_file, fn_info->checksum)\n+\t      || gcov_write_length (da_file, base))\n+\t    goto write_error;\n+\t  \n+\t  /* arc counts.  */\n+\t  if (gcov_write_unsigned (da_file, GCOV_TAG_ARC_COUNTS)\n+\t      || !(base = gcov_reserve_length (da_file)))\n+\t    goto write_error;\n+\t  \n+\t  for (jx = fn_info->n_arc_counts; jx--;)\n+\t    {\n+\t      gcov_type count = *count_ptr++;\n+\t      \n+\t      object.arc_sum += count;\n+\t      if (object.arc_max_sum < count)\n+\t\tobject.arc_max_sum = count;\n+\t      if (gcov_write_counter (da_file, count))\n+\t\tgoto write_error; /* RIP Edsger Dijkstra */\n+\t    }\n+\t  if (gcov_write_length (da_file, base))\n+\t    goto write_error;\n+\t}\n+\n+      /* Object file summary.  */\n+      if (gcov_write_summary (da_file, GCOV_TAG_OBJECT_SUMMARY, &object))\n+\tgoto write_error;\n+\n+      if (merging >= 0)\n+\t{\n+\t  if (fseek (da_file, 0, SEEK_END))\n+\t    goto write_error;\n+\t  ptr->wkspc = ftell (da_file);\n+\t  if (gcov_write_summary (da_file, GCOV_TAG_PLACEHOLDER_SUMMARY,\n+\t\t\t\t  &program))\n+\t    goto write_error;\n+\t}\n+      else if (ptr->wkspc)\n+\t{\n+\t  /* Zap trailing program summary */\n+\t  if (fseek (da_file, ptr->wkspc, SEEK_SET))\n+\t    goto write_error;\n+\t  if (!local_prg.runs)\n+\t    ptr->wkspc = 0;\n+\t  if (gcov_write_unsigned (da_file,\n+\t\t\t     local_prg.runs ? GCOV_TAG_PLACEHOLDER_SUMMARY\n+\t\t\t     : GCOV_TAG_INCORRECT_SUMMARY))\n+\t    goto write_error;\n+\t}\n+      if (fflush (da_file))\n+\tgoto write_error;\n+\n+      if (fclose (da_file))\n+\t{\n+\t  fprintf (stderr, \"profiling:%s:Error closing\\n\", ptr->filename);\n+\t  ptr->filename = 0;\n+\t}\n+      else\n+\t{\n+\t  program_arcs += ptr->n_arc_counts;\n+\t  program_sum += object.arc_sum;\n+\t  if (program_max_sum < object.arc_max_sum)\n+\t    program_max_sum = object.arc_max_sum;\n+\t}\n+    }\n+\n+  /* Generate whole program statistics.  */\n+  program.runs++;\n+  program.arcs = program_arcs;\n+  program.arc_sum = program_sum;\n+  if (program.arc_max_one < program_max_one)\n+    program.arc_max_one = program_max_one;\n+  if (program.arc_max_sum < program_max_sum)\n+    program.arc_max_sum = program_max_sum;\n+  program.arc_sum_max += program_max_one;\n+  \n+  /* Upate whole program statistics.  */\n+  for (ptr = gcov_list; ptr; ptr = ptr->next)\n+    if (ptr->filename && ptr->wkspc)\n+      {\n+\tFILE *da_file;\n+\t\n+\tda_file = fopen (ptr->filename, \"r+b\");\n+\tif (!da_file)\n+\t  {\n+\t    fprintf (stderr, \"profiling:%s:Cannot open\\n\", ptr->filename);\n+\t    continue;\n+\t  }\n+\t\n+#if defined (TARGET_HAS_F_SETLKW)\n+\twhile (fcntl (fileno (da_file), F_SETLKW, &s_flock)\n+\t       && errno == EINTR)\n+\t  continue;\n+#endif\n+\tif (fseek (da_file, ptr->wkspc, SEEK_SET)\n+ \t    || gcov_write_summary (da_file, GCOV_TAG_PROGRAM_SUMMARY, &program)\n+ \t    || fflush (da_file))\n+ \t  fprintf (stderr, \"profiling:%s:Error writing\\n\", ptr->filename);\n+\tif (fclose (da_file))\n+\t  fprintf (stderr, \"profiling:%s:Error closing\\n\", ptr->filename);\n+      }\n+}\n+\n+/* Add a new object file onto the bb chain.  Invoked automatically\n+   when running an object file's global ctors.  */\n+\n+void\n+__gcov_init (struct gcov_info *info)\n+{\n+  if (!info->version)\n+    return;\n+  if (info->version != GCOV_VERSION)\n+    gcov_version_mismatch (info, info->version);\n+  else\n+    {\n+      const char *ptr = info->filename;\n+      unsigned crc32 = gcov_crc32;\n+  \n+      do\n+\t{\n+\t  unsigned ix;\n+\t  unsigned value = *ptr << 24;\n+\n+\t  for (ix = 8; ix--; value <<= 1)\n+\t    {\n+\t      unsigned feedback;\n+\n+\t      feedback = (value ^ crc32) & 0x80000000 ? 0x04c11db7 : 0;\n+\t      crc32 <<= 1;\n+\t      crc32 ^= feedback;\n+\t    }\n+\t}\n+      while (*ptr++);\n+      \n+      gcov_crc32 = crc32;\n+      \n+      if (!gcov_list)\n+\tatexit (gcov_exit);\n+      \n+      info->next = gcov_list;\n+      gcov_list = info;\n+    }\n+  info->version = 0;\n+}\n+\n+/* Called before fork or exec - write out profile information gathered so\n+   far and reset it to zero.  This avoids duplication or loss of the\n+   profile information gathered so far.  */\n+\n+void\n+__gcov_flush (void)\n+{\n+  struct gcov_info *ptr;\n+\n+  gcov_exit ();\n+  for (ptr = gcov_list; ptr; ptr = ptr->next)\n+    {\n+      unsigned i;\n+      \n+      for (i = ptr->n_arc_counts; i--;)\n+\tptr->arc_counts[i] = 0;\n+    }\n+}"}, {"sha": "a18b8dd0a8b07e65366bece81f1197bed33d0fda", "filename": "gcc/mklibgcc.in", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2Fmklibgcc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2Fmklibgcc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmklibgcc.in?ref=23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "patch": "@@ -12,6 +12,7 @@\n # LIB2FUNCS_1\n # LIB2FUNCS_2\n # LIB2FUNCS_ST\n+# LIBGCOV\n # LIB2ADD\n # LIB2ADD_ST \n # LIB2ADDEH\n@@ -65,6 +66,9 @@ make_compile='$(MAKE) GCC_FOR_TARGET=\"$(GCC_FOR_TARGET)\" \\\n # Dependencies for libgcc2.c\n libgcc2_c_dep='stmp-dirs $(srcdir)/libgcc2.c $(CONFIG_H) coretypes.h $(TM_H) $(MACHMODE_H) longlong.h gbl-ctors.h config.status stmp-int-hdrs tsystem.h'\" $LIB2ADDEHDEP\"\n \n+# Dependencies for libgcov.c\n+libgcov_c_dep='stmp-dirs $(srcdir)/libgcov.c $(CONFIG_H) coretypes.h $(TM_H) $(MACHMODE_H) longlong.h gbl-ctors.h config.status stmp-int-hdrs tsystem.h'\n+\n # Dependencies for fp-bit.c\n fpbit_c_dep='stmp-dirs config.status tsystem.h'\n \n@@ -249,6 +253,25 @@ for file in $LIB2ADD_ST; do\n   libgcc2_st_objs=\"$libgcc2_st_objs ${oname}${objext}\"\n done\n \n+#\n+# build libgcov components\n+#\n+\n+libgcov_objs=\"\"\n+\n+for name in $LIBGCOV; do\n+  for ml in $MULTILIBS; do\n+    dir=`echo ${ml} | sed -e 's/;.*$//' -e 's/=/$(EQ)/g'`\n+    flags=`echo ${ml} | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`;\n+    out=\"libgcc/${dir}/${name}${objext}\"\n+\n+    echo $out: $libgcov_c_dep\n+    echo \"\t$gcc_compile\" '$(MAYBE_USE_COLLECT2)' $flags -DL$name \\\n+      -c '$(srcdir)/libgcov.c' -o $out\n+  done\n+  libgcov_objs=\"$libgcov_objs ${name}${objext}\"\n+done\n+\n # SHLIB_MKMAP\n # SHLIB_MKMAP_OPTS\n # SHLIB_MAPFILES\n@@ -275,6 +298,11 @@ for ml in $MULTILIBS; do\n     libgcc_st_objs=\"$libgcc_st_objs libgcc/${dir}/$o\"\n   done\n \n+  libgcov_a_objs=\"\"\n+  for o in $libgcov_objs; do\n+    libgcov_a_objs=\"$libgcov_a_objs libgcc/${dir}/$o\"\n+  done\n+  \n   if [ \"$SHLIB_LINK\" -a \"$SHLIB_MKMAP\" ]; then\n     mapfile=\"libgcc/${dir}/libgcc.map\"\n     tmpmapfile=\"libgcc/${dir}/tmp-libgcc.map\"\n@@ -314,6 +342,12 @@ for ml in $MULTILIBS; do\n   echo '\t$(AR_CREATE_FOR_TARGET)' ${dir}/libgcc.a $libgcc_a_objs\n   echo '\t$(RANLIB_FOR_TARGET)' ${dir}/libgcc.a\n \n+  echo \"\"\n+  echo \"${dir}/libgcov.a: $libgcov_a_objs\"\n+  echo \"\t-rm -rf ${dir}/libgcov.a\"\n+  echo '\t$(AR_CREATE_FOR_TARGET)' ${dir}/libgcov.a $libgcov_a_objs\n+  echo '\t$(RANLIB_FOR_TARGET)' ${dir}/libgcov.a\n+\n   if [ \"$SHLIB_LINK\" ]; then\n \n     echo \"\"\n@@ -395,7 +429,7 @@ for ml in $MULTILIBS; do\n   if [ $dir != . ]; then\n     dirs=\"$dirs ${dir} libgcc/${dir}\"\n   fi\n-  all=\"$all ${dir}/libgcc.a\"\n+  all=\"$all ${dir}/libgcc.a ${dir}/libgcov.a\"\n   if [ \"$SHLIB_LINK\" ]; then\n     all=\"$all ${dir}/libgcc_eh.a\"\n     if [ -z \"$SHLIB_MULTILIB\" ]; then\n@@ -456,6 +490,8 @@ for ml in $MULTILIBS; do\n   fi\n   echo '\t$(INSTALL_DATA)' ${dir}/libgcc.a ${ldir}/\n   echo '\t$(RANLIB_FOR_TARGET)' ${ldir}/libgcc.a\n+  echo '\t$(INSTALL_DATA)' ${dir}/libgcov.a ${ldir}/\n+  echo '\t$(RANLIB_FOR_TARGET)' ${ldir}/libgcov.a\n \n   if [ \"$SHLIB_LINK\" ]; then\n     echo '\t$(INSTALL_DATA)' ${dir}/libgcc_eh.a ${ldir}/"}, {"sha": "de2d309b449ed634c8441cdb6e448171e2dbf824", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "patch": "@@ -289,16 +289,12 @@ index_counts_file ()\n   unsigned magic, version, ix, checksum;\n   long *summary;\n \n-  if (!da_file)\n-    return 0;\n-  counts_file_index = htab_create (10, htab_counts_index_hash, htab_counts_index_eq, htab_counts_index_del);\n-\n   /* No .da file, no data.  */\n   if (!da_file)\n     return 0;\n+  counts_file_index = htab_create (10, htab_counts_index_hash, htab_counts_index_eq, htab_counts_index_del);\n \n   /* Now index all profile sections.  */\n-\n   rewind (da_file);\n \n   summary = NULL;"}]}