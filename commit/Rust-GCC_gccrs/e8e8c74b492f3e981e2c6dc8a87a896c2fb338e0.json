{"sha": "e8e8c74b492f3e981e2c6dc8a87a896c2fb338e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThlOGM3NGI0OTJmM2U5ODFlMmM2ZGM4YTg3YTg5NmMyZmIzMzhlMA==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@redhat.com", "date": "2011-07-08T13:22:52Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2011-07-08T13:22:52Z"}, "message": "fold-const.c (fold_truth_andor): Factored out truth_andor label from fold_binary as function.\n\n2011-07-08  Kai Tietz  <ktietz@redhat.com>\n\n        * fold-const.c (fold_truth_andor): Factored out truth_andor\n        label from fold_binary as function.\n        (fold_binary_loc): Replace truth_andor lable\n        by function fold_truth_andor.\n\nFrom-SVN: r176043", "tree": {"sha": "3c943286ca4bbc79f872d1ccdbdd9686da81624d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c943286ca4bbc79f872d1ccdbdd9686da81624d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8e8c74b492f3e981e2c6dc8a87a896c2fb338e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e8c74b492f3e981e2c6dc8a87a896c2fb338e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8e8c74b492f3e981e2c6dc8a87a896c2fb338e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e8c74b492f3e981e2c6dc8a87a896c2fb338e0/comments", "author": null, "committer": null, "parents": [{"sha": "6c3cb698c53a85548621eeb871011b6d7774051c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c3cb698c53a85548621eeb871011b6d7774051c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c3cb698c53a85548621eeb871011b6d7774051c"}], "stats": {"total": 185, "additions": 107, "deletions": 78}, "files": [{"sha": "3d1c284dbf0264baa46629745af54c302a7ab645", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e8c74b492f3e981e2c6dc8a87a896c2fb338e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e8c74b492f3e981e2c6dc8a87a896c2fb338e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8e8c74b492f3e981e2c6dc8a87a896c2fb338e0", "patch": "@@ -1,3 +1,10 @@\n+2011-07-08  Kai Tietz  <ktietz@redhat.com>\n+\n+\t* fold-const.c (fold_truth_andor): Factored out truth_andor\n+\tlabel from fold_binary as function.\n+\t(fold_binary_loc): Replace truth_andor lable\n+\tby function fold_truth_andor.\n+\n 2011-07-08  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \tPR middle-end/49519"}, {"sha": "1b5683d6e7a99e16095e18dba1d2d5a8a514506c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 100, "deletions": 78, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e8c74b492f3e981e2c6dc8a87a896c2fb338e0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e8c74b492f3e981e2c6dc8a87a896c2fb338e0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e8e8c74b492f3e981e2c6dc8a87a896c2fb338e0", "patch": "@@ -8211,6 +8211,97 @@ fold_unary_ignore_overflow_loc (location_t loc, enum tree_code code,\n   return res;\n }\n \n+/* Fold a binary bitwise/truth expression of code CODE and type TYPE with\n+   operands OP0 and OP1.  LOC is the location of the resulting expression.\n+   ARG0 and ARG1 are the NOP_STRIPed results of OP0 and OP1.\n+   Return the folded expression if folding is successful.  Otherwise,\n+   return NULL_TREE.  */\n+static tree\n+fold_truth_andor (location_t loc, enum tree_code code, tree type,\n+\t\t  tree arg0, tree arg1, tree op0, tree op1)\n+{\n+  tree tem;\n+\n+  /* We only do these simplifications if we are optimizing.  */\n+  if (!optimize)\n+    return NULL_TREE;\n+\n+  /* Check for things like (A || B) && (A || C).  We can convert this\n+     to A || (B && C).  Note that either operator can be any of the four\n+     truth and/or operations and the transformation will still be\n+     valid.   Also note that we only care about order for the\n+     ANDIF and ORIF operators.  If B contains side effects, this\n+     might change the truth-value of A.  */\n+  if (TREE_CODE (arg0) == TREE_CODE (arg1)\n+      && (TREE_CODE (arg0) == TRUTH_ANDIF_EXPR\n+\t  || TREE_CODE (arg0) == TRUTH_ORIF_EXPR\n+\t  || TREE_CODE (arg0) == TRUTH_AND_EXPR\n+\t  || TREE_CODE (arg0) == TRUTH_OR_EXPR)\n+      && ! TREE_SIDE_EFFECTS (TREE_OPERAND (arg0, 1)))\n+    {\n+      tree a00 = TREE_OPERAND (arg0, 0);\n+      tree a01 = TREE_OPERAND (arg0, 1);\n+      tree a10 = TREE_OPERAND (arg1, 0);\n+      tree a11 = TREE_OPERAND (arg1, 1);\n+      int commutative = ((TREE_CODE (arg0) == TRUTH_OR_EXPR\n+\t\t\t  || TREE_CODE (arg0) == TRUTH_AND_EXPR)\n+\t\t\t && (code == TRUTH_AND_EXPR\n+\t\t\t     || code == TRUTH_OR_EXPR));\n+\n+      if (operand_equal_p (a00, a10, 0))\n+\treturn fold_build2_loc (loc, TREE_CODE (arg0), type, a00,\n+\t\t\t    fold_build2_loc (loc, code, type, a01, a11));\n+      else if (commutative && operand_equal_p (a00, a11, 0))\n+\treturn fold_build2_loc (loc, TREE_CODE (arg0), type, a00,\n+\t\t\t    fold_build2_loc (loc, code, type, a01, a10));\n+      else if (commutative && operand_equal_p (a01, a10, 0))\n+\treturn fold_build2_loc (loc, TREE_CODE (arg0), type, a01,\n+\t\t\t    fold_build2_loc (loc, code, type, a00, a11));\n+\n+      /* This case if tricky because we must either have commutative\n+\t operators or else A10 must not have side-effects.  */\n+\n+      else if ((commutative || ! TREE_SIDE_EFFECTS (a10))\n+\t       && operand_equal_p (a01, a11, 0))\n+\treturn fold_build2_loc (loc, TREE_CODE (arg0), type,\n+\t\t\t    fold_build2_loc (loc, code, type, a00, a10),\n+\t\t\t    a01);\n+    }\n+\n+  /* See if we can build a range comparison.  */\n+  if (0 != (tem = fold_range_test (loc, code, type, op0, op1)))\n+    return tem;\n+\n+  if ((code == TRUTH_ANDIF_EXPR && TREE_CODE (arg0) == TRUTH_ORIF_EXPR)\n+      || (code == TRUTH_ORIF_EXPR && TREE_CODE (arg0) == TRUTH_ANDIF_EXPR))\n+    {\n+      tem = merge_truthop_with_opposite_arm (loc, arg0, arg1, true);\n+      if (tem)\n+\treturn fold_build2_loc (loc, code, type, tem, arg1);\n+    }\n+\n+  if ((code == TRUTH_ANDIF_EXPR && TREE_CODE (arg1) == TRUTH_ORIF_EXPR)\n+      || (code == TRUTH_ORIF_EXPR && TREE_CODE (arg1) == TRUTH_ANDIF_EXPR))\n+    {\n+      tem = merge_truthop_with_opposite_arm (loc, arg1, arg0, false);\n+      if (tem)\n+\treturn fold_build2_loc (loc, code, type, arg0, tem);\n+    }\n+\n+  /* Check for the possibility of merging component references.  If our\n+     lhs is another similar operation, try to merge its rhs with our\n+     rhs.  Then try to merge our lhs and rhs.  */\n+  if (TREE_CODE (arg0) == code\n+      && 0 != (tem = fold_truthop (loc, code, type,\n+\t\t\t\t   TREE_OPERAND (arg0, 1), arg1)))\n+    return fold_build2_loc (loc, code, type, TREE_OPERAND (arg0, 0), tem);\n+\n+  if ((tem = fold_truthop (loc, code, type, arg0, arg1)) != 0)\n+    return tem;\n+\n+  return NULL_TREE;\n+}\n+\n /* Fold a binary expression of code CODE and type TYPE with operands\n    OP0 and OP1, containing either a MIN-MAX or a MAX-MIN combination.\n    Return the folded expression if folding is successful.  Otherwise,\n@@ -11953,83 +12044,9 @@ fold_binary_loc (location_t loc,\n \t    return fold_build2_loc (loc, code, type, arg0, tem);\n \t}\n \n-    truth_andor:\n-      /* We only do these simplifications if we are optimizing.  */\n-      if (!optimize)\n-\treturn NULL_TREE;\n-\n-      /* Check for things like (A || B) && (A || C).  We can convert this\n-\t to A || (B && C).  Note that either operator can be any of the four\n-\t truth and/or operations and the transformation will still be\n-\t valid.   Also note that we only care about order for the\n-\t ANDIF and ORIF operators.  If B contains side effects, this\n-\t might change the truth-value of A.  */\n-      if (TREE_CODE (arg0) == TREE_CODE (arg1)\n-\t  && (TREE_CODE (arg0) == TRUTH_ANDIF_EXPR\n-\t      || TREE_CODE (arg0) == TRUTH_ORIF_EXPR\n-\t      || TREE_CODE (arg0) == TRUTH_AND_EXPR\n-\t      || TREE_CODE (arg0) == TRUTH_OR_EXPR)\n-\t  && ! TREE_SIDE_EFFECTS (TREE_OPERAND (arg0, 1)))\n-\t{\n-\t  tree a00 = TREE_OPERAND (arg0, 0);\n-\t  tree a01 = TREE_OPERAND (arg0, 1);\n-\t  tree a10 = TREE_OPERAND (arg1, 0);\n-\t  tree a11 = TREE_OPERAND (arg1, 1);\n-\t  int commutative = ((TREE_CODE (arg0) == TRUTH_OR_EXPR\n-\t\t\t      || TREE_CODE (arg0) == TRUTH_AND_EXPR)\n-\t\t\t     && (code == TRUTH_AND_EXPR\n-\t\t\t\t || code == TRUTH_OR_EXPR));\n-\n-\t  if (operand_equal_p (a00, a10, 0))\n-\t    return fold_build2_loc (loc, TREE_CODE (arg0), type, a00,\n-\t\t\t\tfold_build2_loc (loc, code, type, a01, a11));\n-\t  else if (commutative && operand_equal_p (a00, a11, 0))\n-\t    return fold_build2_loc (loc, TREE_CODE (arg0), type, a00,\n-\t\t\t\tfold_build2_loc (loc, code, type, a01, a10));\n-\t  else if (commutative && operand_equal_p (a01, a10, 0))\n-\t    return fold_build2_loc (loc, TREE_CODE (arg0), type, a01,\n-\t\t\t\tfold_build2_loc (loc, code, type, a00, a11));\n-\n-\t  /* This case if tricky because we must either have commutative\n-\t     operators or else A10 must not have side-effects.  */\n-\n-\t  else if ((commutative || ! TREE_SIDE_EFFECTS (a10))\n-\t\t   && operand_equal_p (a01, a11, 0))\n-\t    return fold_build2_loc (loc, TREE_CODE (arg0), type,\n-\t\t\t\tfold_build2_loc (loc, code, type, a00, a10),\n-\t\t\t\ta01);\n-\t}\n-\n-      /* See if we can build a range comparison.  */\n-      if (0 != (tem = fold_range_test (loc, code, type, op0, op1)))\n-\treturn tem;\n-\n-      if ((code == TRUTH_ANDIF_EXPR && TREE_CODE (arg0) == TRUTH_ORIF_EXPR)\n-\t  || (code == TRUTH_ORIF_EXPR && TREE_CODE (arg0) == TRUTH_ANDIF_EXPR))\n-\t{\n-\t  tem = merge_truthop_with_opposite_arm (loc, arg0, arg1, true);\n-\t  if (tem)\n-\t    return fold_build2_loc (loc, code, type, tem, arg1);\n-\t}\n-\n-      if ((code == TRUTH_ANDIF_EXPR && TREE_CODE (arg1) == TRUTH_ORIF_EXPR)\n-\t  || (code == TRUTH_ORIF_EXPR && TREE_CODE (arg1) == TRUTH_ANDIF_EXPR))\n-\t{\n-\t  tem = merge_truthop_with_opposite_arm (loc, arg1, arg0, false);\n-\t  if (tem)\n-\t    return fold_build2_loc (loc, code, type, arg0, tem);\n-\t}\n-\n-      /* Check for the possibility of merging component references.  If our\n-\t lhs is another similar operation, try to merge its rhs with our\n-\t rhs.  Then try to merge our lhs and rhs.  */\n-      if (TREE_CODE (arg0) == code\n-\t  && 0 != (tem = fold_truthop (loc, code, type,\n-\t\t\t\t       TREE_OPERAND (arg0, 1), arg1)))\n-\treturn fold_build2_loc (loc, code, type, TREE_OPERAND (arg0, 0), tem);\n-\n-      if ((tem = fold_truthop (loc, code, type, arg0, arg1)) != 0)\n-\treturn tem;\n+      if ((tem = fold_truth_andor (loc, code, type, arg0, arg1, op0, op1))\n+          != NULL_TREE)\n+        return tem;\n \n       return NULL_TREE;\n \n@@ -12087,7 +12104,12 @@ fold_binary_loc (location_t loc,\n \t\t  && operand_equal_p (n1, a0, 0)))\n \t    return fold_build2_loc (loc, TRUTH_XOR_EXPR, type, l0, n1);\n \t}\n-      goto truth_andor;\n+\n+      if ((tem = fold_truth_andor (loc, code, type, arg0, arg1, op0, op1))\n+          != NULL_TREE)\n+        return tem;\n+\n+      return NULL_TREE;\n \n     case TRUTH_XOR_EXPR:\n       /* If the second arg is constant zero, drop it.  */"}]}