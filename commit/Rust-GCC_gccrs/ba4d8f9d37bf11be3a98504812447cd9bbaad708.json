{"sha": "ba4d8f9d37bf11be3a98504812447cd9bbaad708", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE0ZDhmOWQzN2JmMTFiZTNhOTg1MDQ4MTI0NDdjZDliYmFhZDcwOA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-03-31T10:23:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-03-31T10:23:44Z"}, "message": "re PR middle-end/23401 (Gimplifier produces too many temporaries)\n\n2009-03-31  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/23401\n\tPR middle-end/27810\n\t* tree.h (DECL_GIMPLE_FORMAL_TEMP_P): Remove.\n\t(struct tree_decl_with_vis): Remove gimple_formal_temp member.\n\t* tree-eh.c (lower_eh_constructs_2): Move LHS assignment to\n\ta separate statement.\n\t* gimplify.c (pop_gimplify_context): Remove formal temp handling.\n\t(lookup_tmp_var): Likewise.\n\t(is_gimple_formal_tmp_or_call_rhs): Remove.\n\t(is_gimple_reg_or_call_rhs): Rename to ...\n\t(is_gimple_reg_rhs_or_call): ... this.\n\t(is_gimple_mem_or_call_rhs): Rename to ...\n\t(is_gimple_mem_rhs_or_call): ... this.\n\t(internal_get_tmp_var): Use is_gimple_reg_rhs_or_call.  Set\n\tDECL_GIMPLE_REG_P only if is_formal is true.\n\t(gimplify_compound_lval): Use is_gimple_reg.  Remove workaround\n\tfor non-proper post-modify expression gimplification.\n\t(gimplify_self_mod_expr): For post-modify expressions gimplify\n\tthe lvalue to a minimal lvalue.\n\t(rhs_predicate_for): Remove formal temp case.\n\t(gimplify_modify_expr_rhs): Likewise.\n\t(gimplify_addr_expr): Use is_gimple_reg.\n\t(gimplify_expr): Remove formal temp cases.\n\t(gimple_regimplify_operands): Likewise.\n\t* tree-ssa-pre.c (get_or_alloc_expr_for): Treat EXC_PTR_EXPR\n\tand FILTER_EXPR like constants.\n\t* gimple.c (walk_gimple_op): Fix val_only initialization, use\n\tis_gimple_reg.\n\t(is_gimple_formal_tmp_rhs): Remove.\n\t(is_gimple_reg_rhs): Remove special casing.\n\t(is_gimple_mem_rhs): Fix.\n\t(is_gimple_reg): Move DECL_GIMPLE_REG_P handling earlier.\n\t(is_gimple_formal_tmp_var): Remove.\n\t(is_gimple_formal_tmp_reg): Likewise.\n\t(is_gimple_min_lval): Allow invariant component ref parts.\n\t* gimple.h (is_gimple_formal_tmp_rhs, is_gimple_formal_tmp_var,\n\tis_gimple_formal_tmp_reg): Remove declarations.\n\t* tree-cfg.c (verify_expr): Verify that variables with address\n\ttaken do not have DECL_GIMPLE_REG_P set.\n\t* tree-mudflap.c (mf_build_check_statement_for): Use\n\tforce_gimple_operand instead of gimplify_expr.\n\n\tjava/\n\t* java-gimplify.c (java_gimplify_expr): Do not manually gimplify\n\tthe first operand of binary and comaprison expressions.\n\n\t* gcc.dg/tree-ssa/pr23401.c: New testcase.\n\t* gcc.dg/tree-ssa/pr27810.c: Likewise.\n\nFrom-SVN: r145338", "tree": {"sha": "5f692532b5bfb1559215c17e5d2b5753f7a01415", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f692532b5bfb1559215c17e5d2b5753f7a01415"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba4d8f9d37bf11be3a98504812447cd9bbaad708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4d8f9d37bf11be3a98504812447cd9bbaad708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba4d8f9d37bf11be3a98504812447cd9bbaad708", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4d8f9d37bf11be3a98504812447cd9bbaad708/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8de9b877e7853c725c1a9cc4dc5e18c39debf41d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de9b877e7853c725c1a9cc4dc5e18c39debf41d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8de9b877e7853c725c1a9cc4dc5e18c39debf41d"}], "stats": {"total": 387, "additions": 195, "deletions": 192}, "files": [{"sha": "15a8228c6cf9623715828fcfd893f3324a0e2a6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -1,3 +1,47 @@\n+2009-03-31  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/23401\n+\tPR middle-end/27810\n+\t* tree.h (DECL_GIMPLE_FORMAL_TEMP_P): Remove.\n+\t(struct tree_decl_with_vis): Remove gimple_formal_temp member.\n+\t* tree-eh.c (lower_eh_constructs_2): Move LHS assignment to\n+\ta separate statement.\n+\t* gimplify.c (pop_gimplify_context): Remove formal temp handling.\n+\t(lookup_tmp_var): Likewise.\n+\t(is_gimple_formal_tmp_or_call_rhs): Remove.\n+\t(is_gimple_reg_or_call_rhs): Rename to ...\n+\t(is_gimple_reg_rhs_or_call): ... this.\n+\t(is_gimple_mem_or_call_rhs): Rename to ...\n+\t(is_gimple_mem_rhs_or_call): ... this.\n+\t(internal_get_tmp_var): Use is_gimple_reg_rhs_or_call.  Set\n+\tDECL_GIMPLE_REG_P only if is_formal is true.\n+\t(gimplify_compound_lval): Use is_gimple_reg.  Remove workaround\n+\tfor non-proper post-modify expression gimplification.\n+\t(gimplify_self_mod_expr): For post-modify expressions gimplify\n+\tthe lvalue to a minimal lvalue.\n+\t(rhs_predicate_for): Remove formal temp case.\n+\t(gimplify_modify_expr_rhs): Likewise.\n+\t(gimplify_addr_expr): Use is_gimple_reg.\n+\t(gimplify_expr): Remove formal temp cases.\n+\t(gimple_regimplify_operands): Likewise.\n+\t* tree-ssa-pre.c (get_or_alloc_expr_for): Treat EXC_PTR_EXPR\n+\tand FILTER_EXPR like constants.\n+\t* gimple.c (walk_gimple_op): Fix val_only initialization, use\n+\tis_gimple_reg.\n+\t(is_gimple_formal_tmp_rhs): Remove.\n+\t(is_gimple_reg_rhs): Remove special casing.\n+\t(is_gimple_mem_rhs): Fix.\n+\t(is_gimple_reg): Move DECL_GIMPLE_REG_P handling earlier.\n+\t(is_gimple_formal_tmp_var): Remove.\n+\t(is_gimple_formal_tmp_reg): Likewise.\n+\t(is_gimple_min_lval): Allow invariant component ref parts.\n+\t* gimple.h (is_gimple_formal_tmp_rhs, is_gimple_formal_tmp_var,\n+\tis_gimple_formal_tmp_reg): Remove declarations.\n+\t* tree-cfg.c (verify_expr): Verify that variables with address\n+\ttaken do not have DECL_GIMPLE_REG_P set.\n+\t* tree-mudflap.c (mf_build_check_statement_for): Use\n+\tforce_gimple_operand instead of gimplify_expr.\n+\n 2009-03-31  Ayal Zaks  <zaks@il.ibm.com>\n \n \t* modulo-sched.c (sms_schedule_by_order): Pass the actual"}, {"sha": "a1dd6a750723d31b41fefe0fd0f091d771e5d7c2", "filename": "gcc/gimple.c", "status": "modified", "additions": 12, "deletions": 62, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -1380,7 +1380,8 @@ walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n       /* Walk the RHS operands.  A formal temporary LHS may use a\n \t COMPONENT_REF RHS.  */\n       if (wi)\n-\twi->val_only = !is_gimple_formal_tmp_var (gimple_assign_lhs (stmt));\n+\twi->val_only = !is_gimple_reg (gimple_assign_lhs (stmt))\n+                       || !gimple_assign_single_p (stmt);\n \n       for (i = 1; i < gimple_num_ops (stmt); i++)\n \t{\n@@ -2559,37 +2560,13 @@ is_gimple_operand (const_tree op)\n   return op && get_gimple_rhs_class (TREE_CODE (op)) == GIMPLE_SINGLE_RHS;\n }\n \n-\n-/* Return true if T is a GIMPLE RHS for an assignment to a temporary.  */\n-\n-bool\n-is_gimple_formal_tmp_rhs (tree t)\n-{\n-  if (is_gimple_lvalue (t) || is_gimple_val (t))\n-    return true;\n-\n-  return get_gimple_rhs_class (TREE_CODE (t)) != GIMPLE_INVALID_RHS;\n-}\n-\n /* Returns true iff T is a valid RHS for an assignment to a renamed\n    user -- or front-end generated artificial -- variable.  */\n \n bool\n is_gimple_reg_rhs (tree t)\n {\n-  /* If the RHS of the MODIFY_EXPR may throw or make a nonlocal goto\n-     and the LHS is a user variable, then we need to introduce a formal\n-     temporary.  This way the optimizers can determine that the user\n-     variable is only modified if evaluation of the RHS does not throw.\n-\n-     Don't force a temp of a non-renamable type; the copy could be\n-     arbitrarily expensive.  Instead we will generate a VDEF for\n-     the assignment.  */\n-\n-  if (is_gimple_reg_type (TREE_TYPE (t)) && tree_could_throw_p (t))\n-    return false;\n-\n-  return is_gimple_formal_tmp_rhs (t);\n+  return get_gimple_rhs_class (TREE_CODE (t)) != GIMPLE_INVALID_RHS;\n }\n \n /* Returns true iff T is a valid RHS for an assignment to an un-renamed\n@@ -2603,7 +2580,7 @@ is_gimple_mem_rhs (tree t)\n   if (is_gimple_reg_type (TREE_TYPE (t)))\n     return is_gimple_val (t);\n   else\n-    return is_gimple_formal_tmp_rhs (t);\n+    return is_gimple_val (t) || is_gimple_lvalue (t);\n }\n \n /*  Return true if T is a valid LHS for a GIMPLE assignment expression.  */\n@@ -2895,6 +2872,12 @@ is_gimple_reg (tree t)\n   if (!is_gimple_variable (t))\n     return false;\n \n+  /* Complex and vector values must have been put into SSA-like form.\n+     That is, no assignments to the individual components.  */\n+  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n+      || TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n+    return DECL_GIMPLE_REG_P (t);\n+\n   if (!is_gimple_reg_type (TREE_TYPE (t)))\n     return false;\n \n@@ -2921,45 +2904,10 @@ is_gimple_reg (tree t)\n   if (TREE_CODE (t) == VAR_DECL && DECL_HARD_REGISTER (t))\n     return false;\n \n-  /* Complex and vector values must have been put into SSA-like form.\n-     That is, no assignments to the individual components.  */\n-  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n-      || TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n-    return DECL_GIMPLE_REG_P (t);\n-\n   return true;\n }\n \n \n-/* Returns true if T is a GIMPLE formal temporary variable.  */\n-\n-bool\n-is_gimple_formal_tmp_var (tree t)\n-{\n-  if (TREE_CODE (t) == SSA_NAME)\n-    return true;\n-\n-  return TREE_CODE (t) == VAR_DECL && DECL_GIMPLE_FORMAL_TEMP_P (t);\n-}\n-\n-/* Returns true if T is a GIMPLE formal temporary register variable.  */\n-\n-bool\n-is_gimple_formal_tmp_reg (tree t)\n-{\n-  /* The intent of this is to get hold of a value that won't change.\n-     An SSA_NAME qualifies no matter if its of a user variable or not.  */\n-  if (TREE_CODE (t) == SSA_NAME)\n-    return true;\n-\n-  /* We don't know the lifetime characteristics of user variables.  */\n-  if (!is_gimple_formal_tmp_var (t))\n-    return false;\n-\n-  /* Finally, it must be capable of being placed in a register.  */\n-  return is_gimple_reg (t);\n-}\n-\n /* Return true if T is a GIMPLE variable whose address is not needed.  */\n \n bool\n@@ -3006,6 +2954,8 @@ is_gimple_asm_val (tree t)\n bool\n is_gimple_min_lval (tree t)\n {\n+  if (!(t = CONST_CAST_TREE (strip_invariant_refs (t))))\n+    return false;\n   return (is_gimple_id (t) || TREE_CODE (t) == INDIRECT_REF);\n }\n "}, {"sha": "b482c1d607dff2a405a08367f0c9e0bee758ddd9", "filename": "gcc/gimple.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -859,10 +859,6 @@ extern bool is_gimple_stmt (tree);\n extern bool is_gimple_reg_type (tree);\n /* Returns true iff T is a scalar register variable.  */\n extern bool is_gimple_reg (tree);\n-/* Returns true if T is a GIMPLE temporary variable, false otherwise.  */\n-extern bool is_gimple_formal_tmp_var (tree);\n-/* Returns true if T is a GIMPLE temporary register variable.  */\n-extern bool is_gimple_formal_tmp_reg (tree);\n /* Returns true iff T is any sort of variable.  */\n extern bool is_gimple_variable (tree);\n /* Returns true iff T is any sort of symbol.  */\n@@ -894,7 +890,6 @@ extern bool is_gimple_asm_val (tree);\n /* Returns true iff T is a valid rhs for a MODIFY_EXPR where the LHS is a\n    GIMPLE temporary, a renamed user variable, or something else,\n    respectively.  */\n-extern bool is_gimple_formal_tmp_rhs (tree);\n extern bool is_gimple_reg_rhs (tree);\n extern bool is_gimple_mem_rhs (tree);\n "}, {"sha": "515c58ed57e9ead1a1dcd66f262daa2d7bb08116", "filename": "gcc/gimplify.c", "status": "modified", "additions": 46, "deletions": 91, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -214,16 +214,12 @@ void\n pop_gimplify_context (gimple body)\n {\n   struct gimplify_ctx *c = gimplify_ctxp;\n-  tree t;\n \n   gcc_assert (c && (c->bind_expr_stack == NULL\n \t\t    || VEC_empty (gimple, c->bind_expr_stack)));\n   VEC_free (gimple, heap, c->bind_expr_stack);\n   gimplify_ctxp = c->prev_context;\n \n-  for (t = c->temps; t ; t = TREE_CHAIN (t))\n-    DECL_GIMPLE_FORMAL_TEMP_P (t) = 0;\n-\n   if (body)\n     declare_vars (c->temps, body, false);\n   else\n@@ -609,9 +605,6 @@ lookup_tmp_var (tree val, bool is_formal)\n \t}\n     }\n \n-  if (is_formal)\n-    DECL_GIMPLE_FORMAL_TEMP_P (ret) = 1;\n-\n   return ret;\n }\n \n@@ -622,61 +615,29 @@ lookup_tmp_var (tree val, bool is_formal)\n    gimplify_modify_expr.  */\n \n static bool\n-is_gimple_formal_tmp_or_call_rhs (tree t)\n+is_gimple_reg_rhs_or_call (tree t)\n {\n-  return TREE_CODE (t) == CALL_EXPR || is_gimple_formal_tmp_rhs (t);\n-}\n-\n-/* Returns true iff T is a valid RHS for an assignment to a renamed\n-   user -- or front-end generated artificial -- variable.  */\n-\n-static bool\n-is_gimple_reg_or_call_rhs (tree t)\n-{\n-  /* If the RHS of the MODIFY_EXPR may throw or make a nonlocal goto\n-     and the LHS is a user variable, then we need to introduce a formal\n-     temporary.  This way the optimizers can determine that the user\n-     variable is only modified if evaluation of the RHS does not throw.\n-\n-     Don't force a temp of a non-renamable type; the copy could be\n-     arbitrarily expensive.  Instead we will generate a VDEF for\n-     the assignment.  */\n-\n-  if (is_gimple_reg_type (TREE_TYPE (t))\n-      && ((TREE_CODE (t) == CALL_EXPR && TREE_SIDE_EFFECTS (t))\n-\t  || tree_could_throw_p (t)))\n-    return false;\n-\n-  return is_gimple_formal_tmp_or_call_rhs (t);\n+  return (get_gimple_rhs_class (TREE_CODE (t)) != GIMPLE_INVALID_RHS\n+\t  || TREE_CODE (t) == CALL_EXPR);\n }\n \n /* Return true if T is a valid memory RHS or a CALL_EXPR.  Note that\n    this predicate should only be used during gimplification.  See the\n    rationale for this in gimplify_modify_expr.  */\n \n static bool\n-is_gimple_mem_or_call_rhs (tree t)\n+is_gimple_mem_rhs_or_call (tree t)\n {\n   /* If we're dealing with a renamable type, either source or dest must be\n      a renamed variable.  */\n   if (is_gimple_reg_type (TREE_TYPE (t)))\n     return is_gimple_val (t);\n   else\n-    return is_gimple_formal_tmp_or_call_rhs (t);\n+    return (is_gimple_val (t) || is_gimple_lvalue (t)\n+\t    || TREE_CODE (t) == CALL_EXPR);\n }\n \n-\n-/* Returns a formal temporary variable initialized with VAL.  PRE_P is as\n-   in gimplify_expr.  Only use this function if:\n-\n-   1) The value of the unfactored expression represented by VAL will not\n-      change between the initialization and use of the temporary, and\n-   2) The temporary will not be otherwise modified.\n-\n-   For instance, #1 means that this is inappropriate for SAVE_EXPR temps,\n-   and #2 means it is inappropriate for && temps.\n-\n-   For other cases, use get_initialized_tmp_var instead.  */\n+/* Helper for get_formal_tmp_var and get_initialized_tmp_var.  */\n \n static tree\n internal_get_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p,\n@@ -686,7 +647,7 @@ internal_get_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p,\n \n   /* Notice that we explicitly allow VAL to be a CALL_EXPR so that we\n      can create an INIT_EXPR and convert it into a GIMPLE_CALL below.  */\n-  gimplify_expr (&val, pre_p, post_p, is_gimple_formal_tmp_or_call_rhs,\n+  gimplify_expr (&val, pre_p, post_p, is_gimple_reg_rhs_or_call,\n \t\t fb_rvalue);\n \n   t = lookup_tmp_var (val, is_formal);\n@@ -707,11 +668,11 @@ internal_get_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p,\n \t      SET_DECL_RESTRICT_BASE (t, u);\n \t    }\n \t}\n-    }\n \n-  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n-      || TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n-    DECL_GIMPLE_REG_P (t) = 1;\n+      if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n+\t  || TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n+\tDECL_GIMPLE_REG_P (t) = 1;\n+    }\n \n   mod = build2 (INIT_EXPR, TREE_TYPE (t), t, unshare_expr (val));\n \n@@ -735,9 +696,17 @@ internal_get_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p,\n   return t;\n }\n \n-/* Returns a formal temporary variable initialized with VAL.  PRE_P\n-   points to a sequence where side-effects needed to compute VAL should be\n-   stored.  */\n+/* Returns a formal temporary variable initialized with VAL.  PRE_P is as\n+   in gimplify_expr.  Only use this function if:\n+\n+   1) The value of the unfactored expression represented by VAL will not\n+      change between the initialization and use of the temporary, and\n+   2) The temporary will not be otherwise modified.\n+\n+   For instance, #1 means that this is inappropriate for SAVE_EXPR temps,\n+   and #2 means it is inappropriate for && temps.\n+\n+   For other cases, use get_initialized_tmp_var instead.  */\n \n tree\n get_formal_tmp_var (tree val, gimple_seq *pre_p)\n@@ -2006,7 +1975,7 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t{\n \t\t  TREE_OPERAND (t, 2) = low;\n \t\t  tret = gimplify_expr (&TREE_OPERAND (t, 2), pre_p,\n-\t\t\t\t\tpost_p, is_gimple_formal_tmp_reg,\n+\t\t\t\t\tpost_p, is_gimple_reg,\n \t\t\t\t\tfb_rvalue);\n \t\t  ret = MIN (ret, tret);\n \t\t}\n@@ -2026,7 +1995,7 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t{\n \t\t  TREE_OPERAND (t, 3) = elmt_size;\n \t\t  tret = gimplify_expr (&TREE_OPERAND (t, 3), pre_p,\n-\t\t\t\t\tpost_p, is_gimple_formal_tmp_reg,\n+\t\t\t\t\tpost_p, is_gimple_reg,\n \t\t\t\t\tfb_rvalue);\n \t\t  ret = MIN (ret, tret);\n \t\t}\n@@ -2049,7 +2018,7 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t{\n \t\t  TREE_OPERAND (t, 2) = offset;\n \t\t  tret = gimplify_expr (&TREE_OPERAND (t, 2), pre_p,\n-\t\t\t\t\tpost_p, is_gimple_formal_tmp_reg,\n+\t\t\t\t\tpost_p, is_gimple_reg,\n \t\t\t\t\tfb_rvalue);\n \t\t  ret = MIN (ret, tret);\n \t\t}\n@@ -2072,19 +2041,11 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n       if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t{\n-\t  /* Gimplify the dimension.\n-\t     Temporary fix for gcc.c-torture/execute/20040313-1.c.\n-\t     Gimplify non-constant array indices into a temporary\n-\t     variable.\n-\t     FIXME - The real fix is to gimplify post-modify\n-\t     expressions into a minimal gimple lvalue.  However, that\n-\t     exposes bugs in alias analysis.  The alias analyzer does\n-\t     not handle &PTR->FIELD very well.  Will fix after the\n-\t     branch is merged into mainline (dnovillo 2004-05-03).  */\n+\t  /* Gimplify the dimension.  */\n \t  if (!is_gimple_min_invariant (TREE_OPERAND (t, 1)))\n \t    {\n \t      tret = gimplify_expr (&TREE_OPERAND (t, 1), pre_p, post_p,\n-\t\t\t\t    is_gimple_formal_tmp_reg, fb_rvalue);\n+\t\t\t\t    is_gimple_val, fb_rvalue);\n \t      ret = MIN (ret, tret);\n \t    }\n \t}\n@@ -2176,9 +2137,18 @@ gimplify_self_mod_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   rhs = TREE_OPERAND (*expr_p, 1);\n \n   /* For postfix operator, we evaluate the LHS to an rvalue and then use\n-     that as the result value and in the postqueue operation.  */\n+     that as the result value and in the postqueue operation.  We also\n+     make sure to make lvalue a minimal lval, see\n+     gcc.c-torture/execute/20040313-1.c for an example where this matters.  */\n   if (postfix)\n     {\n+      if (!is_gimple_min_lval (lvalue))\n+\t{\n+\t  mark_addressable (lvalue);\n+\t  lvalue = build_fold_addr_expr (lvalue);\n+\t  gimplify_expr (&lvalue, pre_p, post_p, is_gimple_val, fb_rvalue);\n+\t  lvalue = build_fold_indirect_ref (lvalue);\n+\t}\n       ret = gimplify_expr (&lhs, pre_p, post_p, is_gimple_val, fb_rvalue);\n       if (ret == GS_ERROR)\n \treturn ret;\n@@ -3448,12 +3418,10 @@ gimplify_init_ctor_eval (tree object, VEC(constructor_elt,gc) *elts,\n gimple_predicate\n rhs_predicate_for (tree lhs)\n {\n-  if (is_gimple_formal_tmp_var (lhs))\n-    return is_gimple_formal_tmp_or_call_rhs;\n-  else if (is_gimple_reg (lhs))\n-    return is_gimple_reg_or_call_rhs;\n+  if (is_gimple_reg (lhs))\n+    return is_gimple_reg_rhs_or_call;\n   else\n-    return is_gimple_mem_or_call_rhs;\n+    return is_gimple_mem_rhs_or_call;\n }\n \n /* Gimplify a C99 compound literal expression.  This just means adding\n@@ -4120,11 +4088,6 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p,\n \t\t     || (DECL_P (*to_p) && DECL_REGISTER (*to_p)))\n \t      /* Don't force regs into memory.  */\n \t      use_target = false;\n-\t    else if (TREE_CODE (*to_p) == VAR_DECL\n-\t\t     && DECL_GIMPLE_FORMAL_TEMP_P (*to_p))\n-\t      /* Don't use the original target if it's a formal temp; we\n-\t\t don't want to take their addresses.  */\n-\t      use_target = false;\n \t    else if (TREE_CODE (*expr_p) == INIT_EXPR)\n \t      /* It's OK to use the target directly if it's being\n \t\t initialized. */\n@@ -4644,7 +4607,7 @@ gimplify_addr_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t This mostly happens if the frontend passed us something that\n \t it could not mark addressable yet, like a fortran\n \t pass-by-reference parameter (int) floatvar.  */\n-      if (is_gimple_formal_tmp_var (TREE_OPERAND (expr, 0)))\n+      if (is_gimple_reg (TREE_OPERAND (expr, 0)))\n \tTREE_OPERAND (expr, 0)\n \t  = get_initialized_tmp_var (TREE_OPERAND (expr, 0), pre_p, post_p);\n \n@@ -6316,16 +6279,12 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   if (gimple_test_f == is_gimple_reg)\n     gcc_assert (fallback & (fb_rvalue | fb_lvalue));\n   else if (gimple_test_f == is_gimple_val\n-           || gimple_test_f == is_gimple_formal_tmp_rhs\n-           || gimple_test_f == is_gimple_formal_tmp_or_call_rhs\n-           || gimple_test_f == is_gimple_formal_tmp_reg\n-           || gimple_test_f == is_gimple_formal_tmp_var\n            || gimple_test_f == is_gimple_call_addr\n            || gimple_test_f == is_gimple_condexpr\n            || gimple_test_f == is_gimple_mem_rhs\n-           || gimple_test_f == is_gimple_mem_or_call_rhs\n+           || gimple_test_f == is_gimple_mem_rhs_or_call\n            || gimple_test_f == is_gimple_reg_rhs\n-           || gimple_test_f == is_gimple_reg_or_call_rhs\n+           || gimple_test_f == is_gimple_reg_rhs_or_call\n            || gimple_test_f == is_gimple_asm_val)\n     gcc_assert (fallback & fb_rvalue);\n   else if (gimple_test_f == is_gimple_min_lval\n@@ -7128,7 +7087,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       gimplify_expr (&tmp, pre_p, post_p, is_gimple_reg, fb_rvalue);\n       *expr_p = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (tmp)), tmp);\n     }\n-  else if ((fallback & fb_rvalue) && is_gimple_formal_tmp_or_call_rhs (*expr_p))\n+  else if ((fallback & fb_rvalue) && is_gimple_reg_rhs_or_call (*expr_p))\n     {\n       /* An rvalue will do.  Assign the gimplified expression into a\n \t new temporary TMP and replace the original expression with\n@@ -7143,9 +7102,6 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t*expr_p = get_initialized_tmp_var (*expr_p, pre_p, post_p);\n       else\n \t*expr_p = get_formal_tmp_var (*expr_p, pre_p);\n-\n-      if (TREE_CODE (*expr_p) != SSA_NAME)\n-\tDECL_GIMPLE_FORMAL_TEMP_P (*expr_p) = 1;\n     }\n   else\n     {\n@@ -7597,7 +7553,7 @@ gimple_regimplify_operands (gimple stmt, gimple_stmt_iterator *gsi_p)\n       lhs = gimple_get_lhs (stmt);\n       /* If the LHS changed it in a way that requires a simple RHS,\n \t create temporary.  */\n-      if (lhs && !is_gimple_formal_tmp_var (lhs))\n+      if (lhs && !is_gimple_reg (lhs))\n \t{\n \t  bool need_temp = false;\n \n@@ -7646,7 +7602,6 @@ gimple_regimplify_operands (gimple stmt, gimple_stmt_iterator *gsi_p)\n \t    {\n \t      tree temp = create_tmp_var (TREE_TYPE (lhs), NULL);\n \n-\t      DECL_GIMPLE_FORMAL_TEMP_P (temp) = 1;\n \t      if (TREE_CODE (TREE_TYPE (lhs)) == COMPLEX_TYPE\n \t\t  || TREE_CODE (TREE_TYPE (lhs)) == VECTOR_TYPE)\n \t\tDECL_GIMPLE_REG_P (temp) = 1;"}, {"sha": "62c76a77c4f3fce998c716e53503b6a5ab1d1cab", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -1,3 +1,8 @@\n+2009-03-31  Richard Guenther  <rguenther@suse.de>\n+\n+\t* java-gimplify.c (java_gimplify_expr): Do not manually gimplify\n+\tthe first operand of binary and comaprison expressions.\n+\n 2009-03-30  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR rtl-optimization/323"}, {"sha": "e2ad02b697a12fbcba8869609eb9ece636ad882f", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -96,26 +96,6 @@ java_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       gcc_unreachable ();\n \n     default:\n-      /* Java insists on strict left-to-right evaluation of expressions.\n-\t A problem may arise if a variable used in the LHS of a binary\n-\t operation is altered by an assignment to that value in the RHS\n-\t before we've performed the operation.  So, we always copy every\n-\t LHS to a temporary variable.  \n-\n-\t FIXME: Are there any other cases where we should do this?\n-\t Parameter lists, maybe?  Or perhaps that's unnecessary because\n-\t the front end already generates SAVE_EXPRs.  */\n-\n-      if (TREE_CODE_CLASS (code) == tcc_binary\n-\t  || TREE_CODE_CLASS (code) == tcc_comparison)\n-\t{\n-\t  enum gimplify_status stat \n-\t    = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n-\t\t\t     is_gimple_formal_tmp_var, fb_rvalue);\n-\t  if (stat == GS_ERROR)\n-\t    return stat;\n-\t}\n-\n       return GS_UNHANDLED;\n     }\n "}, {"sha": "c21f1074cfb62750a4c0f8b28b0ed4e0d4888708", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -1,3 +1,10 @@\n+2009-03-31  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/23401\n+\tPR middle-end/27810\n+\t* gcc.dg/tree-ssa/pr23401.c: New testcase.\n+\t* gcc.dg/tree-ssa/pr27810.c: Likewise.\n+\n 2009-03-30  Steven G. Kargl  <kargls@comcast.net>\n \n \tPR fortran/38389"}, {"sha": "1d30ac7519f5369ffe5fc0c6ebc07324b9f14ef5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr23401.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23401.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23401.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23401.c?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-gimple\" } */\n+\n+struct f\n+{\n+  struct {\n+      int i;\n+  } ff[10];\n+};\n+\n+struct f g;\n+int ffff(int i)\n+{\n+  int t1 = 0;\n+  int i1 = g.ff[t1].i;\n+  int i2 = g.ff[i].i;\n+  return i1 + i2;\n+}\n+\n+/* We should not use extra temporaries apart from for i1 + i2.  */\n+\n+/* { dg-final { scan-tree-dump-times \"int\" 5 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"int D\\\\\\.\" 1 \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "c7da3bd5d06b7669ec0aa141f1977ad6e2f1cbe8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr27810.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr27810.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr27810.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr27810.c?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-gimple\" } */\n+\n+int bar (int);\n+\n+int qqq (int a)\n+{\n+    int result;\n+    result = bar (a);\n+    return result;\n+}\n+\n+/* We should not use an extra temporary for the result of the\n+   function call.  */\n+\n+/* { dg-final { scan-tree-dump-times \"int\" 3 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"int D\\\\\\.\" 1 \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "66f121836cb3e27b0d064670ae812369f112d2cd", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -2886,6 +2886,11 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t    error (\"address taken, but ADDRESSABLE bit not set\");\n \t    return x;\n \t  }\n+\tif (DECL_GIMPLE_REG_P (x))\n+\t  {\n+\t    error (\"DECL_GIMPLE_REG_P set on a variable with address taken\");\n+\t    return x;\n+\t  }\n \n \tbreak;\n       }"}, {"sha": "1d9a9bdac3629856a70514536c95e9048bd08c1b", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -1823,6 +1823,25 @@ lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n     {\n     case GIMPLE_CALL:\n     case GIMPLE_ASSIGN:\n+      /* If the stmt can throw use a new temporary for the assignment\n+         to a LHS.  This makes sure the old value of the LHS is\n+\t available on the EH edge.  */\n+      if (stmt_could_throw_p (stmt)\n+\t  && gimple_has_lhs (stmt)\n+\t  && !tree_could_throw_p (gimple_get_lhs (stmt))\n+\t  && is_gimple_reg_type (TREE_TYPE (gimple_get_lhs (stmt))))\n+\t{\n+\t  tree lhs = gimple_get_lhs (stmt);\n+\t  tree tmp = create_tmp_var (TREE_TYPE (lhs), NULL);\n+\t  gimple s = gimple_build_assign (lhs, tmp);\n+\t  gimple_set_location (s, gimple_location (stmt));\n+\t  gimple_set_block (s, gimple_block (stmt));\n+\t  gimple_set_lhs (stmt, tmp);\n+\t  if (TREE_CODE (TREE_TYPE (tmp)) == COMPLEX_TYPE\n+\t      || TREE_CODE (TREE_TYPE (tmp)) == VECTOR_TYPE)\n+\t    DECL_GIMPLE_REG_P (tmp) = 1;\n+\t  gsi_insert_after (gsi, s, GSI_SAME_STMT);\n+\t}\n       /* Look for things that can throw exceptions, and record them.  */\n       if (state->cur_region && stmt_could_throw_p (stmt))\n \t{"}, {"sha": "dae12874dad6c6fe951b0fa5768725f257856995", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -503,7 +503,7 @@ mf_build_check_statement_for (tree base, tree limit,\n   tree mf_elem;\n   tree mf_limit;\n   gimple g;\n-  gimple_seq seq;\n+  gimple_seq seq, stmts;\n \n   /* We first need to split the current basic block, and start altering\n      the CFG.  This allows us to insert the statements we're about to\n@@ -553,14 +553,16 @@ mf_build_check_statement_for (tree base, tree limit,\n   /* Build: __mf_base = (uintptr_t) <base address expression>.  */\n   seq = gimple_seq_alloc ();\n   t = fold_convert (mf_uintptr_type, unshare_expr (base));\n-  gimplify_expr (&t, &seq, &seq, is_gimple_reg_rhs, fb_rvalue);\n+  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n+  gimple_seq_add_seq (&seq, stmts);\n   g = gimple_build_assign (mf_base, t);\n   gimple_set_location (g, location);\n   gimple_seq_add_stmt (&seq, g);\n \n   /* Build: __mf_limit = (uintptr_t) <limit address expression>.  */\n   t = fold_convert (mf_uintptr_type, unshare_expr (limit));\n-  gimplify_expr (&t, &seq, &seq, is_gimple_reg_rhs, fb_rvalue);\n+  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n+  gimple_seq_add_seq (&seq, stmts);\n   g = gimple_build_assign (mf_limit, t);\n   gimple_set_location (g, location);\n   gimple_seq_add_stmt (&seq, g);\n@@ -577,7 +579,8 @@ mf_build_check_statement_for (tree base, tree limit,\n               TREE_TYPE (TREE_TYPE (mf_cache_array_decl)),\n               mf_cache_array_decl, t, NULL_TREE, NULL_TREE);\n   t = build1 (ADDR_EXPR, mf_cache_structptr_type, t);\n-  gimplify_expr (&t, &seq, &seq, is_gimple_reg_rhs, fb_rvalue);\n+  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n+  gimple_seq_add_seq (&seq, stmts);\n   g = gimple_build_assign (mf_elem, t);\n   gimple_set_location (g, location);\n   gimple_seq_add_stmt (&seq, g);\n@@ -622,7 +625,8 @@ mf_build_check_statement_for (tree base, tree limit,\n      result of the evaluation of 't' in a temporary variable which we\n      can use as the condition for the conditional jump.  */\n   t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, u);\n-  gimplify_expr (&t, &seq, &seq, is_gimple_reg_rhs, fb_rvalue);\n+  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n+  gimple_seq_add_seq (&seq, stmts);\n   cond = create_tmp_var (boolean_type_node, \"__mf_unlikely_cond\");\n   g = gimple_build_assign  (cond, t);\n   gimple_set_location (g, location);\n@@ -663,7 +667,8 @@ mf_build_check_statement_for (tree base, tree limit,\n   v = fold_build2 (PLUS_EXPR, integer_type_node,\n \t\t   fold_build2 (MINUS_EXPR, mf_uintptr_type, mf_limit, mf_base),\n \t\t   integer_one_node);\n-  gimplify_expr (&v, &seq, &seq, is_gimple_mem_rhs, fb_rvalue);\n+  v = force_gimple_operand (v, &stmts, true, NULL_TREE);\n+  gimple_seq_add_seq (&seq, stmts);\n   g = gimple_build_call (mf_check_fndecl, 4, mf_base, v, dirflag, u);\n   gimple_seq_add_stmt (&seq, g);\n "}, {"sha": "267c2fcfea22cabaf15ed24cf7257bd726ccb04e", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -1051,7 +1051,9 @@ get_or_alloc_expr_for (tree t)\n {\n   if (TREE_CODE (t) == SSA_NAME)\n     return get_or_alloc_expr_for_name (t);\n-  else if (is_gimple_min_invariant (t))\n+  else if (is_gimple_min_invariant (t)\n+\t   || TREE_CODE (t) == EXC_PTR_EXPR\n+\t   || TREE_CODE (t) == FILTER_EXPR)\n     return get_or_alloc_expr_for_constant (t);\n   else\n     {"}, {"sha": "1a83c2505da5bda7b70c6ed35307a4f381180d88", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4d8f9d37bf11be3a98504812447cd9bbaad708/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ba4d8f9d37bf11be3a98504812447cd9bbaad708", "patch": "@@ -2928,11 +2928,6 @@ struct tree_parm_decl GTY(())\n   /* Used to indicate that this DECL has weak linkage.  */\n #define DECL_WEAK(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.weak_flag)\n \n-/* Internal to the gimplifier.  Indicates that the value is a formal\n-   temporary controlled by the gimplifier.  */\n-#define DECL_GIMPLE_FORMAL_TEMP_P(DECL) \\\n-  DECL_WITH_VIS_CHECK (DECL)->decl_with_vis.gimple_formal_temp\n-\n /* Used to indicate that the DECL is a dllimport.  */\n #define DECL_DLLIMPORT_P(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.dllimport_flag)\n \n@@ -3044,7 +3039,6 @@ struct tree_decl_with_vis GTY(())\n  unsigned thread_local:1;\n  unsigned common_flag:1;\n  unsigned in_text_section : 1;\n- unsigned gimple_formal_temp : 1;\n  unsigned dllimport_flag : 1;\n  unsigned based_on_restrict_p : 1;\n  /* Used by C++.  Might become a generic decl flag.  */\n@@ -3062,7 +3056,7 @@ struct tree_decl_with_vis GTY(())\n \n  /* Belongs to VAR_DECL exclusively.  */\n  ENUM_BITFIELD(tls_model) tls_model : 3;\n- /* 12 unused bits. */\n+ /* 13 unused bits. */\n };\n \n /* In a VAR_DECL that's static,"}]}