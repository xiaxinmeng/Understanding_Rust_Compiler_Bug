{"sha": "5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEyZmM0ZDczODRjZGIwZjgwMmM4YWQyYmQ5N2ZlNjg2MGYyMjQ0Mw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-05-01T03:23:26Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-05-01T03:23:26Z"}, "message": "predicates.md (any_register_operand, [...]): Delete.\n\ngcc/\n\t* config/sh/predicates.md (any_register_operand, zero_extend_operand,\n\tlogical_reg_operand): Delete.\n\t(arith_operand, arith_reg_dest, arith_or_int_operand, cmpsi_operand,\n\tarith_reg_or_0_operand, arith_reg_or_0_or_1_operand, logical_operand,\n\tlogical_and_operand, movsrc_no_disp_mem_operand): Rewrite using\n\tmatch_operand and match_test.\n\t(sh_const_vec, sh_1el_vec): Remove redundant checks.  Declare local\n\tvariables on their first use.  Return bool values.\n\t* config/sh/sh.h (LOAD_EXTEND_OP): Update comment.\n\t* config/sh/sh.md (andsi3, iorsi3): Use arith_reg_dest for result and\n\tarith_reg_operand for input operand.  Remove empty constraints.\n\t(xorsi3): Delete.\n\t(*xorsi3_compact): Rename to xorsi3.\n\t(zero_extend<mode>si2): Use arith_reg_operand for input operand.\n\t(*zero_extend<mode>si2_disp_mem): Update comment.\n\t(mov_nop): Delete.\n\nFrom-SVN: r235687", "tree": {"sha": "0405693b3c474c1ffcf7893e8900a7521eb6a3fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0405693b3c474c1ffcf7893e8900a7521eb6a3fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443/comments", "author": null, "committer": null, "parents": [{"sha": "c4ef2cba3868fb829230c8f29be331b5640d6944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ef2cba3868fb829230c8f29be331b5640d6944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ef2cba3868fb829230c8f29be331b5640d6944"}], "stats": {"total": 255, "additions": 96, "deletions": 159}, "files": [{"sha": "fd8a95c213e46915ba6cb9a32309c0a8c3f89653", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443", "patch": "@@ -1,3 +1,22 @@\n+2016-05-01  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* config/sh/predicates.md (any_register_operand, zero_extend_operand,\n+\tlogical_reg_operand): Delete.\n+\t(arith_operand, arith_reg_dest, arith_or_int_operand, cmpsi_operand,\n+\tarith_reg_or_0_operand, arith_reg_or_0_or_1_operand, logical_operand,\n+\tlogical_and_operand, movsrc_no_disp_mem_operand): Rewrite using\n+\tmatch_operand and match_test.\n+\t(sh_const_vec, sh_1el_vec): Remove redundant checks.  Declare local\n+\tvariables on their first use.  Return bool values.\n+\t* config/sh/sh.h (LOAD_EXTEND_OP): Update comment.\n+\t* config/sh/sh.md (andsi3, iorsi3): Use arith_reg_dest for result and\n+\tarith_reg_operand for input operand.  Remove empty constraints.\n+\t(xorsi3): Delete.\n+\t(*xorsi3_compact): Rename to xorsi3.\n+\t(zero_extend<mode>si2): Use arith_reg_operand for input operand.\n+\t(*zero_extend<mode>si2_disp_mem): Update comment.\n+\t(mov_nop): Delete.\n+\n 2016-04-30  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* config/sh/t-sh: Remove SH5 support."}, {"sha": "3e69d88f64bbe6390532bf9948888744483aa7e4", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 62, "deletions": 124, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443", "patch": "@@ -17,29 +17,6 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-;; Like register_operand, but this predicate is defined with\n-;; define_special_predicate, not define_predicate.\n-(define_special_predicate \"any_register_operand\"\n-  (match_code \"subreg,reg\")\n-{\n-  return register_operand (op, mode);\n-})\n-\n-;; Returns 1 if OP is a valid source operand for an arithmetic insn.\n-(define_predicate \"arith_operand\"\n-  (match_code \"subreg,reg,const_int,truncate\")\n-{\n-  return arith_reg_operand (op, mode) || satisfies_constraint_I08 (op);\n-})\n-\n-;; Like above, but for DImode destinations: forbid paradoxical DImode\n-;; subregs, because this would lead to missing sign extensions when\n-;; truncating from DImode to SImode.\n-(define_predicate \"arith_reg_dest\"\n-  (match_code \"subreg,reg\")\n-{\n-  return arith_reg_operand (op, mode);\n-})\n \n ;; Returns 1 if OP is a normal arithmetic register.\n (define_predicate \"arith_reg_operand\"\n@@ -82,38 +59,36 @@\n   return 0;\n })\n \n-;; Likewise arith_operand but always permits const_int.\n-(define_predicate \"arith_or_int_operand\"\n-  (match_code \"subreg,reg,const_int,const_vector\")\n-{\n-  if (arith_operand (op, mode))\n-    return 1;\n-\n-  if (CONST_INT_P (op))\n-    return 1;\n-\n-  return 0;\n-})\n+;; Like above, but for DImode destinations: forbid paradoxical DImode\n+;; subregs, because this would lead to missing sign extensions when\n+;; truncating from DImode to SImode.\n+(define_predicate \"arith_reg_dest\"\n+  (and (match_code \"subreg,reg\")\n+       (match_operand 0 \"arith_reg_operand\")))\n \n-;; Returns 1 if OP is a valid source operand for a compare insn.\n-(define_predicate \"arith_reg_or_0_operand\"\n-  (match_code \"subreg,reg,const_int,const_vector\")\n-{\n-  if (arith_reg_operand (op, mode))\n-    return 1;\n+;; Returns true if OP is a valid source operand for an arithmetic insn.\n+(define_predicate \"arith_operand\"\n+  (and (match_code \"subreg,reg,const_int,truncate\")\n+       (ior (match_operand 0 \"arith_reg_operand\")\n+\t    (match_test \"satisfies_constraint_I08 (op)\"))))\n \n-  if (satisfies_constraint_Z (op))\n-    return 1;\n+;; Likewise arith_operand but always permits const_int.\n+(define_predicate \"arith_or_int_operand\"\n+  (and (match_code \"subreg,reg,const_int,const_vector\")\n+       (ior (match_operand 0 \"arith_operand\")\n+\t    (match_operand 0 \"const_int_operand\"))))\n \n-  return 0;\n-})\n+;; Returns true if OP is a valid source operand for a compare insn.\n+(define_predicate \"arith_reg_or_0_operand\" \n+  (and (match_code \"subreg,reg,const_int,const_vector\")\n+       (ior (match_operand 0 \"arith_reg_operand\")\n+\t    (match_test \"satisfies_constraint_Z (op)\"))))\n \n ;; Returns true if OP is either a register or constant 0 or constant 1.\n (define_predicate \"arith_reg_or_0_or_1_operand\"\n-  (match_code \"subreg,reg,const_int,const_vector\")\n-{\n-  return arith_reg_or_0_operand (op, mode) || satisfies_constraint_M (op);\n-})\n+  (and (match_code \"subreg,reg,const_int,const_vector\")\n+       (ior (match_operand 0 \"arith_reg_or_0_operand\")\n+\t    (match_test \"satisfies_constraint_M (op)\"))))\n \n ;; Returns true if OP is a suitable constant for the minimum value of a\n ;; clips.b or clips.w insn.\n@@ -136,18 +111,6 @@\n        (ior (match_test \"INTVAL (op) == 255\")\n \t    (match_test \"INTVAL (op) == 65535\"))))\n \n-;; Returns true if OP is an operand that can be used as the first operand in\n-;; the cstoresi4 expander pattern.\n-(define_predicate \"cmpsi_operand\"\n-  (match_code \"subreg,reg,const_int\")\n-{\n-  if (REG_P (op) && REGNO (op) == T_REG\n-      && GET_MODE (op) == SImode\n-      && TARGET_SH1)\n-    return 1;\n-  return arith_operand (op, mode);\n-})\n-\n ;; Returns true if OP is a floating point register that can be used in floating\n ;; point arithmetic operations.\n (define_predicate \"fp_arith_reg_operand\"\n@@ -274,10 +237,6 @@\n        (ior (match_test \"GET_MODE (op) == QImode\")\n \t    (match_test \"GET_MODE (op) == HImode\"))))\n \n-;; Returns 1 if the operand can be used in a zero_extend.\n-(define_predicate \"zero_extend_operand\"\n-  (match_operand 0 \"arith_reg_operand\"))\n-\n ;; Returns 1 if OP can be source of a simple move operation. Same as\n ;; general_operand, but a LABEL_REF is valid, PRE_DEC is invalid as\n ;; are subregs of system registers.\n@@ -376,12 +335,11 @@\n   return general_operand (op, mode);\n })\n \n-;; Returns 1 if OP is a MEM that does not use displacement addressing.\n+;; Returns true if OP is a MEM that does not use displacement addressing.\n (define_predicate \"movsrc_no_disp_mem_operand\"\n-  (match_code \"mem\")\n-{\n-  return general_movsrc_operand (op, mode) && satisfies_constraint_Snd (op);\n-})\n+  (and (match_code \"mem\")\n+       (match_operand 0 \"general_movsrc_operand\")\n+       (match_test \"satisfies_constraint_Snd (op)\")))\n \n ;; Returns 1 if OP can be a destination of a move. Same as\n ;; general_operand, but no preinc allowed.\n@@ -510,12 +468,11 @@\n \t && sh_legitimate_index_p (mode, XEXP (plus0_rtx, 1), TARGET_SH2A, true);\n })\n \n-;; Returns 1 if OP is a valid source operand for a logical operation.\n+;; Returns true if OP is a valid source operand for a logical operation.\n (define_predicate \"logical_operand\"\n-  (match_code \"subreg,reg,const_int\")\n-{\n-  return arith_reg_operand (op, mode) || satisfies_constraint_K08 (op);\n-})\n+  (and (match_code \"subreg,reg,const_int\")\n+       (ior (match_operand 0 \"arith_reg_operand\")\n+\t    (match_test \"satisfies_constraint_K08 (op)\"))))\n \n ;; Returns true if OP is a valid constant source operand for a logical\n ;; operations tst/and/or/xor #imm,r0.\n@@ -526,36 +483,23 @@\n ;; Like logical_operand but allows additional constant values which can be\n ;; done with zero extensions.  Used for the second operand of and insns.\n (define_predicate \"logical_and_operand\"\n-  (match_code \"subreg,reg,const_int\")\n-{\n-  return logical_operand (op, mode) || satisfies_constraint_Jmb (op)\n-\t || satisfies_constraint_Jmw (op);\n-})\n+  (and (match_code \"subreg,reg,const_int\")\n+       (ior (match_operand 0 \"logical_operand\")\n+\t    (match_test \"satisfies_constraint_Jmb (op)\")\n+\t    (match_test \"satisfies_constraint_Jmw (op)\"))))\n \n ;; Returns true if OP is a logical operator.\n (define_predicate \"logical_operator\"\n   (match_code \"and,ior,xor\"))\n \n-(define_predicate \"logical_reg_operand\"\n-  (match_code \"subreg,reg\")\n-{\n-  return arith_reg_operand (op, mode);\n-})\n-\n ;; Returns true if OP is a constant vector.\n (define_predicate \"sh_const_vec\"\n   (match_code \"const_vector\")\n {\n-  int i;\n-\n-  if (GET_CODE (op) != CONST_VECTOR\n-      || (GET_MODE (op) != mode && mode != VOIDmode))\n-    return 0;\n-  i = XVECLEN (op, 0) - 1;\n-  for (; i >= 0; i--)\n+  for (int i = XVECLEN (op, 0) - 1; i >= 0; i--)\n     if (!CONST_INT_P (XVECEXP (op, 0, i)))\n-      return 0;\n-  return 1;\n+      return false;\n+  return true;\n })\n \n ;; Determine if OP is a constant vector matching MODE with only one\n@@ -564,60 +508,47 @@\n (define_predicate \"sh_1el_vec\"\n   (match_code \"const_vector\")\n {\n-  int unit_size;\n-  int i, last, least, sign_ix;\n-  rtx sign;\n-\n-  if (GET_CODE (op) != CONST_VECTOR\n-      || (GET_MODE (op) != mode && mode != VOIDmode))\n-    return 0;\n   /* Determine numbers of last and of least significant elements.  */\n-  last = XVECLEN (op, 0) - 1;\n-  least = TARGET_LITTLE_ENDIAN ? 0 : last;\n+  int last = XVECLEN (op, 0) - 1;\n+  int least = TARGET_LITTLE_ENDIAN ? 0 : last;\n   if (!CONST_INT_P (XVECEXP (op, 0, least)))\n-    return 0;\n-  sign_ix = least;\n+    return false;\n+  int sign_ix = least;\n   if (GET_MODE_UNIT_SIZE (mode) == 1)\n     sign_ix = TARGET_LITTLE_ENDIAN ? 1 : last - 1;\n   if (!CONST_INT_P (XVECEXP (op, 0, sign_ix)))\n-    return 0;\n-  unit_size = GET_MODE_UNIT_SIZE (GET_MODE (op));\n-  sign = (INTVAL (XVECEXP (op, 0, sign_ix)) >> (unit_size * BITS_PER_UNIT - 1)\n-\t  ? constm1_rtx : const0_rtx);\n-  i = XVECLEN (op, 0) - 1;\n+    return false;\n+  int unit_size = GET_MODE_UNIT_SIZE (GET_MODE (op));\n+  rtx sign = INTVAL (XVECEXP (op, 0, sign_ix)) >> (unit_size * BITS_PER_UNIT - 1)\n+\t     ? constm1_rtx : const0_rtx;\n+  int i = XVECLEN (op, 0) - 1;\n   do\n     if (i != least && i != sign_ix && XVECEXP (op, 0, i) != sign)\n       return 0;\n   while (--i);\n-  return 1;\n+  return true;\n })\n \n ;; Returns true if OP is a vector which is composed of one element that is\n ;; repeated.\n (define_predicate \"sh_rep_vec\"\n   (match_code \"const_vector,parallel\")\n {\n-  int i;\n-  rtx x, y;\n-\n-  if ((GET_CODE (op) != CONST_VECTOR && GET_CODE (op) != PARALLEL)\n-      || (GET_MODE (op) != mode && mode != VOIDmode))\n-    return 0;\n-  i = XVECLEN (op, 0) - 2;\n-  x = XVECEXP (op, 0, i + 1);\n+  int i = XVECLEN (op, 0) - 2;\n+  rtx x = XVECEXP (op, 0, i + 1);\n   if (GET_MODE_UNIT_SIZE (mode) == 1)\n     {\n-      y = XVECEXP (op, 0, i);\n+      rtx y = XVECEXP (op, 0, i);\n       for (i -= 2; i >= 0; i -= 2)\n \tif (! rtx_equal_p (XVECEXP (op, 0, i + 1), x)\n \t    || ! rtx_equal_p (XVECEXP (op, 0, i), y))\n-\t  return 0;\n+\t  return false;\n     }\n   else\n     for (; i >= 0; i--)\n       if (XVECEXP (op, 0, i) != x)\n-\treturn 0;\n-  return 1;\n+\treturn false;\n+  return true;\n })\n \n ;; Returns true if OP is a valid shift count operand for shift operations.\n@@ -745,6 +676,13 @@\n     }\n })\n \n+;; Returns true if OP is an operand that can be used as the first operand in\n+;; the cstoresi4 expander pattern.\n+(define_predicate \"cmpsi_operand\"\n+  (and (match_code \"subreg,reg,const_int\")\n+       (ior (match_operand:SI 0 \"t_reg_operand\")\n+\t    (match_operand 0 \"arith_operand\"))))\n+\n ;; A predicate that returns true if OP is a valid construct around the T bit\n ;; that can be used as an operand for conditional branches.\n (define_predicate \"cbranch_treg_value\""}, {"sha": "719ebd35b06d21f5857afce7245351486e647bf5", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443", "patch": "@@ -1523,10 +1523,7 @@ struct sh_args {\n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n-   done, UNKNOWN if none.\n-   For SHmedia, we can truncate to QImode easier using zero extension.\n-   FP registers can load SImode values, but don't implicitly sign-extend\n-   them to DImode.  */\n+   done, UNKNOWN if none.  */\n #define LOAD_EXTEND_OP(MODE) ((MODE) != SImode ? SIGN_EXTEND : UNKNOWN)\n \n /* Define if loading short immediate values into registers sign extends.  */"}, {"sha": "f019d407b7be18d47739eab723243cb674583e84", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 14, "deletions": 31, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=5a2fc4d7384cdb0f802c8ad2bd97fe6860f22443", "patch": "@@ -2823,14 +2823,14 @@\n ;; -------------------------------------------------------------------------\n \n (define_expand \"andsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(and:SI (match_operand:SI 1 \"logical_reg_operand\" \"\")\n-\t\t(match_operand:SI 2 \"logical_and_operand\" \"\")))]\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(and:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t(match_operand:SI 2 \"logical_and_operand\")))]\n   \"\"\n {\n   /* If it is possible to turn the and insn into a zero extension\n      already, redundant zero extensions will be folded, which results\n-     in better code.  \n+     in better code.\n      Ideally the splitter of *andsi_compact would be enough, if redundant\n      zero extensions were detected after the combine pass, which does not\n      happen at the moment.  */\n@@ -2880,11 +2880,9 @@\n   [(set_attr \"type\" \"arith\")])\n \n (define_expand \"iorsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(ior:SI (match_operand:SI 1 \"logical_reg_operand\" \"\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"\")))]\n-  \"\"\n-  \"\")\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t(match_operand:SI 2 \"logical_operand\")))])\n \n (define_insn \"*iorsi3_compact\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,z\")\n@@ -2903,14 +2901,7 @@\n   \"bset\t%V2,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n-(define_expand \"xorsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(xor:SI (match_operand:SI 1 \"logical_reg_operand\" \"\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*xorsi3_compact\"\n+(define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z,r\")\n \t(xor:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"logical_operand\" \"K08,r\")))]\n@@ -4784,7 +4775,7 @@\n \n (define_expand \"zero_extend<mode>si2\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(zero_extend:SI (match_operand:QIHI 1 \"zero_extend_operand\")))])\n+\t(zero_extend:SI (match_operand:QIHI 1 \"arith_reg_operand\")))])\n \n (define_insn_and_split \"*zero_extend<mode>si2_compact\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n@@ -4819,12 +4810,11 @@\n ;; the displacement value to zero.  However, doing so too early results in\n ;; missed opportunities for other optimizations such as post-inc or index\n ;; addressing loads.\n-;; We don't allow the zero extending loads to match during RTL expansion\n-;; (see zero_extend_operand predicate), as this would pessimize other\n-;; optimization opportunities such as bit extractions of unsigned mems,\n-;; where the zero extraction is irrelevant.  If the zero extracting mem\n-;; loads are emitted early it will be more difficult to change them back\n-;; to sign extending loads (which are preferred).\n+;; We don't allow the zero extending loads to match during RTL expansion,\n+;; as this would pessimize other optimization opportunities such as bit\n+;; extractions of unsigned mems, where the zero extraction is irrelevant.\n+;; If the zero extracting mem loads are emitted early it will be more\n+;; difficult to change them back to sign extending loads (which are preferred).\n ;; The combine pass will also try to combine mem loads and zero extends,\n ;; which is prevented by 'sh_legitimate_combined_insn'.\n (define_insn \"*zero_extend<mode>si2_disp_mem\"\n@@ -6269,13 +6259,6 @@\n     }\n })\n \n-(define_insn \"mov_nop\"\n-  [(set (match_operand 0 \"any_register_operand\" \"\") (match_dup 0))]\n-  \"TARGET_SH2E\"\n-  \"\"\n-  [(set_attr \"length\" \"0\")\n-   (set_attr \"type\" \"nil\")])\n-\n (define_expand \"reload_insf__frn\"\n   [(parallel [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n \t\t   (match_operand:SF 1 \"immediate_operand\" \"FQ\"))"}]}