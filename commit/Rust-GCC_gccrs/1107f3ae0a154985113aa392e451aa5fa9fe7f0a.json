{"sha": "1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEwN2YzYWUwYTE1NDk4NTExM2FhMzkyZTQ1MWFhNWZhOWZlN2YwYQ==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-08-04T16:47:17Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-08-04T16:47:17Z"}, "message": "tree-vectorizer.h (struct _stmt_vec_info): Add new field for pattern def statement, and its access macro.\n\n\n        * tree-vectorizer.h (struct _stmt_vec_info): Add new field for\n        pattern def statement, and its access macro.\n        (NUM_PATTERNS): Set to 5.\n        * tree-vect-loop.c (vect_determine_vectorization_factor): Handle\n        pattern def statement.\n        (vect_transform_loop): Likewise.\n        * tree-vect-patterns.c (vect_vect_recog_func_ptrs): Add new\n        function vect_recog_over_widening_pattern ().\n        (vect_operation_fits_smaller_type): New function.\n        (vect_recog_over_widening_pattern, vect_mark_pattern_stmts):\n        Likewise.\n        (vect_pattern_recog_1): Move the code that marks pattern\n        statements to vect_mark_pattern_stmts (), and call it.  Update\n        documentation.\n        * tree-vect-stmts.c (vect_supportable_shift): New function.\n        (vect_analyze_stmt): Handle pattern def statement.\n        (new_stmt_vec_info): Initialize pattern def statement.\n\nFrom-SVN: r177409", "tree": {"sha": "f97727c3e140e3effeba1ba33adafa64f68719ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f97727c3e140e3effeba1ba33adafa64f68719ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/comments", "author": null, "committer": null, "parents": [{"sha": "6394830f4797f29b28552a98e5c9031c275041c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6394830f4797f29b28552a98e5c9031c275041c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6394830f4797f29b28552a98e5c9031c275041c1"}], "stats": {"total": 859, "additions": 825, "deletions": 34}, "files": [{"sha": "5c46be35cf0d9b244256c5ae61c33958838cfe36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "patch": "@@ -1,3 +1,23 @@\n+2011-08-04  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Add new field for\n+\tpattern def statement, and its access macro.\n+\t(NUM_PATTERNS): Set to 5.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Handle\n+\tpattern def statement.\n+\t(vect_transform_loop): Likewise.\n+\t* tree-vect-patterns.c (vect_vect_recog_func_ptrs): Add new\n+\tfunction vect_recog_over_widening_pattern ().\n+\t(vect_operation_fits_smaller_type): New function.\n+\t(vect_recog_over_widening_pattern, vect_mark_pattern_stmts):\n+\tLikewise.\n+\t(vect_pattern_recog_1): Move the code that marks pattern\n+\tstatements to vect_mark_pattern_stmts (), and call it.  Update\n+\tdocumentation.\n+\t* tree-vect-stmts.c (vect_supportable_shift): New function.\n+\t(vect_analyze_stmt): Handle pattern def statement.\n+\t(new_stmt_vec_info): Initialize pattern def statement.\n+\n 2011-08-04  Richard Henderson  <rth@redhat.com>\n \n \tPR target/49964"}, {"sha": "9545dc30a8d0bb0a80f0581069ae6fa5e0d3219a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "patch": "@@ -1,3 +1,10 @@\n+2011-08-04  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* gcc.dg/vect/vect-over-widen-1.c: New test.\n+\t* gcc.dg/vect/vect-over-widen-2.c: New test.\n+\t* gcc.dg/vect/vect-over-widen-3.c: New test.\n+\t* gcc.dg/vect/vect-over-widen-4.c: New test.\n+\n 2011-08-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR fortran/49957"}, {"sha": "36f4684ad582e921faf8611892a7954c54849198", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-1.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1.c?ref=1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+/* Modified rgb to rgb conversion from FFmpeg.  */\n+__attribute__ ((noinline)) void\n+foo (unsigned char *src, unsigned char *dst)\n+{\n+  unsigned char *s = src;\n+  unsigned short *d = (unsigned short *)dst;\n+  int i;\n+\n+  for (i = 0; i < N/4; i++)\n+    {\n+      const int b = *s++;\n+      const int g = *s++;\n+      const int r = *s++;\n+      const int a = *s++;\n+      *d = ((b>>3) | ((g&0xFC)<<3) | ((r&0xF8)<<8) | (a>>5));\n+      d++;\n+    }\n+\n+  s = src;\n+  d = (unsigned short *)dst;\n+  for (i = 0; i < N/4; i++)\n+    {\n+      const int b = *s++;\n+      const int g = *s++;\n+      const int r = *s++;\n+      const int a = *s++;\n+      if (*d != ((b>>3) | ((g&0xFC)<<3) | ((r&0xF8)<<8) | (a>>5)))\n+        abort ();\n+      d++;\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned char in[N], out[N];\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in[i] = i;\n+      out[i] = 255;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (in, out);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "fecc5ef3038106330df8350808dcdf61a62b6f24", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-2.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-2.c?ref=1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+/* Modified rgb to rgb conversion from FFmpeg.  */\n+__attribute__ ((noinline)) void\n+foo (unsigned char *src, unsigned char *dst)\n+{\n+  unsigned char *s = src;\n+  int *d = (int *)dst;\n+  int i;\n+\n+  for (i = 0; i < N/4; i++)\n+    {\n+      const int b = *s++;\n+      const int g = *s++;\n+      const int r = *s++;\n+      const int a = *s++;\n+      *d = ((b>>3) | ((g&0xFC)<<3) | ((r&0xF8)<<8) | (a>>5));\n+      d++;\n+    }\n+\n+  s = src;\n+  d = (int *)dst;\n+  for (i = 0; i < N/4; i++)\n+    {\n+      const int b = *s++;\n+      const int g = *s++;\n+      const int r = *s++;\n+      const int a = *s++;\n+      if (*d != ((b>>3) | ((g&0xFC)<<3) | ((r&0xF8)<<8) | (a>>5)))\n+        abort ();\n+      d++;\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned char in[N], out[N];\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in[i] = i;\n+      out[i] = 255;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (in, out);\n+\n+  return 0;\n+}\n+\n+/* Final value stays in int, so no over-widening is detected at the moment.  */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "ed36688f6c6b94709c8937b3405a289a80a4b755", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-3.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-3.c?ref=1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+/* Modified rgb to rgb conversion from FFmpeg.  */\n+__attribute__ ((noinline)) void\n+foo (unsigned char *src, unsigned char *dst)\n+{\n+  unsigned char *s = src;\n+  unsigned short *d = (unsigned short *)dst;\n+  int i;\n+\n+  for (i = 0; i < N/4; i++)\n+    {\n+      const int b = *s++;\n+      const int g = *s++;\n+      const int r = *s++;\n+      const int a = *s++;\n+      *d = ((b>>3) | ((g&0xFFC)<<3) | ((r+0xF8)>>8) | (a<<9));\n+      d++;\n+    }\n+\n+  s = src;\n+  d = (unsigned short *)dst;\n+  for (i = 0; i < N/4; i++)\n+    {\n+      const int b = *s++;\n+      const int g = *s++;\n+      const int r = *s++;\n+      const int a = *s++;\n+      if (*d != ((b>>3) | ((g&0xFFC)<<3) | ((r+0xF8)>>8) | (a<<9)))\n+        abort ();\n+      d++;\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned char in[N], out[N];\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in[i] = i;\n+      out[i] = 255;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (in, out);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "c1291e38f6d9842e46feda07c7ea945ade0c12c6", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-4.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4.c?ref=1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+/* Modified rgb to rgb conversion from FFmpeg.  */\n+__attribute__ ((noinline)) int\n+foo (unsigned char *src, unsigned char *dst)\n+{\n+  unsigned char *s = src;\n+  unsigned short *d = (unsigned short *)dst, res;\n+  int i, result = 0;\n+\n+  for (i = 0; i < N/4; i++)\n+    {\n+      const int b = *s++;\n+      const int g = *s++;\n+      const int r = *s++;\n+      const int a = *s++;\n+      res = ((b>>3) | ((g&0xFC)<<3) | ((r&0xF8)<<8) | (a>>5));\n+      *d = res;\n+      result += res;\n+      d++;\n+    }\n+\n+  s = src;\n+  d = (unsigned short *)dst;\n+  for (i = 0; i < N/4; i++)\n+    {\n+      const int b = *s++;\n+      const int g = *s++;\n+      const int r = *s++;\n+      const int a = *s++;\n+      if (*d != ((b>>3) | ((g&0xFC)<<3) | ((r&0xF8)<<8) | (a>>5)))\n+        abort ();\n+      d++;\n+    }\n+\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned char in[N], out[N];\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in[i] = i;\n+      out[i] = 255;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (in, out);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "7b765964713dfa9a404ecfdb61292eb3a55d4cab", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "patch": "@@ -181,8 +181,8 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   stmt_vec_info stmt_info;\n   int i;\n   HOST_WIDE_INT dummy;\n-  gimple stmt, pattern_stmt = NULL;\n-  bool analyze_pattern_stmt = false;\n+  gimple stmt, pattern_stmt = NULL, pattern_def_stmt = NULL;\n+  bool analyze_pattern_stmt = false, pattern_def = false;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_determine_vectorization_factor ===\");\n@@ -296,6 +296,29 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                        || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n             analyze_pattern_stmt = true;\n \n+          /* If a pattern statement has a def stmt, analyze it too.  */\n+          if (is_pattern_stmt_p (stmt_info)\n+              && (pattern_def_stmt = STMT_VINFO_PATTERN_DEF_STMT (stmt_info))\n+              && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_def_stmt))\n+                  || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_def_stmt))))\n+            {\n+              if (pattern_def)\n+                pattern_def = false;\n+              else\n+                {\n+                  if (vect_print_dump_info (REPORT_DETAILS))\n+                    {\n+                      fprintf (vect_dump, \"==> examining pattern def stmt: \");\n+                      print_gimple_stmt (vect_dump, pattern_def_stmt, 0,\n+                                         TDF_SLIM);\n+                    }\n+\n+                  pattern_def = true;\n+                  stmt = pattern_def_stmt;\n+                  stmt_info = vinfo_for_stmt (stmt);\n+                }\n+            }\n+\n \t  if (gimple_get_lhs (stmt) == NULL_TREE)\n \t    {\n \t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n@@ -400,7 +423,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      || (nunits > vectorization_factor))\n \t    vectorization_factor = nunits;\n \n-          if (!analyze_pattern_stmt)\n+          if (!analyze_pattern_stmt && !pattern_def)\n             gsi_next (&si);\n         }\n     }\n@@ -5085,8 +5108,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   tree cond_expr = NULL_TREE;\n   gimple_seq cond_expr_stmt_list = NULL;\n   bool do_peeling_for_loop_bound;\n-  gimple stmt, pattern_stmt;\n-  bool transform_pattern_stmt = false;\n+  gimple stmt, pattern_stmt, pattern_def_stmt;\n+  bool transform_pattern_stmt = false, pattern_def = false;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n@@ -5230,6 +5253,30 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n                        || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n             transform_pattern_stmt = true;\n \n+          /* If pattern statement has a def stmt, vectorize it too.  */\n+          if (is_pattern_stmt_p (stmt_info)\n+              && (pattern_def_stmt = STMT_VINFO_PATTERN_DEF_STMT (stmt_info))\n+              && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_def_stmt))\n+                  || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_def_stmt))))\n+            {\n+              if (pattern_def)\n+                pattern_def = false;\n+              else\n+                {\n+                  if (vect_print_dump_info (REPORT_DETAILS))\n+                    {\n+                      fprintf (vect_dump, \"==> vectorizing pattern def\"\n+                                          \" stmt: \");\n+                      print_gimple_stmt (vect_dump, pattern_def_stmt, 0,\n+                                         TDF_SLIM);\n+                    }\n+\n+                  pattern_def = true;\n+                  stmt = pattern_def_stmt;\n+                  stmt_info = vinfo_for_stmt (stmt);\n+                }\n+            }\n+\n \t  gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n \t  nunits = (unsigned int) TYPE_VECTOR_SUBPARTS (\n                                                STMT_VINFO_VECTYPE (stmt_info));\n@@ -5257,7 +5304,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t      /* Hybrid SLP stmts must be vectorized in addition to SLP.  */\n \t      if (!vinfo_for_stmt (stmt) || PURE_SLP_STMT (stmt_info))\n \t\t{\n-                  if (!transform_pattern_stmt)\n+                  if (!transform_pattern_stmt && !pattern_def)\n  \t\t    gsi_next (&si);\n   \t\t  continue;\n \t\t}\n@@ -5289,7 +5336,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t}\n \t    }\n \n-          if (!transform_pattern_stmt)\n+          if (!transform_pattern_stmt && !pattern_def)\n  \t    gsi_next (&si);\n \t}\t\t        /* stmts in BB */\n     }\t\t\t\t/* BBs in loop */"}, {"sha": "ac3afd8986251836e376a15cb18c6c482051eea1", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 422, "deletions": 25, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "patch": "@@ -47,11 +47,14 @@ static gimple vect_recog_widen_mult_pattern (VEC (gimple, heap) **, tree *,\n static gimple vect_recog_dot_prod_pattern (VEC (gimple, heap) **, tree *,\n \t\t\t\t\t   tree *);\n static gimple vect_recog_pow_pattern (VEC (gimple, heap) **, tree *, tree *);\n+static gimple vect_recog_over_widening_pattern (VEC (gimple, heap) **, tree *,\n+                                                 tree *);\n static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_widen_mult_pattern,\n \tvect_recog_widen_sum_pattern,\n \tvect_recog_dot_prod_pattern,\n-\tvect_recog_pow_pattern};\n+\tvect_recog_pow_pattern,\n+        vect_recog_over_widening_pattern};\n \n \n /* Function widened_name_p\n@@ -827,6 +830,419 @@ vect_recog_widen_sum_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n }\n \n \n+/* Return TRUE if the operation in STMT can be performed on a smaller type.\n+\n+   Input:\n+   STMT - a statement to check.\n+   DEF - we support operations with two operands, one of which is constant.\n+         The other operand can be defined by a demotion operation, or by a\n+         previous statement in a sequence of over-promoted operations.  In the\n+         later case DEF is used to replace that operand.  (It is defined by a\n+         pattern statement we created for the previous statement in the\n+         sequence).\n+\n+   Input/output:\n+   NEW_TYPE - Output: a smaller type that we are trying to use.  Input: if not\n+         NULL, it's the type of DEF.\n+   STMTS - additional pattern statements.  If a pattern statement (type\n+         conversion) is created in this function, its original statement is\n+         added to STMTS.\n+\n+   Output:\n+   OP0, OP1 - if the operation fits a smaller type, OP0 and OP1 are the new\n+         operands to use in the new pattern statement for STMT (will be created\n+         in vect_recog_over_widening_pattern ()).\n+   NEW_DEF_STMT - in case DEF has to be promoted, we create two pattern\n+         statements for STMT: the first one is a type promotion and the second\n+         one is the operation itself.  We return the type promotion statement\n+         in NEW_DEF_STMT and further store it in STMT_VINFO_PATTERN_DEF_STMT of\n+         the second pattern statement.  */\n+\n+static bool\n+vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n+                                  tree *op0, tree *op1, gimple *new_def_stmt,\n+                                  VEC (gimple, heap) **stmts)\n+{\n+  enum tree_code code;\n+  tree const_oprnd, oprnd;\n+  tree interm_type = NULL_TREE, half_type, tmp, new_oprnd, type;\n+  gimple def_stmt, new_stmt;\n+  bool first = false;\n+\n+  *new_def_stmt = NULL;\n+\n+  if (!is_gimple_assign (stmt))\n+    return false;\n+\n+  code = gimple_assign_rhs_code (stmt);\n+  if (code != LSHIFT_EXPR && code != RSHIFT_EXPR\n+      && code != BIT_IOR_EXPR && code != BIT_XOR_EXPR && code != BIT_AND_EXPR)\n+    return false;\n+\n+  oprnd = gimple_assign_rhs1 (stmt);\n+  const_oprnd = gimple_assign_rhs2 (stmt);\n+  type = gimple_expr_type (stmt);\n+\n+  if (TREE_CODE (oprnd) != SSA_NAME\n+      || TREE_CODE (const_oprnd) != INTEGER_CST)\n+    return false;\n+\n+  /* If we are in the middle of a sequence, we use DEF from a previous\n+     statement.  Otherwise, OPRND has to be a result of type promotion.  */\n+  if (*new_type)\n+    {\n+      half_type = *new_type;\n+      oprnd = def;\n+    }\n+  else\n+    {\n+      first = true;\n+      if (!widened_name_p (oprnd, stmt, &half_type, &def_stmt, false))\n+        return false;\n+    }\n+\n+  /* Can we perform the operation on a smaller type?  */\n+  switch (code)\n+    {\n+      case BIT_IOR_EXPR:\n+      case BIT_XOR_EXPR:\n+      case BIT_AND_EXPR:\n+        if (!int_fits_type_p (const_oprnd, half_type))\n+          {\n+            /* HALF_TYPE is not enough.  Try a bigger type if possible.  */\n+            if (TYPE_PRECISION (type) < (TYPE_PRECISION (half_type) * 4))\n+              return false;\n+\n+            interm_type = build_nonstandard_integer_type (\n+                        TYPE_PRECISION (half_type) * 2, TYPE_UNSIGNED (type));\n+            if (!int_fits_type_p (const_oprnd, interm_type))\n+              return false;\n+          }\n+\n+        break;\n+\n+      case LSHIFT_EXPR:\n+        /* Try intermediate type - HALF_TYPE is not enough for sure.  */\n+        if (TYPE_PRECISION (type) < (TYPE_PRECISION (half_type) * 4))\n+          return false;\n+\n+        /* Check that HALF_TYPE size + shift amount <= INTERM_TYPE size.\n+          (e.g., if the original value was char, the shift amount is at most 8\n+           if we want to use short).  */\n+        if (compare_tree_int (const_oprnd, TYPE_PRECISION (half_type)) == 1)\n+          return false;\n+\n+        interm_type = build_nonstandard_integer_type (\n+                        TYPE_PRECISION (half_type) * 2, TYPE_UNSIGNED (type));\n+\n+        if (!vect_supportable_shift (code, interm_type))\n+          return false;\n+\n+        break;\n+\n+      case RSHIFT_EXPR:\n+        if (vect_supportable_shift (code, half_type))\n+          break;\n+\n+        /* Try intermediate type - HALF_TYPE is not supported.  */\n+        if (TYPE_PRECISION (type) < (TYPE_PRECISION (half_type) * 4))\n+          return false;\n+\n+        interm_type = build_nonstandard_integer_type (\n+                        TYPE_PRECISION (half_type) * 2, TYPE_UNSIGNED (type));\n+\n+        if (!vect_supportable_shift (code, interm_type))\n+          return false;\n+\n+        break;\n+\n+      default:\n+        gcc_unreachable ();\n+    }\n+\n+  /* There are four possible cases:\n+     1. OPRND is defined by a type promotion (in that case FIRST is TRUE, it's\n+        the first statement in the sequence)\n+        a. The original, HALF_TYPE, is not enough - we replace the promotion\n+           from HALF_TYPE to TYPE with a promotion to INTERM_TYPE.\n+        b. HALF_TYPE is sufficient, OPRND is set as the RHS of the original\n+           promotion.\n+     2. OPRND is defined by a pattern statement we created.\n+        a. Its type is not sufficient for the operation, we create a new stmt:\n+           a type conversion for OPRND from HALF_TYPE to INTERM_TYPE.  We store\n+           this statement in NEW_DEF_STMT, and it is later put in\n+           STMT_VINFO_PATTERN_DEF_STMT of the pattern statement for STMT.\n+        b. OPRND is good to use in the new statement.  */\n+  if (first)\n+    {\n+      if (interm_type)\n+        {\n+          /* Replace the original type conversion HALF_TYPE->TYPE with\n+             HALF_TYPE->INTERM_TYPE.  */\n+          if (STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)))\n+            {\n+              new_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt));\n+              /* Check if the already created pattern stmt is what we need.  */\n+              if (!is_gimple_assign (new_stmt)\n+                  || gimple_assign_rhs_code (new_stmt) != NOP_EXPR\n+                  || TREE_TYPE (gimple_assign_lhs (new_stmt)) != interm_type)\n+                return false;\n+\n+              oprnd = gimple_assign_lhs (new_stmt);\n+            }\n+          else\n+            {\n+              /* Create NEW_OPRND = (INTERM_TYPE) OPRND.  */\n+              oprnd = gimple_assign_rhs1 (def_stmt);\n+              tmp = create_tmp_reg (interm_type, NULL);\n+              add_referenced_var (tmp);\n+              new_oprnd = make_ssa_name (tmp, NULL);\n+              new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n+                                                       oprnd, NULL_TREE);\n+              SSA_NAME_DEF_STMT (new_oprnd) = new_stmt;\n+              STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)) = new_stmt;\n+              VEC_safe_push (gimple, heap, *stmts, def_stmt);\n+              oprnd = new_oprnd;\n+            }\n+        }\n+      else\n+        {\n+          /* Retrieve the operand before the type promotion.  */\n+          oprnd = gimple_assign_rhs1 (def_stmt);\n+        }\n+    }\n+  else\n+    {\n+      if (interm_type)\n+        {\n+          /* Create a type conversion HALF_TYPE->INTERM_TYPE.  */\n+          tmp = create_tmp_reg (interm_type, NULL);\n+          add_referenced_var (tmp);\n+          new_oprnd = make_ssa_name (tmp, NULL);\n+          new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n+                                                   oprnd, NULL_TREE);\n+          SSA_NAME_DEF_STMT (new_oprnd) = new_stmt;\n+          oprnd = new_oprnd;\n+          *new_def_stmt = new_stmt;\n+        }\n+\n+      /* Otherwise, OPRND is already set.  */\n+    }\n+\n+  if (interm_type)\n+    *new_type = interm_type;\n+  else\n+    *new_type = half_type;\n+\n+  *op0 = oprnd;\n+  *op1 = fold_convert (*new_type, const_oprnd);\n+\n+  return true;\n+}\n+\n+\n+/* Try to find a statement or a sequence of statements that can be performed\n+   on a smaller type:\n+\n+     type x_t;\n+     TYPE x_T, res0_T, res1_T;\n+   loop:\n+     S1  x_t = *p;\n+     S2  x_T = (TYPE) x_t;\n+     S3  res0_T = op (x_T, C0);\n+     S4  res1_T = op (res0_T, C1);\n+     S5  ... = () res1_T;  - type demotion\n+\n+   where type 'TYPE' is at least double the size of type 'type', C0 and C1 are\n+   constants.\n+   Check if S3 and S4 can be done on a smaller type than 'TYPE', it can either\n+   be 'type' or some intermediate type.  For now, we expect S5 to be a type\n+   demotion operation.  We also check that S3 and S4 have only one use.\n+.\n+\n+*/\n+static gimple\n+vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n+                                  tree *type_in, tree *type_out)\n+{\n+  gimple stmt = VEC_pop (gimple, *stmts);\n+  gimple pattern_stmt = NULL, new_def_stmt, prev_stmt = NULL, use_stmt = NULL;\n+  tree op0, op1, vectype = NULL_TREE, lhs, use_lhs, use_type;\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  int nuses = 0;\n+  tree var = NULL_TREE, new_type = NULL_TREE, tmp, new_oprnd;\n+  bool first;\n+  struct loop *loop = (gimple_bb (stmt))->loop_father;\n+\n+  first = true;\n+  while (1)\n+    {\n+      if (!vinfo_for_stmt (stmt)\n+          || STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (stmt)))\n+        return NULL;\n+\n+      new_def_stmt = NULL;\n+      if (!vect_operation_fits_smaller_type (stmt, var, &new_type,\n+                                             &op0, &op1, &new_def_stmt,\n+                                             stmts))\n+        {\n+          if (first)\n+            return NULL;\n+          else\n+            break;\n+        }\n+\n+      /* STMT can be performed on a smaller type.  Check its uses.  */\n+      lhs = gimple_assign_lhs (stmt);\n+      nuses = 0;\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+        {\n+          if (is_gimple_debug (USE_STMT (use_p)))\n+            continue;\n+          use_stmt = USE_STMT (use_p);\n+          nuses++;\n+        }\n+\n+      if (nuses != 1 || !is_gimple_assign (use_stmt)\n+          || !gimple_bb (use_stmt)\n+          || !flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n+        return NULL;\n+\n+      /* Create pattern statement for STMT.  */\n+      vectype = get_vectype_for_scalar_type (new_type);\n+      if (!vectype)\n+        return NULL;\n+\n+      /* We want to collect all the statements for which we create pattern\n+         statetments, except for the case when the last statement in the\n+         sequence doesn't have a corresponding pattern statement.  In such\n+         case we associate the last pattern statement with the last statement\n+         in the sequence.  Therefore, we only add an original statetement to\n+         the list if we know that it is not the last.  */\n+      if (prev_stmt)\n+        VEC_safe_push (gimple, heap, *stmts, prev_stmt);\n+\n+      var = vect_recog_temp_ssa_var (new_type, NULL);\n+      pattern_stmt = gimple_build_assign_with_ops (\n+                          gimple_assign_rhs_code (stmt), var, op0, op1);\n+      SSA_NAME_DEF_STMT (var) = pattern_stmt;\n+      STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt)) = pattern_stmt;\n+      STMT_VINFO_PATTERN_DEF_STMT (vinfo_for_stmt (stmt)) = new_def_stmt;\n+\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"created pattern stmt: \");\n+          print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+        }\n+\n+      prev_stmt = stmt;\n+      stmt = use_stmt;\n+\n+      first = false;\n+    }\n+\n+  /* We got a sequence.  We expect it to end with a type demotion operation.\n+     Otherwise, we quit (for now).  There are three possible cases: the\n+     conversion is to NEW_TYPE (we don't do anything), the conversion is to\n+     a type bigger than NEW_TYPE and/or the signedness of USE_TYPE and\n+     NEW_TYPE differs (we create a new conversion statement).  */\n+  if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n+    {\n+      use_lhs = gimple_assign_lhs (use_stmt);\n+      use_type = TREE_TYPE (use_lhs);\n+      /* Support only type promotion or signedess change.  */\n+      if (!INTEGRAL_TYPE_P (use_type)\n+          || TYPE_PRECISION (new_type) > TYPE_PRECISION (use_type))\n+        return NULL;\n+\n+      if (TYPE_UNSIGNED (new_type) != TYPE_UNSIGNED (use_type)\n+          || TYPE_PRECISION (new_type) != TYPE_PRECISION (use_type))\n+        {\n+          /* Create NEW_TYPE->USE_TYPE conversion.  */\n+          tmp = create_tmp_reg (use_type, NULL);\n+          add_referenced_var (tmp);\n+          new_oprnd = make_ssa_name (tmp, NULL);\n+          pattern_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n+                                                       var, NULL_TREE);\n+          SSA_NAME_DEF_STMT (new_oprnd) = pattern_stmt;\n+          STMT_VINFO_RELATED_STMT (vinfo_for_stmt (use_stmt)) = pattern_stmt;\n+\n+          *type_in = get_vectype_for_scalar_type (new_type);\n+          *type_out = get_vectype_for_scalar_type (use_type);\n+\n+          /* We created a pattern statement for the last statement in the\n+             sequence, so we don't need to associate it with the pattern\n+             statement created for PREV_STMT.  Therefore, we add PREV_STMT\n+             to the list in order to mark it later in vect_pattern_recog_1.  */\n+          if (prev_stmt)\n+            VEC_safe_push (gimple, heap, *stmts, prev_stmt);\n+        }\n+      else\n+        {\n+          if (prev_stmt)\n+            STMT_VINFO_PATTERN_DEF_STMT (vinfo_for_stmt (use_stmt))\n+               = STMT_VINFO_PATTERN_DEF_STMT (vinfo_for_stmt (prev_stmt));\n+\n+          *type_in = vectype;\n+          *type_out = NULL_TREE;\n+        }\n+\n+      VEC_safe_push (gimple, heap, *stmts, use_stmt);\n+    }\n+  else\n+    /* TODO: support general case, create a conversion to the correct type.  */\n+    return NULL;\n+\n+  /* Pattern detected.  */\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    {\n+      fprintf (vect_dump, \"vect_recog_over_widening_pattern: detected: \");\n+      print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+    }\n+\n+  return pattern_stmt;\n+}\n+\n+\n+/* Mark statements that are involved in a pattern.  */\n+\n+static inline void\n+vect_mark_pattern_stmts (gimple orig_stmt, gimple pattern_stmt,\n+                         tree pattern_vectype)\n+{\n+  stmt_vec_info pattern_stmt_info, def_stmt_info;\n+  stmt_vec_info orig_stmt_info = vinfo_for_stmt (orig_stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (orig_stmt_info);\n+  gimple def_stmt;\n+\n+  set_vinfo_for_stmt (pattern_stmt,\n+                      new_stmt_vec_info (pattern_stmt, loop_vinfo, NULL));\n+  gimple_set_bb (pattern_stmt, gimple_bb (orig_stmt));\n+  pattern_stmt_info = vinfo_for_stmt (pattern_stmt);\n+\n+  STMT_VINFO_RELATED_STMT (pattern_stmt_info) = orig_stmt;\n+  STMT_VINFO_DEF_TYPE (pattern_stmt_info)\n+\t= STMT_VINFO_DEF_TYPE (orig_stmt_info);\n+  STMT_VINFO_VECTYPE (pattern_stmt_info) = pattern_vectype;\n+  STMT_VINFO_IN_PATTERN_P (orig_stmt_info) = true;\n+  STMT_VINFO_RELATED_STMT (orig_stmt_info) = pattern_stmt;\n+  STMT_VINFO_PATTERN_DEF_STMT (pattern_stmt_info)\n+\t= STMT_VINFO_PATTERN_DEF_STMT (orig_stmt_info);\n+  if (STMT_VINFO_PATTERN_DEF_STMT (pattern_stmt_info))\n+    {\n+      def_stmt = STMT_VINFO_PATTERN_DEF_STMT (pattern_stmt_info);\n+      set_vinfo_for_stmt (def_stmt,\n+                          new_stmt_vec_info (def_stmt, loop_vinfo, NULL));\n+      gimple_set_bb (def_stmt, gimple_bb (orig_stmt));\n+      def_stmt_info = vinfo_for_stmt (def_stmt);\n+      STMT_VINFO_RELATED_STMT (def_stmt_info) = orig_stmt;\n+      STMT_VINFO_DEF_TYPE (def_stmt_info)\n+\t= STMT_VINFO_DEF_TYPE (orig_stmt_info);\n+      STMT_VINFO_VECTYPE (def_stmt_info) = pattern_vectype;\n+    }\n+}\n+\n /* Function vect_pattern_recog_1\n \n    Input:\n@@ -856,7 +1272,6 @@ vect_pattern_recog_1 (\n {\n   gimple stmt = gsi_stmt (si), pattern_stmt;\n   stmt_vec_info stmt_info;\n-  stmt_vec_info pattern_stmt_info;\n   loop_vec_info loop_vinfo;\n   tree pattern_vectype;\n   tree type_in, type_out;\n@@ -924,26 +1339,17 @@ vect_pattern_recog_1 (\n     }\n \n   /* Mark the stmts that are involved in the pattern. */\n-  set_vinfo_for_stmt (pattern_stmt,\n-\t\t      new_stmt_vec_info (pattern_stmt, loop_vinfo, NULL));\n-  gimple_set_bb (pattern_stmt, gimple_bb (stmt));\n-  pattern_stmt_info = vinfo_for_stmt (pattern_stmt);\n-\n-  STMT_VINFO_RELATED_STMT (pattern_stmt_info) = stmt;\n-  STMT_VINFO_DEF_TYPE (pattern_stmt_info) = STMT_VINFO_DEF_TYPE (stmt_info);\n-  STMT_VINFO_VECTYPE (pattern_stmt_info) = pattern_vectype;\n-  STMT_VINFO_IN_PATTERN_P (stmt_info) = true;\n-  STMT_VINFO_RELATED_STMT (stmt_info) = pattern_stmt;\n+  vect_mark_pattern_stmts (stmt, pattern_stmt, pattern_vectype);\n \n   /* Patterns cannot be vectorized using SLP, because they change the order of\n      computation.  */\n   FOR_EACH_VEC_ELT (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i, next)\n     if (next == stmt)\n       VEC_ordered_remove (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i); \n \n-  /* In case of widen-mult by a constant, it is possible that an additional\n-     pattern stmt is created and inserted in STMTS_TO_REPLACE.  We create a\n-     stmt_info for it, and mark the relevant statements.  */\n+  /* It is possible that additional pattern stmts are created and inserted in\n+     STMTS_TO_REPLACE.  We create a stmt_info for each of them, and mark the\n+     relevant statements.  */\n   for (i = 0; VEC_iterate (gimple, stmts_to_replace, i, stmt)\n               && (unsigned) i < (VEC_length (gimple, stmts_to_replace) - 1);\n        i++)\n@@ -956,16 +1362,7 @@ vect_pattern_recog_1 (\n           print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n         }\n \n-      set_vinfo_for_stmt (pattern_stmt,\n-                      new_stmt_vec_info (pattern_stmt, loop_vinfo, NULL));\n-      gimple_set_bb (pattern_stmt, gimple_bb (stmt));\n-      pattern_stmt_info = vinfo_for_stmt (pattern_stmt);\n-\n-      STMT_VINFO_RELATED_STMT (pattern_stmt_info) = stmt;\n-      STMT_VINFO_DEF_TYPE (pattern_stmt_info)\n-        = STMT_VINFO_DEF_TYPE (stmt_info);\n-      STMT_VINFO_VECTYPE (pattern_stmt_info) = STMT_VINFO_VECTYPE (stmt_info);\n-      STMT_VINFO_IN_PATTERN_P (stmt_info) = true;\n+      vect_mark_pattern_stmts (stmt, pattern_stmt, NULL_TREE);\n     }\n \n   VEC_free (gimple, heap, stmts_to_replace);"}, {"sha": "e00822b7ea49fe3b8bb6ed38160a0b0c35d10e30", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "patch": "@@ -2212,6 +2212,42 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n }\n \n \n+/* Return TRUE if CODE (a shift operation) is supported for SCALAR_TYPE\n+   either as shift by a scalar or by a vector.  */\n+\n+bool\n+vect_supportable_shift (enum tree_code code, tree scalar_type)\n+{\n+\n+  enum machine_mode vec_mode;\n+  optab optab;\n+  int icode;\n+  tree vectype;\n+\n+  vectype = get_vectype_for_scalar_type (scalar_type);\n+  if (!vectype)\n+    return false;\n+\n+  optab = optab_for_tree_code (code, vectype, optab_scalar);\n+  if (!optab\n+      || optab_handler (optab, TYPE_MODE (vectype)) == CODE_FOR_nothing)\n+    {\n+      optab = optab_for_tree_code (code, vectype, optab_vector);\n+      if (!optab\n+          || (optab_handler (optab, TYPE_MODE (vectype))\n+                      == CODE_FOR_nothing))\n+        return false;\n+    }\n+\n+  vec_mode = TYPE_MODE (vectype);\n+  icode = (int) optab_handler (optab, vec_mode);\n+  if (icode == CODE_FOR_nothing)\n+    return false;\n+\n+  return true;\n+}\n+\n+\n /* Function vectorizable_shift.\n \n    Check if STMT performs a shift operation that can be vectorized.\n@@ -4890,7 +4926,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n   enum vect_relevant relevance = STMT_VINFO_RELEVANT (stmt_info);\n   bool ok;\n   tree scalar_type, vectype;\n-  gimple pattern_stmt;\n+  gimple pattern_stmt, pattern_def_stmt;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -4960,6 +4996,23 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n         return false;\n    }\n \n+  if (is_pattern_stmt_p (stmt_info)\n+      && (pattern_def_stmt = STMT_VINFO_PATTERN_DEF_STMT (stmt_info))\n+      && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_def_stmt))\n+          || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_def_stmt))))\n+    {\n+      /* Analyze def stmt of STMT if it's a pattern stmt.  */\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"==> examining pattern def statement: \");\n+          print_gimple_stmt (vect_dump, pattern_def_stmt, 0, TDF_SLIM);\n+        }\n+\n+      if (!vect_analyze_stmt (pattern_def_stmt, need_to_vectorize, node))\n+        return false;\n+   }\n+\n+\n   switch (STMT_VINFO_DEF_TYPE (stmt_info))\n     {\n       case vect_internal_def:\n@@ -5280,6 +5333,7 @@ new_stmt_vec_info (gimple stmt, loop_vec_info loop_vinfo,\n   STMT_VINFO_VECTORIZABLE (res) = true;\n   STMT_VINFO_IN_PATTERN_P (res) = false;\n   STMT_VINFO_RELATED_STMT (res) = NULL;\n+  STMT_VINFO_PATTERN_DEF_STMT (res) = NULL;\n   STMT_VINFO_DATA_REF (res) = NULL;\n \n   STMT_VINFO_DR_BASE_ADDRESS (res) = NULL;"}, {"sha": "3fe8b620c153747eb62730b7bbc9729def9933c7", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1107f3ae0a154985113aa392e451aa5fa9fe7f0a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=1107f3ae0a154985113aa392e451aa5fa9fe7f0a", "patch": "@@ -469,6 +469,9 @@ typedef struct _stmt_vec_info {\n         pattern).  */\n   gimple related_stmt;\n \n+  /* Used to keep a def stmt of a pattern stmt if such exists.  */\n+  gimple pattern_def_stmt;\n+\n   /* List of datarefs that are known to have the same alignment as the dataref\n      of this stmt.  */\n   VEC(dr_p,heap) *same_align_refs;\n@@ -536,6 +539,7 @@ typedef struct _stmt_vec_info {\n \n #define STMT_VINFO_IN_PATTERN_P(S)         (S)->in_pattern_p\n #define STMT_VINFO_RELATED_STMT(S)         (S)->related_stmt\n+#define STMT_VINFO_PATTERN_DEF_STMT(S)     (S)->pattern_def_stmt\n #define STMT_VINFO_SAME_ALIGN_REFS(S)      (S)->same_align_refs\n #define STMT_VINFO_DEF_TYPE(S)             (S)->def_type\n #define STMT_VINFO_GROUP_FIRST_ELEMENT(S)  (S)->first_element\n@@ -819,6 +823,7 @@ extern bool vectorizable_condition (gimple, gimple_stmt_iterator *, gimple *,\n extern void vect_get_load_cost (struct data_reference *, int, bool,\n                                 unsigned int *, unsigned int *);\n extern void vect_get_store_cost (struct data_reference *, int, unsigned int *);\n+extern bool vect_supportable_shift (enum tree_code, tree);\n \n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);\n@@ -897,7 +902,7 @@ extern void vect_slp_transform_bb (basic_block);\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n typedef gimple (* vect_recog_func_ptr) (VEC (gimple, heap) **, tree *, tree *);\n-#define NUM_PATTERNS 4\n+#define NUM_PATTERNS 5\n void vect_pattern_recog (loop_vec_info);\n \n /* In tree-vectorizer.c.  */"}]}