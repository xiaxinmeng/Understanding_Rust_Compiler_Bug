{"sha": "c00217fc2535186f7fe4536d2fa5581f23182903", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAwMjE3ZmMyNTM1MTg2ZjdmZTQ1MzZkMmZhNTU4MWYyMzE4MjkwMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-03-22T11:22:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-03-22T11:22:14Z"}, "message": "tree-ssa-loop-im.c (memory_references): Add refs_stored_in_loop bitmaps.\n\n2013-03-22  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-loop-im.c (memory_references): Add refs_stored_in_loop\n\tbitmaps.\n\t(gather_mem_refs_in_loops): Perform store accumulation here.\n\t(create_vop_ref_mapping_loop): Remove.\n\t(create_vop_ref_mapping): Likewise.\n\t(analyze_memory_references): Initialize refs_stored_in_loop.\n\t(LOOP_DEP_BIT): New define to map to bits in (in)dep_loop\n\tbitmaps.\n\t(record_indep_loop): Remove.\n\t(record_dep_loop): New function.\n\t(ref_indep_loop_p_1): Adjust to only walk over references\n\tin the loop, not its subloops.\n\t(ref_indep_loop_p): Rename to ...\n\t(ref_indep_loop_p_2): ... this and recurse over the loop tree,\n\tmaintaining a more fine-grained cache.\n\t(ref_indep_loop_p): Wrap ref_indep_loop_p_2.\n\t(tree_ssa_lim_finalize): Free refs_stored_in_loop.\n\nFrom-SVN: r196956", "tree": {"sha": "2091ae548ff730d4307a9666a4cd30fa315ba5d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2091ae548ff730d4307a9666a4cd30fa315ba5d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c00217fc2535186f7fe4536d2fa5581f23182903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c00217fc2535186f7fe4536d2fa5581f23182903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c00217fc2535186f7fe4536d2fa5581f23182903", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c00217fc2535186f7fe4536d2fa5581f23182903/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7ad689673f91f57394ed8d7229b6b0b5f2a189ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ad689673f91f57394ed8d7229b6b0b5f2a189ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ad689673f91f57394ed8d7229b6b0b5f2a189ed"}], "stats": {"total": 195, "additions": 113, "deletions": 82}, "files": [{"sha": "d4ba470527564e4b131eeda7bec104b0486d7173", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00217fc2535186f7fe4536d2fa5581f23182903/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00217fc2535186f7fe4536d2fa5581f23182903/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c00217fc2535186f7fe4536d2fa5581f23182903", "patch": "@@ -1,3 +1,23 @@\n+2013-03-22  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-loop-im.c (memory_references): Add refs_stored_in_loop\n+\tbitmaps.\n+\t(gather_mem_refs_in_loops): Perform store accumulation here.\n+\t(create_vop_ref_mapping_loop): Remove.\n+\t(create_vop_ref_mapping): Likewise.\n+\t(analyze_memory_references): Initialize refs_stored_in_loop.\n+\t(LOOP_DEP_BIT): New define to map to bits in (in)dep_loop\n+\tbitmaps.\n+\t(record_indep_loop): Remove.\n+\t(record_dep_loop): New function.\n+\t(ref_indep_loop_p_1): Adjust to only walk over references\n+\tin the loop, not its subloops.\n+\t(ref_indep_loop_p): Rename to ...\n+\t(ref_indep_loop_p_2): ... this and recurse over the loop tree,\n+\tmaintaining a more fine-grained cache.\n+\t(ref_indep_loop_p): Wrap ref_indep_loop_p_2.\n+\t(tree_ssa_lim_finalize): Free refs_stored_in_loop.\n+\n 2013-03-22  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-loop-im.c (struct mem_ref_locs): Remove."}, {"sha": "488a035b32a25da763f17abaa71a16976f055f54", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 93, "deletions": 82, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00217fc2535186f7fe4536d2fa5581f23182903/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00217fc2535186f7fe4536d2fa5581f23182903/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=c00217fc2535186f7fe4536d2fa5581f23182903", "patch": "@@ -140,6 +140,11 @@ typedef struct mem_ref\n   bitmap dep_ref;\t\t/* The complement of INDEP_REF.  */\n } *mem_ref_p;\n \n+/* We use two bits per loop in the ref->{in,}dep_loop bitmaps, the first\n+   to record (in)dependence against stores in the loop and its subloops, the\n+   second to record (in)dependence against all references in the loop\n+   and its subloops.  */\n+#define LOOP_DEP_BIT(loopnum, storedp) (2 * (loopnum) + (storedp ? 1 : 0))\n \n \n \n@@ -156,12 +161,14 @@ static struct\n   /* The set of memory references accessed in each loop.  */\n   vec<bitmap> refs_in_loop;\n \n+  /* The set of memory references stored in each loop.  */\n+  vec<bitmap> refs_stored_in_loop;\n+\n   /* The set of memory references accessed in each loop, including\n      subloops.  */\n   vec<bitmap> all_refs_in_loop;\n \n-  /* The set of memory references stored in each loop, including\n-     subloops.  */\n+  /* The set of memory references stored in each loop, including subloops .  */\n   vec<bitmap> all_refs_stored_in_loop;\n \n   /* Cache for expanding memory addresses.  */\n@@ -1575,7 +1582,10 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n     }\n   bitmap_set_bit (memory_accesses.refs_in_loop[loop->num], ref->id);\n   if (is_stored)\n-    mark_ref_stored (ref, loop);\n+    {\n+      bitmap_set_bit (memory_accesses.refs_stored_in_loop[loop->num], ref->id);\n+      mark_ref_stored (ref, loop);\n+    }\n   return;\n }\n \n@@ -1602,9 +1612,8 @@ gather_mem_refs_in_loops (void)\n {\n   gimple_stmt_iterator bsi;\n   basic_block bb, *bbs;\n-  struct loop *loop;\n+  struct loop *loop, *outer;\n   loop_iterator li;\n-  bitmap lrefs, alrefs, alrefso;\n   unsigned i, n;\n \n   /* Initialize bb_loop_postorder with a mapping from loop->num to\n@@ -1639,56 +1648,22 @@ gather_mem_refs_in_loops (void)\n      the loop hierarchy.  */\n   FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n-      lrefs = memory_accesses.refs_in_loop[loop->num];\n-      alrefs = memory_accesses.all_refs_in_loop[loop->num];\n-      bitmap_ior_into (alrefs, lrefs);\n-\n-      if (loop_outer (loop) == current_loops->tree_root)\n+      /* Finalize the overall touched references (including subloops).  */\n+      bitmap_ior_into (memory_accesses.all_refs_in_loop[loop->num],\n+\t\t       memory_accesses.refs_in_loop[loop->num]);\n+      bitmap_ior_into (memory_accesses.all_refs_stored_in_loop[loop->num],\n+\t\t       memory_accesses.refs_stored_in_loop[loop->num]);\n+\n+      /* Propagate the information about accessed memory references up\n+\t the loop hierarchy.  */\n+      outer = loop_outer (loop);\n+      if (outer == current_loops->tree_root)\n \tcontinue;\n \n-      alrefso = memory_accesses.all_refs_in_loop[loop_outer (loop)->num];\n-      bitmap_ior_into (alrefso, alrefs);\n-    }\n-}\n-\n-/* Create a mapping from virtual operands to references that touch them\n-   in LOOP.  */\n-\n-static void\n-create_vop_ref_mapping_loop (struct loop *loop)\n-{\n-  bitmap refs = memory_accesses.refs_in_loop[loop->num];\n-  struct loop *sloop;\n-  bitmap_iterator bi;\n-  unsigned i;\n-  mem_ref_p ref;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (refs, 0, i, bi)\n-    {\n-      ref = memory_accesses.refs_list[i];\n-      for (sloop = loop; sloop != current_loops->tree_root;\n-\t   sloop = loop_outer (sloop))\n-\tif (bitmap_bit_p (ref->stored, loop->num))\n-\t  {\n-\t    bitmap refs_stored\n-\t      = memory_accesses.all_refs_stored_in_loop[sloop->num];\n-\t    bitmap_set_bit (refs_stored, ref->id);\n-\t  }\n-    }\n-}\n-\n-/* For each non-clobbered virtual operand and each loop, record the memory\n-   references in this loop that touch the operand.  */\n-\n-static void\n-create_vop_ref_mapping (void)\n-{\n-  loop_iterator li;\n-  struct loop *loop;\n-\n-  FOR_EACH_LOOP (li, loop, 0)\n-    {\n-      create_vop_ref_mapping_loop (loop);\n+      bitmap_ior_into (memory_accesses.all_refs_in_loop[outer->num],\n+\t\t       memory_accesses.all_refs_in_loop[loop->num]);\n+      bitmap_ior_into (memory_accesses.all_refs_stored_in_loop[outer->num],\n+\t\t       memory_accesses.all_refs_stored_in_loop[loop->num]);\n     }\n }\n \n@@ -1707,6 +1682,7 @@ analyze_memory_references (void)\n     (mem_ref_alloc (error_mark_node, 0, UNANALYZABLE_MEM_ID));\n \n   memory_accesses.refs_in_loop.create (number_of_loops ());\n+  memory_accesses.refs_stored_in_loop.create (number_of_loops ());\n   memory_accesses.all_refs_in_loop.create (number_of_loops ());\n   memory_accesses.all_refs_stored_in_loop.create (number_of_loops ());\n \n@@ -1715,6 +1691,8 @@ analyze_memory_references (void)\n       empty = BITMAP_ALLOC (&lim_bitmap_obstack);\n       memory_accesses.refs_in_loop.quick_push (empty);\n       empty = BITMAP_ALLOC (&lim_bitmap_obstack);\n+      memory_accesses.refs_stored_in_loop.quick_push (empty);\n+      empty = BITMAP_ALLOC (&lim_bitmap_obstack);\n       memory_accesses.all_refs_in_loop.quick_push (empty);\n       empty = BITMAP_ALLOC (&lim_bitmap_obstack);\n       memory_accesses.all_refs_stored_in_loop.quick_push (empty);\n@@ -1723,7 +1701,6 @@ analyze_memory_references (void)\n   memory_accesses.ttae_cache = NULL;\n \n   gather_mem_refs_in_loops ();\n-  create_vop_ref_mapping ();\n }\n \n /* Returns true if MEM1 and MEM2 may alias.  TTAE_CACHE is used as a cache in\n@@ -2299,34 +2276,34 @@ refs_independent_p (mem_ref_p ref1, mem_ref_p ref2)\n     }\n }\n \n-/* Records the information whether REF is independent in LOOP (according\n-   to INDEP).  */\n+/* Mark REF dependent on stores or loads (according to STORED_P) in LOOP\n+   and its super-loops.  */\n \n static void\n-record_indep_loop (struct loop *loop, mem_ref_p ref, bool indep)\n+record_dep_loop (struct loop *loop, mem_ref_p ref, bool stored_p)\n {\n-  if (indep)\n-    bitmap_set_bit (ref->indep_loop, loop->num);\n-  else\n-    bitmap_set_bit (ref->dep_loop, loop->num);\n+  /* We can propagate dependent-in-loop bits up the loop\n+     hierarchy to all outer loops.  */\n+  while (loop != current_loops->tree_root\n+\t && bitmap_set_bit (ref->dep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n+    loop = loop_outer (loop);\n }\n \n /* Returns true if REF is independent on all other memory references in\n    LOOP.  */\n \n static bool\n-ref_indep_loop_p_1 (struct loop *loop, mem_ref_p ref)\n+ref_indep_loop_p_1 (struct loop *loop, mem_ref_p ref, bool stored_p)\n {\n   bitmap refs_to_check;\n   unsigned i;\n   bitmap_iterator bi;\n-  bool ret = true, stored = bitmap_bit_p (ref->stored, loop->num);\n   mem_ref_p aref;\n \n-  if (stored)\n-    refs_to_check = memory_accesses.all_refs_in_loop[loop->num];\n+  if (stored_p)\n+    refs_to_check = memory_accesses.refs_in_loop[loop->num];\n   else\n-    refs_to_check = memory_accesses.all_refs_stored_in_loop[loop->num];\n+    refs_to_check = memory_accesses.refs_stored_in_loop[loop->num];\n \n   if (bitmap_bit_p (refs_to_check, UNANALYZABLE_MEM_ID))\n     return false;\n@@ -2335,40 +2312,73 @@ ref_indep_loop_p_1 (struct loop *loop, mem_ref_p ref)\n     {\n       aref = memory_accesses.refs_list[i];\n       if (!refs_independent_p (ref, aref))\n-\t{\n-\t  ret = false;\n-\t  record_indep_loop (loop, aref, false);\n-\t  break;\n-\t}\n+\treturn false;\n     }\n \n-  return ret;\n+  return true;\n }\n \n /* Returns true if REF is independent on all other memory references in\n    LOOP.  Wrapper over ref_indep_loop_p_1, caching its results.  */\n \n static bool\n-ref_indep_loop_p (struct loop *loop, mem_ref_p ref)\n+ref_indep_loop_p_2 (struct loop *loop, mem_ref_p ref, bool stored_p)\n {\n-  bool ret;\n-\n-  gcc_checking_assert (MEM_ANALYZABLE (ref));\n+  stored_p |= bitmap_bit_p (ref->stored, loop->num);\n \n-  if (bitmap_bit_p (ref->indep_loop, loop->num))\n+  if (bitmap_bit_p (ref->indep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n     return true;\n-  if (bitmap_bit_p (ref->dep_loop, loop->num))\n+  if (bitmap_bit_p (ref->dep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n     return false;\n \n-  ret = ref_indep_loop_p_1 (loop, ref);\n+  struct loop *inner = loop->inner;\n+  while (inner)\n+    {\n+      if (!ref_indep_loop_p_2 (inner, ref, stored_p))\n+\treturn false;\n+      inner = inner->next;\n+    }\n+\n+  bool indep_p = ref_indep_loop_p_1 (loop, ref, stored_p);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Querying dependencies of ref %u in loop %d: %s\\n\",\n-\t     ref->id, loop->num, ret ? \"independent\" : \"dependent\");\n+\t     ref->id, loop->num, indep_p ? \"independent\" : \"dependent\");\n \n-  record_indep_loop (loop, ref, ret);\n+  /* Record the computed result in the cache.  */\n+  if (indep_p)\n+    {\n+      if (bitmap_set_bit (ref->indep_loop, LOOP_DEP_BIT (loop->num, stored_p))\n+\t  && stored_p)\n+\t{\n+\t  /* If it's independend against all refs then it's independent\n+\t     against stores, too.  */\n+\t  bitmap_set_bit (ref->indep_loop, LOOP_DEP_BIT (loop->num, false));\n+\t}\n+    }\n+  else\n+    {\n+      record_dep_loop (loop, ref, stored_p);\n+      if (!stored_p)\n+\t{\n+\t  /* If it's dependent against stores it's dependent against\n+\t     all refs, too.  */\n+\t  record_dep_loop (loop, ref, true);\n+\t}\n+    }\n \n-  return ret;\n+  return indep_p;\n+}\n+\n+/* Returns true if REF is independent on all other memory references in\n+   LOOP.  */\n+\n+static bool\n+ref_indep_loop_p (struct loop *loop, mem_ref_p ref)\n+{\n+  gcc_checking_assert (MEM_ANALYZABLE (ref));\n+\n+  return ref_indep_loop_p_2 (loop, ref, false);\n }\n \n /* Returns true if we can perform store motion of REF from LOOP.  */\n@@ -2619,6 +2629,7 @@ tree_ssa_lim_finalize (void)\n   memory_accesses.refs_list.release ();\n \n   memory_accesses.refs_in_loop.release ();\n+  memory_accesses.refs_stored_in_loop.release ();\n   memory_accesses.all_refs_in_loop.release ();\n   memory_accesses.all_refs_stored_in_loop.release ();\n "}]}